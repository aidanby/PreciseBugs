{"buggy_code": ["<?php\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Core;\n\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Core\\Utility\\PathUtility;\n\n/**\n * Class to encapsulate base setup of bootstrap.\n *\n * This class contains all code that must be executed by every entry script.\n *\n * It sets up all basic paths, constants, global variables and checks\n * the basic environment TYPO3 runs in.\n *\n * This class does not use any TYPO3 instance specific configuration, it only\n * sets up things based on the server environment and core code. Even with a\n * missing system/settings.php this script will be successful.\n *\n * The script aborts execution with an error message if\n * some part fails or conditions are not met.\n *\n * This script is internal code and subject to change.\n * DO NOT use it in own code, or be prepared your code might\n * break in future versions of the core.\n */\nclass SystemEnvironmentBuilder\n{\n    /** @internal */\n    public const REQUESTTYPE_FE = 1;\n    /** @internal */\n    public const REQUESTTYPE_BE = 2;\n    /** @internal */\n    public const REQUESTTYPE_CLI = 4;\n    /** @internal */\n    public const REQUESTTYPE_AJAX = 8;\n    /** @internal */\n    public const REQUESTTYPE_INSTALL = 16;\n\n    /**\n     * Run base setup.\n     * This entry method is used in all scopes (FE, BE, Install Tool and CLI)\n     *\n     * @internal This method should not be used by 3rd party code. It will change without further notice.\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     */\n    public static function run(int $entryPointLevel = 0, int $requestType = self::REQUESTTYPE_FE)\n    {\n        self::defineBaseConstants();\n        $scriptPath = self::calculateScriptPath($entryPointLevel, $requestType);\n        $rootPath = self::calculateRootPath($entryPointLevel, $requestType);\n\n        self::initializeGlobalVariables();\n        self::initializeGlobalTimeTrackingVariables();\n        self::initializeEnvironment($requestType, $scriptPath, $rootPath);\n    }\n\n    /**\n     * Some notes:\n     *\n     * HTTP_TYPO3_CONTEXT -> used with Apache suexec support\n     * REDIRECT_TYPO3_CONTEXT -> used under some circumstances when value is set in the webserver and proxying the values to FPM\n     * @throws \\TYPO3\\CMS\\Core\\Exception\n     */\n    protected static function createApplicationContext(): ApplicationContext\n    {\n        $applicationContext = getenv('TYPO3_CONTEXT') ?: (getenv('REDIRECT_TYPO3_CONTEXT') ?: (getenv('HTTP_TYPO3_CONTEXT') ?: 'Production'));\n        return new ApplicationContext($applicationContext);\n    }\n\n    /**\n     * Define all simple constants that have no dependency to local configuration\n     */\n    protected static function defineBaseConstants()\n    {\n        // A linefeed, a carriage return, a CR-LF combination\n        defined('LF') ?: define('LF', chr(10));\n        defined('CR') ?: define('CR', chr(13));\n        defined('CRLF') ?: define('CRLF', CR . LF);\n\n        // A generic constant to state we are in TYPO3 scope. This is especially used in script files\n        // like ext_localconf.php that run in global scope without class encapsulation: \"defined('TYPO3') or die();\"\n        // This is a security measure to prevent script output if those files are located within document root and\n        // called directly without bootstrap and error handling setup.\n        defined('TYPO3') ?: define('TYPO3', true);\n\n        // Relative path from document root to typo3/ directory, hardcoded to \"typo3/\"\n        // @deprecated: will be removed in TYPO3 v13.0\n        if (!defined('TYPO3_mainDir')) {\n            define('TYPO3_mainDir', 'typo3/');\n        }\n    }\n\n    /**\n     * Calculate script path. This is the absolute path to the entry script.\n     * Can be something like '.../public/index.php' or '.../public/typo3/index.php' for\n     * web calls, or '.../bin/typo3' or similar for cli calls.\n     *\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     * @return string Absolute path to entry script\n     */\n    protected static function calculateScriptPath(int $entryPointLevel, int $requestType): string\n    {\n        $isCli = self::isCliRequestType($requestType);\n        // Absolute path of the entry script that was called\n        $scriptPath = GeneralUtility::fixWindowsFilePath(self::getPathThisScript($isCli));\n        $rootPath = self::getRootPathFromScriptPath($scriptPath, $entryPointLevel);\n        // Check if the root path has been set in the environment (e.g. by the composer installer)\n        if (getenv('TYPO3_PATH_ROOT')) {\n            if ($isCli && self::usesComposerClassLoading()) {\n                // $scriptPath is used for various path calculations based on the document root\n                // Therefore we assume it is always a subdirectory of the document root, which is not the case\n                // in composer mode on cli, as the binary is in the composer bin directory.\n                // Because of that, we enforce the document root path of this binary to be set\n                $scriptName = 'typo3/sysext/core/bin/typo3';\n            } else {\n                // Base the script path on the path taken from the environment\n                // to make relative path calculations work in case only one of both is symlinked\n                // or has the real path\n                $scriptName = ltrim(substr($scriptPath, strlen($rootPath)), '/');\n            }\n            $rootPath = rtrim(GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_ROOT')), '/');\n            $scriptPath = $rootPath . '/' . $scriptName;\n        }\n        return $scriptPath;\n    }\n\n    /**\n     * Absolute path to the \"classic\" site root of the TYPO3 application.\n     * This semantically refers to the directory where executable server-side code, configuration\n     * and runtime files are located (e.g. typo3conf/ext, typo3/sysext, typo3temp/var).\n     * In practice this is always identical to the public web document root path which contains\n     * files that are served by the webserver directly (fileadmin/ and public resources).\n     *\n     * This is not to be confused with the app-path that is used in composer-mode installations (by default).\n     * Resources in app-path are located outside the document root.\n     *\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     * @param int $requestType\n     * @return string Absolute path without trailing slash\n     */\n    protected static function calculateRootPath(int $entryPointLevel, int $requestType): string\n    {\n        // Check if the root path has been set in the environment (e.g. by the composer installer)\n        if (getenv('TYPO3_PATH_ROOT')) {\n            return rtrim(GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_ROOT')), '/');\n        }\n        $isCli = self::isCliRequestType($requestType);\n        // Absolute path of the entry script that was called\n        $scriptPath = GeneralUtility::fixWindowsFilePath(self::getPathThisScript($isCli));\n        return self::getRootPathFromScriptPath($scriptPath, $entryPointLevel);\n    }\n\n    /**\n     * Set up / initialize several globals variables\n     */\n    protected static function initializeGlobalVariables()\n    {\n        // Unset variable(s) in global scope (security issue #13959)\n        $GLOBALS['T3_SERVICES'] = [];\n    }\n\n    /**\n     * Initialize global time tracking variables.\n     * These are helpers to for example output script parsetime at the end of a script.\n     */\n    protected static function initializeGlobalTimeTrackingVariables()\n    {\n        // EXEC_TIME is set so that the rest of the script has a common value for the script execution time\n        $GLOBALS['EXEC_TIME'] = time();\n        // $ACCESS_TIME is a common time in minutes for access control\n        $GLOBALS['ACCESS_TIME'] = $GLOBALS['EXEC_TIME'] - $GLOBALS['EXEC_TIME'] % 60;\n        // $SIM_EXEC_TIME is set to $EXEC_TIME but can be altered later in the script if we want to\n        // simulate another execution-time when selecting from eg. a database\n        $GLOBALS['SIM_EXEC_TIME'] = $GLOBALS['EXEC_TIME'];\n        // If $SIM_EXEC_TIME is changed this value must be set accordingly\n        $GLOBALS['SIM_ACCESS_TIME'] = $GLOBALS['ACCESS_TIME'];\n    }\n\n    /**\n     * Initialize the Environment class\n     */\n    protected static function initializeEnvironment(int $requestType, string $scriptPath, string $sitePath)\n    {\n        if (getenv('TYPO3_PATH_ROOT')) {\n            $rootPathFromEnvironment = rtrim(GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_ROOT')), '/');\n            if ($sitePath !== $rootPathFromEnvironment) {\n                // This means, that we re-initialized the environment during a single request\n                // This currently only happens in custom code or during functional testing\n                // Once the constants are removed, we might be able to remove this code here as well and directly pass an environment to the application\n                $scriptPath = $rootPathFromEnvironment . substr($scriptPath, strlen($sitePath));\n                $sitePath = $rootPathFromEnvironment;\n            }\n        }\n\n        $projectRootPath = GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_APP'));\n        $isDifferentRootPath = ($projectRootPath && $projectRootPath !== $sitePath);\n        Environment::initialize(\n            static::createApplicationContext(),\n            self::isCliRequestType($requestType),\n            static::usesComposerClassLoading(),\n            $isDifferentRootPath ? $projectRootPath : $sitePath,\n            $sitePath,\n            $isDifferentRootPath ? $projectRootPath . '/var' : $sitePath . '/typo3temp/var',\n            $isDifferentRootPath ? $projectRootPath . '/config' : $sitePath . '/typo3conf',\n            $scriptPath,\n            self::isRunningOnWindows() ? 'WINDOWS' : 'UNIX'\n        );\n    }\n\n    /**\n     * Determine if the operating system TYPO3 is running on is windows.\n     */\n    protected static function isRunningOnWindows(): bool\n    {\n        return stripos(PHP_OS, 'darwin') === false\n            && stripos(PHP_OS, 'cygwin') === false\n            && stripos(PHP_OS, 'win') !== false;\n    }\n\n    /**\n     * Calculate script path.\n     *\n     * First step in path calculation: Goal is to find the absolute path of the entry script\n     * that was called without resolving any links. This is important since the TYPO3 entry\n     * points are often linked to a central core location, so we can not use the php magic\n     * __FILE__ here, but resolve the called script path from given server environments.\n     *\n     * This path is important to calculate the document root. The strategy is to\n     * find out the script name that was called in the first place and to subtract the local\n     * part from it to find the document root.\n     *\n     * @param bool $isCli\n     * @return string Absolute path to entry script\n     */\n    protected static function getPathThisScript(bool $isCli)\n    {\n        if ($isCli) {\n            return self::getPathThisScriptCli();\n        }\n        return self::getPathThisScriptNonCli();\n    }\n\n    /**\n     * Calculate path to entry script if not in cli mode.\n     *\n     * Depending on the environment, the script path is found in different $_SERVER variables.\n     *\n     * @return string Absolute path to entry script\n     */\n    protected static function getPathThisScriptNonCli()\n    {\n        $isCgi = Environment::isRunningOnCgiServer();\n        if ($isCgi && Environment::usesCgiFixPathInfo()) {\n            return $_SERVER['SCRIPT_FILENAME'];\n        }\n        $cgiPath = $_SERVER['ORIG_PATH_TRANSLATED'] ?? $_SERVER['PATH_TRANSLATED'] ?? '';\n        if ($cgiPath && $isCgi) {\n            return $cgiPath;\n        }\n        return $_SERVER['ORIG_SCRIPT_FILENAME'] ?? $_SERVER['SCRIPT_FILENAME'];\n    }\n\n    /**\n     * Calculate path to entry script if in cli mode.\n     *\n     * First argument of a cli script is the path to the script that was called. If the script does not start\n     * with / (or A:\\ for Windows), the path is not absolute yet, and the current working directory is added.\n     *\n     * @return string Absolute path to entry script\n     */\n    protected static function getPathThisScriptCli()\n    {\n        // Possible relative path of the called script\n        $scriptPath = $_SERVER['argv'][0] ?? $_ENV['_'] ?? $_SERVER['_'];\n        // Find out if path is relative or not\n        $isRelativePath = false;\n        if (self::isRunningOnWindows()) {\n            if (!preg_match('/^([a-zA-Z]:)?\\\\\\\\/', $scriptPath)) {\n                $isRelativePath = true;\n            }\n        } elseif ($scriptPath[0] !== '/') {\n            $isRelativePath = true;\n        }\n        // Concatenate path to current working directory with relative path and remove \"/./\" constructs\n        if ($isRelativePath) {\n            $workingDirectory = $_SERVER['PWD'] ?? getcwd();\n            $scriptPath = $workingDirectory . '/' . preg_replace('/\\\\.\\\\//', '', $scriptPath);\n        }\n        return $scriptPath;\n    }\n\n    /**\n     * Calculate the document root part to the instance from $scriptPath.\n     * This is based on the amount of subdirectories \"under\" root path where $scriptPath is located.\n     *\n     * The following main scenarios for entry points exist by default in the TYPO3 core:\n     * - Directly called documentRoot/index.php (-> FE call or eiD include): index.php is located in the same directory\n     * as the main project. The document root is identical to the directory the script is located at.\n     * - The install tool, located under typo3/install.php.\n     * - A Backend script: This is the case for the typo3/index.php dispatcher and other entry scripts like 'typo3/sysext/core/bin/typo3'\n     * or 'typo3/index.php' that are located inside typo3/ directly.\n     *\n     * @param string $scriptPath Calculated path to the entry script\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     * @return string Absolute path to document root of installation without trailing slash\n     */\n    protected static function getRootPathFromScriptPath($scriptPath, $entryPointLevel)\n    {\n        $entryScriptDirectory = PathUtility::dirnameDuringBootstrap($scriptPath);\n        if ($entryPointLevel > 0) {\n            [$rootPath] = GeneralUtility::revExplode('/', $entryScriptDirectory, $entryPointLevel + 1);\n        } else {\n            $rootPath = $entryScriptDirectory;\n        }\n        return $rootPath;\n    }\n\n    protected static function usesComposerClassLoading(): bool\n    {\n        return defined('TYPO3_COMPOSER_MODE') && TYPO3_COMPOSER_MODE;\n    }\n\n    /**\n     * Checks if request type is cli.\n     * Falls back to check PHP_SAPI in case request type is not provided\n     */\n    protected static function isCliRequestType(?int $requestType): bool\n    {\n        if ($requestType === null) {\n            $requestType = PHP_SAPI === 'cli' ? self::REQUESTTYPE_CLI : self::REQUESTTYPE_FE;\n        }\n\n        return ($requestType & self::REQUESTTYPE_CLI) === self::REQUESTTYPE_CLI;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Http;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\n\n/**\n * This class provides normalized server parameters in HTTP request context.\n * It normalizes reverse proxy scenarios and various other web server specific differences\n * of the native PSR-7 request object parameters (->getServerParams() / $GLOBALS['_SERVER']).\n *\n * An instance of this class is available as PSR-7 ServerRequestInterface attribute:\n *\n * ```\n * $normalizedParams = $request->getAttribute('normalizedParams')\n * ```\n *\n * This class substitutes the old GeneralUtility::getIndpEnv() method.\n */\nclass NormalizedParams\n{\n    /**\n     * Sanitized HTTP_HOST value\n     *\n     * host[:port]\n     *\n     * - www.domain.com\n     * - www.domain.com:443\n     * - 192.168.1.42:80\n     *\n     * @var string\n     */\n    protected $httpHost = '';\n\n    /**\n     * @var bool True if request has been done via HTTPS\n     */\n    protected $isHttps = false;\n\n    /**\n     * Sanitized HTTP_HOST with protocol\n     *\n     * scheme://host[:port]\n     *\n     * - https://www.domain.com\n     *\n     * @var string\n     */\n    protected $requestHost = '';\n\n    /**\n     * Host / domain part of HTTP_HOST, no port, no protocol\n     *\n     * - www.domain.com\n     * - 192.168.1.42\n     *\n     * @var string\n     */\n    protected $requestHostOnly = '';\n\n    /**\n     * Port of HTTP_HOST if given\n     *\n     * @var int\n     */\n    protected $requestPort = 0;\n\n    /**\n     * Entry script path of URI, without domain and without query parameters, with leading /\n     *\n     * [path_script]\n     *\n     * - /index.php\n     * - /typo3/index.php\n     *\n     * @var string\n     */\n    protected $scriptName = '';\n\n    /**\n     * REQUEST URI without domain and scheme, with trailing slash\n     *\n     * [path][?[query]]\n     *\n     * - /some/path?p1=parameter1&p2[key]=value\n     * - /typo3/some/path?p1=parameter1&p2[key]=value\n     *\n     * @var string\n     */\n    protected $requestUri = '';\n\n    /**\n     * REQUEST URI with scheme, host, port, path and query\n     *\n     * scheme://host[:[port]][path][?[query]]\n     *\n     * - http://www.domain.com/some/path?p1=parameter1&p2[key]=value\n     * - http://www.domain.com/typo3/some/path?id=42\n     *\n     * @var string\n     */\n    protected $requestUrl = '';\n\n    /**\n     * REQUEST URI with scheme, host, port and path, but *without* query part\n     *\n     * scheme://host[:[port]][path_script]\n     *\n     * - http://www.domain.com/index.php\n     * - http://www.domain.com/typo3/index.php\n     *\n     * @var string\n     */\n    protected $requestScript = '';\n\n    /**\n     * Full Uri with path, but without script name and query parts\n     *\n     * scheme://host[:[port]][path_dir]\n     *\n     * - http://www.domain.com/\n     * - http://www.domain.com/typo3/\n     *\n     * @var string\n     */\n    protected $requestDir = '';\n\n    /**\n     * True if request via a reverse proxy is detected\n     *\n     * @var bool\n     */\n    protected $isBehindReverseProxy = false;\n\n    /**\n     * IPv4 or IPv6 address of remote client with resolved proxy setup\n     *\n     * @var string\n     */\n    protected $remoteAddress = '';\n\n    /**\n     * Absolute server path to entry script on server filesystem\n     *\n     * - /var/www/index.php\n     * - /var/www/typo3/index.php\n     *\n     * @var string\n     */\n    protected $scriptFilename = '';\n\n    /**\n     * Absolute server path to web document root without trailing slash\n     *\n     * - /var/www\n     *\n     * @var string\n     */\n    protected $documentRoot = '';\n\n    /**\n     * Website frontend URL.\n     * Note this is note \"safe\" if called from Backend since sys_domain and\n     * other factors are not taken into account.\n     *\n     * scheme://host[:[port]]/[path_dir]\n     *\n     * - https://www.domain.com/\n     * - https://www.domain.com/some/sub/dir/\n     *\n     * @var string\n     */\n    protected $siteUrl = '';\n\n    /**\n     * Path part to frontend, no domain, no protocol\n     *\n     * - /\n     * - /some/sub/dir/\n     *\n     * @var string\n     */\n    protected $sitePath = '';\n\n    /**\n     * Path to script, without sub path if TYPO3 is running in sub directory, without trailing slash\n     *\n     * - index.php?id=42\n     * - /some/path?id=42\n     * - typo3/some/path?id=411\n     *\n     * @var string\n     */\n    protected $siteScript = '';\n\n    /**\n     * Entry script path of URI, without domain and without query parameters, with leading /\n     * This is often not set at all.\n     * Will be deprecated later, use $scriptName instead as more reliable solution.\n     *\n     * [path_script]\n     *\n     * @var string\n     */\n    protected $pathInfo = '';\n\n    /**\n     * HTTP_REFERER\n     * Will be deprecated later, use $request->getServerParams()['HTTP_REFERER'] instead\n     *\n     * scheme://host[:[port]][path]\n     *\n     * - https://www.domain.com/typo3/module/web/layout?id=42\n     *\n     * @var string\n     */\n    protected $httpReferer = '';\n\n    /**\n     * HTTP_USER_AGENT\n     * Will be deprecated later, use $request->getServerParams()['HTTP_USER_AGENT'] instead\n     *\n     * - Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36\n     *\n     * @var string\n     */\n    protected $httpUserAgent = '';\n\n    /**\n     * HTTP_ACCEPT_ENCODING\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_ENCODING'] instead\n     *\n     * - gzip, deflate\n     *\n     * @var string\n     */\n    protected $httpAcceptEncoding = '';\n\n    /**\n     * HTTP_ACCEPT_LANGUAGE\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] instead\n     *\n     * - de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7\n     *\n     * @var string\n     */\n    protected $httpAcceptLanguage = '';\n\n    /**\n     * REMOTE_HOST Resolved host name of REMOTE_ADDR if configured in web server\n     * Will be deprecated later, use $request->getServerParams()['REMOTE_HOST'] instead\n     *\n     * - www.clientDomain.com\n     *\n     * @var string\n     */\n    protected $remoteHost = '';\n\n    /**\n     * QUERY_STRING\n     * Will be deprecated later, use $request->getServerParams()['QUERY_STRING'] instead\n     *\n     * [query]\n     *\n     * - id=42&foo=bar\n     *\n     * @var string\n     */\n    protected $queryString = '';\n\n    /**\n     * Constructor calculates all values by incoming variables.\n     *\n     * This object is immutable.\n     *\n     * All determine*() \"detail worker methods\" in this class retrieve their dependencies\n     * to other properties as method arguments, they are static, stateless and have no\n     * dependency to $this. This ensures the chain of inter-property dependencies\n     * is visible by only looking at the construct() method.\n     *\n     * @param array $serverParams , usually coming from $_SERVER or $request->getServerParams()\n     * @param array $configuration $GLOBALS['TYPO3_CONF_VARS']['SYS']\n     * @param string $pathThisScript Absolute server entry script path, usually found within Environment::getCurrentScript()\n     * @param string $pathSite Absolute server path to document root, Environment::getPublicPath()\n     */\n    public function __construct(array $serverParams, array $configuration, string $pathThisScript, string $pathSite)\n    {\n        $isBehindReverseProxy = $this->isBehindReverseProxy = self::determineIsBehindReverseProxy(\n            $serverParams,\n            $configuration\n        );\n        $httpHost = $this->httpHost = self::determineHttpHost($serverParams, $configuration, $isBehindReverseProxy);\n        $isHttps = $this->isHttps = self::determineHttps($serverParams, $configuration);\n        $requestHost = $this->requestHost = ($isHttps ? 'https://' : 'http://') . $httpHost;\n        $requestHostOnly = $this->requestHostOnly = self::determineRequestHostOnly($httpHost);\n        $this->requestPort = self::determineRequestPort($httpHost, $requestHostOnly);\n        $scriptName = $this->scriptName = self::determineScriptName(\n            $serverParams,\n            $configuration,\n            $isHttps,\n            $isBehindReverseProxy\n        );\n        $requestUri = $this->requestUri = self::determineRequestUri(\n            $serverParams,\n            $configuration,\n            $isHttps,\n            $scriptName,\n            $isBehindReverseProxy\n        );\n        $requestUrl = $this->requestUrl = $requestHost . $requestUri;\n        $this->requestScript = $requestHost . $scriptName;\n        $requestDir = $this->requestDir = $requestHost . GeneralUtility::dirname($scriptName) . '/';\n        $this->remoteAddress = self::determineRemoteAddress($serverParams, $configuration, $isBehindReverseProxy);\n        $scriptFilename = $this->scriptFilename = $pathThisScript;\n        $this->documentRoot = self::determineDocumentRoot($scriptName, $scriptFilename);\n        $siteUrl = $this->siteUrl = self::determineSiteUrl($requestDir, $pathThisScript, $pathSite . '/');\n        $this->sitePath = self::determineSitePath($requestHost, $siteUrl);\n        $this->siteScript = self::determineSiteScript($requestUrl, $siteUrl);\n\n        // @deprecated Below variables can be fully deprecated as soon as core does not use them anymore\n        $this->pathInfo = $serverParams['PATH_INFO'] ?? '';\n        $this->httpReferer = $serverParams['HTTP_REFERER'] ?? '';\n        $this->httpUserAgent = $serverParams['HTTP_USER_AGENT'] ?? '';\n        $this->httpAcceptEncoding = $serverParams['HTTP_ACCEPT_ENCODING'] ?? '';\n        $this->httpAcceptLanguage = $serverParams['HTTP_ACCEPT_LANGUAGE'] ?? '';\n        $this->remoteHost = $serverParams['REMOTE_HOST'] ?? '';\n        $this->queryString = $serverParams['QUERY_STRING'] ?? '';\n    }\n\n    /**\n     * @return string Sanitized HTTP_HOST value host[:port]\n     */\n    public function getHttpHost(): string\n    {\n        return $this->httpHost;\n    }\n\n    /**\n     * @return bool True if client request has been done using HTTPS\n     */\n    public function isHttps(): bool\n    {\n        return $this->isHttps;\n    }\n\n    /**\n     * @return string Sanitized HTTP_HOST with protocol scheme://host[:port], eg. https://www.domain.com/\n     */\n    public function getRequestHost(): string\n    {\n        return $this->requestHost;\n    }\n\n    /**\n     * @return string Host / domain /IP only, eg. www.domain.com\n     */\n    public function getRequestHostOnly(): string\n    {\n        return $this->requestHostOnly;\n    }\n\n    /**\n     * @return int Requested port if given, eg. 8080 - often not explicitly given, then 0\n     */\n    public function getRequestPort(): int\n    {\n        return $this->requestPort;\n    }\n\n    /**\n     * @return string Script path part of URI, eg. '/typo3/index.php'\n     */\n    public function getScriptName(): string\n    {\n        return $this->scriptName;\n    }\n\n    /**\n     * @return string Request Uri without domain and protocol, eg. /index.php?id=42\n     */\n    public function getRequestUri(): string\n    {\n        return $this->requestUri;\n    }\n\n    /**\n     * @return string Full REQUEST_URI, eg. http://www.domain.com/typo3/foo/bar?id=42\n     */\n    public function getRequestUrl(): string\n    {\n        return $this->requestUrl;\n    }\n\n    /**\n     * @return string REQUEST URI without query part, eg. http://www.domain.com/typo3/index.php\n     */\n    public function getRequestScript(): string\n    {\n        return $this->requestScript;\n    }\n\n    /**\n     * @return string REQUEST URI without script file name and query parts, eg. http://www.domain.com/typo3/\n     */\n    public function getRequestDir(): string\n    {\n        return $this->requestDir;\n    }\n\n    /**\n     * @return bool True if request comes from a configured reverse proxy\n     */\n    public function isBehindReverseProxy(): bool\n    {\n        return $this->isBehindReverseProxy;\n    }\n\n    /**\n     * @return string Client IP\n     */\n    public function getRemoteAddress(): string\n    {\n        return $this->remoteAddress;\n    }\n\n    /**\n     * @return string Absolute entry script path on server, eg. /var/www/typo3/index.php\n     */\n    public function getScriptFilename(): string\n    {\n        return $this->scriptFilename;\n    }\n\n    /**\n     * @return string Absolute path to web document root, eg. /var/www/typo3\n     */\n    public function getDocumentRoot(): string\n    {\n        return $this->documentRoot;\n    }\n\n    /**\n     * @return string Website frontend url, eg. https://www.domain.com/some/sub/dir/\n     */\n    public function getSiteUrl(): string\n    {\n        return $this->siteUrl;\n    }\n\n    /**\n     * @return string Path part to frontend, eg. /some/sub/dir/\n     */\n    public function getSitePath(): string\n    {\n        return $this->sitePath;\n    }\n\n    /**\n     * @return string Path part to entry script with parameters, without sub dir, eg 'typo3/index.php?id=42'\n     */\n    public function getSiteScript(): string\n    {\n        return $this->siteScript;\n    }\n\n    /**\n     * Will be deprecated later, use getScriptName() as reliable solution instead\n     *\n     * @return string Script path part of URI, eg. 'typo3/index.php'\n     */\n    public function getPathInfo(): string\n    {\n        return $this->pathInfo;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_REFERER'] instead\n     *\n     * @return string HTTP_REFERER, eg. 'https://www.domain.com/typo3/index.php?id=42'\n     */\n    public function getHttpReferer(): string\n    {\n        return $this->httpReferer;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_USER_AGENT'] instead\n     *\n     * @return string HTTP_USER_AGENT identifier\n     */\n    public function getHttpUserAgent(): string\n    {\n        return $this->httpUserAgent;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_ENCODING'] instead\n     *\n     * @return string HTTP_ACCEPT_ENCODING, eg. 'gzip, deflate'\n     */\n    public function getHttpAcceptEncoding(): string\n    {\n        return $this->httpAcceptEncoding;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] instead\n     *\n     * @return string HTTP_ACCEPT_LANGUAGE, eg. 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7'\n     */\n    public function getHttpAcceptLanguage(): string\n    {\n        return $this->httpAcceptLanguage;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['REMOTE_HOST'] instead\n     *\n     * @return string REMOTE_HOST if configured in web server, eg. 'www.clientDomain.com'\n     */\n    public function getRemoteHost(): string\n    {\n        return $this->remoteHost;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['QUERY_STRING'] instead\n     *\n     * @return string QUERY_STRING, eg 'id=42&foo=bar'\n     */\n    public function getQueryString(): string\n    {\n        return $this->queryString;\n    }\n\n    /**\n     * Normalize HTTP_HOST by taking proxy configuration into account.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS['SYS'] array\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Normalized HTTP_HOST\n     */\n    protected static function determineHttpHost(\n        array $serverParams,\n        array $configuration,\n        bool $isBehindReverseProxy\n    ): string {\n        $httpHost = $serverParams['HTTP_HOST'] ?? '';\n        if ($isBehindReverseProxy) {\n            // If the request comes from a configured proxy which has set HTTP_X_FORWARDED_HOST, then\n            // evaluate reverseProxyHeaderMultiValue and\n            $xForwardedHostArray = GeneralUtility::trimExplode(',', $serverParams['HTTP_X_FORWARDED_HOST'] ?? '', true);\n            $xForwardedHost = '';\n            // Choose which host in list to use\n            if (!empty($xForwardedHostArray)) {\n                $configuredReverseProxyHeaderMultiValue = trim($configuration['reverseProxyHeaderMultiValue'] ?? '');\n                // Default if reverseProxyHeaderMultiValue is not set or set to 'none', instead of 'first' / 'last' is to\n                // ignore $serverParams['HTTP_X_FORWARDED_HOST']\n                // @todo: Maybe this default is stupid: Both SYS/reverseProxyIP hand SYS/reverseProxyHeaderMultiValue have to\n                // @todo: be configured for a working setup. It would be easier to only configure SYS/reverseProxyIP and fall\n                // @todo: back to \"first\" if SYS/reverseProxyHeaderMultiValue is not set.\n                if ($configuredReverseProxyHeaderMultiValue === 'last') {\n                    $xForwardedHost = array_pop($xForwardedHostArray);\n                } elseif ($configuredReverseProxyHeaderMultiValue === 'first') {\n                    $xForwardedHost = array_shift($xForwardedHostArray);\n                }\n            }\n            if ($xForwardedHost) {\n                $httpHost = $xForwardedHost;\n            }\n        }\n        return $httpHost;\n    }\n\n    /**\n     * Determine if the client called via HTTPS. Takes proxy ssl terminator\n     * configurations into account.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS['SYS'] array\n     * @return bool True if request has been done via HTTPS\n     */\n    protected static function determineHttps(array $serverParams, array $configuration): bool\n    {\n        $isHttps = false;\n        $configuredProxySSL = trim($configuration['reverseProxySSL'] ?? '');\n        if ($configuredProxySSL === '*') {\n            $configuredProxySSL = trim($configuration['reverseProxyIP'] ?? '');\n        }\n        $httpsParam = (string)($serverParams['HTTPS'] ?? '');\n        if (GeneralUtility::cmpIP(trim($serverParams['REMOTE_ADDR'] ?? ''), $configuredProxySSL)\n            || ($serverParams['SSL_SESSION_ID'] ?? '')\n            // https://secure.php.net/manual/en/reserved.variables.server.php\n            // \"Set to a non-empty value if the script was queried through the HTTPS protocol.\"\n            || ($httpsParam !== '' && $httpsParam !== 'off' && $httpsParam !== '0')\n        ) {\n            $isHttps = true;\n        }\n        return $isHttps;\n    }\n\n    /**\n     * Determine script name and path\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration TYPO3_CONF_VARS['SYS'] array\n     * @param bool $isHttps True if used protocol is HTTPS\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Sanitized script name\n     */\n    protected static function determineScriptName(\n        array $serverParams,\n        array $configuration,\n        bool $isHttps,\n        bool $isBehindReverseProxy\n    ): string {\n        // see https://forge.typo3.org/issues/89312\n        // When using a CGI wrapper to dispatch the PHP process `ORIG_SCRIPT_NAME`\n        // contains the name of the wrapper script (which is most probably outside\n        // the TYPO3's project root) and leads to invalid prefixes, e.g. resolving\n        // the `siteUrl` incorrectly as `http://ip10.local/fcgi/` instead of\n        // actual `http://ip10.local/`\n        $possiblePathInfo = ($serverParams['ORIG_PATH_INFO'] ?? '') ?: ($serverParams['PATH_INFO'] ?? '');\n        $possibleScriptName = ($serverParams['ORIG_SCRIPT_NAME'] ?? '') ?: ($serverParams['SCRIPT_NAME'] ?? '');\n        $scriptName = Environment::isRunningOnCgiServer() && $possiblePathInfo\n            ? $possiblePathInfo\n            : $possibleScriptName;\n        if ($isBehindReverseProxy) {\n            // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n            if ($isHttps && !empty($configuration['reverseProxyPrefixSSL'])) {\n                $scriptName = $configuration['reverseProxyPrefixSSL'] . $scriptName;\n            } elseif (!empty($configuration['reverseProxyPrefix'])) {\n                $scriptName = $configuration['reverseProxyPrefix'] . $scriptName;\n            }\n        }\n        return $scriptName;\n    }\n\n    /**\n     * Determine REQUEST_URI, taking proxy configuration and various web server\n     * specifics into account.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS['SYS'] array\n     * @param bool $isHttps True if used protocol is HTTPS\n     * @param string $scriptName Script name\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Sanitized REQUEST_URI\n     */\n    protected static function determineRequestUri(\n        array $serverParams,\n        array $configuration,\n        bool $isHttps,\n        string $scriptName,\n        bool $isBehindReverseProxy\n    ): string {\n        $proxyPrefixApplied = false;\n        if (!empty($configuration['requestURIvar'])) {\n            // This is for URL rewriter that store the original URI in a server\n            // variable (e.g. ISAPI Rewriter for IIS: HTTP_X_REWRITE_URL), a config then looks like:\n            // requestURIvar = '_SERVER|HTTP_X_REWRITE_URL' which will access $GLOBALS['_SERVER']['HTTP_X_REWRITE_URL']\n            [$firstLevel, $secondLevel] = GeneralUtility::trimExplode('|', $configuration['requestURIvar'], true);\n            $requestUri = $GLOBALS[$firstLevel][$secondLevel];\n        } elseif (empty($serverParams['REQUEST_URI'])) {\n            // This is for ISS/CGI which does not have the REQUEST_URI available.\n            $queryString = !empty($serverParams['QUERY_STRING']) ? '?' . $serverParams['QUERY_STRING'] : '';\n            // script name already had the proxy prefix handling, we must not add it a second time\n            $proxyPrefixApplied = true;\n            $requestUri = '/' . ltrim($scriptName, '/') . $queryString;\n        } else {\n            $requestUri = '/' . ltrim($serverParams['REQUEST_URI'], '/');\n        }\n        if (!$proxyPrefixApplied && $isBehindReverseProxy) {\n            // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n            if ($isHttps && !empty($configuration['reverseProxyPrefixSSL'])) {\n                $requestUri = $configuration['reverseProxyPrefixSSL'] . $requestUri;\n            } elseif (!empty($configuration['reverseProxyPrefix'])) {\n                $requestUri = $configuration['reverseProxyPrefix'] . $requestUri;\n            }\n        }\n        return $requestUri;\n    }\n\n    /**\n     * Determine clients REMOTE_ADDR, even if there is a reverse proxy in between.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS[SYS] array\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Resolved REMOTE_ADDR\n     */\n    protected static function determineRemoteAddress(\n        array $serverParams,\n        array $configuration,\n        bool $isBehindReverseProxy\n    ): string {\n        $remoteAddress = trim($serverParams['REMOTE_ADDR'] ?? '');\n        if ($isBehindReverseProxy) {\n            $ip = GeneralUtility::trimExplode(',', $serverParams['HTTP_X_FORWARDED_FOR'] ?? '', true);\n            // Choose which IP in list to use\n            $configuredReverseProxyHeaderMultiValue = trim($configuration['reverseProxyHeaderMultiValue'] ?? '');\n            if (!empty($ip) && $configuredReverseProxyHeaderMultiValue === 'last') {\n                $ip = (string)array_pop($ip);\n            } elseif (!empty($ip) && $configuredReverseProxyHeaderMultiValue === 'first') {\n                $ip = (string)array_shift($ip);\n            } else {\n                $ip = '';\n            }\n            if (GeneralUtility::validIP($ip)) {\n                $remoteAddress = $ip;\n            }\n        }\n        return $remoteAddress;\n    }\n\n    /**\n     * Check if a configured reverse proxy setup is detected.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS[SYS] array\n     * @return bool True if TYPO3 is behind a reverse proxy\n     */\n    protected static function determineIsBehindReverseProxy($serverParams, $configuration): bool\n    {\n        return GeneralUtility::cmpIP(\n            trim($serverParams['REMOTE_ADDR'] ?? ''),\n            trim($configuration['reverseProxyIP'] ?? '')\n        );\n    }\n\n    /**\n     * HTTP_HOST without port\n     *\n     * @param string $httpHost host[:[port]]\n     * @return string Resolved host\n     */\n    protected static function determineRequestHostOnly(string $httpHost): string\n    {\n        $httpHostBracketPosition = strpos($httpHost, ']');\n        $httpHostParts = explode(':', $httpHost);\n        return $httpHostBracketPosition !== false ? substr(\n            $httpHost,\n            0,\n            $httpHostBracketPosition + 1\n        ) : array_shift($httpHostParts);\n    }\n\n    /**\n     * Requested port if given\n     *\n     * @param string $httpHost host[:[port]]\n     * @param string $httpHostOnly host\n     * @return int Resolved port if given, else 0\n     */\n    protected static function determineRequestPort(string $httpHost, string $httpHostOnly): int\n    {\n        return strlen($httpHost) > strlen($httpHostOnly) ? (int)substr($httpHost, strlen($httpHostOnly) + 1) : 0;\n    }\n\n    /**\n     * Calculate absolute path to web document root\n     *\n     * @param string $scriptName Entry script path of URI, without domain and without query parameters, with leading /\n     * @param string $scriptFilename Absolute path to entry script on server filesystem\n     * @return string Path to document root with trailing slash\n     */\n    protected static function determineDocumentRoot(string $scriptName, string $scriptFilename): string\n    {\n        // Get the web root (it is not the root of the TYPO3 installation)\n        // Some CGI-versions (LA13CGI) and mod-rewrite rules on MODULE versions will deliver a 'wrong'\n        // DOCUMENT_ROOT (according to our description). Further various aliases/mod_rewrite rules can\n        // disturb this as well. Therefore the DOCUMENT_ROOT is always calculated as the SCRIPT_FILENAME\n        // minus the end part shared with SCRIPT_NAME.\n        $webDocRoot = '';\n        $scriptNameArray = explode('/', strrev($scriptName));\n        $scriptFilenameArray = explode('/', strrev($scriptFilename));\n        $path = [];\n        foreach ($scriptNameArray as $segmentNumber => $segment) {\n            if ((string)$scriptFilenameArray[$segmentNumber] === (string)$segment) {\n                $path[] = $segment;\n            } else {\n                break;\n            }\n        }\n        $commonEnd = strrev(implode('/', $path));\n        if ((string)$commonEnd !== '') {\n            $webDocRoot = substr($scriptFilename, 0, -(strlen($commonEnd) + 1));\n        }\n        return $webDocRoot;\n    }\n\n    /**\n     * Determine frontend url\n     *\n     * @param string $requestDir Full Uri with path, but without script name and query parts\n     * @param string $pathThisScript Absolute path to entry script on server filesystem\n     * @param string $pathSite Absolute server path to document root\n     * @return string Calculated Frontend Url\n     */\n    protected static function determineSiteUrl(string $requestDir, string $pathThisScript, string $pathSite): string\n    {\n        $pathThisScriptDir = substr(dirname($pathThisScript), strlen($pathSite)) . '/';\n        $siteUrl = (string)substr($requestDir, 0, -strlen($pathThisScriptDir));\n\n        return rtrim($siteUrl, '/') . '/';\n    }\n\n    /**\n     * Determine site path\n     *\n     * @param string $requestHost scheme://host[:port]\n     * @param string $siteUrl Full Frontend Url\n     */\n    protected static function determineSitePath(string $requestHost, string $siteUrl): string\n    {\n        return (string)substr($siteUrl, strlen($requestHost));\n    }\n\n    /**\n     * Determine site script\n     */\n    protected static function determineSiteScript(string $requestUrl, string $siteUrl): string\n    {\n        return (string)substr($requestUrl, strlen($siteUrl));\n    }\n\n    /**\n     * Factory method, to allow TYPO3 to handle configuration options directly.\n     *\n     * @param array $serverParams - could be fulfilled by $_SERVER (on web requests)\n     * @param array|null $systemConfiguration\n     * @return static\n     */\n    public static function createFromServerParams(array $serverParams, array $systemConfiguration = null): self\n    {\n        return new NormalizedParams(\n            $serverParams,\n            $systemConfiguration ?? $GLOBALS['TYPO3_CONF_VARS']['SYS'],\n            Environment::getCurrentScript(),\n            Environment::getPublicPath()\n        );\n    }\n\n    /**\n     * Factory method for creating normalized params from a PSR-7 server request object\n     *\n     * @param array|null $systemConfiguration\n     * @return static\n     */\n    public static function createFromRequest(ServerRequestInterface $request, array $systemConfiguration = null): self\n    {\n        return static::createFromServerParams(\n            $request->getServerParams(),\n            $systemConfiguration ?? $GLOBALS['TYPO3_CONF_VARS']['SYS']\n        );\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Utility;\n\nuse Egulias\\EmailValidator\\EmailValidator;\nuse Egulias\\EmailValidator\\Validation\\EmailValidation;\nuse Egulias\\EmailValidator\\Validation\\MultipleValidationWithAnd;\nuse Egulias\\EmailValidator\\Validation\\RFCValidation;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerInterface;\nuse TYPO3\\CMS\\Core\\Authentication\\AbstractAuthenticationService;\nuse TYPO3\\CMS\\Core\\Cache\\CacheManager;\nuse TYPO3\\CMS\\Core\\Core\\ClassLoadingInformation;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Http\\ApplicationType;\nuse TYPO3\\CMS\\Core\\Http\\RequestFactory;\nuse TYPO3\\CMS\\Core\\Log\\LogManager;\nuse TYPO3\\CMS\\Core\\Package\\Exception as PackageException;\nuse TYPO3\\CMS\\Core\\SingletonInterface;\n\n/**\n * The legendary \"t3lib_div\" class - Miscellaneous functions for general purpose.\n * Most of the functions do not relate specifically to TYPO3\n * However a section of functions requires certain TYPO3 features available\n * See comments in the source.\n * You are encouraged to use this library in your own scripts!\n *\n * USE:\n * All methods in this class are meant to be called statically.\n * So use \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::[method-name] to refer to the functions, eg. '\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::milliseconds()'\n */\nclass GeneralUtility\n{\n    protected static ?ContainerInterface $container = null;\n\n    /**\n     * Singleton instances returned by `makeInstance`, using the class names as array keys\n     *\n     * @var array<class-string, SingletonInterface>\n     */\n    protected static array $singletonInstances = [];\n\n    /**\n     * Instances returned by `makeInstance`, using the class names as array keys\n     *\n     * @var array<class-string, array<int, object>>\n     */\n    protected static array $nonSingletonInstances = [];\n\n    /**\n     * Cache for `makeInstance` with given class name and final class names to reduce number of\n     * `self::getClassName()` calls\n     *\n     * @var array<class-string, class-string> Given class name => final class name\n     */\n    protected static array $finalClassNameCache = [];\n\n    /**\n     * @var array<string, string|bool|array<string, string|bool|null>|null>\n     */\n    protected static array $indpEnvCache = [];\n\n    final private function __construct()\n    {\n    }\n\n    /*************************\n     *\n     * GET/POST Variables\n     *\n     * Background:\n     * Input GET/POST variables in PHP may have their quotes escaped with \"\\\" or not depending on configuration.\n     * TYPO3 has always converted quotes to BE escaped if the configuration told that they would not be so.\n     * But the clean solution is that quotes are never escaped and that is what the functions below offers.\n     * Eventually TYPO3 should provide this in the global space as well.\n     * In the transitional phase (or forever..?) we need to encourage EVERY to read and write GET/POST vars through the API functions below.\n     * This functionality was previously needed to normalize between magic quotes logic, which was removed from PHP 5.4,\n     * so these methods are still in use, but not tackle the slash problem anymore.\n     *\n     *************************/\n    /**\n     * Returns the 'GLOBAL' value of incoming data from POST or GET, with priority to POST, which is equivalent to 'GP' order\n     * In case you already know by which method your data is arriving consider using GeneralUtility::_GET or GeneralUtility::_POST.\n     *\n     * @param string $var GET/POST var to return\n     * @return mixed POST var named $var, if not set, the GET var of the same name and if also not set, NULL.\n     */\n    public static function _GP($var)\n    {\n        if (empty($var)) {\n            return;\n        }\n\n        $value = $_POST[$var] ?? $_GET[$var] ?? null;\n\n        // This is there for backwards-compatibility, in order to avoid NULL\n        if (isset($value) && !is_array($value)) {\n            $value = (string)$value;\n        }\n        return $value;\n    }\n\n    /**\n     * Returns the global arrays $_GET and $_POST merged with $_POST taking precedence.\n     *\n     * @param string $parameter Key (variable name) from GET or POST vars\n     * @return array Returns the GET vars merged recursively onto the POST vars.\n     * @deprecated since TYPO3 v12.2. will be removed in TYPO3 v13.0.\n     */\n    public static function _GPmerged($parameter)\n    {\n        trigger_error(\n            'GeneralUtility::_GPmerged() will be removed in TYPO3 v13.0, retrieve request related' .\n            ' details from PSR-7 ServerRequestInterface instead.',\n            E_USER_DEPRECATED\n        );\n        $postParameter = isset($_POST[$parameter]) && is_array($_POST[$parameter]) ? $_POST[$parameter] : [];\n        $getParameter = isset($_GET[$parameter]) && is_array($_GET[$parameter]) ? $_GET[$parameter] : [];\n        $mergedParameters = $getParameter;\n        ArrayUtility::mergeRecursiveWithOverrule($mergedParameters, $postParameter);\n        return $mergedParameters;\n    }\n\n    /**\n     * Returns the global $_GET array (or value from) normalized to contain un-escaped values.\n     * This function was previously used to normalize between magic quotes logic, which was removed from PHP 5.5\n     *\n     * @param string $var Optional pointer to value in GET array (basically name of GET var)\n     * @return mixed If $var is set it returns the value of $_GET[$var]. If $var is NULL (default), returns $_GET itself.\n     * @see _POST()\n     * @see _GP()\n     */\n    public static function _GET($var = null)\n    {\n        $value = $var === null\n            ? $_GET\n            : (empty($var) ? null : ($_GET[$var] ?? null));\n        // This is there for backwards-compatibility, in order to avoid NULL\n        if (isset($value) && !is_array($value)) {\n            $value = (string)$value;\n        }\n        return $value;\n    }\n\n    /**\n     * Returns the global $_POST array (or value from) normalized to contain un-escaped values.\n     *\n     * @param string $var Optional pointer to value in POST array (basically name of POST var)\n     * @return mixed If $var is set it returns the value of $_POST[$var]. If $var is NULL (default), returns $_POST itself.\n     * @see _GET()\n     * @see _GP()\n     * @deprecated since TYPO3 v12.2. will be removed in TYPO3 v13.0.\n     */\n    public static function _POST($var = null)\n    {\n        trigger_error(\n            'GeneralUtility::_POST() will be removed in TYPO3 v13.0, retrieve request related' .\n            ' details from PSR-7 ServerRequestInterface instead.',\n            E_USER_DEPRECATED\n        );\n        $value = $var === null ? $_POST : (empty($var) || !isset($_POST[$var]) ? null : $_POST[$var]);\n        // This is there for backwards-compatibility, in order to avoid NULL\n        if (isset($value) && !is_array($value)) {\n            $value = (string)$value;\n        }\n        return $value;\n    }\n\n    /*************************\n     *\n     * STRING FUNCTIONS\n     *\n     *************************/\n    /**\n     * Truncates a string with appended/prepended \"...\" and takes current character set into consideration.\n     *\n     * @param string $string String to truncate\n     * @param int $chars Must be an integer with an absolute value of at least 4. if negative the string is cropped from the right end.\n     * @param string $appendString Appendix to the truncated string\n     * @return string Cropped string\n     */\n    public static function fixed_lgd_cs(string $string, int $chars, string $appendString = '...'): string\n    {\n        if ($chars === 0 || mb_strlen($string, 'utf-8') <= abs($chars)) {\n            return $string;\n        }\n        if ($chars > 0) {\n            $string = mb_substr($string, 0, $chars, 'utf-8') . $appendString;\n        } else {\n            $string = $appendString . mb_substr($string, $chars, mb_strlen($string, 'utf-8'), 'utf-8');\n        }\n        return $string;\n    }\n\n    /**\n     * Match IP number with list of numbers with wildcard\n     * Dispatcher method for switching into specialised IPv4 and IPv6 methods.\n     *\n     * @param string $baseIP Is the current remote IP address for instance, typ. REMOTE_ADDR\n     * @param string $list Is a comma-list of IP-addresses to match with. CIDR-notation should be used. For IPv4 addresses only, the *-wildcard is also allowed instead of number, plus leaving out parts in the IP number is accepted as wildcard (eg. 192.168.*.* equals 192.168). If list is \"*\" no check is done and the function returns TRUE immediately. An empty list always returns FALSE.\n     * @return bool TRUE if an IP-mask from $list matches $baseIP\n     */\n    public static function cmpIP($baseIP, $list)\n    {\n        $list = trim($list);\n        if ($list === '') {\n            return false;\n        }\n        if ($list === '*') {\n            return true;\n        }\n        if (str_contains($baseIP, ':') && self::validIPv6($baseIP)) {\n            return self::cmpIPv6($baseIP, $list);\n        }\n        return self::cmpIPv4($baseIP, $list);\n    }\n\n    /**\n     * Match IPv4 number with list of numbers with wildcard\n     *\n     * @param string $baseIP Is the current remote IP address for instance, typ. REMOTE_ADDR\n     * @param string $list Is a comma-list of IP-addresses to match with. CIDR-notation, *-wildcard allowed instead of number, plus leaving out parts in the IP number is accepted as wildcard (eg. 192.168.0.0/16 equals 192.168.*.* equals 192.168), could also contain IPv6 addresses\n     * @return bool TRUE if an IP-mask from $list matches $baseIP\n     */\n    public static function cmpIPv4($baseIP, $list)\n    {\n        $IPpartsReq = explode('.', $baseIP);\n        if (count($IPpartsReq) === 4) {\n            $values = self::trimExplode(',', $list, true);\n            foreach ($values as $test) {\n                $testList = explode('/', $test);\n                if (count($testList) === 2) {\n                    [$test, $mask] = $testList;\n                } else {\n                    $mask = false;\n                }\n                if ((int)$mask) {\n                    $mask = (int)$mask;\n                    // \"192.168.3.0/24\"\n                    $lnet = (int)ip2long($test);\n                    $lip = (int)ip2long($baseIP);\n                    $binnet = str_pad(decbin($lnet), 32, '0', STR_PAD_LEFT);\n                    $firstpart = substr($binnet, 0, $mask);\n                    $binip = str_pad(decbin($lip), 32, '0', STR_PAD_LEFT);\n                    $firstip = substr($binip, 0, $mask);\n                    $yes = $firstpart === $firstip;\n                } else {\n                    // \"192.168.*.*\"\n                    $IPparts = explode('.', $test);\n                    $yes = 1;\n                    foreach ($IPparts as $index => $val) {\n                        $val = trim($val);\n                        if ($val !== '*' && $IPpartsReq[$index] !== $val) {\n                            $yes = 0;\n                        }\n                    }\n                }\n                if ($yes) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Match IPv6 address with a list of IPv6 prefixes\n     *\n     * @param string $baseIP Is the current remote IP address for instance\n     * @param string $list Is a comma-list of IPv6 prefixes, could also contain IPv4 addresses. IPv6 addresses\n     *   must be specified in CIDR-notation, not with * wildcard, otherwise self::validIPv6() will fail.\n     * @return bool TRUE If a baseIP matches any prefix\n     */\n    public static function cmpIPv6($baseIP, $list)\n    {\n        // Policy default: Deny connection\n        $success = false;\n        $baseIP = self::normalizeIPv6($baseIP);\n        $values = self::trimExplode(',', $list, true);\n        foreach ($values as $test) {\n            $testList = explode('/', $test);\n            if (count($testList) === 2) {\n                [$test, $mask] = $testList;\n            } else {\n                $mask = false;\n            }\n            if (self::validIPv6($test)) {\n                $test = self::normalizeIPv6($test);\n                $maskInt = (int)$mask ?: 128;\n                // Special case; /0 is an allowed mask - equals a wildcard\n                if ($mask === '0') {\n                    $success = true;\n                } elseif ($maskInt == 128) {\n                    $success = $test === $baseIP;\n                } else {\n                    $testBin = (string)inet_pton($test);\n                    $baseIPBin = (string)inet_pton($baseIP);\n\n                    $success = true;\n                    // Modulo is 0 if this is a 8-bit-boundary\n                    $maskIntModulo = $maskInt % 8;\n                    $numFullCharactersUntilBoundary = (int)($maskInt / 8);\n                    $substring = (string)substr($baseIPBin, 0, $numFullCharactersUntilBoundary);\n                    if (!str_starts_with($testBin, $substring)) {\n                        $success = false;\n                    } elseif ($maskIntModulo > 0) {\n                        // If not an 8-bit-boundary, check bits of last character\n                        $testLastBits = str_pad(decbin(ord(substr($testBin, $numFullCharactersUntilBoundary, 1))), 8, '0', STR_PAD_LEFT);\n                        $baseIPLastBits = str_pad(decbin(ord(substr($baseIPBin, $numFullCharactersUntilBoundary, 1))), 8, '0', STR_PAD_LEFT);\n                        if (strncmp($testLastBits, $baseIPLastBits, $maskIntModulo) != 0) {\n                            $success = false;\n                        }\n                    }\n                }\n            }\n            if ($success) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Normalize an IPv6 address to full length\n     *\n     * @param string $address Given IPv6 address\n     * @return string Normalized address\n     */\n    public static function normalizeIPv6($address)\n    {\n        $normalizedAddress = '';\n        // According to RFC lowercase-representation is recommended\n        $address = strtolower($address);\n        // Normalized representation has 39 characters (0000:0000:0000:0000:0000:0000:0000:0000)\n        if (strlen($address) === 39) {\n            // Already in full expanded form\n            return $address;\n        }\n        // Count 2 if if address has hidden zero blocks\n        $chunks = explode('::', $address);\n        if (count($chunks) === 2) {\n            $chunksLeft = explode(':', $chunks[0]);\n            $chunksRight = explode(':', $chunks[1]);\n            $left = count($chunksLeft);\n            $right = count($chunksRight);\n            // Special case: leading zero-only blocks count to 1, should be 0\n            if ($left === 1 && strlen($chunksLeft[0]) === 0) {\n                $left = 0;\n            }\n            $hiddenBlocks = 8 - ($left + $right);\n            $hiddenPart = '';\n            $h = 0;\n            while ($h < $hiddenBlocks) {\n                $hiddenPart .= '0000:';\n                $h++;\n            }\n            if ($left === 0) {\n                $stageOneAddress = $hiddenPart . $chunks[1];\n            } else {\n                $stageOneAddress = $chunks[0] . ':' . $hiddenPart . $chunks[1];\n            }\n        } else {\n            $stageOneAddress = $address;\n        }\n        // Normalize the blocks:\n        $blocks = explode(':', $stageOneAddress);\n        $divCounter = 0;\n        foreach ($blocks as $block) {\n            $tmpBlock = '';\n            $i = 0;\n            $hiddenZeros = 4 - strlen($block);\n            while ($i < $hiddenZeros) {\n                $tmpBlock .= '0';\n                $i++;\n            }\n            $normalizedAddress .= $tmpBlock . $block;\n            if ($divCounter < 7) {\n                $normalizedAddress .= ':';\n                $divCounter++;\n            }\n        }\n        return $normalizedAddress;\n    }\n\n    /**\n     * Validate a given IP address.\n     *\n     * Possible format are IPv4 and IPv6.\n     *\n     * @param string $ip IP address to be tested\n     * @return bool TRUE if $ip is either of IPv4 or IPv6 format.\n     */\n    public static function validIP($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP) !== false;\n    }\n\n    /**\n     * Validate a given IP address to the IPv4 address format.\n     *\n     * Example for possible format: 10.0.45.99\n     *\n     * @param string $ip IP address to be tested\n     * @return bool TRUE if $ip is of IPv4 format.\n     */\n    public static function validIPv4($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false;\n    }\n\n    /**\n     * Validate a given IP address to the IPv6 address format.\n     *\n     * Example for possible format: 43FB::BB3F:A0A0:0 | ::1\n     *\n     * @param string $ip IP address to be tested\n     * @return bool TRUE if $ip is of IPv6 format.\n     */\n    public static function validIPv6($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false;\n    }\n\n    /**\n     * Match fully qualified domain name with list of strings with wildcard\n     *\n     * @param string $baseHost A hostname or an IPv4/IPv6-address (will by reverse-resolved; typically REMOTE_ADDR)\n     * @param string $list A comma-list of domain names to match with. *-wildcard allowed but cannot be part of a string, so it must match the full host name (eg. myhost.*.com => correct, myhost.*domain.com => wrong)\n     * @return bool TRUE if a domain name mask from $list matches $baseIP\n     */\n    public static function cmpFQDN($baseHost, $list)\n    {\n        $baseHost = trim($baseHost);\n        if (empty($baseHost)) {\n            return false;\n        }\n        if (self::validIPv4($baseHost) || self::validIPv6($baseHost)) {\n            // Resolve hostname\n            // Note: this is reverse-lookup and can be randomly set as soon as somebody is able to set\n            // the reverse-DNS for his IP (security when for example used with REMOTE_ADDR)\n            $baseHostName = (string)gethostbyaddr($baseHost);\n            if ($baseHostName === $baseHost) {\n                // Unable to resolve hostname\n                return false;\n            }\n        } else {\n            $baseHostName = $baseHost;\n        }\n        $baseHostNameParts = explode('.', $baseHostName);\n        $values = self::trimExplode(',', $list, true);\n        foreach ($values as $test) {\n            $hostNameParts = explode('.', $test);\n            // To match hostNameParts can only be shorter (in case of wildcards) or equal\n            $hostNamePartsCount = count($hostNameParts);\n            $baseHostNamePartsCount = count($baseHostNameParts);\n            if ($hostNamePartsCount > $baseHostNamePartsCount) {\n                continue;\n            }\n            $yes = true;\n            foreach ($hostNameParts as $index => $val) {\n                $val = trim($val);\n                if ($val === '*') {\n                    // Wildcard valid for one or more hostname-parts\n                    $wildcardStart = $index + 1;\n                    // Wildcard as last/only part always matches, otherwise perform recursive checks\n                    if ($wildcardStart < $hostNamePartsCount) {\n                        $wildcardMatched = false;\n                        $tempHostName = implode('.', array_slice($hostNameParts, $index + 1));\n                        while ($wildcardStart < $baseHostNamePartsCount && !$wildcardMatched) {\n                            $tempBaseHostName = implode('.', array_slice($baseHostNameParts, $wildcardStart));\n                            $wildcardMatched = self::cmpFQDN($tempBaseHostName, $tempHostName);\n                            $wildcardStart++;\n                        }\n                        if ($wildcardMatched) {\n                            // Match found by recursive compare\n                            return true;\n                        }\n                        $yes = false;\n                    }\n                } elseif ($baseHostNameParts[$index] !== $val) {\n                    // In case of no match\n                    $yes = false;\n                }\n            }\n            if ($yes) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if a given URL matches the host that currently handles this HTTP request.\n     * Scheme, hostname and (optional) port of the given URL are compared.\n     *\n     * @param string $url URL to compare with the TYPO3 request host\n     * @return bool Whether the URL matches the TYPO3 request host\n     */\n    public static function isOnCurrentHost($url)\n    {\n        return stripos($url . '/', self::getIndpEnv('TYPO3_REQUEST_HOST') . '/') === 0;\n    }\n\n    /**\n     * Check for item in list\n     * Check if an item exists in a comma-separated list of items.\n     *\n     * @param string $list Comma-separated list of items (string)\n     * @param string $item Item to check for\n     * @return bool TRUE if $item is in $list\n     */\n    public static function inList($list, $item)\n    {\n        return str_contains(',' . $list . ',', ',' . $item . ',');\n    }\n\n    /**\n     * Expand a comma-separated list of integers with ranges (eg 1,3-5,7 becomes 1,3,4,5,7).\n     * Ranges are limited to 1000 values per range.\n     *\n     * @param string $list Comma-separated list of integers with ranges (string)\n     * @return string New comma-separated list of items\n     */\n    public static function expandList($list)\n    {\n        $items = explode(',', $list);\n        $list = [];\n        foreach ($items as $item) {\n            $range = explode('-', $item);\n            if (isset($range[1])) {\n                $runAwayBrake = 1000;\n                for ($n = $range[0]; $n <= $range[1]; $n++) {\n                    $list[] = $n;\n                    $runAwayBrake--;\n                    if ($runAwayBrake <= 0) {\n                        break;\n                    }\n                }\n            } else {\n                $list[] = $item;\n            }\n        }\n        return implode(',', $list);\n    }\n\n    /**\n     * Makes a positive integer hash out of the first 7 chars from the md5 hash of the input\n     *\n     * @param string $str String to md5-hash\n     * @return int Returns 28bit integer-hash\n     */\n    public static function md5int($str)\n    {\n        return hexdec(substr(md5($str), 0, 7));\n    }\n\n    /**\n     * Returns a proper HMAC on a given input string and secret TYPO3 encryption key.\n     *\n     * @param string $input Input string to create HMAC from\n     * @param string $additionalSecret additionalSecret to prevent hmac being used in a different context\n     * @return string resulting (hexadecimal) HMAC currently with a length of 40 (HMAC-SHA-1)\n     */\n    public static function hmac($input, $additionalSecret = '')\n    {\n        $hashAlgorithm = 'sha1';\n        $secret = $GLOBALS['TYPO3_CONF_VARS']['SYS']['encryptionKey'] . $additionalSecret;\n        return hash_hmac($hashAlgorithm, $input, $secret);\n    }\n\n    /**\n     * Splits a reference to a file in 5 parts\n     *\n     * @param string $fileNameWithPath File name with path to be analyzed (must exist if open_basedir is set)\n     * @return array<string, string> Contains keys [path], [file], [filebody], [fileext], [realFileext]\n     */\n    public static function split_fileref($fileNameWithPath)\n    {\n        $info = [];\n        $reg = [];\n        if (preg_match('/(.*\\\\/)(.*)$/', $fileNameWithPath, $reg)) {\n            $info['path'] = $reg[1];\n            $info['file'] = $reg[2];\n        } else {\n            $info['path'] = '';\n            $info['file'] = $fileNameWithPath;\n        }\n        $reg = '';\n        // If open_basedir is set and the fileName was supplied without a path the is_dir check fails\n        if (!is_dir($fileNameWithPath) && preg_match('/(.*)\\\\.([^\\\\.]*$)/', $info['file'], $reg)) {\n            $info['filebody'] = $reg[1];\n            $info['fileext'] = strtolower($reg[2]);\n            $info['realFileext'] = $reg[2];\n        } else {\n            $info['filebody'] = $info['file'];\n            $info['fileext'] = '';\n        }\n        reset($info);\n        return $info;\n    }\n\n    /**\n     * Returns the directory part of a path without trailing slash\n     * If there is no dir-part, then an empty string is returned.\n     * Behaviour:\n     *\n     * '/dir1/dir2/script.php' => '/dir1/dir2'\n     * '/dir1/' => '/dir1'\n     * 'dir1/script.php' => 'dir1'\n     * 'd/script.php' => 'd'\n     * '/script.php' => ''\n     * '' => ''\n     *\n     * @param string $path Directory name / path\n     * @return string Processed input value. See function description.\n     */\n    public static function dirname($path)\n    {\n        $p = self::revExplode('/', $path, 2);\n        return count($p) === 2 ? $p[0] : '';\n    }\n\n    /**\n     * Formats the input integer $sizeInBytes as bytes/kilobytes/megabytes (-/K/M)\n     *\n     * @param int $sizeInBytes Number of bytes to format.\n     * @param string $labels Binary unit name \"iec\", decimal unit name \"si\" or labels for bytes, kilo, mega, giga, and so on separated by vertical bar (|) and possibly encapsulated in \"\". Eg: \" | K| M| G\". Defaults to \"iec\".\n     * @param int $base The unit base if not using a unit name. Defaults to 1024.\n     * @return string Formatted representation of the byte number, for output.\n     */\n    public static function formatSize($sizeInBytes, $labels = '', $base = 0)\n    {\n        $defaultFormats = [\n            'iec' => ['base' => 1024, 'labels' => [' ', ' Ki', ' Mi', ' Gi', ' Ti', ' Pi', ' Ei', ' Zi', ' Yi']],\n            'si' => ['base' => 1000, 'labels' => [' ', ' k', ' M', ' G', ' T', ' P', ' E', ' Z', ' Y']],\n        ];\n        // Set labels and base:\n        if (empty($labels)) {\n            $labels = 'iec';\n        }\n        if (isset($defaultFormats[$labels])) {\n            $base = $defaultFormats[$labels]['base'];\n            $labelArr = $defaultFormats[$labels]['labels'];\n        } else {\n            $base = (int)$base;\n            if ($base !== 1000 && $base !== 1024) {\n                $base = 1024;\n            }\n            $labelArr = explode('|', str_replace('\"', '', $labels));\n        }\n        // This is set via Site Handling and in the Locales class via setlocale()\n        $localeInfo = localeconv();\n        $sizeInBytes = max($sizeInBytes, 0);\n        $multiplier = floor(($sizeInBytes ? log($sizeInBytes) : 0) / log($base));\n        $sizeInUnits = $sizeInBytes / $base ** $multiplier;\n        if ($sizeInUnits > ($base * .9)) {\n            $multiplier++;\n        }\n        $multiplier = min($multiplier, count($labelArr) - 1);\n        $sizeInUnits = $sizeInBytes / $base ** $multiplier;\n        return number_format($sizeInUnits, (($multiplier > 0) && ($sizeInUnits < 20)) ? 2 : 0, $localeInfo['decimal_point'], '') . $labelArr[$multiplier];\n    }\n\n    /**\n     * This splits a string by the chars in $operators (typical /+-*) and returns an array with them in\n     *\n     * @param string $string Input string, eg \"123 + 456 / 789 - 4\n     * @param string $operators Operators to split by, typically \"/+-*\n     * @return array<int, array<int, string>> Array with operators and operands separated.\n     * @see \\TYPO3\\CMS\\Frontend\\ContentObject\\ContentObjectRenderer::calc()\n     * @see \\TYPO3\\CMS\\Frontend\\Imaging\\GifBuilder::calcOffset()\n     */\n    public static function splitCalc($string, $operators)\n    {\n        $res = [];\n        $sign = '+';\n        while ($string) {\n            $valueLen = strcspn($string, $operators);\n            $value = substr($string, 0, $valueLen);\n            $res[] = [$sign, trim($value)];\n            $sign = substr($string, $valueLen, 1);\n            $string = substr($string, $valueLen + 1);\n        }\n        reset($res);\n        return $res;\n    }\n\n    /**\n     * Checking syntax of input email address\n     *\n     * @param string $email Input string to evaluate\n     * @return bool Returns TRUE if the $email address (input string) is valid\n     */\n    public static function validEmail($email)\n    {\n        // Early return in case input is not a string\n        if (!is_string($email)) {\n            return false;\n        }\n        if (trim($email) !== $email) {\n            return false;\n        }\n        if (!str_contains($email, '@')) {\n            return false;\n        }\n        $validators = [];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['MAIL']['validators'] ?? [RFCValidation::class] as $className) {\n            $validator = new $className();\n            if ($validator instanceof EmailValidation) {\n                $validators[] = $validator;\n            }\n        }\n        return (new EmailValidator())->isValid($email, new MultipleValidationWithAnd($validators, MultipleValidationWithAnd::STOP_ON_ERROR));\n    }\n\n    /**\n     * Returns a given string with underscores as UpperCamelCase.\n     * Example: Converts blog_example to BlogExample\n     *\n     * @param string $string String to be converted to camel case\n     * @return string UpperCamelCasedWord\n     */\n    public static function underscoredToUpperCamelCase($string)\n    {\n        return str_replace(' ', '', ucwords(str_replace('_', ' ', strtolower($string))));\n    }\n\n    /**\n     * Returns a given string with underscores as lowerCamelCase.\n     * Example: Converts minimal_value to minimalValue\n     *\n     * @param string $string String to be converted to camel case\n     * @return string lowerCamelCasedWord\n     */\n    public static function underscoredToLowerCamelCase($string)\n    {\n        return lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', strtolower($string)))));\n    }\n\n    /**\n     * Returns a given CamelCasedString as a lowercase string with underscores.\n     * Example: Converts BlogExample to blog_example, and minimalValue to minimal_value\n     *\n     * @param string $string String to be converted to lowercase underscore\n     * @return string lowercase_and_underscored_string\n     */\n    public static function camelCaseToLowerCaseUnderscored($string)\n    {\n        $value = preg_replace('/(?<=\\\\w)([A-Z])/', '_\\\\1', $string) ?? '';\n        return mb_strtolower($value, 'utf-8');\n    }\n\n    /**\n     * Checks if a given string is a Uniform Resource Locator (URL).\n     *\n     * On seriously malformed URLs, parse_url may return FALSE and emit an\n     * E_WARNING.\n     *\n     * filter_var() requires a scheme to be present.\n     *\n     * http://www.faqs.org/rfcs/rfc2396.html\n     * Scheme names consist of a sequence of characters beginning with a\n     * lower case letter and followed by any combination of lower case letters,\n     * digits, plus (\"+\"), period (\".\"), or hyphen (\"-\").  For resiliency,\n     * programs interpreting URI should treat upper case letters as equivalent to\n     * lower case in scheme names (e.g., allow \"HTTP\" as well as \"http\").\n     * scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )\n     *\n     * Convert the domain part to punicode if it does not look like a regular\n     * domain name. Only the domain part because RFC3986 specifies the the rest of\n     * the url may not contain special characters:\n     * https://tools.ietf.org/html/rfc3986#appendix-A\n     *\n     * @param string $url The URL to be validated\n     * @return bool Whether the given URL is valid\n     */\n    public static function isValidUrl($url)\n    {\n        $parsedUrl = parse_url($url);\n        if (!$parsedUrl || !isset($parsedUrl['scheme'])) {\n            return false;\n        }\n        // HttpUtility::buildUrl() will always build urls with <scheme>://\n        // our original $url might only contain <scheme>: (e.g. mail:)\n        // so we convert that to the double-slashed version to ensure\n        // our check against the $recomposedUrl is proper\n        if (!str_starts_with($url, $parsedUrl['scheme'] . '://')) {\n            $url = str_replace($parsedUrl['scheme'] . ':', $parsedUrl['scheme'] . '://', $url);\n        }\n        $recomposedUrl = HttpUtility::buildUrl($parsedUrl);\n        if ($recomposedUrl !== $url) {\n            // The parse_url() had to modify characters, so the URL is invalid\n            return false;\n        }\n        if (isset($parsedUrl['host']) && !preg_match('/^[a-z0-9.\\\\-]*$/i', $parsedUrl['host'])) {\n            $host = idn_to_ascii($parsedUrl['host']);\n            if ($host === false) {\n                return false;\n            }\n            $parsedUrl['host'] = $host;\n        }\n        return filter_var(HttpUtility::buildUrl($parsedUrl), FILTER_VALIDATE_URL) !== false;\n    }\n\n    /*************************\n     *\n     * ARRAY FUNCTIONS\n     *\n     *************************/\n\n    /**\n     * Explodes a $string delimited by $delimiter and casts each item in the array to (int).\n     * Corresponds to \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::trimExplode(), but with conversion to integers for all values.\n     *\n     * @param string $delimiter Delimiter string to explode with\n     * @param string $string The string to explode\n     * @param bool $removeEmptyValues If set, all empty values (='') will NOT be set in output\n     * @param int $limit If positive, the result will contain a maximum of limit elements,\n     * @return int[] Exploded values, all converted to integers\n     */\n    public static function intExplode($delimiter, $string, $removeEmptyValues = false, $limit = 0)\n    {\n        $result = explode($delimiter, $string);\n        foreach ($result as $key => &$value) {\n            if ($removeEmptyValues && ($value === '' || trim($value) === '')) {\n                unset($result[$key]);\n            } else {\n                $value = (int)$value;\n            }\n        }\n        unset($value);\n        if ($limit !== 0) {\n            if ($limit < 0) {\n                $result = array_slice($result, 0, $limit);\n            } elseif (count($result) > $limit) {\n                $lastElements = array_slice($result, $limit - 1);\n                $result = array_slice($result, 0, $limit - 1);\n                $result[] = implode($delimiter, $lastElements);\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Reverse explode which explodes the string counting from behind.\n     *\n     * Note: The delimiter has to given in the reverse order as\n     *       it is occurring within the string.\n     *\n     * GeneralUtility::revExplode('[]', '[my][words][here]', 2)\n     *   ==> array('[my][words', 'here]')\n     *\n     * @param string $delimiter Delimiter string to explode with\n     * @param string $string The string to explode\n     * @param int $count Number of array entries\n     * @return string[] Exploded values\n     */\n    public static function revExplode($delimiter, $string, $count = 0)\n    {\n        // 2 is the (currently, as of 2014-02) most-used value for $count in the core, therefore we check it first\n        if ($count === 2) {\n            $position = strrpos($string, strrev($delimiter));\n            if ($position !== false) {\n                return [substr($string, 0, $position), substr($string, $position + strlen($delimiter))];\n            }\n            return [$string];\n        }\n        if ($count <= 1) {\n            return [$string];\n        }\n        $explodedValues = explode($delimiter, strrev($string), $count);\n        $explodedValues = array_map('strrev', $explodedValues);\n        return array_reverse($explodedValues);\n    }\n\n    /**\n     * Explodes a string and removes whitespace-only values.\n     *\n     * If $removeEmptyValues is set, then all values that contain only whitespace are removed.\n     *\n     * Each item will have leading and trailing whitespace removed. However, if the tail items are\n     * returned as a single array item, their internal whitespace will not be modified.\n     *\n     * @param string $delim Delimiter string to explode with\n     * @param string $string The string to explode\n     * @param bool $removeEmptyValues If set, all empty values will be removed in output\n     * @param int $limit If limit is set and positive, the returned array will contain a maximum of limit elements with\n     *                   the last element containing the rest of string. If the limit parameter is negative, all components\n     *                   except the last -limit are returned.\n     * @return string[] Exploded values\n     */\n    public static function trimExplode($delim, $string, $removeEmptyValues = false, $limit = 0): array\n    {\n        $result = explode($delim, (string)$string);\n        if ($removeEmptyValues) {\n            // Remove items that are just whitespace, but leave whitespace intact for the rest.\n            $result = array_values(array_filter($result, static fn ($item) => trim($item) !== ''));\n        }\n\n        if ($limit === 0) {\n            // Return everything.\n            return array_map('trim', $result);\n        }\n\n        if ($limit < 0) {\n            // Trim and return just the first $limit elements and ignore the rest.\n            return array_map('trim', array_slice($result, 0, $limit));\n        }\n\n        // Fold the last length - $limit elements into a single trailing item, then trim and return the result.\n        $tail = array_slice($result, $limit - 1);\n        $result = array_slice($result, 0, $limit - 1);\n        if ($tail) {\n            $result[] = implode($delim, $tail);\n        }\n        return array_map('trim', $result);\n    }\n\n    /**\n     * Implodes a multidim-array into GET-parameters (eg. &param[key][key2]=value2&param[key][key3]=value3)\n     *\n     * @param string $name Name prefix for entries. Set to blank if you wish none.\n     * @param array $theArray The (multidimensional) array to implode\n     * @param string $str (keep blank)\n     * @param bool $skipBlank If set, parameters which were blank strings would be removed.\n     * @param bool $rawurlencodeParamName If set, the param name itself (for example \"param[key][key2]\") would be rawurlencoded as well.\n     * @return string Imploded result, fx. &param[key][key2]=value2&param[key][key3]=value3\n     * @see explodeUrl2Array()\n     */\n    public static function implodeArrayForUrl($name, array $theArray, $str = '', $skipBlank = false, $rawurlencodeParamName = false)\n    {\n        foreach ($theArray as $Akey => $AVal) {\n            $thisKeyName = $name ? $name . '[' . $Akey . ']' : $Akey;\n            if (is_array($AVal)) {\n                $str = self::implodeArrayForUrl($thisKeyName, $AVal, $str, $skipBlank, $rawurlencodeParamName);\n            } else {\n                $stringValue = (string)$AVal;\n                if (!$skipBlank || $stringValue !== '') {\n                    $parameterName = $rawurlencodeParamName ? rawurlencode($thisKeyName) : $thisKeyName;\n                    $parameterValue = rawurlencode($stringValue);\n                    $str .= '&' . $parameterName . '=' . $parameterValue;\n                }\n            }\n        }\n        return $str;\n    }\n\n    /**\n     * Explodes a string with GETvars (eg. \"&id=1&type=2&ext[mykey]=3\") into an array.\n     *\n     * Note! If you want to use a multi-dimensional string, consider this plain simple PHP code instead:\n     *\n     * $result = [];\n     * parse_str($queryParametersAsString, $result);\n     *\n     * However, if you do magic with a flat structure (e.g. keeping \"ext[mykey]\" as flat key in a one-dimensional array)\n     * then this method is for you.\n     *\n     * @param string $string GETvars string\n     * @return array<string, string> Array of values. All values AND keys are rawurldecoded() as they properly should be. But this means that any implosion of the array again must rawurlencode it!\n     * @see implodeArrayForUrl()\n     */\n    public static function explodeUrl2Array($string)\n    {\n        $output = [];\n        $p = explode('&', $string);\n        foreach ($p as $v) {\n            if ($v !== '') {\n                $nameAndValue = explode('=', $v, 2);\n                $output[rawurldecode($nameAndValue[0])] = isset($nameAndValue[1]) ? rawurldecode($nameAndValue[1]) : '';\n            }\n        }\n        return $output;\n    }\n\n    /**\n     * Removes dots \".\" from end of a key identifier of TypoScript styled array.\n     * array('key.' => array('property.' => 'value')) --> array('key' => array('property' => 'value'))\n     *\n     * @param array $ts TypoScript configuration array\n     * @return array TypoScript configuration array without dots at the end of all keys\n     */\n    public static function removeDotsFromTS(array $ts): array\n    {\n        $out = [];\n        foreach ($ts as $key => $value) {\n            if (is_array($value)) {\n                $key = rtrim($key, '.');\n                $out[$key] = self::removeDotsFromTS($value);\n            } else {\n                $out[$key] = $value;\n            }\n        }\n        return $out;\n    }\n\n    /*************************\n     *\n     * HTML/XML PROCESSING\n     *\n     *************************/\n    /**\n     * Returns an array with all attributes of the input HTML tag as key/value pairs. Attributes are only lowercase a-z\n     * $tag is either a whole tag (eg '<TAG OPTION ATTRIB=VALUE>') or the parameter list (ex ' OPTION ATTRIB=VALUE>')\n     * If an attribute is empty, then the value for the key is empty. You can check if it existed with isset()\n     *\n     * @param string $tag HTML-tag string (or attributes only)\n     * @param bool $decodeEntities Whether to decode HTML entities\n     * @return array<string, string> Array with the attribute values.\n     */\n    public static function get_tag_attributes($tag, bool $decodeEntities = false)\n    {\n        $components = self::split_tag_attributes($tag);\n        // Attribute name is stored here\n        $name = '';\n        $valuemode = false;\n        $attributes = [];\n        foreach ($components as $key => $val) {\n            // Only if $name is set (if there is an attribute, that waits for a value), that valuemode is enabled. This ensures that the attribute is assigned it's value\n            if ($val !== '=') {\n                if ($valuemode) {\n                    if ($name) {\n                        $attributes[$name] = $decodeEntities ? htmlspecialchars_decode($val) : $val;\n                        $name = '';\n                    }\n                } else {\n                    if ($key = strtolower(preg_replace('/[^[:alnum:]_\\\\:\\\\-]/', '', $val) ?? '')) {\n                        $attributes[$key] = '';\n                        $name = $key;\n                    }\n                }\n                $valuemode = false;\n            } else {\n                $valuemode = true;\n            }\n        }\n        return $attributes;\n    }\n\n    /**\n     * Returns an array with the 'components' from an attribute list from an HTML tag. The result is normally analyzed by get_tag_attributes\n     * Removes tag-name if found\n     *\n     * @param string $tag HTML-tag string (or attributes only)\n     * @return string[] Array with the attribute values.\n     */\n    public static function split_tag_attributes($tag)\n    {\n        $tag_tmp = trim(preg_replace('/^<[^[:space:]]*/', '', trim($tag)) ?? '');\n        // Removes any > in the end of the string\n        $tag_tmp = trim(rtrim($tag_tmp, '>'));\n        $value = [];\n        // Compared with empty string instead , 030102\n        while ($tag_tmp !== '') {\n            $firstChar = $tag_tmp[0];\n            if ($firstChar === '\"' || $firstChar === '\\'') {\n                $reg = explode($firstChar, $tag_tmp, 3);\n                $value[] = $reg[1];\n                $tag_tmp = trim($reg[2]);\n            } elseif ($firstChar === '=') {\n                $value[] = '=';\n                // Removes = chars.\n                $tag_tmp = trim(substr($tag_tmp, 1));\n            } else {\n                // There are '' around the value. We look for the next ' ' or '>'\n                $reg = preg_split('/[[:space:]=]/', $tag_tmp, 2);\n                $value[] = trim($reg[0]);\n                $tag_tmp = trim(substr($tag_tmp, strlen($reg[0]), 1) . ($reg[1] ?? ''));\n            }\n        }\n        reset($value);\n        return $value;\n    }\n\n    /**\n     * Implodes attributes in the array $arr for an attribute list in eg. and HTML tag (with quotes)\n     *\n     * @param array<string, string> $arr Array with attribute key/value pairs, eg. \"bgcolor\" => \"red\", \"border\" => \"0\"\n     * @param bool $xhtmlSafe If set the resulting attribute list will have a) all attributes in lowercase (and duplicates weeded out, first entry taking precedence) and b) all values htmlspecialchar()'ed. It is recommended to use this switch!\n     * @param bool $keepBlankAttributes If TRUE, don't check if values are blank. Default is to omit attributes with blank values.\n     * @return string Imploded attributes, eg. 'bgcolor=\"red\" border=\"0\"'\n     */\n    public static function implodeAttributes(array $arr, $xhtmlSafe = false, $keepBlankAttributes = false)\n    {\n        if ($xhtmlSafe) {\n            $newArr = [];\n            foreach ($arr as $attributeName => $attributeValue) {\n                $attributeName = strtolower($attributeName);\n                if (!isset($newArr[$attributeName])) {\n                    $newArr[$attributeName] = htmlspecialchars((string)$attributeValue);\n                }\n            }\n            $arr = $newArr;\n        }\n        $list = [];\n        foreach ($arr as $attributeName => $attributeValue) {\n            if ((string)$attributeValue !== '' || $keepBlankAttributes) {\n                $list[] = $attributeName . '=\"' . $attributeValue . '\"';\n            }\n        }\n        return implode(' ', $list);\n    }\n\n    /**\n     * Wraps JavaScript code XHTML ready with <script>-tags\n     * Automatic re-indenting of the JS code is done by using the first line as indent reference.\n     * This is nice for indenting JS code with PHP code on the same level.\n     *\n     * @param string $string JavaScript code\n     * @return string The wrapped JS code, ready to put into a XHTML page\n     */\n    public static function wrapJS($string)\n    {\n        if (trim($string)) {\n            // remove nl from the beginning\n            $string = ltrim($string, LF);\n            // re-ident to one tab using the first line as reference\n            $match = [];\n            if (preg_match('/^(\\\\t+)/', $string, $match)) {\n                $string = str_replace($match[1], \"\\t\", $string);\n            }\n            return '<script>\n/*<![CDATA[*/\n' . $string . '\n/*]]>*/\n</script>';\n        }\n        return '';\n    }\n\n    /**\n     * Parses XML input into a PHP array with associative keys\n     *\n     * @param string $string XML data input\n     * @param int $depth Number of element levels to resolve the XML into an array. Any further structure will be set as XML.\n     * @param array $parserOptions Options that will be passed to PHP's xml_parser_set_option()\n     * @return mixed The array with the parsed structure unless the XML parser returns with an error in which case the error message string is returned.\n     */\n    public static function xml2tree($string, $depth = 999, $parserOptions = [])\n    {\n        $parser = xml_parser_create();\n        $vals = [];\n        $index = [];\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 0);\n        foreach ($parserOptions as $option => $value) {\n            xml_parser_set_option($parser, $option, $value);\n        }\n        xml_parse_into_struct($parser, $string, $vals, $index);\n        if (xml_get_error_code($parser)) {\n            return 'Line ' . xml_get_current_line_number($parser) . ': ' . xml_error_string(xml_get_error_code($parser));\n        }\n        xml_parser_free($parser);\n        $stack = [[]];\n        $stacktop = 0;\n        $startPoint = 0;\n        $tagi = [];\n        foreach ($vals as $key => $val) {\n            $type = $val['type'];\n            // open tag:\n            if ($type === 'open' || $type === 'complete') {\n                $stack[$stacktop++] = $tagi;\n                if ($depth == $stacktop) {\n                    $startPoint = $key;\n                }\n                $tagi = ['tag' => $val['tag']];\n                if (isset($val['attributes'])) {\n                    $tagi['attrs'] = $val['attributes'];\n                }\n                if (isset($val['value'])) {\n                    $tagi['values'][] = $val['value'];\n                }\n            }\n            // finish tag:\n            if ($type === 'complete' || $type === 'close') {\n                $oldtagi = $tagi;\n                $tagi = $stack[--$stacktop];\n                $oldtag = $oldtagi['tag'];\n                unset($oldtagi['tag']);\n                if ($depth == $stacktop + 1) {\n                    if ($key - $startPoint > 0) {\n                        $partArray = array_slice($vals, $startPoint + 1, $key - $startPoint - 1);\n                        $oldtagi['XMLvalue'] = self::xmlRecompileFromStructValArray($partArray);\n                    } else {\n                        $oldtagi['XMLvalue'] = $oldtagi['values'][0];\n                    }\n                }\n                $tagi['ch'][$oldtag][] = $oldtagi;\n                unset($oldtagi);\n            }\n            // cdata\n            if ($type === 'cdata') {\n                $tagi['values'][] = $val['value'];\n            }\n        }\n        return $tagi['ch'];\n    }\n\n    /**\n     * Converts a PHP array into an XML string.\n     * The XML output is optimized for readability since associative keys are used as tag names.\n     * This also means that only alphanumeric characters are allowed in the tag names AND only keys NOT starting with numbers (so watch your usage of keys!). However there are options you can set to avoid this problem.\n     * Numeric keys are stored with the default tag name \"numIndex\" but can be overridden to other formats)\n     * The function handles input values from the PHP array in a binary-safe way; All characters below 32 (except 9,10,13) will trigger the content to be converted to a base64-string\n     * The PHP variable type of the data IS preserved as long as the types are strings, arrays, integers and booleans. Strings are the default type unless the \"type\" attribute is set.\n     * The output XML has been tested with the PHP XML-parser and parses OK under all tested circumstances with 4.x versions. However, with PHP5 there seems to be the need to add an XML prologue a la <?xml version=\"1.0\" encoding=\"[charset]\" standalone=\"yes\" ?> - otherwise UTF-8 is assumed! Unfortunately, many times the output from this function is used without adding that prologue meaning that non-ASCII characters will break the parsing!! This sucks of course! Effectively it means that the prologue should always be prepended setting the right characterset, alternatively the system should always run as utf-8!\n     * However using MSIE to read the XML output didn't always go well: One reason could be that the character encoding is not observed in the PHP data. The other reason may be if the tag-names are invalid in the eyes of MSIE. Also using the namespace feature will make MSIE break parsing. There might be more reasons...\n     *\n     * @param array $array The input PHP array with any kind of data; text, binary, integers. Not objects though.\n     * @param string $NSprefix tag-prefix, eg. a namespace prefix like \"T3:\"\n     * @param int $level Current recursion level. Don't change, stay at zero!\n     * @param string $docTag Alternative document tag. Default is \"phparray\".\n     * @param int $spaceInd If greater than zero, then the number of spaces corresponding to this number is used for indenting, if less than zero - no indentation, if zero - a single TAB is used\n     * @param array $options Options for the compilation. Key \"useNindex\" => 0/1 (boolean: whether to use \"n0, n1, n2\" for num. indexes); Key \"useIndexTagForNum\" => \"[tag for numerical indexes]\"; Key \"useIndexTagForAssoc\" => \"[tag for associative indexes\"; Key \"parentTagMap\" => array('parentTag' => 'thisLevelTag')\n     * @param array $stackData Stack data. Don't touch.\n     * @return string An XML string made from the input content in the array.\n     * @see xml2array()\n     */\n    public static function array2xml(array $array, $NSprefix = '', $level = 0, $docTag = 'phparray', $spaceInd = 0, array $options = [], array $stackData = [])\n    {\n        // The list of byte values which will trigger binary-safe storage. If any value has one of these char values in it, it will be encoded in base64\n        $binaryChars = \"\\0\" . chr(1) . chr(2) . chr(3) . chr(4) . chr(5) . chr(6) . chr(7) . chr(8) . chr(11) . chr(12) . chr(14) . chr(15) . chr(16) . chr(17) . chr(18) . chr(19) . chr(20) . chr(21) . chr(22) . chr(23) . chr(24) . chr(25) . chr(26) . chr(27) . chr(28) . chr(29) . chr(30) . chr(31);\n        // Set indenting mode:\n        $indentChar = $spaceInd ? ' ' : \"\\t\";\n        $indentN = $spaceInd > 0 ? $spaceInd : 1;\n        $nl = $spaceInd >= 0 ? LF : '';\n        // Init output variable:\n        $output = '';\n        // Traverse the input array\n        foreach ($array as $k => $v) {\n            $attr = '';\n            $tagName = (string)$k;\n            // Construct the tag name.\n            // Use tag based on grand-parent + parent tag name\n            if (isset($stackData['grandParentTagName'], $stackData['parentTagName'], $options['grandParentTagMap'][$stackData['grandParentTagName'] . '/' . $stackData['parentTagName']])) {\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['grandParentTagMap'][$stackData['grandParentTagName'] . '/' . $stackData['parentTagName']];\n            } elseif (isset($stackData['parentTagName'], $options['parentTagMap'][$stackData['parentTagName'] . ':_IS_NUM']) && MathUtility::canBeInterpretedAsInteger($tagName)) {\n                // Use tag based on parent tag name + if current tag is numeric\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['parentTagMap'][$stackData['parentTagName'] . ':_IS_NUM'];\n            } elseif (isset($stackData['parentTagName'], $options['parentTagMap'][$stackData['parentTagName'] . ':' . $tagName])) {\n                // Use tag based on parent tag name + current tag\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['parentTagMap'][$stackData['parentTagName'] . ':' . $tagName];\n            } elseif (isset($stackData['parentTagName'], $options['parentTagMap'][$stackData['parentTagName']])) {\n                // Use tag based on parent tag name:\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['parentTagMap'][$stackData['parentTagName']];\n            } elseif (MathUtility::canBeInterpretedAsInteger($tagName)) {\n                // If integer...;\n                if ($options['useNindex'] ?? false) {\n                    // If numeric key, prefix \"n\"\n                    $tagName = 'n' . $tagName;\n                } else {\n                    // Use special tag for num. keys:\n                    $attr .= ' index=\"' . $tagName . '\"';\n                    $tagName = ($options['useIndexTagForNum'] ?? false) ?: 'numIndex';\n                }\n            } elseif (!empty($options['useIndexTagForAssoc'])) {\n                // Use tag for all associative keys:\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = $options['useIndexTagForAssoc'];\n            }\n            // The tag name is cleaned up so only alphanumeric chars (plus - and _) are in there and not longer than 100 chars either.\n            $tagName = substr(preg_replace('/[^[:alnum:]_-]/', '', $tagName), 0, 100);\n            // If the value is an array then we will call this function recursively:\n            if (is_array($v)) {\n                // Sub elements:\n                if (isset($options['alt_options']) && ($options['alt_options'][($stackData['path'] ?? '') . '/' . $tagName] ?? false)) {\n                    $subOptions = $options['alt_options'][($stackData['path'] ?? '') . '/' . $tagName];\n                    $clearStackPath = (bool)($subOptions['clearStackPath'] ?? false);\n                } else {\n                    $subOptions = $options;\n                    $clearStackPath = false;\n                }\n                if (empty($v)) {\n                    $content = '';\n                } else {\n                    $content = $nl . self::array2xml($v, $NSprefix, $level + 1, '', $spaceInd, $subOptions, [\n                            'parentTagName' => $tagName,\n                            'grandParentTagName' => $stackData['parentTagName'] ?? '',\n                            'path' => $clearStackPath ? '' : ($stackData['path'] ?? '') . '/' . $tagName,\n                        ]) . ($spaceInd >= 0 ? str_pad('', ($level + 1) * $indentN, $indentChar) : '');\n                }\n                // Do not set \"type = array\". Makes prettier XML but means that empty arrays are not restored with xml2array\n                if (!isset($options['disableTypeAttrib']) || (int)$options['disableTypeAttrib'] != 2) {\n                    $attr .= ' type=\"array\"';\n                }\n            } else {\n                $stringValue = (string)$v;\n                // Just a value:\n                // Look for binary chars:\n                $vLen = strlen($stringValue);\n                // Go for base64 encoding if the initial segment NOT matching any binary char has the same length as the whole string!\n                if ($vLen && strcspn($stringValue, $binaryChars) != $vLen) {\n                    // If the value contained binary chars then we base64-encode it and set an attribute to notify this situation:\n                    $content = $nl . chunk_split(base64_encode($stringValue));\n                    $attr .= ' base64=\"1\"';\n                } else {\n                    // Otherwise, just htmlspecialchar the stuff:\n                    $content = htmlspecialchars($stringValue);\n                    $dType = gettype($v);\n                    if ($dType === 'string') {\n                        if (isset($options['useCDATA']) && $options['useCDATA'] && $content != $stringValue) {\n                            $content = '<![CDATA[' . $stringValue . ']]>';\n                        }\n                    } elseif (!($options['disableTypeAttrib'] ?? false)) {\n                        $attr .= ' type=\"' . $dType . '\"';\n                    }\n                }\n            }\n            if ($tagName !== '') {\n                // Add the element to the output string:\n                $output .= ($spaceInd >= 0 ? str_pad('', ($level + 1) * $indentN, $indentChar) : '')\n                    . '<' . $NSprefix . $tagName . $attr . '>' . $content . '</' . $NSprefix . $tagName . '>' . $nl;\n            }\n        }\n        // If we are at the outer-most level, then we finally wrap it all in the document tags and return that as the value:\n        if (!$level) {\n            $output = '<' . $docTag . '>' . $nl . $output . '</' . $docTag . '>';\n        }\n        return $output;\n    }\n\n    /**\n     * Converts an XML string to a PHP array.\n     * This is the reverse function of array2xml()\n     * This is a wrapper for xml2arrayProcess that adds a two-level cache\n     *\n     * @param string $string XML content to convert into an array\n     * @param string $NSprefix The tag-prefix resolve, eg. a namespace like \"T3:\"\n     * @param bool $reportDocTag If set, the document tag will be set in the key \"_DOCUMENT_TAG\" of the output array\n     * @return mixed If the parsing had errors, a string with the error message is returned. Otherwise an array with the content.\n     * @see array2xml()\n     * @see xml2arrayProcess()\n     */\n    public static function xml2array($string, $NSprefix = '', $reportDocTag = false)\n    {\n        $runtimeCache = static::makeInstance(CacheManager::class)->getCache('runtime');\n        $firstLevelCache = $runtimeCache->get('generalUtilityXml2Array') ?: [];\n        $identifier = md5($string . $NSprefix . ($reportDocTag ? '1' : '0'));\n        // Look up in first level cache\n        if (empty($firstLevelCache[$identifier])) {\n            $firstLevelCache[$identifier] = self::xml2arrayProcess($string, $NSprefix, $reportDocTag);\n            $runtimeCache->set('generalUtilityXml2Array', $firstLevelCache);\n        }\n        return $firstLevelCache[$identifier];\n    }\n\n    /**\n     * Converts an XML string to a PHP array.\n     * This is the reverse function of array2xml()\n     *\n     * @param string $string XML content to convert into an array\n     * @param string $NSprefix The tag-prefix resolve, eg. a namespace like \"T3:\"\n     * @param bool $reportDocTag If set, the document tag will be set in the key \"_DOCUMENT_TAG\" of the output array\n     * @return mixed If the parsing had errors, a string with the error message is returned. Otherwise an array with the content.\n     * @see array2xml()\n     */\n    public static function xml2arrayProcess($string, $NSprefix = '', $reportDocTag = false)\n    {\n        $string = trim((string)$string);\n        // Create parser:\n        $parser = xml_parser_create();\n        $vals = [];\n        $index = [];\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 0);\n        // Default output charset is UTF-8, only ASCII, ISO-8859-1 and UTF-8 are supported!!!\n        $match = [];\n        preg_match('/^[[:space:]]*<\\\\?xml[^>]*encoding[[:space:]]*=[[:space:]]*\"([^\"]*)\"/', substr($string, 0, 200), $match);\n        $theCharset = $match[1] ?? 'utf-8';\n        // us-ascii / utf-8 / iso-8859-1\n        xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING, $theCharset);\n        // Parse content:\n        xml_parse_into_struct($parser, $string, $vals, $index);\n        // If error, return error message:\n        if (xml_get_error_code($parser)) {\n            return 'Line ' . xml_get_current_line_number($parser) . ': ' . xml_error_string(xml_get_error_code($parser));\n        }\n        xml_parser_free($parser);\n        // Init vars:\n        $stack = [[]];\n        $stacktop = 0;\n        $current = [];\n        $tagName = '';\n        $documentTag = '';\n        // Traverse the parsed XML structure:\n        foreach ($vals as $key => $val) {\n            // First, process the tag-name (which is used in both cases, whether \"complete\" or \"close\")\n            $tagName = $val['tag'];\n            if (!$documentTag) {\n                $documentTag = $tagName;\n            }\n            // Test for name space:\n            $tagName = $NSprefix && str_starts_with($tagName, $NSprefix) ? substr($tagName, strlen($NSprefix)) : $tagName;\n            // Test for numeric tag, encoded on the form \"nXXX\":\n            $testNtag = substr($tagName, 1);\n            // Closing tag.\n            $tagName = $tagName[0] === 'n' && MathUtility::canBeInterpretedAsInteger($testNtag) ? (int)$testNtag : $tagName;\n            // Test for alternative index value:\n            if ((string)($val['attributes']['index'] ?? '') !== '') {\n                $tagName = $val['attributes']['index'];\n            }\n            // Setting tag-values, manage stack:\n            switch ($val['type']) {\n                case 'open':\n                    // If open tag it means there is an array stored in sub-elements. Therefore increase the stackpointer and reset the accumulation array:\n                    // Setting blank place holder\n                    $current[$tagName] = [];\n                    $stack[$stacktop++] = $current;\n                    $current = [];\n                    break;\n                case 'close':\n                    // If the tag is \"close\" then it is an array which is closing and we decrease the stack pointer.\n                    $oldCurrent = $current;\n                    $current = $stack[--$stacktop];\n                    // Going to the end of array to get placeholder key, key($current), and fill in array next:\n                    end($current);\n                    $current[key($current)] = $oldCurrent;\n                    unset($oldCurrent);\n                    break;\n                case 'complete':\n                    // If \"complete\", then it's a value. If the attribute \"base64\" is set, then decode the value, otherwise just set it.\n                    if (!empty($val['attributes']['base64'])) {\n                        $current[$tagName] = base64_decode($val['value']);\n                    } else {\n                        // Had to cast it as a string - otherwise it would be evaluate FALSE if tested with isset()!!\n                        $current[$tagName] = (string)($val['value'] ?? '');\n                        // Cast type:\n                        switch ((string)($val['attributes']['type'] ?? '')) {\n                            case 'integer':\n                                $current[$tagName] = (int)$current[$tagName];\n                                break;\n                            case 'double':\n                                $current[$tagName] = (float)$current[$tagName];\n                                break;\n                            case 'boolean':\n                                $current[$tagName] = (bool)$current[$tagName];\n                                break;\n                            case 'NULL':\n                                $current[$tagName] = null;\n                                break;\n                            case 'array':\n                                // MUST be an empty array since it is processed as a value; Empty arrays would end up here because they would have no tags inside...\n                                $current[$tagName] = [];\n                                break;\n                        }\n                    }\n                    break;\n            }\n        }\n        if ($reportDocTag) {\n            $current[$tagName]['_DOCUMENT_TAG'] = $documentTag;\n        }\n        // Finally return the content of the document tag.\n        return $current[$tagName];\n    }\n\n    /**\n     * This implodes an array of XML parts (made with xml_parse_into_struct()) into XML again.\n     *\n     * @param array<int, array<string, mixed>> $vals An array of XML parts, see xml2tree\n     * @return string Re-compiled XML data.\n     */\n    public static function xmlRecompileFromStructValArray(array $vals)\n    {\n        $XMLcontent = '';\n        foreach ($vals as $val) {\n            $type = $val['type'];\n            // Open tag:\n            if ($type === 'open' || $type === 'complete') {\n                $XMLcontent .= '<' . $val['tag'];\n                if (isset($val['attributes'])) {\n                    foreach ($val['attributes'] as $k => $v) {\n                        $XMLcontent .= ' ' . $k . '=\"' . htmlspecialchars($v) . '\"';\n                    }\n                }\n                if ($type === 'complete') {\n                    if (isset($val['value'])) {\n                        $XMLcontent .= '>' . htmlspecialchars($val['value']) . '</' . $val['tag'] . '>';\n                    } else {\n                        $XMLcontent .= '/>';\n                    }\n                } else {\n                    $XMLcontent .= '>';\n                }\n                if ($type === 'open' && isset($val['value'])) {\n                    $XMLcontent .= htmlspecialchars($val['value']);\n                }\n            }\n            // Finish tag:\n            if ($type === 'close') {\n                $XMLcontent .= '</' . $val['tag'] . '>';\n            }\n            // Cdata\n            if ($type === 'cdata') {\n                $XMLcontent .= htmlspecialchars($val['value']);\n            }\n        }\n        return $XMLcontent;\n    }\n\n    /*************************\n     *\n     * FILES FUNCTIONS\n     *\n     *************************/\n    /**\n     * Reads the file or url $url and returns the content\n     * If you are having trouble with proxies when reading URLs you can configure your way out of that with settings within $GLOBALS['TYPO3_CONF_VARS']['HTTP'].\n     *\n     * @param string $url File/URL to read\n     * @return string|false The content from the resource given as input. FALSE if an error has occurred.\n     */\n    public static function getUrl($url)\n    {\n        // Looks like it's an external file, use Guzzle by default\n        if (preg_match('/^(?:http|ftp)s?|s(?:ftp|cp):/', $url)) {\n            $requestFactory = static::makeInstance(RequestFactory::class);\n            try {\n                $response = $requestFactory->request($url);\n            } catch (RequestException $exception) {\n                return false;\n            }\n            $content = $response->getBody()->getContents();\n        } else {\n            $content = @file_get_contents($url);\n        }\n        return $content;\n    }\n\n    /**\n     * Writes $content to the file $file\n     *\n     * @param string $file Filepath to write to\n     * @param string $content Content to write\n     * @param bool $changePermissions If TRUE, permissions are forced to be set\n     * @return bool TRUE if the file was successfully opened and written to.\n     */\n    public static function writeFile($file, $content, $changePermissions = false)\n    {\n        if (!@is_file($file)) {\n            $changePermissions = true;\n        }\n        if ($fd = fopen($file, 'wb')) {\n            $res = fwrite($fd, $content);\n            fclose($fd);\n            if ($res === false) {\n                return false;\n            }\n            // Change the permissions only if the file has just been created\n            if ($changePermissions) {\n                static::fixPermissions($file);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets the file system mode and group ownership of a file or a folder.\n     *\n     * @param string $path Path of file or folder, must not be escaped. Path can be absolute or relative\n     * @param bool $recursive If set, also fixes permissions of files and folders in the folder (if $path is a folder)\n     * @return mixed TRUE on success, FALSE on error, always TRUE on Windows OS\n     */\n    public static function fixPermissions($path, $recursive = false)\n    {\n        $targetPermissions = null;\n        if (Environment::isWindows()) {\n            return true;\n        }\n        $result = false;\n        // Make path absolute\n        if (!PathUtility::isAbsolutePath($path)) {\n            $path = static::getFileAbsFileName($path);\n        }\n        if (static::isAllowedAbsPath($path)) {\n            if (@is_file($path)) {\n                $targetPermissions = (string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['fileCreateMask'] ?? '0644');\n            } elseif (@is_dir($path)) {\n                $targetPermissions = (string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask'] ?? '0755');\n            }\n            if (!empty($targetPermissions)) {\n                // make sure it's always 4 digits\n                $targetPermissions = str_pad($targetPermissions, 4, '0', STR_PAD_LEFT);\n                $targetPermissions = octdec($targetPermissions);\n                // \"@\" is there because file is not necessarily OWNED by the user\n                $result = @chmod($path, (int)$targetPermissions);\n            }\n            // Set createGroup if not empty\n            if (\n                isset($GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup'])\n                && $GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup'] !== ''\n            ) {\n                // \"@\" is there because file is not necessarily OWNED by the user\n                $changeGroupResult = @chgrp($path, $GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup']);\n                $result = $changeGroupResult ? $result : false;\n            }\n            // Call recursive if recursive flag if set and $path is directory\n            if ($recursive && @is_dir($path)) {\n                $handle = opendir($path);\n                if (is_resource($handle)) {\n                    while (($file = readdir($handle)) !== false) {\n                        $recursionResult = null;\n                        if ($file !== '.' && $file !== '..') {\n                            if (@is_file($path . '/' . $file)) {\n                                $recursionResult = static::fixPermissions($path . '/' . $file);\n                            } elseif (@is_dir($path . '/' . $file)) {\n                                $recursionResult = static::fixPermissions($path . '/' . $file, true);\n                            }\n                            if (isset($recursionResult) && !$recursionResult) {\n                                $result = false;\n                            }\n                        }\n                    }\n                    closedir($handle);\n                }\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Writes $content to a filename in the typo3temp/ folder (and possibly one or two subfolders...)\n     * Accepts an additional subdirectory in the file path!\n     *\n     * @param string $filepath Absolute file path to write within the typo3temp/ or Environment::getVarPath() folder - the file path must be prefixed with this path\n     * @param string $content Content string to write\n     * @return string|null Returns NULL on success, otherwise an error string telling about the problem.\n     */\n    public static function writeFileToTypo3tempDir($filepath, $content)\n    {\n        // Parse filepath into directory and basename:\n        $fI = pathinfo($filepath);\n        $fI['dirname'] .= '/';\n        // Check parts:\n        if (!static::validPathStr($filepath) || !$fI['basename'] || strlen($fI['basename']) >= 60) {\n            return 'Input filepath \"' . $filepath . '\" was generally invalid!';\n        }\n\n        // Setting main temporary directory name (standard)\n        $allowedPathPrefixes = [\n            Environment::getPublicPath() . '/typo3temp' => 'Environment::getPublicPath() + \"/typo3temp/\"',\n        ];\n        // Also allow project-path + /var/\n        if (Environment::getVarPath() !== Environment::getPublicPath() . '/typo3temp/var') {\n            $relPath = substr(Environment::getVarPath(), strlen(Environment::getProjectPath()) + 1);\n            $allowedPathPrefixes[Environment::getVarPath()] = 'ProjectPath + ' . $relPath;\n        }\n\n        $errorMessage = null;\n        foreach ($allowedPathPrefixes as $pathPrefix => $prefixLabel) {\n            $dirName = $pathPrefix . '/';\n            // Invalid file path, let's check for the other path, if it exists\n            if (!str_starts_with($fI['dirname'], $dirName)) {\n                if ($errorMessage === null) {\n                    $errorMessage = '\"' . $fI['dirname'] . '\" was not within directory ' . $prefixLabel;\n                }\n                continue;\n            }\n            // This resets previous error messages from the first path\n            $errorMessage = null;\n\n            if (!@is_dir($dirName)) {\n                $errorMessage = $prefixLabel . ' was not a directory!';\n                // continue and see if the next iteration resets the errorMessage above\n                continue;\n            }\n            // Checking if the \"subdir\" is found\n            $subdir = substr($fI['dirname'], strlen($dirName));\n            if ($subdir) {\n                if (preg_match('#^(?:[[:alnum:]_]+/)+$#', $subdir)) {\n                    $dirName .= $subdir;\n                    if (!@is_dir($dirName)) {\n                        static::mkdir_deep($pathPrefix . '/' . $subdir);\n                    }\n                } else {\n                    $errorMessage = 'Subdir, \"' . $subdir . '\", was NOT on the form \"[[:alnum:]_]/+\"';\n                    break;\n                }\n            }\n            // Checking dir-name again (sub-dir might have been created)\n            if (@is_dir($dirName)) {\n                if ($filepath === $dirName . $fI['basename']) {\n                    static::writeFile($filepath, $content);\n                    if (!@is_file($filepath)) {\n                        $errorMessage = 'The file was not written to the disk. Please, check that you have write permissions to the ' . $prefixLabel . ' directory.';\n                    }\n                    break;\n                }\n                $errorMessage = 'Calculated file location didn\\'t match input \"' . $filepath . '\".';\n                break;\n            }\n            $errorMessage = '\"' . $dirName . '\" is not a directory!';\n            break;\n        }\n        return $errorMessage;\n    }\n\n    /**\n     * Wrapper function for mkdir.\n     * Sets folder permissions according to $GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask']\n     * and group ownership according to $GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup']\n     *\n     * @param string $newFolder Absolute path to folder, see PHP mkdir() function. Removes trailing slash internally.\n     * @return bool TRUE if operation was successful\n     */\n    public static function mkdir($newFolder)\n    {\n        $result = @mkdir($newFolder, (int)octdec((string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask'] ?? '0')));\n        if ($result) {\n            static::fixPermissions($newFolder);\n        }\n        return $result;\n    }\n\n    /**\n     * Creates a directory - including parent directories if necessary and\n     * sets permissions on newly created directories.\n     *\n     * @param string $directory Target directory to create\n     * @throws \\InvalidArgumentException If $directory is not a string\n     * @throws \\RuntimeException If directory could not be created\n     */\n    public static function mkdir_deep($directory)\n    {\n        if (!is_string($directory)) {\n            throw new \\InvalidArgumentException('The specified directory is of type \"' . gettype($directory) . '\" but a string is expected.', 1303662955);\n        }\n        // Ensure there is only one slash\n        $fullPath = rtrim($directory, '/') . '/';\n        if ($fullPath !== '/' && !is_dir($fullPath)) {\n            $firstCreatedPath = static::createDirectoryPath($fullPath);\n            if ($firstCreatedPath !== '') {\n                static::fixPermissions($firstCreatedPath, true);\n            }\n        }\n    }\n\n    /**\n     * Creates directories for the specified paths if they do not exist. This\n     * functions sets proper permission mask but does not set proper user and\n     * group.\n     *\n     * @static\n     * @param string $fullDirectoryPath\n     * @return string Path to the the first created directory in the hierarchy\n     * @see \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::mkdir_deep\n     * @throws \\RuntimeException If directory could not be created\n     */\n    protected static function createDirectoryPath($fullDirectoryPath)\n    {\n        $currentPath = $fullDirectoryPath;\n        $firstCreatedPath = '';\n        $permissionMask = (int)octdec((string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask'] ?? '0'));\n        if (!@is_dir($currentPath)) {\n            do {\n                $firstCreatedPath = $currentPath;\n                $separatorPosition = (int)strrpos($currentPath, DIRECTORY_SEPARATOR);\n                $currentPath = substr($currentPath, 0, $separatorPosition);\n            } while (!is_dir($currentPath) && $separatorPosition > 0);\n            $result = @mkdir($fullDirectoryPath, $permissionMask, true);\n            // Check existence of directory again to avoid race condition. Directory could have get created by another process between previous is_dir() and mkdir()\n            if (!$result && !@is_dir($fullDirectoryPath)) {\n                throw new \\RuntimeException('Could not create directory \"' . $fullDirectoryPath . '\"!', 1170251401);\n            }\n        }\n        return $firstCreatedPath;\n    }\n\n    /**\n     * Wrapper function for rmdir, allowing recursive deletion of folders and files\n     *\n     * @param string $path Absolute path to folder, see PHP rmdir() function. Removes trailing slash internally.\n     * @param bool $removeNonEmpty Allow deletion of non-empty directories\n     * @return bool TRUE if operation was successful\n     */\n    public static function rmdir($path, $removeNonEmpty = false)\n    {\n        $OK = false;\n        // Remove trailing slash\n        $path = preg_replace('|/$|', '', $path) ?? '';\n        $isWindows = DIRECTORY_SEPARATOR === '\\\\';\n        if (file_exists($path)) {\n            $OK = true;\n            if (!is_link($path) && is_dir($path)) {\n                if ($removeNonEmpty === true && ($handle = @opendir($path))) {\n                    $entries = [];\n\n                    while (false !== ($file = readdir($handle))) {\n                        if ($file === '.' || $file === '..') {\n                            continue;\n                        }\n\n                        $entries[] = $path . '/' . $file;\n                    }\n\n                    closedir($handle);\n\n                    foreach ($entries as $entry) {\n                        if (!static::rmdir($entry, $removeNonEmpty)) {\n                            $OK = false;\n                        }\n                    }\n                }\n                if ($OK) {\n                    $OK = @rmdir($path);\n                }\n            } elseif (is_link($path) && is_dir($path) && $isWindows) {\n                $OK = @rmdir($path);\n            } else {\n                // If $path is a file, simply remove it\n                $OK = @unlink($path);\n            }\n            clearstatcache();\n        } elseif (is_link($path)) {\n            $OK = @unlink($path);\n            if (!$OK && $isWindows) {\n                // Try to delete dead folder links on Windows systems\n                $OK = @rmdir($path);\n            }\n            clearstatcache();\n        }\n        return $OK;\n    }\n\n    /**\n     * Returns an array with the names of folders in a specific path\n     * Will return 'error' (string) if there were an error with reading directory content.\n     * Will return null if provided path is false.\n     *\n     * @param string $path Path to list directories from\n     * @return string[]|string|null Returns an array with the directory entries as values. If no path is provided, the return value will be null.\n     */\n    public static function get_dirs($path)\n    {\n        $dirs = null;\n        if ($path) {\n            if (is_dir($path)) {\n                $dir = scandir($path);\n                $dirs = [];\n                foreach ($dir as $entry) {\n                    if (is_dir($path . '/' . $entry) && $entry !== '..' && $entry !== '.') {\n                        $dirs[] = $entry;\n                    }\n                }\n            } else {\n                $dirs = 'error';\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Finds all files in a given path and returns them as an array. Each\n     * array key is a md5 hash of the full path to the file. This is done because\n     * 'some' extensions like the import/export extension depend on this.\n     *\n     * @param string $path The path to retrieve the files from.\n     * @param string $extensionList A comma-separated list of file extensions. Only files of the specified types will be retrieved. When left blank, files of any type will be retrieved.\n     * @param bool $prependPath If TRUE, the full path to the file is returned. If FALSE only the file name is returned.\n     * @param string $order The sorting order. The default sorting order is alphabetical. Setting $order to 'mtime' will sort the files by modification time.\n     * @param string $excludePattern A regular expression pattern of file names to exclude. For example: 'clear.gif' or '(clear.gif|.htaccess)'. The pattern will be wrapped with: '/^' and '$/'.\n     * @return array<string, string>|string Array of the files found, or an error message in case the path could not be opened.\n     */\n    public static function getFilesInDir($path, $extensionList = '', $prependPath = false, $order = '', $excludePattern = '')\n    {\n        $excludePattern = (string)$excludePattern;\n        $path = rtrim($path, '/');\n        if (!@is_dir($path)) {\n            return [];\n        }\n\n        $rawFileList = scandir($path);\n        if ($rawFileList === false) {\n            return 'error opening path: \"' . $path . '\"';\n        }\n\n        $pathPrefix = $path . '/';\n        $allowedFileExtensionArray = self::trimExplode(',', $extensionList);\n        $extensionList = ',' . str_replace(' ', '', $extensionList) . ',';\n        $files = [];\n        foreach ($rawFileList as $entry) {\n            $completePathToEntry = $pathPrefix . $entry;\n            if (!@is_file($completePathToEntry)) {\n                continue;\n            }\n\n            foreach ($allowedFileExtensionArray as $allowedFileExtension) {\n                if (\n                    ($extensionList === ',,' || stripos($extensionList, ',' . substr($entry, strlen($allowedFileExtension) * -1, strlen($allowedFileExtension)) . ',') !== false)\n                    && ($excludePattern === '' || !preg_match('/^' . $excludePattern . '$/', $entry))\n                ) {\n                    if ($order !== 'mtime') {\n                        $files[] = $entry;\n                    } else {\n                        // Store the value in the key so we can do a fast asort later.\n                        $files[$entry] = filemtime($completePathToEntry);\n                    }\n                }\n            }\n        }\n\n        $valueName = 'value';\n        if ($order === 'mtime') {\n            asort($files);\n            $valueName = 'key';\n        }\n\n        $valuePathPrefix = $prependPath ? $pathPrefix : '';\n        $foundFiles = [];\n        foreach ($files as $key => $value) {\n            // Don't change this ever - extensions may depend on the fact that the hash is an md5 of the path! (import/export extension)\n            $foundFiles[md5($pathPrefix . ${$valueName})] = $valuePathPrefix . ${$valueName};\n        }\n\n        return $foundFiles;\n    }\n\n    /**\n     * Recursively gather all files and folders of a path.\n     *\n     * @param string[] $fileArr Empty input array (will have files added to it)\n     * @param string $path The path to read recursively from (absolute) (include trailing slash!)\n     * @param string $extList Comma list of file extensions: Only files with extensions in this list (if applicable) will be selected.\n     * @param bool $regDirs If set, directories are also included in output.\n     * @param int $recursivityLevels The number of levels to dig down...\n     * @param string $excludePattern regex pattern of files/directories to exclude\n     * @return array<string, string> An array with the found files/directories.\n     */\n    public static function getAllFilesAndFoldersInPath(array $fileArr, $path, $extList = '', $regDirs = false, $recursivityLevels = 99, $excludePattern = '')\n    {\n        if ($regDirs) {\n            $fileArr[md5($path)] = $path;\n        }\n        $fileArr = array_merge($fileArr, (array)self::getFilesInDir($path, $extList, true, '', $excludePattern));\n        $dirs = self::get_dirs($path);\n        if ($recursivityLevels > 0 && is_array($dirs)) {\n            foreach ($dirs as $subdirs) {\n                if ((string)$subdirs !== '' && ($excludePattern === '' || !preg_match('/^' . $excludePattern . '$/', $subdirs))) {\n                    $fileArr = self::getAllFilesAndFoldersInPath($fileArr, $path . $subdirs . '/', $extList, $regDirs, $recursivityLevels - 1, $excludePattern);\n                }\n            }\n        }\n        return $fileArr;\n    }\n\n    /**\n     * Removes the absolute part of all files/folders in fileArr\n     *\n     * @param string[] $fileArr The file array to remove the prefix from\n     * @param string $prefixToRemove The prefix path to remove (if found as first part of string!)\n     * @return string[]|string The input $fileArr processed, or a string with an error message, when an error occurred.\n     */\n    public static function removePrefixPathFromList(array $fileArr, string $prefixToRemove)\n    {\n        foreach ($fileArr as &$absFileRef) {\n            if (str_starts_with($absFileRef, $prefixToRemove)) {\n                $absFileRef = substr($absFileRef, strlen($prefixToRemove));\n            } else {\n                return 'ERROR: One or more of the files was NOT prefixed with the prefix-path!';\n            }\n        }\n        unset($absFileRef);\n        return $fileArr;\n    }\n\n    /**\n     * Fixes a path for windows-backslashes and reduces double-slashes to single slashes\n     *\n     * @param string $theFile File path to process\n     * @return string\n     */\n    public static function fixWindowsFilePath($theFile)\n    {\n        return str_replace(['\\\\', '//'], '/', $theFile);\n    }\n\n    /**\n     * Resolves \"../\" sections in the input path string.\n     * For example \"fileadmin/directory/../other_directory/\" will be resolved to \"fileadmin/other_directory/\"\n     *\n     * @param string $pathStr File path in which \"/../\" is resolved\n     * @return string\n     */\n    public static function resolveBackPath($pathStr)\n    {\n        if (!str_contains($pathStr, '..')) {\n            return $pathStr;\n        }\n        $parts = explode('/', $pathStr);\n        $output = [];\n        $c = 0;\n        foreach ($parts as $part) {\n            if ($part === '..') {\n                if ($c) {\n                    array_pop($output);\n                    --$c;\n                } else {\n                    $output[] = $part;\n                }\n            } else {\n                ++$c;\n                $output[] = $part;\n            }\n        }\n        return implode('/', $output);\n    }\n\n    /**\n     * Prefixes a URL used with 'header-location' with 'http://...' depending on whether it has it already.\n     * - If already having a scheme, nothing is prepended\n     * - If having REQUEST_URI slash '/', then prefixing 'http://[host]' (relative to host)\n     * - Otherwise prefixed with TYPO3_REQUEST_DIR (relative to current dir / TYPO3_REQUEST_DIR)\n     *\n     * @param string $path URL / path to prepend full URL addressing to.\n     * @return ($path is non-empty-string ? non-empty-string : string)\n     */\n    public static function locationHeaderUrl($path)\n    {\n        if (str_starts_with($path, '//')) {\n            return $path;\n        }\n\n        // relative to HOST\n        if (str_starts_with($path, '/')) {\n            return self::getIndpEnv('TYPO3_REQUEST_HOST') . $path;\n        }\n\n        $urlComponents = parse_url($path);\n        if (!($urlComponents['scheme'] ?? false)) {\n            // No scheme either\n            return self::getIndpEnv('TYPO3_REQUEST_DIR') . $path;\n        }\n\n        return $path;\n    }\n\n    /**\n     * Returns the maximum upload size for a file that is allowed. Measured in KB.\n     * This might be handy to find out the real upload limit that is possible for this\n     * TYPO3 installation.\n     *\n     * @return int The maximum size of uploads that are allowed (measured in kilobytes)\n     */\n    public static function getMaxUploadFileSize()\n    {\n        $uploadMaxFilesize = (string)ini_get('upload_max_filesize');\n        $postMaxSize = (string)ini_get('post_max_size');\n        // Check for PHP restrictions of the maximum size of one of the $_FILES\n        $phpUploadLimit = self::getBytesFromSizeMeasurement($uploadMaxFilesize);\n        // Check for PHP restrictions of the maximum $_POST size\n        $phpPostLimit = self::getBytesFromSizeMeasurement($postMaxSize);\n        // If the total amount of post data is smaller (!) than the upload_max_filesize directive,\n        // then this is the real limit in PHP\n        $phpUploadLimit = $phpPostLimit > 0 && $phpPostLimit < $phpUploadLimit ? $phpPostLimit : $phpUploadLimit;\n        return floor($phpUploadLimit) / 1024;\n    }\n\n    /**\n     * Gets the bytes value from a measurement string like \"100k\".\n     *\n     * @param string $measurement The measurement (e.g. \"100k\")\n     * @return int The bytes value (e.g. 102400)\n     */\n    public static function getBytesFromSizeMeasurement($measurement)\n    {\n        $bytes = (float)$measurement;\n        if (stripos($measurement, 'G')) {\n            $bytes *= 1024 * 1024 * 1024;\n        } elseif (stripos($measurement, 'M')) {\n            $bytes *= 1024 * 1024;\n        } elseif (stripos($measurement, 'K')) {\n            $bytes *= 1024;\n        }\n        return (int)$bytes;\n    }\n\n    /**\n     * Function for static version numbers on files, based on the filemtime\n     *\n     * This will make the filename automatically change when a file is\n     * changed, and by that re-cached by the browser. If the file does not\n     * exist physically the original file passed to the function is\n     * returned without the timestamp.\n     *\n     * Behaviour is influenced by the setting\n     * TYPO3_CONF_VARS['BE' and 'FE'][versionNumberInFilename]\n     * = TRUE (BE) / \"embed\" (FE) : modify filename\n     * = FALSE (BE) / \"querystring\" (FE) : add timestamp as parameter\n     *\n     * @param string $file Relative path to file including all potential query parameters (not htmlspecialchared yet)\n     * @return string Relative path with version filename including the timestamp\n     */\n    public static function createVersionNumberedFilename($file)\n    {\n        $isFrontend = ($GLOBALS['TYPO3_REQUEST'] ?? null) instanceof ServerRequestInterface\n            && ApplicationType::fromRequest($GLOBALS['TYPO3_REQUEST'])->isFrontend();\n        $lookupFile = explode('?', $file);\n        $path = $lookupFile[0];\n\n        // @todo: in v12 this should be resolved by using Environment::getPublicPath() once\n        if ($isFrontend) {\n            // Frontend should still allow /static/myfile.css - see #98106\n            // This should happen regardless of the incoming path is absolute or not\n            $path = self::resolveBackPath(self::dirname(Environment::getCurrentScript()) . '/' . $path);\n        } elseif (!PathUtility::isAbsolutePath($path)) {\n            // Backend and non-absolute path\n            $path = self::resolveBackPath(self::dirname(Environment::getCurrentScript()) . '/' . $path);\n        }\n\n        $doNothing = false;\n\n        if ($isFrontend) {\n            $mode = strtolower($GLOBALS['TYPO3_CONF_VARS']['FE']['versionNumberInFilename']);\n            if ($mode === 'embed') {\n                $mode = true;\n            } else {\n                if ($mode === 'querystring') {\n                    $mode = false;\n                } else {\n                    $doNothing = true;\n                }\n            }\n        } else {\n            $mode = $GLOBALS['TYPO3_CONF_VARS']['BE']['versionNumberInFilename'];\n        }\n        try {\n            $fileExists = file_exists($path);\n        } catch (\\Throwable $e) {\n            $fileExists = false;\n        }\n        if ($doNothing || !$fileExists) {\n            // File not found, return filename unaltered\n            $fullName = $file;\n        } else {\n            if (!$mode) {\n                // If use of .htaccess rule is not configured,\n                // we use the default query-string method\n                if (!empty($lookupFile[1])) {\n                    $separator = '&';\n                } else {\n                    $separator = '?';\n                }\n                $fullName = $file . $separator . filemtime($path);\n            } else {\n                // Change the filename\n                $name = explode('.', $lookupFile[0]);\n                $extension = array_pop($name);\n                array_push($name, filemtime($path), $extension);\n                $fullName = implode('.', $name);\n                // Append potential query string\n                $fullName .= !empty($lookupFile[1]) ? '?' . $lookupFile[1] : '';\n            }\n        }\n        return $fullName;\n    }\n\n    /**\n     * Writes string to a temporary file named after the md5-hash of the string\n     * Quite useful for extensions adding their custom built JavaScript during runtime.\n     *\n     * @param string $content JavaScript to write to file.\n     * @return string filename to include in the <script> tag\n     */\n    public static function writeJavaScriptContentToTemporaryFile(string $content)\n    {\n        $script = 'typo3temp/assets/js/' . md5($content) . '.js';\n        if (!@is_file(Environment::getPublicPath() . '/' . $script)) {\n            self::writeFileToTypo3tempDir(Environment::getPublicPath() . '/' . $script, $content);\n        }\n        return $script;\n    }\n\n    /**\n     * Writes string to a temporary file named after the md5-hash of the string\n     * Quite useful for extensions adding their custom built StyleSheet during runtime.\n     *\n     * @param string $content CSS styles to write to file.\n     * @return string filename to include in the <link> tag\n     */\n    public static function writeStyleSheetContentToTemporaryFile(string $content)\n    {\n        $script = 'typo3temp/assets/css/' . md5($content) . '.css';\n        if (!@is_file(Environment::getPublicPath() . '/' . $script)) {\n            self::writeFileToTypo3tempDir(Environment::getPublicPath() . '/' . $script, $content);\n        }\n        return $script;\n    }\n\n    /*************************\n     *\n     * SYSTEM INFORMATION\n     *\n     *************************/\n\n    /**\n     * Returns the link-url to the current script.\n     * In $getParams you can set associative keys corresponding to the GET-vars you wish to add to the URL. If you set them empty, they will remove existing GET-vars from the current URL.\n     * REMEMBER to always use htmlspecialchars() for content in href-properties to get ampersands converted to entities (XHTML requirement and XSS precaution)\n     *\n     * @param array $getParams Array of GET parameters to include\n     * @return string\n     */\n    public static function linkThisScript(array $getParams = [])\n    {\n        $parts = self::getIndpEnv('SCRIPT_NAME');\n        $params = self::_GET();\n        foreach ($getParams as $key => $value) {\n            if ($value !== '') {\n                $params[$key] = $value;\n            } else {\n                unset($params[$key]);\n            }\n        }\n        $pString = self::implodeArrayForUrl('', $params);\n        return $pString ? $parts . '?' . ltrim($pString, '&') : $parts;\n    }\n\n    /**\n     * This method is only for testing and should never be used outside tests.\n     *\n     * @param non-empty-string $envName\n     * @param string|bool|array<string, string|bool|null>|null $value\n     * @internal\n     */\n    public static function setIndpEnv($envName, $value)\n    {\n        self::$indpEnvCache[$envName] = $value;\n    }\n\n    /**\n     * Abstraction method which returns System Environment Variables regardless of server OS, CGI/MODULE version etc. Basically this is SERVER variables for most of them.\n     * This should be used instead of getEnv() and $_SERVER/ENV_VARS to get reliable values for all situations.\n     *\n     * @param string $getEnvName Name of the \"environment variable\"/\"server variable\" you wish to use. Valid values are SCRIPT_NAME, SCRIPT_FILENAME, REQUEST_URI, PATH_INFO, REMOTE_ADDR, REMOTE_HOST, HTTP_REFERER, HTTP_HOST, HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, QUERY_STRING, TYPO3_DOCUMENT_ROOT, TYPO3_HOST_ONLY, TYPO3_HOST_ONLY, TYPO3_REQUEST_HOST, TYPO3_REQUEST_URL, TYPO3_REQUEST_SCRIPT, TYPO3_REQUEST_DIR, TYPO3_SITE_URL, _ARRAY\n     * @return string|bool|array<string, string|bool|null>|null Value based on the input key, independent of server/OS environment.\n     * @throws \\UnexpectedValueException\n     */\n    public static function getIndpEnv($getEnvName)\n    {\n        if (array_key_exists($getEnvName, self::$indpEnvCache)) {\n            return self::$indpEnvCache[$getEnvName];\n        }\n\n        /*\n        Conventions:\n        output from parse_url():\n        URL:\thttp://username:password@192.168.1.4:8080/typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/?arg1,arg2,arg3&p1=parameter1&p2[key]=value#link1\n        [scheme] => 'http'\n        [user] => 'username'\n        [pass] => 'password'\n        [host] => '192.168.1.4'\n        [port] => '8080'\n        [path] => '/typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/'\n        [query] => 'arg1,arg2,arg3&p1=parameter1&p2[key]=value'\n        [fragment] => 'link1'Further definition: [path_script] = '/typo3/32/temp/phpcheck/index.php'\n        [path_dir] = '/typo3/32/temp/phpcheck/'\n        [path_info] = '/arg1/arg2/arg3/'\n        [path] = [path_script/path_dir][path_info]Keys supported:URI______:\n        REQUEST_URI\t\t=\t[path]?[query]\t\t= /typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/?arg1,arg2,arg3&p1=parameter1&p2[key]=value\n        HTTP_HOST\t\t=\t[host][:[port]]\t\t= 192.168.1.4:8080\n        SCRIPT_NAME\t\t=\t[path_script]++\t\t= /typo3/32/temp/phpcheck/index.php\t\t// NOTICE THAT SCRIPT_NAME will return the php-script name ALSO. [path_script] may not do that (eg. '/somedir/' may result in SCRIPT_NAME '/somedir/index.php')!\n        PATH_INFO\t\t=\t[path_info]\t\t\t= /arg1/arg2/arg3/\n        QUERY_STRING\t=\t[query]\t\t\t\t= arg1,arg2,arg3&p1=parameter1&p2[key]=value\n        HTTP_REFERER\t=\t[scheme]://[host][:[port]][path]\t= http://192.168.1.4:8080/typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/?arg1,arg2,arg3&p1=parameter1&p2[key]=value\n        (Notice: NO username/password + NO fragment)CLIENT____:\n        REMOTE_ADDR\t\t=\t(client IP)\n        REMOTE_HOST\t\t=\t(client host)\n        HTTP_USER_AGENT\t=\t(client user agent)\n        HTTP_ACCEPT_LANGUAGE\t= (client accept language)SERVER____:\n        SCRIPT_FILENAME\t=\tAbsolute filename of script\t\t(Differs between windows/unix). On windows 'C:\\\\some\\\\path\\\\' will be converted to 'C:/some/path/'Special extras:\n        TYPO3_HOST_ONLY =\t\t[host] = 192.168.1.4\n        TYPO3_PORT =\t\t\t[port] = 8080 (blank if 80, taken from host value)\n        TYPO3_REQUEST_HOST = \t\t[scheme]://[host][:[port]]\n        TYPO3_REQUEST_URL =\t\t[scheme]://[host][:[port]][path]?[query] (scheme will by default be \"http\" until we can detect something different)\n        TYPO3_REQUEST_SCRIPT =  \t[scheme]://[host][:[port]][path_script]\n        TYPO3_REQUEST_DIR =\t\t[scheme]://[host][:[port]][path_dir]\n        TYPO3_SITE_URL = \t\t[scheme]://[host][:[port]][path_dir] of the TYPO3 website frontend\n        TYPO3_SITE_PATH = \t\t[path_dir] of the TYPO3 website frontend\n        TYPO3_SITE_SCRIPT = \t\t[script / Speaking URL] of the TYPO3 website\n        TYPO3_DOCUMENT_ROOT =\t\tAbsolute path of root of documents: TYPO3_DOCUMENT_ROOT.SCRIPT_NAME = SCRIPT_FILENAME (typically)\n        TYPO3_SSL = \t\t\tReturns TRUE if this session uses SSL/TLS (https)\n        TYPO3_PROXY = \t\t\tReturns TRUE if this session runs over a well known proxyNotice: [fragment] is apparently NEVER available to the script!Testing suggestions:\n        - Output all the values.\n        - In the script, make a link to the script it self, maybe add some parameters and click the link a few times so HTTP_REFERER is seen\n        - ALSO TRY the script from the ROOT of a site (like 'http://www.mytest.com/' and not 'http://www.mytest.com/test/' !!)\n         */\n        $retVal = '';\n        switch ((string)$getEnvName) {\n            case 'SCRIPT_NAME':\n                $retVal = Environment::isRunningOnCgiServer()\n                    && (($_SERVER['ORIG_PATH_INFO'] ?? false) ?: ($_SERVER['PATH_INFO'] ?? false))\n                        ? (($_SERVER['ORIG_PATH_INFO'] ?? '') ?: ($_SERVER['PATH_INFO'] ?? ''))\n                        : (($_SERVER['ORIG_SCRIPT_NAME'] ?? '') ?: ($_SERVER['SCRIPT_NAME'] ?? ''));\n                // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n                if (self::cmpIP($_SERVER['REMOTE_ADDR'] ?? '', $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'] ?? '')) {\n                    if (self::getIndpEnv('TYPO3_SSL') && $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL'] . $retVal;\n                    } elseif ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix'] . $retVal;\n                    }\n                }\n                break;\n            case 'SCRIPT_FILENAME':\n                $retVal = Environment::getCurrentScript();\n                break;\n            case 'REQUEST_URI':\n                // Typical application of REQUEST_URI is return urls, forms submitting to itself etc. Example: returnUrl='.rawurlencode(\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::getIndpEnv('REQUEST_URI'))\n                if (!empty($GLOBALS['TYPO3_CONF_VARS']['SYS']['requestURIvar'])) {\n                    // This is for URL rewriters that store the original URI in a server variable (eg ISAPI_Rewriter for IIS: HTTP_X_REWRITE_URL)\n                    [$v, $n] = explode('|', $GLOBALS['TYPO3_CONF_VARS']['SYS']['requestURIvar']);\n                    $retVal = $GLOBALS[$v][$n];\n                } elseif (empty($_SERVER['REQUEST_URI'])) {\n                    // This is for ISS/CGI which does not have the REQUEST_URI available.\n                    $retVal = '/' . ltrim(self::getIndpEnv('SCRIPT_NAME'), '/') . (!empty($_SERVER['QUERY_STRING']) ? '?' . $_SERVER['QUERY_STRING'] : '');\n                } else {\n                    $retVal = '/' . ltrim($_SERVER['REQUEST_URI'], '/');\n                }\n                // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n                if (isset($_SERVER['REMOTE_ADDR'], $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'])\n                    && self::cmpIP($_SERVER['REMOTE_ADDR'], $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'])\n                ) {\n                    if (self::getIndpEnv('TYPO3_SSL') && $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL'] . $retVal;\n                    } elseif ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix'] . $retVal;\n                    }\n                }\n                break;\n            case 'PATH_INFO':\n                // $_SERVER['PATH_INFO'] != $_SERVER['SCRIPT_NAME'] is necessary because some servers (Windows/CGI)\n                // are seen to set PATH_INFO equal to script_name\n                // Further, there must be at least one '/' in the path - else the PATH_INFO value does not make sense.\n                // IF 'PATH_INFO' never works for our purpose in TYPO3 with CGI-servers,\n                // then 'PHP_SAPI=='cgi'' might be a better check.\n                // Right now strcmp($_SERVER['PATH_INFO'], GeneralUtility::getIndpEnv('SCRIPT_NAME')) will always\n                // return FALSE for CGI-versions, but that is only as long as SCRIPT_NAME is set equal to PATH_INFO\n                // because of PHP_SAPI=='cgi' (see above)\n                if (!Environment::isRunningOnCgiServer()) {\n                    $retVal = $_SERVER['PATH_INFO'] ?? '';\n                }\n                break;\n            case 'TYPO3_REV_PROXY':\n                $retVal = self::cmpIP($_SERVER['REMOTE_ADDR'] ?? '', $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP']);\n                break;\n            case 'REMOTE_ADDR':\n                $retVal = $_SERVER['REMOTE_ADDR'] ?? '';\n                if (self::cmpIP($retVal, $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'] ?? '')) {\n                    $ip = self::trimExplode(',', $_SERVER['HTTP_X_FORWARDED_FOR'] ?? '');\n                    // Choose which IP in list to use\n                    if (!empty($ip)) {\n                        switch ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyHeaderMultiValue']) {\n                            case 'last':\n                                $ip = array_pop($ip);\n                                break;\n                            case 'first':\n                                $ip = array_shift($ip);\n                                break;\n                            case 'none':\n\n                            default:\n                                $ip = '';\n                        }\n                    }\n                    if (self::validIP((string)$ip)) {\n                        $retVal = $ip;\n                    }\n                }\n                break;\n            case 'HTTP_HOST':\n                // if it is not set we're most likely on the cli\n                $retVal = $_SERVER['HTTP_HOST'] ?? '';\n                if (isset($_SERVER['REMOTE_ADDR']) && static::cmpIP($_SERVER['REMOTE_ADDR'], $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'])) {\n                    $host = self::trimExplode(',', $_SERVER['HTTP_X_FORWARDED_HOST'] ?? '');\n                    // Choose which host in list to use\n                    if (!empty($host)) {\n                        switch ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyHeaderMultiValue']) {\n                            case 'last':\n                                $host = array_pop($host);\n                                break;\n                            case 'first':\n                                $host = array_shift($host);\n                                break;\n                            case 'none':\n\n                            default:\n                                $host = '';\n                        }\n                    }\n                    if ($host) {\n                        $retVal = $host;\n                    }\n                }\n                break;\n            case 'HTTP_REFERER':\n\n            case 'HTTP_USER_AGENT':\n\n            case 'HTTP_ACCEPT_ENCODING':\n\n            case 'HTTP_ACCEPT_LANGUAGE':\n\n            case 'REMOTE_HOST':\n\n            case 'QUERY_STRING':\n                $retVal = $_SERVER[$getEnvName] ?? '';\n                break;\n            case 'TYPO3_DOCUMENT_ROOT':\n                // Get the web root (it is not the root of the TYPO3 installation)\n                // The absolute path of the script can be calculated with TYPO3_DOCUMENT_ROOT + SCRIPT_FILENAME\n                // Some CGI-versions (LA13CGI) and mod-rewrite rules on MODULE versions will deliver a 'wrong' DOCUMENT_ROOT (according to our description). Further various aliases/mod_rewrite rules can disturb this as well.\n                // Therefore the DOCUMENT_ROOT is now always calculated as the SCRIPT_FILENAME minus the end part shared with SCRIPT_NAME.\n                $SFN = self::getIndpEnv('SCRIPT_FILENAME');\n                $SN_A = explode('/', strrev(self::getIndpEnv('SCRIPT_NAME')));\n                $SFN_A = explode('/', strrev($SFN));\n                $acc = [];\n                foreach ($SN_A as $kk => $vv) {\n                    if ((string)$SFN_A[$kk] === (string)$vv) {\n                        $acc[] = $vv;\n                    } else {\n                        break;\n                    }\n                }\n                $commonEnd = strrev(implode('/', $acc));\n                if ((string)$commonEnd !== '') {\n                    $retVal = substr($SFN, 0, -(strlen($commonEnd) + 1));\n                }\n                break;\n            case 'TYPO3_HOST_ONLY':\n                $httpHost = self::getIndpEnv('HTTP_HOST');\n                $httpHostBracketPosition = strpos($httpHost, ']');\n                $httpHostParts = explode(':', $httpHost);\n                $retVal = $httpHostBracketPosition !== false ? substr($httpHost, 0, $httpHostBracketPosition + 1) : array_shift($httpHostParts);\n                break;\n            case 'TYPO3_PORT':\n                $httpHost = self::getIndpEnv('HTTP_HOST');\n                $httpHostOnly = self::getIndpEnv('TYPO3_HOST_ONLY');\n                $retVal = strlen($httpHost) > strlen($httpHostOnly) ? substr($httpHost, strlen($httpHostOnly) + 1) : '';\n                break;\n            case 'TYPO3_REQUEST_HOST':\n                $retVal = (self::getIndpEnv('TYPO3_SSL') ? 'https://' : 'http://') . self::getIndpEnv('HTTP_HOST');\n                break;\n            case 'TYPO3_REQUEST_URL':\n                $retVal = self::getIndpEnv('TYPO3_REQUEST_HOST') . self::getIndpEnv('REQUEST_URI');\n                break;\n            case 'TYPO3_REQUEST_SCRIPT':\n                $retVal = self::getIndpEnv('TYPO3_REQUEST_HOST') . self::getIndpEnv('SCRIPT_NAME');\n                break;\n            case 'TYPO3_REQUEST_DIR':\n                $retVal = self::getIndpEnv('TYPO3_REQUEST_HOST') . self::dirname(self::getIndpEnv('SCRIPT_NAME')) . '/';\n                break;\n            case 'TYPO3_SITE_URL':\n                if (Environment::getCurrentScript()) {\n                    $lPath = PathUtility::stripPathSitePrefix(PathUtility::dirnameDuringBootstrap(Environment::getCurrentScript())) . '/';\n                    $url = self::getIndpEnv('TYPO3_REQUEST_DIR');\n                    $siteUrl = substr($url, 0, -strlen($lPath));\n                    if (substr($siteUrl, -1) !== '/') {\n                        $siteUrl .= '/';\n                    }\n                    $retVal = $siteUrl;\n                }\n                break;\n            case 'TYPO3_SITE_PATH':\n                $retVal = substr(self::getIndpEnv('TYPO3_SITE_URL'), strlen(self::getIndpEnv('TYPO3_REQUEST_HOST')));\n                break;\n            case 'TYPO3_SITE_SCRIPT':\n                $retVal = substr(self::getIndpEnv('TYPO3_REQUEST_URL'), strlen(self::getIndpEnv('TYPO3_SITE_URL')));\n                break;\n            case 'TYPO3_SSL':\n                $proxySSL = trim($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxySSL'] ?? '');\n                if ($proxySSL === '*') {\n                    $proxySSL = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'];\n                }\n                if (self::cmpIP($_SERVER['REMOTE_ADDR'] ?? '', $proxySSL)) {\n                    $retVal = true;\n                } else {\n                    $retVal = self::webserverUsesHttps();\n                }\n                break;\n            case '_ARRAY':\n                $out = [];\n                // Here, list ALL possible keys to this function for debug display.\n                $envTestVars = [\n                    'HTTP_HOST',\n                    'TYPO3_HOST_ONLY',\n                    'TYPO3_PORT',\n                    'PATH_INFO',\n                    'QUERY_STRING',\n                    'REQUEST_URI',\n                    'HTTP_REFERER',\n                    'TYPO3_REQUEST_HOST',\n                    'TYPO3_REQUEST_URL',\n                    'TYPO3_REQUEST_SCRIPT',\n                    'TYPO3_REQUEST_DIR',\n                    'TYPO3_SITE_URL',\n                    'TYPO3_SITE_SCRIPT',\n                    'TYPO3_SSL',\n                    'TYPO3_REV_PROXY',\n                    'SCRIPT_NAME',\n                    'TYPO3_DOCUMENT_ROOT',\n                    'SCRIPT_FILENAME',\n                    'REMOTE_ADDR',\n                    'REMOTE_HOST',\n                    'HTTP_USER_AGENT',\n                    'HTTP_ACCEPT_LANGUAGE',\n                ];\n                foreach ($envTestVars as $v) {\n                    $out[$v] = self::getIndpEnv($v);\n                }\n                reset($out);\n                $retVal = $out;\n                break;\n        }\n        self::$indpEnvCache[$getEnvName] = $retVal;\n        return $retVal;\n    }\n\n    /**\n     * Determine if the webserver uses HTTPS.\n     *\n     * HEADS UP: This does not check if the client performed a\n     * HTTPS request, as possible proxies are not taken into\n     * account. It provides raw information about the current\n     * webservers configuration only.\n     *\n     * @return bool\n     */\n    protected static function webserverUsesHttps()\n    {\n        if (!empty($_SERVER['SSL_SESSION_ID'])) {\n            return true;\n        }\n\n        // https://secure.php.net/manual/en/reserved.variables.server.php\n        // \"Set to a non-empty value if the script was queried through the HTTPS protocol.\"\n        return !empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off';\n    }\n\n    /*************************\n     *\n     * TYPO3 SPECIFIC FUNCTIONS\n     *\n     *************************/\n    /**\n     * Returns the absolute filename of a relative reference, resolves the \"EXT:\" prefix\n     * (way of referring to files inside extensions) and checks that the file is inside\n     * the TYPO3's base folder and implies a check with\n     * \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::validPathStr().\n     *\n     * @param string $filename The input filename/filepath to evaluate\n     * @return string Returns the absolute filename of $filename if valid, otherwise blank string.\n     */\n    public static function getFileAbsFileName($filename)\n    {\n        if ((string)$filename === '') {\n            return '';\n        }\n        // Extension\n        if (PathUtility::isExtensionPath($filename)) {\n            try {\n                $filename = ExtensionManagementUtility::resolvePackagePath($filename);\n            } catch (PackageException $e) {\n                $filename = '';\n            }\n        } elseif (!PathUtility::isAbsolutePath($filename)) {\n            // is relative. Prepended with the public web folder\n            $filename = Environment::getPublicPath() . '/' . $filename;\n        } elseif (!(\n            str_starts_with($filename, Environment::getProjectPath())\n                  || str_starts_with($filename, Environment::getPublicPath())\n        )) {\n            // absolute, but set to blank if not allowed\n            $filename = '';\n        }\n        if ((string)$filename !== '' && static::validPathStr($filename)) {\n            // checks backpath.\n            return $filename;\n        }\n        return '';\n    }\n\n    /**\n     * Checks for malicious file paths.\n     *\n     * Returns TRUE if no '//', '..', '\\' or control characters are found in the $theFile.\n     * This should make sure that the path is not pointing 'backwards' and further doesn't contain double/back slashes.\n     * So it's compatible with the UNIX style path strings valid for TYPO3 internally.\n     *\n     * @param string $theFile File path to evaluate\n     * @return bool TRUE, $theFile is allowed path string, FALSE otherwise\n     * @see https://php.net/manual/en/security.filesystem.nullbytes.php\n     */\n    public static function validPathStr($theFile)\n    {\n        return !str_contains($theFile, '//') && !str_contains($theFile, '\\\\')\n            && preg_match('#(?:^\\\\.\\\\.|/\\\\.\\\\./|[[:cntrl:]])#u', $theFile) === 0;\n    }\n\n    /**\n     * Returns TRUE if the path is absolute, without backpath '..' and within TYPO3s project or public folder OR within the lockRootPath\n     *\n     * @param string $path File path to evaluate\n     * @return bool\n     */\n    public static function isAllowedAbsPath($path)\n    {\n        if (substr($path, 0, 6) === 'vfs://') {\n            return true;\n        }\n        $lockRootPath = $GLOBALS['TYPO3_CONF_VARS']['BE']['lockRootPath'] ?? '';\n        return PathUtility::isAbsolutePath($path) && static::validPathStr($path)\n            && (\n                str_starts_with($path, Environment::getProjectPath())\n                || str_starts_with($path, Environment::getPublicPath())\n                || ($lockRootPath && str_starts_with($path, $lockRootPath))\n            );\n    }\n\n    /**\n     * Low level utility function to copy directories and content recursive\n     *\n     * @param string $source Path to source directory, relative to document root or absolute\n     * @param string $destination Path to destination directory, relative to document root or absolute\n     */\n    public static function copyDirectory($source, $destination)\n    {\n        if (!str_contains($source, Environment::getProjectPath() . '/')) {\n            $source = Environment::getPublicPath() . '/' . $source;\n        }\n        if (!str_contains($destination, Environment::getProjectPath() . '/')) {\n            $destination = Environment::getPublicPath() . '/' . $destination;\n        }\n        if (static::isAllowedAbsPath($source) && static::isAllowedAbsPath($destination)) {\n            static::mkdir_deep($destination);\n            $iterator = new \\RecursiveIteratorIterator(\n                new \\RecursiveDirectoryIterator($source, \\RecursiveDirectoryIterator::SKIP_DOTS),\n                \\RecursiveIteratorIterator::SELF_FIRST\n            );\n            /** @var \\SplFileInfo $item */\n            foreach ($iterator as $item) {\n                $target = $destination . '/' . static::fixWindowsFilePath($iterator->getSubPathName());\n                if ($item->isDir()) {\n                    static::mkdir($target);\n                } else {\n                    static::upload_copy_move(static::fixWindowsFilePath($item->getPathname()), $target);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if a given string is a valid frame URL to be loaded in the\n     * backend.\n     *\n     * If the given url is empty or considered to be harmless, it is returned\n     * as is, else the event is logged and an empty string is returned.\n     *\n     * @param string $url potential URL to check\n     * @return string $url or empty string\n     */\n    public static function sanitizeLocalUrl($url = '')\n    {\n        $sanitizedUrl = '';\n        if (!empty($url)) {\n            $decodedUrl = rawurldecode($url);\n            $parsedUrl = parse_url($decodedUrl);\n            $testAbsoluteUrl = self::resolveBackPath($decodedUrl);\n            $testRelativeUrl = self::resolveBackPath(self::dirname(self::getIndpEnv('SCRIPT_NAME')) . '/' . $decodedUrl);\n            // Pass if URL is on the current host:\n            if (self::isValidUrl($decodedUrl)) {\n                if (self::isOnCurrentHost($decodedUrl) && str_starts_with($decodedUrl, self::getIndpEnv('TYPO3_SITE_URL'))) {\n                    $sanitizedUrl = $url;\n                }\n            } elseif (PathUtility::isAbsolutePath($decodedUrl) && self::isAllowedAbsPath($decodedUrl)) {\n                $sanitizedUrl = $url;\n            } elseif (str_starts_with($testAbsoluteUrl, self::getIndpEnv('TYPO3_SITE_PATH')) && $decodedUrl[0] === '/' &&\n                substr($decodedUrl, 0, 2) !== '//'\n            ) {\n                $sanitizedUrl = $url;\n            } elseif (empty($parsedUrl['scheme']) && str_starts_with($testRelativeUrl, self::getIndpEnv('TYPO3_SITE_PATH'))\n                && $decodedUrl[0] !== '/' && strpbrk($decodedUrl, '*:|\"<>') === false && !str_contains($decodedUrl, '\\\\\\\\')\n            ) {\n                $sanitizedUrl = $url;\n            }\n        }\n        if (!empty($url) && empty($sanitizedUrl)) {\n            static::getLogger()->notice('The URL \"{url}\" is not considered to be local and was denied.', ['url' => $url]);\n        }\n        return $sanitizedUrl;\n    }\n\n    /**\n     * Moves $source file to $destination if uploaded, otherwise try to make a copy\n     *\n     * @param string $source Source file, absolute path\n     * @param string $destination Destination file, absolute path\n     * @return bool Returns TRUE if the file was moved.\n     * @see upload_to_tempfile()\n     */\n    public static function upload_copy_move($source, $destination)\n    {\n        if (is_array($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] ?? null)) {\n            $params = ['source' => $source, 'destination' => $destination, 'method' => 'upload_copy_move'];\n            foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] as $hookMethod) {\n                $fakeThis = null;\n                self::callUserFunction($hookMethod, $params, $fakeThis);\n            }\n        }\n\n        $result = false;\n        if (is_uploaded_file($source)) {\n            // Return the value of move_uploaded_file, and if FALSE the temporary $source is still\n            // around so the user can use unlink to delete it:\n            $result = move_uploaded_file($source, $destination);\n        } else {\n            @copy($source, $destination);\n        }\n        // Change the permissions of the file\n        self::fixPermissions($destination);\n        // If here the file is copied and the temporary $source is still around,\n        // so when returning FALSE the user can try unlink to delete the $source\n        return $result;\n    }\n\n    /**\n     * Will move an uploaded file (normally in \"/tmp/xxxxx\") to a temporary filename in Environment::getProjectPath() . \"var/\" from where TYPO3 can use it.\n     * Use this function to move uploaded files to where you can work on them.\n     * REMEMBER to use \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::unlink_tempfile() afterwards - otherwise temp-files will build up! They are NOT automatically deleted in the temporary folder!\n     *\n     * @param string $uploadedFileName The temporary uploaded filename, eg. $_FILES['[upload field name here]']['tmp_name']\n     * @return string If a new file was successfully created, return its filename, otherwise blank string.\n     * @see unlink_tempfile()\n     * @see upload_copy_move()\n     */\n    public static function upload_to_tempfile($uploadedFileName)\n    {\n        if (is_uploaded_file($uploadedFileName)) {\n            $tempFile = self::tempnam('upload_temp_');\n            if (is_array($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] ?? null)) {\n                $params = ['source' => $uploadedFileName, 'destination' => $tempFile, 'method' => 'upload_to_tempfile'];\n                foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] as $hookMethod) {\n                    $fakeThis = null;\n                    self::callUserFunction($hookMethod, $params, $fakeThis);\n                }\n            }\n\n            move_uploaded_file($uploadedFileName, $tempFile);\n            return @is_file($tempFile) ? $tempFile : '';\n        }\n\n        return '';\n    }\n\n    /**\n     * Deletes (unlink) a temporary filename in the var/ or typo3temp folder given as input.\n     * The function will check that the file exists, is within TYPO3's var/ or typo3temp/ folder and does not contain back-spaces (\"../\") so it should be pretty safe.\n     * Use this after upload_to_tempfile() or tempnam() from this class!\n     *\n     * @param string $uploadedTempFileName absolute file path - must reside within var/ or typo3temp/ folder.\n     * @return bool|null Returns TRUE if the file was unlink()'ed\n     * @see upload_to_tempfile()\n     * @see tempnam()\n     */\n    public static function unlink_tempfile($uploadedTempFileName)\n    {\n        if ($uploadedTempFileName) {\n            $uploadedTempFileName = self::fixWindowsFilePath($uploadedTempFileName);\n            if (\n                self::validPathStr($uploadedTempFileName)\n                && (\n                    str_starts_with($uploadedTempFileName, Environment::getPublicPath() . '/typo3temp/')\n                    || str_starts_with($uploadedTempFileName, Environment::getVarPath() . '/')\n                )\n                && @is_file($uploadedTempFileName)\n            ) {\n                if (unlink($uploadedTempFileName)) {\n                    return true;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Create temporary filename (Create file with unique file name)\n     * This function should be used for getting temporary file names - will make your applications safe for open_basedir = on\n     * REMEMBER to delete the temporary files after use! This is done by \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::unlink_tempfile()\n     *\n     * @param string $filePrefix Prefix for temporary file\n     * @param string $fileSuffix Suffix for temporary file, for example a special file extension\n     * @return non-empty-string result from PHP function `tempnam()` with the temp/var folder prefixed.\n     * @see unlink_tempfile()\n     * @see upload_to_tempfile()\n     */\n    public static function tempnam($filePrefix, $fileSuffix = '')\n    {\n        $temporaryPath = Environment::getVarPath() . '/transient/';\n        if (!is_dir($temporaryPath)) {\n            self::mkdir_deep($temporaryPath);\n        }\n        if ($fileSuffix === '') {\n            $path = (string)tempnam($temporaryPath, $filePrefix);\n            $tempFileName = $temporaryPath . PathUtility::basename($path);\n        } else {\n            do {\n                $tempFileName = $temporaryPath . $filePrefix . random_int(1, PHP_INT_MAX) . $fileSuffix;\n            } while (file_exists($tempFileName));\n            touch($tempFileName);\n            clearstatcache(false, $tempFileName);\n        }\n        return $tempFileName;\n    }\n\n    /**\n     * Calls a user-defined function/method in class\n     * Such a function/method should look like this: \"function proc(&$params, &$ref) {...}\"\n     *\n     * @param non-empty-string|\\Closure $funcName Function/Method reference or Closure.\n     * @param mixed $params Parameters to be pass along (typically an array) (REFERENCE!)\n     * @param object|null $ref Reference to be passed along (typically \"$this\" - being a reference to the calling object)\n     * @return mixed Content from method/function call\n     * @throws \\InvalidArgumentException\n     */\n    public static function callUserFunction($funcName, &$params, ?object $ref = null)\n    {\n        // Check if we're using a closure and invoke it directly.\n        if (is_object($funcName) && is_a($funcName, \\Closure::class)) {\n            return call_user_func_array($funcName, [&$params, &$ref]);\n        }\n        $funcName = trim($funcName);\n        $parts = explode('->', $funcName);\n        // Call function or method\n        if (count($parts) === 2) {\n            // It's a class/method\n            // Check if class/method exists:\n            if (class_exists($parts[0])) {\n                // Create object\n                $classObj = self::makeInstance($parts[0]);\n                $methodName = (string)$parts[1];\n                $callable = [$classObj, $methodName];\n                if (is_callable($callable)) {\n                    // Call method:\n                    $content = call_user_func_array($callable, [&$params, &$ref]);\n                } else {\n                    throw new \\InvalidArgumentException('No method name \\'' . $parts[1] . '\\' in class ' . $parts[0], 1294585865);\n                }\n            } else {\n                throw new \\InvalidArgumentException('No class named ' . $parts[0], 1294585866);\n            }\n        } elseif (function_exists($funcName) && is_callable($funcName)) {\n            // It's a function\n            $content = call_user_func_array($funcName, [&$params, &$ref]);\n        } else {\n            // Usually this will be annotated by static code analysis tools, but there's no native \"not empty string\" type\n            throw new \\InvalidArgumentException('No function named: ' . $funcName, 1294585867);\n        }\n        return $content;\n    }\n\n    /**\n     * @internal\n     */\n    public static function setContainer(ContainerInterface $container): void\n    {\n        self::$container = $container;\n    }\n\n    /**\n     * @internal\n     */\n    public static function getContainer(): ContainerInterface\n    {\n        if (self::$container === null) {\n            throw new \\LogicException('PSR-11 Container is not available', 1549404144);\n        }\n        return self::$container;\n    }\n\n    /**\n     * Creates an instance of a class taking into account the class-extensions\n     * API of TYPO3. USE THIS method instead of the PHP `new` keyword.\n     * For example, `$obj = new myclass;` should be\n     * `$obj = \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::makeInstance(\"myclass\")` instead.\n     *\n     * You can also pass arguments for a constructor:\n     * `GeneralUtility::makeInstance(\\myClass::class, $arg1, $arg2, ..., $argN)`\n     *\n     * @template T of object\n     * @param class-string<T> $className name of the class to instantiate, must not be empty and not start with a backslash\n     * @param array<int, mixed> $constructorArguments Arguments for the constructor\n     * @return T the created instance\n     * @throws \\InvalidArgumentException if $className is empty or starts with a backslash\n     */\n    public static function makeInstance($className, ...$constructorArguments)\n    {\n        // PHPStan will complain about this check. That's okay as we're checking a contract violation here.\n        if (!is_string($className) || empty($className)) {\n            throw new \\InvalidArgumentException('$className must be a non empty string.', 1288965219);\n        }\n        // Never instantiate with a beginning backslash, otherwise things like singletons won't work.\n        if ($className[0] === '\\\\') {\n            throw new \\InvalidArgumentException(\n                '$className \"' . $className . '\" must not start with a backslash.',\n                1420281366\n            );\n        }\n        if (isset(static::$finalClassNameCache[$className])) {\n            $finalClassName = static::$finalClassNameCache[$className];\n        } else {\n            $finalClassName = self::getClassName($className);\n            static::$finalClassNameCache[$className] = $finalClassName;\n        }\n        // Return singleton instance if it is already registered\n        if (isset(self::$singletonInstances[$finalClassName])) {\n            return self::$singletonInstances[$finalClassName];\n        }\n        // Return instance if it has been injected by addInstance()\n        if (\n            isset(self::$nonSingletonInstances[$finalClassName])\n            && !empty(self::$nonSingletonInstances[$finalClassName])\n        ) {\n            return array_shift(self::$nonSingletonInstances[$finalClassName]);\n        }\n\n        // Read service and prototypes from the DI container, this is required to\n        // support classes that require dependency injection.\n        // We operate on the original class name on purpose, as class overrides\n        // are resolved inside the container\n        if (self::$container !== null && $constructorArguments === [] && self::$container->has($className)) {\n            return self::$container->get($className);\n        }\n\n        // Create new instance and call constructor with parameters\n        $instance = new $finalClassName(...$constructorArguments);\n        // Register new singleton instance, but only if it is not a known PSR-11 container service\n        if ($instance instanceof SingletonInterface && !(self::$container !== null && self::$container->has($className))) {\n            self::$singletonInstances[$finalClassName] = $instance;\n        }\n        if ($instance instanceof LoggerAwareInterface) {\n            $instance->setLogger(static::makeInstance(LogManager::class)->getLogger($className));\n        }\n        return $instance;\n    }\n\n    /**\n     * Creates a class taking implementation settings and class aliases into account.\n     *\n     * Intended to be used to create objects by the dependency injection container.\n     *\n     * @template T of object\n     * @param class-string<T> $className name of the class to instantiate\n     * @param array<int, mixed> $constructorArguments Arguments for the constructor\n     * @return T the created instance\n     * @internal\n     */\n    public static function makeInstanceForDi(string $className, ...$constructorArguments): object\n    {\n        $finalClassName = static::$finalClassNameCache[$className] ?? static::$finalClassNameCache[$className] = self::getClassName($className);\n\n        // Return singleton instance if it is already registered (currently required for unit and functional tests)\n        if (isset(self::$singletonInstances[$finalClassName])) {\n            return self::$singletonInstances[$finalClassName];\n        }\n        // Create new instance and call constructor with parameters\n        return new $finalClassName(...$constructorArguments);\n    }\n\n    /**\n     * Returns the class name for a new instance, taking into account\n     * registered implementations for this class\n     *\n     * @param class-string $className Base class name to evaluate\n     * @return class-string Final class name to instantiate with `new [classname]`\n     */\n    protected static function getClassName($className)\n    {\n        if (class_exists($className)) {\n            while (static::classHasImplementation($className)) {\n                $className = static::getImplementationForClass($className);\n            }\n        }\n        return ClassLoadingInformation::getClassNameForAlias($className);\n    }\n\n    /**\n     * Returns the configured implementation of the class\n     *\n     * @param class-string $className\n     * @return class-string\n     */\n    protected static function getImplementationForClass($className)\n    {\n        return $GLOBALS['TYPO3_CONF_VARS']['SYS']['Objects'][$className]['className'];\n    }\n\n    /**\n     * Checks if a class has a configured implementation\n     *\n     * @param class-string $className\n     * @return bool\n     */\n    protected static function classHasImplementation($className)\n    {\n        return !empty($GLOBALS['TYPO3_CONF_VARS']['SYS']['Objects'][$className]['className']);\n    }\n\n    /**\n     * Sets the instance of a singleton class to be returned by `makeInstance`.\n     *\n     * If this function is called multiple times for the same $className,\n     * makeInstance will return the last set instance.\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method exists mostly for unit tests to inject a mock of a singleton class.\n     * If you use this, make sure to always combine this with `getSingletonInstances()`\n     * and `resetSingletonInstances()` in setUp() and `tearDown()` of the test class.\n     *\n     * @see makeInstance\n     * @param class-string $className\n     * @internal\n     */\n    public static function setSingletonInstance($className, SingletonInterface $instance)\n    {\n        self::checkInstanceClassName($className, $instance);\n        // Check for XCLASS registration (same is done in makeInstance() in order to store the singleton of the final class name)\n        $finalClassName = self::getClassName($className);\n        self::$singletonInstances[$finalClassName] = $instance;\n    }\n\n    /**\n     * Removes the instance of a singleton class to be returned by `makeInstance`.\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method exists mostly for unit tests to inject a mock of a singleton class.\n     * If you use this, make sure to always combine this with `getSingletonInstances()`\n     * and `resetSingletonInstances()` in `setUp()` and `tearDown()` of the test class.\n     *\n     * @see makeInstance\n     * @param class-string $className\n     * @throws \\InvalidArgumentException\n     * @internal\n     */\n    public static function removeSingletonInstance($className, SingletonInterface $instance)\n    {\n        self::checkInstanceClassName($className, $instance);\n        if (!isset(self::$singletonInstances[$className])) {\n            throw new \\InvalidArgumentException('No Instance registered for ' . $className . '.', 1394099179);\n        }\n        if ($instance !== self::$singletonInstances[$className]) {\n            throw new \\InvalidArgumentException('The instance you are trying to remove has not been registered before.', 1394099256);\n        }\n        unset(self::$singletonInstances[$className]);\n    }\n\n    /**\n     * Set a group of singleton instances. Similar to `setSingletonInstance()`,\n     * but multiple instances can be set.\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method is usually only used in tests to restore the list of singletons in\n     * `tearDown()` that was backed up with `getSingletonInstances()` in `setUp()` and\n     * manipulated in tests with `setSingletonInstance()`.\n     *\n     * @internal\n     * @param array<class-string, SingletonInterface> $newSingletonInstances\n     */\n    public static function resetSingletonInstances(array $newSingletonInstances)\n    {\n        static::$singletonInstances = [];\n        foreach ($newSingletonInstances as $className => $instance) {\n            static::setSingletonInstance($className, $instance);\n        }\n    }\n\n    /**\n     * Get all currently registered singletons\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method is usually only used in tests in `setUp()` to fetch the list of\n     * currently registered singletons, if this list is manipulated with\n     * `setSingletonInstance()` in tests.\n     *\n     * @internal\n     * @return array<class-string, SingletonInterface>\n     */\n    public static function getSingletonInstances()\n    {\n        return static::$singletonInstances;\n    }\n\n    /**\n     * Get all currently registered non singleton instances\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method is only used in `UnitTestCase` base test `tearDown()` to verify tests\n     * have no left-over instances that were previously added using `addInstance()`.\n     *\n     * @internal\n     * @return array<class-string, array<object>>\n     */\n    public static function getInstances()\n    {\n        return static::$nonSingletonInstances;\n    }\n\n    /**\n     * Sets the instance of a non-singleton class to be returned by `makeInstance`.\n     *\n     * If this function is called multiple times for the same `$className`,\n     * `makeInstance` will return the instances in the order in which they have\n     * been added (FIFO).\n     *\n     * Warning: This is a helper method for unit tests. Do not call this directly in production code!\n     *\n     * @see makeInstance\n     * @param class-string $className\n     * @param object $instance\n     * @throws \\InvalidArgumentException if class extends \\TYPO3\\CMS\\Core\\SingletonInterface\n     */\n    public static function addInstance($className, $instance)\n    {\n        self::checkInstanceClassName($className, $instance);\n        if ($instance instanceof SingletonInterface) {\n            throw new \\InvalidArgumentException('$instance must not be an instance of TYPO3\\\\CMS\\\\Core\\\\SingletonInterface. For setting singletons, please use setSingletonInstance.', 1288969325);\n        }\n        if (!isset(self::$nonSingletonInstances[$className])) {\n            self::$nonSingletonInstances[$className] = [];\n        }\n        self::$nonSingletonInstances[$className][] = $instance;\n    }\n\n    /**\n     * Checks that `$className` is non-empty and that `$instance` is an instance of `$className`.\n     *\n     * @param string $className\n     * @param object $instance\n     * @throws \\InvalidArgumentException if $className is empty or if $instance is no instance of $className\n     */\n    protected static function checkInstanceClassName($className, $instance)\n    {\n        if ($className === '') {\n            throw new \\InvalidArgumentException('$className must not be empty.', 1288967479);\n        }\n        if (!$instance instanceof $className) {\n            throw new \\InvalidArgumentException('$instance must be an instance of ' . $className . ', but actually is an instance of ' . get_class($instance) . '.', 1288967686);\n        }\n    }\n\n    /**\n     * Purge all instances returned by makeInstance.\n     *\n     * This function is most useful when called from tearDown in a test case\n     * to drop any instances that have been created by the tests.\n     *\n     * Warning: This is a helper method for unit tests. Do not call this directly in production code!\n     *\n     * @see makeInstance\n     */\n    public static function purgeInstances()\n    {\n        self::$container = null;\n        self::$singletonInstances = [];\n        self::$nonSingletonInstances = [];\n    }\n\n    /**\n     * Flushes some internal runtime caches:\n     * - the class-name mapping used by `makeInstance()`\n     * - the cache for `getIndpEnv()`\n     *\n     * This function is intended to be used in unit tests to keep environment changes from spilling into the next test.\n     *\n     * @internal\n     */\n    public static function flushInternalRuntimeCaches()\n    {\n        self::$finalClassNameCache = [];\n        self::$indpEnvCache = [];\n    }\n\n    /**\n     * Find the best service and check if it works.\n     * Returns object of the service class.\n     *\n     * This method is used for the legacy ExtensionManager:addService() mechanism,\n     * not with Dependency-Injected services. In practice, all remaining core uses of\n     * this mechanism are authentication services, which all have an info property.\n     *\n     * @param string $serviceType Type of service (service key).\n     * @param string $serviceSubType Sub type like file extensions or similar. Defined by the service.\n     * @param array $excludeServiceKeys List of service keys which should be excluded in the search for a service\n     * @throws \\RuntimeException\n     * @return object|string[]|false The service object or an array with error infos, or false if no service was found.\n     */\n    public static function makeInstanceService(string $serviceType, string $serviceSubType = '', array $excludeServiceKeys = []): array|object|false\n    {\n        $error = false;\n        $requestInfo = [\n            'requestedServiceType' => $serviceType,\n            'requestedServiceSubType' => $serviceSubType,\n            'requestedExcludeServiceKeys' => $excludeServiceKeys,\n        ];\n        while ($info = ExtensionManagementUtility::findService($serviceType, $serviceSubType, $excludeServiceKeys)) {\n            // provide information about requested service to service object\n            $info = array_merge($info, $requestInfo);\n\n            /** @var class-string<AbstractAuthenticationService> $className */\n            $className = $info['className'];\n            /** @var AbstractAuthenticationService $obj */\n            $obj = self::makeInstance($className);\n            if (is_object($obj)) {\n                if (!is_callable([$obj, 'init'])) {\n                    self::getLogger()->error('Requested service {class} has no init() method.', [\n                        'class' => $info['className'],\n                        'service' => $info,\n                    ]);\n                    throw new \\RuntimeException('Broken service: ' . $info['className'], 1568119209);\n                }\n                $obj->info = $info;\n                // service available?\n                if ($obj->init()) {\n                    return $obj;\n                }\n                $error = $obj->getLastErrorArray();\n                unset($obj);\n            }\n\n            // deactivate the service\n            ExtensionManagementUtility::deactivateService($info['serviceType'], $info['serviceKey']);\n        }\n        return $error;\n    }\n\n    /**\n     * Quotes a string for usage as JS parameter.\n     *\n     * @param string $value the string to encode, may be empty\n     * @return string the encoded value already quoted (with single quotes),\n     */\n    public static function quoteJSvalue($value)\n    {\n        $json = (string)json_encode(\n            (string)$value,\n            JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_TAG\n        );\n\n        return strtr(\n            $json,\n            [\n                '\"' => '\\'',\n                '\\\\\\\\' => '\\\\u005C',\n                ' ' => '\\\\u0020',\n                '!' => '\\\\u0021',\n                '\\\\t' => '\\\\u0009',\n                '\\\\n' => '\\\\u000A',\n                '\\\\r' => '\\\\u000D',\n            ]\n        );\n    }\n\n    /**\n     * Serializes data to JSON, to be used in HTML attribute, e.g.\n     *\n     * `<div data-value=\"[[JSON]]\">...</div>`\n     * (`[[JSON]]` represents return value of this function)\n     *\n     * @param mixed $value\n     * @param bool $useHtmlEntities\n     */\n    public static function jsonEncodeForHtmlAttribute($value, bool $useHtmlEntities = true): string\n    {\n        $json = (string)json_encode($value, JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_TAG);\n        return $useHtmlEntities ? htmlspecialchars($json) : $json;\n    }\n\n    /**\n     * Serializes data to JSON, to be used in JavaScript instructions, e.g.\n     *\n     * `<script>const value = JSON.parse('[[JSON]]');</script>`\n     * (`[[JSON]]` represents return value of this function)\n     *\n     * @param mixed $value\n     */\n    public static function jsonEncodeForJavaScript($value): string\n    {\n        $json = (string)json_encode($value, JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_TAG);\n        return strtr(\n            $json,\n            [\n                // comments below refer to JSON-encoded data\n                '\\\\\\\\' => '\\\\\\\\u005C', // `\"\\\\Vendor\\\\Package\"` -> `\"\\\\u005CVendor\\\\u005CPackage\"`\n                '\\\\t' => '\\\\u0009', // `\"\\t\"` -> `\"\\u0009\"`\n                '\\\\n' => '\\\\u000A', // `\"\\n\"` -> `\"\\u000A\"`\n                '\\\\r' => '\\\\u000D', // `\"\\r\"` -> `\"\\u000D\"`\n            ]\n        );\n    }\n\n    /**\n     * @return LoggerInterface\n     */\n    protected static function getLogger()\n    {\n        return static::makeInstance(LogManager::class)->getLogger(__CLASS__);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Tests\\Acceptance\\Support\\Extension;\n\nuse Codeception\\Event\\SuiteEvent;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Symfony\\Component\\Mailer\\Transport\\NullTransport;\nuse TYPO3\\CMS\\Core\\Authentication\\BackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Core\\Bootstrap;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Http\\ServerRequest;\nuse TYPO3\\CMS\\Styleguide\\TcaDataGenerator\\Generator;\nuse TYPO3\\CMS\\Styleguide\\TcaDataGenerator\\GeneratorFrontend;\nuse TYPO3\\TestingFramework\\Core\\Acceptance\\Extension\\BackendEnvironment;\n\n/**\n * Load various core extensions and styleguide and call styleguide generator\n */\nfinal class ApplicationEnvironment extends BackendEnvironment\n{\n    /**\n     * Load a list of core extensions and styleguide\n     *\n     * @var array\n     */\n    protected $localConfig = [\n        'coreExtensionsToLoad' => [\n            'core',\n            'beuser',\n            'extbase',\n            'fluid',\n            'filelist',\n            'extensionmanager',\n            'setup',\n            'backend',\n            'belog',\n            'install',\n            'impexp',\n            'frontend',\n            'redirects',\n            'reports',\n            'sys_note',\n            'scheduler',\n            'tstemplate',\n            'lowlevel',\n            'dashboard',\n            'workspaces',\n            'info',\n            'fluid_styled_content',\n            'indexed_search',\n            'adminpanel',\n            'form',\n            'felogin',\n            'seo',\n            'recycler',\n        ],\n        'testExtensionsToLoad' => [\n            'typo3conf/ext/styleguide',\n        ],\n        'csvDatabaseFixtures' => [\n            __DIR__ . '/../../Fixtures/BackendEnvironment.csv',\n        ],\n        'configurationToUseInTestInstance' => [\n            'MAIL' => [\n                'transport' => NullTransport::class,\n            ],\n            'BE' => [\n                'HTTP' => [\n                    'Response' => [\n                        'Headers' => [\n                            // Notes:\n                            //  * `script-src 'nonce-rAnd0m'` required for importmap\n                            //                                todo: this needs to be a proper random value, requires API.\n                            //  * `frame-src blob:` required for es-module-shims blob: URLs\n                            //  * `style-src 'unsafe-inline'` required for lit in safari and firefox to allow inline <style> tags\n                            //                (for browsers that do not support https://caniuse.com/mdn-api_shadowroot_adoptedstylesheets)\n                            'csp-report' => \"Content-Security-Policy-Report-Only: default-src 'self'; script-src 'self' 'nonce-rAnd0m'; style-src 'self' 'unsafe-inline'; style-src-attr 'unsafe-inline'; style-src-elem 'self' 'unsafe-inline'; img-src 'self' data:; worker-src 'self' blob:; frame-src 'self' blob:;\",\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ];\n\n    /**\n     * Generate styleguide data\n     */\n    public function bootstrapTypo3Environment(SuiteEvent $suiteEvent): void\n    {\n        parent::bootstrapTypo3Environment($suiteEvent);\n        // styleguide generator uses DataHandler for some parts. DataHandler needs an initialized BE user\n        // with admin right and the live workspace.\n        $request = $this->createServerRequest('https://typo3-testing.local/typo3/');\n        Bootstrap::initializeBackendUser(BackendUserAuthentication::class, $request);\n        $GLOBALS['BE_USER']->user['username'] = 'acceptanceTestSetup';\n        $GLOBALS['BE_USER']->user['admin'] = 1;\n        $GLOBALS['BE_USER']->user['uid'] = 1;\n        $GLOBALS['BE_USER']->workspace = 0;\n        Bootstrap::initializeLanguageObject();\n\n        // Create favicon.ico to suppress potential javascript errors in console\n        // which are caused by calling a non html in the browser, e.g. seo sitemap xml\n        $faviconTargetPath = '../../../../favicon.ico';\n        if (!is_file($faviconTargetPath)) {\n            symlink('typo3/sysext/backend/Resources/Public/Icons/favicon.ico', '../../../../favicon.ico');\n        }\n\n        $styleguideGenerator = new Generator();\n        $styleguideGenerator->create();\n\n        $styleguideGeneratorFrontend = new GeneratorFrontend();\n        // Force basePath for testing environment, required for the frontend!\n        // Otherwise the page can not be found, also do not set root page to\n        // 'hidden' so menus (e.g. menu_sitemap_pages) are displayed correctly\n        $styleguideGeneratorFrontend->create('/typo3temp/var/tests/acceptance/', 0);\n    }\n\n    // @todo Eventually move this up to TF::BackendEnvironment, but then as protected.\n    private function createServerRequest(string $url, string $method = 'GET'): ServerRequestInterface\n    {\n        $requestUrlParts = parse_url($url);\n        $docRoot = getenv('TYPO3_PATH_APP') ?? '';\n        $serverParams = [\n            'DOCUMENT_ROOT' => $docRoot,\n            'HTTP_USER_AGENT' => 'TYPO3 Functional Test Request',\n            'HTTP_HOST' => $requestUrlParts['host'] ?? 'localhost',\n            'SERVER_NAME' => $requestUrlParts['host'] ?? 'localhost',\n            'SERVER_ADDR' => '127.0.0.1',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '/typo3/index.php',\n            'PHP_SELF' => '/typo3/index.php',\n            'SCRIPT_FILENAME' => $docRoot . '/index.php',\n            'PATH_TRANSLATED' => $docRoot . '/index.php',\n            'QUERY_STRING' => $requestUrlParts['query'] ?? '',\n            'REQUEST_URI' => $requestUrlParts['path'] . (isset($requestUrlParts['query']) ? '?' . $requestUrlParts['query'] : ''),\n            'REQUEST_METHOD' => $method,\n        ];\n        // Define HTTPS and server port\n        if (isset($requestUrlParts['scheme'])) {\n            if ($requestUrlParts['scheme'] === 'https') {\n                $serverParams['HTTPS'] = 'on';\n                $serverParams['SERVER_PORT'] = '443';\n            } else {\n                $serverParams['SERVER_PORT'] = '80';\n            }\n        }\n\n        // Define a port if used in the URL\n        if (isset($requestUrlParts['port'])) {\n            $serverParams['SERVER_PORT'] = $requestUrlParts['port'];\n        }\n        // set up normalizedParams\n        $request = new ServerRequest($url, $method, null, [], $serverParams);\n        return $request->withAttribute('normalizedParams', NormalizedParams::createFromRequest($request));\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Tests\\Unit\\Http;\n\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\TestingFramework\\Core\\Unit\\UnitTestCase;\n\nclass NormalizedParamsTest extends UnitTestCase\n{\n    /**\n     * @return array[]\n     */\n    public function getHttpHostReturnsSanitizedValueDataProvider(): array\n    {\n        return [\n            'simple HTTP_HOST' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                'www.domain.com',\n            ],\n            'first HTTP_X_FORWARDED_HOST from configured proxy, HTTP_HOST empty' => [\n                [\n                    'HTTP_HOST' => '',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com, www.domain2.com,',\n                ],\n                [\n                    'reverseProxyIP' => ' 123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'first',\n                ],\n                'www.domain1.com',\n            ],\n            'first HTTP_X_FORWARDED_HOST from configured proxy, HTTP_HOST given' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com, www.domain2.com,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'first',\n                ],\n                'www.domain1.com',\n            ],\n            'last HTTP_X_FORWARDED_HOST from configured proxy' => [\n                [\n                    'HTTP_HOST' => '',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com, www.domain2.com,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain2.com',\n            ],\n            'simple HTTP_HOST if reverseProxyHeaderMultiValue is not configured' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                ],\n                'www.domain.com',\n            ],\n            'simple HTTP_HOST if proxy IP does not match' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com',\n                ],\n                [\n                    'reverseProxyIP' => '234.234.234.234',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain.com',\n            ],\n            'simple HTTP_HOST if REMOTE_ADDR misses' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com',\n                ],\n                [\n                    'reverseProxyIP' => '234.234.234.234',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain.com',\n            ],\n            'simple HTTP_HOST if HTTP_X_FORWARDED_HOST is empty' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => '',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain.com',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getHttpHostReturnsSanitizedValueDataProvider\n     */\n    public function getHttpHostReturnsSanitizedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpHost());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function isHttpsReturnSanitizedValueDataProvider(): array\n    {\n        return [\n            'false if nothing special is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                false,\n            ],\n            'true if SSL_SESSION_ID is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'SSL_SESSION_ID' => 'foo',\n                ],\n                [],\n                true,\n            ],\n            'false if SSL_SESSION_ID is empty' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'SSL_SESSION_ID' => '',\n                ],\n                [],\n                false,\n            ],\n            'true if HTTPS is \"ON\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'ON',\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is \"on\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'on',\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is \"1\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => '1',\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is int(1)\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 1,\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is bool(true)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => true,\n                ],\n                [],\n                true,\n            ],\n            // https://secure.php.net/manual/en/reserved.variables.server.php\n            // \"Set to a non-empty value if the script was queried through the HTTPS protocol.\"\n            'true if HTTPS is \"somethingrandom\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'somethingrandom',\n                ],\n                [],\n                true,\n            ],\n            'false if HTTPS is \"0\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => '0',\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is int(0)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 0,\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is float(0)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 0.0,\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is not on' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'off',\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is empty' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => '',\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is null' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => null,\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is bool(false)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => false,\n                ],\n                [],\n                false,\n            ],\n            // Per PHP documentation 'HTTPS' is:\n            //   \"Set to a non-empty value if the script\n            //   was queried through the HTTPS protocol.\"\n            // So theoretically an empty array means HTTPS is off.\n            // We do not support that. Therefore this test is disabled.\n            //'false if HTTPS is an empty Array' => [\n            //    [\n            //        'HTTP_HOST' => 'www.domain.com',\n            //        'HTTPS' => [],\n            //    ],\n            //    [],\n            //    false,\n            //],\n            'true if ssl proxy IP matches REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123 ',\n                ],\n                [\n                    'reverseProxySSL' => ' 123.123.123.123',\n                ],\n                true,\n            ],\n            'false if ssl proxy IP does not match REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                ],\n                [\n                    'reverseProxySSL' => '234.234.234.234',\n                ],\n                false,\n            ],\n            'true if SSL proxy is * and reverse proxy IP matches REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                ],\n                [\n                    'reverseProxySSL' => '*',\n                    'reverseProxyIP' => '123.123.123.123',\n                ],\n                true,\n            ],\n            'false if SSL proxy is * and reverse proxy IP does not match REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                ],\n                [\n                    'reverseProxySSL' => '*',\n                    'reverseProxyIP' => '234.234.234.234',\n                ],\n                false,\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isHttpsReturnSanitizedValueDataProvider\n     */\n    public function isHttpsReturnSanitizedValue(array $serverParams, array $configuration, bool $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->isHttps());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestHostReturnsRequestHost(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'HTTPS' => 'on',\n        ];\n        $expected = 'https://www.domain.com';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestHost());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getScriptNameReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'empty string if nothing is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                '',\n            ],\n            'use ORIG_SCRIPT_NAME if ORIG_PATH_INFO is set but empty' => [\n                [\n                    'ORIG_PATH_INFO' => '',\n                    'PATH_INFO' => '',\n                    'ORIG_SCRIPT_NAME' => '/orig/script/name.php',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/orig/script/name.php',\n            ],\n            'use ORIG_SCRIPT_NAME if PATH_INFO is set but empty' => [\n                [\n                    'PATH_INFO' => '',\n                    'ORIG_SCRIPT_NAME' => '/orig/script/name.php',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/orig/script/name.php',\n            ],\n            'use SCRIPT_NAME if ORIG_PATH_INFO is set but empty' => [\n                [\n                    'ORIG_PATH_INFO' => '',\n                    'PATH_INFO' => '',\n                    'ORIG_SCRIPT_NAME' => '',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/script/name.php',\n            ],\n            'use SCRIPT_NAME if PATH_INFO is set but empty' => [\n                [\n                    'PATH_INFO' => '',\n                    'ORIG_SCRIPT_NAME' => '',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/script/name.php',\n            ],\n            'use SCRIPT_NAME if ORIG_PATH_INFO is set' => [\n                [\n                    'ORIG_PATH_INFO' => '/foo/bar',\n                    'PATH_INFO' => '',\n                    'ORIG_SCRIPT_NAME' => '',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/script/name.php',\n            ],\n            'use SCRIPT_NAME if PATH_INFO is set' => [\n                [\n                    'PATH_INFO' => '/foo/bar',\n                    'ORIG_SCRIPT_NAME' => '',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/script/name.php',\n            ],\n            'use ORIG_SCRIPT_NAME' => [\n                [\n                    'ORIG_SCRIPT_NAME' => '/orig/script/name.php',\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/orig/script/name.php',\n            ],\n            'use SCRIPT_NAME' => [\n                [\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/script/name.php',\n            ],\n            'add proxy ssl prefix' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'SCRIPT_NAME' => '/path/info.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefixSSL' => '/proxyPrefixSSL',\n                ],\n                '/proxyPrefixSSL/path/info.php',\n            ],\n            'add proxy prefix' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'SCRIPT_NAME' => '/path/info.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefix' => '/proxyPrefix',\n                ],\n                '/proxyPrefix/path/info.php',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getScriptNameReturnsExpectedValueDataProvider\n     */\n    public function getScriptNameReturnsExpectedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getScriptName());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getRequestUriReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'slash if nothing is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                '/',\n            ],\n            'use REQUEST_URI' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REQUEST_URI' => 'typo3/bar?id=42',\n                ],\n                [],\n                '/typo3/bar?id=42',\n            ],\n            'use query string and script name if REQUEST_URI is not set' => [\n                [\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                ],\n                [],\n                '/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n            'prefix with proxy prefix with ssl if using REQUEST_URI' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'REQUEST_URI' => 'typo3/foo/bar?id=42',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefixSSL' => '/proxyPrefixSSL',\n                ],\n                '/proxyPrefixSSL/typo3/foo/bar?id=42',\n            ],\n            'prefix with proxy prefix if using REQUEST_URI' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'REQUEST_URI' => 'typo3/foo/bar?id=42',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefix' => '/proxyPrefix',\n                ],\n                '/proxyPrefix/typo3/foo/bar?id=42',\n            ],\n            'prefix with proxy prefix with ssl if using query string and script name' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefixSSL' => '/proxyPrefixSSL',\n                ],\n                '/proxyPrefixSSL/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n            'prefix with proxy prefix if using query string and script name' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefix' => '/proxyPrefix',\n                ],\n                '/proxyPrefix/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRequestUriReturnsExpectedValueDataProvider\n     */\n    public function getRequestUriReturnsExpectedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestUri());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestUriFetchesFromConfiguredRequestUriVar(): void\n    {\n        $GLOBALS['foo']['bar'] = '/foo/bar.php';\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n        ];\n        $configuration = [\n            'requestURIvar' => 'foo|bar',\n        ];\n        $expected = '/foo/bar.php';\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestUri());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestUrlReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'REQUEST_URI' => 'typo3/foo/bar?id=42',\n        ];\n        $expected = 'http://www.domain.com/typo3/foo/bar?id=42';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestUrl());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestScriptReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $expected = 'http://www.domain.com/typo3/index.php';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestScript());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestDirReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $expected = 'http://www.domain.com/typo3/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestDir());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function isBehindReverseProxyReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'false with empty data' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                false,\n            ],\n            'false if REMOTE_ADDR and reverseProxyIP do not match' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '100.100.100.100',\n                ],\n                [\n                    'reverseProxyIP' => '200.200.200.200',\n                ],\n                false,\n            ],\n            'true if REMOTE_ADDR matches configured reverseProxyIP' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '100.100.100.100',\n                ],\n                [\n                    'reverseProxyIP' => '100.100.100.100',\n                ],\n                true,\n            ],\n            'true if trimmed REMOTE_ADDR matches configured trimmed reverseProxyIP' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 100.100.100.100 ',\n                ],\n                [\n                    'reverseProxyIP' => '  100.100.100.100  ',\n                ],\n                true,\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isBehindReverseProxyReturnsExpectedValueDataProvider\n     */\n    public function isBehindReverseProxyReturnsExpectedValue(array $serverParams, array $configuration, bool $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->isBehindReverseProxy());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getRemoteAddressReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'simple REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                ],\n                [],\n                '123.123.123.123',\n            ],\n            'reverse proxy with last HTTP_X_FORWARDED_FOR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                    'HTTP_X_FORWARDED_FOR' => ' 234.234.234.234, 235.235.235.235,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => ' last ',\n                ],\n                '235.235.235.235',\n            ],\n            'reverse proxy with first HTTP_X_FORWARDED_FOR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                    'HTTP_X_FORWARDED_FOR' => ' 234.234.234.234, 235.235.235.235,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123 ',\n                    'reverseProxyHeaderMultiValue' => ' first ',\n                ],\n                '234.234.234.234',\n            ],\n            'reverse proxy with broken reverseProxyHeaderMultiValue returns REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                    'HTTP_X_FORWARDED_FOR' => ' 234.234.234.234, 235.235.235.235,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123 ',\n                    'reverseProxyHeaderMultiValue' => ' foo ',\n                ],\n                '123.123.123.123',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRemoteAddressReturnsExpectedValueDataProvider\n     */\n    public function getRemoteAddressReturnsExpectedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getRemoteAddress());\n    }\n\n    public static function getRequestHostOnlyReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'localhost ipv4 without port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1',\n                ],\n                '127.0.0.1',\n            ],\n            'localhost ipv4 with port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1:81',\n                ],\n                '127.0.0.1',\n            ],\n            'localhost ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[::1]',\n                ],\n                '[::1]',\n            ],\n            'localhost ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[::1]:81',\n                ],\n                '[::1]',\n            ],\n            'ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]',\n                ],\n                '[2001:DB8::1]',\n            ],\n            'ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]:81',\n                ],\n                '[2001:DB8::1]',\n            ],\n            'hostname without port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this',\n                ],\n                'lolli.did.this',\n            ],\n            'hostname with port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this:42',\n                ],\n                'lolli.did.this',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRequestHostOnlyReturnsExpectedValueDataProvider\n     */\n    public function getRequestHostOnlyReturnsExpectedValue(array $serverParams, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestHostOnly());\n    }\n\n    public static function getRequestPortOnlyReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'localhost ipv4 without port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1',\n                ],\n                0,\n            ],\n            'localhost ipv4 with port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1:81',\n                ],\n                81,\n            ],\n            'localhost ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[::1]',\n                ],\n                0,\n            ],\n            'localhost ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[::1]:81',\n                ],\n                81,\n            ],\n            'ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]',\n                ],\n                0,\n            ],\n            'ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]:81',\n                ],\n                81,\n            ],\n            'hostname without port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this',\n                ],\n                0,\n            ],\n            'hostname with port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this:42',\n                ],\n                42,\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRequestPortOnlyReturnsExpectedValueDataProvider\n     */\n    public function getRequestPortReturnsExpectedValue(array $serverParams, int $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestPort());\n    }\n\n    /**\n     * @test\n     */\n    public function getScriptFilenameReturnsThirdConstructorArgument(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $pathSite = '/var/www/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '/var/www/typo3/index.php', $pathSite);\n        self::assertSame('/var/www/typo3/index.php', $serverRequestParameters->getScriptFilename());\n    }\n\n    /**\n     * @test\n     */\n    public function getDocumentRootReturnsExpectedPath(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $pathThisScript = '/var/www/myInstance/Web/typo3/index.php';\n        $pathSite = '/var/www/myInstance/Web/';\n        $expected = '/var/www/myInstance/Web';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getDocumentRoot());\n    }\n\n    /**\n     * @test\n     */\n    public function getSiteUrlReturnsExpectedUrl(): void\n    {\n        $serverParams = [\n            'SCRIPT_NAME' => '/typo3/index.php',\n            'HTTP_HOST' => 'www.domain.com',\n            'PATH_INFO' => '/typo3/index.php',\n        ];\n        $pathThisScript = '/var/www/myInstance/Web/typo3/index.php';\n        $pathSite = '/var/www/myInstance/Web';\n        $expected = 'http://www.domain.com/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSiteUrl());\n    }\n\n    /**\n     * @test\n     */\n    public function getSiteUrlReturnsExpectedUrlForCliCommand(): void\n    {\n        $serverParams = [];\n        $pathThisScript = '/var/www/html/typo3temp/var/tests/acceptance/typo3/sysext/core/bin/typo3';\n        $pathSite = '/var/www/html/typo3temp/var/tests/acceptance/';\n        $expected = '/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSiteUrl());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getSitePathReturnsExpectedPathDataProvider(): array\n    {\n        return [\n            'empty config' => [\n                [],\n                '',\n                '',\n                '',\n            ],\n            'not in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                '/',\n            ],\n            'in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/some/sub/dir/typo3/index.php',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                '/some/sub/dir/',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getSitePathReturnsExpectedPathDataProvider\n     */\n    public function getSitePathReturnsExpectedPath(array $serverParams, string $pathThisScript, string $pathSite, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSitePath());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getSiteScriptReturnsExpectedPathDataProvider(): array\n    {\n        return [\n            'not in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/typo3/index.php?id=42&foo=bar',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                'typo3/index.php?id=42&foo=bar',\n            ],\n            'in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/some/sub/dir/typo3/index.php?id=42&foo=bar',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                'typo3/index.php?id=42&foo=bar',\n            ],\n            'redirected to a sub directory' => [\n                'serverParams' => [\n                    'REQUEST_URI' => '/',\n                    'SCRIPT_NAME' => '/public/',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                'pathThisScript' => '/var/www/html/public/index.php',\n                'pathSite' => '/var/www/html/html/public',\n                'expected' => '',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getSiteScriptReturnsExpectedPathDataProvider\n     */\n    public function getSiteScriptReturnsExpectedPath(array $serverParams, string $pathThisScript, string $pathSite, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSiteScript());\n    }\n\n    /**\n     * @test\n     */\n    public function getPathInfoReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'PATH_INFO' => '/typo3/index.php',\n        ];\n        $expected = '/typo3/index.php';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getPathInfo());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpRefererReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_REFERER' => 'https://www.domain.com/typo3/index.php?id=42',\n        ];\n        $expected = 'https://www.domain.com/typo3/index.php?id=42';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpReferer());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpUserAgentReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_USER_AGENT' => 'the client browser',\n        ];\n        $expected = 'the client browser';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpUserAgent());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpAcceptEncodingReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_ACCEPT_ENCODING' => 'gzip, deflate',\n        ];\n        $expected = 'gzip, deflate';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpAcceptEncoding());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpAcceptLanguageReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_ACCEPT_LANGUAGE' => 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7',\n        ];\n        $expected = 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpAcceptLanguage());\n    }\n\n    /**\n     * @test\n     */\n    public function getRemoteHostReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'REMOTE_HOST' => 'www.clientDomain.com',\n        ];\n        $expected = 'www.clientDomain.com';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRemoteHost());\n    }\n\n    /**\n     * @test\n     */\n    public function getQueryStringReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'QUERY_STRING' => 'id=42&foo=bar',\n        ];\n        $expected = 'id=42&foo=bar';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getQueryString());\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Tests\\Unit\\Log\\Processor;\n\nuse Psr\\Log\\LogLevel;\nuse TYPO3\\CMS\\Core\\Log\\LogRecord;\nuse TYPO3\\CMS\\Core\\Log\\Processor\\WebProcessor;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\TestingFramework\\Core\\Unit\\UnitTestCase;\n\nclass WebProcessorTest extends UnitTestCase\n{\n    /**\n     * @test\n     */\n    public function webProcessorAddsWebDataToLogRecord(): void\n    {\n        $_SERVER['PATH_INFO'] = '';\n        $_SERVER['REQUEST_URI'] = '';\n        $_SERVER['ORIG_SCRIPT_NAME'] = '';\n        $_SERVER['REMOTE_ADDR'] = '';\n        $_SERVER['QUERY_STRING'] = '';\n        $_SERVER['SSL_SESSION_ID'] = '';\n        $_SERVER['HTTP_HOST'] = 'acme.com';\n\n        $environmentVariables = GeneralUtility::getIndpEnv('_ARRAY');\n        $logRecord = new LogRecord('test.core.log', LogLevel::DEBUG, 'test');\n        $processor = new WebProcessor();\n        $logRecord = $processor->processLogRecord($logRecord);\n        foreach ($environmentVariables as $key => $value) {\n            self::assertEquals($value, $logRecord['data'][$key]);\n        }\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\FrontendLogin\\Tests\\Unit\\Validation;\n\nuse Psr\\Log\\NullLogger;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Core\\SystemEnvironmentBuilder;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Http\\ServerRequestFactory;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\Site;\nuse TYPO3\\CMS\\Core\\Site\\SiteFinder;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Extbase\\Mvc\\ExtbaseRequestParameters;\nuse TYPO3\\CMS\\Extbase\\Mvc\\Request;\nuse TYPO3\\CMS\\Extbase\\Mvc\\RequestInterface;\nuse TYPO3\\CMS\\FrontendLogin\\Validation\\RedirectUrlValidator;\nuse TYPO3\\TestingFramework\\Core\\AccessibleObjectInterface;\nuse TYPO3\\TestingFramework\\Core\\Unit\\UnitTestCase;\n\nclass RedirectUrlValidatorTest extends UnitTestCase\n{\n    protected bool $backupEnvironment = true;\n\n    protected RedirectUrlValidator&AccessibleObjectInterface $accessibleFixture;\n    protected RequestInterface $extbaseRequest;\n    protected string $testHostName;\n    protected string $testSitePath;\n\n    protected bool $resetSingletonInstances = true;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $site1 = new Site('dummy', 1, ['base' => 'http://sub.domainhostname.tld/path/']);\n        $site2 = new Site('dummy', 1, ['base' => 'http://sub2.domainhostname.tld/']);\n        $mockedSiteFinder = $this->getAccessibleMock(SiteFinder::class, ['getAllSites'], [], '', false, false);\n        $mockedSiteFinder->method('getAllSites')->willReturn([$site1, $site2]);\n\n        $this->testHostName = 'hostname.tld';\n        $this->testSitePath = '/';\n        $this->accessibleFixture = $this->getAccessibleMock(RedirectUrlValidator::class, null, [$mockedSiteFinder]);\n        $this->accessibleFixture->setLogger(new NullLogger());\n        $this->setUpFakeSitePathAndHost();\n    }\n\n    /**\n     * Set up a fake site path and host\n     */\n    protected function setUpFakeSitePathAndHost(): void\n    {\n        $_SERVER['ORIG_PATH_INFO'] = $_SERVER['PATH_INFO'] = $_SERVER['ORIG_SCRIPT_NAME'] = $_SERVER['SCRIPT_NAME'] = $this->testSitePath . 'index.php';\n        $_SERVER['HTTP_HOST'] = $this->testHostName;\n\n        $request = ServerRequestFactory::fromGlobals();\n        $request = $request->withAttribute('applicationType', SystemEnvironmentBuilder::REQUESTTYPE_FE);\n        $normalizedParams = NormalizedParams::createFromRequest($request);\n        $request = $request->withAttribute('normalizedParams', $normalizedParams)->withAttribute('extbase', new ExtbaseRequestParameters());\n        $this->extbaseRequest = new Request($request);\n    }\n\n    /**\n     * Data provider for validateRedirectUrlClearsUrl\n     */\n    public function validateRedirectUrlClearsUrlDataProvider(): array\n    {\n        return [\n            'absolute URL, hostname not in site, trailing slash' => ['http://badhost.tld/'],\n            'absolute URL, hostname not in site, no trailing slash' => ['http://badhost.tld'],\n            'absolute URL, subdomain in site, but main domain not, trailing slash' => ['http://domainhostname.tld.badhost.tld/'],\n            'absolute URL, subdomain in site, but main domain not, no trailing slash' => ['http://domainhostname.tld.badhost.tld'],\n            'non http absolute URL 1' => ['its://domainhostname.tld/itunes/'],\n            'non http absolute URL 2' => ['ftp://domainhostname.tld/download/'],\n            'XSS attempt 1' => ['javascript:alert(123)'],\n            'XSS attempt 2' => ['\" onmouseover=\"alert(123)\"'],\n            'invalid URL, HTML break out attempt' => ['\" >blabuubb'],\n            'invalid URL, UNC path' => ['\\\\\\\\foo\\\\bar\\\\'],\n            'invalid URL, backslashes in path' => ['http://domainhostname.tld\\\\bla\\\\blupp'],\n            'invalid URL, linefeed in path' => ['http://domainhostname.tld/bla/blupp' . LF],\n            'invalid URL, only one slash after scheme' => ['http:/domainhostname.tld/bla/blupp'],\n            'invalid URL, illegal chars' => ['http://(<>domainhostname).tld/bla/blupp'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlClearsUrlDataProvider\n     */\n    public function validateRedirectUrlClearsUrl(string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        self::assertFalse($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**\n     * Data provider for validateRedirectUrlKeepsCleanUrl\n     */\n    public function validateRedirectUrlKeepsCleanUrlDataProvider(): array\n    {\n        return [\n            'sane absolute URL' => ['http://sub.domainhostname.tld/path/'],\n            'sane absolute URL with script' => ['http://sub.domainhostname.tld/path/index.php?id=1'],\n            'sane absolute URL with routing' => ['http://sub.domainhostname.tld/path/foo/bar/foo.html'],\n            'sane absolute URL with homedir' => ['http://sub.domainhostname.tld/path/~user/'],\n            'sane absolute URL with some strange chars encoded' => ['http://sub.domainhostname.tld/path/~user/a%cc%88o%cc%88%c3%9fa%cc%82/foo.html'],\n            'relative URL, no leading slash 1' => ['index.php?id=1'],\n            'relative URL, no leading slash 2' => ['foo/bar/index.php?id=2'],\n            'relative URL, leading slash, no routing' => ['/index.php?id=1'],\n            'relative URL, leading slash, routing' => ['/de/service/imprint.html'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlKeepsCleanUrlDataProvider\n     */\n    public function validateRedirectUrlKeepsCleanUrl(string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        self::assertTrue($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**\n     * Data provider for validateRedirectUrlClearsInvalidUrlInSubdirectory\n     */\n    public function validateRedirectUrlClearsInvalidUrlInSubdirectoryDataProvider(): array\n    {\n        return [\n            'absolute URL, missing subdirectory' => ['http://hostname.tld/'],\n            'absolute URL, wrong subdirectory' => ['http://hostname.tld/hacker/index.php'],\n            'absolute URL, correct subdirectory, no trailing slash' => ['http://hostname.tld/subdir'],\n            'relative URL, leading slash, no path' => ['/index.php?id=1'],\n            'relative URL, leading slash, wrong path' => ['/de/sub/site.html'],\n            'relative URL, leading slash, slash only' => ['/'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlClearsInvalidUrlInSubdirectoryDataProvider\n     */\n    public function validateRedirectUrlClearsInvalidUrlInSubdirectory(string $url): void\n    {\n        GeneralUtility::flushInternalRuntimeCaches();\n        $this->testSitePath = '/subdir/';\n        $this->setUpFakeSitePathAndHost();\n        self::assertFalse($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**\n     * Data provider for validateRedirectUrlKeepsCleanUrlInSubdirectory\n     */\n    public function validateRedirectUrlKeepsCleanUrlInSubdirectoryDataProvider(): array\n    {\n        return [\n            'absolute URL, correct subdirectory' => ['http://hostname.tld/subdir/'],\n            'absolute URL, correct subdirectory, routing' => ['http://hostname.tld/subdir/de/imprint.html'],\n            'absolute URL, correct subdirectory, no routing' => ['http://hostname.tld/subdir/index.php?id=10'],\n            'absolute URL, correct subdirectory of site base' => ['http://sub.domainhostname.tld/path/'],\n            'relative URL, no leading slash, routing' => ['de/service/imprint.html'],\n            'relative URL, no leading slash, no routing' => ['index.php?id=1'],\n            'relative nested URL, no leading slash, no routing' => ['foo/bar/index.php?id=2'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlKeepsCleanUrlInSubdirectoryDataProvider\n     */\n    public function validateRedirectUrlKeepsCleanUrlInSubdirectory(string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        $this->testSitePath = '/subdir/';\n        $this->setUpFakeSitePathAndHost();\n        self::assertTrue($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**************************************************\n     * Tests concerning isInCurrentDomain\n     **************************************************/\n\n    /**\n     * Dataprovider for isInCurrentDomainIgnoresScheme\n     */\n    public function isInCurrentDomainIgnoresSchemeDataProvider(): array\n    {\n        return [\n            'url https, current host http' => [\n                'example.com', // HTTP_HOST\n                '0', // HTTPS\n                'https://example.com/foo.html', // URL\n            ],\n            'url http, current host https' => [\n                'example.com',\n                '1',\n                'http://example.com/foo.html',\n            ],\n            'url https, current host https' => [\n                'example.com',\n                '1',\n                'https://example.com/foo.html',\n            ],\n            'url http, current host http' => [\n                'example.com',\n                '0',\n                'http://example.com/foo.html',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isInCurrentDomainIgnoresSchemeDataProvider\n     * @param string $host $_SERVER['HTTP_HOST']\n     * @param string $https $_SERVER['HTTPS']\n     * @param string $url The url to test\n     */\n    public function isInCurrentDomainIgnoresScheme(string $host, string $https, string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        $_SERVER['HTTP_HOST'] = $host;\n        $_SERVER['HTTPS'] = $https;\n\n        $request = ServerRequestFactory::fromGlobals();\n        $request = $request->withAttribute('applicationType', SystemEnvironmentBuilder::REQUESTTYPE_FE);\n        $normalizedParams = NormalizedParams::createFromRequest($request);\n        $request = $request->withAttribute('normalizedParams', $normalizedParams)->withAttribute('extbase', new ExtbaseRequestParameters());\n        $extbaseRequest = new Request($request);\n\n        self::assertTrue($this->accessibleFixture->_call('isInCurrentDomain', $extbaseRequest, $url));\n    }\n\n    public function isInCurrentDomainReturnsFalseIfDomainsAreDifferentDataProvider(): array\n    {\n        return [\n            'simple difference' => [\n                'example.com', // HTTP_HOST\n                'http://typo3.org/foo.html', // URL\n            ],\n            'subdomain different' => [\n                'example.com',\n                'http://foo.example.com/bar.html',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isInCurrentDomainReturnsFalseIfDomainsAreDifferentDataProvider\n     * @param string $host $_SERVER['HTTP_HOST']\n     * @param string $url The url to test\n     */\n    public function isInCurrentDomainReturnsFalseIfDomainsAreDifferent(string $host, string $url): void\n    {\n        $_SERVER['HTTP_HOST'] = $host;\n\n        $request = ServerRequestFactory::fromGlobals();\n        $request = $request->withAttribute('applicationType', SystemEnvironmentBuilder::REQUESTTYPE_FE);\n        $normalizedParams = NormalizedParams::createFromRequest($request);\n        $request = $request->withAttribute('normalizedParams', $normalizedParams)->withAttribute('extbase', new ExtbaseRequestParameters());\n        $extbaseRequest = new Request($request);\n\n        self::assertFalse($this->accessibleFixture->_call('isInCurrentDomain', $extbaseRequest, $url));\n    }\n\n    /**************************************************\n     * Tests concerning isInLocalDomain\n     **************************************************/\n\n    /**\n     * @test\n     */\n    public function isInLocalDomainValidatesSites(): void\n    {\n        $url = 'http://example.com';\n        self::assertFalse($this->accessibleFixture->_call('isInLocalDomain', $url));\n\n        $url = 'http://sub2.domainhostname.tld/some/path';\n        self::assertTrue($this->accessibleFixture->_call('isInLocalDomain', $url));\n    }\n}\n", "<?php\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Frontend\\Controller;\n\nuse Psr\\EventDispatcher\\EventDispatcherInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Psr\\Log\\LogLevel;\nuse TYPO3\\CMS\\Backend\\FrontendBackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Cache\\CacheManager;\nuse TYPO3\\CMS\\Core\\Cache\\Frontend\\FrontendInterface;\nuse TYPO3\\CMS\\Core\\Cache\\Frontend\\PhpFrontend;\nuse TYPO3\\CMS\\Core\\Compatibility\\PublicPropertyDeprecationTrait;\nuse TYPO3\\CMS\\Core\\Configuration\\PageTsConfig;\nuse TYPO3\\CMS\\Core\\Context\\Context;\nuse TYPO3\\CMS\\Core\\Context\\LanguageAspect;\nuse TYPO3\\CMS\\Core\\Context\\LanguageAspectFactory;\nuse TYPO3\\CMS\\Core\\Context\\UserAspect;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Database\\ConnectionPool;\nuse TYPO3\\CMS\\Core\\Domain\\Access\\RecordAccessVoter;\nuse TYPO3\\CMS\\Core\\Domain\\Repository\\PageRepository;\nuse TYPO3\\CMS\\Core\\Error\\Http\\AbstractServerErrorException;\nuse TYPO3\\CMS\\Core\\Error\\Http\\PageNotFoundException;\nuse TYPO3\\CMS\\Core\\Error\\Http\\ShortcutTargetPageNotFoundException;\nuse TYPO3\\CMS\\Core\\Exception\\Page\\RootLineException;\nuse TYPO3\\CMS\\Core\\Exception\\SiteNotFoundException;\nuse TYPO3\\CMS\\Core\\Http\\ImmediateResponseException;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Http\\PropagateResponseException;\nuse TYPO3\\CMS\\Core\\Localization\\LanguageService;\nuse TYPO3\\CMS\\Core\\Localization\\LanguageServiceFactory;\nuse TYPO3\\CMS\\Core\\Locking\\ResourceMutex;\nuse TYPO3\\CMS\\Core\\Page\\AssetCollector;\nuse TYPO3\\CMS\\Core\\Page\\PageRenderer;\nuse TYPO3\\CMS\\Core\\PageTitle\\PageTitleProviderManager;\nuse TYPO3\\CMS\\Core\\Routing\\PageArguments;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\Site;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\SiteLanguage;\nuse TYPO3\\CMS\\Core\\Site\\SiteFinder;\nuse TYPO3\\CMS\\Core\\TimeTracker\\TimeTracker;\nuse TYPO3\\CMS\\Core\\Type\\Bitmask\\PageTranslationVisibility;\nuse TYPO3\\CMS\\Core\\Type\\Bitmask\\Permission;\nuse TYPO3\\CMS\\Core\\Type\\DocType;\nuse TYPO3\\CMS\\Core\\TypoScript\\AST\\Node\\ChildNode;\nuse TYPO3\\CMS\\Core\\TypoScript\\AST\\Node\\RootNode;\nuse TYPO3\\CMS\\Core\\TypoScript\\FrontendTypoScript;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\SysTemplateRepository;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\SysTemplateTreeBuilder;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Traverser\\ConditionVerdictAwareIncludeTreeTraverser;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Traverser\\IncludeTreeTraverser;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeAstBuilderVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeConditionIncludeListAccumulatorVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeConditionMatcherVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeSetupConditionConstantSubstitutionVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\TemplateService;\nuse TYPO3\\CMS\\Core\\TypoScript\\Tokenizer\\LossyTokenizer;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Core\\Utility\\HttpUtility;\nuse TYPO3\\CMS\\Core\\Utility\\MathUtility;\nuse TYPO3\\CMS\\Core\\Utility\\PathUtility;\nuse TYPO3\\CMS\\Core\\Utility\\RootlineUtility;\nuse TYPO3\\CMS\\Frontend\\Aspect\\PreviewAspect;\nuse TYPO3\\CMS\\Frontend\\Authentication\\FrontendUserAuthentication;\nuse TYPO3\\CMS\\Frontend\\Cache\\CacheLifetimeCalculator;\nuse TYPO3\\CMS\\Frontend\\Configuration\\TypoScript\\ConditionMatching\\ConditionMatcher as FrontendConditionMatcher;\nuse TYPO3\\CMS\\Frontend\\ContentObject\\ContentObjectRenderer;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterCacheableContentIsGeneratedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterCachedPageIsPersistedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterPageAndLanguageIsResolvedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterPageWithRootLineIsResolvedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\BeforePageIsResolvedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\ShouldUseCachedPageDataIfAvailableEvent;\nuse TYPO3\\CMS\\Frontend\\Page\\CacheHashCalculator;\nuse TYPO3\\CMS\\Frontend\\Page\\PageAccessFailureReasons;\nuse TYPO3\\CMS\\Frontend\\Typolink\\LinkVarsCalculator;\n\n/**\n * Main controller class of the TypoScript based frontend.\n *\n * This is prepared in Frontend middlewares and the content rendering is\n * ultimately called in \\TYPO3\\CMS\\Frontend\\Http\\RequestHandler.\n *\n * When calling a Frontend page, an instance of this object is available\n * as $GLOBALS['TSFE'], even though the core development strives to get\n * rid of this in the future.\n */\nclass TypoScriptFrontendController implements LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n    use PublicPropertyDeprecationTrait;\n\n    protected array $deprecatedPublicProperties = [\n        'intTarget' => '$TSFE->intTarget will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'intTarget\\'] instead.',\n        'extTarget' => '$TSFE->extTarget will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'extTarget\\'] instead.',\n        'fileTarget' => '$TSFE->fileTarget will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'fileTarget\\'] instead.',\n        'spamProtectEmailAddresses' => '$TSFE->spamProtectEmailAddresses will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'spamProtectEmailAddresses\\'] instead.',\n        'baseUrl' => '$TSFE->baseUrl will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'baseURL\\'] instead.',\n        'xhtmlDoctype' => '$TSFE->xhtmlDoctype will be removed in TYPO3 v13.0. Use PageRenderer->getDocType() instead.',\n        'xhtmlVersion' => '$TSFE->xhtmlVersion will be removed in TYPO3 v13.0. Use PageRenderer->getDocType() instead.',\n    ];\n\n    /**\n     * The page id (int)\n     */\n    public int $id;\n\n    /**\n     * The type (read-only)\n     * @var int|string\n     */\n    public $type = 0;\n\n    protected Site $site;\n    protected SiteLanguage $language;\n\n    /**\n     * @internal\n     */\n    protected PageArguments $pageArguments;\n\n    /**\n     * Page will not be cached. Write only TRUE. Never clear value (some other\n     * code might have reasons to set it TRUE).\n     * @var bool\n     * @internal\n     */\n    public $no_cache = false;\n\n    /**\n     * Rootline of page records all the way to the root.\n     *\n     * Both language and version overlays are applied to these page records:\n     * All \"data\" fields are set to language / version overlay values, *except* uid and\n     * pid, which are the default-language and live-version ids.\n     *\n     * First array row with the highest key is the deepest page (the requested page),\n     * then parent pages with descending keys until (but not including) the\n     * project root pseudo page 0.\n     *\n     * When page uid 5 is called in this example:\n     * [0] Project name\n     * |- [2] An organizational page, probably with is_siteroot=1 and a site config\n     *    |- [3] Site root with a sys_template having \"root\" flag set\n     *       |- [5] Here you are\n     *\n     * This $absoluteRootLine is:\n     * [3] => [uid = 5, pid = 3, title = Here you are, ...]\n     * [2] => [uid = 3, pid = 2, title = Site root with a sys_template having \"root\" flag set, ...]\n     * [1] => [uid = 2, pid = 0, title = An organizational page, probably with is_siteroot=1 and a site config, ...]\n     *\n     * @var array<int, array<string, mixed>>\n     */\n    public array $rootLine = [];\n\n    /**\n     * The pagerecord\n     * @var array\n     */\n    public $page = [];\n\n    /**\n     * This will normally point to the same value as id, but can be changed to\n     * point to another page from which content will then be displayed instead.\n     */\n    public int $contentPid = 0;\n\n    /**\n     * Gets set when we are processing a page of type mountpoint with enabled overlay in getPageAndRootline()\n     * Used later in checkPageForMountpointRedirect() to determine the final target URL where the user\n     * should be redirected to.\n     */\n    protected ?array $originalMountPointPage = null;\n\n    /**\n     * Gets set when we are processing a page of type shortcut in the early stages\n     * of the request, used later in the request to resolve the shortcut and redirect again.\n     */\n    protected ?array $originalShortcutPage = null;\n\n    /**\n     * sys_page-object, pagefunctions\n     *\n     * @var PageRepository|string\n     */\n    public $sys_page = '';\n\n    /**\n     * Is set to > 0 if the page could not be resolved. This will then result in early returns when resolving the page.\n     */\n    protected int $pageNotFound = 0;\n\n    /**\n     * Array containing a history of why a requested page was not accessible.\n     */\n    protected array $pageAccessFailureHistory = [];\n\n    /**\n     * @var string\n     * @internal\n     */\n    public $MP = '';\n\n    /**\n     * The frontend user\n     *\n     * @var FrontendUserAuthentication\n     */\n    public $fe_user;\n\n    /**\n     * A central data array consisting of various keys, initialized and\n     * processed at various places in the class.\n     *\n     * This array is cached along with the rendered page content and contains\n     * for instance a list of INT identifiers used to calculate 'dynamic' page\n     * parts when a page is retrieved from cache.\n     *\n     * Some sub keys:\n     *\n     * 'config': This is the TypoScript ['config.'] sub-array, with some\n     *           settings being sanitized and merged.\n     *\n     * 'rootLine': This is the \"local\" rootline of a deep page that stops at the first parent\n     *             sys_template record that has \"root\" flag set, in natural parent-child order.\n     *\n     *             Both language and version overlays are applied to these page records:\n     *             All \"data\" fields are set to language / version overlay values, *except* uid and\n     *             pid, which are the default-language and live-version ids.\n     *\n     *             When page uid 5 is called in this example:\n     *             [0] Project name\n     *             |- [2] An organizational page, probably with is_siteroot=1 and a site config\n     *                |- [3] Site root with a sys_template having \"root\" flag set\n     *                   |- [5] Here you are\n     *\n     *             This rootLine is:\n     *             [0] => [uid = 3, pid = 2, title = Site root with a sys_template having \"root\" flag set, ...]\n     *             [1] => [uid = 5, pid = 3, title = Here you are, ...]\n     *\n     * @var array<string, mixed>\n     */\n    public $config = [];\n\n    /**\n     * The TypoScript template object. Used to parse the TypoScript template\n     *\n     * @var TemplateService\n     * @internal: Will get a proper deprecation in v12.x.\n     * @deprecated: TemplateService is kept for b/w compat in v12 but will be removed in v13.\n     */\n    public $tmpl;\n\n    /**\n     * Is set to the time-to-live time of cached pages. Default is 60*60*24, which is 24 hours.\n     *\n     * @internal\n     */\n    protected int $cacheTimeOutDefault = 0;\n\n    /**\n     * Set if cached content was fetched from the cache.\n     * @internal\n     */\n    protected bool $pageContentWasLoadedFromCache = false;\n\n    /**\n     * Set to the expire time of cached content\n     * @internal\n     */\n    protected int $cacheExpires = 0;\n\n    /**\n     * TypoScript configuration of the page-object.\n     * @var array|string\n     * @internal should only be used by TYPO3 Core\n     */\n    public $pSetup = '';\n\n    /**\n     * This hash is unique to the template, the $this->id and $this->type vars and\n     * the list of groups. Used to get and later store the cached data\n     * @internal\n     */\n    public string $newHash = '';\n\n    /**\n     * This flag is set before the page is generated IF $this->no_cache is set. If this\n     * flag is set after the page content was generated, $this->no_cache is forced to be set.\n     * This is done in order to make sure that PHP code from Plugins / USER scripts does not falsely\n     * clear the no_cache flag.\n     * @internal\n     */\n    protected bool $no_cacheBeforePageGen = false;\n\n    /**\n     * May be set to the pagesTSconfig\n     * @internal\n     */\n    protected ?array $pagesTSconfig = null;\n\n    /**\n     * Eg. insert JS-functions in this array ($additionalHeaderData) to include them\n     * once. Use associative keys.\n     *\n     * Keys in use:\n     *\n     * used to accumulate additional HTML-code for the header-section,\n     * <head>...</head>. Insert either associative keys (like\n     * additionalHeaderData['myStyleSheet'], see reserved keys above) or num-keys\n     * (like additionalHeaderData[] = '...')\n     *\n     * @var array\n     */\n    public $additionalHeaderData = [];\n\n    /**\n     * Used to accumulate additional HTML-code for the footer-section of the template\n     * @var array\n     */\n    public $additionalFooterData = [];\n\n    /**\n     * Default internal target\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $intTarget = '';\n\n    /**\n     * Default external target\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $extTarget = '';\n\n    /**\n     * Default file link target\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $fileTarget = '';\n\n    /**\n     * If set, typolink() function encrypts email addresses.\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected int $spamProtectEmailAddresses = 0;\n\n    /**\n     * Absolute Reference prefix\n     * @var string\n     */\n    public $absRefPrefix = '';\n\n    /**\n     * A string prepared for insertion in all links on the page as url-parameters.\n     * Based on configuration in TypoScript where you defined which GET parameters you\n     * would like to pass on.\n     * @internal if needed, generate linkVars via LinkVarsCalculator\n     */\n    public string $linkVars = '';\n\n    /**\n     * 'Global' Storage for various applications. Keys should be 'tx_'.extKey for\n     * extensions.\n     */\n    public array $applicationData = [];\n\n    public array $register = [];\n\n    /**\n     * Stack used for storing array and retrieving register arrays (see\n     * LOAD_REGISTER and RESTORE_REGISTER)\n     */\n    public array $registerStack = [];\n\n    /**\n     * Used by RecordContentObject and ContentContentObject to ensure the a records is NOT\n     * rendered twice through it!\n     */\n    public array $recordRegister = [];\n\n    /**\n     * This is set to the [table]:[uid] of the latest record rendered. Note that\n     * class ContentObjectRenderer has an equal value, but that is pointing to the\n     * record delivered in the $data-array of the ContentObjectRenderer instance, if\n     * the cObjects CONTENT or RECORD created that instance\n     */\n    public string $currentRecord = '';\n\n    /**\n     * Used to generate page-unique keys. Point is that uniqid() functions is very\n     * slow, so a unique key is made based on this, see function uniqueHash()\n     * @internal\n     */\n    protected int $uniqueCounter = 0;\n\n    /**\n     * @internal\n     */\n    protected string $uniqueString = '';\n\n    /**\n     * The base URL set for the page header.\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $baseUrl = '';\n\n    /**\n     * Page content render object\n     *\n     * @var ContentObjectRenderer\n     */\n    public $cObj;\n\n    /**\n     * All page content is accumulated in this variable. See RequestHandler\n     * @var string\n     */\n    public $content = '';\n\n    /**\n     * Info-array of the last resulting image resource of content object\n     * IMG_RESOURCE (if any), containing width, height and so on.\n     */\n    public ?array $lastImgResourceInfo = null;\n\n    /**\n     * Internal calculations for labels\n     */\n    protected ?LanguageService $languageService = null;\n\n    /**\n     * @internal Internal locking. May move to a middleware soon.\n     */\n    public ?ResourceMutex $lock = null;\n\n    protected ?PageRenderer $pageRenderer = null;\n\n    /**\n     * The page cache object, use this to save pages to the cache and to\n     * retrieve them again\n     *\n     * @var FrontendInterface\n     */\n    protected $pageCache;\n\n    protected array $pageCacheTags = [];\n\n    /**\n     * Content type HTTP header being sent in the request.\n     * @todo Ticket: #63642 Should be refactored to a request/response model later\n     * @internal Should only be used by TYPO3 core for now\n     */\n    protected string $contentType = 'text/html';\n\n    /**\n     * Doctype to use\n     *\n     * @var string\n     * @deprecated since TYPO3 v12, will be removed in TYPO3 v13. Use PageRenderer->getDocType() instead.\n     */\n    protected $xhtmlDoctype = '';\n\n    /**\n     * @var int\n     * @deprecated since TYPO3 v12, will be removed in TYPO3 v13. Use PageRenderer->getDocType() instead.\n     */\n    protected $xhtmlVersion;\n\n    /**\n     * Originally requested id from PageArguments\n     */\n    protected int $requestedId = 0;\n\n    /**\n     * The context for keeping the current state, mostly related to current page information,\n     * backend user / frontend user access, workspaceId\n     */\n    protected Context $context;\n\n    /**\n     * If debug mode is enabled, this contains the information if a page is fetched from cache,\n     * and sent as HTTP Response Header.\n     */\n    protected string $debugInformationHeader = '';\n\n    /**\n     * Since TYPO3 v10.0, TSFE is composed out of\n     *  - Context\n     *  - Site\n     *  - SiteLanguage\n     *  - PageArguments (containing ID, Type, cHash and MP arguments)\n     *\n     * Also sets a unique string (->uniqueString) for this script instance; A md5 hash of the microtime()\n     *\n     * @param Context $context the Context object to work with\n     * @param Site $site The resolved site to work with\n     * @param SiteLanguage $siteLanguage The resolved language to work with\n     * @param PageArguments $pageArguments The PageArguments object containing Page ID, type and GET parameters\n     * @param FrontendUserAuthentication $frontendUser a FrontendUserAuthentication object\n     */\n    public function __construct(Context $context, Site $site, SiteLanguage $siteLanguage, PageArguments $pageArguments, FrontendUserAuthentication $frontendUser)\n    {\n        $this->initializeContext($context);\n        $this->site = $site;\n        $this->language = $siteLanguage;\n        $this->setPageArguments($pageArguments);\n        $this->fe_user = $frontendUser;\n        $this->uniqueString = md5(microtime());\n        $this->initPageRenderer();\n        $this->initCaches();\n    }\n\n    private function initializeContext(Context $context): void\n    {\n        $this->context = $context;\n        if (!$this->context->hasAspect('frontend.preview')) {\n            $this->context->setAspect('frontend.preview', GeneralUtility::makeInstance(PreviewAspect::class));\n        }\n    }\n\n    /**\n     * Initializes the page renderer object\n     */\n    protected function initPageRenderer()\n    {\n        if ($this->pageRenderer !== null) {\n            return;\n        }\n        $this->pageRenderer = GeneralUtility::makeInstance(PageRenderer::class);\n        $this->pageRenderer->setTemplateFile('EXT:frontend/Resources/Private/Templates/MainPage.html');\n        // As initPageRenderer could be called in constructor and for USER_INTs, this information is only set\n        // once - in order to not override any previous settings of PageRenderer.\n        $this->pageRenderer->setLanguage($this->language->getTypo3Language());\n    }\n\n    /**\n     * @param string $contentType\n     * @internal Must only be used by TYPO3 core\n     */\n    public function setContentType($contentType)\n    {\n        $this->contentType = $contentType;\n    }\n\n    /********************************************\n     *\n     * Initializing, resolving page id\n     *\n     ********************************************/\n    /**\n     * Initializes the caching system.\n     */\n    protected function initCaches()\n    {\n        $cacheManager = GeneralUtility::makeInstance(CacheManager::class);\n        $this->pageCache = $cacheManager->getCache('pages');\n    }\n\n    /**\n     * Initializes the front-end user groups.\n     * Sets frontend.user aspect based on front-end user status.\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function initUserGroups()\n    {\n        trigger_error('TSFE->initUserGroups() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        $this->context->setAspect('frontend.user', $this->fe_user->createUserAspect());\n    }\n\n    /**\n     * Checking if a user is logged in or a group constellation different from \"0,-1\"\n     *\n     * @return bool TRUE if either a login user is found (array fe_user->user) OR if the gr_list is set to something else than '0,-1' (could be done even without a user being logged in!)\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function isUserOrGroupSet()\n    {\n        trigger_error('TSFE->isUserOrGroupSet() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        /** @var UserAspect $userAspect */\n        $userAspect = $this->context->getAspect('frontend.user');\n        return $userAspect->isUserOrGroupSet();\n    }\n\n    /**\n     * Checks if a backend user is logged in\n     *\n     * @return bool whether a backend user is logged in\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function isBackendUserLoggedIn()\n    {\n        trigger_error('TSFE->isBackendUserLoggedIn() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        return (bool)$this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false);\n    }\n\n    /**\n     * Resolves the page id and sets up several related properties.\n     *\n     * At this point, the Context object already contains relevant preview\n     * settings (if a backend user is logged in etc).\n     *\n     * If $this->id is not set at all, the method does its best to set the\n     * value to an integer. Resolving is based on this options:\n     *\n     * - Finding the domain record start page\n     * - First visible page\n     * - Relocating the id below the site if outside the site / domain\n     *\n     * The following properties may be set up or updated:\n     *\n     * - id\n     * - sys_page\n     * - sys_page->where_groupAccess\n     * - sys_page->where_hid_del\n     * - register['SYS_LASTCHANGED']\n     * - pageNotFound\n     *\n     * Via getPageAndRootline()\n     *\n     * - rootLine\n     * - page\n     * - MP\n     * - originalShortcutPage\n     * - originalMountPointPage\n     * - pageAccessFailureHistory['direct_access']\n     * - pageNotFound\n     */\n    public function determineId(ServerRequestInterface $request): ?ResponseInterface\n    {\n        $this->sys_page = GeneralUtility::makeInstance(PageRepository::class, $this->context);\n\n        $eventDispatcher = GeneralUtility::makeInstance(EventDispatcherInterface::class);\n        $eventDispatcher->dispatch(new BeforePageIsResolvedEvent($this, $request));\n\n        $timeTracker = $this->getTimeTracker();\n        $timeTracker->push('determineId rootLine/');\n        try {\n            // Sets ->page and ->rootline information based on ->id. ->id may change during this operation.\n            // If the found Page ID is not within the site, then pageNotFound is set.\n            $this->getPageAndRootline($request);\n            // Checks if the rootPageId of the site is in the resolved rootLine.\n            // This is necessary so that references to page-id's via ?id=123 from other sites are not possible.\n            $siteRootWithinRootlineFound = false;\n            foreach ($this->rootLine as $pageInRootLine) {\n                if ((int)$pageInRootLine['uid'] === $this->site->getRootPageId()) {\n                    $siteRootWithinRootlineFound = true;\n                    break;\n                }\n            }\n            // Page is 'not found' in case the id was outside the domain, code 3\n            // This can only happen if there was a shortcut. So $this->page is now the shortcut target\n            // But the original page is in $this->originalShortcutPage.\n            // This only happens if people actually call TYPO3 with index.php?id=123 where 123 is in a different\n            // page tree. This is not allowed.\n            $directlyRequestedId = (int)($request->getQueryParams()['id'] ?? 0);\n            if (!$siteRootWithinRootlineFound && $directlyRequestedId && (int)($this->originalShortcutPage['uid'] ?? 0) !== $directlyRequestedId) {\n                $this->pageNotFound = 3;\n                $this->id = $this->site->getRootPageId();\n                // re-get the page and rootline if the id was not found.\n                $this->getPageAndRootline($request);\n            }\n        } catch (ShortcutTargetPageNotFoundException $e) {\n            $this->pageNotFound = 1;\n        }\n        $timeTracker->pull();\n\n        $event = new AfterPageWithRootLineIsResolvedEvent($this, $request);\n        $event = $eventDispatcher->dispatch($event);\n        if ($event->getResponse()) {\n            return $event->getResponse();\n        }\n\n        $response = null;\n        try {\n            $this->evaluatePageNotFound($this->pageNotFound, $request);\n\n            // Setting language and fetch translated page\n            $this->settingLanguage($request);\n            // Check the \"content_from_pid\" field of the resolved page\n            $this->contentPid = $this->resolveContentPid($request);\n\n            // Update SYS_LASTCHANGED at the very last, when $this->page might be changed\n            // by settingLanguage() and the $this->page was finally resolved\n            $this->setRegisterValueForSysLastChanged($this->page);\n        } catch (PropagateResponseException $e) {\n            $response = $e->getResponse();\n        }\n\n        $event = new AfterPageAndLanguageIsResolvedEvent($this, $request, $response);\n        $eventDispatcher->dispatch($event);\n        return $event->getResponse();\n    }\n\n    /**\n     * If $this->pageNotFound is set, then throw an exception to stop further page generation process\n     */\n    protected function evaluatePageNotFound(int $pageNotFoundNumber, ServerRequestInterface $request): void\n    {\n        if (!$pageNotFoundNumber) {\n            return;\n        }\n        $response = match ($pageNotFoundNumber) {\n            1 => GeneralUtility::makeInstance(ErrorController::class)->accessDeniedAction(\n                $request,\n                'ID was not an accessible page',\n                $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_PAGE_NOT_RESOLVED)\n            ),\n            2 => GeneralUtility::makeInstance(ErrorController::class)->accessDeniedAction(\n                $request,\n                'Subsection was found and not accessible',\n                $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_SUBSECTION_NOT_RESOLVED)\n            ),\n            3 => GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                $request,\n                'ID was outside the domain',\n                $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_HOST_PAGE_MISMATCH)\n            ),\n            default => GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                $request,\n                'Unspecified error',\n                $this->getPageAccessFailureReasons()\n            ),\n        };\n        throw new PropagateResponseException($response, 1533931329);\n    }\n\n    /**\n     * Loads the page and root line records based on $this->id\n     *\n     * A final page and the matching root line are determined and loaded by\n     * the algorithm defined by this method.\n     *\n     * First it loads the initial page from the page repository for $this->id.\n     * If that can't be loaded directly, it gets the root line for $this->id.\n     * It walks up the root line towards the root page until the page\n     * repository can deliver a page record. (The loading restrictions of\n     * the root line records are more liberal than that of the page record.)\n     *\n     * Now the page type is evaluated and handled if necessary. If the page is\n     * a short cut, it is replaced by the target page. If the page is a mount\n     * point in overlay mode, the page is replaced by the mounted page.\n     *\n     * After this potential replacements are done, the root line is loaded\n     * (again) for this page record. It walks up the root line up to\n     * the first viewable record.\n     *\n     * (While upon the first accessibility check of the root line it was done\n     * by loading page by page from the page repository, this time the method\n     * checkRootlineForIncludeSection() is used to find the most distant\n     * accessible page within the root line.)\n     *\n     * Having found the final page id, the page record and the root line are\n     * loaded for last time by this method.\n     *\n     * Exceptions may be thrown for DOKTYPE_SPACER and not loadable page records\n     * or root lines.\n     *\n     * May set or update these properties:\n     *\n     * @see TypoScriptFrontendController::$id\n     * @see TypoScriptFrontendController::$MP\n     * @see TypoScriptFrontendController::$page\n     * @see TypoScriptFrontendController::$pageNotFound\n     * @see TypoScriptFrontendController::$pageAccessFailureHistory\n     * @see TypoScriptFrontendController::$originalMountPointPage\n     * @see TypoScriptFrontendController::$originalShortcutPage\n     *\n     * @throws \\TYPO3\\CMS\\Core\\Error\\Http\\ServiceUnavailableException\n     * @throws PageNotFoundException\n     * @throws ShortcutTargetPageNotFoundException\n     */\n    protected function getPageAndRootline(ServerRequestInterface $request)\n    {\n        $requestedPageRowWithoutGroupCheck = [];\n        $this->page = $this->sys_page->getPage($this->id);\n        if (empty($this->page)) {\n            // If no page, we try to find the page above in the rootLine.\n            // Page is 'not found' in case the id itself was not an accessible page. code 1\n            $this->pageNotFound = 1;\n            $requestedPageIsHidden = false;\n            try {\n                $hiddenField = $GLOBALS['TCA']['pages']['ctrl']['enablecolumns']['disabled'] ?? '';\n                $includeHiddenPages = $this->context->getPropertyFromAspect('visibility', 'includeHiddenPages') || $this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false);\n                if (!empty($hiddenField) && !$includeHiddenPages) {\n                    // Page is \"hidden\" => 404 (deliberately done in default language, as this cascades to language overlays)\n                    $rawPageRecord = $this->sys_page->getPage_noCheck($this->id);\n                    $requestedPageIsHidden = (bool)$rawPageRecord[$hiddenField];\n                }\n\n                $requestedPageRowWithoutGroupCheck = $this->sys_page->getPage($this->id, true);\n                if (!empty($requestedPageRowWithoutGroupCheck)) {\n                    $this->pageAccessFailureHistory['direct_access'][] = $requestedPageRowWithoutGroupCheck;\n                }\n                $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n                if (!empty($this->rootLine)) {\n                    $c = count($this->rootLine) - 1;\n                    while ($c > 0) {\n                        // Add to page access failure history:\n                        $this->pageAccessFailureHistory['direct_access'][] = $this->rootLine[$c];\n                        // Decrease to next page in rootline and check the access to that, if OK, set as page record and ID value.\n                        $c--;\n                        $this->id = (int)$this->rootLine[$c]['uid'];\n                        $this->page = $this->sys_page->getPage($this->id);\n                        if (!empty($this->page)) {\n                            break;\n                        }\n                    }\n                }\n            } catch (RootLineException $e) {\n                $this->rootLine = [];\n            }\n            // If still no page...\n            if ($requestedPageIsHidden || (empty($requestedPageRowWithoutGroupCheck) && empty($this->page))) {\n                $message = 'The requested page does not exist!';\n                try {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        $message,\n                        $this->getPageAccessFailureReasons(PageAccessFailureReasons::PAGE_NOT_FOUND)\n                    );\n                    throw new PropagateResponseException($response, 1533931330);\n                } catch (PageNotFoundException $e) {\n                    throw new PageNotFoundException($message, 1301648780);\n                }\n            }\n        }\n        // Spacer and sysfolders is not accessible in frontend\n        $pageDoktype = (int)($this->page['doktype'] ?? 0);\n        $isSpacerOrSysfolder = $pageDoktype === PageRepository::DOKTYPE_SPACER || $pageDoktype === PageRepository::DOKTYPE_SYSFOLDER;\n        // Page itself is not accessible, but the parent page is a spacer/sysfolder\n        if ($isSpacerOrSysfolder && !empty($requestedPageRowWithoutGroupCheck)) {\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->accessDeniedAction(\n                    $request,\n                    'Subsection was found and not accessible',\n                    $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_SUBSECTION_NOT_RESOLVED)\n                );\n                throw new PropagateResponseException($response, 1633171038);\n            } catch (PageNotFoundException $e) {\n                throw new PageNotFoundException('Subsection was found and not accessible', 1633171172);\n            }\n        }\n\n        if ($isSpacerOrSysfolder) {\n            $message = 'The requested page does not exist!';\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                    $request,\n                    $message,\n                    $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_INVALID_PAGETYPE)\n                );\n                throw new PropagateResponseException($response, 1533931343);\n            } catch (PageNotFoundException $e) {\n                throw new PageNotFoundException($message, 1301648781);\n            }\n        }\n        // Is the ID a link to another page??\n        if ($pageDoktype === PageRepository::DOKTYPE_SHORTCUT) {\n            // We need to clear MP if the page is a shortcut. Reason is if the shortcut goes to another page, then we LEAVE the rootline which the MP expects.\n            $this->MP = '';\n            // saving the page so that we can check later - when we know\n            // about languages - whether we took the correct shortcut or\n            // whether a translation of the page overwrites the shortcut\n            // target and we need to follow the new target\n            $this->originalShortcutPage = $this->page;\n            $this->page = $this->sys_page->resolveShortcutPage($this->page, true);\n            $this->id = (int)$this->page['uid'];\n            $pageDoktype = (int)($this->page['doktype'] ?? 0);\n        }\n        // If the page is a mountpoint which should be overlaid with the contents of the mounted page,\n        // it must never be accessible directly, but only in the mountpoint context. Therefore we change\n        // the current ID and the user is redirected by checkPageForMountpointRedirect().\n        if ($pageDoktype === PageRepository::DOKTYPE_MOUNTPOINT && $this->page['mount_pid_ol']) {\n            $this->originalMountPointPage = $this->page;\n            $this->page = $this->sys_page->getPage($this->page['mount_pid']);\n            if (empty($this->page)) {\n                $message = 'This page (ID ' . $this->originalMountPointPage['uid'] . ') is of type \"Mount point\" and '\n                    . 'mounts a page which is not accessible (ID ' . $this->originalMountPointPage['mount_pid'] . ').';\n                throw new PageNotFoundException($message, 1402043263);\n            }\n            // If the current page is a shortcut, the MP parameter will be replaced\n            if ($this->MP === '' || !empty($this->originalShortcutPage)) {\n                $this->MP = $this->page['uid'] . '-' . $this->originalMountPointPage['uid'];\n            } else {\n                $this->MP .= ',' . $this->page['uid'] . '-' . $this->originalMountPointPage['uid'];\n            }\n            $this->id = (int)$this->page['uid'];\n            $pageDoktype = (int)($this->page['doktype'] ?? 0);\n        }\n        // Gets the rootLine\n        try {\n            $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n        } catch (RootLineException $e) {\n            $this->rootLine = [];\n        }\n        // If not rootline we're off...\n        if (empty($this->rootLine)) {\n            $message = 'The requested page didn\\'t have a proper connection to the tree-root!';\n            $this->logPageAccessFailure($message, $request);\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->internalErrorAction(\n                    $request,\n                    $message,\n                    $this->getPageAccessFailureReasons(PageAccessFailureReasons::ROOTLINE_BROKEN)\n                );\n                throw new PropagateResponseException($response, 1533931350);\n            } catch (AbstractServerErrorException $e) {\n                $this->logger->error($message, ['exception' => $e]);\n                $exceptionClass = get_class($e);\n                throw new $exceptionClass($message, 1301648167);\n            }\n        }\n        // Checking for include section regarding the hidden/starttime/endtime/fe_user (that is access control of a whole subbranch!)\n        if ($this->checkRootlineForIncludeSection()) {\n            if (empty($this->rootLine)) {\n                $message = 'The requested page does not exist!';\n                try {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        $message,\n                        $this->getPageAccessFailureReasons(PageAccessFailureReasons::PAGE_NOT_FOUND)\n                    );\n                    throw new PropagateResponseException($response, 1533931351);\n                } catch (AbstractServerErrorException $e) {\n                    $this->logger->warning($message);\n                    $exceptionClass = get_class($e);\n                    throw new $exceptionClass($message, 1301648234);\n                }\n            } else {\n                $el = reset($this->rootLine);\n                $this->id = (int)$el['uid'];\n                $this->page = $this->sys_page->getPage($this->id);\n                try {\n                    $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n                } catch (RootLineException $e) {\n                    $this->rootLine = [];\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if visibility of the page is blocked upwards in the root line.\n     *\n     * If any page in the root line is blocking visibility, true is returned.\n     *\n     * All pages from the blocking page downwards are removed from the root\n     * line, so that the remaining pages can be used to relocate the page up\n     * to lowest visible page.\n     *\n     * The blocking feature of a page must be turned on by setting the page\n     * record field 'extendToSubpages' to 1 in case of hidden, starttime,\n     * endtime or fe_group restrictions.\n     *\n     * Additionally, this method checks for backend user sections in root line\n     * and if found, evaluates if a backend user is logged in and has access.\n     *\n     * Recyclers are also checked and trigger page not found if found in root\n     * line.\n     *\n     * @todo Find a better name, i.e. checkVisibilityByRootLine\n     * @todo Invert boolean return value. Return true if visible.\n     */\n    protected function checkRootlineForIncludeSection(): bool\n    {\n        $c = count($this->rootLine);\n        $removeTheRestFlag = false;\n        $accessVoter = GeneralUtility::makeInstance(RecordAccessVoter::class);\n        for ($a = 0; $a < $c; $a++) {\n            if (!$accessVoter->accessGrantedForPageInRootLine($this->rootLine[$a], $this->context)) {\n                // Add to page access failure history and mark the page as not found\n                // Keep the rootline however to trigger an access denied error instead of a service unavailable error\n                $this->pageAccessFailureHistory['sub_section'][] = $this->rootLine[$a];\n                $this->pageNotFound = 2;\n            }\n\n            if ((int)$this->rootLine[$a]['doktype'] === PageRepository::DOKTYPE_BE_USER_SECTION) {\n                // If there is a backend user logged in, check if they have read access to the page:\n                if ($this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false)) {\n                    // If there was no page selected, the user apparently did not have read access to the\n                    // current page (not position in rootline) and we set the remove-flag...\n                    if (!$this->getBackendUser()->doesUserHaveAccess($this->page, Permission::PAGE_SHOW)) {\n                        $removeTheRestFlag = true;\n                    }\n                } else {\n                    // Don't go here, if there is no backend user logged in.\n                    $removeTheRestFlag = true;\n                }\n            } elseif ((int)$this->rootLine[$a]['doktype'] === PageRepository::DOKTYPE_RECYCLER) {\n                // page is in a recycler\n                $removeTheRestFlag = true;\n            }\n            if ($removeTheRestFlag) {\n                // Page is 'not found' in case a subsection was found and not accessible, code 2\n                $this->pageNotFound = 2;\n                unset($this->rootLine[$a]);\n            }\n        }\n        return $removeTheRestFlag;\n    }\n\n    /**\n     * Checks page record for enableFields\n     * Returns TRUE if enableFields does not disable the page record.\n     * Takes notice of the includeHiddenPages visibility aspect flag and uses SIM_ACCESS_TIME for start/endtime evaluation\n     *\n     * @param array $row The page record to evaluate (needs fields: hidden, starttime, endtime, fe_group)\n     * @param bool $bypassGroupCheck Bypass group-check\n     * @return bool TRUE, if record is viewable.\n     * @deprecated since TYPO3 v12, will be removed in TYPO3 v13. Use RecordAccessVoter instead.\n     */\n    public function checkEnableFields($row, $bypassGroupCheck = false)\n    {\n        trigger_error(\n            'Method ' . __METHOD__ . ' has been deprecated in v12 and will be removed with v13. Use RecordAccessVoter instead.',\n            E_USER_DEPRECATED\n        );\n        return GeneralUtility::makeInstance(RecordAccessVoter::class)->accessGranted('pages', $row, $this->context);\n    }\n\n    /**\n     * Analysing $this->pageAccessFailureHistory into a summary array telling which features disabled display and on which pages and conditions. That data can be used inside a page-not-found handler\n     *\n     * @param string|null $failureReasonCode the error code to be attached (optional), see PageAccessFailureReasons list for details\n     * @return array Summary of why page access was not allowed.\n     */\n    public function getPageAccessFailureReasons(string $failureReasonCode = null)\n    {\n        $output = [];\n        if ($failureReasonCode) {\n            $output['code'] = $failureReasonCode;\n        }\n        $combinedRecords = array_merge(\n            is_array($this->pageAccessFailureHistory['direct_access'] ?? false) ? $this->pageAccessFailureHistory['direct_access'] : [['fe_group' => 0]],\n            is_array($this->pageAccessFailureHistory['sub_section'] ?? false) ? $this->pageAccessFailureHistory['sub_section'] : []\n        );\n        if (!empty($combinedRecords)) {\n            $accessVoter = GeneralUtility::makeInstance(RecordAccessVoter::class);\n            foreach ($combinedRecords as $k => $pagerec) {\n                // If $k=0 then it is the very first page the original ID was pointing at and that will get a full check of course\n                // If $k>0 it is parent pages being tested. They are only significant for the access to the first page IF they had the extendToSubpages flag set, hence checked only then!\n                if (!$k || $pagerec['extendToSubpages']) {\n                    if ($pagerec['hidden'] ?? false) {\n                        $output['hidden'][$pagerec['uid']] = true;\n                    }\n                    if (isset($pagerec['starttime']) && $pagerec['starttime'] > $GLOBALS['SIM_ACCESS_TIME']) {\n                        $output['starttime'][$pagerec['uid']] = $pagerec['starttime'];\n                    }\n                    if (isset($pagerec['endtime']) && $pagerec['endtime'] != 0 && $pagerec['endtime'] <= $GLOBALS['SIM_ACCESS_TIME']) {\n                        $output['endtime'][$pagerec['uid']] = $pagerec['endtime'];\n                    }\n                    if (!$accessVoter->groupAccessGranted('pages', $pagerec, $this->context)) {\n                        $output['fe_group'][$pagerec['uid']] = $pagerec['fe_group'];\n                    }\n                }\n            }\n        }\n        return $output;\n    }\n\n    /********************************************\n     *\n     * Template and caching related functions.\n     *\n     *******************************************/\n\n    protected function setPageArguments(PageArguments $pageArguments): void\n    {\n        $this->pageArguments = $pageArguments;\n        $this->id = $pageArguments->getPageId();\n        // We store the originally requested id\n        $this->requestedId = $this->id;\n        $this->type = (int)($pageArguments->getPageType() ?: 0);\n        if ($GLOBALS['TYPO3_CONF_VARS']['FE']['enable_mount_pids']) {\n            $this->MP = (string)($pageArguments->getArguments()['MP'] ?? '');\n            // Ensure no additional arguments are given via the &MP=123-345,908-172 (e.g. \"/\")\n            $this->MP = preg_replace('/[^0-9,-]/', '', $this->MP);\n        }\n    }\n\n    /**\n     * Fetches the arguments that are relevant for creating the hash base from the given PageArguments object.\n     * Excluded parameters are not taken into account when calculating the hash base.\n     */\n    protected function getRelevantParametersForCachingFromPageArguments(PageArguments $pageArguments): array\n    {\n        $queryParams = $pageArguments->getDynamicArguments();\n        if (!empty($queryParams) && ($pageArguments->getArguments()['cHash'] ?? false)) {\n            $queryParams['id'] = $pageArguments->getPageId();\n            return GeneralUtility::makeInstance(CacheHashCalculator::class)\n                ->getRelevantParameters(HttpUtility::buildQueryString($queryParams));\n        }\n        return [];\n    }\n\n    /**\n     * This is a central and quite early method called by PrepareTypoScriptFrontendRendering middleware:\n     * This code is *always* executed for *every* frontend call if a general page rendering has to be done,\n     * if there is no early redirect or eid call or similar.\n     *\n     * The goal is to calculate dependencies up to a point to see if a possible page cache can be used,\n     * and to prepare TypoScript as far as really needed.\n     *\n     * @throws PropagateResponseException\n     * @throws AbstractServerErrorException\n     * @return ServerRequestInterface New request object with typoscript attribute\n     *\n     * @internal This method may vanish from TypoScriptFrontendController without further notice.\n     * @todo: This method is typically called by PrepareTypoScriptFrontendRendering middleware.\n     *        However, the RedirectService of (earlier) ext:redirects RedirectHandler middleware\n     *        calls this as well. We may want to put this code into some helper class, reduce class\n     *        state as much as possible and carry really needed state as request attributes around?!\n     */\n    public function getFromCache(ServerRequestInterface $request): ServerRequestInterface\n    {\n        // Reset some state.\n        // @todo: Find out which resets are really needed here - Since this is called from a\n        //        relatively early middleware, we can expect these properties to be not set already?!\n        $this->content = '';\n        $this->config = [];\n        $this->pageContentWasLoadedFromCache = false;\n\n        // Very first thing, *always* executed: TypoScript is one factor that influences page content.\n        // There can be multiple cache entries per page, when TypoScript conditions on the same page\n        // create different TypoScript. We thus need the sys_template rows relevant for this page.\n        // @todo: Even though all rootline sys_template records are fetched with only one query\n        //        in below implementation, we could potentially join or sub select sys_template\n        //        records already when pages rootline is queried. This will safe one query\n        //        and needs an implementation in getPageAndRootline() which is called via determineId()\n        //        in TypoScriptFrontendInitialization. This could be done when getPageAndRootline()\n        //        switches to a CTE query instead of using RootlineUtility.\n        $sysTemplateRepository = GeneralUtility::makeInstance(SysTemplateRepository::class);\n        $sysTemplateRows = $sysTemplateRepository->getSysTemplateRowsByRootline($this->rootLine, $request);\n        // Needed for cache calculations. Put into a variable here to not serialize multiple times.\n        $serializedSysTemplateRows = serialize($sysTemplateRows);\n\n        // Early exception if there is no sys_template at all.\n        if (empty($sysTemplateRows)) {\n            $message = 'No TypoScript record found!';\n            $this->logger->alert($message);\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->internalErrorAction(\n                    $request,\n                    $message,\n                    ['code' => PageAccessFailureReasons::RENDERING_INSTRUCTIONS_NOT_FOUND]\n                );\n                throw new PropagateResponseException($response, 1533931380);\n            } catch (AbstractServerErrorException $e) {\n                $exceptionClass = get_class($e);\n                throw new $exceptionClass($message, 1294587218);\n            }\n        }\n\n        if (!$this->tmpl instanceof TemplateService) {\n            // @deprecated since v12, will be removed in v13: b/w compat. Remove when TemplateService is dropped.\n            $this->tmpl = GeneralUtility::makeInstance(TemplateService::class, $this->context, null, $this);\n        }\n\n        // Calculate \"local\" rootLine that stops at first root=1 template, will be set as $this->config['rootLine']\n        $sysTemplateRowsIndexedByPid = array_combine(array_column($sysTemplateRows, 'pid'), $sysTemplateRows);\n        $localRootline = [];\n        foreach ($this->rootLine as $rootlinePage) {\n            array_unshift($localRootline, $rootlinePage);\n            if ((int)($rootlinePage['uid'] ?? 0) > 0\n                && (int)($sysTemplateRowsIndexedByPid[$rootlinePage['uid']]['root'] ?? 0) === 1\n            ) {\n                break;\n            }\n        }\n        // @deprecated: since v12, will be removed in v13: b/w compat. Remove when TemplateService is dropped.\n        $this->tmpl->rootLine = $localRootline;\n\n        $tokenizer = new LossyTokenizer();\n        $treeBuilder = GeneralUtility::makeInstance(SysTemplateTreeBuilder::class);\n        $includeTreeTraverser = new IncludeTreeTraverser();\n        $includeTreeTraverserConditionVerdictAware = new ConditionVerdictAwareIncludeTreeTraverser();\n        $frontendConditionMatcher = GeneralUtility::makeInstance(FrontendConditionMatcher::class, $this->context, $this->id, $this->rootLine);\n        $cacheManager = GeneralUtility::makeInstance(CacheManager::class);\n        /** @var PhpFrontend|null $typoscriptCache */\n        $typoscriptCache = null;\n        if (!$this->no_cache) {\n            // $this->no_cache = true might have been set by earlier TypoScriptFrontendInitialization middleware.\n            // This means we don't do fancy cache stuff, calculate full TypoScript and ignore page cache.\n            /** @var PhpFrontend|null $typoscriptCache */\n            $typoscriptCache = $cacheManager->getCache('typoscript');\n        }\n\n        // We *always* need the TypoScript constants, one way or the other: Setup conditions can use constants,\n        // so we need the constants to substitute their values within setup conditions.\n        $constantConditionIncludeListCacheIdentifier = 'constant-condition-include-list-' . sha1($serializedSysTemplateRows);\n        $constantConditionList = [];\n        $constantsAst = new RootNode();\n        $flatConstants = [];\n        $serializedConstantConditionList = '';\n        $gotConstantFromCache = false;\n        if (!$this->no_cache && $constantConditionIncludeTree = $typoscriptCache->require($constantConditionIncludeListCacheIdentifier)) {\n            // We got the flat list of all constants conditions for this TypoScript combination from cache. Good. We traverse\n            // this list to calculate \"current\" condition verdicts. With a hash of this list together with a hash of the\n            // TypoScript sys_templates, we try to retrieve the full constants TypoScript from cache.\n            $conditionMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $conditionMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverser->addVisitor($conditionMatcherVisitor);\n            // It does not matter if we use IncludeTreeTraverser or ConditionVerdictAwareIncludeTreeTraverser here:\n            // Condition list is flat, not nested. IncludeTreeTraverser has an if() less, so we use that one.\n            $includeTreeTraverser->traverse($constantConditionIncludeTree);\n            $constantConditionList = $conditionMatcherVisitor->getConditionListWithVerdicts();\n            // Needed for cache identifier calculations. Put into a variable here to not serialize multiple times.\n            $serializedConstantConditionList = serialize($constantConditionList);\n            $constantCacheEntryIdentifier = 'constant-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList);\n            $constantsCacheEntry = $typoscriptCache->require($constantCacheEntryIdentifier);\n            if (is_array($constantsCacheEntry)) {\n                $constantsAst = $constantsCacheEntry['ast'];\n                $flatConstants = $constantsCacheEntry['flatConstants'];\n                $gotConstantFromCache = true;\n            }\n        }\n        if ($this->no_cache || !$gotConstantFromCache) {\n            // We did not get constants from cache, or are not allowed to use cache. We have to build constants from scratch.\n            // This means we'll fetch the full constants include tree (from cache if possible), register the condition\n            // matcher and register the AST builder and traverse include tree to retrieve constants AST and calculate\n            // 'flat constants' from it. Both are cached if allowed afterwards for the 'if' above to kick in next time.\n            if ($this->no_cache) {\n                // Note $typoscriptCache *is not* hand over here: IncludeTree is calculated from scratch, we're not allowed to use cache.\n                $constantIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('constants', $sysTemplateRows, $tokenizer, $this->getSite());\n            } else {\n                // Note $typoscriptCache *is* hand over here, we can potentially grab the fully cached includeTree here, or cache entry will be created.\n                $constantIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('constants', $sysTemplateRows, $tokenizer, $this->getSite(), $typoscriptCache);\n            }\n            $conditionMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $conditionMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverserConditionVerdictAware->addVisitor($conditionMatcherVisitor);\n            $constantAstBuilderVisitor = GeneralUtility::makeInstance(IncludeTreeAstBuilderVisitor::class);\n            $includeTreeTraverserConditionVerdictAware->addVisitor($constantAstBuilderVisitor);\n            // We must use ConditionVerdictAwareIncludeTreeTraverser here: This one does not walk into\n            // children for not matching conditions, which is important to create the correct AST.\n            $includeTreeTraverserConditionVerdictAware->traverse($constantIncludeTree);\n            $constantsAst = $constantAstBuilderVisitor->getAst();\n            $flatConstants = $constantsAst->flatten();\n            if (!$this->no_cache) {\n                // We are allowed to cache and can create both the full list of conditions, plus the constant AST and flat constant\n                // list cache entry. To do that, we need all (!) conditions, but the above ConditionVerdictAwareIncludeTreeTraverser\n                // did not find nested conditions if an upper condition did not match. We thus have to traverse include tree a\n                // second time with the IncludeTreeTraverser that does traverse into not matching conditions as well.\n                $includeTreeTraverser->resetVisitors();\n                $conditionMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n                $conditionMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n                $includeTreeTraverser->addVisitor($conditionMatcherVisitor);\n                $constantConditionIncludeListAccumulatorVisitor = new IncludeTreeConditionIncludeListAccumulatorVisitor();\n                $includeTreeTraverser->addVisitor($constantConditionIncludeListAccumulatorVisitor);\n                $includeTreeTraverser->traverse($constantIncludeTree);\n                $constantConditionList = $conditionMatcherVisitor->getConditionListWithVerdicts();\n                // Needed for cache identifier calculations. Put into a variable here to not serialize multiple times.\n                $serializedConstantConditionList = serialize($constantConditionList);\n                $typoscriptCache->set($constantConditionIncludeListCacheIdentifier, 'return unserialize(\\'' . addcslashes(serialize($constantConditionIncludeListAccumulatorVisitor->getConditionIncludes()), '\\'\\\\') . '\\');');\n                $constantCacheEntryIdentifier = 'constant-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList);\n                $typoscriptCache->set($constantCacheEntryIdentifier, 'return unserialize(\\'' . addcslashes(serialize(['ast' => $constantsAst, 'flatConstants' => $flatConstants]), '\\'\\\\') . '\\');');\n            }\n        }\n\n        $frontendTypoScript = new FrontendTypoScript($constantsAst, $flatConstants);\n\n        // Next step: We have constants and fetch the setup include tree now. We then calculate setup condition verdicts\n        // and set the constants to allow substitution of constants within conditions. Next, we traverse include tree\n        // to calculate conditions verdicts and gather them along the way. A hash of these conditions with their verdicts\n        // is then part of the page cache identifier hash: When a condition on a page creates a different result, the hash\n        // is different from an existing page cache entry and a new one is created later.\n        $setupConditionIncludeListCacheIdentifier = 'setup-condition-include-list-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList);\n        $setupConditionList = [];\n        $gotSetupConditionsFromCache = false;\n        if (!$this->no_cache && $setupConditionIncludeTree = $typoscriptCache->require($setupConditionIncludeListCacheIdentifier)) {\n            // We got the flat list of all setup conditions for this TypoScript combination from cache. Good. We traverse\n            // this list to calculate \"current\" condition verdicts, which we need as hash to be part of page cache identifier.\n            $includeTreeTraverser->resetVisitors();\n            $setupConditionConstantSubstitutionVisitor = new IncludeTreeSetupConditionConstantSubstitutionVisitor();\n            $setupConditionConstantSubstitutionVisitor->setFlattenedConstants($flatConstants);\n            $includeTreeTraverser->addVisitor($setupConditionConstantSubstitutionVisitor);\n            $setupMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $setupMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverser->addVisitor($setupMatcherVisitor);\n            // It does not matter if we use IncludeTreeTraverser or ConditionVerdictAwareIncludeTreeTraverser here:\n            // Condition list is flat, not nested. IncludeTreeTraverser has an if() less, so we use that one.\n            $includeTreeTraverser->traverse($setupConditionIncludeTree);\n            $setupConditionList = $setupMatcherVisitor->getConditionListWithVerdicts();\n            $gotSetupConditionsFromCache = true;\n        }\n        if ($this->no_cache || !$gotSetupConditionsFromCache) {\n            // We did not get setup condition list from cache, or are not allowed to use cache. We have to build setup\n            // condition list from scratch. This means we'll fetch the full setup include tree (from cache if possible),\n            // register the constant substitution visitor, and register condition matcher and register the condition\n            // accumulator visitor.\n            if ($this->no_cache) {\n                // Note $typoscriptCache *is not* hand over here: IncludeTree is calculated from scratch, we're not allowed to use cache.\n                $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite());\n            } else {\n                // Note $typoscriptCache *is* hand over here, we can potentially grab the fully cached includeTree here, or cache entry will be created.\n                $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite(), $typoscriptCache);\n            }\n            $includeTreeTraverser->resetVisitors();\n            $setupConditionConstantSubstitutionVisitor = new IncludeTreeSetupConditionConstantSubstitutionVisitor();\n            $setupConditionConstantSubstitutionVisitor->setFlattenedConstants($flatConstants);\n            $includeTreeTraverser->addVisitor($setupConditionConstantSubstitutionVisitor);\n            $setupMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $setupMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverser->addVisitor($setupMatcherVisitor);\n            $setupConditionIncludeListAccumulatorVisitor = new IncludeTreeConditionIncludeListAccumulatorVisitor();\n            $includeTreeTraverser->addVisitor($setupConditionIncludeListAccumulatorVisitor);\n            // It is important we use IncludeTreeTraverser here: We to have the condition verdicts of *all* conditions, plus\n            // want to accumulate all of them. The ConditionVerdictAwareIncludeTreeTraverser wouldn't walk into nested\n            // conditions if an upper one does not match.\n            $includeTreeTraverser->traverse($setupIncludeTree);\n            $setupConditionList = $setupMatcherVisitor->getConditionListWithVerdicts();\n            if (!$this->no_cache) {\n                $typoscriptCache->set($setupConditionIncludeListCacheIdentifier, 'return unserialize(\\'' . addcslashes(serialize($setupConditionIncludeListAccumulatorVisitor->getConditionIncludes()), '\\'\\\\') . '\\');');\n            }\n        }\n\n        // We now gathered everything to calculate the page cache identifier: It depends on sys_template rows, the calculated\n        // constant condition verdicts, the setup condition verdicts, plus various not TypoScript related details like\n        // obviously the page id.\n        $this->lock = GeneralUtility::makeInstance(ResourceMutex::class);\n        $this->newHash = $this->createHashBase($sysTemplateRows, $constantConditionList, $setupConditionList);\n        if (!$this->no_cache) {\n            if ($this->shouldAcquireCacheData($request)) {\n                // Try to get a page cache row.\n                $this->getTimeTracker()->push('Cache Row');\n                $pageCacheRow = $this->pageCache->get($this->newHash);\n                if (!is_array($pageCacheRow)) {\n                    // Nothing in the cache, we acquire an exclusive lock now.\n                    // There are two scenarios when locking: We're either the first process acquiring this lock. This means we'll\n                    // \"immediately\" get it and can continue with page rendering. Or, another process acquired the lock already. In\n                    // this case, the below call will wait until the lock is released again. The other process then probably wrote\n                    // a page cache entry, which we can use.\n                    // To handle the second case - if our process had to wait for another one creating the content for us - we\n                    // simply query the page cache again to see if there is a page cache now.\n                    $hadToWaitForLock = $this->lock->acquireLock('pages', $this->newHash);\n                    // From this point on we're the only one working on that page.\n                    if ($hadToWaitForLock) {\n                        // Query the cache again to see if the data is there meanwhile: We did not get the lock\n                        // immediately, chances are high the other process created a page cache for us.\n                        // There is a small chance the other process actually pageCache->set() the content,\n                        // but pageCache->get() still returns false, for instance when a database returned \"done\"\n                        // for the INSERT, but SELECT still does not return the new row - may happen in multi-head\n                        // DB instances, and with some other distributed cache backends as well. The worst that\n                        // can happen here is the page generation is done too often, which we accept as trade-off.\n                        $pageCacheRow = $this->pageCache->get($this->newHash);\n                        if (is_array($pageCacheRow)) {\n                            // We have the content, some other process did the work for us, release our lock again.\n                            $this->releaseLocks();\n                        }\n                    }\n                    // We keep the lock set, because we are the ones generating the page now and filling the cache.\n                    // This indicates that we have to release the lock later in releaseLocks()!\n                }\n                if (is_array($pageCacheRow)) {\n                    // Note this especially populates $this->config!\n                    $this->populatePageDataFromCache($pageCacheRow);\n                }\n                $this->getTimeTracker()->pull();\n            } else {\n                // User forced page cache rebuilding. Get a lock for the page content so other processes can't interfere.\n                $this->lock->acquireLock('pages', $this->newHash);\n            }\n        } else {\n            // Caching is not allowed. We'll rebuild the page. Lock this.\n            $this->lock->acquireLock('pages', $this->newHash);\n        }\n\n        $forceTemplateParsing = $this->context->getPropertyFromAspect('typoscript', 'forcedTemplateParsing');\n        if ($this->no_cache || empty($this->config) || $this->isINTincScript() || $forceTemplateParsing) {\n            // We don't need the full setup AST in many cached scenarios. However, if no_cache is set, if no page cache\n            // entry could be loaded, if the page cache entry has _INT object, or if the user forced template\n            // parsing (adminpanel), then we still need the full setup AST. If there is \"just\" an _INT object, we can\n            // use a possible cache entry for the setup AST, which speeds up _INT parsing quite a bit. In other cases\n            // we calculate full setup AST and cache it if allowed.\n            $setupTypoScriptCacheIdentifier = 'setup-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList . serialize($setupConditionList));\n            $gotSetupFromCache = false;\n            $setupArray = [];\n            if (!$this->no_cache && !$forceTemplateParsing) {\n                // We need AST, but we are allowed to potentially get it from cache.\n                if ($setupTypoScriptCache = $typoscriptCache->require($setupTypoScriptCacheIdentifier)) {\n                    $frontendTypoScript->setSetupTree($setupTypoScriptCache['ast']);\n                    $setupArray = $setupTypoScriptCache['array'];\n                    $gotSetupFromCache = true;\n                }\n            }\n            if ($this->no_cache || $forceTemplateParsing || !$gotSetupFromCache) {\n                // We need AST and couldn't get it from cache or are now allowed to. We thus need the full setup\n                // IncludeTree, which we can get from cache again if allowed, or is calculated a-new if not.\n                if ($this->no_cache || $forceTemplateParsing) {\n                    // Note $typoscriptCache *is not* hand over here: IncludeTree is calculated from scratch, we're not allowed to use cache.\n                    $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite());\n                } else {\n                    // Note $typoscriptCache *is* hand over here, we can potentially grab the fully cached includeTree here, or cache entry will be created.\n                    $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite(), $typoscriptCache);\n                }\n                $includeTreeTraverserConditionVerdictAware->resetVisitors();\n                $setupConditionConstantSubstitutionVisitor = new IncludeTreeSetupConditionConstantSubstitutionVisitor();\n                $setupConditionConstantSubstitutionVisitor->setFlattenedConstants($flatConstants);\n                $includeTreeTraverserConditionVerdictAware->addVisitor($setupConditionConstantSubstitutionVisitor);\n                $setupMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n                $setupMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n                $includeTreeTraverserConditionVerdictAware->addVisitor($setupMatcherVisitor);\n                $setupAstBuilderVisitor = GeneralUtility::makeInstance(IncludeTreeAstBuilderVisitor::class);\n                $setupAstBuilderVisitor->setFlatConstants($flatConstants);\n                $includeTreeTraverserConditionVerdictAware->addVisitor($setupAstBuilderVisitor);\n                $includeTreeTraverserConditionVerdictAware->traverse($setupIncludeTree);\n                $setupAst = $setupAstBuilderVisitor->getAst();\n                $frontendTypoScript->setSetupTree($setupAst);\n\n                // Create top-level setup AST 'types' node from all top-level PAGE objects.\n                // This is essentially a preparation for type-lookup below and should vanish later.\n                $typesNode = new ChildNode('types');\n                $gotTypeNumZero = false;\n                foreach ($setupAst->getNextChild() as $setupChild) {\n                    if ($setupChild->getValue() === 'PAGE') {\n                        $typeNumChild = $setupChild->getChildByName('typeNum');\n                        if ($typeNumChild) {\n                            $typeNumValue = $typeNumChild->getValue();\n                            $typesSubNode = new ChildNode($typeNumValue);\n                            $typesSubNode->setValue($setupChild->getName());\n                            $typesNode->addChild($typesSubNode);\n                            if ($typeNumValue === '0') {\n                                $gotTypeNumZero = true;\n                            }\n                        } elseif (!$gotTypeNumZero) {\n                            // The first PAGE node that has no typeNum = 0 is considered '0' automatically.\n                            $typesSubNode = new ChildNode('0');\n                            $typesSubNode->setValue($setupChild->getName());\n                            $typesNode->addChild($typesSubNode);\n                            $gotTypeNumZero = true;\n                        }\n                    }\n                }\n                if ($typesNode->hasChildren()) {\n                    $setupAst->addChild($typesNode);\n                }\n                $setupArray = $setupAst->toArray();\n                if (!$this->no_cache && !$forceTemplateParsing) {\n                    // Write cache entry for AST and its array representation, we're allowed to do it.\n                    $typoscriptCache->set($setupTypoScriptCacheIdentifier, 'return unserialize(\\'' . addcslashes(serialize(['ast' => $setupAst, 'array' => $setupArray]), '\\'\\\\') . '\\');');\n                }\n            }\n\n            $typoScriptPageTypeName = $setupArray['types.'][$this->type] ?? '';\n            $this->pSetup = $setupArray[$typoScriptPageTypeName . '.'] ?? '';\n\n            if (!is_array($this->pSetup)) {\n                $this->logger->alert('The page is not configured! [type={type}][{type_name}].', ['type' => $this->type, 'type_name' => $typoScriptPageTypeName]);\n                try {\n                    $message = 'The page is not configured! [type=' . $this->type . '][' . $typoScriptPageTypeName . '].';\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->internalErrorAction(\n                        $request,\n                        $message,\n                        ['code' => PageAccessFailureReasons::RENDERING_INSTRUCTIONS_NOT_CONFIGURED]\n                    );\n                    throw new PropagateResponseException($response, 1533931374);\n                } catch (AbstractServerErrorException $e) {\n                    $explanation = 'This means that there is no TypoScript object of type PAGE with typeNum=' . $this->type . ' configured.';\n                    $exceptionClass = get_class($e);\n                    throw new $exceptionClass($message . ' ' . $explanation, 1294587217);\n                }\n            }\n\n            if (!isset($this->config['config'])) {\n                $this->config['config'] = [];\n            }\n            // Filling the config-array, first with the main \"config.\" part\n            if (is_array($setupArray['config.'] ?? null)) {\n                // @todo: These operations should happen on AST instead and array is exported (and cached) afterwards\n                $setupArray['config.'] = array_replace_recursive($setupArray['config.'], $this->config['config']);\n                $this->config['config'] = $setupArray['config.'];\n            }\n            // Override it with the page/type-specific \"config.\"\n            if (is_array($this->pSetup['config.'] ?? null)) {\n                $this->config['config'] = array_replace_recursive($this->config['config'], $this->pSetup['config.']);\n            }\n            $this->config['rootLine'] = $localRootline;\n            $frontendTypoScript->setSetupArray($setupArray);\n\n            // @deprecated: since v12, will be removed in v13: b/w compat. Remove when TemplateService is dropped.\n            $this->tmpl->setup = $setupArray;\n            $this->tmpl->loaded = true;\n            $this->tmpl->flatSetup = $flatConstants;\n        }\n\n        // Set $this->no_cache TRUE if the config.no_cache value is set!\n        if (!$this->no_cache && ($this->config['config']['no_cache'] ?? false)) {\n            $this->set_no_cache('config.no_cache is set', true);\n        }\n\n        // Auto-configure settings when a site is configured\n        $this->config['config']['absRefPrefix'] = $this->config['config']['absRefPrefix'] ?? 'auto';\n\n        // Hook for postProcessing the configuration array\n        $params = ['config' => &$this->config['config']];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS']['tslib/class.tslib_fe.php']['configArrayPostProc'] ?? [] as $funcRef) {\n            GeneralUtility::callUserFunction($funcRef, $params, $this);\n        }\n\n        return $request->withAttribute('frontend.typoscript', $frontendTypoScript);\n    }\n\n    /**\n     * This method properly sets the values given from the pages cache into the corresponding\n     * TSFE variables. The counterpart is setPageCacheContent() where all relevant information is fetched.\n     * This also contains all data that could be cached, even for pages that are partially cached, as they\n     * have non-cacheable content still to be rendered.\n     *\n     * @see getFromCache()\n     * @see setPageCacheContent()\n     * @internal\n     */\n    protected function populatePageDataFromCache(array $cachedData): void\n    {\n        // Call hook when a page is retrieved from cache\n        $_params = ['pObj' => &$this, 'cache_pages_row' => &$cachedData];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS']['tslib/class.tslib_fe.php']['pageLoadedFromCache'] ?? [] as $_funcRef) {\n            GeneralUtility::callUserFunction($_funcRef, $_params, $this);\n        }\n        // Fetches the lowlevel config stored with the cached data\n        $this->config = $cachedData['cache_data'];\n        // Getting the content\n        $this->content = $cachedData['content'];\n        // Getting the content type\n        $this->contentType = $cachedData['contentType'] ?? $this->contentType;\n        // Setting flag, so we know, that some cached content has been loaded\n        $this->pageContentWasLoadedFromCache = true;\n        $this->cacheExpires = $cachedData['expires'];\n        // Restore the current tags as they can be retrieved by getPageCacheTags()\n        $this->pageCacheTags = $cachedData['cacheTags'] ?? [];\n\n        if (isset($this->config['config']['debug'])) {\n            $debugCacheTime = (bool)$this->config['config']['debug'];\n        } else {\n            $debugCacheTime = !empty($GLOBALS['TYPO3_CONF_VARS']['FE']['debug']);\n        }\n        if ($debugCacheTime) {\n            $dateFormat = $GLOBALS['TYPO3_CONF_VARS']['SYS']['ddmmyy'];\n            $timeFormat = $GLOBALS['TYPO3_CONF_VARS']['SYS']['hhmm'];\n            $this->debugInformationHeader = 'Cached page generated ' . date($dateFormat . ' ' . $timeFormat, $cachedData['tstamp'])\n                . '. Expires ' . date($dateFormat . ' ' . $timeFormat, $cachedData['expires']);\n        }\n    }\n\n    /**\n     * Detecting if shift-reload has been clicked.\n     * This option will have no effect if re-generation of page happens by other reasons (for instance that the page is not in cache yet).\n     * Also, a backend user MUST be logged in for the shift-reload to be detected due to DoS-attack-security reasons.\n     *\n     * @return bool If shift-reload in client browser has been clicked, disable getting cached page and regenerate the page content.\n     * @internal\n     */\n    protected function shouldAcquireCacheData(ServerRequestInterface $request): bool\n    {\n        // Trigger event for possible by-pass of requiring of page cache (for re-caching purposes)\n        $event = new ShouldUseCachedPageDataIfAvailableEvent($request, $this, !$this->no_cache);\n        GeneralUtility::makeInstance(EventDispatcherInterface::class)->dispatch($event);\n        return $event->shouldUseCachedPageData();\n    }\n\n    /**\n     * This creates a hash used as page cache entry identifier and as page generation lock.\n     * When multiple requests try to render the same page that will result in the same page cache entry,\n     * this lock allows creation by one request which typically puts the result into page cache, while\n     * the other requests wait until this finished and re-use the result.\n     *\n     * This hash is unique to the TS template and constant and setup condition verdict,\n     * the variables ->id, ->type, list of frontend user groups, ->MP (Mount Points) and cHash array.\n     *\n     * @return string Page cache entry identifier also used as page generation lock\n     */\n    protected function createHashBase(array $sysTemplateRows, array $constantConditionList, array $setupConditionList): string\n    {\n        // Fetch the list of user groups\n        /** @var UserAspect $userAspect */\n        $userAspect = $this->context->getAspect('frontend.user');\n        $hashParameters = [\n            'id' => $this->id,\n            'type' => $this->type,\n            'groupIds' => (string)implode(',', $userAspect->getGroupIds()),\n            'MP' => (string)$this->MP,\n            'site' => $this->site->getIdentifier(),\n            // Ensure the language base is used for the hash base calculation as well, otherwise TypoScript and page-related rendering\n            // is not cached properly as we don't have any language-specific conditions anymore\n            'siteBase' => (string)$this->language->getBase(),\n            // additional variation trigger for static routes\n            'staticRouteArguments' => $this->pageArguments->getStaticArguments(),\n            // dynamic route arguments (if route was resolved)\n            'dynamicArguments' => $this->getRelevantParametersForCachingFromPageArguments($this->pageArguments),\n            'sysTemplateRows' => $sysTemplateRows,\n            'constantConditionList' => $constantConditionList,\n            'setupConditionList' => $setupConditionList,\n        ];\n        // Call hook to influence the hash calculation\n        $_params = [\n            'hashParameters' => &$hashParameters,\n        ];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS']['tslib/class.tslib_fe.php']['createHashBase'] ?? [] as $_funcRef) {\n            GeneralUtility::callUserFunction($_funcRef, $_params, $this);\n        }\n        return $this->id . '_' . sha1(serialize($hashParameters));\n    }\n\n    /********************************************\n     *\n     * Further initialization and data processing\n     *\n     *******************************************/\n    /**\n     * Setting the language key that will be used by the current page.\n     * In this function it should be checked, 1) that this language exists, 2) that a page_overlay_record exists, .. and if not the default language, 0 (zero), should be set.\n     *\n     * @internal\n     */\n    protected function settingLanguage(ServerRequestInterface $request)\n    {\n        // Get values from site language\n        $languageAspect = LanguageAspectFactory::createFromSiteLanguage($this->language);\n\n        $languageId = $languageAspect->getId();\n        $languageContentId = $languageAspect->getContentId();\n\n        $pageTranslationVisibility = new PageTranslationVisibility((int)($this->page['l18n_cfg'] ?? 0));\n        // If the incoming language is set to another language than default\n        if ($languageAspect->getId() > 0) {\n            // Request the translation for the requested language\n            $olRec = $this->sys_page->getPageOverlay($this->page, $languageAspect);\n            $overlaidLanguageId = (int)($olRec['sys_language_uid'] ?? 0);\n            if ($overlaidLanguageId !== $languageAspect->getId()) {\n                // If requested translation is not available\n                if ($pageTranslationVisibility->shouldHideTranslationIfNoTranslatedRecordExists()) {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        'Page is not available in the requested language.',\n                        ['code' => PageAccessFailureReasons::LANGUAGE_NOT_AVAILABLE]\n                    );\n                    throw new PropagateResponseException($response, 1533931388);\n                }\n                switch ($languageAspect->getLegacyLanguageMode()) {\n                    case 'strict':\n                        $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                            $request,\n                            'Page is not available in the requested language (strict).',\n                            ['code' => PageAccessFailureReasons::LANGUAGE_NOT_AVAILABLE_STRICT_MODE]\n                        );\n                        throw new PropagateResponseException($response, 1533931395);\n                    case 'content_fallback':\n                        // Setting content uid (but leaving the sys_language_uid) when a content_fallback\n                        // value was found.\n                        foreach ($languageAspect->getFallbackChain() as $orderValue) {\n                            if ($orderValue === '0' || $orderValue === 0 || $orderValue === '') {\n                                $languageContentId = 0;\n                                break;\n                            }\n                            if (MathUtility::canBeInterpretedAsInteger($orderValue) && $overlaidLanguageId === (int)$orderValue) {\n                                $languageContentId = (int)$orderValue;\n                                break;\n                            }\n                            if ($orderValue === 'pageNotFound') {\n                                // The existing fallbacks have not been found, but instead of continuing\n                                // page rendering with default language, a \"page not found\" message should be shown\n                                // instead.\n                                $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                                    $request,\n                                    'Page is not available in the requested language (fallbacks did not apply).',\n                                    ['code' => PageAccessFailureReasons::LANGUAGE_AND_FALLBACKS_NOT_AVAILABLE]\n                                );\n                                throw new PropagateResponseException($response, 1533931402);\n                            }\n                        }\n                        break;\n                    default:\n                        // Default is that everything defaults to the default language...\n                        $languageId = ($languageContentId = 0);\n                }\n            }\n\n            // Define the language aspect again now\n            $languageAspect = GeneralUtility::makeInstance(\n                LanguageAspect::class,\n                $languageId,\n                $languageContentId,\n                $languageAspect->getOverlayType(),\n                $languageAspect->getFallbackChain()\n            );\n\n            // Setting the $this->page if an overlay record was found (which it is only if a language is used)\n            // Doing this ensures that page properties like the page title are resolved in the correct language\n            $this->page = $olRec;\n        }\n\n        // Set the language aspect\n        $this->context->setAspect('language', $languageAspect);\n\n        // Setting sys_language_uid inside sys-page by creating a new page repository\n        $this->sys_page = GeneralUtility::makeInstance(PageRepository::class, $this->context);\n        // If default language is not available\n        if ((!$languageAspect->getContentId() || !$languageAspect->getId())\n            && $pageTranslationVisibility->shouldBeHiddenInDefaultLanguage()\n        ) {\n            $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                $request,\n                'Page is not available in default language.',\n                ['code' => PageAccessFailureReasons::LANGUAGE_DEFAULT_NOT_AVAILABLE]\n            );\n            throw new PropagateResponseException($response, 1533931423);\n        }\n\n        if ($languageAspect->getId() > 0) {\n            $this->updateRootLinesWithTranslations();\n        }\n    }\n\n    /**\n     * Updating content of the two rootLines IF the language key is set!\n     */\n    protected function updateRootLinesWithTranslations()\n    {\n        try {\n            $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n        } catch (RootLineException $e) {\n            $this->rootLine = [];\n        }\n    }\n\n    /**\n     * Calculates and sets the internal linkVars based upon the current request parameters\n     * and the setting \"config.linkVars\".\n     *\n     * @param array $queryParams $_GET (usually called with a PSR-7 $request->getQueryParams())\n     */\n    public function calculateLinkVars(array $queryParams)\n    {\n        $this->linkVars = GeneralUtility::makeInstance(LinkVarsCalculator::class)\n            ->getAllowedLinkVarsFromRequest(\n                (string)($this->config['config']['linkVars'] ?? ''),\n                $queryParams,\n                $this->context\n            );\n    }\n\n    /**\n     * Returns URI of target page, if the current page is an overlaid mountpoint.\n     *\n     * If the current page is of type mountpoint and should be overlaid with the contents of the mountpoint page\n     * and is accessed directly, the user will be redirected to the mountpoint context.\n     * @internal\n     * @param ServerRequestInterface $request\n     */\n    public function getRedirectUriForMountPoint(ServerRequestInterface $request): ?string\n    {\n        if (!empty($this->originalMountPointPage) && (int)$this->originalMountPointPage['doktype'] === PageRepository::DOKTYPE_MOUNTPOINT) {\n            return $this->getUriToCurrentPageForRedirect($request);\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns URI of target page, if the current page is a Shortcut.\n     *\n     * If the current page is of type shortcut and accessed directly via its URL,\n     * the user will be redirected to shortcut target.\n     *\n     * @internal\n     * @param ServerRequestInterface $request\n     */\n    public function getRedirectUriForShortcut(ServerRequestInterface $request): ?string\n    {\n        if (!empty($this->originalShortcutPage) && $this->originalShortcutPage['doktype'] == PageRepository::DOKTYPE_SHORTCUT) {\n            // Check if the shortcut page is actually on the current site, if not, this is a \"page not found\"\n            // because the request was www.mydomain.com/?id=23 where page ID 23 (which is a shortcut) is on another domain/site.\n            if ((int)($request->getQueryParams()['id'] ?? 0) > 0) {\n                try {\n                    $site = GeneralUtility::makeInstance(SiteFinder::class)->getSiteByPageId($this->originalShortcutPage['l10n_parent'] ?: $this->originalShortcutPage['uid']);\n                } catch (SiteNotFoundException $e) {\n                    $site = null;\n                }\n                if ($site !== $this->site) {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        'ID was outside the domain',\n                        $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_HOST_PAGE_MISMATCH)\n                    );\n                    throw new ImmediateResponseException($response, 1638022483);\n                }\n            }\n            return $this->getUriToCurrentPageForRedirect($request);\n        }\n\n        return null;\n    }\n\n    /**\n     * Instantiate \\TYPO3\\CMS\\Frontend\\ContentObject to generate the correct target URL\n     */\n    protected function getUriToCurrentPageForRedirect(ServerRequestInterface $request): string\n    {\n        $this->calculateLinkVars($request->getQueryParams());\n        $parameter = $this->page['uid'];\n        if ($this->type) {\n            $parameter .= ',' . $this->type;\n        }\n        return GeneralUtility::makeInstance(ContentObjectRenderer::class, $this)->createUrl([\n            'parameter' => $parameter,\n            'addQueryString' => 'untrusted',\n            'addQueryString.' => ['exclude' => 'id,type'],\n            'forceAbsoluteUrl' => true,\n        ]);\n    }\n\n    /********************************************\n     *\n     * Page generation; cache handling\n     *\n     *******************************************/\n    /**\n     * Returns TRUE if the page content should be generated.\n     */\n    public function isGeneratePage(): bool\n    {\n        return !$this->pageContentWasLoadedFromCache;\n    }\n\n    /**\n     * Sets cache content; Inserts the content string into the pages cache.\n     *\n     * @param string $content The content to store in the HTML field of the cache table\n     * @param array $data The additional cache_data array, fx. $this->config\n     * @param int $expirationTstamp Expiration timestamp\n     * @see populatePageDataFromCache()\n     */\n    protected function setPageCacheContent(string $content, array $data, int $expirationTstamp): array\n    {\n        $cacheData = [\n            'page_id' => $this->id,\n            'content' => $content,\n            'contentType' => $this->contentType,\n            'cache_data' => $data,\n            'expires' => $expirationTstamp,\n            'tstamp' => $GLOBALS['EXEC_TIME'],\n        ];\n        $this->cacheExpires = $expirationTstamp;\n        $this->pageCacheTags[] = 'pageId_' . $this->id;\n        // Respect the page cache when content of pid is shown\n        if ($this->id !== $this->contentPid) {\n            $this->pageCacheTags[] = 'pageId_' . $this->contentPid;\n        }\n        if (!empty($this->page['cache_tags'])) {\n            $tags = GeneralUtility::trimExplode(',', $this->page['cache_tags'], true);\n            $this->pageCacheTags = array_merge($this->pageCacheTags, $tags);\n        }\n        $this->pageCacheTags = array_unique($this->pageCacheTags);\n        // Add the cache themselves as well, because they are fetched by getPageCacheTags()\n        $cacheData['cacheTags'] = $this->pageCacheTags;\n        $this->pageCache->set($this->newHash, $cacheData, $this->pageCacheTags, $expirationTstamp - $GLOBALS['EXEC_TIME']);\n        return $cacheData;\n    }\n\n    /**\n     * Clears cache content (for $this->newHash)\n     *\n     * @internal\n     */\n    public function clearPageCacheContent()\n    {\n        $this->pageCache->remove($this->newHash);\n    }\n\n    /**\n     * Setting the SYS_LASTCHANGED value in the pagerecord: This value will thus be set to the highest tstamp of records rendered on the page.\n     * This includes all records with no regard to hidden records, userprotection and so on.\n     *\n     * The important part is that this actually updates a translated \"pages\" record (_PAGES_OVERLAY_UID) if\n     * the Frontend is called with a translation.\n     *\n     * @see ContentObjectRenderer::lastChanged()\n     * @see setRegisterValueForSysLastChanged()\n     */\n    protected function setSysLastChanged()\n    {\n        // We only update the info if browsing the live workspace\n        $isInWorkspace = $this->context->getPropertyFromAspect('workspace', 'isOffline', false);\n        if ($isInWorkspace) {\n            return;\n        }\n        if ($this->page['SYS_LASTCHANGED'] < (int)$this->register['SYS_LASTCHANGED']) {\n            $connection = GeneralUtility::makeInstance(ConnectionPool::class)\n                ->getConnectionForTable('pages');\n            $pageId = $this->page['_PAGES_OVERLAY_UID'] ?? $this->id;\n            $connection->update(\n                'pages',\n                [\n                    'SYS_LASTCHANGED' => (int)$this->register['SYS_LASTCHANGED'],\n                ],\n                [\n                    'uid' => (int)$pageId,\n                ]\n            );\n        }\n    }\n\n    /**\n     * Set the SYS_LASTCHANGED register value, is also called when a translated page is in use,\n     * so the register reflects the state of the translated page, not the page in the default language.\n     *\n     * @internal\n     * @see setSysLastChanged()\n     */\n    protected function setRegisterValueForSysLastChanged(array $page): void\n    {\n        $this->register['SYS_LASTCHANGED'] = (int)$page['tstamp'];\n        if ($this->register['SYS_LASTCHANGED'] < (int)$page['SYS_LASTCHANGED']) {\n            $this->register['SYS_LASTCHANGED'] = (int)$page['SYS_LASTCHANGED'];\n        }\n    }\n\n    /**\n     * Adds tags to this page's cache entry, you can then f.e. remove cache\n     * entries by tag\n     *\n     * @param array $tags An array of tag\n     */\n    public function addCacheTags(array $tags)\n    {\n        $this->pageCacheTags = array_merge($this->pageCacheTags, $tags);\n    }\n\n    public function getPageCacheTags(): array\n    {\n        return $this->pageCacheTags;\n    }\n\n    /********************************************\n     *\n     * Page generation; rendering and inclusion\n     *\n     *******************************************/\n    /**\n     * Does some processing BEFORE the page content is generated / built.\n     */\n    public function generatePage_preProcessing()\n    {\n        // Used as a safety check in case a PHP script is falsely disabling $this->no_cache during page generation.\n        $this->no_cacheBeforePageGen = $this->no_cache;\n    }\n\n    /**\n     * Check the value of \"content_from_pid\" of the current page record, and see if the current request\n     * should actually show content from another page.\n     *\n     * By using $TSFE->getPageAndRootline() on the cloned object, all rootline restrictions (extendToSubPages)\n     * are evaluated as well.\n     *\n     * @param ServerRequestInterface $request\n     * @return int the current page ID or another one if resolved properly - usually set to $this->contentPid\n     */\n    protected function resolveContentPid(ServerRequestInterface $request): int\n    {\n        if (!isset($this->page['content_from_pid']) || empty($this->page['content_from_pid'])) {\n            return $this->id;\n        }\n        // make REAL copy of TSFE object - not reference!\n        $temp_copy_TSFE = clone $this;\n        // Set ->id to the content_from_pid value - we are going to evaluate this pid as was it a given id for a page-display!\n        $temp_copy_TSFE->id = (int)$this->page['content_from_pid'];\n        $temp_copy_TSFE->MP = '';\n        $temp_copy_TSFE->getPageAndRootline($request);\n        return $temp_copy_TSFE->id;\n    }\n    /**\n     * Sets up TypoScript \"config.\" options and set properties in $TSFE.\n     */\n    public function preparePageContentGeneration(ServerRequestInterface $request)\n    {\n        $this->getTimeTracker()->push('Prepare page content generation');\n        // @deprecated: these properties can be removed in TYPO3 v13.0\n        $this->baseUrl = (string)($this->config['config']['baseURL'] ?? '');\n        // Internal and External target defaults\n        $this->intTarget = (string)($this->config['config']['intTarget'] ?? '');\n        $this->extTarget = (string)($this->config['config']['extTarget'] ?? '');\n        $this->fileTarget = (string)($this->config['config']['fileTarget'] ?? '');\n        if (($this->config['config']['spamProtectEmailAddresses'] ?? '') === 'ascii') {\n            $this->logDeprecatedTyposcript('config.spamProtectEmailAddresses = ascii', 'This setting has no effect anymore. Change it to a number between -10 and 10 or remove it completely');\n            $this->config['config']['spamProtectEmailAddresses'] = 0;\n        }\n        // @deprecated: these properties can be removed in TYPO3 v13.0\n        $this->spamProtectEmailAddresses = (int)($this->config['config']['spamProtectEmailAddresses'] ?? 0);\n        $this->spamProtectEmailAddresses = MathUtility::forceIntegerInRange($this->spamProtectEmailAddresses, -10, 10, 0);\n        // calculate the absolute path prefix\n        if (!empty($this->absRefPrefix = trim($this->config['config']['absRefPrefix'] ?? ''))) {\n            if ($this->absRefPrefix === 'auto') {\n                $normalizedParams = $request->getAttribute('normalizedParams');\n                $this->absRefPrefix = $normalizedParams->getSitePath();\n            }\n        }\n        // config.forceAbsoluteUrls will override absRefPrefix\n        if ($this->config['config']['forceAbsoluteUrls'] ?? false) {\n            $normalizedParams = $request->getAttribute('normalizedParams');\n            $this->absRefPrefix = $normalizedParams->getSiteUrl();\n        }\n\n        // linkVars\n        $this->calculateLinkVars($request->getQueryParams());\n        // Setting XHTML-doctype from doctype\n        $this->config['config']['xhtmlDoctype'] = $this->config['config']['xhtmlDoctype'] ?? $this->config['config']['doctype'] ?? '';\n        $docType = DocType::createFromConfigurationKey($this->config['config']['xhtmlDoctype']);\n        $this->xhtmlDoctype = $docType->getXhtmlDocType();\n        $this->xhtmlVersion = $docType->getXhtmlVersion();\n        $this->pageRenderer->setDocType($docType);\n\n        // Global content object\n        $this->newCObj($request);\n        $this->getTimeTracker()->pull();\n    }\n\n    /**\n     * Does processing of the content after the page content was generated.\n     *\n     * This includes caching the page, indexing the page (if configured) and setting sysLastChanged\n     */\n    public function generatePage_postProcessing(ServerRequestInterface $request)\n    {\n        $this->setAbsRefPrefix();\n        // This is to ensure, that the page is NOT cached if the no_cache parameter was set before the page was generated.\n        // This is a safety precaution, as it could have been unset by some script.\n        if ($this->no_cacheBeforePageGen) {\n            $this->set_no_cache('no_cache has been set before the page was generated - safety check', true);\n        }\n        $eventDispatcher = GeneralUtility::makeInstance(EventDispatcherInterface::class);\n        $event = new AfterCacheableContentIsGeneratedEvent($request, $this, $this->newHash, !$this->no_cache);\n        $event = $eventDispatcher->dispatch($event);\n\n        // Processing if caching is enabled\n        if ($event->isCachingEnabled()) {\n            // Seconds until a cached page is too old\n            $cacheTimeout = $this->get_cache_timeout();\n            $timeOutTime = $GLOBALS['EXEC_TIME'] + $cacheTimeout;\n            // Write the page to cache\n            $cachedInformation = $this->setPageCacheContent($this->content, $this->config, $timeOutTime);\n\n            // Event for cache post processing (eg. writing static files)\n            $event = new AfterCachedPageIsPersistedEvent($request, $this, $this->newHash, $cachedInformation, $cacheTimeout);\n            $eventDispatcher->dispatch($event);\n        }\n        $this->setSysLastChanged();\n    }\n\n    /**\n     * Generate the page title, can be called multiple times,\n     * as PageTitleProvider might have been modified by an uncached plugin etc.\n     *\n     * @return string the generated page title\n     */\n    public function generatePageTitle(): string\n    {\n        // Check for a custom pageTitleSeparator, and perform stdWrap on it\n        $pageTitleSeparator = (string)$this->cObj->stdWrapValue('pageTitleSeparator', $this->config['config'] ?? []);\n        if ($pageTitleSeparator !== '' && $pageTitleSeparator === ($this->config['config']['pageTitleSeparator'] ?? '')) {\n            $pageTitleSeparator .= ' ';\n        }\n\n        $titleProvider = GeneralUtility::makeInstance(PageTitleProviderManager::class);\n        if (!empty($this->config['config']['pageTitleCache'])) {\n            $titleProvider->setPageTitleCache($this->config['config']['pageTitleCache']);\n        }\n        $pageTitle = $titleProvider->getTitle();\n        $this->config['config']['pageTitleCache'] = $titleProvider->getPageTitleCache();\n\n        $titleTagContent = $this->printTitle(\n            $pageTitle,\n            (bool)($this->config['config']['noPageTitle'] ?? false),\n            (bool)($this->config['config']['pageTitleFirst'] ?? false),\n            $pageTitleSeparator,\n            (bool)($this->config['config']['showWebsiteTitle'] ?? true)\n        );\n        $this->config['config']['pageTitle'] = $titleTagContent;\n        // stdWrap around the title tag\n        $titleTagContent = $this->cObj->stdWrapValue('pageTitle', $this->config['config']);\n\n        // config.noPageTitle = 2 - means do not render the page title\n        if (isset($this->config['config']['noPageTitle']) && (int)$this->config['config']['noPageTitle'] === 2) {\n            $titleTagContent = '';\n        }\n        if ($titleTagContent !== '') {\n            $this->pageRenderer->setTitle($titleTagContent);\n        }\n        return (string)$titleTagContent;\n    }\n\n    /**\n     * Compiles the content for the page <title> tag.\n     *\n     * @param string $pageTitle The input title string, typically the \"title\" field of a page's record.\n     * @param bool $noPageTitle If set, the page title will not be printed\n     * @param bool $showPageTitleFirst If set, website title and page title are swapped\n     * @param string $pageTitleSeparator an alternative to the \": \" as the separator between site title and page title\n     * @param bool $showWebsiteTitle If set, the website title will be printed\n     * @return string The page title on the form \"[website title]: [input-title]\". Not htmlspecialchar()'ed.\n     * @see generatePageTitle()\n     */\n    protected function printTitle(string $pageTitle, bool $noPageTitle = false, bool $showPageTitleFirst = false, string $pageTitleSeparator = '', bool $showWebsiteTitle = true): string\n    {\n        $websiteTitle = $showWebsiteTitle ? $this->getWebsiteTitle() : '';\n        $pageTitle = $noPageTitle ? '' : $pageTitle;\n        // only show a separator if there are both site title and page title\n        if ($pageTitle === '' || $websiteTitle === '') {\n            $pageTitleSeparator = '';\n        } elseif (empty($pageTitleSeparator)) {\n            // use the default separator if non given\n            $pageTitleSeparator = ': ';\n        }\n        if ($showPageTitleFirst) {\n            return $pageTitle . $pageTitleSeparator . $websiteTitle;\n        }\n        return $websiteTitle . $pageTitleSeparator . $pageTitle;\n    }\n\n    protected function getWebsiteTitle(): string\n    {\n        if (trim($this->language->getWebsiteTitle()) !== '') {\n            return trim($this->language->getWebsiteTitle());\n        }\n        if (trim($this->site->getConfiguration()['websiteTitle'] ?? '') !== '') {\n            return trim($this->site->getConfiguration()['websiteTitle']);\n        }\n\n        return '';\n    }\n\n    /**\n     * Processes the INTinclude-scripts\n     */\n    public function INTincScript(ServerRequestInterface $request): void\n    {\n        $this->additionalHeaderData = $this->config['INTincScript_ext']['additionalHeaderData'] ?? [];\n        $this->additionalFooterData = $this->config['INTincScript_ext']['additionalFooterData'] ?? [];\n        if (empty($this->config['INTincScript_ext']['pageRendererState'])) {\n            $this->initPageRenderer();\n        } else {\n            $pageRendererState = unserialize($this->config['INTincScript_ext']['pageRendererState'], ['allowed_classes' => false]);\n            $this->pageRenderer->updateState($pageRendererState);\n        }\n        if (!empty($this->config['INTincScript_ext']['assetCollectorState'])) {\n            $assetCollectorState = unserialize($this->config['INTincScript_ext']['assetCollectorState'], ['allowed_classes' => false]);\n            GeneralUtility::makeInstance(AssetCollector::class)->updateState($assetCollectorState);\n        }\n\n        $this->recursivelyReplaceIntPlaceholdersInContent($request);\n        $this->getTimeTracker()->push('Substitute header section');\n        $this->INTincScript_loadJSCode();\n        $this->generatePageTitle();\n\n        $this->content = str_replace(\n            [\n                '<!--HD_' . $this->config['INTincScript_ext']['divKey'] . '-->',\n                '<!--FD_' . $this->config['INTincScript_ext']['divKey'] . '-->',\n            ],\n            [\n                implode(LF, $this->additionalHeaderData),\n                implode(LF, $this->additionalFooterData),\n            ],\n            $this->pageRenderer->renderJavaScriptAndCssForProcessingOfUncachedContentObjects($this->content, $this->config['INTincScript_ext']['divKey'])\n        );\n        // Replace again, because header and footer data and page renderer replacements may introduce additional placeholders (see #44825)\n        $this->recursivelyReplaceIntPlaceholdersInContent($request);\n        $this->setAbsRefPrefix();\n        $this->getTimeTracker()->pull();\n    }\n\n    /**\n     * Replaces INT placeholders (COA_INT and USER_INT) in $this->content\n     * In case the replacement adds additional placeholders, it loops\n     * until no new placeholders are found any more.\n     */\n    protected function recursivelyReplaceIntPlaceholdersInContent(ServerRequestInterface $request)\n    {\n        do {\n            $nonCacheableData = $this->config['INTincScript'];\n            $this->processNonCacheableContentPartsAndSubstituteContentMarkers($nonCacheableData, $request);\n            // Check if there were new items added to INTincScript during the previous execution:\n            // array_diff_assoc throws notices if values are arrays but not strings. We suppress this here.\n            $nonCacheableData = @array_diff_assoc($this->config['INTincScript'], $nonCacheableData);\n            $reprocess = count($nonCacheableData) > 0;\n        } while ($reprocess);\n    }\n\n    /**\n     * Processes the INTinclude-scripts and substitute in content.\n     *\n     * Takes $this->content, and splits the content by <!--INT_SCRIPT.12345 --> and then puts the content\n     * back together.\n     *\n     * @param array $nonCacheableData $GLOBALS['TSFE']->config['INTincScript'] or part of it\n     * @see INTincScript()\n     */\n    protected function processNonCacheableContentPartsAndSubstituteContentMarkers(array $nonCacheableData, ServerRequestInterface $request)\n    {\n        $timeTracker = $this->getTimeTracker();\n        $timeTracker->push('Split content');\n        // Splits content with the key.\n        $contentSplitByUncacheableMarkers = explode('<!--INT_SCRIPT.', $this->content);\n        $this->content = '';\n        $timeTracker->setTSlogMessage('Parts: ' . count($contentSplitByUncacheableMarkers), LogLevel::INFO);\n        $timeTracker->pull();\n        foreach ($contentSplitByUncacheableMarkers as $counter => $contentPart) {\n            // If the split had a comment-end after 32 characters it's probably a split-string\n            if (substr($contentPart, 32, 3) === '-->') {\n                $nonCacheableKey = 'INT_SCRIPT.' . substr($contentPart, 0, 32);\n                if (is_array($nonCacheableData[$nonCacheableKey])) {\n                    $label = 'Include ' . $nonCacheableData[$nonCacheableKey]['type'];\n                    $timeTracker->push($label);\n                    $nonCacheableContent = '';\n                    $contentObjectRendererForNonCacheable = unserialize($nonCacheableData[$nonCacheableKey]['cObj']);\n                    /* @var ContentObjectRenderer $contentObjectRendererForNonCacheable */\n                    $contentObjectRendererForNonCacheable->setRequest($request);\n                    switch ($nonCacheableData[$nonCacheableKey]['type']) {\n                        case 'COA':\n                            $nonCacheableContent = $contentObjectRendererForNonCacheable->cObjGetSingle('COA', $nonCacheableData[$nonCacheableKey]['conf']);\n                            break;\n                        case 'FUNC':\n                            $nonCacheableContent = $contentObjectRendererForNonCacheable->cObjGetSingle('USER', $nonCacheableData[$nonCacheableKey]['conf']);\n                            break;\n                        case 'POSTUSERFUNC':\n                            $nonCacheableContent = $contentObjectRendererForNonCacheable->callUserFunction($nonCacheableData[$nonCacheableKey]['postUserFunc'], $nonCacheableData[$nonCacheableKey]['conf'], $nonCacheableData[$nonCacheableKey]['content']);\n                            break;\n                    }\n                    $this->content .= $nonCacheableContent;\n                    $this->content .= substr($contentPart, 35);\n                    $timeTracker->pull($nonCacheableContent);\n                } else {\n                    $this->content .= substr($contentPart, 35);\n                }\n            } elseif ($counter) {\n                // If it's not the first entry (which would be \"0\" of the array keys), then re-add the INT_SCRIPT part\n                $this->content .= '<!--INT_SCRIPT.' . $contentPart;\n            } else {\n                $this->content .= $contentPart;\n            }\n        }\n    }\n\n    /**\n     * Loads the JavaScript/CSS code for INTincScript, if there are non-cacheable content objects\n     * it prepares the placeholders, otherwise populates options directly.\n     *\n     * @internal this method should be renamed as it does not only handle JS, but all additional header data\n     */\n    public function INTincScript_loadJSCode()\n    {\n        // Prepare code and placeholders for additional header and footer files (and make sure that this isn't called twice)\n        if ($this->isINTincScript() && !isset($this->config['INTincScript_ext'])) {\n            $substituteHash = $this->uniqueHash();\n            $this->config['INTincScript_ext']['divKey'] = $substituteHash;\n            // Storing the header-data array\n            $this->config['INTincScript_ext']['additionalHeaderData'] = $this->additionalHeaderData;\n            // Storing the footer-data array\n            $this->config['INTincScript_ext']['additionalFooterData'] = $this->additionalFooterData;\n            // Clearing the array\n            $this->additionalHeaderData = ['<!--HD_' . $substituteHash . '-->'];\n            // Clearing the array\n            $this->additionalFooterData = ['<!--FD_' . $substituteHash . '-->'];\n        }\n    }\n\n    /**\n     * Determines if there are any INTincScripts to include = \"non-cacheable\" parts\n     *\n     * @return bool Returns TRUE if scripts are found\n     */\n    public function isINTincScript()\n    {\n        return !empty($this->config['INTincScript']) && is_array($this->config['INTincScript']);\n    }\n\n    /**\n     * Add HTTP headers to the response object.\n     */\n    public function applyHttpHeadersToResponse(ResponseInterface $response): ResponseInterface\n    {\n        // Set header for content-type + charset-encoding\n        $response = $response->withHeader('Content-Type', $this->contentType . '; charset=utf-8');\n        // Set header for content language unless disabled\n        $contentLanguage = (string)$this->language->getLocale();\n        if (empty($this->config['config']['disableLanguageHeader'])) {\n            $response = $response->withHeader('Content-Language', $contentLanguage);\n        }\n\n        // Add a Response header to show debug information if a page was fetched from cache\n        if ($this->debugInformationHeader) {\n            $response = $response->withHeader('X-TYPO3-Debug-Cache', $this->debugInformationHeader);\n        }\n\n        // Set cache related headers to client (used to enable proxy / client caching!)\n        if (!empty($this->config['config']['sendCacheHeaders'])) {\n            $headers = $this->getCacheHeaders();\n            foreach ($headers as $header => $value) {\n                $response = $response->withHeader($header, $value);\n            }\n        }\n        // Set additional headers if any have been configured via TypoScript\n        $additionalHeaders = $this->getAdditionalHeaders();\n        foreach ($additionalHeaders as $headerConfig) {\n            [$header, $value] = GeneralUtility::trimExplode(':', $headerConfig['header'], false, 2);\n            if ($headerConfig['statusCode']) {\n                $response = $response->withStatus((int)$headerConfig['statusCode']);\n            }\n            if ($headerConfig['replace']) {\n                $response = $response->withHeader($header, $value);\n            } else {\n                $response = $response->withAddedHeader($header, $value);\n            }\n        }\n        return $response;\n    }\n\n    /**\n     * Get cache headers good for client/reverse proxy caching.\n     */\n    protected function getCacheHeaders(): array\n    {\n        // Getting status whether we can send cache control headers for proxy caching:\n        $doCache = $this->isStaticCacheble();\n        $isBackendUserLoggedIn = $this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false);\n        $isInWorkspace = $this->context->getPropertyFromAspect('workspace', 'isOffline', false);\n        // Finally, when backend users are logged in, do not send cache headers at all (Admin Panel might be displayed for instance).\n        $isClientCachable = $doCache && !$isBackendUserLoggedIn && !$isInWorkspace;\n        if ($isClientCachable) {\n            $headers = [\n                'Expires' => gmdate('D, d M Y H:i:s T', $this->cacheExpires),\n                'ETag' => '\"' . md5($this->content) . '\"',\n                'Cache-Control' => 'max-age=' . ($this->cacheExpires - $GLOBALS['EXEC_TIME']),\n                // no-cache\n                'Pragma' => 'public',\n            ];\n        } else {\n            // \"no-store\" is used to ensure that the client HAS to ask the server every time, and is not allowed to store anything at all\n            $headers = [\n                'Cache-Control' => 'private, no-store',\n            ];\n            // Now, if a backend user is logged in, tell him in the Admin Panel log what the caching status would have been:\n            if ($isBackendUserLoggedIn) {\n                if ($doCache) {\n                    $this->getTimeTracker()->setTSlogMessage('Cache-headers with max-age \"' . ($this->cacheExpires - $GLOBALS['EXEC_TIME']) . '\" would have been sent');\n                } else {\n                    $reasonMsg = [];\n                    if ($this->no_cache) {\n                        $reasonMsg[] = 'Caching disabled (no_cache).';\n                    }\n                    if ($this->isINTincScript()) {\n                        $reasonMsg[] = '*_INT object(s) on page.';\n                    }\n                    if ($this->context->getPropertyFromAspect('frontend.user', 'isLoggedIn', false)) {\n                        $reasonMsg[] = 'Frontend user logged in.';\n                    }\n                    $this->getTimeTracker()->setTSlogMessage('Cache-headers would disable proxy caching! Reason(s): \"' . implode(' ', $reasonMsg) . '\"', LogLevel::NOTICE);\n                }\n            }\n        }\n        return $headers;\n    }\n\n    /**\n     * Reporting status whether we can send cache control headers for proxy caching or publishing to static files\n     *\n     * Rules are:\n     * no_cache cannot be set: If it is, the page might contain dynamic content and should never be cached.\n     * There can be no USER_INT objects on the page (\"isINTincScript()\") because they implicitly indicate dynamic content\n     * There can be no logged in user because user sessions are based on a cookie and thereby does not offer client caching a chance to know if the user is logged in. Actually, there will be a reverse problem here; If a page will somehow change when a user is logged in he may not see it correctly if the non-login version sent a cache-header! So do NOT use cache headers in page sections where user logins change the page content. (unless using such as realurl to apply a prefix in case of login sections)\n     *\n     * @return bool\n     */\n    public function isStaticCacheble()\n    {\n        return !$this->no_cache && !$this->isINTincScript() && !$this->context->getAspect('frontend.user')->isUserOrGroupSet();\n    }\n\n    /********************************************\n     *\n     * Various internal API functions\n     *\n     *******************************************/\n    /**\n     * Creates an instance of ContentObjectRenderer in $this->cObj\n     * This instance is used to start the rendering of the TypoScript template structure\n     *\n     * @param ServerRequestInterface|null $request\n     */\n    public function newCObj(ServerRequestInterface $request = null)\n    {\n        $this->cObj = GeneralUtility::makeInstance(ContentObjectRenderer::class, $this);\n        $this->cObj->start($this->page, 'pages', $request);\n    }\n\n    /**\n     * Converts relative paths in the HTML source to absolute paths for fileadmin/, typo3conf/ext/ and media/ folders.\n     *\n     * @internal\n     * @see \\TYPO3\\CMS\\Frontend\\Http\\RequestHandler\n     * @see INTincScript()\n     */\n    protected function setAbsRefPrefix()\n    {\n        if (!$this->absRefPrefix) {\n            return;\n        }\n        $search = [\n            '\"_assets/',\n            '\"typo3temp/',\n            '\"' . PathUtility::stripPathSitePrefix(Environment::getExtensionsPath()) . '/',\n            '\"' . PathUtility::stripPathSitePrefix(Environment::getFrameworkBasePath()) . '/',\n        ];\n        $replace = [\n            '\"' . $this->absRefPrefix . '_assets/',\n            '\"' . $this->absRefPrefix . 'typo3temp/',\n            '\"' . $this->absRefPrefix . PathUtility::stripPathSitePrefix(Environment::getExtensionsPath()) . '/',\n            '\"' . $this->absRefPrefix . PathUtility::stripPathSitePrefix(Environment::getFrameworkBasePath()) . '/',\n        ];\n        // Process additional directories\n        $directories = GeneralUtility::trimExplode(',', $GLOBALS['TYPO3_CONF_VARS']['FE']['additionalAbsRefPrefixDirectories'], true);\n        foreach ($directories as $directory) {\n            $search[] = '\"' . $directory;\n            $replace[] = '\"' . $this->absRefPrefix . $directory;\n        }\n        $this->content = str_replace(\n            $search,\n            $replace,\n            $this->content\n        );\n    }\n\n    /**\n     * Prefixing the input URL with ->baseUrl If ->baseUrl is set and the input url is not absolute in some way.\n     * Designed as a wrapper functions for use with all frontend links that are processed by JavaScript (for \"realurl\" compatibility!). So each time a URL goes into window.open, window.location.href or otherwise, wrap it with this function!\n     *\n     * @param string $url Input URL, relative or absolute\n     * @param bool $internal used for TYPO3 Core to avoid deprecation errors in v12 when calling this method directly.\n     * @return string Processed input value.\n     * @internal only for TYPO3 Core internal purposes. Might be removed at a later point as it was related to RealURL functionality.\n     * @deprecated will be removed in TYPO3 v13.0 along with config.baseURL\n     */\n    public function baseUrlWrap($url, bool $internal = false)\n    {\n        if (!$internal) {\n            trigger_error('Calling $TSFE->baseUrlWrap will not work anymore in TYPO3 v13.0. Use SiteHandling and config.forceAbsoluteUrls anymore, or build your own <base> tag via TypoScript headerData.', E_USER_DEPRECATED);\n        }\n        if ($this->config['config']['baseURL'] ?? false) {\n            $urlParts = parse_url($url);\n            if (empty($urlParts['scheme']) && $url[0] !== '/') {\n                $url = $this->config['config']['baseURL'] . $url;\n            }\n        }\n        return $url;\n    }\n\n    /**\n     * Logs access to deprecated TypoScript objects and properties.\n     *\n     * Dumps message to the TypoScript message log (admin panel) and the TYPO3 deprecation log.\n     *\n     * @param string $typoScriptProperty Deprecated object or property\n     * @param string $explanation Message or additional information\n     */\n    public function logDeprecatedTyposcript($typoScriptProperty, $explanation = '')\n    {\n        $explanationText = $explanation !== '' ? ' - ' . $explanation : '';\n        $this->getTimeTracker()->setTSlogMessage($typoScriptProperty . ' is deprecated.' . $explanationText, LogLevel::WARNING);\n        trigger_error('TypoScript property ' . $typoScriptProperty . ' is deprecated' . $explanationText, E_USER_DEPRECATED);\n    }\n\n    /********************************************\n     * PUBLIC ACCESSIBLE WORKSPACES FUNCTIONS\n     *******************************************/\n\n    /**\n     * Returns TRUE if workspace preview is enabled\n     *\n     * @return bool Returns TRUE if workspace preview is enabled\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function doWorkspacePreview()\n    {\n        trigger_error('TSFE->doWorkspacePreview() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        return $this->context->getPropertyFromAspect('workspace', 'isOffline', false);\n    }\n\n    /**\n     * Returns the uid of the current workspace\n     *\n     * @return int returns workspace integer for which workspace is being preview. 0 if none (= live workspace).\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function whichWorkspace(): int\n    {\n        trigger_error('TSFE->whichWorkspace() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        return $this->context->getPropertyFromAspect('workspace', 'id', 0);\n    }\n\n    /********************************************\n     *\n     * Various external API functions - for use in plugins etc.\n     *\n     *******************************************/\n    /**\n     * Returns the pages TSconfig array based on the current ->rootLine\n     *\n     * @deprecated since TYPO3 v12, will be removed in v13. Frontend should typically not depend on Backend TsConfig.\n     *             If really needed, use PageTsConfigFactory, see usage in DatabaseRecordLinkBuilder.\n     *             Remove together with class PageTsConfig.\n     */\n    public function getPagesTSconfig(): array\n    {\n        trigger_error('Method getPagesTSconfig() is deprecated since TYPO3 v12 and will be removed with TYPO3 v13.0.', E_USER_DEPRECATED);\n        if (!is_array($this->pagesTSconfig)) {\n            $matcher = GeneralUtility::makeInstance(FrontendConditionMatcher::class, $this->context, $this->id, $this->rootLine);\n            $this->pagesTSconfig = GeneralUtility::makeInstance(PageTsConfig::class)\n                ->getForRootLine(\n                    array_reverse($this->rootLine),\n                    $this->site,\n                    $matcher\n                );\n        }\n        return $this->pagesTSconfig;\n    }\n\n    /**\n     * Returns a unique md5 hash.\n     * There is no special magic in this, the only point is that you don't have to call md5(uniqid()) which is slow and by this you are sure to get a unique string each time in a little faster way.\n     *\n     * @param string $str Some string to include in what is hashed. Not significant at all.\n     * @return string MD5 hash of ->uniqueString, input string and uniqueCounter\n     */\n    public function uniqueHash($str = '')\n    {\n        return md5($this->uniqueString . '_' . $str . $this->uniqueCounter++);\n    }\n\n    /**\n     * Sets the cache-flag to 1. Could be called from user-included php-files in order to ensure that a page is not cached.\n     *\n     * @param string $reason An optional reason to be written to the log.\n     * @param bool $internal Whether the call is done from core itself (should only be used by core).\n     */\n    public function set_no_cache($reason = '', $internal = false)\n    {\n        $warning = '';\n        $context = [];\n        if ($reason !== '') {\n            $warning = '$TSFE->set_no_cache() was triggered. Reason: {reason}.';\n            $context['reason'] = $reason;\n        } else {\n            $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1);\n            if (isset($trace[0]['class'])) {\n                $context['class'] = $trace[0]['class'];\n                $warning = '$GLOBALS[\\'TSFE\\']->set_no_cache() was triggered by {class} on line {line}.';\n            }\n            if (isset($trace[0]['function'])) {\n                $context['function'] = $trace[0]['function'];\n                $warning = '$GLOBALS[\\'TSFE\\']->set_no_cache() was triggered by {class}->{function} on line {line}.';\n            }\n            if ($context === []) {\n                // Only store the filename, not the full path for safety reasons\n                $context['file'] = basename($trace[0]['file']);\n                $warning = '$GLOBALS[\\'TSFE\\']->set_no_cache() was triggered by {file} on line {line}.';\n            }\n            $context['line'] = $trace[0]['line'];\n        }\n        if (!$internal && $GLOBALS['TYPO3_CONF_VARS']['FE']['disableNoCacheParameter']) {\n            $warning .= ' However, $TYPO3_CONF_VARS[\\'FE\\'][\\'disableNoCacheParameter\\'] is set, so it will be ignored!';\n            $this->getTimeTracker()->setTSlogMessage($warning, LogLevel::WARNING);\n        } else {\n            $warning .= ' Caching is disabled!';\n            $this->disableCache();\n        }\n        if ($internal) {\n            $this->logger->notice($warning, $context);\n        } else {\n            $this->logger->warning($warning, $context);\n        }\n    }\n\n    /**\n     * Disables caching of the current page.\n     *\n     * @internal\n     */\n    protected function disableCache()\n    {\n        $this->no_cache = true;\n    }\n\n    /**\n     * Sets the cache-timeout in seconds\n     *\n     * @param int $seconds Cache-timeout in seconds\n     */\n    public function set_cache_timeout_default($seconds)\n    {\n        $seconds = (int)$seconds;\n        if ($seconds > 0) {\n            $this->cacheTimeOutDefault = $seconds;\n        }\n    }\n\n    /**\n     * Get the cache timeout for the current page.\n     */\n    public function get_cache_timeout(): int\n    {\n        return GeneralUtility::makeInstance(CacheLifetimeCalculator::class)\n            ->calculateLifetimeForPage(\n                (int)$this->id,\n                $this->page,\n                $this->config['config'] ?? [],\n                $this->cacheTimeOutDefault,\n                $this->context\n            );\n    }\n\n    /*********************************************\n     *\n     * Localization and character set conversion\n     *\n     *********************************************/\n    /**\n     * Split Label function for front-end applications.\n     *\n     * @param string $input Key string. Accepts the \"LLL:\" prefix.\n     * @return string Label value, if any.\n     */\n    public function sL($input)\n    {\n        if ($this->languageService === null) {\n            $this->languageService = GeneralUtility::makeInstance(LanguageServiceFactory::class)->createFromSiteLanguage($this->language);\n        }\n        return $this->languageService->sL($input);\n    }\n\n    /**\n     * Returns the originally requested page uid when TSFE was instantiated initially.\n     */\n    public function getRequestedId(): int\n    {\n        return $this->requestedId;\n    }\n\n    /**\n     * Release the page specific lock.\n     *\n     * @throws \\InvalidArgumentException\n     * @throws \\RuntimeException\n     * @internal\n     */\n    public function releaseLocks(): void\n    {\n        $this->lock?->releaseLock('pages');\n    }\n\n    /**\n     * Send additional headers from config.additionalHeaders\n     */\n    protected function getAdditionalHeaders(): array\n    {\n        if (!isset($this->config['config']['additionalHeaders.'])) {\n            return [];\n        }\n        $additionalHeaders = [];\n        ksort($this->config['config']['additionalHeaders.']);\n        foreach ($this->config['config']['additionalHeaders.'] as $options) {\n            if (!is_array($options)) {\n                continue;\n            }\n            $header = trim($options['header'] ?? '');\n            if ($header === '') {\n                continue;\n            }\n            $additionalHeaders[] = [\n                'header' => $header,\n                // \"replace existing headers\" is turned on by default, unless turned off\n                'replace' => ($options['replace'] ?? '') !== '0',\n                'statusCode' => (int)($options['httpResponseCode'] ?? 0) ?: null,\n            ];\n        }\n        return $additionalHeaders;\n    }\n\n    /**\n     * Log the page access failure with additional request information\n     */\n    protected function logPageAccessFailure(string $message, ServerRequestInterface $request): void\n    {\n        $context = ['pageId' => $this->id];\n        if (($normalizedParams = $request->getAttribute('normalizedParams')) instanceof NormalizedParams) {\n            $context['requestUrl'] = $normalizedParams->getRequestUrl();\n        }\n        $this->logger->error($message, $context);\n    }\n\n    /**\n     * Returns the current BE user.\n     * @todo: Add PHP return type declaration and ensure, that classes using TSFE in BE/CLI context always instantiate\n     *        a FrontendBackendUserAuthentication object in $GLOBALS['BE_USER'].\n     *\n     * @return FrontendBackendUserAuthentication|null\n     */\n    protected function getBackendUser()\n    {\n        return $GLOBALS['BE_USER'] ?? null;\n    }\n\n    /**\n     * @return TimeTracker\n     */\n    protected function getTimeTracker()\n    {\n        return GeneralUtility::makeInstance(TimeTracker::class);\n    }\n\n    public function getLanguage(): SiteLanguage\n    {\n        return $this->language;\n    }\n\n    public function getSite(): Site\n    {\n        return $this->site;\n    }\n\n    public function getContext(): Context\n    {\n        return $this->context;\n    }\n\n    public function getPageArguments(): PageArguments\n    {\n        return $this->pageArguments;\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Core;\n\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Core\\Utility\\PathUtility;\n\n/**\n * Class to encapsulate base setup of bootstrap.\n *\n * This class contains all code that must be executed by every entry script.\n *\n * It sets up all basic paths, constants, global variables and checks\n * the basic environment TYPO3 runs in.\n *\n * This class does not use any TYPO3 instance specific configuration, it only\n * sets up things based on the server environment and core code. Even with a\n * missing system/settings.php this script will be successful.\n *\n * The script aborts execution with an error message if\n * some part fails or conditions are not met.\n *\n * This script is internal code and subject to change.\n * DO NOT use it in own code, or be prepared your code might\n * break in future versions of the core.\n */\nclass SystemEnvironmentBuilder\n{\n    /** @internal */\n    public const REQUESTTYPE_FE = 1;\n    /** @internal */\n    public const REQUESTTYPE_BE = 2;\n    /** @internal */\n    public const REQUESTTYPE_CLI = 4;\n    /** @internal */\n    public const REQUESTTYPE_AJAX = 8;\n    /** @internal */\n    public const REQUESTTYPE_INSTALL = 16;\n\n    /**\n     * Run base setup.\n     * This entry method is used in all scopes (FE, BE, Install Tool and CLI)\n     *\n     * @internal This method should not be used by 3rd party code. It will change without further notice.\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     */\n    public static function run(int $entryPointLevel = 0, int $requestType = self::REQUESTTYPE_FE)\n    {\n        self::defineBaseConstants();\n        $scriptPath = self::calculateScriptPath($entryPointLevel, $requestType);\n        $rootPath = self::calculateRootPath($entryPointLevel, $requestType);\n\n        self::initializeGlobalVariables();\n        self::initializeGlobalTimeTrackingVariables();\n        self::initializeEnvironment($requestType, $scriptPath, $rootPath);\n    }\n\n    /**\n     * Some notes:\n     *\n     * HTTP_TYPO3_CONTEXT -> used with Apache suexec support\n     * REDIRECT_TYPO3_CONTEXT -> used under some circumstances when value is set in the webserver and proxying the values to FPM\n     * @throws \\TYPO3\\CMS\\Core\\Exception\n     */\n    protected static function createApplicationContext(): ApplicationContext\n    {\n        $applicationContext = getenv('TYPO3_CONTEXT') ?: (getenv('REDIRECT_TYPO3_CONTEXT') ?: (getenv('HTTP_TYPO3_CONTEXT') ?: 'Production'));\n        return new ApplicationContext($applicationContext);\n    }\n\n    /**\n     * Define all simple constants that have no dependency to local configuration\n     */\n    protected static function defineBaseConstants()\n    {\n        // A linefeed, a carriage return, a CR-LF combination\n        defined('LF') ?: define('LF', chr(10));\n        defined('CR') ?: define('CR', chr(13));\n        defined('CRLF') ?: define('CRLF', CR . LF);\n\n        // A generic constant to state we are in TYPO3 scope. This is especially used in script files\n        // like ext_localconf.php that run in global scope without class encapsulation: \"defined('TYPO3') or die();\"\n        // This is a security measure to prevent script output if those files are located within document root and\n        // called directly without bootstrap and error handling setup.\n        defined('TYPO3') ?: define('TYPO3', true);\n\n        // Relative path from document root to typo3/ directory, hardcoded to \"typo3/\"\n        // @deprecated: will be removed in TYPO3 v13.0\n        if (!defined('TYPO3_mainDir')) {\n            define('TYPO3_mainDir', 'typo3/');\n        }\n    }\n\n    /**\n     * Calculate script path. This is the absolute path to the entry script.\n     * Can be something like '.../public/index.php' or '.../public/typo3/index.php' for\n     * web calls, or '.../bin/typo3' or similar for cli calls.\n     *\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     * @return string Absolute path to entry script\n     */\n    protected static function calculateScriptPath(int $entryPointLevel, int $requestType): string\n    {\n        $isCli = self::isCliRequestType($requestType);\n        // Absolute path of the entry script that was called\n        $scriptPath = GeneralUtility::fixWindowsFilePath(self::getPathThisScript($isCli));\n        $rootPath = self::getRootPathFromScriptPath($scriptPath, $entryPointLevel);\n        // Check if the root path has been set in the environment (e.g. by the composer installer)\n        if (getenv('TYPO3_PATH_ROOT')) {\n            if ($isCli && self::usesComposerClassLoading()) {\n                // $scriptPath is used for various path calculations based on the document root\n                // Therefore we assume it is always a subdirectory of the document root, which is not the case\n                // in composer mode on cli, as the binary is in the composer bin directory.\n                // Because of that, we enforce the document root path of this binary to be set\n                $scriptName = 'typo3/sysext/core/bin/typo3';\n            } else {\n                // Base the script path on the path taken from the environment\n                // to make relative path calculations work in case only one of both is symlinked\n                // or has the real path\n                $scriptName = ltrim(substr($scriptPath, strlen($rootPath)), '/');\n            }\n            $rootPath = rtrim(GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_ROOT')), '/');\n            $scriptPath = $rootPath . '/' . $scriptName;\n        }\n        return $scriptPath;\n    }\n\n    /**\n     * Absolute path to the \"classic\" site root of the TYPO3 application.\n     * This semantically refers to the directory where executable server-side code, configuration\n     * and runtime files are located (e.g. typo3conf/ext, typo3/sysext, typo3temp/var).\n     * In practice this is always identical to the public web document root path which contains\n     * files that are served by the webserver directly (fileadmin/ and public resources).\n     *\n     * This is not to be confused with the app-path that is used in composer-mode installations (by default).\n     * Resources in app-path are located outside the document root.\n     *\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     * @param int $requestType\n     * @return string Absolute path without trailing slash\n     */\n    protected static function calculateRootPath(int $entryPointLevel, int $requestType): string\n    {\n        // Check if the root path has been set in the environment (e.g. by the composer installer)\n        if (getenv('TYPO3_PATH_ROOT')) {\n            return rtrim(GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_ROOT')), '/');\n        }\n        $isCli = self::isCliRequestType($requestType);\n        // Absolute path of the entry script that was called\n        $scriptPath = GeneralUtility::fixWindowsFilePath(self::getPathThisScript($isCli));\n        return self::getRootPathFromScriptPath($scriptPath, $entryPointLevel);\n    }\n\n    /**\n     * Set up / initialize several globals variables\n     */\n    protected static function initializeGlobalVariables()\n    {\n        // Unset variable(s) in global scope (security issue #13959)\n        $GLOBALS['T3_SERVICES'] = [];\n    }\n\n    /**\n     * Initialize global time tracking variables.\n     * These are helpers to for example output script parsetime at the end of a script.\n     */\n    protected static function initializeGlobalTimeTrackingVariables()\n    {\n        // EXEC_TIME is set so that the rest of the script has a common value for the script execution time\n        $GLOBALS['EXEC_TIME'] = time();\n        // $ACCESS_TIME is a common time in minutes for access control\n        $GLOBALS['ACCESS_TIME'] = $GLOBALS['EXEC_TIME'] - $GLOBALS['EXEC_TIME'] % 60;\n        // $SIM_EXEC_TIME is set to $EXEC_TIME but can be altered later in the script if we want to\n        // simulate another execution-time when selecting from eg. a database\n        $GLOBALS['SIM_EXEC_TIME'] = $GLOBALS['EXEC_TIME'];\n        // If $SIM_EXEC_TIME is changed this value must be set accordingly\n        $GLOBALS['SIM_ACCESS_TIME'] = $GLOBALS['ACCESS_TIME'];\n    }\n\n    /**\n     * Initialize the Environment class\n     */\n    protected static function initializeEnvironment(int $requestType, string $scriptPath, string $sitePath)\n    {\n        if (getenv('TYPO3_PATH_ROOT')) {\n            $rootPathFromEnvironment = rtrim(GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_ROOT')), '/');\n            if ($sitePath !== $rootPathFromEnvironment) {\n                // This means, that we re-initialized the environment during a single request\n                // This currently only happens in custom code or during functional testing\n                // Once the constants are removed, we might be able to remove this code here as well and directly pass an environment to the application\n                $scriptPath = $rootPathFromEnvironment . substr($scriptPath, strlen($sitePath));\n                $sitePath = $rootPathFromEnvironment;\n            }\n        }\n\n        $projectRootPath = GeneralUtility::fixWindowsFilePath((string)getenv('TYPO3_PATH_APP'));\n        $isDifferentRootPath = ($projectRootPath && $projectRootPath !== $sitePath);\n        Environment::initialize(\n            static::createApplicationContext(),\n            self::isCliRequestType($requestType),\n            static::usesComposerClassLoading(),\n            $isDifferentRootPath ? $projectRootPath : $sitePath,\n            $sitePath,\n            $isDifferentRootPath ? $projectRootPath . '/var' : $sitePath . '/typo3temp/var',\n            $isDifferentRootPath ? $projectRootPath . '/config' : $sitePath . '/typo3conf',\n            $scriptPath,\n            self::isRunningOnWindows() ? 'WINDOWS' : 'UNIX'\n        );\n    }\n\n    /**\n     * Determine if the operating system TYPO3 is running on is windows.\n     */\n    protected static function isRunningOnWindows(): bool\n    {\n        return stripos(PHP_OS, 'darwin') === false\n            && stripos(PHP_OS, 'cygwin') === false\n            && stripos(PHP_OS, 'win') !== false;\n    }\n\n    /**\n     * Calculate script path.\n     *\n     * First step in path calculation: Goal is to find the absolute path of the entry script\n     * that was called without resolving any links. This is important since the TYPO3 entry\n     * points are often linked to a central core location, so we can not use the php magic\n     * __FILE__ here, but resolve the called script path from given server environments.\n     *\n     * This path is important to calculate the document root. The strategy is to\n     * find out the script name that was called in the first place and to subtract the local\n     * part from it to find the document root.\n     *\n     * @param bool $isCli\n     * @return string Absolute path to entry script\n     */\n    protected static function getPathThisScript(bool $isCli)\n    {\n        if ($isCli) {\n            return self::getPathThisScriptCli();\n        }\n        return self::getPathThisScriptNonCli();\n    }\n\n    /**\n     * Return path to entry script if not in cli mode.\n     *\n     * @return string Absolute path to entry script\n     */\n    protected static function getPathThisScriptNonCli()\n    {\n        if (Environment::isRunningOnCgiServer() && !Environment::usesCgiFixPathInfo()) {\n            throw new \\Exception('TYPO3 does only support being used with cgi.fix_pathinfo=1 on CGI server APIs.', 1675108421);\n        }\n\n        return $_SERVER['SCRIPT_FILENAME'];\n    }\n\n    /**\n     * Calculate path to entry script if in cli mode.\n     *\n     * First argument of a cli script is the path to the script that was called. If the script does not start\n     * with / (or A:\\ for Windows), the path is not absolute yet, and the current working directory is added.\n     *\n     * @return string Absolute path to entry script\n     */\n    protected static function getPathThisScriptCli()\n    {\n        // Possible relative path of the called script\n        $scriptPath = $_SERVER['argv'][0] ?? $_ENV['_'] ?? $_SERVER['_'];\n        // Find out if path is relative or not\n        $isRelativePath = false;\n        if (self::isRunningOnWindows()) {\n            if (!preg_match('/^([a-zA-Z]:)?\\\\\\\\/', $scriptPath)) {\n                $isRelativePath = true;\n            }\n        } elseif ($scriptPath[0] !== '/') {\n            $isRelativePath = true;\n        }\n        // Concatenate path to current working directory with relative path and remove \"/./\" constructs\n        if ($isRelativePath) {\n            $workingDirectory = $_SERVER['PWD'] ?? getcwd();\n            $scriptPath = $workingDirectory . '/' . preg_replace('/\\\\.\\\\//', '', $scriptPath);\n        }\n        return $scriptPath;\n    }\n\n    /**\n     * Calculate the document root part to the instance from $scriptPath.\n     * This is based on the amount of subdirectories \"under\" root path where $scriptPath is located.\n     *\n     * The following main scenarios for entry points exist by default in the TYPO3 core:\n     * - Directly called documentRoot/index.php (-> FE call or eiD include): index.php is located in the same directory\n     * as the main project. The document root is identical to the directory the script is located at.\n     * - The install tool, located under typo3/install.php.\n     * - A Backend script: This is the case for the typo3/index.php dispatcher and other entry scripts like 'typo3/sysext/core/bin/typo3'\n     * or 'typo3/index.php' that are located inside typo3/ directly.\n     *\n     * @param string $scriptPath Calculated path to the entry script\n     * @param int $entryPointLevel Number of subdirectories where the entry script is located under the document root\n     * @return string Absolute path to document root of installation without trailing slash\n     */\n    protected static function getRootPathFromScriptPath($scriptPath, $entryPointLevel)\n    {\n        $entryScriptDirectory = PathUtility::dirnameDuringBootstrap($scriptPath);\n        if ($entryPointLevel > 0) {\n            [$rootPath] = GeneralUtility::revExplode('/', $entryScriptDirectory, $entryPointLevel + 1);\n        } else {\n            $rootPath = $entryScriptDirectory;\n        }\n        return $rootPath;\n    }\n\n    protected static function usesComposerClassLoading(): bool\n    {\n        return defined('TYPO3_COMPOSER_MODE') && TYPO3_COMPOSER_MODE;\n    }\n\n    /**\n     * Checks if request type is cli.\n     * Falls back to check PHP_SAPI in case request type is not provided\n     */\n    protected static function isCliRequestType(?int $requestType): bool\n    {\n        if ($requestType === null) {\n            $requestType = PHP_SAPI === 'cli' ? self::REQUESTTYPE_CLI : self::REQUESTTYPE_FE;\n        }\n\n        return ($requestType & self::REQUESTTYPE_CLI) === self::REQUESTTYPE_CLI;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Http;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\n\n/**\n * This class provides normalized server parameters in HTTP request context.\n * It normalizes reverse proxy scenarios and various other web server specific differences\n * of the native PSR-7 request object parameters (->getServerParams() / $GLOBALS['_SERVER']).\n *\n * An instance of this class is available as PSR-7 ServerRequestInterface attribute:\n *\n * ```\n * $normalizedParams = $request->getAttribute('normalizedParams')\n * ```\n *\n * This class substitutes the old GeneralUtility::getIndpEnv() method.\n */\nclass NormalizedParams\n{\n    /**\n     * Sanitized HTTP_HOST value\n     *\n     * host[:port]\n     *\n     * - www.domain.com\n     * - www.domain.com:443\n     * - 192.168.1.42:80\n     *\n     * @var string\n     */\n    protected $httpHost = '';\n\n    /**\n     * @var bool True if request has been done via HTTPS\n     */\n    protected $isHttps = false;\n\n    /**\n     * Sanitized HTTP_HOST with protocol\n     *\n     * scheme://host[:port]\n     *\n     * - https://www.domain.com\n     *\n     * @var string\n     */\n    protected $requestHost = '';\n\n    /**\n     * Host / domain part of HTTP_HOST, no port, no protocol\n     *\n     * - www.domain.com\n     * - 192.168.1.42\n     *\n     * @var string\n     */\n    protected $requestHostOnly = '';\n\n    /**\n     * Port of HTTP_HOST if given\n     *\n     * @var int\n     */\n    protected $requestPort = 0;\n\n    /**\n     * Entry script path of URI, without domain and without query parameters, with leading /\n     *\n     * [path_script]\n     *\n     * - /index.php\n     * - /typo3/index.php\n     *\n     * @var string\n     */\n    protected $scriptName = '';\n\n    /**\n     * REQUEST URI without domain and scheme, with trailing slash\n     *\n     * [path][?[query]]\n     *\n     * - /some/path?p1=parameter1&p2[key]=value\n     * - /typo3/some/path?p1=parameter1&p2[key]=value\n     *\n     * @var string\n     */\n    protected $requestUri = '';\n\n    /**\n     * REQUEST URI with scheme, host, port, path and query\n     *\n     * scheme://host[:[port]][path][?[query]]\n     *\n     * - http://www.domain.com/some/path?p1=parameter1&p2[key]=value\n     * - http://www.domain.com/typo3/some/path?id=42\n     *\n     * @var string\n     */\n    protected $requestUrl = '';\n\n    /**\n     * REQUEST URI with scheme, host, port and path, but *without* query part\n     *\n     * scheme://host[:[port]][path_script]\n     *\n     * - http://www.domain.com/index.php\n     * - http://www.domain.com/typo3/index.php\n     *\n     * @var string\n     */\n    protected $requestScript = '';\n\n    /**\n     * Full Uri with path, but without script name and query parts\n     *\n     * scheme://host[:[port]][path_dir]\n     *\n     * - http://www.domain.com/\n     * - http://www.domain.com/typo3/\n     *\n     * @var string\n     */\n    protected $requestDir = '';\n\n    /**\n     * True if request via a reverse proxy is detected\n     *\n     * @var bool\n     */\n    protected $isBehindReverseProxy = false;\n\n    /**\n     * IPv4 or IPv6 address of remote client with resolved proxy setup\n     *\n     * @var string\n     */\n    protected $remoteAddress = '';\n\n    /**\n     * Absolute server path to entry script on server filesystem\n     *\n     * - /var/www/index.php\n     * - /var/www/typo3/index.php\n     *\n     * @var string\n     */\n    protected $scriptFilename = '';\n\n    /**\n     * Absolute server path to web document root without trailing slash\n     *\n     * - /var/www\n     *\n     * @var string\n     */\n    protected $documentRoot = '';\n\n    /**\n     * Website frontend URL.\n     * Note this is note \"safe\" if called from Backend since sys_domain and\n     * other factors are not taken into account.\n     *\n     * scheme://host[:[port]]/[path_dir]\n     *\n     * - https://www.domain.com/\n     * - https://www.domain.com/some/sub/dir/\n     *\n     * @var string\n     */\n    protected $siteUrl = '';\n\n    /**\n     * Path part to frontend, no domain, no protocol\n     *\n     * - /\n     * - /some/sub/dir/\n     *\n     * @var string\n     */\n    protected $sitePath = '';\n\n    /**\n     * Path to script, without sub path if TYPO3 is running in sub directory, without trailing slash\n     *\n     * - index.php?id=42\n     * - /some/path?id=42\n     * - typo3/some/path?id=411\n     *\n     * @var string\n     */\n    protected $siteScript = '';\n\n    /**\n     * Entry script path of URI, without domain and without query parameters, with leading /\n     * This is often not set at all.\n     * Will be deprecated later, use $scriptName instead as more reliable solution.\n     *\n     * [path_script]\n     *\n     * @var string\n     */\n    protected $pathInfo = '';\n\n    /**\n     * HTTP_REFERER\n     * Will be deprecated later, use $request->getServerParams()['HTTP_REFERER'] instead\n     *\n     * scheme://host[:[port]][path]\n     *\n     * - https://www.domain.com/typo3/module/web/layout?id=42\n     *\n     * @var string\n     */\n    protected $httpReferer = '';\n\n    /**\n     * HTTP_USER_AGENT\n     * Will be deprecated later, use $request->getServerParams()['HTTP_USER_AGENT'] instead\n     *\n     * - Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36\n     *\n     * @var string\n     */\n    protected $httpUserAgent = '';\n\n    /**\n     * HTTP_ACCEPT_ENCODING\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_ENCODING'] instead\n     *\n     * - gzip, deflate\n     *\n     * @var string\n     */\n    protected $httpAcceptEncoding = '';\n\n    /**\n     * HTTP_ACCEPT_LANGUAGE\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] instead\n     *\n     * - de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7\n     *\n     * @var string\n     */\n    protected $httpAcceptLanguage = '';\n\n    /**\n     * REMOTE_HOST Resolved host name of REMOTE_ADDR if configured in web server\n     * Will be deprecated later, use $request->getServerParams()['REMOTE_HOST'] instead\n     *\n     * - www.clientDomain.com\n     *\n     * @var string\n     */\n    protected $remoteHost = '';\n\n    /**\n     * QUERY_STRING\n     * Will be deprecated later, use $request->getServerParams()['QUERY_STRING'] instead\n     *\n     * [query]\n     *\n     * - id=42&foo=bar\n     *\n     * @var string\n     */\n    protected $queryString = '';\n\n    /**\n     * Constructor calculates all values by incoming variables.\n     *\n     * This object is immutable.\n     *\n     * All determine*() \"detail worker methods\" in this class retrieve their dependencies\n     * to other properties as method arguments, they are static, stateless and have no\n     * dependency to $this. This ensures the chain of inter-property dependencies\n     * is visible by only looking at the construct() method.\n     *\n     * @param array $serverParams , usually coming from $_SERVER or $request->getServerParams()\n     * @param array $configuration $GLOBALS['TYPO3_CONF_VARS']['SYS']\n     * @param string $pathThisScript Absolute server entry script path, usually found within Environment::getCurrentScript()\n     * @param string $pathSite Absolute server path to document root, Environment::getPublicPath()\n     */\n    public function __construct(array $serverParams, array $configuration, string $pathThisScript, string $pathSite)\n    {\n        $isBehindReverseProxy = $this->isBehindReverseProxy = self::determineIsBehindReverseProxy(\n            $serverParams,\n            $configuration\n        );\n        $httpHost = $this->httpHost = self::determineHttpHost($serverParams, $configuration, $isBehindReverseProxy);\n        $isHttps = $this->isHttps = self::determineHttps($serverParams, $configuration);\n        $requestHost = $this->requestHost = ($isHttps ? 'https://' : 'http://') . $httpHost;\n        $requestHostOnly = $this->requestHostOnly = self::determineRequestHostOnly($httpHost);\n        $this->requestPort = self::determineRequestPort($httpHost, $requestHostOnly);\n        $scriptNameOnFileSystem = self::determineScriptName(\n            $serverParams,\n            $configuration,\n            $isHttps,\n            $isBehindReverseProxy\n        );\n        $scriptName = $this->scriptName = self::encodeFileSystemPathComponentForUrlPath($scriptNameOnFileSystem);\n        $requestUri = $this->requestUri = self::determineRequestUri(\n            $serverParams,\n            $configuration,\n            $isHttps,\n            $scriptName,\n            $isBehindReverseProxy\n        );\n        $requestUrl = $this->requestUrl = $requestHost . $requestUri;\n        $this->requestScript = $requestHost . $scriptName;\n        $requestDir = $this->requestDir = $requestHost . GeneralUtility::dirname($scriptName) . '/';\n        $this->remoteAddress = self::determineRemoteAddress($serverParams, $configuration, $isBehindReverseProxy);\n        $scriptFilename = $this->scriptFilename = $pathThisScript;\n        $this->documentRoot = self::determineDocumentRoot($scriptNameOnFileSystem, $scriptFilename);\n        $siteUrl = $this->siteUrl = self::determineSiteUrl($requestDir, $pathThisScript, $pathSite . '/');\n        $this->sitePath = self::determineSitePath($requestHost, $siteUrl);\n        $this->siteScript = self::determineSiteScript($requestUrl, $siteUrl);\n\n        // @deprecated Below variables can be fully deprecated as soon as core does not use them anymore\n        $this->pathInfo = $serverParams['PATH_INFO'] ?? '';\n        $this->httpReferer = $serverParams['HTTP_REFERER'] ?? '';\n        $this->httpUserAgent = $serverParams['HTTP_USER_AGENT'] ?? '';\n        $this->httpAcceptEncoding = $serverParams['HTTP_ACCEPT_ENCODING'] ?? '';\n        $this->httpAcceptLanguage = $serverParams['HTTP_ACCEPT_LANGUAGE'] ?? '';\n        $this->remoteHost = $serverParams['REMOTE_HOST'] ?? '';\n        $this->queryString = $serverParams['QUERY_STRING'] ?? '';\n    }\n\n    private static function encodeFileSystemPathComponentForUrlPath(string $path): string\n    {\n        return implode('/', array_map('rawurlencode', explode('/', $path)));\n    }\n\n    /**\n     * @return string Sanitized HTTP_HOST value host[:port]\n     */\n    public function getHttpHost(): string\n    {\n        return $this->httpHost;\n    }\n\n    /**\n     * @return bool True if client request has been done using HTTPS\n     */\n    public function isHttps(): bool\n    {\n        return $this->isHttps;\n    }\n\n    /**\n     * @return string Sanitized HTTP_HOST with protocol scheme://host[:port], eg. https://www.domain.com/\n     */\n    public function getRequestHost(): string\n    {\n        return $this->requestHost;\n    }\n\n    /**\n     * @return string Host / domain /IP only, eg. www.domain.com\n     */\n    public function getRequestHostOnly(): string\n    {\n        return $this->requestHostOnly;\n    }\n\n    /**\n     * @return int Requested port if given, eg. 8080 - often not explicitly given, then 0\n     */\n    public function getRequestPort(): int\n    {\n        return $this->requestPort;\n    }\n\n    /**\n     * @return string Script path part of URI, eg. '/typo3/index.php'\n     */\n    public function getScriptName(): string\n    {\n        return $this->scriptName;\n    }\n\n    /**\n     * @return string Request Uri without domain and protocol, eg. /index.php?id=42\n     */\n    public function getRequestUri(): string\n    {\n        return $this->requestUri;\n    }\n\n    /**\n     * @return string Full REQUEST_URI, eg. http://www.domain.com/typo3/foo/bar?id=42\n     */\n    public function getRequestUrl(): string\n    {\n        return $this->requestUrl;\n    }\n\n    /**\n     * @return string REQUEST URI without query part, eg. http://www.domain.com/typo3/index.php\n     */\n    public function getRequestScript(): string\n    {\n        return $this->requestScript;\n    }\n\n    /**\n     * @return string REQUEST URI without script file name and query parts, eg. http://www.domain.com/typo3/\n     */\n    public function getRequestDir(): string\n    {\n        return $this->requestDir;\n    }\n\n    /**\n     * @return bool True if request comes from a configured reverse proxy\n     */\n    public function isBehindReverseProxy(): bool\n    {\n        return $this->isBehindReverseProxy;\n    }\n\n    /**\n     * @return string Client IP\n     */\n    public function getRemoteAddress(): string\n    {\n        return $this->remoteAddress;\n    }\n\n    /**\n     * @return string Absolute entry script path on server, eg. /var/www/typo3/index.php\n     */\n    public function getScriptFilename(): string\n    {\n        return $this->scriptFilename;\n    }\n\n    /**\n     * @return string Absolute path to web document root, eg. /var/www/typo3\n     */\n    public function getDocumentRoot(): string\n    {\n        return $this->documentRoot;\n    }\n\n    /**\n     * @return string Website frontend url, eg. https://www.domain.com/some/sub/dir/\n     */\n    public function getSiteUrl(): string\n    {\n        return $this->siteUrl;\n    }\n\n    /**\n     * @return string Path part to frontend, eg. /some/sub/dir/\n     */\n    public function getSitePath(): string\n    {\n        return $this->sitePath;\n    }\n\n    /**\n     * @return string Path part to entry script with parameters, without sub dir, eg 'typo3/index.php?id=42'\n     */\n    public function getSiteScript(): string\n    {\n        return $this->siteScript;\n    }\n\n    /**\n     * Will be deprecated later, use getScriptName() as reliable solution instead\n     *\n     * @return string Script path part of URI, eg. 'typo3/index.php'\n     */\n    public function getPathInfo(): string\n    {\n        return $this->pathInfo;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_REFERER'] instead\n     *\n     * @return string HTTP_REFERER, eg. 'https://www.domain.com/typo3/index.php?id=42'\n     */\n    public function getHttpReferer(): string\n    {\n        return $this->httpReferer;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_USER_AGENT'] instead\n     *\n     * @return string HTTP_USER_AGENT identifier\n     */\n    public function getHttpUserAgent(): string\n    {\n        return $this->httpUserAgent;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_ENCODING'] instead\n     *\n     * @return string HTTP_ACCEPT_ENCODING, eg. 'gzip, deflate'\n     */\n    public function getHttpAcceptEncoding(): string\n    {\n        return $this->httpAcceptEncoding;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] instead\n     *\n     * @return string HTTP_ACCEPT_LANGUAGE, eg. 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7'\n     */\n    public function getHttpAcceptLanguage(): string\n    {\n        return $this->httpAcceptLanguage;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['REMOTE_HOST'] instead\n     *\n     * @return string REMOTE_HOST if configured in web server, eg. 'www.clientDomain.com'\n     */\n    public function getRemoteHost(): string\n    {\n        return $this->remoteHost;\n    }\n\n    /**\n     * Will be deprecated later, use $request->getServerParams()['QUERY_STRING'] instead\n     *\n     * @return string QUERY_STRING, eg 'id=42&foo=bar'\n     */\n    public function getQueryString(): string\n    {\n        return $this->queryString;\n    }\n\n    /**\n     * Normalize HTTP_HOST by taking proxy configuration into account.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS['SYS'] array\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Normalized HTTP_HOST\n     */\n    protected static function determineHttpHost(\n        array $serverParams,\n        array $configuration,\n        bool $isBehindReverseProxy\n    ): string {\n        $httpHost = $serverParams['HTTP_HOST'] ?? '';\n        if ($isBehindReverseProxy) {\n            // If the request comes from a configured proxy which has set HTTP_X_FORWARDED_HOST, then\n            // evaluate reverseProxyHeaderMultiValue and\n            $xForwardedHostArray = GeneralUtility::trimExplode(',', $serverParams['HTTP_X_FORWARDED_HOST'] ?? '', true);\n            $xForwardedHost = '';\n            // Choose which host in list to use\n            if (!empty($xForwardedHostArray)) {\n                $configuredReverseProxyHeaderMultiValue = trim($configuration['reverseProxyHeaderMultiValue'] ?? '');\n                // Default if reverseProxyHeaderMultiValue is not set or set to 'none', instead of 'first' / 'last' is to\n                // ignore $serverParams['HTTP_X_FORWARDED_HOST']\n                // @todo: Maybe this default is stupid: Both SYS/reverseProxyIP hand SYS/reverseProxyHeaderMultiValue have to\n                // @todo: be configured for a working setup. It would be easier to only configure SYS/reverseProxyIP and fall\n                // @todo: back to \"first\" if SYS/reverseProxyHeaderMultiValue is not set.\n                if ($configuredReverseProxyHeaderMultiValue === 'last') {\n                    $xForwardedHost = array_pop($xForwardedHostArray);\n                } elseif ($configuredReverseProxyHeaderMultiValue === 'first') {\n                    $xForwardedHost = array_shift($xForwardedHostArray);\n                }\n            }\n            if ($xForwardedHost) {\n                $httpHost = $xForwardedHost;\n            }\n        }\n        return $httpHost;\n    }\n\n    /**\n     * Determine if the client called via HTTPS. Takes proxy ssl terminator\n     * configurations into account.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS['SYS'] array\n     * @return bool True if request has been done via HTTPS\n     */\n    protected static function determineHttps(array $serverParams, array $configuration): bool\n    {\n        $isHttps = false;\n        $configuredProxySSL = trim($configuration['reverseProxySSL'] ?? '');\n        if ($configuredProxySSL === '*') {\n            $configuredProxySSL = trim($configuration['reverseProxyIP'] ?? '');\n        }\n        $httpsParam = (string)($serverParams['HTTPS'] ?? '');\n        if (GeneralUtility::cmpIP(trim($serverParams['REMOTE_ADDR'] ?? ''), $configuredProxySSL)\n            || ($serverParams['SSL_SESSION_ID'] ?? '')\n            // https://secure.php.net/manual/en/reserved.variables.server.php\n            // \"Set to a non-empty value if the script was queried through the HTTPS protocol.\"\n            || ($httpsParam !== '' && $httpsParam !== 'off' && $httpsParam !== '0')\n        ) {\n            $isHttps = true;\n        }\n        return $isHttps;\n    }\n\n    /**\n     * Determine script name and path\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration TYPO3_CONF_VARS['SYS'] array\n     * @param bool $isHttps True if used protocol is HTTPS\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Sanitized script name\n     */\n    protected static function determineScriptName(\n        array $serverParams,\n        array $configuration,\n        bool $isHttps,\n        bool $isBehindReverseProxy\n    ): string {\n        $scriptName = $serverParams['SCRIPT_NAME'] ?? '';\n        if ($isBehindReverseProxy) {\n            // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n            if ($isHttps && !empty($configuration['reverseProxyPrefixSSL'])) {\n                $scriptName = $configuration['reverseProxyPrefixSSL'] . $scriptName;\n            } elseif (!empty($configuration['reverseProxyPrefix'])) {\n                $scriptName = $configuration['reverseProxyPrefix'] . $scriptName;\n            }\n        }\n        return $scriptName;\n    }\n\n    /**\n     * Determine REQUEST_URI, taking proxy configuration and various web server\n     * specifics into account.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS['SYS'] array\n     * @param bool $isHttps True if used protocol is HTTPS\n     * @param string $scriptName Script name\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Sanitized REQUEST_URI\n     */\n    protected static function determineRequestUri(\n        array $serverParams,\n        array $configuration,\n        bool $isHttps,\n        string $scriptName,\n        bool $isBehindReverseProxy\n    ): string {\n        $proxyPrefixApplied = false;\n        if (!empty($configuration['requestURIvar'])) {\n            // This is for URL rewriter that store the original URI in a server\n            // variable (e.g. ISAPI Rewriter for IIS: HTTP_X_REWRITE_URL), a config then looks like:\n            // requestURIvar = '_SERVER|HTTP_X_REWRITE_URL' which will access $GLOBALS['_SERVER']['HTTP_X_REWRITE_URL']\n            [$firstLevel, $secondLevel] = GeneralUtility::trimExplode('|', $configuration['requestURIvar'], true);\n            $requestUri = $GLOBALS[$firstLevel][$secondLevel];\n        } elseif (empty($serverParams['REQUEST_URI'])) {\n            // This is for ISS/CGI which does not have the REQUEST_URI available.\n            $queryString = !empty($serverParams['QUERY_STRING']) ? '?' . $serverParams['QUERY_STRING'] : '';\n            // script name already had the proxy prefix handling, we must not add it a second time\n            $proxyPrefixApplied = true;\n            $requestUri = '/' . ltrim($scriptName, '/') . $queryString;\n        } else {\n            $requestUri = '/' . ltrim($serverParams['REQUEST_URI'], '/');\n        }\n        if (!$proxyPrefixApplied && $isBehindReverseProxy) {\n            // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n            if ($isHttps && !empty($configuration['reverseProxyPrefixSSL'])) {\n                $requestUri = $configuration['reverseProxyPrefixSSL'] . $requestUri;\n            } elseif (!empty($configuration['reverseProxyPrefix'])) {\n                $requestUri = $configuration['reverseProxyPrefix'] . $requestUri;\n            }\n        }\n        return $requestUri;\n    }\n\n    /**\n     * Determine clients REMOTE_ADDR, even if there is a reverse proxy in between.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS[SYS] array\n     * @param bool $isBehindReverseProxy True if reverse proxy setup is detected\n     * @return string Resolved REMOTE_ADDR\n     */\n    protected static function determineRemoteAddress(\n        array $serverParams,\n        array $configuration,\n        bool $isBehindReverseProxy\n    ): string {\n        $remoteAddress = trim($serverParams['REMOTE_ADDR'] ?? '');\n        if ($isBehindReverseProxy) {\n            $ip = GeneralUtility::trimExplode(',', $serverParams['HTTP_X_FORWARDED_FOR'] ?? '', true);\n            // Choose which IP in list to use\n            $configuredReverseProxyHeaderMultiValue = trim($configuration['reverseProxyHeaderMultiValue'] ?? '');\n            if (!empty($ip) && $configuredReverseProxyHeaderMultiValue === 'last') {\n                $ip = (string)array_pop($ip);\n            } elseif (!empty($ip) && $configuredReverseProxyHeaderMultiValue === 'first') {\n                $ip = (string)array_shift($ip);\n            } else {\n                $ip = '';\n            }\n            if (GeneralUtility::validIP($ip)) {\n                $remoteAddress = $ip;\n            }\n        }\n        return $remoteAddress;\n    }\n\n    /**\n     * Check if a configured reverse proxy setup is detected.\n     *\n     * @param array $serverParams Basically the $_SERVER, but from $request object\n     * @param array $configuration $TYPO3_CONF_VARS[SYS] array\n     * @return bool True if TYPO3 is behind a reverse proxy\n     */\n    protected static function determineIsBehindReverseProxy($serverParams, $configuration): bool\n    {\n        return GeneralUtility::cmpIP(\n            trim($serverParams['REMOTE_ADDR'] ?? ''),\n            trim($configuration['reverseProxyIP'] ?? '')\n        );\n    }\n\n    /**\n     * HTTP_HOST without port\n     *\n     * @param string $httpHost host[:[port]]\n     * @return string Resolved host\n     */\n    protected static function determineRequestHostOnly(string $httpHost): string\n    {\n        $httpHostBracketPosition = strpos($httpHost, ']');\n        $httpHostParts = explode(':', $httpHost);\n        return $httpHostBracketPosition !== false ? substr(\n            $httpHost,\n            0,\n            $httpHostBracketPosition + 1\n        ) : array_shift($httpHostParts);\n    }\n\n    /**\n     * Requested port if given\n     *\n     * @param string $httpHost host[:[port]]\n     * @param string $httpHostOnly host\n     * @return int Resolved port if given, else 0\n     */\n    protected static function determineRequestPort(string $httpHost, string $httpHostOnly): int\n    {\n        return strlen($httpHost) > strlen($httpHostOnly) ? (int)substr($httpHost, strlen($httpHostOnly) + 1) : 0;\n    }\n\n    /**\n     * Calculate absolute path to web document root\n     *\n     * @param string $scriptNameOnFileSystem Entry script path of URI on file system, without domain and without query parameters, with leading /\n     * @param string $scriptFilename Absolute path to entry script on server filesystem\n     * @return string Path to document root with trailing slash\n     */\n    protected static function determineDocumentRoot(string $scriptNameOnFileSystem, string $scriptFilename): string\n    {\n        // Get the web root (it is not the root of the TYPO3 installation)\n        // Some CGI-versions (LA13CGI) and mod-rewrite rules on MODULE versions will deliver a 'wrong'\n        // DOCUMENT_ROOT (according to our description). Further various aliases/mod_rewrite rules can\n        // disturb this as well. Therefore the DOCUMENT_ROOT is always calculated as the SCRIPT_FILENAME\n        // minus the end part shared with SCRIPT_NAME.\n        $webDocRoot = '';\n        $scriptNameArray = explode('/', strrev($scriptNameOnFileSystem));\n        $scriptFilenameArray = explode('/', strrev($scriptFilename));\n        $path = [];\n        foreach ($scriptNameArray as $segmentNumber => $segment) {\n            if ((string)$scriptFilenameArray[$segmentNumber] === (string)$segment) {\n                $path[] = $segment;\n            } else {\n                break;\n            }\n        }\n        $commonEnd = strrev(implode('/', $path));\n        if ((string)$commonEnd !== '') {\n            $webDocRoot = substr($scriptFilename, 0, -(strlen($commonEnd) + 1));\n        }\n        return $webDocRoot;\n    }\n\n    /**\n     * Determine frontend url\n     *\n     * @param string $requestDir Full Uri with path, but without script name and query parts\n     * @param string $pathThisScript Absolute path to entry script on server filesystem\n     * @param string $pathSite Absolute server path to document root\n     * @return string Calculated Frontend Url\n     */\n    protected static function determineSiteUrl(string $requestDir, string $pathThisScript, string $pathSite): string\n    {\n        $pathThisScriptDir = substr(dirname($pathThisScript), strlen($pathSite)) . '/';\n        $siteUrl = (string)substr($requestDir, 0, -strlen($pathThisScriptDir));\n\n        return rtrim($siteUrl, '/') . '/';\n    }\n\n    /**\n     * Determine site path\n     *\n     * @param string $requestHost scheme://host[:port]\n     * @param string $siteUrl Full Frontend Url\n     */\n    protected static function determineSitePath(string $requestHost, string $siteUrl): string\n    {\n        return (string)substr($siteUrl, strlen($requestHost));\n    }\n\n    /**\n     * Determine site script\n     */\n    protected static function determineSiteScript(string $requestUrl, string $siteUrl): string\n    {\n        return (string)substr($requestUrl, strlen($siteUrl));\n    }\n\n    /**\n     * Factory method, to allow TYPO3 to handle configuration options directly.\n     *\n     * @param array $serverParams - could be fulfilled by $_SERVER (on web requests)\n     * @param array|null $systemConfiguration\n     * @return static\n     */\n    public static function createFromServerParams(array $serverParams, array $systemConfiguration = null): self\n    {\n        return new NormalizedParams(\n            $serverParams,\n            $systemConfiguration ?? $GLOBALS['TYPO3_CONF_VARS']['SYS'],\n            Environment::getCurrentScript(),\n            Environment::getPublicPath()\n        );\n    }\n\n    /**\n     * Factory method for creating normalized params from a PSR-7 server request object\n     *\n     * @param array|null $systemConfiguration\n     * @return static\n     */\n    public static function createFromRequest(ServerRequestInterface $request, array $systemConfiguration = null): self\n    {\n        return static::createFromServerParams(\n            $request->getServerParams(),\n            $systemConfiguration ?? $GLOBALS['TYPO3_CONF_VARS']['SYS']\n        );\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Utility;\n\nuse Egulias\\EmailValidator\\EmailValidator;\nuse Egulias\\EmailValidator\\Validation\\EmailValidation;\nuse Egulias\\EmailValidator\\Validation\\MultipleValidationWithAnd;\nuse Egulias\\EmailValidator\\Validation\\RFCValidation;\nuse GuzzleHttp\\Exception\\RequestException;\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerInterface;\nuse TYPO3\\CMS\\Core\\Authentication\\AbstractAuthenticationService;\nuse TYPO3\\CMS\\Core\\Cache\\CacheManager;\nuse TYPO3\\CMS\\Core\\Core\\ClassLoadingInformation;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Http\\ApplicationType;\nuse TYPO3\\CMS\\Core\\Http\\RequestFactory;\nuse TYPO3\\CMS\\Core\\Log\\LogManager;\nuse TYPO3\\CMS\\Core\\Package\\Exception as PackageException;\nuse TYPO3\\CMS\\Core\\SingletonInterface;\n\n/**\n * The legendary \"t3lib_div\" class - Miscellaneous functions for general purpose.\n * Most of the functions do not relate specifically to TYPO3\n * However a section of functions requires certain TYPO3 features available\n * See comments in the source.\n * You are encouraged to use this library in your own scripts!\n *\n * USE:\n * All methods in this class are meant to be called statically.\n * So use \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::[method-name] to refer to the functions, eg. '\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::milliseconds()'\n */\nclass GeneralUtility\n{\n    protected static ?ContainerInterface $container = null;\n\n    /**\n     * Singleton instances returned by `makeInstance`, using the class names as array keys\n     *\n     * @var array<class-string, SingletonInterface>\n     */\n    protected static array $singletonInstances = [];\n\n    /**\n     * Instances returned by `makeInstance`, using the class names as array keys\n     *\n     * @var array<class-string, array<int, object>>\n     */\n    protected static array $nonSingletonInstances = [];\n\n    /**\n     * Cache for `makeInstance` with given class name and final class names to reduce number of\n     * `self::getClassName()` calls\n     *\n     * @var array<class-string, class-string> Given class name => final class name\n     */\n    protected static array $finalClassNameCache = [];\n\n    /**\n     * @var array<string, string|bool|array<string, string|bool|null>|null>\n     */\n    protected static array $indpEnvCache = [];\n\n    final private function __construct()\n    {\n    }\n\n    /*************************\n     *\n     * GET/POST Variables\n     *\n     * Background:\n     * Input GET/POST variables in PHP may have their quotes escaped with \"\\\" or not depending on configuration.\n     * TYPO3 has always converted quotes to BE escaped if the configuration told that they would not be so.\n     * But the clean solution is that quotes are never escaped and that is what the functions below offers.\n     * Eventually TYPO3 should provide this in the global space as well.\n     * In the transitional phase (or forever..?) we need to encourage EVERY to read and write GET/POST vars through the API functions below.\n     * This functionality was previously needed to normalize between magic quotes logic, which was removed from PHP 5.4,\n     * so these methods are still in use, but not tackle the slash problem anymore.\n     *\n     *************************/\n    /**\n     * Returns the 'GLOBAL' value of incoming data from POST or GET, with priority to POST, which is equivalent to 'GP' order\n     * In case you already know by which method your data is arriving consider using GeneralUtility::_GET or GeneralUtility::_POST.\n     *\n     * @param string $var GET/POST var to return\n     * @return mixed POST var named $var, if not set, the GET var of the same name and if also not set, NULL.\n     */\n    public static function _GP($var)\n    {\n        if (empty($var)) {\n            return;\n        }\n\n        $value = $_POST[$var] ?? $_GET[$var] ?? null;\n\n        // This is there for backwards-compatibility, in order to avoid NULL\n        if (isset($value) && !is_array($value)) {\n            $value = (string)$value;\n        }\n        return $value;\n    }\n\n    /**\n     * Returns the global arrays $_GET and $_POST merged with $_POST taking precedence.\n     *\n     * @param string $parameter Key (variable name) from GET or POST vars\n     * @return array Returns the GET vars merged recursively onto the POST vars.\n     * @deprecated since TYPO3 v12.2. will be removed in TYPO3 v13.0.\n     */\n    public static function _GPmerged($parameter)\n    {\n        trigger_error(\n            'GeneralUtility::_GPmerged() will be removed in TYPO3 v13.0, retrieve request related' .\n            ' details from PSR-7 ServerRequestInterface instead.',\n            E_USER_DEPRECATED\n        );\n        $postParameter = isset($_POST[$parameter]) && is_array($_POST[$parameter]) ? $_POST[$parameter] : [];\n        $getParameter = isset($_GET[$parameter]) && is_array($_GET[$parameter]) ? $_GET[$parameter] : [];\n        $mergedParameters = $getParameter;\n        ArrayUtility::mergeRecursiveWithOverrule($mergedParameters, $postParameter);\n        return $mergedParameters;\n    }\n\n    /**\n     * Returns the global $_GET array (or value from) normalized to contain un-escaped values.\n     * This function was previously used to normalize between magic quotes logic, which was removed from PHP 5.5\n     *\n     * @param string $var Optional pointer to value in GET array (basically name of GET var)\n     * @return mixed If $var is set it returns the value of $_GET[$var]. If $var is NULL (default), returns $_GET itself.\n     * @see _POST()\n     * @see _GP()\n     */\n    public static function _GET($var = null)\n    {\n        $value = $var === null\n            ? $_GET\n            : (empty($var) ? null : ($_GET[$var] ?? null));\n        // This is there for backwards-compatibility, in order to avoid NULL\n        if (isset($value) && !is_array($value)) {\n            $value = (string)$value;\n        }\n        return $value;\n    }\n\n    /**\n     * Returns the global $_POST array (or value from) normalized to contain un-escaped values.\n     *\n     * @param string $var Optional pointer to value in POST array (basically name of POST var)\n     * @return mixed If $var is set it returns the value of $_POST[$var]. If $var is NULL (default), returns $_POST itself.\n     * @see _GET()\n     * @see _GP()\n     * @deprecated since TYPO3 v12.2. will be removed in TYPO3 v13.0.\n     */\n    public static function _POST($var = null)\n    {\n        trigger_error(\n            'GeneralUtility::_POST() will be removed in TYPO3 v13.0, retrieve request related' .\n            ' details from PSR-7 ServerRequestInterface instead.',\n            E_USER_DEPRECATED\n        );\n        $value = $var === null ? $_POST : (empty($var) || !isset($_POST[$var]) ? null : $_POST[$var]);\n        // This is there for backwards-compatibility, in order to avoid NULL\n        if (isset($value) && !is_array($value)) {\n            $value = (string)$value;\n        }\n        return $value;\n    }\n\n    /*************************\n     *\n     * STRING FUNCTIONS\n     *\n     *************************/\n    /**\n     * Truncates a string with appended/prepended \"...\" and takes current character set into consideration.\n     *\n     * @param string $string String to truncate\n     * @param int $chars Must be an integer with an absolute value of at least 4. if negative the string is cropped from the right end.\n     * @param string $appendString Appendix to the truncated string\n     * @return string Cropped string\n     */\n    public static function fixed_lgd_cs(string $string, int $chars, string $appendString = '...'): string\n    {\n        if ($chars === 0 || mb_strlen($string, 'utf-8') <= abs($chars)) {\n            return $string;\n        }\n        if ($chars > 0) {\n            $string = mb_substr($string, 0, $chars, 'utf-8') . $appendString;\n        } else {\n            $string = $appendString . mb_substr($string, $chars, mb_strlen($string, 'utf-8'), 'utf-8');\n        }\n        return $string;\n    }\n\n    /**\n     * Match IP number with list of numbers with wildcard\n     * Dispatcher method for switching into specialised IPv4 and IPv6 methods.\n     *\n     * @param string $baseIP Is the current remote IP address for instance, typ. REMOTE_ADDR\n     * @param string $list Is a comma-list of IP-addresses to match with. CIDR-notation should be used. For IPv4 addresses only, the *-wildcard is also allowed instead of number, plus leaving out parts in the IP number is accepted as wildcard (eg. 192.168.*.* equals 192.168). If list is \"*\" no check is done and the function returns TRUE immediately. An empty list always returns FALSE.\n     * @return bool TRUE if an IP-mask from $list matches $baseIP\n     */\n    public static function cmpIP($baseIP, $list)\n    {\n        $list = trim($list);\n        if ($list === '') {\n            return false;\n        }\n        if ($list === '*') {\n            return true;\n        }\n        if (str_contains($baseIP, ':') && self::validIPv6($baseIP)) {\n            return self::cmpIPv6($baseIP, $list);\n        }\n        return self::cmpIPv4($baseIP, $list);\n    }\n\n    /**\n     * Match IPv4 number with list of numbers with wildcard\n     *\n     * @param string $baseIP Is the current remote IP address for instance, typ. REMOTE_ADDR\n     * @param string $list Is a comma-list of IP-addresses to match with. CIDR-notation, *-wildcard allowed instead of number, plus leaving out parts in the IP number is accepted as wildcard (eg. 192.168.0.0/16 equals 192.168.*.* equals 192.168), could also contain IPv6 addresses\n     * @return bool TRUE if an IP-mask from $list matches $baseIP\n     */\n    public static function cmpIPv4($baseIP, $list)\n    {\n        $IPpartsReq = explode('.', $baseIP);\n        if (count($IPpartsReq) === 4) {\n            $values = self::trimExplode(',', $list, true);\n            foreach ($values as $test) {\n                $testList = explode('/', $test);\n                if (count($testList) === 2) {\n                    [$test, $mask] = $testList;\n                } else {\n                    $mask = false;\n                }\n                if ((int)$mask) {\n                    $mask = (int)$mask;\n                    // \"192.168.3.0/24\"\n                    $lnet = (int)ip2long($test);\n                    $lip = (int)ip2long($baseIP);\n                    $binnet = str_pad(decbin($lnet), 32, '0', STR_PAD_LEFT);\n                    $firstpart = substr($binnet, 0, $mask);\n                    $binip = str_pad(decbin($lip), 32, '0', STR_PAD_LEFT);\n                    $firstip = substr($binip, 0, $mask);\n                    $yes = $firstpart === $firstip;\n                } else {\n                    // \"192.168.*.*\"\n                    $IPparts = explode('.', $test);\n                    $yes = 1;\n                    foreach ($IPparts as $index => $val) {\n                        $val = trim($val);\n                        if ($val !== '*' && $IPpartsReq[$index] !== $val) {\n                            $yes = 0;\n                        }\n                    }\n                }\n                if ($yes) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Match IPv6 address with a list of IPv6 prefixes\n     *\n     * @param string $baseIP Is the current remote IP address for instance\n     * @param string $list Is a comma-list of IPv6 prefixes, could also contain IPv4 addresses. IPv6 addresses\n     *   must be specified in CIDR-notation, not with * wildcard, otherwise self::validIPv6() will fail.\n     * @return bool TRUE If a baseIP matches any prefix\n     */\n    public static function cmpIPv6($baseIP, $list)\n    {\n        // Policy default: Deny connection\n        $success = false;\n        $baseIP = self::normalizeIPv6($baseIP);\n        $values = self::trimExplode(',', $list, true);\n        foreach ($values as $test) {\n            $testList = explode('/', $test);\n            if (count($testList) === 2) {\n                [$test, $mask] = $testList;\n            } else {\n                $mask = false;\n            }\n            if (self::validIPv6($test)) {\n                $test = self::normalizeIPv6($test);\n                $maskInt = (int)$mask ?: 128;\n                // Special case; /0 is an allowed mask - equals a wildcard\n                if ($mask === '0') {\n                    $success = true;\n                } elseif ($maskInt == 128) {\n                    $success = $test === $baseIP;\n                } else {\n                    $testBin = (string)inet_pton($test);\n                    $baseIPBin = (string)inet_pton($baseIP);\n\n                    $success = true;\n                    // Modulo is 0 if this is a 8-bit-boundary\n                    $maskIntModulo = $maskInt % 8;\n                    $numFullCharactersUntilBoundary = (int)($maskInt / 8);\n                    $substring = (string)substr($baseIPBin, 0, $numFullCharactersUntilBoundary);\n                    if (!str_starts_with($testBin, $substring)) {\n                        $success = false;\n                    } elseif ($maskIntModulo > 0) {\n                        // If not an 8-bit-boundary, check bits of last character\n                        $testLastBits = str_pad(decbin(ord(substr($testBin, $numFullCharactersUntilBoundary, 1))), 8, '0', STR_PAD_LEFT);\n                        $baseIPLastBits = str_pad(decbin(ord(substr($baseIPBin, $numFullCharactersUntilBoundary, 1))), 8, '0', STR_PAD_LEFT);\n                        if (strncmp($testLastBits, $baseIPLastBits, $maskIntModulo) != 0) {\n                            $success = false;\n                        }\n                    }\n                }\n            }\n            if ($success) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Normalize an IPv6 address to full length\n     *\n     * @param string $address Given IPv6 address\n     * @return string Normalized address\n     */\n    public static function normalizeIPv6($address)\n    {\n        $normalizedAddress = '';\n        // According to RFC lowercase-representation is recommended\n        $address = strtolower($address);\n        // Normalized representation has 39 characters (0000:0000:0000:0000:0000:0000:0000:0000)\n        if (strlen($address) === 39) {\n            // Already in full expanded form\n            return $address;\n        }\n        // Count 2 if if address has hidden zero blocks\n        $chunks = explode('::', $address);\n        if (count($chunks) === 2) {\n            $chunksLeft = explode(':', $chunks[0]);\n            $chunksRight = explode(':', $chunks[1]);\n            $left = count($chunksLeft);\n            $right = count($chunksRight);\n            // Special case: leading zero-only blocks count to 1, should be 0\n            if ($left === 1 && strlen($chunksLeft[0]) === 0) {\n                $left = 0;\n            }\n            $hiddenBlocks = 8 - ($left + $right);\n            $hiddenPart = '';\n            $h = 0;\n            while ($h < $hiddenBlocks) {\n                $hiddenPart .= '0000:';\n                $h++;\n            }\n            if ($left === 0) {\n                $stageOneAddress = $hiddenPart . $chunks[1];\n            } else {\n                $stageOneAddress = $chunks[0] . ':' . $hiddenPart . $chunks[1];\n            }\n        } else {\n            $stageOneAddress = $address;\n        }\n        // Normalize the blocks:\n        $blocks = explode(':', $stageOneAddress);\n        $divCounter = 0;\n        foreach ($blocks as $block) {\n            $tmpBlock = '';\n            $i = 0;\n            $hiddenZeros = 4 - strlen($block);\n            while ($i < $hiddenZeros) {\n                $tmpBlock .= '0';\n                $i++;\n            }\n            $normalizedAddress .= $tmpBlock . $block;\n            if ($divCounter < 7) {\n                $normalizedAddress .= ':';\n                $divCounter++;\n            }\n        }\n        return $normalizedAddress;\n    }\n\n    /**\n     * Validate a given IP address.\n     *\n     * Possible format are IPv4 and IPv6.\n     *\n     * @param string $ip IP address to be tested\n     * @return bool TRUE if $ip is either of IPv4 or IPv6 format.\n     */\n    public static function validIP($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP) !== false;\n    }\n\n    /**\n     * Validate a given IP address to the IPv4 address format.\n     *\n     * Example for possible format: 10.0.45.99\n     *\n     * @param string $ip IP address to be tested\n     * @return bool TRUE if $ip is of IPv4 format.\n     */\n    public static function validIPv4($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false;\n    }\n\n    /**\n     * Validate a given IP address to the IPv6 address format.\n     *\n     * Example for possible format: 43FB::BB3F:A0A0:0 | ::1\n     *\n     * @param string $ip IP address to be tested\n     * @return bool TRUE if $ip is of IPv6 format.\n     */\n    public static function validIPv6($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false;\n    }\n\n    /**\n     * Match fully qualified domain name with list of strings with wildcard\n     *\n     * @param string $baseHost A hostname or an IPv4/IPv6-address (will by reverse-resolved; typically REMOTE_ADDR)\n     * @param string $list A comma-list of domain names to match with. *-wildcard allowed but cannot be part of a string, so it must match the full host name (eg. myhost.*.com => correct, myhost.*domain.com => wrong)\n     * @return bool TRUE if a domain name mask from $list matches $baseIP\n     */\n    public static function cmpFQDN($baseHost, $list)\n    {\n        $baseHost = trim($baseHost);\n        if (empty($baseHost)) {\n            return false;\n        }\n        if (self::validIPv4($baseHost) || self::validIPv6($baseHost)) {\n            // Resolve hostname\n            // Note: this is reverse-lookup and can be randomly set as soon as somebody is able to set\n            // the reverse-DNS for his IP (security when for example used with REMOTE_ADDR)\n            $baseHostName = (string)gethostbyaddr($baseHost);\n            if ($baseHostName === $baseHost) {\n                // Unable to resolve hostname\n                return false;\n            }\n        } else {\n            $baseHostName = $baseHost;\n        }\n        $baseHostNameParts = explode('.', $baseHostName);\n        $values = self::trimExplode(',', $list, true);\n        foreach ($values as $test) {\n            $hostNameParts = explode('.', $test);\n            // To match hostNameParts can only be shorter (in case of wildcards) or equal\n            $hostNamePartsCount = count($hostNameParts);\n            $baseHostNamePartsCount = count($baseHostNameParts);\n            if ($hostNamePartsCount > $baseHostNamePartsCount) {\n                continue;\n            }\n            $yes = true;\n            foreach ($hostNameParts as $index => $val) {\n                $val = trim($val);\n                if ($val === '*') {\n                    // Wildcard valid for one or more hostname-parts\n                    $wildcardStart = $index + 1;\n                    // Wildcard as last/only part always matches, otherwise perform recursive checks\n                    if ($wildcardStart < $hostNamePartsCount) {\n                        $wildcardMatched = false;\n                        $tempHostName = implode('.', array_slice($hostNameParts, $index + 1));\n                        while ($wildcardStart < $baseHostNamePartsCount && !$wildcardMatched) {\n                            $tempBaseHostName = implode('.', array_slice($baseHostNameParts, $wildcardStart));\n                            $wildcardMatched = self::cmpFQDN($tempBaseHostName, $tempHostName);\n                            $wildcardStart++;\n                        }\n                        if ($wildcardMatched) {\n                            // Match found by recursive compare\n                            return true;\n                        }\n                        $yes = false;\n                    }\n                } elseif ($baseHostNameParts[$index] !== $val) {\n                    // In case of no match\n                    $yes = false;\n                }\n            }\n            if ($yes) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if a given URL matches the host that currently handles this HTTP request.\n     * Scheme, hostname and (optional) port of the given URL are compared.\n     *\n     * @param string $url URL to compare with the TYPO3 request host\n     * @return bool Whether the URL matches the TYPO3 request host\n     */\n    public static function isOnCurrentHost($url)\n    {\n        return stripos($url . '/', self::getIndpEnv('TYPO3_REQUEST_HOST') . '/') === 0;\n    }\n\n    /**\n     * Check for item in list\n     * Check if an item exists in a comma-separated list of items.\n     *\n     * @param string $list Comma-separated list of items (string)\n     * @param string $item Item to check for\n     * @return bool TRUE if $item is in $list\n     */\n    public static function inList($list, $item)\n    {\n        return str_contains(',' . $list . ',', ',' . $item . ',');\n    }\n\n    /**\n     * Expand a comma-separated list of integers with ranges (eg 1,3-5,7 becomes 1,3,4,5,7).\n     * Ranges are limited to 1000 values per range.\n     *\n     * @param string $list Comma-separated list of integers with ranges (string)\n     * @return string New comma-separated list of items\n     */\n    public static function expandList($list)\n    {\n        $items = explode(',', $list);\n        $list = [];\n        foreach ($items as $item) {\n            $range = explode('-', $item);\n            if (isset($range[1])) {\n                $runAwayBrake = 1000;\n                for ($n = $range[0]; $n <= $range[1]; $n++) {\n                    $list[] = $n;\n                    $runAwayBrake--;\n                    if ($runAwayBrake <= 0) {\n                        break;\n                    }\n                }\n            } else {\n                $list[] = $item;\n            }\n        }\n        return implode(',', $list);\n    }\n\n    /**\n     * Makes a positive integer hash out of the first 7 chars from the md5 hash of the input\n     *\n     * @param string $str String to md5-hash\n     * @return int Returns 28bit integer-hash\n     */\n    public static function md5int($str)\n    {\n        return hexdec(substr(md5($str), 0, 7));\n    }\n\n    /**\n     * Returns a proper HMAC on a given input string and secret TYPO3 encryption key.\n     *\n     * @param string $input Input string to create HMAC from\n     * @param string $additionalSecret additionalSecret to prevent hmac being used in a different context\n     * @return string resulting (hexadecimal) HMAC currently with a length of 40 (HMAC-SHA-1)\n     */\n    public static function hmac($input, $additionalSecret = '')\n    {\n        $hashAlgorithm = 'sha1';\n        $secret = $GLOBALS['TYPO3_CONF_VARS']['SYS']['encryptionKey'] . $additionalSecret;\n        return hash_hmac($hashAlgorithm, $input, $secret);\n    }\n\n    /**\n     * Splits a reference to a file in 5 parts\n     *\n     * @param string $fileNameWithPath File name with path to be analyzed (must exist if open_basedir is set)\n     * @return array<string, string> Contains keys [path], [file], [filebody], [fileext], [realFileext]\n     */\n    public static function split_fileref($fileNameWithPath)\n    {\n        $info = [];\n        $reg = [];\n        if (preg_match('/(.*\\\\/)(.*)$/', $fileNameWithPath, $reg)) {\n            $info['path'] = $reg[1];\n            $info['file'] = $reg[2];\n        } else {\n            $info['path'] = '';\n            $info['file'] = $fileNameWithPath;\n        }\n        $reg = '';\n        // If open_basedir is set and the fileName was supplied without a path the is_dir check fails\n        if (!is_dir($fileNameWithPath) && preg_match('/(.*)\\\\.([^\\\\.]*$)/', $info['file'], $reg)) {\n            $info['filebody'] = $reg[1];\n            $info['fileext'] = strtolower($reg[2]);\n            $info['realFileext'] = $reg[2];\n        } else {\n            $info['filebody'] = $info['file'];\n            $info['fileext'] = '';\n        }\n        reset($info);\n        return $info;\n    }\n\n    /**\n     * Returns the directory part of a path without trailing slash\n     * If there is no dir-part, then an empty string is returned.\n     * Behaviour:\n     *\n     * '/dir1/dir2/script.php' => '/dir1/dir2'\n     * '/dir1/' => '/dir1'\n     * 'dir1/script.php' => 'dir1'\n     * 'd/script.php' => 'd'\n     * '/script.php' => ''\n     * '' => ''\n     *\n     * @param string $path Directory name / path\n     * @return string Processed input value. See function description.\n     */\n    public static function dirname($path)\n    {\n        $p = self::revExplode('/', $path, 2);\n        return count($p) === 2 ? $p[0] : '';\n    }\n\n    /**\n     * Formats the input integer $sizeInBytes as bytes/kilobytes/megabytes (-/K/M)\n     *\n     * @param int $sizeInBytes Number of bytes to format.\n     * @param string $labels Binary unit name \"iec\", decimal unit name \"si\" or labels for bytes, kilo, mega, giga, and so on separated by vertical bar (|) and possibly encapsulated in \"\". Eg: \" | K| M| G\". Defaults to \"iec\".\n     * @param int $base The unit base if not using a unit name. Defaults to 1024.\n     * @return string Formatted representation of the byte number, for output.\n     */\n    public static function formatSize($sizeInBytes, $labels = '', $base = 0)\n    {\n        $defaultFormats = [\n            'iec' => ['base' => 1024, 'labels' => [' ', ' Ki', ' Mi', ' Gi', ' Ti', ' Pi', ' Ei', ' Zi', ' Yi']],\n            'si' => ['base' => 1000, 'labels' => [' ', ' k', ' M', ' G', ' T', ' P', ' E', ' Z', ' Y']],\n        ];\n        // Set labels and base:\n        if (empty($labels)) {\n            $labels = 'iec';\n        }\n        if (isset($defaultFormats[$labels])) {\n            $base = $defaultFormats[$labels]['base'];\n            $labelArr = $defaultFormats[$labels]['labels'];\n        } else {\n            $base = (int)$base;\n            if ($base !== 1000 && $base !== 1024) {\n                $base = 1024;\n            }\n            $labelArr = explode('|', str_replace('\"', '', $labels));\n        }\n        // This is set via Site Handling and in the Locales class via setlocale()\n        $localeInfo = localeconv();\n        $sizeInBytes = max($sizeInBytes, 0);\n        $multiplier = floor(($sizeInBytes ? log($sizeInBytes) : 0) / log($base));\n        $sizeInUnits = $sizeInBytes / $base ** $multiplier;\n        if ($sizeInUnits > ($base * .9)) {\n            $multiplier++;\n        }\n        $multiplier = min($multiplier, count($labelArr) - 1);\n        $sizeInUnits = $sizeInBytes / $base ** $multiplier;\n        return number_format($sizeInUnits, (($multiplier > 0) && ($sizeInUnits < 20)) ? 2 : 0, $localeInfo['decimal_point'], '') . $labelArr[$multiplier];\n    }\n\n    /**\n     * This splits a string by the chars in $operators (typical /+-*) and returns an array with them in\n     *\n     * @param string $string Input string, eg \"123 + 456 / 789 - 4\n     * @param string $operators Operators to split by, typically \"/+-*\n     * @return array<int, array<int, string>> Array with operators and operands separated.\n     * @see \\TYPO3\\CMS\\Frontend\\ContentObject\\ContentObjectRenderer::calc()\n     * @see \\TYPO3\\CMS\\Frontend\\Imaging\\GifBuilder::calcOffset()\n     */\n    public static function splitCalc($string, $operators)\n    {\n        $res = [];\n        $sign = '+';\n        while ($string) {\n            $valueLen = strcspn($string, $operators);\n            $value = substr($string, 0, $valueLen);\n            $res[] = [$sign, trim($value)];\n            $sign = substr($string, $valueLen, 1);\n            $string = substr($string, $valueLen + 1);\n        }\n        reset($res);\n        return $res;\n    }\n\n    /**\n     * Checking syntax of input email address\n     *\n     * @param string $email Input string to evaluate\n     * @return bool Returns TRUE if the $email address (input string) is valid\n     */\n    public static function validEmail($email)\n    {\n        // Early return in case input is not a string\n        if (!is_string($email)) {\n            return false;\n        }\n        if (trim($email) !== $email) {\n            return false;\n        }\n        if (!str_contains($email, '@')) {\n            return false;\n        }\n        $validators = [];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['MAIL']['validators'] ?? [RFCValidation::class] as $className) {\n            $validator = new $className();\n            if ($validator instanceof EmailValidation) {\n                $validators[] = $validator;\n            }\n        }\n        return (new EmailValidator())->isValid($email, new MultipleValidationWithAnd($validators, MultipleValidationWithAnd::STOP_ON_ERROR));\n    }\n\n    /**\n     * Returns a given string with underscores as UpperCamelCase.\n     * Example: Converts blog_example to BlogExample\n     *\n     * @param string $string String to be converted to camel case\n     * @return string UpperCamelCasedWord\n     */\n    public static function underscoredToUpperCamelCase($string)\n    {\n        return str_replace(' ', '', ucwords(str_replace('_', ' ', strtolower($string))));\n    }\n\n    /**\n     * Returns a given string with underscores as lowerCamelCase.\n     * Example: Converts minimal_value to minimalValue\n     *\n     * @param string $string String to be converted to camel case\n     * @return string lowerCamelCasedWord\n     */\n    public static function underscoredToLowerCamelCase($string)\n    {\n        return lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', strtolower($string)))));\n    }\n\n    /**\n     * Returns a given CamelCasedString as a lowercase string with underscores.\n     * Example: Converts BlogExample to blog_example, and minimalValue to minimal_value\n     *\n     * @param string $string String to be converted to lowercase underscore\n     * @return string lowercase_and_underscored_string\n     */\n    public static function camelCaseToLowerCaseUnderscored($string)\n    {\n        $value = preg_replace('/(?<=\\\\w)([A-Z])/', '_\\\\1', $string) ?? '';\n        return mb_strtolower($value, 'utf-8');\n    }\n\n    /**\n     * Checks if a given string is a Uniform Resource Locator (URL).\n     *\n     * On seriously malformed URLs, parse_url may return FALSE and emit an\n     * E_WARNING.\n     *\n     * filter_var() requires a scheme to be present.\n     *\n     * http://www.faqs.org/rfcs/rfc2396.html\n     * Scheme names consist of a sequence of characters beginning with a\n     * lower case letter and followed by any combination of lower case letters,\n     * digits, plus (\"+\"), period (\".\"), or hyphen (\"-\").  For resiliency,\n     * programs interpreting URI should treat upper case letters as equivalent to\n     * lower case in scheme names (e.g., allow \"HTTP\" as well as \"http\").\n     * scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )\n     *\n     * Convert the domain part to punicode if it does not look like a regular\n     * domain name. Only the domain part because RFC3986 specifies the the rest of\n     * the url may not contain special characters:\n     * https://tools.ietf.org/html/rfc3986#appendix-A\n     *\n     * @param string $url The URL to be validated\n     * @return bool Whether the given URL is valid\n     */\n    public static function isValidUrl($url)\n    {\n        $parsedUrl = parse_url($url);\n        if (!$parsedUrl || !isset($parsedUrl['scheme'])) {\n            return false;\n        }\n        // HttpUtility::buildUrl() will always build urls with <scheme>://\n        // our original $url might only contain <scheme>: (e.g. mail:)\n        // so we convert that to the double-slashed version to ensure\n        // our check against the $recomposedUrl is proper\n        if (!str_starts_with($url, $parsedUrl['scheme'] . '://')) {\n            $url = str_replace($parsedUrl['scheme'] . ':', $parsedUrl['scheme'] . '://', $url);\n        }\n        $recomposedUrl = HttpUtility::buildUrl($parsedUrl);\n        if ($recomposedUrl !== $url) {\n            // The parse_url() had to modify characters, so the URL is invalid\n            return false;\n        }\n        if (isset($parsedUrl['host']) && !preg_match('/^[a-z0-9.\\\\-]*$/i', $parsedUrl['host'])) {\n            $host = idn_to_ascii($parsedUrl['host']);\n            if ($host === false) {\n                return false;\n            }\n            $parsedUrl['host'] = $host;\n        }\n        return filter_var(HttpUtility::buildUrl($parsedUrl), FILTER_VALIDATE_URL) !== false;\n    }\n\n    /*************************\n     *\n     * ARRAY FUNCTIONS\n     *\n     *************************/\n\n    /**\n     * Explodes a $string delimited by $delimiter and casts each item in the array to (int).\n     * Corresponds to \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::trimExplode(), but with conversion to integers for all values.\n     *\n     * @param string $delimiter Delimiter string to explode with\n     * @param string $string The string to explode\n     * @param bool $removeEmptyValues If set, all empty values (='') will NOT be set in output\n     * @param int $limit If positive, the result will contain a maximum of limit elements,\n     * @return int[] Exploded values, all converted to integers\n     */\n    public static function intExplode($delimiter, $string, $removeEmptyValues = false, $limit = 0)\n    {\n        $result = explode($delimiter, $string);\n        foreach ($result as $key => &$value) {\n            if ($removeEmptyValues && ($value === '' || trim($value) === '')) {\n                unset($result[$key]);\n            } else {\n                $value = (int)$value;\n            }\n        }\n        unset($value);\n        if ($limit !== 0) {\n            if ($limit < 0) {\n                $result = array_slice($result, 0, $limit);\n            } elseif (count($result) > $limit) {\n                $lastElements = array_slice($result, $limit - 1);\n                $result = array_slice($result, 0, $limit - 1);\n                $result[] = implode($delimiter, $lastElements);\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Reverse explode which explodes the string counting from behind.\n     *\n     * Note: The delimiter has to given in the reverse order as\n     *       it is occurring within the string.\n     *\n     * GeneralUtility::revExplode('[]', '[my][words][here]', 2)\n     *   ==> array('[my][words', 'here]')\n     *\n     * @param string $delimiter Delimiter string to explode with\n     * @param string $string The string to explode\n     * @param int $count Number of array entries\n     * @return string[] Exploded values\n     */\n    public static function revExplode($delimiter, $string, $count = 0)\n    {\n        // 2 is the (currently, as of 2014-02) most-used value for $count in the core, therefore we check it first\n        if ($count === 2) {\n            $position = strrpos($string, strrev($delimiter));\n            if ($position !== false) {\n                return [substr($string, 0, $position), substr($string, $position + strlen($delimiter))];\n            }\n            return [$string];\n        }\n        if ($count <= 1) {\n            return [$string];\n        }\n        $explodedValues = explode($delimiter, strrev($string), $count);\n        $explodedValues = array_map('strrev', $explodedValues);\n        return array_reverse($explodedValues);\n    }\n\n    /**\n     * Explodes a string and removes whitespace-only values.\n     *\n     * If $removeEmptyValues is set, then all values that contain only whitespace are removed.\n     *\n     * Each item will have leading and trailing whitespace removed. However, if the tail items are\n     * returned as a single array item, their internal whitespace will not be modified.\n     *\n     * @param string $delim Delimiter string to explode with\n     * @param string $string The string to explode\n     * @param bool $removeEmptyValues If set, all empty values will be removed in output\n     * @param int $limit If limit is set and positive, the returned array will contain a maximum of limit elements with\n     *                   the last element containing the rest of string. If the limit parameter is negative, all components\n     *                   except the last -limit are returned.\n     * @return string[] Exploded values\n     */\n    public static function trimExplode($delim, $string, $removeEmptyValues = false, $limit = 0): array\n    {\n        $result = explode($delim, (string)$string);\n        if ($removeEmptyValues) {\n            // Remove items that are just whitespace, but leave whitespace intact for the rest.\n            $result = array_values(array_filter($result, static fn ($item) => trim($item) !== ''));\n        }\n\n        if ($limit === 0) {\n            // Return everything.\n            return array_map('trim', $result);\n        }\n\n        if ($limit < 0) {\n            // Trim and return just the first $limit elements and ignore the rest.\n            return array_map('trim', array_slice($result, 0, $limit));\n        }\n\n        // Fold the last length - $limit elements into a single trailing item, then trim and return the result.\n        $tail = array_slice($result, $limit - 1);\n        $result = array_slice($result, 0, $limit - 1);\n        if ($tail) {\n            $result[] = implode($delim, $tail);\n        }\n        return array_map('trim', $result);\n    }\n\n    /**\n     * Implodes a multidim-array into GET-parameters (eg. &param[key][key2]=value2&param[key][key3]=value3)\n     *\n     * @param string $name Name prefix for entries. Set to blank if you wish none.\n     * @param array $theArray The (multidimensional) array to implode\n     * @param string $str (keep blank)\n     * @param bool $skipBlank If set, parameters which were blank strings would be removed.\n     * @param bool $rawurlencodeParamName If set, the param name itself (for example \"param[key][key2]\") would be rawurlencoded as well.\n     * @return string Imploded result, fx. &param[key][key2]=value2&param[key][key3]=value3\n     * @see explodeUrl2Array()\n     */\n    public static function implodeArrayForUrl($name, array $theArray, $str = '', $skipBlank = false, $rawurlencodeParamName = false)\n    {\n        foreach ($theArray as $Akey => $AVal) {\n            $thisKeyName = $name ? $name . '[' . $Akey . ']' : $Akey;\n            if (is_array($AVal)) {\n                $str = self::implodeArrayForUrl($thisKeyName, $AVal, $str, $skipBlank, $rawurlencodeParamName);\n            } else {\n                $stringValue = (string)$AVal;\n                if (!$skipBlank || $stringValue !== '') {\n                    $parameterName = $rawurlencodeParamName ? rawurlencode($thisKeyName) : $thisKeyName;\n                    $parameterValue = rawurlencode($stringValue);\n                    $str .= '&' . $parameterName . '=' . $parameterValue;\n                }\n            }\n        }\n        return $str;\n    }\n\n    /**\n     * Explodes a string with GETvars (eg. \"&id=1&type=2&ext[mykey]=3\") into an array.\n     *\n     * Note! If you want to use a multi-dimensional string, consider this plain simple PHP code instead:\n     *\n     * $result = [];\n     * parse_str($queryParametersAsString, $result);\n     *\n     * However, if you do magic with a flat structure (e.g. keeping \"ext[mykey]\" as flat key in a one-dimensional array)\n     * then this method is for you.\n     *\n     * @param string $string GETvars string\n     * @return array<string, string> Array of values. All values AND keys are rawurldecoded() as they properly should be. But this means that any implosion of the array again must rawurlencode it!\n     * @see implodeArrayForUrl()\n     */\n    public static function explodeUrl2Array($string)\n    {\n        $output = [];\n        $p = explode('&', $string);\n        foreach ($p as $v) {\n            if ($v !== '') {\n                $nameAndValue = explode('=', $v, 2);\n                $output[rawurldecode($nameAndValue[0])] = isset($nameAndValue[1]) ? rawurldecode($nameAndValue[1]) : '';\n            }\n        }\n        return $output;\n    }\n\n    /**\n     * Removes dots \".\" from end of a key identifier of TypoScript styled array.\n     * array('key.' => array('property.' => 'value')) --> array('key' => array('property' => 'value'))\n     *\n     * @param array $ts TypoScript configuration array\n     * @return array TypoScript configuration array without dots at the end of all keys\n     */\n    public static function removeDotsFromTS(array $ts): array\n    {\n        $out = [];\n        foreach ($ts as $key => $value) {\n            if (is_array($value)) {\n                $key = rtrim($key, '.');\n                $out[$key] = self::removeDotsFromTS($value);\n            } else {\n                $out[$key] = $value;\n            }\n        }\n        return $out;\n    }\n\n    /*************************\n     *\n     * HTML/XML PROCESSING\n     *\n     *************************/\n    /**\n     * Returns an array with all attributes of the input HTML tag as key/value pairs. Attributes are only lowercase a-z\n     * $tag is either a whole tag (eg '<TAG OPTION ATTRIB=VALUE>') or the parameter list (ex ' OPTION ATTRIB=VALUE>')\n     * If an attribute is empty, then the value for the key is empty. You can check if it existed with isset()\n     *\n     * @param string $tag HTML-tag string (or attributes only)\n     * @param bool $decodeEntities Whether to decode HTML entities\n     * @return array<string, string> Array with the attribute values.\n     */\n    public static function get_tag_attributes($tag, bool $decodeEntities = false)\n    {\n        $components = self::split_tag_attributes($tag);\n        // Attribute name is stored here\n        $name = '';\n        $valuemode = false;\n        $attributes = [];\n        foreach ($components as $key => $val) {\n            // Only if $name is set (if there is an attribute, that waits for a value), that valuemode is enabled. This ensures that the attribute is assigned it's value\n            if ($val !== '=') {\n                if ($valuemode) {\n                    if ($name) {\n                        $attributes[$name] = $decodeEntities ? htmlspecialchars_decode($val) : $val;\n                        $name = '';\n                    }\n                } else {\n                    if ($key = strtolower(preg_replace('/[^[:alnum:]_\\\\:\\\\-]/', '', $val) ?? '')) {\n                        $attributes[$key] = '';\n                        $name = $key;\n                    }\n                }\n                $valuemode = false;\n            } else {\n                $valuemode = true;\n            }\n        }\n        return $attributes;\n    }\n\n    /**\n     * Returns an array with the 'components' from an attribute list from an HTML tag. The result is normally analyzed by get_tag_attributes\n     * Removes tag-name if found\n     *\n     * @param string $tag HTML-tag string (or attributes only)\n     * @return string[] Array with the attribute values.\n     */\n    public static function split_tag_attributes($tag)\n    {\n        $tag_tmp = trim(preg_replace('/^<[^[:space:]]*/', '', trim($tag)) ?? '');\n        // Removes any > in the end of the string\n        $tag_tmp = trim(rtrim($tag_tmp, '>'));\n        $value = [];\n        // Compared with empty string instead , 030102\n        while ($tag_tmp !== '') {\n            $firstChar = $tag_tmp[0];\n            if ($firstChar === '\"' || $firstChar === '\\'') {\n                $reg = explode($firstChar, $tag_tmp, 3);\n                $value[] = $reg[1];\n                $tag_tmp = trim($reg[2]);\n            } elseif ($firstChar === '=') {\n                $value[] = '=';\n                // Removes = chars.\n                $tag_tmp = trim(substr($tag_tmp, 1));\n            } else {\n                // There are '' around the value. We look for the next ' ' or '>'\n                $reg = preg_split('/[[:space:]=]/', $tag_tmp, 2);\n                $value[] = trim($reg[0]);\n                $tag_tmp = trim(substr($tag_tmp, strlen($reg[0]), 1) . ($reg[1] ?? ''));\n            }\n        }\n        reset($value);\n        return $value;\n    }\n\n    /**\n     * Implodes attributes in the array $arr for an attribute list in eg. and HTML tag (with quotes)\n     *\n     * @param array<string, string> $arr Array with attribute key/value pairs, eg. \"bgcolor\" => \"red\", \"border\" => \"0\"\n     * @param bool $xhtmlSafe If set the resulting attribute list will have a) all attributes in lowercase (and duplicates weeded out, first entry taking precedence) and b) all values htmlspecialchar()'ed. It is recommended to use this switch!\n     * @param bool $keepBlankAttributes If TRUE, don't check if values are blank. Default is to omit attributes with blank values.\n     * @return string Imploded attributes, eg. 'bgcolor=\"red\" border=\"0\"'\n     */\n    public static function implodeAttributes(array $arr, $xhtmlSafe = false, $keepBlankAttributes = false)\n    {\n        if ($xhtmlSafe) {\n            $newArr = [];\n            foreach ($arr as $attributeName => $attributeValue) {\n                $attributeName = strtolower($attributeName);\n                if (!isset($newArr[$attributeName])) {\n                    $newArr[$attributeName] = htmlspecialchars((string)$attributeValue);\n                }\n            }\n            $arr = $newArr;\n        }\n        $list = [];\n        foreach ($arr as $attributeName => $attributeValue) {\n            if ((string)$attributeValue !== '' || $keepBlankAttributes) {\n                $list[] = $attributeName . '=\"' . $attributeValue . '\"';\n            }\n        }\n        return implode(' ', $list);\n    }\n\n    /**\n     * Wraps JavaScript code XHTML ready with <script>-tags\n     * Automatic re-indenting of the JS code is done by using the first line as indent reference.\n     * This is nice for indenting JS code with PHP code on the same level.\n     *\n     * @param string $string JavaScript code\n     * @return string The wrapped JS code, ready to put into a XHTML page\n     */\n    public static function wrapJS($string)\n    {\n        if (trim($string)) {\n            // remove nl from the beginning\n            $string = ltrim($string, LF);\n            // re-ident to one tab using the first line as reference\n            $match = [];\n            if (preg_match('/^(\\\\t+)/', $string, $match)) {\n                $string = str_replace($match[1], \"\\t\", $string);\n            }\n            return '<script>\n/*<![CDATA[*/\n' . $string . '\n/*]]>*/\n</script>';\n        }\n        return '';\n    }\n\n    /**\n     * Parses XML input into a PHP array with associative keys\n     *\n     * @param string $string XML data input\n     * @param int $depth Number of element levels to resolve the XML into an array. Any further structure will be set as XML.\n     * @param array $parserOptions Options that will be passed to PHP's xml_parser_set_option()\n     * @return mixed The array with the parsed structure unless the XML parser returns with an error in which case the error message string is returned.\n     */\n    public static function xml2tree($string, $depth = 999, $parserOptions = [])\n    {\n        $parser = xml_parser_create();\n        $vals = [];\n        $index = [];\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 0);\n        foreach ($parserOptions as $option => $value) {\n            xml_parser_set_option($parser, $option, $value);\n        }\n        xml_parse_into_struct($parser, $string, $vals, $index);\n        if (xml_get_error_code($parser)) {\n            return 'Line ' . xml_get_current_line_number($parser) . ': ' . xml_error_string(xml_get_error_code($parser));\n        }\n        xml_parser_free($parser);\n        $stack = [[]];\n        $stacktop = 0;\n        $startPoint = 0;\n        $tagi = [];\n        foreach ($vals as $key => $val) {\n            $type = $val['type'];\n            // open tag:\n            if ($type === 'open' || $type === 'complete') {\n                $stack[$stacktop++] = $tagi;\n                if ($depth == $stacktop) {\n                    $startPoint = $key;\n                }\n                $tagi = ['tag' => $val['tag']];\n                if (isset($val['attributes'])) {\n                    $tagi['attrs'] = $val['attributes'];\n                }\n                if (isset($val['value'])) {\n                    $tagi['values'][] = $val['value'];\n                }\n            }\n            // finish tag:\n            if ($type === 'complete' || $type === 'close') {\n                $oldtagi = $tagi;\n                $tagi = $stack[--$stacktop];\n                $oldtag = $oldtagi['tag'];\n                unset($oldtagi['tag']);\n                if ($depth == $stacktop + 1) {\n                    if ($key - $startPoint > 0) {\n                        $partArray = array_slice($vals, $startPoint + 1, $key - $startPoint - 1);\n                        $oldtagi['XMLvalue'] = self::xmlRecompileFromStructValArray($partArray);\n                    } else {\n                        $oldtagi['XMLvalue'] = $oldtagi['values'][0];\n                    }\n                }\n                $tagi['ch'][$oldtag][] = $oldtagi;\n                unset($oldtagi);\n            }\n            // cdata\n            if ($type === 'cdata') {\n                $tagi['values'][] = $val['value'];\n            }\n        }\n        return $tagi['ch'];\n    }\n\n    /**\n     * Converts a PHP array into an XML string.\n     * The XML output is optimized for readability since associative keys are used as tag names.\n     * This also means that only alphanumeric characters are allowed in the tag names AND only keys NOT starting with numbers (so watch your usage of keys!). However there are options you can set to avoid this problem.\n     * Numeric keys are stored with the default tag name \"numIndex\" but can be overridden to other formats)\n     * The function handles input values from the PHP array in a binary-safe way; All characters below 32 (except 9,10,13) will trigger the content to be converted to a base64-string\n     * The PHP variable type of the data IS preserved as long as the types are strings, arrays, integers and booleans. Strings are the default type unless the \"type\" attribute is set.\n     * The output XML has been tested with the PHP XML-parser and parses OK under all tested circumstances with 4.x versions. However, with PHP5 there seems to be the need to add an XML prologue a la <?xml version=\"1.0\" encoding=\"[charset]\" standalone=\"yes\" ?> - otherwise UTF-8 is assumed! Unfortunately, many times the output from this function is used without adding that prologue meaning that non-ASCII characters will break the parsing!! This sucks of course! Effectively it means that the prologue should always be prepended setting the right characterset, alternatively the system should always run as utf-8!\n     * However using MSIE to read the XML output didn't always go well: One reason could be that the character encoding is not observed in the PHP data. The other reason may be if the tag-names are invalid in the eyes of MSIE. Also using the namespace feature will make MSIE break parsing. There might be more reasons...\n     *\n     * @param array $array The input PHP array with any kind of data; text, binary, integers. Not objects though.\n     * @param string $NSprefix tag-prefix, eg. a namespace prefix like \"T3:\"\n     * @param int $level Current recursion level. Don't change, stay at zero!\n     * @param string $docTag Alternative document tag. Default is \"phparray\".\n     * @param int $spaceInd If greater than zero, then the number of spaces corresponding to this number is used for indenting, if less than zero - no indentation, if zero - a single TAB is used\n     * @param array $options Options for the compilation. Key \"useNindex\" => 0/1 (boolean: whether to use \"n0, n1, n2\" for num. indexes); Key \"useIndexTagForNum\" => \"[tag for numerical indexes]\"; Key \"useIndexTagForAssoc\" => \"[tag for associative indexes\"; Key \"parentTagMap\" => array('parentTag' => 'thisLevelTag')\n     * @param array $stackData Stack data. Don't touch.\n     * @return string An XML string made from the input content in the array.\n     * @see xml2array()\n     */\n    public static function array2xml(array $array, $NSprefix = '', $level = 0, $docTag = 'phparray', $spaceInd = 0, array $options = [], array $stackData = [])\n    {\n        // The list of byte values which will trigger binary-safe storage. If any value has one of these char values in it, it will be encoded in base64\n        $binaryChars = \"\\0\" . chr(1) . chr(2) . chr(3) . chr(4) . chr(5) . chr(6) . chr(7) . chr(8) . chr(11) . chr(12) . chr(14) . chr(15) . chr(16) . chr(17) . chr(18) . chr(19) . chr(20) . chr(21) . chr(22) . chr(23) . chr(24) . chr(25) . chr(26) . chr(27) . chr(28) . chr(29) . chr(30) . chr(31);\n        // Set indenting mode:\n        $indentChar = $spaceInd ? ' ' : \"\\t\";\n        $indentN = $spaceInd > 0 ? $spaceInd : 1;\n        $nl = $spaceInd >= 0 ? LF : '';\n        // Init output variable:\n        $output = '';\n        // Traverse the input array\n        foreach ($array as $k => $v) {\n            $attr = '';\n            $tagName = (string)$k;\n            // Construct the tag name.\n            // Use tag based on grand-parent + parent tag name\n            if (isset($stackData['grandParentTagName'], $stackData['parentTagName'], $options['grandParentTagMap'][$stackData['grandParentTagName'] . '/' . $stackData['parentTagName']])) {\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['grandParentTagMap'][$stackData['grandParentTagName'] . '/' . $stackData['parentTagName']];\n            } elseif (isset($stackData['parentTagName'], $options['parentTagMap'][$stackData['parentTagName'] . ':_IS_NUM']) && MathUtility::canBeInterpretedAsInteger($tagName)) {\n                // Use tag based on parent tag name + if current tag is numeric\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['parentTagMap'][$stackData['parentTagName'] . ':_IS_NUM'];\n            } elseif (isset($stackData['parentTagName'], $options['parentTagMap'][$stackData['parentTagName'] . ':' . $tagName])) {\n                // Use tag based on parent tag name + current tag\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['parentTagMap'][$stackData['parentTagName'] . ':' . $tagName];\n            } elseif (isset($stackData['parentTagName'], $options['parentTagMap'][$stackData['parentTagName']])) {\n                // Use tag based on parent tag name:\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = (string)$options['parentTagMap'][$stackData['parentTagName']];\n            } elseif (MathUtility::canBeInterpretedAsInteger($tagName)) {\n                // If integer...;\n                if ($options['useNindex'] ?? false) {\n                    // If numeric key, prefix \"n\"\n                    $tagName = 'n' . $tagName;\n                } else {\n                    // Use special tag for num. keys:\n                    $attr .= ' index=\"' . $tagName . '\"';\n                    $tagName = ($options['useIndexTagForNum'] ?? false) ?: 'numIndex';\n                }\n            } elseif (!empty($options['useIndexTagForAssoc'])) {\n                // Use tag for all associative keys:\n                $attr .= ' index=\"' . htmlspecialchars($tagName) . '\"';\n                $tagName = $options['useIndexTagForAssoc'];\n            }\n            // The tag name is cleaned up so only alphanumeric chars (plus - and _) are in there and not longer than 100 chars either.\n            $tagName = substr(preg_replace('/[^[:alnum:]_-]/', '', $tagName), 0, 100);\n            // If the value is an array then we will call this function recursively:\n            if (is_array($v)) {\n                // Sub elements:\n                if (isset($options['alt_options']) && ($options['alt_options'][($stackData['path'] ?? '') . '/' . $tagName] ?? false)) {\n                    $subOptions = $options['alt_options'][($stackData['path'] ?? '') . '/' . $tagName];\n                    $clearStackPath = (bool)($subOptions['clearStackPath'] ?? false);\n                } else {\n                    $subOptions = $options;\n                    $clearStackPath = false;\n                }\n                if (empty($v)) {\n                    $content = '';\n                } else {\n                    $content = $nl . self::array2xml($v, $NSprefix, $level + 1, '', $spaceInd, $subOptions, [\n                            'parentTagName' => $tagName,\n                            'grandParentTagName' => $stackData['parentTagName'] ?? '',\n                            'path' => $clearStackPath ? '' : ($stackData['path'] ?? '') . '/' . $tagName,\n                        ]) . ($spaceInd >= 0 ? str_pad('', ($level + 1) * $indentN, $indentChar) : '');\n                }\n                // Do not set \"type = array\". Makes prettier XML but means that empty arrays are not restored with xml2array\n                if (!isset($options['disableTypeAttrib']) || (int)$options['disableTypeAttrib'] != 2) {\n                    $attr .= ' type=\"array\"';\n                }\n            } else {\n                $stringValue = (string)$v;\n                // Just a value:\n                // Look for binary chars:\n                $vLen = strlen($stringValue);\n                // Go for base64 encoding if the initial segment NOT matching any binary char has the same length as the whole string!\n                if ($vLen && strcspn($stringValue, $binaryChars) != $vLen) {\n                    // If the value contained binary chars then we base64-encode it and set an attribute to notify this situation:\n                    $content = $nl . chunk_split(base64_encode($stringValue));\n                    $attr .= ' base64=\"1\"';\n                } else {\n                    // Otherwise, just htmlspecialchar the stuff:\n                    $content = htmlspecialchars($stringValue);\n                    $dType = gettype($v);\n                    if ($dType === 'string') {\n                        if (isset($options['useCDATA']) && $options['useCDATA'] && $content != $stringValue) {\n                            $content = '<![CDATA[' . $stringValue . ']]>';\n                        }\n                    } elseif (!($options['disableTypeAttrib'] ?? false)) {\n                        $attr .= ' type=\"' . $dType . '\"';\n                    }\n                }\n            }\n            if ($tagName !== '') {\n                // Add the element to the output string:\n                $output .= ($spaceInd >= 0 ? str_pad('', ($level + 1) * $indentN, $indentChar) : '')\n                    . '<' . $NSprefix . $tagName . $attr . '>' . $content . '</' . $NSprefix . $tagName . '>' . $nl;\n            }\n        }\n        // If we are at the outer-most level, then we finally wrap it all in the document tags and return that as the value:\n        if (!$level) {\n            $output = '<' . $docTag . '>' . $nl . $output . '</' . $docTag . '>';\n        }\n        return $output;\n    }\n\n    /**\n     * Converts an XML string to a PHP array.\n     * This is the reverse function of array2xml()\n     * This is a wrapper for xml2arrayProcess that adds a two-level cache\n     *\n     * @param string $string XML content to convert into an array\n     * @param string $NSprefix The tag-prefix resolve, eg. a namespace like \"T3:\"\n     * @param bool $reportDocTag If set, the document tag will be set in the key \"_DOCUMENT_TAG\" of the output array\n     * @return mixed If the parsing had errors, a string with the error message is returned. Otherwise an array with the content.\n     * @see array2xml()\n     * @see xml2arrayProcess()\n     */\n    public static function xml2array($string, $NSprefix = '', $reportDocTag = false)\n    {\n        $runtimeCache = static::makeInstance(CacheManager::class)->getCache('runtime');\n        $firstLevelCache = $runtimeCache->get('generalUtilityXml2Array') ?: [];\n        $identifier = md5($string . $NSprefix . ($reportDocTag ? '1' : '0'));\n        // Look up in first level cache\n        if (empty($firstLevelCache[$identifier])) {\n            $firstLevelCache[$identifier] = self::xml2arrayProcess($string, $NSprefix, $reportDocTag);\n            $runtimeCache->set('generalUtilityXml2Array', $firstLevelCache);\n        }\n        return $firstLevelCache[$identifier];\n    }\n\n    /**\n     * Converts an XML string to a PHP array.\n     * This is the reverse function of array2xml()\n     *\n     * @param string $string XML content to convert into an array\n     * @param string $NSprefix The tag-prefix resolve, eg. a namespace like \"T3:\"\n     * @param bool $reportDocTag If set, the document tag will be set in the key \"_DOCUMENT_TAG\" of the output array\n     * @return mixed If the parsing had errors, a string with the error message is returned. Otherwise an array with the content.\n     * @see array2xml()\n     */\n    public static function xml2arrayProcess($string, $NSprefix = '', $reportDocTag = false)\n    {\n        $string = trim((string)$string);\n        // Create parser:\n        $parser = xml_parser_create();\n        $vals = [];\n        $index = [];\n        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n        xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 0);\n        // Default output charset is UTF-8, only ASCII, ISO-8859-1 and UTF-8 are supported!!!\n        $match = [];\n        preg_match('/^[[:space:]]*<\\\\?xml[^>]*encoding[[:space:]]*=[[:space:]]*\"([^\"]*)\"/', substr($string, 0, 200), $match);\n        $theCharset = $match[1] ?? 'utf-8';\n        // us-ascii / utf-8 / iso-8859-1\n        xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING, $theCharset);\n        // Parse content:\n        xml_parse_into_struct($parser, $string, $vals, $index);\n        // If error, return error message:\n        if (xml_get_error_code($parser)) {\n            return 'Line ' . xml_get_current_line_number($parser) . ': ' . xml_error_string(xml_get_error_code($parser));\n        }\n        xml_parser_free($parser);\n        // Init vars:\n        $stack = [[]];\n        $stacktop = 0;\n        $current = [];\n        $tagName = '';\n        $documentTag = '';\n        // Traverse the parsed XML structure:\n        foreach ($vals as $key => $val) {\n            // First, process the tag-name (which is used in both cases, whether \"complete\" or \"close\")\n            $tagName = $val['tag'];\n            if (!$documentTag) {\n                $documentTag = $tagName;\n            }\n            // Test for name space:\n            $tagName = $NSprefix && str_starts_with($tagName, $NSprefix) ? substr($tagName, strlen($NSprefix)) : $tagName;\n            // Test for numeric tag, encoded on the form \"nXXX\":\n            $testNtag = substr($tagName, 1);\n            // Closing tag.\n            $tagName = $tagName[0] === 'n' && MathUtility::canBeInterpretedAsInteger($testNtag) ? (int)$testNtag : $tagName;\n            // Test for alternative index value:\n            if ((string)($val['attributes']['index'] ?? '') !== '') {\n                $tagName = $val['attributes']['index'];\n            }\n            // Setting tag-values, manage stack:\n            switch ($val['type']) {\n                case 'open':\n                    // If open tag it means there is an array stored in sub-elements. Therefore increase the stackpointer and reset the accumulation array:\n                    // Setting blank place holder\n                    $current[$tagName] = [];\n                    $stack[$stacktop++] = $current;\n                    $current = [];\n                    break;\n                case 'close':\n                    // If the tag is \"close\" then it is an array which is closing and we decrease the stack pointer.\n                    $oldCurrent = $current;\n                    $current = $stack[--$stacktop];\n                    // Going to the end of array to get placeholder key, key($current), and fill in array next:\n                    end($current);\n                    $current[key($current)] = $oldCurrent;\n                    unset($oldCurrent);\n                    break;\n                case 'complete':\n                    // If \"complete\", then it's a value. If the attribute \"base64\" is set, then decode the value, otherwise just set it.\n                    if (!empty($val['attributes']['base64'])) {\n                        $current[$tagName] = base64_decode($val['value']);\n                    } else {\n                        // Had to cast it as a string - otherwise it would be evaluate FALSE if tested with isset()!!\n                        $current[$tagName] = (string)($val['value'] ?? '');\n                        // Cast type:\n                        switch ((string)($val['attributes']['type'] ?? '')) {\n                            case 'integer':\n                                $current[$tagName] = (int)$current[$tagName];\n                                break;\n                            case 'double':\n                                $current[$tagName] = (float)$current[$tagName];\n                                break;\n                            case 'boolean':\n                                $current[$tagName] = (bool)$current[$tagName];\n                                break;\n                            case 'NULL':\n                                $current[$tagName] = null;\n                                break;\n                            case 'array':\n                                // MUST be an empty array since it is processed as a value; Empty arrays would end up here because they would have no tags inside...\n                                $current[$tagName] = [];\n                                break;\n                        }\n                    }\n                    break;\n            }\n        }\n        if ($reportDocTag) {\n            $current[$tagName]['_DOCUMENT_TAG'] = $documentTag;\n        }\n        // Finally return the content of the document tag.\n        return $current[$tagName];\n    }\n\n    /**\n     * This implodes an array of XML parts (made with xml_parse_into_struct()) into XML again.\n     *\n     * @param array<int, array<string, mixed>> $vals An array of XML parts, see xml2tree\n     * @return string Re-compiled XML data.\n     */\n    public static function xmlRecompileFromStructValArray(array $vals)\n    {\n        $XMLcontent = '';\n        foreach ($vals as $val) {\n            $type = $val['type'];\n            // Open tag:\n            if ($type === 'open' || $type === 'complete') {\n                $XMLcontent .= '<' . $val['tag'];\n                if (isset($val['attributes'])) {\n                    foreach ($val['attributes'] as $k => $v) {\n                        $XMLcontent .= ' ' . $k . '=\"' . htmlspecialchars($v) . '\"';\n                    }\n                }\n                if ($type === 'complete') {\n                    if (isset($val['value'])) {\n                        $XMLcontent .= '>' . htmlspecialchars($val['value']) . '</' . $val['tag'] . '>';\n                    } else {\n                        $XMLcontent .= '/>';\n                    }\n                } else {\n                    $XMLcontent .= '>';\n                }\n                if ($type === 'open' && isset($val['value'])) {\n                    $XMLcontent .= htmlspecialchars($val['value']);\n                }\n            }\n            // Finish tag:\n            if ($type === 'close') {\n                $XMLcontent .= '</' . $val['tag'] . '>';\n            }\n            // Cdata\n            if ($type === 'cdata') {\n                $XMLcontent .= htmlspecialchars($val['value']);\n            }\n        }\n        return $XMLcontent;\n    }\n\n    /*************************\n     *\n     * FILES FUNCTIONS\n     *\n     *************************/\n    /**\n     * Reads the file or url $url and returns the content\n     * If you are having trouble with proxies when reading URLs you can configure your way out of that with settings within $GLOBALS['TYPO3_CONF_VARS']['HTTP'].\n     *\n     * @param string $url File/URL to read\n     * @return string|false The content from the resource given as input. FALSE if an error has occurred.\n     */\n    public static function getUrl($url)\n    {\n        // Looks like it's an external file, use Guzzle by default\n        if (preg_match('/^(?:http|ftp)s?|s(?:ftp|cp):/', $url)) {\n            $requestFactory = static::makeInstance(RequestFactory::class);\n            try {\n                $response = $requestFactory->request($url);\n            } catch (RequestException $exception) {\n                return false;\n            }\n            $content = $response->getBody()->getContents();\n        } else {\n            $content = @file_get_contents($url);\n        }\n        return $content;\n    }\n\n    /**\n     * Writes $content to the file $file\n     *\n     * @param string $file Filepath to write to\n     * @param string $content Content to write\n     * @param bool $changePermissions If TRUE, permissions are forced to be set\n     * @return bool TRUE if the file was successfully opened and written to.\n     */\n    public static function writeFile($file, $content, $changePermissions = false)\n    {\n        if (!@is_file($file)) {\n            $changePermissions = true;\n        }\n        if ($fd = fopen($file, 'wb')) {\n            $res = fwrite($fd, $content);\n            fclose($fd);\n            if ($res === false) {\n                return false;\n            }\n            // Change the permissions only if the file has just been created\n            if ($changePermissions) {\n                static::fixPermissions($file);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets the file system mode and group ownership of a file or a folder.\n     *\n     * @param string $path Path of file or folder, must not be escaped. Path can be absolute or relative\n     * @param bool $recursive If set, also fixes permissions of files and folders in the folder (if $path is a folder)\n     * @return mixed TRUE on success, FALSE on error, always TRUE on Windows OS\n     */\n    public static function fixPermissions($path, $recursive = false)\n    {\n        $targetPermissions = null;\n        if (Environment::isWindows()) {\n            return true;\n        }\n        $result = false;\n        // Make path absolute\n        if (!PathUtility::isAbsolutePath($path)) {\n            $path = static::getFileAbsFileName($path);\n        }\n        if (static::isAllowedAbsPath($path)) {\n            if (@is_file($path)) {\n                $targetPermissions = (string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['fileCreateMask'] ?? '0644');\n            } elseif (@is_dir($path)) {\n                $targetPermissions = (string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask'] ?? '0755');\n            }\n            if (!empty($targetPermissions)) {\n                // make sure it's always 4 digits\n                $targetPermissions = str_pad($targetPermissions, 4, '0', STR_PAD_LEFT);\n                $targetPermissions = octdec($targetPermissions);\n                // \"@\" is there because file is not necessarily OWNED by the user\n                $result = @chmod($path, (int)$targetPermissions);\n            }\n            // Set createGroup if not empty\n            if (\n                isset($GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup'])\n                && $GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup'] !== ''\n            ) {\n                // \"@\" is there because file is not necessarily OWNED by the user\n                $changeGroupResult = @chgrp($path, $GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup']);\n                $result = $changeGroupResult ? $result : false;\n            }\n            // Call recursive if recursive flag if set and $path is directory\n            if ($recursive && @is_dir($path)) {\n                $handle = opendir($path);\n                if (is_resource($handle)) {\n                    while (($file = readdir($handle)) !== false) {\n                        $recursionResult = null;\n                        if ($file !== '.' && $file !== '..') {\n                            if (@is_file($path . '/' . $file)) {\n                                $recursionResult = static::fixPermissions($path . '/' . $file);\n                            } elseif (@is_dir($path . '/' . $file)) {\n                                $recursionResult = static::fixPermissions($path . '/' . $file, true);\n                            }\n                            if (isset($recursionResult) && !$recursionResult) {\n                                $result = false;\n                            }\n                        }\n                    }\n                    closedir($handle);\n                }\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Writes $content to a filename in the typo3temp/ folder (and possibly one or two subfolders...)\n     * Accepts an additional subdirectory in the file path!\n     *\n     * @param string $filepath Absolute file path to write within the typo3temp/ or Environment::getVarPath() folder - the file path must be prefixed with this path\n     * @param string $content Content string to write\n     * @return string|null Returns NULL on success, otherwise an error string telling about the problem.\n     */\n    public static function writeFileToTypo3tempDir($filepath, $content)\n    {\n        // Parse filepath into directory and basename:\n        $fI = pathinfo($filepath);\n        $fI['dirname'] .= '/';\n        // Check parts:\n        if (!static::validPathStr($filepath) || !$fI['basename'] || strlen($fI['basename']) >= 60) {\n            return 'Input filepath \"' . $filepath . '\" was generally invalid!';\n        }\n\n        // Setting main temporary directory name (standard)\n        $allowedPathPrefixes = [\n            Environment::getPublicPath() . '/typo3temp' => 'Environment::getPublicPath() + \"/typo3temp/\"',\n        ];\n        // Also allow project-path + /var/\n        if (Environment::getVarPath() !== Environment::getPublicPath() . '/typo3temp/var') {\n            $relPath = substr(Environment::getVarPath(), strlen(Environment::getProjectPath()) + 1);\n            $allowedPathPrefixes[Environment::getVarPath()] = 'ProjectPath + ' . $relPath;\n        }\n\n        $errorMessage = null;\n        foreach ($allowedPathPrefixes as $pathPrefix => $prefixLabel) {\n            $dirName = $pathPrefix . '/';\n            // Invalid file path, let's check for the other path, if it exists\n            if (!str_starts_with($fI['dirname'], $dirName)) {\n                if ($errorMessage === null) {\n                    $errorMessage = '\"' . $fI['dirname'] . '\" was not within directory ' . $prefixLabel;\n                }\n                continue;\n            }\n            // This resets previous error messages from the first path\n            $errorMessage = null;\n\n            if (!@is_dir($dirName)) {\n                $errorMessage = $prefixLabel . ' was not a directory!';\n                // continue and see if the next iteration resets the errorMessage above\n                continue;\n            }\n            // Checking if the \"subdir\" is found\n            $subdir = substr($fI['dirname'], strlen($dirName));\n            if ($subdir) {\n                if (preg_match('#^(?:[[:alnum:]_]+/)+$#', $subdir)) {\n                    $dirName .= $subdir;\n                    if (!@is_dir($dirName)) {\n                        static::mkdir_deep($pathPrefix . '/' . $subdir);\n                    }\n                } else {\n                    $errorMessage = 'Subdir, \"' . $subdir . '\", was NOT on the form \"[[:alnum:]_]/+\"';\n                    break;\n                }\n            }\n            // Checking dir-name again (sub-dir might have been created)\n            if (@is_dir($dirName)) {\n                if ($filepath === $dirName . $fI['basename']) {\n                    static::writeFile($filepath, $content);\n                    if (!@is_file($filepath)) {\n                        $errorMessage = 'The file was not written to the disk. Please, check that you have write permissions to the ' . $prefixLabel . ' directory.';\n                    }\n                    break;\n                }\n                $errorMessage = 'Calculated file location didn\\'t match input \"' . $filepath . '\".';\n                break;\n            }\n            $errorMessage = '\"' . $dirName . '\" is not a directory!';\n            break;\n        }\n        return $errorMessage;\n    }\n\n    /**\n     * Wrapper function for mkdir.\n     * Sets folder permissions according to $GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask']\n     * and group ownership according to $GLOBALS['TYPO3_CONF_VARS']['SYS']['createGroup']\n     *\n     * @param string $newFolder Absolute path to folder, see PHP mkdir() function. Removes trailing slash internally.\n     * @return bool TRUE if operation was successful\n     */\n    public static function mkdir($newFolder)\n    {\n        $result = @mkdir($newFolder, (int)octdec((string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask'] ?? '0')));\n        if ($result) {\n            static::fixPermissions($newFolder);\n        }\n        return $result;\n    }\n\n    /**\n     * Creates a directory - including parent directories if necessary and\n     * sets permissions on newly created directories.\n     *\n     * @param string $directory Target directory to create\n     * @throws \\InvalidArgumentException If $directory is not a string\n     * @throws \\RuntimeException If directory could not be created\n     */\n    public static function mkdir_deep($directory)\n    {\n        if (!is_string($directory)) {\n            throw new \\InvalidArgumentException('The specified directory is of type \"' . gettype($directory) . '\" but a string is expected.', 1303662955);\n        }\n        // Ensure there is only one slash\n        $fullPath = rtrim($directory, '/') . '/';\n        if ($fullPath !== '/' && !is_dir($fullPath)) {\n            $firstCreatedPath = static::createDirectoryPath($fullPath);\n            if ($firstCreatedPath !== '') {\n                static::fixPermissions($firstCreatedPath, true);\n            }\n        }\n    }\n\n    /**\n     * Creates directories for the specified paths if they do not exist. This\n     * functions sets proper permission mask but does not set proper user and\n     * group.\n     *\n     * @static\n     * @param string $fullDirectoryPath\n     * @return string Path to the the first created directory in the hierarchy\n     * @see \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::mkdir_deep\n     * @throws \\RuntimeException If directory could not be created\n     */\n    protected static function createDirectoryPath($fullDirectoryPath)\n    {\n        $currentPath = $fullDirectoryPath;\n        $firstCreatedPath = '';\n        $permissionMask = (int)octdec((string)($GLOBALS['TYPO3_CONF_VARS']['SYS']['folderCreateMask'] ?? '0'));\n        if (!@is_dir($currentPath)) {\n            do {\n                $firstCreatedPath = $currentPath;\n                $separatorPosition = (int)strrpos($currentPath, DIRECTORY_SEPARATOR);\n                $currentPath = substr($currentPath, 0, $separatorPosition);\n            } while (!is_dir($currentPath) && $separatorPosition > 0);\n            $result = @mkdir($fullDirectoryPath, $permissionMask, true);\n            // Check existence of directory again to avoid race condition. Directory could have get created by another process between previous is_dir() and mkdir()\n            if (!$result && !@is_dir($fullDirectoryPath)) {\n                throw new \\RuntimeException('Could not create directory \"' . $fullDirectoryPath . '\"!', 1170251401);\n            }\n        }\n        return $firstCreatedPath;\n    }\n\n    /**\n     * Wrapper function for rmdir, allowing recursive deletion of folders and files\n     *\n     * @param string $path Absolute path to folder, see PHP rmdir() function. Removes trailing slash internally.\n     * @param bool $removeNonEmpty Allow deletion of non-empty directories\n     * @return bool TRUE if operation was successful\n     */\n    public static function rmdir($path, $removeNonEmpty = false)\n    {\n        $OK = false;\n        // Remove trailing slash\n        $path = preg_replace('|/$|', '', $path) ?? '';\n        $isWindows = DIRECTORY_SEPARATOR === '\\\\';\n        if (file_exists($path)) {\n            $OK = true;\n            if (!is_link($path) && is_dir($path)) {\n                if ($removeNonEmpty === true && ($handle = @opendir($path))) {\n                    $entries = [];\n\n                    while (false !== ($file = readdir($handle))) {\n                        if ($file === '.' || $file === '..') {\n                            continue;\n                        }\n\n                        $entries[] = $path . '/' . $file;\n                    }\n\n                    closedir($handle);\n\n                    foreach ($entries as $entry) {\n                        if (!static::rmdir($entry, $removeNonEmpty)) {\n                            $OK = false;\n                        }\n                    }\n                }\n                if ($OK) {\n                    $OK = @rmdir($path);\n                }\n            } elseif (is_link($path) && is_dir($path) && $isWindows) {\n                $OK = @rmdir($path);\n            } else {\n                // If $path is a file, simply remove it\n                $OK = @unlink($path);\n            }\n            clearstatcache();\n        } elseif (is_link($path)) {\n            $OK = @unlink($path);\n            if (!$OK && $isWindows) {\n                // Try to delete dead folder links on Windows systems\n                $OK = @rmdir($path);\n            }\n            clearstatcache();\n        }\n        return $OK;\n    }\n\n    /**\n     * Returns an array with the names of folders in a specific path\n     * Will return 'error' (string) if there were an error with reading directory content.\n     * Will return null if provided path is false.\n     *\n     * @param string $path Path to list directories from\n     * @return string[]|string|null Returns an array with the directory entries as values. If no path is provided, the return value will be null.\n     */\n    public static function get_dirs($path)\n    {\n        $dirs = null;\n        if ($path) {\n            if (is_dir($path)) {\n                $dir = scandir($path);\n                $dirs = [];\n                foreach ($dir as $entry) {\n                    if (is_dir($path . '/' . $entry) && $entry !== '..' && $entry !== '.') {\n                        $dirs[] = $entry;\n                    }\n                }\n            } else {\n                $dirs = 'error';\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Finds all files in a given path and returns them as an array. Each\n     * array key is a md5 hash of the full path to the file. This is done because\n     * 'some' extensions like the import/export extension depend on this.\n     *\n     * @param string $path The path to retrieve the files from.\n     * @param string $extensionList A comma-separated list of file extensions. Only files of the specified types will be retrieved. When left blank, files of any type will be retrieved.\n     * @param bool $prependPath If TRUE, the full path to the file is returned. If FALSE only the file name is returned.\n     * @param string $order The sorting order. The default sorting order is alphabetical. Setting $order to 'mtime' will sort the files by modification time.\n     * @param string $excludePattern A regular expression pattern of file names to exclude. For example: 'clear.gif' or '(clear.gif|.htaccess)'. The pattern will be wrapped with: '/^' and '$/'.\n     * @return array<string, string>|string Array of the files found, or an error message in case the path could not be opened.\n     */\n    public static function getFilesInDir($path, $extensionList = '', $prependPath = false, $order = '', $excludePattern = '')\n    {\n        $excludePattern = (string)$excludePattern;\n        $path = rtrim($path, '/');\n        if (!@is_dir($path)) {\n            return [];\n        }\n\n        $rawFileList = scandir($path);\n        if ($rawFileList === false) {\n            return 'error opening path: \"' . $path . '\"';\n        }\n\n        $pathPrefix = $path . '/';\n        $allowedFileExtensionArray = self::trimExplode(',', $extensionList);\n        $extensionList = ',' . str_replace(' ', '', $extensionList) . ',';\n        $files = [];\n        foreach ($rawFileList as $entry) {\n            $completePathToEntry = $pathPrefix . $entry;\n            if (!@is_file($completePathToEntry)) {\n                continue;\n            }\n\n            foreach ($allowedFileExtensionArray as $allowedFileExtension) {\n                if (\n                    ($extensionList === ',,' || stripos($extensionList, ',' . substr($entry, strlen($allowedFileExtension) * -1, strlen($allowedFileExtension)) . ',') !== false)\n                    && ($excludePattern === '' || !preg_match('/^' . $excludePattern . '$/', $entry))\n                ) {\n                    if ($order !== 'mtime') {\n                        $files[] = $entry;\n                    } else {\n                        // Store the value in the key so we can do a fast asort later.\n                        $files[$entry] = filemtime($completePathToEntry);\n                    }\n                }\n            }\n        }\n\n        $valueName = 'value';\n        if ($order === 'mtime') {\n            asort($files);\n            $valueName = 'key';\n        }\n\n        $valuePathPrefix = $prependPath ? $pathPrefix : '';\n        $foundFiles = [];\n        foreach ($files as $key => $value) {\n            // Don't change this ever - extensions may depend on the fact that the hash is an md5 of the path! (import/export extension)\n            $foundFiles[md5($pathPrefix . ${$valueName})] = $valuePathPrefix . ${$valueName};\n        }\n\n        return $foundFiles;\n    }\n\n    /**\n     * Recursively gather all files and folders of a path.\n     *\n     * @param string[] $fileArr Empty input array (will have files added to it)\n     * @param string $path The path to read recursively from (absolute) (include trailing slash!)\n     * @param string $extList Comma list of file extensions: Only files with extensions in this list (if applicable) will be selected.\n     * @param bool $regDirs If set, directories are also included in output.\n     * @param int $recursivityLevels The number of levels to dig down...\n     * @param string $excludePattern regex pattern of files/directories to exclude\n     * @return array<string, string> An array with the found files/directories.\n     */\n    public static function getAllFilesAndFoldersInPath(array $fileArr, $path, $extList = '', $regDirs = false, $recursivityLevels = 99, $excludePattern = '')\n    {\n        if ($regDirs) {\n            $fileArr[md5($path)] = $path;\n        }\n        $fileArr = array_merge($fileArr, (array)self::getFilesInDir($path, $extList, true, '', $excludePattern));\n        $dirs = self::get_dirs($path);\n        if ($recursivityLevels > 0 && is_array($dirs)) {\n            foreach ($dirs as $subdirs) {\n                if ((string)$subdirs !== '' && ($excludePattern === '' || !preg_match('/^' . $excludePattern . '$/', $subdirs))) {\n                    $fileArr = self::getAllFilesAndFoldersInPath($fileArr, $path . $subdirs . '/', $extList, $regDirs, $recursivityLevels - 1, $excludePattern);\n                }\n            }\n        }\n        return $fileArr;\n    }\n\n    /**\n     * Removes the absolute part of all files/folders in fileArr\n     *\n     * @param string[] $fileArr The file array to remove the prefix from\n     * @param string $prefixToRemove The prefix path to remove (if found as first part of string!)\n     * @return string[]|string The input $fileArr processed, or a string with an error message, when an error occurred.\n     */\n    public static function removePrefixPathFromList(array $fileArr, string $prefixToRemove)\n    {\n        foreach ($fileArr as &$absFileRef) {\n            if (str_starts_with($absFileRef, $prefixToRemove)) {\n                $absFileRef = substr($absFileRef, strlen($prefixToRemove));\n            } else {\n                return 'ERROR: One or more of the files was NOT prefixed with the prefix-path!';\n            }\n        }\n        unset($absFileRef);\n        return $fileArr;\n    }\n\n    /**\n     * Fixes a path for windows-backslashes and reduces double-slashes to single slashes\n     *\n     * @param string $theFile File path to process\n     * @return string\n     */\n    public static function fixWindowsFilePath($theFile)\n    {\n        return str_replace(['\\\\', '//'], '/', $theFile);\n    }\n\n    /**\n     * Resolves \"../\" sections in the input path string.\n     * For example \"fileadmin/directory/../other_directory/\" will be resolved to \"fileadmin/other_directory/\"\n     *\n     * @param string $pathStr File path in which \"/../\" is resolved\n     * @return string\n     */\n    public static function resolveBackPath($pathStr)\n    {\n        if (!str_contains($pathStr, '..')) {\n            return $pathStr;\n        }\n        $parts = explode('/', $pathStr);\n        $output = [];\n        $c = 0;\n        foreach ($parts as $part) {\n            if ($part === '..') {\n                if ($c) {\n                    array_pop($output);\n                    --$c;\n                } else {\n                    $output[] = $part;\n                }\n            } else {\n                ++$c;\n                $output[] = $part;\n            }\n        }\n        return implode('/', $output);\n    }\n\n    /**\n     * Prefixes a URL used with 'header-location' with 'http://...' depending on whether it has it already.\n     * - If already having a scheme, nothing is prepended\n     * - If having REQUEST_URI slash '/', then prefixing 'http://[host]' (relative to host)\n     * - Otherwise prefixed with TYPO3_REQUEST_DIR (relative to current dir / TYPO3_REQUEST_DIR)\n     *\n     * @param string $path URL / path to prepend full URL addressing to.\n     * @return ($path is non-empty-string ? non-empty-string : string)\n     */\n    public static function locationHeaderUrl($path)\n    {\n        if (str_starts_with($path, '//')) {\n            return $path;\n        }\n\n        // relative to HOST\n        if (str_starts_with($path, '/')) {\n            return self::getIndpEnv('TYPO3_REQUEST_HOST') . $path;\n        }\n\n        $urlComponents = parse_url($path);\n        if (!($urlComponents['scheme'] ?? false)) {\n            // No scheme either\n            return self::getIndpEnv('TYPO3_REQUEST_DIR') . $path;\n        }\n\n        return $path;\n    }\n\n    /**\n     * Returns the maximum upload size for a file that is allowed. Measured in KB.\n     * This might be handy to find out the real upload limit that is possible for this\n     * TYPO3 installation.\n     *\n     * @return int The maximum size of uploads that are allowed (measured in kilobytes)\n     */\n    public static function getMaxUploadFileSize()\n    {\n        $uploadMaxFilesize = (string)ini_get('upload_max_filesize');\n        $postMaxSize = (string)ini_get('post_max_size');\n        // Check for PHP restrictions of the maximum size of one of the $_FILES\n        $phpUploadLimit = self::getBytesFromSizeMeasurement($uploadMaxFilesize);\n        // Check for PHP restrictions of the maximum $_POST size\n        $phpPostLimit = self::getBytesFromSizeMeasurement($postMaxSize);\n        // If the total amount of post data is smaller (!) than the upload_max_filesize directive,\n        // then this is the real limit in PHP\n        $phpUploadLimit = $phpPostLimit > 0 && $phpPostLimit < $phpUploadLimit ? $phpPostLimit : $phpUploadLimit;\n        return floor($phpUploadLimit) / 1024;\n    }\n\n    /**\n     * Gets the bytes value from a measurement string like \"100k\".\n     *\n     * @param string $measurement The measurement (e.g. \"100k\")\n     * @return int The bytes value (e.g. 102400)\n     */\n    public static function getBytesFromSizeMeasurement($measurement)\n    {\n        $bytes = (float)$measurement;\n        if (stripos($measurement, 'G')) {\n            $bytes *= 1024 * 1024 * 1024;\n        } elseif (stripos($measurement, 'M')) {\n            $bytes *= 1024 * 1024;\n        } elseif (stripos($measurement, 'K')) {\n            $bytes *= 1024;\n        }\n        return (int)$bytes;\n    }\n\n    /**\n     * Function for static version numbers on files, based on the filemtime\n     *\n     * This will make the filename automatically change when a file is\n     * changed, and by that re-cached by the browser. If the file does not\n     * exist physically the original file passed to the function is\n     * returned without the timestamp.\n     *\n     * Behaviour is influenced by the setting\n     * TYPO3_CONF_VARS['BE' and 'FE'][versionNumberInFilename]\n     * = TRUE (BE) / \"embed\" (FE) : modify filename\n     * = FALSE (BE) / \"querystring\" (FE) : add timestamp as parameter\n     *\n     * @param string $file Relative path to file including all potential query parameters (not htmlspecialchared yet)\n     * @return string Relative path with version filename including the timestamp\n     */\n    public static function createVersionNumberedFilename($file)\n    {\n        $isFrontend = ($GLOBALS['TYPO3_REQUEST'] ?? null) instanceof ServerRequestInterface\n            && ApplicationType::fromRequest($GLOBALS['TYPO3_REQUEST'])->isFrontend();\n        $lookupFile = explode('?', $file);\n        $path = $lookupFile[0];\n\n        // @todo: in v12 this should be resolved by using Environment::getPublicPath() once\n        if ($isFrontend) {\n            // Frontend should still allow /static/myfile.css - see #98106\n            // This should happen regardless of the incoming path is absolute or not\n            $path = self::resolveBackPath(self::dirname(Environment::getCurrentScript()) . '/' . $path);\n        } elseif (!PathUtility::isAbsolutePath($path)) {\n            // Backend and non-absolute path\n            $path = self::resolveBackPath(self::dirname(Environment::getCurrentScript()) . '/' . $path);\n        }\n\n        $doNothing = false;\n\n        if ($isFrontend) {\n            $mode = strtolower($GLOBALS['TYPO3_CONF_VARS']['FE']['versionNumberInFilename']);\n            if ($mode === 'embed') {\n                $mode = true;\n            } else {\n                if ($mode === 'querystring') {\n                    $mode = false;\n                } else {\n                    $doNothing = true;\n                }\n            }\n        } else {\n            $mode = $GLOBALS['TYPO3_CONF_VARS']['BE']['versionNumberInFilename'];\n        }\n        try {\n            $fileExists = file_exists($path);\n        } catch (\\Throwable $e) {\n            $fileExists = false;\n        }\n        if ($doNothing || !$fileExists) {\n            // File not found, return filename unaltered\n            $fullName = $file;\n        } else {\n            if (!$mode) {\n                // If use of .htaccess rule is not configured,\n                // we use the default query-string method\n                if (!empty($lookupFile[1])) {\n                    $separator = '&';\n                } else {\n                    $separator = '?';\n                }\n                $fullName = $file . $separator . filemtime($path);\n            } else {\n                // Change the filename\n                $name = explode('.', $lookupFile[0]);\n                $extension = array_pop($name);\n                array_push($name, filemtime($path), $extension);\n                $fullName = implode('.', $name);\n                // Append potential query string\n                $fullName .= !empty($lookupFile[1]) ? '?' . $lookupFile[1] : '';\n            }\n        }\n        return $fullName;\n    }\n\n    /**\n     * Writes string to a temporary file named after the md5-hash of the string\n     * Quite useful for extensions adding their custom built JavaScript during runtime.\n     *\n     * @param string $content JavaScript to write to file.\n     * @return string filename to include in the <script> tag\n     */\n    public static function writeJavaScriptContentToTemporaryFile(string $content)\n    {\n        $script = 'typo3temp/assets/js/' . md5($content) . '.js';\n        if (!@is_file(Environment::getPublicPath() . '/' . $script)) {\n            self::writeFileToTypo3tempDir(Environment::getPublicPath() . '/' . $script, $content);\n        }\n        return $script;\n    }\n\n    /**\n     * Writes string to a temporary file named after the md5-hash of the string\n     * Quite useful for extensions adding their custom built StyleSheet during runtime.\n     *\n     * @param string $content CSS styles to write to file.\n     * @return string filename to include in the <link> tag\n     */\n    public static function writeStyleSheetContentToTemporaryFile(string $content)\n    {\n        $script = 'typo3temp/assets/css/' . md5($content) . '.css';\n        if (!@is_file(Environment::getPublicPath() . '/' . $script)) {\n            self::writeFileToTypo3tempDir(Environment::getPublicPath() . '/' . $script, $content);\n        }\n        return $script;\n    }\n\n    /*************************\n     *\n     * SYSTEM INFORMATION\n     *\n     *************************/\n\n    /**\n     * Returns the link-url to the current script.\n     * In $getParams you can set associative keys corresponding to the GET-vars you wish to add to the URL. If you set them empty, they will remove existing GET-vars from the current URL.\n     * REMEMBER to always use htmlspecialchars() for content in href-properties to get ampersands converted to entities (XHTML requirement and XSS precaution)\n     *\n     * @param array $getParams Array of GET parameters to include\n     * @return string\n     */\n    public static function linkThisScript(array $getParams = [])\n    {\n        $parts = self::getIndpEnv('SCRIPT_NAME');\n        $params = self::_GET();\n        foreach ($getParams as $key => $value) {\n            if ($value !== '') {\n                $params[$key] = $value;\n            } else {\n                unset($params[$key]);\n            }\n        }\n        $pString = self::implodeArrayForUrl('', $params);\n        return $pString ? $parts . '?' . ltrim($pString, '&') : $parts;\n    }\n\n    /**\n     * This method is only for testing and should never be used outside tests.\n     *\n     * @param non-empty-string $envName\n     * @param string|bool|array<string, string|bool|null>|null $value\n     * @internal\n     */\n    public static function setIndpEnv($envName, $value)\n    {\n        self::$indpEnvCache[$envName] = $value;\n    }\n\n    /**\n     * Abstraction method which returns System Environment Variables regardless of server OS, CGI/MODULE version etc. Basically this is SERVER variables for most of them.\n     * This should be used instead of getEnv() and $_SERVER/ENV_VARS to get reliable values for all situations.\n     *\n     * @param string $getEnvName Name of the \"environment variable\"/\"server variable\" you wish to use. Valid values are SCRIPT_NAME, SCRIPT_FILENAME, REQUEST_URI, PATH_INFO, REMOTE_ADDR, REMOTE_HOST, HTTP_REFERER, HTTP_HOST, HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, QUERY_STRING, TYPO3_DOCUMENT_ROOT, TYPO3_HOST_ONLY, TYPO3_HOST_ONLY, TYPO3_REQUEST_HOST, TYPO3_REQUEST_URL, TYPO3_REQUEST_SCRIPT, TYPO3_REQUEST_DIR, TYPO3_SITE_URL, _ARRAY\n     * @return string|bool|array<string, string|bool|null>|null Value based on the input key, independent of server/OS environment.\n     * @throws \\UnexpectedValueException\n     */\n    public static function getIndpEnv($getEnvName)\n    {\n        if (array_key_exists($getEnvName, self::$indpEnvCache)) {\n            return self::$indpEnvCache[$getEnvName];\n        }\n\n        /*\n        Conventions:\n        output from parse_url():\n        URL:\thttp://username:password@192.168.1.4:8080/typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/?arg1,arg2,arg3&p1=parameter1&p2[key]=value#link1\n        [scheme] => 'http'\n        [user] => 'username'\n        [pass] => 'password'\n        [host] => '192.168.1.4'\n        [port] => '8080'\n        [path] => '/typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/'\n        [query] => 'arg1,arg2,arg3&p1=parameter1&p2[key]=value'\n        [fragment] => 'link1'Further definition: [path_script] = '/typo3/32/temp/phpcheck/index.php'\n        [path_dir] = '/typo3/32/temp/phpcheck/'\n        [path_info] = '/arg1/arg2/arg3/'\n        [path] = [path_script/path_dir][path_info]Keys supported:URI______:\n        REQUEST_URI\t\t=\t[path]?[query]\t\t= /typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/?arg1,arg2,arg3&p1=parameter1&p2[key]=value\n        HTTP_HOST\t\t=\t[host][:[port]]\t\t= 192.168.1.4:8080\n        SCRIPT_NAME\t\t=\t[path_script]++\t\t= /typo3/32/temp/phpcheck/index.php\t\t// NOTICE THAT SCRIPT_NAME will return the php-script name ALSO. [path_script] may not do that (eg. '/somedir/' may result in SCRIPT_NAME '/somedir/index.php')!\n        PATH_INFO\t\t=\t[path_info]\t\t\t= /arg1/arg2/arg3/\n        QUERY_STRING\t=\t[query]\t\t\t\t= arg1,arg2,arg3&p1=parameter1&p2[key]=value\n        HTTP_REFERER\t=\t[scheme]://[host][:[port]][path]\t= http://192.168.1.4:8080/typo3/32/temp/phpcheck/index.php/arg1/arg2/arg3/?arg1,arg2,arg3&p1=parameter1&p2[key]=value\n        (Notice: NO username/password + NO fragment)CLIENT____:\n        REMOTE_ADDR\t\t=\t(client IP)\n        REMOTE_HOST\t\t=\t(client host)\n        HTTP_USER_AGENT\t=\t(client user agent)\n        HTTP_ACCEPT_LANGUAGE\t= (client accept language)SERVER____:\n        SCRIPT_FILENAME\t=\tAbsolute filename of script\t\t(Differs between windows/unix). On windows 'C:\\\\some\\\\path\\\\' will be converted to 'C:/some/path/'Special extras:\n        TYPO3_HOST_ONLY =\t\t[host] = 192.168.1.4\n        TYPO3_PORT =\t\t\t[port] = 8080 (blank if 80, taken from host value)\n        TYPO3_REQUEST_HOST = \t\t[scheme]://[host][:[port]]\n        TYPO3_REQUEST_URL =\t\t[scheme]://[host][:[port]][path]?[query] (scheme will by default be \"http\" until we can detect something different)\n        TYPO3_REQUEST_SCRIPT =  \t[scheme]://[host][:[port]][path_script]\n        TYPO3_REQUEST_DIR =\t\t[scheme]://[host][:[port]][path_dir]\n        TYPO3_SITE_URL = \t\t[scheme]://[host][:[port]][path_dir] of the TYPO3 website frontend\n        TYPO3_SITE_PATH = \t\t[path_dir] of the TYPO3 website frontend\n        TYPO3_SITE_SCRIPT = \t\t[script / Speaking URL] of the TYPO3 website\n        TYPO3_DOCUMENT_ROOT =\t\tAbsolute path of root of documents: TYPO3_DOCUMENT_ROOT.SCRIPT_NAME = SCRIPT_FILENAME (typically)\n        TYPO3_SSL = \t\t\tReturns TRUE if this session uses SSL/TLS (https)\n        TYPO3_PROXY = \t\t\tReturns TRUE if this session runs over a well known proxyNotice: [fragment] is apparently NEVER available to the script!Testing suggestions:\n        - Output all the values.\n        - In the script, make a link to the script it self, maybe add some parameters and click the link a few times so HTTP_REFERER is seen\n        - ALSO TRY the script from the ROOT of a site (like 'http://www.mytest.com/' and not 'http://www.mytest.com/test/' !!)\n         */\n        $retVal = '';\n        switch ((string)$getEnvName) {\n            case 'SCRIPT_NAME':\n                $retVal = $_SERVER['SCRIPT_NAME'] ?? '';\n                // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n                if (self::cmpIP($_SERVER['REMOTE_ADDR'] ?? '', $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'] ?? '')) {\n                    if (self::getIndpEnv('TYPO3_SSL') && $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL'] . $retVal;\n                    } elseif ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix'] . $retVal;\n                    }\n                }\n                $retVal = self::encodeFileSystemPathComponentForUrlPath($retVal);\n                break;\n            case 'SCRIPT_FILENAME':\n                $retVal = Environment::getCurrentScript();\n                break;\n            case 'REQUEST_URI':\n                // Typical application of REQUEST_URI is return urls, forms submitting to itself etc. Example: returnUrl='.rawurlencode(\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::getIndpEnv('REQUEST_URI'))\n                if (!empty($GLOBALS['TYPO3_CONF_VARS']['SYS']['requestURIvar'])) {\n                    // This is for URL rewriters that store the original URI in a server variable (eg ISAPI_Rewriter for IIS: HTTP_X_REWRITE_URL)\n                    [$v, $n] = explode('|', $GLOBALS['TYPO3_CONF_VARS']['SYS']['requestURIvar']);\n                    $retVal = $GLOBALS[$v][$n];\n                } elseif (empty($_SERVER['REQUEST_URI'])) {\n                    // This is for ISS/CGI which does not have the REQUEST_URI available.\n                    $retVal = '/' . ltrim(self::getIndpEnv('SCRIPT_NAME'), '/') . (!empty($_SERVER['QUERY_STRING']) ? '?' . $_SERVER['QUERY_STRING'] : '');\n                } else {\n                    $retVal = '/' . ltrim($_SERVER['REQUEST_URI'], '/');\n                }\n                // Add a prefix if TYPO3 is behind a proxy: ext-domain.com => int-server.com/prefix\n                if (isset($_SERVER['REMOTE_ADDR'], $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'])\n                    && self::cmpIP($_SERVER['REMOTE_ADDR'], $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'])\n                ) {\n                    if (self::getIndpEnv('TYPO3_SSL') && $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefixSSL'] . $retVal;\n                    } elseif ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix']) {\n                        $retVal = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyPrefix'] . $retVal;\n                    }\n                }\n                break;\n            case 'PATH_INFO':\n                $retVal = $_SERVER['PATH_INFO'] ?? '';\n                break;\n            case 'TYPO3_REV_PROXY':\n                $retVal = self::cmpIP($_SERVER['REMOTE_ADDR'] ?? '', $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP']);\n                break;\n            case 'REMOTE_ADDR':\n                $retVal = $_SERVER['REMOTE_ADDR'] ?? '';\n                if (self::cmpIP($retVal, $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'] ?? '')) {\n                    $ip = self::trimExplode(',', $_SERVER['HTTP_X_FORWARDED_FOR'] ?? '');\n                    // Choose which IP in list to use\n                    if (!empty($ip)) {\n                        switch ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyHeaderMultiValue']) {\n                            case 'last':\n                                $ip = array_pop($ip);\n                                break;\n                            case 'first':\n                                $ip = array_shift($ip);\n                                break;\n                            case 'none':\n\n                            default:\n                                $ip = '';\n                        }\n                    }\n                    if (self::validIP((string)$ip)) {\n                        $retVal = $ip;\n                    }\n                }\n                break;\n            case 'HTTP_HOST':\n                // if it is not set we're most likely on the cli\n                $retVal = $_SERVER['HTTP_HOST'] ?? '';\n                if (isset($_SERVER['REMOTE_ADDR']) && static::cmpIP($_SERVER['REMOTE_ADDR'], $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'])) {\n                    $host = self::trimExplode(',', $_SERVER['HTTP_X_FORWARDED_HOST'] ?? '');\n                    // Choose which host in list to use\n                    if (!empty($host)) {\n                        switch ($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyHeaderMultiValue']) {\n                            case 'last':\n                                $host = array_pop($host);\n                                break;\n                            case 'first':\n                                $host = array_shift($host);\n                                break;\n                            case 'none':\n\n                            default:\n                                $host = '';\n                        }\n                    }\n                    if ($host) {\n                        $retVal = $host;\n                    }\n                }\n                break;\n            case 'HTTP_REFERER':\n\n            case 'HTTP_USER_AGENT':\n\n            case 'HTTP_ACCEPT_ENCODING':\n\n            case 'HTTP_ACCEPT_LANGUAGE':\n\n            case 'REMOTE_HOST':\n\n            case 'QUERY_STRING':\n                $retVal = $_SERVER[$getEnvName] ?? '';\n                break;\n            case 'TYPO3_DOCUMENT_ROOT':\n                // Get the web root (it is not the root of the TYPO3 installation)\n                // The absolute path of the script can be calculated with TYPO3_DOCUMENT_ROOT + SCRIPT_FILENAME\n                // Some CGI-versions (LA13CGI) and mod-rewrite rules on MODULE versions will deliver a 'wrong' DOCUMENT_ROOT (according to our description). Further various aliases/mod_rewrite rules can disturb this as well.\n                // Therefore the DOCUMENT_ROOT is now always calculated as the SCRIPT_FILENAME minus the end part shared with SCRIPT_NAME.\n                $SFN = self::getIndpEnv('SCRIPT_FILENAME');\n                // Use rawurldecode to reverse the result of self::encodeFileSystemPathComponentForUrlPath()\n                // which has been applied to getIndpEnv(SCRIPT_NAME) for web URI usage.\n                // We compare with a file system path (SCRIPT_FILENAME) in here and therefore need to undo the encoding.\n                $SN_A = array_map('rawurldecode', explode('/', strrev(self::getIndpEnv('SCRIPT_NAME'))));\n                $SFN_A = explode('/', strrev($SFN));\n                $acc = [];\n                foreach ($SN_A as $kk => $vv) {\n                    if ((string)$SFN_A[$kk] === (string)$vv) {\n                        $acc[] = $vv;\n                    } else {\n                        break;\n                    }\n                }\n                $commonEnd = strrev(implode('/', $acc));\n                if ((string)$commonEnd !== '') {\n                    $retVal = substr($SFN, 0, -(strlen($commonEnd) + 1));\n                }\n                break;\n            case 'TYPO3_HOST_ONLY':\n                $httpHost = self::getIndpEnv('HTTP_HOST');\n                $httpHostBracketPosition = strpos($httpHost, ']');\n                $httpHostParts = explode(':', $httpHost);\n                $retVal = $httpHostBracketPosition !== false ? substr($httpHost, 0, $httpHostBracketPosition + 1) : array_shift($httpHostParts);\n                break;\n            case 'TYPO3_PORT':\n                $httpHost = self::getIndpEnv('HTTP_HOST');\n                $httpHostOnly = self::getIndpEnv('TYPO3_HOST_ONLY');\n                $retVal = strlen($httpHost) > strlen($httpHostOnly) ? substr($httpHost, strlen($httpHostOnly) + 1) : '';\n                break;\n            case 'TYPO3_REQUEST_HOST':\n                $retVal = (self::getIndpEnv('TYPO3_SSL') ? 'https://' : 'http://') . self::getIndpEnv('HTTP_HOST');\n                break;\n            case 'TYPO3_REQUEST_URL':\n                $retVal = self::getIndpEnv('TYPO3_REQUEST_HOST') . self::getIndpEnv('REQUEST_URI');\n                break;\n            case 'TYPO3_REQUEST_SCRIPT':\n                $retVal = self::getIndpEnv('TYPO3_REQUEST_HOST') . self::getIndpEnv('SCRIPT_NAME');\n                break;\n            case 'TYPO3_REQUEST_DIR':\n                $retVal = self::getIndpEnv('TYPO3_REQUEST_HOST') . self::dirname(self::getIndpEnv('SCRIPT_NAME')) . '/';\n                break;\n            case 'TYPO3_SITE_URL':\n                if (Environment::getCurrentScript()) {\n                    $lPath = PathUtility::stripPathSitePrefix(PathUtility::dirnameDuringBootstrap(Environment::getCurrentScript())) . '/';\n                    $url = self::getIndpEnv('TYPO3_REQUEST_DIR');\n                    $siteUrl = substr($url, 0, -strlen($lPath));\n                    if (substr($siteUrl, -1) !== '/') {\n                        $siteUrl .= '/';\n                    }\n                    $retVal = $siteUrl;\n                }\n                break;\n            case 'TYPO3_SITE_PATH':\n                $retVal = substr(self::getIndpEnv('TYPO3_SITE_URL'), strlen(self::getIndpEnv('TYPO3_REQUEST_HOST')));\n                break;\n            case 'TYPO3_SITE_SCRIPT':\n                $retVal = substr(self::getIndpEnv('TYPO3_REQUEST_URL'), strlen(self::getIndpEnv('TYPO3_SITE_URL')));\n                break;\n            case 'TYPO3_SSL':\n                $proxySSL = trim($GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxySSL'] ?? '');\n                if ($proxySSL === '*') {\n                    $proxySSL = $GLOBALS['TYPO3_CONF_VARS']['SYS']['reverseProxyIP'];\n                }\n                if (self::cmpIP($_SERVER['REMOTE_ADDR'] ?? '', $proxySSL)) {\n                    $retVal = true;\n                } else {\n                    $retVal = self::webserverUsesHttps();\n                }\n                break;\n            case '_ARRAY':\n                $out = [];\n                // Here, list ALL possible keys to this function for debug display.\n                $envTestVars = [\n                    'HTTP_HOST',\n                    'TYPO3_HOST_ONLY',\n                    'TYPO3_PORT',\n                    'PATH_INFO',\n                    'QUERY_STRING',\n                    'REQUEST_URI',\n                    'HTTP_REFERER',\n                    'TYPO3_REQUEST_HOST',\n                    'TYPO3_REQUEST_URL',\n                    'TYPO3_REQUEST_SCRIPT',\n                    'TYPO3_REQUEST_DIR',\n                    'TYPO3_SITE_URL',\n                    'TYPO3_SITE_SCRIPT',\n                    'TYPO3_SSL',\n                    'TYPO3_REV_PROXY',\n                    'SCRIPT_NAME',\n                    'TYPO3_DOCUMENT_ROOT',\n                    'SCRIPT_FILENAME',\n                    'REMOTE_ADDR',\n                    'REMOTE_HOST',\n                    'HTTP_USER_AGENT',\n                    'HTTP_ACCEPT_LANGUAGE',\n                ];\n                foreach ($envTestVars as $v) {\n                    $out[$v] = self::getIndpEnv($v);\n                }\n                reset($out);\n                $retVal = $out;\n                break;\n        }\n        self::$indpEnvCache[$getEnvName] = $retVal;\n        return $retVal;\n    }\n\n    /**\n     * Determine if the webserver uses HTTPS.\n     *\n     * HEADS UP: This does not check if the client performed a\n     * HTTPS request, as possible proxies are not taken into\n     * account. It provides raw information about the current\n     * webservers configuration only.\n     *\n     * @return bool\n     */\n    protected static function webserverUsesHttps()\n    {\n        if (!empty($_SERVER['SSL_SESSION_ID'])) {\n            return true;\n        }\n\n        // https://secure.php.net/manual/en/reserved.variables.server.php\n        // \"Set to a non-empty value if the script was queried through the HTTPS protocol.\"\n        return !empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off';\n    }\n\n    protected static function encodeFileSystemPathComponentForUrlPath(string $path): string\n    {\n        return implode('/', array_map('rawurlencode', explode('/', $path)));\n    }\n\n    /*************************\n     *\n     * TYPO3 SPECIFIC FUNCTIONS\n     *\n     *************************/\n    /**\n     * Returns the absolute filename of a relative reference, resolves the \"EXT:\" prefix\n     * (way of referring to files inside extensions) and checks that the file is inside\n     * the TYPO3's base folder and implies a check with\n     * \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::validPathStr().\n     *\n     * @param string $filename The input filename/filepath to evaluate\n     * @return string Returns the absolute filename of $filename if valid, otherwise blank string.\n     */\n    public static function getFileAbsFileName($filename)\n    {\n        if ((string)$filename === '') {\n            return '';\n        }\n        // Extension\n        if (PathUtility::isExtensionPath($filename)) {\n            try {\n                $filename = ExtensionManagementUtility::resolvePackagePath($filename);\n            } catch (PackageException $e) {\n                $filename = '';\n            }\n        } elseif (!PathUtility::isAbsolutePath($filename)) {\n            // is relative. Prepended with the public web folder\n            $filename = Environment::getPublicPath() . '/' . $filename;\n        } elseif (!(\n            str_starts_with($filename, Environment::getProjectPath())\n                  || str_starts_with($filename, Environment::getPublicPath())\n        )) {\n            // absolute, but set to blank if not allowed\n            $filename = '';\n        }\n        if ((string)$filename !== '' && static::validPathStr($filename)) {\n            // checks backpath.\n            return $filename;\n        }\n        return '';\n    }\n\n    /**\n     * Checks for malicious file paths.\n     *\n     * Returns TRUE if no '//', '..', '\\' or control characters are found in the $theFile.\n     * This should make sure that the path is not pointing 'backwards' and further doesn't contain double/back slashes.\n     * So it's compatible with the UNIX style path strings valid for TYPO3 internally.\n     *\n     * @param string $theFile File path to evaluate\n     * @return bool TRUE, $theFile is allowed path string, FALSE otherwise\n     * @see https://php.net/manual/en/security.filesystem.nullbytes.php\n     */\n    public static function validPathStr($theFile)\n    {\n        return !str_contains($theFile, '//') && !str_contains($theFile, '\\\\')\n            && preg_match('#(?:^\\\\.\\\\.|/\\\\.\\\\./|[[:cntrl:]])#u', $theFile) === 0;\n    }\n\n    /**\n     * Returns TRUE if the path is absolute, without backpath '..' and within TYPO3s project or public folder OR within the lockRootPath\n     *\n     * @param string $path File path to evaluate\n     * @return bool\n     */\n    public static function isAllowedAbsPath($path)\n    {\n        if (substr($path, 0, 6) === 'vfs://') {\n            return true;\n        }\n        $lockRootPath = $GLOBALS['TYPO3_CONF_VARS']['BE']['lockRootPath'] ?? '';\n        return PathUtility::isAbsolutePath($path) && static::validPathStr($path)\n            && (\n                str_starts_with($path, Environment::getProjectPath())\n                || str_starts_with($path, Environment::getPublicPath())\n                || ($lockRootPath && str_starts_with($path, $lockRootPath))\n            );\n    }\n\n    /**\n     * Low level utility function to copy directories and content recursive\n     *\n     * @param string $source Path to source directory, relative to document root or absolute\n     * @param string $destination Path to destination directory, relative to document root or absolute\n     */\n    public static function copyDirectory($source, $destination)\n    {\n        if (!str_contains($source, Environment::getProjectPath() . '/')) {\n            $source = Environment::getPublicPath() . '/' . $source;\n        }\n        if (!str_contains($destination, Environment::getProjectPath() . '/')) {\n            $destination = Environment::getPublicPath() . '/' . $destination;\n        }\n        if (static::isAllowedAbsPath($source) && static::isAllowedAbsPath($destination)) {\n            static::mkdir_deep($destination);\n            $iterator = new \\RecursiveIteratorIterator(\n                new \\RecursiveDirectoryIterator($source, \\RecursiveDirectoryIterator::SKIP_DOTS),\n                \\RecursiveIteratorIterator::SELF_FIRST\n            );\n            /** @var \\SplFileInfo $item */\n            foreach ($iterator as $item) {\n                $target = $destination . '/' . static::fixWindowsFilePath($iterator->getSubPathName());\n                if ($item->isDir()) {\n                    static::mkdir($target);\n                } else {\n                    static::upload_copy_move(static::fixWindowsFilePath($item->getPathname()), $target);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if a given string is a valid frame URL to be loaded in the\n     * backend.\n     *\n     * If the given url is empty or considered to be harmless, it is returned\n     * as is, else the event is logged and an empty string is returned.\n     *\n     * @param string $url potential URL to check\n     * @return string $url or empty string\n     */\n    public static function sanitizeLocalUrl($url = '')\n    {\n        $sanitizedUrl = '';\n        if (!empty($url)) {\n            $decodedUrl = rawurldecode($url);\n            $parsedUrl = parse_url($decodedUrl);\n            $testAbsoluteUrl = self::resolveBackPath($decodedUrl);\n            $testRelativeUrl = self::resolveBackPath(self::dirname(self::getIndpEnv('SCRIPT_NAME')) . '/' . $decodedUrl);\n            // Pass if URL is on the current host:\n            if (self::isValidUrl($decodedUrl)) {\n                if (self::isOnCurrentHost($decodedUrl) && str_starts_with($decodedUrl, self::getIndpEnv('TYPO3_SITE_URL'))) {\n                    $sanitizedUrl = $url;\n                }\n            } elseif (PathUtility::isAbsolutePath($decodedUrl) && self::isAllowedAbsPath($decodedUrl)) {\n                $sanitizedUrl = $url;\n            } elseif (str_starts_with($testAbsoluteUrl, self::getIndpEnv('TYPO3_SITE_PATH')) && $decodedUrl[0] === '/' &&\n                substr($decodedUrl, 0, 2) !== '//'\n            ) {\n                $sanitizedUrl = $url;\n            } elseif (empty($parsedUrl['scheme']) && str_starts_with($testRelativeUrl, self::getIndpEnv('TYPO3_SITE_PATH'))\n                && $decodedUrl[0] !== '/' && strpbrk($decodedUrl, '*:|\"<>') === false && !str_contains($decodedUrl, '\\\\\\\\')\n            ) {\n                $sanitizedUrl = $url;\n            }\n        }\n        if (!empty($url) && empty($sanitizedUrl)) {\n            static::getLogger()->notice('The URL \"{url}\" is not considered to be local and was denied.', ['url' => $url]);\n        }\n        return $sanitizedUrl;\n    }\n\n    /**\n     * Moves $source file to $destination if uploaded, otherwise try to make a copy\n     *\n     * @param string $source Source file, absolute path\n     * @param string $destination Destination file, absolute path\n     * @return bool Returns TRUE if the file was moved.\n     * @see upload_to_tempfile()\n     */\n    public static function upload_copy_move($source, $destination)\n    {\n        if (is_array($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] ?? null)) {\n            $params = ['source' => $source, 'destination' => $destination, 'method' => 'upload_copy_move'];\n            foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] as $hookMethod) {\n                $fakeThis = null;\n                self::callUserFunction($hookMethod, $params, $fakeThis);\n            }\n        }\n\n        $result = false;\n        if (is_uploaded_file($source)) {\n            // Return the value of move_uploaded_file, and if FALSE the temporary $source is still\n            // around so the user can use unlink to delete it:\n            $result = move_uploaded_file($source, $destination);\n        } else {\n            @copy($source, $destination);\n        }\n        // Change the permissions of the file\n        self::fixPermissions($destination);\n        // If here the file is copied and the temporary $source is still around,\n        // so when returning FALSE the user can try unlink to delete the $source\n        return $result;\n    }\n\n    /**\n     * Will move an uploaded file (normally in \"/tmp/xxxxx\") to a temporary filename in Environment::getProjectPath() . \"var/\" from where TYPO3 can use it.\n     * Use this function to move uploaded files to where you can work on them.\n     * REMEMBER to use \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::unlink_tempfile() afterwards - otherwise temp-files will build up! They are NOT automatically deleted in the temporary folder!\n     *\n     * @param string $uploadedFileName The temporary uploaded filename, eg. $_FILES['[upload field name here]']['tmp_name']\n     * @return string If a new file was successfully created, return its filename, otherwise blank string.\n     * @see unlink_tempfile()\n     * @see upload_copy_move()\n     */\n    public static function upload_to_tempfile($uploadedFileName)\n    {\n        if (is_uploaded_file($uploadedFileName)) {\n            $tempFile = self::tempnam('upload_temp_');\n            if (is_array($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] ?? null)) {\n                $params = ['source' => $uploadedFileName, 'destination' => $tempFile, 'method' => 'upload_to_tempfile'];\n                foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS'][\\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::class]['moveUploadedFile'] as $hookMethod) {\n                    $fakeThis = null;\n                    self::callUserFunction($hookMethod, $params, $fakeThis);\n                }\n            }\n\n            move_uploaded_file($uploadedFileName, $tempFile);\n            return @is_file($tempFile) ? $tempFile : '';\n        }\n\n        return '';\n    }\n\n    /**\n     * Deletes (unlink) a temporary filename in the var/ or typo3temp folder given as input.\n     * The function will check that the file exists, is within TYPO3's var/ or typo3temp/ folder and does not contain back-spaces (\"../\") so it should be pretty safe.\n     * Use this after upload_to_tempfile() or tempnam() from this class!\n     *\n     * @param string $uploadedTempFileName absolute file path - must reside within var/ or typo3temp/ folder.\n     * @return bool|null Returns TRUE if the file was unlink()'ed\n     * @see upload_to_tempfile()\n     * @see tempnam()\n     */\n    public static function unlink_tempfile($uploadedTempFileName)\n    {\n        if ($uploadedTempFileName) {\n            $uploadedTempFileName = self::fixWindowsFilePath($uploadedTempFileName);\n            if (\n                self::validPathStr($uploadedTempFileName)\n                && (\n                    str_starts_with($uploadedTempFileName, Environment::getPublicPath() . '/typo3temp/')\n                    || str_starts_with($uploadedTempFileName, Environment::getVarPath() . '/')\n                )\n                && @is_file($uploadedTempFileName)\n            ) {\n                if (unlink($uploadedTempFileName)) {\n                    return true;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Create temporary filename (Create file with unique file name)\n     * This function should be used for getting temporary file names - will make your applications safe for open_basedir = on\n     * REMEMBER to delete the temporary files after use! This is done by \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::unlink_tempfile()\n     *\n     * @param string $filePrefix Prefix for temporary file\n     * @param string $fileSuffix Suffix for temporary file, for example a special file extension\n     * @return non-empty-string result from PHP function `tempnam()` with the temp/var folder prefixed.\n     * @see unlink_tempfile()\n     * @see upload_to_tempfile()\n     */\n    public static function tempnam($filePrefix, $fileSuffix = '')\n    {\n        $temporaryPath = Environment::getVarPath() . '/transient/';\n        if (!is_dir($temporaryPath)) {\n            self::mkdir_deep($temporaryPath);\n        }\n        if ($fileSuffix === '') {\n            $path = (string)tempnam($temporaryPath, $filePrefix);\n            $tempFileName = $temporaryPath . PathUtility::basename($path);\n        } else {\n            do {\n                $tempFileName = $temporaryPath . $filePrefix . random_int(1, PHP_INT_MAX) . $fileSuffix;\n            } while (file_exists($tempFileName));\n            touch($tempFileName);\n            clearstatcache(false, $tempFileName);\n        }\n        return $tempFileName;\n    }\n\n    /**\n     * Calls a user-defined function/method in class\n     * Such a function/method should look like this: \"function proc(&$params, &$ref) {...}\"\n     *\n     * @param non-empty-string|\\Closure $funcName Function/Method reference or Closure.\n     * @param mixed $params Parameters to be pass along (typically an array) (REFERENCE!)\n     * @param object|null $ref Reference to be passed along (typically \"$this\" - being a reference to the calling object)\n     * @return mixed Content from method/function call\n     * @throws \\InvalidArgumentException\n     */\n    public static function callUserFunction($funcName, &$params, ?object $ref = null)\n    {\n        // Check if we're using a closure and invoke it directly.\n        if (is_object($funcName) && is_a($funcName, \\Closure::class)) {\n            return call_user_func_array($funcName, [&$params, &$ref]);\n        }\n        $funcName = trim($funcName);\n        $parts = explode('->', $funcName);\n        // Call function or method\n        if (count($parts) === 2) {\n            // It's a class/method\n            // Check if class/method exists:\n            if (class_exists($parts[0])) {\n                // Create object\n                $classObj = self::makeInstance($parts[0]);\n                $methodName = (string)$parts[1];\n                $callable = [$classObj, $methodName];\n                if (is_callable($callable)) {\n                    // Call method:\n                    $content = call_user_func_array($callable, [&$params, &$ref]);\n                } else {\n                    throw new \\InvalidArgumentException('No method name \\'' . $parts[1] . '\\' in class ' . $parts[0], 1294585865);\n                }\n            } else {\n                throw new \\InvalidArgumentException('No class named ' . $parts[0], 1294585866);\n            }\n        } elseif (function_exists($funcName) && is_callable($funcName)) {\n            // It's a function\n            $content = call_user_func_array($funcName, [&$params, &$ref]);\n        } else {\n            // Usually this will be annotated by static code analysis tools, but there's no native \"not empty string\" type\n            throw new \\InvalidArgumentException('No function named: ' . $funcName, 1294585867);\n        }\n        return $content;\n    }\n\n    /**\n     * @internal\n     */\n    public static function setContainer(ContainerInterface $container): void\n    {\n        self::$container = $container;\n    }\n\n    /**\n     * @internal\n     */\n    public static function getContainer(): ContainerInterface\n    {\n        if (self::$container === null) {\n            throw new \\LogicException('PSR-11 Container is not available', 1549404144);\n        }\n        return self::$container;\n    }\n\n    /**\n     * Creates an instance of a class taking into account the class-extensions\n     * API of TYPO3. USE THIS method instead of the PHP `new` keyword.\n     * For example, `$obj = new myclass;` should be\n     * `$obj = \\TYPO3\\CMS\\Core\\Utility\\GeneralUtility::makeInstance(\"myclass\")` instead.\n     *\n     * You can also pass arguments for a constructor:\n     * `GeneralUtility::makeInstance(\\myClass::class, $arg1, $arg2, ..., $argN)`\n     *\n     * @template T of object\n     * @param class-string<T> $className name of the class to instantiate, must not be empty and not start with a backslash\n     * @param array<int, mixed> $constructorArguments Arguments for the constructor\n     * @return T the created instance\n     * @throws \\InvalidArgumentException if $className is empty or starts with a backslash\n     */\n    public static function makeInstance($className, ...$constructorArguments)\n    {\n        // PHPStan will complain about this check. That's okay as we're checking a contract violation here.\n        if (!is_string($className) || empty($className)) {\n            throw new \\InvalidArgumentException('$className must be a non empty string.', 1288965219);\n        }\n        // Never instantiate with a beginning backslash, otherwise things like singletons won't work.\n        if ($className[0] === '\\\\') {\n            throw new \\InvalidArgumentException(\n                '$className \"' . $className . '\" must not start with a backslash.',\n                1420281366\n            );\n        }\n        if (isset(static::$finalClassNameCache[$className])) {\n            $finalClassName = static::$finalClassNameCache[$className];\n        } else {\n            $finalClassName = self::getClassName($className);\n            static::$finalClassNameCache[$className] = $finalClassName;\n        }\n        // Return singleton instance if it is already registered\n        if (isset(self::$singletonInstances[$finalClassName])) {\n            return self::$singletonInstances[$finalClassName];\n        }\n        // Return instance if it has been injected by addInstance()\n        if (\n            isset(self::$nonSingletonInstances[$finalClassName])\n            && !empty(self::$nonSingletonInstances[$finalClassName])\n        ) {\n            return array_shift(self::$nonSingletonInstances[$finalClassName]);\n        }\n\n        // Read service and prototypes from the DI container, this is required to\n        // support classes that require dependency injection.\n        // We operate on the original class name on purpose, as class overrides\n        // are resolved inside the container\n        if (self::$container !== null && $constructorArguments === [] && self::$container->has($className)) {\n            return self::$container->get($className);\n        }\n\n        // Create new instance and call constructor with parameters\n        $instance = new $finalClassName(...$constructorArguments);\n        // Register new singleton instance, but only if it is not a known PSR-11 container service\n        if ($instance instanceof SingletonInterface && !(self::$container !== null && self::$container->has($className))) {\n            self::$singletonInstances[$finalClassName] = $instance;\n        }\n        if ($instance instanceof LoggerAwareInterface) {\n            $instance->setLogger(static::makeInstance(LogManager::class)->getLogger($className));\n        }\n        return $instance;\n    }\n\n    /**\n     * Creates a class taking implementation settings and class aliases into account.\n     *\n     * Intended to be used to create objects by the dependency injection container.\n     *\n     * @template T of object\n     * @param class-string<T> $className name of the class to instantiate\n     * @param array<int, mixed> $constructorArguments Arguments for the constructor\n     * @return T the created instance\n     * @internal\n     */\n    public static function makeInstanceForDi(string $className, ...$constructorArguments): object\n    {\n        $finalClassName = static::$finalClassNameCache[$className] ?? static::$finalClassNameCache[$className] = self::getClassName($className);\n\n        // Return singleton instance if it is already registered (currently required for unit and functional tests)\n        if (isset(self::$singletonInstances[$finalClassName])) {\n            return self::$singletonInstances[$finalClassName];\n        }\n        // Create new instance and call constructor with parameters\n        return new $finalClassName(...$constructorArguments);\n    }\n\n    /**\n     * Returns the class name for a new instance, taking into account\n     * registered implementations for this class\n     *\n     * @param class-string $className Base class name to evaluate\n     * @return class-string Final class name to instantiate with `new [classname]`\n     */\n    protected static function getClassName($className)\n    {\n        if (class_exists($className)) {\n            while (static::classHasImplementation($className)) {\n                $className = static::getImplementationForClass($className);\n            }\n        }\n        return ClassLoadingInformation::getClassNameForAlias($className);\n    }\n\n    /**\n     * Returns the configured implementation of the class\n     *\n     * @param class-string $className\n     * @return class-string\n     */\n    protected static function getImplementationForClass($className)\n    {\n        return $GLOBALS['TYPO3_CONF_VARS']['SYS']['Objects'][$className]['className'];\n    }\n\n    /**\n     * Checks if a class has a configured implementation\n     *\n     * @param class-string $className\n     * @return bool\n     */\n    protected static function classHasImplementation($className)\n    {\n        return !empty($GLOBALS['TYPO3_CONF_VARS']['SYS']['Objects'][$className]['className']);\n    }\n\n    /**\n     * Sets the instance of a singleton class to be returned by `makeInstance`.\n     *\n     * If this function is called multiple times for the same $className,\n     * makeInstance will return the last set instance.\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method exists mostly for unit tests to inject a mock of a singleton class.\n     * If you use this, make sure to always combine this with `getSingletonInstances()`\n     * and `resetSingletonInstances()` in setUp() and `tearDown()` of the test class.\n     *\n     * @see makeInstance\n     * @param class-string $className\n     * @internal\n     */\n    public static function setSingletonInstance($className, SingletonInterface $instance)\n    {\n        self::checkInstanceClassName($className, $instance);\n        // Check for XCLASS registration (same is done in makeInstance() in order to store the singleton of the final class name)\n        $finalClassName = self::getClassName($className);\n        self::$singletonInstances[$finalClassName] = $instance;\n    }\n\n    /**\n     * Removes the instance of a singleton class to be returned by `makeInstance`.\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method exists mostly for unit tests to inject a mock of a singleton class.\n     * If you use this, make sure to always combine this with `getSingletonInstances()`\n     * and `resetSingletonInstances()` in `setUp()` and `tearDown()` of the test class.\n     *\n     * @see makeInstance\n     * @param class-string $className\n     * @throws \\InvalidArgumentException\n     * @internal\n     */\n    public static function removeSingletonInstance($className, SingletonInterface $instance)\n    {\n        self::checkInstanceClassName($className, $instance);\n        if (!isset(self::$singletonInstances[$className])) {\n            throw new \\InvalidArgumentException('No Instance registered for ' . $className . '.', 1394099179);\n        }\n        if ($instance !== self::$singletonInstances[$className]) {\n            throw new \\InvalidArgumentException('The instance you are trying to remove has not been registered before.', 1394099256);\n        }\n        unset(self::$singletonInstances[$className]);\n    }\n\n    /**\n     * Set a group of singleton instances. Similar to `setSingletonInstance()`,\n     * but multiple instances can be set.\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method is usually only used in tests to restore the list of singletons in\n     * `tearDown()` that was backed up with `getSingletonInstances()` in `setUp()` and\n     * manipulated in tests with `setSingletonInstance()`.\n     *\n     * @internal\n     * @param array<class-string, SingletonInterface> $newSingletonInstances\n     */\n    public static function resetSingletonInstances(array $newSingletonInstances)\n    {\n        static::$singletonInstances = [];\n        foreach ($newSingletonInstances as $className => $instance) {\n            static::setSingletonInstance($className, $instance);\n        }\n    }\n\n    /**\n     * Get all currently registered singletons\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method is usually only used in tests in `setUp()` to fetch the list of\n     * currently registered singletons, if this list is manipulated with\n     * `setSingletonInstance()` in tests.\n     *\n     * @internal\n     * @return array<class-string, SingletonInterface>\n     */\n    public static function getSingletonInstances()\n    {\n        return static::$singletonInstances;\n    }\n\n    /**\n     * Get all currently registered non singleton instances\n     *\n     * Warning:\n     * This is NOT a public API method and must not be used in own extensions!\n     * This method is only used in `UnitTestCase` base test `tearDown()` to verify tests\n     * have no left-over instances that were previously added using `addInstance()`.\n     *\n     * @internal\n     * @return array<class-string, array<object>>\n     */\n    public static function getInstances()\n    {\n        return static::$nonSingletonInstances;\n    }\n\n    /**\n     * Sets the instance of a non-singleton class to be returned by `makeInstance`.\n     *\n     * If this function is called multiple times for the same `$className`,\n     * `makeInstance` will return the instances in the order in which they have\n     * been added (FIFO).\n     *\n     * Warning: This is a helper method for unit tests. Do not call this directly in production code!\n     *\n     * @see makeInstance\n     * @param class-string $className\n     * @param object $instance\n     * @throws \\InvalidArgumentException if class extends \\TYPO3\\CMS\\Core\\SingletonInterface\n     */\n    public static function addInstance($className, $instance)\n    {\n        self::checkInstanceClassName($className, $instance);\n        if ($instance instanceof SingletonInterface) {\n            throw new \\InvalidArgumentException('$instance must not be an instance of TYPO3\\\\CMS\\\\Core\\\\SingletonInterface. For setting singletons, please use setSingletonInstance.', 1288969325);\n        }\n        if (!isset(self::$nonSingletonInstances[$className])) {\n            self::$nonSingletonInstances[$className] = [];\n        }\n        self::$nonSingletonInstances[$className][] = $instance;\n    }\n\n    /**\n     * Checks that `$className` is non-empty and that `$instance` is an instance of `$className`.\n     *\n     * @param string $className\n     * @param object $instance\n     * @throws \\InvalidArgumentException if $className is empty or if $instance is no instance of $className\n     */\n    protected static function checkInstanceClassName($className, $instance)\n    {\n        if ($className === '') {\n            throw new \\InvalidArgumentException('$className must not be empty.', 1288967479);\n        }\n        if (!$instance instanceof $className) {\n            throw new \\InvalidArgumentException('$instance must be an instance of ' . $className . ', but actually is an instance of ' . get_class($instance) . '.', 1288967686);\n        }\n    }\n\n    /**\n     * Purge all instances returned by makeInstance.\n     *\n     * This function is most useful when called from tearDown in a test case\n     * to drop any instances that have been created by the tests.\n     *\n     * Warning: This is a helper method for unit tests. Do not call this directly in production code!\n     *\n     * @see makeInstance\n     */\n    public static function purgeInstances()\n    {\n        self::$container = null;\n        self::$singletonInstances = [];\n        self::$nonSingletonInstances = [];\n    }\n\n    /**\n     * Flushes some internal runtime caches:\n     * - the class-name mapping used by `makeInstance()`\n     * - the cache for `getIndpEnv()`\n     *\n     * This function is intended to be used in unit tests to keep environment changes from spilling into the next test.\n     *\n     * @internal\n     */\n    public static function flushInternalRuntimeCaches()\n    {\n        self::$finalClassNameCache = [];\n        self::$indpEnvCache = [];\n    }\n\n    /**\n     * Find the best service and check if it works.\n     * Returns object of the service class.\n     *\n     * This method is used for the legacy ExtensionManager:addService() mechanism,\n     * not with Dependency-Injected services. In practice, all remaining core uses of\n     * this mechanism are authentication services, which all have an info property.\n     *\n     * @param string $serviceType Type of service (service key).\n     * @param string $serviceSubType Sub type like file extensions or similar. Defined by the service.\n     * @param array $excludeServiceKeys List of service keys which should be excluded in the search for a service\n     * @throws \\RuntimeException\n     * @return object|string[]|false The service object or an array with error infos, or false if no service was found.\n     */\n    public static function makeInstanceService(string $serviceType, string $serviceSubType = '', array $excludeServiceKeys = []): array|object|false\n    {\n        $error = false;\n        $requestInfo = [\n            'requestedServiceType' => $serviceType,\n            'requestedServiceSubType' => $serviceSubType,\n            'requestedExcludeServiceKeys' => $excludeServiceKeys,\n        ];\n        while ($info = ExtensionManagementUtility::findService($serviceType, $serviceSubType, $excludeServiceKeys)) {\n            // provide information about requested service to service object\n            $info = array_merge($info, $requestInfo);\n\n            /** @var class-string<AbstractAuthenticationService> $className */\n            $className = $info['className'];\n            /** @var AbstractAuthenticationService $obj */\n            $obj = self::makeInstance($className);\n            if (is_object($obj)) {\n                if (!is_callable([$obj, 'init'])) {\n                    self::getLogger()->error('Requested service {class} has no init() method.', [\n                        'class' => $info['className'],\n                        'service' => $info,\n                    ]);\n                    throw new \\RuntimeException('Broken service: ' . $info['className'], 1568119209);\n                }\n                $obj->info = $info;\n                // service available?\n                if ($obj->init()) {\n                    return $obj;\n                }\n                $error = $obj->getLastErrorArray();\n                unset($obj);\n            }\n\n            // deactivate the service\n            ExtensionManagementUtility::deactivateService($info['serviceType'], $info['serviceKey']);\n        }\n        return $error;\n    }\n\n    /**\n     * Quotes a string for usage as JS parameter.\n     *\n     * @param string $value the string to encode, may be empty\n     * @return string the encoded value already quoted (with single quotes),\n     */\n    public static function quoteJSvalue($value)\n    {\n        $json = (string)json_encode(\n            (string)$value,\n            JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_TAG\n        );\n\n        return strtr(\n            $json,\n            [\n                '\"' => '\\'',\n                '\\\\\\\\' => '\\\\u005C',\n                ' ' => '\\\\u0020',\n                '!' => '\\\\u0021',\n                '\\\\t' => '\\\\u0009',\n                '\\\\n' => '\\\\u000A',\n                '\\\\r' => '\\\\u000D',\n            ]\n        );\n    }\n\n    /**\n     * Serializes data to JSON, to be used in HTML attribute, e.g.\n     *\n     * `<div data-value=\"[[JSON]]\">...</div>`\n     * (`[[JSON]]` represents return value of this function)\n     *\n     * @param mixed $value\n     * @param bool $useHtmlEntities\n     */\n    public static function jsonEncodeForHtmlAttribute($value, bool $useHtmlEntities = true): string\n    {\n        $json = (string)json_encode($value, JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_TAG);\n        return $useHtmlEntities ? htmlspecialchars($json) : $json;\n    }\n\n    /**\n     * Serializes data to JSON, to be used in JavaScript instructions, e.g.\n     *\n     * `<script>const value = JSON.parse('[[JSON]]');</script>`\n     * (`[[JSON]]` represents return value of this function)\n     *\n     * @param mixed $value\n     */\n    public static function jsonEncodeForJavaScript($value): string\n    {\n        $json = (string)json_encode($value, JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_TAG);\n        return strtr(\n            $json,\n            [\n                // comments below refer to JSON-encoded data\n                '\\\\\\\\' => '\\\\\\\\u005C', // `\"\\\\Vendor\\\\Package\"` -> `\"\\\\u005CVendor\\\\u005CPackage\"`\n                '\\\\t' => '\\\\u0009', // `\"\\t\"` -> `\"\\u0009\"`\n                '\\\\n' => '\\\\u000A', // `\"\\n\"` -> `\"\\u000A\"`\n                '\\\\r' => '\\\\u000D', // `\"\\r\"` -> `\"\\u000D\"`\n            ]\n        );\n    }\n\n    /**\n     * @return LoggerInterface\n     */\n    protected static function getLogger()\n    {\n        return static::makeInstance(LogManager::class)->getLogger(__CLASS__);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Tests\\Acceptance\\Support\\Extension;\n\nuse Codeception\\Event\\SuiteEvent;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Symfony\\Component\\Mailer\\Transport\\NullTransport;\nuse TYPO3\\CMS\\Core\\Authentication\\BackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Core\\Bootstrap;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Http\\ServerRequest;\nuse TYPO3\\CMS\\Styleguide\\TcaDataGenerator\\Generator;\nuse TYPO3\\CMS\\Styleguide\\TcaDataGenerator\\GeneratorFrontend;\nuse TYPO3\\TestingFramework\\Core\\Acceptance\\Extension\\BackendEnvironment;\n\n/**\n * Load various core extensions and styleguide and call styleguide generator\n */\nfinal class ApplicationEnvironment extends BackendEnvironment\n{\n    /**\n     * Load a list of core extensions and styleguide\n     *\n     * @var array\n     */\n    protected $localConfig = [\n        'coreExtensionsToLoad' => [\n            'core',\n            'beuser',\n            'extbase',\n            'fluid',\n            'filelist',\n            'extensionmanager',\n            'setup',\n            'backend',\n            'belog',\n            'install',\n            'impexp',\n            'frontend',\n            'redirects',\n            'reports',\n            'sys_note',\n            'scheduler',\n            'tstemplate',\n            'lowlevel',\n            'dashboard',\n            'workspaces',\n            'info',\n            'fluid_styled_content',\n            'indexed_search',\n            'adminpanel',\n            'form',\n            'felogin',\n            'seo',\n            'recycler',\n        ],\n        'testExtensionsToLoad' => [\n            'typo3conf/ext/styleguide',\n        ],\n        'csvDatabaseFixtures' => [\n            __DIR__ . '/../../Fixtures/BackendEnvironment.csv',\n        ],\n        'configurationToUseInTestInstance' => [\n            'MAIL' => [\n                'transport' => NullTransport::class,\n            ],\n            'BE' => [\n                'HTTP' => [\n                    'Response' => [\n                        'Headers' => [\n                            // Notes:\n                            //  * `script-src 'nonce-rAnd0m'` required for importmap\n                            //                                todo: this needs to be a proper random value, requires API.\n                            //  * `frame-src blob:` required for es-module-shims blob: URLs\n                            //  * `style-src 'unsafe-inline'` required for lit in safari and firefox to allow inline <style> tags\n                            //                (for browsers that do not support https://caniuse.com/mdn-api_shadowroot_adoptedstylesheets)\n                            'csp-report' => \"Content-Security-Policy-Report-Only: default-src 'self'; script-src 'self' 'nonce-rAnd0m'; style-src 'self' 'unsafe-inline'; style-src-attr 'unsafe-inline'; style-src-elem 'self' 'unsafe-inline'; img-src 'self' data:; worker-src 'self' blob:; frame-src 'self' blob:;\",\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ];\n\n    /**\n     * Generate styleguide data\n     */\n    public function bootstrapTypo3Environment(SuiteEvent $suiteEvent): void\n    {\n        parent::bootstrapTypo3Environment($suiteEvent);\n        // styleguide generator uses DataHandler for some parts. DataHandler needs an initialized BE user\n        // with admin right and the live workspace.\n        $request = $this->createServerRequest('https://typo3-testing.local/typo3/');\n        Bootstrap::initializeBackendUser(BackendUserAuthentication::class, $request);\n        $GLOBALS['BE_USER']->user['username'] = 'acceptanceTestSetup';\n        $GLOBALS['BE_USER']->user['admin'] = 1;\n        $GLOBALS['BE_USER']->user['uid'] = 1;\n        $GLOBALS['BE_USER']->workspace = 0;\n        Bootstrap::initializeLanguageObject();\n\n        // Create favicon.ico to suppress potential javascript errors in console\n        // which are caused by calling a non html in the browser, e.g. seo sitemap xml\n        $faviconTargetPath = '../../../../favicon.ico';\n        if (!is_file($faviconTargetPath)) {\n            symlink('typo3/sysext/backend/Resources/Public/Icons/favicon.ico', '../../../../favicon.ico');\n        }\n\n        $styleguideGenerator = new Generator();\n        $styleguideGenerator->create();\n\n        $styleguideGeneratorFrontend = new GeneratorFrontend();\n        // Force basePath for testing environment, required for the frontend!\n        // Otherwise the page can not be found, also do not set root page to\n        // 'hidden' so menus (e.g. menu_sitemap_pages) are displayed correctly\n        $styleguideGeneratorFrontend->create('/typo3temp/var/tests/acceptance/', 0);\n    }\n\n    // @todo Eventually move this up to TF::BackendEnvironment, but then as protected.\n    private function createServerRequest(string $url, string $method = 'GET'): ServerRequestInterface\n    {\n        $requestUrlParts = parse_url($url);\n        $docRoot = getenv('TYPO3_PATH_APP') ?? '';\n        $serverParams = [\n            'DOCUMENT_ROOT' => $docRoot,\n            'HTTP_USER_AGENT' => 'TYPO3 Functional Test Request',\n            'HTTP_HOST' => $requestUrlParts['host'] ?? 'localhost',\n            'SERVER_NAME' => $requestUrlParts['host'] ?? 'localhost',\n            'SERVER_ADDR' => '127.0.0.1',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '/typo3/index.php',\n            'PHP_SELF' => '/typo3/index.php',\n            'SCRIPT_FILENAME' => $docRoot . '/index.php',\n            'QUERY_STRING' => $requestUrlParts['query'] ?? '',\n            'REQUEST_URI' => $requestUrlParts['path'] . (isset($requestUrlParts['query']) ? '?' . $requestUrlParts['query'] : ''),\n            'REQUEST_METHOD' => $method,\n        ];\n        // Define HTTPS and server port\n        if (isset($requestUrlParts['scheme'])) {\n            if ($requestUrlParts['scheme'] === 'https') {\n                $serverParams['HTTPS'] = 'on';\n                $serverParams['SERVER_PORT'] = '443';\n            } else {\n                $serverParams['SERVER_PORT'] = '80';\n            }\n        }\n\n        // Define a port if used in the URL\n        if (isset($requestUrlParts['port'])) {\n            $serverParams['SERVER_PORT'] = $requestUrlParts['port'];\n        }\n        // set up normalizedParams\n        $request = new ServerRequest($url, $method, null, [], $serverParams);\n        return $request->withAttribute('normalizedParams', NormalizedParams::createFromRequest($request));\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Tests\\Unit\\Http;\n\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\TestingFramework\\Core\\Unit\\UnitTestCase;\n\nclass NormalizedParamsTest extends UnitTestCase\n{\n    /**\n     * @return array[]\n     */\n    public function getHttpHostReturnsSanitizedValueDataProvider(): array\n    {\n        return [\n            'simple HTTP_HOST' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                'www.domain.com',\n            ],\n            'first HTTP_X_FORWARDED_HOST from configured proxy, HTTP_HOST empty' => [\n                [\n                    'HTTP_HOST' => '',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com, www.domain2.com,',\n                ],\n                [\n                    'reverseProxyIP' => ' 123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'first',\n                ],\n                'www.domain1.com',\n            ],\n            'first HTTP_X_FORWARDED_HOST from configured proxy, HTTP_HOST given' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com, www.domain2.com,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'first',\n                ],\n                'www.domain1.com',\n            ],\n            'last HTTP_X_FORWARDED_HOST from configured proxy' => [\n                [\n                    'HTTP_HOST' => '',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com, www.domain2.com,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain2.com',\n            ],\n            'simple HTTP_HOST if reverseProxyHeaderMultiValue is not configured' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                ],\n                'www.domain.com',\n            ],\n            'simple HTTP_HOST if proxy IP does not match' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com',\n                ],\n                [\n                    'reverseProxyIP' => '234.234.234.234',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain.com',\n            ],\n            'simple HTTP_HOST if REMOTE_ADDR misses' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTP_X_FORWARDED_HOST' => 'www.domain1.com',\n                ],\n                [\n                    'reverseProxyIP' => '234.234.234.234',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain.com',\n            ],\n            'simple HTTP_HOST if HTTP_X_FORWARDED_HOST is empty' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTP_X_FORWARDED_HOST' => '',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => 'last',\n                ],\n                'www.domain.com',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getHttpHostReturnsSanitizedValueDataProvider\n     */\n    public function getHttpHostReturnsSanitizedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpHost());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function isHttpsReturnSanitizedValueDataProvider(): array\n    {\n        return [\n            'false if nothing special is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                false,\n            ],\n            'true if SSL_SESSION_ID is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'SSL_SESSION_ID' => 'foo',\n                ],\n                [],\n                true,\n            ],\n            'false if SSL_SESSION_ID is empty' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'SSL_SESSION_ID' => '',\n                ],\n                [],\n                false,\n            ],\n            'true if HTTPS is \"ON\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'ON',\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is \"on\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'on',\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is \"1\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => '1',\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is int(1)\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 1,\n                ],\n                [],\n                true,\n            ],\n            'true if HTTPS is bool(true)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => true,\n                ],\n                [],\n                true,\n            ],\n            // https://secure.php.net/manual/en/reserved.variables.server.php\n            // \"Set to a non-empty value if the script was queried through the HTTPS protocol.\"\n            'true if HTTPS is \"somethingrandom\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'somethingrandom',\n                ],\n                [],\n                true,\n            ],\n            'false if HTTPS is \"0\"' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => '0',\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is int(0)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 0,\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is float(0)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 0.0,\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is not on' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => 'off',\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is empty' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => '',\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is null' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => null,\n                ],\n                [],\n                false,\n            ],\n            'false if HTTPS is bool(false)' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'HTTPS' => false,\n                ],\n                [],\n                false,\n            ],\n            // Per PHP documentation 'HTTPS' is:\n            //   \"Set to a non-empty value if the script\n            //   was queried through the HTTPS protocol.\"\n            // So theoretically an empty array means HTTPS is off.\n            // We do not support that. Therefore this test is disabled.\n            //'false if HTTPS is an empty Array' => [\n            //    [\n            //        'HTTP_HOST' => 'www.domain.com',\n            //        'HTTPS' => [],\n            //    ],\n            //    [],\n            //    false,\n            //],\n            'true if ssl proxy IP matches REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123 ',\n                ],\n                [\n                    'reverseProxySSL' => ' 123.123.123.123',\n                ],\n                true,\n            ],\n            'false if ssl proxy IP does not match REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                ],\n                [\n                    'reverseProxySSL' => '234.234.234.234',\n                ],\n                false,\n            ],\n            'true if SSL proxy is * and reverse proxy IP matches REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                ],\n                [\n                    'reverseProxySSL' => '*',\n                    'reverseProxyIP' => '123.123.123.123',\n                ],\n                true,\n            ],\n            'false if SSL proxy is * and reverse proxy IP does not match REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                ],\n                [\n                    'reverseProxySSL' => '*',\n                    'reverseProxyIP' => '234.234.234.234',\n                ],\n                false,\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isHttpsReturnSanitizedValueDataProvider\n     */\n    public function isHttpsReturnSanitizedValue(array $serverParams, array $configuration, bool $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->isHttps());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestHostReturnsRequestHost(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'HTTPS' => 'on',\n        ];\n        $expected = 'https://www.domain.com';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestHost());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getScriptNameReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'empty string if nothing is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                '',\n            ],\n            'use SCRIPT_NAME' => [\n                [\n                    'SCRIPT_NAME' => '/script/name.php',\n                ],\n                [],\n                '/script/name.php',\n            ],\n            'apply URL encoding to SCRIPT_NAME' => [\n                [\n                    'SCRIPT_NAME' => '/test:site/script/name.php',\n                ],\n                [],\n                '/test%3Asite/script/name.php',\n            ],\n            'add proxy ssl prefix' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'SCRIPT_NAME' => '/path/info.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefixSSL' => '/proxyPrefixSSL',\n                ],\n                '/proxyPrefixSSL/path/info.php',\n            ],\n            'add proxy prefix' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'SCRIPT_NAME' => '/path/info.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefix' => '/proxyPrefix',\n                ],\n                '/proxyPrefix/path/info.php',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getScriptNameReturnsExpectedValueDataProvider\n     */\n    public function getScriptNameReturnsExpectedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getScriptName());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getRequestUriReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'slash if nothing is set' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                '/',\n            ],\n            'use REQUEST_URI' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REQUEST_URI' => 'typo3/bar?id=42',\n                ],\n                [],\n                '/typo3/bar?id=42',\n            ],\n            'use query string and script name if REQUEST_URI is not set' => [\n                [\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                ],\n                [],\n                '/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n            'use query string and script name in special subdirectory if REQUEST_URI is not set' => [\n                [\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/sub:dir/typo3/index.php',\n                ],\n                [],\n                '/sub%3Adir/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n            'prefix with proxy prefix with ssl if using REQUEST_URI' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'REQUEST_URI' => 'typo3/foo/bar?id=42',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefixSSL' => '/proxyPrefixSSL',\n                ],\n                '/proxyPrefixSSL/typo3/foo/bar?id=42',\n            ],\n            'prefix with proxy prefix if using REQUEST_URI' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'REQUEST_URI' => 'typo3/foo/bar?id=42',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefix' => '/proxyPrefix',\n                ],\n                '/proxyPrefix/typo3/foo/bar?id=42',\n            ],\n            'prefix with proxy prefix with ssl if using query string and script name' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefixSSL' => '/proxyPrefixSSL',\n                ],\n                '/proxyPrefixSSL/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n            'prefix with proxy prefix if using query string and script name' => [\n                [\n                    'REMOTE_ADDR' => '123.123.123.123',\n                    'HTTPS' => 'on',\n                    'QUERY_STRING' => 'parameter=foo/bar&id=42',\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyPrefix' => '/proxyPrefix',\n                ],\n                '/proxyPrefix/typo3/index.php?parameter=foo/bar&id=42',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRequestUriReturnsExpectedValueDataProvider\n     */\n    public function getRequestUriReturnsExpectedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestUri());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestUriFetchesFromConfiguredRequestUriVar(): void\n    {\n        $GLOBALS['foo']['bar'] = '/foo/bar.php';\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n        ];\n        $configuration = [\n            'requestURIvar' => 'foo|bar',\n        ];\n        $expected = '/foo/bar.php';\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestUri());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestUrlReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'REQUEST_URI' => 'typo3/foo/bar?id=42',\n        ];\n        $expected = 'http://www.domain.com/typo3/foo/bar?id=42';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestUrl());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestScriptReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $expected = 'http://www.domain.com/typo3/index.php';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestScript());\n    }\n\n    /**\n     * @test\n     */\n    public function getRequestDirReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $expected = 'http://www.domain.com/typo3/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestDir());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function isBehindReverseProxyReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'false with empty data' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                [],\n                false,\n            ],\n            'false if REMOTE_ADDR and reverseProxyIP do not match' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '100.100.100.100',\n                ],\n                [\n                    'reverseProxyIP' => '200.200.200.200',\n                ],\n                false,\n            ],\n            'true if REMOTE_ADDR matches configured reverseProxyIP' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => '100.100.100.100',\n                ],\n                [\n                    'reverseProxyIP' => '100.100.100.100',\n                ],\n                true,\n            ],\n            'true if trimmed REMOTE_ADDR matches configured trimmed reverseProxyIP' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 100.100.100.100 ',\n                ],\n                [\n                    'reverseProxyIP' => '  100.100.100.100  ',\n                ],\n                true,\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isBehindReverseProxyReturnsExpectedValueDataProvider\n     */\n    public function isBehindReverseProxyReturnsExpectedValue(array $serverParams, array $configuration, bool $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->isBehindReverseProxy());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getRemoteAddressReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'simple REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                ],\n                [],\n                '123.123.123.123',\n            ],\n            'reverse proxy with last HTTP_X_FORWARDED_FOR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                    'HTTP_X_FORWARDED_FOR' => ' 234.234.234.234, 235.235.235.235,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123',\n                    'reverseProxyHeaderMultiValue' => ' last ',\n                ],\n                '235.235.235.235',\n            ],\n            'reverse proxy with first HTTP_X_FORWARDED_FOR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                    'HTTP_X_FORWARDED_FOR' => ' 234.234.234.234, 235.235.235.235,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123 ',\n                    'reverseProxyHeaderMultiValue' => ' first ',\n                ],\n                '234.234.234.234',\n            ],\n            'reverse proxy with broken reverseProxyHeaderMultiValue returns REMOTE_ADDR' => [\n                [\n                    'HTTP_HOST' => 'www.domain.com',\n                    'REMOTE_ADDR' => ' 123.123.123.123 ',\n                    'HTTP_X_FORWARDED_FOR' => ' 234.234.234.234, 235.235.235.235,',\n                ],\n                [\n                    'reverseProxyIP' => '123.123.123.123 ',\n                    'reverseProxyHeaderMultiValue' => ' foo ',\n                ],\n                '123.123.123.123',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRemoteAddressReturnsExpectedValueDataProvider\n     */\n    public function getRemoteAddressReturnsExpectedValue(array $serverParams, array $configuration, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, $configuration, '', '');\n        self::assertSame($expected, $serverRequestParameters->getRemoteAddress());\n    }\n\n    public static function getRequestHostOnlyReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'localhost ipv4 without port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1',\n                ],\n                '127.0.0.1',\n            ],\n            'localhost ipv4 with port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1:81',\n                ],\n                '127.0.0.1',\n            ],\n            'localhost ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[::1]',\n                ],\n                '[::1]',\n            ],\n            'localhost ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[::1]:81',\n                ],\n                '[::1]',\n            ],\n            'ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]',\n                ],\n                '[2001:DB8::1]',\n            ],\n            'ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]:81',\n                ],\n                '[2001:DB8::1]',\n            ],\n            'hostname without port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this',\n                ],\n                'lolli.did.this',\n            ],\n            'hostname with port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this:42',\n                ],\n                'lolli.did.this',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRequestHostOnlyReturnsExpectedValueDataProvider\n     */\n    public function getRequestHostOnlyReturnsExpectedValue(array $serverParams, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestHostOnly());\n    }\n\n    public static function getRequestPortOnlyReturnsExpectedValueDataProvider(): array\n    {\n        return [\n            'localhost ipv4 without port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1',\n                ],\n                0,\n            ],\n            'localhost ipv4 with port' => [\n                [\n                    'HTTP_HOST' => '127.0.0.1:81',\n                ],\n                81,\n            ],\n            'localhost ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[::1]',\n                ],\n                0,\n            ],\n            'localhost ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[::1]:81',\n                ],\n                81,\n            ],\n            'ipv6 without port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]',\n                ],\n                0,\n            ],\n            'ipv6 with port' => [\n                [\n                    'HTTP_HOST' => '[2001:DB8::1]:81',\n                ],\n                81,\n            ],\n            'hostname without port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this',\n                ],\n                0,\n            ],\n            'hostname with port' => [\n                [\n                    'HTTP_HOST' => 'lolli.did.this:42',\n                ],\n                42,\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getRequestPortOnlyReturnsExpectedValueDataProvider\n     */\n    public function getRequestPortReturnsExpectedValue(array $serverParams, int $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRequestPort());\n    }\n\n    /**\n     * @test\n     */\n    public function getScriptFilenameReturnsThirdConstructorArgument(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $pathSite = '/var/www/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '/var/www/typo3/index.php', $pathSite);\n        self::assertSame('/var/www/typo3/index.php', $serverRequestParameters->getScriptFilename());\n    }\n\n    /**\n     * @test\n     */\n    public function getDocumentRootReturnsExpectedPath(): void\n    {\n        $serverParams = [\n            'HTTP_HOST' => 'www.domain.com',\n            'SCRIPT_NAME' => '/typo3/index.php',\n        ];\n        $pathThisScript = '/var/www/myInstance/Web/typo3/index.php';\n        $pathSite = '/var/www/myInstance/Web/';\n        $expected = '/var/www/myInstance/Web';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getDocumentRoot());\n    }\n\n    /**\n     * @test\n     */\n    public function getSiteUrlReturnsExpectedUrl(): void\n    {\n        $serverParams = [\n            'SCRIPT_NAME' => '/typo3/index.php',\n            'HTTP_HOST' => 'www.domain.com',\n        ];\n        $pathThisScript = '/var/www/myInstance/Web/typo3/index.php';\n        $pathSite = '/var/www/myInstance/Web';\n        $expected = 'http://www.domain.com/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSiteUrl());\n    }\n\n    /**\n     * @test\n     */\n    public function getSiteUrlReturnsExpectedUrlForCliCommand(): void\n    {\n        $serverParams = [];\n        $pathThisScript = '/var/www/html/typo3temp/var/tests/acceptance/typo3/sysext/core/bin/typo3';\n        $pathSite = '/var/www/html/typo3temp/var/tests/acceptance/';\n        $expected = '/';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSiteUrl());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getSitePathReturnsExpectedPathDataProvider(): array\n    {\n        return [\n            'empty config' => [\n                [],\n                '',\n                '',\n                '',\n            ],\n            'not in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                '/',\n            ],\n            'in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/some/sub/dir/typo3/index.php',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                '/some/sub/dir/',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getSitePathReturnsExpectedPathDataProvider\n     */\n    public function getSitePathReturnsExpectedPath(array $serverParams, string $pathThisScript, string $pathSite, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSitePath());\n    }\n\n    /**\n     * @return array[]\n     */\n    public function getSiteScriptReturnsExpectedPathDataProvider(): array\n    {\n        return [\n            'not in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/typo3/index.php',\n                    'REQUEST_URI' => '/typo3/index.php?id=42&foo=bar',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                'typo3/index.php?id=42&foo=bar',\n            ],\n            'in a sub directory' => [\n                [\n                    'SCRIPT_NAME' => '/some/sub/dir/typo3/index.php',\n                    'REQUEST_URI' => '/some/sub/dir/typo3/index.php?id=42&foo=bar',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                '/var/www/myInstance/Web/typo3/index.php',\n                '/var/www/myInstance/Web',\n                'typo3/index.php?id=42&foo=bar',\n            ],\n            'redirected to a sub directory' => [\n                'serverParams' => [\n                    'REQUEST_URI' => '/',\n                    'SCRIPT_NAME' => '/public/',\n                    'HTTP_HOST' => 'www.domain.com',\n                ],\n                'pathThisScript' => '/var/www/html/public/index.php',\n                'pathSite' => '/var/www/html/html/public',\n                'expected' => '',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider getSiteScriptReturnsExpectedPathDataProvider\n     */\n    public function getSiteScriptReturnsExpectedPath(array $serverParams, string $pathThisScript, string $pathSite, string $expected): void\n    {\n        $serverRequestParameters = new NormalizedParams($serverParams, [], $pathThisScript, $pathSite);\n        self::assertSame($expected, $serverRequestParameters->getSiteScript());\n    }\n\n    /**\n     * @test\n     */\n    public function getPathInfoReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'PATH_INFO' => '/foo/bar',\n        ];\n        $expected = '/foo/bar';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getPathInfo());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpRefererReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_REFERER' => 'https://www.domain.com/typo3/index.php?id=42',\n        ];\n        $expected = 'https://www.domain.com/typo3/index.php?id=42';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpReferer());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpUserAgentReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_USER_AGENT' => 'the client browser',\n        ];\n        $expected = 'the client browser';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpUserAgent());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpAcceptEncodingReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_ACCEPT_ENCODING' => 'gzip, deflate',\n        ];\n        $expected = 'gzip, deflate';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpAcceptEncoding());\n    }\n\n    /**\n     * @test\n     */\n    public function getHttpAcceptLanguageReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'HTTP_ACCEPT_LANGUAGE' => 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7',\n        ];\n        $expected = 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getHttpAcceptLanguage());\n    }\n\n    /**\n     * @test\n     */\n    public function getRemoteHostReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'REMOTE_HOST' => 'www.clientDomain.com',\n        ];\n        $expected = 'www.clientDomain.com';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getRemoteHost());\n    }\n\n    /**\n     * @test\n     */\n    public function getQueryStringReturnsExpectedValue(): void\n    {\n        $serverParams = [\n            'QUERY_STRING' => 'id=42&foo=bar',\n        ];\n        $expected = 'id=42&foo=bar';\n        $serverRequestParameters = new NormalizedParams($serverParams, [], '', '');\n        self::assertSame($expected, $serverRequestParameters->getQueryString());\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Core\\Tests\\Unit\\Log\\Processor;\n\nuse Psr\\Log\\LogLevel;\nuse TYPO3\\CMS\\Core\\Log\\LogRecord;\nuse TYPO3\\CMS\\Core\\Log\\Processor\\WebProcessor;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\TestingFramework\\Core\\Unit\\UnitTestCase;\n\nclass WebProcessorTest extends UnitTestCase\n{\n    /**\n     * @test\n     */\n    public function webProcessorAddsWebDataToLogRecord(): void\n    {\n        $_SERVER['REQUEST_URI'] = '';\n        $_SERVER['SCRIPT_NAME'] = '';\n        $_SERVER['REMOTE_ADDR'] = '';\n        $_SERVER['QUERY_STRING'] = '';\n        $_SERVER['SSL_SESSION_ID'] = '';\n        $_SERVER['HTTP_HOST'] = 'acme.com';\n\n        $environmentVariables = GeneralUtility::getIndpEnv('_ARRAY');\n        $logRecord = new LogRecord('test.core.log', LogLevel::DEBUG, 'test');\n        $processor = new WebProcessor();\n        $logRecord = $processor->processLogRecord($logRecord);\n        foreach ($environmentVariables as $key => $value) {\n            self::assertEquals($value, $logRecord['data'][$key]);\n        }\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\FrontendLogin\\Tests\\Unit\\Validation;\n\nuse Psr\\Log\\NullLogger;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Core\\SystemEnvironmentBuilder;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Http\\ServerRequestFactory;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\Site;\nuse TYPO3\\CMS\\Core\\Site\\SiteFinder;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Extbase\\Mvc\\ExtbaseRequestParameters;\nuse TYPO3\\CMS\\Extbase\\Mvc\\Request;\nuse TYPO3\\CMS\\Extbase\\Mvc\\RequestInterface;\nuse TYPO3\\CMS\\FrontendLogin\\Validation\\RedirectUrlValidator;\nuse TYPO3\\TestingFramework\\Core\\AccessibleObjectInterface;\nuse TYPO3\\TestingFramework\\Core\\Unit\\UnitTestCase;\n\nclass RedirectUrlValidatorTest extends UnitTestCase\n{\n    protected bool $backupEnvironment = true;\n\n    protected RedirectUrlValidator&AccessibleObjectInterface $accessibleFixture;\n    protected RequestInterface $extbaseRequest;\n    protected string $testHostName;\n    protected string $testSitePath;\n\n    protected bool $resetSingletonInstances = true;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $site1 = new Site('dummy', 1, ['base' => 'http://sub.domainhostname.tld/path/']);\n        $site2 = new Site('dummy', 1, ['base' => 'http://sub2.domainhostname.tld/']);\n        $mockedSiteFinder = $this->getAccessibleMock(SiteFinder::class, ['getAllSites'], [], '', false, false);\n        $mockedSiteFinder->method('getAllSites')->willReturn([$site1, $site2]);\n\n        $this->testHostName = 'hostname.tld';\n        $this->testSitePath = '/';\n        $this->accessibleFixture = $this->getAccessibleMock(RedirectUrlValidator::class, null, [$mockedSiteFinder]);\n        $this->accessibleFixture->setLogger(new NullLogger());\n        $this->setUpFakeSitePathAndHost();\n    }\n\n    /**\n     * Set up a fake site path and host\n     */\n    protected function setUpFakeSitePathAndHost(): void\n    {\n        $_SERVER['SCRIPT_NAME'] = $this->testSitePath . 'index.php';\n        $_SERVER['HTTP_HOST'] = $this->testHostName;\n\n        $request = ServerRequestFactory::fromGlobals();\n        $request = $request->withAttribute('applicationType', SystemEnvironmentBuilder::REQUESTTYPE_FE);\n        $normalizedParams = NormalizedParams::createFromRequest($request);\n        $request = $request->withAttribute('normalizedParams', $normalizedParams)->withAttribute('extbase', new ExtbaseRequestParameters());\n        $this->extbaseRequest = new Request($request);\n    }\n\n    /**\n     * Data provider for validateRedirectUrlClearsUrl\n     */\n    public function validateRedirectUrlClearsUrlDataProvider(): array\n    {\n        return [\n            'absolute URL, hostname not in site, trailing slash' => ['http://badhost.tld/'],\n            'absolute URL, hostname not in site, no trailing slash' => ['http://badhost.tld'],\n            'absolute URL, subdomain in site, but main domain not, trailing slash' => ['http://domainhostname.tld.badhost.tld/'],\n            'absolute URL, subdomain in site, but main domain not, no trailing slash' => ['http://domainhostname.tld.badhost.tld'],\n            'non http absolute URL 1' => ['its://domainhostname.tld/itunes/'],\n            'non http absolute URL 2' => ['ftp://domainhostname.tld/download/'],\n            'XSS attempt 1' => ['javascript:alert(123)'],\n            'XSS attempt 2' => ['\" onmouseover=\"alert(123)\"'],\n            'invalid URL, HTML break out attempt' => ['\" >blabuubb'],\n            'invalid URL, UNC path' => ['\\\\\\\\foo\\\\bar\\\\'],\n            'invalid URL, backslashes in path' => ['http://domainhostname.tld\\\\bla\\\\blupp'],\n            'invalid URL, linefeed in path' => ['http://domainhostname.tld/bla/blupp' . LF],\n            'invalid URL, only one slash after scheme' => ['http:/domainhostname.tld/bla/blupp'],\n            'invalid URL, illegal chars' => ['http://(<>domainhostname).tld/bla/blupp'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlClearsUrlDataProvider\n     */\n    public function validateRedirectUrlClearsUrl(string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        self::assertFalse($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**\n     * Data provider for validateRedirectUrlKeepsCleanUrl\n     */\n    public function validateRedirectUrlKeepsCleanUrlDataProvider(): array\n    {\n        return [\n            'sane absolute URL' => ['http://sub.domainhostname.tld/path/'],\n            'sane absolute URL with script' => ['http://sub.domainhostname.tld/path/index.php?id=1'],\n            'sane absolute URL with routing' => ['http://sub.domainhostname.tld/path/foo/bar/foo.html'],\n            'sane absolute URL with homedir' => ['http://sub.domainhostname.tld/path/~user/'],\n            'sane absolute URL with some strange chars encoded' => ['http://sub.domainhostname.tld/path/~user/a%cc%88o%cc%88%c3%9fa%cc%82/foo.html'],\n            'relative URL, no leading slash 1' => ['index.php?id=1'],\n            'relative URL, no leading slash 2' => ['foo/bar/index.php?id=2'],\n            'relative URL, leading slash, no routing' => ['/index.php?id=1'],\n            'relative URL, leading slash, routing' => ['/de/service/imprint.html'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlKeepsCleanUrlDataProvider\n     */\n    public function validateRedirectUrlKeepsCleanUrl(string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        self::assertTrue($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**\n     * Data provider for validateRedirectUrlClearsInvalidUrlInSubdirectory\n     */\n    public function validateRedirectUrlClearsInvalidUrlInSubdirectoryDataProvider(): array\n    {\n        return [\n            'absolute URL, missing subdirectory' => ['http://hostname.tld/'],\n            'absolute URL, wrong subdirectory' => ['http://hostname.tld/hacker/index.php'],\n            'absolute URL, correct subdirectory, no trailing slash' => ['http://hostname.tld/subdir'],\n            'relative URL, leading slash, no path' => ['/index.php?id=1'],\n            'relative URL, leading slash, wrong path' => ['/de/sub/site.html'],\n            'relative URL, leading slash, slash only' => ['/'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlClearsInvalidUrlInSubdirectoryDataProvider\n     */\n    public function validateRedirectUrlClearsInvalidUrlInSubdirectory(string $url): void\n    {\n        GeneralUtility::flushInternalRuntimeCaches();\n        $this->testSitePath = '/subdir/';\n        $this->setUpFakeSitePathAndHost();\n        self::assertFalse($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**\n     * Data provider for validateRedirectUrlKeepsCleanUrlInSubdirectory\n     */\n    public function validateRedirectUrlKeepsCleanUrlInSubdirectoryDataProvider(): array\n    {\n        return [\n            'absolute URL, correct subdirectory' => ['http://hostname.tld/subdir/'],\n            'absolute URL, correct subdirectory, routing' => ['http://hostname.tld/subdir/de/imprint.html'],\n            'absolute URL, correct subdirectory, no routing' => ['http://hostname.tld/subdir/index.php?id=10'],\n            'absolute URL, correct subdirectory of site base' => ['http://sub.domainhostname.tld/path/'],\n            'relative URL, no leading slash, routing' => ['de/service/imprint.html'],\n            'relative URL, no leading slash, no routing' => ['index.php?id=1'],\n            'relative nested URL, no leading slash, no routing' => ['foo/bar/index.php?id=2'],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider validateRedirectUrlKeepsCleanUrlInSubdirectoryDataProvider\n     */\n    public function validateRedirectUrlKeepsCleanUrlInSubdirectory(string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        $this->testSitePath = '/subdir/';\n        $this->setUpFakeSitePathAndHost();\n        self::assertTrue($this->accessibleFixture->isValid($this->extbaseRequest, $url));\n    }\n\n    /**************************************************\n     * Tests concerning isInCurrentDomain\n     **************************************************/\n\n    /**\n     * Dataprovider for isInCurrentDomainIgnoresScheme\n     */\n    public function isInCurrentDomainIgnoresSchemeDataProvider(): array\n    {\n        return [\n            'url https, current host http' => [\n                'example.com', // HTTP_HOST\n                '0', // HTTPS\n                'https://example.com/foo.html', // URL\n            ],\n            'url http, current host https' => [\n                'example.com',\n                '1',\n                'http://example.com/foo.html',\n            ],\n            'url https, current host https' => [\n                'example.com',\n                '1',\n                'https://example.com/foo.html',\n            ],\n            'url http, current host http' => [\n                'example.com',\n                '0',\n                'http://example.com/foo.html',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isInCurrentDomainIgnoresSchemeDataProvider\n     * @param string $host $_SERVER['HTTP_HOST']\n     * @param string $https $_SERVER['HTTPS']\n     * @param string $url The url to test\n     */\n    public function isInCurrentDomainIgnoresScheme(string $host, string $https, string $url): void\n    {\n        Environment::initialize(\n            Environment::getContext(),\n            true,\n            false,\n            Environment::getProjectPath(),\n            Environment::getPublicPath(),\n            Environment::getVarPath(),\n            Environment::getConfigPath(),\n            Environment::getPublicPath() . '/index.php',\n            Environment::isWindows() ? 'WINDOWS' : 'UNIX'\n        );\n        $_SERVER['HTTP_HOST'] = $host;\n        $_SERVER['HTTPS'] = $https;\n\n        $request = ServerRequestFactory::fromGlobals();\n        $request = $request->withAttribute('applicationType', SystemEnvironmentBuilder::REQUESTTYPE_FE);\n        $normalizedParams = NormalizedParams::createFromRequest($request);\n        $request = $request->withAttribute('normalizedParams', $normalizedParams)->withAttribute('extbase', new ExtbaseRequestParameters());\n        $extbaseRequest = new Request($request);\n\n        self::assertTrue($this->accessibleFixture->_call('isInCurrentDomain', $extbaseRequest, $url));\n    }\n\n    public function isInCurrentDomainReturnsFalseIfDomainsAreDifferentDataProvider(): array\n    {\n        return [\n            'simple difference' => [\n                'example.com', // HTTP_HOST\n                'http://typo3.org/foo.html', // URL\n            ],\n            'subdomain different' => [\n                'example.com',\n                'http://foo.example.com/bar.html',\n            ],\n        ];\n    }\n\n    /**\n     * @test\n     * @dataProvider isInCurrentDomainReturnsFalseIfDomainsAreDifferentDataProvider\n     * @param string $host $_SERVER['HTTP_HOST']\n     * @param string $url The url to test\n     */\n    public function isInCurrentDomainReturnsFalseIfDomainsAreDifferent(string $host, string $url): void\n    {\n        $_SERVER['HTTP_HOST'] = $host;\n\n        $request = ServerRequestFactory::fromGlobals();\n        $request = $request->withAttribute('applicationType', SystemEnvironmentBuilder::REQUESTTYPE_FE);\n        $normalizedParams = NormalizedParams::createFromRequest($request);\n        $request = $request->withAttribute('normalizedParams', $normalizedParams)->withAttribute('extbase', new ExtbaseRequestParameters());\n        $extbaseRequest = new Request($request);\n\n        self::assertFalse($this->accessibleFixture->_call('isInCurrentDomain', $extbaseRequest, $url));\n    }\n\n    /**************************************************\n     * Tests concerning isInLocalDomain\n     **************************************************/\n\n    /**\n     * @test\n     */\n    public function isInLocalDomainValidatesSites(): void\n    {\n        $url = 'http://example.com';\n        self::assertFalse($this->accessibleFixture->_call('isInLocalDomain', $url));\n\n        $url = 'http://sub2.domainhostname.tld/some/path';\n        self::assertTrue($this->accessibleFixture->_call('isInLocalDomain', $url));\n    }\n}\n", "<?php\n\n/*\n * This file is part of the TYPO3 CMS project.\n *\n * It is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License, either version 2\n * of the License, or any later version.\n *\n * For the full copyright and license information, please read the\n * LICENSE.txt file that was distributed with this source code.\n *\n * The TYPO3 project - inspiring people to share!\n */\n\nnamespace TYPO3\\CMS\\Frontend\\Controller;\n\nuse Psr\\EventDispatcher\\EventDispatcherInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Psr\\Log\\LogLevel;\nuse TYPO3\\CMS\\Backend\\FrontendBackendUserAuthentication;\nuse TYPO3\\CMS\\Core\\Cache\\CacheManager;\nuse TYPO3\\CMS\\Core\\Cache\\Frontend\\FrontendInterface;\nuse TYPO3\\CMS\\Core\\Cache\\Frontend\\PhpFrontend;\nuse TYPO3\\CMS\\Core\\Compatibility\\PublicPropertyDeprecationTrait;\nuse TYPO3\\CMS\\Core\\Configuration\\PageTsConfig;\nuse TYPO3\\CMS\\Core\\Context\\Context;\nuse TYPO3\\CMS\\Core\\Context\\LanguageAspect;\nuse TYPO3\\CMS\\Core\\Context\\LanguageAspectFactory;\nuse TYPO3\\CMS\\Core\\Context\\UserAspect;\nuse TYPO3\\CMS\\Core\\Core\\Environment;\nuse TYPO3\\CMS\\Core\\Database\\ConnectionPool;\nuse TYPO3\\CMS\\Core\\Domain\\Access\\RecordAccessVoter;\nuse TYPO3\\CMS\\Core\\Domain\\Repository\\PageRepository;\nuse TYPO3\\CMS\\Core\\Error\\Http\\AbstractServerErrorException;\nuse TYPO3\\CMS\\Core\\Error\\Http\\PageNotFoundException;\nuse TYPO3\\CMS\\Core\\Error\\Http\\ShortcutTargetPageNotFoundException;\nuse TYPO3\\CMS\\Core\\Exception\\Page\\RootLineException;\nuse TYPO3\\CMS\\Core\\Exception\\SiteNotFoundException;\nuse TYPO3\\CMS\\Core\\Http\\ImmediateResponseException;\nuse TYPO3\\CMS\\Core\\Http\\NormalizedParams;\nuse TYPO3\\CMS\\Core\\Http\\PropagateResponseException;\nuse TYPO3\\CMS\\Core\\Localization\\LanguageService;\nuse TYPO3\\CMS\\Core\\Localization\\LanguageServiceFactory;\nuse TYPO3\\CMS\\Core\\Locking\\ResourceMutex;\nuse TYPO3\\CMS\\Core\\Page\\AssetCollector;\nuse TYPO3\\CMS\\Core\\Page\\PageRenderer;\nuse TYPO3\\CMS\\Core\\PageTitle\\PageTitleProviderManager;\nuse TYPO3\\CMS\\Core\\Routing\\PageArguments;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\Site;\nuse TYPO3\\CMS\\Core\\Site\\Entity\\SiteLanguage;\nuse TYPO3\\CMS\\Core\\Site\\SiteFinder;\nuse TYPO3\\CMS\\Core\\TimeTracker\\TimeTracker;\nuse TYPO3\\CMS\\Core\\Type\\Bitmask\\PageTranslationVisibility;\nuse TYPO3\\CMS\\Core\\Type\\Bitmask\\Permission;\nuse TYPO3\\CMS\\Core\\Type\\DocType;\nuse TYPO3\\CMS\\Core\\TypoScript\\AST\\Node\\ChildNode;\nuse TYPO3\\CMS\\Core\\TypoScript\\AST\\Node\\RootNode;\nuse TYPO3\\CMS\\Core\\TypoScript\\FrontendTypoScript;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\SysTemplateRepository;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\SysTemplateTreeBuilder;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Traverser\\ConditionVerdictAwareIncludeTreeTraverser;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Traverser\\IncludeTreeTraverser;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeAstBuilderVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeConditionIncludeListAccumulatorVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeConditionMatcherVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\IncludeTree\\Visitor\\IncludeTreeSetupConditionConstantSubstitutionVisitor;\nuse TYPO3\\CMS\\Core\\TypoScript\\TemplateService;\nuse TYPO3\\CMS\\Core\\TypoScript\\Tokenizer\\LossyTokenizer;\nuse TYPO3\\CMS\\Core\\Utility\\GeneralUtility;\nuse TYPO3\\CMS\\Core\\Utility\\HttpUtility;\nuse TYPO3\\CMS\\Core\\Utility\\MathUtility;\nuse TYPO3\\CMS\\Core\\Utility\\PathUtility;\nuse TYPO3\\CMS\\Core\\Utility\\RootlineUtility;\nuse TYPO3\\CMS\\Frontend\\Aspect\\PreviewAspect;\nuse TYPO3\\CMS\\Frontend\\Authentication\\FrontendUserAuthentication;\nuse TYPO3\\CMS\\Frontend\\Cache\\CacheLifetimeCalculator;\nuse TYPO3\\CMS\\Frontend\\Configuration\\TypoScript\\ConditionMatching\\ConditionMatcher as FrontendConditionMatcher;\nuse TYPO3\\CMS\\Frontend\\ContentObject\\ContentObjectRenderer;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterCacheableContentIsGeneratedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterCachedPageIsPersistedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterPageAndLanguageIsResolvedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\AfterPageWithRootLineIsResolvedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\BeforePageIsResolvedEvent;\nuse TYPO3\\CMS\\Frontend\\Event\\ShouldUseCachedPageDataIfAvailableEvent;\nuse TYPO3\\CMS\\Frontend\\Page\\CacheHashCalculator;\nuse TYPO3\\CMS\\Frontend\\Page\\PageAccessFailureReasons;\nuse TYPO3\\CMS\\Frontend\\Typolink\\LinkVarsCalculator;\n\n/**\n * Main controller class of the TypoScript based frontend.\n *\n * This is prepared in Frontend middlewares and the content rendering is\n * ultimately called in \\TYPO3\\CMS\\Frontend\\Http\\RequestHandler.\n *\n * When calling a Frontend page, an instance of this object is available\n * as $GLOBALS['TSFE'], even though the core development strives to get\n * rid of this in the future.\n */\nclass TypoScriptFrontendController implements LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n    use PublicPropertyDeprecationTrait;\n\n    protected array $deprecatedPublicProperties = [\n        'intTarget' => '$TSFE->intTarget will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'intTarget\\'] instead.',\n        'extTarget' => '$TSFE->extTarget will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'extTarget\\'] instead.',\n        'fileTarget' => '$TSFE->fileTarget will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'fileTarget\\'] instead.',\n        'spamProtectEmailAddresses' => '$TSFE->spamProtectEmailAddresses will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'spamProtectEmailAddresses\\'] instead.',\n        'baseUrl' => '$TSFE->baseUrl will be removed in TYPO3 v13.0. Use $TSFE->config[\\'config\\'][\\'baseURL\\'] instead.',\n        'xhtmlDoctype' => '$TSFE->xhtmlDoctype will be removed in TYPO3 v13.0. Use PageRenderer->getDocType() instead.',\n        'xhtmlVersion' => '$TSFE->xhtmlVersion will be removed in TYPO3 v13.0. Use PageRenderer->getDocType() instead.',\n    ];\n\n    /**\n     * The page id (int)\n     */\n    public int $id;\n\n    /**\n     * The type (read-only)\n     * @var int|string\n     */\n    public $type = 0;\n\n    protected Site $site;\n    protected SiteLanguage $language;\n\n    /**\n     * @internal\n     */\n    protected PageArguments $pageArguments;\n\n    /**\n     * Page will not be cached. Write only TRUE. Never clear value (some other\n     * code might have reasons to set it TRUE).\n     * @var bool\n     * @internal\n     */\n    public $no_cache = false;\n\n    /**\n     * Rootline of page records all the way to the root.\n     *\n     * Both language and version overlays are applied to these page records:\n     * All \"data\" fields are set to language / version overlay values, *except* uid and\n     * pid, which are the default-language and live-version ids.\n     *\n     * First array row with the highest key is the deepest page (the requested page),\n     * then parent pages with descending keys until (but not including) the\n     * project root pseudo page 0.\n     *\n     * When page uid 5 is called in this example:\n     * [0] Project name\n     * |- [2] An organizational page, probably with is_siteroot=1 and a site config\n     *    |- [3] Site root with a sys_template having \"root\" flag set\n     *       |- [5] Here you are\n     *\n     * This $absoluteRootLine is:\n     * [3] => [uid = 5, pid = 3, title = Here you are, ...]\n     * [2] => [uid = 3, pid = 2, title = Site root with a sys_template having \"root\" flag set, ...]\n     * [1] => [uid = 2, pid = 0, title = An organizational page, probably with is_siteroot=1 and a site config, ...]\n     *\n     * @var array<int, array<string, mixed>>\n     */\n    public array $rootLine = [];\n\n    /**\n     * The pagerecord\n     * @var array\n     */\n    public $page = [];\n\n    /**\n     * This will normally point to the same value as id, but can be changed to\n     * point to another page from which content will then be displayed instead.\n     */\n    public int $contentPid = 0;\n\n    /**\n     * Gets set when we are processing a page of type mountpoint with enabled overlay in getPageAndRootline()\n     * Used later in checkPageForMountpointRedirect() to determine the final target URL where the user\n     * should be redirected to.\n     */\n    protected ?array $originalMountPointPage = null;\n\n    /**\n     * Gets set when we are processing a page of type shortcut in the early stages\n     * of the request, used later in the request to resolve the shortcut and redirect again.\n     */\n    protected ?array $originalShortcutPage = null;\n\n    /**\n     * sys_page-object, pagefunctions\n     *\n     * @var PageRepository|string\n     */\n    public $sys_page = '';\n\n    /**\n     * Is set to > 0 if the page could not be resolved. This will then result in early returns when resolving the page.\n     */\n    protected int $pageNotFound = 0;\n\n    /**\n     * Array containing a history of why a requested page was not accessible.\n     */\n    protected array $pageAccessFailureHistory = [];\n\n    /**\n     * @var string\n     * @internal\n     */\n    public $MP = '';\n\n    /**\n     * The frontend user\n     *\n     * @var FrontendUserAuthentication\n     */\n    public $fe_user;\n\n    /**\n     * A central data array consisting of various keys, initialized and\n     * processed at various places in the class.\n     *\n     * This array is cached along with the rendered page content and contains\n     * for instance a list of INT identifiers used to calculate 'dynamic' page\n     * parts when a page is retrieved from cache.\n     *\n     * Some sub keys:\n     *\n     * 'config': This is the TypoScript ['config.'] sub-array, with some\n     *           settings being sanitized and merged.\n     *\n     * 'rootLine': This is the \"local\" rootline of a deep page that stops at the first parent\n     *             sys_template record that has \"root\" flag set, in natural parent-child order.\n     *\n     *             Both language and version overlays are applied to these page records:\n     *             All \"data\" fields are set to language / version overlay values, *except* uid and\n     *             pid, which are the default-language and live-version ids.\n     *\n     *             When page uid 5 is called in this example:\n     *             [0] Project name\n     *             |- [2] An organizational page, probably with is_siteroot=1 and a site config\n     *                |- [3] Site root with a sys_template having \"root\" flag set\n     *                   |- [5] Here you are\n     *\n     *             This rootLine is:\n     *             [0] => [uid = 3, pid = 2, title = Site root with a sys_template having \"root\" flag set, ...]\n     *             [1] => [uid = 5, pid = 3, title = Here you are, ...]\n     *\n     * @var array<string, mixed>\n     */\n    public $config = [];\n\n    /**\n     * The TypoScript template object. Used to parse the TypoScript template\n     *\n     * @var TemplateService\n     * @internal: Will get a proper deprecation in v12.x.\n     * @deprecated: TemplateService is kept for b/w compat in v12 but will be removed in v13.\n     */\n    public $tmpl;\n\n    /**\n     * Is set to the time-to-live time of cached pages. Default is 60*60*24, which is 24 hours.\n     *\n     * @internal\n     */\n    protected int $cacheTimeOutDefault = 0;\n\n    /**\n     * Set if cached content was fetched from the cache.\n     * @internal\n     */\n    protected bool $pageContentWasLoadedFromCache = false;\n\n    /**\n     * Set to the expire time of cached content\n     * @internal\n     */\n    protected int $cacheExpires = 0;\n\n    /**\n     * TypoScript configuration of the page-object.\n     * @var array|string\n     * @internal should only be used by TYPO3 Core\n     */\n    public $pSetup = '';\n\n    /**\n     * This hash is unique to the template, the $this->id and $this->type vars and\n     * the list of groups. Used to get and later store the cached data\n     * @internal\n     */\n    public string $newHash = '';\n\n    /**\n     * This flag is set before the page is generated IF $this->no_cache is set. If this\n     * flag is set after the page content was generated, $this->no_cache is forced to be set.\n     * This is done in order to make sure that PHP code from Plugins / USER scripts does not falsely\n     * clear the no_cache flag.\n     * @internal\n     */\n    protected bool $no_cacheBeforePageGen = false;\n\n    /**\n     * May be set to the pagesTSconfig\n     * @internal\n     */\n    protected ?array $pagesTSconfig = null;\n\n    /**\n     * Eg. insert JS-functions in this array ($additionalHeaderData) to include them\n     * once. Use associative keys.\n     *\n     * Keys in use:\n     *\n     * used to accumulate additional HTML-code for the header-section,\n     * <head>...</head>. Insert either associative keys (like\n     * additionalHeaderData['myStyleSheet'], see reserved keys above) or num-keys\n     * (like additionalHeaderData[] = '...')\n     *\n     * @var array\n     */\n    public $additionalHeaderData = [];\n\n    /**\n     * Used to accumulate additional HTML-code for the footer-section of the template\n     * @var array\n     */\n    public $additionalFooterData = [];\n\n    /**\n     * Default internal target\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $intTarget = '';\n\n    /**\n     * Default external target\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $extTarget = '';\n\n    /**\n     * Default file link target\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $fileTarget = '';\n\n    /**\n     * If set, typolink() function encrypts email addresses.\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected int $spamProtectEmailAddresses = 0;\n\n    /**\n     * Absolute Reference prefix\n     * @var string\n     */\n    public $absRefPrefix = '';\n\n    /**\n     * A string prepared for insertion in all links on the page as url-parameters.\n     * Based on configuration in TypoScript where you defined which GET parameters you\n     * would like to pass on.\n     * @internal if needed, generate linkVars via LinkVarsCalculator\n     */\n    public string $linkVars = '';\n\n    /**\n     * 'Global' Storage for various applications. Keys should be 'tx_'.extKey for\n     * extensions.\n     */\n    public array $applicationData = [];\n\n    public array $register = [];\n\n    /**\n     * Stack used for storing array and retrieving register arrays (see\n     * LOAD_REGISTER and RESTORE_REGISTER)\n     */\n    public array $registerStack = [];\n\n    /**\n     * Used by RecordContentObject and ContentContentObject to ensure the a records is NOT\n     * rendered twice through it!\n     */\n    public array $recordRegister = [];\n\n    /**\n     * This is set to the [table]:[uid] of the latest record rendered. Note that\n     * class ContentObjectRenderer has an equal value, but that is pointing to the\n     * record delivered in the $data-array of the ContentObjectRenderer instance, if\n     * the cObjects CONTENT or RECORD created that instance\n     */\n    public string $currentRecord = '';\n\n    /**\n     * Used to generate page-unique keys. Point is that uniqid() functions is very\n     * slow, so a unique key is made based on this, see function uniqueHash()\n     * @internal\n     */\n    protected int $uniqueCounter = 0;\n\n    /**\n     * @internal\n     */\n    protected string $uniqueString = '';\n\n    /**\n     * The base URL set for the page header.\n     * @var string\n     * @deprecated since TYPO3 v12.0. will be removed in TYPO3 v13.0.\n     */\n    protected $baseUrl = '';\n\n    /**\n     * Page content render object\n     *\n     * @var ContentObjectRenderer\n     */\n    public $cObj;\n\n    /**\n     * All page content is accumulated in this variable. See RequestHandler\n     * @var string\n     */\n    public $content = '';\n\n    /**\n     * Info-array of the last resulting image resource of content object\n     * IMG_RESOURCE (if any), containing width, height and so on.\n     */\n    public ?array $lastImgResourceInfo = null;\n\n    /**\n     * Internal calculations for labels\n     */\n    protected ?LanguageService $languageService = null;\n\n    /**\n     * @internal Internal locking. May move to a middleware soon.\n     */\n    public ?ResourceMutex $lock = null;\n\n    protected ?PageRenderer $pageRenderer = null;\n\n    /**\n     * The page cache object, use this to save pages to the cache and to\n     * retrieve them again\n     *\n     * @var FrontendInterface\n     */\n    protected $pageCache;\n\n    protected array $pageCacheTags = [];\n\n    /**\n     * Content type HTTP header being sent in the request.\n     * @todo Ticket: #63642 Should be refactored to a request/response model later\n     * @internal Should only be used by TYPO3 core for now\n     */\n    protected string $contentType = 'text/html';\n\n    /**\n     * Doctype to use\n     *\n     * @var string\n     * @deprecated since TYPO3 v12, will be removed in TYPO3 v13. Use PageRenderer->getDocType() instead.\n     */\n    protected $xhtmlDoctype = '';\n\n    /**\n     * @var int\n     * @deprecated since TYPO3 v12, will be removed in TYPO3 v13. Use PageRenderer->getDocType() instead.\n     */\n    protected $xhtmlVersion;\n\n    /**\n     * Originally requested id from PageArguments\n     */\n    protected int $requestedId = 0;\n\n    /**\n     * The context for keeping the current state, mostly related to current page information,\n     * backend user / frontend user access, workspaceId\n     */\n    protected Context $context;\n\n    /**\n     * If debug mode is enabled, this contains the information if a page is fetched from cache,\n     * and sent as HTTP Response Header.\n     */\n    protected string $debugInformationHeader = '';\n\n    /**\n     * Since TYPO3 v10.0, TSFE is composed out of\n     *  - Context\n     *  - Site\n     *  - SiteLanguage\n     *  - PageArguments (containing ID, Type, cHash and MP arguments)\n     *\n     * Also sets a unique string (->uniqueString) for this script instance; A md5 hash of the microtime()\n     *\n     * @param Context $context the Context object to work with\n     * @param Site $site The resolved site to work with\n     * @param SiteLanguage $siteLanguage The resolved language to work with\n     * @param PageArguments $pageArguments The PageArguments object containing Page ID, type and GET parameters\n     * @param FrontendUserAuthentication $frontendUser a FrontendUserAuthentication object\n     */\n    public function __construct(Context $context, Site $site, SiteLanguage $siteLanguage, PageArguments $pageArguments, FrontendUserAuthentication $frontendUser)\n    {\n        $this->initializeContext($context);\n        $this->site = $site;\n        $this->language = $siteLanguage;\n        $this->setPageArguments($pageArguments);\n        $this->fe_user = $frontendUser;\n        $this->uniqueString = md5(microtime());\n        $this->initPageRenderer();\n        $this->initCaches();\n    }\n\n    private function initializeContext(Context $context): void\n    {\n        $this->context = $context;\n        if (!$this->context->hasAspect('frontend.preview')) {\n            $this->context->setAspect('frontend.preview', GeneralUtility::makeInstance(PreviewAspect::class));\n        }\n    }\n\n    /**\n     * Initializes the page renderer object\n     */\n    protected function initPageRenderer()\n    {\n        if ($this->pageRenderer !== null) {\n            return;\n        }\n        $this->pageRenderer = GeneralUtility::makeInstance(PageRenderer::class);\n        $this->pageRenderer->setTemplateFile('EXT:frontend/Resources/Private/Templates/MainPage.html');\n        // As initPageRenderer could be called in constructor and for USER_INTs, this information is only set\n        // once - in order to not override any previous settings of PageRenderer.\n        $this->pageRenderer->setLanguage($this->language->getTypo3Language());\n    }\n\n    /**\n     * @param string $contentType\n     * @internal Must only be used by TYPO3 core\n     */\n    public function setContentType($contentType)\n    {\n        $this->contentType = $contentType;\n    }\n\n    /********************************************\n     *\n     * Initializing, resolving page id\n     *\n     ********************************************/\n    /**\n     * Initializes the caching system.\n     */\n    protected function initCaches()\n    {\n        $cacheManager = GeneralUtility::makeInstance(CacheManager::class);\n        $this->pageCache = $cacheManager->getCache('pages');\n    }\n\n    /**\n     * Initializes the front-end user groups.\n     * Sets frontend.user aspect based on front-end user status.\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function initUserGroups()\n    {\n        trigger_error('TSFE->initUserGroups() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        $this->context->setAspect('frontend.user', $this->fe_user->createUserAspect());\n    }\n\n    /**\n     * Checking if a user is logged in or a group constellation different from \"0,-1\"\n     *\n     * @return bool TRUE if either a login user is found (array fe_user->user) OR if the gr_list is set to something else than '0,-1' (could be done even without a user being logged in!)\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function isUserOrGroupSet()\n    {\n        trigger_error('TSFE->isUserOrGroupSet() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        /** @var UserAspect $userAspect */\n        $userAspect = $this->context->getAspect('frontend.user');\n        return $userAspect->isUserOrGroupSet();\n    }\n\n    /**\n     * Checks if a backend user is logged in\n     *\n     * @return bool whether a backend user is logged in\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function isBackendUserLoggedIn()\n    {\n        trigger_error('TSFE->isBackendUserLoggedIn() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        return (bool)$this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false);\n    }\n\n    /**\n     * Resolves the page id and sets up several related properties.\n     *\n     * At this point, the Context object already contains relevant preview\n     * settings (if a backend user is logged in etc).\n     *\n     * If $this->id is not set at all, the method does its best to set the\n     * value to an integer. Resolving is based on this options:\n     *\n     * - Finding the domain record start page\n     * - First visible page\n     * - Relocating the id below the site if outside the site / domain\n     *\n     * The following properties may be set up or updated:\n     *\n     * - id\n     * - sys_page\n     * - sys_page->where_groupAccess\n     * - sys_page->where_hid_del\n     * - register['SYS_LASTCHANGED']\n     * - pageNotFound\n     *\n     * Via getPageAndRootline()\n     *\n     * - rootLine\n     * - page\n     * - MP\n     * - originalShortcutPage\n     * - originalMountPointPage\n     * - pageAccessFailureHistory['direct_access']\n     * - pageNotFound\n     */\n    public function determineId(ServerRequestInterface $request): ?ResponseInterface\n    {\n        $this->sys_page = GeneralUtility::makeInstance(PageRepository::class, $this->context);\n\n        $eventDispatcher = GeneralUtility::makeInstance(EventDispatcherInterface::class);\n        $eventDispatcher->dispatch(new BeforePageIsResolvedEvent($this, $request));\n\n        $timeTracker = $this->getTimeTracker();\n        $timeTracker->push('determineId rootLine/');\n        try {\n            // Sets ->page and ->rootline information based on ->id. ->id may change during this operation.\n            // If the found Page ID is not within the site, then pageNotFound is set.\n            $this->getPageAndRootline($request);\n            // Checks if the rootPageId of the site is in the resolved rootLine.\n            // This is necessary so that references to page-id's via ?id=123 from other sites are not possible.\n            $siteRootWithinRootlineFound = false;\n            foreach ($this->rootLine as $pageInRootLine) {\n                if ((int)$pageInRootLine['uid'] === $this->site->getRootPageId()) {\n                    $siteRootWithinRootlineFound = true;\n                    break;\n                }\n            }\n            // Page is 'not found' in case the id was outside the domain, code 3\n            // This can only happen if there was a shortcut. So $this->page is now the shortcut target\n            // But the original page is in $this->originalShortcutPage.\n            // This only happens if people actually call TYPO3 with index.php?id=123 where 123 is in a different\n            // page tree. This is not allowed.\n            $directlyRequestedId = (int)($request->getQueryParams()['id'] ?? 0);\n            if (!$siteRootWithinRootlineFound && $directlyRequestedId && (int)($this->originalShortcutPage['uid'] ?? 0) !== $directlyRequestedId) {\n                $this->pageNotFound = 3;\n                $this->id = $this->site->getRootPageId();\n                // re-get the page and rootline if the id was not found.\n                $this->getPageAndRootline($request);\n            }\n        } catch (ShortcutTargetPageNotFoundException $e) {\n            $this->pageNotFound = 1;\n        }\n        $timeTracker->pull();\n\n        $event = new AfterPageWithRootLineIsResolvedEvent($this, $request);\n        $event = $eventDispatcher->dispatch($event);\n        if ($event->getResponse()) {\n            return $event->getResponse();\n        }\n\n        $response = null;\n        try {\n            $this->evaluatePageNotFound($this->pageNotFound, $request);\n\n            // Setting language and fetch translated page\n            $this->settingLanguage($request);\n            // Check the \"content_from_pid\" field of the resolved page\n            $this->contentPid = $this->resolveContentPid($request);\n\n            // Update SYS_LASTCHANGED at the very last, when $this->page might be changed\n            // by settingLanguage() and the $this->page was finally resolved\n            $this->setRegisterValueForSysLastChanged($this->page);\n        } catch (PropagateResponseException $e) {\n            $response = $e->getResponse();\n        }\n\n        $event = new AfterPageAndLanguageIsResolvedEvent($this, $request, $response);\n        $eventDispatcher->dispatch($event);\n        return $event->getResponse();\n    }\n\n    /**\n     * If $this->pageNotFound is set, then throw an exception to stop further page generation process\n     */\n    protected function evaluatePageNotFound(int $pageNotFoundNumber, ServerRequestInterface $request): void\n    {\n        if (!$pageNotFoundNumber) {\n            return;\n        }\n        $response = match ($pageNotFoundNumber) {\n            1 => GeneralUtility::makeInstance(ErrorController::class)->accessDeniedAction(\n                $request,\n                'ID was not an accessible page',\n                $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_PAGE_NOT_RESOLVED)\n            ),\n            2 => GeneralUtility::makeInstance(ErrorController::class)->accessDeniedAction(\n                $request,\n                'Subsection was found and not accessible',\n                $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_SUBSECTION_NOT_RESOLVED)\n            ),\n            3 => GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                $request,\n                'ID was outside the domain',\n                $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_HOST_PAGE_MISMATCH)\n            ),\n            default => GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                $request,\n                'Unspecified error',\n                $this->getPageAccessFailureReasons()\n            ),\n        };\n        throw new PropagateResponseException($response, 1533931329);\n    }\n\n    /**\n     * Loads the page and root line records based on $this->id\n     *\n     * A final page and the matching root line are determined and loaded by\n     * the algorithm defined by this method.\n     *\n     * First it loads the initial page from the page repository for $this->id.\n     * If that can't be loaded directly, it gets the root line for $this->id.\n     * It walks up the root line towards the root page until the page\n     * repository can deliver a page record. (The loading restrictions of\n     * the root line records are more liberal than that of the page record.)\n     *\n     * Now the page type is evaluated and handled if necessary. If the page is\n     * a short cut, it is replaced by the target page. If the page is a mount\n     * point in overlay mode, the page is replaced by the mounted page.\n     *\n     * After this potential replacements are done, the root line is loaded\n     * (again) for this page record. It walks up the root line up to\n     * the first viewable record.\n     *\n     * (While upon the first accessibility check of the root line it was done\n     * by loading page by page from the page repository, this time the method\n     * checkRootlineForIncludeSection() is used to find the most distant\n     * accessible page within the root line.)\n     *\n     * Having found the final page id, the page record and the root line are\n     * loaded for last time by this method.\n     *\n     * Exceptions may be thrown for DOKTYPE_SPACER and not loadable page records\n     * or root lines.\n     *\n     * May set or update these properties:\n     *\n     * @see TypoScriptFrontendController::$id\n     * @see TypoScriptFrontendController::$MP\n     * @see TypoScriptFrontendController::$page\n     * @see TypoScriptFrontendController::$pageNotFound\n     * @see TypoScriptFrontendController::$pageAccessFailureHistory\n     * @see TypoScriptFrontendController::$originalMountPointPage\n     * @see TypoScriptFrontendController::$originalShortcutPage\n     *\n     * @throws \\TYPO3\\CMS\\Core\\Error\\Http\\ServiceUnavailableException\n     * @throws PageNotFoundException\n     * @throws ShortcutTargetPageNotFoundException\n     */\n    protected function getPageAndRootline(ServerRequestInterface $request)\n    {\n        $requestedPageRowWithoutGroupCheck = [];\n        $this->page = $this->sys_page->getPage($this->id);\n        if (empty($this->page)) {\n            // If no page, we try to find the page above in the rootLine.\n            // Page is 'not found' in case the id itself was not an accessible page. code 1\n            $this->pageNotFound = 1;\n            $requestedPageIsHidden = false;\n            try {\n                $hiddenField = $GLOBALS['TCA']['pages']['ctrl']['enablecolumns']['disabled'] ?? '';\n                $includeHiddenPages = $this->context->getPropertyFromAspect('visibility', 'includeHiddenPages') || $this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false);\n                if (!empty($hiddenField) && !$includeHiddenPages) {\n                    // Page is \"hidden\" => 404 (deliberately done in default language, as this cascades to language overlays)\n                    $rawPageRecord = $this->sys_page->getPage_noCheck($this->id);\n                    $requestedPageIsHidden = (bool)$rawPageRecord[$hiddenField];\n                }\n\n                $requestedPageRowWithoutGroupCheck = $this->sys_page->getPage($this->id, true);\n                if (!empty($requestedPageRowWithoutGroupCheck)) {\n                    $this->pageAccessFailureHistory['direct_access'][] = $requestedPageRowWithoutGroupCheck;\n                }\n                $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n                if (!empty($this->rootLine)) {\n                    $c = count($this->rootLine) - 1;\n                    while ($c > 0) {\n                        // Add to page access failure history:\n                        $this->pageAccessFailureHistory['direct_access'][] = $this->rootLine[$c];\n                        // Decrease to next page in rootline and check the access to that, if OK, set as page record and ID value.\n                        $c--;\n                        $this->id = (int)$this->rootLine[$c]['uid'];\n                        $this->page = $this->sys_page->getPage($this->id);\n                        if (!empty($this->page)) {\n                            break;\n                        }\n                    }\n                }\n            } catch (RootLineException $e) {\n                $this->rootLine = [];\n            }\n            // If still no page...\n            if ($requestedPageIsHidden || (empty($requestedPageRowWithoutGroupCheck) && empty($this->page))) {\n                $message = 'The requested page does not exist!';\n                try {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        $message,\n                        $this->getPageAccessFailureReasons(PageAccessFailureReasons::PAGE_NOT_FOUND)\n                    );\n                    throw new PropagateResponseException($response, 1533931330);\n                } catch (PageNotFoundException $e) {\n                    throw new PageNotFoundException($message, 1301648780);\n                }\n            }\n        }\n        // Spacer and sysfolders is not accessible in frontend\n        $pageDoktype = (int)($this->page['doktype'] ?? 0);\n        $isSpacerOrSysfolder = $pageDoktype === PageRepository::DOKTYPE_SPACER || $pageDoktype === PageRepository::DOKTYPE_SYSFOLDER;\n        // Page itself is not accessible, but the parent page is a spacer/sysfolder\n        if ($isSpacerOrSysfolder && !empty($requestedPageRowWithoutGroupCheck)) {\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->accessDeniedAction(\n                    $request,\n                    'Subsection was found and not accessible',\n                    $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_SUBSECTION_NOT_RESOLVED)\n                );\n                throw new PropagateResponseException($response, 1633171038);\n            } catch (PageNotFoundException $e) {\n                throw new PageNotFoundException('Subsection was found and not accessible', 1633171172);\n            }\n        }\n\n        if ($isSpacerOrSysfolder) {\n            $message = 'The requested page does not exist!';\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                    $request,\n                    $message,\n                    $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_INVALID_PAGETYPE)\n                );\n                throw new PropagateResponseException($response, 1533931343);\n            } catch (PageNotFoundException $e) {\n                throw new PageNotFoundException($message, 1301648781);\n            }\n        }\n        // Is the ID a link to another page??\n        if ($pageDoktype === PageRepository::DOKTYPE_SHORTCUT) {\n            // We need to clear MP if the page is a shortcut. Reason is if the shortcut goes to another page, then we LEAVE the rootline which the MP expects.\n            $this->MP = '';\n            // saving the page so that we can check later - when we know\n            // about languages - whether we took the correct shortcut or\n            // whether a translation of the page overwrites the shortcut\n            // target and we need to follow the new target\n            $this->originalShortcutPage = $this->page;\n            $this->page = $this->sys_page->resolveShortcutPage($this->page, true);\n            $this->id = (int)$this->page['uid'];\n            $pageDoktype = (int)($this->page['doktype'] ?? 0);\n        }\n        // If the page is a mountpoint which should be overlaid with the contents of the mounted page,\n        // it must never be accessible directly, but only in the mountpoint context. Therefore we change\n        // the current ID and the user is redirected by checkPageForMountpointRedirect().\n        if ($pageDoktype === PageRepository::DOKTYPE_MOUNTPOINT && $this->page['mount_pid_ol']) {\n            $this->originalMountPointPage = $this->page;\n            $this->page = $this->sys_page->getPage($this->page['mount_pid']);\n            if (empty($this->page)) {\n                $message = 'This page (ID ' . $this->originalMountPointPage['uid'] . ') is of type \"Mount point\" and '\n                    . 'mounts a page which is not accessible (ID ' . $this->originalMountPointPage['mount_pid'] . ').';\n                throw new PageNotFoundException($message, 1402043263);\n            }\n            // If the current page is a shortcut, the MP parameter will be replaced\n            if ($this->MP === '' || !empty($this->originalShortcutPage)) {\n                $this->MP = $this->page['uid'] . '-' . $this->originalMountPointPage['uid'];\n            } else {\n                $this->MP .= ',' . $this->page['uid'] . '-' . $this->originalMountPointPage['uid'];\n            }\n            $this->id = (int)$this->page['uid'];\n            $pageDoktype = (int)($this->page['doktype'] ?? 0);\n        }\n        // Gets the rootLine\n        try {\n            $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n        } catch (RootLineException $e) {\n            $this->rootLine = [];\n        }\n        // If not rootline we're off...\n        if (empty($this->rootLine)) {\n            $message = 'The requested page didn\\'t have a proper connection to the tree-root!';\n            $this->logPageAccessFailure($message, $request);\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->internalErrorAction(\n                    $request,\n                    $message,\n                    $this->getPageAccessFailureReasons(PageAccessFailureReasons::ROOTLINE_BROKEN)\n                );\n                throw new PropagateResponseException($response, 1533931350);\n            } catch (AbstractServerErrorException $e) {\n                $this->logger->error($message, ['exception' => $e]);\n                $exceptionClass = get_class($e);\n                throw new $exceptionClass($message, 1301648167);\n            }\n        }\n        // Checking for include section regarding the hidden/starttime/endtime/fe_user (that is access control of a whole subbranch!)\n        if ($this->checkRootlineForIncludeSection()) {\n            if (empty($this->rootLine)) {\n                $message = 'The requested page does not exist!';\n                try {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        $message,\n                        $this->getPageAccessFailureReasons(PageAccessFailureReasons::PAGE_NOT_FOUND)\n                    );\n                    throw new PropagateResponseException($response, 1533931351);\n                } catch (AbstractServerErrorException $e) {\n                    $this->logger->warning($message);\n                    $exceptionClass = get_class($e);\n                    throw new $exceptionClass($message, 1301648234);\n                }\n            } else {\n                $el = reset($this->rootLine);\n                $this->id = (int)$el['uid'];\n                $this->page = $this->sys_page->getPage($this->id);\n                try {\n                    $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n                } catch (RootLineException $e) {\n                    $this->rootLine = [];\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if visibility of the page is blocked upwards in the root line.\n     *\n     * If any page in the root line is blocking visibility, true is returned.\n     *\n     * All pages from the blocking page downwards are removed from the root\n     * line, so that the remaining pages can be used to relocate the page up\n     * to lowest visible page.\n     *\n     * The blocking feature of a page must be turned on by setting the page\n     * record field 'extendToSubpages' to 1 in case of hidden, starttime,\n     * endtime or fe_group restrictions.\n     *\n     * Additionally, this method checks for backend user sections in root line\n     * and if found, evaluates if a backend user is logged in and has access.\n     *\n     * Recyclers are also checked and trigger page not found if found in root\n     * line.\n     *\n     * @todo Find a better name, i.e. checkVisibilityByRootLine\n     * @todo Invert boolean return value. Return true if visible.\n     */\n    protected function checkRootlineForIncludeSection(): bool\n    {\n        $c = count($this->rootLine);\n        $removeTheRestFlag = false;\n        $accessVoter = GeneralUtility::makeInstance(RecordAccessVoter::class);\n        for ($a = 0; $a < $c; $a++) {\n            if (!$accessVoter->accessGrantedForPageInRootLine($this->rootLine[$a], $this->context)) {\n                // Add to page access failure history and mark the page as not found\n                // Keep the rootline however to trigger an access denied error instead of a service unavailable error\n                $this->pageAccessFailureHistory['sub_section'][] = $this->rootLine[$a];\n                $this->pageNotFound = 2;\n            }\n\n            if ((int)$this->rootLine[$a]['doktype'] === PageRepository::DOKTYPE_BE_USER_SECTION) {\n                // If there is a backend user logged in, check if they have read access to the page:\n                if ($this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false)) {\n                    // If there was no page selected, the user apparently did not have read access to the\n                    // current page (not position in rootline) and we set the remove-flag...\n                    if (!$this->getBackendUser()->doesUserHaveAccess($this->page, Permission::PAGE_SHOW)) {\n                        $removeTheRestFlag = true;\n                    }\n                } else {\n                    // Don't go here, if there is no backend user logged in.\n                    $removeTheRestFlag = true;\n                }\n            } elseif ((int)$this->rootLine[$a]['doktype'] === PageRepository::DOKTYPE_RECYCLER) {\n                // page is in a recycler\n                $removeTheRestFlag = true;\n            }\n            if ($removeTheRestFlag) {\n                // Page is 'not found' in case a subsection was found and not accessible, code 2\n                $this->pageNotFound = 2;\n                unset($this->rootLine[$a]);\n            }\n        }\n        return $removeTheRestFlag;\n    }\n\n    /**\n     * Checks page record for enableFields\n     * Returns TRUE if enableFields does not disable the page record.\n     * Takes notice of the includeHiddenPages visibility aspect flag and uses SIM_ACCESS_TIME for start/endtime evaluation\n     *\n     * @param array $row The page record to evaluate (needs fields: hidden, starttime, endtime, fe_group)\n     * @param bool $bypassGroupCheck Bypass group-check\n     * @return bool TRUE, if record is viewable.\n     * @deprecated since TYPO3 v12, will be removed in TYPO3 v13. Use RecordAccessVoter instead.\n     */\n    public function checkEnableFields($row, $bypassGroupCheck = false)\n    {\n        trigger_error(\n            'Method ' . __METHOD__ . ' has been deprecated in v12 and will be removed with v13. Use RecordAccessVoter instead.',\n            E_USER_DEPRECATED\n        );\n        return GeneralUtility::makeInstance(RecordAccessVoter::class)->accessGranted('pages', $row, $this->context);\n    }\n\n    /**\n     * Analysing $this->pageAccessFailureHistory into a summary array telling which features disabled display and on which pages and conditions. That data can be used inside a page-not-found handler\n     *\n     * @param string|null $failureReasonCode the error code to be attached (optional), see PageAccessFailureReasons list for details\n     * @return array Summary of why page access was not allowed.\n     */\n    public function getPageAccessFailureReasons(string $failureReasonCode = null)\n    {\n        $output = [];\n        if ($failureReasonCode) {\n            $output['code'] = $failureReasonCode;\n        }\n        $combinedRecords = array_merge(\n            is_array($this->pageAccessFailureHistory['direct_access'] ?? false) ? $this->pageAccessFailureHistory['direct_access'] : [['fe_group' => 0]],\n            is_array($this->pageAccessFailureHistory['sub_section'] ?? false) ? $this->pageAccessFailureHistory['sub_section'] : []\n        );\n        if (!empty($combinedRecords)) {\n            $accessVoter = GeneralUtility::makeInstance(RecordAccessVoter::class);\n            foreach ($combinedRecords as $k => $pagerec) {\n                // If $k=0 then it is the very first page the original ID was pointing at and that will get a full check of course\n                // If $k>0 it is parent pages being tested. They are only significant for the access to the first page IF they had the extendToSubpages flag set, hence checked only then!\n                if (!$k || $pagerec['extendToSubpages']) {\n                    if ($pagerec['hidden'] ?? false) {\n                        $output['hidden'][$pagerec['uid']] = true;\n                    }\n                    if (isset($pagerec['starttime']) && $pagerec['starttime'] > $GLOBALS['SIM_ACCESS_TIME']) {\n                        $output['starttime'][$pagerec['uid']] = $pagerec['starttime'];\n                    }\n                    if (isset($pagerec['endtime']) && $pagerec['endtime'] != 0 && $pagerec['endtime'] <= $GLOBALS['SIM_ACCESS_TIME']) {\n                        $output['endtime'][$pagerec['uid']] = $pagerec['endtime'];\n                    }\n                    if (!$accessVoter->groupAccessGranted('pages', $pagerec, $this->context)) {\n                        $output['fe_group'][$pagerec['uid']] = $pagerec['fe_group'];\n                    }\n                }\n            }\n        }\n        return $output;\n    }\n\n    /********************************************\n     *\n     * Template and caching related functions.\n     *\n     *******************************************/\n\n    protected function setPageArguments(PageArguments $pageArguments): void\n    {\n        $this->pageArguments = $pageArguments;\n        $this->id = $pageArguments->getPageId();\n        // We store the originally requested id\n        $this->requestedId = $this->id;\n        $this->type = (int)($pageArguments->getPageType() ?: 0);\n        if ($GLOBALS['TYPO3_CONF_VARS']['FE']['enable_mount_pids']) {\n            $this->MP = (string)($pageArguments->getArguments()['MP'] ?? '');\n            // Ensure no additional arguments are given via the &MP=123-345,908-172 (e.g. \"/\")\n            $this->MP = preg_replace('/[^0-9,-]/', '', $this->MP);\n        }\n    }\n\n    /**\n     * Fetches the arguments that are relevant for creating the hash base from the given PageArguments object.\n     * Excluded parameters are not taken into account when calculating the hash base.\n     */\n    protected function getRelevantParametersForCachingFromPageArguments(PageArguments $pageArguments): array\n    {\n        $queryParams = $pageArguments->getDynamicArguments();\n        if (!empty($queryParams) && ($pageArguments->getArguments()['cHash'] ?? false)) {\n            $queryParams['id'] = $pageArguments->getPageId();\n            return GeneralUtility::makeInstance(CacheHashCalculator::class)\n                ->getRelevantParameters(HttpUtility::buildQueryString($queryParams));\n        }\n        return [];\n    }\n\n    /**\n     * This is a central and quite early method called by PrepareTypoScriptFrontendRendering middleware:\n     * This code is *always* executed for *every* frontend call if a general page rendering has to be done,\n     * if there is no early redirect or eid call or similar.\n     *\n     * The goal is to calculate dependencies up to a point to see if a possible page cache can be used,\n     * and to prepare TypoScript as far as really needed.\n     *\n     * @throws PropagateResponseException\n     * @throws AbstractServerErrorException\n     * @return ServerRequestInterface New request object with typoscript attribute\n     *\n     * @internal This method may vanish from TypoScriptFrontendController without further notice.\n     * @todo: This method is typically called by PrepareTypoScriptFrontendRendering middleware.\n     *        However, the RedirectService of (earlier) ext:redirects RedirectHandler middleware\n     *        calls this as well. We may want to put this code into some helper class, reduce class\n     *        state as much as possible and carry really needed state as request attributes around?!\n     */\n    public function getFromCache(ServerRequestInterface $request): ServerRequestInterface\n    {\n        // Reset some state.\n        // @todo: Find out which resets are really needed here - Since this is called from a\n        //        relatively early middleware, we can expect these properties to be not set already?!\n        $this->content = '';\n        $this->config = [];\n        $this->pageContentWasLoadedFromCache = false;\n\n        // Very first thing, *always* executed: TypoScript is one factor that influences page content.\n        // There can be multiple cache entries per page, when TypoScript conditions on the same page\n        // create different TypoScript. We thus need the sys_template rows relevant for this page.\n        // @todo: Even though all rootline sys_template records are fetched with only one query\n        //        in below implementation, we could potentially join or sub select sys_template\n        //        records already when pages rootline is queried. This will safe one query\n        //        and needs an implementation in getPageAndRootline() which is called via determineId()\n        //        in TypoScriptFrontendInitialization. This could be done when getPageAndRootline()\n        //        switches to a CTE query instead of using RootlineUtility.\n        $sysTemplateRepository = GeneralUtility::makeInstance(SysTemplateRepository::class);\n        $sysTemplateRows = $sysTemplateRepository->getSysTemplateRowsByRootline($this->rootLine, $request);\n        // Needed for cache calculations. Put into a variable here to not serialize multiple times.\n        $serializedSysTemplateRows = serialize($sysTemplateRows);\n\n        // Early exception if there is no sys_template at all.\n        if (empty($sysTemplateRows)) {\n            $message = 'No TypoScript record found!';\n            $this->logger->alert($message);\n            try {\n                $response = GeneralUtility::makeInstance(ErrorController::class)->internalErrorAction(\n                    $request,\n                    $message,\n                    ['code' => PageAccessFailureReasons::RENDERING_INSTRUCTIONS_NOT_FOUND]\n                );\n                throw new PropagateResponseException($response, 1533931380);\n            } catch (AbstractServerErrorException $e) {\n                $exceptionClass = get_class($e);\n                throw new $exceptionClass($message, 1294587218);\n            }\n        }\n\n        if (!$this->tmpl instanceof TemplateService) {\n            // @deprecated since v12, will be removed in v13: b/w compat. Remove when TemplateService is dropped.\n            $this->tmpl = GeneralUtility::makeInstance(TemplateService::class, $this->context, null, $this);\n        }\n\n        // Calculate \"local\" rootLine that stops at first root=1 template, will be set as $this->config['rootLine']\n        $sysTemplateRowsIndexedByPid = array_combine(array_column($sysTemplateRows, 'pid'), $sysTemplateRows);\n        $localRootline = [];\n        foreach ($this->rootLine as $rootlinePage) {\n            array_unshift($localRootline, $rootlinePage);\n            if ((int)($rootlinePage['uid'] ?? 0) > 0\n                && (int)($sysTemplateRowsIndexedByPid[$rootlinePage['uid']]['root'] ?? 0) === 1\n            ) {\n                break;\n            }\n        }\n        // @deprecated: since v12, will be removed in v13: b/w compat. Remove when TemplateService is dropped.\n        $this->tmpl->rootLine = $localRootline;\n\n        $tokenizer = new LossyTokenizer();\n        $treeBuilder = GeneralUtility::makeInstance(SysTemplateTreeBuilder::class);\n        $includeTreeTraverser = new IncludeTreeTraverser();\n        $includeTreeTraverserConditionVerdictAware = new ConditionVerdictAwareIncludeTreeTraverser();\n        $frontendConditionMatcher = GeneralUtility::makeInstance(FrontendConditionMatcher::class, $this->context, $this->id, $this->rootLine);\n        $cacheManager = GeneralUtility::makeInstance(CacheManager::class);\n        /** @var PhpFrontend|null $typoscriptCache */\n        $typoscriptCache = null;\n        if (!$this->no_cache) {\n            // $this->no_cache = true might have been set by earlier TypoScriptFrontendInitialization middleware.\n            // This means we don't do fancy cache stuff, calculate full TypoScript and ignore page cache.\n            /** @var PhpFrontend|null $typoscriptCache */\n            $typoscriptCache = $cacheManager->getCache('typoscript');\n        }\n\n        // We *always* need the TypoScript constants, one way or the other: Setup conditions can use constants,\n        // so we need the constants to substitute their values within setup conditions.\n        $constantConditionIncludeListCacheIdentifier = 'constant-condition-include-list-' . sha1($serializedSysTemplateRows);\n        $constantConditionList = [];\n        $constantsAst = new RootNode();\n        $flatConstants = [];\n        $serializedConstantConditionList = '';\n        $gotConstantFromCache = false;\n        if (!$this->no_cache && $constantConditionIncludeTree = $typoscriptCache->require($constantConditionIncludeListCacheIdentifier)) {\n            // We got the flat list of all constants conditions for this TypoScript combination from cache. Good. We traverse\n            // this list to calculate \"current\" condition verdicts. With a hash of this list together with a hash of the\n            // TypoScript sys_templates, we try to retrieve the full constants TypoScript from cache.\n            $conditionMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $conditionMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverser->addVisitor($conditionMatcherVisitor);\n            // It does not matter if we use IncludeTreeTraverser or ConditionVerdictAwareIncludeTreeTraverser here:\n            // Condition list is flat, not nested. IncludeTreeTraverser has an if() less, so we use that one.\n            $includeTreeTraverser->traverse($constantConditionIncludeTree);\n            $constantConditionList = $conditionMatcherVisitor->getConditionListWithVerdicts();\n            // Needed for cache identifier calculations. Put into a variable here to not serialize multiple times.\n            $serializedConstantConditionList = serialize($constantConditionList);\n            $constantCacheEntryIdentifier = 'constant-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList);\n            $constantsCacheEntry = $typoscriptCache->require($constantCacheEntryIdentifier);\n            if (is_array($constantsCacheEntry)) {\n                $constantsAst = $constantsCacheEntry['ast'];\n                $flatConstants = $constantsCacheEntry['flatConstants'];\n                $gotConstantFromCache = true;\n            }\n        }\n        if ($this->no_cache || !$gotConstantFromCache) {\n            // We did not get constants from cache, or are not allowed to use cache. We have to build constants from scratch.\n            // This means we'll fetch the full constants include tree (from cache if possible), register the condition\n            // matcher and register the AST builder and traverse include tree to retrieve constants AST and calculate\n            // 'flat constants' from it. Both are cached if allowed afterwards for the 'if' above to kick in next time.\n            if ($this->no_cache) {\n                // Note $typoscriptCache *is not* hand over here: IncludeTree is calculated from scratch, we're not allowed to use cache.\n                $constantIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('constants', $sysTemplateRows, $tokenizer, $this->getSite());\n            } else {\n                // Note $typoscriptCache *is* hand over here, we can potentially grab the fully cached includeTree here, or cache entry will be created.\n                $constantIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('constants', $sysTemplateRows, $tokenizer, $this->getSite(), $typoscriptCache);\n            }\n            $conditionMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $conditionMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverserConditionVerdictAware->addVisitor($conditionMatcherVisitor);\n            $constantAstBuilderVisitor = GeneralUtility::makeInstance(IncludeTreeAstBuilderVisitor::class);\n            $includeTreeTraverserConditionVerdictAware->addVisitor($constantAstBuilderVisitor);\n            // We must use ConditionVerdictAwareIncludeTreeTraverser here: This one does not walk into\n            // children for not matching conditions, which is important to create the correct AST.\n            $includeTreeTraverserConditionVerdictAware->traverse($constantIncludeTree);\n            $constantsAst = $constantAstBuilderVisitor->getAst();\n            $flatConstants = $constantsAst->flatten();\n            if (!$this->no_cache) {\n                // We are allowed to cache and can create both the full list of conditions, plus the constant AST and flat constant\n                // list cache entry. To do that, we need all (!) conditions, but the above ConditionVerdictAwareIncludeTreeTraverser\n                // did not find nested conditions if an upper condition did not match. We thus have to traverse include tree a\n                // second time with the IncludeTreeTraverser that does traverse into not matching conditions as well.\n                $includeTreeTraverser->resetVisitors();\n                $conditionMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n                $conditionMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n                $includeTreeTraverser->addVisitor($conditionMatcherVisitor);\n                $constantConditionIncludeListAccumulatorVisitor = new IncludeTreeConditionIncludeListAccumulatorVisitor();\n                $includeTreeTraverser->addVisitor($constantConditionIncludeListAccumulatorVisitor);\n                $includeTreeTraverser->traverse($constantIncludeTree);\n                $constantConditionList = $conditionMatcherVisitor->getConditionListWithVerdicts();\n                // Needed for cache identifier calculations. Put into a variable here to not serialize multiple times.\n                $serializedConstantConditionList = serialize($constantConditionList);\n                $typoscriptCache->set($constantConditionIncludeListCacheIdentifier, 'return unserialize(\\'' . addcslashes(serialize($constantConditionIncludeListAccumulatorVisitor->getConditionIncludes()), '\\'\\\\') . '\\');');\n                $constantCacheEntryIdentifier = 'constant-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList);\n                $typoscriptCache->set($constantCacheEntryIdentifier, 'return unserialize(\\'' . addcslashes(serialize(['ast' => $constantsAst, 'flatConstants' => $flatConstants]), '\\'\\\\') . '\\');');\n            }\n        }\n\n        $frontendTypoScript = new FrontendTypoScript($constantsAst, $flatConstants);\n\n        // Next step: We have constants and fetch the setup include tree now. We then calculate setup condition verdicts\n        // and set the constants to allow substitution of constants within conditions. Next, we traverse include tree\n        // to calculate conditions verdicts and gather them along the way. A hash of these conditions with their verdicts\n        // is then part of the page cache identifier hash: When a condition on a page creates a different result, the hash\n        // is different from an existing page cache entry and a new one is created later.\n        $setupConditionIncludeListCacheIdentifier = 'setup-condition-include-list-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList);\n        $setupConditionList = [];\n        $gotSetupConditionsFromCache = false;\n        if (!$this->no_cache && $setupConditionIncludeTree = $typoscriptCache->require($setupConditionIncludeListCacheIdentifier)) {\n            // We got the flat list of all setup conditions for this TypoScript combination from cache. Good. We traverse\n            // this list to calculate \"current\" condition verdicts, which we need as hash to be part of page cache identifier.\n            $includeTreeTraverser->resetVisitors();\n            $setupConditionConstantSubstitutionVisitor = new IncludeTreeSetupConditionConstantSubstitutionVisitor();\n            $setupConditionConstantSubstitutionVisitor->setFlattenedConstants($flatConstants);\n            $includeTreeTraverser->addVisitor($setupConditionConstantSubstitutionVisitor);\n            $setupMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $setupMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverser->addVisitor($setupMatcherVisitor);\n            // It does not matter if we use IncludeTreeTraverser or ConditionVerdictAwareIncludeTreeTraverser here:\n            // Condition list is flat, not nested. IncludeTreeTraverser has an if() less, so we use that one.\n            $includeTreeTraverser->traverse($setupConditionIncludeTree);\n            $setupConditionList = $setupMatcherVisitor->getConditionListWithVerdicts();\n            $gotSetupConditionsFromCache = true;\n        }\n        if ($this->no_cache || !$gotSetupConditionsFromCache) {\n            // We did not get setup condition list from cache, or are not allowed to use cache. We have to build setup\n            // condition list from scratch. This means we'll fetch the full setup include tree (from cache if possible),\n            // register the constant substitution visitor, and register condition matcher and register the condition\n            // accumulator visitor.\n            if ($this->no_cache) {\n                // Note $typoscriptCache *is not* hand over here: IncludeTree is calculated from scratch, we're not allowed to use cache.\n                $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite());\n            } else {\n                // Note $typoscriptCache *is* hand over here, we can potentially grab the fully cached includeTree here, or cache entry will be created.\n                $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite(), $typoscriptCache);\n            }\n            $includeTreeTraverser->resetVisitors();\n            $setupConditionConstantSubstitutionVisitor = new IncludeTreeSetupConditionConstantSubstitutionVisitor();\n            $setupConditionConstantSubstitutionVisitor->setFlattenedConstants($flatConstants);\n            $includeTreeTraverser->addVisitor($setupConditionConstantSubstitutionVisitor);\n            $setupMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n            $setupMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n            $includeTreeTraverser->addVisitor($setupMatcherVisitor);\n            $setupConditionIncludeListAccumulatorVisitor = new IncludeTreeConditionIncludeListAccumulatorVisitor();\n            $includeTreeTraverser->addVisitor($setupConditionIncludeListAccumulatorVisitor);\n            // It is important we use IncludeTreeTraverser here: We to have the condition verdicts of *all* conditions, plus\n            // want to accumulate all of them. The ConditionVerdictAwareIncludeTreeTraverser wouldn't walk into nested\n            // conditions if an upper one does not match.\n            $includeTreeTraverser->traverse($setupIncludeTree);\n            $setupConditionList = $setupMatcherVisitor->getConditionListWithVerdicts();\n            if (!$this->no_cache) {\n                $typoscriptCache->set($setupConditionIncludeListCacheIdentifier, 'return unserialize(\\'' . addcslashes(serialize($setupConditionIncludeListAccumulatorVisitor->getConditionIncludes()), '\\'\\\\') . '\\');');\n            }\n        }\n\n        // We now gathered everything to calculate the page cache identifier: It depends on sys_template rows, the calculated\n        // constant condition verdicts, the setup condition verdicts, plus various not TypoScript related details like\n        // obviously the page id.\n        $this->lock = GeneralUtility::makeInstance(ResourceMutex::class);\n        $this->newHash = $this->createHashBase($sysTemplateRows, $constantConditionList, $setupConditionList);\n        if (!$this->no_cache) {\n            if ($this->shouldAcquireCacheData($request)) {\n                // Try to get a page cache row.\n                $this->getTimeTracker()->push('Cache Row');\n                $pageCacheRow = $this->pageCache->get($this->newHash);\n                if (!is_array($pageCacheRow)) {\n                    // Nothing in the cache, we acquire an exclusive lock now.\n                    // There are two scenarios when locking: We're either the first process acquiring this lock. This means we'll\n                    // \"immediately\" get it and can continue with page rendering. Or, another process acquired the lock already. In\n                    // this case, the below call will wait until the lock is released again. The other process then probably wrote\n                    // a page cache entry, which we can use.\n                    // To handle the second case - if our process had to wait for another one creating the content for us - we\n                    // simply query the page cache again to see if there is a page cache now.\n                    $hadToWaitForLock = $this->lock->acquireLock('pages', $this->newHash);\n                    // From this point on we're the only one working on that page.\n                    if ($hadToWaitForLock) {\n                        // Query the cache again to see if the data is there meanwhile: We did not get the lock\n                        // immediately, chances are high the other process created a page cache for us.\n                        // There is a small chance the other process actually pageCache->set() the content,\n                        // but pageCache->get() still returns false, for instance when a database returned \"done\"\n                        // for the INSERT, but SELECT still does not return the new row - may happen in multi-head\n                        // DB instances, and with some other distributed cache backends as well. The worst that\n                        // can happen here is the page generation is done too often, which we accept as trade-off.\n                        $pageCacheRow = $this->pageCache->get($this->newHash);\n                        if (is_array($pageCacheRow)) {\n                            // We have the content, some other process did the work for us, release our lock again.\n                            $this->releaseLocks();\n                        }\n                    }\n                    // We keep the lock set, because we are the ones generating the page now and filling the cache.\n                    // This indicates that we have to release the lock later in releaseLocks()!\n                }\n                if (is_array($pageCacheRow)) {\n                    // Note this especially populates $this->config!\n                    $this->populatePageDataFromCache($pageCacheRow);\n                }\n                $this->getTimeTracker()->pull();\n            } else {\n                // User forced page cache rebuilding. Get a lock for the page content so other processes can't interfere.\n                $this->lock->acquireLock('pages', $this->newHash);\n            }\n        } else {\n            // Caching is not allowed. We'll rebuild the page. Lock this.\n            $this->lock->acquireLock('pages', $this->newHash);\n        }\n\n        $forceTemplateParsing = $this->context->getPropertyFromAspect('typoscript', 'forcedTemplateParsing');\n        if ($this->no_cache || empty($this->config) || $this->isINTincScript() || $forceTemplateParsing) {\n            // We don't need the full setup AST in many cached scenarios. However, if no_cache is set, if no page cache\n            // entry could be loaded, if the page cache entry has _INT object, or if the user forced template\n            // parsing (adminpanel), then we still need the full setup AST. If there is \"just\" an _INT object, we can\n            // use a possible cache entry for the setup AST, which speeds up _INT parsing quite a bit. In other cases\n            // we calculate full setup AST and cache it if allowed.\n            $setupTypoScriptCacheIdentifier = 'setup-' . sha1($serializedSysTemplateRows . $serializedConstantConditionList . serialize($setupConditionList));\n            $gotSetupFromCache = false;\n            $setupArray = [];\n            if (!$this->no_cache && !$forceTemplateParsing) {\n                // We need AST, but we are allowed to potentially get it from cache.\n                if ($setupTypoScriptCache = $typoscriptCache->require($setupTypoScriptCacheIdentifier)) {\n                    $frontendTypoScript->setSetupTree($setupTypoScriptCache['ast']);\n                    $setupArray = $setupTypoScriptCache['array'];\n                    $gotSetupFromCache = true;\n                }\n            }\n            if ($this->no_cache || $forceTemplateParsing || !$gotSetupFromCache) {\n                // We need AST and couldn't get it from cache or are now allowed to. We thus need the full setup\n                // IncludeTree, which we can get from cache again if allowed, or is calculated a-new if not.\n                if ($this->no_cache || $forceTemplateParsing) {\n                    // Note $typoscriptCache *is not* hand over here: IncludeTree is calculated from scratch, we're not allowed to use cache.\n                    $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite());\n                } else {\n                    // Note $typoscriptCache *is* hand over here, we can potentially grab the fully cached includeTree here, or cache entry will be created.\n                    $setupIncludeTree = $treeBuilder->getTreeBySysTemplateRowsAndSite('setup', $sysTemplateRows, $tokenizer, $this->getSite(), $typoscriptCache);\n                }\n                $includeTreeTraverserConditionVerdictAware->resetVisitors();\n                $setupConditionConstantSubstitutionVisitor = new IncludeTreeSetupConditionConstantSubstitutionVisitor();\n                $setupConditionConstantSubstitutionVisitor->setFlattenedConstants($flatConstants);\n                $includeTreeTraverserConditionVerdictAware->addVisitor($setupConditionConstantSubstitutionVisitor);\n                $setupMatcherVisitor = new IncludeTreeConditionMatcherVisitor();\n                $setupMatcherVisitor->setConditionMatcher($frontendConditionMatcher);\n                $includeTreeTraverserConditionVerdictAware->addVisitor($setupMatcherVisitor);\n                $setupAstBuilderVisitor = GeneralUtility::makeInstance(IncludeTreeAstBuilderVisitor::class);\n                $setupAstBuilderVisitor->setFlatConstants($flatConstants);\n                $includeTreeTraverserConditionVerdictAware->addVisitor($setupAstBuilderVisitor);\n                $includeTreeTraverserConditionVerdictAware->traverse($setupIncludeTree);\n                $setupAst = $setupAstBuilderVisitor->getAst();\n                $frontendTypoScript->setSetupTree($setupAst);\n\n                // Create top-level setup AST 'types' node from all top-level PAGE objects.\n                // This is essentially a preparation for type-lookup below and should vanish later.\n                $typesNode = new ChildNode('types');\n                $gotTypeNumZero = false;\n                foreach ($setupAst->getNextChild() as $setupChild) {\n                    if ($setupChild->getValue() === 'PAGE') {\n                        $typeNumChild = $setupChild->getChildByName('typeNum');\n                        if ($typeNumChild) {\n                            $typeNumValue = $typeNumChild->getValue();\n                            $typesSubNode = new ChildNode($typeNumValue);\n                            $typesSubNode->setValue($setupChild->getName());\n                            $typesNode->addChild($typesSubNode);\n                            if ($typeNumValue === '0') {\n                                $gotTypeNumZero = true;\n                            }\n                        } elseif (!$gotTypeNumZero) {\n                            // The first PAGE node that has no typeNum = 0 is considered '0' automatically.\n                            $typesSubNode = new ChildNode('0');\n                            $typesSubNode->setValue($setupChild->getName());\n                            $typesNode->addChild($typesSubNode);\n                            $gotTypeNumZero = true;\n                        }\n                    }\n                }\n                if ($typesNode->hasChildren()) {\n                    $setupAst->addChild($typesNode);\n                }\n                $setupArray = $setupAst->toArray();\n                if (!$this->no_cache && !$forceTemplateParsing) {\n                    // Write cache entry for AST and its array representation, we're allowed to do it.\n                    $typoscriptCache->set($setupTypoScriptCacheIdentifier, 'return unserialize(\\'' . addcslashes(serialize(['ast' => $setupAst, 'array' => $setupArray]), '\\'\\\\') . '\\');');\n                }\n            }\n\n            $typoScriptPageTypeName = $setupArray['types.'][$this->type] ?? '';\n            $this->pSetup = $setupArray[$typoScriptPageTypeName . '.'] ?? '';\n\n            if (!is_array($this->pSetup)) {\n                $this->logger->alert('The page is not configured! [type={type}][{type_name}].', ['type' => $this->type, 'type_name' => $typoScriptPageTypeName]);\n                try {\n                    $message = 'The page is not configured! [type=' . $this->type . '][' . $typoScriptPageTypeName . '].';\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->internalErrorAction(\n                        $request,\n                        $message,\n                        ['code' => PageAccessFailureReasons::RENDERING_INSTRUCTIONS_NOT_CONFIGURED]\n                    );\n                    throw new PropagateResponseException($response, 1533931374);\n                } catch (AbstractServerErrorException $e) {\n                    $explanation = 'This means that there is no TypoScript object of type PAGE with typeNum=' . $this->type . ' configured.';\n                    $exceptionClass = get_class($e);\n                    throw new $exceptionClass($message . ' ' . $explanation, 1294587217);\n                }\n            }\n\n            if (!isset($this->config['config'])) {\n                $this->config['config'] = [];\n            }\n            // Filling the config-array, first with the main \"config.\" part\n            if (is_array($setupArray['config.'] ?? null)) {\n                // @todo: These operations should happen on AST instead and array is exported (and cached) afterwards\n                $setupArray['config.'] = array_replace_recursive($setupArray['config.'], $this->config['config']);\n                $this->config['config'] = $setupArray['config.'];\n            }\n            // Override it with the page/type-specific \"config.\"\n            if (is_array($this->pSetup['config.'] ?? null)) {\n                $this->config['config'] = array_replace_recursive($this->config['config'], $this->pSetup['config.']);\n            }\n            $this->config['rootLine'] = $localRootline;\n            $frontendTypoScript->setSetupArray($setupArray);\n\n            // @deprecated: since v12, will be removed in v13: b/w compat. Remove when TemplateService is dropped.\n            $this->tmpl->setup = $setupArray;\n            $this->tmpl->loaded = true;\n            $this->tmpl->flatSetup = $flatConstants;\n        }\n\n        // Set $this->no_cache TRUE if the config.no_cache value is set!\n        if (!$this->no_cache && ($this->config['config']['no_cache'] ?? false)) {\n            $this->set_no_cache('config.no_cache is set', true);\n        }\n\n        // Auto-configure settings when a site is configured\n        $this->config['config']['absRefPrefix'] = $this->config['config']['absRefPrefix'] ?? 'auto';\n\n        // Hook for postProcessing the configuration array\n        $params = ['config' => &$this->config['config']];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS']['tslib/class.tslib_fe.php']['configArrayPostProc'] ?? [] as $funcRef) {\n            GeneralUtility::callUserFunction($funcRef, $params, $this);\n        }\n\n        return $request->withAttribute('frontend.typoscript', $frontendTypoScript);\n    }\n\n    /**\n     * This method properly sets the values given from the pages cache into the corresponding\n     * TSFE variables. The counterpart is setPageCacheContent() where all relevant information is fetched.\n     * This also contains all data that could be cached, even for pages that are partially cached, as they\n     * have non-cacheable content still to be rendered.\n     *\n     * @see getFromCache()\n     * @see setPageCacheContent()\n     * @internal\n     */\n    protected function populatePageDataFromCache(array $cachedData): void\n    {\n        // Call hook when a page is retrieved from cache\n        $_params = ['pObj' => &$this, 'cache_pages_row' => &$cachedData];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS']['tslib/class.tslib_fe.php']['pageLoadedFromCache'] ?? [] as $_funcRef) {\n            GeneralUtility::callUserFunction($_funcRef, $_params, $this);\n        }\n        // Fetches the lowlevel config stored with the cached data\n        $this->config = $cachedData['cache_data'];\n        // Getting the content\n        $this->content = $cachedData['content'];\n        // Getting the content type\n        $this->contentType = $cachedData['contentType'] ?? $this->contentType;\n        // Setting flag, so we know, that some cached content has been loaded\n        $this->pageContentWasLoadedFromCache = true;\n        $this->cacheExpires = $cachedData['expires'];\n        // Restore the current tags as they can be retrieved by getPageCacheTags()\n        $this->pageCacheTags = $cachedData['cacheTags'] ?? [];\n\n        if (isset($this->config['config']['debug'])) {\n            $debugCacheTime = (bool)$this->config['config']['debug'];\n        } else {\n            $debugCacheTime = !empty($GLOBALS['TYPO3_CONF_VARS']['FE']['debug']);\n        }\n        if ($debugCacheTime) {\n            $dateFormat = $GLOBALS['TYPO3_CONF_VARS']['SYS']['ddmmyy'];\n            $timeFormat = $GLOBALS['TYPO3_CONF_VARS']['SYS']['hhmm'];\n            $this->debugInformationHeader = 'Cached page generated ' . date($dateFormat . ' ' . $timeFormat, $cachedData['tstamp'])\n                . '. Expires ' . date($dateFormat . ' ' . $timeFormat, $cachedData['expires']);\n        }\n    }\n\n    /**\n     * Detecting if shift-reload has been clicked.\n     * This option will have no effect if re-generation of page happens by other reasons (for instance that the page is not in cache yet).\n     * Also, a backend user MUST be logged in for the shift-reload to be detected due to DoS-attack-security reasons.\n     *\n     * @return bool If shift-reload in client browser has been clicked, disable getting cached page and regenerate the page content.\n     * @internal\n     */\n    protected function shouldAcquireCacheData(ServerRequestInterface $request): bool\n    {\n        // Trigger event for possible by-pass of requiring of page cache (for re-caching purposes)\n        $event = new ShouldUseCachedPageDataIfAvailableEvent($request, $this, !$this->no_cache);\n        GeneralUtility::makeInstance(EventDispatcherInterface::class)->dispatch($event);\n        return $event->shouldUseCachedPageData();\n    }\n\n    /**\n     * This creates a hash used as page cache entry identifier and as page generation lock.\n     * When multiple requests try to render the same page that will result in the same page cache entry,\n     * this lock allows creation by one request which typically puts the result into page cache, while\n     * the other requests wait until this finished and re-use the result.\n     *\n     * This hash is unique to the TS template and constant and setup condition verdict,\n     * the variables ->id, ->type, list of frontend user groups, ->MP (Mount Points) and cHash array.\n     *\n     * @return string Page cache entry identifier also used as page generation lock\n     */\n    protected function createHashBase(array $sysTemplateRows, array $constantConditionList, array $setupConditionList): string\n    {\n        // Fetch the list of user groups\n        /** @var UserAspect $userAspect */\n        $userAspect = $this->context->getAspect('frontend.user');\n        $hashParameters = [\n            'id' => $this->id,\n            'type' => $this->type,\n            'groupIds' => (string)implode(',', $userAspect->getGroupIds()),\n            'MP' => (string)$this->MP,\n            'site' => $this->site->getIdentifier(),\n            // Ensure the language base is used for the hash base calculation as well, otherwise TypoScript and page-related rendering\n            // is not cached properly as we don't have any language-specific conditions anymore\n            'siteBase' => (string)$this->language->getBase(),\n            // additional variation trigger for static routes\n            'staticRouteArguments' => $this->pageArguments->getStaticArguments(),\n            // dynamic route arguments (if route was resolved)\n            'dynamicArguments' => $this->getRelevantParametersForCachingFromPageArguments($this->pageArguments),\n            'sysTemplateRows' => $sysTemplateRows,\n            'constantConditionList' => $constantConditionList,\n            'setupConditionList' => $setupConditionList,\n        ];\n        // Call hook to influence the hash calculation\n        $_params = [\n            'hashParameters' => &$hashParameters,\n        ];\n        foreach ($GLOBALS['TYPO3_CONF_VARS']['SC_OPTIONS']['tslib/class.tslib_fe.php']['createHashBase'] ?? [] as $_funcRef) {\n            GeneralUtility::callUserFunction($_funcRef, $_params, $this);\n        }\n        return $this->id . '_' . sha1(serialize($hashParameters));\n    }\n\n    /********************************************\n     *\n     * Further initialization and data processing\n     *\n     *******************************************/\n    /**\n     * Setting the language key that will be used by the current page.\n     * In this function it should be checked, 1) that this language exists, 2) that a page_overlay_record exists, .. and if not the default language, 0 (zero), should be set.\n     *\n     * @internal\n     */\n    protected function settingLanguage(ServerRequestInterface $request)\n    {\n        // Get values from site language\n        $languageAspect = LanguageAspectFactory::createFromSiteLanguage($this->language);\n\n        $languageId = $languageAspect->getId();\n        $languageContentId = $languageAspect->getContentId();\n\n        $pageTranslationVisibility = new PageTranslationVisibility((int)($this->page['l18n_cfg'] ?? 0));\n        // If the incoming language is set to another language than default\n        if ($languageAspect->getId() > 0) {\n            // Request the translation for the requested language\n            $olRec = $this->sys_page->getPageOverlay($this->page, $languageAspect);\n            $overlaidLanguageId = (int)($olRec['sys_language_uid'] ?? 0);\n            if ($overlaidLanguageId !== $languageAspect->getId()) {\n                // If requested translation is not available\n                if ($pageTranslationVisibility->shouldHideTranslationIfNoTranslatedRecordExists()) {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        'Page is not available in the requested language.',\n                        ['code' => PageAccessFailureReasons::LANGUAGE_NOT_AVAILABLE]\n                    );\n                    throw new PropagateResponseException($response, 1533931388);\n                }\n                switch ($languageAspect->getLegacyLanguageMode()) {\n                    case 'strict':\n                        $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                            $request,\n                            'Page is not available in the requested language (strict).',\n                            ['code' => PageAccessFailureReasons::LANGUAGE_NOT_AVAILABLE_STRICT_MODE]\n                        );\n                        throw new PropagateResponseException($response, 1533931395);\n                    case 'content_fallback':\n                        // Setting content uid (but leaving the sys_language_uid) when a content_fallback\n                        // value was found.\n                        foreach ($languageAspect->getFallbackChain() as $orderValue) {\n                            if ($orderValue === '0' || $orderValue === 0 || $orderValue === '') {\n                                $languageContentId = 0;\n                                break;\n                            }\n                            if (MathUtility::canBeInterpretedAsInteger($orderValue) && $overlaidLanguageId === (int)$orderValue) {\n                                $languageContentId = (int)$orderValue;\n                                break;\n                            }\n                            if ($orderValue === 'pageNotFound') {\n                                // The existing fallbacks have not been found, but instead of continuing\n                                // page rendering with default language, a \"page not found\" message should be shown\n                                // instead.\n                                $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                                    $request,\n                                    'Page is not available in the requested language (fallbacks did not apply).',\n                                    ['code' => PageAccessFailureReasons::LANGUAGE_AND_FALLBACKS_NOT_AVAILABLE]\n                                );\n                                throw new PropagateResponseException($response, 1533931402);\n                            }\n                        }\n                        break;\n                    default:\n                        // Default is that everything defaults to the default language...\n                        $languageId = ($languageContentId = 0);\n                }\n            }\n\n            // Define the language aspect again now\n            $languageAspect = GeneralUtility::makeInstance(\n                LanguageAspect::class,\n                $languageId,\n                $languageContentId,\n                $languageAspect->getOverlayType(),\n                $languageAspect->getFallbackChain()\n            );\n\n            // Setting the $this->page if an overlay record was found (which it is only if a language is used)\n            // Doing this ensures that page properties like the page title are resolved in the correct language\n            $this->page = $olRec;\n        }\n\n        // Set the language aspect\n        $this->context->setAspect('language', $languageAspect);\n\n        // Setting sys_language_uid inside sys-page by creating a new page repository\n        $this->sys_page = GeneralUtility::makeInstance(PageRepository::class, $this->context);\n        // If default language is not available\n        if ((!$languageAspect->getContentId() || !$languageAspect->getId())\n            && $pageTranslationVisibility->shouldBeHiddenInDefaultLanguage()\n        ) {\n            $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                $request,\n                'Page is not available in default language.',\n                ['code' => PageAccessFailureReasons::LANGUAGE_DEFAULT_NOT_AVAILABLE]\n            );\n            throw new PropagateResponseException($response, 1533931423);\n        }\n\n        if ($languageAspect->getId() > 0) {\n            $this->updateRootLinesWithTranslations();\n        }\n    }\n\n    /**\n     * Updating content of the two rootLines IF the language key is set!\n     */\n    protected function updateRootLinesWithTranslations()\n    {\n        try {\n            $this->rootLine = GeneralUtility::makeInstance(RootlineUtility::class, $this->id, $this->MP, $this->context)->get();\n        } catch (RootLineException $e) {\n            $this->rootLine = [];\n        }\n    }\n\n    /**\n     * Calculates and sets the internal linkVars based upon the current request parameters\n     * and the setting \"config.linkVars\".\n     *\n     * @param array $queryParams $_GET (usually called with a PSR-7 $request->getQueryParams())\n     */\n    public function calculateLinkVars(array $queryParams)\n    {\n        $this->linkVars = GeneralUtility::makeInstance(LinkVarsCalculator::class)\n            ->getAllowedLinkVarsFromRequest(\n                (string)($this->config['config']['linkVars'] ?? ''),\n                $queryParams,\n                $this->context\n            );\n    }\n\n    /**\n     * Returns URI of target page, if the current page is an overlaid mountpoint.\n     *\n     * If the current page is of type mountpoint and should be overlaid with the contents of the mountpoint page\n     * and is accessed directly, the user will be redirected to the mountpoint context.\n     * @internal\n     * @param ServerRequestInterface $request\n     */\n    public function getRedirectUriForMountPoint(ServerRequestInterface $request): ?string\n    {\n        if (!empty($this->originalMountPointPage) && (int)$this->originalMountPointPage['doktype'] === PageRepository::DOKTYPE_MOUNTPOINT) {\n            return $this->getUriToCurrentPageForRedirect($request);\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns URI of target page, if the current page is a Shortcut.\n     *\n     * If the current page is of type shortcut and accessed directly via its URL,\n     * the user will be redirected to shortcut target.\n     *\n     * @internal\n     * @param ServerRequestInterface $request\n     */\n    public function getRedirectUriForShortcut(ServerRequestInterface $request): ?string\n    {\n        if (!empty($this->originalShortcutPage) && $this->originalShortcutPage['doktype'] == PageRepository::DOKTYPE_SHORTCUT) {\n            // Check if the shortcut page is actually on the current site, if not, this is a \"page not found\"\n            // because the request was www.mydomain.com/?id=23 where page ID 23 (which is a shortcut) is on another domain/site.\n            if ((int)($request->getQueryParams()['id'] ?? 0) > 0) {\n                try {\n                    $site = GeneralUtility::makeInstance(SiteFinder::class)->getSiteByPageId($this->originalShortcutPage['l10n_parent'] ?: $this->originalShortcutPage['uid']);\n                } catch (SiteNotFoundException $e) {\n                    $site = null;\n                }\n                if ($site !== $this->site) {\n                    $response = GeneralUtility::makeInstance(ErrorController::class)->pageNotFoundAction(\n                        $request,\n                        'ID was outside the domain',\n                        $this->getPageAccessFailureReasons(PageAccessFailureReasons::ACCESS_DENIED_HOST_PAGE_MISMATCH)\n                    );\n                    throw new ImmediateResponseException($response, 1638022483);\n                }\n            }\n            return $this->getUriToCurrentPageForRedirect($request);\n        }\n\n        return null;\n    }\n\n    /**\n     * Instantiate \\TYPO3\\CMS\\Frontend\\ContentObject to generate the correct target URL\n     */\n    protected function getUriToCurrentPageForRedirect(ServerRequestInterface $request): string\n    {\n        $this->calculateLinkVars($request->getQueryParams());\n        $parameter = $this->page['uid'];\n        if ($this->type) {\n            $parameter .= ',' . $this->type;\n        }\n        return GeneralUtility::makeInstance(ContentObjectRenderer::class, $this)->createUrl([\n            'parameter' => $parameter,\n            'addQueryString' => 'untrusted',\n            'addQueryString.' => ['exclude' => 'id,type'],\n            'forceAbsoluteUrl' => true,\n        ]);\n    }\n\n    /********************************************\n     *\n     * Page generation; cache handling\n     *\n     *******************************************/\n    /**\n     * Returns TRUE if the page content should be generated.\n     */\n    public function isGeneratePage(): bool\n    {\n        return !$this->pageContentWasLoadedFromCache;\n    }\n\n    /**\n     * Sets cache content; Inserts the content string into the pages cache.\n     *\n     * @param string $content The content to store in the HTML field of the cache table\n     * @param array $data The additional cache_data array, fx. $this->config\n     * @param int $expirationTstamp Expiration timestamp\n     * @see populatePageDataFromCache()\n     */\n    protected function setPageCacheContent(string $content, array $data, int $expirationTstamp): array\n    {\n        $cacheData = [\n            'page_id' => $this->id,\n            'content' => $content,\n            'contentType' => $this->contentType,\n            'cache_data' => $data,\n            'expires' => $expirationTstamp,\n            'tstamp' => $GLOBALS['EXEC_TIME'],\n        ];\n        $this->cacheExpires = $expirationTstamp;\n        $this->pageCacheTags[] = 'pageId_' . $this->id;\n        // Respect the page cache when content of pid is shown\n        if ($this->id !== $this->contentPid) {\n            $this->pageCacheTags[] = 'pageId_' . $this->contentPid;\n        }\n        if (!empty($this->page['cache_tags'])) {\n            $tags = GeneralUtility::trimExplode(',', $this->page['cache_tags'], true);\n            $this->pageCacheTags = array_merge($this->pageCacheTags, $tags);\n        }\n        $this->pageCacheTags = array_unique($this->pageCacheTags);\n        // Add the cache themselves as well, because they are fetched by getPageCacheTags()\n        $cacheData['cacheTags'] = $this->pageCacheTags;\n        $this->pageCache->set($this->newHash, $cacheData, $this->pageCacheTags, $expirationTstamp - $GLOBALS['EXEC_TIME']);\n        return $cacheData;\n    }\n\n    /**\n     * Clears cache content (for $this->newHash)\n     *\n     * @internal\n     */\n    public function clearPageCacheContent()\n    {\n        $this->pageCache->remove($this->newHash);\n    }\n\n    /**\n     * Setting the SYS_LASTCHANGED value in the pagerecord: This value will thus be set to the highest tstamp of records rendered on the page.\n     * This includes all records with no regard to hidden records, userprotection and so on.\n     *\n     * The important part is that this actually updates a translated \"pages\" record (_PAGES_OVERLAY_UID) if\n     * the Frontend is called with a translation.\n     *\n     * @see ContentObjectRenderer::lastChanged()\n     * @see setRegisterValueForSysLastChanged()\n     */\n    protected function setSysLastChanged()\n    {\n        // We only update the info if browsing the live workspace\n        $isInWorkspace = $this->context->getPropertyFromAspect('workspace', 'isOffline', false);\n        if ($isInWorkspace) {\n            return;\n        }\n        if ($this->page['SYS_LASTCHANGED'] < (int)$this->register['SYS_LASTCHANGED']) {\n            $connection = GeneralUtility::makeInstance(ConnectionPool::class)\n                ->getConnectionForTable('pages');\n            $pageId = $this->page['_PAGES_OVERLAY_UID'] ?? $this->id;\n            $connection->update(\n                'pages',\n                [\n                    'SYS_LASTCHANGED' => (int)$this->register['SYS_LASTCHANGED'],\n                ],\n                [\n                    'uid' => (int)$pageId,\n                ]\n            );\n        }\n    }\n\n    /**\n     * Set the SYS_LASTCHANGED register value, is also called when a translated page is in use,\n     * so the register reflects the state of the translated page, not the page in the default language.\n     *\n     * @internal\n     * @see setSysLastChanged()\n     */\n    protected function setRegisterValueForSysLastChanged(array $page): void\n    {\n        $this->register['SYS_LASTCHANGED'] = (int)$page['tstamp'];\n        if ($this->register['SYS_LASTCHANGED'] < (int)$page['SYS_LASTCHANGED']) {\n            $this->register['SYS_LASTCHANGED'] = (int)$page['SYS_LASTCHANGED'];\n        }\n    }\n\n    /**\n     * Adds tags to this page's cache entry, you can then f.e. remove cache\n     * entries by tag\n     *\n     * @param array $tags An array of tag\n     */\n    public function addCacheTags(array $tags)\n    {\n        $this->pageCacheTags = array_merge($this->pageCacheTags, $tags);\n    }\n\n    public function getPageCacheTags(): array\n    {\n        return $this->pageCacheTags;\n    }\n\n    /********************************************\n     *\n     * Page generation; rendering and inclusion\n     *\n     *******************************************/\n    /**\n     * Does some processing BEFORE the page content is generated / built.\n     */\n    public function generatePage_preProcessing()\n    {\n        // Used as a safety check in case a PHP script is falsely disabling $this->no_cache during page generation.\n        $this->no_cacheBeforePageGen = $this->no_cache;\n    }\n\n    /**\n     * Check the value of \"content_from_pid\" of the current page record, and see if the current request\n     * should actually show content from another page.\n     *\n     * By using $TSFE->getPageAndRootline() on the cloned object, all rootline restrictions (extendToSubPages)\n     * are evaluated as well.\n     *\n     * @param ServerRequestInterface $request\n     * @return int the current page ID or another one if resolved properly - usually set to $this->contentPid\n     */\n    protected function resolveContentPid(ServerRequestInterface $request): int\n    {\n        if (!isset($this->page['content_from_pid']) || empty($this->page['content_from_pid'])) {\n            return $this->id;\n        }\n        // make REAL copy of TSFE object - not reference!\n        $temp_copy_TSFE = clone $this;\n        // Set ->id to the content_from_pid value - we are going to evaluate this pid as was it a given id for a page-display!\n        $temp_copy_TSFE->id = (int)$this->page['content_from_pid'];\n        $temp_copy_TSFE->MP = '';\n        $temp_copy_TSFE->getPageAndRootline($request);\n        return $temp_copy_TSFE->id;\n    }\n    /**\n     * Sets up TypoScript \"config.\" options and set properties in $TSFE.\n     */\n    public function preparePageContentGeneration(ServerRequestInterface $request)\n    {\n        $this->getTimeTracker()->push('Prepare page content generation');\n        // @deprecated: these properties can be removed in TYPO3 v13.0\n        $this->baseUrl = (string)($this->config['config']['baseURL'] ?? '');\n        // Internal and External target defaults\n        $this->intTarget = (string)($this->config['config']['intTarget'] ?? '');\n        $this->extTarget = (string)($this->config['config']['extTarget'] ?? '');\n        $this->fileTarget = (string)($this->config['config']['fileTarget'] ?? '');\n        if (($this->config['config']['spamProtectEmailAddresses'] ?? '') === 'ascii') {\n            $this->logDeprecatedTyposcript('config.spamProtectEmailAddresses = ascii', 'This setting has no effect anymore. Change it to a number between -10 and 10 or remove it completely');\n            $this->config['config']['spamProtectEmailAddresses'] = 0;\n        }\n        // @deprecated: these properties can be removed in TYPO3 v13.0\n        $this->spamProtectEmailAddresses = (int)($this->config['config']['spamProtectEmailAddresses'] ?? 0);\n        $this->spamProtectEmailAddresses = MathUtility::forceIntegerInRange($this->spamProtectEmailAddresses, -10, 10, 0);\n        // calculate the absolute path prefix\n        if (!empty($this->absRefPrefix = trim($this->config['config']['absRefPrefix'] ?? ''))) {\n            if ($this->absRefPrefix === 'auto') {\n                $normalizedParams = $request->getAttribute('normalizedParams');\n                $this->absRefPrefix = $normalizedParams->getSitePath();\n            }\n        }\n        // config.forceAbsoluteUrls will override absRefPrefix\n        if ($this->config['config']['forceAbsoluteUrls'] ?? false) {\n            $normalizedParams = $request->getAttribute('normalizedParams');\n            $this->absRefPrefix = $normalizedParams->getSiteUrl();\n        }\n\n        // linkVars\n        $this->calculateLinkVars($request->getQueryParams());\n        // Setting XHTML-doctype from doctype\n        $this->config['config']['xhtmlDoctype'] = $this->config['config']['xhtmlDoctype'] ?? $this->config['config']['doctype'] ?? '';\n        $docType = DocType::createFromConfigurationKey($this->config['config']['xhtmlDoctype']);\n        $this->xhtmlDoctype = $docType->getXhtmlDocType();\n        $this->xhtmlVersion = $docType->getXhtmlVersion();\n        $this->pageRenderer->setDocType($docType);\n\n        // Global content object\n        $this->newCObj($request);\n        $this->getTimeTracker()->pull();\n    }\n\n    /**\n     * Does processing of the content after the page content was generated.\n     *\n     * This includes caching the page, indexing the page (if configured) and setting sysLastChanged\n     */\n    public function generatePage_postProcessing(ServerRequestInterface $request)\n    {\n        $this->setAbsRefPrefix();\n        // This is to ensure, that the page is NOT cached if the no_cache parameter was set before the page was generated.\n        // This is a safety precaution, as it could have been unset by some script.\n        if ($this->no_cacheBeforePageGen) {\n            $this->set_no_cache('no_cache has been set before the page was generated - safety check', true);\n        }\n        $eventDispatcher = GeneralUtility::makeInstance(EventDispatcherInterface::class);\n        $event = new AfterCacheableContentIsGeneratedEvent($request, $this, $this->newHash, !$this->no_cache);\n        $event = $eventDispatcher->dispatch($event);\n\n        // Processing if caching is enabled\n        if ($event->isCachingEnabled()) {\n            // Seconds until a cached page is too old\n            $cacheTimeout = $this->get_cache_timeout();\n            $timeOutTime = $GLOBALS['EXEC_TIME'] + $cacheTimeout;\n            // Write the page to cache\n            $cachedInformation = $this->setPageCacheContent($this->content, $this->config, $timeOutTime);\n\n            // Event for cache post processing (eg. writing static files)\n            $event = new AfterCachedPageIsPersistedEvent($request, $this, $this->newHash, $cachedInformation, $cacheTimeout);\n            $eventDispatcher->dispatch($event);\n        }\n        $this->setSysLastChanged();\n    }\n\n    /**\n     * Generate the page title, can be called multiple times,\n     * as PageTitleProvider might have been modified by an uncached plugin etc.\n     *\n     * @return string the generated page title\n     */\n    public function generatePageTitle(): string\n    {\n        // Check for a custom pageTitleSeparator, and perform stdWrap on it\n        $pageTitleSeparator = (string)$this->cObj->stdWrapValue('pageTitleSeparator', $this->config['config'] ?? []);\n        if ($pageTitleSeparator !== '' && $pageTitleSeparator === ($this->config['config']['pageTitleSeparator'] ?? '')) {\n            $pageTitleSeparator .= ' ';\n        }\n\n        $titleProvider = GeneralUtility::makeInstance(PageTitleProviderManager::class);\n        if (!empty($this->config['config']['pageTitleCache'])) {\n            $titleProvider->setPageTitleCache($this->config['config']['pageTitleCache']);\n        }\n        $pageTitle = $titleProvider->getTitle();\n        $this->config['config']['pageTitleCache'] = $titleProvider->getPageTitleCache();\n\n        $titleTagContent = $this->printTitle(\n            $pageTitle,\n            (bool)($this->config['config']['noPageTitle'] ?? false),\n            (bool)($this->config['config']['pageTitleFirst'] ?? false),\n            $pageTitleSeparator,\n            (bool)($this->config['config']['showWebsiteTitle'] ?? true)\n        );\n        $this->config['config']['pageTitle'] = $titleTagContent;\n        // stdWrap around the title tag\n        $titleTagContent = $this->cObj->stdWrapValue('pageTitle', $this->config['config']);\n\n        // config.noPageTitle = 2 - means do not render the page title\n        if (isset($this->config['config']['noPageTitle']) && (int)$this->config['config']['noPageTitle'] === 2) {\n            $titleTagContent = '';\n        }\n        if ($titleTagContent !== '') {\n            $this->pageRenderer->setTitle($titleTagContent);\n        }\n        return (string)$titleTagContent;\n    }\n\n    /**\n     * Compiles the content for the page <title> tag.\n     *\n     * @param string $pageTitle The input title string, typically the \"title\" field of a page's record.\n     * @param bool $noPageTitle If set, the page title will not be printed\n     * @param bool $showPageTitleFirst If set, website title and page title are swapped\n     * @param string $pageTitleSeparator an alternative to the \": \" as the separator between site title and page title\n     * @param bool $showWebsiteTitle If set, the website title will be printed\n     * @return string The page title on the form \"[website title]: [input-title]\". Not htmlspecialchar()'ed.\n     * @see generatePageTitle()\n     */\n    protected function printTitle(string $pageTitle, bool $noPageTitle = false, bool $showPageTitleFirst = false, string $pageTitleSeparator = '', bool $showWebsiteTitle = true): string\n    {\n        $websiteTitle = $showWebsiteTitle ? $this->getWebsiteTitle() : '';\n        $pageTitle = $noPageTitle ? '' : $pageTitle;\n        // only show a separator if there are both site title and page title\n        if ($pageTitle === '' || $websiteTitle === '') {\n            $pageTitleSeparator = '';\n        } elseif (empty($pageTitleSeparator)) {\n            // use the default separator if non given\n            $pageTitleSeparator = ': ';\n        }\n        if ($showPageTitleFirst) {\n            return $pageTitle . $pageTitleSeparator . $websiteTitle;\n        }\n        return $websiteTitle . $pageTitleSeparator . $pageTitle;\n    }\n\n    protected function getWebsiteTitle(): string\n    {\n        if (trim($this->language->getWebsiteTitle()) !== '') {\n            return trim($this->language->getWebsiteTitle());\n        }\n        if (trim($this->site->getConfiguration()['websiteTitle'] ?? '') !== '') {\n            return trim($this->site->getConfiguration()['websiteTitle']);\n        }\n\n        return '';\n    }\n\n    /**\n     * Processes the INTinclude-scripts\n     */\n    public function INTincScript(ServerRequestInterface $request): void\n    {\n        $this->additionalHeaderData = $this->config['INTincScript_ext']['additionalHeaderData'] ?? [];\n        $this->additionalFooterData = $this->config['INTincScript_ext']['additionalFooterData'] ?? [];\n        if (empty($this->config['INTincScript_ext']['pageRendererState'])) {\n            $this->initPageRenderer();\n        } else {\n            $pageRendererState = unserialize($this->config['INTincScript_ext']['pageRendererState'], ['allowed_classes' => false]);\n            $this->pageRenderer->updateState($pageRendererState);\n        }\n        if (!empty($this->config['INTincScript_ext']['assetCollectorState'])) {\n            $assetCollectorState = unserialize($this->config['INTincScript_ext']['assetCollectorState'], ['allowed_classes' => false]);\n            GeneralUtility::makeInstance(AssetCollector::class)->updateState($assetCollectorState);\n        }\n\n        $this->recursivelyReplaceIntPlaceholdersInContent($request);\n        $this->getTimeTracker()->push('Substitute header section');\n        $this->INTincScript_loadJSCode();\n        $this->generatePageTitle();\n\n        $this->content = str_replace(\n            [\n                '<!--HD_' . $this->config['INTincScript_ext']['divKey'] . '-->',\n                '<!--FD_' . $this->config['INTincScript_ext']['divKey'] . '-->',\n            ],\n            [\n                implode(LF, $this->additionalHeaderData),\n                implode(LF, $this->additionalFooterData),\n            ],\n            $this->pageRenderer->renderJavaScriptAndCssForProcessingOfUncachedContentObjects($this->content, $this->config['INTincScript_ext']['divKey'])\n        );\n        // Replace again, because header and footer data and page renderer replacements may introduce additional placeholders (see #44825)\n        $this->recursivelyReplaceIntPlaceholdersInContent($request);\n        $this->setAbsRefPrefix();\n        $this->getTimeTracker()->pull();\n    }\n\n    /**\n     * Replaces INT placeholders (COA_INT and USER_INT) in $this->content\n     * In case the replacement adds additional placeholders, it loops\n     * until no new placeholders are found any more.\n     */\n    protected function recursivelyReplaceIntPlaceholdersInContent(ServerRequestInterface $request)\n    {\n        do {\n            $nonCacheableData = $this->config['INTincScript'];\n            $this->processNonCacheableContentPartsAndSubstituteContentMarkers($nonCacheableData, $request);\n            // Check if there were new items added to INTincScript during the previous execution:\n            // array_diff_assoc throws notices if values are arrays but not strings. We suppress this here.\n            $nonCacheableData = @array_diff_assoc($this->config['INTincScript'], $nonCacheableData);\n            $reprocess = count($nonCacheableData) > 0;\n        } while ($reprocess);\n    }\n\n    /**\n     * Processes the INTinclude-scripts and substitute in content.\n     *\n     * Takes $this->content, and splits the content by <!--INT_SCRIPT.12345 --> and then puts the content\n     * back together.\n     *\n     * @param array $nonCacheableData $GLOBALS['TSFE']->config['INTincScript'] or part of it\n     * @see INTincScript()\n     */\n    protected function processNonCacheableContentPartsAndSubstituteContentMarkers(array $nonCacheableData, ServerRequestInterface $request)\n    {\n        $timeTracker = $this->getTimeTracker();\n        $timeTracker->push('Split content');\n        // Splits content with the key.\n        $contentSplitByUncacheableMarkers = explode('<!--INT_SCRIPT.', $this->content);\n        $this->content = '';\n        $timeTracker->setTSlogMessage('Parts: ' . count($contentSplitByUncacheableMarkers), LogLevel::INFO);\n        $timeTracker->pull();\n        foreach ($contentSplitByUncacheableMarkers as $counter => $contentPart) {\n            // If the split had a comment-end after 32 characters it's probably a split-string\n            if (substr($contentPart, 32, 3) === '-->') {\n                $nonCacheableKey = 'INT_SCRIPT.' . substr($contentPart, 0, 32);\n                if (is_array($nonCacheableData[$nonCacheableKey])) {\n                    $label = 'Include ' . $nonCacheableData[$nonCacheableKey]['type'];\n                    $timeTracker->push($label);\n                    $nonCacheableContent = '';\n                    $contentObjectRendererForNonCacheable = unserialize($nonCacheableData[$nonCacheableKey]['cObj']);\n                    /* @var ContentObjectRenderer $contentObjectRendererForNonCacheable */\n                    $contentObjectRendererForNonCacheable->setRequest($request);\n                    switch ($nonCacheableData[$nonCacheableKey]['type']) {\n                        case 'COA':\n                            $nonCacheableContent = $contentObjectRendererForNonCacheable->cObjGetSingle('COA', $nonCacheableData[$nonCacheableKey]['conf']);\n                            break;\n                        case 'FUNC':\n                            $nonCacheableContent = $contentObjectRendererForNonCacheable->cObjGetSingle('USER', $nonCacheableData[$nonCacheableKey]['conf']);\n                            break;\n                        case 'POSTUSERFUNC':\n                            $nonCacheableContent = $contentObjectRendererForNonCacheable->callUserFunction($nonCacheableData[$nonCacheableKey]['postUserFunc'], $nonCacheableData[$nonCacheableKey]['conf'], $nonCacheableData[$nonCacheableKey]['content']);\n                            break;\n                    }\n                    $this->content .= $nonCacheableContent;\n                    $this->content .= substr($contentPart, 35);\n                    $timeTracker->pull($nonCacheableContent);\n                } else {\n                    $this->content .= substr($contentPart, 35);\n                }\n            } elseif ($counter) {\n                // If it's not the first entry (which would be \"0\" of the array keys), then re-add the INT_SCRIPT part\n                $this->content .= '<!--INT_SCRIPT.' . $contentPart;\n            } else {\n                $this->content .= $contentPart;\n            }\n        }\n    }\n\n    /**\n     * Loads the JavaScript/CSS code for INTincScript, if there are non-cacheable content objects\n     * it prepares the placeholders, otherwise populates options directly.\n     *\n     * @internal this method should be renamed as it does not only handle JS, but all additional header data\n     */\n    public function INTincScript_loadJSCode()\n    {\n        // Prepare code and placeholders for additional header and footer files (and make sure that this isn't called twice)\n        if ($this->isINTincScript() && !isset($this->config['INTincScript_ext'])) {\n            $substituteHash = $this->uniqueHash();\n            $this->config['INTincScript_ext']['divKey'] = $substituteHash;\n            // Storing the header-data array\n            $this->config['INTincScript_ext']['additionalHeaderData'] = $this->additionalHeaderData;\n            // Storing the footer-data array\n            $this->config['INTincScript_ext']['additionalFooterData'] = $this->additionalFooterData;\n            // Clearing the array\n            $this->additionalHeaderData = ['<!--HD_' . $substituteHash . '-->'];\n            // Clearing the array\n            $this->additionalFooterData = ['<!--FD_' . $substituteHash . '-->'];\n        }\n    }\n\n    /**\n     * Determines if there are any INTincScripts to include = \"non-cacheable\" parts\n     *\n     * @return bool Returns TRUE if scripts are found\n     */\n    public function isINTincScript()\n    {\n        return !empty($this->config['INTincScript']) && is_array($this->config['INTincScript']);\n    }\n\n    /**\n     * Add HTTP headers to the response object.\n     */\n    public function applyHttpHeadersToResponse(ResponseInterface $response): ResponseInterface\n    {\n        // Set header for content-type + charset-encoding\n        $response = $response->withHeader('Content-Type', $this->contentType . '; charset=utf-8');\n        // Set header for content language unless disabled\n        $contentLanguage = (string)$this->language->getLocale();\n        if (empty($this->config['config']['disableLanguageHeader'])) {\n            $response = $response->withHeader('Content-Language', $contentLanguage);\n        }\n\n        // Add a Response header to show debug information if a page was fetched from cache\n        if ($this->debugInformationHeader) {\n            $response = $response->withHeader('X-TYPO3-Debug-Cache', $this->debugInformationHeader);\n        }\n\n        // Set cache related headers to client (used to enable proxy / client caching!)\n        if (!empty($this->config['config']['sendCacheHeaders'])) {\n            $headers = $this->getCacheHeaders();\n            foreach ($headers as $header => $value) {\n                $response = $response->withHeader($header, $value);\n            }\n        }\n        // Set additional headers if any have been configured via TypoScript\n        $additionalHeaders = $this->getAdditionalHeaders();\n        foreach ($additionalHeaders as $headerConfig) {\n            [$header, $value] = GeneralUtility::trimExplode(':', $headerConfig['header'], false, 2);\n            if ($headerConfig['statusCode']) {\n                $response = $response->withStatus((int)$headerConfig['statusCode']);\n            }\n            if ($headerConfig['replace']) {\n                $response = $response->withHeader($header, $value);\n            } else {\n                $response = $response->withAddedHeader($header, $value);\n            }\n        }\n        return $response;\n    }\n\n    /**\n     * Get cache headers good for client/reverse proxy caching.\n     */\n    protected function getCacheHeaders(): array\n    {\n        // Getting status whether we can send cache control headers for proxy caching:\n        $doCache = $this->isStaticCacheble();\n        $isBackendUserLoggedIn = $this->context->getPropertyFromAspect('backend.user', 'isLoggedIn', false);\n        $isInWorkspace = $this->context->getPropertyFromAspect('workspace', 'isOffline', false);\n        // Finally, when backend users are logged in, do not send cache headers at all (Admin Panel might be displayed for instance).\n        $isClientCachable = $doCache && !$isBackendUserLoggedIn && !$isInWorkspace;\n        if ($isClientCachable) {\n            $headers = [\n                'Expires' => gmdate('D, d M Y H:i:s T', $this->cacheExpires),\n                'ETag' => '\"' . md5($this->content) . '\"',\n                'Cache-Control' => 'max-age=' . ($this->cacheExpires - $GLOBALS['EXEC_TIME']),\n                // no-cache\n                'Pragma' => 'public',\n            ];\n        } else {\n            // \"no-store\" is used to ensure that the client HAS to ask the server every time, and is not allowed to store anything at all\n            $headers = [\n                'Cache-Control' => 'private, no-store',\n            ];\n            // Now, if a backend user is logged in, tell him in the Admin Panel log what the caching status would have been:\n            if ($isBackendUserLoggedIn) {\n                if ($doCache) {\n                    $this->getTimeTracker()->setTSlogMessage('Cache-headers with max-age \"' . ($this->cacheExpires - $GLOBALS['EXEC_TIME']) . '\" would have been sent');\n                } else {\n                    $reasonMsg = [];\n                    if ($this->no_cache) {\n                        $reasonMsg[] = 'Caching disabled (no_cache).';\n                    }\n                    if ($this->isINTincScript()) {\n                        $reasonMsg[] = '*_INT object(s) on page.';\n                    }\n                    if ($this->context->getPropertyFromAspect('frontend.user', 'isLoggedIn', false)) {\n                        $reasonMsg[] = 'Frontend user logged in.';\n                    }\n                    $this->getTimeTracker()->setTSlogMessage('Cache-headers would disable proxy caching! Reason(s): \"' . implode(' ', $reasonMsg) . '\"', LogLevel::NOTICE);\n                }\n            }\n        }\n        return $headers;\n    }\n\n    /**\n     * Reporting status whether we can send cache control headers for proxy caching or publishing to static files\n     *\n     * Rules are:\n     * no_cache cannot be set: If it is, the page might contain dynamic content and should never be cached.\n     * There can be no USER_INT objects on the page (\"isINTincScript()\") because they implicitly indicate dynamic content\n     * There can be no logged in user because user sessions are based on a cookie and thereby does not offer client caching a chance to know if the user is logged in. Actually, there will be a reverse problem here; If a page will somehow change when a user is logged in he may not see it correctly if the non-login version sent a cache-header! So do NOT use cache headers in page sections where user logins change the page content. (unless using such as realurl to apply a prefix in case of login sections)\n     *\n     * @return bool\n     */\n    public function isStaticCacheble()\n    {\n        return !$this->no_cache && !$this->isINTincScript() && !$this->context->getAspect('frontend.user')->isUserOrGroupSet();\n    }\n\n    /********************************************\n     *\n     * Various internal API functions\n     *\n     *******************************************/\n    /**\n     * Creates an instance of ContentObjectRenderer in $this->cObj\n     * This instance is used to start the rendering of the TypoScript template structure\n     *\n     * @param ServerRequestInterface|null $request\n     */\n    public function newCObj(ServerRequestInterface $request = null)\n    {\n        $this->cObj = GeneralUtility::makeInstance(ContentObjectRenderer::class, $this);\n        $this->cObj->start($this->page, 'pages', $request);\n    }\n\n    /**\n     * Converts relative paths in the HTML source to absolute paths for fileadmin/, typo3conf/ext/ and media/ folders.\n     *\n     * @internal\n     * @see \\TYPO3\\CMS\\Frontend\\Http\\RequestHandler\n     * @see INTincScript()\n     */\n    protected function setAbsRefPrefix()\n    {\n        if (!$this->absRefPrefix) {\n            return;\n        }\n        $encodedAbsRefPrefix = htmlspecialchars($this->absRefPrefix, ENT_QUOTES | ENT_HTML5);\n        $search = [\n            '\"_assets/',\n            '\"typo3temp/',\n            '\"' . PathUtility::stripPathSitePrefix(Environment::getExtensionsPath()) . '/',\n            '\"' . PathUtility::stripPathSitePrefix(Environment::getFrameworkBasePath()) . '/',\n        ];\n        $replace = [\n            '\"' . $encodedAbsRefPrefix . '_assets/',\n            '\"' . $encodedAbsRefPrefix . 'typo3temp/',\n            '\"' . $encodedAbsRefPrefix . PathUtility::stripPathSitePrefix(Environment::getExtensionsPath()) . '/',\n            '\"' . $encodedAbsRefPrefix . PathUtility::stripPathSitePrefix(Environment::getFrameworkBasePath()) . '/',\n        ];\n        // Process additional directories\n        $directories = GeneralUtility::trimExplode(',', $GLOBALS['TYPO3_CONF_VARS']['FE']['additionalAbsRefPrefixDirectories'], true);\n        foreach ($directories as $directory) {\n            $search[] = '\"' . $directory;\n            $replace[] = '\"' . $encodedAbsRefPrefix . $directory;\n        }\n        $this->content = str_replace(\n            $search,\n            $replace,\n            $this->content\n        );\n    }\n\n    /**\n     * Prefixing the input URL with ->baseUrl If ->baseUrl is set and the input url is not absolute in some way.\n     * Designed as a wrapper functions for use with all frontend links that are processed by JavaScript (for \"realurl\" compatibility!). So each time a URL goes into window.open, window.location.href or otherwise, wrap it with this function!\n     *\n     * @param string $url Input URL, relative or absolute\n     * @param bool $internal used for TYPO3 Core to avoid deprecation errors in v12 when calling this method directly.\n     * @return string Processed input value.\n     * @internal only for TYPO3 Core internal purposes. Might be removed at a later point as it was related to RealURL functionality.\n     * @deprecated will be removed in TYPO3 v13.0 along with config.baseURL\n     */\n    public function baseUrlWrap($url, bool $internal = false)\n    {\n        if (!$internal) {\n            trigger_error('Calling $TSFE->baseUrlWrap will not work anymore in TYPO3 v13.0. Use SiteHandling and config.forceAbsoluteUrls anymore, or build your own <base> tag via TypoScript headerData.', E_USER_DEPRECATED);\n        }\n        if ($this->config['config']['baseURL'] ?? false) {\n            $urlParts = parse_url($url);\n            if (empty($urlParts['scheme']) && $url[0] !== '/') {\n                $url = $this->config['config']['baseURL'] . $url;\n            }\n        }\n        return $url;\n    }\n\n    /**\n     * Logs access to deprecated TypoScript objects and properties.\n     *\n     * Dumps message to the TypoScript message log (admin panel) and the TYPO3 deprecation log.\n     *\n     * @param string $typoScriptProperty Deprecated object or property\n     * @param string $explanation Message or additional information\n     */\n    public function logDeprecatedTyposcript($typoScriptProperty, $explanation = '')\n    {\n        $explanationText = $explanation !== '' ? ' - ' . $explanation : '';\n        $this->getTimeTracker()->setTSlogMessage($typoScriptProperty . ' is deprecated.' . $explanationText, LogLevel::WARNING);\n        trigger_error('TypoScript property ' . $typoScriptProperty . ' is deprecated' . $explanationText, E_USER_DEPRECATED);\n    }\n\n    /********************************************\n     * PUBLIC ACCESSIBLE WORKSPACES FUNCTIONS\n     *******************************************/\n\n    /**\n     * Returns TRUE if workspace preview is enabled\n     *\n     * @return bool Returns TRUE if workspace preview is enabled\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function doWorkspacePreview()\n    {\n        trigger_error('TSFE->doWorkspacePreview() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        return $this->context->getPropertyFromAspect('workspace', 'isOffline', false);\n    }\n\n    /**\n     * Returns the uid of the current workspace\n     *\n     * @return int returns workspace integer for which workspace is being preview. 0 if none (= live workspace).\n     * @deprecated will be removed in TYPO3 v13.0. Use the Context API directly.\n     */\n    public function whichWorkspace(): int\n    {\n        trigger_error('TSFE->whichWorkspace() will be removed in TYPO3 v13.0. Use the Context API directly.', E_USER_DEPRECATED);\n        return $this->context->getPropertyFromAspect('workspace', 'id', 0);\n    }\n\n    /********************************************\n     *\n     * Various external API functions - for use in plugins etc.\n     *\n     *******************************************/\n    /**\n     * Returns the pages TSconfig array based on the current ->rootLine\n     *\n     * @deprecated since TYPO3 v12, will be removed in v13. Frontend should typically not depend on Backend TsConfig.\n     *             If really needed, use PageTsConfigFactory, see usage in DatabaseRecordLinkBuilder.\n     *             Remove together with class PageTsConfig.\n     */\n    public function getPagesTSconfig(): array\n    {\n        trigger_error('Method getPagesTSconfig() is deprecated since TYPO3 v12 and will be removed with TYPO3 v13.0.', E_USER_DEPRECATED);\n        if (!is_array($this->pagesTSconfig)) {\n            $matcher = GeneralUtility::makeInstance(FrontendConditionMatcher::class, $this->context, $this->id, $this->rootLine);\n            $this->pagesTSconfig = GeneralUtility::makeInstance(PageTsConfig::class)\n                ->getForRootLine(\n                    array_reverse($this->rootLine),\n                    $this->site,\n                    $matcher\n                );\n        }\n        return $this->pagesTSconfig;\n    }\n\n    /**\n     * Returns a unique md5 hash.\n     * There is no special magic in this, the only point is that you don't have to call md5(uniqid()) which is slow and by this you are sure to get a unique string each time in a little faster way.\n     *\n     * @param string $str Some string to include in what is hashed. Not significant at all.\n     * @return string MD5 hash of ->uniqueString, input string and uniqueCounter\n     */\n    public function uniqueHash($str = '')\n    {\n        return md5($this->uniqueString . '_' . $str . $this->uniqueCounter++);\n    }\n\n    /**\n     * Sets the cache-flag to 1. Could be called from user-included php-files in order to ensure that a page is not cached.\n     *\n     * @param string $reason An optional reason to be written to the log.\n     * @param bool $internal Whether the call is done from core itself (should only be used by core).\n     */\n    public function set_no_cache($reason = '', $internal = false)\n    {\n        $warning = '';\n        $context = [];\n        if ($reason !== '') {\n            $warning = '$TSFE->set_no_cache() was triggered. Reason: {reason}.';\n            $context['reason'] = $reason;\n        } else {\n            $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1);\n            if (isset($trace[0]['class'])) {\n                $context['class'] = $trace[0]['class'];\n                $warning = '$GLOBALS[\\'TSFE\\']->set_no_cache() was triggered by {class} on line {line}.';\n            }\n            if (isset($trace[0]['function'])) {\n                $context['function'] = $trace[0]['function'];\n                $warning = '$GLOBALS[\\'TSFE\\']->set_no_cache() was triggered by {class}->{function} on line {line}.';\n            }\n            if ($context === []) {\n                // Only store the filename, not the full path for safety reasons\n                $context['file'] = basename($trace[0]['file']);\n                $warning = '$GLOBALS[\\'TSFE\\']->set_no_cache() was triggered by {file} on line {line}.';\n            }\n            $context['line'] = $trace[0]['line'];\n        }\n        if (!$internal && $GLOBALS['TYPO3_CONF_VARS']['FE']['disableNoCacheParameter']) {\n            $warning .= ' However, $TYPO3_CONF_VARS[\\'FE\\'][\\'disableNoCacheParameter\\'] is set, so it will be ignored!';\n            $this->getTimeTracker()->setTSlogMessage($warning, LogLevel::WARNING);\n        } else {\n            $warning .= ' Caching is disabled!';\n            $this->disableCache();\n        }\n        if ($internal) {\n            $this->logger->notice($warning, $context);\n        } else {\n            $this->logger->warning($warning, $context);\n        }\n    }\n\n    /**\n     * Disables caching of the current page.\n     *\n     * @internal\n     */\n    protected function disableCache()\n    {\n        $this->no_cache = true;\n    }\n\n    /**\n     * Sets the cache-timeout in seconds\n     *\n     * @param int $seconds Cache-timeout in seconds\n     */\n    public function set_cache_timeout_default($seconds)\n    {\n        $seconds = (int)$seconds;\n        if ($seconds > 0) {\n            $this->cacheTimeOutDefault = $seconds;\n        }\n    }\n\n    /**\n     * Get the cache timeout for the current page.\n     */\n    public function get_cache_timeout(): int\n    {\n        return GeneralUtility::makeInstance(CacheLifetimeCalculator::class)\n            ->calculateLifetimeForPage(\n                (int)$this->id,\n                $this->page,\n                $this->config['config'] ?? [],\n                $this->cacheTimeOutDefault,\n                $this->context\n            );\n    }\n\n    /*********************************************\n     *\n     * Localization and character set conversion\n     *\n     *********************************************/\n    /**\n     * Split Label function for front-end applications.\n     *\n     * @param string $input Key string. Accepts the \"LLL:\" prefix.\n     * @return string Label value, if any.\n     */\n    public function sL($input)\n    {\n        if ($this->languageService === null) {\n            $this->languageService = GeneralUtility::makeInstance(LanguageServiceFactory::class)->createFromSiteLanguage($this->language);\n        }\n        return $this->languageService->sL($input);\n    }\n\n    /**\n     * Returns the originally requested page uid when TSFE was instantiated initially.\n     */\n    public function getRequestedId(): int\n    {\n        return $this->requestedId;\n    }\n\n    /**\n     * Release the page specific lock.\n     *\n     * @throws \\InvalidArgumentException\n     * @throws \\RuntimeException\n     * @internal\n     */\n    public function releaseLocks(): void\n    {\n        $this->lock?->releaseLock('pages');\n    }\n\n    /**\n     * Send additional headers from config.additionalHeaders\n     */\n    protected function getAdditionalHeaders(): array\n    {\n        if (!isset($this->config['config']['additionalHeaders.'])) {\n            return [];\n        }\n        $additionalHeaders = [];\n        ksort($this->config['config']['additionalHeaders.']);\n        foreach ($this->config['config']['additionalHeaders.'] as $options) {\n            if (!is_array($options)) {\n                continue;\n            }\n            $header = trim($options['header'] ?? '');\n            if ($header === '') {\n                continue;\n            }\n            $additionalHeaders[] = [\n                'header' => $header,\n                // \"replace existing headers\" is turned on by default, unless turned off\n                'replace' => ($options['replace'] ?? '') !== '0',\n                'statusCode' => (int)($options['httpResponseCode'] ?? 0) ?: null,\n            ];\n        }\n        return $additionalHeaders;\n    }\n\n    /**\n     * Log the page access failure with additional request information\n     */\n    protected function logPageAccessFailure(string $message, ServerRequestInterface $request): void\n    {\n        $context = ['pageId' => $this->id];\n        if (($normalizedParams = $request->getAttribute('normalizedParams')) instanceof NormalizedParams) {\n            $context['requestUrl'] = $normalizedParams->getRequestUrl();\n        }\n        $this->logger->error($message, $context);\n    }\n\n    /**\n     * Returns the current BE user.\n     * @todo: Add PHP return type declaration and ensure, that classes using TSFE in BE/CLI context always instantiate\n     *        a FrontendBackendUserAuthentication object in $GLOBALS['BE_USER'].\n     *\n     * @return FrontendBackendUserAuthentication|null\n     */\n    protected function getBackendUser()\n    {\n        return $GLOBALS['BE_USER'] ?? null;\n    }\n\n    /**\n     * @return TimeTracker\n     */\n    protected function getTimeTracker()\n    {\n        return GeneralUtility::makeInstance(TimeTracker::class);\n    }\n\n    public function getLanguage(): SiteLanguage\n    {\n        return $this->language;\n    }\n\n    public function getSite(): Site\n    {\n        return $this->site;\n    }\n\n    public function getContext(): Context\n    {\n        return $this->context;\n    }\n\n    public function getPageArguments(): PageArguments\n    {\n        return $this->pageArguments;\n    }\n}\n"], "filenames": ["typo3/sysext/core/Classes/Core/SystemEnvironmentBuilder.php", "typo3/sysext/core/Classes/Http/NormalizedParams.php", "typo3/sysext/core/Classes/Utility/GeneralUtility.php", "typo3/sysext/core/Tests/Acceptance/Support/Extension/ApplicationEnvironment.php", "typo3/sysext/core/Tests/Unit/Http/NormalizedParamsTest.php", "typo3/sysext/core/Tests/Unit/Log/Processor/WebProcessorTest.php", "typo3/sysext/felogin/Tests/Unit/Validation/RedirectUrlValidatorTest.php", "typo3/sysext/frontend/Classes/Controller/TypoScriptFrontendController.php"], "buggy_code_start_loc": [258, 314, 2313, 148, 363, 33, 67, 2425], "buggy_code_end_loc": [275, 794, 2560, 149, 1029, 36, 68, 2443], "fixing_code_start_loc": [258, 314, 2313, 147, 363, 32, 67, 2426], "fixing_code_end_loc": [269, 790, 2557, 147, 980, 35, 68, 2444], "type": "CWE-79", "message": "TYPO3 is a free and open source Content Management Framework released under the GNU General Public License. In affected versions the TYPO3 core component `GeneralUtility::getIndpEnv()` uses the unfiltered server environment variable `PATH_INFO`, which allows attackers to inject malicious content. In combination with the TypoScript setting `config.absRefPrefix=auto`, attackers can inject malicious HTML code to pages that have not been rendered and cached, yet. As a result, injected values would be cached and delivered to other website visitors (persisted cross-site scripting). Individual code which relies on the resolved value of `GeneralUtility::getIndpEnv('SCRIPT_NAME')` and corresponding usages (as shown below) are vulnerable as well. Additional investigations confirmed that at least Apache web server deployments using CGI (FPM, FCGI/FastCGI, and similar) are affected. However, there still might be the risk that other scenarios like nginx, IIS, or Apache/mod_php are vulnerable. The usage of server environment variable `PATH_INFO` has been removed from corresponding processings in `GeneralUtility::getIndpEnv()`. Besides that, the public property `TypoScriptFrontendController::$absRefPrefix` is encoded for both being used as a URI component and for being used as a prefix in an HTML context. This mitigates the cross-site scripting vulnerability. Users are advised to update to TYPO3 versions 8.7.51 ELTS, 9.5.40 ELTS, 10.4.35 LTS, 11.5.23 LTS and 12.2.0 which fix this problem. For users who are unable to patch in a timely manner the TypoScript setting `config.absRefPrefix` should at least be set to a static path value, instead of using auto - e.g. `config.absRefPrefix=/`. This workaround **does not fix all aspects of the vulnerability**, and is just considered to be an intermediate mitigation to the most prominent manifestation.", "other": {"cve": {"id": "CVE-2023-24814", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-07T19:15:09.473", "lastModified": "2023-02-16T16:38:32.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TYPO3 is a free and open source Content Management Framework released under the GNU General Public License. In affected versions the TYPO3 core component `GeneralUtility::getIndpEnv()` uses the unfiltered server environment variable `PATH_INFO`, which allows attackers to inject malicious content. In combination with the TypoScript setting `config.absRefPrefix=auto`, attackers can inject malicious HTML code to pages that have not been rendered and cached, yet. As a result, injected values would be cached and delivered to other website visitors (persisted cross-site scripting). Individual code which relies on the resolved value of `GeneralUtility::getIndpEnv('SCRIPT_NAME')` and corresponding usages (as shown below) are vulnerable as well. Additional investigations confirmed that at least Apache web server deployments using CGI (FPM, FCGI/FastCGI, and similar) are affected. However, there still might be the risk that other scenarios like nginx, IIS, or Apache/mod_php are vulnerable. The usage of server environment variable `PATH_INFO` has been removed from corresponding processings in `GeneralUtility::getIndpEnv()`. Besides that, the public property `TypoScriptFrontendController::$absRefPrefix` is encoded for both being used as a URI component and for being used as a prefix in an HTML context. This mitigates the cross-site scripting vulnerability. Users are advised to update to TYPO3 versions 8.7.51 ELTS, 9.5.40 ELTS, 10.4.35 LTS, 11.5.23 LTS and 12.2.0 which fix this problem. For users who are unable to patch in a timely manner the TypoScript setting `config.absRefPrefix` should at least be set to a static path value, instead of using auto - e.g. `config.absRefPrefix=/`. This workaround **does not fix all aspects of the vulnerability**, and is just considered to be an intermediate mitigation to the most prominent manifestation."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.3}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.7.0", "versionEndExcluding": "9.7.51", "matchCriteriaId": "A0A441EE-3A04-499B-AEA3-E5869BC418DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.5.40", "matchCriteriaId": "E7D02B4E-9050-4C4E-ABE5-00E8662145E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.4.36", "matchCriteriaId": "6AF24F98-DCD1-442F-98DB-B0DE64AC2556"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0.0", "versionEndExcluding": "11.5.23", "matchCriteriaId": "2E225EC3-5236-450C-9655-AE920702AAA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0.0", "versionEndExcluding": "12.2.0", "matchCriteriaId": "7E3B9E03-7D04-4A74-8FE0-200097544319"}]}]}], "references": [{"url": "https://docs.typo3.org/m/typo3/reference-typoscript/main/en-us/Setup/Config/Index.html#absrefprefix", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/TYPO3/typo3/blob/v11.5.22/typo3/sysext/core/Classes/Utility/GeneralUtility.php#L2481-L2484", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/TYPO3/typo3/blob/v11.5.22/typo3/sysext/frontend/Classes/Controller/TypoScriptFrontendController.php#L2547-L2549", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/TYPO3/typo3/commit/0005a6fd86ab97eff8bf2e3a5828bf0e7cb6263a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/TYPO3/typo3/security/advisories/GHSA-r4f8-f93x-5qh3", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2023-001", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-psa-2023-001", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/TYPO3/typo3/commit/0005a6fd86ab97eff8bf2e3a5828bf0e7cb6263a"}}