{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        SSSSS  TTTTT   AAA   TTTTT  IIIII  SSSSS  TTTTT  IIIII   CCCC        %\n%        SS       T    A   A    T      I    SS       T      I    C            %\n%         SSS     T    AAAAA    T      I     SSS     T      I    C            %\n%           SS    T    A   A    T      I       SS    T      I    C            %\n%        SSSSS    T    A   A    T    IIIII  SSSSS    T    IIIII   CCCC        %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Statistical Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/accelerate-private.h\"\n#include \"magick/animate.h\"\n#include \"magick/animate.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-private.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/client.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/composite.h\"\n#include \"magick/composite-private.h\"\n#include \"magick/compress.h\"\n#include \"magick/constitute.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/draw.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/list.h\"\n#include \"magick/image-private.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/random_.h\"\n#include \"magick/random-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/signature-private.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/timer.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     E v a l u a t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EvaluateImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the EvaluateImageChannel method is:\n%\n%      MagickBooleanType EvaluateImage(Image *image,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%      MagickBooleanType EvaluateImages(Image *images,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%      MagickBooleanType EvaluateImageChannel(Image *image,\n%        const ChannelType channel,const MagickEvaluateOperator op,\n%        const double value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o op: A channel op.\n%\n%    o value: A value value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickPixelPacket **DestroyPixelThreadSet(const Image *images,\n  MagickPixelPacket **pixels)\n{\n  register ssize_t\n    i;\n\n  size_t\n    rows;\n\n  assert(pixels != (MagickPixelPacket **) NULL);\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (MagickPixelPacket *) NULL)\n      pixels[i]=(MagickPixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(MagickPixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic MagickPixelPacket **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n\n  MagickPixelPacket\n    **pixels;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    columns,\n    rows;\n\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(rows,sizeof(*pixels));\n  if (pixels == (MagickPixelPacket **) NULL)\n    return((MagickPixelPacket **) NULL);\n  (void) memset(pixels,0,rows*sizeof(*pixels));\n  columns=GetImageListLength(images);\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) rows; i++)\n  {\n    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,\n      sizeof(**pixels));\n    if (pixels[i] == (MagickPixelPacket *) NULL)\n      return(DestroyPixelThreadSet(images,pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n      GetMagickPixelPacket(images,&pixels[i][j]);\n  }\n  return(pixels);\n}\n\nstatic inline double EvaluateMax(const double x,const double y)\n{\n  if (x > y)\n    return(x);\n  return(y);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int IntensityCompare(const void *x,const void *y)\n{\n  const MagickPixelPacket\n    *color_1,\n    *color_2;\n\n  int\n    intensity;\n\n  color_1=(const MagickPixelPacket *) x;\n  color_2=(const MagickPixelPacket *) y;\n  intensity=(int) MagickPixelIntensity(color_2)-(int)\n    MagickPixelIntensity(color_1);\n  return(intensity);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickRealType ApplyEvaluateOperator(RandomInfo *random_info,\n  const Quantum pixel,const MagickEvaluateOperator op,\n  const MagickRealType value)\n{\n  MagickRealType\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(MagickRealType) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a\n        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale*\n        pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        ImpulseNoise,value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(MagickRealType) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(MagickRealType) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 :\n        QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange :\n        pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}\n\nstatic Image *AcquireImageCanvas(const Image *images,ExceptionInfo *exception)\n{\n  const Image\n    *p,\n    *q;\n\n  size_t\n    columns,\n    number_channels,\n    rows;\n\n  q=images;\n  columns=images->columns;\n  rows=images->rows;\n  number_channels=0;\n  for (p=images; p != (Image *) NULL; p=p->next)\n  {\n    size_t\n      channels;\n\n    channels=3;\n    if (p->matte != MagickFalse)\n      channels+=1;\n    if (p->colorspace == CMYKColorspace)\n      channels+=1;\n    if (channels > number_channels)\n      {\n        number_channels=channels;\n        q=p;\n      }\n    if (p->columns > columns)\n      columns=p->columns;\n    if (p->rows > rows)\n      rows=p->rows;\n  }\n  return(CloneImage(q,columns,rows,MagickTrue,exception));\n}\n\nMagickExport MagickBooleanType EvaluateImage(Image *image,\n  const MagickEvaluateOperator op,const double value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=EvaluateImageChannel(image,CompositeChannels,op,value,exception);\n  return(status);\n}\n\nMagickExport Image *EvaluateImages(const Image *images,\n  const MagickEvaluateOperator op,ExceptionInfo *exception)\n{\n#define EvaluateImageTag  \"Evaluate/Image\"\n\n  CacheView\n    *evaluate_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickPixelPacket\n    **magick_restrict evaluate_pixels,\n    zero;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  size_t\n    number_images;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  evaluate_pixels=AcquirePixelThreadSet(images);\n  if (evaluate_pixels == (MagickPixelPacket **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Evaluate image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_images=GetImageListLength(images);\n  GetMagickPixelPacket(images,&zero);\n  random_info=AcquireRandomInfoThreadSet();\n  evaluate_view=AcquireAuthenticCacheView(image,exception);\n  if (op == MedianEvaluateOperator)\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register IndexPacket\n          *magick_restrict evaluate_indexes;\n\n        register MagickPixelPacket\n          *evaluate_pixel;\n\n        register PixelPacket\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_indexes=GetCacheViewAuthenticIndexQueue(evaluate_view);\n        evaluate_pixel=evaluate_pixels[id];\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) number_images; i++)\n            evaluate_pixel[i]=zero;\n          next=images;\n          for (i=0; i < (ssize_t) number_images; i++)\n          {\n            register const IndexPacket\n              *indexes;\n\n            register const PixelPacket\n              *p;\n\n            image_view=AcquireVirtualCacheView(next,exception);\n            p=GetCacheViewVirtualPixels(image_view,x,y,1,1,exception);\n            if (p == (const PixelPacket *) NULL)\n              {\n                image_view=DestroyCacheView(image_view);\n                break;\n              }\n            indexes=GetCacheViewVirtualIndexQueue(image_view);\n            evaluate_pixel[i].red=ApplyEvaluateOperator(random_info[id],\n              GetPixelRed(p),op,evaluate_pixel[i].red);\n            evaluate_pixel[i].green=ApplyEvaluateOperator(random_info[id],\n              GetPixelGreen(p),op,evaluate_pixel[i].green);\n            evaluate_pixel[i].blue=ApplyEvaluateOperator(random_info[id],\n              GetPixelBlue(p),op,evaluate_pixel[i].blue);\n            evaluate_pixel[i].opacity=ApplyEvaluateOperator(random_info[id],\n              GetPixelAlpha(p),op,evaluate_pixel[i].opacity);\n            if (image->colorspace == CMYKColorspace)\n              evaluate_pixel[i].index=ApplyEvaluateOperator(random_info[id],\n                *indexes,op,evaluate_pixel[i].index);\n            image_view=DestroyCacheView(image_view);\n            next=GetNextImageInList(next);\n          }\n          qsort((void *) evaluate_pixel,number_images,sizeof(*evaluate_pixel),\n            IntensityCompare);\n          SetPixelRed(q,ClampToQuantum(evaluate_pixel[i/2].red));\n          SetPixelGreen(q,ClampToQuantum(evaluate_pixel[i/2].green));\n          SetPixelBlue(q,ClampToQuantum(evaluate_pixel[i/2].blue));\n          SetPixelAlpha(q,ClampToQuantum(evaluate_pixel[i/2].opacity));\n          if (image->colorspace == CMYKColorspace)\n            SetPixelIndex(evaluate_indexes+i,ClampToQuantum(\n              evaluate_pixel[i/2].index));\n          q++;\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp atomic\n#endif\n            progress++;\n            proceed=SetImageProgress(images,EvaluateImageTag,progress,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  else\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register IndexPacket\n          *magick_restrict evaluate_indexes;\n\n        register ssize_t\n          i,\n          x;\n\n        register MagickPixelPacket\n          *evaluate_pixel;\n\n        register PixelPacket\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_indexes=GetCacheViewAuthenticIndexQueue(evaluate_view);\n        evaluate_pixel=evaluate_pixels[id];\n        for (x=0; x < (ssize_t) image->columns; x++)\n          evaluate_pixel[x]=zero;\n        next=images;\n        for (i=0; i < (ssize_t) number_images; i++)\n        {\n          register const IndexPacket\n            *indexes;\n\n          register const PixelPacket\n            *p;\n\n          image_view=AcquireVirtualCacheView(next,exception);\n          p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,\n            exception);\n          if (p == (const PixelPacket *) NULL)\n            {\n              image_view=DestroyCacheView(image_view);\n              break;\n            }\n          indexes=GetCacheViewVirtualIndexQueue(image_view);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            evaluate_pixel[x].red=ApplyEvaluateOperator(random_info[id],\n              GetPixelRed(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].red);\n            evaluate_pixel[x].green=ApplyEvaluateOperator(random_info[id],\n              GetPixelGreen(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].green);\n            evaluate_pixel[x].blue=ApplyEvaluateOperator(random_info[id],\n              GetPixelBlue(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].blue);\n            evaluate_pixel[x].opacity=ApplyEvaluateOperator(random_info[id],\n              GetPixelAlpha(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].opacity);\n            if (image->colorspace == CMYKColorspace)\n              evaluate_pixel[x].index=ApplyEvaluateOperator(random_info[id],\n                GetPixelIndex(indexes+x),i == 0 ? AddEvaluateOperator : op,\n                evaluate_pixel[x].index);\n            p++;\n          }\n          image_view=DestroyCacheView(image_view);\n          next=GetNextImageInList(next);\n        }\n        if (op == MeanEvaluateOperator)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            evaluate_pixel[x].red/=number_images;\n            evaluate_pixel[x].green/=number_images;\n            evaluate_pixel[x].blue/=number_images;\n            evaluate_pixel[x].opacity/=number_images;\n            evaluate_pixel[x].index/=number_images;\n          }\n        if (op == RootMeanSquareEvaluateOperator)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            evaluate_pixel[x].red=sqrt((double) evaluate_pixel[x].red/\n              number_images);\n            evaluate_pixel[x].green=sqrt((double) evaluate_pixel[x].green/\n              number_images);\n            evaluate_pixel[x].blue=sqrt((double) evaluate_pixel[x].blue/\n              number_images);\n            evaluate_pixel[x].opacity=sqrt((double) evaluate_pixel[x].opacity/\n              number_images);\n            evaluate_pixel[x].index=sqrt((double) evaluate_pixel[x].index/\n              number_images);\n          }\n        if (op == MultiplyEvaluateOperator)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            register ssize_t\n              j;\n\n            for (j=0; j < (ssize_t) (number_images-1); j++)\n            {\n              evaluate_pixel[x].red*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].green*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].blue*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].opacity*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].index*=(MagickRealType) QuantumScale;\n            }\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(q,ClampToQuantum(evaluate_pixel[x].red));\n          SetPixelGreen(q,ClampToQuantum(evaluate_pixel[x].green));\n          SetPixelBlue(q,ClampToQuantum(evaluate_pixel[x].blue));\n          SetPixelAlpha(q,ClampToQuantum(evaluate_pixel[x].opacity));\n          if (image->colorspace == CMYKColorspace)\n            SetPixelIndex(evaluate_indexes+x,ClampToQuantum(\n              evaluate_pixel[x].index));\n          q++;\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(images,EvaluateImageTag,progress++,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  evaluate_view=DestroyCacheView(evaluate_view);\n  evaluate_pixels=DestroyPixelThreadSet(images,evaluate_pixels);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\nMagickExport MagickBooleanType EvaluateImageChannel(Image *image,\n  const ChannelType channel,const MagickEvaluateOperator op,const double value,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(MagickFalse);\n    }\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        result;\n\n      if ((channel & RedChannel) != 0)\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelRed(q),op,value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelRed(q,ClampToQuantum(result));\n        }\n      if ((channel & GreenChannel) != 0)\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelGreen(q),op,\n            value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelGreen(q,ClampToQuantum(result));\n        }\n      if ((channel & BlueChannel) != 0)\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelBlue(q),op,\n            value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelBlue(q,ClampToQuantum(result));\n        }\n      if ((channel & OpacityChannel) != 0)\n        {\n          if (image->matte == MagickFalse)\n            {\n              result=ApplyEvaluateOperator(random_info[id],GetPixelOpacity(q),\n                op,value);\n              if (op == MeanEvaluateOperator)\n                result/=2.0;\n              SetPixelOpacity(q,ClampToQuantum(result));\n            }\n          else\n            {\n              result=ApplyEvaluateOperator(random_info[id],GetPixelAlpha(q),\n                op,value);\n              if (op == MeanEvaluateOperator)\n                result/=2.0;\n              SetPixelAlpha(q,ClampToQuantum(result));\n            }\n        }\n      if (((channel & IndexChannel) != 0) && (indexes != (IndexPacket *) NULL))\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelIndex(indexes+x),\n            op,value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelIndex(indexes+x,ClampToQuantum(result));\n        }\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,EvaluateImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F u n c t i o n I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FunctionImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the FunctionImageChannel method is:\n%\n%      MagickBooleanType FunctionImage(Image *image,\n%        const MagickFunction function,const ssize_t number_parameters,\n%        const double *parameters,ExceptionInfo *exception)\n%      MagickBooleanType FunctionImageChannel(Image *image,\n%        const ChannelType channel,const MagickFunction function,\n%        const ssize_t number_parameters,const double *argument,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o function: A channel function.\n%\n%    o parameters: one or more parameters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Quantum ApplyFunction(Quantum pixel,const MagickFunction function,\n  const size_t number_parameters,const double *parameters,\n  ExceptionInfo *exception)\n{\n  MagickRealType\n    result;\n\n  register ssize_t\n    i;\n\n  (void) exception;\n  result=0.0;\n  switch (function)\n  {\n    case PolynomialFunction:\n    {\n      /*\n       * Polynomial\n       * Parameters:   polynomial constants,  highest to lowest order\n       *   For example:      c0*x^3 + c1*x^2 + c2*x  + c3\n       */\n      result=0.0;\n      for (i=0; i < (ssize_t) number_parameters; i++)\n        result=result*QuantumScale*pixel + parameters[i];\n      result*=QuantumRange;\n      break;\n    }\n    case SinusoidFunction:\n    {\n      /* Sinusoid Function\n       * Parameters:   Freq, Phase, Ampl, bias\n       */\n      double  freq,phase,ampl,bias;\n      freq  = ( number_parameters >= 1 ) ? parameters[0] : 1.0;\n      phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0;\n      ampl  = ( number_parameters >= 3 ) ? parameters[2] : 0.5;\n      bias  = ( number_parameters >= 4 ) ? parameters[3] : 0.5;\n      result=(MagickRealType) (QuantumRange*(ampl*sin((double) (2.0*MagickPI*\n        (freq*QuantumScale*pixel + phase/360.0) )) + bias ) );\n      break;\n    }\n    case ArcsinFunction:\n    {\n      /* Arcsin Function  (peged at range limits for invalid results)\n       * Parameters:   Width, Center, Range, Bias\n       */\n      double  width,range,center,bias;\n      width  = ( number_parameters >= 1 ) ? parameters[0] : 1.0;\n      center = ( number_parameters >= 2 ) ? parameters[1] : 0.5;\n      range  = ( number_parameters >= 3 ) ? parameters[2] : 1.0;\n      bias   = ( number_parameters >= 4 ) ? parameters[3] : 0.5;\n      result = 2.0/width*(QuantumScale*pixel - center);\n      if ( result <= -1.0 )\n        result = bias - range/2.0;\n      else if ( result >= 1.0 )\n        result = bias + range/2.0;\n      else\n        result=(MagickRealType) (range/MagickPI*asin((double) result)+bias);\n      result *= QuantumRange;\n      break;\n    }\n    case ArctanFunction:\n    {\n      /* Arctan Function\n       * Parameters:   Slope, Center, Range, Bias\n       */\n      double  slope,range,center,bias;\n      slope  = ( number_parameters >= 1 ) ? parameters[0] : 1.0;\n      center = ( number_parameters >= 2 ) ? parameters[1] : 0.5;\n      range  = ( number_parameters >= 3 ) ? parameters[2] : 1.0;\n      bias   = ( number_parameters >= 4 ) ? parameters[3] : 0.5;\n      result=(MagickRealType) (MagickPI*slope*(QuantumScale*pixel-center));\n      result=(MagickRealType) (QuantumRange*(range/MagickPI*atan((double)\n                  result) + bias ) );\n      break;\n    }\n    case UndefinedFunction:\n      break;\n  }\n  return(ClampToQuantum(result));\n}\n\nMagickExport MagickBooleanType FunctionImage(Image *image,\n  const MagickFunction function,const size_t number_parameters,\n  const double *parameters,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=FunctionImageChannel(image,CompositeChannels,function,\n    number_parameters,parameters,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType FunctionImageChannel(Image *image,\n  const ChannelType channel,const MagickFunction function,\n  const size_t number_parameters,const double *parameters,\n  ExceptionInfo *exception)\n{\n#define FunctionImageTag  \"Function/Image \"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(MagickFalse);\n    }\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  status=AccelerateFunctionImage(image,channel,function,number_parameters,\n    parameters,exception);\n  if (status != MagickFalse)\n    return(status);\n#endif\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q,ApplyFunction(GetPixelRed(q),function,\n          number_parameters,parameters,exception));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q,ApplyFunction(GetPixelGreen(q),function,\n          number_parameters,parameters,exception));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q,ApplyFunction(GetPixelBlue(q),function,\n          number_parameters,parameters,exception));\n      if ((channel & OpacityChannel) != 0)\n        {\n          if (image->matte == MagickFalse)\n            SetPixelOpacity(q,ApplyFunction(GetPixelOpacity(q),function,\n              number_parameters,parameters,exception));\n          else\n            SetPixelAlpha(q,ApplyFunction((Quantum) GetPixelAlpha(q),function,\n              number_parameters,parameters,exception));\n        }\n      if (((channel & IndexChannel) != 0) && (indexes != (IndexPacket *) NULL))\n        SetPixelIndex(indexes+x,ApplyFunction(GetPixelIndex(indexes+x),function,\n          number_parameters,parameters,exception));\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,FunctionImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l E n t r o p y                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelEntropy() returns the entropy of one or more image channels.\n%\n%  The format of the GetImageChannelEntropy method is:\n%\n%      MagickBooleanType GetImageChannelEntropy(const Image *image,\n%        const ChannelType channel,double *entropy,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o entropy: the average entropy of the selected channels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageEntropy(const Image *image,\n  double *entropy,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelEntropy(image,CompositeChannels,entropy,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelEntropy(const Image *image,\n  const ChannelType channel,double *entropy,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  size_t\n    channels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageChannelStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  channels=0;\n  channel_statistics[CompositeChannels].entropy=0.0;\n  if ((channel & RedChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[RedChannel].entropy;\n      channels++;\n    }\n  if ((channel & GreenChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[GreenChannel].entropy;\n      channels++;\n    }\n  if ((channel & BlueChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[BlueChannel].entropy;\n      channels++;\n    }\n  if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[OpacityChannel].entropy;\n      channels++;\n    }\n  if (((channel & IndexChannel) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[BlackChannel].entropy;\n      channels++;\n    }\n  channel_statistics[CompositeChannels].entropy/=channels;\n  *entropy=channel_statistics[CompositeChannels].entropy;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e C h a n n e l E x t r e m a                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelExtrema() returns the extrema of one or more image channels.\n%\n%  The format of the GetImageChannelExtrema method is:\n%\n%      MagickBooleanType GetImageChannelExtrema(const Image *image,\n%        const ChannelType channel,size_t *minima,size_t *maxima,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageExtrema(const Image *image,\n  size_t *minima,size_t *maxima,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelExtrema(image,CompositeChannels,minima,maxima,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelExtrema(const Image *image,\n  const ChannelType channel,size_t *minima,size_t *maxima,\n  ExceptionInfo *exception)\n{\n  double\n    max,\n    min;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=GetImageChannelRange(image,channel,&min,&max,exception);\n  *minima=(size_t) ceil(min-0.5);\n  *maxima=(size_t) floor(max+0.5);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l K u r t o s i s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelKurtosis() returns the kurtosis and skewness of one or more\n%  image channels.\n%\n%  The format of the GetImageChannelKurtosis method is:\n%\n%      MagickBooleanType GetImageChannelKurtosis(const Image *image,\n%        const ChannelType channel,double *kurtosis,double *skewness,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o kurtosis: the kurtosis of the channel.\n%\n%    o skewness: the skewness of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageKurtosis(const Image *image,\n  double *kurtosis,double *skewness,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelKurtosis(image,CompositeChannels,kurtosis,skewness,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelKurtosis(const Image *image,\n  const ChannelType channel,double *kurtosis,double *skewness,\n  ExceptionInfo *exception)\n{\n  double\n    area,\n    mean,\n    standard_deviation,\n    sum_squares,\n    sum_cubes,\n    sum_fourth_power;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *kurtosis=0.0;\n  *skewness=0.0;\n  area=0.0;\n  mean=0.0;\n  standard_deviation=0.0;\n  sum_squares=0.0;\n  sum_cubes=0.0;\n  sum_fourth_power=0.0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((channel & RedChannel) != 0)\n        {\n          mean+=GetPixelRed(p);\n          sum_squares+=(double) GetPixelRed(p)*GetPixelRed(p);\n          sum_cubes+=(double) GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p);\n          sum_fourth_power+=(double) GetPixelRed(p)*GetPixelRed(p)*\n            GetPixelRed(p)*GetPixelRed(p);\n          area++;\n        }\n      if ((channel & GreenChannel) != 0)\n        {\n          mean+=GetPixelGreen(p);\n          sum_squares+=(double) GetPixelGreen(p)*GetPixelGreen(p);\n          sum_cubes+=(double) GetPixelGreen(p)*GetPixelGreen(p)*\n            GetPixelGreen(p);\n          sum_fourth_power+=(double) GetPixelGreen(p)*GetPixelGreen(p)*\n            GetPixelGreen(p)*GetPixelGreen(p);\n          area++;\n        }\n      if ((channel & BlueChannel) != 0)\n        {\n          mean+=GetPixelBlue(p);\n          sum_squares+=(double) GetPixelBlue(p)*GetPixelBlue(p);\n          sum_cubes+=(double) GetPixelBlue(p)*GetPixelBlue(p)*GetPixelBlue(p);\n          sum_fourth_power+=(double) GetPixelBlue(p)*GetPixelBlue(p)*\n            GetPixelBlue(p)*GetPixelBlue(p);\n          area++;\n        }\n      if ((channel & OpacityChannel) != 0)\n        {\n          mean+=GetPixelAlpha(p);\n          sum_squares+=(double) GetPixelOpacity(p)*GetPixelAlpha(p);\n          sum_cubes+=(double) GetPixelOpacity(p)*GetPixelAlpha(p)*\n            GetPixelAlpha(p);\n          sum_fourth_power+=(double) GetPixelAlpha(p)*GetPixelAlpha(p)*\n            GetPixelAlpha(p)*GetPixelAlpha(p);\n          area++;\n        }\n      if (((channel & IndexChannel) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n          double\n            index;\n\n          index=(double) GetPixelIndex(indexes+x);\n          mean+=index;\n          sum_squares+=index*index;\n          sum_cubes+=index*index*index;\n          sum_fourth_power+=index*index*index*index;\n          area++;\n        }\n      p++;\n    }\n  }\n  if (y < (ssize_t) image->rows)\n    return(MagickFalse);\n  if (area != 0.0)\n    {\n      mean/=area;\n      sum_squares/=area;\n      sum_cubes/=area;\n      sum_fourth_power/=area;\n    }\n  standard_deviation=sqrt(sum_squares-(mean*mean));\n  if (standard_deviation != 0.0)\n    {\n      *kurtosis=sum_fourth_power-4.0*mean*sum_cubes+6.0*mean*mean*sum_squares-\n        3.0*mean*mean*mean*mean;\n      *kurtosis/=standard_deviation*standard_deviation*standard_deviation*\n        standard_deviation;\n      *kurtosis-=3.0;\n      *skewness=sum_cubes-3.0*mean*sum_squares+2.0*mean*mean*mean;\n      *skewness/=standard_deviation*standard_deviation*standard_deviation;\n    }\n  return(y == (ssize_t) image->rows ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l M e a n                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelMean() returns the mean and standard deviation of one or more\n%  image channels.\n%\n%  The format of the GetImageChannelMean method is:\n%\n%      MagickBooleanType GetImageChannelMean(const Image *image,\n%        const ChannelType channel,double *mean,double *standard_deviation,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o mean: the average value in the channel.\n%\n%    o standard_deviation: the standard deviation of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageMean(const Image *image,double *mean,\n  double *standard_deviation,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelMean(image,CompositeChannels,mean,standard_deviation,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelMean(const Image *image,\n  const ChannelType channel,double *mean,double *standard_deviation,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  size_t\n    channels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageChannelStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  channels=0;\n  channel_statistics[CompositeChannels].mean=0.0;\n  channel_statistics[CompositeChannels].standard_deviation=0.0;\n  if ((channel & RedChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[RedChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[RedChannel].standard_deviation;\n      channels++;\n    }\n  if ((channel & GreenChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[GreenChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[GreenChannel].standard_deviation;\n      channels++;\n    }\n  if ((channel & BlueChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[BlueChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[BlueChannel].standard_deviation;\n      channels++;\n    }\n  if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      channel_statistics[CompositeChannels].mean+=\n        (QuantumRange-channel_statistics[OpacityChannel].mean);\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[OpacityChannel].standard_deviation;\n      channels++;\n    }\n  if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[BlackChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[CompositeChannels].standard_deviation;\n      channels++;\n    }\n  channel_statistics[CompositeChannels].mean/=channels;\n  channel_statistics[CompositeChannels].standard_deviation/=channels;\n  *mean=channel_statistics[CompositeChannels].mean;\n  *standard_deviation=channel_statistics[CompositeChannels].standard_deviation;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l M o m e n t s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelMoments() returns the normalized moments of one or more image\n%  channels.\n%\n%  The format of the GetImageChannelMoments method is:\n%\n%      ChannelMoments *GetImageChannelMoments(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ChannelMoments *GetImageChannelMoments(const Image *image,\n  ExceptionInfo *exception)\n{\n#define MaxNumberImageMoments  8\n\n  ChannelMoments\n    *channel_moments;\n\n  double\n    M00[CompositeChannels+1],\n    M01[CompositeChannels+1],\n    M02[CompositeChannels+1],\n    M03[CompositeChannels+1],\n    M10[CompositeChannels+1],\n    M11[CompositeChannels+1],\n    M12[CompositeChannels+1],\n    M20[CompositeChannels+1],\n    M21[CompositeChannels+1],\n    M22[CompositeChannels+1],\n    M30[CompositeChannels+1];\n\n  MagickPixelPacket\n    pixel;\n\n  PointInfo\n    centroid[CompositeChannels+1];\n\n  ssize_t\n    channel,\n    channels,\n    y;\n\n  size_t\n    length;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=CompositeChannels+1UL;\n  channel_moments=(ChannelMoments *) AcquireQuantumMemory(length,\n    sizeof(*channel_moments));\n  if (channel_moments == (ChannelMoments *) NULL)\n    return(channel_moments);\n  (void) memset(channel_moments,0,length*sizeof(*channel_moments));\n  (void) memset(centroid,0,sizeof(centroid));\n  (void) memset(M00,0,sizeof(M00));\n  (void) memset(M01,0,sizeof(M01));\n  (void) memset(M02,0,sizeof(M02));\n  (void) memset(M03,0,sizeof(M03));\n  (void) memset(M10,0,sizeof(M10));\n  (void) memset(M11,0,sizeof(M11));\n  (void) memset(M12,0,sizeof(M12));\n  (void) memset(M20,0,sizeof(M20));\n  (void) memset(M21,0,sizeof(M21));\n  (void) memset(M22,0,sizeof(M22));\n  (void) memset(M30,0,sizeof(M30));\n  GetMagickPixelPacket(image,&pixel);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute center of mass (centroid).\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      M00[RedChannel]+=QuantumScale*pixel.red;\n      M10[RedChannel]+=x*QuantumScale*pixel.red;\n      M01[RedChannel]+=y*QuantumScale*pixel.red;\n      M00[GreenChannel]+=QuantumScale*pixel.green;\n      M10[GreenChannel]+=x*QuantumScale*pixel.green;\n      M01[GreenChannel]+=y*QuantumScale*pixel.green;\n      M00[BlueChannel]+=QuantumScale*pixel.blue;\n      M10[BlueChannel]+=x*QuantumScale*pixel.blue;\n      M01[BlueChannel]+=y*QuantumScale*pixel.blue;\n      if (image->matte != MagickFalse)\n        {\n          M00[OpacityChannel]+=QuantumScale*pixel.opacity;\n          M10[OpacityChannel]+=x*QuantumScale*pixel.opacity;\n          M01[OpacityChannel]+=y*QuantumScale*pixel.opacity;\n        }\n      if (image->colorspace == CMYKColorspace)\n        {\n          M00[IndexChannel]+=QuantumScale*pixel.index;\n          M10[IndexChannel]+=x*QuantumScale*pixel.index;\n          M01[IndexChannel]+=y*QuantumScale*pixel.index;\n        }\n      p++;\n    }\n  }\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Compute center of mass (centroid).\n    */\n    if (M00[channel] < MagickEpsilon)\n      {\n        M00[channel]+=MagickEpsilon;\n        centroid[channel].x=(double) image->columns/2.0;\n        centroid[channel].y=(double) image->rows/2.0;\n        continue;\n      }\n    M00[channel]+=MagickEpsilon;\n    centroid[channel].x=M10[channel]/M00[channel];\n    centroid[channel].y=M01[channel]/M00[channel];\n  }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute the image moments.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      M11[RedChannel]+=(x-centroid[RedChannel].x)*(y-\n        centroid[RedChannel].y)*QuantumScale*pixel.red;\n      M20[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*QuantumScale*pixel.red;\n      M02[RedChannel]+=(y-centroid[RedChannel].y)*(y-\n        centroid[RedChannel].y)*QuantumScale*pixel.red;\n      M21[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*(y-centroid[RedChannel].y)*QuantumScale*\n        pixel.red;\n      M12[RedChannel]+=(x-centroid[RedChannel].x)*(y-\n        centroid[RedChannel].y)*(y-centroid[RedChannel].y)*QuantumScale*\n        pixel.red;\n      M22[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*(y-centroid[RedChannel].y)*(y-\n        centroid[RedChannel].y)*QuantumScale*pixel.red;\n      M30[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*(x-centroid[RedChannel].x)*QuantumScale*\n        pixel.red;\n      M03[RedChannel]+=(y-centroid[RedChannel].y)*(y-\n        centroid[RedChannel].y)*(y-centroid[RedChannel].y)*QuantumScale*\n        pixel.red;\n      M11[GreenChannel]+=(x-centroid[GreenChannel].x)*(y-\n        centroid[GreenChannel].y)*QuantumScale*pixel.green;\n      M20[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*QuantumScale*pixel.green;\n      M02[GreenChannel]+=(y-centroid[GreenChannel].y)*(y-\n        centroid[GreenChannel].y)*QuantumScale*pixel.green;\n      M21[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*(y-centroid[GreenChannel].y)*QuantumScale*\n        pixel.green;\n      M12[GreenChannel]+=(x-centroid[GreenChannel].x)*(y-\n        centroid[GreenChannel].y)*(y-centroid[GreenChannel].y)*QuantumScale*\n        pixel.green;\n      M22[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*(y-centroid[GreenChannel].y)*(y-\n        centroid[GreenChannel].y)*QuantumScale*pixel.green;\n      M30[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*(x-centroid[GreenChannel].x)*QuantumScale*\n        pixel.green;\n      M03[GreenChannel]+=(y-centroid[GreenChannel].y)*(y-\n        centroid[GreenChannel].y)*(y-centroid[GreenChannel].y)*QuantumScale*\n        pixel.green;\n      M11[BlueChannel]+=(x-centroid[BlueChannel].x)*(y-\n        centroid[BlueChannel].y)*QuantumScale*pixel.blue;\n      M20[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*QuantumScale*pixel.blue;\n      M02[BlueChannel]+=(y-centroid[BlueChannel].y)*(y-\n        centroid[BlueChannel].y)*QuantumScale*pixel.blue;\n      M21[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*(y-centroid[BlueChannel].y)*QuantumScale*\n        pixel.blue;\n      M12[BlueChannel]+=(x-centroid[BlueChannel].x)*(y-\n        centroid[BlueChannel].y)*(y-centroid[BlueChannel].y)*QuantumScale*\n        pixel.blue;\n      M22[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*(y-centroid[BlueChannel].y)*(y-\n        centroid[BlueChannel].y)*QuantumScale*pixel.blue;\n      M30[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*(x-centroid[BlueChannel].x)*QuantumScale*\n        pixel.blue;\n      M03[BlueChannel]+=(y-centroid[BlueChannel].y)*(y-\n        centroid[BlueChannel].y)*(y-centroid[BlueChannel].y)*QuantumScale*\n        pixel.blue;\n      if (image->matte != MagickFalse)\n        {\n          M11[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(y-\n            centroid[OpacityChannel].y)*QuantumScale*pixel.opacity;\n          M20[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*QuantumScale*pixel.opacity;\n          M02[OpacityChannel]+=(y-centroid[OpacityChannel].y)*(y-\n            centroid[OpacityChannel].y)*QuantumScale*pixel.opacity;\n          M21[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*(y-centroid[OpacityChannel].y)*\n            QuantumScale*pixel.opacity;\n          M12[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(y-\n            centroid[OpacityChannel].y)*(y-centroid[OpacityChannel].y)*\n            QuantumScale*pixel.opacity;\n          M22[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*(y-centroid[OpacityChannel].y)*(y-\n            centroid[OpacityChannel].y)*QuantumScale*pixel.opacity;\n          M30[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*(x-centroid[OpacityChannel].x)*\n            QuantumScale*pixel.opacity;\n          M03[OpacityChannel]+=(y-centroid[OpacityChannel].y)*(y-\n            centroid[OpacityChannel].y)*(y-centroid[OpacityChannel].y)*\n            QuantumScale*pixel.opacity;\n        }\n      if (image->colorspace == CMYKColorspace)\n        {\n          M11[IndexChannel]+=(x-centroid[IndexChannel].x)*(y-\n            centroid[IndexChannel].y)*QuantumScale*pixel.index;\n          M20[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*QuantumScale*pixel.index;\n          M02[IndexChannel]+=(y-centroid[IndexChannel].y)*(y-\n            centroid[IndexChannel].y)*QuantumScale*pixel.index;\n          M21[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*(y-centroid[IndexChannel].y)*\n            QuantumScale*pixel.index;\n          M12[IndexChannel]+=(x-centroid[IndexChannel].x)*(y-\n            centroid[IndexChannel].y)*(y-centroid[IndexChannel].y)*\n            QuantumScale*pixel.index;\n          M22[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*(y-centroid[IndexChannel].y)*(y-\n            centroid[IndexChannel].y)*QuantumScale*pixel.index;\n          M30[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*(x-centroid[IndexChannel].x)*\n            QuantumScale*pixel.index;\n          M03[IndexChannel]+=(y-centroid[IndexChannel].y)*(y-\n            centroid[IndexChannel].y)*(y-centroid[IndexChannel].y)*\n            QuantumScale*pixel.index;\n        }\n      p++;\n    }\n  }\n  channels=3;\n  M00[CompositeChannels]+=(M00[RedChannel]+M00[GreenChannel]+M00[BlueChannel]);\n  M01[CompositeChannels]+=(M01[RedChannel]+M01[GreenChannel]+M01[BlueChannel]);\n  M02[CompositeChannels]+=(M02[RedChannel]+M02[GreenChannel]+M02[BlueChannel]);\n  M03[CompositeChannels]+=(M03[RedChannel]+M03[GreenChannel]+M03[BlueChannel]);\n  M10[CompositeChannels]+=(M10[RedChannel]+M10[GreenChannel]+M10[BlueChannel]);\n  M11[CompositeChannels]+=(M11[RedChannel]+M11[GreenChannel]+M11[BlueChannel]);\n  M12[CompositeChannels]+=(M12[RedChannel]+M12[GreenChannel]+M12[BlueChannel]);\n  M20[CompositeChannels]+=(M20[RedChannel]+M20[GreenChannel]+M20[BlueChannel]);\n  M21[CompositeChannels]+=(M21[RedChannel]+M21[GreenChannel]+M21[BlueChannel]);\n  M22[CompositeChannels]+=(M22[RedChannel]+M22[GreenChannel]+M22[BlueChannel]);\n  M30[CompositeChannels]+=(M30[RedChannel]+M30[GreenChannel]+M30[BlueChannel]);\n  if (image->matte != MagickFalse)\n    {\n      channels+=1;\n      M00[CompositeChannels]+=M00[OpacityChannel];\n      M01[CompositeChannels]+=M01[OpacityChannel];\n      M02[CompositeChannels]+=M02[OpacityChannel];\n      M03[CompositeChannels]+=M03[OpacityChannel];\n      M10[CompositeChannels]+=M10[OpacityChannel];\n      M11[CompositeChannels]+=M11[OpacityChannel];\n      M12[CompositeChannels]+=M12[OpacityChannel];\n      M20[CompositeChannels]+=M20[OpacityChannel];\n      M21[CompositeChannels]+=M21[OpacityChannel];\n      M22[CompositeChannels]+=M22[OpacityChannel];\n      M30[CompositeChannels]+=M30[OpacityChannel];\n    }\n  if (image->colorspace == CMYKColorspace)\n    {\n      channels+=1;\n      M00[CompositeChannels]+=M00[IndexChannel];\n      M01[CompositeChannels]+=M01[IndexChannel];\n      M02[CompositeChannels]+=M02[IndexChannel];\n      M03[CompositeChannels]+=M03[IndexChannel];\n      M10[CompositeChannels]+=M10[IndexChannel];\n      M11[CompositeChannels]+=M11[IndexChannel];\n      M12[CompositeChannels]+=M12[IndexChannel];\n      M20[CompositeChannels]+=M20[IndexChannel];\n      M21[CompositeChannels]+=M21[IndexChannel];\n      M22[CompositeChannels]+=M22[IndexChannel];\n      M30[CompositeChannels]+=M30[IndexChannel];\n    }\n  M00[CompositeChannels]/=(double) channels;\n  M01[CompositeChannels]/=(double) channels;\n  M02[CompositeChannels]/=(double) channels;\n  M03[CompositeChannels]/=(double) channels;\n  M10[CompositeChannels]/=(double) channels;\n  M11[CompositeChannels]/=(double) channels;\n  M12[CompositeChannels]/=(double) channels;\n  M20[CompositeChannels]/=(double) channels;\n  M21[CompositeChannels]/=(double) channels;\n  M22[CompositeChannels]/=(double) channels;\n  M30[CompositeChannels]/=(double) channels;\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Compute elliptical angle, major and minor axes, eccentricity, & intensity.\n    */\n    channel_moments[channel].centroid=centroid[channel];\n    channel_moments[channel].ellipse_axis.x=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])+sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_axis.y=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])-sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_angle=RadiansToDegrees(0.5*atan(2.0*\n      M11[channel]/(M20[channel]-M02[channel]+MagickEpsilon)));\n    if (fabs(M11[channel]) < MagickEpsilon)\n      {\n        if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n          channel_moments[channel].ellipse_angle+=0.0;\n        else\n          if ((M20[channel]-M02[channel]) < 0.0)\n            channel_moments[channel].ellipse_angle+=90.0;\n          else\n            channel_moments[channel].ellipse_angle+=0.0;\n      }\n    else\n      if (M11[channel] < 0.0)\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=180.0;\n        }\n      else\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=0.0;\n       }\n    channel_moments[channel].ellipse_eccentricity=sqrt(1.0-(\n      channel_moments[channel].ellipse_axis.y/\n      (channel_moments[channel].ellipse_axis.x+MagickEpsilon)));\n    channel_moments[channel].ellipse_intensity=M00[channel]/\n      (MagickPI*channel_moments[channel].ellipse_axis.x*\n      channel_moments[channel].ellipse_axis.y+MagickEpsilon);\n  }\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Normalize image moments.\n    */\n    M10[channel]=0.0;\n    M01[channel]=0.0;\n    M11[channel]/=pow(M00[channel],1.0+(1.0+1.0)/2.0);\n    M20[channel]/=pow(M00[channel],1.0+(2.0+0.0)/2.0);\n    M02[channel]/=pow(M00[channel],1.0+(0.0+2.0)/2.0);\n    M21[channel]/=pow(M00[channel],1.0+(2.0+1.0)/2.0);\n    M12[channel]/=pow(M00[channel],1.0+(1.0+2.0)/2.0);\n    M22[channel]/=pow(M00[channel],1.0+(2.0+2.0)/2.0);\n    M30[channel]/=pow(M00[channel],1.0+(3.0+0.0)/2.0);\n    M03[channel]/=pow(M00[channel],1.0+(0.0+3.0)/2.0);\n    M00[channel]=1.0;\n  }\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Compute Hu invariant moments.\n    */\n    channel_moments[channel].I[0]=M20[channel]+M02[channel];\n    channel_moments[channel].I[1]=(M20[channel]-M02[channel])*\n      (M20[channel]-M02[channel])+4.0*M11[channel]*M11[channel];\n    channel_moments[channel].I[2]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]-3.0*M12[channel])+(3.0*M21[channel]-M03[channel])*\n      (3.0*M21[channel]-M03[channel]);\n    channel_moments[channel].I[3]=(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])+(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]);\n    channel_moments[channel].I[4]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))+(3.0*M21[channel]-M03[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].I[5]=(M20[channel]-M02[channel])*\n      ((M30[channel]+M12[channel])*(M30[channel]+M12[channel])-\n      (M21[channel]+M03[channel])*(M21[channel]+M03[channel]))+\n      4.0*M11[channel]*(M30[channel]+M12[channel])*(M21[channel]+M03[channel]);\n    channel_moments[channel].I[6]=(3.0*M21[channel]-M03[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))-(M30[channel]-3*M12[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].I[7]=M11[channel]*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M03[channel]+M21[channel])*\n      (M03[channel]+M21[channel]))-(M20[channel]-M02[channel])*\n      (M30[channel]+M12[channel])*(M03[channel]+M21[channel]);\n  }\n  if (y < (ssize_t) image->rows)\n    channel_moments=(ChannelMoments *) RelinquishMagickMemory(channel_moments);\n  return(channel_moments);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l P e r c e p t u a l H a s h                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelPerceptualHash() returns the perceptual hash of one or more\n%  image channels.\n%\n%  The format of the GetImageChannelPerceptualHash method is:\n%\n%      ChannelPerceptualHash *GetImageChannelPerceptualHash(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickLog10(const double x)\n{\n#define Log10Epsilon  (1.0e-11)\n\n if (fabs(x) < Log10Epsilon)\n   return(log10(Log10Epsilon));\n return(log10(fabs(x)));\n}\n\nMagickExport ChannelPerceptualHash *GetImageChannelPerceptualHash(\n  const Image *image,ExceptionInfo *exception)\n{\n  ChannelMoments\n    *moments;\n\n  ChannelPerceptualHash\n    *perceptual_hash;\n\n  Image\n    *hash_image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    channel;\n\n  /*\n    Blur then transform to sRGB colorspace.\n  */\n  hash_image=BlurImage(image,0.0,1.0,exception);\n  if (hash_image == (Image *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  hash_image->depth=8;\n  status=TransformImageColorspace(hash_image,sRGBColorspace);\n  if (status == MagickFalse)\n    return((ChannelPerceptualHash *) NULL);\n  moments=GetImageChannelMoments(hash_image,exception);\n  hash_image=DestroyImage(hash_image);\n  if (moments == (ChannelMoments *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    CompositeChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  for (channel=0; channel <= CompositeChannels; channel++)\n    for (i=0; i < MaximumNumberOfImageMoments; i++)\n      perceptual_hash[channel].P[i]=(-MagickLog10(moments[channel].I[i]));\n  moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  /*\n    Blur then transform to HCLp colorspace.\n  */\n  hash_image=BlurImage(image,0.0,1.0,exception);\n  if (hash_image == (Image *) NULL)\n    {\n      perceptual_hash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        perceptual_hash);\n      return((ChannelPerceptualHash *) NULL);\n    }\n  hash_image->depth=8;\n  status=TransformImageColorspace(hash_image,HCLpColorspace);\n  if (status == MagickFalse)\n    {\n      perceptual_hash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        perceptual_hash);\n      return((ChannelPerceptualHash *) NULL);\n    }\n  moments=GetImageChannelMoments(hash_image,exception);\n  hash_image=DestroyImage(hash_image);\n  if (moments == (ChannelMoments *) NULL)\n    {\n      perceptual_hash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        perceptual_hash);\n      return((ChannelPerceptualHash *) NULL);\n    }\n  for (channel=0; channel <= CompositeChannels; channel++)\n    for (i=0; i < MaximumNumberOfImageMoments; i++)\n      perceptual_hash[channel].Q[i]=(-MagickLog10(moments[channel].I[i]));\n  moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  return(perceptual_hash);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l R a n g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelRange() returns the range of one or more image channels.\n%\n%  The format of the GetImageChannelRange method is:\n%\n%      MagickBooleanType GetImageChannelRange(const Image *image,\n%        const ChannelType channel,double *minima,double *maxima,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageRange(const Image *image,\n  double *minima,double *maxima,ExceptionInfo *exception)\n{\n  return(GetImageChannelRange(image,CompositeChannels,minima,maxima,exception));\n}\n\nMagickExport MagickBooleanType GetImageChannelRange(const Image *image,\n  const ChannelType channel,double *minima,double *maxima,\n  ExceptionInfo *exception)\n{\n  MagickPixelPacket\n    pixel;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *maxima=(-MagickMaximumValue);\n  *minima=MagickMaximumValue;\n  GetMagickPixelPacket(image,&pixel);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      if ((channel & RedChannel) != 0)\n        {\n          if (pixel.red < *minima)\n            *minima=(double) pixel.red;\n          if (pixel.red > *maxima)\n            *maxima=(double) pixel.red;\n        }\n      if ((channel & GreenChannel) != 0)\n        {\n          if (pixel.green < *minima)\n            *minima=(double) pixel.green;\n          if (pixel.green > *maxima)\n            *maxima=(double) pixel.green;\n        }\n      if ((channel & BlueChannel) != 0)\n        {\n          if (pixel.blue < *minima)\n            *minima=(double) pixel.blue;\n          if (pixel.blue > *maxima)\n            *maxima=(double) pixel.blue;\n        }\n      if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n        {\n          if ((QuantumRange-pixel.opacity) < *minima)\n            *minima=(double) (QuantumRange-pixel.opacity);\n          if ((QuantumRange-pixel.opacity) > *maxima)\n            *maxima=(double) (QuantumRange-pixel.opacity);\n        }\n      if (((channel & IndexChannel) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n          if ((double) pixel.index < *minima)\n            *minima=(double) pixel.index;\n          if ((double) pixel.index > *maxima)\n            *maxima=(double) pixel.index;\n        }\n      p++;\n    }\n  }\n  return(y == (ssize_t) image->rows ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l S t a t i s t i c s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelStatistics() returns statistics for each channel in the\n%  image.  The statistics include the channel depth, its minima, maxima, mean,\n%  standard deviation, kurtosis and skewness.  You can access the red channel\n%  mean, for example, like this:\n%\n%      channel_statistics=GetImageChannelStatistics(image,exception);\n%      red_mean=channel_statistics[RedChannel].mean;\n%\n%  Use MagickRelinquishMemory() to free the statistics buffer.\n%\n%  The format of the GetImageChannelStatistics method is:\n%\n%      ChannelStatistics *GetImageChannelStatistics(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ChannelStatistics *GetImageChannelStatistics(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  double\n    area,\n    standard_deviation;\n\n  MagickPixelPacket\n    number_bins,\n    *histogram;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i;\n\n  size_t\n    channels,\n    depth,\n    length;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=CompositeChannels+1UL;\n  channel_statistics=(ChannelStatistics *) AcquireQuantumMemory(length,\n    sizeof(*channel_statistics));\n  histogram=(MagickPixelPacket *) AcquireQuantumMemory(MaxMap+1U,\n    sizeof(*histogram));\n  if ((channel_statistics == (ChannelStatistics *) NULL) ||\n      (histogram == (MagickPixelPacket *) NULL))\n    {\n      if (histogram != (MagickPixelPacket *) NULL)\n        histogram=(MagickPixelPacket *) RelinquishMagickMemory(histogram);\n      if (channel_statistics != (ChannelStatistics *) NULL)\n        channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n          channel_statistics);\n      return(channel_statistics);\n    }\n  (void) memset(channel_statistics,0,length*\n    sizeof(*channel_statistics));\n  for (i=0; i <= (ssize_t) CompositeChannels; i++)\n  {\n    channel_statistics[i].depth=1;\n    channel_statistics[i].maxima=(-MagickMaximumValue);\n    channel_statistics[i].minima=MagickMaximumValue;\n  }\n  (void) memset(histogram,0,(MaxMap+1U)*sizeof(*histogram));\n  (void) memset(&number_bins,0,sizeof(number_bins));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute pixel statistics.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; )\n    {\n      if (channel_statistics[RedChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n        {\n          depth=channel_statistics[RedChannel].depth;\n          range=GetQuantumRange(depth);\n          if (IsPixelAtDepth(GetPixelRed(p),range) == MagickFalse)\n            {\n              channel_statistics[RedChannel].depth++;\n              continue;\n            }\n        }\n      if (channel_statistics[GreenChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n        {\n          depth=channel_statistics[GreenChannel].depth;\n          range=GetQuantumRange(depth);\n          if (IsPixelAtDepth(GetPixelGreen(p),range) == MagickFalse)\n            {\n              channel_statistics[GreenChannel].depth++;\n              continue;\n            }\n        }\n      if (channel_statistics[BlueChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n        {\n          depth=channel_statistics[BlueChannel].depth;\n          range=GetQuantumRange(depth);\n          if (IsPixelAtDepth(GetPixelBlue(p),range) == MagickFalse)\n            {\n              channel_statistics[BlueChannel].depth++;\n              continue;\n            }\n        }\n      if (image->matte != MagickFalse)\n        {\n          if (channel_statistics[OpacityChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n            {\n              depth=channel_statistics[OpacityChannel].depth;\n              range=GetQuantumRange(depth);\n              if (IsPixelAtDepth(GetPixelAlpha(p),range) == MagickFalse)\n                {\n                  channel_statistics[OpacityChannel].depth++;\n                  continue;\n                }\n            }\n          }\n      if (image->colorspace == CMYKColorspace)\n        {\n          if (channel_statistics[BlackChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n            {\n              depth=channel_statistics[BlackChannel].depth;\n              range=GetQuantumRange(depth);\n              if (IsPixelAtDepth(GetPixelIndex(indexes+x),range) == MagickFalse)\n                {\n                  channel_statistics[BlackChannel].depth++;\n                  continue;\n                }\n            }\n        }\n      if ((double) GetPixelRed(p) < channel_statistics[RedChannel].minima)\n        channel_statistics[RedChannel].minima=(double) GetPixelRed(p);\n      if ((double) GetPixelRed(p) > channel_statistics[RedChannel].maxima)\n        channel_statistics[RedChannel].maxima=(double) GetPixelRed(p);\n      channel_statistics[RedChannel].sum+=GetPixelRed(p);\n      channel_statistics[RedChannel].sum_squared+=(double) GetPixelRed(p)*\n        GetPixelRed(p);\n      channel_statistics[RedChannel].sum_cubed+=(double)\n        GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p);\n      channel_statistics[RedChannel].sum_fourth_power+=(double)\n        GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p);\n      if ((double) GetPixelGreen(p) < channel_statistics[GreenChannel].minima)\n        channel_statistics[GreenChannel].minima=(double) GetPixelGreen(p);\n      if ((double) GetPixelGreen(p) > channel_statistics[GreenChannel].maxima)\n        channel_statistics[GreenChannel].maxima=(double) GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum+=GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum_squared+=(double) GetPixelGreen(p)*\n        GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum_cubed+=(double) GetPixelGreen(p)*\n        GetPixelGreen(p)*GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum_fourth_power+=(double)\n        GetPixelGreen(p)*GetPixelGreen(p)*GetPixelGreen(p)*GetPixelGreen(p);\n      if ((double) GetPixelBlue(p) < channel_statistics[BlueChannel].minima)\n        channel_statistics[BlueChannel].minima=(double) GetPixelBlue(p);\n      if ((double) GetPixelBlue(p) > channel_statistics[BlueChannel].maxima)\n        channel_statistics[BlueChannel].maxima=(double) GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum+=GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum_squared+=(double) GetPixelBlue(p)*\n        GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum_cubed+=(double) GetPixelBlue(p)*\n        GetPixelBlue(p)*GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum_fourth_power+=(double)\n        GetPixelBlue(p)*GetPixelBlue(p)*GetPixelBlue(p)*GetPixelBlue(p);\n      histogram[ScaleQuantumToMap(GetPixelRed(p))].red++;\n      histogram[ScaleQuantumToMap(GetPixelGreen(p))].green++;\n      histogram[ScaleQuantumToMap(GetPixelBlue(p))].blue++;\n      if (image->matte != MagickFalse)\n        {\n          if ((double) GetPixelAlpha(p) < channel_statistics[OpacityChannel].minima)\n            channel_statistics[OpacityChannel].minima=(double) GetPixelAlpha(p);\n          if ((double) GetPixelAlpha(p) > channel_statistics[OpacityChannel].maxima)\n            channel_statistics[OpacityChannel].maxima=(double) GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum+=GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum_squared+=(double)\n            GetPixelAlpha(p)*GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum_cubed+=(double)\n            GetPixelAlpha(p)*GetPixelAlpha(p)*GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum_fourth_power+=(double)\n            GetPixelAlpha(p)*GetPixelAlpha(p)*GetPixelAlpha(p)*GetPixelAlpha(p);\n          histogram[ScaleQuantumToMap(GetPixelAlpha(p))].opacity++;\n        }\n      if (image->colorspace == CMYKColorspace)\n        {\n          if ((double) GetPixelIndex(indexes+x) < channel_statistics[BlackChannel].minima)\n            channel_statistics[BlackChannel].minima=(double)\n              GetPixelIndex(indexes+x);\n          if ((double) GetPixelIndex(indexes+x) > channel_statistics[BlackChannel].maxima)\n            channel_statistics[BlackChannel].maxima=(double)\n              GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum+=GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum_squared+=(double)\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum_cubed+=(double)\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x)*\n            GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum_fourth_power+=(double)\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x)*\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x);\n          histogram[ScaleQuantumToMap(GetPixelIndex(indexes+x))].index++;\n        }\n      x++;\n      p++;\n    }\n  }\n  for (i=0; i < (ssize_t) CompositeChannels; i++)\n  {\n    double\n      area,\n      mean,\n      standard_deviation;\n\n    /*\n      Normalize pixel statistics.\n    */\n    area=PerceptibleReciprocal((double) image->columns*image->rows);\n    mean=channel_statistics[i].sum*area;\n    channel_statistics[i].sum=mean;\n    channel_statistics[i].sum_squared*=area;\n    channel_statistics[i].sum_cubed*=area;\n    channel_statistics[i].sum_fourth_power*=area;\n    channel_statistics[i].mean=mean;\n    channel_statistics[i].variance=channel_statistics[i].sum_squared;\n    standard_deviation=sqrt(channel_statistics[i].variance-(mean*mean));\n    area=PerceptibleReciprocal((double) image->columns*image->rows-1.0)*\n      ((double) image->columns*image->rows);\n    standard_deviation=sqrt(area*standard_deviation*standard_deviation);\n    channel_statistics[i].standard_deviation=standard_deviation;\n  }\n  for (i=0; i < (ssize_t) (MaxMap+1U); i++)\n  {\n    if (histogram[i].red > 0.0)\n      number_bins.red++;\n    if (histogram[i].green > 0.0)\n      number_bins.green++;\n    if (histogram[i].blue > 0.0)\n      number_bins.blue++;\n    if ((image->matte != MagickFalse) && (histogram[i].opacity > 0.0))\n      number_bins.opacity++;\n    if ((image->colorspace == CMYKColorspace) && (histogram[i].index > 0.0))\n      number_bins.index++;\n  }\n  area=PerceptibleReciprocal((double) image->columns*image->rows);\n  for (i=0; i < (ssize_t) (MaxMap+1U); i++)\n  {\n    /*\n      Compute pixel entropy.\n    */\n    histogram[i].red*=area;\n    channel_statistics[RedChannel].entropy+=-histogram[i].red*\n      MagickLog10(histogram[i].red)*\n      PerceptibleReciprocal(MagickLog10((double) number_bins.red));\n    histogram[i].green*=area;\n    channel_statistics[GreenChannel].entropy+=-histogram[i].green*\n      MagickLog10(histogram[i].green)*\n      PerceptibleReciprocal(MagickLog10((double) number_bins.green));\n    histogram[i].blue*=area;\n    channel_statistics[BlueChannel].entropy+=-histogram[i].blue*\n      MagickLog10(histogram[i].blue)*\n      PerceptibleReciprocal(MagickLog10((double) number_bins.blue));\n    if (image->matte != MagickFalse)\n      {\n        histogram[i].opacity*=area;\n        channel_statistics[OpacityChannel].entropy+=-histogram[i].opacity*\n          MagickLog10(histogram[i].opacity)*\n          PerceptibleReciprocal(MagickLog10((double) number_bins.opacity));\n      }\n    if (image->colorspace == CMYKColorspace)\n      {\n        histogram[i].index*=area;\n        channel_statistics[IndexChannel].entropy+=-histogram[i].index*\n          MagickLog10(histogram[i].index)*\n          PerceptibleReciprocal(MagickLog10((double) number_bins.index));\n      }\n  }\n  /*\n    Compute overall statistics.\n  */\n  for (i=0; i < (ssize_t) CompositeChannels; i++)\n  {\n    channel_statistics[CompositeChannels].depth=(size_t) EvaluateMax((double)\n      channel_statistics[CompositeChannels].depth,(double)\n      channel_statistics[i].depth);\n    channel_statistics[CompositeChannels].minima=MagickMin(\n      channel_statistics[CompositeChannels].minima,\n      channel_statistics[i].minima);\n    channel_statistics[CompositeChannels].maxima=EvaluateMax(\n      channel_statistics[CompositeChannels].maxima,\n      channel_statistics[i].maxima);\n    channel_statistics[CompositeChannels].sum+=channel_statistics[i].sum;\n    channel_statistics[CompositeChannels].sum_squared+=\n      channel_statistics[i].sum_squared;\n    channel_statistics[CompositeChannels].sum_cubed+=\n      channel_statistics[i].sum_cubed;\n    channel_statistics[CompositeChannels].sum_fourth_power+=\n      channel_statistics[i].sum_fourth_power;\n    channel_statistics[CompositeChannels].mean+=channel_statistics[i].mean;\n    channel_statistics[CompositeChannels].variance+=\n      channel_statistics[i].variance-channel_statistics[i].mean*\n      channel_statistics[i].mean;\n    standard_deviation=sqrt(channel_statistics[i].variance-\n      (channel_statistics[i].mean*channel_statistics[i].mean));\n    area=PerceptibleReciprocal((double) image->columns*image->rows-1.0)*\n      ((double) image->columns*image->rows);\n    standard_deviation=sqrt(area*standard_deviation*standard_deviation);\n    channel_statistics[CompositeChannels].standard_deviation=standard_deviation;\n    channel_statistics[CompositeChannels].entropy+=\n      channel_statistics[i].entropy;\n  }\n  channels=3;\n  if (image->matte != MagickFalse)\n    channels++;\n  if (image->colorspace == CMYKColorspace)\n    channels++;\n  channel_statistics[CompositeChannels].sum/=channels;\n  channel_statistics[CompositeChannels].sum_squared/=channels;\n  channel_statistics[CompositeChannels].sum_cubed/=channels;\n  channel_statistics[CompositeChannels].sum_fourth_power/=channels;\n  channel_statistics[CompositeChannels].mean/=channels;\n  channel_statistics[CompositeChannels].kurtosis/=channels;\n  channel_statistics[CompositeChannels].skewness/=channels;\n  channel_statistics[CompositeChannels].entropy/=channels;\n  i=CompositeChannels;\n  area=PerceptibleReciprocal((double) channels*image->columns*image->rows);\n  channel_statistics[i].variance=channel_statistics[i].sum_squared;\n  channel_statistics[i].mean=channel_statistics[i].sum;\n  standard_deviation=sqrt(channel_statistics[i].variance-\n    (channel_statistics[i].mean*channel_statistics[i].mean));\n  standard_deviation=sqrt(PerceptibleReciprocal((double) channels*\n    image->columns*image->rows-1.0)*channels*image->columns*image->rows*\n    standard_deviation*standard_deviation);\n  channel_statistics[i].standard_deviation=standard_deviation;\n  for (i=0; i <= (ssize_t) CompositeChannels; i++)\n  {\n    /*\n      Compute kurtosis & skewness statistics.\n    */\n    standard_deviation=PerceptibleReciprocal(\n      channel_statistics[i].standard_deviation);\n    channel_statistics[i].skewness=(channel_statistics[i].sum_cubed-3.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_squared+2.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation);\n    channel_statistics[i].kurtosis=(channel_statistics[i].sum_fourth_power-4.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_cubed+6.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].sum_squared-3.0*channel_statistics[i].mean*\n      channel_statistics[i].mean*1.0*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation*standard_deviation)-3.0;\n  }\n  channel_statistics[CompositeChannels].mean=0.0;\n  channel_statistics[CompositeChannels].standard_deviation=0.0;\n  for (i=0; i < (ssize_t) CompositeChannels; i++)\n  {\n    channel_statistics[CompositeChannels].mean+=\n      channel_statistics[i].mean;\n    channel_statistics[CompositeChannels].standard_deviation+=\n      channel_statistics[i].standard_deviation;\n  }\n  channel_statistics[CompositeChannels].mean/=(double) channels;\n  channel_statistics[CompositeChannels].standard_deviation/=(double) channels;\n  histogram=(MagickPixelPacket *) RelinquishMagickMemory(histogram);\n  if (y < (ssize_t) image->rows)\n    channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n      channel_statistics);\n  return(channel_statistics);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P o l y n o m i a l I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PolynomialImage() returns a new image where each pixel is the sum of the\n%  pixels in the image sequence after applying its corresponding terms\n%  (coefficient and degree pairs).\n%\n%  The format of the PolynomialImage method is:\n%\n%      Image *PolynomialImage(const Image *images,const size_t number_terms,\n%        const double *terms,ExceptionInfo *exception)\n%      Image *PolynomialImageChannel(const Image *images,\n%        const size_t number_terms,const ChannelType channel,\n%        const double *terms,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o channel: the channel.\n%\n%    o number_terms: the number of terms in the list.  The actual list length\n%      is 2 x number_terms + 1 (the constant).\n%\n%    o terms: the list of polynomial coefficients and degree pairs and a\n%      constant.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PolynomialImage(const Image *images,\n  const size_t number_terms,const double *terms,ExceptionInfo *exception)\n{\n  Image\n    *polynomial_image;\n\n  polynomial_image=PolynomialImageChannel(images,DefaultChannels,number_terms,\n    terms,exception);\n  return(polynomial_image);\n}\n\nMagickExport Image *PolynomialImageChannel(const Image *images,\n  const ChannelType channel,const size_t number_terms,const double *terms,\n  ExceptionInfo *exception)\n{\n#define PolynomialImageTag  \"Polynomial/Image\"\n\n  CacheView\n    *polynomial_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickPixelPacket\n    **magick_restrict polynomial_pixels,\n    zero;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  polynomial_pixels=AcquirePixelThreadSet(images);\n  if (polynomial_pixels == (MagickPixelPacket **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Polynomial image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  GetMagickPixelPacket(images,&zero);\n  polynomial_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    CacheView\n      *image_view;\n\n    const Image\n      *next;\n\n    const int\n      id = GetOpenMPThreadId();\n\n    register IndexPacket\n      *magick_restrict polynomial_indexes;\n\n    register MagickPixelPacket\n      *polynomial_pixel;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    size_t\n      number_images;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(polynomial_view,0,y,image->columns,1,\n      exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    polynomial_indexes=GetCacheViewAuthenticIndexQueue(polynomial_view);\n    polynomial_pixel=polynomial_pixels[id];\n    for (x=0; x < (ssize_t) image->columns; x++)\n      polynomial_pixel[x]=zero;\n    next=images;\n    number_images=GetImageListLength(images);\n    for (i=0; i < (ssize_t) number_images; i++)\n    {\n      register const IndexPacket\n        *indexes;\n\n      register const PixelPacket\n        *p;\n\n      if (i >= (ssize_t) number_terms)\n        break;\n      image_view=AcquireVirtualCacheView(next,exception);\n      p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n      if (p == (const PixelPacket *) NULL)\n        {\n          image_view=DestroyCacheView(image_view);\n          break;\n        }\n      indexes=GetCacheViewVirtualIndexQueue(image_view);\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        double\n          coefficient,\n          degree;\n\n        coefficient=terms[i << 1];\n        degree=terms[(i << 1)+1];\n        if ((channel & RedChannel) != 0)\n          polynomial_pixel[x].red+=coefficient*pow(QuantumScale*p->red,degree);\n        if ((channel & GreenChannel) != 0)\n          polynomial_pixel[x].green+=coefficient*pow(QuantumScale*p->green,\n            degree);\n        if ((channel & BlueChannel) != 0)\n          polynomial_pixel[x].blue+=coefficient*pow(QuantumScale*p->blue,\n            degree);\n        if ((channel & OpacityChannel) != 0)\n          polynomial_pixel[x].opacity+=coefficient*pow(QuantumScale*\n            (QuantumRange-p->opacity),degree);\n        if (((channel & IndexChannel) != 0) &&\n            (image->colorspace == CMYKColorspace))\n          polynomial_pixel[x].index+=coefficient*pow(QuantumScale*indexes[x],\n            degree);\n        p++;\n      }\n      image_view=DestroyCacheView(image_view);\n      next=GetNextImageInList(next);\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ClampToQuantum(QuantumRange*polynomial_pixel[x].red));\n      SetPixelGreen(q,ClampToQuantum(QuantumRange*polynomial_pixel[x].green));\n      SetPixelBlue(q,ClampToQuantum(QuantumRange*polynomial_pixel[x].blue));\n      if (image->matte == MagickFalse)\n        SetPixelOpacity(q,ClampToQuantum(QuantumRange-QuantumRange*\n          polynomial_pixel[x].opacity));\n      else\n        SetPixelAlpha(q,ClampToQuantum(QuantumRange-QuantumRange*\n          polynomial_pixel[x].opacity));\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(polynomial_indexes+x,ClampToQuantum(QuantumRange*\n          polynomial_pixel[x].index));\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(polynomial_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(images,PolynomialImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  polynomial_view=DestroyCacheView(polynomial_view);\n  polynomial_pixels=DestroyPixelThreadSet(images,polynomial_pixels);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S t a t i s t i c I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StatisticImage() makes each pixel the min / max / median / mode / etc. of\n%  the neighborhood of the specified width and height.\n%\n%  The format of the StatisticImage method is:\n%\n%      Image *StatisticImage(const Image *image,const StatisticType type,\n%        const size_t width,const size_t height,ExceptionInfo *exception)\n%      Image *StatisticImageChannel(const Image *image,\n%        const ChannelType channel,const StatisticType type,\n%        const size_t width,const size_t height,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the image channel.\n%\n%    o type: the statistic type (median, mode, etc.).\n%\n%    o width: the width of the pixel neighborhood.\n%\n%    o height: the height of the pixel neighborhood.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#define ListChannels  5\n\ntypedef struct _ListNode\n{\n  size_t\n    next[9],\n    count,\n    signature;\n} ListNode;\n\ntypedef struct _SkipList\n{\n  ssize_t\n    level;\n\n  ListNode\n    *nodes;\n} SkipList;\n\ntypedef struct _PixelList\n{\n  size_t\n    length,\n    seed,\n    signature;\n\n  SkipList\n    lists[ListChannels];\n} PixelList;\n\nstatic PixelList *DestroyPixelList(PixelList *pixel_list)\n{\n  register ssize_t\n    i;\n\n  if (pixel_list == (PixelList *) NULL)\n    return((PixelList *) NULL);\n  for (i=0; i < ListChannels; i++)\n    if (pixel_list->lists[i].nodes != (ListNode *) NULL)\n      pixel_list->lists[i].nodes=(ListNode *) RelinquishAlignedMemory(\n        pixel_list->lists[i].nodes);\n  pixel_list=(PixelList *) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList **DestroyPixelListThreadSet(PixelList **pixel_list)\n{\n  register ssize_t\n    i;\n\n  assert(pixel_list != (PixelList **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixel_list[i] != (PixelList *) NULL)\n      pixel_list[i]=DestroyPixelList(pixel_list[i]);\n  pixel_list=(PixelList **) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList *AcquirePixelList(const size_t width,const size_t height)\n{\n  PixelList\n    *pixel_list;\n\n  register ssize_t\n    i;\n\n  pixel_list=(PixelList *) AcquireMagickMemory(sizeof(*pixel_list));\n  if (pixel_list == (PixelList *) NULL)\n    return(pixel_list);\n  (void) memset((void *) pixel_list,0,sizeof(*pixel_list));\n  pixel_list->length=width*height;\n  for (i=0; i < ListChannels; i++)\n  {\n    pixel_list->lists[i].nodes=(ListNode *) AcquireAlignedMemory(65537UL,\n      sizeof(*pixel_list->lists[i].nodes));\n    if (pixel_list->lists[i].nodes == (ListNode *) NULL)\n      return(DestroyPixelList(pixel_list));\n    (void) memset(pixel_list->lists[i].nodes,0,65537UL*\n      sizeof(*pixel_list->lists[i].nodes));\n  }\n  pixel_list->signature=MagickCoreSignature;\n  return(pixel_list);\n}\n\nstatic PixelList **AcquirePixelListThreadSet(const size_t width,\n  const size_t height)\n{\n  PixelList\n    **pixel_list;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixel_list=(PixelList **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixel_list));\n  if (pixel_list == (PixelList **) NULL)\n    return((PixelList **) NULL);\n  (void) memset(pixel_list,0,number_threads*sizeof(*pixel_list));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixel_list[i]=AcquirePixelList(width,height);\n    if (pixel_list[i] == (PixelList *) NULL)\n      return(DestroyPixelListThreadSet(pixel_list));\n  }\n  return(pixel_list);\n}\n\nstatic void AddNodePixelList(PixelList *pixel_list,const ssize_t channel,\n  const size_t color)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    level;\n\n  size_t\n    search,\n    update[9];\n\n  /*\n    Initialize the node.\n  */\n  list=pixel_list->lists+channel;\n  list->nodes[color].signature=pixel_list->signature;\n  list->nodes[color].count=1;\n  /*\n    Determine where it belongs in the list.\n  */\n  search=65536UL;\n  for (level=list->level; level >= 0; level--)\n  {\n    while (list->nodes[search].next[level] < color)\n      search=list->nodes[search].next[level];\n    update[level]=search;\n  }\n  /*\n    Generate a pseudo-random level for this node.\n  */\n  for (level=0; ; level++)\n  {\n    pixel_list->seed=(pixel_list->seed*42893621L)+1L;\n    if ((pixel_list->seed & 0x300) != 0x300)\n      break;\n  }\n  if (level > 8)\n    level=8;\n  if (level > (list->level+2))\n    level=list->level+2;\n  /*\n    If we're raising the list's level, link back to the root node.\n  */\n  while (level > list->level)\n  {\n    list->level++;\n    update[list->level]=65536UL;\n  }\n  /*\n    Link the node into the skip-list.\n  */\n  do\n  {\n    list->nodes[color].next[level]=list->nodes[update[level]].next[level];\n    list->nodes[update[level]].next[level]=color;\n  } while (level-- > 0);\n}\n\nstatic void GetMaximumPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    maximum;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the maximum value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    maximum=list->nodes[color].next[0];\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (color > maximum)\n        maximum=color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) maximum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetMeanPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the mean value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    channels[channel]=(unsigned short) sum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetMedianPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the median value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      count+=list->nodes[color].count;\n    } while (count <= (ssize_t) (pixel_list->length >> 1));\n    channels[channel]=(unsigned short) color;\n  }\n  GetMagickPixelPacket((const Image *) NULL,pixel);\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetMinimumPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    minimum;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the minimum value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    count=0;\n    color=65536UL;\n    minimum=list->nodes[color].next[0];\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (color < minimum)\n        minimum=color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) minimum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetModePixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    max_count,\n    mode;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[5];\n\n  /*\n    Make each pixel the 'predominant color' of the specified neighborhood.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    mode=color;\n    max_count=list->nodes[mode].count;\n    count=0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (list->nodes[color].count > max_count)\n        {\n          mode=color;\n          max_count=list->nodes[mode].count;\n        }\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) mode;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetNonpeakPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    next,\n    previous;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[5];\n\n  /*\n    Finds the non peak value for each of the colors.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    next=list->nodes[color].next[0];\n    count=0;\n    do\n    {\n      previous=color;\n      color=next;\n      next=list->nodes[color].next[0];\n      count+=list->nodes[color].count;\n    } while (count <= (ssize_t) (pixel_list->length >> 1));\n    if ((previous == 65536UL) && (next != 65536UL))\n      color=next;\n    else\n      if ((previous != 65536UL) && (next == 65536UL))\n        color=previous;\n    channels[channel]=(unsigned short) color;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetRootMeanSquarePixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the root mean square value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) (list->nodes[color].count*color*color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum);\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetStandardDeviationPixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum,\n    sum_squared;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the standard-deviation value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    sum_squared=0.0;\n    do\n    {\n      register ssize_t\n        i;\n\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      for (i=0; i < (ssize_t) list->nodes[color].count; i++)\n        sum_squared+=((MagickRealType) color)*((MagickRealType) color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    sum_squared/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum_squared-(sum*sum));\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic inline void InsertPixelList(const Image *image,const PixelPacket *pixel,\n  const IndexPacket *indexes,PixelList *pixel_list)\n{\n  size_t\n    signature;\n\n  unsigned short\n    index;\n\n  index=ScaleQuantumToShort(GetPixelRed(pixel));\n  signature=pixel_list->lists[0].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[0].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,0,index);\n  index=ScaleQuantumToShort(GetPixelGreen(pixel));\n  signature=pixel_list->lists[1].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[1].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,1,index);\n  index=ScaleQuantumToShort(GetPixelBlue(pixel));\n  signature=pixel_list->lists[2].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[2].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,2,index);\n  index=ScaleQuantumToShort(GetPixelOpacity(pixel));\n  signature=pixel_list->lists[3].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[3].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,3,index);\n  if (image->colorspace == CMYKColorspace)\n    index=ScaleQuantumToShort(GetPixelIndex(indexes));\n  signature=pixel_list->lists[4].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[4].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,4,index);\n}\n\nstatic void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n\n  register ListNode\n    *root;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  /*\n    Reset the skip-list.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    root=list->nodes+65536UL;\n    list->level=0;\n    for (level=0; level < 9; level++)\n      root->next[level]=65536UL;\n  }\n  pixel_list->seed=pixel_list->signature++;\n}\n\nMagickExport Image *StatisticImage(const Image *image,const StatisticType type,\n  const size_t width,const size_t height,ExceptionInfo *exception)\n{\n  Image\n    *statistic_image;\n\n  statistic_image=StatisticImageChannel(image,DefaultChannels,type,width,\n    height,exception);\n  return(statistic_image);\n}\n\nMagickExport Image *StatisticImageChannel(const Image *image,\n  const ChannelType channel,const StatisticType type,const size_t width,\n  const size_t height,ExceptionInfo *exception)\n{\n#define StatisticImageTag  \"Statistic/Image\"\n\n  CacheView\n    *image_view,\n    *statistic_view;\n\n  Image\n    *statistic_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelList\n    **magick_restrict pixel_list;\n\n  size_t\n    neighbor_height,\n    neighbor_width;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize statistics image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  statistic_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (statistic_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(statistic_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&statistic_image->exception);\n      statistic_image=DestroyImage(statistic_image);\n      return((Image *) NULL);\n    }\n  neighbor_width=width == 0 ? GetOptimalKernelWidth2D((double) width,0.5) :\n    width;\n  neighbor_height=height == 0 ? GetOptimalKernelWidth2D((double) height,0.5) :\n    height;\n  pixel_list=AcquirePixelListThreadSet(neighbor_width,neighbor_height);\n  if (pixel_list == (PixelList **) NULL)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Make each pixel the min / max / median / mode / etc. of the neighborhood.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  statistic_view=AcquireAuthenticCacheView(statistic_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,statistic_image,statistic_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) statistic_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register IndexPacket\n      *magick_restrict statistic_indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) neighbor_width/2L),y-\n      (ssize_t) (neighbor_height/2L),image->columns+neighbor_width,\n      neighbor_height,exception);\n    q=QueueCacheViewAuthenticPixels(statistic_view,0,y,statistic_image->columns,      1,exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    statistic_indexes=GetCacheViewAuthenticIndexQueue(statistic_view);\n    for (x=0; x < (ssize_t) statistic_image->columns; x++)\n    {\n      MagickPixelPacket\n        pixel;\n\n      register const IndexPacket\n        *magick_restrict s;\n\n      register const PixelPacket\n        *magick_restrict r;\n\n      register ssize_t\n        u,\n        v;\n\n      r=p;\n      s=indexes+x;\n      ResetPixelList(pixel_list[id]);\n      for (v=0; v < (ssize_t) neighbor_height; v++)\n      {\n        for (u=0; u < (ssize_t) neighbor_width; u++)\n          InsertPixelList(image,r+u,s+u,pixel_list[id]);\n        r+=image->columns+neighbor_width;\n        s+=image->columns+neighbor_width;\n      }\n      GetMagickPixelPacket(image,&pixel);\n      SetMagickPixelPacket(image,p+neighbor_width*neighbor_height/2,indexes+x+\n        neighbor_width*neighbor_height/2,&pixel);\n      switch (type)\n      {\n        case GradientStatistic:\n        {\n          MagickPixelPacket\n            maximum,\n            minimum;\n\n          GetMinimumPixelList(pixel_list[id],&pixel);\n          minimum=pixel;\n          GetMaximumPixelList(pixel_list[id],&pixel);\n          maximum=pixel;\n          pixel.red=MagickAbsoluteValue(maximum.red-minimum.red);\n          pixel.green=MagickAbsoluteValue(maximum.green-minimum.green);\n          pixel.blue=MagickAbsoluteValue(maximum.blue-minimum.blue);\n          pixel.opacity=MagickAbsoluteValue(maximum.opacity-minimum.opacity);\n          if (image->colorspace == CMYKColorspace)\n            pixel.index=MagickAbsoluteValue(maximum.index-minimum.index);\n          break;\n        }\n        case MaximumStatistic:\n        {\n          GetMaximumPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case MeanStatistic:\n        {\n          GetMeanPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case MedianStatistic:\n        default:\n        {\n          GetMedianPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case MinimumStatistic:\n        {\n          GetMinimumPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case ModeStatistic:\n        {\n          GetModePixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case NonpeakStatistic:\n        {\n          GetNonpeakPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case RootMeanSquareStatistic:\n        {\n          GetRootMeanSquarePixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case StandardDeviationStatistic:\n        {\n          GetStandardDeviationPixelList(pixel_list[id],&pixel);\n          break;\n        }\n      }\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q,ClampToQuantum(pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q,ClampToQuantum(pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q,ClampToQuantum(pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n        SetPixelOpacity(q,ClampToQuantum(pixel.opacity));\n      if (((channel & IndexChannel) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        SetPixelIndex(statistic_indexes+x,ClampToQuantum(pixel.index));\n      p++;\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(statistic_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,StatisticImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  statistic_view=DestroyCacheView(statistic_view);\n  image_view=DestroyCacheView(image_view);\n  pixel_list=DestroyPixelListThreadSet(pixel_list);\n  if (status == MagickFalse)\n    statistic_image=DestroyImage(statistic_image);\n  return(statistic_image);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        SSSSS  TTTTT   AAA   TTTTT  IIIII  SSSSS  TTTTT  IIIII   CCCC        %\n%        SS       T    A   A    T      I    SS       T      I    C            %\n%         SSS     T    AAAAA    T      I     SSS     T      I    C            %\n%           SS    T    A   A    T      I       SS    T      I    C            %\n%        SSSSS    T    A   A    T    IIIII  SSSSS    T    IIIII   CCCC        %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Statistical Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/accelerate-private.h\"\n#include \"magick/animate.h\"\n#include \"magick/animate.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-private.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/client.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/composite.h\"\n#include \"magick/composite-private.h\"\n#include \"magick/compress.h\"\n#include \"magick/constitute.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/draw.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/list.h\"\n#include \"magick/image-private.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/random_.h\"\n#include \"magick/random-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/signature-private.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/timer.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     E v a l u a t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EvaluateImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the EvaluateImageChannel method is:\n%\n%      MagickBooleanType EvaluateImage(Image *image,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%      MagickBooleanType EvaluateImages(Image *images,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%      MagickBooleanType EvaluateImageChannel(Image *image,\n%        const ChannelType channel,const MagickEvaluateOperator op,\n%        const double value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o op: A channel op.\n%\n%    o value: A value value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickPixelPacket **DestroyPixelThreadSet(const Image *images,\n  MagickPixelPacket **pixels)\n{\n  register ssize_t\n    i;\n\n  size_t\n    rows;\n\n  assert(pixels != (MagickPixelPacket **) NULL);\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (MagickPixelPacket *) NULL)\n      pixels[i]=(MagickPixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(MagickPixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic MagickPixelPacket **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n\n  MagickPixelPacket\n    **pixels;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    columns,\n    rows;\n\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(rows,sizeof(*pixels));\n  if (pixels == (MagickPixelPacket **) NULL)\n    return((MagickPixelPacket **) NULL);\n  (void) memset(pixels,0,rows*sizeof(*pixels));\n  columns=GetImageListLength(images);\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) rows; i++)\n  {\n    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,\n      sizeof(**pixels));\n    if (pixels[i] == (MagickPixelPacket *) NULL)\n      return(DestroyPixelThreadSet(images,pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n      GetMagickPixelPacket(images,&pixels[i][j]);\n  }\n  return(pixels);\n}\n\nstatic inline double EvaluateMax(const double x,const double y)\n{\n  if (x > y)\n    return(x);\n  return(y);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int IntensityCompare(const void *x,const void *y)\n{\n  const MagickPixelPacket\n    *color_1,\n    *color_2;\n\n  int\n    intensity;\n\n  color_1=(const MagickPixelPacket *) x;\n  color_2=(const MagickPixelPacket *) y;\n  intensity=(int) MagickPixelIntensity(color_2)-(int)\n    MagickPixelIntensity(color_1);\n  return(intensity);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickRealType ApplyEvaluateOperator(RandomInfo *random_info,\n  const Quantum pixel,const MagickEvaluateOperator op,\n  const MagickRealType value)\n{\n  MagickRealType\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(MagickRealType) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a\n        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale*\n        pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        ImpulseNoise,value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(MagickRealType) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(MagickRealType) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 :\n        QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange :\n        pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}\n\nstatic Image *AcquireImageCanvas(const Image *images,ExceptionInfo *exception)\n{\n  const Image\n    *p,\n    *q;\n\n  size_t\n    columns,\n    number_channels,\n    rows;\n\n  q=images;\n  columns=images->columns;\n  rows=images->rows;\n  number_channels=0;\n  for (p=images; p != (Image *) NULL; p=p->next)\n  {\n    size_t\n      channels;\n\n    channels=3;\n    if (p->matte != MagickFalse)\n      channels+=1;\n    if (p->colorspace == CMYKColorspace)\n      channels+=1;\n    if (channels > number_channels)\n      {\n        number_channels=channels;\n        q=p;\n      }\n    if (p->columns > columns)\n      columns=p->columns;\n    if (p->rows > rows)\n      rows=p->rows;\n  }\n  return(CloneImage(q,columns,rows,MagickTrue,exception));\n}\n\nMagickExport MagickBooleanType EvaluateImage(Image *image,\n  const MagickEvaluateOperator op,const double value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=EvaluateImageChannel(image,CompositeChannels,op,value,exception);\n  return(status);\n}\n\nMagickExport Image *EvaluateImages(const Image *images,\n  const MagickEvaluateOperator op,ExceptionInfo *exception)\n{\n#define EvaluateImageTag  \"Evaluate/Image\"\n\n  CacheView\n    *evaluate_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickPixelPacket\n    **magick_restrict evaluate_pixels,\n    zero;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  size_t\n    number_images;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  evaluate_pixels=AcquirePixelThreadSet(images);\n  if (evaluate_pixels == (MagickPixelPacket **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Evaluate image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_images=GetImageListLength(images);\n  GetMagickPixelPacket(images,&zero);\n  random_info=AcquireRandomInfoThreadSet();\n  evaluate_view=AcquireAuthenticCacheView(image,exception);\n  if (op == MedianEvaluateOperator)\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register IndexPacket\n          *magick_restrict evaluate_indexes;\n\n        register MagickPixelPacket\n          *evaluate_pixel;\n\n        register PixelPacket\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_indexes=GetCacheViewAuthenticIndexQueue(evaluate_view);\n        evaluate_pixel=evaluate_pixels[id];\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) number_images; i++)\n            evaluate_pixel[i]=zero;\n          next=images;\n          for (i=0; i < (ssize_t) number_images; i++)\n          {\n            register const IndexPacket\n              *indexes;\n\n            register const PixelPacket\n              *p;\n\n            image_view=AcquireVirtualCacheView(next,exception);\n            p=GetCacheViewVirtualPixels(image_view,x,y,1,1,exception);\n            if (p == (const PixelPacket *) NULL)\n              {\n                image_view=DestroyCacheView(image_view);\n                break;\n              }\n            indexes=GetCacheViewVirtualIndexQueue(image_view);\n            evaluate_pixel[i].red=ApplyEvaluateOperator(random_info[id],\n              GetPixelRed(p),op,evaluate_pixel[i].red);\n            evaluate_pixel[i].green=ApplyEvaluateOperator(random_info[id],\n              GetPixelGreen(p),op,evaluate_pixel[i].green);\n            evaluate_pixel[i].blue=ApplyEvaluateOperator(random_info[id],\n              GetPixelBlue(p),op,evaluate_pixel[i].blue);\n            evaluate_pixel[i].opacity=ApplyEvaluateOperator(random_info[id],\n              GetPixelAlpha(p),op,evaluate_pixel[i].opacity);\n            if (image->colorspace == CMYKColorspace)\n              evaluate_pixel[i].index=ApplyEvaluateOperator(random_info[id],\n                *indexes,op,evaluate_pixel[i].index);\n            image_view=DestroyCacheView(image_view);\n            next=GetNextImageInList(next);\n          }\n          qsort((void *) evaluate_pixel,number_images,sizeof(*evaluate_pixel),\n            IntensityCompare);\n          SetPixelRed(q,ClampToQuantum(evaluate_pixel[i/2].red));\n          SetPixelGreen(q,ClampToQuantum(evaluate_pixel[i/2].green));\n          SetPixelBlue(q,ClampToQuantum(evaluate_pixel[i/2].blue));\n          SetPixelAlpha(q,ClampToQuantum(evaluate_pixel[i/2].opacity));\n          if (image->colorspace == CMYKColorspace)\n            SetPixelIndex(evaluate_indexes+i,ClampToQuantum(\n              evaluate_pixel[i/2].index));\n          q++;\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp atomic\n#endif\n            progress++;\n            proceed=SetImageProgress(images,EvaluateImageTag,progress,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  else\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register IndexPacket\n          *magick_restrict evaluate_indexes;\n\n        register ssize_t\n          i,\n          x;\n\n        register MagickPixelPacket\n          *evaluate_pixel;\n\n        register PixelPacket\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_indexes=GetCacheViewAuthenticIndexQueue(evaluate_view);\n        evaluate_pixel=evaluate_pixels[id];\n        for (x=0; x < (ssize_t) image->columns; x++)\n          evaluate_pixel[x]=zero;\n        next=images;\n        for (i=0; i < (ssize_t) number_images; i++)\n        {\n          register const IndexPacket\n            *indexes;\n\n          register const PixelPacket\n            *p;\n\n          image_view=AcquireVirtualCacheView(next,exception);\n          p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,\n            exception);\n          if (p == (const PixelPacket *) NULL)\n            {\n              image_view=DestroyCacheView(image_view);\n              break;\n            }\n          indexes=GetCacheViewVirtualIndexQueue(image_view);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            evaluate_pixel[x].red=ApplyEvaluateOperator(random_info[id],\n              GetPixelRed(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].red);\n            evaluate_pixel[x].green=ApplyEvaluateOperator(random_info[id],\n              GetPixelGreen(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].green);\n            evaluate_pixel[x].blue=ApplyEvaluateOperator(random_info[id],\n              GetPixelBlue(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].blue);\n            evaluate_pixel[x].opacity=ApplyEvaluateOperator(random_info[id],\n              GetPixelAlpha(p),i == 0 ? AddEvaluateOperator : op,\n              evaluate_pixel[x].opacity);\n            if (image->colorspace == CMYKColorspace)\n              evaluate_pixel[x].index=ApplyEvaluateOperator(random_info[id],\n                GetPixelIndex(indexes+x),i == 0 ? AddEvaluateOperator : op,\n                evaluate_pixel[x].index);\n            p++;\n          }\n          image_view=DestroyCacheView(image_view);\n          next=GetNextImageInList(next);\n        }\n        if (op == MeanEvaluateOperator)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            evaluate_pixel[x].red/=number_images;\n            evaluate_pixel[x].green/=number_images;\n            evaluate_pixel[x].blue/=number_images;\n            evaluate_pixel[x].opacity/=number_images;\n            evaluate_pixel[x].index/=number_images;\n          }\n        if (op == RootMeanSquareEvaluateOperator)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            evaluate_pixel[x].red=sqrt((double) evaluate_pixel[x].red/\n              number_images);\n            evaluate_pixel[x].green=sqrt((double) evaluate_pixel[x].green/\n              number_images);\n            evaluate_pixel[x].blue=sqrt((double) evaluate_pixel[x].blue/\n              number_images);\n            evaluate_pixel[x].opacity=sqrt((double) evaluate_pixel[x].opacity/\n              number_images);\n            evaluate_pixel[x].index=sqrt((double) evaluate_pixel[x].index/\n              number_images);\n          }\n        if (op == MultiplyEvaluateOperator)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            register ssize_t\n              j;\n\n            for (j=0; j < (ssize_t) (number_images-1); j++)\n            {\n              evaluate_pixel[x].red*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].green*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].blue*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].opacity*=(MagickRealType) QuantumScale;\n              evaluate_pixel[x].index*=(MagickRealType) QuantumScale;\n            }\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(q,ClampToQuantum(evaluate_pixel[x].red));\n          SetPixelGreen(q,ClampToQuantum(evaluate_pixel[x].green));\n          SetPixelBlue(q,ClampToQuantum(evaluate_pixel[x].blue));\n          SetPixelAlpha(q,ClampToQuantum(evaluate_pixel[x].opacity));\n          if (image->colorspace == CMYKColorspace)\n            SetPixelIndex(evaluate_indexes+x,ClampToQuantum(\n              evaluate_pixel[x].index));\n          q++;\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(images,EvaluateImageTag,progress++,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  evaluate_view=DestroyCacheView(evaluate_view);\n  evaluate_pixels=DestroyPixelThreadSet(images,evaluate_pixels);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\nMagickExport MagickBooleanType EvaluateImageChannel(Image *image,\n  const ChannelType channel,const MagickEvaluateOperator op,const double value,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(MagickFalse);\n    }\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        result;\n\n      if ((channel & RedChannel) != 0)\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelRed(q),op,value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelRed(q,ClampToQuantum(result));\n        }\n      if ((channel & GreenChannel) != 0)\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelGreen(q),op,\n            value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelGreen(q,ClampToQuantum(result));\n        }\n      if ((channel & BlueChannel) != 0)\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelBlue(q),op,\n            value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelBlue(q,ClampToQuantum(result));\n        }\n      if ((channel & OpacityChannel) != 0)\n        {\n          if (image->matte == MagickFalse)\n            {\n              result=ApplyEvaluateOperator(random_info[id],GetPixelOpacity(q),\n                op,value);\n              if (op == MeanEvaluateOperator)\n                result/=2.0;\n              SetPixelOpacity(q,ClampToQuantum(result));\n            }\n          else\n            {\n              result=ApplyEvaluateOperator(random_info[id],GetPixelAlpha(q),\n                op,value);\n              if (op == MeanEvaluateOperator)\n                result/=2.0;\n              SetPixelAlpha(q,ClampToQuantum(result));\n            }\n        }\n      if (((channel & IndexChannel) != 0) && (indexes != (IndexPacket *) NULL))\n        {\n          result=ApplyEvaluateOperator(random_info[id],GetPixelIndex(indexes+x),\n            op,value);\n          if (op == MeanEvaluateOperator)\n            result/=2.0;\n          SetPixelIndex(indexes+x,ClampToQuantum(result));\n        }\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,EvaluateImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F u n c t i o n I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FunctionImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the FunctionImageChannel method is:\n%\n%      MagickBooleanType FunctionImage(Image *image,\n%        const MagickFunction function,const ssize_t number_parameters,\n%        const double *parameters,ExceptionInfo *exception)\n%      MagickBooleanType FunctionImageChannel(Image *image,\n%        const ChannelType channel,const MagickFunction function,\n%        const ssize_t number_parameters,const double *argument,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o function: A channel function.\n%\n%    o parameters: one or more parameters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Quantum ApplyFunction(Quantum pixel,const MagickFunction function,\n  const size_t number_parameters,const double *parameters,\n  ExceptionInfo *exception)\n{\n  MagickRealType\n    result;\n\n  register ssize_t\n    i;\n\n  (void) exception;\n  result=0.0;\n  switch (function)\n  {\n    case PolynomialFunction:\n    {\n      /*\n       * Polynomial\n       * Parameters:   polynomial constants,  highest to lowest order\n       *   For example:      c0*x^3 + c1*x^2 + c2*x  + c3\n       */\n      result=0.0;\n      for (i=0; i < (ssize_t) number_parameters; i++)\n        result=result*QuantumScale*pixel + parameters[i];\n      result*=QuantumRange;\n      break;\n    }\n    case SinusoidFunction:\n    {\n      /* Sinusoid Function\n       * Parameters:   Freq, Phase, Ampl, bias\n       */\n      double  freq,phase,ampl,bias;\n      freq  = ( number_parameters >= 1 ) ? parameters[0] : 1.0;\n      phase = ( number_parameters >= 2 ) ? parameters[1] : 0.0;\n      ampl  = ( number_parameters >= 3 ) ? parameters[2] : 0.5;\n      bias  = ( number_parameters >= 4 ) ? parameters[3] : 0.5;\n      result=(MagickRealType) (QuantumRange*(ampl*sin((double) (2.0*MagickPI*\n        (freq*QuantumScale*pixel + phase/360.0) )) + bias ) );\n      break;\n    }\n    case ArcsinFunction:\n    {\n      /* Arcsin Function  (peged at range limits for invalid results)\n       * Parameters:   Width, Center, Range, Bias\n       */\n      double  width,range,center,bias;\n      width  = ( number_parameters >= 1 ) ? parameters[0] : 1.0;\n      center = ( number_parameters >= 2 ) ? parameters[1] : 0.5;\n      range  = ( number_parameters >= 3 ) ? parameters[2] : 1.0;\n      bias   = ( number_parameters >= 4 ) ? parameters[3] : 0.5;\n      result = 2.0/width*(QuantumScale*pixel - center);\n      if ( result <= -1.0 )\n        result = bias - range/2.0;\n      else if ( result >= 1.0 )\n        result = bias + range/2.0;\n      else\n        result=(MagickRealType) (range/MagickPI*asin((double) result)+bias);\n      result *= QuantumRange;\n      break;\n    }\n    case ArctanFunction:\n    {\n      /* Arctan Function\n       * Parameters:   Slope, Center, Range, Bias\n       */\n      double  slope,range,center,bias;\n      slope  = ( number_parameters >= 1 ) ? parameters[0] : 1.0;\n      center = ( number_parameters >= 2 ) ? parameters[1] : 0.5;\n      range  = ( number_parameters >= 3 ) ? parameters[2] : 1.0;\n      bias   = ( number_parameters >= 4 ) ? parameters[3] : 0.5;\n      result=(MagickRealType) (MagickPI*slope*(QuantumScale*pixel-center));\n      result=(MagickRealType) (QuantumRange*(range/MagickPI*atan((double)\n                  result) + bias ) );\n      break;\n    }\n    case UndefinedFunction:\n      break;\n  }\n  return(ClampToQuantum(result));\n}\n\nMagickExport MagickBooleanType FunctionImage(Image *image,\n  const MagickFunction function,const size_t number_parameters,\n  const double *parameters,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=FunctionImageChannel(image,CompositeChannels,function,\n    number_parameters,parameters,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType FunctionImageChannel(Image *image,\n  const ChannelType channel,const MagickFunction function,\n  const size_t number_parameters,const double *parameters,\n  ExceptionInfo *exception)\n{\n#define FunctionImageTag  \"Function/Image \"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(MagickFalse);\n    }\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  status=AccelerateFunctionImage(image,channel,function,number_parameters,\n    parameters,exception);\n  if (status != MagickFalse)\n    return(status);\n#endif\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q,ApplyFunction(GetPixelRed(q),function,\n          number_parameters,parameters,exception));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q,ApplyFunction(GetPixelGreen(q),function,\n          number_parameters,parameters,exception));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q,ApplyFunction(GetPixelBlue(q),function,\n          number_parameters,parameters,exception));\n      if ((channel & OpacityChannel) != 0)\n        {\n          if (image->matte == MagickFalse)\n            SetPixelOpacity(q,ApplyFunction(GetPixelOpacity(q),function,\n              number_parameters,parameters,exception));\n          else\n            SetPixelAlpha(q,ApplyFunction((Quantum) GetPixelAlpha(q),function,\n              number_parameters,parameters,exception));\n        }\n      if (((channel & IndexChannel) != 0) && (indexes != (IndexPacket *) NULL))\n        SetPixelIndex(indexes+x,ApplyFunction(GetPixelIndex(indexes+x),function,\n          number_parameters,parameters,exception));\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,FunctionImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l E n t r o p y                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelEntropy() returns the entropy of one or more image channels.\n%\n%  The format of the GetImageChannelEntropy method is:\n%\n%      MagickBooleanType GetImageChannelEntropy(const Image *image,\n%        const ChannelType channel,double *entropy,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o entropy: the average entropy of the selected channels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageEntropy(const Image *image,\n  double *entropy,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelEntropy(image,CompositeChannels,entropy,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelEntropy(const Image *image,\n  const ChannelType channel,double *entropy,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  size_t\n    channels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageChannelStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  channels=0;\n  channel_statistics[CompositeChannels].entropy=0.0;\n  if ((channel & RedChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[RedChannel].entropy;\n      channels++;\n    }\n  if ((channel & GreenChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[GreenChannel].entropy;\n      channels++;\n    }\n  if ((channel & BlueChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[BlueChannel].entropy;\n      channels++;\n    }\n  if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[OpacityChannel].entropy;\n      channels++;\n    }\n  if (((channel & IndexChannel) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    {\n      channel_statistics[CompositeChannels].entropy+=\n        channel_statistics[BlackChannel].entropy;\n      channels++;\n    }\n  channel_statistics[CompositeChannels].entropy/=channels;\n  *entropy=channel_statistics[CompositeChannels].entropy;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e C h a n n e l E x t r e m a                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelExtrema() returns the extrema of one or more image channels.\n%\n%  The format of the GetImageChannelExtrema method is:\n%\n%      MagickBooleanType GetImageChannelExtrema(const Image *image,\n%        const ChannelType channel,size_t *minima,size_t *maxima,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageExtrema(const Image *image,\n  size_t *minima,size_t *maxima,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelExtrema(image,CompositeChannels,minima,maxima,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelExtrema(const Image *image,\n  const ChannelType channel,size_t *minima,size_t *maxima,\n  ExceptionInfo *exception)\n{\n  double\n    max,\n    min;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=GetImageChannelRange(image,channel,&min,&max,exception);\n  *minima=(size_t) ceil(min-0.5);\n  *maxima=(size_t) floor(max+0.5);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l K u r t o s i s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelKurtosis() returns the kurtosis and skewness of one or more\n%  image channels.\n%\n%  The format of the GetImageChannelKurtosis method is:\n%\n%      MagickBooleanType GetImageChannelKurtosis(const Image *image,\n%        const ChannelType channel,double *kurtosis,double *skewness,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o kurtosis: the kurtosis of the channel.\n%\n%    o skewness: the skewness of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageKurtosis(const Image *image,\n  double *kurtosis,double *skewness,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelKurtosis(image,CompositeChannels,kurtosis,skewness,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelKurtosis(const Image *image,\n  const ChannelType channel,double *kurtosis,double *skewness,\n  ExceptionInfo *exception)\n{\n  double\n    area,\n    mean,\n    standard_deviation,\n    sum_squares,\n    sum_cubes,\n    sum_fourth_power;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *kurtosis=0.0;\n  *skewness=0.0;\n  area=0.0;\n  mean=0.0;\n  standard_deviation=0.0;\n  sum_squares=0.0;\n  sum_cubes=0.0;\n  sum_fourth_power=0.0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((channel & RedChannel) != 0)\n        {\n          mean+=GetPixelRed(p);\n          sum_squares+=(double) GetPixelRed(p)*GetPixelRed(p);\n          sum_cubes+=(double) GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p);\n          sum_fourth_power+=(double) GetPixelRed(p)*GetPixelRed(p)*\n            GetPixelRed(p)*GetPixelRed(p);\n          area++;\n        }\n      if ((channel & GreenChannel) != 0)\n        {\n          mean+=GetPixelGreen(p);\n          sum_squares+=(double) GetPixelGreen(p)*GetPixelGreen(p);\n          sum_cubes+=(double) GetPixelGreen(p)*GetPixelGreen(p)*\n            GetPixelGreen(p);\n          sum_fourth_power+=(double) GetPixelGreen(p)*GetPixelGreen(p)*\n            GetPixelGreen(p)*GetPixelGreen(p);\n          area++;\n        }\n      if ((channel & BlueChannel) != 0)\n        {\n          mean+=GetPixelBlue(p);\n          sum_squares+=(double) GetPixelBlue(p)*GetPixelBlue(p);\n          sum_cubes+=(double) GetPixelBlue(p)*GetPixelBlue(p)*GetPixelBlue(p);\n          sum_fourth_power+=(double) GetPixelBlue(p)*GetPixelBlue(p)*\n            GetPixelBlue(p)*GetPixelBlue(p);\n          area++;\n        }\n      if ((channel & OpacityChannel) != 0)\n        {\n          mean+=GetPixelAlpha(p);\n          sum_squares+=(double) GetPixelOpacity(p)*GetPixelAlpha(p);\n          sum_cubes+=(double) GetPixelOpacity(p)*GetPixelAlpha(p)*\n            GetPixelAlpha(p);\n          sum_fourth_power+=(double) GetPixelAlpha(p)*GetPixelAlpha(p)*\n            GetPixelAlpha(p)*GetPixelAlpha(p);\n          area++;\n        }\n      if (((channel & IndexChannel) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n          double\n            index;\n\n          index=(double) GetPixelIndex(indexes+x);\n          mean+=index;\n          sum_squares+=index*index;\n          sum_cubes+=index*index*index;\n          sum_fourth_power+=index*index*index*index;\n          area++;\n        }\n      p++;\n    }\n  }\n  if (y < (ssize_t) image->rows)\n    return(MagickFalse);\n  if (area != 0.0)\n    {\n      mean/=area;\n      sum_squares/=area;\n      sum_cubes/=area;\n      sum_fourth_power/=area;\n    }\n  standard_deviation=sqrt(sum_squares-(mean*mean));\n  if (standard_deviation != 0.0)\n    {\n      *kurtosis=sum_fourth_power-4.0*mean*sum_cubes+6.0*mean*mean*sum_squares-\n        3.0*mean*mean*mean*mean;\n      *kurtosis/=standard_deviation*standard_deviation*standard_deviation*\n        standard_deviation;\n      *kurtosis-=3.0;\n      *skewness=sum_cubes-3.0*mean*sum_squares+2.0*mean*mean*mean;\n      *skewness/=standard_deviation*standard_deviation*standard_deviation;\n    }\n  return(y == (ssize_t) image->rows ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l M e a n                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelMean() returns the mean and standard deviation of one or more\n%  image channels.\n%\n%  The format of the GetImageChannelMean method is:\n%\n%      MagickBooleanType GetImageChannelMean(const Image *image,\n%        const ChannelType channel,double *mean,double *standard_deviation,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o mean: the average value in the channel.\n%\n%    o standard_deviation: the standard deviation of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageMean(const Image *image,double *mean,\n  double *standard_deviation,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=GetImageChannelMean(image,CompositeChannels,mean,standard_deviation,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType GetImageChannelMean(const Image *image,\n  const ChannelType channel,double *mean,double *standard_deviation,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  size_t\n    channels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageChannelStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  channels=0;\n  channel_statistics[CompositeChannels].mean=0.0;\n  channel_statistics[CompositeChannels].standard_deviation=0.0;\n  if ((channel & RedChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[RedChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[RedChannel].standard_deviation;\n      channels++;\n    }\n  if ((channel & GreenChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[GreenChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[GreenChannel].standard_deviation;\n      channels++;\n    }\n  if ((channel & BlueChannel) != 0)\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[BlueChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[BlueChannel].standard_deviation;\n      channels++;\n    }\n  if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n    {\n      channel_statistics[CompositeChannels].mean+=\n        (QuantumRange-channel_statistics[OpacityChannel].mean);\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[OpacityChannel].standard_deviation;\n      channels++;\n    }\n  if (((channel & IndexChannel) != 0) && (image->colorspace == CMYKColorspace))\n    {\n      channel_statistics[CompositeChannels].mean+=\n        channel_statistics[BlackChannel].mean;\n      channel_statistics[CompositeChannels].standard_deviation+=\n        channel_statistics[CompositeChannels].standard_deviation;\n      channels++;\n    }\n  channel_statistics[CompositeChannels].mean/=channels;\n  channel_statistics[CompositeChannels].standard_deviation/=channels;\n  *mean=channel_statistics[CompositeChannels].mean;\n  *standard_deviation=channel_statistics[CompositeChannels].standard_deviation;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l M o m e n t s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelMoments() returns the normalized moments of one or more image\n%  channels.\n%\n%  The format of the GetImageChannelMoments method is:\n%\n%      ChannelMoments *GetImageChannelMoments(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ChannelMoments *GetImageChannelMoments(const Image *image,\n  ExceptionInfo *exception)\n{\n#define MaxNumberImageMoments  8\n\n  ChannelMoments\n    *channel_moments;\n\n  double\n    M00[CompositeChannels+1],\n    M01[CompositeChannels+1],\n    M02[CompositeChannels+1],\n    M03[CompositeChannels+1],\n    M10[CompositeChannels+1],\n    M11[CompositeChannels+1],\n    M12[CompositeChannels+1],\n    M20[CompositeChannels+1],\n    M21[CompositeChannels+1],\n    M22[CompositeChannels+1],\n    M30[CompositeChannels+1];\n\n  MagickPixelPacket\n    pixel;\n\n  PointInfo\n    centroid[CompositeChannels+1];\n\n  ssize_t\n    channel,\n    channels,\n    y;\n\n  size_t\n    length;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=CompositeChannels+1UL;\n  channel_moments=(ChannelMoments *) AcquireQuantumMemory(length,\n    sizeof(*channel_moments));\n  if (channel_moments == (ChannelMoments *) NULL)\n    return(channel_moments);\n  (void) memset(channel_moments,0,length*sizeof(*channel_moments));\n  (void) memset(centroid,0,sizeof(centroid));\n  (void) memset(M00,0,sizeof(M00));\n  (void) memset(M01,0,sizeof(M01));\n  (void) memset(M02,0,sizeof(M02));\n  (void) memset(M03,0,sizeof(M03));\n  (void) memset(M10,0,sizeof(M10));\n  (void) memset(M11,0,sizeof(M11));\n  (void) memset(M12,0,sizeof(M12));\n  (void) memset(M20,0,sizeof(M20));\n  (void) memset(M21,0,sizeof(M21));\n  (void) memset(M22,0,sizeof(M22));\n  (void) memset(M30,0,sizeof(M30));\n  GetMagickPixelPacket(image,&pixel);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute center of mass (centroid).\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      M00[RedChannel]+=QuantumScale*pixel.red;\n      M10[RedChannel]+=x*QuantumScale*pixel.red;\n      M01[RedChannel]+=y*QuantumScale*pixel.red;\n      M00[GreenChannel]+=QuantumScale*pixel.green;\n      M10[GreenChannel]+=x*QuantumScale*pixel.green;\n      M01[GreenChannel]+=y*QuantumScale*pixel.green;\n      M00[BlueChannel]+=QuantumScale*pixel.blue;\n      M10[BlueChannel]+=x*QuantumScale*pixel.blue;\n      M01[BlueChannel]+=y*QuantumScale*pixel.blue;\n      if (image->matte != MagickFalse)\n        {\n          M00[OpacityChannel]+=QuantumScale*pixel.opacity;\n          M10[OpacityChannel]+=x*QuantumScale*pixel.opacity;\n          M01[OpacityChannel]+=y*QuantumScale*pixel.opacity;\n        }\n      if (image->colorspace == CMYKColorspace)\n        {\n          M00[IndexChannel]+=QuantumScale*pixel.index;\n          M10[IndexChannel]+=x*QuantumScale*pixel.index;\n          M01[IndexChannel]+=y*QuantumScale*pixel.index;\n        }\n      p++;\n    }\n  }\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Compute center of mass (centroid).\n    */\n    if (M00[channel] < MagickEpsilon)\n      {\n        M00[channel]+=MagickEpsilon;\n        centroid[channel].x=(double) image->columns/2.0;\n        centroid[channel].y=(double) image->rows/2.0;\n        continue;\n      }\n    M00[channel]+=MagickEpsilon;\n    centroid[channel].x=M10[channel]/M00[channel];\n    centroid[channel].y=M01[channel]/M00[channel];\n  }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute the image moments.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      M11[RedChannel]+=(x-centroid[RedChannel].x)*(y-\n        centroid[RedChannel].y)*QuantumScale*pixel.red;\n      M20[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*QuantumScale*pixel.red;\n      M02[RedChannel]+=(y-centroid[RedChannel].y)*(y-\n        centroid[RedChannel].y)*QuantumScale*pixel.red;\n      M21[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*(y-centroid[RedChannel].y)*QuantumScale*\n        pixel.red;\n      M12[RedChannel]+=(x-centroid[RedChannel].x)*(y-\n        centroid[RedChannel].y)*(y-centroid[RedChannel].y)*QuantumScale*\n        pixel.red;\n      M22[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*(y-centroid[RedChannel].y)*(y-\n        centroid[RedChannel].y)*QuantumScale*pixel.red;\n      M30[RedChannel]+=(x-centroid[RedChannel].x)*(x-\n        centroid[RedChannel].x)*(x-centroid[RedChannel].x)*QuantumScale*\n        pixel.red;\n      M03[RedChannel]+=(y-centroid[RedChannel].y)*(y-\n        centroid[RedChannel].y)*(y-centroid[RedChannel].y)*QuantumScale*\n        pixel.red;\n      M11[GreenChannel]+=(x-centroid[GreenChannel].x)*(y-\n        centroid[GreenChannel].y)*QuantumScale*pixel.green;\n      M20[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*QuantumScale*pixel.green;\n      M02[GreenChannel]+=(y-centroid[GreenChannel].y)*(y-\n        centroid[GreenChannel].y)*QuantumScale*pixel.green;\n      M21[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*(y-centroid[GreenChannel].y)*QuantumScale*\n        pixel.green;\n      M12[GreenChannel]+=(x-centroid[GreenChannel].x)*(y-\n        centroid[GreenChannel].y)*(y-centroid[GreenChannel].y)*QuantumScale*\n        pixel.green;\n      M22[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*(y-centroid[GreenChannel].y)*(y-\n        centroid[GreenChannel].y)*QuantumScale*pixel.green;\n      M30[GreenChannel]+=(x-centroid[GreenChannel].x)*(x-\n        centroid[GreenChannel].x)*(x-centroid[GreenChannel].x)*QuantumScale*\n        pixel.green;\n      M03[GreenChannel]+=(y-centroid[GreenChannel].y)*(y-\n        centroid[GreenChannel].y)*(y-centroid[GreenChannel].y)*QuantumScale*\n        pixel.green;\n      M11[BlueChannel]+=(x-centroid[BlueChannel].x)*(y-\n        centroid[BlueChannel].y)*QuantumScale*pixel.blue;\n      M20[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*QuantumScale*pixel.blue;\n      M02[BlueChannel]+=(y-centroid[BlueChannel].y)*(y-\n        centroid[BlueChannel].y)*QuantumScale*pixel.blue;\n      M21[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*(y-centroid[BlueChannel].y)*QuantumScale*\n        pixel.blue;\n      M12[BlueChannel]+=(x-centroid[BlueChannel].x)*(y-\n        centroid[BlueChannel].y)*(y-centroid[BlueChannel].y)*QuantumScale*\n        pixel.blue;\n      M22[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*(y-centroid[BlueChannel].y)*(y-\n        centroid[BlueChannel].y)*QuantumScale*pixel.blue;\n      M30[BlueChannel]+=(x-centroid[BlueChannel].x)*(x-\n        centroid[BlueChannel].x)*(x-centroid[BlueChannel].x)*QuantumScale*\n        pixel.blue;\n      M03[BlueChannel]+=(y-centroid[BlueChannel].y)*(y-\n        centroid[BlueChannel].y)*(y-centroid[BlueChannel].y)*QuantumScale*\n        pixel.blue;\n      if (image->matte != MagickFalse)\n        {\n          M11[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(y-\n            centroid[OpacityChannel].y)*QuantumScale*pixel.opacity;\n          M20[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*QuantumScale*pixel.opacity;\n          M02[OpacityChannel]+=(y-centroid[OpacityChannel].y)*(y-\n            centroid[OpacityChannel].y)*QuantumScale*pixel.opacity;\n          M21[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*(y-centroid[OpacityChannel].y)*\n            QuantumScale*pixel.opacity;\n          M12[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(y-\n            centroid[OpacityChannel].y)*(y-centroid[OpacityChannel].y)*\n            QuantumScale*pixel.opacity;\n          M22[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*(y-centroid[OpacityChannel].y)*(y-\n            centroid[OpacityChannel].y)*QuantumScale*pixel.opacity;\n          M30[OpacityChannel]+=(x-centroid[OpacityChannel].x)*(x-\n            centroid[OpacityChannel].x)*(x-centroid[OpacityChannel].x)*\n            QuantumScale*pixel.opacity;\n          M03[OpacityChannel]+=(y-centroid[OpacityChannel].y)*(y-\n            centroid[OpacityChannel].y)*(y-centroid[OpacityChannel].y)*\n            QuantumScale*pixel.opacity;\n        }\n      if (image->colorspace == CMYKColorspace)\n        {\n          M11[IndexChannel]+=(x-centroid[IndexChannel].x)*(y-\n            centroid[IndexChannel].y)*QuantumScale*pixel.index;\n          M20[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*QuantumScale*pixel.index;\n          M02[IndexChannel]+=(y-centroid[IndexChannel].y)*(y-\n            centroid[IndexChannel].y)*QuantumScale*pixel.index;\n          M21[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*(y-centroid[IndexChannel].y)*\n            QuantumScale*pixel.index;\n          M12[IndexChannel]+=(x-centroid[IndexChannel].x)*(y-\n            centroid[IndexChannel].y)*(y-centroid[IndexChannel].y)*\n            QuantumScale*pixel.index;\n          M22[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*(y-centroid[IndexChannel].y)*(y-\n            centroid[IndexChannel].y)*QuantumScale*pixel.index;\n          M30[IndexChannel]+=(x-centroid[IndexChannel].x)*(x-\n            centroid[IndexChannel].x)*(x-centroid[IndexChannel].x)*\n            QuantumScale*pixel.index;\n          M03[IndexChannel]+=(y-centroid[IndexChannel].y)*(y-\n            centroid[IndexChannel].y)*(y-centroid[IndexChannel].y)*\n            QuantumScale*pixel.index;\n        }\n      p++;\n    }\n  }\n  channels=3;\n  M00[CompositeChannels]+=(M00[RedChannel]+M00[GreenChannel]+M00[BlueChannel]);\n  M01[CompositeChannels]+=(M01[RedChannel]+M01[GreenChannel]+M01[BlueChannel]);\n  M02[CompositeChannels]+=(M02[RedChannel]+M02[GreenChannel]+M02[BlueChannel]);\n  M03[CompositeChannels]+=(M03[RedChannel]+M03[GreenChannel]+M03[BlueChannel]);\n  M10[CompositeChannels]+=(M10[RedChannel]+M10[GreenChannel]+M10[BlueChannel]);\n  M11[CompositeChannels]+=(M11[RedChannel]+M11[GreenChannel]+M11[BlueChannel]);\n  M12[CompositeChannels]+=(M12[RedChannel]+M12[GreenChannel]+M12[BlueChannel]);\n  M20[CompositeChannels]+=(M20[RedChannel]+M20[GreenChannel]+M20[BlueChannel]);\n  M21[CompositeChannels]+=(M21[RedChannel]+M21[GreenChannel]+M21[BlueChannel]);\n  M22[CompositeChannels]+=(M22[RedChannel]+M22[GreenChannel]+M22[BlueChannel]);\n  M30[CompositeChannels]+=(M30[RedChannel]+M30[GreenChannel]+M30[BlueChannel]);\n  if (image->matte != MagickFalse)\n    {\n      channels+=1;\n      M00[CompositeChannels]+=M00[OpacityChannel];\n      M01[CompositeChannels]+=M01[OpacityChannel];\n      M02[CompositeChannels]+=M02[OpacityChannel];\n      M03[CompositeChannels]+=M03[OpacityChannel];\n      M10[CompositeChannels]+=M10[OpacityChannel];\n      M11[CompositeChannels]+=M11[OpacityChannel];\n      M12[CompositeChannels]+=M12[OpacityChannel];\n      M20[CompositeChannels]+=M20[OpacityChannel];\n      M21[CompositeChannels]+=M21[OpacityChannel];\n      M22[CompositeChannels]+=M22[OpacityChannel];\n      M30[CompositeChannels]+=M30[OpacityChannel];\n    }\n  if (image->colorspace == CMYKColorspace)\n    {\n      channels+=1;\n      M00[CompositeChannels]+=M00[IndexChannel];\n      M01[CompositeChannels]+=M01[IndexChannel];\n      M02[CompositeChannels]+=M02[IndexChannel];\n      M03[CompositeChannels]+=M03[IndexChannel];\n      M10[CompositeChannels]+=M10[IndexChannel];\n      M11[CompositeChannels]+=M11[IndexChannel];\n      M12[CompositeChannels]+=M12[IndexChannel];\n      M20[CompositeChannels]+=M20[IndexChannel];\n      M21[CompositeChannels]+=M21[IndexChannel];\n      M22[CompositeChannels]+=M22[IndexChannel];\n      M30[CompositeChannels]+=M30[IndexChannel];\n    }\n  M00[CompositeChannels]/=(double) channels;\n  M01[CompositeChannels]/=(double) channels;\n  M02[CompositeChannels]/=(double) channels;\n  M03[CompositeChannels]/=(double) channels;\n  M10[CompositeChannels]/=(double) channels;\n  M11[CompositeChannels]/=(double) channels;\n  M12[CompositeChannels]/=(double) channels;\n  M20[CompositeChannels]/=(double) channels;\n  M21[CompositeChannels]/=(double) channels;\n  M22[CompositeChannels]/=(double) channels;\n  M30[CompositeChannels]/=(double) channels;\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Compute elliptical angle, major and minor axes, eccentricity, & intensity.\n    */\n    channel_moments[channel].centroid=centroid[channel];\n    channel_moments[channel].ellipse_axis.x=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])+sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_axis.y=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])-sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_angle=RadiansToDegrees(0.5*atan(2.0*\n      M11[channel]/(M20[channel]-M02[channel]+MagickEpsilon)));\n    if (fabs(M11[channel]) < MagickEpsilon)\n      {\n        if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n          channel_moments[channel].ellipse_angle+=0.0;\n        else\n          if ((M20[channel]-M02[channel]) < 0.0)\n            channel_moments[channel].ellipse_angle+=90.0;\n          else\n            channel_moments[channel].ellipse_angle+=0.0;\n      }\n    else\n      if (M11[channel] < 0.0)\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=180.0;\n        }\n      else\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=0.0;\n       }\n    channel_moments[channel].ellipse_eccentricity=sqrt(1.0-(\n      channel_moments[channel].ellipse_axis.y/\n      (channel_moments[channel].ellipse_axis.x+MagickEpsilon)));\n    channel_moments[channel].ellipse_intensity=M00[channel]/\n      (MagickPI*channel_moments[channel].ellipse_axis.x*\n      channel_moments[channel].ellipse_axis.y+MagickEpsilon);\n  }\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Normalize image moments.\n    */\n    M10[channel]=0.0;\n    M01[channel]=0.0;\n    M11[channel]/=pow(M00[channel],1.0+(1.0+1.0)/2.0);\n    M20[channel]/=pow(M00[channel],1.0+(2.0+0.0)/2.0);\n    M02[channel]/=pow(M00[channel],1.0+(0.0+2.0)/2.0);\n    M21[channel]/=pow(M00[channel],1.0+(2.0+1.0)/2.0);\n    M12[channel]/=pow(M00[channel],1.0+(1.0+2.0)/2.0);\n    M22[channel]/=pow(M00[channel],1.0+(2.0+2.0)/2.0);\n    M30[channel]/=pow(M00[channel],1.0+(3.0+0.0)/2.0);\n    M03[channel]/=pow(M00[channel],1.0+(0.0+3.0)/2.0);\n    M00[channel]=1.0;\n  }\n  for (channel=0; channel <= CompositeChannels; channel++)\n  {\n    /*\n      Compute Hu invariant moments.\n    */\n    channel_moments[channel].I[0]=M20[channel]+M02[channel];\n    channel_moments[channel].I[1]=(M20[channel]-M02[channel])*\n      (M20[channel]-M02[channel])+4.0*M11[channel]*M11[channel];\n    channel_moments[channel].I[2]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]-3.0*M12[channel])+(3.0*M21[channel]-M03[channel])*\n      (3.0*M21[channel]-M03[channel]);\n    channel_moments[channel].I[3]=(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])+(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]);\n    channel_moments[channel].I[4]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))+(3.0*M21[channel]-M03[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].I[5]=(M20[channel]-M02[channel])*\n      ((M30[channel]+M12[channel])*(M30[channel]+M12[channel])-\n      (M21[channel]+M03[channel])*(M21[channel]+M03[channel]))+\n      4.0*M11[channel]*(M30[channel]+M12[channel])*(M21[channel]+M03[channel]);\n    channel_moments[channel].I[6]=(3.0*M21[channel]-M03[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))-(M30[channel]-3*M12[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].I[7]=M11[channel]*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M03[channel]+M21[channel])*\n      (M03[channel]+M21[channel]))-(M20[channel]-M02[channel])*\n      (M30[channel]+M12[channel])*(M03[channel]+M21[channel]);\n  }\n  if (y < (ssize_t) image->rows)\n    channel_moments=(ChannelMoments *) RelinquishMagickMemory(channel_moments);\n  return(channel_moments);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l P e r c e p t u a l H a s h                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelPerceptualHash() returns the perceptual hash of one or more\n%  image channels.\n%\n%  The format of the GetImageChannelPerceptualHash method is:\n%\n%      ChannelPerceptualHash *GetImageChannelPerceptualHash(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickLog10(const double x)\n{\n#define Log10Epsilon  (1.0e-11)\n\n if (fabs(x) < Log10Epsilon)\n   return(log10(Log10Epsilon));\n return(log10(fabs(x)));\n}\n\nMagickExport ChannelPerceptualHash *GetImageChannelPerceptualHash(\n  const Image *image,ExceptionInfo *exception)\n{\n  ChannelMoments\n    *moments;\n\n  ChannelPerceptualHash\n    *perceptual_hash;\n\n  Image\n    *hash_image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    channel;\n\n  /*\n    Blur then transform to sRGB colorspace.\n  */\n  hash_image=BlurImage(image,0.0,1.0,exception);\n  if (hash_image == (Image *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  hash_image->depth=8;\n  status=TransformImageColorspace(hash_image,sRGBColorspace);\n  if (status == MagickFalse)\n    return((ChannelPerceptualHash *) NULL);\n  moments=GetImageChannelMoments(hash_image,exception);\n  hash_image=DestroyImage(hash_image);\n  if (moments == (ChannelMoments *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    CompositeChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  for (channel=0; channel <= CompositeChannels; channel++)\n    for (i=0; i < MaximumNumberOfImageMoments; i++)\n      perceptual_hash[channel].P[i]=(-MagickLog10(moments[channel].I[i]));\n  moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  /*\n    Blur then transform to HCLp colorspace.\n  */\n  hash_image=BlurImage(image,0.0,1.0,exception);\n  if (hash_image == (Image *) NULL)\n    {\n      perceptual_hash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        perceptual_hash);\n      return((ChannelPerceptualHash *) NULL);\n    }\n  hash_image->depth=8;\n  status=TransformImageColorspace(hash_image,HCLpColorspace);\n  if (status == MagickFalse)\n    {\n      perceptual_hash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        perceptual_hash);\n      return((ChannelPerceptualHash *) NULL);\n    }\n  moments=GetImageChannelMoments(hash_image,exception);\n  hash_image=DestroyImage(hash_image);\n  if (moments == (ChannelMoments *) NULL)\n    {\n      perceptual_hash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        perceptual_hash);\n      return((ChannelPerceptualHash *) NULL);\n    }\n  for (channel=0; channel <= CompositeChannels; channel++)\n    for (i=0; i < MaximumNumberOfImageMoments; i++)\n      perceptual_hash[channel].Q[i]=(-MagickLog10(moments[channel].I[i]));\n  moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  return(perceptual_hash);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l R a n g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelRange() returns the range of one or more image channels.\n%\n%  The format of the GetImageChannelRange method is:\n%\n%      MagickBooleanType GetImageChannelRange(const Image *image,\n%        const ChannelType channel,double *minima,double *maxima,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType GetImageRange(const Image *image,\n  double *minima,double *maxima,ExceptionInfo *exception)\n{\n  return(GetImageChannelRange(image,CompositeChannels,minima,maxima,exception));\n}\n\nMagickExport MagickBooleanType GetImageChannelRange(const Image *image,\n  const ChannelType channel,double *minima,double *maxima,\n  ExceptionInfo *exception)\n{\n  MagickPixelPacket\n    pixel;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *maxima=(-MagickMaximumValue);\n  *minima=MagickMaximumValue;\n  GetMagickPixelPacket(image,&pixel);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      if ((channel & RedChannel) != 0)\n        {\n          if (pixel.red < *minima)\n            *minima=(double) pixel.red;\n          if (pixel.red > *maxima)\n            *maxima=(double) pixel.red;\n        }\n      if ((channel & GreenChannel) != 0)\n        {\n          if (pixel.green < *minima)\n            *minima=(double) pixel.green;\n          if (pixel.green > *maxima)\n            *maxima=(double) pixel.green;\n        }\n      if ((channel & BlueChannel) != 0)\n        {\n          if (pixel.blue < *minima)\n            *minima=(double) pixel.blue;\n          if (pixel.blue > *maxima)\n            *maxima=(double) pixel.blue;\n        }\n      if (((channel & OpacityChannel) != 0) && (image->matte != MagickFalse))\n        {\n          if ((QuantumRange-pixel.opacity) < *minima)\n            *minima=(double) (QuantumRange-pixel.opacity);\n          if ((QuantumRange-pixel.opacity) > *maxima)\n            *maxima=(double) (QuantumRange-pixel.opacity);\n        }\n      if (((channel & IndexChannel) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n          if ((double) pixel.index < *minima)\n            *minima=(double) pixel.index;\n          if ((double) pixel.index > *maxima)\n            *maxima=(double) pixel.index;\n        }\n      p++;\n    }\n  }\n  return(y == (ssize_t) image->rows ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l S t a t i s t i c s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannelStatistics() returns statistics for each channel in the\n%  image.  The statistics include the channel depth, its minima, maxima, mean,\n%  standard deviation, kurtosis and skewness.  You can access the red channel\n%  mean, for example, like this:\n%\n%      channel_statistics=GetImageChannelStatistics(image,exception);\n%      red_mean=channel_statistics[RedChannel].mean;\n%\n%  Use MagickRelinquishMemory() to free the statistics buffer.\n%\n%  The format of the GetImageChannelStatistics method is:\n%\n%      ChannelStatistics *GetImageChannelStatistics(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ChannelStatistics *GetImageChannelStatistics(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  double\n    area,\n    standard_deviation;\n\n  MagickPixelPacket\n    number_bins,\n    *histogram;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i;\n\n  size_t\n    channels,\n    depth,\n    length;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=CompositeChannels+1UL;\n  channel_statistics=(ChannelStatistics *) AcquireQuantumMemory(length,\n    sizeof(*channel_statistics));\n  histogram=(MagickPixelPacket *) AcquireQuantumMemory(MaxMap+1U,\n    sizeof(*histogram));\n  if ((channel_statistics == (ChannelStatistics *) NULL) ||\n      (histogram == (MagickPixelPacket *) NULL))\n    {\n      if (histogram != (MagickPixelPacket *) NULL)\n        histogram=(MagickPixelPacket *) RelinquishMagickMemory(histogram);\n      if (channel_statistics != (ChannelStatistics *) NULL)\n        channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n          channel_statistics);\n      return(channel_statistics);\n    }\n  (void) memset(channel_statistics,0,length*\n    sizeof(*channel_statistics));\n  for (i=0; i <= (ssize_t) CompositeChannels; i++)\n  {\n    channel_statistics[i].depth=1;\n    channel_statistics[i].maxima=(-MagickMaximumValue);\n    channel_statistics[i].minima=MagickMaximumValue;\n  }\n  (void) memset(histogram,0,(MaxMap+1U)*sizeof(*histogram));\n  (void) memset(&number_bins,0,sizeof(number_bins));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute pixel statistics.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; )\n    {\n      if (channel_statistics[RedChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n        {\n          depth=channel_statistics[RedChannel].depth;\n          range=GetQuantumRange(depth);\n          if (IsPixelAtDepth(GetPixelRed(p),range) == MagickFalse)\n            {\n              channel_statistics[RedChannel].depth++;\n              continue;\n            }\n        }\n      if (channel_statistics[GreenChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n        {\n          depth=channel_statistics[GreenChannel].depth;\n          range=GetQuantumRange(depth);\n          if (IsPixelAtDepth(GetPixelGreen(p),range) == MagickFalse)\n            {\n              channel_statistics[GreenChannel].depth++;\n              continue;\n            }\n        }\n      if (channel_statistics[BlueChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n        {\n          depth=channel_statistics[BlueChannel].depth;\n          range=GetQuantumRange(depth);\n          if (IsPixelAtDepth(GetPixelBlue(p),range) == MagickFalse)\n            {\n              channel_statistics[BlueChannel].depth++;\n              continue;\n            }\n        }\n      if (image->matte != MagickFalse)\n        {\n          if (channel_statistics[OpacityChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n            {\n              depth=channel_statistics[OpacityChannel].depth;\n              range=GetQuantumRange(depth);\n              if (IsPixelAtDepth(GetPixelAlpha(p),range) == MagickFalse)\n                {\n                  channel_statistics[OpacityChannel].depth++;\n                  continue;\n                }\n            }\n          }\n      if (image->colorspace == CMYKColorspace)\n        {\n          if (channel_statistics[BlackChannel].depth != MAGICKCORE_QUANTUM_DEPTH)\n            {\n              depth=channel_statistics[BlackChannel].depth;\n              range=GetQuantumRange(depth);\n              if (IsPixelAtDepth(GetPixelIndex(indexes+x),range) == MagickFalse)\n                {\n                  channel_statistics[BlackChannel].depth++;\n                  continue;\n                }\n            }\n        }\n      if ((double) GetPixelRed(p) < channel_statistics[RedChannel].minima)\n        channel_statistics[RedChannel].minima=(double) GetPixelRed(p);\n      if ((double) GetPixelRed(p) > channel_statistics[RedChannel].maxima)\n        channel_statistics[RedChannel].maxima=(double) GetPixelRed(p);\n      channel_statistics[RedChannel].sum+=GetPixelRed(p);\n      channel_statistics[RedChannel].sum_squared+=(double) GetPixelRed(p)*\n        GetPixelRed(p);\n      channel_statistics[RedChannel].sum_cubed+=(double)\n        GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p);\n      channel_statistics[RedChannel].sum_fourth_power+=(double)\n        GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p)*GetPixelRed(p);\n      if ((double) GetPixelGreen(p) < channel_statistics[GreenChannel].minima)\n        channel_statistics[GreenChannel].minima=(double) GetPixelGreen(p);\n      if ((double) GetPixelGreen(p) > channel_statistics[GreenChannel].maxima)\n        channel_statistics[GreenChannel].maxima=(double) GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum+=GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum_squared+=(double) GetPixelGreen(p)*\n        GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum_cubed+=(double) GetPixelGreen(p)*\n        GetPixelGreen(p)*GetPixelGreen(p);\n      channel_statistics[GreenChannel].sum_fourth_power+=(double)\n        GetPixelGreen(p)*GetPixelGreen(p)*GetPixelGreen(p)*GetPixelGreen(p);\n      if ((double) GetPixelBlue(p) < channel_statistics[BlueChannel].minima)\n        channel_statistics[BlueChannel].minima=(double) GetPixelBlue(p);\n      if ((double) GetPixelBlue(p) > channel_statistics[BlueChannel].maxima)\n        channel_statistics[BlueChannel].maxima=(double) GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum+=GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum_squared+=(double) GetPixelBlue(p)*\n        GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum_cubed+=(double) GetPixelBlue(p)*\n        GetPixelBlue(p)*GetPixelBlue(p);\n      channel_statistics[BlueChannel].sum_fourth_power+=(double)\n        GetPixelBlue(p)*GetPixelBlue(p)*GetPixelBlue(p)*GetPixelBlue(p);\n      histogram[ScaleQuantumToMap(GetPixelRed(p))].red++;\n      histogram[ScaleQuantumToMap(GetPixelGreen(p))].green++;\n      histogram[ScaleQuantumToMap(GetPixelBlue(p))].blue++;\n      if (image->matte != MagickFalse)\n        {\n          if ((double) GetPixelAlpha(p) < channel_statistics[OpacityChannel].minima)\n            channel_statistics[OpacityChannel].minima=(double) GetPixelAlpha(p);\n          if ((double) GetPixelAlpha(p) > channel_statistics[OpacityChannel].maxima)\n            channel_statistics[OpacityChannel].maxima=(double) GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum+=GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum_squared+=(double)\n            GetPixelAlpha(p)*GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum_cubed+=(double)\n            GetPixelAlpha(p)*GetPixelAlpha(p)*GetPixelAlpha(p);\n          channel_statistics[OpacityChannel].sum_fourth_power+=(double)\n            GetPixelAlpha(p)*GetPixelAlpha(p)*GetPixelAlpha(p)*GetPixelAlpha(p);\n          histogram[ScaleQuantumToMap(GetPixelAlpha(p))].opacity++;\n        }\n      if (image->colorspace == CMYKColorspace)\n        {\n          if ((double) GetPixelIndex(indexes+x) < channel_statistics[BlackChannel].minima)\n            channel_statistics[BlackChannel].minima=(double)\n              GetPixelIndex(indexes+x);\n          if ((double) GetPixelIndex(indexes+x) > channel_statistics[BlackChannel].maxima)\n            channel_statistics[BlackChannel].maxima=(double)\n              GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum+=GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum_squared+=(double)\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum_cubed+=(double)\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x)*\n            GetPixelIndex(indexes+x);\n          channel_statistics[BlackChannel].sum_fourth_power+=(double)\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x)*\n            GetPixelIndex(indexes+x)*GetPixelIndex(indexes+x);\n          histogram[ScaleQuantumToMap(GetPixelIndex(indexes+x))].index++;\n        }\n      x++;\n      p++;\n    }\n  }\n  for (i=0; i < (ssize_t) CompositeChannels; i++)\n  {\n    double\n      area,\n      mean,\n      standard_deviation;\n\n    /*\n      Normalize pixel statistics.\n    */\n    area=PerceptibleReciprocal((double) image->columns*image->rows);\n    mean=channel_statistics[i].sum*area;\n    channel_statistics[i].sum=mean;\n    channel_statistics[i].sum_squared*=area;\n    channel_statistics[i].sum_cubed*=area;\n    channel_statistics[i].sum_fourth_power*=area;\n    channel_statistics[i].mean=mean;\n    channel_statistics[i].variance=channel_statistics[i].sum_squared;\n    standard_deviation=sqrt(channel_statistics[i].variance-(mean*mean));\n    area=PerceptibleReciprocal((double) image->columns*image->rows-1.0)*\n      ((double) image->columns*image->rows);\n    standard_deviation=sqrt(area*standard_deviation*standard_deviation);\n    channel_statistics[i].standard_deviation=standard_deviation;\n  }\n  for (i=0; i < (ssize_t) (MaxMap+1U); i++)\n  {\n    if (histogram[i].red > 0.0)\n      number_bins.red++;\n    if (histogram[i].green > 0.0)\n      number_bins.green++;\n    if (histogram[i].blue > 0.0)\n      number_bins.blue++;\n    if ((image->matte != MagickFalse) && (histogram[i].opacity > 0.0))\n      number_bins.opacity++;\n    if ((image->colorspace == CMYKColorspace) && (histogram[i].index > 0.0))\n      number_bins.index++;\n  }\n  area=PerceptibleReciprocal((double) image->columns*image->rows);\n  for (i=0; i < (ssize_t) (MaxMap+1U); i++)\n  {\n    /*\n      Compute pixel entropy.\n    */\n    histogram[i].red*=area;\n    channel_statistics[RedChannel].entropy+=-histogram[i].red*\n      MagickLog10(histogram[i].red)*\n      PerceptibleReciprocal(MagickLog10((double) number_bins.red));\n    histogram[i].green*=area;\n    channel_statistics[GreenChannel].entropy+=-histogram[i].green*\n      MagickLog10(histogram[i].green)*\n      PerceptibleReciprocal(MagickLog10((double) number_bins.green));\n    histogram[i].blue*=area;\n    channel_statistics[BlueChannel].entropy+=-histogram[i].blue*\n      MagickLog10(histogram[i].blue)*\n      PerceptibleReciprocal(MagickLog10((double) number_bins.blue));\n    if (image->matte != MagickFalse)\n      {\n        histogram[i].opacity*=area;\n        channel_statistics[OpacityChannel].entropy+=-histogram[i].opacity*\n          MagickLog10(histogram[i].opacity)*\n          PerceptibleReciprocal(MagickLog10((double) number_bins.opacity));\n      }\n    if (image->colorspace == CMYKColorspace)\n      {\n        histogram[i].index*=area;\n        channel_statistics[IndexChannel].entropy+=-histogram[i].index*\n          MagickLog10(histogram[i].index)*\n          PerceptibleReciprocal(MagickLog10((double) number_bins.index));\n      }\n  }\n  /*\n    Compute overall statistics.\n  */\n  for (i=0; i < (ssize_t) CompositeChannels; i++)\n  {\n    channel_statistics[CompositeChannels].depth=(size_t) EvaluateMax((double)\n      channel_statistics[CompositeChannels].depth,(double)\n      channel_statistics[i].depth);\n    channel_statistics[CompositeChannels].minima=MagickMin(\n      channel_statistics[CompositeChannels].minima,\n      channel_statistics[i].minima);\n    channel_statistics[CompositeChannels].maxima=EvaluateMax(\n      channel_statistics[CompositeChannels].maxima,\n      channel_statistics[i].maxima);\n    channel_statistics[CompositeChannels].sum+=channel_statistics[i].sum;\n    channel_statistics[CompositeChannels].sum_squared+=\n      channel_statistics[i].sum_squared;\n    channel_statistics[CompositeChannels].sum_cubed+=\n      channel_statistics[i].sum_cubed;\n    channel_statistics[CompositeChannels].sum_fourth_power+=\n      channel_statistics[i].sum_fourth_power;\n    channel_statistics[CompositeChannels].mean+=channel_statistics[i].mean;\n    channel_statistics[CompositeChannels].variance+=\n      channel_statistics[i].variance-channel_statistics[i].mean*\n      channel_statistics[i].mean;\n    standard_deviation=sqrt(channel_statistics[i].variance-\n      (channel_statistics[i].mean*channel_statistics[i].mean));\n    area=PerceptibleReciprocal((double) image->columns*image->rows-1.0)*\n      ((double) image->columns*image->rows);\n    standard_deviation=sqrt(area*standard_deviation*standard_deviation);\n    channel_statistics[CompositeChannels].standard_deviation=standard_deviation;\n    channel_statistics[CompositeChannels].entropy+=\n      channel_statistics[i].entropy;\n  }\n  channels=3;\n  if (image->matte != MagickFalse)\n    channels++;\n  if (image->colorspace == CMYKColorspace)\n    channels++;\n  channel_statistics[CompositeChannels].sum/=channels;\n  channel_statistics[CompositeChannels].sum_squared/=channels;\n  channel_statistics[CompositeChannels].sum_cubed/=channels;\n  channel_statistics[CompositeChannels].sum_fourth_power/=channels;\n  channel_statistics[CompositeChannels].mean/=channels;\n  channel_statistics[CompositeChannels].kurtosis/=channels;\n  channel_statistics[CompositeChannels].skewness/=channels;\n  channel_statistics[CompositeChannels].entropy/=channels;\n  i=CompositeChannels;\n  area=PerceptibleReciprocal((double) channels*image->columns*image->rows);\n  channel_statistics[i].variance=channel_statistics[i].sum_squared;\n  channel_statistics[i].mean=channel_statistics[i].sum;\n  standard_deviation=sqrt(channel_statistics[i].variance-\n    (channel_statistics[i].mean*channel_statistics[i].mean));\n  standard_deviation=sqrt(PerceptibleReciprocal((double) channels*\n    image->columns*image->rows-1.0)*channels*image->columns*image->rows*\n    standard_deviation*standard_deviation);\n  channel_statistics[i].standard_deviation=standard_deviation;\n  for (i=0; i <= (ssize_t) CompositeChannels; i++)\n  {\n    /*\n      Compute kurtosis & skewness statistics.\n    */\n    standard_deviation=PerceptibleReciprocal(\n      channel_statistics[i].standard_deviation);\n    channel_statistics[i].skewness=(channel_statistics[i].sum_cubed-3.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_squared+2.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation);\n    channel_statistics[i].kurtosis=(channel_statistics[i].sum_fourth_power-4.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_cubed+6.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].sum_squared-3.0*channel_statistics[i].mean*\n      channel_statistics[i].mean*1.0*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation*standard_deviation)-3.0;\n  }\n  channel_statistics[CompositeChannels].mean=0.0;\n  channel_statistics[CompositeChannels].standard_deviation=0.0;\n  for (i=0; i < (ssize_t) CompositeChannels; i++)\n  {\n    channel_statistics[CompositeChannels].mean+=\n      channel_statistics[i].mean;\n    channel_statistics[CompositeChannels].standard_deviation+=\n      channel_statistics[i].standard_deviation;\n  }\n  channel_statistics[CompositeChannels].mean/=(double) channels;\n  channel_statistics[CompositeChannels].standard_deviation/=(double) channels;\n  histogram=(MagickPixelPacket *) RelinquishMagickMemory(histogram);\n  if (y < (ssize_t) image->rows)\n    channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n      channel_statistics);\n  return(channel_statistics);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P o l y n o m i a l I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PolynomialImage() returns a new image where each pixel is the sum of the\n%  pixels in the image sequence after applying its corresponding terms\n%  (coefficient and degree pairs).\n%\n%  The format of the PolynomialImage method is:\n%\n%      Image *PolynomialImage(const Image *images,const size_t number_terms,\n%        const double *terms,ExceptionInfo *exception)\n%      Image *PolynomialImageChannel(const Image *images,\n%        const size_t number_terms,const ChannelType channel,\n%        const double *terms,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o channel: the channel.\n%\n%    o number_terms: the number of terms in the list.  The actual list length\n%      is 2 x number_terms + 1 (the constant).\n%\n%    o terms: the list of polynomial coefficients and degree pairs and a\n%      constant.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PolynomialImage(const Image *images,\n  const size_t number_terms,const double *terms,ExceptionInfo *exception)\n{\n  Image\n    *polynomial_image;\n\n  polynomial_image=PolynomialImageChannel(images,DefaultChannels,number_terms,\n    terms,exception);\n  return(polynomial_image);\n}\n\nMagickExport Image *PolynomialImageChannel(const Image *images,\n  const ChannelType channel,const size_t number_terms,const double *terms,\n  ExceptionInfo *exception)\n{\n#define PolynomialImageTag  \"Polynomial/Image\"\n\n  CacheView\n    *polynomial_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickPixelPacket\n    **magick_restrict polynomial_pixels,\n    zero;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  polynomial_pixels=AcquirePixelThreadSet(images);\n  if (polynomial_pixels == (MagickPixelPacket **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Polynomial image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  GetMagickPixelPacket(images,&zero);\n  polynomial_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    CacheView\n      *image_view;\n\n    const Image\n      *next;\n\n    const int\n      id = GetOpenMPThreadId();\n\n    register IndexPacket\n      *magick_restrict polynomial_indexes;\n\n    register MagickPixelPacket\n      *polynomial_pixel;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    size_t\n      number_images;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(polynomial_view,0,y,image->columns,1,\n      exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    polynomial_indexes=GetCacheViewAuthenticIndexQueue(polynomial_view);\n    polynomial_pixel=polynomial_pixels[id];\n    for (x=0; x < (ssize_t) image->columns; x++)\n      polynomial_pixel[x]=zero;\n    next=images;\n    number_images=GetImageListLength(images);\n    for (i=0; i < (ssize_t) number_images; i++)\n    {\n      register const IndexPacket\n        *indexes;\n\n      register const PixelPacket\n        *p;\n\n      if (i >= (ssize_t) number_terms)\n        break;\n      image_view=AcquireVirtualCacheView(next,exception);\n      p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n      if (p == (const PixelPacket *) NULL)\n        {\n          image_view=DestroyCacheView(image_view);\n          break;\n        }\n      indexes=GetCacheViewVirtualIndexQueue(image_view);\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        double\n          coefficient,\n          degree;\n\n        coefficient=terms[i << 1];\n        degree=terms[(i << 1)+1];\n        if ((channel & RedChannel) != 0)\n          polynomial_pixel[x].red+=coefficient*pow(QuantumScale*p->red,degree);\n        if ((channel & GreenChannel) != 0)\n          polynomial_pixel[x].green+=coefficient*pow(QuantumScale*p->green,\n            degree);\n        if ((channel & BlueChannel) != 0)\n          polynomial_pixel[x].blue+=coefficient*pow(QuantumScale*p->blue,\n            degree);\n        if ((channel & OpacityChannel) != 0)\n          polynomial_pixel[x].opacity+=coefficient*pow(QuantumScale*\n            (QuantumRange-p->opacity),degree);\n        if (((channel & IndexChannel) != 0) &&\n            (image->colorspace == CMYKColorspace))\n          polynomial_pixel[x].index+=coefficient*pow(QuantumScale*indexes[x],\n            degree);\n        p++;\n      }\n      image_view=DestroyCacheView(image_view);\n      next=GetNextImageInList(next);\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ClampToQuantum(QuantumRange*polynomial_pixel[x].red));\n      SetPixelGreen(q,ClampToQuantum(QuantumRange*polynomial_pixel[x].green));\n      SetPixelBlue(q,ClampToQuantum(QuantumRange*polynomial_pixel[x].blue));\n      if (image->matte == MagickFalse)\n        SetPixelOpacity(q,ClampToQuantum(QuantumRange-QuantumRange*\n          polynomial_pixel[x].opacity));\n      else\n        SetPixelAlpha(q,ClampToQuantum(QuantumRange-QuantumRange*\n          polynomial_pixel[x].opacity));\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(polynomial_indexes+x,ClampToQuantum(QuantumRange*\n          polynomial_pixel[x].index));\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(polynomial_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(images,PolynomialImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  polynomial_view=DestroyCacheView(polynomial_view);\n  polynomial_pixels=DestroyPixelThreadSet(images,polynomial_pixels);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S t a t i s t i c I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StatisticImage() makes each pixel the min / max / median / mode / etc. of\n%  the neighborhood of the specified width and height.\n%\n%  The format of the StatisticImage method is:\n%\n%      Image *StatisticImage(const Image *image,const StatisticType type,\n%        const size_t width,const size_t height,ExceptionInfo *exception)\n%      Image *StatisticImageChannel(const Image *image,\n%        const ChannelType channel,const StatisticType type,\n%        const size_t width,const size_t height,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the image channel.\n%\n%    o type: the statistic type (median, mode, etc.).\n%\n%    o width: the width of the pixel neighborhood.\n%\n%    o height: the height of the pixel neighborhood.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#define ListChannels  5\n\ntypedef struct _ListNode\n{\n  size_t\n    next[9],\n    count,\n    signature;\n} ListNode;\n\ntypedef struct _SkipList\n{\n  ssize_t\n    level;\n\n  ListNode\n    *nodes;\n} SkipList;\n\ntypedef struct _PixelList\n{\n  size_t\n    length,\n    seed,\n    signature;\n\n  SkipList\n    lists[ListChannels];\n} PixelList;\n\nstatic PixelList *DestroyPixelList(PixelList *pixel_list)\n{\n  register ssize_t\n    i;\n\n  if (pixel_list == (PixelList *) NULL)\n    return((PixelList *) NULL);\n  for (i=0; i < ListChannels; i++)\n    if (pixel_list->lists[i].nodes != (ListNode *) NULL)\n      pixel_list->lists[i].nodes=(ListNode *) RelinquishAlignedMemory(\n        pixel_list->lists[i].nodes);\n  pixel_list=(PixelList *) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList **DestroyPixelListThreadSet(PixelList **pixel_list)\n{\n  register ssize_t\n    i;\n\n  assert(pixel_list != (PixelList **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixel_list[i] != (PixelList *) NULL)\n      pixel_list[i]=DestroyPixelList(pixel_list[i]);\n  pixel_list=(PixelList **) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList *AcquirePixelList(const size_t width,const size_t height)\n{\n  PixelList\n    *pixel_list;\n\n  register ssize_t\n    i;\n\n  pixel_list=(PixelList *) AcquireMagickMemory(sizeof(*pixel_list));\n  if (pixel_list == (PixelList *) NULL)\n    return(pixel_list);\n  (void) memset((void *) pixel_list,0,sizeof(*pixel_list));\n  pixel_list->length=width*height;\n  for (i=0; i < ListChannels; i++)\n  {\n    pixel_list->lists[i].nodes=(ListNode *) AcquireAlignedMemory(65537UL,\n      sizeof(*pixel_list->lists[i].nodes));\n    if (pixel_list->lists[i].nodes == (ListNode *) NULL)\n      return(DestroyPixelList(pixel_list));\n    (void) memset(pixel_list->lists[i].nodes,0,65537UL*\n      sizeof(*pixel_list->lists[i].nodes));\n  }\n  pixel_list->signature=MagickCoreSignature;\n  return(pixel_list);\n}\n\nstatic PixelList **AcquirePixelListThreadSet(const size_t width,\n  const size_t height)\n{\n  PixelList\n    **pixel_list;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixel_list=(PixelList **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixel_list));\n  if (pixel_list == (PixelList **) NULL)\n    return((PixelList **) NULL);\n  (void) memset(pixel_list,0,number_threads*sizeof(*pixel_list));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixel_list[i]=AcquirePixelList(width,height);\n    if (pixel_list[i] == (PixelList *) NULL)\n      return(DestroyPixelListThreadSet(pixel_list));\n  }\n  return(pixel_list);\n}\n\nstatic void AddNodePixelList(PixelList *pixel_list,const ssize_t channel,\n  const size_t color)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    level;\n\n  size_t\n    search,\n    update[9];\n\n  /*\n    Initialize the node.\n  */\n  list=pixel_list->lists+channel;\n  list->nodes[color].signature=pixel_list->signature;\n  list->nodes[color].count=1;\n  /*\n    Determine where it belongs in the list.\n  */\n  search=65536UL;\n  for (level=list->level; level >= 0; level--)\n  {\n    while (list->nodes[search].next[level] < color)\n      search=list->nodes[search].next[level];\n    update[level]=search;\n  }\n  /*\n    Generate a pseudo-random level for this node.\n  */\n  for (level=0; ; level++)\n  {\n    pixel_list->seed=(pixel_list->seed*42893621L)+1L;\n    if ((pixel_list->seed & 0x300) != 0x300)\n      break;\n  }\n  if (level > 8)\n    level=8;\n  if (level > (list->level+2))\n    level=list->level+2;\n  /*\n    If we're raising the list's level, link back to the root node.\n  */\n  while (level > list->level)\n  {\n    list->level++;\n    update[list->level]=65536UL;\n  }\n  /*\n    Link the node into the skip-list.\n  */\n  do\n  {\n    list->nodes[color].next[level]=list->nodes[update[level]].next[level];\n    list->nodes[update[level]].next[level]=color;\n  } while (level-- > 0);\n}\n\nstatic void GetMaximumPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    maximum;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the maximum value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    maximum=list->nodes[color].next[0];\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (color > maximum)\n        maximum=color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) maximum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetMeanPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the mean value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    channels[channel]=(unsigned short) sum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetMedianPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the median value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      count+=list->nodes[color].count;\n    } while (count <= (ssize_t) (pixel_list->length >> 1));\n    channels[channel]=(unsigned short) color;\n  }\n  GetMagickPixelPacket((const Image *) NULL,pixel);\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetMinimumPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    minimum;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the minimum value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    count=0;\n    color=65536UL;\n    minimum=list->nodes[color].next[0];\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (color < minimum)\n        minimum=color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) minimum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetModePixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    max_count,\n    mode;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[5];\n\n  /*\n    Make each pixel the 'predominant color' of the specified neighborhood.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    mode=color;\n    max_count=list->nodes[mode].count;\n    count=0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (list->nodes[color].count > max_count)\n        {\n          mode=color;\n          max_count=list->nodes[mode].count;\n        }\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) mode;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetNonpeakPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    next,\n    previous;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[5];\n\n  /*\n    Finds the non peak value for each of the colors.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    next=list->nodes[color].next[0];\n    count=0;\n    do\n    {\n      previous=color;\n      color=next;\n      next=list->nodes[color].next[0];\n      count+=list->nodes[color].count;\n    } while (count <= (ssize_t) (pixel_list->length >> 1));\n    if ((previous == 65536UL) && (next != 65536UL))\n      color=next;\n    else\n      if ((previous != 65536UL) && (next == 65536UL))\n        color=previous;\n    channels[channel]=(unsigned short) color;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetRootMeanSquarePixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the root mean square value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) (list->nodes[color].count*color*color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum);\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic void GetStandardDeviationPixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum,\n    sum_squared;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the standard-deviation value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    sum_squared=0.0;\n    do\n    {\n      register ssize_t\n        i;\n\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      for (i=0; i < (ssize_t) list->nodes[color].count; i++)\n        sum_squared+=((MagickRealType) color)*((MagickRealType) color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    sum_squared/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum_squared-(sum*sum));\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n\nstatic inline void InsertPixelList(const Image *image,const PixelPacket *pixel,\n  const IndexPacket *indexes,PixelList *pixel_list)\n{\n  size_t\n    signature;\n\n  unsigned short\n    index;\n\n  index=ScaleQuantumToShort(GetPixelRed(pixel));\n  signature=pixel_list->lists[0].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[0].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,0,index);\n  index=ScaleQuantumToShort(GetPixelGreen(pixel));\n  signature=pixel_list->lists[1].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[1].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,1,index);\n  index=ScaleQuantumToShort(GetPixelBlue(pixel));\n  signature=pixel_list->lists[2].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[2].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,2,index);\n  index=ScaleQuantumToShort(GetPixelOpacity(pixel));\n  signature=pixel_list->lists[3].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[3].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,3,index);\n  if (image->colorspace == CMYKColorspace)\n    index=ScaleQuantumToShort(GetPixelIndex(indexes));\n  signature=pixel_list->lists[4].nodes[index].signature;\n  if (signature == pixel_list->signature)\n    pixel_list->lists[4].nodes[index].count++;\n  else\n    AddNodePixelList(pixel_list,4,index);\n}\n\nstatic void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n\n  register ListNode\n    *root;\n\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  /*\n    Reset the skip-list.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    root=list->nodes+65536UL;\n    list->level=0;\n    for (level=0; level < 9; level++)\n      root->next[level]=65536UL;\n  }\n  pixel_list->seed=pixel_list->signature++;\n}\n\nMagickExport Image *StatisticImage(const Image *image,const StatisticType type,\n  const size_t width,const size_t height,ExceptionInfo *exception)\n{\n  Image\n    *statistic_image;\n\n  statistic_image=StatisticImageChannel(image,DefaultChannels,type,width,\n    height,exception);\n  return(statistic_image);\n}\n\nMagickExport Image *StatisticImageChannel(const Image *image,\n  const ChannelType channel,const StatisticType type,const size_t width,\n  const size_t height,ExceptionInfo *exception)\n{\n#define StatisticImageTag  \"Statistic/Image\"\n\n  CacheView\n    *image_view,\n    *statistic_view;\n\n  Image\n    *statistic_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelList\n    **magick_restrict pixel_list;\n\n  size_t\n    neighbor_height,\n    neighbor_width;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize statistics image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  statistic_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (statistic_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(statistic_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&statistic_image->exception);\n      statistic_image=DestroyImage(statistic_image);\n      return((Image *) NULL);\n    }\n  neighbor_width=width == 0 ? GetOptimalKernelWidth2D((double) width,0.5) :\n    width;\n  neighbor_height=height == 0 ? GetOptimalKernelWidth2D((double) height,0.5) :\n    height;\n  pixel_list=AcquirePixelListThreadSet(neighbor_width,neighbor_height);\n  if (pixel_list == (PixelList **) NULL)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Make each pixel the min / max / median / mode / etc. of the neighborhood.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  statistic_view=AcquireAuthenticCacheView(statistic_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,statistic_image,statistic_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) statistic_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register IndexPacket\n      *magick_restrict statistic_indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) neighbor_width/2L),y-\n      (ssize_t) (neighbor_height/2L),image->columns+neighbor_width,\n      neighbor_height,exception);\n    q=QueueCacheViewAuthenticPixels(statistic_view,0,y,statistic_image->columns,      1,exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    statistic_indexes=GetCacheViewAuthenticIndexQueue(statistic_view);\n    for (x=0; x < (ssize_t) statistic_image->columns; x++)\n    {\n      MagickPixelPacket\n        pixel;\n\n      register const IndexPacket\n        *magick_restrict s;\n\n      register const PixelPacket\n        *magick_restrict r;\n\n      register ssize_t\n        u,\n        v;\n\n      r=p;\n      s=indexes+x;\n      ResetPixelList(pixel_list[id]);\n      for (v=0; v < (ssize_t) neighbor_height; v++)\n      {\n        for (u=0; u < (ssize_t) neighbor_width; u++)\n          InsertPixelList(image,r+u,s+u,pixel_list[id]);\n        r+=image->columns+neighbor_width;\n        s+=image->columns+neighbor_width;\n      }\n      GetMagickPixelPacket(image,&pixel);\n      SetMagickPixelPacket(image,p+neighbor_width*neighbor_height/2,indexes+x+\n        neighbor_width*neighbor_height/2,&pixel);\n      switch (type)\n      {\n        case GradientStatistic:\n        {\n          MagickPixelPacket\n            maximum,\n            minimum;\n\n          GetMinimumPixelList(pixel_list[id],&pixel);\n          minimum=pixel;\n          GetMaximumPixelList(pixel_list[id],&pixel);\n          maximum=pixel;\n          pixel.red=MagickAbsoluteValue(maximum.red-minimum.red);\n          pixel.green=MagickAbsoluteValue(maximum.green-minimum.green);\n          pixel.blue=MagickAbsoluteValue(maximum.blue-minimum.blue);\n          pixel.opacity=MagickAbsoluteValue(maximum.opacity-minimum.opacity);\n          if (image->colorspace == CMYKColorspace)\n            pixel.index=MagickAbsoluteValue(maximum.index-minimum.index);\n          break;\n        }\n        case MaximumStatistic:\n        {\n          GetMaximumPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case MeanStatistic:\n        {\n          GetMeanPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case MedianStatistic:\n        default:\n        {\n          GetMedianPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case MinimumStatistic:\n        {\n          GetMinimumPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case ModeStatistic:\n        {\n          GetModePixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case NonpeakStatistic:\n        {\n          GetNonpeakPixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case RootMeanSquareStatistic:\n        {\n          GetRootMeanSquarePixelList(pixel_list[id],&pixel);\n          break;\n        }\n        case StandardDeviationStatistic:\n        {\n          GetStandardDeviationPixelList(pixel_list[id],&pixel);\n          break;\n        }\n      }\n      if ((channel & RedChannel) != 0)\n        SetPixelRed(q,ClampToQuantum(pixel.red));\n      if ((channel & GreenChannel) != 0)\n        SetPixelGreen(q,ClampToQuantum(pixel.green));\n      if ((channel & BlueChannel) != 0)\n        SetPixelBlue(q,ClampToQuantum(pixel.blue));\n      if ((channel & OpacityChannel) != 0)\n        SetPixelOpacity(q,ClampToQuantum(pixel.opacity));\n      if (((channel & IndexChannel) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        SetPixelIndex(statistic_indexes+x,ClampToQuantum(pixel.index));\n      p++;\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(statistic_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,StatisticImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  statistic_view=DestroyCacheView(statistic_view);\n  image_view=DestroyCacheView(image_view);\n  pixel_list=DestroyPixelListThreadSet(pixel_list);\n  if (status == MagickFalse)\n    statistic_image=DestroyImage(statistic_image);\n  return(statistic_image);\n}\n"], "filenames": ["magick/statistic.c"], "buggy_code_start_loc": [263], "buggy_code_end_loc": [418], "fixing_code_start_loc": [263], "fixing_code_end_loc": [418], "type": "CWE-190", "message": "In /MagickCore/statistic.c, there are several areas in ApplyEvaluateOperator() where a size_t cast should have been a ssize_t cast, which causes out-of-range values under some circumstances when a crafted input file is processed by ImageMagick. Red Hat Product Security marked this as Low severity because although it could potentially lead to an impact to application availability, no specific impact was shown in this case. This flaw affects ImageMagick versions prior to 6.9.10-69.", "other": {"cve": {"id": "CVE-2020-27764", "sourceIdentifier": "secalert@redhat.com", "published": "2020-12-03T17:15:13.037", "lastModified": "2023-03-11T23:15:13.907", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In /MagickCore/statistic.c, there are several areas in ApplyEvaluateOperator() where a size_t cast should have been a ssize_t cast, which causes out-of-range values under some circumstances when a crafted input file is processed by ImageMagick. Red Hat Product Security marked this as Low severity because although it could potentially lead to an impact to application availability, no specific impact was shown in this case. This flaw affects ImageMagick versions prior to 6.9.10-69."}, {"lang": "es", "value": "En el archivo /MagickCore/statistic.c, presenta varias \u00e1reas en la funci\u00f3n ApplyEvaluateOperator() donde una conversi\u00f3n size_t deber\u00eda haber sido una conversi\u00f3n ssize_t, lo que causa valores fuera de rango bajo algunas circunstancias cuando ImageMagick procesa un archivo de entrada dise\u00f1ado. Red Hat Product Security marc\u00f3 esto como de gravedad baja porque, aunque podr\u00eda generar un impacto en la disponibilidad de la aplicaci\u00f3n, ning\u00fan impacto espec\u00edfico fue mostrado en este caso. Este fallo afecta a las versiones de ImageMagick versiones anteriores a 6.9.10-69"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-69", "matchCriteriaId": "0DA39290-2761-4869-AC2B-A251A33AEA75"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1894683", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00030.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00008.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5"}}