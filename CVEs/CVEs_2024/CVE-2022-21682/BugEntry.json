{"buggy_code": ["/*\n * Copyright \u00a9 2014-2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-run-private.h\"\n#include \"flatpak-proxy.h\"\n#include \"flatpak-utils-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include \"flatpak-error.h\"\n\n/* Same order as enum */\nconst char *flatpak_context_shares[] = {\n  \"network\",\n  \"ipc\",\n  NULL\n};\n\n/* Same order as enum */\nconst char *flatpak_context_sockets[] = {\n  \"x11\",\n  \"wayland\",\n  \"pulseaudio\",\n  \"session-bus\",\n  \"system-bus\",\n  \"fallback-x11\",\n  \"ssh-auth\",\n  \"pcsc\",\n  \"cups\",\n  NULL\n};\n\nconst char *flatpak_context_devices[] = {\n  \"dri\",\n  \"all\",\n  \"kvm\",\n  \"shm\",\n  NULL\n};\n\nconst char *flatpak_context_features[] = {\n  \"devel\",\n  \"multiarch\",\n  \"bluetooth\",\n  \"canbus\",\n  \"per-app-dev-shm\",\n  NULL\n};\n\nconst char *flatpak_context_special_filesystems[] = {\n  \"home\",\n  \"host\",\n  \"host-etc\",\n  \"host-os\",\n  NULL\n};\n\nFlatpakContext *\nflatpak_context_new (void)\n{\n  FlatpakContext *context;\n\n  context = g_slice_new0 (FlatpakContext);\n  context->env_vars = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);\n  context->persistent = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  /* filename or special filesystem name => FlatpakFilesystemMode */\n  context->filesystems = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  context->session_bus_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  context->system_bus_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  context->generic_policy = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                                   g_free, (GDestroyNotify) g_strfreev);\n\n  return context;\n}\n\nvoid\nflatpak_context_free (FlatpakContext *context)\n{\n  g_hash_table_destroy (context->env_vars);\n  g_hash_table_destroy (context->persistent);\n  g_hash_table_destroy (context->filesystems);\n  g_hash_table_destroy (context->session_bus_policy);\n  g_hash_table_destroy (context->system_bus_policy);\n  g_hash_table_destroy (context->generic_policy);\n  g_slice_free (FlatpakContext, context);\n}\n\nstatic guint32\nflatpak_context_bitmask_from_string (const char *name, const char **names)\n{\n  guint32 i;\n\n  for (i = 0; names[i] != NULL; i++)\n    {\n      if (strcmp (names[i], name) == 0)\n        return 1 << i;\n    }\n\n  return 0;\n}\n\nstatic char **\nflatpak_context_bitmask_to_string (guint32 enabled, guint32 valid, const char **names)\n{\n  guint32 i;\n  GPtrArray *array;\n\n  array = g_ptr_array_new ();\n\n  for (i = 0; names[i] != NULL; i++)\n    {\n      guint32 bitmask = 1 << i;\n      if (valid & bitmask)\n        {\n          if (enabled & bitmask)\n            g_ptr_array_add (array, g_strdup (names[i]));\n          else\n            g_ptr_array_add (array, g_strdup_printf (\"!%s\", names[i]));\n        }\n    }\n\n  g_ptr_array_add (array, NULL);\n  return (char **) g_ptr_array_free (array, FALSE);\n}\n\nstatic void\nflatpak_context_bitmask_to_args (guint32 enabled, guint32 valid, const char **names,\n                                 const char *enable_arg, const char *disable_arg,\n                                 GPtrArray *args)\n{\n  guint32 i;\n\n  for (i = 0; names[i] != NULL; i++)\n    {\n      guint32 bitmask = 1 << i;\n      if (valid & bitmask)\n        {\n          if (enabled & bitmask)\n            g_ptr_array_add (args, g_strdup_printf (\"%s=%s\", enable_arg, names[i]));\n          else\n            g_ptr_array_add (args, g_strdup_printf (\"%s=%s\", disable_arg, names[i]));\n        }\n    }\n}\n\n\nstatic FlatpakContextShares\nflatpak_context_share_from_string (const char *string, GError **error)\n{\n  FlatpakContextShares shares = flatpak_context_bitmask_from_string (string, flatpak_context_shares);\n\n  if (shares == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_shares);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown share type %s, valid types are: %s\"), string, values);\n    }\n\n  return shares;\n}\n\nstatic char **\nflatpak_context_shared_to_string (FlatpakContextShares shares, FlatpakContextShares valid)\n{\n  return flatpak_context_bitmask_to_string (shares, valid, flatpak_context_shares);\n}\n\nstatic void\nflatpak_context_shared_to_args (FlatpakContextShares shares,\n                                FlatpakContextShares valid,\n                                GPtrArray           *args)\n{\n  return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, \"--share\", \"--unshare\", args);\n}\n\nstatic FlatpakPolicy\nflatpak_policy_from_string (const char *string, GError **error)\n{\n  const char *policies[] = { \"none\", \"see\", \"talk\", \"own\", NULL };\n  int i;\n  g_autofree char *values = NULL;\n\n  for (i = 0; policies[i]; i++)\n    {\n      if (strcmp (string, policies[i]) == 0)\n        return i;\n    }\n\n  values = g_strjoinv (\", \", (char **) policies);\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Unknown policy type %s, valid types are: %s\"), string, values);\n\n  return -1;\n}\n\nstatic const char *\nflatpak_policy_to_string (FlatpakPolicy policy)\n{\n  if (policy == FLATPAK_POLICY_SEE)\n    return \"see\";\n  if (policy == FLATPAK_POLICY_TALK)\n    return \"talk\";\n  if (policy == FLATPAK_POLICY_OWN)\n    return \"own\";\n\n  return \"none\";\n}\n\nstatic gboolean\nflatpak_verify_dbus_name (const char *name, GError **error)\n{\n  const char *name_part;\n  g_autofree char *tmp = NULL;\n\n  if (g_str_has_suffix (name, \".*\"))\n    {\n      tmp = g_strndup (name, strlen (name) - 2);\n      name_part = tmp;\n    }\n  else\n    {\n      name_part = name;\n    }\n\n  if (g_dbus_is_name (name_part) && !g_dbus_is_unique_name (name_part))\n    return TRUE;\n\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Invalid dbus name %s\"), name);\n  return FALSE;\n}\n\nstatic FlatpakContextSockets\nflatpak_context_socket_from_string (const char *string, GError **error)\n{\n  FlatpakContextSockets sockets = flatpak_context_bitmask_from_string (string, flatpak_context_sockets);\n\n  if (sockets == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_sockets);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown socket type %s, valid types are: %s\"), string, values);\n    }\n\n  return sockets;\n}\n\nstatic char **\nflatpak_context_sockets_to_string (FlatpakContextSockets sockets, FlatpakContextSockets valid)\n{\n  return flatpak_context_bitmask_to_string (sockets, valid, flatpak_context_sockets);\n}\n\nstatic void\nflatpak_context_sockets_to_args (FlatpakContextSockets sockets,\n                                 FlatpakContextSockets valid,\n                                 GPtrArray            *args)\n{\n  return flatpak_context_bitmask_to_args (sockets, valid, flatpak_context_sockets, \"--socket\", \"--nosocket\", args);\n}\n\nstatic FlatpakContextDevices\nflatpak_context_device_from_string (const char *string, GError **error)\n{\n  FlatpakContextDevices devices = flatpak_context_bitmask_from_string (string, flatpak_context_devices);\n\n  if (devices == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_devices);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown device type %s, valid types are: %s\"), string, values);\n    }\n  return devices;\n}\n\nstatic char **\nflatpak_context_devices_to_string (FlatpakContextDevices devices, FlatpakContextDevices valid)\n{\n  return flatpak_context_bitmask_to_string (devices, valid, flatpak_context_devices);\n}\n\nstatic void\nflatpak_context_devices_to_args (FlatpakContextDevices devices,\n                                 FlatpakContextDevices valid,\n                                 GPtrArray            *args)\n{\n  return flatpak_context_bitmask_to_args (devices, valid, flatpak_context_devices, \"--device\", \"--nodevice\", args);\n}\n\nstatic FlatpakContextFeatures\nflatpak_context_feature_from_string (const char *string, GError **error)\n{\n  FlatpakContextFeatures feature = flatpak_context_bitmask_from_string (string, flatpak_context_features);\n\n  if (feature == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_features);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown feature type %s, valid types are: %s\"), string, values);\n    }\n\n  return feature;\n}\n\nstatic char **\nflatpak_context_features_to_string (FlatpakContextFeatures features, FlatpakContextFeatures valid)\n{\n  return flatpak_context_bitmask_to_string (features, valid, flatpak_context_features);\n}\n\nstatic void\nflatpak_context_features_to_args (FlatpakContextFeatures features,\n                                  FlatpakContextFeatures valid,\n                                  GPtrArray             *args)\n{\n  return flatpak_context_bitmask_to_args (features, valid, flatpak_context_features, \"--allow\", \"--disallow\", args);\n}\n\nstatic void\nflatpak_context_add_shares (FlatpakContext      *context,\n                            FlatpakContextShares shares)\n{\n  context->shares_valid |= shares;\n  context->shares |= shares;\n}\n\nstatic void\nflatpak_context_remove_shares (FlatpakContext      *context,\n                               FlatpakContextShares shares)\n{\n  context->shares_valid |= shares;\n  context->shares &= ~shares;\n}\n\nstatic void\nflatpak_context_add_sockets (FlatpakContext       *context,\n                             FlatpakContextSockets sockets)\n{\n  context->sockets_valid |= sockets;\n  context->sockets |= sockets;\n}\n\nstatic void\nflatpak_context_remove_sockets (FlatpakContext       *context,\n                                FlatpakContextSockets sockets)\n{\n  context->sockets_valid |= sockets;\n  context->sockets &= ~sockets;\n}\n\nstatic void\nflatpak_context_add_devices (FlatpakContext       *context,\n                             FlatpakContextDevices devices)\n{\n  context->devices_valid |= devices;\n  context->devices |= devices;\n}\n\nstatic void\nflatpak_context_remove_devices (FlatpakContext       *context,\n                                FlatpakContextDevices devices)\n{\n  context->devices_valid |= devices;\n  context->devices &= ~devices;\n}\n\nstatic void\nflatpak_context_add_features (FlatpakContext        *context,\n                              FlatpakContextFeatures features)\n{\n  context->features_valid |= features;\n  context->features |= features;\n}\n\nstatic void\nflatpak_context_remove_features (FlatpakContext        *context,\n                                 FlatpakContextFeatures features)\n{\n  context->features_valid |= features;\n  context->features &= ~features;\n}\n\nstatic void\nflatpak_context_set_env_var (FlatpakContext *context,\n                             const char     *name,\n                             const char     *value)\n{\n  g_hash_table_insert (context->env_vars, g_strdup (name), g_strdup (value));\n}\n\nvoid\nflatpak_context_set_session_bus_policy (FlatpakContext *context,\n                                        const char     *name,\n                                        FlatpakPolicy   policy)\n{\n  g_hash_table_insert (context->session_bus_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n\nGStrv\nflatpak_context_get_session_bus_policy_allowed_own_names (FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  g_autoptr(GPtrArray) names = g_ptr_array_new_with_free_func (g_free);\n\n  g_hash_table_iter_init (&iter, context->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    if (GPOINTER_TO_INT (value) == FLATPAK_POLICY_OWN)\n      g_ptr_array_add (names, g_strdup (key));\n\n  g_ptr_array_add (names, NULL);\n  return (GStrv) g_ptr_array_free (g_steal_pointer (&names), FALSE);\n}\n\nvoid\nflatpak_context_set_system_bus_policy (FlatpakContext *context,\n                                       const char     *name,\n                                       FlatpakPolicy   policy)\n{\n  g_hash_table_insert (context->system_bus_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n\nstatic void\nflatpak_context_apply_generic_policy (FlatpakContext *context,\n                                      const char     *key,\n                                      const char     *value)\n{\n  GPtrArray *new = g_ptr_array_new ();\n  const char **old_v;\n  int i;\n\n  g_assert (strchr (key, '.') != NULL);\n\n  old_v = g_hash_table_lookup (context->generic_policy, key);\n  for (i = 0; old_v != NULL && old_v[i] != NULL; i++)\n    {\n      const char *old = old_v[i];\n      const char *cmp1 = old;\n      const char *cmp2 = value;\n      if (*cmp1 == '!')\n        cmp1++;\n      if (*cmp2 == '!')\n        cmp2++;\n      if (strcmp (cmp1, cmp2) != 0)\n        g_ptr_array_add (new, g_strdup (old));\n    }\n\n  g_ptr_array_add (new, g_strdup (value));\n  g_ptr_array_add (new, NULL);\n\n  g_hash_table_insert (context->generic_policy, g_strdup (key),\n                       g_ptr_array_free (new, FALSE));\n}\n\nstatic void\nflatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}\n\nstatic gboolean\nget_xdg_dir_from_prefix (const char  *prefix,\n                         const char **where,\n                         const char **dir)\n{\n  if (strcmp (prefix, \"xdg-data\") == 0)\n    {\n      if (where)\n        *where = \"data\";\n      if (dir)\n        *dir = g_get_user_data_dir ();\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-cache\") == 0)\n    {\n      if (where)\n        *where = \"cache\";\n      if (dir)\n        *dir = g_get_user_cache_dir ();\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-config\") == 0)\n    {\n      if (where)\n        *where = \"config\";\n      if (dir)\n        *dir = g_get_user_config_dir ();\n      return TRUE;\n    }\n  return FALSE;\n}\n\n/* This looks only in the xdg dirs (config, cache, data), not the user\n   definable ones */\nstatic char *\nget_xdg_dir_from_string (const char  *filesystem,\n                         const char **suffix,\n                         const char **where)\n{\n  char *slash;\n  const char *rest;\n  g_autofree char *prefix = NULL;\n  const char *dir = NULL;\n  gsize len;\n\n  slash = strchr (filesystem, '/');\n\n  if (slash)\n    len = slash - filesystem;\n  else\n    len = strlen (filesystem);\n\n  rest = filesystem + len;\n  while (*rest == '/')\n    rest++;\n\n  if (suffix != NULL)\n    *suffix = rest;\n\n  prefix = g_strndup (filesystem, len);\n\n  if (get_xdg_dir_from_prefix (prefix, where, &dir))\n    return g_build_filename (dir, rest, NULL);\n\n  return NULL;\n}\n\nstatic gboolean\nget_xdg_user_dir_from_string (const char  *filesystem,\n                              const char **config_key,\n                              const char **suffix,\n                              const char **dir)\n{\n  char *slash;\n  const char *rest;\n  g_autofree char *prefix = NULL;\n  gsize len;\n\n  slash = strchr (filesystem, '/');\n\n  if (slash)\n    len = slash - filesystem;\n  else\n    len = strlen (filesystem);\n\n  rest = filesystem + len;\n  while (*rest == '/')\n    rest++;\n\n  if (suffix)\n    *suffix = rest;\n\n  prefix = g_strndup (filesystem, len);\n\n  if (strcmp (prefix, \"xdg-desktop\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_DESKTOP_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_DESKTOP);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-documents\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_DOCUMENTS_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_DOCUMENTS);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-download\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_DOWNLOAD_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_DOWNLOAD);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-music\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_MUSIC_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_MUSIC);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-pictures\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_PICTURES_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_PICTURES);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-public-share\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_PUBLICSHARE_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_PUBLIC_SHARE);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-templates\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_TEMPLATES_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_TEMPLATES);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-videos\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_VIDEOS_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_VIDEOS);\n      return TRUE;\n    }\n  if (get_xdg_dir_from_prefix (prefix, NULL, dir))\n    {\n      if (config_key)\n        *config_key = NULL;\n      return TRUE;\n    }\n  /* Don't support xdg-run without suffix, because that doesn't work */\n  if (strcmp (prefix, \"xdg-run\") == 0 &&\n      *rest != 0)\n    {\n      if (config_key)\n        *config_key = NULL;\n      if (dir)\n        *dir = flatpak_get_real_xdg_runtime_dir ();\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic char *\nunparse_filesystem_flags (const char           *path,\n                          FlatpakFilesystemMode mode)\n{\n  g_autoptr(GString) s = g_string_new (\"\");\n  const char *p;\n\n  for (p = path; *p != 0; p++)\n    {\n      if (*p == ':')\n        g_string_append (s, \"\\\\:\");\n      else if (*p == '\\\\')\n        g_string_append (s, \"\\\\\\\\\");\n      else\n        g_string_append_c (s, *p);\n    }\n\n  switch (mode)\n    {\n    case FLATPAK_FILESYSTEM_MODE_READ_ONLY:\n      g_string_append (s, \":ro\");\n      break;\n\n    case FLATPAK_FILESYSTEM_MODE_CREATE:\n      g_string_append (s, \":create\");\n      break;\n\n    case FLATPAK_FILESYSTEM_MODE_READ_WRITE:\n      break;\n\n    case FLATPAK_FILESYSTEM_MODE_NONE:\n      g_string_insert_c (s, 0, '!');\n      break;\n\n    default:\n      g_warning (\"Unexpected filesystem mode %d\", mode);\n      break;\n    }\n\n  return g_string_free (g_steal_pointer (&s), FALSE);\n}\n\nstatic char *\nparse_filesystem_flags (const char            *filesystem,\n                        FlatpakFilesystemMode *mode_out)\n{\n  g_autoptr(GString) s = g_string_new (\"\");\n  const char *p, *suffix;\n  FlatpakFilesystemMode mode;\n\n  p = filesystem;\n  while (*p != 0 && *p != ':')\n    {\n      if (*p == '\\\\')\n        {\n          p++;\n          if (*p != 0)\n            g_string_append_c (s, *p++);\n        }\n      else\n        g_string_append_c (s, *p++);\n    }\n\n  mode = FLATPAK_FILESYSTEM_MODE_READ_WRITE;\n\n  if (*p == ':')\n    {\n      suffix = p + 1;\n\n      if (strcmp (suffix, \"ro\") == 0)\n        mode = FLATPAK_FILESYSTEM_MODE_READ_ONLY;\n      else if (strcmp (suffix, \"rw\") == 0)\n        mode = FLATPAK_FILESYSTEM_MODE_READ_WRITE;\n      else if (strcmp (suffix, \"create\") == 0)\n        mode = FLATPAK_FILESYSTEM_MODE_CREATE;\n      else if (*suffix != 0)\n        g_warning (\"Unexpected filesystem suffix %s, ignoring\", suffix);\n    }\n\n  if (mode_out)\n    *mode_out = mode;\n\n  return g_string_free (g_steal_pointer (&s), FALSE);\n}\n\ngboolean\nflatpak_context_parse_filesystem (const char             *filesystem_and_mode,\n                                  char                  **filesystem_out,\n                                  FlatpakFilesystemMode  *mode_out,\n                                  GError                **error)\n{\n  g_autofree char *filesystem = parse_filesystem_flags (filesystem_and_mode, mode_out);\n  char *slash;\n\n  slash = strchr (filesystem, '/');\n\n  /* Forbid /../ in paths */\n  if (slash != NULL)\n    {\n      if (g_str_has_prefix (slash + 1, \"../\") ||\n          g_str_has_suffix (slash + 1, \"/..\") ||\n          strstr (slash + 1, \"/../\") != NULL)\n        {\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"Filesystem location \\\"%s\\\" contains \\\"..\\\"\"),\n                       filesystem);\n          return FALSE;\n        }\n\n      /* Convert \"//\" and \"/./\" to \"/\" */\n      for (; slash != NULL; slash = strchr (slash + 1, '/'))\n        {\n          while (TRUE)\n            {\n              if (slash[1] == '/')\n                memmove (slash + 1, slash + 2, strlen (slash + 2) + 1);\n              else if (slash[1] == '.' && slash[2] == '/')\n                memmove (slash + 1, slash + 3, strlen (slash + 3) + 1);\n              else\n                break;\n            }\n        }\n\n      /* Eliminate trailing \"/.\" or \"/\". */\n      while (TRUE)\n        {\n          slash = strrchr (filesystem, '/');\n\n          if (slash != NULL &&\n              ((slash != filesystem && slash[1] == '\\0') ||\n               (slash[1] == '.' && slash[2] == '\\0')))\n            *slash = '\\0';\n          else\n            break;\n        }\n\n      if (filesystem[0] == '/' && filesystem[1] == '\\0')\n        {\n          /* We don't allow --filesystem=/ as equivalent to host, because\n           * it doesn't do what you'd think: --filesystem=host mounts some\n           * host directories in /run/host, not in the root. */\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"--filesystem=/ is not available, \"\n                         \"use --filesystem=host for a similar result\"));\n          return FALSE;\n        }\n    }\n\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      get_xdg_user_dir_from_string (filesystem, NULL, NULL, NULL) ||\n      g_str_has_prefix (filesystem, \"~/\") ||\n      g_str_has_prefix (filesystem, \"/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_steal_pointer (&filesystem);\n\n      return TRUE;\n    }\n\n  if (strcmp (filesystem, \"~\") == 0)\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strdup (\"home\");\n\n      return TRUE;\n    }\n\n  if (g_str_has_prefix (filesystem, \"home/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strconcat (\"~/\", filesystem + 5, NULL);\n\n      return TRUE;\n    }\n\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/\u2026], ~/dir, /dir\"), filesystem);\n  return FALSE;\n}\n\nstatic void\nflatpak_context_take_filesystem (FlatpakContext        *context,\n                                 char                  *fs,\n                                 FlatpakFilesystemMode  mode)\n{\n  g_hash_table_insert (context->filesystems, fs, GINT_TO_POINTER (mode));\n}\n\nvoid\nflatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}\n\nstatic gboolean\noption_share_cb (const gchar *option_name,\n                 const gchar *value,\n                 gpointer     data,\n                 GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextShares share;\n\n  share = flatpak_context_share_from_string (value, error);\n  if (share == 0)\n    return FALSE;\n\n  flatpak_context_add_shares (context, share);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_unshare_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextShares share;\n\n  share = flatpak_context_share_from_string (value, error);\n  if (share == 0)\n    return FALSE;\n\n  flatpak_context_remove_shares (context, share);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_socket_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextSockets socket;\n\n  socket = flatpak_context_socket_from_string (value, error);\n  if (socket == 0)\n    return FALSE;\n\n  if (socket == FLATPAK_CONTEXT_SOCKET_FALLBACK_X11)\n    socket |= FLATPAK_CONTEXT_SOCKET_X11;\n\n  flatpak_context_add_sockets (context, socket);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_nosocket_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextSockets socket;\n\n  socket = flatpak_context_socket_from_string (value, error);\n  if (socket == 0)\n    return FALSE;\n\n  if (socket == FLATPAK_CONTEXT_SOCKET_FALLBACK_X11)\n    socket |= FLATPAK_CONTEXT_SOCKET_X11;\n\n  flatpak_context_remove_sockets (context, socket);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_device_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextDevices device;\n\n  device = flatpak_context_device_from_string (value, error);\n  if (device == 0)\n    return FALSE;\n\n  flatpak_context_add_devices (context, device);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_nodevice_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextDevices device;\n\n  device = flatpak_context_device_from_string (value, error);\n  if (device == 0)\n    return FALSE;\n\n  flatpak_context_remove_devices (context, device);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_allow_cb (const gchar *option_name,\n                 const gchar *value,\n                 gpointer     data,\n                 GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextFeatures feature;\n\n  feature = flatpak_context_feature_from_string (value, error);\n  if (feature == 0)\n    return FALSE;\n\n  flatpak_context_add_features (context, feature);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_disallow_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextFeatures feature;\n\n  feature = flatpak_context_feature_from_string (value, error);\n  if (feature == 0)\n    return FALSE;\n\n  flatpak_context_remove_features (context, feature);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_filesystem_cb (const gchar *option_name,\n                      const gchar *value,\n                      gpointer     data,\n                      GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autofree char *fs = NULL;\n  FlatpakFilesystemMode mode;\n\n  if (!flatpak_context_parse_filesystem (value, &fs, &mode, error))\n    return FALSE;\n\n  flatpak_context_take_filesystem (context, g_steal_pointer (&fs), mode);\n  return TRUE;\n}\n\nstatic gboolean\noption_nofilesystem_cb (const gchar *option_name,\n                        const gchar *value,\n                        gpointer     data,\n                        GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autofree char *fs = NULL;\n  FlatpakFilesystemMode mode;\n\n  if (!flatpak_context_parse_filesystem (value, &fs, &mode, error))\n    return FALSE;\n\n  flatpak_context_take_filesystem (context, g_steal_pointer (&fs),\n                                   FLATPAK_FILESYSTEM_MODE_NONE);\n  return TRUE;\n}\n\nstatic gboolean\noption_env_cb (const gchar *option_name,\n               const gchar *value,\n               gpointer     data,\n               GError     **error)\n{\n  FlatpakContext *context = data;\n  g_auto(GStrv) split = g_strsplit (value, \"=\", 2);\n\n  if (split == NULL || split[0] == NULL || split[0][0] == 0 || split[1] == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Invalid env format %s\"), value);\n      return FALSE;\n    }\n\n  flatpak_context_set_env_var (context, split[0], split[1]);\n  return TRUE;\n}\n\ngboolean\nflatpak_context_parse_env_block (FlatpakContext *context,\n                                 const char *data,\n                                 gsize length,\n                                 GError **error)\n{\n  const char *p = data;\n  gsize remaining = length;\n\n  /* env_block might not be \\0-terminated */\n  while (remaining > 0)\n    {\n      size_t len = strnlen (p, remaining);\n      const char *equals;\n      g_autofree char *env_var = NULL;\n      g_autofree char *env_value = NULL;\n\n      g_assert (len <= remaining);\n\n      equals = memchr (p, '=', len);\n\n      if (equals == NULL || equals == p)\n        return glnx_throw (error,\n                           \"Environment variable must be given in the form VARIABLE=VALUE, not %.*s\", (int) len, p);\n\n      env_var = g_strndup (p, equals - p);\n      env_value = g_strndup (equals + 1, len - (equals - p) - 1);\n      flatpak_context_set_env_var (context, env_var, env_value);\n      p += len;\n      remaining -= len;\n\n      if (remaining > 0)\n        {\n          g_assert (*p == '\\0');\n          p += 1;\n          remaining -= 1;\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_context_parse_env_fd (FlatpakContext *context,\n                              int fd,\n                              GError **error)\n{\n  g_autoptr(GBytes) env_block = NULL;\n  const char *data;\n  gsize len;\n\n  env_block = glnx_fd_readall_bytes (fd, NULL, error);\n\n  if (env_block == NULL)\n    return FALSE;\n\n  data = g_bytes_get_data (env_block, &len);\n  return flatpak_context_parse_env_block (context, data, len, error);\n}\n\nstatic gboolean\noption_env_fd_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  guint64 fd;\n  gchar *endptr;\n  gboolean ret;\n\n  fd = g_ascii_strtoull (value, &endptr, 10);\n\n  if (endptr == NULL || *endptr != '\\0' || fd > G_MAXINT)\n    return glnx_throw (error, \"Not a valid file descriptor: %s\", value);\n\n  ret = flatpak_context_parse_env_fd (context, (int) fd, error);\n\n  if (fd >= 3)\n    close (fd);\n\n  return ret;\n}\n\nstatic gboolean\noption_unset_env_cb (const gchar *option_name,\n                     const gchar *value,\n                     gpointer     data,\n                     GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (strchr (value, '=') != NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Environment variable name must not contain '=': %s\"), value);\n      return FALSE;\n    }\n\n  flatpak_context_set_env_var (context, value, NULL);\n  return TRUE;\n}\n\nstatic gboolean\noption_own_name_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_session_bus_policy (context, value, FLATPAK_POLICY_OWN);\n  return TRUE;\n}\n\nstatic gboolean\noption_talk_name_cb (const gchar *option_name,\n                     const gchar *value,\n                     gpointer     data,\n                     GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_session_bus_policy (context, value, FLATPAK_POLICY_TALK);\n  return TRUE;\n}\n\nstatic gboolean\noption_no_talk_name_cb (const gchar *option_name,\n                        const gchar *value,\n                        gpointer     data,\n                        GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_session_bus_policy (context, value, FLATPAK_POLICY_NONE);\n  return TRUE;\n}\n\nstatic gboolean\noption_system_own_name_cb (const gchar *option_name,\n                           const gchar *value,\n                           gpointer     data,\n                           GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_system_bus_policy (context, value, FLATPAK_POLICY_OWN);\n  return TRUE;\n}\n\nstatic gboolean\noption_system_talk_name_cb (const gchar *option_name,\n                            const gchar *value,\n                            gpointer     data,\n                            GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_system_bus_policy (context, value, FLATPAK_POLICY_TALK);\n  return TRUE;\n}\n\nstatic gboolean\noption_system_no_talk_name_cb (const gchar *option_name,\n                               const gchar *value,\n                               gpointer     data,\n                               GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_system_bus_policy (context, value, FLATPAK_POLICY_NONE);\n  return TRUE;\n}\n\nstatic gboolean\noption_add_generic_policy_cb (const gchar *option_name,\n                              const gchar *value,\n                              gpointer     data,\n                              GError     **error)\n{\n  FlatpakContext *context = data;\n  char *t;\n  g_autofree char *key = NULL;\n  const char *policy_value;\n\n  t = strchr (value, '=');\n  if (t == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--add-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n  policy_value = t + 1;\n  key = g_strndup (value, t - value);\n  if (strchr (key, '.') == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--add-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n\n  if (policy_value[0] == '!')\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--add-policy values can't start with \\\"!\\\"\"));\n      return FALSE;\n    }\n\n  flatpak_context_apply_generic_policy (context, key, policy_value);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_remove_generic_policy_cb (const gchar *option_name,\n                                 const gchar *value,\n                                 gpointer     data,\n                                 GError     **error)\n{\n  FlatpakContext *context = data;\n  char *t;\n  g_autofree char *key = NULL;\n  const char *policy_value;\n  g_autofree char *extended_value = NULL;\n\n  t = strchr (value, '=');\n  if (t == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--remove-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n  policy_value = t + 1;\n  key = g_strndup (value, t - value);\n  if (strchr (key, '.') == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--remove-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n\n  if (policy_value[0] == '!')\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--remove-policy values can't start with \\\"!\\\"\"));\n      return FALSE;\n    }\n\n  extended_value = g_strconcat (\"!\", policy_value, NULL);\n\n  flatpak_context_apply_generic_policy (context, key, extended_value);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}\n\nstatic gboolean option_no_desktop_deprecated;\n\nstatic GOptionEntry context_options[] = {\n  { \"share\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_share_cb, N_(\"Share with host\"), N_(\"SHARE\") },\n  { \"unshare\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_unshare_cb, N_(\"Unshare with host\"), N_(\"SHARE\") },\n  { \"socket\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_socket_cb, N_(\"Expose socket to app\"), N_(\"SOCKET\") },\n  { \"nosocket\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_nosocket_cb, N_(\"Don't expose socket to app\"), N_(\"SOCKET\") },\n  { \"device\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_device_cb, N_(\"Expose device to app\"), N_(\"DEVICE\") },\n  { \"nodevice\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_nodevice_cb, N_(\"Don't expose device to app\"), N_(\"DEVICE\") },\n  { \"allow\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_allow_cb, N_(\"Allow feature\"), N_(\"FEATURE\") },\n  { \"disallow\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_disallow_cb, N_(\"Don't allow feature\"), N_(\"FEATURE\") },\n  { \"filesystem\", 0, G_OPTION_FLAG_IN_MAIN | G_OPTION_FLAG_FILENAME, G_OPTION_ARG_CALLBACK, &option_filesystem_cb, N_(\"Expose filesystem to app (:ro for read-only)\"), N_(\"FILESYSTEM[:ro]\") },\n  { \"nofilesystem\", 0, G_OPTION_FLAG_IN_MAIN | G_OPTION_FLAG_FILENAME, G_OPTION_ARG_CALLBACK, &option_nofilesystem_cb, N_(\"Don't expose filesystem to app\"), N_(\"FILESYSTEM\") },\n  { \"env\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_env_cb, N_(\"Set environment variable\"), N_(\"VAR=VALUE\") },\n  { \"env-fd\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_env_fd_cb, N_(\"Read environment variables in env -0 format from FD\"), N_(\"FD\") },\n  { \"unset-env\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_unset_env_cb, N_(\"Remove variable from environment\"), N_(\"VAR\") },\n  { \"own-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_own_name_cb, N_(\"Allow app to own name on the session bus\"), N_(\"DBUS_NAME\") },\n  { \"talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_talk_name_cb, N_(\"Allow app to talk to name on the session bus\"), N_(\"DBUS_NAME\") },\n  { \"no-talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_no_talk_name_cb, N_(\"Don't allow app to talk to name on the session bus\"), N_(\"DBUS_NAME\") },\n  { \"system-own-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_system_own_name_cb, N_(\"Allow app to own name on the system bus\"), N_(\"DBUS_NAME\") },\n  { \"system-talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_system_talk_name_cb, N_(\"Allow app to talk to name on the system bus\"), N_(\"DBUS_NAME\") },\n  { \"system-no-talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_system_no_talk_name_cb, N_(\"Don't allow app to talk to name on the system bus\"), N_(\"DBUS_NAME\") },\n  { \"add-policy\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_add_generic_policy_cb, N_(\"Add generic policy option\"), N_(\"SUBSYSTEM.KEY=VALUE\") },\n  { \"remove-policy\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_remove_generic_policy_cb, N_(\"Remove generic policy option\"), N_(\"SUBSYSTEM.KEY=VALUE\") },\n  { \"persist\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_persist_cb, N_(\"Persist home directory subpath\"), N_(\"FILENAME\") },\n  /* This is not needed/used anymore, so hidden, but we accept it for backwards compat */\n  { \"no-desktop\", 0, G_OPTION_FLAG_IN_MAIN |  G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, &option_no_desktop_deprecated, N_(\"Don't require a running session (no cgroups creation)\"), NULL },\n  { NULL }\n};\n\nGOptionEntry *\nflatpak_context_get_option_entries (void)\n{\n  return context_options;\n}\n\nGOptionGroup  *\nflatpak_context_get_options (FlatpakContext *context)\n{\n  GOptionGroup *group;\n\n  group = g_option_group_new (\"environment\",\n                              \"Runtime Environment\",\n                              \"Runtime Environment\",\n                              context,\n                              NULL);\n  g_option_group_set_translation_domain (group, GETTEXT_PACKAGE);\n\n  g_option_group_add_entries (group, context_options);\n\n  return group;\n}\n\nstatic const char *\nparse_negated (const char *option, gboolean *negated)\n{\n  if (option[0] == '!')\n    {\n      option++;\n      *negated = TRUE;\n    }\n  else\n    {\n      *negated = FALSE;\n    }\n  return option;\n}\n\n/*\n * Merge the FLATPAK_METADATA_GROUP_CONTEXT,\n * FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY,\n * FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY and\n * FLATPAK_METADATA_GROUP_ENVIRONMENT groups, and all groups starting\n * with FLATPAK_METADATA_GROUP_PREFIX_POLICY, from metakey into context.\n *\n * This is a merge, not a replace!\n */\ngboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_debug (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_debug (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_debug (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_debug (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, &filesystem, &mode, NULL))\n            g_debug (\"Unknown filesystem type %s\", filesystems[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem),\n                                                 FLATPAK_FILESYSTEM_MODE_NONE);\n              else\n                flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        flatpak_context_set_persistent (context, persistent[i]);\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}\n\n/*\n * Save the FLATPAK_METADATA_GROUP_CONTEXT,\n * FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY,\n * FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY and\n * FLATPAK_METADATA_GROUP_ENVIRONMENT groups, and all groups starting\n * with FLATPAK_METADATA_GROUP_PREFIX_POLICY, into metakey\n */\nvoid\nflatpak_context_save_metadata (FlatpakContext *context,\n                               gboolean        flatten,\n                               GKeyFile       *metakey)\n{\n  g_auto(GStrv) shared = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) features = NULL;\n  g_autoptr(GPtrArray) unset_env = NULL;\n  GHashTableIter iter;\n  gpointer key, value;\n  FlatpakContextShares shares_mask = context->shares;\n  FlatpakContextShares shares_valid = context->shares_valid;\n  FlatpakContextSockets sockets_mask = context->sockets;\n  FlatpakContextSockets sockets_valid = context->sockets_valid;\n  FlatpakContextDevices devices_mask = context->devices;\n  FlatpakContextDevices devices_valid = context->devices_valid;\n  FlatpakContextFeatures features_mask = context->features;\n  FlatpakContextFeatures features_valid = context->features_valid;\n  g_auto(GStrv) groups = NULL;\n  int i;\n\n  if (flatten)\n    {\n      /* A flattened format means we don't expect this to be merged on top of\n         another context. In that case we never need to negate any flags.\n         We calculate this by removing the zero parts of the mask from the valid set.\n       */\n      /* First we make sure only the valid parts of the mask are set, in case we\n         got some leftover */\n      shares_mask &= shares_valid;\n      sockets_mask &= sockets_valid;\n      devices_mask &= devices_valid;\n      features_mask &= features_valid;\n\n      /* Then just set the valid set to be the mask set */\n      shares_valid = shares_mask;\n      sockets_valid = sockets_mask;\n      devices_valid = devices_mask;\n      features_valid = features_mask;\n    }\n\n  shared = flatpak_context_shared_to_string (shares_mask, shares_valid);\n  sockets = flatpak_context_sockets_to_string (sockets_mask, sockets_valid);\n  devices = flatpak_context_devices_to_string (devices_mask, devices_valid);\n  features = flatpak_context_features_to_string (features_mask, features_valid);\n\n  if (shared[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_SHARED,\n                                  (const char * const *) shared, g_strv_length (shared));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_SHARED,\n                             NULL);\n    }\n\n  if (sockets[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_SOCKETS,\n                                  (const char * const *) sockets, g_strv_length (sockets));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_SOCKETS,\n                             NULL);\n    }\n\n  if (devices[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_DEVICES,\n                                  (const char * const *) devices, g_strv_length (devices));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_DEVICES,\n                             NULL);\n    }\n\n  if (features[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_FEATURES,\n                                  (const char * const *) features, g_strv_length (features));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_FEATURES,\n                             NULL);\n    }\n\n  if (g_hash_table_size (context->filesystems) > 0)\n    {\n      g_autoptr(GPtrArray) array = g_ptr_array_new_with_free_func (g_free);\n\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n\n          g_ptr_array_add (array, unparse_filesystem_flags (key, mode));\n        }\n\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_FILESYSTEMS,\n                                  (const char * const *) array->pdata, array->len);\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_FILESYSTEMS,\n                             NULL);\n    }\n\n  if (g_hash_table_size (context->persistent) > 0)\n    {\n      g_autofree char **keys = (char **) g_hash_table_get_keys_as_array (context->persistent, NULL);\n\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_PERSISTENT,\n                                  (const char * const *) keys, g_strv_length (keys));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_PERSISTENT,\n                             NULL);\n    }\n\n  g_key_file_remove_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, NULL);\n  g_hash_table_iter_init (&iter, context->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      if (flatten && (policy == 0))\n        continue;\n\n      g_key_file_set_string (metakey,\n                             FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY,\n                             (char *) key, flatpak_policy_to_string (policy));\n    }\n\n  g_key_file_remove_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, NULL);\n  g_hash_table_iter_init (&iter, context->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      if (flatten && (policy == 0))\n        continue;\n\n      g_key_file_set_string (metakey,\n                             FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY,\n                             (char *) key, flatpak_policy_to_string (policy));\n    }\n\n  /* Elements are borrowed from context->env_vars */\n  unset_env = g_ptr_array_new ();\n\n  g_key_file_remove_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, NULL);\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      if (value != NULL)\n        {\n          g_key_file_set_string (metakey,\n                                 FLATPAK_METADATA_GROUP_ENVIRONMENT,\n                                 (char *) key, (char *) value);\n        }\n      else\n        {\n          /* In older versions of Flatpak, [Environment] FOO=\n           * was interpreted as unsetting - so let's do both. */\n          g_key_file_set_string (metakey,\n                                 FLATPAK_METADATA_GROUP_ENVIRONMENT,\n                                 (char *) key, \"\");\n          g_ptr_array_add (unset_env, key);\n        }\n    }\n\n  if (unset_env->len > 0)\n    {\n      g_ptr_array_add (unset_env, NULL);\n      g_key_file_set_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                  (const char * const *) unset_env->pdata,\n                                  unset_env->len - 1);\n    }\n  else\n    {\n      g_key_file_remove_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL);\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        g_key_file_remove_group (metakey, group, NULL);\n    }\n\n  g_hash_table_iter_init (&iter, context->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      g_auto(GStrv) parts = g_strsplit ((const char *) key, \".\", 2);\n      g_autofree char *group = NULL;\n      g_assert (parts[1] != NULL);\n      const char **policy_values = (const char **) value;\n      g_autoptr(GPtrArray) new = g_ptr_array_new ();\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        {\n          const char *policy_value = policy_values[i];\n\n          if (!flatten || policy_value[0] != '!')\n            g_ptr_array_add (new, (char *) policy_value);\n        }\n\n      if (new->len > 0)\n        {\n          group = g_strconcat (FLATPAK_METADATA_GROUP_PREFIX_POLICY,\n                               parts[0], NULL);\n          g_key_file_set_string_list (metakey, group, parts[1],\n                                      (const char * const *) new->pdata,\n                                      new->len);\n        }\n    }\n}\n\nvoid\nflatpak_context_allow_host_fs (FlatpakContext *context)\n{\n  flatpak_context_take_filesystem (context, g_strdup (\"host\"), FLATPAK_FILESYSTEM_MODE_READ_WRITE);\n}\n\ngboolean\nflatpak_context_get_needs_session_bus_proxy (FlatpakContext *context)\n{\n  return g_hash_table_size (context->session_bus_policy) > 0;\n}\n\ngboolean\nflatpak_context_get_needs_system_bus_proxy (FlatpakContext *context)\n{\n  return g_hash_table_size (context->system_bus_policy) > 0;\n}\n\nstatic gboolean\nadds_flags (guint32 old_flags, guint32 new_flags)\n{\n  return (new_flags & ~old_flags) != 0;\n}\n\nstatic gboolean\nadds_bus_policy (GHashTable *old, GHashTable *new)\n{\n  GLNX_HASH_TABLE_FOREACH_KV (new, const char *, name, gpointer, _new_policy)\n    {\n      int new_policy = GPOINTER_TO_INT (_new_policy);\n      int old_policy = GPOINTER_TO_INT (g_hash_table_lookup (old, name));\n      if (new_policy > old_policy)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nadds_generic_policy (GHashTable *old, GHashTable *new)\n{\n  GLNX_HASH_TABLE_FOREACH_KV (new, const char *, key, GPtrArray *, new_values)\n    {\n      GPtrArray *old_values = g_hash_table_lookup (old, key);\n      int i;\n\n      if (new_values == NULL || new_values->len == 0)\n        continue;\n\n      if (old_values == NULL || old_values->len == 0)\n        return TRUE;\n\n      for (i = 0; i < new_values->len; i++)\n        {\n          const char *new_value = g_ptr_array_index (new_values, i);\n\n          if (!flatpak_g_ptr_array_contains_string (old_values, new_value))\n            return TRUE;\n        }\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nadds_filesystem_access (GHashTable *old, GHashTable *new)\n{\n  FlatpakFilesystemMode old_host_mode = GPOINTER_TO_INT (g_hash_table_lookup (old, \"host\"));\n\n  GLNX_HASH_TABLE_FOREACH_KV (new, const char *, location, gpointer, _new_mode)\n    {\n      FlatpakFilesystemMode new_mode = GPOINTER_TO_INT (_new_mode);\n      FlatpakFilesystemMode old_mode = GPOINTER_TO_INT (g_hash_table_lookup (old, location));\n\n      /* Allow more limited access to the same thing */\n      if (new_mode <= old_mode)\n        continue;\n\n      /* Allow more limited access if we used to have access to everything */\n     if (new_mode <= old_host_mode)\n        continue;\n\n     /* For the remainder we have to be pessimistic, for instance even\n        if we have home access we can't allow adding access to ~/foo,\n        because foo might be a symlink outside home which didn't work\n        before but would work with an explicit access to that\n        particular file. */\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\n\ngboolean\nflatpak_context_adds_permissions (FlatpakContext *old,\n                                  FlatpakContext *new)\n{\n  /* We allow upgrade to multiarch, that is really not a huge problem.\n   * Similarly, having sensible semantics for /dev/shm is\n   * not a security concern. */\n  guint32 harmless_features = (FLATPAK_CONTEXT_FEATURE_MULTIARCH |\n                               FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM);\n  guint32 old_sockets;\n\n  if (adds_flags (old->shares & old->shares_valid,\n                  new->shares & new->shares_valid))\n    return TRUE;\n\n  old_sockets = old->sockets & old->sockets_valid;\n\n  /* If we used to allow X11, also allow new fallback X11,\n     as that is actually less permissions */\n  if (old_sockets & FLATPAK_CONTEXT_SOCKET_X11)\n    old_sockets |= FLATPAK_CONTEXT_SOCKET_FALLBACK_X11;\n\n  if (adds_flags (old_sockets,\n                  new->sockets & new->sockets_valid))\n    return TRUE;\n\n  if (adds_flags (old->devices & old->devices_valid,\n                  new->devices & new->devices_valid))\n    return TRUE;\n\n  if (adds_flags ((old->features & old->features_valid) | harmless_features,\n                  new->features & new->features_valid))\n    return TRUE;\n\n  if (adds_bus_policy (old->session_bus_policy, new->session_bus_policy))\n    return TRUE;\n\n  if (adds_bus_policy (old->system_bus_policy, new->system_bus_policy))\n    return TRUE;\n\n  if (adds_generic_policy (old->generic_policy, new->generic_policy))\n    return TRUE;\n\n  if (adds_filesystem_access (old->filesystems, new->filesystems))\n    return TRUE;\n\n  return FALSE;\n}\n\ngboolean\nflatpak_context_allows_features (FlatpakContext        *context,\n                                 FlatpakContextFeatures features)\n{\n  return (context->features & features) == features;\n}\n\nvoid\nflatpak_context_to_args (FlatpakContext *context,\n                         GPtrArray      *args)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  flatpak_context_shared_to_args (context->shares, context->shares_valid, args);\n  flatpak_context_sockets_to_args (context->sockets, context->sockets_valid, args);\n  flatpak_context_devices_to_args (context->devices, context->devices_valid, args);\n  flatpak_context_features_to_args (context->features, context->features_valid, args);\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      if (value != NULL)\n        g_ptr_array_add (args, g_strdup_printf (\"--env=%s=%s\", (char *) key, (char *) value));\n      else\n        g_ptr_array_add (args, g_strdup_printf (\"--unset-env=%s\", (char *) key));\n    }\n\n  g_hash_table_iter_init (&iter, context->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_ptr_array_add (args, g_strdup_printf (\"--persist=%s\", (char *) key));\n\n  g_hash_table_iter_init (&iter, context->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      g_ptr_array_add (args, g_strdup_printf (\"--%s-name=%s\", flatpak_policy_to_string (policy), name));\n    }\n\n  g_hash_table_iter_init (&iter, context->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      g_ptr_array_add (args, g_strdup_printf (\"--system-%s-name=%s\", flatpak_policy_to_string (policy), name));\n    }\n\n  g_hash_table_iter_init (&iter, context->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n\n      if (mode != FLATPAK_FILESYSTEM_MODE_NONE)\n        {\n          g_autofree char *fs = unparse_filesystem_flags (key, mode);\n          g_ptr_array_add (args, g_strdup_printf (\"--filesystem=%s\", fs));\n        }\n      else\n        g_ptr_array_add (args, g_strdup_printf (\"--nofilesystem=%s\", (char *) key));\n    }\n}\n\nvoid\nflatpak_context_add_bus_filters (FlatpakContext *context,\n                                 const char     *app_id,\n                                 gboolean        session_bus,\n                                 gboolean        sandboxed,\n                                 FlatpakBwrap   *bwrap)\n{\n  GHashTable *ht;\n  GHashTableIter iter;\n  gpointer key, value;\n\n  flatpak_bwrap_add_arg (bwrap, \"--filter\");\n  if (app_id && session_bus)\n    {\n      if (!sandboxed)\n        {\n          flatpak_bwrap_add_arg_printf (bwrap, \"--own=%s.*\", app_id);\n          flatpak_bwrap_add_arg_printf (bwrap, \"--own=org.mpris.MediaPlayer2.%s.*\", app_id);\n        }\n      else\n        flatpak_bwrap_add_arg_printf (bwrap, \"--own=%s.Sandboxed.*\", app_id);\n    }\n\n  if (session_bus)\n    ht = context->session_bus_policy;\n  else\n    ht = context->system_bus_policy;\n\n  g_hash_table_iter_init (&iter, ht);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      if (policy > 0)\n        flatpak_bwrap_add_arg_printf (bwrap, \"--%s=%s\",\n                                      flatpak_policy_to_string (policy),\n                                      (char *) key);\n    }\n}\n\nvoid\nflatpak_context_reset_non_permissions (FlatpakContext *context)\n{\n  g_hash_table_remove_all (context->env_vars);\n}\n\nvoid\nflatpak_context_reset_permissions (FlatpakContext *context)\n{\n  context->shares_valid = 0;\n  context->sockets_valid = 0;\n  context->devices_valid = 0;\n  context->features_valid = 0;\n\n  context->shares = 0;\n  context->sockets = 0;\n  context->devices = 0;\n  context->features = 0;\n\n  g_hash_table_remove_all (context->persistent);\n  g_hash_table_remove_all (context->filesystems);\n  g_hash_table_remove_all (context->session_bus_policy);\n  g_hash_table_remove_all (context->system_bus_policy);\n  g_hash_table_remove_all (context->generic_policy);\n}\n\nvoid\nflatpak_context_make_sandboxed (FlatpakContext *context)\n{\n  /* We drop almost everything from the app permission, except\n   * multiarch which is inherited, to make sure app code keeps\n   * running. */\n  context->shares_valid &= 0;\n  context->sockets_valid &= 0;\n  context->devices_valid &= 0;\n  context->features_valid &= FLATPAK_CONTEXT_FEATURE_MULTIARCH;\n\n  context->shares &= context->shares_valid;\n  context->sockets &= context->sockets_valid;\n  context->devices &= context->devices_valid;\n  context->features &= context->features_valid;\n\n  g_hash_table_remove_all (context->persistent);\n  g_hash_table_remove_all (context->filesystems);\n  g_hash_table_remove_all (context->session_bus_policy);\n  g_hash_table_remove_all (context->system_bus_policy);\n  g_hash_table_remove_all (context->generic_policy);\n}\n\nconst char *dont_mount_in_root[] = {\n  \".\", \"..\", \"lib\", \"lib32\", \"lib64\", \"bin\", \"sbin\", \"usr\", \"boot\", \"root\",\n  \"tmp\", \"etc\", \"app\", \"run\", \"proc\", \"sys\", \"dev\", \"var\", NULL\n};\n\nstatic void\nflatpak_context_export (FlatpakContext *context,\n                        FlatpakExports *exports,\n                        GFile          *app_id_dir,\n                        GPtrArray       *extra_app_id_dirs,\n                        gboolean        do_create,\n                        gchar         **xdg_dirs_conf_out,\n                        gboolean       *home_access_out)\n{\n  gboolean home_access = FALSE;\n  g_autoptr(GString) xdg_dirs_conf = NULL;\n  FlatpakFilesystemMode fs_mode, os_mode, etc_mode, home_mode;\n  GHashTableIter iter;\n  gpointer key, value;\n\n  if (xdg_dirs_conf_out != NULL)\n    xdg_dirs_conf = g_string_new (\"\");\n\n  fs_mode = GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"host\"));\n  if (fs_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    {\n      DIR *dir;\n      struct dirent *dirent;\n\n      g_debug (\"Allowing host-fs access\");\n      home_access = TRUE;\n\n      /* Bind mount most dirs in / into the new root */\n      dir = opendir (\"/\");\n      if (dir != NULL)\n        {\n          while ((dirent = readdir (dir)))\n            {\n              g_autofree char *path = NULL;\n\n              if (g_strv_contains (dont_mount_in_root, dirent->d_name))\n                continue;\n\n              path = g_build_filename (\"/\", dirent->d_name, NULL);\n              flatpak_exports_add_path_expose (exports, fs_mode, path);\n            }\n          closedir (dir);\n        }\n      flatpak_exports_add_path_expose (exports, fs_mode, \"/run/media\");\n    }\n\n  os_mode = MAX (GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"host-os\")),\n                   fs_mode);\n\n  if (os_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    flatpak_exports_add_host_os_expose (exports, os_mode);\n\n  etc_mode = MAX (GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"host-etc\")),\n                   fs_mode);\n\n  if (etc_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    flatpak_exports_add_host_etc_expose (exports, etc_mode);\n\n  home_mode = GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"home\"));\n  if (home_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    {\n      g_debug (\"Allowing homedir access\");\n      home_access = TRUE;\n\n      flatpak_exports_add_path_expose (exports, MAX (home_mode, fs_mode), g_get_home_dir ());\n    }\n\n  g_hash_table_iter_init (&iter, context->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *filesystem = key;\n      FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n\n      if (g_strv_contains (flatpak_context_special_filesystems, filesystem))\n        continue;\n\n      if (g_str_has_prefix (filesystem, \"xdg-\"))\n        {\n          const char *path, *rest = NULL;\n          const char *config_key = NULL;\n          g_autofree char *subpath = NULL;\n\n          if (!get_xdg_user_dir_from_string (filesystem, &config_key, &rest, &path))\n            {\n              g_warning (\"Unsupported xdg dir %s\", filesystem);\n              continue;\n            }\n\n          if (path == NULL)\n            continue; /* Unconfigured, ignore */\n\n          if (strcmp (path, g_get_home_dir ()) == 0)\n            {\n              /* xdg-user-dirs sets disabled dirs to $HOME, and its in general not a good\n                 idea to set full access to $HOME other than explicitly, so we ignore\n                 these */\n              g_debug (\"Xdg dir %s is $HOME (i.e. disabled), ignoring\", filesystem);\n              continue;\n            }\n\n          subpath = g_build_filename (path, rest, NULL);\n\n          if (mode == FLATPAK_FILESYSTEM_MODE_CREATE && do_create)\n            g_mkdir_with_parents (subpath, 0755);\n\n          if (g_file_test (subpath, G_FILE_TEST_EXISTS))\n            {\n              if (config_key && xdg_dirs_conf)\n                g_string_append_printf (xdg_dirs_conf, \"%s=\\\"%s\\\"\\n\",\n                                        config_key, path);\n\n              flatpak_exports_add_path_expose_or_hide (exports, mode, subpath);\n            }\n        }\n      else if (g_str_has_prefix (filesystem, \"~/\"))\n        {\n          g_autofree char *path = NULL;\n\n          path = g_build_filename (g_get_home_dir (), filesystem + 2, NULL);\n\n          if (mode == FLATPAK_FILESYSTEM_MODE_CREATE && do_create)\n            g_mkdir_with_parents (path, 0755);\n\n          if (g_file_test (path, G_FILE_TEST_EXISTS))\n            flatpak_exports_add_path_expose_or_hide (exports, mode, path);\n        }\n      else if (g_str_has_prefix (filesystem, \"/\"))\n        {\n          if (mode == FLATPAK_FILESYSTEM_MODE_CREATE && do_create)\n            g_mkdir_with_parents (filesystem, 0755);\n\n          if (g_file_test (filesystem, G_FILE_TEST_EXISTS))\n            flatpak_exports_add_path_expose_or_hide (exports, mode, filesystem);\n        }\n      else\n        {\n          g_warning (\"Unexpected filesystem arg %s\", filesystem);\n        }\n    }\n\n  if (app_id_dir)\n    {\n      g_autoptr(GFile) apps_dir = g_file_get_parent (app_id_dir);\n      int i;\n      /* Hide the .var/app dir by default (unless explicitly made visible) */\n      flatpak_exports_add_path_tmpfs (exports, flatpak_file_get_path_cached (apps_dir));\n      /* But let the app write to the per-app dir in it */\n      flatpak_exports_add_path_expose (exports, FLATPAK_FILESYSTEM_MODE_READ_WRITE,\n                                       flatpak_file_get_path_cached (app_id_dir));\n\n      if (extra_app_id_dirs != NULL)\n        {\n          for (i = 0; i < extra_app_id_dirs->len; i++)\n            {\n              GFile *extra_app_id_dir = g_ptr_array_index (extra_app_id_dirs, i);\n              flatpak_exports_add_path_expose (exports, FLATPAK_FILESYSTEM_MODE_READ_WRITE,\n                                               flatpak_file_get_path_cached (extra_app_id_dir));\n            }\n        }\n    }\n\n  if (home_access_out != NULL)\n    *home_access_out = home_access;\n\n  if (xdg_dirs_conf_out != NULL)\n    {\n      g_assert (xdg_dirs_conf != NULL);\n      *xdg_dirs_conf_out = g_string_free (g_steal_pointer (&xdg_dirs_conf), FALSE);\n    }\n}\n\nFlatpakExports *\nflatpak_context_get_exports (FlatpakContext *context,\n                             const char     *app_id)\n{\n  g_autoptr(GFile) app_id_dir = flatpak_get_data_dir (app_id);\n\n  return flatpak_context_get_exports_full (context,\n                                           app_id_dir, NULL,\n                                           FALSE, FALSE, NULL, NULL);\n}\n\nFlatpakRunFlags\nflatpak_context_get_run_flags (FlatpakContext *context)\n{\n  FlatpakRunFlags flags = 0;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_DEVEL))\n    flags |= FLATPAK_RUN_FLAG_DEVEL;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_MULTIARCH))\n    flags |= FLATPAK_RUN_FLAG_MULTIARCH;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_BLUETOOTH))\n    flags |= FLATPAK_RUN_FLAG_BLUETOOTH;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_CANBUS))\n    flags |= FLATPAK_RUN_FLAG_CANBUS;\n\n  return flags;\n}\n\nFlatpakExports *\nflatpak_context_get_exports_full (FlatpakContext *context,\n                                  GFile          *app_id_dir,\n                                  GPtrArray      *extra_app_id_dirs,\n                                  gboolean        do_create,\n                                  gboolean        include_default_dirs,\n                                  gchar         **xdg_dirs_conf_out,\n                                  gboolean       *home_access_out)\n{\n  g_autoptr(FlatpakExports) exports = flatpak_exports_new ();\n\n  flatpak_context_export (context, exports,\n                          app_id_dir, extra_app_id_dirs,\n                          do_create, xdg_dirs_conf_out, home_access_out);\n\n  if (include_default_dirs)\n    {\n      g_autoptr(GFile) user_flatpak_dir = NULL;\n\n      /* Hide the flatpak dir by default (unless explicitly made visible) */\n      user_flatpak_dir = flatpak_get_user_base_dir_location ();\n      flatpak_exports_add_path_tmpfs (exports, flatpak_file_get_path_cached (user_flatpak_dir));\n\n      /* Ensure we always have a homedir */\n      flatpak_exports_add_path_dir (exports, g_get_home_dir ());\n    }\n\n  return g_steal_pointer (&exports);\n}\n\nvoid\nflatpak_context_append_bwrap_filesystem (FlatpakContext  *context,\n                                         FlatpakBwrap    *bwrap,\n                                         const char      *app_id,\n                                         GFile           *app_id_dir,\n                                         FlatpakExports  *exports,\n                                         const char      *xdg_dirs_conf,\n                                         gboolean         home_access)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  if (app_id_dir != NULL)\n    flatpak_run_apply_env_appid (bwrap, app_id_dir);\n\n  if (!home_access)\n    {\n      /* Enable persistent mapping only if no access to real home dir */\n\n      g_hash_table_iter_init (&iter, context->persistent);\n      while (g_hash_table_iter_next (&iter, &key, NULL))\n        {\n          const char *persist = key;\n          g_autofree char *src = g_build_filename (g_get_home_dir (), \".var/app\", app_id, persist, NULL);\n          g_autofree char *dest = g_build_filename (g_get_home_dir (), persist, NULL);\n\n          g_mkdir_with_parents (src, 0755);\n\n          flatpak_bwrap_add_bind_arg (bwrap, \"--bind\", src, dest);\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n      g_autofree char *run_user_app_dst = g_strdup_printf (\"/run/flatpak/app/%s\", app_id);\n      g_autofree char *run_user_app_src = g_build_filename (user_runtime_dir, \"app\", app_id, NULL);\n\n      if (glnx_shutil_mkdir_p_at (AT_FDCWD,\n                                  run_user_app_src,\n                                  0700,\n                                  NULL,\n                                  NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--bind\", run_user_app_src, run_user_app_dst,\n                                NULL);\n\n      /* Later, we'll make $XDG_RUNTIME_DIR/app a symlink to /run/flatpak/app */\n      flatpak_bwrap_add_runtime_dir_member (bwrap, \"app\");\n    }\n\n  /* This actually outputs the args for the hide/expose operations\n   * in the exports */\n  flatpak_exports_append_bwrap_args (exports, bwrap);\n\n  /* Special case subdirectories of the cache, config and data xdg\n   * dirs.  If these are accessible explicitly, then we bind-mount\n   * these in the app-id dir. This allows applications to explicitly\n   * opt out of keeping some config/cache/data in the app-specific\n   * directory.\n   */\n  if (app_id_dir)\n    {\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          const char *filesystem = key;\n          FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n          g_autofree char *xdg_path = NULL;\n          const char *rest, *where;\n\n          xdg_path = get_xdg_dir_from_string (filesystem, &rest, &where);\n\n          if (xdg_path != NULL && *rest != 0 &&\n              mode >= FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n            {\n              g_autoptr(GFile) app_version = g_file_get_child (app_id_dir, where);\n              g_autoptr(GFile) app_version_subdir = g_file_resolve_relative_path (app_version, rest);\n\n              if (g_file_test (xdg_path, G_FILE_TEST_IS_DIR) ||\n                  g_file_test (xdg_path, G_FILE_TEST_IS_REGULAR))\n                {\n                  g_autofree char *xdg_path_in_app = g_file_get_path (app_version_subdir);\n                  flatpak_bwrap_add_bind_arg (bwrap,\n                                              mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY ? \"--ro-bind\" : \"--bind\",\n                                              xdg_path, xdg_path_in_app);\n                }\n            }\n        }\n    }\n\n  if (home_access && app_id_dir != NULL)\n    {\n      g_autofree char *src_path = g_build_filename (g_get_user_config_dir (),\n                                                    \"user-dirs.dirs\",\n                                                    NULL);\n      g_autofree char *path = g_build_filename (flatpak_file_get_path_cached (app_id_dir),\n                                                \"config/user-dirs.dirs\", NULL);\n      if (g_file_test (src_path, G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_bind_arg (bwrap, \"--ro-bind\", src_path, path);\n    }\n  else if (xdg_dirs_conf != NULL && xdg_dirs_conf[0] != '\\0' && app_id_dir != NULL)\n    {\n      g_autofree char *path =\n        g_build_filename (flatpak_file_get_path_cached (app_id_dir),\n                          \"config/user-dirs.dirs\", NULL);\n\n      flatpak_bwrap_add_args_data (bwrap, \"xdg-config-dirs\",\n                                   xdg_dirs_conf, strlen (xdg_dirs_conf), path, NULL);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2014-2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-run-private.h\"\n#include \"flatpak-proxy.h\"\n#include \"flatpak-utils-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include \"flatpak-error.h\"\n\n/* Same order as enum */\nconst char *flatpak_context_shares[] = {\n  \"network\",\n  \"ipc\",\n  NULL\n};\n\n/* Same order as enum */\nconst char *flatpak_context_sockets[] = {\n  \"x11\",\n  \"wayland\",\n  \"pulseaudio\",\n  \"session-bus\",\n  \"system-bus\",\n  \"fallback-x11\",\n  \"ssh-auth\",\n  \"pcsc\",\n  \"cups\",\n  NULL\n};\n\nconst char *flatpak_context_devices[] = {\n  \"dri\",\n  \"all\",\n  \"kvm\",\n  \"shm\",\n  NULL\n};\n\nconst char *flatpak_context_features[] = {\n  \"devel\",\n  \"multiarch\",\n  \"bluetooth\",\n  \"canbus\",\n  \"per-app-dev-shm\",\n  NULL\n};\n\nconst char *flatpak_context_special_filesystems[] = {\n  \"home\",\n  \"host\",\n  \"host-etc\",\n  \"host-os\",\n  NULL\n};\n\nFlatpakContext *\nflatpak_context_new (void)\n{\n  FlatpakContext *context;\n\n  context = g_slice_new0 (FlatpakContext);\n  context->env_vars = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);\n  context->persistent = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  /* filename or special filesystem name => FlatpakFilesystemMode */\n  context->filesystems = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  context->session_bus_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  context->system_bus_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  context->generic_policy = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                                   g_free, (GDestroyNotify) g_strfreev);\n\n  return context;\n}\n\nvoid\nflatpak_context_free (FlatpakContext *context)\n{\n  g_hash_table_destroy (context->env_vars);\n  g_hash_table_destroy (context->persistent);\n  g_hash_table_destroy (context->filesystems);\n  g_hash_table_destroy (context->session_bus_policy);\n  g_hash_table_destroy (context->system_bus_policy);\n  g_hash_table_destroy (context->generic_policy);\n  g_slice_free (FlatpakContext, context);\n}\n\nstatic guint32\nflatpak_context_bitmask_from_string (const char *name, const char **names)\n{\n  guint32 i;\n\n  for (i = 0; names[i] != NULL; i++)\n    {\n      if (strcmp (names[i], name) == 0)\n        return 1 << i;\n    }\n\n  return 0;\n}\n\nstatic char **\nflatpak_context_bitmask_to_string (guint32 enabled, guint32 valid, const char **names)\n{\n  guint32 i;\n  GPtrArray *array;\n\n  array = g_ptr_array_new ();\n\n  for (i = 0; names[i] != NULL; i++)\n    {\n      guint32 bitmask = 1 << i;\n      if (valid & bitmask)\n        {\n          if (enabled & bitmask)\n            g_ptr_array_add (array, g_strdup (names[i]));\n          else\n            g_ptr_array_add (array, g_strdup_printf (\"!%s\", names[i]));\n        }\n    }\n\n  g_ptr_array_add (array, NULL);\n  return (char **) g_ptr_array_free (array, FALSE);\n}\n\nstatic void\nflatpak_context_bitmask_to_args (guint32 enabled, guint32 valid, const char **names,\n                                 const char *enable_arg, const char *disable_arg,\n                                 GPtrArray *args)\n{\n  guint32 i;\n\n  for (i = 0; names[i] != NULL; i++)\n    {\n      guint32 bitmask = 1 << i;\n      if (valid & bitmask)\n        {\n          if (enabled & bitmask)\n            g_ptr_array_add (args, g_strdup_printf (\"%s=%s\", enable_arg, names[i]));\n          else\n            g_ptr_array_add (args, g_strdup_printf (\"%s=%s\", disable_arg, names[i]));\n        }\n    }\n}\n\n\nstatic FlatpakContextShares\nflatpak_context_share_from_string (const char *string, GError **error)\n{\n  FlatpakContextShares shares = flatpak_context_bitmask_from_string (string, flatpak_context_shares);\n\n  if (shares == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_shares);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown share type %s, valid types are: %s\"), string, values);\n    }\n\n  return shares;\n}\n\nstatic char **\nflatpak_context_shared_to_string (FlatpakContextShares shares, FlatpakContextShares valid)\n{\n  return flatpak_context_bitmask_to_string (shares, valid, flatpak_context_shares);\n}\n\nstatic void\nflatpak_context_shared_to_args (FlatpakContextShares shares,\n                                FlatpakContextShares valid,\n                                GPtrArray           *args)\n{\n  return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, \"--share\", \"--unshare\", args);\n}\n\nstatic FlatpakPolicy\nflatpak_policy_from_string (const char *string, GError **error)\n{\n  const char *policies[] = { \"none\", \"see\", \"talk\", \"own\", NULL };\n  int i;\n  g_autofree char *values = NULL;\n\n  for (i = 0; policies[i]; i++)\n    {\n      if (strcmp (string, policies[i]) == 0)\n        return i;\n    }\n\n  values = g_strjoinv (\", \", (char **) policies);\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Unknown policy type %s, valid types are: %s\"), string, values);\n\n  return -1;\n}\n\nstatic const char *\nflatpak_policy_to_string (FlatpakPolicy policy)\n{\n  if (policy == FLATPAK_POLICY_SEE)\n    return \"see\";\n  if (policy == FLATPAK_POLICY_TALK)\n    return \"talk\";\n  if (policy == FLATPAK_POLICY_OWN)\n    return \"own\";\n\n  return \"none\";\n}\n\nstatic gboolean\nflatpak_verify_dbus_name (const char *name, GError **error)\n{\n  const char *name_part;\n  g_autofree char *tmp = NULL;\n\n  if (g_str_has_suffix (name, \".*\"))\n    {\n      tmp = g_strndup (name, strlen (name) - 2);\n      name_part = tmp;\n    }\n  else\n    {\n      name_part = name;\n    }\n\n  if (g_dbus_is_name (name_part) && !g_dbus_is_unique_name (name_part))\n    return TRUE;\n\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Invalid dbus name %s\"), name);\n  return FALSE;\n}\n\nstatic FlatpakContextSockets\nflatpak_context_socket_from_string (const char *string, GError **error)\n{\n  FlatpakContextSockets sockets = flatpak_context_bitmask_from_string (string, flatpak_context_sockets);\n\n  if (sockets == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_sockets);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown socket type %s, valid types are: %s\"), string, values);\n    }\n\n  return sockets;\n}\n\nstatic char **\nflatpak_context_sockets_to_string (FlatpakContextSockets sockets, FlatpakContextSockets valid)\n{\n  return flatpak_context_bitmask_to_string (sockets, valid, flatpak_context_sockets);\n}\n\nstatic void\nflatpak_context_sockets_to_args (FlatpakContextSockets sockets,\n                                 FlatpakContextSockets valid,\n                                 GPtrArray            *args)\n{\n  return flatpak_context_bitmask_to_args (sockets, valid, flatpak_context_sockets, \"--socket\", \"--nosocket\", args);\n}\n\nstatic FlatpakContextDevices\nflatpak_context_device_from_string (const char *string, GError **error)\n{\n  FlatpakContextDevices devices = flatpak_context_bitmask_from_string (string, flatpak_context_devices);\n\n  if (devices == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_devices);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown device type %s, valid types are: %s\"), string, values);\n    }\n  return devices;\n}\n\nstatic char **\nflatpak_context_devices_to_string (FlatpakContextDevices devices, FlatpakContextDevices valid)\n{\n  return flatpak_context_bitmask_to_string (devices, valid, flatpak_context_devices);\n}\n\nstatic void\nflatpak_context_devices_to_args (FlatpakContextDevices devices,\n                                 FlatpakContextDevices valid,\n                                 GPtrArray            *args)\n{\n  return flatpak_context_bitmask_to_args (devices, valid, flatpak_context_devices, \"--device\", \"--nodevice\", args);\n}\n\nstatic FlatpakContextFeatures\nflatpak_context_feature_from_string (const char *string, GError **error)\n{\n  FlatpakContextFeatures feature = flatpak_context_bitmask_from_string (string, flatpak_context_features);\n\n  if (feature == 0)\n    {\n      g_autofree char *values = g_strjoinv (\", \", (char **) flatpak_context_features);\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Unknown feature type %s, valid types are: %s\"), string, values);\n    }\n\n  return feature;\n}\n\nstatic char **\nflatpak_context_features_to_string (FlatpakContextFeatures features, FlatpakContextFeatures valid)\n{\n  return flatpak_context_bitmask_to_string (features, valid, flatpak_context_features);\n}\n\nstatic void\nflatpak_context_features_to_args (FlatpakContextFeatures features,\n                                  FlatpakContextFeatures valid,\n                                  GPtrArray             *args)\n{\n  return flatpak_context_bitmask_to_args (features, valid, flatpak_context_features, \"--allow\", \"--disallow\", args);\n}\n\nstatic void\nflatpak_context_add_shares (FlatpakContext      *context,\n                            FlatpakContextShares shares)\n{\n  context->shares_valid |= shares;\n  context->shares |= shares;\n}\n\nstatic void\nflatpak_context_remove_shares (FlatpakContext      *context,\n                               FlatpakContextShares shares)\n{\n  context->shares_valid |= shares;\n  context->shares &= ~shares;\n}\n\nstatic void\nflatpak_context_add_sockets (FlatpakContext       *context,\n                             FlatpakContextSockets sockets)\n{\n  context->sockets_valid |= sockets;\n  context->sockets |= sockets;\n}\n\nstatic void\nflatpak_context_remove_sockets (FlatpakContext       *context,\n                                FlatpakContextSockets sockets)\n{\n  context->sockets_valid |= sockets;\n  context->sockets &= ~sockets;\n}\n\nstatic void\nflatpak_context_add_devices (FlatpakContext       *context,\n                             FlatpakContextDevices devices)\n{\n  context->devices_valid |= devices;\n  context->devices |= devices;\n}\n\nstatic void\nflatpak_context_remove_devices (FlatpakContext       *context,\n                                FlatpakContextDevices devices)\n{\n  context->devices_valid |= devices;\n  context->devices &= ~devices;\n}\n\nstatic void\nflatpak_context_add_features (FlatpakContext        *context,\n                              FlatpakContextFeatures features)\n{\n  context->features_valid |= features;\n  context->features |= features;\n}\n\nstatic void\nflatpak_context_remove_features (FlatpakContext        *context,\n                                 FlatpakContextFeatures features)\n{\n  context->features_valid |= features;\n  context->features &= ~features;\n}\n\nstatic void\nflatpak_context_set_env_var (FlatpakContext *context,\n                             const char     *name,\n                             const char     *value)\n{\n  g_hash_table_insert (context->env_vars, g_strdup (name), g_strdup (value));\n}\n\nvoid\nflatpak_context_set_session_bus_policy (FlatpakContext *context,\n                                        const char     *name,\n                                        FlatpakPolicy   policy)\n{\n  g_hash_table_insert (context->session_bus_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n\nGStrv\nflatpak_context_get_session_bus_policy_allowed_own_names (FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  g_autoptr(GPtrArray) names = g_ptr_array_new_with_free_func (g_free);\n\n  g_hash_table_iter_init (&iter, context->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    if (GPOINTER_TO_INT (value) == FLATPAK_POLICY_OWN)\n      g_ptr_array_add (names, g_strdup (key));\n\n  g_ptr_array_add (names, NULL);\n  return (GStrv) g_ptr_array_free (g_steal_pointer (&names), FALSE);\n}\n\nvoid\nflatpak_context_set_system_bus_policy (FlatpakContext *context,\n                                       const char     *name,\n                                       FlatpakPolicy   policy)\n{\n  g_hash_table_insert (context->system_bus_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n\nstatic void\nflatpak_context_apply_generic_policy (FlatpakContext *context,\n                                      const char     *key,\n                                      const char     *value)\n{\n  GPtrArray *new = g_ptr_array_new ();\n  const char **old_v;\n  int i;\n\n  g_assert (strchr (key, '.') != NULL);\n\n  old_v = g_hash_table_lookup (context->generic_policy, key);\n  for (i = 0; old_v != NULL && old_v[i] != NULL; i++)\n    {\n      const char *old = old_v[i];\n      const char *cmp1 = old;\n      const char *cmp2 = value;\n      if (*cmp1 == '!')\n        cmp1++;\n      if (*cmp2 == '!')\n        cmp2++;\n      if (strcmp (cmp1, cmp2) != 0)\n        g_ptr_array_add (new, g_strdup (old));\n    }\n\n  g_ptr_array_add (new, g_strdup (value));\n  g_ptr_array_add (new, NULL);\n\n  g_hash_table_insert (context->generic_policy, g_strdup (key),\n                       g_ptr_array_free (new, FALSE));\n}\n\nstatic void\nflatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}\n\nstatic gboolean\nget_xdg_dir_from_prefix (const char  *prefix,\n                         const char **where,\n                         const char **dir)\n{\n  if (strcmp (prefix, \"xdg-data\") == 0)\n    {\n      if (where)\n        *where = \"data\";\n      if (dir)\n        *dir = g_get_user_data_dir ();\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-cache\") == 0)\n    {\n      if (where)\n        *where = \"cache\";\n      if (dir)\n        *dir = g_get_user_cache_dir ();\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-config\") == 0)\n    {\n      if (where)\n        *where = \"config\";\n      if (dir)\n        *dir = g_get_user_config_dir ();\n      return TRUE;\n    }\n  return FALSE;\n}\n\n/* This looks only in the xdg dirs (config, cache, data), not the user\n   definable ones */\nstatic char *\nget_xdg_dir_from_string (const char  *filesystem,\n                         const char **suffix,\n                         const char **where)\n{\n  char *slash;\n  const char *rest;\n  g_autofree char *prefix = NULL;\n  const char *dir = NULL;\n  gsize len;\n\n  slash = strchr (filesystem, '/');\n\n  if (slash)\n    len = slash - filesystem;\n  else\n    len = strlen (filesystem);\n\n  rest = filesystem + len;\n  while (*rest == '/')\n    rest++;\n\n  if (suffix != NULL)\n    *suffix = rest;\n\n  prefix = g_strndup (filesystem, len);\n\n  if (get_xdg_dir_from_prefix (prefix, where, &dir))\n    return g_build_filename (dir, rest, NULL);\n\n  return NULL;\n}\n\nstatic gboolean\nget_xdg_user_dir_from_string (const char  *filesystem,\n                              const char **config_key,\n                              const char **suffix,\n                              const char **dir)\n{\n  char *slash;\n  const char *rest;\n  g_autofree char *prefix = NULL;\n  gsize len;\n\n  slash = strchr (filesystem, '/');\n\n  if (slash)\n    len = slash - filesystem;\n  else\n    len = strlen (filesystem);\n\n  rest = filesystem + len;\n  while (*rest == '/')\n    rest++;\n\n  if (suffix)\n    *suffix = rest;\n\n  prefix = g_strndup (filesystem, len);\n\n  if (strcmp (prefix, \"xdg-desktop\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_DESKTOP_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_DESKTOP);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-documents\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_DOCUMENTS_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_DOCUMENTS);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-download\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_DOWNLOAD_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_DOWNLOAD);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-music\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_MUSIC_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_MUSIC);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-pictures\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_PICTURES_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_PICTURES);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-public-share\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_PUBLICSHARE_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_PUBLIC_SHARE);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-templates\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_TEMPLATES_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_TEMPLATES);\n      return TRUE;\n    }\n  if (strcmp (prefix, \"xdg-videos\") == 0)\n    {\n      if (config_key)\n        *config_key = \"XDG_VIDEOS_DIR\";\n      if (dir)\n        *dir = g_get_user_special_dir (G_USER_DIRECTORY_VIDEOS);\n      return TRUE;\n    }\n  if (get_xdg_dir_from_prefix (prefix, NULL, dir))\n    {\n      if (config_key)\n        *config_key = NULL;\n      return TRUE;\n    }\n  /* Don't support xdg-run without suffix, because that doesn't work */\n  if (strcmp (prefix, \"xdg-run\") == 0 &&\n      *rest != 0)\n    {\n      if (config_key)\n        *config_key = NULL;\n      if (dir)\n        *dir = flatpak_get_real_xdg_runtime_dir ();\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic char *\nunparse_filesystem_flags (const char           *path,\n                          FlatpakFilesystemMode mode)\n{\n  g_autoptr(GString) s = g_string_new (\"\");\n  const char *p;\n\n  for (p = path; *p != 0; p++)\n    {\n      if (*p == ':')\n        g_string_append (s, \"\\\\:\");\n      else if (*p == '\\\\')\n        g_string_append (s, \"\\\\\\\\\");\n      else\n        g_string_append_c (s, *p);\n    }\n\n  switch (mode)\n    {\n    case FLATPAK_FILESYSTEM_MODE_READ_ONLY:\n      g_string_append (s, \":ro\");\n      break;\n\n    case FLATPAK_FILESYSTEM_MODE_CREATE:\n      g_string_append (s, \":create\");\n      break;\n\n    case FLATPAK_FILESYSTEM_MODE_READ_WRITE:\n      break;\n\n    case FLATPAK_FILESYSTEM_MODE_NONE:\n      g_string_insert_c (s, 0, '!');\n      break;\n\n    default:\n      g_warning (\"Unexpected filesystem mode %d\", mode);\n      break;\n    }\n\n  return g_string_free (g_steal_pointer (&s), FALSE);\n}\n\nstatic char *\nparse_filesystem_flags (const char            *filesystem,\n                        FlatpakFilesystemMode *mode_out)\n{\n  g_autoptr(GString) s = g_string_new (\"\");\n  const char *p, *suffix;\n  FlatpakFilesystemMode mode;\n\n  p = filesystem;\n  while (*p != 0 && *p != ':')\n    {\n      if (*p == '\\\\')\n        {\n          p++;\n          if (*p != 0)\n            g_string_append_c (s, *p++);\n        }\n      else\n        g_string_append_c (s, *p++);\n    }\n\n  mode = FLATPAK_FILESYSTEM_MODE_READ_WRITE;\n\n  if (*p == ':')\n    {\n      suffix = p + 1;\n\n      if (strcmp (suffix, \"ro\") == 0)\n        mode = FLATPAK_FILESYSTEM_MODE_READ_ONLY;\n      else if (strcmp (suffix, \"rw\") == 0)\n        mode = FLATPAK_FILESYSTEM_MODE_READ_WRITE;\n      else if (strcmp (suffix, \"create\") == 0)\n        mode = FLATPAK_FILESYSTEM_MODE_CREATE;\n      else if (*suffix != 0)\n        g_warning (\"Unexpected filesystem suffix %s, ignoring\", suffix);\n    }\n\n  if (mode_out)\n    *mode_out = mode;\n\n  return g_string_free (g_steal_pointer (&s), FALSE);\n}\n\ngboolean\nflatpak_context_parse_filesystem (const char             *filesystem_and_mode,\n                                  char                  **filesystem_out,\n                                  FlatpakFilesystemMode  *mode_out,\n                                  GError                **error)\n{\n  g_autofree char *filesystem = parse_filesystem_flags (filesystem_and_mode, mode_out);\n  char *slash;\n\n  slash = strchr (filesystem, '/');\n\n  /* Forbid /../ in paths */\n  if (slash != NULL)\n    {\n      if (g_str_has_prefix (slash + 1, \"../\") ||\n          g_str_has_suffix (slash + 1, \"/..\") ||\n          strstr (slash + 1, \"/../\") != NULL)\n        {\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"Filesystem location \\\"%s\\\" contains \\\"..\\\"\"),\n                       filesystem);\n          return FALSE;\n        }\n\n      /* Convert \"//\" and \"/./\" to \"/\" */\n      for (; slash != NULL; slash = strchr (slash + 1, '/'))\n        {\n          while (TRUE)\n            {\n              if (slash[1] == '/')\n                memmove (slash + 1, slash + 2, strlen (slash + 2) + 1);\n              else if (slash[1] == '.' && slash[2] == '/')\n                memmove (slash + 1, slash + 3, strlen (slash + 3) + 1);\n              else\n                break;\n            }\n        }\n\n      /* Eliminate trailing \"/.\" or \"/\". */\n      while (TRUE)\n        {\n          slash = strrchr (filesystem, '/');\n\n          if (slash != NULL &&\n              ((slash != filesystem && slash[1] == '\\0') ||\n               (slash[1] == '.' && slash[2] == '\\0')))\n            *slash = '\\0';\n          else\n            break;\n        }\n\n      if (filesystem[0] == '/' && filesystem[1] == '\\0')\n        {\n          /* We don't allow --filesystem=/ as equivalent to host, because\n           * it doesn't do what you'd think: --filesystem=host mounts some\n           * host directories in /run/host, not in the root. */\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"--filesystem=/ is not available, \"\n                         \"use --filesystem=host for a similar result\"));\n          return FALSE;\n        }\n    }\n\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      get_xdg_user_dir_from_string (filesystem, NULL, NULL, NULL) ||\n      g_str_has_prefix (filesystem, \"~/\") ||\n      g_str_has_prefix (filesystem, \"/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_steal_pointer (&filesystem);\n\n      return TRUE;\n    }\n\n  if (strcmp (filesystem, \"~\") == 0)\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strdup (\"home\");\n\n      return TRUE;\n    }\n\n  if (g_str_has_prefix (filesystem, \"home/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strconcat (\"~/\", filesystem + 5, NULL);\n\n      return TRUE;\n    }\n\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/\u2026], ~/dir, /dir\"), filesystem);\n  return FALSE;\n}\n\n/* Note: This only works with valid keys, i.e. they passed flatpak_context_parse_filesystem */\nstatic gboolean\nflatpak_filesystem_key_in_home (const char *filesystem)\n{\n  /* \"home\" is definitely in home */\n  if (strcmp (filesystem, \"home\") == 0)\n    return TRUE;\n\n  /* All the other special fs:es are non-home.\n   * Note: This considers absolute paths that are in the homedir as non-home.\n   */\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      g_str_has_prefix (filesystem, \"/\"))\n    return FALSE;\n\n  /* Files in xdg-run are not in home */\n  if (g_str_has_prefix (filesystem, \"xdg-run\"))\n    return FALSE;\n\n  /* All remaining keys (~/, xdg-data, etc) are considered in home,\n   * Note: technically $XDG_HOME_DATA could point outside the homedir, but we ignore that.\n   */\n  return TRUE;\n}\n\nstatic void\nflatpak_context_take_filesystem (FlatpakContext        *context,\n                                 char                  *fs,\n                                 FlatpakFilesystemMode  mode)\n{\n  g_hash_table_insert (context->filesystems, fs, GINT_TO_POINTER (mode));\n}\n\nvoid\nflatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  gboolean no_home = FALSE;\n  gboolean no_host = FALSE;\n\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n\n  /* We first handle all negative home and host as they override other\n     keys than themselves from the parent */\n  if (g_hash_table_lookup_extended (other->filesystems,\n                                    \"host\",\n                                    NULL, &value))\n    {\n      FlatpakFilesystemMode host_mode = GPOINTER_TO_INT (value);\n      if (host_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n        no_host = TRUE;\n    }\n\n  if (g_hash_table_lookup_extended (other->filesystems,\n                                    \"home\",\n                                    NULL, &value))\n    {\n      FlatpakFilesystemMode home_mode = GPOINTER_TO_INT (value);\n      if (home_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n        no_home = TRUE;\n    }\n\n  if (no_host)\n    {\n      g_hash_table_remove_all (context->filesystems);\n    }\n  else if (no_home)\n    {\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          if (flatpak_filesystem_key_in_home ((const char *)key))\n            g_hash_table_iter_remove (&iter);\n        }\n    }\n\n  /* Then set the new ones, which includes propagating the nohost and nohome ones. */\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}\n\nstatic gboolean\noption_share_cb (const gchar *option_name,\n                 const gchar *value,\n                 gpointer     data,\n                 GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextShares share;\n\n  share = flatpak_context_share_from_string (value, error);\n  if (share == 0)\n    return FALSE;\n\n  flatpak_context_add_shares (context, share);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_unshare_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextShares share;\n\n  share = flatpak_context_share_from_string (value, error);\n  if (share == 0)\n    return FALSE;\n\n  flatpak_context_remove_shares (context, share);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_socket_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextSockets socket;\n\n  socket = flatpak_context_socket_from_string (value, error);\n  if (socket == 0)\n    return FALSE;\n\n  if (socket == FLATPAK_CONTEXT_SOCKET_FALLBACK_X11)\n    socket |= FLATPAK_CONTEXT_SOCKET_X11;\n\n  flatpak_context_add_sockets (context, socket);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_nosocket_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextSockets socket;\n\n  socket = flatpak_context_socket_from_string (value, error);\n  if (socket == 0)\n    return FALSE;\n\n  if (socket == FLATPAK_CONTEXT_SOCKET_FALLBACK_X11)\n    socket |= FLATPAK_CONTEXT_SOCKET_X11;\n\n  flatpak_context_remove_sockets (context, socket);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_device_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextDevices device;\n\n  device = flatpak_context_device_from_string (value, error);\n  if (device == 0)\n    return FALSE;\n\n  flatpak_context_add_devices (context, device);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_nodevice_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextDevices device;\n\n  device = flatpak_context_device_from_string (value, error);\n  if (device == 0)\n    return FALSE;\n\n  flatpak_context_remove_devices (context, device);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_allow_cb (const gchar *option_name,\n                 const gchar *value,\n                 gpointer     data,\n                 GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextFeatures feature;\n\n  feature = flatpak_context_feature_from_string (value, error);\n  if (feature == 0)\n    return FALSE;\n\n  flatpak_context_add_features (context, feature);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_disallow_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n  FlatpakContextFeatures feature;\n\n  feature = flatpak_context_feature_from_string (value, error);\n  if (feature == 0)\n    return FALSE;\n\n  flatpak_context_remove_features (context, feature);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_filesystem_cb (const gchar *option_name,\n                      const gchar *value,\n                      gpointer     data,\n                      GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autofree char *fs = NULL;\n  FlatpakFilesystemMode mode;\n\n  if (!flatpak_context_parse_filesystem (value, &fs, &mode, error))\n    return FALSE;\n\n  flatpak_context_take_filesystem (context, g_steal_pointer (&fs), mode);\n  return TRUE;\n}\n\nstatic gboolean\noption_nofilesystem_cb (const gchar *option_name,\n                        const gchar *value,\n                        gpointer     data,\n                        GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autofree char *fs = NULL;\n  FlatpakFilesystemMode mode;\n\n  if (!flatpak_context_parse_filesystem (value, &fs, &mode, error))\n    return FALSE;\n\n  flatpak_context_take_filesystem (context, g_steal_pointer (&fs),\n                                   FLATPAK_FILESYSTEM_MODE_NONE);\n  return TRUE;\n}\n\nstatic gboolean\noption_env_cb (const gchar *option_name,\n               const gchar *value,\n               gpointer     data,\n               GError     **error)\n{\n  FlatpakContext *context = data;\n  g_auto(GStrv) split = g_strsplit (value, \"=\", 2);\n\n  if (split == NULL || split[0] == NULL || split[0][0] == 0 || split[1] == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Invalid env format %s\"), value);\n      return FALSE;\n    }\n\n  flatpak_context_set_env_var (context, split[0], split[1]);\n  return TRUE;\n}\n\ngboolean\nflatpak_context_parse_env_block (FlatpakContext *context,\n                                 const char *data,\n                                 gsize length,\n                                 GError **error)\n{\n  const char *p = data;\n  gsize remaining = length;\n\n  /* env_block might not be \\0-terminated */\n  while (remaining > 0)\n    {\n      size_t len = strnlen (p, remaining);\n      const char *equals;\n      g_autofree char *env_var = NULL;\n      g_autofree char *env_value = NULL;\n\n      g_assert (len <= remaining);\n\n      equals = memchr (p, '=', len);\n\n      if (equals == NULL || equals == p)\n        return glnx_throw (error,\n                           \"Environment variable must be given in the form VARIABLE=VALUE, not %.*s\", (int) len, p);\n\n      env_var = g_strndup (p, equals - p);\n      env_value = g_strndup (equals + 1, len - (equals - p) - 1);\n      flatpak_context_set_env_var (context, env_var, env_value);\n      p += len;\n      remaining -= len;\n\n      if (remaining > 0)\n        {\n          g_assert (*p == '\\0');\n          p += 1;\n          remaining -= 1;\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_context_parse_env_fd (FlatpakContext *context,\n                              int fd,\n                              GError **error)\n{\n  g_autoptr(GBytes) env_block = NULL;\n  const char *data;\n  gsize len;\n\n  env_block = glnx_fd_readall_bytes (fd, NULL, error);\n\n  if (env_block == NULL)\n    return FALSE;\n\n  data = g_bytes_get_data (env_block, &len);\n  return flatpak_context_parse_env_block (context, data, len, error);\n}\n\nstatic gboolean\noption_env_fd_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  guint64 fd;\n  gchar *endptr;\n  gboolean ret;\n\n  fd = g_ascii_strtoull (value, &endptr, 10);\n\n  if (endptr == NULL || *endptr != '\\0' || fd > G_MAXINT)\n    return glnx_throw (error, \"Not a valid file descriptor: %s\", value);\n\n  ret = flatpak_context_parse_env_fd (context, (int) fd, error);\n\n  if (fd >= 3)\n    close (fd);\n\n  return ret;\n}\n\nstatic gboolean\noption_unset_env_cb (const gchar *option_name,\n                     const gchar *value,\n                     gpointer     data,\n                     GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (strchr (value, '=') != NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n                   _(\"Environment variable name must not contain '=': %s\"), value);\n      return FALSE;\n    }\n\n  flatpak_context_set_env_var (context, value, NULL);\n  return TRUE;\n}\n\nstatic gboolean\noption_own_name_cb (const gchar *option_name,\n                    const gchar *value,\n                    gpointer     data,\n                    GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_session_bus_policy (context, value, FLATPAK_POLICY_OWN);\n  return TRUE;\n}\n\nstatic gboolean\noption_talk_name_cb (const gchar *option_name,\n                     const gchar *value,\n                     gpointer     data,\n                     GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_session_bus_policy (context, value, FLATPAK_POLICY_TALK);\n  return TRUE;\n}\n\nstatic gboolean\noption_no_talk_name_cb (const gchar *option_name,\n                        const gchar *value,\n                        gpointer     data,\n                        GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_session_bus_policy (context, value, FLATPAK_POLICY_NONE);\n  return TRUE;\n}\n\nstatic gboolean\noption_system_own_name_cb (const gchar *option_name,\n                           const gchar *value,\n                           gpointer     data,\n                           GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_system_bus_policy (context, value, FLATPAK_POLICY_OWN);\n  return TRUE;\n}\n\nstatic gboolean\noption_system_talk_name_cb (const gchar *option_name,\n                            const gchar *value,\n                            gpointer     data,\n                            GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_system_bus_policy (context, value, FLATPAK_POLICY_TALK);\n  return TRUE;\n}\n\nstatic gboolean\noption_system_no_talk_name_cb (const gchar *option_name,\n                               const gchar *value,\n                               gpointer     data,\n                               GError     **error)\n{\n  FlatpakContext *context = data;\n\n  if (!flatpak_verify_dbus_name (value, error))\n    return FALSE;\n\n  flatpak_context_set_system_bus_policy (context, value, FLATPAK_POLICY_NONE);\n  return TRUE;\n}\n\nstatic gboolean\noption_add_generic_policy_cb (const gchar *option_name,\n                              const gchar *value,\n                              gpointer     data,\n                              GError     **error)\n{\n  FlatpakContext *context = data;\n  char *t;\n  g_autofree char *key = NULL;\n  const char *policy_value;\n\n  t = strchr (value, '=');\n  if (t == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--add-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n  policy_value = t + 1;\n  key = g_strndup (value, t - value);\n  if (strchr (key, '.') == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--add-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n\n  if (policy_value[0] == '!')\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--add-policy values can't start with \\\"!\\\"\"));\n      return FALSE;\n    }\n\n  flatpak_context_apply_generic_policy (context, key, policy_value);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_remove_generic_policy_cb (const gchar *option_name,\n                                 const gchar *value,\n                                 gpointer     data,\n                                 GError     **error)\n{\n  FlatpakContext *context = data;\n  char *t;\n  g_autofree char *key = NULL;\n  const char *policy_value;\n  g_autofree char *extended_value = NULL;\n\n  t = strchr (value, '=');\n  if (t == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--remove-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n  policy_value = t + 1;\n  key = g_strndup (value, t - value);\n  if (strchr (key, '.') == NULL)\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--remove-policy arguments must be in the form SUBSYSTEM.KEY=VALUE\"));\n      return FALSE;\n    }\n\n  if (policy_value[0] == '!')\n    {\n      g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                   _(\"--remove-policy values can't start with \\\"!\\\"\"));\n      return FALSE;\n    }\n\n  extended_value = g_strconcat (\"!\", policy_value, NULL);\n\n  flatpak_context_apply_generic_policy (context, key, extended_value);\n\n  return TRUE;\n}\n\nstatic gboolean\noption_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}\n\nstatic gboolean option_no_desktop_deprecated;\n\nstatic GOptionEntry context_options[] = {\n  { \"share\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_share_cb, N_(\"Share with host\"), N_(\"SHARE\") },\n  { \"unshare\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_unshare_cb, N_(\"Unshare with host\"), N_(\"SHARE\") },\n  { \"socket\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_socket_cb, N_(\"Expose socket to app\"), N_(\"SOCKET\") },\n  { \"nosocket\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_nosocket_cb, N_(\"Don't expose socket to app\"), N_(\"SOCKET\") },\n  { \"device\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_device_cb, N_(\"Expose device to app\"), N_(\"DEVICE\") },\n  { \"nodevice\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_nodevice_cb, N_(\"Don't expose device to app\"), N_(\"DEVICE\") },\n  { \"allow\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_allow_cb, N_(\"Allow feature\"), N_(\"FEATURE\") },\n  { \"disallow\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_disallow_cb, N_(\"Don't allow feature\"), N_(\"FEATURE\") },\n  { \"filesystem\", 0, G_OPTION_FLAG_IN_MAIN | G_OPTION_FLAG_FILENAME, G_OPTION_ARG_CALLBACK, &option_filesystem_cb, N_(\"Expose filesystem to app (:ro for read-only)\"), N_(\"FILESYSTEM[:ro]\") },\n  { \"nofilesystem\", 0, G_OPTION_FLAG_IN_MAIN | G_OPTION_FLAG_FILENAME, G_OPTION_ARG_CALLBACK, &option_nofilesystem_cb, N_(\"Don't expose filesystem to app\"), N_(\"FILESYSTEM\") },\n  { \"env\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_env_cb, N_(\"Set environment variable\"), N_(\"VAR=VALUE\") },\n  { \"env-fd\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_env_fd_cb, N_(\"Read environment variables in env -0 format from FD\"), N_(\"FD\") },\n  { \"unset-env\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_unset_env_cb, N_(\"Remove variable from environment\"), N_(\"VAR\") },\n  { \"own-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_own_name_cb, N_(\"Allow app to own name on the session bus\"), N_(\"DBUS_NAME\") },\n  { \"talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_talk_name_cb, N_(\"Allow app to talk to name on the session bus\"), N_(\"DBUS_NAME\") },\n  { \"no-talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_no_talk_name_cb, N_(\"Don't allow app to talk to name on the session bus\"), N_(\"DBUS_NAME\") },\n  { \"system-own-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_system_own_name_cb, N_(\"Allow app to own name on the system bus\"), N_(\"DBUS_NAME\") },\n  { \"system-talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_system_talk_name_cb, N_(\"Allow app to talk to name on the system bus\"), N_(\"DBUS_NAME\") },\n  { \"system-no-talk-name\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_system_no_talk_name_cb, N_(\"Don't allow app to talk to name on the system bus\"), N_(\"DBUS_NAME\") },\n  { \"add-policy\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_add_generic_policy_cb, N_(\"Add generic policy option\"), N_(\"SUBSYSTEM.KEY=VALUE\") },\n  { \"remove-policy\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_remove_generic_policy_cb, N_(\"Remove generic policy option\"), N_(\"SUBSYSTEM.KEY=VALUE\") },\n  { \"persist\", 0, G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_CALLBACK, &option_persist_cb, N_(\"Persist home directory subpath\"), N_(\"FILENAME\") },\n  /* This is not needed/used anymore, so hidden, but we accept it for backwards compat */\n  { \"no-desktop\", 0, G_OPTION_FLAG_IN_MAIN |  G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, &option_no_desktop_deprecated, N_(\"Don't require a running session (no cgroups creation)\"), NULL },\n  { NULL }\n};\n\nGOptionEntry *\nflatpak_context_get_option_entries (void)\n{\n  return context_options;\n}\n\nGOptionGroup  *\nflatpak_context_get_options (FlatpakContext *context)\n{\n  GOptionGroup *group;\n\n  group = g_option_group_new (\"environment\",\n                              \"Runtime Environment\",\n                              \"Runtime Environment\",\n                              context,\n                              NULL);\n  g_option_group_set_translation_domain (group, GETTEXT_PACKAGE);\n\n  g_option_group_add_entries (group, context_options);\n\n  return group;\n}\n\nstatic const char *\nparse_negated (const char *option, gboolean *negated)\n{\n  if (option[0] == '!')\n    {\n      option++;\n      *negated = TRUE;\n    }\n  else\n    {\n      *negated = FALSE;\n    }\n  return option;\n}\n\n/*\n * Merge the FLATPAK_METADATA_GROUP_CONTEXT,\n * FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY,\n * FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY and\n * FLATPAK_METADATA_GROUP_ENVIRONMENT groups, and all groups starting\n * with FLATPAK_METADATA_GROUP_PREFIX_POLICY, from metakey into context.\n *\n * This is a merge, not a replace!\n */\ngboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_debug (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_debug (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_debug (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_debug (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, &filesystem, &mode, NULL))\n            g_debug (\"Unknown filesystem type %s\", filesystems[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem),\n                                                 FLATPAK_FILESYSTEM_MODE_NONE);\n              else\n                flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        flatpak_context_set_persistent (context, persistent[i]);\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}\n\n/*\n * Save the FLATPAK_METADATA_GROUP_CONTEXT,\n * FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY,\n * FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY and\n * FLATPAK_METADATA_GROUP_ENVIRONMENT groups, and all groups starting\n * with FLATPAK_METADATA_GROUP_PREFIX_POLICY, into metakey\n */\nvoid\nflatpak_context_save_metadata (FlatpakContext *context,\n                               gboolean        flatten,\n                               GKeyFile       *metakey)\n{\n  g_auto(GStrv) shared = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) features = NULL;\n  g_autoptr(GPtrArray) unset_env = NULL;\n  GHashTableIter iter;\n  gpointer key, value;\n  FlatpakContextShares shares_mask = context->shares;\n  FlatpakContextShares shares_valid = context->shares_valid;\n  FlatpakContextSockets sockets_mask = context->sockets;\n  FlatpakContextSockets sockets_valid = context->sockets_valid;\n  FlatpakContextDevices devices_mask = context->devices;\n  FlatpakContextDevices devices_valid = context->devices_valid;\n  FlatpakContextFeatures features_mask = context->features;\n  FlatpakContextFeatures features_valid = context->features_valid;\n  g_auto(GStrv) groups = NULL;\n  int i;\n\n  if (flatten)\n    {\n      /* A flattened format means we don't expect this to be merged on top of\n         another context. In that case we never need to negate any flags.\n         We calculate this by removing the zero parts of the mask from the valid set.\n       */\n      /* First we make sure only the valid parts of the mask are set, in case we\n         got some leftover */\n      shares_mask &= shares_valid;\n      sockets_mask &= sockets_valid;\n      devices_mask &= devices_valid;\n      features_mask &= features_valid;\n\n      /* Then just set the valid set to be the mask set */\n      shares_valid = shares_mask;\n      sockets_valid = sockets_mask;\n      devices_valid = devices_mask;\n      features_valid = features_mask;\n    }\n\n  shared = flatpak_context_shared_to_string (shares_mask, shares_valid);\n  sockets = flatpak_context_sockets_to_string (sockets_mask, sockets_valid);\n  devices = flatpak_context_devices_to_string (devices_mask, devices_valid);\n  features = flatpak_context_features_to_string (features_mask, features_valid);\n\n  if (shared[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_SHARED,\n                                  (const char * const *) shared, g_strv_length (shared));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_SHARED,\n                             NULL);\n    }\n\n  if (sockets[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_SOCKETS,\n                                  (const char * const *) sockets, g_strv_length (sockets));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_SOCKETS,\n                             NULL);\n    }\n\n  if (devices[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_DEVICES,\n                                  (const char * const *) devices, g_strv_length (devices));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_DEVICES,\n                             NULL);\n    }\n\n  if (features[0] != NULL)\n    {\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_FEATURES,\n                                  (const char * const *) features, g_strv_length (features));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_FEATURES,\n                             NULL);\n    }\n\n  if (g_hash_table_size (context->filesystems) > 0)\n    {\n      g_autoptr(GPtrArray) array = g_ptr_array_new_with_free_func (g_free);\n\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n\n          g_ptr_array_add (array, unparse_filesystem_flags (key, mode));\n        }\n\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_FILESYSTEMS,\n                                  (const char * const *) array->pdata, array->len);\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_FILESYSTEMS,\n                             NULL);\n    }\n\n  if (g_hash_table_size (context->persistent) > 0)\n    {\n      g_autofree char **keys = (char **) g_hash_table_get_keys_as_array (context->persistent, NULL);\n\n      g_key_file_set_string_list (metakey,\n                                  FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_PERSISTENT,\n                                  (const char * const *) keys, g_strv_length (keys));\n    }\n  else\n    {\n      g_key_file_remove_key (metakey,\n                             FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_PERSISTENT,\n                             NULL);\n    }\n\n  g_key_file_remove_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, NULL);\n  g_hash_table_iter_init (&iter, context->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      if (flatten && (policy == 0))\n        continue;\n\n      g_key_file_set_string (metakey,\n                             FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY,\n                             (char *) key, flatpak_policy_to_string (policy));\n    }\n\n  g_key_file_remove_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, NULL);\n  g_hash_table_iter_init (&iter, context->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      if (flatten && (policy == 0))\n        continue;\n\n      g_key_file_set_string (metakey,\n                             FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY,\n                             (char *) key, flatpak_policy_to_string (policy));\n    }\n\n  /* Elements are borrowed from context->env_vars */\n  unset_env = g_ptr_array_new ();\n\n  g_key_file_remove_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, NULL);\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      if (value != NULL)\n        {\n          g_key_file_set_string (metakey,\n                                 FLATPAK_METADATA_GROUP_ENVIRONMENT,\n                                 (char *) key, (char *) value);\n        }\n      else\n        {\n          /* In older versions of Flatpak, [Environment] FOO=\n           * was interpreted as unsetting - so let's do both. */\n          g_key_file_set_string (metakey,\n                                 FLATPAK_METADATA_GROUP_ENVIRONMENT,\n                                 (char *) key, \"\");\n          g_ptr_array_add (unset_env, key);\n        }\n    }\n\n  if (unset_env->len > 0)\n    {\n      g_ptr_array_add (unset_env, NULL);\n      g_key_file_set_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                  FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                  (const char * const *) unset_env->pdata,\n                                  unset_env->len - 1);\n    }\n  else\n    {\n      g_key_file_remove_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                             FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL);\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        g_key_file_remove_group (metakey, group, NULL);\n    }\n\n  g_hash_table_iter_init (&iter, context->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      g_auto(GStrv) parts = g_strsplit ((const char *) key, \".\", 2);\n      g_autofree char *group = NULL;\n      g_assert (parts[1] != NULL);\n      const char **policy_values = (const char **) value;\n      g_autoptr(GPtrArray) new = g_ptr_array_new ();\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        {\n          const char *policy_value = policy_values[i];\n\n          if (!flatten || policy_value[0] != '!')\n            g_ptr_array_add (new, (char *) policy_value);\n        }\n\n      if (new->len > 0)\n        {\n          group = g_strconcat (FLATPAK_METADATA_GROUP_PREFIX_POLICY,\n                               parts[0], NULL);\n          g_key_file_set_string_list (metakey, group, parts[1],\n                                      (const char * const *) new->pdata,\n                                      new->len);\n        }\n    }\n}\n\nvoid\nflatpak_context_allow_host_fs (FlatpakContext *context)\n{\n  flatpak_context_take_filesystem (context, g_strdup (\"host\"), FLATPAK_FILESYSTEM_MODE_READ_WRITE);\n}\n\ngboolean\nflatpak_context_get_needs_session_bus_proxy (FlatpakContext *context)\n{\n  return g_hash_table_size (context->session_bus_policy) > 0;\n}\n\ngboolean\nflatpak_context_get_needs_system_bus_proxy (FlatpakContext *context)\n{\n  return g_hash_table_size (context->system_bus_policy) > 0;\n}\n\nstatic gboolean\nadds_flags (guint32 old_flags, guint32 new_flags)\n{\n  return (new_flags & ~old_flags) != 0;\n}\n\nstatic gboolean\nadds_bus_policy (GHashTable *old, GHashTable *new)\n{\n  GLNX_HASH_TABLE_FOREACH_KV (new, const char *, name, gpointer, _new_policy)\n    {\n      int new_policy = GPOINTER_TO_INT (_new_policy);\n      int old_policy = GPOINTER_TO_INT (g_hash_table_lookup (old, name));\n      if (new_policy > old_policy)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nadds_generic_policy (GHashTable *old, GHashTable *new)\n{\n  GLNX_HASH_TABLE_FOREACH_KV (new, const char *, key, GPtrArray *, new_values)\n    {\n      GPtrArray *old_values = g_hash_table_lookup (old, key);\n      int i;\n\n      if (new_values == NULL || new_values->len == 0)\n        continue;\n\n      if (old_values == NULL || old_values->len == 0)\n        return TRUE;\n\n      for (i = 0; i < new_values->len; i++)\n        {\n          const char *new_value = g_ptr_array_index (new_values, i);\n\n          if (!flatpak_g_ptr_array_contains_string (old_values, new_value))\n            return TRUE;\n        }\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nadds_filesystem_access (GHashTable *old, GHashTable *new)\n{\n  FlatpakFilesystemMode old_host_mode = GPOINTER_TO_INT (g_hash_table_lookup (old, \"host\"));\n\n  GLNX_HASH_TABLE_FOREACH_KV (new, const char *, location, gpointer, _new_mode)\n    {\n      FlatpakFilesystemMode new_mode = GPOINTER_TO_INT (_new_mode);\n      FlatpakFilesystemMode old_mode = GPOINTER_TO_INT (g_hash_table_lookup (old, location));\n\n      /* Allow more limited access to the same thing */\n      if (new_mode <= old_mode)\n        continue;\n\n      /* Allow more limited access if we used to have access to everything */\n     if (new_mode <= old_host_mode)\n        continue;\n\n     /* For the remainder we have to be pessimistic, for instance even\n        if we have home access we can't allow adding access to ~/foo,\n        because foo might be a symlink outside home which didn't work\n        before but would work with an explicit access to that\n        particular file. */\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\n\ngboolean\nflatpak_context_adds_permissions (FlatpakContext *old,\n                                  FlatpakContext *new)\n{\n  /* We allow upgrade to multiarch, that is really not a huge problem.\n   * Similarly, having sensible semantics for /dev/shm is\n   * not a security concern. */\n  guint32 harmless_features = (FLATPAK_CONTEXT_FEATURE_MULTIARCH |\n                               FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM);\n  guint32 old_sockets;\n\n  if (adds_flags (old->shares & old->shares_valid,\n                  new->shares & new->shares_valid))\n    return TRUE;\n\n  old_sockets = old->sockets & old->sockets_valid;\n\n  /* If we used to allow X11, also allow new fallback X11,\n     as that is actually less permissions */\n  if (old_sockets & FLATPAK_CONTEXT_SOCKET_X11)\n    old_sockets |= FLATPAK_CONTEXT_SOCKET_FALLBACK_X11;\n\n  if (adds_flags (old_sockets,\n                  new->sockets & new->sockets_valid))\n    return TRUE;\n\n  if (adds_flags (old->devices & old->devices_valid,\n                  new->devices & new->devices_valid))\n    return TRUE;\n\n  if (adds_flags ((old->features & old->features_valid) | harmless_features,\n                  new->features & new->features_valid))\n    return TRUE;\n\n  if (adds_bus_policy (old->session_bus_policy, new->session_bus_policy))\n    return TRUE;\n\n  if (adds_bus_policy (old->system_bus_policy, new->system_bus_policy))\n    return TRUE;\n\n  if (adds_generic_policy (old->generic_policy, new->generic_policy))\n    return TRUE;\n\n  if (adds_filesystem_access (old->filesystems, new->filesystems))\n    return TRUE;\n\n  return FALSE;\n}\n\ngboolean\nflatpak_context_allows_features (FlatpakContext        *context,\n                                 FlatpakContextFeatures features)\n{\n  return (context->features & features) == features;\n}\n\nvoid\nflatpak_context_to_args (FlatpakContext *context,\n                         GPtrArray      *args)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  flatpak_context_shared_to_args (context->shares, context->shares_valid, args);\n  flatpak_context_sockets_to_args (context->sockets, context->sockets_valid, args);\n  flatpak_context_devices_to_args (context->devices, context->devices_valid, args);\n  flatpak_context_features_to_args (context->features, context->features_valid, args);\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      if (value != NULL)\n        g_ptr_array_add (args, g_strdup_printf (\"--env=%s=%s\", (char *) key, (char *) value));\n      else\n        g_ptr_array_add (args, g_strdup_printf (\"--unset-env=%s\", (char *) key));\n    }\n\n  g_hash_table_iter_init (&iter, context->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_ptr_array_add (args, g_strdup_printf (\"--persist=%s\", (char *) key));\n\n  g_hash_table_iter_init (&iter, context->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      g_ptr_array_add (args, g_strdup_printf (\"--%s-name=%s\", flatpak_policy_to_string (policy), name));\n    }\n\n  g_hash_table_iter_init (&iter, context->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      g_ptr_array_add (args, g_strdup_printf (\"--system-%s-name=%s\", flatpak_policy_to_string (policy), name));\n    }\n\n  g_hash_table_iter_init (&iter, context->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n\n      if (mode != FLATPAK_FILESYSTEM_MODE_NONE)\n        {\n          g_autofree char *fs = unparse_filesystem_flags (key, mode);\n          g_ptr_array_add (args, g_strdup_printf (\"--filesystem=%s\", fs));\n        }\n      else\n        g_ptr_array_add (args, g_strdup_printf (\"--nofilesystem=%s\", (char *) key));\n    }\n}\n\nvoid\nflatpak_context_add_bus_filters (FlatpakContext *context,\n                                 const char     *app_id,\n                                 gboolean        session_bus,\n                                 gboolean        sandboxed,\n                                 FlatpakBwrap   *bwrap)\n{\n  GHashTable *ht;\n  GHashTableIter iter;\n  gpointer key, value;\n\n  flatpak_bwrap_add_arg (bwrap, \"--filter\");\n  if (app_id && session_bus)\n    {\n      if (!sandboxed)\n        {\n          flatpak_bwrap_add_arg_printf (bwrap, \"--own=%s.*\", app_id);\n          flatpak_bwrap_add_arg_printf (bwrap, \"--own=org.mpris.MediaPlayer2.%s.*\", app_id);\n        }\n      else\n        flatpak_bwrap_add_arg_printf (bwrap, \"--own=%s.Sandboxed.*\", app_id);\n    }\n\n  if (session_bus)\n    ht = context->session_bus_policy;\n  else\n    ht = context->system_bus_policy;\n\n  g_hash_table_iter_init (&iter, ht);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      FlatpakPolicy policy = GPOINTER_TO_INT (value);\n\n      if (policy > 0)\n        flatpak_bwrap_add_arg_printf (bwrap, \"--%s=%s\",\n                                      flatpak_policy_to_string (policy),\n                                      (char *) key);\n    }\n}\n\nvoid\nflatpak_context_reset_non_permissions (FlatpakContext *context)\n{\n  g_hash_table_remove_all (context->env_vars);\n}\n\nvoid\nflatpak_context_reset_permissions (FlatpakContext *context)\n{\n  context->shares_valid = 0;\n  context->sockets_valid = 0;\n  context->devices_valid = 0;\n  context->features_valid = 0;\n\n  context->shares = 0;\n  context->sockets = 0;\n  context->devices = 0;\n  context->features = 0;\n\n  g_hash_table_remove_all (context->persistent);\n  g_hash_table_remove_all (context->filesystems);\n  g_hash_table_remove_all (context->session_bus_policy);\n  g_hash_table_remove_all (context->system_bus_policy);\n  g_hash_table_remove_all (context->generic_policy);\n}\n\nvoid\nflatpak_context_make_sandboxed (FlatpakContext *context)\n{\n  /* We drop almost everything from the app permission, except\n   * multiarch which is inherited, to make sure app code keeps\n   * running. */\n  context->shares_valid &= 0;\n  context->sockets_valid &= 0;\n  context->devices_valid &= 0;\n  context->features_valid &= FLATPAK_CONTEXT_FEATURE_MULTIARCH;\n\n  context->shares &= context->shares_valid;\n  context->sockets &= context->sockets_valid;\n  context->devices &= context->devices_valid;\n  context->features &= context->features_valid;\n\n  g_hash_table_remove_all (context->persistent);\n  g_hash_table_remove_all (context->filesystems);\n  g_hash_table_remove_all (context->session_bus_policy);\n  g_hash_table_remove_all (context->system_bus_policy);\n  g_hash_table_remove_all (context->generic_policy);\n}\n\nconst char *dont_mount_in_root[] = {\n  \".\", \"..\", \"lib\", \"lib32\", \"lib64\", \"bin\", \"sbin\", \"usr\", \"boot\", \"root\",\n  \"tmp\", \"etc\", \"app\", \"run\", \"proc\", \"sys\", \"dev\", \"var\", NULL\n};\n\nstatic void\nflatpak_context_export (FlatpakContext *context,\n                        FlatpakExports *exports,\n                        GFile          *app_id_dir,\n                        GPtrArray       *extra_app_id_dirs,\n                        gboolean        do_create,\n                        gchar         **xdg_dirs_conf_out,\n                        gboolean       *home_access_out)\n{\n  gboolean home_access = FALSE;\n  g_autoptr(GString) xdg_dirs_conf = NULL;\n  FlatpakFilesystemMode fs_mode, os_mode, etc_mode, home_mode;\n  GHashTableIter iter;\n  gpointer key, value;\n\n  if (xdg_dirs_conf_out != NULL)\n    xdg_dirs_conf = g_string_new (\"\");\n\n  fs_mode = GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"host\"));\n  if (fs_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    {\n      DIR *dir;\n      struct dirent *dirent;\n\n      g_debug (\"Allowing host-fs access\");\n      home_access = TRUE;\n\n      /* Bind mount most dirs in / into the new root */\n      dir = opendir (\"/\");\n      if (dir != NULL)\n        {\n          while ((dirent = readdir (dir)))\n            {\n              g_autofree char *path = NULL;\n\n              if (g_strv_contains (dont_mount_in_root, dirent->d_name))\n                continue;\n\n              path = g_build_filename (\"/\", dirent->d_name, NULL);\n              flatpak_exports_add_path_expose (exports, fs_mode, path);\n            }\n          closedir (dir);\n        }\n      flatpak_exports_add_path_expose (exports, fs_mode, \"/run/media\");\n    }\n\n  os_mode = MAX (GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"host-os\")),\n                   fs_mode);\n\n  if (os_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    flatpak_exports_add_host_os_expose (exports, os_mode);\n\n  etc_mode = MAX (GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"host-etc\")),\n                   fs_mode);\n\n  if (etc_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    flatpak_exports_add_host_etc_expose (exports, etc_mode);\n\n  home_mode = GPOINTER_TO_INT (g_hash_table_lookup (context->filesystems, \"home\"));\n  if (home_mode != FLATPAK_FILESYSTEM_MODE_NONE)\n    {\n      g_debug (\"Allowing homedir access\");\n      home_access = TRUE;\n\n      flatpak_exports_add_path_expose (exports, MAX (home_mode, fs_mode), g_get_home_dir ());\n    }\n\n  g_hash_table_iter_init (&iter, context->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *filesystem = key;\n      FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n\n      if (g_strv_contains (flatpak_context_special_filesystems, filesystem))\n        continue;\n\n      if (g_str_has_prefix (filesystem, \"xdg-\"))\n        {\n          const char *path, *rest = NULL;\n          const char *config_key = NULL;\n          g_autofree char *subpath = NULL;\n\n          if (!get_xdg_user_dir_from_string (filesystem, &config_key, &rest, &path))\n            {\n              g_warning (\"Unsupported xdg dir %s\", filesystem);\n              continue;\n            }\n\n          if (path == NULL)\n            continue; /* Unconfigured, ignore */\n\n          if (strcmp (path, g_get_home_dir ()) == 0)\n            {\n              /* xdg-user-dirs sets disabled dirs to $HOME, and its in general not a good\n                 idea to set full access to $HOME other than explicitly, so we ignore\n                 these */\n              g_debug (\"Xdg dir %s is $HOME (i.e. disabled), ignoring\", filesystem);\n              continue;\n            }\n\n          subpath = g_build_filename (path, rest, NULL);\n\n          if (mode == FLATPAK_FILESYSTEM_MODE_CREATE && do_create)\n            g_mkdir_with_parents (subpath, 0755);\n\n          if (g_file_test (subpath, G_FILE_TEST_EXISTS))\n            {\n              if (config_key && xdg_dirs_conf)\n                g_string_append_printf (xdg_dirs_conf, \"%s=\\\"%s\\\"\\n\",\n                                        config_key, path);\n\n              flatpak_exports_add_path_expose_or_hide (exports, mode, subpath);\n            }\n        }\n      else if (g_str_has_prefix (filesystem, \"~/\"))\n        {\n          g_autofree char *path = NULL;\n\n          path = g_build_filename (g_get_home_dir (), filesystem + 2, NULL);\n\n          if (mode == FLATPAK_FILESYSTEM_MODE_CREATE && do_create)\n            g_mkdir_with_parents (path, 0755);\n\n          if (g_file_test (path, G_FILE_TEST_EXISTS))\n            flatpak_exports_add_path_expose_or_hide (exports, mode, path);\n        }\n      else if (g_str_has_prefix (filesystem, \"/\"))\n        {\n          if (mode == FLATPAK_FILESYSTEM_MODE_CREATE && do_create)\n            g_mkdir_with_parents (filesystem, 0755);\n\n          if (g_file_test (filesystem, G_FILE_TEST_EXISTS))\n            flatpak_exports_add_path_expose_or_hide (exports, mode, filesystem);\n        }\n      else\n        {\n          g_warning (\"Unexpected filesystem arg %s\", filesystem);\n        }\n    }\n\n  if (app_id_dir)\n    {\n      g_autoptr(GFile) apps_dir = g_file_get_parent (app_id_dir);\n      int i;\n      /* Hide the .var/app dir by default (unless explicitly made visible) */\n      flatpak_exports_add_path_tmpfs (exports, flatpak_file_get_path_cached (apps_dir));\n      /* But let the app write to the per-app dir in it */\n      flatpak_exports_add_path_expose (exports, FLATPAK_FILESYSTEM_MODE_READ_WRITE,\n                                       flatpak_file_get_path_cached (app_id_dir));\n\n      if (extra_app_id_dirs != NULL)\n        {\n          for (i = 0; i < extra_app_id_dirs->len; i++)\n            {\n              GFile *extra_app_id_dir = g_ptr_array_index (extra_app_id_dirs, i);\n              flatpak_exports_add_path_expose (exports, FLATPAK_FILESYSTEM_MODE_READ_WRITE,\n                                               flatpak_file_get_path_cached (extra_app_id_dir));\n            }\n        }\n    }\n\n  if (home_access_out != NULL)\n    *home_access_out = home_access;\n\n  if (xdg_dirs_conf_out != NULL)\n    {\n      g_assert (xdg_dirs_conf != NULL);\n      *xdg_dirs_conf_out = g_string_free (g_steal_pointer (&xdg_dirs_conf), FALSE);\n    }\n}\n\nFlatpakExports *\nflatpak_context_get_exports (FlatpakContext *context,\n                             const char     *app_id)\n{\n  g_autoptr(GFile) app_id_dir = flatpak_get_data_dir (app_id);\n\n  return flatpak_context_get_exports_full (context,\n                                           app_id_dir, NULL,\n                                           FALSE, FALSE, NULL, NULL);\n}\n\nFlatpakRunFlags\nflatpak_context_get_run_flags (FlatpakContext *context)\n{\n  FlatpakRunFlags flags = 0;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_DEVEL))\n    flags |= FLATPAK_RUN_FLAG_DEVEL;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_MULTIARCH))\n    flags |= FLATPAK_RUN_FLAG_MULTIARCH;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_BLUETOOTH))\n    flags |= FLATPAK_RUN_FLAG_BLUETOOTH;\n\n  if (flatpak_context_allows_features (context, FLATPAK_CONTEXT_FEATURE_CANBUS))\n    flags |= FLATPAK_RUN_FLAG_CANBUS;\n\n  return flags;\n}\n\nFlatpakExports *\nflatpak_context_get_exports_full (FlatpakContext *context,\n                                  GFile          *app_id_dir,\n                                  GPtrArray      *extra_app_id_dirs,\n                                  gboolean        do_create,\n                                  gboolean        include_default_dirs,\n                                  gchar         **xdg_dirs_conf_out,\n                                  gboolean       *home_access_out)\n{\n  g_autoptr(FlatpakExports) exports = flatpak_exports_new ();\n\n  flatpak_context_export (context, exports,\n                          app_id_dir, extra_app_id_dirs,\n                          do_create, xdg_dirs_conf_out, home_access_out);\n\n  if (include_default_dirs)\n    {\n      g_autoptr(GFile) user_flatpak_dir = NULL;\n\n      /* Hide the flatpak dir by default (unless explicitly made visible) */\n      user_flatpak_dir = flatpak_get_user_base_dir_location ();\n      flatpak_exports_add_path_tmpfs (exports, flatpak_file_get_path_cached (user_flatpak_dir));\n\n      /* Ensure we always have a homedir */\n      flatpak_exports_add_path_dir (exports, g_get_home_dir ());\n    }\n\n  return g_steal_pointer (&exports);\n}\n\nvoid\nflatpak_context_append_bwrap_filesystem (FlatpakContext  *context,\n                                         FlatpakBwrap    *bwrap,\n                                         const char      *app_id,\n                                         GFile           *app_id_dir,\n                                         FlatpakExports  *exports,\n                                         const char      *xdg_dirs_conf,\n                                         gboolean         home_access)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  if (app_id_dir != NULL)\n    flatpak_run_apply_env_appid (bwrap, app_id_dir);\n\n  if (!home_access)\n    {\n      /* Enable persistent mapping only if no access to real home dir */\n\n      g_hash_table_iter_init (&iter, context->persistent);\n      while (g_hash_table_iter_next (&iter, &key, NULL))\n        {\n          const char *persist = key;\n          g_autofree char *src = g_build_filename (g_get_home_dir (), \".var/app\", app_id, persist, NULL);\n          g_autofree char *dest = g_build_filename (g_get_home_dir (), persist, NULL);\n\n          g_mkdir_with_parents (src, 0755);\n\n          flatpak_bwrap_add_bind_arg (bwrap, \"--bind\", src, dest);\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n      g_autofree char *run_user_app_dst = g_strdup_printf (\"/run/flatpak/app/%s\", app_id);\n      g_autofree char *run_user_app_src = g_build_filename (user_runtime_dir, \"app\", app_id, NULL);\n\n      if (glnx_shutil_mkdir_p_at (AT_FDCWD,\n                                  run_user_app_src,\n                                  0700,\n                                  NULL,\n                                  NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--bind\", run_user_app_src, run_user_app_dst,\n                                NULL);\n\n      /* Later, we'll make $XDG_RUNTIME_DIR/app a symlink to /run/flatpak/app */\n      flatpak_bwrap_add_runtime_dir_member (bwrap, \"app\");\n    }\n\n  /* This actually outputs the args for the hide/expose operations\n   * in the exports */\n  flatpak_exports_append_bwrap_args (exports, bwrap);\n\n  /* Special case subdirectories of the cache, config and data xdg\n   * dirs.  If these are accessible explicitly, then we bind-mount\n   * these in the app-id dir. This allows applications to explicitly\n   * opt out of keeping some config/cache/data in the app-specific\n   * directory.\n   */\n  if (app_id_dir)\n    {\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          const char *filesystem = key;\n          FlatpakFilesystemMode mode = GPOINTER_TO_INT (value);\n          g_autofree char *xdg_path = NULL;\n          const char *rest, *where;\n\n          xdg_path = get_xdg_dir_from_string (filesystem, &rest, &where);\n\n          if (xdg_path != NULL && *rest != 0 &&\n              mode >= FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n            {\n              g_autoptr(GFile) app_version = g_file_get_child (app_id_dir, where);\n              g_autoptr(GFile) app_version_subdir = g_file_resolve_relative_path (app_version, rest);\n\n              if (g_file_test (xdg_path, G_FILE_TEST_IS_DIR) ||\n                  g_file_test (xdg_path, G_FILE_TEST_IS_REGULAR))\n                {\n                  g_autofree char *xdg_path_in_app = g_file_get_path (app_version_subdir);\n                  flatpak_bwrap_add_bind_arg (bwrap,\n                                              mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY ? \"--ro-bind\" : \"--bind\",\n                                              xdg_path, xdg_path_in_app);\n                }\n            }\n        }\n    }\n\n  if (home_access && app_id_dir != NULL)\n    {\n      g_autofree char *src_path = g_build_filename (g_get_user_config_dir (),\n                                                    \"user-dirs.dirs\",\n                                                    NULL);\n      g_autofree char *path = g_build_filename (flatpak_file_get_path_cached (app_id_dir),\n                                                \"config/user-dirs.dirs\", NULL);\n      if (g_file_test (src_path, G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_bind_arg (bwrap, \"--ro-bind\", src_path, path);\n    }\n  else if (xdg_dirs_conf != NULL && xdg_dirs_conf[0] != '\\0' && app_id_dir != NULL)\n    {\n      g_autofree char *path =\n        g_build_filename (flatpak_file_get_path_cached (app_id_dir),\n                          \"config/user-dirs.dirs\", NULL);\n\n      flatpak_bwrap_add_args_data (bwrap, \"xdg-config-dirs\",\n                                   xdg_dirs_conf, strlen (xdg_dirs_conf), path, NULL);\n    }\n}\n"], "filenames": ["common/flatpak-context.c"], "buggy_code_start_loc": [854], "buggy_code_end_loc": [890], "fixing_code_start_loc": [855], "fixing_code_end_loc": [953], "type": "CWE-22", "message": "Flatpak is a Linux application sandboxing and distribution framework. A path traversal vulnerability affects versions of Flatpak prior to 1.12.3 and 1.10.6. flatpak-builder applies `finish-args` last in the build. At this point the build directory will have the full access that is specified in the manifest, so running `flatpak build` against it will gain those permissions. Normally this will not be done, so this is not problem. However, if `--mirror-screenshots-url` is specified, then flatpak-builder will launch `flatpak build --nofilesystem=host appstream-utils mirror-screenshots` after finalization, which can lead to issues even with the `--nofilesystem=host` protection. In normal use, the only issue is that these empty directories can be created wherever the user has write permissions. However, a malicious application could replace the `appstream-util` binary and potentially do something more hostile. This has been resolved in Flatpak 1.12.3 and 1.10.6 by changing the behaviour of `--nofilesystem=home` and `--nofilesystem=host`.", "other": {"cve": {"id": "CVE-2022-21682", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-13T21:15:08.690", "lastModified": "2022-02-10T07:52:55.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flatpak is a Linux application sandboxing and distribution framework. A path traversal vulnerability affects versions of Flatpak prior to 1.12.3 and 1.10.6. flatpak-builder applies `finish-args` last in the build. At this point the build directory will have the full access that is specified in the manifest, so running `flatpak build` against it will gain those permissions. Normally this will not be done, so this is not problem. However, if `--mirror-screenshots-url` is specified, then flatpak-builder will launch `flatpak build --nofilesystem=host appstream-utils mirror-screenshots` after finalization, which can lead to issues even with the `--nofilesystem=host` protection. In normal use, the only issue is that these empty directories can be created wherever the user has write permissions. However, a malicious application could replace the `appstream-util` binary and potentially do something more hostile. This has been resolved in Flatpak 1.12.3 and 1.10.6 by changing the behaviour of `--nofilesystem=home` and `--nofilesystem=host`."}, {"lang": "es", "value": "Flatpak es un marco de distribuci\u00f3n y sandboxing de aplicaciones Linux. Una vulnerabilidad de salto de ruta afecta a las versiones de Flatpak anteriores a 1.12.3 y 1.10.6. flatpak-builder aplica \"finish-args\" en \u00faltimo lugar en la construcci\u00f3n. En este punto, el directorio de construcci\u00f3n tendr\u00e1 el acceso completo que es especificado en el manifiesto, por lo que la ejecuci\u00f3n de \"flatpak build\" contra \u00e9l ganar\u00e1 esos permisos. Normalmente esto no se realiza, por lo que no es un problema. Sin embargo, si se especifica \"--mirror-screenshots-url\", entonces flatpak-builder lanzar\u00e1 \"flatpak build --nofilesystem=host appstream-utils mirror-screenshots\" tras la finalizaci\u00f3n, lo que puede conllevar a problemas incluso con la protecci\u00f3n \"--nofilesystem=host\". En un uso normal, el \u00fanico problema es que estos directorios vac\u00edos pueden crearse en cualquier lugar donde el usuario tenga permisos de escritura. Sin embargo, una aplicaci\u00f3n maliciosa podr\u00eda reemplazar el binario \"appstream-util\" y potencialmente hacer algo m\u00e1s hostil. Esto ha sido resuelto en Flatpak versiones 1.12.3 y 1.10.6, al cambiar el comportamiento de \"--nofilesystem=home\" y \"--nofilesystem=host\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.7", "matchCriteriaId": "613765F7-BD3F-473D-99F7-EDB260050197"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.1", "versionEndExcluding": "1.12.4", "matchCriteriaId": "4789481C-5282-4021-946B-0A75D38F6400"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak-builder:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "F476472C-7143-4706-9E76-85EA7800A96F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/flatpak/flatpak/commit/445bddeee657fdc8d2a0a1f0de12975400d4fc1a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/4d11f77aa7fd3e64cfa80af89d92567ab9e8e6fa", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/security/advisories/GHSA-8ch7-5j3h-g4fx", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/APFTBYGJJVJPFVHRXUW5PII5XOAFI4KH/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IXKBERLJRYV7KXKGXOLI6IOXVBQNN4DP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5049", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flatpak/flatpak/commit/445bddeee657fdc8d2a0a1f0de12975400d4fc1a"}}