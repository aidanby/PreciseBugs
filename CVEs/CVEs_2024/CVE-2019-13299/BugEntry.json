{"buggy_code": ["/*\n  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization\n  dedicated to making software imaging solutions freely available.\n\n  You may not use this file except in compliance with the License.  You may\n  obtain a copy of the License at\n\n    https://imagemagick.org/script/license.php\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  MagickCore pixel accessor methods.\n*/\n#ifndef MAGICKCORE_PIXEL_ACCESSOR_H\n#define MAGICKCORE_PIXEL_ACCESSOR_H\n\n#include <assert.h>\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/memory_.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#undef index\n\nstatic inline Quantum ClampPixel(const MagickRealType pixel)\n{\n  if (pixel < 0.0f)\n    return((Quantum) 0);\n  if (pixel >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) (pixel+0.5f));\n#else\n  return((Quantum) pixel);\n#endif\n}\n\nstatic inline Quantum GetPixela(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[aPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelAlpha(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits == UndefinedPixelTrait)\n    return(OpaqueAlpha);\n  return(pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelAlphaTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[AlphaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelb(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[bPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelBlack(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[BlackPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlackTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[BlackPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelBlue(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[BluePixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlueTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[BluePixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCb(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[CbPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCbTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[CbPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}\n\nstatic inline PixelChannel GetPixelChannelChannel(\n  const Image *magick_restrict image,const ssize_t offset)\n{\n  return(image->channel_map[offset].channel);\n}\n\nstatic inline ssize_t GetPixelChannelOffset(const Image *magick_restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].offset);\n}\n\nstatic inline PixelTrait GetPixelChannelTraits(\n  const Image *magick_restrict image,const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline size_t GetPixelChannels(const Image *magick_restrict image)\n{\n  return(image->number_channels);\n}\n\nstatic inline Quantum GetPixelCompositeMask(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[CompositeMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[CompositeMaskPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelCr(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[CrPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCrTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[CrPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCyan(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[CyanPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCyanTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[CyanPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGray(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[GrayPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGrayTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[GrayPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGreen(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[GreenPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGreenTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[GreenPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelIndex(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[IndexPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelIndexTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[IndexPixelChannel].traits);\n}\n\nstatic inline MagickRealType GetPixelInfoChannel(\n  const PixelInfo *magick_restrict pixel_info,const PixelChannel channel)\n{\n  switch (channel)\n  {\n    case RedPixelChannel: return(pixel_info->red);\n    case GreenPixelChannel: return(pixel_info->green);\n    case BluePixelChannel: return(pixel_info->blue);\n    case BlackPixelChannel: return(pixel_info->black);\n    case AlphaPixelChannel: return(pixel_info->alpha);\n    case IndexPixelChannel: return(pixel_info->index);\n    default: return((MagickRealType) 0.0);\n  }\n}\n\nstatic inline double PerceptibleReciprocal(const double x)\n{\n  double\n    sign;\n\n  /*\n    Return 1/x where x is perceptible (not unlimited or infinitesimal).\n  */\n  sign=x < 0.0 ? -1.0 : 1.0;\n  if ((sign*x) >= MagickEpsilon)\n    return(1.0/x);\n  return(sign/MagickEpsilon);\n}\n\nstatic inline MagickRealType GetPixelInfoLuma(\n  const PixelInfo *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  if (pixel->colorspace == sRGBColorspace)\n    {\n      intensity=(MagickRealType) (0.212656f*pixel->red+0.715158f*pixel->green+\n        0.072186f*pixel->blue);\n      return(intensity);\n    }\n  intensity=(MagickRealType) (0.212656f*EncodePixelGamma(pixel->red)+\n    0.715158f*EncodePixelGamma(pixel->green)+\n    0.072186f*EncodePixelGamma(pixel->blue));\n  return(intensity);\n}\n\nstatic inline MagickRealType GetPixelInfoLuminance(\n  const PixelInfo *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  if (pixel->colorspace != sRGBColorspace)\n    {\n      intensity=(MagickRealType) (0.212656f*pixel->red+0.715158f*pixel->green+\n        0.072186f*pixel->blue);\n      return(intensity);\n    }\n  intensity=(MagickRealType) (0.212656f*DecodePixelGamma(pixel->red)+\n    0.715158f*DecodePixelGamma(pixel->green)+\n    0.072186f*DecodePixelGamma(pixel->blue));\n  return(intensity);\n}\n\nstatic inline Quantum GetPixelL(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[LPixelChannel].offset]);\n}\n\nstatic inline ssize_t GetPixelLabel(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return((ssize_t) pixel[image->channel_map[LabelPixelChannel].offset]);\n}\n\nstatic inline MagickRealType GetPixelLuma(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  intensity=(MagickRealType) (\n    0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n    0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n    0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);\n  return(intensity);\n}\n\nstatic inline MagickRealType GetPixelLuminance(\n  const Image *magick_restrict image,const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  if (image->colorspace != sRGBColorspace)\n    {\n      intensity=(MagickRealType) (\n        0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n        0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n        0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);\n      return(intensity);\n    }\n  intensity=(MagickRealType) (0.212656f*DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[RedPixelChannel].offset])+0.715158f*\n    DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset])+0.072186f*\n    DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[BluePixelChannel].offset]));\n  return(intensity);\n}\n\nstatic inline Quantum GetPixelMagenta(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[MagentaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelMagentaTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[MagentaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelReadMask(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[ReadMaskPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelWriteMask(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[WriteMaskPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelReadMaskTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[ReadMaskPixelChannel].traits);\n}\n\nstatic inline size_t GetPixelMetaChannels(const Image *magick_restrict image)\n{\n  return(image->number_meta_channels);\n}\n\nstatic inline size_t GetPixelMetacontentExtent(\n  const Image *magick_restrict image)\n{\n  return(image->metacontent_extent);\n}\n\nstatic inline Quantum GetPixelOpacity(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != BlendPixelTrait)\n    return(QuantumRange-OpaqueAlpha);\n  return(QuantumRange-pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelRed(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[RedPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelRedTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[RedPixelChannel].traits);\n}\n\nstatic inline void GetPixelInfoPixel(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel,PixelInfo *magick_restrict pixel_info)\n{\n  (void) ResetMagickMemory(pixel_info,0,sizeof(*pixel_info));\n  pixel_info->storage_class=DirectClass;\n  pixel_info->colorspace=sRGBColorspace;\n  pixel_info->depth=MAGICKCORE_QUANTUM_DEPTH;\n  pixel_info->alpha_trait=UndefinedPixelTrait;\n  pixel_info->alpha=(MagickRealType) OpaqueAlpha;\n  if (image != (Image *) NULL)\n    {\n      pixel_info->storage_class=image->storage_class;\n      pixel_info->colorspace=image->colorspace;\n      pixel_info->fuzz=image->fuzz;\n      pixel_info->depth=image->depth;\n      pixel_info->alpha_trait=image->alpha_trait;\n      if (pixel != (Quantum *) NULL)\n        {\n          pixel_info->red=(MagickRealType)\n            pixel[image->channel_map[RedPixelChannel].offset];\n          pixel_info->green=(MagickRealType)\n            pixel[image->channel_map[GreenPixelChannel].offset];\n          pixel_info->blue=(MagickRealType)\n            pixel[image->channel_map[BluePixelChannel].offset];\n          if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n            pixel_info->black=(MagickRealType)\n              pixel[image->channel_map[BlackPixelChannel].offset];\n          if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n            {\n              pixel_info->alpha=(MagickRealType)\n                pixel[image->channel_map[AlphaPixelChannel].offset];\n              pixel_info->alpha_trait=BlendPixelTrait;\n            }\n          if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n            pixel_info->index=(MagickRealType)\n          pixel[image->channel_map[IndexPixelChannel].offset];\n        }\n    }\n}\n\nstatic inline PixelTrait GetPixelTraits(const Image *magick_restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline Quantum GetPixelY(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[YPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[YPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelYellow(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[YellowPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYellowTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[YellowPixelChannel].traits);\n}\n\nstatic inline MagickRealType AbsolutePixelValue(const MagickRealType x)\n{\n  return(x < 0.0f ? -x : x);\n}\n\nstatic inline MagickBooleanType IsPixelAtDepth(const Quantum pixel,\n  const QuantumAny range)\n{\n  Quantum\n    quantum;\n\n  if (range == 0)\n    return(MagickTrue);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny)\n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range+0.5);\n#else\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny)\n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range);\n#endif\n  return(pixel == quantum ? MagickTrue : MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelEquivalent(\n  const Image *magick_restrict image,const Quantum *magick_restrict p,\n  const PixelInfo *magick_restrict q)\n{\n  MagickRealType\n    alpha,\n    beta,\n    color;\n\n  color=(MagickRealType) p[image->channel_map[AlphaPixelChannel].offset];\n  alpha=image->alpha_trait == UndefinedPixelTrait ? (MagickRealType)\n    OpaqueAlpha : color;\n  beta=q->alpha_trait == UndefinedPixelTrait ? (MagickRealType) OpaqueAlpha :\n    q->alpha;\n  if (AbsolutePixelValue(alpha-beta) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((AbsolutePixelValue(alpha-TransparentAlpha) < MagickEpsilon) ||\n      (AbsolutePixelValue(beta-TransparentAlpha) < MagickEpsilon))\n    return(MagickTrue);  /* no color component if pixel is transparent */\n  color=(MagickRealType) p[image->channel_map[RedPixelChannel].offset];\n  if (AbsolutePixelValue(color-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  color=(MagickRealType) p[image->channel_map[GreenPixelChannel].offset];\n  if (AbsolutePixelValue(color-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  color=(MagickRealType) p[image->channel_map[BluePixelChannel].offset];\n  if (AbsolutePixelValue(color-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n  if (image->colorspace == CMYKColorspace)\n    {\n      color=(MagickRealType) p[image->channel_map[BlackPixelChannel].offset];\n      if (AbsolutePixelValue(color-q->black) >= MagickEpsilon)\n        return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelGray(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    green_blue,\n    red_green;\n\n  red_green=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset]-\n    pixel[image->channel_map[GreenPixelChannel].offset];\n  green_blue=(MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset]-\n    pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red_green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green_blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoEquivalent(\n  const PixelInfo *magick_restrict p,const PixelInfo *magick_restrict q)\n{\n  MagickRealType\n    alpha,\n    beta;\n\n  alpha=p->alpha_trait == UndefinedPixelTrait ? (MagickRealType) OpaqueAlpha :\n    p->alpha;\n  beta=q->alpha_trait == UndefinedPixelTrait ? (MagickRealType) OpaqueAlpha :\n    q->alpha;\n  if (AbsolutePixelValue(alpha-beta) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((AbsolutePixelValue(alpha-TransparentAlpha) < MagickEpsilon) ||\n      (AbsolutePixelValue(beta-TransparentAlpha) < MagickEpsilon))\n    return(MagickTrue);  /* no color component if pixel is transparent */\n  if (AbsolutePixelValue(p->red-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->green-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->blue-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n  if (p->colorspace == CMYKColorspace)\n    {\n      if (AbsolutePixelValue(p->black-q->black) >= MagickEpsilon)\n        return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelMonochrome(\n  const Image *magick_restrict image,const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    green_blue,\n    red,\n    red_green;\n\n  red=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset];\n  if ((AbsolutePixelValue(red) >= MagickEpsilon) &&\n      (AbsolutePixelValue(red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  red_green=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset]-\n    pixel[image->channel_map[GreenPixelChannel].offset];\n  green_blue=(MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset]-\n    pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red_green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green_blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoGray(\n  const PixelInfo *magick_restrict pixel)\n{\n  if ((AbsolutePixelValue(pixel->red-pixel->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(pixel->green-pixel->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoMonochrome(\n  const PixelInfo *magick_restrict pixel_info)\n{\n  MagickRealType\n    green_blue,\n    red_green;\n\n  if ((AbsolutePixelValue(pixel_info->red) >= MagickEpsilon) ||\n      (AbsolutePixelValue(pixel_info->red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  red_green=pixel_info->red-pixel_info->green;\n  green_blue=pixel_info->green-pixel_info->blue;\n  if ((AbsolutePixelValue(red_green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green_blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline void SetPixela(const Image *magick_restrict image,\n  const Quantum a,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[aPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[aPixelChannel].offset]=a;\n}\n\nstatic inline void SetPixelAlpha(const Image *magick_restrict image,\n  const Quantum alpha,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=alpha;\n}\n\nstatic inline void SetPixelAlphaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[AlphaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelb(const Image *magick_restrict image,\n  const Quantum b,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[bPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[bPixelChannel].offset]=b;\n}\n\nstatic inline void SetPixelBackgoundColor(const Image *magick_restrict image,\n  Quantum *magick_restrict pixel)\n{\n  ssize_t\n    i;\n\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    pixel[i]=(Quantum) 0;\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(image->background_color.red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(image->background_color.green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(image->background_color.blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(image->background_color.black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      image->background_color.alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(image->background_color.alpha);\n}\n\nstatic inline void SetPixelBlack(const Image *magick_restrict image,\n  const Quantum black,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=black;\n}\n\nstatic inline void SetPixelBlackTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BlackPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelBlue(const Image *magick_restrict image,\n  const Quantum blue,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[BluePixelChannel].offset]=blue;\n}\n\nstatic inline void SetPixelBlueTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BluePixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCb(const Image *magick_restrict image,\n  const Quantum cb,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[CbPixelChannel].offset]=cb;\n}\n\nstatic inline void SetPixelCbTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CbPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum quantum,\n  Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[channel].offset]=quantum;\n}\n\nstatic inline void SetPixelChannelAttributes(\n  const Image *magick_restrict image,const PixelChannel channel,\n  const PixelTrait traits,const ssize_t offset)\n{\n  assert((ssize_t) channel < MaxPixelChannels);\n  assert(offset < MaxPixelChannels);\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelChannelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const ssize_t offset)\n{\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n}\n\nstatic inline void SetPixelChannels(Image *image,const size_t number_channels)\n{\n  image->number_channels=number_channels;\n}\n\nstatic inline void SetPixelChannelTraits(Image *image,\n  const PixelChannel channel,const PixelTrait traits)\n{\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelCompositeMask(const Image *magick_restrict image,\n  const Quantum mask,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[CompositeMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[CompositeMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelCr(const Image *magick_restrict image,\n  const Quantum cr,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[CrPixelChannel].offset]=cr;\n}\n\nstatic inline void SetPixelCrTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CrPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCyan(const Image *magick_restrict image,\n  const Quantum cyan,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[CyanPixelChannel].offset]=cyan;\n}\n\nstatic inline void SetPixelGray(const Image *magick_restrict image,\n  const Quantum gray,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[GrayPixelChannel].offset]=gray;\n}\n\nstatic inline void SetPixelGrayTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GrayPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelGreen(const Image *magick_restrict image,\n  const Quantum green,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[GreenPixelChannel].offset]=green;\n}\n\nstatic inline void SetPixelGreenTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GreenPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelIndex(const Image *magick_restrict image,\n  const Quantum index,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[IndexPixelChannel].offset]=index;\n}\n\nstatic inline void SetPixelIndexTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[IndexPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelViaPixelInfo(const Image *magick_restrict image,\n  const PixelInfo *magick_restrict pixel_info,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(pixel_info->red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(pixel_info->green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(pixel_info->blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(pixel_info->black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      pixel_info->alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(pixel_info->alpha);\n}\n\nstatic inline void SetPixelL(const Image *magick_restrict image,const Quantum L,\n  Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[LPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[LPixelChannel].offset]=L;\n}\n\nstatic inline void SetPixelMagenta(const Image *magick_restrict image,\n  const Quantum magenta,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[MagentaPixelChannel].offset]=magenta;\n}\n\nstatic inline void SetPixelMagentaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[MagentaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelReadMask(const Image *magick_restrict image,\n  const Quantum mask,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[ReadMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelWriteMask(const Image *magick_restrict image,\n  const Quantum mask,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[WriteMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelMetacontentExtent(Image *image,const size_t extent)\n{\n  image->metacontent_extent=extent;\n}\n\nstatic inline void SetPixelOpacity(const Image *magick_restrict image,\n  const Quantum alpha,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=QuantumRange-alpha;\n}\n\nstatic inline void SetPixelRed(const Image *magick_restrict image,\n  const Quantum red,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=red;\n}\n\nstatic inline void SetPixelRedTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[RedPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelYellow(const Image *magick_restrict image,\n  const Quantum yellow,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[YellowPixelChannel].offset]=yellow;\n}\n\nstatic inline void SetPixelYellowTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YellowPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelY(const Image *magick_restrict image,\n  const Quantum y,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[YPixelChannel].offset]=y;\n}\n\nstatic inline void SetPixelYTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YPixelChannel].traits=traits;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n"], "fixing_code": ["/*\n  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization\n  dedicated to making software imaging solutions freely available.\n\n  You may not use this file except in compliance with the License.  You may\n  obtain a copy of the License at\n\n    https://imagemagick.org/script/license.php\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  MagickCore pixel accessor methods.\n*/\n#ifndef MAGICKCORE_PIXEL_ACCESSOR_H\n#define MAGICKCORE_PIXEL_ACCESSOR_H\n\n#include <assert.h>\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/memory_.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#undef index\n\nstatic inline Quantum ClampPixel(const MagickRealType pixel)\n{\n  if (pixel < 0.0f)\n    return((Quantum) 0);\n  if (pixel >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) (pixel+0.5f));\n#else\n  return((Quantum) pixel);\n#endif\n}\n\nstatic inline Quantum GetPixela(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[aPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelAlpha(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits == UndefinedPixelTrait)\n    return(OpaqueAlpha);\n  return(pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelAlphaTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[AlphaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelb(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[bPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelBlack(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[BlackPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlackTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[BlackPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelBlue(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[BluePixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlueTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[BluePixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCb(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[CbPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCbTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[CbPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}\n\nstatic inline PixelChannel GetPixelChannelChannel(\n  const Image *magick_restrict image,const ssize_t offset)\n{\n  return(image->channel_map[offset].channel);\n}\n\nstatic inline ssize_t GetPixelChannelOffset(const Image *magick_restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].offset);\n}\n\nstatic inline PixelTrait GetPixelChannelTraits(\n  const Image *magick_restrict image,const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline size_t GetPixelChannels(const Image *magick_restrict image)\n{\n  return(image->number_channels);\n}\n\nstatic inline Quantum GetPixelCompositeMask(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[CompositeMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[CompositeMaskPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelCr(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[CrPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCrTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[CrPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCyan(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[CyanPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCyanTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[CyanPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGray(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[GrayPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGrayTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[GrayPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGreen(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[GreenPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGreenTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[GreenPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelIndex(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[IndexPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelIndexTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[IndexPixelChannel].traits);\n}\n\nstatic inline MagickRealType GetPixelInfoChannel(\n  const PixelInfo *magick_restrict pixel_info,const PixelChannel channel)\n{\n  switch (channel)\n  {\n    case RedPixelChannel: return(pixel_info->red);\n    case GreenPixelChannel: return(pixel_info->green);\n    case BluePixelChannel: return(pixel_info->blue);\n    case BlackPixelChannel: return(pixel_info->black);\n    case AlphaPixelChannel: return(pixel_info->alpha);\n    case IndexPixelChannel: return(pixel_info->index);\n    default: return((MagickRealType) 0.0);\n  }\n}\n\nstatic inline double PerceptibleReciprocal(const double x)\n{\n  double\n    sign;\n\n  /*\n    Return 1/x where x is perceptible (not unlimited or infinitesimal).\n  */\n  sign=x < 0.0 ? -1.0 : 1.0;\n  if ((sign*x) >= MagickEpsilon)\n    return(1.0/x);\n  return(sign/MagickEpsilon);\n}\n\nstatic inline MagickRealType GetPixelInfoLuma(\n  const PixelInfo *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  if (pixel->colorspace == sRGBColorspace)\n    {\n      intensity=(MagickRealType) (0.212656f*pixel->red+0.715158f*pixel->green+\n        0.072186f*pixel->blue);\n      return(intensity);\n    }\n  intensity=(MagickRealType) (0.212656f*EncodePixelGamma(pixel->red)+\n    0.715158f*EncodePixelGamma(pixel->green)+\n    0.072186f*EncodePixelGamma(pixel->blue));\n  return(intensity);\n}\n\nstatic inline MagickRealType GetPixelInfoLuminance(\n  const PixelInfo *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  if (pixel->colorspace != sRGBColorspace)\n    {\n      intensity=(MagickRealType) (0.212656f*pixel->red+0.715158f*pixel->green+\n        0.072186f*pixel->blue);\n      return(intensity);\n    }\n  intensity=(MagickRealType) (0.212656f*DecodePixelGamma(pixel->red)+\n    0.715158f*DecodePixelGamma(pixel->green)+\n    0.072186f*DecodePixelGamma(pixel->blue));\n  return(intensity);\n}\n\nstatic inline Quantum GetPixelL(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[LPixelChannel].offset]);\n}\n\nstatic inline ssize_t GetPixelLabel(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return((ssize_t) pixel[image->channel_map[LabelPixelChannel].offset]);\n}\n\nstatic inline MagickRealType GetPixelLuma(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  intensity=(MagickRealType) (\n    0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n    0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n    0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);\n  return(intensity);\n}\n\nstatic inline MagickRealType GetPixelLuminance(\n  const Image *magick_restrict image,const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    intensity;\n\n  if (image->colorspace != sRGBColorspace)\n    {\n      intensity=(MagickRealType) (\n        0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n        0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n        0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);\n      return(intensity);\n    }\n  intensity=(MagickRealType) (0.212656f*DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[RedPixelChannel].offset])+0.715158f*\n    DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset])+0.072186f*\n    DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[BluePixelChannel].offset]));\n  return(intensity);\n}\n\nstatic inline Quantum GetPixelMagenta(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[MagentaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelMagentaTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[MagentaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelReadMask(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[ReadMaskPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelWriteMask(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[WriteMaskPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelReadMaskTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[ReadMaskPixelChannel].traits);\n}\n\nstatic inline size_t GetPixelMetaChannels(const Image *magick_restrict image)\n{\n  return(image->number_meta_channels);\n}\n\nstatic inline size_t GetPixelMetacontentExtent(\n  const Image *magick_restrict image)\n{\n  return(image->metacontent_extent);\n}\n\nstatic inline Quantum GetPixelOpacity(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != BlendPixelTrait)\n    return(QuantumRange-OpaqueAlpha);\n  return(QuantumRange-pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelRed(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[RedPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelRedTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[RedPixelChannel].traits);\n}\n\nstatic inline void GetPixelInfoPixel(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel,PixelInfo *magick_restrict pixel_info)\n{\n  (void) ResetMagickMemory(pixel_info,0,sizeof(*pixel_info));\n  pixel_info->storage_class=DirectClass;\n  pixel_info->colorspace=sRGBColorspace;\n  pixel_info->depth=MAGICKCORE_QUANTUM_DEPTH;\n  pixel_info->alpha_trait=UndefinedPixelTrait;\n  pixel_info->alpha=(MagickRealType) OpaqueAlpha;\n  if (image != (Image *) NULL)\n    {\n      pixel_info->storage_class=image->storage_class;\n      pixel_info->colorspace=image->colorspace;\n      pixel_info->fuzz=image->fuzz;\n      pixel_info->depth=image->depth;\n      pixel_info->alpha_trait=image->alpha_trait;\n      if (pixel != (Quantum *) NULL)\n        {\n          pixel_info->red=(MagickRealType)\n            pixel[image->channel_map[RedPixelChannel].offset];\n          pixel_info->green=(MagickRealType)\n            pixel[image->channel_map[GreenPixelChannel].offset];\n          pixel_info->blue=(MagickRealType)\n            pixel[image->channel_map[BluePixelChannel].offset];\n          if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n            pixel_info->black=(MagickRealType)\n              pixel[image->channel_map[BlackPixelChannel].offset];\n          if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n            {\n              pixel_info->alpha=(MagickRealType)\n                pixel[image->channel_map[AlphaPixelChannel].offset];\n              pixel_info->alpha_trait=BlendPixelTrait;\n            }\n          if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n            pixel_info->index=(MagickRealType)\n          pixel[image->channel_map[IndexPixelChannel].offset];\n        }\n    }\n}\n\nstatic inline PixelTrait GetPixelTraits(const Image *magick_restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline Quantum GetPixelY(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[YPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYTraits(const Image *magick_restrict image)\n{\n  return(image->channel_map[YPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelYellow(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  return(pixel[image->channel_map[YellowPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYellowTraits(\n  const Image *magick_restrict image)\n{\n  return(image->channel_map[YellowPixelChannel].traits);\n}\n\nstatic inline MagickRealType AbsolutePixelValue(const MagickRealType x)\n{\n  return(x < 0.0f ? -x : x);\n}\n\nstatic inline MagickBooleanType IsPixelAtDepth(const Quantum pixel,\n  const QuantumAny range)\n{\n  Quantum\n    quantum;\n\n  if (range == 0)\n    return(MagickTrue);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny)\n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range+0.5);\n#else\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny)\n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range);\n#endif\n  return(pixel == quantum ? MagickTrue : MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelEquivalent(\n  const Image *magick_restrict image,const Quantum *magick_restrict p,\n  const PixelInfo *magick_restrict q)\n{\n  MagickRealType\n    alpha,\n    beta,\n    color;\n\n  color=(MagickRealType) p[image->channel_map[AlphaPixelChannel].offset];\n  alpha=image->alpha_trait == UndefinedPixelTrait ? (MagickRealType)\n    OpaqueAlpha : color;\n  beta=q->alpha_trait == UndefinedPixelTrait ? (MagickRealType) OpaqueAlpha :\n    q->alpha;\n  if (AbsolutePixelValue(alpha-beta) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((AbsolutePixelValue(alpha-TransparentAlpha) < MagickEpsilon) ||\n      (AbsolutePixelValue(beta-TransparentAlpha) < MagickEpsilon))\n    return(MagickTrue);  /* no color component if pixel is transparent */\n  color=(MagickRealType) p[image->channel_map[RedPixelChannel].offset];\n  if (AbsolutePixelValue(color-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  color=(MagickRealType) p[image->channel_map[GreenPixelChannel].offset];\n  if (AbsolutePixelValue(color-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  color=(MagickRealType) p[image->channel_map[BluePixelChannel].offset];\n  if (AbsolutePixelValue(color-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n  if (image->colorspace == CMYKColorspace)\n    {\n      color=(MagickRealType) p[image->channel_map[BlackPixelChannel].offset];\n      if (AbsolutePixelValue(color-q->black) >= MagickEpsilon)\n        return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelGray(const Image *magick_restrict image,\n  const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    green_blue,\n    red_green;\n\n  red_green=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset]-\n    pixel[image->channel_map[GreenPixelChannel].offset];\n  green_blue=(MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset]-\n    pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red_green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green_blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoEquivalent(\n  const PixelInfo *magick_restrict p,const PixelInfo *magick_restrict q)\n{\n  MagickRealType\n    alpha,\n    beta;\n\n  alpha=p->alpha_trait == UndefinedPixelTrait ? (MagickRealType) OpaqueAlpha :\n    p->alpha;\n  beta=q->alpha_trait == UndefinedPixelTrait ? (MagickRealType) OpaqueAlpha :\n    q->alpha;\n  if (AbsolutePixelValue(alpha-beta) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((AbsolutePixelValue(alpha-TransparentAlpha) < MagickEpsilon) ||\n      (AbsolutePixelValue(beta-TransparentAlpha) < MagickEpsilon))\n    return(MagickTrue);  /* no color component if pixel is transparent */\n  if (AbsolutePixelValue(p->red-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->green-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->blue-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n  if (p->colorspace == CMYKColorspace)\n    {\n      if (AbsolutePixelValue(p->black-q->black) >= MagickEpsilon)\n        return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelMonochrome(\n  const Image *magick_restrict image,const Quantum *magick_restrict pixel)\n{\n  MagickRealType\n    green_blue,\n    red,\n    red_green;\n\n  red=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset];\n  if ((AbsolutePixelValue(red) >= MagickEpsilon) &&\n      (AbsolutePixelValue(red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  red_green=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset]-\n    pixel[image->channel_map[GreenPixelChannel].offset];\n  green_blue=(MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset]-\n    pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red_green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green_blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoGray(\n  const PixelInfo *magick_restrict pixel)\n{\n  if ((AbsolutePixelValue(pixel->red-pixel->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(pixel->green-pixel->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoMonochrome(\n  const PixelInfo *magick_restrict pixel_info)\n{\n  MagickRealType\n    green_blue,\n    red_green;\n\n  if ((AbsolutePixelValue(pixel_info->red) >= MagickEpsilon) ||\n      (AbsolutePixelValue(pixel_info->red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  red_green=pixel_info->red-pixel_info->green;\n  green_blue=pixel_info->green-pixel_info->blue;\n  if ((AbsolutePixelValue(red_green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green_blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline void SetPixela(const Image *magick_restrict image,\n  const Quantum a,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[aPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[aPixelChannel].offset]=a;\n}\n\nstatic inline void SetPixelAlpha(const Image *magick_restrict image,\n  const Quantum alpha,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=alpha;\n}\n\nstatic inline void SetPixelAlphaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[AlphaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelb(const Image *magick_restrict image,\n  const Quantum b,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[bPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[bPixelChannel].offset]=b;\n}\n\nstatic inline void SetPixelBackgoundColor(const Image *magick_restrict image,\n  Quantum *magick_restrict pixel)\n{\n  ssize_t\n    i;\n\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    pixel[i]=(Quantum) 0;\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(image->background_color.red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(image->background_color.green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(image->background_color.blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(image->background_color.black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      image->background_color.alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(image->background_color.alpha);\n}\n\nstatic inline void SetPixelBlack(const Image *magick_restrict image,\n  const Quantum black,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=black;\n}\n\nstatic inline void SetPixelBlackTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BlackPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelBlue(const Image *magick_restrict image,\n  const Quantum blue,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[BluePixelChannel].offset]=blue;\n}\n\nstatic inline void SetPixelBlueTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BluePixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCb(const Image *magick_restrict image,\n  const Quantum cb,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[CbPixelChannel].offset]=cb;\n}\n\nstatic inline void SetPixelCbTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CbPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum quantum,\n  Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[channel].offset]=quantum;\n}\n\nstatic inline void SetPixelChannelAttributes(\n  const Image *magick_restrict image,const PixelChannel channel,\n  const PixelTrait traits,const ssize_t offset)\n{\n  assert((ssize_t) channel < MaxPixelChannels);\n  assert(offset < MaxPixelChannels);\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelChannelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const ssize_t offset)\n{\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n}\n\nstatic inline void SetPixelChannels(Image *image,const size_t number_channels)\n{\n  image->number_channels=number_channels;\n}\n\nstatic inline void SetPixelChannelTraits(Image *image,\n  const PixelChannel channel,const PixelTrait traits)\n{\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelCompositeMask(const Image *magick_restrict image,\n  const Quantum mask,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[CompositeMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[CompositeMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelCr(const Image *magick_restrict image,\n  const Quantum cr,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[CrPixelChannel].offset]=cr;\n}\n\nstatic inline void SetPixelCrTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CrPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCyan(const Image *magick_restrict image,\n  const Quantum cyan,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[CyanPixelChannel].offset]=cyan;\n}\n\nstatic inline void SetPixelGray(const Image *magick_restrict image,\n  const Quantum gray,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[GrayPixelChannel].offset]=gray;\n}\n\nstatic inline void SetPixelGrayTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GrayPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelGreen(const Image *magick_restrict image,\n  const Quantum green,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[GreenPixelChannel].offset]=green;\n}\n\nstatic inline void SetPixelGreenTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GreenPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelIndex(const Image *magick_restrict image,\n  const Quantum index,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[IndexPixelChannel].offset]=index;\n}\n\nstatic inline void SetPixelIndexTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[IndexPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelViaPixelInfo(const Image *magick_restrict image,\n  const PixelInfo *magick_restrict pixel_info,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(pixel_info->red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(pixel_info->green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(pixel_info->blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(pixel_info->black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      pixel_info->alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(pixel_info->alpha);\n}\n\nstatic inline void SetPixelL(const Image *magick_restrict image,const Quantum L,\n  Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[LPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[LPixelChannel].offset]=L;\n}\n\nstatic inline void SetPixelMagenta(const Image *magick_restrict image,\n  const Quantum magenta,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[MagentaPixelChannel].offset]=magenta;\n}\n\nstatic inline void SetPixelMagentaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[MagentaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelReadMask(const Image *magick_restrict image,\n  const Quantum mask,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[ReadMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelWriteMask(const Image *magick_restrict image,\n  const Quantum mask,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[WriteMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelMetacontentExtent(Image *image,const size_t extent)\n{\n  image->metacontent_extent=extent;\n}\n\nstatic inline void SetPixelOpacity(const Image *magick_restrict image,\n  const Quantum alpha,Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=QuantumRange-alpha;\n}\n\nstatic inline void SetPixelRed(const Image *magick_restrict image,\n  const Quantum red,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=red;\n}\n\nstatic inline void SetPixelRedTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[RedPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelYellow(const Image *magick_restrict image,\n  const Quantum yellow,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[YellowPixelChannel].offset]=yellow;\n}\n\nstatic inline void SetPixelYellowTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YellowPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelY(const Image *magick_restrict image,\n  const Quantum y,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[YPixelChannel].offset]=y;\n}\n\nstatic inline void SetPixelYTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YPixelChannel].traits=traits;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n"], "filenames": ["MagickCore/pixel-accessor.h"], "buggy_code_start_loc": [114], "buggy_code_end_loc": [115], "fixing_code_start_loc": [114], "fixing_code_end_loc": [115], "type": "CWE-125", "message": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/pixel-accessor.h in GetPixelChannel.", "other": {"cve": {"id": "CVE-2019-13299", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.187", "lastModified": "2023-03-02T15:57:35.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/pixel-accessor.h in GetPixelChannel."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap) en MagickCore/pixel-accessor.h en GetPixelChannel."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/8187d2d8fd010d2d6b1a3a8edd935beec404dddc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1610", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/8187d2d8fd010d2d6b1a3a8edd935beec404dddc"}}