{"buggy_code": ["\"\"\"\nA base Application class for Jupyter applications.\n\nAll Jupyter applications should inherit from this.\n\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport logging\nimport os\nimport sys\nfrom copy import deepcopy\nfrom shutil import which\n\nfrom traitlets import Bool, List, Unicode, observe\nfrom traitlets.config.application import Application, catch_config_error\nfrom traitlets.config.loader import ConfigFileNotFound\n\nfrom .paths import (\n    allow_insecure_writes,\n    issue_insecure_write_warning,\n    jupyter_config_dir,\n    jupyter_config_path,\n    jupyter_data_dir,\n    jupyter_path,\n    jupyter_runtime_dir,\n)\nfrom .utils import ensure_dir_exists\n\n# aliases and flags\n\nbase_aliases = {}\nif isinstance(Application.aliases, dict):\n    # traitlets 5\n    base_aliases.update(Application.aliases)\n_jupyter_aliases = {\n    \"log-level\": \"Application.log_level\",\n    \"config\": \"JupyterApp.config_file\",\n}\nbase_aliases.update(_jupyter_aliases)\n\nbase_flags = {}\nif isinstance(Application.flags, dict):\n    # traitlets 5\n    base_flags.update(Application.flags)\n_jupyter_flags = {\n    \"debug\": (\n        {\"Application\": {\"log_level\": logging.DEBUG}},\n        \"set log level to logging.DEBUG (maximize logging output)\",\n    ),\n    \"generate-config\": ({\"JupyterApp\": {\"generate_config\": True}}, \"generate default config file\"),\n    \"y\": (\n        {\"JupyterApp\": {\"answer_yes\": True}},\n        \"Answer yes to any questions instead of prompting.\",\n    ),\n}\nbase_flags.update(_jupyter_flags)\n\n\nclass NoStart(Exception):\n    \"\"\"Exception to raise when an application shouldn't start\"\"\"\n\n\nclass JupyterApp(Application):\n    \"\"\"Base class for Jupyter applications\"\"\"\n\n    name = \"jupyter\"  # override in subclasses\n    description = \"A Jupyter Application\"\n\n    aliases = base_aliases\n    flags = base_flags\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    jupyter_path = List(Unicode())\n\n    def _jupyter_path_default(self):\n        return jupyter_path()\n\n    config_dir = Unicode()\n\n    def _config_dir_default(self):\n        return jupyter_config_dir()\n\n    @property\n    def config_file_paths(self):\n        path = jupyter_config_path()\n        if self.config_dir not in path:\n            path.insert(0, self.config_dir)\n        path.insert(0, os.getcwd())\n        return path\n\n    data_dir = Unicode()\n\n    def _data_dir_default(self):\n        d = jupyter_data_dir()\n        ensure_dir_exists(d, mode=0o700)\n        return d\n\n    runtime_dir = Unicode()\n\n    def _runtime_dir_default(self):\n        rd = jupyter_runtime_dir()\n        ensure_dir_exists(rd, mode=0o700)\n        return rd\n\n    @observe(\"runtime_dir\")\n    def _runtime_dir_changed(self, change):\n        ensure_dir_exists(change[\"new\"], mode=0o700)\n\n    generate_config = Bool(False, config=True, help=\"\"\"Generate default config file.\"\"\")\n\n    config_file_name = Unicode(config=True, help=\"Specify a config file to load.\")\n\n    def _config_file_name_default(self):\n        if not self.name:\n            return \"\"\n        return self.name.replace(\"-\", \"_\") + \"_config\"\n\n    config_file = Unicode(\n        config=True,\n        help=\"\"\"Full path of a config file.\"\"\",\n    )\n\n    answer_yes = Bool(False, config=True, help=\"\"\"Answer yes to any prompts.\"\"\")\n\n    def write_default_config(self):\n        \"\"\"Write our default config to a .py config file\"\"\"\n        if self.config_file:\n            config_file = self.config_file\n        else:\n            config_file = os.path.join(self.config_dir, self.config_file_name + \".py\")\n\n        if os.path.exists(config_file) and not self.answer_yes:\n            answer = \"\"\n\n            def ask():\n                prompt = \"Overwrite %s with default config? [y/N]\" % config_file\n                try:\n                    return input(prompt).lower() or \"n\"\n                except KeyboardInterrupt:\n                    print(\"\")  # empty line\n                    return \"n\"\n\n            answer = ask()\n            while not answer.startswith((\"y\", \"n\")):\n                print(\"Please answer 'yes' or 'no'\")\n                answer = ask()\n            if answer.startswith(\"n\"):\n                return\n\n        config_text = self.generate_config_file()\n        if isinstance(config_text, bytes):\n            config_text = config_text.decode(\"utf8\")\n        print(\"Writing default config to: %s\" % config_file)\n        ensure_dir_exists(os.path.abspath(os.path.dirname(config_file)), 0o700)\n        with open(config_file, mode=\"w\", encoding=\"utf-8\") as f:\n            f.write(config_text)\n\n    def migrate_config(self):\n        \"\"\"Migrate config/data from IPython 3\"\"\"\n        if os.path.exists(os.path.join(self.config_dir, \"migrated\")):\n            # already migrated\n            return\n\n        from .migrate import get_ipython_dir, migrate\n\n        # No IPython dir, nothing to migrate\n        if not os.path.exists(get_ipython_dir()):\n            return\n\n        migrate()\n\n    def load_config_file(self, suppress_errors=True):\n        \"\"\"Load the config file.\n\n        By default, errors in loading config are handled, and a warning\n        printed on screen. For testing, the suppress_errors option is set\n        to False, so errors will make tests fail.\n        \"\"\"\n        self.log.debug(\"Searching %s for config files\", self.config_file_paths)\n        base_config = \"jupyter_config\"\n        try:\n            super().load_config_file(\n                base_config,\n                path=self.config_file_paths,\n            )\n        except ConfigFileNotFound:\n            # ignore errors loading parent\n            self.log.debug(\"Config file %s not found\", base_config)\n\n        if self.config_file:\n            path, config_file_name = os.path.split(self.config_file)\n        else:\n            path = self.config_file_paths\n            config_file_name = self.config_file_name\n\n            if not config_file_name or (config_file_name == base_config):\n                return\n\n        try:\n            super().load_config_file(config_file_name, path=path)\n        except ConfigFileNotFound:\n            self.log.debug(\"Config file not found, skipping: %s\", config_file_name)\n        except Exception:\n            # Reraise errors for testing purposes, or if set in\n            # self.raise_config_file_errors\n            if (not suppress_errors) or self.raise_config_file_errors:\n                raise\n            self.log.warning(\"Error loading config file: %s\" % config_file_name, exc_info=True)\n\n    # subcommand-related\n    def _find_subcommand(self, name):\n        name = f\"{self.name}-{name}\"\n        return which(name)\n\n    @property\n    def _dispatching(self):\n        \"\"\"Return whether we are dispatching to another command\n\n        or running ourselves.\n        \"\"\"\n        return bool(self.generate_config or self.subapp or self.subcommand)\n\n    subcommand = Unicode()\n\n    @catch_config_error\n    def initialize(self, argv=None):\n        # don't hook up crash handler before parsing command-line\n        if argv is None:\n            argv = sys.argv[1:]\n        if argv:\n            subc = self._find_subcommand(argv[0])\n            if subc:\n                self.argv = argv\n                self.subcommand = subc\n                return\n        self.parse_command_line(argv)\n        cl_config = deepcopy(self.config)\n        if self._dispatching:\n            return\n        self.migrate_config()\n        self.load_config_file()\n        # enforce cl-opts override configfile opts:\n        self.update_config(cl_config)\n        if allow_insecure_writes:\n            issue_insecure_write_warning()\n\n    def start(self):\n        \"\"\"Start the whole thing\"\"\"\n        if self.subcommand:\n            os.execv(self.subcommand, [self.subcommand] + self.argv[1:])\n            raise NoStart()\n\n        if self.subapp:\n            self.subapp.start()\n            raise NoStart()\n\n        if self.generate_config:\n            self.write_default_config()\n            raise NoStart()\n\n    @classmethod\n    def launch_instance(cls, argv=None, **kwargs):\n        \"\"\"Launch an instance of a Jupyter Application\"\"\"\n        try:\n            return super().launch_instance(argv=argv, **kwargs)\n        except NoStart:\n            return\n\n\nif __name__ == \"__main__\":\n    JupyterApp.launch_instance()\n", "import os\nimport shutil\nfrom tempfile import mkdtemp\nfrom unittest.mock import patch\n\nimport pytest\nfrom traitlets import Integer\n\nfrom jupyter_core.application import JupyterApp, NoStart\n\npjoin = os.path.join\n\n\ndef test_basic():\n    JupyterApp()\n\n\ndef test_default_traits():\n    app = JupyterApp()\n    for trait_name in app.traits():\n        getattr(app, trait_name)\n\n\nclass DummyApp(JupyterApp):\n    name = \"dummy-app\"\n    m = Integer(0, config=True)\n    n = Integer(0, config=True)\n\n\n_dummy_config = \"\"\"\nc.DummyApp.n = 10\n\"\"\"\n\n\ndef test_custom_config():\n    app = DummyApp()\n    td = mkdtemp()\n    fname = pjoin(td, \"config.py\")\n    with open(fname, \"w\", encoding=\"utf-8\") as f:\n        f.write(_dummy_config)\n    app.initialize([\"--config\", fname])\n    shutil.rmtree(td)\n    assert app.config_file == fname\n    assert app.n == 10\n\n\ndef test_cli_override():\n    app = DummyApp()\n    td = mkdtemp()\n    fname = pjoin(td, \"config.py\")\n    with open(fname, \"w\", encoding=\"utf-8\") as f:\n        f.write(_dummy_config)\n    app.initialize([\"--config\", fname, \"--DummyApp.n=20\"])\n    shutil.rmtree(td)\n    assert app.n == 20\n\n\ndef test_generate_config():\n    td = mkdtemp()\n    app = DummyApp(config_dir=td)\n    app.initialize([\"--generate-config\"])\n    assert app.generate_config\n\n    with pytest.raises(NoStart):\n        app.start()\n\n    assert os.path.exists(os.path.join(td, \"dummy_app_config.py\"))\n\n\ndef test_load_config():\n    config_dir = mkdtemp()\n    wd = mkdtemp()\n    with open(pjoin(config_dir, \"dummy_app_config.py\"), \"w\", encoding=\"utf-8\") as f:\n        f.write(\"c.DummyApp.m = 1\\n\")\n        f.write(\"c.DummyApp.n = 1\")\n    with patch.object(os, \"getcwd\", lambda: wd):\n        app = DummyApp(config_dir=config_dir)\n        app.initialize([])\n\n    assert app.n == 1, \"Loaded config from config dir\"\n\n    with open(pjoin(wd, \"dummy_app_config.py\"), \"w\", encoding=\"utf-8\") as f:\n        f.write(\"c.DummyApp.n = 2\")\n\n    with patch.object(os, \"getcwd\", lambda: wd):\n        app = DummyApp(config_dir=config_dir)\n        app.initialize([])\n\n    assert app.m == 1, \"Loaded config from config dir\"\n    assert app.n == 2, \"Loaded config from CWD\"\n\n    shutil.rmtree(config_dir)\n    shutil.rmtree(wd)\n\n\ndef test_load_bad_config():\n    config_dir = mkdtemp()\n    wd = mkdtemp()\n    with open(pjoin(config_dir, \"dummy_app_config.py\"), \"w\", encoding=\"utf-8\") as f:\n        f.write('c.DummyApp.m = \"a\\n')  # Syntax error\n    with patch.object(os, \"getcwd\", lambda: wd):\n        with pytest.raises(SyntaxError):\n            app = DummyApp(config_dir=config_dir)\n            app.raise_config_file_errors = True\n            app.initialize([])\n\n    shutil.rmtree(config_dir)\n    shutil.rmtree(wd)\n\n\ndef test_runtime_dir_changed():\n    app = DummyApp()\n    td = mkdtemp()\n    shutil.rmtree(td)\n    app.runtime_dir = td\n    assert os.path.isdir(td)\n    shutil.rmtree(td)\n"], "fixing_code": ["\"\"\"\nA base Application class for Jupyter applications.\n\nAll Jupyter applications should inherit from this.\n\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport logging\nimport os\nimport sys\nfrom copy import deepcopy\nfrom shutil import which\n\nfrom traitlets import Bool, List, Unicode, observe\nfrom traitlets.config.application import Application, catch_config_error\nfrom traitlets.config.loader import ConfigFileNotFound\n\nfrom .paths import (\n    allow_insecure_writes,\n    issue_insecure_write_warning,\n    jupyter_config_dir,\n    jupyter_config_path,\n    jupyter_data_dir,\n    jupyter_path,\n    jupyter_runtime_dir,\n)\nfrom .utils import ensure_dir_exists\n\n# aliases and flags\n\nbase_aliases = {}\nif isinstance(Application.aliases, dict):\n    # traitlets 5\n    base_aliases.update(Application.aliases)\n_jupyter_aliases = {\n    \"log-level\": \"Application.log_level\",\n    \"config\": \"JupyterApp.config_file\",\n}\nbase_aliases.update(_jupyter_aliases)\n\nbase_flags = {}\nif isinstance(Application.flags, dict):\n    # traitlets 5\n    base_flags.update(Application.flags)\n_jupyter_flags = {\n    \"debug\": (\n        {\"Application\": {\"log_level\": logging.DEBUG}},\n        \"set log level to logging.DEBUG (maximize logging output)\",\n    ),\n    \"generate-config\": ({\"JupyterApp\": {\"generate_config\": True}}, \"generate default config file\"),\n    \"y\": (\n        {\"JupyterApp\": {\"answer_yes\": True}},\n        \"Answer yes to any questions instead of prompting.\",\n    ),\n}\nbase_flags.update(_jupyter_flags)\n\n\nclass NoStart(Exception):\n    \"\"\"Exception to raise when an application shouldn't start\"\"\"\n\n\nclass JupyterApp(Application):\n    \"\"\"Base class for Jupyter applications\"\"\"\n\n    name = \"jupyter\"  # override in subclasses\n    description = \"A Jupyter Application\"\n\n    aliases = base_aliases\n    flags = base_flags\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    jupyter_path = List(Unicode())\n\n    def _jupyter_path_default(self):\n        return jupyter_path()\n\n    config_dir = Unicode()\n\n    def _config_dir_default(self):\n        return jupyter_config_dir()\n\n    @property\n    def config_file_paths(self):\n        path = jupyter_config_path()\n        if self.config_dir not in path:\n            # Insert config dir as first item.\n            path.insert(0, self.config_dir)\n        return path\n\n    data_dir = Unicode()\n\n    def _data_dir_default(self):\n        d = jupyter_data_dir()\n        ensure_dir_exists(d, mode=0o700)\n        return d\n\n    runtime_dir = Unicode()\n\n    def _runtime_dir_default(self):\n        rd = jupyter_runtime_dir()\n        ensure_dir_exists(rd, mode=0o700)\n        return rd\n\n    @observe(\"runtime_dir\")\n    def _runtime_dir_changed(self, change):\n        ensure_dir_exists(change[\"new\"], mode=0o700)\n\n    generate_config = Bool(False, config=True, help=\"\"\"Generate default config file.\"\"\")\n\n    config_file_name = Unicode(config=True, help=\"Specify a config file to load.\")\n\n    def _config_file_name_default(self):\n        if not self.name:\n            return \"\"\n        return self.name.replace(\"-\", \"_\") + \"_config\"\n\n    config_file = Unicode(\n        config=True,\n        help=\"\"\"Full path of a config file.\"\"\",\n    )\n\n    answer_yes = Bool(False, config=True, help=\"\"\"Answer yes to any prompts.\"\"\")\n\n    def write_default_config(self):\n        \"\"\"Write our default config to a .py config file\"\"\"\n        if self.config_file:\n            config_file = self.config_file\n        else:\n            config_file = os.path.join(self.config_dir, self.config_file_name + \".py\")\n\n        if os.path.exists(config_file) and not self.answer_yes:\n            answer = \"\"\n\n            def ask():\n                prompt = \"Overwrite %s with default config? [y/N]\" % config_file\n                try:\n                    return input(prompt).lower() or \"n\"\n                except KeyboardInterrupt:\n                    print(\"\")  # empty line\n                    return \"n\"\n\n            answer = ask()\n            while not answer.startswith((\"y\", \"n\")):\n                print(\"Please answer 'yes' or 'no'\")\n                answer = ask()\n            if answer.startswith(\"n\"):\n                return\n\n        config_text = self.generate_config_file()\n        if isinstance(config_text, bytes):\n            config_text = config_text.decode(\"utf8\")\n        print(\"Writing default config to: %s\" % config_file)\n        ensure_dir_exists(os.path.abspath(os.path.dirname(config_file)), 0o700)\n        with open(config_file, mode=\"w\", encoding=\"utf-8\") as f:\n            f.write(config_text)\n\n    def migrate_config(self):\n        \"\"\"Migrate config/data from IPython 3\"\"\"\n        if os.path.exists(os.path.join(self.config_dir, \"migrated\")):\n            # already migrated\n            return\n\n        from .migrate import get_ipython_dir, migrate\n\n        # No IPython dir, nothing to migrate\n        if not os.path.exists(get_ipython_dir()):\n            return\n\n        migrate()\n\n    def load_config_file(self, suppress_errors=True):\n        \"\"\"Load the config file.\n\n        By default, errors in loading config are handled, and a warning\n        printed on screen. For testing, the suppress_errors option is set\n        to False, so errors will make tests fail.\n        \"\"\"\n        self.log.debug(\"Searching %s for config files\", self.config_file_paths)\n        base_config = \"jupyter_config\"\n        try:\n            super().load_config_file(\n                base_config,\n                path=self.config_file_paths,\n            )\n        except ConfigFileNotFound:\n            # ignore errors loading parent\n            self.log.debug(\"Config file %s not found\", base_config)\n\n        if self.config_file:\n            path, config_file_name = os.path.split(self.config_file)\n        else:\n            path = self.config_file_paths\n            config_file_name = self.config_file_name\n\n            if not config_file_name or (config_file_name == base_config):\n                return\n\n        try:\n            super().load_config_file(config_file_name, path=path)\n        except ConfigFileNotFound:\n            self.log.debug(\"Config file not found, skipping: %s\", config_file_name)\n        except Exception:\n            # Reraise errors for testing purposes, or if set in\n            # self.raise_config_file_errors\n            if (not suppress_errors) or self.raise_config_file_errors:\n                raise\n            self.log.warning(\"Error loading config file: %s\" % config_file_name, exc_info=True)\n\n    # subcommand-related\n    def _find_subcommand(self, name):\n        name = f\"{self.name}-{name}\"\n        return which(name)\n\n    @property\n    def _dispatching(self):\n        \"\"\"Return whether we are dispatching to another command\n\n        or running ourselves.\n        \"\"\"\n        return bool(self.generate_config or self.subapp or self.subcommand)\n\n    subcommand = Unicode()\n\n    @catch_config_error\n    def initialize(self, argv=None):\n        # don't hook up crash handler before parsing command-line\n        if argv is None:\n            argv = sys.argv[1:]\n        if argv:\n            subc = self._find_subcommand(argv[0])\n            if subc:\n                self.argv = argv\n                self.subcommand = subc\n                return\n        self.parse_command_line(argv)\n        cl_config = deepcopy(self.config)\n        if self._dispatching:\n            return\n        self.migrate_config()\n        self.load_config_file()\n        # enforce cl-opts override configfile opts:\n        self.update_config(cl_config)\n        if allow_insecure_writes:\n            issue_insecure_write_warning()\n\n    def start(self):\n        \"\"\"Start the whole thing\"\"\"\n        if self.subcommand:\n            os.execv(self.subcommand, [self.subcommand] + self.argv[1:])\n            raise NoStart()\n\n        if self.subapp:\n            self.subapp.start()\n            raise NoStart()\n\n        if self.generate_config:\n            self.write_default_config()\n            raise NoStart()\n\n    @classmethod\n    def launch_instance(cls, argv=None, **kwargs):\n        \"\"\"Launch an instance of a Jupyter Application\"\"\"\n        try:\n            return super().launch_instance(argv=argv, **kwargs)\n        except NoStart:\n            return\n\n\nif __name__ == \"__main__\":\n    JupyterApp.launch_instance()\n", "import os\nimport shutil\nfrom tempfile import mkdtemp\nfrom unittest.mock import patch\n\nimport pytest\nfrom traitlets import Integer\n\nfrom jupyter_core.application import JupyterApp, NoStart\n\npjoin = os.path.join\n\n\ndef test_basic():\n    JupyterApp()\n\n\ndef test_default_traits():\n    app = JupyterApp()\n    for trait_name in app.traits():\n        getattr(app, trait_name)\n\n\nclass DummyApp(JupyterApp):\n    name = \"dummy-app\"\n    m = Integer(0, config=True)\n    n = Integer(0, config=True)\n\n\n_dummy_config = \"\"\"\nc.DummyApp.n = 10\n\"\"\"\n\n\ndef test_custom_config():\n    app = DummyApp()\n    td = mkdtemp()\n    fname = pjoin(td, \"config.py\")\n    with open(fname, \"w\", encoding=\"utf-8\") as f:\n        f.write(_dummy_config)\n    app.initialize([\"--config\", fname])\n    shutil.rmtree(td)\n    assert app.config_file == fname\n    assert app.n == 10\n\n\ndef test_cli_override():\n    app = DummyApp()\n    td = mkdtemp()\n    fname = pjoin(td, \"config.py\")\n    with open(fname, \"w\", encoding=\"utf-8\") as f:\n        f.write(_dummy_config)\n    app.initialize([\"--config\", fname, \"--DummyApp.n=20\"])\n    shutil.rmtree(td)\n    assert app.n == 20\n\n\ndef test_generate_config():\n    td = mkdtemp()\n    app = DummyApp(config_dir=td)\n    app.initialize([\"--generate-config\"])\n    assert app.generate_config\n\n    with pytest.raises(NoStart):\n        app.start()\n\n    assert os.path.exists(os.path.join(td, \"dummy_app_config.py\"))\n\n\ndef test_load_config():\n    config_dir = mkdtemp()\n    os.environ[\"JUPYTER_CONFIG_PATH\"] = str(config_dir)\n    with open(pjoin(config_dir, \"dummy_app_config.py\"), \"w\", encoding=\"utf-8\") as f:\n        f.write(\"c.DummyApp.m = 1\\n\")\n        f.write(\"c.DummyApp.n = 1\")\n\n    app = DummyApp(config_dir=config_dir)\n    app.initialize([])\n\n    assert app.n == 1, \"Loaded config from config dir\"\n    assert app.m == 1, \"Loaded config from config dir\"\n\n    shutil.rmtree(config_dir)\n    del os.environ[\"JUPYTER_CONFIG_PATH\"]\n\n\ndef test_load_config_no_cwd():\n    config_dir = mkdtemp()\n    wd = mkdtemp()\n    with open(pjoin(wd, \"dummy_app_config.py\"), \"w\", encoding=\"utf-8\") as f:\n        f.write(\"c.DummyApp.m = 1\\n\")\n        f.write(\"c.DummyApp.n = 1\")\n    with patch.object(os, \"getcwd\", lambda: wd):\n        app = DummyApp(config_dir=config_dir)\n        app.initialize([])\n\n    assert app.n == 0\n    assert app.m == 0\n\n    shutil.rmtree(config_dir)\n    shutil.rmtree(wd)\n\n\ndef test_load_bad_config():\n    config_dir = mkdtemp()\n    os.environ[\"JUPYTER_CONFIG_PATH\"] = str(config_dir)\n    with open(pjoin(config_dir, \"dummy_app_config.py\"), \"w\", encoding=\"utf-8\") as f:\n        f.write('c.DummyApp.m = \"a\\n')  # Syntax error\n\n    with pytest.raises(SyntaxError):\n        app = DummyApp(config_dir=config_dir)\n        app.raise_config_file_errors = True\n        app.initialize([])\n\n    shutil.rmtree(config_dir)\n    del os.environ[\"JUPYTER_CONFIG_PATH\"]\n\n\ndef test_runtime_dir_changed():\n    app = DummyApp()\n    td = mkdtemp()\n    shutil.rmtree(td)\n    app.runtime_dir = td\n    assert os.path.isdir(td)\n    shutil.rmtree(td)\n"], "filenames": ["jupyter_core/application.py", "jupyter_core/tests/test_application.py"], "buggy_code_start_loc": [90, 71], "buggy_code_end_loc": [93, 109], "fixing_code_start_loc": [91, 72], "fixing_code_end_loc": [92, 117], "type": "CWE-250", "message": "Jupyter Core is a package for the core common functionality of Jupyter projects. Jupyter Core prior to version 4.11.2 contains an arbitrary code execution vulnerability in `jupyter_core` that stems from `jupyter_core` executing untrusted files in CWD. This vulnerability allows one user to run code as another. Version 4.11.2 contains a patch for this issue. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-39286", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-26T20:15:10.490", "lastModified": "2023-06-09T20:15:09.533", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Jupyter Core is a package for the core common functionality of Jupyter projects. Jupyter Core prior to version 4.11.2 contains an arbitrary code execution vulnerability in `jupyter_core` that stems from `jupyter_core` executing untrusted files in CWD. This vulnerability allows one user to run code as another. Version 4.11.2 contains a patch for this issue. There are no known workarounds."}, {"lang": "es", "value": "Jupyter Core es un paquete para la funcionalidad com\u00fan del n\u00facleo de los proyectos Jupyter. Jupyter Core versiones anteriores a 4.11.2, contiene una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo arbitrario en \"jupyter_core\" que proviene de que \"jupyter_core\" ejecuta archivos no confiables en CWD. Esta vulnerabilidad permite a un usuario ejecutar c\u00f3digo como otro. La versi\u00f3n 4.11.2 contiene un parche para este problema. No se presentan mitigaciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-250"}, {"lang": "en", "value": "CWE-269"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:jupyter_core:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.11.2", "matchCriteriaId": "F0D34D9C-BFA6-425F-A733-4B6ABBF5F7DF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/jupyter/jupyter_core/commit/1118c8ce01800cb689d51f655f5ccef19516e283", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyter/jupyter_core/security/advisories/GHSA-m678-f26j-3hrp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00022.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KKMP5OXXIX2QAUNVNJZ5UEQFKDYYJVBA/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YIDN7JMLK6AOMBQI4QPSW4MBQGWQ5NIN/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202301-04", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5422", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/jupyter/jupyter_core/commit/1118c8ce01800cb689d51f655f5ccef19516e283"}}