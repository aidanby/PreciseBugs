{"buggy_code": ["<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<!--\nCopyright (c) Brock Allen & Dominick Baier. All rights reserved.\nLicensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n-->\n<configuration>\n  <!--\n    Configure your application settings in appsettings.json. Learn more at http://go.microsoft.com/fwlink/?LinkId=786380\n  -->\n  <system.webServer>\n    <handlers>\n      <add name=\"aspNetCore\" path=\"*\" verb=\"*\" modules=\"AspNetCoreModule\" resourceType=\"Unspecified\" />\n    </handlers>\n    <aspNetCore processPath=\"%LAUNCHER_PATH%\" arguments=\"%LAUNCHER_ARGS%\" stdoutLogEnabled=\"false\" stdoutLogFile=\".\\logs\\stdout\" forwardWindowsAuthToken=\"true\" />\n  </system.webServer>\n</configuration>", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n\nusing System.Threading.Tasks;\nusing IdentityServer4.Models;\nusing IdentityServer4.Extensions;\nusing IdentityServer4.Hosting;\nusing IdentityModel;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing IdentityServer4.Services;\nusing IdentityServer4.Configuration;\nusing IdentityServer4.Stores;\nusing IdentityServer4.ResponseHandling;\nusing Microsoft.AspNetCore.Authentication;\n\nnamespace IdentityServer4.Endpoints.Results\n{\n    internal class AuthorizeResult : IEndpointResult\n    {\n        public AuthorizeResponse Response { get; }\n\n        public AuthorizeResult(AuthorizeResponse response)\n        {\n            Response = response ?? throw new ArgumentNullException(nameof(response));\n        }\n\n        internal AuthorizeResult(\n            AuthorizeResponse response,\n            IdentityServerOptions options,\n            IUserSession userSession,\n            IMessageStore<ErrorMessage> errorMessageStore,\n            ISystemClock clock)\n            : this(response)\n        {\n            _options = options;\n            _userSession = userSession;\n            _errorMessageStore = errorMessageStore;\n            _clock = clock;\n        }\n\n        private IdentityServerOptions _options;\n        private IUserSession _userSession;\n        private IMessageStore<ErrorMessage> _errorMessageStore;\n        private ISystemClock _clock;\n\n        private void Init(HttpContext context)\n        {\n            _options = _options ?? context.RequestServices.GetRequiredService<IdentityServerOptions>();\n            _userSession = _userSession ?? context.RequestServices.GetRequiredService<IUserSession>();\n            _errorMessageStore = _errorMessageStore ?? context.RequestServices.GetRequiredService<IMessageStore<ErrorMessage>>();\n            _clock = _clock ?? context.RequestServices.GetRequiredService<ISystemClock>();\n        }\n\n        public async Task ExecuteAsync(HttpContext context)\n        {\n            Init(context);\n\n            if (Response.IsError)\n            {\n                await ProcessErrorAsync(context);\n            }\n            else\n            {\n                await ProcessResponseAsync(context);\n            }\n        }\n\n        private async Task ProcessErrorAsync(HttpContext context)\n        {\n            // these are the conditions where we can send a response \n            // back directly to the client, otherwise we're only showing the error UI\n            var isPromptNoneError = Response.Error == OidcConstants.AuthorizeErrors.AccountSelectionRequired ||\n                Response.Error == OidcConstants.AuthorizeErrors.LoginRequired ||\n                Response.Error == OidcConstants.AuthorizeErrors.ConsentRequired ||\n                Response.Error == OidcConstants.AuthorizeErrors.InteractionRequired;\n\n            if (Response.Error == OidcConstants.AuthorizeErrors.AccessDenied ||\n                (isPromptNoneError && Response.Request?.PromptMode == OidcConstants.PromptModes.None)\n            )\n            {\n                // this scenario we can return back to the client\n                await ProcessResponseAsync(context);\n            }\n            else\n            {\n                // we now know we must show error page\n                await RedirectToErrorPageAsync(context);\n            }\n        }\n\n        protected async Task ProcessResponseAsync(HttpContext context)\n        {\n            if (!Response.IsError)\n            {\n                // success response -- track client authorization for sign-out\n                //_logger.LogDebug(\"Adding client {0} to client list cookie for subject {1}\", request.ClientId, request.Subject.GetSubjectId());\n                await _userSession.AddClientIdAsync(Response.Request.ClientId);\n            }\n\n            await RenderAuthorizeResponseAsync(context);\n        }\n\n        private async Task RenderAuthorizeResponseAsync(HttpContext context)\n        {\n            if (Response.Request.ResponseMode == OidcConstants.ResponseModes.Query ||\n                Response.Request.ResponseMode == OidcConstants.ResponseModes.Fragment)\n            {\n                context.Response.SetNoCache();\n                context.Response.Redirect(BuildRedirectUri());\n            }\n            else if (Response.Request.ResponseMode == OidcConstants.ResponseModes.FormPost)\n            {\n                context.Response.SetNoCache();\n                AddSecurityHeaders(context);\n                await context.Response.WriteHtmlAsync(GetFormPostHtml());\n            }\n            else\n            {\n                //_logger.LogError(\"Unsupported response mode.\");\n                throw new InvalidOperationException(\"Unsupported response mode\");\n            }\n        }\n\n        private void AddSecurityHeaders(HttpContext context)\n        {\n            var formOrigin = Response.Request.RedirectUri.GetOrigin();\n            var csp = $\"default-src 'none'; script-src 'sha256-VuNUSJ59bpCpw62HM2JG/hCyGiqoPN3NqGvNXQPU+rY='; \";\n\n            if (!context.Response.Headers.ContainsKey(\"Content-Security-Policy\"))\n            {\n                context.Response.Headers.Add(\"Content-Security-Policy\", csp);\n            }\n\n            if (!context.Response.Headers.ContainsKey(\"X-Content-Security-Policy\"))\n            {\n                context.Response.Headers.Add(\"X-Content-Security-Policy\", csp);\n            }\n\n            var referrer_policy = \"no-referrer\";\n            if (!context.Response.Headers.ContainsKey(\"Referrer-Policy\"))\n            {\n                context.Response.Headers.Add(\"Referrer-Policy\", referrer_policy);\n            }\n        }\n\n        private string BuildRedirectUri()\n        {\n            var uri = Response.RedirectUri;\n            var query = Response.ToNameValueCollection().ToQueryString();\n\n            if (Response.Request.ResponseMode == OidcConstants.ResponseModes.Query)\n            {\n                uri = uri.AddQueryString(query);\n            }\n            else\n            {\n                uri = uri.AddHashFragment(query);\n            }\n\n            if (Response.IsError && !uri.Contains(\"#\"))\n            {\n                // https://tools.ietf.org/html/draft-bradley-oauth-open-redirector-00\n                uri += \"#_=_\";\n            }\n\n            return uri;\n        }\n\n        private const string FormPostHtml = \"<form method='post' action='{uri}'>{body}<noscript><button>Click to continue</button></noscript></form><script>(function(){document.forms[0].submit();})();</script>\";\n\n        private string GetFormPostHtml()\n        {\n            var html = FormPostHtml;\n\n            html = html.Replace(\"{uri}\", Response.Request.RedirectUri);\n            html = html.Replace(\"{body}\", Response.ToNameValueCollection().ToFormPost());\n\n            return html;\n        }\n\n        private async Task RedirectToErrorPageAsync(HttpContext context)\n        {\n            var errorModel = new ErrorMessage\n            {\n                RequestId = context.TraceIdentifier,\n                Error = Response.Error,\n                ErrorDescription = Response.ErrorDescription,\n                UiLocales = Response.Request?.UiLocales,\n                DisplayMode = Response.Request?.DisplayMode\n            };\n\n            if (Response.RedirectUri != null && Response.Request?.ResponseMode != null)\n            {\n                // if we have a valid redirect uri, then include it to the error page\n                errorModel.RedirectUri = BuildRedirectUri();\n                errorModel.ResponseMode = Response.Request.ResponseMode;\n            }\n\n            var message = new Message<ErrorMessage>(errorModel, _clock.UtcNow.UtcDateTime);\n            var id = await _errorMessageStore.WriteAsync(message);\n\n            var errorUrl = _options.UserInteraction.ErrorUrl;\n\n            var url = errorUrl.AddQueryString(_options.UserInteraction.ErrorIdParameter, id);\n            context.Response.RedirectToAbsoluteUrl(url);\n        }\n    }\n}\n"], "fixing_code": ["<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\nCopyright (c) Brock Allen & Dominick Baier. All rights reserved.\nLicensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n-->\n<configuration>\n  <!--\n    Configure your application settings in appsettings.json. Learn more at http://go.microsoft.com/fwlink/?LinkId=786380\n  -->\n  <system.webServer>\n    <handlers>\n      <add name=\"aspNetCore\" path=\"*\" verb=\"*\" modules=\"AspNetCoreModule\" resourceType=\"Unspecified\" />\n    </handlers>\n    <aspNetCore processPath=\"%LAUNCHER_PATH%\" arguments=\"%LAUNCHER_ARGS%\" stdoutLogEnabled=\"false\" stdoutLogFile=\".\\logs\\stdout\" forwardWindowsAuthToken=\"true\" startupTimeLimit=\"3600\" requestTimeout=\"23:00:00\" />\n  </system.webServer>\n</configuration>", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n\nusing System.Threading.Tasks;\nusing IdentityServer4.Models;\nusing IdentityServer4.Extensions;\nusing IdentityServer4.Hosting;\nusing IdentityModel;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing IdentityServer4.Services;\nusing IdentityServer4.Configuration;\nusing IdentityServer4.Stores;\nusing IdentityServer4.ResponseHandling;\nusing Microsoft.AspNetCore.Authentication;\nusing System.Text.Encodings.Web;\n\nnamespace IdentityServer4.Endpoints.Results\n{\n    internal class AuthorizeResult : IEndpointResult\n    {\n        public AuthorizeResponse Response { get; }\n\n        public AuthorizeResult(AuthorizeResponse response)\n        {\n            Response = response ?? throw new ArgumentNullException(nameof(response));\n        }\n\n        internal AuthorizeResult(\n            AuthorizeResponse response,\n            IdentityServerOptions options,\n            IUserSession userSession,\n            IMessageStore<ErrorMessage> errorMessageStore,\n            ISystemClock clock)\n            : this(response)\n        {\n            _options = options;\n            _userSession = userSession;\n            _errorMessageStore = errorMessageStore;\n            _clock = clock;\n        }\n\n        private IdentityServerOptions _options;\n        private IUserSession _userSession;\n        private IMessageStore<ErrorMessage> _errorMessageStore;\n        private ISystemClock _clock;\n\n        private void Init(HttpContext context)\n        {\n            _options = _options ?? context.RequestServices.GetRequiredService<IdentityServerOptions>();\n            _userSession = _userSession ?? context.RequestServices.GetRequiredService<IUserSession>();\n            _errorMessageStore = _errorMessageStore ?? context.RequestServices.GetRequiredService<IMessageStore<ErrorMessage>>();\n            _clock = _clock ?? context.RequestServices.GetRequiredService<ISystemClock>();\n        }\n\n        public async Task ExecuteAsync(HttpContext context)\n        {\n            Init(context);\n\n            if (Response.IsError)\n            {\n                await ProcessErrorAsync(context);\n            }\n            else\n            {\n                await ProcessResponseAsync(context);\n            }\n        }\n\n        private async Task ProcessErrorAsync(HttpContext context)\n        {\n            // these are the conditions where we can send a response \n            // back directly to the client, otherwise we're only showing the error UI\n            var isPromptNoneError = Response.Error == OidcConstants.AuthorizeErrors.AccountSelectionRequired ||\n                Response.Error == OidcConstants.AuthorizeErrors.LoginRequired ||\n                Response.Error == OidcConstants.AuthorizeErrors.ConsentRequired ||\n                Response.Error == OidcConstants.AuthorizeErrors.InteractionRequired;\n\n            if (Response.Error == OidcConstants.AuthorizeErrors.AccessDenied ||\n                (isPromptNoneError && Response.Request?.PromptMode == OidcConstants.PromptModes.None)\n            )\n            {\n                // this scenario we can return back to the client\n                await ProcessResponseAsync(context);\n            }\n            else\n            {\n                // we now know we must show error page\n                await RedirectToErrorPageAsync(context);\n            }\n        }\n\n        protected async Task ProcessResponseAsync(HttpContext context)\n        {\n            if (!Response.IsError)\n            {\n                // success response -- track client authorization for sign-out\n                //_logger.LogDebug(\"Adding client {0} to client list cookie for subject {1}\", request.ClientId, request.Subject.GetSubjectId());\n                await _userSession.AddClientIdAsync(Response.Request.ClientId);\n            }\n\n            await RenderAuthorizeResponseAsync(context);\n        }\n\n        private async Task RenderAuthorizeResponseAsync(HttpContext context)\n        {\n            if (Response.Request.ResponseMode == OidcConstants.ResponseModes.Query ||\n                Response.Request.ResponseMode == OidcConstants.ResponseModes.Fragment)\n            {\n                context.Response.SetNoCache();\n                context.Response.Redirect(BuildRedirectUri());\n            }\n            else if (Response.Request.ResponseMode == OidcConstants.ResponseModes.FormPost)\n            {\n                context.Response.SetNoCache();\n                AddSecurityHeaders(context);\n                await context.Response.WriteHtmlAsync(GetFormPostHtml());\n            }\n            else\n            {\n                //_logger.LogError(\"Unsupported response mode.\");\n                throw new InvalidOperationException(\"Unsupported response mode\");\n            }\n        }\n\n        private void AddSecurityHeaders(HttpContext context)\n        {\n            var formOrigin = Response.Request.RedirectUri.GetOrigin();\n            var csp = $\"default-src 'none'; script-src 'sha256-VuNUSJ59bpCpw62HM2JG/hCyGiqoPN3NqGvNXQPU+rY='; \";\n\n            if (!context.Response.Headers.ContainsKey(\"Content-Security-Policy\"))\n            {\n                context.Response.Headers.Add(\"Content-Security-Policy\", csp);\n            }\n\n            if (!context.Response.Headers.ContainsKey(\"X-Content-Security-Policy\"))\n            {\n                context.Response.Headers.Add(\"X-Content-Security-Policy\", csp);\n            }\n\n            var referrer_policy = \"no-referrer\";\n            if (!context.Response.Headers.ContainsKey(\"Referrer-Policy\"))\n            {\n                context.Response.Headers.Add(\"Referrer-Policy\", referrer_policy);\n            }\n        }\n\n        private string BuildRedirectUri()\n        {\n            var uri = Response.RedirectUri;\n            var query = Response.ToNameValueCollection().ToQueryString();\n\n            if (Response.Request.ResponseMode == OidcConstants.ResponseModes.Query)\n            {\n                uri = uri.AddQueryString(query);\n            }\n            else\n            {\n                uri = uri.AddHashFragment(query);\n            }\n\n            if (Response.IsError && !uri.Contains(\"#\"))\n            {\n                // https://tools.ietf.org/html/draft-bradley-oauth-open-redirector-00\n                uri += \"#_=_\";\n            }\n\n            return uri;\n        }\n\n        private const string FormPostHtml = \"<form method='post' action='{uri}'>{body}<noscript><button>Click to continue</button></noscript></form><script>(function(){document.forms[0].submit();})();</script>\";\n\n        private string GetFormPostHtml()\n        {\n            var html = FormPostHtml;\n\n            var url = Response.Request.RedirectUri;\n            url = HtmlEncoder.Default.Encode(url);\n            html = html.Replace(\"{uri}\", url);\n            html = html.Replace(\"{body}\", Response.ToNameValueCollection().ToFormPost());\n\n            return html;\n        }\n\n        private async Task RedirectToErrorPageAsync(HttpContext context)\n        {\n            var errorModel = new ErrorMessage\n            {\n                RequestId = context.TraceIdentifier,\n                Error = Response.Error,\n                ErrorDescription = Response.ErrorDescription,\n                UiLocales = Response.Request?.UiLocales,\n                DisplayMode = Response.Request?.DisplayMode\n            };\n\n            if (Response.RedirectUri != null && Response.Request?.ResponseMode != null)\n            {\n                // if we have a valid redirect uri, then include it to the error page\n                errorModel.RedirectUri = BuildRedirectUri();\n                errorModel.ResponseMode = Response.Request.ResponseMode;\n            }\n\n            var message = new Message<ErrorMessage>(errorModel, _clock.UtcNow.UtcDateTime);\n            var id = await _errorMessageStore.WriteAsync(message);\n\n            var errorUrl = _options.UserInteraction.ErrorUrl;\n\n            var url = errorUrl.AddQueryString(_options.UserInteraction.ErrorIdParameter, id);\n            context.Response.RedirectToAbsoluteUrl(url);\n        }\n    }\n}\n"], "filenames": ["src/Host/web.config", "src/IdentityServer4/Endpoints/Results/AuthorizeResult.cs"], "buggy_code_start_loc": [2, 17], "buggy_code_end_loc": [16, 179], "fixing_code_start_loc": [1, 18], "fixing_code_end_loc": [15, 182], "type": "CWE-79", "message": "IdentityServer IdentityServer4 1.x before 1.5.3 and 2.x before 2.1.3 does not encode the redirect URI on the authorization response page, which might lead to XSS in some configurations.", "other": {"cve": {"id": "CVE-2018-8899", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-22T05:29:00.287", "lastModified": "2018-04-18T01:28:51.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "IdentityServer IdentityServer4 1.x before 1.5.3 and 2.x before 2.1.3 does not encode the redirect URI on the authorization response page, which might lead to XSS in some configurations."}, {"lang": "es", "value": "IdentityServer IdentityServer4, en versiones 1.x anteriores a la 1.5.3 y 2.x anteriores a la 2.1.3, no cifra el URI de redirecci\u00f3n en la p\u00e1gina de respuesta de autorizaci\u00f3n. Esto podr\u00eda conducir a Cross-Site Scripting (XSS) en algunas configuraciones."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:identityserver:identityserver4:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "1.5.2", "matchCriteriaId": "AFBF1F40-0032-4A48-B2BD-8DC2C9397CBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:identityserver:identityserver4:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.1.2", "matchCriteriaId": "08D8FCA9-C767-452D-A5F3-D3F721650214"}]}]}], "references": [{"url": "https://github.com/IdentityServer/IdentityServer4/commit/21d0da227f50ac102de469a13bc5a15d2cc0f895", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/IdentityServer/IdentityServer4/issues/2164", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/IdentityServer/IdentityServer4/releases/tag/1.5.3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/IdentityServer/IdentityServer4/releases/tag/2.1.3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/IdentityServer/IdentityServer4/commit/21d0da227f50ac102de469a13bc5a15d2cc0f895"}}