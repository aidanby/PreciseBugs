{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                              CCC  U   U  TTTTT                              %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                              CCC   UUU     T                                %\n%                                                                             %\n%                                                                             %\n%                         Read DR Halo Image Format                           %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n{\n  unsigned Width;\n  unsigned Height;\n  unsigned Reserved;\n} CUTHeader;\n\ntypedef struct\n{\n  char FileId[2];\n  unsigned Version;\n  unsigned Size;\n  char FileType;\n  char SubType;\n  unsigned BoardID;\n  unsigned GraphicsMode;\n  unsigned MaxIndex;\n  unsigned MaxRed;\n  unsigned MaxGreen;\n  unsigned MaxBlue;\n  char PaletteId[20];\n} CUTPalHeader;\n\n\f\nstatic void InsertRow(Image *image,ssize_t depth,unsigned char *p,ssize_t y,\n  ExceptionInfo *exception)\n{\n  size_t bit; ssize_t x;\n  register Quantum *q;\n  Quantum index;\n\n  index=0;\n  switch (depth)\n  {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) ((((*p) & (0x80 >> bit)) != 0) ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n            p++;\n          }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n          index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          p++;\n        }\n        if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) >= 1)\n\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) >= 2)\n\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0xf,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,*p,exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        (void) SyncAuthenticPixels(image,exception);\n        break;\n      }\n    }\n}\n\n/*\n   Compute the number of colors in Grayed R[i]=G[i]=B[i] image\n*/\nstatic int GetCutColors(Image *image,ExceptionInfo *exception)\n{\n  Quantum\n    intensity,\n    scale_intensity;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x,\n    y;\n\n  intensity=0;\n  scale_intensity=ScaleCharToQuantum(16);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (intensity < GetPixelRed(image,q))\n        intensity=GetPixelRed(image,q);\n      if (intensity >= scale_intensity)\n        return(255);\n      q+=GetPixelChannels(image);\n    }\n  }\n  if (intensity < ScaleCharToQuantum(2))\n    return(2);\n  if (intensity < ScaleCharToQuantum(16))\n    return(16);\n  return((int) intensity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C U T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCUTImage() reads an CUT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadCUTImage method is:\n%\n%      Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowCUTReaderException(severity,tag) \\\n{ \\\n  if (palette != NULL) \\\n    palette=DestroyImage(palette); \\\n  if (clone_info != NULL) \\\n    clone_info=DestroyImageInfo(clone_info); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  register Quantum *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n  image->depth=8;\n  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n\n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (palette != NULL) \n        palette=DestroyImage(palette); \n      if (clone_info != NULL) \n        clone_info=DestroyImageInfo(clone_info); \n      return(DestroyImageList(image));\n    }\n\n  /* ----- Do something with palette ----- */\n  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MagickPathExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MagickPathExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n        NoMemory:\n          ThrowCUTReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n  if(BImgBuff==NULL) goto NoMemory;\n\n  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n  if (offset < 0)\n    {\n      if (palette != NULL)\n        palette=DestroyImage(palette);\n      if (clone_info != NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(image,depth,BImgBuff,i,exception);\n    }\n  (void) SyncImage(image,exception);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (SetImageGray(image,exception) != MagickFalse))\n        {\n          if(GetCutColors(image,exception)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(image,QuantumRange,q);\n                          SetPixelGreen(image,QuantumRange,q);\n                          SetPixelBlue(image,QuantumRange,q);\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C U T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCUTImage() adds attributes for the CUT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterCUTImage method is:\n%\n%      size_t RegisterCUTImage(void)\n%\n*/\nModuleExport size_t RegisterCUTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CUT\",\"CUT\",\"DR Halo\");\n  entry->decoder=(DecodeImageHandler *) ReadCUTImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C U T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCUTImage() removes format registrations made by the\n%  CUT module from the list of supported formats.\n%\n%  The format of the UnregisterCUTImage method is:\n%\n%      UnregisterCUTImage(void)\n%\n*/\nModuleExport void UnregisterCUTImage(void)\n{\n  (void) UnregisterMagickInfo(\"CUT\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                              CCC  U   U  TTTTT                              %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                              CCC   UUU     T                                %\n%                                                                             %\n%                                                                             %\n%                         Read DR Halo Image Format                           %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n{\n  unsigned Width;\n  unsigned Height;\n  unsigned Reserved;\n} CUTHeader;\n\ntypedef struct\n{\n  char FileId[2];\n  unsigned Version;\n  unsigned Size;\n  char FileType;\n  char SubType;\n  unsigned BoardID;\n  unsigned GraphicsMode;\n  unsigned MaxIndex;\n  unsigned MaxRed;\n  unsigned MaxGreen;\n  unsigned MaxBlue;\n  char PaletteId[20];\n} CUTPalHeader;\n\n\f\nstatic MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,\n  ssize_t y,ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return(MagickFalse);\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              if (index < image->colors)\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            p++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) > 1)\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                if (index < image->colors)\n                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) > 2)\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    if (index < image->colors)\n                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n                        index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n      }\n      break;\n\n    case 24:     /*  Convert DirectColor scanline.  */\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n  if (!SyncAuthenticPixels(image,exception))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\n/*\n   Compute the number of colors in Grayed R[i]=G[i]=B[i] image\n*/\nstatic int GetCutColors(Image *image,ExceptionInfo *exception)\n{\n  Quantum\n    intensity,\n    scale_intensity;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x,\n    y;\n\n  intensity=0;\n  scale_intensity=ScaleCharToQuantum(16);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (intensity < GetPixelRed(image,q))\n        intensity=GetPixelRed(image,q);\n      if (intensity >= scale_intensity)\n        return(255);\n      q+=GetPixelChannels(image);\n    }\n  }\n  if (intensity < ScaleCharToQuantum(2))\n    return(2);\n  if (intensity < ScaleCharToQuantum(16))\n    return(16);\n  return((int) intensity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C U T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCUTImage() reads an CUT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadCUTImage method is:\n%\n%      Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowCUTReaderException(severity,tag) \\\n{ \\\n  if (palette != NULL) \\\n    palette=DestroyImage(palette); \\\n  if (clone_info != NULL) \\\n    clone_info=DestroyImageInfo(clone_info); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  register Quantum *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n  image->depth=8;\n  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n\n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (palette != NULL) \n        palette=DestroyImage(palette); \n      if (clone_info != NULL) \n        clone_info=DestroyImageInfo(clone_info); \n      return(DestroyImageList(image));\n    }\n\n  /* ----- Do something with palette ----- */\n  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MagickPathExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MagickPathExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n        NoMemory:\n          ThrowCUTReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n  if(BImgBuff==NULL) goto NoMemory;\n\n  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n  if (offset < 0)\n    {\n      if (palette != NULL)\n        palette=DestroyImage(palette);\n      if (clone_info != NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(image,depth,BImgBuff,i,exception);\n    }\n  (void) SyncImage(image,exception);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (SetImageGray(image,exception) != MagickFalse))\n        {\n          if(GetCutColors(image,exception)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(image,QuantumRange,q);\n                          SetPixelGreen(image,QuantumRange,q);\n                          SetPixelBlue(image,QuantumRange,q);\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C U T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCUTImage() adds attributes for the CUT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterCUTImage method is:\n%\n%      size_t RegisterCUTImage(void)\n%\n*/\nModuleExport size_t RegisterCUTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CUT\",\"CUT\",\"DR Halo\");\n  entry->decoder=(DecodeImageHandler *) ReadCUTImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C U T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCUTImage() removes format registrations made by the\n%  CUT module from the list of supported formats.\n%\n%  The format of the UnregisterCUTImage method is:\n%\n%      UnregisterCUTImage(void)\n%\n*/\nModuleExport void UnregisterCUTImage(void)\n{\n  (void) UnregisterMagickInfo(\"CUT\");\n}\n"], "filenames": ["coders/cut.c"], "buggy_code_start_loc": [101], "buggy_code_end_loc": [227], "fixing_code_start_loc": [101], "fixing_code_end_loc": [260], "type": "CWE-787", "message": "The function InsertRow in coders/cut.c in ImageMagick 7.0.7-37 allows remote attackers to cause a denial of service via a crafted image file due to an out-of-bounds write.", "other": {"cve": {"id": "CVE-2018-16642", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-06T22:29:00.880", "lastModified": "2018-10-25T19:02:33.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The function InsertRow in coders/cut.c in ImageMagick 7.0.7-37 allows remote attackers to cause a denial of service via a crafted image file due to an out-of-bounds write."}, {"lang": "es", "value": "La funci\u00f3n InsertRow en coders/cut.c en ImageMagick 7.0.7-37 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (DoS) mediante un archivo de imagen manipulado debido a una escritura fuera de l\u00edmites."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.7-37:*:*:*:*:*:*:*", "matchCriteriaId": "B2F5B824-B05B-4E7E-83E0-17F9B4408A49"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1162", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00002.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3785-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4316", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e"}}