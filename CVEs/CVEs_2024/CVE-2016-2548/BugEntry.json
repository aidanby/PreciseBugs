{"buggy_code": ["/*\n *  Timers abstract layer\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/timer.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n\n#if IS_ENABLED(CONFIG_SND_HRTIMER)\n#define DEFAULT_TIMER_LIMIT 4\n#elif IS_ENABLED(CONFIG_SND_RTCTIMER)\n#define DEFAULT_TIMER_LIMIT 2\n#else\n#define DEFAULT_TIMER_LIMIT 1\n#endif\n\nstatic int timer_limit = DEFAULT_TIMER_LIMIT;\nstatic int timer_tstamp_monotonic = 1;\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA timer interface\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(timer_limit, int, 0444);\nMODULE_PARM_DESC(timer_limit, \"Maximum global timers in system.\");\nmodule_param(timer_tstamp_monotonic, int, 0444);\nMODULE_PARM_DESC(timer_tstamp_monotonic, \"Use posix monotonic clock source for timestamps (default).\");\n\nMODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);\nMODULE_ALIAS(\"devname:snd/timer\");\n\nstruct snd_timer_user {\n\tstruct snd_timer_instance *timeri;\n\tint tread;\t\t/* enhanced read with timestamps and events */\n\tunsigned long ticks;\n\tunsigned long overrun;\n\tint qhead;\n\tint qtail;\n\tint qused;\n\tint queue_size;\n\tstruct snd_timer_read *queue;\n\tstruct snd_timer_tread *tqueue;\n\tspinlock_t qlock;\n\tunsigned long last_resolution;\n\tunsigned int filter;\n\tstruct timespec tstamp;\t\t/* trigger tstamp */\n\twait_queue_head_t qchange_sleep;\n\tstruct fasync_struct *fasync;\n\tstruct mutex ioctl_lock;\n};\n\n/* list of timers */\nstatic LIST_HEAD(snd_timer_list);\n\n/* list of slave instances */\nstatic LIST_HEAD(snd_timer_slave_list);\n\n/* lock for slave active lists */\nstatic DEFINE_SPINLOCK(slave_active_lock);\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int snd_timer_free(struct snd_timer *timer);\nstatic int snd_timer_dev_free(struct snd_device *device);\nstatic int snd_timer_dev_register(struct snd_device *device);\nstatic int snd_timer_dev_disconnect(struct snd_device *device);\n\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);\n\n/*\n * create a timer instance with the given owner string.\n * when timer is not NULL, increments the module counter\n */\nstatic struct snd_timer_instance *snd_timer_instance_new(char *owner,\n\t\t\t\t\t\t\t struct snd_timer *timer)\n{\n\tstruct snd_timer_instance *timeri;\n\ttimeri = kzalloc(sizeof(*timeri), GFP_KERNEL);\n\tif (timeri == NULL)\n\t\treturn NULL;\n\ttimeri->owner = kstrdup(owner, GFP_KERNEL);\n\tif (! timeri->owner) {\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&timeri->open_list);\n\tINIT_LIST_HEAD(&timeri->active_list);\n\tINIT_LIST_HEAD(&timeri->ack_list);\n\tINIT_LIST_HEAD(&timeri->slave_list_head);\n\tINIT_LIST_HEAD(&timeri->slave_active_head);\n\n\ttimeri->timer = timer;\n\tif (timer && !try_module_get(timer->module)) {\n\t\tkfree(timeri->owner);\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\n\treturn timeri;\n}\n\n/*\n * find a timer instance from the given timer id\n */\nstatic struct snd_timer *snd_timer_find(struct snd_timer_id *tid)\n{\n\tstruct snd_timer *timer = NULL;\n\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->tmr_class != tid->dev_class)\n\t\t\tcontinue;\n\t\tif ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||\n\t\t     timer->tmr_class == SNDRV_TIMER_CLASS_PCM) &&\n\t\t    (timer->card == NULL ||\n\t\t     timer->card->number != tid->card))\n\t\t\tcontinue;\n\t\tif (timer->tmr_device != tid->device)\n\t\t\tcontinue;\n\t\tif (timer->tmr_subdevice != tid->subdevice)\n\t\t\tcontinue;\n\t\treturn timer;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_MODULES\n\nstatic void snd_timer_request(struct snd_timer_id *tid)\n{\n\tswitch (tid->dev_class) {\n\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\tif (tid->device < timer_limit)\n\t\t\trequest_module(\"snd-timer-%i\", tid->device);\n\t\tbreak;\n\tcase SNDRV_TIMER_CLASS_CARD:\n\tcase SNDRV_TIMER_CLASS_PCM:\n\t\tif (tid->card < snd_ecards_limit)\n\t\t\trequest_module(\"snd-card-%i\", tid->card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#endif\n\n/*\n * look for a master instance matching with the slave id of the given slave.\n * when found, relink the open_link of the slave.\n *\n * call this with register_mutex down.\n */\nstatic void snd_timer_check_slave(struct snd_timer_instance *slave)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *master;\n\n\t/* FIXME: it's really dumb to look up all entries.. */\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tlist_for_each_entry(master, &timer->open_list_head, open_list) {\n\t\t\tif (slave->slave_class == master->slave_class &&\n\t\t\t    slave->slave_id == master->slave_id) {\n\t\t\t\tlist_move_tail(&slave->open_list,\n\t\t\t\t\t       &master->slave_list_head);\n\t\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t\tslave->master = master;\n\t\t\t\tslave->timer = master->timer;\n\t\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * look for slave instances matching with the slave id of the given master.\n * when found, relink the open_link of slaves.\n *\n * call this with register_mutex down.\n */\nstatic void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t/* check all pending slaves */\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}\n\n/*\n * open a timer instance\n * when opening a master, the slave id must be here given.\n */\nint snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&register_mutex);\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\tsnd_timer_check_slave(timeri);\n\t\tmutex_unlock(&register_mutex);\n\t\t*ti = timeri;\n\t\treturn 0;\n\t}\n\n\t/* open a master instance */\n\tmutex_lock(&register_mutex);\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENODEV;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\ttimeri = list_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENOMEM;\n\t}\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\tif (list_empty(&timer->open_list_head) && timer->hw.open)\n\t\ttimer->hw.open(timer);\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\tsnd_timer_check_master(timeri);\n\tmutex_unlock(&register_mutex);\n\t*ti = timeri;\n\treturn 0;\n}\n\nstatic int _snd_timer_stop(struct snd_timer_instance *timeri,\n\t\t\t   int keep_flag, int event);\n\n/*\n * close a timer instance\n */\nint snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n\t\t    timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* remove slave links */\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t\tmutex_unlock(&register_mutex);\n\t}\n out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n\nunsigned long snd_timer_resolution(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer * timer;\n\n\tif (timeri == NULL)\n\t\treturn 0;\n\tif ((timer = timeri->timer) != NULL) {\n\t\tif (timer->hw.c_resolution)\n\t\t\treturn timer->hw.c_resolution(timer);\n\t\treturn timer->hw.resolution;\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_notify1(struct snd_timer_instance *ti, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ts;\n\tstruct timespec tstamp;\n\n\tif (timer_tstamp_monotonic)\n\t\tktime_get_ts(&tstamp);\n\telse\n\t\tgetnstimeofday(&tstamp);\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||\n\t\t       event > SNDRV_TIMER_EVENT_PAUSE))\n\t\treturn;\n\tif (event == SNDRV_TIMER_EVENT_START ||\n\t    event == SNDRV_TIMER_EVENT_CONTINUE)\n\t\tresolution = snd_timer_resolution(ti);\n\tif (ti->ccallback)\n\t\tti->ccallback(ti, event, &tstamp, resolution);\n\tif (ti->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn;\n\ttimer = ti->timer;\n\tif (timer == NULL)\n\t\treturn;\n\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\tif (ts->ccallback)\n\t\t\tts->ccallback(ti, event + 100, &tstamp, resolution);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\nstatic int snd_timer_start1(struct snd_timer *timer, struct snd_timer_instance *timeri,\n\t\t\t    unsigned long sticks)\n{\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\treturn 1;\t/* delayed start */\n\t} else {\n\t\ttimer->sticks = sticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\treturn 0;\n\t}\n}\n\nstatic int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}\n\n/*\n *  start the timer instance\n */\nint snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)\n{\n\tstruct snd_timer *timer;\n\tint result = -EINVAL;\n\tunsigned long flags;\n\n\tif (timeri == NULL || ticks < 1)\n\t\treturn -EINVAL;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tresult = snd_timer_start_slave(timeri);\n\t\tsnd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);\n\t\treturn result;\n\t}\n\ttimer = timeri->timer;\n\tif (timer == NULL)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\ttimeri->ticks = timeri->cticks = ticks;\n\ttimeri->pticks = 0;\n\tresult = snd_timer_start1(timer, timeri, ticks);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\tsnd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);\n\treturn result;\n}\n\nstatic int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tif (!keep_flag) {\n\t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n\t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\t\t}\n\t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}\n\n/*\n * stop the timer instance.\n *\n * do not call this from the timer callback!\n */\nint snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\tint err;\n\n\terr = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);\n\tif (err < 0)\n\t\treturn err;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\ttimeri->cticks = timeri->ticks;\n\ttimeri->pticks = 0;\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn 0;\n}\n\n/*\n * start again..  the tick is kept.\n */\nint snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer;\n\tint result = -EINVAL;\n\tunsigned long flags;\n\n\tif (timeri == NULL)\n\t\treturn result;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri);\n\ttimer = timeri->timer;\n\tif (! timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tresult = snd_timer_start1(timer, timeri, timer->sticks);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\tsnd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);\n\treturn result;\n}\n\n/*\n * pause.. remember the ticks left\n */\nint snd_timer_pause(struct snd_timer_instance * timeri)\n{\n\treturn _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);\n}\n\n/*\n * reschedule the timer\n *\n * start pending instances and check the scheduling ticks.\n * when the scheduling ticks is changed set CHANGE flag to reprogram the timer.\n */\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long ticks = ~0UL;\n\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_START) {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_START;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\t\ttimer->running++;\n\t\t}\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\t\tif (ticks > ti->cticks)\n\t\t\t\tticks = ti->cticks;\n\t\t}\n\t}\n\tif (ticks == ~0UL) {\n\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\treturn;\n\t}\n\tif (ticks > timer->hw.ticks)\n\t\tticks = timer->hw.ticks;\n\tif (ticks_left != ticks)\n\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\ttimer->sticks = ticks;\n}\n\n/*\n * timer tasklet\n *\n */\nstatic void snd_timer_tasklet(unsigned long arg)\n{\n\tstruct snd_timer *timer = (struct snd_timer *) arg;\n\tstruct snd_timer_instance *ti;\n\tstruct list_head *p;\n\tunsigned long resolution, ticks;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\t/* now process all callbacks */\n\twhile (!list_empty(&timer->sack_list_head)) {\n\t\tp = timer->sack_list_head.next;\t\t/* get first item */\n\t\tti = list_entry(p, struct snd_timer_instance, ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(p);\n\n\t\tticks = ti->pticks;\n\t\tti->pticks = 0;\n\t\tresolution = ti->resolution;\n\n\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\tspin_unlock(&timer->lock);\n\t\tif (ti->callback)\n\t\t\tti->callback(ti, resolution, ticks);\n\t\tspin_lock(&timer->lock);\n\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * timer interrupt\n *\n * ticks_left is usually equal to timer->sticks.\n *\n */\nvoid snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution, ticks;\n\tstruct list_head *p, *ack_list_head;\n\tunsigned long flags;\n\tint use_tasklet = 0;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t/* remember the current resolution */\n\tif (timer->hw.c_resolution)\n\t\tresolution = timer->hw.c_resolution(timer);\n\telse\n\t\tresolution = timer->hw.resolution;\n\n\t/* loop for all active instances\n\t * Here we cannot use list_for_each_entry because the active_list of a\n\t * processed instance is relinked to done_list_head before the callback\n\t * is called.\n\t */\n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks) /* not expired */\n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n\t\t} else {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tif (--timer->running)\n\t\t\t\tlist_del_init(&ti->active_list);\n\t\t}\n\t\tif ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||\n\t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t/* restart timer */\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t/* now process all fast callbacks */\n\twhile (!list_empty(&timer->ack_list_head)) {\n\t\tp = timer->ack_list_head.next;\t\t/* get first item */\n\t\tti = list_entry(p, struct snd_timer_instance, ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(p);\n\n\t\tticks = ti->pticks;\n\t\tti->pticks = 0;\n\n\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\tspin_unlock(&timer->lock);\n\t\tif (ti->callback)\n\t\t\tti->callback(ti, resolution, ticks);\n\t\tspin_lock(&timer->lock);\n\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t}\n\n\t/* do we have any slow callbacks? */\n\tuse_tasklet = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_tasklet)\n\t\ttasklet_schedule(&timer->task_queue);\n}\n\n/*\n\n */\n\nint snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,\n\t\t  struct snd_timer **rtimer)\n{\n\tstruct snd_timer *timer;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_timer_dev_free,\n\t\t.dev_register = snd_timer_dev_register,\n\t\t.dev_disconnect = snd_timer_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!tid))\n\t\treturn -EINVAL;\n\tif (rtimer)\n\t\t*rtimer = NULL;\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\ttimer->tmr_class = tid->dev_class;\n\ttimer->card = card;\n\ttimer->tmr_device = tid->device;\n\ttimer->tmr_subdevice = tid->subdevice;\n\tif (id)\n\t\tstrlcpy(timer->id, id, sizeof(timer->id));\n\tINIT_LIST_HEAD(&timer->device_list);\n\tINIT_LIST_HEAD(&timer->open_list_head);\n\tINIT_LIST_HEAD(&timer->active_list_head);\n\tINIT_LIST_HEAD(&timer->ack_list_head);\n\tINIT_LIST_HEAD(&timer->sack_list_head);\n\tspin_lock_init(&timer->lock);\n\ttasklet_init(&timer->task_queue, snd_timer_tasklet,\n\t\t     (unsigned long)timer);\n\tif (card != NULL) {\n\t\ttimer->module = card->module;\n\t\terr = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_free(timer);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (rtimer)\n\t\t*rtimer = timer;\n\treturn 0;\n}\n\nstatic int snd_timer_free(struct snd_timer *timer)\n{\n\tif (!timer)\n\t\treturn 0;\n\n\tmutex_lock(&register_mutex);\n\tif (! list_empty(&timer->open_list_head)) {\n\t\tstruct list_head *p, *n;\n\t\tstruct snd_timer_instance *ti;\n\t\tpr_warn(\"ALSA: timer %p is busy?\\n\", timer);\n\t\tlist_for_each_safe(p, n, &timer->open_list_head) {\n\t\t\tlist_del_init(p);\n\t\t\tti = list_entry(p, struct snd_timer_instance, open_list);\n\t\t\tti->timer = NULL;\n\t\t}\n\t}\n\tlist_del(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\n\tif (timer->private_free)\n\t\ttimer->private_free(timer);\n\tkfree(timer);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_free(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\treturn snd_timer_free(timer);\n}\n\nstatic int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t/* conflicts.. */\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nvoid snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME) {\n\t\tif (timer->hw.c_resolution)\n\t\t\tresolution = timer->hw.c_resolution(timer);\n\t\telse\n\t\t\tresolution = timer->hw.resolution;\n\t}\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * exported functions for global timers\n */\nint snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}\n\nint snd_timer_global_free(struct snd_timer *timer)\n{\n\treturn snd_timer_free(timer);\n}\n\nint snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}\n\n/*\n *  System timer\n */\n\nstruct snd_timer_system_private {\n\tstruct timer_list tlist;\n\tunsigned long last_expires;\n\tunsigned long last_jiffies;\n\tunsigned long correction;\n};\n\nstatic void snd_timer_s_function(unsigned long data)\n{\n\tstruct snd_timer *timer = (struct snd_timer *)data;\n\tstruct snd_timer_system_private *priv = timer->private_data;\n\tunsigned long jiff = jiffies;\n\tif (time_after(jiff, priv->last_expires))\n\t\tpriv->correction += (long)jiff - (long)priv->last_expires;\n\tsnd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);\n}\n\nstatic int snd_timer_s_start(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long njiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tnjiff = (priv->last_jiffies = jiffies);\n\tif (priv->correction > timer->sticks - 1) {\n\t\tpriv->correction -= timer->sticks - 1;\n\t\tnjiff++;\n\t} else {\n\t\tnjiff += timer->sticks - priv->correction;\n\t\tpriv->correction = 0;\n\t}\n\tpriv->last_expires = priv->tlist.expires = njiff;\n\tadd_timer(&priv->tlist);\n\treturn 0;\n}\n\nstatic int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}\n\nstatic struct snd_timer_hardware snd_timer_system =\n{\n\t.flags =\tSNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,\n\t.resolution =\t1000000000L / HZ,\n\t.ticks =\t10000000L,\n\t.start =\tsnd_timer_s_start,\n\t.stop =\t\tsnd_timer_s_stop\n};\n\nstatic void snd_timer_free_system(struct snd_timer *timer)\n{\n\tkfree(timer->private_data);\n}\n\nstatic int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tsetup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n/*\n *  Info interface\n */\n\nstatic void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_timer_proc_entry;\n\nstatic void __init snd_timer_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"timers\", NULL);\n\tif (entry != NULL) {\n\t\tentry->c.text.read = snd_timer_proc_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_timer_proc_entry = entry;\n}\n\nstatic void __exit snd_timer_proc_done(void)\n{\n\tsnd_info_free_entry(snd_timer_proc_entry);\n}\n#else /* !CONFIG_SND_PROC_FS */\n#define snd_timer_proc_init()\n#define snd_timer_proc_done()\n#endif\n\n/*\n *  USER SPACE interface\n */\n\nstatic void snd_timer_user_interrupt(struct snd_timer_instance *timeri,\n\t\t\t\t     unsigned long resolution,\n\t\t\t\t     unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_read *r;\n\tint prev;\n\n\tspin_lock(&tu->qlock);\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->queue[prev];\n\t\tif (r->resolution == resolution) {\n\t\t\tr->ticks += ticks;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tr = &tu->queue[tu->qtail++];\n\t\ttu->qtail %= tu->queue_size;\n\t\tr->resolution = resolution;\n\t\tr->ticks = ticks;\n\t\ttu->qused++;\n\t}\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,\n\t\t\t\t\t    struct snd_timer_tread *tread)\n{\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tmemcpy(&tu->tqueue[tu->qtail++], tread, sizeof(*tread));\n\t\ttu->qtail %= tu->queue_size;\n\t\ttu->qused++;\n\t}\n}\n\nstatic void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n\nstatic int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_user_zero_id(struct snd_timer_id *id)\n{\n\tid->dev_class = SNDRV_TIMER_CLASS_NONE;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = -1;\n\tid->device = -1;\n\tid->subdevice = -1;\n}\n\nstatic void snd_timer_user_copy_id(struct snd_timer_id *id, struct snd_timer *timer)\n{\n\tid->dev_class = timer->tmr_class;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = timer->card ? timer->card->number : -1;\n\tid->device = timer->tmr_device;\n\tid->subdevice = timer->tmr_subdevice;\n}\n\nstatic int snd_timer_user_next_device(struct snd_timer_id __user *_tid)\n{\n\tstruct snd_timer_id id;\n\tstruct snd_timer *timer;\n\tstruct list_head *p;\n\n\tif (copy_from_user(&id, _tid, sizeof(id)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tif (id.dev_class < 0) {\t\t/* first item */\n\t\tif (list_empty(&snd_timer_list))\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\telse {\n\t\t\ttimer = list_entry(snd_timer_list.next,\n\t\t\t\t\t   struct snd_timer, device_list);\n\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t}\n\t} else {\n\t\tswitch (id.dev_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tid.device = id.device < 0 ? 0 : id.device + 1;\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device >= id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tif (id.card < 0) {\n\t\t\t\tid.card = 0;\n\t\t\t} else {\n\t\t\t\tif (id.card < 0) {\n\t\t\t\t\tid.card = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (id.device < 0) {\n\t\t\t\t\t\tid.device = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (id.subdevice < 0) {\n\t\t\t\t\t\t\tid.subdevice = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tid.subdevice++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > id.dev_class) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_class < id.dev_class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->card->number > id.card) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->card->number < id.card)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_device > id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device < id.device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_subdevice > id.subdevice) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_subdevice < id.subdevice)\n\t\t\t\t\tcontinue;\n\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\t}\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (copy_to_user(_tid, &id, sizeof(*_tid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_ginfo(struct file *file,\n\t\t\t\tstruct snd_timer_ginfo __user *_ginfo)\n{\n\tstruct snd_timer_ginfo *ginfo;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tginfo = memdup_user(_ginfo, sizeof(*ginfo));\n\tif (IS_ERR(ginfo))\n\t\treturn PTR_ERR(ginfo);\n\n\ttid = ginfo->tid;\n\tmemset(ginfo, 0, sizeof(*ginfo));\n\tginfo->tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tginfo->card = t->card ? t->card->number : -1;\n\t\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tginfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\t\tstrlcpy(ginfo->id, t->id, sizeof(ginfo->id));\n\t\tstrlcpy(ginfo->name, t->name, sizeof(ginfo->name));\n\t\tginfo->resolution = t->hw.resolution;\n\t\tif (t->hw.resolution_min > 0) {\n\t\t\tginfo->resolution_min = t->hw.resolution_min;\n\t\t\tginfo->resolution_max = t->hw.resolution_max;\n\t\t}\n\t\tlist_for_each(p, &t->open_list_head) {\n\t\t\tginfo->clients++;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))\n\t\terr = -EFAULT;\n\tkfree(ginfo);\n\treturn err;\n}\n\nstatic int snd_timer_user_gparams(struct file *file,\n\t\t\t\t  struct snd_timer_gparams __user *_gparams)\n{\n\tstruct snd_timer_gparams gparams;\n\tstruct snd_timer *t;\n\tint err;\n\n\tif (copy_from_user(&gparams, _gparams, sizeof(gparams)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&gparams.tid);\n\tif (!t) {\n\t\terr = -ENODEV;\n\t\tgoto _error;\n\t}\n\tif (!list_empty(&t->open_list_head)) {\n\t\terr = -EBUSY;\n\t\tgoto _error;\n\t}\n\tif (!t->hw.set_period) {\n\t\terr = -ENOSYS;\n\t\tgoto _error;\n\t}\n\terr = t->hw.set_period(t, gparams.period_num, gparams.period_den);\n_error:\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_timer_user_gstatus(struct file *file,\n\t\t\t\t  struct snd_timer_gstatus __user *_gstatus)\n{\n\tstruct snd_timer_gstatus gstatus;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\tif (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))\n\t\treturn -EFAULT;\n\ttid = gstatus.tid;\n\tmemset(&gstatus, 0, sizeof(gstatus));\n\tgstatus.tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tif (t->hw.c_resolution)\n\t\t\tgstatus.resolution = t->hw.c_resolution(t);\n\t\telse\n\t\t\tgstatus.resolution = t->hw.resolution;\n\t\tif (t->hw.precise_resolution) {\n\t\t\tt->hw.precise_resolution(t, &gstatus.resolution_num,\n\t\t\t\t\t\t &gstatus.resolution_den);\n\t\t} else {\n\t\t\tgstatus.resolution_num = gstatus.resolution;\n\t\t\tgstatus.resolution_den = 1000000000uL;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n\n      __err:\n\treturn err;\n}\n\nstatic int snd_timer_user_info(struct file *file,\n\t\t\t       struct snd_timer_info __user *_info)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_info *info;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tinfo->card = t->card ? t->card->number : -1;\n\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\tinfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\tstrlcpy(info->id, t->id, sizeof(info->id));\n\tstrlcpy(info->name, t->name, sizeof(info->name));\n\tinfo->resolution = t->hw.resolution;\n\tif (copy_to_user(_info, info, sizeof(*_info)))\n\t\terr = -EFAULT;\n\tkfree(info);\n\treturn err;\n}\n\nstatic int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tstruct snd_timer_read *tr;\n\tstruct snd_timer_tread *ttr;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\tif (tu->tread) {\n\t\t\tttr = kmalloc(params.queue_size * sizeof(*ttr),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (ttr) {\n\t\t\t\tkfree(tu->tqueue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->tqueue = ttr;\n\t\t\t}\n\t\t} else {\n\t\t\ttr = kmalloc(params.queue_size * sizeof(*tr),\n\t\t\t\t     GFP_KERNEL);\n\t\t\tif (tr) {\n\t\t\t\tkfree(tu->queue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->queue = tr;\n\t\t\t}\n\t\t}\n\t}\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread tread;\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp.tv_sec = 0;\n\t\t\ttread.tstamp.tv_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_status(struct file *file,\n\t\t\t\t struct snd_timer_status __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp = tu->tstamp;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_start(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tsnd_timer_stop(tu->timeri);\n\ttu->timeri->lost = 0;\n\ttu->last_resolution = 0;\n\treturn (err = snd_timer_start(tu->timeri, tu->ticks)) < 0 ? err : 0;\n}\n\nstatic int snd_timer_user_stop(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\treturn (err = snd_timer_stop(tu->timeri)) < 0 ? err : 0;\n}\n\nstatic int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\ttu->timeri->lost = 0;\n\treturn (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;\n}\n\nstatic int snd_timer_user_pause(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\treturn (err = snd_timer_pause(tu->timeri)) < 0 ? err : 0;\n}\n\nenum {\n\tSNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),\n\tSNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),\n\tSNDRV_TIMER_IOCTL_CONTINUE_OLD = _IO('T', 0x22),\n\tSNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),\n};\n\nstatic long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\n\t\tif (tu->timeri)\t/* too late */\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}\n\nstatic int snd_timer_user_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\treturn fasync_helper(fd, file, on, &tu->fasync);\n}\n\nstatic ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[tu->qhead++],\n\t\t\t\t\t sizeof(struct snd_timer_tread))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[tu->qhead++],\n\t\t\t\t\t sizeof(struct snd_timer_read))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\ttu->qhead %= tu->queue_size;\n\n\t\tresult += unit;\n\t\tbuffer += unit;\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\ttu->qused--;\n\t}\n\tspin_unlock_irq(&tu->qlock);\n _error:\n\treturn result > 0 ? result : err;\n}\n\nstatic unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)\n{\n        unsigned int mask;\n        struct snd_timer_user *tu;\n\n        tu = file->private_data;\n\n        poll_wait(file, &tu->qchange_sleep, wait);\n\n\tmask = 0;\n\tif (tu->qused)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"timer_compat.c\"\n#else\n#define snd_timer_user_ioctl_compat\tNULL\n#endif\n\nstatic const struct file_operations snd_timer_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_timer_user_read,\n\t.open =\t\tsnd_timer_user_open,\n\t.release =\tsnd_timer_user_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_timer_user_poll,\n\t.unlocked_ioctl =\tsnd_timer_user_ioctl,\n\t.compat_ioctl =\tsnd_timer_user_ioctl_compat,\n\t.fasync = \tsnd_timer_user_fasync,\n};\n\n/* unregister the system timer */\nstatic void snd_timer_free_all(void)\n{\n\tstruct snd_timer *timer, *n;\n\n\tlist_for_each_entry_safe(timer, n, &snd_timer_list, device_list)\n\t\tsnd_timer_free(timer);\n}\n\nstatic struct device timer_dev;\n\n/*\n *  ENTRY functions\n */\n\nstatic int __init alsa_timer_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&timer_dev, NULL);\n\tdev_set_name(&timer_dev, \"timer\");\n\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,\n\t\t\t      \"system timer\");\n#endif\n\n\terr = snd_timer_register_system();\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register system timer (%i)\\n\", err);\n\t\tput_device(&timer_dev);\n\t\treturn err;\n\t}\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,\n\t\t\t\t  &snd_timer_f_ops, NULL, &timer_dev);\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register timer device (%i)\\n\", err);\n\t\tsnd_timer_free_all();\n\t\tput_device(&timer_dev);\n\t\treturn err;\n\t}\n\n\tsnd_timer_proc_init();\n\treturn 0;\n}\n\nstatic void __exit alsa_timer_exit(void)\n{\n\tsnd_unregister_device(&timer_dev);\n\tsnd_timer_free_all();\n\tput_device(&timer_dev);\n\tsnd_timer_proc_done();\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);\n#endif\n}\n\nmodule_init(alsa_timer_init)\nmodule_exit(alsa_timer_exit)\n\nEXPORT_SYMBOL(snd_timer_open);\nEXPORT_SYMBOL(snd_timer_close);\nEXPORT_SYMBOL(snd_timer_resolution);\nEXPORT_SYMBOL(snd_timer_start);\nEXPORT_SYMBOL(snd_timer_stop);\nEXPORT_SYMBOL(snd_timer_continue);\nEXPORT_SYMBOL(snd_timer_pause);\nEXPORT_SYMBOL(snd_timer_new);\nEXPORT_SYMBOL(snd_timer_notify);\nEXPORT_SYMBOL(snd_timer_global_new);\nEXPORT_SYMBOL(snd_timer_global_free);\nEXPORT_SYMBOL(snd_timer_global_register);\nEXPORT_SYMBOL(snd_timer_interrupt);\n"], "fixing_code": ["/*\n *  Timers abstract layer\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/timer.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n\n#if IS_ENABLED(CONFIG_SND_HRTIMER)\n#define DEFAULT_TIMER_LIMIT 4\n#elif IS_ENABLED(CONFIG_SND_RTCTIMER)\n#define DEFAULT_TIMER_LIMIT 2\n#else\n#define DEFAULT_TIMER_LIMIT 1\n#endif\n\nstatic int timer_limit = DEFAULT_TIMER_LIMIT;\nstatic int timer_tstamp_monotonic = 1;\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA timer interface\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(timer_limit, int, 0444);\nMODULE_PARM_DESC(timer_limit, \"Maximum global timers in system.\");\nmodule_param(timer_tstamp_monotonic, int, 0444);\nMODULE_PARM_DESC(timer_tstamp_monotonic, \"Use posix monotonic clock source for timestamps (default).\");\n\nMODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);\nMODULE_ALIAS(\"devname:snd/timer\");\n\nstruct snd_timer_user {\n\tstruct snd_timer_instance *timeri;\n\tint tread;\t\t/* enhanced read with timestamps and events */\n\tunsigned long ticks;\n\tunsigned long overrun;\n\tint qhead;\n\tint qtail;\n\tint qused;\n\tint queue_size;\n\tstruct snd_timer_read *queue;\n\tstruct snd_timer_tread *tqueue;\n\tspinlock_t qlock;\n\tunsigned long last_resolution;\n\tunsigned int filter;\n\tstruct timespec tstamp;\t\t/* trigger tstamp */\n\twait_queue_head_t qchange_sleep;\n\tstruct fasync_struct *fasync;\n\tstruct mutex ioctl_lock;\n};\n\n/* list of timers */\nstatic LIST_HEAD(snd_timer_list);\n\n/* list of slave instances */\nstatic LIST_HEAD(snd_timer_slave_list);\n\n/* lock for slave active lists */\nstatic DEFINE_SPINLOCK(slave_active_lock);\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int snd_timer_free(struct snd_timer *timer);\nstatic int snd_timer_dev_free(struct snd_device *device);\nstatic int snd_timer_dev_register(struct snd_device *device);\nstatic int snd_timer_dev_disconnect(struct snd_device *device);\n\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);\n\n/*\n * create a timer instance with the given owner string.\n * when timer is not NULL, increments the module counter\n */\nstatic struct snd_timer_instance *snd_timer_instance_new(char *owner,\n\t\t\t\t\t\t\t struct snd_timer *timer)\n{\n\tstruct snd_timer_instance *timeri;\n\ttimeri = kzalloc(sizeof(*timeri), GFP_KERNEL);\n\tif (timeri == NULL)\n\t\treturn NULL;\n\ttimeri->owner = kstrdup(owner, GFP_KERNEL);\n\tif (! timeri->owner) {\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&timeri->open_list);\n\tINIT_LIST_HEAD(&timeri->active_list);\n\tINIT_LIST_HEAD(&timeri->ack_list);\n\tINIT_LIST_HEAD(&timeri->slave_list_head);\n\tINIT_LIST_HEAD(&timeri->slave_active_head);\n\n\ttimeri->timer = timer;\n\tif (timer && !try_module_get(timer->module)) {\n\t\tkfree(timeri->owner);\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\n\treturn timeri;\n}\n\n/*\n * find a timer instance from the given timer id\n */\nstatic struct snd_timer *snd_timer_find(struct snd_timer_id *tid)\n{\n\tstruct snd_timer *timer = NULL;\n\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->tmr_class != tid->dev_class)\n\t\t\tcontinue;\n\t\tif ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||\n\t\t     timer->tmr_class == SNDRV_TIMER_CLASS_PCM) &&\n\t\t    (timer->card == NULL ||\n\t\t     timer->card->number != tid->card))\n\t\t\tcontinue;\n\t\tif (timer->tmr_device != tid->device)\n\t\t\tcontinue;\n\t\tif (timer->tmr_subdevice != tid->subdevice)\n\t\t\tcontinue;\n\t\treturn timer;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_MODULES\n\nstatic void snd_timer_request(struct snd_timer_id *tid)\n{\n\tswitch (tid->dev_class) {\n\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\tif (tid->device < timer_limit)\n\t\t\trequest_module(\"snd-timer-%i\", tid->device);\n\t\tbreak;\n\tcase SNDRV_TIMER_CLASS_CARD:\n\tcase SNDRV_TIMER_CLASS_PCM:\n\t\tif (tid->card < snd_ecards_limit)\n\t\t\trequest_module(\"snd-card-%i\", tid->card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#endif\n\n/*\n * look for a master instance matching with the slave id of the given slave.\n * when found, relink the open_link of the slave.\n *\n * call this with register_mutex down.\n */\nstatic void snd_timer_check_slave(struct snd_timer_instance *slave)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *master;\n\n\t/* FIXME: it's really dumb to look up all entries.. */\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tlist_for_each_entry(master, &timer->open_list_head, open_list) {\n\t\t\tif (slave->slave_class == master->slave_class &&\n\t\t\t    slave->slave_id == master->slave_id) {\n\t\t\t\tlist_move_tail(&slave->open_list,\n\t\t\t\t\t       &master->slave_list_head);\n\t\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t\tslave->master = master;\n\t\t\t\tslave->timer = master->timer;\n\t\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * look for slave instances matching with the slave id of the given master.\n * when found, relink the open_link of slaves.\n *\n * call this with register_mutex down.\n */\nstatic void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t/* check all pending slaves */\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}\n\n/*\n * open a timer instance\n * when opening a master, the slave id must be here given.\n */\nint snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&register_mutex);\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\tsnd_timer_check_slave(timeri);\n\t\tmutex_unlock(&register_mutex);\n\t\t*ti = timeri;\n\t\treturn 0;\n\t}\n\n\t/* open a master instance */\n\tmutex_lock(&register_mutex);\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENODEV;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\ttimeri = list_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENOMEM;\n\t}\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\tif (list_empty(&timer->open_list_head) && timer->hw.open)\n\t\ttimer->hw.open(timer);\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\tsnd_timer_check_master(timeri);\n\tmutex_unlock(&register_mutex);\n\t*ti = timeri;\n\treturn 0;\n}\n\nstatic int _snd_timer_stop(struct snd_timer_instance *timeri,\n\t\t\t   int keep_flag, int event);\n\n/*\n * close a timer instance\n */\nint snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n\t\t    timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* remove slave links */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_unlock(&register_mutex);\n\t}\n out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n\nunsigned long snd_timer_resolution(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer * timer;\n\n\tif (timeri == NULL)\n\t\treturn 0;\n\tif ((timer = timeri->timer) != NULL) {\n\t\tif (timer->hw.c_resolution)\n\t\t\treturn timer->hw.c_resolution(timer);\n\t\treturn timer->hw.resolution;\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_notify1(struct snd_timer_instance *ti, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ts;\n\tstruct timespec tstamp;\n\n\tif (timer_tstamp_monotonic)\n\t\tktime_get_ts(&tstamp);\n\telse\n\t\tgetnstimeofday(&tstamp);\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||\n\t\t       event > SNDRV_TIMER_EVENT_PAUSE))\n\t\treturn;\n\tif (event == SNDRV_TIMER_EVENT_START ||\n\t    event == SNDRV_TIMER_EVENT_CONTINUE)\n\t\tresolution = snd_timer_resolution(ti);\n\tif (ti->ccallback)\n\t\tti->ccallback(ti, event, &tstamp, resolution);\n\tif (ti->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn;\n\ttimer = ti->timer;\n\tif (timer == NULL)\n\t\treturn;\n\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\tif (ts->ccallback)\n\t\t\tts->ccallback(ti, event + 100, &tstamp, resolution);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\nstatic int snd_timer_start1(struct snd_timer *timer, struct snd_timer_instance *timeri,\n\t\t\t    unsigned long sticks)\n{\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\treturn 1;\t/* delayed start */\n\t} else {\n\t\ttimer->sticks = sticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\treturn 0;\n\t}\n}\n\nstatic int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}\n\n/*\n *  start the timer instance\n */\nint snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)\n{\n\tstruct snd_timer *timer;\n\tint result = -EINVAL;\n\tunsigned long flags;\n\n\tif (timeri == NULL || ticks < 1)\n\t\treturn -EINVAL;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tresult = snd_timer_start_slave(timeri);\n\t\tsnd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);\n\t\treturn result;\n\t}\n\ttimer = timeri->timer;\n\tif (timer == NULL)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\ttimeri->ticks = timeri->cticks = ticks;\n\ttimeri->pticks = 0;\n\tresult = snd_timer_start1(timer, timeri, ticks);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\tsnd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);\n\treturn result;\n}\n\nstatic int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tif (!keep_flag) {\n\t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n\t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tlist_del_init(&timeri->ack_list);\n\t\t\tlist_del_init(&timeri->active_list);\n\t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\t\t}\n\t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}\n\n/*\n * stop the timer instance.\n *\n * do not call this from the timer callback!\n */\nint snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\tint err;\n\n\terr = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);\n\tif (err < 0)\n\t\treturn err;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\ttimeri->cticks = timeri->ticks;\n\ttimeri->pticks = 0;\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn 0;\n}\n\n/*\n * start again..  the tick is kept.\n */\nint snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer;\n\tint result = -EINVAL;\n\tunsigned long flags;\n\n\tif (timeri == NULL)\n\t\treturn result;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri);\n\ttimer = timeri->timer;\n\tif (! timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tresult = snd_timer_start1(timer, timeri, timer->sticks);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\tsnd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);\n\treturn result;\n}\n\n/*\n * pause.. remember the ticks left\n */\nint snd_timer_pause(struct snd_timer_instance * timeri)\n{\n\treturn _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);\n}\n\n/*\n * reschedule the timer\n *\n * start pending instances and check the scheduling ticks.\n * when the scheduling ticks is changed set CHANGE flag to reprogram the timer.\n */\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long ticks = ~0UL;\n\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_START) {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_START;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\t\ttimer->running++;\n\t\t}\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\t\tif (ticks > ti->cticks)\n\t\t\t\tticks = ti->cticks;\n\t\t}\n\t}\n\tif (ticks == ~0UL) {\n\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\treturn;\n\t}\n\tif (ticks > timer->hw.ticks)\n\t\tticks = timer->hw.ticks;\n\tif (ticks_left != ticks)\n\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\ttimer->sticks = ticks;\n}\n\n/*\n * timer tasklet\n *\n */\nstatic void snd_timer_tasklet(unsigned long arg)\n{\n\tstruct snd_timer *timer = (struct snd_timer *) arg;\n\tstruct snd_timer_instance *ti;\n\tstruct list_head *p;\n\tunsigned long resolution, ticks;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\t/* now process all callbacks */\n\twhile (!list_empty(&timer->sack_list_head)) {\n\t\tp = timer->sack_list_head.next;\t\t/* get first item */\n\t\tti = list_entry(p, struct snd_timer_instance, ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(p);\n\n\t\tticks = ti->pticks;\n\t\tti->pticks = 0;\n\t\tresolution = ti->resolution;\n\n\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\tspin_unlock(&timer->lock);\n\t\tif (ti->callback)\n\t\t\tti->callback(ti, resolution, ticks);\n\t\tspin_lock(&timer->lock);\n\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * timer interrupt\n *\n * ticks_left is usually equal to timer->sticks.\n *\n */\nvoid snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution, ticks;\n\tstruct list_head *p, *ack_list_head;\n\tunsigned long flags;\n\tint use_tasklet = 0;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t/* remember the current resolution */\n\tif (timer->hw.c_resolution)\n\t\tresolution = timer->hw.c_resolution(timer);\n\telse\n\t\tresolution = timer->hw.resolution;\n\n\t/* loop for all active instances\n\t * Here we cannot use list_for_each_entry because the active_list of a\n\t * processed instance is relinked to done_list_head before the callback\n\t * is called.\n\t */\n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks) /* not expired */\n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n\t\t} else {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tif (--timer->running)\n\t\t\t\tlist_del_init(&ti->active_list);\n\t\t}\n\t\tif ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||\n\t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t/* restart timer */\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t/* now process all fast callbacks */\n\twhile (!list_empty(&timer->ack_list_head)) {\n\t\tp = timer->ack_list_head.next;\t\t/* get first item */\n\t\tti = list_entry(p, struct snd_timer_instance, ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(p);\n\n\t\tticks = ti->pticks;\n\t\tti->pticks = 0;\n\n\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\tspin_unlock(&timer->lock);\n\t\tif (ti->callback)\n\t\t\tti->callback(ti, resolution, ticks);\n\t\tspin_lock(&timer->lock);\n\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t}\n\n\t/* do we have any slow callbacks? */\n\tuse_tasklet = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_tasklet)\n\t\ttasklet_schedule(&timer->task_queue);\n}\n\n/*\n\n */\n\nint snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,\n\t\t  struct snd_timer **rtimer)\n{\n\tstruct snd_timer *timer;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_timer_dev_free,\n\t\t.dev_register = snd_timer_dev_register,\n\t\t.dev_disconnect = snd_timer_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!tid))\n\t\treturn -EINVAL;\n\tif (rtimer)\n\t\t*rtimer = NULL;\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\ttimer->tmr_class = tid->dev_class;\n\ttimer->card = card;\n\ttimer->tmr_device = tid->device;\n\ttimer->tmr_subdevice = tid->subdevice;\n\tif (id)\n\t\tstrlcpy(timer->id, id, sizeof(timer->id));\n\tINIT_LIST_HEAD(&timer->device_list);\n\tINIT_LIST_HEAD(&timer->open_list_head);\n\tINIT_LIST_HEAD(&timer->active_list_head);\n\tINIT_LIST_HEAD(&timer->ack_list_head);\n\tINIT_LIST_HEAD(&timer->sack_list_head);\n\tspin_lock_init(&timer->lock);\n\ttasklet_init(&timer->task_queue, snd_timer_tasklet,\n\t\t     (unsigned long)timer);\n\tif (card != NULL) {\n\t\ttimer->module = card->module;\n\t\terr = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_free(timer);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (rtimer)\n\t\t*rtimer = timer;\n\treturn 0;\n}\n\nstatic int snd_timer_free(struct snd_timer *timer)\n{\n\tif (!timer)\n\t\treturn 0;\n\n\tmutex_lock(&register_mutex);\n\tif (! list_empty(&timer->open_list_head)) {\n\t\tstruct list_head *p, *n;\n\t\tstruct snd_timer_instance *ti;\n\t\tpr_warn(\"ALSA: timer %p is busy?\\n\", timer);\n\t\tlist_for_each_safe(p, n, &timer->open_list_head) {\n\t\t\tlist_del_init(p);\n\t\t\tti = list_entry(p, struct snd_timer_instance, open_list);\n\t\t\tti->timer = NULL;\n\t\t}\n\t}\n\tlist_del(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\n\tif (timer->private_free)\n\t\ttimer->private_free(timer);\n\tkfree(timer);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_free(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\treturn snd_timer_free(timer);\n}\n\nstatic int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t/* conflicts.. */\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nvoid snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME) {\n\t\tif (timer->hw.c_resolution)\n\t\t\tresolution = timer->hw.c_resolution(timer);\n\t\telse\n\t\t\tresolution = timer->hw.resolution;\n\t}\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * exported functions for global timers\n */\nint snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}\n\nint snd_timer_global_free(struct snd_timer *timer)\n{\n\treturn snd_timer_free(timer);\n}\n\nint snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}\n\n/*\n *  System timer\n */\n\nstruct snd_timer_system_private {\n\tstruct timer_list tlist;\n\tunsigned long last_expires;\n\tunsigned long last_jiffies;\n\tunsigned long correction;\n};\n\nstatic void snd_timer_s_function(unsigned long data)\n{\n\tstruct snd_timer *timer = (struct snd_timer *)data;\n\tstruct snd_timer_system_private *priv = timer->private_data;\n\tunsigned long jiff = jiffies;\n\tif (time_after(jiff, priv->last_expires))\n\t\tpriv->correction += (long)jiff - (long)priv->last_expires;\n\tsnd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);\n}\n\nstatic int snd_timer_s_start(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long njiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tnjiff = (priv->last_jiffies = jiffies);\n\tif (priv->correction > timer->sticks - 1) {\n\t\tpriv->correction -= timer->sticks - 1;\n\t\tnjiff++;\n\t} else {\n\t\tnjiff += timer->sticks - priv->correction;\n\t\tpriv->correction = 0;\n\t}\n\tpriv->last_expires = priv->tlist.expires = njiff;\n\tadd_timer(&priv->tlist);\n\treturn 0;\n}\n\nstatic int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}\n\nstatic struct snd_timer_hardware snd_timer_system =\n{\n\t.flags =\tSNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,\n\t.resolution =\t1000000000L / HZ,\n\t.ticks =\t10000000L,\n\t.start =\tsnd_timer_s_start,\n\t.stop =\t\tsnd_timer_s_stop\n};\n\nstatic void snd_timer_free_system(struct snd_timer *timer)\n{\n\tkfree(timer->private_data);\n}\n\nstatic int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tsetup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n/*\n *  Info interface\n */\n\nstatic void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_timer_proc_entry;\n\nstatic void __init snd_timer_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"timers\", NULL);\n\tif (entry != NULL) {\n\t\tentry->c.text.read = snd_timer_proc_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_timer_proc_entry = entry;\n}\n\nstatic void __exit snd_timer_proc_done(void)\n{\n\tsnd_info_free_entry(snd_timer_proc_entry);\n}\n#else /* !CONFIG_SND_PROC_FS */\n#define snd_timer_proc_init()\n#define snd_timer_proc_done()\n#endif\n\n/*\n *  USER SPACE interface\n */\n\nstatic void snd_timer_user_interrupt(struct snd_timer_instance *timeri,\n\t\t\t\t     unsigned long resolution,\n\t\t\t\t     unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_read *r;\n\tint prev;\n\n\tspin_lock(&tu->qlock);\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->queue[prev];\n\t\tif (r->resolution == resolution) {\n\t\t\tr->ticks += ticks;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tr = &tu->queue[tu->qtail++];\n\t\ttu->qtail %= tu->queue_size;\n\t\tr->resolution = resolution;\n\t\tr->ticks = ticks;\n\t\ttu->qused++;\n\t}\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,\n\t\t\t\t\t    struct snd_timer_tread *tread)\n{\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tmemcpy(&tu->tqueue[tu->qtail++], tread, sizeof(*tread));\n\t\ttu->qtail %= tu->queue_size;\n\t\ttu->qused++;\n\t}\n}\n\nstatic void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n\nstatic int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_user_zero_id(struct snd_timer_id *id)\n{\n\tid->dev_class = SNDRV_TIMER_CLASS_NONE;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = -1;\n\tid->device = -1;\n\tid->subdevice = -1;\n}\n\nstatic void snd_timer_user_copy_id(struct snd_timer_id *id, struct snd_timer *timer)\n{\n\tid->dev_class = timer->tmr_class;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = timer->card ? timer->card->number : -1;\n\tid->device = timer->tmr_device;\n\tid->subdevice = timer->tmr_subdevice;\n}\n\nstatic int snd_timer_user_next_device(struct snd_timer_id __user *_tid)\n{\n\tstruct snd_timer_id id;\n\tstruct snd_timer *timer;\n\tstruct list_head *p;\n\n\tif (copy_from_user(&id, _tid, sizeof(id)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tif (id.dev_class < 0) {\t\t/* first item */\n\t\tif (list_empty(&snd_timer_list))\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\telse {\n\t\t\ttimer = list_entry(snd_timer_list.next,\n\t\t\t\t\t   struct snd_timer, device_list);\n\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t}\n\t} else {\n\t\tswitch (id.dev_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tid.device = id.device < 0 ? 0 : id.device + 1;\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device >= id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tif (id.card < 0) {\n\t\t\t\tid.card = 0;\n\t\t\t} else {\n\t\t\t\tif (id.card < 0) {\n\t\t\t\t\tid.card = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (id.device < 0) {\n\t\t\t\t\t\tid.device = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (id.subdevice < 0) {\n\t\t\t\t\t\t\tid.subdevice = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tid.subdevice++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > id.dev_class) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_class < id.dev_class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->card->number > id.card) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->card->number < id.card)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_device > id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device < id.device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_subdevice > id.subdevice) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_subdevice < id.subdevice)\n\t\t\t\t\tcontinue;\n\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\t}\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (copy_to_user(_tid, &id, sizeof(*_tid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_ginfo(struct file *file,\n\t\t\t\tstruct snd_timer_ginfo __user *_ginfo)\n{\n\tstruct snd_timer_ginfo *ginfo;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tginfo = memdup_user(_ginfo, sizeof(*ginfo));\n\tif (IS_ERR(ginfo))\n\t\treturn PTR_ERR(ginfo);\n\n\ttid = ginfo->tid;\n\tmemset(ginfo, 0, sizeof(*ginfo));\n\tginfo->tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tginfo->card = t->card ? t->card->number : -1;\n\t\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tginfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\t\tstrlcpy(ginfo->id, t->id, sizeof(ginfo->id));\n\t\tstrlcpy(ginfo->name, t->name, sizeof(ginfo->name));\n\t\tginfo->resolution = t->hw.resolution;\n\t\tif (t->hw.resolution_min > 0) {\n\t\t\tginfo->resolution_min = t->hw.resolution_min;\n\t\t\tginfo->resolution_max = t->hw.resolution_max;\n\t\t}\n\t\tlist_for_each(p, &t->open_list_head) {\n\t\t\tginfo->clients++;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))\n\t\terr = -EFAULT;\n\tkfree(ginfo);\n\treturn err;\n}\n\nstatic int snd_timer_user_gparams(struct file *file,\n\t\t\t\t  struct snd_timer_gparams __user *_gparams)\n{\n\tstruct snd_timer_gparams gparams;\n\tstruct snd_timer *t;\n\tint err;\n\n\tif (copy_from_user(&gparams, _gparams, sizeof(gparams)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&gparams.tid);\n\tif (!t) {\n\t\terr = -ENODEV;\n\t\tgoto _error;\n\t}\n\tif (!list_empty(&t->open_list_head)) {\n\t\terr = -EBUSY;\n\t\tgoto _error;\n\t}\n\tif (!t->hw.set_period) {\n\t\terr = -ENOSYS;\n\t\tgoto _error;\n\t}\n\terr = t->hw.set_period(t, gparams.period_num, gparams.period_den);\n_error:\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_timer_user_gstatus(struct file *file,\n\t\t\t\t  struct snd_timer_gstatus __user *_gstatus)\n{\n\tstruct snd_timer_gstatus gstatus;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\tif (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))\n\t\treturn -EFAULT;\n\ttid = gstatus.tid;\n\tmemset(&gstatus, 0, sizeof(gstatus));\n\tgstatus.tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tif (t->hw.c_resolution)\n\t\t\tgstatus.resolution = t->hw.c_resolution(t);\n\t\telse\n\t\t\tgstatus.resolution = t->hw.resolution;\n\t\tif (t->hw.precise_resolution) {\n\t\t\tt->hw.precise_resolution(t, &gstatus.resolution_num,\n\t\t\t\t\t\t &gstatus.resolution_den);\n\t\t} else {\n\t\t\tgstatus.resolution_num = gstatus.resolution;\n\t\t\tgstatus.resolution_den = 1000000000uL;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n\n      __err:\n\treturn err;\n}\n\nstatic int snd_timer_user_info(struct file *file,\n\t\t\t       struct snd_timer_info __user *_info)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_info *info;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tinfo->card = t->card ? t->card->number : -1;\n\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\tinfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\tstrlcpy(info->id, t->id, sizeof(info->id));\n\tstrlcpy(info->name, t->name, sizeof(info->name));\n\tinfo->resolution = t->hw.resolution;\n\tif (copy_to_user(_info, info, sizeof(*_info)))\n\t\terr = -EFAULT;\n\tkfree(info);\n\treturn err;\n}\n\nstatic int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tstruct snd_timer_read *tr;\n\tstruct snd_timer_tread *ttr;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\tif (tu->tread) {\n\t\t\tttr = kmalloc(params.queue_size * sizeof(*ttr),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (ttr) {\n\t\t\t\tkfree(tu->tqueue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->tqueue = ttr;\n\t\t\t}\n\t\t} else {\n\t\t\ttr = kmalloc(params.queue_size * sizeof(*tr),\n\t\t\t\t     GFP_KERNEL);\n\t\t\tif (tr) {\n\t\t\t\tkfree(tu->queue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->queue = tr;\n\t\t\t}\n\t\t}\n\t}\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread tread;\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp.tv_sec = 0;\n\t\t\ttread.tstamp.tv_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_status(struct file *file,\n\t\t\t\t struct snd_timer_status __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp = tu->tstamp;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_start(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tsnd_timer_stop(tu->timeri);\n\ttu->timeri->lost = 0;\n\ttu->last_resolution = 0;\n\treturn (err = snd_timer_start(tu->timeri, tu->ticks)) < 0 ? err : 0;\n}\n\nstatic int snd_timer_user_stop(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\treturn (err = snd_timer_stop(tu->timeri)) < 0 ? err : 0;\n}\n\nstatic int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\ttu->timeri->lost = 0;\n\treturn (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;\n}\n\nstatic int snd_timer_user_pause(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\treturn (err = snd_timer_pause(tu->timeri)) < 0 ? err : 0;\n}\n\nenum {\n\tSNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),\n\tSNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),\n\tSNDRV_TIMER_IOCTL_CONTINUE_OLD = _IO('T', 0x22),\n\tSNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),\n};\n\nstatic long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\n\t\tif (tu->timeri)\t/* too late */\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}\n\nstatic int snd_timer_user_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\treturn fasync_helper(fd, file, on, &tu->fasync);\n}\n\nstatic ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[tu->qhead++],\n\t\t\t\t\t sizeof(struct snd_timer_tread))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[tu->qhead++],\n\t\t\t\t\t sizeof(struct snd_timer_read))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\ttu->qhead %= tu->queue_size;\n\n\t\tresult += unit;\n\t\tbuffer += unit;\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\ttu->qused--;\n\t}\n\tspin_unlock_irq(&tu->qlock);\n _error:\n\treturn result > 0 ? result : err;\n}\n\nstatic unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)\n{\n        unsigned int mask;\n        struct snd_timer_user *tu;\n\n        tu = file->private_data;\n\n        poll_wait(file, &tu->qchange_sleep, wait);\n\n\tmask = 0;\n\tif (tu->qused)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"timer_compat.c\"\n#else\n#define snd_timer_user_ioctl_compat\tNULL\n#endif\n\nstatic const struct file_operations snd_timer_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_timer_user_read,\n\t.open =\t\tsnd_timer_user_open,\n\t.release =\tsnd_timer_user_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_timer_user_poll,\n\t.unlocked_ioctl =\tsnd_timer_user_ioctl,\n\t.compat_ioctl =\tsnd_timer_user_ioctl_compat,\n\t.fasync = \tsnd_timer_user_fasync,\n};\n\n/* unregister the system timer */\nstatic void snd_timer_free_all(void)\n{\n\tstruct snd_timer *timer, *n;\n\n\tlist_for_each_entry_safe(timer, n, &snd_timer_list, device_list)\n\t\tsnd_timer_free(timer);\n}\n\nstatic struct device timer_dev;\n\n/*\n *  ENTRY functions\n */\n\nstatic int __init alsa_timer_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&timer_dev, NULL);\n\tdev_set_name(&timer_dev, \"timer\");\n\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,\n\t\t\t      \"system timer\");\n#endif\n\n\terr = snd_timer_register_system();\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register system timer (%i)\\n\", err);\n\t\tput_device(&timer_dev);\n\t\treturn err;\n\t}\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,\n\t\t\t\t  &snd_timer_f_ops, NULL, &timer_dev);\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register timer device (%i)\\n\", err);\n\t\tsnd_timer_free_all();\n\t\tput_device(&timer_dev);\n\t\treturn err;\n\t}\n\n\tsnd_timer_proc_init();\n\treturn 0;\n}\n\nstatic void __exit alsa_timer_exit(void)\n{\n\tsnd_unregister_device(&timer_dev);\n\tsnd_timer_free_all();\n\tput_device(&timer_dev);\n\tsnd_timer_proc_done();\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);\n#endif\n}\n\nmodule_init(alsa_timer_init)\nmodule_exit(alsa_timer_exit)\n\nEXPORT_SYMBOL(snd_timer_open);\nEXPORT_SYMBOL(snd_timer_close);\nEXPORT_SYMBOL(snd_timer_resolution);\nEXPORT_SYMBOL(snd_timer_start);\nEXPORT_SYMBOL(snd_timer_stop);\nEXPORT_SYMBOL(snd_timer_continue);\nEXPORT_SYMBOL(snd_timer_pause);\nEXPORT_SYMBOL(snd_timer_new);\nEXPORT_SYMBOL(snd_timer_notify);\nEXPORT_SYMBOL(snd_timer_global_new);\nEXPORT_SYMBOL(snd_timer_global_free);\nEXPORT_SYMBOL(snd_timer_global_register);\nEXPORT_SYMBOL(snd_timer_interrupt);\n"], "filenames": ["sound/core/timer.c"], "buggy_code_start_loc": [217], "buggy_code_end_loc": [491], "fixing_code_start_loc": [218], "fixing_code_end_loc": [502], "type": "CWE-20", "message": "sound/core/timer.c in the Linux kernel before 4.4.1 retains certain linked lists after a close or stop action, which allows local users to cause a denial of service (system crash) via a crafted ioctl call, related to the (1) snd_timer_close and (2) _snd_timer_stop functions.", "other": {"cve": {"id": "CVE-2016-2548", "sourceIdentifier": "cve@mitre.org", "published": "2016-04-27T17:59:18.070", "lastModified": "2017-09-07T01:29:02.557", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "sound/core/timer.c in the Linux kernel before 4.4.1 retains certain linked lists after a close or stop action, which allows local users to cause a denial of service (system crash) via a crafted ioctl call, related to the (1) snd_timer_close and (2) _snd_timer_stop functions."}, {"lang": "es", "value": "sound/core/timer.c en el kernel de Linux en versiones anteriores a 4.4.1 conserva ciertas listas enlazadas despu\u00e9s de una acci\u00f3n de cierre o parada, lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) a trav\u00e9s de una llamada ioctl manipulada, relacionada con las funciones (1) snd_timer_close y (2) _snd_timer_stop."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4", "matchCriteriaId": "8B458ACF-17C3-4551-9F11-8D02B6D52B7C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b5a663aa426f4884c71cd8580adae73f33570f0d", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-03/msg00094.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00045.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2016/dsa-3503", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.4.1", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/01/19/1", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/83383", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1035306", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2929-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2929-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-3", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2931-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2932-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2967-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2967-2", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1311568", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d"}}