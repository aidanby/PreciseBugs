{"buggy_code": ["/* radare2 - LGPL - Copyright 2016-2017 - Davis, Alex Kornitzer */\n\n#include <r_util.h>\n\n#include \"mdmp.h\"\n// XXX: this is a random number, no idea how long it should be.\n#define COMMENTS_SIZE 32\n\nut64 r_bin_mdmp_get_paddr(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\t/* FIXME: Will only resolve exact matches, probably no need to fix as\n\t** this function will become redundant on the optimisation stage */\n\tstruct minidump_memory_descriptor64 *memory;\n\tut64 index, paddr = 0;\n\tRListIter *it;\n\n\t/* Loop through the memories sections looking for a match */\n\tindex = obj->streams.memories64.base_rva;\n\tr_list_foreach (obj->streams.memories64.memories, it, memory) {\n\t\tif (vaddr == memory->start_of_memory_range) {\n\t\t\tpaddr = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex += memory->data_size;\n\t}\n\treturn paddr;\n}\n\nstruct minidump_memory_info *r_bin_mdmp_get_mem_info(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\tRListIter *it;\n\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\n\tr_list_foreach (obj->streams.memory_infos, it, mem_info) {\n\t\tif (mem_info->allocation_base && vaddr == mem_info->base_address) {\n\t\t\treturn mem_info;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nut32 r_bin_mdmp_get_perm(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\n\tif (!(mem_info = r_bin_mdmp_get_mem_info(obj, vaddr))) {\n\t\t/* if there is no mem info in the dump, assume default permission */\n\t\treturn R_PERM_R;\n\t}\n\n\t/* FIXME: Have I got these mappings right, I am not sure I have!!! */\n\n\tswitch (mem_info->protect) {\n\tcase MINIDUMP_PAGE_READONLY:\n\t\treturn R_PERM_R;\n\tcase MINIDUMP_PAGE_READWRITE:\n\t\treturn R_PERM_RW;\n\tcase MINIDUMP_PAGE_EXECUTE:\n\t\treturn R_PERM_X;\n\tcase MINIDUMP_PAGE_EXECUTE_READ:\n\t\treturn R_PERM_RX;\n\tcase MINIDUMP_PAGE_EXECUTE_READWRITE:\n\t\treturn R_PERM_RWX;\n\tcase MINIDUMP_PAGE_NOACCESS:\n\tcase MINIDUMP_PAGE_WRITECOPY:\n\tcase MINIDUMP_PAGE_EXECUTE_WRITECOPY:\n\tcase MINIDUMP_PAGE_GUARD:\n\tcase MINIDUMP_PAGE_NOCACHE:\n\tcase MINIDUMP_PAGE_WRITECOMBINE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe32_bin(void *pe_bin_) {\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe32_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe64_bin(void *pe_bin_) {\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe64_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nvoid r_bin_mdmp_free(struct r_bin_mdmp_obj *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tr_list_free (obj->streams.ex_threads);\n\tr_list_free (obj->streams.memories);\n\tr_list_free (obj->streams.memories64.memories);\n\tr_list_free (obj->streams.memory_infos);\n\tr_list_free (obj->streams.modules);\n\tr_list_free (obj->streams.operations);\n\tr_list_free (obj->streams.thread_infos);\n\tr_list_free (obj->streams.threads);\n\tr_list_free (obj->streams.token_infos);\n\tr_list_free (obj->streams.unloaded_modules);\n\tfree (obj->streams.exception);\n\tfree (obj->streams.system_info);\n\tfree (obj->streams.comments_a);\n\tfree (obj->streams.comments_w);\n\tfree (obj->streams.handle_data);\n\tfree (obj->streams.function_table);\n\tfree (obj->streams.misc_info.misc_info_1);\n\n\tr_list_free (obj->pe32_bins);\n\tr_list_free (obj->pe64_bins);\n\n\tr_buf_free (obj->b);\n\tfree (obj->hdr);\n\tobj->b = NULL;\n\tfree (obj);\n\n\treturn;\n}\n\nstatic void r_bin_mdmp_init_parsing(struct r_bin_mdmp_obj *obj) {\n\t/* TODO: Handle unions, can we? */\n\t/* FIXME: Why are we getting struct missing errors when it finds them */\n\tsdb_set (obj->kv, \"mdmp_mem_state.cparse\",\n\t\t\"enum mdmp_mem_state { MEM_COMMIT=0x1000, \"\n\t\t\"MEM_FREE=0x10000, MEM_RESERVE=0x02000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_mem_type.cparse\",\n\t\t\"enum mdmp_mem_type { MEM_IMAGE=0x1000000, \"\n\t\t\"MEM_MAPPED=0x40000, MEM_PRIVATE=0x20000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_page_protect.cparse\",\n\t\t\"enum mdmp_page_protect { PAGE_NOACCESS=1, \"\n\t\t\"PAGE_READONLY=2, PAGE_READWRITE=4, PAGE_WRITECOPY=8, \"\n\t\t\"PAGE_EXECUTE=0x10, PAGE_EXECUTE_READ=0x20, \"\n\t\t\"PAGE_EXECUTE_READWRITE=0x40, PAGE_EXECUTE_WRITECOPY=0x80, \"\n\t\t\"PAGE_GUARD=0x100, PAGE_NOCACHE=0x200, \"\n\t\t\"PAGE_WRITECOMBINE=0x400, PAGE_TARGETS_INVALID=0x40000000 };\",\n\t\t0);\n\n\tsdb_set (obj->kv, \"mdmp_misc1_flags.cparse\",\n\t\t\"enum mdmp_misc1_flags { MINIDUMP_MISC1_PROCESS_ID=1, \"\n\t\t\"MINIDUMP_MISC1_PROCESS_TIMES=2, \"\n\t\t\"MINIDUMP_MISC1_PROCESSOR_POWER_INFO=4 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_processor_architecture.cparse\",\n\t\t\"enum mdmp_processor_architecture { \"\n\t\t\"PROCESSOR_ARCHITECTURE_INTEL=0, \"\n\t\t\"PROCESSOR_ARCHITECTURE_ARM=5, \"\n\t\t\"PROCESSOR_ARCHITECTURE_IA64=6, \"\n\t\t\"PROCESSOR_ARCHITECTURE_AMD64=9, \"\n\t\t\"PROCESSOR_ARCHITECTURE_UNKNOWN=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_product_type.cparse\",\n\t\t\"enum mdmp_product_type { \"\n\t\t\"VER_NT_WORKSTATION=1, VER_NT_DOMAIN_CONTROLLER=2, \"\n\t\t\"VER_NT_SERVER=3 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_platform_id.cparse\",\n\t\t\"enum mdmp_platform_id { \"\n\t\t\"VER_PLATFORM_WIN32s=0, \"\n\t\t\"VER_PLATFORM_WIN32_WINDOWS=1, \"\n\t\t\"VER_PLATFORM_WIN32_NT=2 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_suite_mask.cparse\",\n\t\t\"enum mdmp_suite_mask { \"\n\t\t\"VER_SUITE_SMALLBUSINESS=1, VER_SUITE_ENTERPRISE=2, \"\n\t\t\"VER_SUITE_BACKOFFICE=4, VER_SUITE_TERMINAL=0x10, \"\n\t\t\"VER_SUITE_SMALLBUSINESS_RESTRICTED=0x20, \"\n\t\t\"VER_SUITE_EMBEDDEDNT=0x40, VER_SUITE_DATACENTER=0x80, \"\n\t\t\"VER_SUITE_SINGLEUSERTS=0x100, VER_SUITE_PERSONAL=0x200, \"\n\t\t\"VER_SUITE_BLADE=0x400, VER_SUITE_STORAGE_SERVER=0x2000, \"\n\t\t\"VER_SUITE_COMPUTE_SERVER=0x4000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_callback_type.cparse\",\n\t\t\"enum mdmp_type { ModuleCallback=0,\"\n\t\t\"ThreadCallback=1, ThreadExCallback=2, \"\n\t\t\"IncludeThreadCallback=3, IncludeModuleCallback=4, \"\n\t\t\"MemoryCallback=5, CancelCallback=6, \"\n\t\t\"WriteKernelMinidumpCallback=7, \"\n\t\t\"KernelMinidumpStatusCallback=8, \"\n\t\t\"RemoveMemoryCallback=9, \"\n\t\t\"IncludeVmRegionCallback=10, \"\n\t\t\"IoStartCallback=11, IoWriteAllCallback=12, \"\n\t\t\"IoFinishCallback=13, ReadMemoryFailureCallback=14, \"\n\t\t\"SecondaryFlagsCallback=15 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_code.cparse\",\n\t\t\"enum mdmp_exception_code { \"\n\t\t\"DBG_CONTROL_C=0x40010005, \"\n\t\t\"EXCEPTION_GUARD_PAGE_VIOLATION=0x80000001, \"\n\t\t\"EXCEPTION_DATATYPE_MISALIGNMENT=0x80000002, \"\n\t\t\"EXCEPTION_BREAKPOINT=0x80000003, \"\n\t\t\"EXCEPTION_SINGLE_STEP=0x80000004, \"\n\t\t\"EXCEPTION_ACCESS_VIOLATION=0xc0000005, \"\n\t\t\"EXCEPTION_IN_PAGE_ERROR=0xc0000006, \"\n\t\t\"EXCEPTION_INVALID_HANDLE=0xc0000008, \"\n\t\t\"EXCEPTION_ILLEGAL_INSTRUCTION=0xc000001d, \"\n\t\t\"EXCEPTION_NONCONTINUABLE_EXCEPTION=0xc0000025, \"\n\t\t\"EXCEPTION_INVALID_DISPOSITION=0xc0000026, \"\n\t\t\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED=0xc000008c, \"\n\t\t\"EXCEPTION_FLOAT_DENORMAL_OPERAND=0xc000008d, \"\n\t\t\"EXCEPTION_FLOAT_DIVIDE_BY_ZERO=0xc000008e, \"\n\t\t\"EXCEPTION_FLOAT_INEXACT_RESULT=0xc000008f, \"\n\t\t\"EXCEPTION_FLOAT_INVALID_OPERATION=0xc0000090, \"\n\t\t\"EXCEPTION_FLOAT_OVERFLOW=0xc0000091, \"\n\t\t\"EXCEPTION_FLOAT_STACK_CHECK=0xc0000092, \"\n\t\t\"EXCEPTION_FLOAT_UNDERFLOW=0xc0000093, \"\n\t\t\"EXCEPTION_INTEGER_DIVIDE_BY_ZERO=0xc0000094, \"\n\t\t\"EXCEPTION_INTEGER_OVERFLOW=0xc0000095, \"\n\t\t\"EXCEPTION_PRIVILEGED_INSTRUCTION=0xc0000096, \"\n\t\t\"EXCEPTION_STACK_OVERFLOW=0xc00000fd, \"\n\t\t\"EXCEPTION_POSSIBLE_DEADLOCK=0xc0000194 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_flags.cparse\",\n\t\t\"enum mdmp_exception_flags { \"\n\t\t\"EXCEPTION_CONTINUABLE=0, \"\n\t\t\"EXCEPTION_NONCONTINUABLE=1 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_handle_object_information_type.cparse\",\n\t\t\"enum mdmp_handle_object_information_type { \"\n\t\t\"MiniHandleObjectInformationNone=0, \"\n\t\t\"MiniThreadInformation1=1, MiniMutantInformation1=2, \"\n\t\t\"MiniMutantInformation2=3, MiniMutantProcessInformation1=4, \"\n\t\t\"MiniProcessInformation2=5 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_secondary_flags.cparse\",\n\t\t\"enum mdmp_secondary_flags { \"\n\t\t\"MiniSecondaryWithoutPowerInfo=0 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_stream_type.cparse\",\n\t\t\"enum mdmp_stream_type { UnusedStream=0, \"\n\t\t\"ReservedStream0=1, ReservedStream1=2, \"\n\t\t\"ThreadListStream=3, ModuleListStream=4, \"\n\t\t\"MemoryListStream=5, ExceptionStream=6, \"\n\t\t\"SystemInfoStream=7, ThreadExListStream=8, \"\n\t\t\"Memory64ListStream=9, CommentStreamA=10, \"\n\t\t\"CommentStreamW=11, HandleDataStream=12, \"\n\t\t\"FunctionTableStream=13, UnloadedModuleListStream=14, \"\n\t\t\"MiscInfoStream=15, MemoryInfoListStream=16, \"\n\t\t\"ThreadInfoListStream=17, \"\n\t\t\"HandleOperationListStream=18, \"\n\t\t\"LastReservedStream=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_type.cparse\", \"enum mdmp_type { \"\n\t\t\"MiniDumpNormal=0x0, \"\n\t\t\"MiniDumpWithDataSegs=0x1, \"\n\t\t\"MiniDumpWithFullMemory=0x2, \"\n\t\t\"MiniDumpWithHandleData=0x4, \"\n\t\t\"MiniDumpFilterMemory=0x8, \"\n\t\t\"MiniDumpScanMemory=0x10, \"\n\t\t\"MiniDumpWithUnloadedModule=0x20, \"\n\t\t\"MiniDumpWihinDirectlyReferencedMemory=0x40, \"\n\t\t\"MiniDumpFilterWithModulePaths=0x80,\"\n\t\t\"MiniDumpWithProcessThreadData=0x100, \"\n\t\t\"MiniDumpWithPrivateReadWriteMemory=0x200, \"\n\t\t\"MiniDumpWithoutOptionalDate=0x400, \"\n\t\t\"MiniDumpWithFullMemoryInfo=0x800, \"\n\t\t\"MiniDumpWithThreadInfo=0x1000, \"\n\t\t\"MiniDumpWithCodeSegs=0x2000, \"\n\t\t\"MiniDumpWithoutAuxiliaryState=0x4000, \"\n\t\t\"MiniDumpWithFullAuxiliaryState=0x8000, \"\n\t\t\"MiniDumpWithPrivateWriteCopyMemory=0x10000, \"\n\t\t\"MiniDumpIgnoreInaccessibleMemory=0x20000, \"\n\t\t\"MiniDumpWithTokenInformation=0x40000, \"\n\t\t\"MiniDumpWithModuleHeaders=0x80000, \"\n\t\t\"MiniDumpFilterTriage=0x100000, \"\n\t\t\"MiniDumpValidTypeFlags=0x1fffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_module_write_flags.cparse\",\n\t\t\"enum mdmp_module_write_flags { \"\n\t\t\"ModuleWriteModule=0, ModuleWriteDataSeg=2, \"\n\t\t\"ModuleWriteMiscRecord=4, ModuleWriteCvRecord=8, \"\n\t\t\"ModuleReferencedByMemory=0x10, ModuleWriteTlsData=0x20, \"\n\t\t\"ModuleWriteCodeSegs=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_thread_write_flags.cparse\",\n\t\t\"enum mdmp_thread_write_flags { \"\n\t\t\"ThreadWriteThread=0, ThreadWriteStack=2, \"\n\t\t\"ThreadWriteContext=4, ThreadWriteBackingStore=8, \"\n\t\t\"ThreadWriteInstructionWindow=0x10, \"\n\t\t\"ThreadWriteThreadData=0x20, \"\n\t\t\"ThreadWriteThreadInfo=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_context_flags.cparse\",\n\t\t\"enum mdmp_context_flags { CONTEXT_i386=0x10000, \"\n\t\t\"CONTEXT_CONTROL=0x10001, CONTEXT_INTEGER=0x10002, \"\n\t\t\"CONTEXT_SEGMENTS=0x10004, CONTEXT_FLOATING_POINT=0x10008, \"\n\t\t\"CONTEXT_DEBUG_REGISTERS=0x10010, \"\n\t\t\"CONTEXT_EXTENDED_REGISTERS=0x10020 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_location_descriptor.format\",\n\t\t\"dd DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_location_descriptor64.format\",\n\t\t\"qq DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor.format\", \"q? \"\n\t\t\"StartOfMemoryRange \"\n\t\t\"(mdmp_location_descriptor)Memory\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor64.format\", \"qq \"\n\t\t\"StartOfMemoryRange DataSize\", 0);\n\n#if 0\n\t/* TODO: Flag dependent thus not fully implemented */\n\tsdb_set (obj->kv, \"mdmp_context.format\", \"[4]B \"\n\t\t\"(mdmp_context_flags)ContextFlags\", 0);\n#endif\n\n\tsdb_set (obj->kv, \"mdmp_vs_fixedfileinfo.format\", \"ddddddddddddd \"\n\t\t\"dwSignature dwStrucVersion dwFileVersionMs \"\n\t\t\"dwFileVersionLs dwProductVersionMs \"\n\t\t\"dwProductVersionLs dwFileFlagsMask dwFileFlags \"\n\t\t\"dwFileOs dwFileType dwFileSubtype dwFileDateMs \"\n\t\t\"dwFileDateLs\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_string.format\", \"dZ Length Buffer\", 0);\n}\n\nstatic void read_hdr(RBuffer *b, struct minidump_header *hdr) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, 0, R_BUF_SET);\n\thdr->signature = r_buf_read_le32 (b);\n\thdr->version = r_buf_read_le32 (b);\n\thdr->number_of_streams = r_buf_read_le32 (b);\n\thdr->stream_directory_rva = r_buf_read_le32 (b);\n\thdr->check_sum = r_buf_read_le32 (b);\n\thdr->reserved = r_buf_read_le32 (b);\n\thdr->flags = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {\n\tobj->hdr = R_NEW (struct minidump_header);\n\tif (!obj->hdr) {\n\t\treturn false;\n\t}\n\tread_hdr (obj->b, obj->hdr);\n\n\tif (obj->hdr->number_of_streams == 0) {\n\t\teprintf (\"[WARN] No streams present!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->stream_directory_rva < sizeof (struct minidump_header))\n\t{\n\t\teprintf (\"[ERROR] RVA for directory resides in the header!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->check_sum) {\n\t\teprintf (\"[INFO] Checksum present but needs validating!\\n\");\n\t\treturn false;\n\t}\n\n\tsdb_num_set (obj->kv, \"mdmp.hdr.time_date_stamp\", obj->hdr->time_date_stamp, 0);\n\tsdb_num_set (obj->kv, \"mdmp.hdr.flags\", obj->hdr->flags, 0);\n\tsdb_num_set (obj->kv, \"mdmp_header.offset\", 0, 0);\n\tsdb_set (obj->kv, \"mdmp_header.format\", \"[4]zddddt[8]B Signature \"\n\t\t\"Version NumberOfStreams StreamDirectoryRVA CheckSum \"\n\t\t\"TimeDateStamp (mdmp_type)Flags\", 0);\n\n\treturn true;\n}\n\nstatic void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic void read_memory64_list(RBuffer *b, ut64 addr, struct minidump_memory64_list *memory64_list) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmemory64_list->number_of_memory_ranges = r_buf_read_le64 (b);\n\tmemory64_list->base_rva = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic void read_desc(RBuffer *b, ut64 addr, struct minidump_memory_descriptor64 *desc) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tdesc->start_of_memory_range = r_buf_read_le64 (b);\n\tdesc->data_size = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tr_strf_buffer (128);\n\tstruct minidump_handle_operation_list handle_operation_list;\n\tstruct minidump_memory_list memory_list;\n\tstruct minidump_memory64_list memory64_list;\n\tstruct minidump_memory_info_list memory_info_list;\n\tstruct minidump_module_list module_list;\n\tstruct minidump_thread_list thread_list;\n\tstruct minidump_thread_ex_list thread_ex_list;\n\tstruct minidump_thread_info_list thread_info_list;\n\tstruct minidump_token_info_list token_info_list;\n\tstruct minidump_unloaded_module_list unloaded_module_list;\n\tut64 offset;\n\tint i, r;\n\n\t/* We could confirm data sizes but a malcious MDMP will always get around\n\t** this! But we can ensure that the data is not outside of the file */\n\tif ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));\n\t\tif (r != sizeof (thread_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list.number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list.number_of_modules),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (module_list);\n\t\tfor (i = 0; i < module_list.number_of_modules; i++) {\n\t\t\tstruct minidump_module *module = R_NEW (struct minidump_module);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_module (obj->b, offset, module);\n\t\t\tr_list_append (obj->streams.modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));\n\t\tif (r != sizeof (memory_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_list);\n\t\tfor (i = 0; i < memory_list.number_of_memory_ranges; i++) {\n\t\t\tstruct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));\n\t\t\tif (r != sizeof (*desc)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = R_NEW (struct minidump_exception_stream);\n\t\tif (!obj->streams.exception) {\n\t\t\tbreak;\n\t\t}\n\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));\n\t\tif (r != sizeof (*obj->streams.exception)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\t\t\t\t   \"ExceptionRecord ExceptionAddress \"\n\t\t\t\t\t\t\t   \"NumberParameters __UnusedAlignment \"\n\t\t\t\t\t\t\t   \"ExceptionInformation\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\t\t\t\t\t  \"ThreadId __Alignment \"\n\t\t\t\t\t\t\t\t  \"(mdmp_exception)ExceptionRecord \"\n\t\t\t\t\t\t\t\t  \"(mdmp_location_descriptor)ThreadContext\",\n\t\t\t0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = R_NEW (struct minidump_system_info);\n\t\tif (!obj->streams.system_info) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));\n\t\tif (r != sizeof (*obj->streams.system_info)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));\n\t\tif (r != sizeof (thread_ex_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tr_strf (\"d[%d]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list.number_of_threads),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (thread_ex_list);\n\t\tfor (i = 0; i < thread_ex_list.number_of_threads; i++) {\n\t\t\tstruct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);\n\t\t\tif (!thread) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));\n\t\t\tif (r != sizeof (*thread)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.ex_threads, thread);\n\t\t\toffset += sizeof (*thread);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tread_memory64_list (obj->b, entry->location.rva, &memory64_list);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tr_strf (\"qq[%\"PFMT64d\"]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list.base_rva;\n\t\toffset = entry->location.rva + sizeof (memory64_list);\n\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges; i++) {\n\t\t\tstruct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_desc (obj->b, offset, desc);\n\t\t\tr_list_append (obj->streams.memories64.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_a) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_w) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);\n\t\tif (!obj->streams.handle_data) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));\n\t\tif (r != sizeof (*obj->streams.handle_data)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = R_NEW (struct minidump_function_table_stream);\n\t\tif (!obj->streams.function_table) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));\n\t\tif (r != sizeof (*obj->streams.function_table)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));\n\t\tif (r != sizeof (unloaded_module_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (unloaded_module_list);\n\t\tfor (i = 0; i < unloaded_module_list.number_of_entries; i++) {\n\t\t\tstruct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));\n\t\t\tif (r != sizeof (*module)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.unloaded_modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);\n\t\tif (!obj->streams.misc_info.misc_info_1) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));\n\t\tif (r != sizeof (*obj->streams.misc_info.misc_info_1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));\n\t\tif (r != sizeof (memory_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tr_strf (\"ddq[%\"PFMT64d\"]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list.number_of_entries),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_info_list);\n\t\tfor (i = 0; i < memory_info_list.number_of_entries; i++) {\n\t\t\tstruct minidump_memory_info *info = R_NEW (struct minidump_memory_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memory_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));\n\t\tif (r != sizeof (thread_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (thread_info_list);\n\t\tfor (i = 0; i < thread_info_list.number_of_entries; i++) {\n\t\t\tstruct minidump_thread_info *info = R_NEW (struct minidump_thread_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.thread_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));\n\t\tif (r != sizeof (handle_operation_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\toffset = entry->location.rva + sizeof (handle_operation_list);\n\t\tfor (i = 0; i < handle_operation_list.number_of_entries; i++) {\n\t\t\tstruct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));\n\t\t\tif (r != sizeof (*op)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.operations, op);\n\t\t\toffset += sizeof (*op);\n\t\t}\n\n\t\tbreak;\n\tcase TOKEN_STREAM:\n\t\t/* TODO: Not fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));\n\t\tif (r != sizeof (token_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_token_info.format\", \"ddq \"\n\t\t\t\"TokenSize TokenId TokenHandle\", 0);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_token_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_token_info_list.format\", \"dddd \"\n\t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n\n\t\toffset = entry->location.rva + sizeof (token_info_list);\n\t\tfor (i = 0; i < token_info_list.number_of_entries; i++) {\n\t\t\tstruct minidump_token_info *info = R_NEW (struct minidump_token_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.token_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %d\\n\", entry->stream_type);\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nstatic bool read_entry(RBuffer *b, ut64 addr, struct minidump_directory *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn false;\n\t}\n\tentry->stream_type = r_buf_read_le32 (b);\n\tentry->location.data_size = r_buf_read_le32 (b);\n\tentry->location.rva = r_buf_read_le32 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tut32 i;\n\tstruct minidump_directory entry;\n\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tut64 bytes_left = rvadir < obj->size ? obj->size - rvadir : 0;\n\tsize_t max_entries = R_MIN (obj->hdr->number_of_streams, bytes_left / sizeof (struct minidump_directory));\n\tif (max_entries < obj->hdr->number_of_streams) {\n\t\teprintf (\"[ERROR] Number of streams = %u is greater than is supportable by bin size\\n\",\n\t\t\t\tobj->hdr->number_of_streams);\n\t}\n\t/* Parse each entry in the directory */\n\tfor (i = 0; i < max_entries; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tif (read_entry (obj->b, rvadir + delta, &entry)) {\n\t\t\tif (!r_bin_mdmp_init_directory_entry (obj, &entry)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_patch_pe_headers(RBuffer *pe_buf) {\n\tint i;\n\tPe64_image_dos_header dos_hdr;\n\tPe64_image_nt_headers nt_hdr;\n\n\tPe64_read_dos_header (pe_buf, &dos_hdr);\n\tPe64_read_nt_headers (pe_buf, dos_hdr.e_lfanew, &nt_hdr);\n\n\t/* Patch RawData in headers */\n\tut64 sect_hdrs_off = dos_hdr.e_lfanew + 4 + sizeof (Pe64_image_file_header) + nt_hdr.file_header.SizeOfOptionalHeader;\n\tPe64_image_section_header section_hdr;\n\tfor (i = 0; i < nt_hdr.file_header.NumberOfSections; i++) {\n\t\tPe64_read_image_section_header (pe_buf, sect_hdrs_off + i * sizeof (section_hdr), &section_hdr);\n\t\tsection_hdr.PointerToRawData = section_hdr.VirtualAddress;\n\t\tPe64_write_image_section_header (pe_buf, sect_hdrs_off + i * sizeof (section_hdr), &section_hdr);\n\t}\n\n\treturn true;\n}\n\nstatic int check_pe32_buf(RBuffer *buf, ut64 length) {\n\tunsigned int idx;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = (r_buf_read8_at (buf, 0x3c) | (r_buf_read8_at (buf, 0x3d)<<8));\n\tif (length > idx + 0x18 + 2) {\n\t\tut8 tmp1[2], tmp2[2], tmp3[2];\n\t\tr_buf_read_at (buf, 0, tmp1, 2);\n\t\tr_buf_read_at (buf, idx, tmp2, 2);\n\t\tr_buf_read_at (buf, idx + 0x18, tmp3, 2);\n\t\tif (!memcmp (tmp1, \"MZ\", 2) && !memcmp (tmp2, \"PE\", 2) && !memcmp (tmp3, \"\\x0b\\x01\", 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int check_pe64_buf(RBuffer *buf, ut64 length) {\n\tint idx, ret = false;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = r_buf_read8_at (buf, 0x3c) | (r_buf_read8_at (buf, 0x3d)<<8);\n\tif (length >= idx + 0x20) {\n\t\tut8 tmp1[2], tmp2[2], tmp3[2];\n\t\tr_buf_read_at (buf, 0, tmp1, 2);\n\t\tr_buf_read_at (buf, idx, tmp2, 2);\n\t\tr_buf_read_at (buf, idx + 0x18, tmp3, 2);\n\t\tif (!memcmp (tmp1, \"MZ\", 2) && !memcmp (tmp2, \"PE\", 2) && !memcmp (tmp3, \"\\x0b\\x02\", 2)) {\n\t\t\tret = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic bool r_bin_mdmp_init_pe_bins(struct r_bin_mdmp_obj *obj) {\n\tbool dup;\n\tut64 paddr;\n\tstruct minidump_module *module;\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe32_bin, *pe32_dup;\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe64_bin, *pe64_dup;\n\tRBuffer *buf = NULL;\n\tRListIter *it, *it_dup;\n\n\tr_list_foreach (obj->streams.modules, it, module) {\n\t\t/* Duplicate modules can appear in the MDMP module list,\n\t\t** filtering them out seems to be the correct behaviour */\n\t\tif (!(paddr = r_bin_mdmp_get_paddr (obj, module->base_of_image))) {\n\t\t\tcontinue;\n\t\t}\n\t\tut8 *b = R_NEWS (ut8, module->size_of_image);\n\t\tif (!b) {\n\t\t\tcontinue;\n\t\t}\n\t\tint r = r_buf_read_at (obj->b, paddr, b, module->size_of_image);\n\t\tr_buf_free (buf);\n\t\tbuf = r_buf_new_with_bytes (b, r);\n\t\tdup = false;\n\t\tif (check_pe32_buf (buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe32_bins, it_dup, pe32_dup) {\n\t\t\t\tif (pe32_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe32_bin = R_NEW0 (struct Pe32_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe32_bin->vaddr = module->base_of_image;\n\t\t\tpe32_bin->paddr = paddr;\n\t\t\tpe32_bin->bin = Pe32_r_bin_pe_new_buf (buf, 0);\n\t\t\tif (!pe32_bin->bin) {\n\t\t\t\tfree (pe32_bin);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_list_append (obj->pe32_bins, pe32_bin);\n\t\t} else if (check_pe64_buf (buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe64_bins, it_dup, pe64_dup) {\n\t\t\t\tif (pe64_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe64_bin = R_NEW0 (struct Pe64_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe64_bin->vaddr = module->base_of_image;\n\t\t\tpe64_bin->paddr = paddr;\n\t\t\tpe64_bin->bin = Pe64_r_bin_pe_new_buf (buf, 0);\n\n\t\t\tr_list_append (obj->pe64_bins, pe64_bin);\n\t\t}\n\t}\n\tr_buf_free (buf);\n\tbuf = NULL;\n\treturn true;\n}\n\nstatic int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct r_bin_mdmp_obj *r_bin_mdmp_new_buf(RBuffer *buf) {\n\tbool fail = false;\n\tstruct r_bin_mdmp_obj *obj = R_NEW0 (struct r_bin_mdmp_obj);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tobj->kv = sdb_new0 ();\n\tobj->size = (ut32) r_buf_size (buf);\n\n\tfail |= (!(obj->streams.ex_threads = r_list_new ()));\n\tfail |= (!(obj->streams.memories = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.memories64.memories = r_list_new ()));\n\tfail |= (!(obj->streams.memory_infos = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.modules = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.operations = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.thread_infos = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.token_infos = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.threads = r_list_new ()));\n\tfail |= (!(obj->streams.unloaded_modules = r_list_newf ((RListFree)free)));\n\n\tfail |= (!(obj->pe32_bins = r_list_newf (r_bin_mdmp_free_pe32_bin)));\n\tfail |= (!(obj->pe64_bins = r_list_newf (r_bin_mdmp_free_pe64_bin)));\n\n\tif (fail) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\tobj->b = r_buf_ref (buf);\n\tif (!r_bin_mdmp_init (obj)) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\treturn obj;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2016-2017 - Davis, Alex Kornitzer */\n\n#include <r_util.h>\n\n#include \"mdmp.h\"\n// XXX: this is a random number, no idea how long it should be.\n#define COMMENTS_SIZE 32\n\nut64 r_bin_mdmp_get_paddr(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\t/* FIXME: Will only resolve exact matches, probably no need to fix as\n\t** this function will become redundant on the optimisation stage */\n\tstruct minidump_memory_descriptor64 *memory;\n\tut64 index, paddr = 0;\n\tRListIter *it;\n\n\t/* Loop through the memories sections looking for a match */\n\tindex = obj->streams.memories64.base_rva;\n\tr_list_foreach (obj->streams.memories64.memories, it, memory) {\n\t\tif (vaddr == memory->start_of_memory_range) {\n\t\t\tpaddr = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex += memory->data_size;\n\t}\n\treturn paddr;\n}\n\nstruct minidump_memory_info *r_bin_mdmp_get_mem_info(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\tRListIter *it;\n\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\n\tr_list_foreach (obj->streams.memory_infos, it, mem_info) {\n\t\tif (mem_info->allocation_base && vaddr == mem_info->base_address) {\n\t\t\treturn mem_info;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nut32 r_bin_mdmp_get_perm(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_info *mem_info;\n\n\tif (!(mem_info = r_bin_mdmp_get_mem_info(obj, vaddr))) {\n\t\t/* if there is no mem info in the dump, assume default permission */\n\t\treturn R_PERM_R;\n\t}\n\n\t/* FIXME: Have I got these mappings right, I am not sure I have!!! */\n\n\tswitch (mem_info->protect) {\n\tcase MINIDUMP_PAGE_READONLY:\n\t\treturn R_PERM_R;\n\tcase MINIDUMP_PAGE_READWRITE:\n\t\treturn R_PERM_RW;\n\tcase MINIDUMP_PAGE_EXECUTE:\n\t\treturn R_PERM_X;\n\tcase MINIDUMP_PAGE_EXECUTE_READ:\n\t\treturn R_PERM_RX;\n\tcase MINIDUMP_PAGE_EXECUTE_READWRITE:\n\t\treturn R_PERM_RWX;\n\tcase MINIDUMP_PAGE_NOACCESS:\n\tcase MINIDUMP_PAGE_WRITECOPY:\n\tcase MINIDUMP_PAGE_EXECUTE_WRITECOPY:\n\tcase MINIDUMP_PAGE_GUARD:\n\tcase MINIDUMP_PAGE_NOCACHE:\n\tcase MINIDUMP_PAGE_WRITECOMBINE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe32_bin(void *pe_bin_) {\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe32_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nstatic void r_bin_mdmp_free_pe64_bin(void *pe_bin_) {\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe_bin = pe_bin_;\n\tif (pe_bin) {\n\t\tsdb_free (pe_bin->bin->kv);\n\t\tPe64_r_bin_pe_free (pe_bin->bin);\n\t\tR_FREE (pe_bin);\n\t}\n}\n\nvoid r_bin_mdmp_free(struct r_bin_mdmp_obj *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tr_list_free (obj->streams.ex_threads);\n\tr_list_free (obj->streams.memories);\n\tr_list_free (obj->streams.memories64.memories);\n\tr_list_free (obj->streams.memory_infos);\n\tr_list_free (obj->streams.modules);\n\tr_list_free (obj->streams.operations);\n\tr_list_free (obj->streams.thread_infos);\n\tr_list_free (obj->streams.threads);\n\tr_list_free (obj->streams.token_infos);\n\tr_list_free (obj->streams.unloaded_modules);\n\tfree (obj->streams.exception);\n\tfree (obj->streams.system_info);\n\tfree (obj->streams.comments_a);\n\tfree (obj->streams.comments_w);\n\tfree (obj->streams.handle_data);\n\tfree (obj->streams.function_table);\n\tfree (obj->streams.misc_info.misc_info_1);\n\n\tr_list_free (obj->pe32_bins);\n\tr_list_free (obj->pe64_bins);\n\n\tr_buf_free (obj->b);\n\tfree (obj->hdr);\n\tobj->b = NULL;\n\tfree (obj);\n\n\treturn;\n}\n\nstatic void r_bin_mdmp_init_parsing(struct r_bin_mdmp_obj *obj) {\n\t/* TODO: Handle unions, can we? */\n\t/* FIXME: Why are we getting struct missing errors when it finds them */\n\tsdb_set (obj->kv, \"mdmp_mem_state.cparse\",\n\t\t\"enum mdmp_mem_state { MEM_COMMIT=0x1000, \"\n\t\t\"MEM_FREE=0x10000, MEM_RESERVE=0x02000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_mem_type.cparse\",\n\t\t\"enum mdmp_mem_type { MEM_IMAGE=0x1000000, \"\n\t\t\"MEM_MAPPED=0x40000, MEM_PRIVATE=0x20000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_page_protect.cparse\",\n\t\t\"enum mdmp_page_protect { PAGE_NOACCESS=1, \"\n\t\t\"PAGE_READONLY=2, PAGE_READWRITE=4, PAGE_WRITECOPY=8, \"\n\t\t\"PAGE_EXECUTE=0x10, PAGE_EXECUTE_READ=0x20, \"\n\t\t\"PAGE_EXECUTE_READWRITE=0x40, PAGE_EXECUTE_WRITECOPY=0x80, \"\n\t\t\"PAGE_GUARD=0x100, PAGE_NOCACHE=0x200, \"\n\t\t\"PAGE_WRITECOMBINE=0x400, PAGE_TARGETS_INVALID=0x40000000 };\",\n\t\t0);\n\n\tsdb_set (obj->kv, \"mdmp_misc1_flags.cparse\",\n\t\t\"enum mdmp_misc1_flags { MINIDUMP_MISC1_PROCESS_ID=1, \"\n\t\t\"MINIDUMP_MISC1_PROCESS_TIMES=2, \"\n\t\t\"MINIDUMP_MISC1_PROCESSOR_POWER_INFO=4 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_processor_architecture.cparse\",\n\t\t\"enum mdmp_processor_architecture { \"\n\t\t\"PROCESSOR_ARCHITECTURE_INTEL=0, \"\n\t\t\"PROCESSOR_ARCHITECTURE_ARM=5, \"\n\t\t\"PROCESSOR_ARCHITECTURE_IA64=6, \"\n\t\t\"PROCESSOR_ARCHITECTURE_AMD64=9, \"\n\t\t\"PROCESSOR_ARCHITECTURE_UNKNOWN=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_product_type.cparse\",\n\t\t\"enum mdmp_product_type { \"\n\t\t\"VER_NT_WORKSTATION=1, VER_NT_DOMAIN_CONTROLLER=2, \"\n\t\t\"VER_NT_SERVER=3 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_platform_id.cparse\",\n\t\t\"enum mdmp_platform_id { \"\n\t\t\"VER_PLATFORM_WIN32s=0, \"\n\t\t\"VER_PLATFORM_WIN32_WINDOWS=1, \"\n\t\t\"VER_PLATFORM_WIN32_NT=2 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_suite_mask.cparse\",\n\t\t\"enum mdmp_suite_mask { \"\n\t\t\"VER_SUITE_SMALLBUSINESS=1, VER_SUITE_ENTERPRISE=2, \"\n\t\t\"VER_SUITE_BACKOFFICE=4, VER_SUITE_TERMINAL=0x10, \"\n\t\t\"VER_SUITE_SMALLBUSINESS_RESTRICTED=0x20, \"\n\t\t\"VER_SUITE_EMBEDDEDNT=0x40, VER_SUITE_DATACENTER=0x80, \"\n\t\t\"VER_SUITE_SINGLEUSERTS=0x100, VER_SUITE_PERSONAL=0x200, \"\n\t\t\"VER_SUITE_BLADE=0x400, VER_SUITE_STORAGE_SERVER=0x2000, \"\n\t\t\"VER_SUITE_COMPUTE_SERVER=0x4000 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_callback_type.cparse\",\n\t\t\"enum mdmp_type { ModuleCallback=0,\"\n\t\t\"ThreadCallback=1, ThreadExCallback=2, \"\n\t\t\"IncludeThreadCallback=3, IncludeModuleCallback=4, \"\n\t\t\"MemoryCallback=5, CancelCallback=6, \"\n\t\t\"WriteKernelMinidumpCallback=7, \"\n\t\t\"KernelMinidumpStatusCallback=8, \"\n\t\t\"RemoveMemoryCallback=9, \"\n\t\t\"IncludeVmRegionCallback=10, \"\n\t\t\"IoStartCallback=11, IoWriteAllCallback=12, \"\n\t\t\"IoFinishCallback=13, ReadMemoryFailureCallback=14, \"\n\t\t\"SecondaryFlagsCallback=15 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_code.cparse\",\n\t\t\"enum mdmp_exception_code { \"\n\t\t\"DBG_CONTROL_C=0x40010005, \"\n\t\t\"EXCEPTION_GUARD_PAGE_VIOLATION=0x80000001, \"\n\t\t\"EXCEPTION_DATATYPE_MISALIGNMENT=0x80000002, \"\n\t\t\"EXCEPTION_BREAKPOINT=0x80000003, \"\n\t\t\"EXCEPTION_SINGLE_STEP=0x80000004, \"\n\t\t\"EXCEPTION_ACCESS_VIOLATION=0xc0000005, \"\n\t\t\"EXCEPTION_IN_PAGE_ERROR=0xc0000006, \"\n\t\t\"EXCEPTION_INVALID_HANDLE=0xc0000008, \"\n\t\t\"EXCEPTION_ILLEGAL_INSTRUCTION=0xc000001d, \"\n\t\t\"EXCEPTION_NONCONTINUABLE_EXCEPTION=0xc0000025, \"\n\t\t\"EXCEPTION_INVALID_DISPOSITION=0xc0000026, \"\n\t\t\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED=0xc000008c, \"\n\t\t\"EXCEPTION_FLOAT_DENORMAL_OPERAND=0xc000008d, \"\n\t\t\"EXCEPTION_FLOAT_DIVIDE_BY_ZERO=0xc000008e, \"\n\t\t\"EXCEPTION_FLOAT_INEXACT_RESULT=0xc000008f, \"\n\t\t\"EXCEPTION_FLOAT_INVALID_OPERATION=0xc0000090, \"\n\t\t\"EXCEPTION_FLOAT_OVERFLOW=0xc0000091, \"\n\t\t\"EXCEPTION_FLOAT_STACK_CHECK=0xc0000092, \"\n\t\t\"EXCEPTION_FLOAT_UNDERFLOW=0xc0000093, \"\n\t\t\"EXCEPTION_INTEGER_DIVIDE_BY_ZERO=0xc0000094, \"\n\t\t\"EXCEPTION_INTEGER_OVERFLOW=0xc0000095, \"\n\t\t\"EXCEPTION_PRIVILEGED_INSTRUCTION=0xc0000096, \"\n\t\t\"EXCEPTION_STACK_OVERFLOW=0xc00000fd, \"\n\t\t\"EXCEPTION_POSSIBLE_DEADLOCK=0xc0000194 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_exception_flags.cparse\",\n\t\t\"enum mdmp_exception_flags { \"\n\t\t\"EXCEPTION_CONTINUABLE=0, \"\n\t\t\"EXCEPTION_NONCONTINUABLE=1 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_handle_object_information_type.cparse\",\n\t\t\"enum mdmp_handle_object_information_type { \"\n\t\t\"MiniHandleObjectInformationNone=0, \"\n\t\t\"MiniThreadInformation1=1, MiniMutantInformation1=2, \"\n\t\t\"MiniMutantInformation2=3, MiniMutantProcessInformation1=4, \"\n\t\t\"MiniProcessInformation2=5 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_secondary_flags.cparse\",\n\t\t\"enum mdmp_secondary_flags { \"\n\t\t\"MiniSecondaryWithoutPowerInfo=0 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_stream_type.cparse\",\n\t\t\"enum mdmp_stream_type { UnusedStream=0, \"\n\t\t\"ReservedStream0=1, ReservedStream1=2, \"\n\t\t\"ThreadListStream=3, ModuleListStream=4, \"\n\t\t\"MemoryListStream=5, ExceptionStream=6, \"\n\t\t\"SystemInfoStream=7, ThreadExListStream=8, \"\n\t\t\"Memory64ListStream=9, CommentStreamA=10, \"\n\t\t\"CommentStreamW=11, HandleDataStream=12, \"\n\t\t\"FunctionTableStream=13, UnloadedModuleListStream=14, \"\n\t\t\"MiscInfoStream=15, MemoryInfoListStream=16, \"\n\t\t\"ThreadInfoListStream=17, \"\n\t\t\"HandleOperationListStream=18, \"\n\t\t\"LastReservedStream=0xffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_type.cparse\", \"enum mdmp_type { \"\n\t\t\"MiniDumpNormal=0x0, \"\n\t\t\"MiniDumpWithDataSegs=0x1, \"\n\t\t\"MiniDumpWithFullMemory=0x2, \"\n\t\t\"MiniDumpWithHandleData=0x4, \"\n\t\t\"MiniDumpFilterMemory=0x8, \"\n\t\t\"MiniDumpScanMemory=0x10, \"\n\t\t\"MiniDumpWithUnloadedModule=0x20, \"\n\t\t\"MiniDumpWihinDirectlyReferencedMemory=0x40, \"\n\t\t\"MiniDumpFilterWithModulePaths=0x80,\"\n\t\t\"MiniDumpWithProcessThreadData=0x100, \"\n\t\t\"MiniDumpWithPrivateReadWriteMemory=0x200, \"\n\t\t\"MiniDumpWithoutOptionalDate=0x400, \"\n\t\t\"MiniDumpWithFullMemoryInfo=0x800, \"\n\t\t\"MiniDumpWithThreadInfo=0x1000, \"\n\t\t\"MiniDumpWithCodeSegs=0x2000, \"\n\t\t\"MiniDumpWithoutAuxiliaryState=0x4000, \"\n\t\t\"MiniDumpWithFullAuxiliaryState=0x8000, \"\n\t\t\"MiniDumpWithPrivateWriteCopyMemory=0x10000, \"\n\t\t\"MiniDumpIgnoreInaccessibleMemory=0x20000, \"\n\t\t\"MiniDumpWithTokenInformation=0x40000, \"\n\t\t\"MiniDumpWithModuleHeaders=0x80000, \"\n\t\t\"MiniDumpFilterTriage=0x100000, \"\n\t\t\"MiniDumpValidTypeFlags=0x1fffff };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_module_write_flags.cparse\",\n\t\t\"enum mdmp_module_write_flags { \"\n\t\t\"ModuleWriteModule=0, ModuleWriteDataSeg=2, \"\n\t\t\"ModuleWriteMiscRecord=4, ModuleWriteCvRecord=8, \"\n\t\t\"ModuleReferencedByMemory=0x10, ModuleWriteTlsData=0x20, \"\n\t\t\"ModuleWriteCodeSegs=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_thread_write_flags.cparse\",\n\t\t\"enum mdmp_thread_write_flags { \"\n\t\t\"ThreadWriteThread=0, ThreadWriteStack=2, \"\n\t\t\"ThreadWriteContext=4, ThreadWriteBackingStore=8, \"\n\t\t\"ThreadWriteInstructionWindow=0x10, \"\n\t\t\"ThreadWriteThreadData=0x20, \"\n\t\t\"ThreadWriteThreadInfo=0x40 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_context_flags.cparse\",\n\t\t\"enum mdmp_context_flags { CONTEXT_i386=0x10000, \"\n\t\t\"CONTEXT_CONTROL=0x10001, CONTEXT_INTEGER=0x10002, \"\n\t\t\"CONTEXT_SEGMENTS=0x10004, CONTEXT_FLOATING_POINT=0x10008, \"\n\t\t\"CONTEXT_DEBUG_REGISTERS=0x10010, \"\n\t\t\"CONTEXT_EXTENDED_REGISTERS=0x10020 };\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_location_descriptor.format\",\n\t\t\"dd DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_location_descriptor64.format\",\n\t\t\"qq DataSize RVA\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor.format\", \"q? \"\n\t\t\"StartOfMemoryRange \"\n\t\t\"(mdmp_location_descriptor)Memory\", 0);\n\tsdb_set (obj->kv, \"mdmp_memory_descriptor64.format\", \"qq \"\n\t\t\"StartOfMemoryRange DataSize\", 0);\n\n#if 0\n\t/* TODO: Flag dependent thus not fully implemented */\n\tsdb_set (obj->kv, \"mdmp_context.format\", \"[4]B \"\n\t\t\"(mdmp_context_flags)ContextFlags\", 0);\n#endif\n\n\tsdb_set (obj->kv, \"mdmp_vs_fixedfileinfo.format\", \"ddddddddddddd \"\n\t\t\"dwSignature dwStrucVersion dwFileVersionMs \"\n\t\t\"dwFileVersionLs dwProductVersionMs \"\n\t\t\"dwProductVersionLs dwFileFlagsMask dwFileFlags \"\n\t\t\"dwFileOs dwFileType dwFileSubtype dwFileDateMs \"\n\t\t\"dwFileDateLs\", 0);\n\n\tsdb_set (obj->kv, \"mdmp_string.format\", \"dZ Length Buffer\", 0);\n}\n\nstatic void read_hdr(RBuffer *b, struct minidump_header *hdr) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, 0, R_BUF_SET);\n\thdr->signature = r_buf_read_le32 (b);\n\thdr->version = r_buf_read_le32 (b);\n\thdr->number_of_streams = r_buf_read_le32 (b);\n\thdr->stream_directory_rva = r_buf_read_le32 (b);\n\thdr->check_sum = r_buf_read_le32 (b);\n\thdr->reserved = r_buf_read_le32 (b);\n\thdr->flags = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {\n\tobj->hdr = R_NEW (struct minidump_header);\n\tif (!obj->hdr) {\n\t\treturn false;\n\t}\n\tread_hdr (obj->b, obj->hdr);\n\n\tif (obj->hdr->number_of_streams == 0) {\n\t\teprintf (\"[WARN] No streams present!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->stream_directory_rva < sizeof (struct minidump_header))\n\t{\n\t\teprintf (\"[ERROR] RVA for directory resides in the header!\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->hdr->check_sum) {\n\t\teprintf (\"[INFO] Checksum present but needs validating!\\n\");\n\t\treturn false;\n\t}\n\n\tsdb_num_set (obj->kv, \"mdmp.hdr.time_date_stamp\", obj->hdr->time_date_stamp, 0);\n\tsdb_num_set (obj->kv, \"mdmp.hdr.flags\", obj->hdr->flags, 0);\n\tsdb_num_set (obj->kv, \"mdmp_header.offset\", 0, 0);\n\tsdb_set (obj->kv, \"mdmp_header.format\", \"[4]zddddt[8]B Signature \"\n\t\t\"Version NumberOfStreams StreamDirectoryRVA CheckSum \"\n\t\t\"TimeDateStamp (mdmp_type)Flags\", 0);\n\n\treturn true;\n}\n\nstatic struct minidump_module *read_module(RBuffer *b, ut64 addr) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) == -1) {\n\t\treturn NULL;\n\t}\n\tstruct minidump_module *module = R_NEW0 (struct minidump_module);\n\tif (!module) {\n\t\treturn NULL;\n\t}\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn module;\n}\n\nstatic void read_memory64_list(RBuffer *b, ut64 addr, struct minidump_memory64_list *memory64_list) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmemory64_list->number_of_memory_ranges = r_buf_read_le64 (b);\n\tmemory64_list->base_rva = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic void read_desc(RBuffer *b, ut64 addr, struct minidump_memory_descriptor64 *desc) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tdesc->start_of_memory_range = r_buf_read_le64 (b);\n\tdesc->data_size = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}\n\nstatic bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tr_strf_buffer (128);\n\tstruct minidump_handle_operation_list handle_operation_list;\n\tstruct minidump_memory_list memory_list;\n\tstruct minidump_memory64_list memory64_list;\n\tstruct minidump_memory_info_list memory_info_list;\n\tstruct minidump_module_list module_list;\n\tstruct minidump_thread_list thread_list;\n\tstruct minidump_thread_ex_list thread_ex_list;\n\tstruct minidump_thread_info_list thread_info_list;\n\tstruct minidump_token_info_list token_info_list;\n\tstruct minidump_unloaded_module_list unloaded_module_list;\n\tut64 offset;\n\tint i, r;\n\n\t/* We could confirm data sizes but a malcious MDMP will always get around\n\t** this! But we can ensure that the data is not outside of the file */\n\tif ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));\n\t\tif (r != sizeof (thread_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list.number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list.number_of_modules),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (module_list);\n\t\tfor (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {\n\t\t\tstruct minidump_module *module = read_module (obj->b, offset);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tr_list_append (obj->streams.modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));\n\t\tif (r != sizeof (memory_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_list);\n\t\tfor (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {\n\t\t\tstruct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));\n\t\t\tif (r != sizeof (*desc)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = R_NEW (struct minidump_exception_stream);\n\t\tif (!obj->streams.exception) {\n\t\t\tbreak;\n\t\t}\n\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));\n\t\tif (r != sizeof (*obj->streams.exception)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\t\t\t\t   \"ExceptionRecord ExceptionAddress \"\n\t\t\t\t\t\t\t   \"NumberParameters __UnusedAlignment \"\n\t\t\t\t\t\t\t   \"ExceptionInformation\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\t\t\t\t\t  \"ThreadId __Alignment \"\n\t\t\t\t\t\t\t\t  \"(mdmp_exception)ExceptionRecord \"\n\t\t\t\t\t\t\t\t  \"(mdmp_location_descriptor)ThreadContext\",\n\t\t\t0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = R_NEW (struct minidump_system_info);\n\t\tif (!obj->streams.system_info) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));\n\t\tif (r != sizeof (*obj->streams.system_info)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));\n\t\tif (r != sizeof (thread_ex_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tr_strf (\"d[%d]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list.number_of_threads),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (thread_ex_list);\n\t\tfor (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {\n\t\t\tstruct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);\n\t\t\tif (!thread) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));\n\t\t\tif (r != sizeof (*thread)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.ex_threads, thread);\n\t\t\toffset += sizeof (*thread);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tread_memory64_list (obj->b, entry->location.rva, &memory64_list);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tr_strf (\"qq[%\"PFMT64d\"]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list.base_rva;\n\t\toffset = entry->location.rva + sizeof (memory64_list);\n\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {\n\t\t\tstruct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_desc (obj->b, offset, desc);\n\t\t\tr_list_append (obj->streams.memories64.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_a) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_w) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);\n\t\tif (!obj->streams.handle_data) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));\n\t\tif (r != sizeof (*obj->streams.handle_data)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = R_NEW (struct minidump_function_table_stream);\n\t\tif (!obj->streams.function_table) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));\n\t\tif (r != sizeof (*obj->streams.function_table)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));\n\t\tif (r != sizeof (unloaded_module_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (unloaded_module_list);\n\t\tfor (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));\n\t\t\tif (r != sizeof (*module)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.unloaded_modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);\n\t\tif (!obj->streams.misc_info.misc_info_1) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));\n\t\tif (r != sizeof (*obj->streams.misc_info.misc_info_1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));\n\t\tif (r != sizeof (memory_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tr_strf (\"ddq[%\"PFMT64d\"]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list.number_of_entries),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_info_list);\n\t\tfor (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_memory_info *info = R_NEW (struct minidump_memory_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memory_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));\n\t\tif (r != sizeof (thread_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (thread_info_list);\n\t\tfor (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_thread_info *info = R_NEW (struct minidump_thread_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.thread_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));\n\t\tif (r != sizeof (handle_operation_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\toffset = entry->location.rva + sizeof (handle_operation_list);\n\t\tfor (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));\n\t\t\tif (r != sizeof (*op)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.operations, op);\n\t\t\toffset += sizeof (*op);\n\t\t}\n\n\t\tbreak;\n\tcase TOKEN_STREAM:\n\t\t/* TODO: Not fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));\n\t\tif (r != sizeof (token_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_token_info.format\", \"ddq \"\n\t\t\t\"TokenSize TokenId TokenHandle\", 0);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_token_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_token_info_list.format\", \"dddd \"\n\t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n\n\t\toffset = entry->location.rva + sizeof (token_info_list);\n\t\tfor (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_token_info *info = R_NEW (struct minidump_token_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.token_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %d\\n\", entry->stream_type);\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nstatic bool read_entry(RBuffer *b, ut64 addr, struct minidump_directory *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn false;\n\t}\n\tentry->stream_type = r_buf_read_le32 (b);\n\tentry->location.data_size = r_buf_read_le32 (b);\n\tentry->location.rva = r_buf_read_le32 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tut32 i;\n\tstruct minidump_directory entry;\n\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tut64 bytes_left = rvadir < obj->size ? obj->size - rvadir : 0;\n\tsize_t max_entries = R_MIN (obj->hdr->number_of_streams, bytes_left / sizeof (struct minidump_directory));\n\tif (max_entries < obj->hdr->number_of_streams) {\n\t\teprintf (\"[ERROR] Number of streams = %u is greater than is supportable by bin size\\n\",\n\t\t\t\tobj->hdr->number_of_streams);\n\t}\n\t/* Parse each entry in the directory */\n\tfor (i = 0; i < max_entries; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tif (read_entry (obj->b, rvadir + delta, &entry)) {\n\t\t\tif (!r_bin_mdmp_init_directory_entry (obj, &entry)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool r_bin_mdmp_patch_pe_headers(RBuffer *pe_buf) {\n\tint i;\n\tPe64_image_dos_header dos_hdr;\n\tPe64_image_nt_headers nt_hdr;\n\n\tPe64_read_dos_header (pe_buf, &dos_hdr);\n\tPe64_read_nt_headers (pe_buf, dos_hdr.e_lfanew, &nt_hdr);\n\n\t/* Patch RawData in headers */\n\tut64 sect_hdrs_off = dos_hdr.e_lfanew + 4 + sizeof (Pe64_image_file_header) + nt_hdr.file_header.SizeOfOptionalHeader;\n\tPe64_image_section_header section_hdr;\n\tfor (i = 0; i < nt_hdr.file_header.NumberOfSections; i++) {\n\t\tPe64_read_image_section_header (pe_buf, sect_hdrs_off + i * sizeof (section_hdr), &section_hdr);\n\t\tsection_hdr.PointerToRawData = section_hdr.VirtualAddress;\n\t\tPe64_write_image_section_header (pe_buf, sect_hdrs_off + i * sizeof (section_hdr), &section_hdr);\n\t}\n\n\treturn true;\n}\n\nstatic int check_pe32_buf(RBuffer *buf, ut64 length) {\n\tunsigned int idx;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = (r_buf_read8_at (buf, 0x3c) | (r_buf_read8_at (buf, 0x3d)<<8));\n\tif (length > idx + 0x18 + 2) {\n\t\tut8 tmp1[2], tmp2[2], tmp3[2];\n\t\tr_buf_read_at (buf, 0, tmp1, 2);\n\t\tr_buf_read_at (buf, idx, tmp2, 2);\n\t\tr_buf_read_at (buf, idx + 0x18, tmp3, 2);\n\t\tif (!memcmp (tmp1, \"MZ\", 2) && !memcmp (tmp2, \"PE\", 2) && !memcmp (tmp3, \"\\x0b\\x01\", 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int check_pe64_buf(RBuffer *buf, ut64 length) {\n\tint idx, ret = false;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = r_buf_read8_at (buf, 0x3c) | (r_buf_read8_at (buf, 0x3d)<<8);\n\tif (length >= idx + 0x20) {\n\t\tut8 tmp1[2], tmp2[2], tmp3[2];\n\t\tr_buf_read_at (buf, 0, tmp1, 2);\n\t\tr_buf_read_at (buf, idx, tmp2, 2);\n\t\tr_buf_read_at (buf, idx + 0x18, tmp3, 2);\n\t\tif (!memcmp (tmp1, \"MZ\", 2) && !memcmp (tmp2, \"PE\", 2) && !memcmp (tmp3, \"\\x0b\\x02\", 2)) {\n\t\t\tret = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic bool r_bin_mdmp_init_pe_bins(struct r_bin_mdmp_obj *obj) {\n\tbool dup;\n\tut64 paddr;\n\tstruct minidump_module *module;\n\tstruct Pe32_r_bin_mdmp_pe_bin *pe32_bin, *pe32_dup;\n\tstruct Pe64_r_bin_mdmp_pe_bin *pe64_bin, *pe64_dup;\n\tRBuffer *buf = NULL;\n\tRListIter *it, *it_dup;\n\n\tr_list_foreach (obj->streams.modules, it, module) {\n\t\t/* Duplicate modules can appear in the MDMP module list,\n\t\t** filtering them out seems to be the correct behaviour */\n\t\tif (!(paddr = r_bin_mdmp_get_paddr (obj, module->base_of_image))) {\n\t\t\tcontinue;\n\t\t}\n\t\tut8 *b = R_NEWS (ut8, module->size_of_image);\n\t\tif (!b) {\n\t\t\tcontinue;\n\t\t}\n\t\tint r = r_buf_read_at (obj->b, paddr, b, module->size_of_image);\n\t\tr_buf_free (buf);\n\t\tbuf = r_buf_new_with_bytes (b, r);\n\t\tdup = false;\n\t\tif (check_pe32_buf (buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe32_bins, it_dup, pe32_dup) {\n\t\t\t\tif (pe32_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe32_bin = R_NEW0 (struct Pe32_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe32_bin->vaddr = module->base_of_image;\n\t\t\tpe32_bin->paddr = paddr;\n\t\t\tpe32_bin->bin = Pe32_r_bin_pe_new_buf (buf, 0);\n\t\t\tif (!pe32_bin->bin) {\n\t\t\t\tfree (pe32_bin);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_list_append (obj->pe32_bins, pe32_bin);\n\t\t} else if (check_pe64_buf (buf, module->size_of_image)) {\n\t\t\tr_list_foreach(obj->pe64_bins, it_dup, pe64_dup) {\n\t\t\t\tif (pe64_dup->vaddr == module->base_of_image) {\n\t\t\t\t\tdup = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(pe64_bin = R_NEW0 (struct Pe64_r_bin_mdmp_pe_bin))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_bin_mdmp_patch_pe_headers (buf);\n\t\t\tpe64_bin->vaddr = module->base_of_image;\n\t\t\tpe64_bin->paddr = paddr;\n\t\t\tpe64_bin->bin = Pe64_r_bin_pe_new_buf (buf, 0);\n\n\t\t\tr_list_append (obj->pe64_bins, pe64_bin);\n\t\t}\n\t}\n\tr_buf_free (buf);\n\tbuf = NULL;\n\treturn true;\n}\n\nstatic int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct r_bin_mdmp_obj *r_bin_mdmp_new_buf(RBuffer *buf) {\n\tbool fail = false;\n\tstruct r_bin_mdmp_obj *obj = R_NEW0 (struct r_bin_mdmp_obj);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tobj->kv = sdb_new0 ();\n\tobj->size = (ut32) r_buf_size (buf);\n\n\tfail |= (!(obj->streams.ex_threads = r_list_new ()));\n\tfail |= (!(obj->streams.memories = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.memories64.memories = r_list_new ()));\n\tfail |= (!(obj->streams.memory_infos = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.modules = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.operations = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.thread_infos = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.token_infos = r_list_newf ((RListFree)free)));\n\tfail |= (!(obj->streams.threads = r_list_new ()));\n\tfail |= (!(obj->streams.unloaded_modules = r_list_newf ((RListFree)free)));\n\n\tfail |= (!(obj->pe32_bins = r_list_newf (r_bin_mdmp_free_pe32_bin)));\n\tfail |= (!(obj->pe64_bins = r_list_newf (r_bin_mdmp_free_pe64_bin)));\n\n\tif (fail) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\tobj->b = r_buf_ref (buf);\n\tif (!r_bin_mdmp_init (obj)) {\n\t\tr_bin_mdmp_free (obj);\n\t\treturn NULL;\n\t}\n\n\treturn obj;\n}\n"], "filenames": ["libr/bin/format/mdmp/mdmp.c"], "buggy_code_start_loc": [372], "buggy_code_end_loc": [853], "fixing_code_start_loc": [372], "fixing_code_end_loc": [859], "type": "CWE-400", "message": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.", "other": {"cve": {"id": "CVE-2022-0476", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-23T17:15:21.090", "lastModified": "2022-04-08T13:57:19.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4."}, {"lang": "es", "value": "Una Denegaci\u00f3n de Servicio en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.6.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.4", "matchCriteriaId": "257C5522-E8C9-42F8-8891-50EDBDD3E873"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/81ddfbda-6c9f-4b69-83ff-85b15141e35d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b"}}