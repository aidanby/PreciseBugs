{"buggy_code": ["/* $Id: table.c,v 1.58 2010/08/09 11:59:19 htrb Exp $ */\n/* \n * HTML table\n */\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include \"fm.h\"\n#include \"html.h\"\n#include \"parsetagx.h\"\n#include \"Str.h\"\n#include \"myctype.h\"\n\nint symbol_width = 0;\nint symbol_width0 = 0;\n\n#define RULE_WIDTH symbol_width\n#define RULE(mode,n) (((mode) == BORDER_THICK) ? ((n) + 16) : (n))\n#define TK_VERTICALBAR(mode) RULE(mode,5)\n\n#define BORDERWIDTH     2\n#define BORDERHEIGHT    1\n#define NOBORDERWIDTH   1\n#define NOBORDERHEIGHT  0\n\n#define HTT_X   1\n#define HTT_Y   2\n#define HTT_ALIGN  0x30\n#define HTT_LEFT   0x00\n#define HTT_CENTER 0x10\n#define HTT_RIGHT  0x20\n#define HTT_TRSET  0x40\n#define HTT_VALIGN 0x700\n#define HTT_TOP    0x100\n#define HTT_MIDDLE 0x200\n#define HTT_BOTTOM 0x400\n#define HTT_VTRSET 0x800\n#ifdef NOWRAP\n#define HTT_NOWRAP  4\n#endif\t\t\t\t/* NOWRAP */\n#define TAG_IS(s,tag,len) (strncasecmp(s,tag,len)==0&&(s[len] == '>' || IS_SPACE((int)s[len])))\n\n#ifndef max\n#define max(a,b)        ((a) > (b) ? (a) : (b))\n#endif\t\t\t\t/* not max */\n#ifndef min\n#define min(a,b)        ((a) > (b) ? (b) : (a))\n#endif\t\t\t\t/* not min */\n#ifndef abs\n#define abs(a)          ((a) >= 0. ? (a) : -(a))\n#endif\t\t\t\t/* not abs */\n\n#define set_prevchar(x,y,n) Strcopy_charp_n((x),(y),(n))\n#define set_space_to_prevchar(x) Strcopy_charp_n((x),\" \",1)\n\n#ifdef MATRIX\n#ifndef MESCHACH\n#include \"matrix.c\"\n#endif\t\t\t\t/* not MESCHACH */\n#endif\t\t\t\t/* MATRIX */\n\n#ifdef MATRIX\nint correct_table_matrix(struct table *, int, int, int, double);\nvoid set_table_matrix(struct table *, int);\n#endif\t\t\t\t/* MATRIX */\n\n#ifdef MATRIX\nstatic double\nweight(int x)\n{\n\n    if (x < COLS)\n\treturn (double)x;\n    else\n\treturn COLS * (log((double)x / COLS) + 1.);\n}\n\nstatic double\nweight2(int a)\n{\n    return (double)a / COLS * 4 + 1.;\n}\n\n#define sigma_td(a)       (0.5*weight2(a))\t/* <td width=...> */\n#define sigma_td_nw(a)    (32*weight2(a))\t/* <td ...> */\n#define sigma_table(a)    (0.25*weight2(a))\t/* <table width=...> */\n#define sigma_table_nw(a) (2*weight2(a))\t/* <table...> */\n#else\t\t\t\t/* not MATRIX */\n#define LOG_MIN 1.0\nstatic double\nweight3(int x)\n{\n    if (x < 0.1)\n\treturn 0.1;\n    if (x < LOG_MIN)\n\treturn (double)x;\n    else\n\treturn LOG_MIN * (log((double)x / LOG_MIN) + 1.);\n}\n#endif\t\t\t\t/* not MATRIX */\n\nstatic int\nbsearch_2short(short e1, short *ent1, short e2, short *ent2, int base,\n\t       short *indexarray, int nent)\n{\n    int n = nent;\n    int k = 0;\n\n    int e = e1 * base + e2;\n    while (n > 0) {\n\tint nn = n / 2;\n\tint idx = indexarray[k + nn];\n\tint ne = ent1[idx] * base + ent2[idx];\n\tif (ne == e) {\n\t    k += nn;\n\t    break;\n\t}\n\telse if (ne < e) {\n\t    n -= nn + 1;\n\t    k += nn + 1;\n\t}\n\telse {\n\t    n = nn;\n\t}\n    }\n    return k;\n}\n\nstatic int\nbsearch_double(double e, double *ent, short *indexarray, int nent)\n{\n    int n = nent;\n    int k = 0;\n\n    while (n > 0) {\n\tint nn = n / 2;\n\tint idx = indexarray[k + nn];\n\tdouble ne = ent[idx];\n\tif (ne == e) {\n\t    k += nn;\n\t    break;\n\t}\n\telse if (ne > e) {\n\t    n -= nn + 1;\n\t    k += nn + 1;\n\t}\n\telse {\n\t    n = nn;\n\t}\n    }\n    return k;\n}\n\nstatic int\nceil_at_intervals(int x, int step)\n{\n    int mo = x % step;\n    if (mo > 0)\n\tx += step - mo;\n    else if (mo < 0)\n\tx -= mo;\n    return x;\n}\n\nstatic int\nfloor_at_intervals(int x, int step)\n{\n    int mo = x % step;\n    if (mo > 0)\n\tx -= mo;\n    else if (mo < 0)\n\tx += step - mo;\n    return x;\n}\n\n#define round(x) ((int)floor((x)+0.5))\n\n#ifndef MATRIX\nstatic void\ndv2sv(double *dv, short *iv, int size)\n{\n    int i, k, iw;\n    short *indexarray;\n    double *edv;\n    double w = 0., x;\n\n    indexarray = NewAtom_N(short, size);\n    edv = NewAtom_N(double, size);\n    for (i = 0; i < size; i++) {\n\tiv[i] = (short) ceil(dv[i]);\n\tedv[i] = (double)iv[i] - dv[i];\n    }\n\n    w = 0.;\n    for (k = 0; k < size; k++) {\n\tx = edv[k];\n\tw += x;\n\ti = bsearch_double(x, edv, indexarray, k);\n\tif (k > i) {\n\t    int ii;\n\t    for (ii = k; ii > i; ii--)\n\t\tindexarray[ii] = indexarray[ii - 1];\n\t}\n\tindexarray[i] = k;\n    }\n    iw = min((int)(w + 0.5), size);\n    if (iw <= 1)\n\treturn;\n    x = edv[(int)indexarray[iw - 1]];\n    for (i = 0; i < size; i++) {\n\tk = indexarray[i];\n\tif (i >= iw && abs(edv[k] - x) > 1e-6)\n\t    break;\n\tiv[k]--;\n    }\n}\n#endif\n\nstatic int\ntable_colspan(struct table *t, int row, int col)\n{\n    int i;\n    for (i = col + 1; i <= t->maxcol && (t->tabattr[row][i] & HTT_X); i++) ;\n    return i - col;\n}\n\nstatic int\ntable_rowspan(struct table *t, int row, int col)\n{\n    int i;\n    if (!t->tabattr[row])\n\treturn 0;\n    for (i = row + 1; i <= t->maxrow && t->tabattr[i] &&\n\t (t->tabattr[i][col] & HTT_Y); i++) ;\n    return i - row;\n}\n\nstatic int\nminimum_cellspacing(int border_mode)\n{\n    switch (border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\treturn RULE_WIDTH;\n    case BORDER_NONE:\n\treturn 1;\n    default:\n\t/* not reached */\n\treturn 0;\n    }\n}\n\nstatic int\ntable_border_width(struct table *t)\n{\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\treturn t->maxcol * t->cellspacing + 2 * (RULE_WIDTH + t->cellpadding);\n    case BORDER_NOWIN:\n    case BORDER_NONE:\n\treturn t->maxcol * t->cellspacing;\n    default:\n\t/* not reached */\n\treturn 0;\n    }\n}\n\nstruct table *\nnewTable()\n{\n    struct table *t;\n    int i, j;\n\n    t = New(struct table);\n    t->max_rowsize = MAXROW;\n    t->tabdata = New_N(GeneralList **, MAXROW);\n    t->tabattr = New_N(table_attr *, MAXROW);\n    t->tabheight = NewAtom_N(short, MAXROW);\n#ifdef ID_EXT\n    t->tabidvalue = New_N(Str *, MAXROW);\n    t->tridvalue = New_N(Str, MAXROW);\n#endif\t\t\t\t/* ID_EXT */\n\n    for (i = 0; i < MAXROW; i++) {\n\tt->tabdata[i] = NULL;\n\tt->tabattr[i] = 0;\n\tt->tabheight[i] = 0;\n#ifdef ID_EXT\n\tt->tabidvalue[i] = NULL;\n\tt->tridvalue[i] = NULL;\n#endif\t\t\t\t/* ID_EXT */\n    }\n    for (j = 0; j < MAXCOL; j++) {\n\tt->tabwidth[j] = 0;\n\tt->minimum_width[j] = 0;\n\tt->fixed_width[j] = 0;\n    }\n    t->cell.maxcell = -1;\n    t->cell.icell = -1;\n    t->ntable = 0;\n    t->tables_size = 0;\n    t->tables = NULL;\n#ifdef MATRIX\n    t->matrix = NULL;\n    t->vector = NULL;\n#endif\t\t\t\t/* MATRIX */\n#if 0\n    t->tabcontentssize = 0;\n    t->indent = 0;\n    t->linfo.prev_ctype = PC_ASCII;\n    t->linfo.prev_spaces = -1;\n#endif\n    t->linfo.prevchar = Strnew_size(8);\n    set_prevchar(t->linfo.prevchar, \"\", 0);\n    t->trattr = 0;\n\n    t->caption = Strnew();\n    t->suspended_data = NULL;\n#ifdef ID_EXT\n    t->id = NULL;\n#endif\n    return t;\n}\n\nstatic void\ncheck_row(struct table *t, int row)\n{\n    int i, r;\n    GeneralList ***tabdata;\n    table_attr **tabattr;\n    short *tabheight;\n#ifdef ID_EXT\n    Str **tabidvalue;\n    Str *tridvalue;\n#endif\t\t\t\t/* ID_EXT */\n\n    if (row >= t->max_rowsize) {\n\tr = max(t->max_rowsize * 2, row + 1);\n\ttabdata = New_N(GeneralList **, r);\n\ttabattr = New_N(table_attr *, r);\n\ttabheight = NewAtom_N(short, r);\n#ifdef ID_EXT\n\ttabidvalue = New_N(Str *, r);\n\ttridvalue = New_N(Str, r);\n#endif\t\t\t\t/* ID_EXT */\n\tfor (i = 0; i < t->max_rowsize; i++) {\n\t    tabdata[i] = t->tabdata[i];\n\t    tabattr[i] = t->tabattr[i];\n\t    tabheight[i] = t->tabheight[i];\n#ifdef ID_EXT\n\t    tabidvalue[i] = t->tabidvalue[i];\n\t    tridvalue[i] = t->tridvalue[i];\n#endif\t\t\t\t/* ID_EXT */\n\t}\n\tfor (; i < r; i++) {\n\t    tabdata[i] = NULL;\n\t    tabattr[i] = NULL;\n\t    tabheight[i] = 0;\n#ifdef ID_EXT\n\t    tabidvalue[i] = NULL;\n\t    tridvalue[i] = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\t}\n\tt->tabdata = tabdata;\n\tt->tabattr = tabattr;\n\tt->tabheight = tabheight;\n#ifdef ID_EXT\n\tt->tabidvalue = tabidvalue;\n\tt->tridvalue = tridvalue;\n#endif\t\t\t\t/* ID_EXT */\n\tt->max_rowsize = r;\n    }\n\n    if (t->tabdata[row] == NULL) {\n\tt->tabdata[row] = New_N(GeneralList *, MAXCOL);\n\tt->tabattr[row] = NewAtom_N(table_attr, MAXCOL);\n#ifdef ID_EXT\n\tt->tabidvalue[row] = New_N(Str, MAXCOL);\n#endif\t\t\t\t/* ID_EXT */\n\tfor (i = 0; i < MAXCOL; i++) {\n\t    t->tabdata[row][i] = NULL;\n\t    t->tabattr[row][i] = 0;\n#ifdef ID_EXT\n\t    t->tabidvalue[row][i] = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\t}\n    }\n}\n\nvoid\npushdata(struct table *t, int row, int col, char *data)\n{\n    check_row(t, row);\n    if (t->tabdata[row][col] == NULL)\n\tt->tabdata[row][col] = newGeneralList();\n\n    pushText(t->tabdata[row][col], data ? data : \"\");\n}\n\nvoid\nsuspend_or_pushdata(struct table *tbl, char *line)\n{\n    if (tbl->flag & TBL_IN_COL)\n\tpushdata(tbl, tbl->row, tbl->col, line);\n    else {\n\tif (!tbl->suspended_data)\n\t    tbl->suspended_data = newTextList();\n\tpushText(tbl->suspended_data, line ? line : \"\");\n    }\n}\n\n#ifdef USE_M17N\n#define PUSH_TAG(str,n) Strcat_charp_n(tagbuf, str, n)\n#else\n#define PUSH_TAG(str,n) Strcat_char(tagbuf, *str)\n#endif\n\nint visible_length_offset = 0;\nint\nvisible_length(char *str)\n{\n    int len = 0, n, max_len = 0;\n    int status = R_ST_NORMAL;\n    int prev_status = status;\n    Str tagbuf = Strnew();\n    char *t, *r2;\n    int amp_len = 0;\n\n    while (*str) {\n\tprev_status = status;\n\tif (next_status(*str, &status)) {\n#ifdef USE_M17N\n\t    len += get_mcwidth(str);\n\t    n = get_mclen(str);\n\t}\n\telse {\n\t    n = 1;\n\t}\n#else\n\t    len++;\n\t}\n#endif\n\tif (status == R_ST_TAG0) {\n\t    Strclear(tagbuf);\n\t    PUSH_TAG(str, n);\n\t}\n\telse if (status == R_ST_TAG || status == R_ST_DQUOTE\n\t\t || status == R_ST_QUOTE || status == R_ST_EQL\n\t\t || status == R_ST_VALUE) {\n\t    PUSH_TAG(str, n);\n\t}\n\telse if (status == R_ST_AMP) {\n\t    if (prev_status == R_ST_NORMAL) {\n\t\tStrclear(tagbuf);\n\t\tlen--;\n\t\tamp_len = 0;\n\t    }\n\t    else {\n\t\tPUSH_TAG(str, n);\n\t\tamp_len++;\n\t    }\n\t}\n\telse if (status == R_ST_NORMAL && prev_status == R_ST_AMP) {\n\t    PUSH_TAG(str, n);\n\t    r2 = tagbuf->ptr;\n\t    t = getescapecmd(&r2);\n\t    if (!*r2 && (*t == '\\r' || *t == '\\n')) {\n\t\tif (len > max_len)\n\t\t    max_len = len;\n\t\tlen = 0;\n\t    }\n\t    else\n\t\tlen += get_strwidth(t) + get_strwidth(r2);\n\t}\n\telse if (status == R_ST_NORMAL && ST_IS_REAL_TAG(prev_status)) {\n\t    ;\n\t}\n\telse if (*str == '\\t') {\n\t    len--;\n\t    do {\n\t\tlen++;\n\t    } while ((visible_length_offset + len) % Tabstop != 0);\n\t}\n\telse if (*str == '\\r' || *str == '\\n') {\n\t    len--;\n\t    if (len > max_len)\n\t\tmax_len = len;\n\t    len = 0;\n\t}\n#ifdef USE_M17N\n\tstr += n;\n#else\n\tstr++;\n#endif\n    }\n    if (status == R_ST_AMP) {\n\tr2 = tagbuf->ptr;\n\tt = getescapecmd(&r2);\n\tif (*t != '\\r' && *t != '\\n')\n\t    len += get_strwidth(t) + get_strwidth(r2);\n    }\n    return len > max_len ? len : max_len;\n}\n\nint\nvisible_length_plain(char *str)\n{\n    int len = 0, max_len = 0;\n\n    while (*str) {\n\tif (*str == '\\t') {\n\t    do {\n\t\tlen++;\n\t    } while ((visible_length_offset + len) % Tabstop != 0);\n\t    str++;\n\t}\n\telse if (*str == '\\r' || *str == '\\n') {\n\t    if (len > max_len)\n\t\tmax_len = len;\n\t    len = 0;\n\t    str++;\n\t}\n\telse {\n#ifdef USE_M17N\n\t    len += get_mcwidth(str);\n\t    str += get_mclen(str);\n#else\n\t    len++;\n\t    str++;\n#endif\n\t}\n    }\n    return len > max_len ? len : max_len;\n}\n\nstatic int\nmaximum_visible_length(char *str, int offset)\n{\n    visible_length_offset = offset;\n    return visible_length(str);\n}\n\nstatic int\nmaximum_visible_length_plain(char *str, int offset)\n{\n    visible_length_offset = offset;\n    return visible_length_plain(str);\n}\n\nvoid\nalign(TextLine *lbuf, int width, int mode)\n{\n    int i, l, l1, l2;\n    Str buf, line = lbuf->line;\n\n    if (line->length == 0) {\n\tfor (i = 0; i < width; i++)\n\t    Strcat_char(line, ' ');\n\tlbuf->pos = width;\n\treturn;\n    }\n    buf = Strnew();\n    l = width - lbuf->pos;\n    switch (mode) {\n    case ALIGN_CENTER:\n\tl1 = l / 2;\n\tl2 = l - l1;\n\tfor (i = 0; i < l1; i++)\n\t    Strcat_char(buf, ' ');\n\tStrcat(buf, line);\n\tfor (i = 0; i < l2; i++)\n\t    Strcat_char(buf, ' ');\n\tbreak;\n    case ALIGN_LEFT:\n\tStrcat(buf, line);\n\tfor (i = 0; i < l; i++)\n\t    Strcat_char(buf, ' ');\n\tbreak;\n    case ALIGN_RIGHT:\n\tfor (i = 0; i < l; i++)\n\t    Strcat_char(buf, ' ');\n\tStrcat(buf, line);\n\tbreak;\n    default:\n\treturn;\n    }\n    lbuf->line = buf;\n    if (lbuf->pos < width)\n\tlbuf->pos = width;\n}\n\nvoid\nprint_item(struct table *t, int row, int col, int width, Str buf)\n{\n    int alignment;\n    TextLine *lbuf;\n\n    if (t->tabdata[row])\n\tlbuf = popTextLine(t->tabdata[row][col]);\n    else\n\tlbuf = NULL;\n\n    if (lbuf != NULL) {\n\tcheck_row(t, row);\n\talignment = ALIGN_CENTER;\n\tif ((t->tabattr[row][col] & HTT_ALIGN) == HTT_LEFT)\n\t    alignment = ALIGN_LEFT;\n\telse if ((t->tabattr[row][col] & HTT_ALIGN) == HTT_RIGHT)\n\t    alignment = ALIGN_RIGHT;\n\telse if ((t->tabattr[row][col] & HTT_ALIGN) == HTT_CENTER)\n\t    alignment = ALIGN_CENTER;\n\talign(lbuf, width, alignment);\n\tStrcat(buf, lbuf->line);\n    }\n    else {\n\tlbuf = newTextLine(NULL, 0);\n\talign(lbuf, width, ALIGN_CENTER);\n\tStrcat(buf, lbuf->line);\n    }\n}\n\n\n#define T_TOP           0\n#define T_MIDDLE        1\n#define T_BOTTOM        2\n\nvoid\nprint_sep(struct table *t, int row, int type, int maxcol, Str buf)\n{\n    int forbid;\n    int rule_mode;\n    int i, k, l, m;\n\n    if (row >= 0)\n\tcheck_row(t, row);\n    check_row(t, row + 1);\n    if ((type == T_TOP || type == T_BOTTOM) && t->border_mode == BORDER_THICK) {\n\trule_mode = BORDER_THICK;\n    }\n    else {\n\trule_mode = BORDER_THIN;\n    }\n    forbid = 1;\n    if (type == T_TOP)\n\tforbid |= 2;\n    else if (type == T_BOTTOM)\n\tforbid |= 8;\n    else if (t->tabattr[row + 1][0] & HTT_Y) {\n\tforbid |= 4;\n    }\n    if (t->border_mode != BORDER_NOWIN) {\n\tpush_symbol(buf, RULE(t->border_mode, forbid), symbol_width, 1);\n    }\n    for (i = 0; i <= maxcol; i++) {\n\tforbid = 10;\n\tif (type != T_BOTTOM && (t->tabattr[row + 1][i] & HTT_Y)) {\n\t    if (t->tabattr[row + 1][i] & HTT_X) {\n\t\tgoto do_last_sep;\n\t    }\n\t    else {\n\t\tfor (k = row;\n\t\t     k >= 0 && t->tabattr[k] && (t->tabattr[k][i] & HTT_Y);\n\t\t     k--) ;\n\t\tm = t->tabwidth[i] + 2 * t->cellpadding;\n\t\tfor (l = i + 1; l <= t->maxcol && (t->tabattr[row][l] & HTT_X);\n\t\t     l++)\n\t\t    m += t->tabwidth[l] + t->cellspacing;\n\t\tprint_item(t, k, i, m, buf);\n\t    }\n\t}\n\telse {\n\t    int w = t->tabwidth[i] + 2 * t->cellpadding;\n\t    if (RULE_WIDTH == 2)\n\t\tw = (w + 1) / RULE_WIDTH;\n\t    push_symbol(buf, RULE(rule_mode, forbid), symbol_width, w);\n\t}\n      do_last_sep:\n\tif (i < maxcol) {\n\t    forbid = 0;\n\t    if (type == T_TOP)\n\t\tforbid |= 2;\n\t    else if (t->tabattr[row][i + 1] & HTT_X) {\n\t\tforbid |= 2;\n\t    }\n\t    if (type == T_BOTTOM)\n\t\tforbid |= 8;\n\t    else {\n\t\tif (t->tabattr[row + 1][i + 1] & HTT_X) {\n\t\t    forbid |= 8;\n\t\t}\n\t\tif (t->tabattr[row + 1][i + 1] & HTT_Y) {\n\t\t    forbid |= 4;\n\t\t}\n\t\tif (t->tabattr[row + 1][i] & HTT_Y) {\n\t\t    forbid |= 1;\n\t\t}\n\t    }\n\t    if (forbid != 15)\t/* forbid==15 means 'no rule at all' */\n\t\tpush_symbol(buf, RULE(rule_mode, forbid), symbol_width, 1);\n\t}\n    }\n    forbid = 4;\n    if (type == T_TOP)\n\tforbid |= 2;\n    if (type == T_BOTTOM)\n\tforbid |= 8;\n    if (t->tabattr[row + 1][maxcol] & HTT_Y) {\n\tforbid |= 1;\n    }\n    if (t->border_mode != BORDER_NOWIN)\n\tpush_symbol(buf, RULE(t->border_mode, forbid), symbol_width, 1);\n}\n\nstatic int\nget_spec_cell_width(struct table *tbl, int row, int col)\n{\n    int i, w;\n\n    w = tbl->tabwidth[col];\n    for (i = col + 1; i <= tbl->maxcol; i++) {\n\tcheck_row(tbl, row);\n\tif (tbl->tabattr[row][i] & HTT_X)\n\t    w += tbl->tabwidth[i] + tbl->cellspacing;\n\telse\n\t    break;\n    }\n    return w;\n}\n\nvoid\ndo_refill(struct table *tbl, int row, int col, int maxlimit)\n{\n    TextList *orgdata;\n    TextListItem *l;\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    int colspan, icell;\n\n    if (tbl->tabdata[row] == NULL || tbl->tabdata[row][col] == NULL)\n\treturn;\n    orgdata = (TextList *)tbl->tabdata[row][col];\n    tbl->tabdata[row][col] = newGeneralList();\n\n    init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL,\n\t      (TextLineList *)tbl->tabdata[row][col],\n\t      get_spec_cell_width(tbl, row, col), 0);\n    obuf.flag |= RB_INTABLE;\n    if (h_env.limit > maxlimit)\n\th_env.limit = maxlimit;\n    if (tbl->border_mode != BORDER_NONE && tbl->vcellpadding > 0)\n\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n    for (l = orgdata->first; l != NULL; l = l->next) {\n\tif (TAG_IS(l->ptr, \"<table_alt\", 10)) {\n\t    int id = -1;\n\t    char *p = l->ptr;\n\t    struct parsed_tag *tag;\n\t    if ((tag = parse_tag(&p, TRUE)) != NULL)\n\t\tparsedtag_get_value(tag, ATTR_TID, &id);\n\t    if (id >= 0 && id < tbl->ntable && tbl->tables[id].ptr) {\n\t\tint alignment;\n\t\tTextLineListItem *ti;\n\t\tstruct table *t = tbl->tables[id].ptr;\n\t\tint limit = tbl->tables[id].indent + t->total_width;\n\t\ttbl->tables[id].ptr = NULL;\n\t\tsave_fonteffect(&h_env, h_env.obuf);\n\t\tflushline(&h_env, &obuf, 0, 2, h_env.limit);\n\t\tif (t->vspace > 0 && !(obuf.flag & RB_IGNORE_P))\n\t\t    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t\tif (RB_GET_ALIGN(h_env.obuf) == RB_CENTER)\n\t\t    alignment = ALIGN_CENTER;\n\t\telse if (RB_GET_ALIGN(h_env.obuf) == RB_RIGHT)\n\t\t    alignment = ALIGN_RIGHT;\n\t\telse\n\t\t    alignment = ALIGN_LEFT;\n\n\t\tif (alignment != ALIGN_LEFT) {\n\t\t    for (ti = tbl->tables[id].buf->first;\n\t\t\t ti != NULL; ti = ti->next)\n\t\t\talign(ti->ptr, h_env.limit, alignment);\n\t\t}\n\t\tappendTextLineList(h_env.buf, tbl->tables[id].buf);\n\t\tif (h_env.maxlimit < limit)\n\t\t    h_env.maxlimit = limit;\n\t\trestore_fonteffect(&h_env, h_env.obuf);\n\t\tobuf.flag &= ~RB_IGNORE_P;\n\t\th_env.blank_lines = 0;\n\t\tif (t->vspace > 0) {\n\t\t    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t\t    obuf.flag |= RB_IGNORE_P;\n\t\t}\n\t    }\n\t}\n\telse\n\t    HTMLlineproc1(l->ptr, &h_env);\n    }\n    if (obuf.status != R_ST_NORMAL) {\n\tobuf.status = R_ST_EOL;\n\tHTMLlineproc1(\"\\n\", &h_env);\n    }\n    completeHTMLstream(&h_env, &obuf);\n    flushline(&h_env, &obuf, 0, 2, h_env.limit);\n    if (tbl->border_mode == BORDER_NONE) {\n\tint rowspan = table_rowspan(tbl, row, col);\n\tif (row + rowspan <= tbl->maxrow) {\n\t    if (tbl->vcellpadding > 0 && !(obuf.flag & RB_IGNORE_P))\n\t\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t}\n\telse {\n\t    if (tbl->vspace > 0)\n\t\tpurgeline(&h_env);\n\t}\n    }\n    else {\n\tif (tbl->vcellpadding > 0) {\n\t    if (!(obuf.flag & RB_IGNORE_P))\n\t\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t}\n\telse\n\t    purgeline(&h_env);\n    }\n    if ((colspan = table_colspan(tbl, row, col)) > 1) {\n\tstruct table_cell *cell = &tbl->cell;\n\tint k;\n\tk = bsearch_2short(colspan, cell->colspan, col, cell->col, MAXCOL,\n\t\t\t   cell->index, cell->maxcell + 1);\n\ticell = cell->index[k];\n\tif (cell->minimum_width[icell] < h_env.maxlimit)\n\t    cell->minimum_width[icell] = h_env.maxlimit;\n    }\n    else {\n\tif (tbl->minimum_width[col] < h_env.maxlimit)\n\t    tbl->minimum_width[col] = h_env.maxlimit;\n    }\n}\n\nstatic int\ntable_rule_width(struct table *t)\n{\n    if (t->border_mode == BORDER_NONE)\n\treturn 1;\n    return RULE_WIDTH;\n}\n\nstatic void\ncheck_cell_width(short *tabwidth, short *cellwidth,\n\t\t short *col, short *colspan, short maxcell,\n\t\t short *indexarray, int space, int dir)\n{\n    int i, j, k, bcol, ecol;\n    int swidth, width;\n\n    for (k = 0; k <= maxcell; k++) {\n\tj = indexarray[k];\n\tif (cellwidth[j] <= 0)\n\t    continue;\n\tbcol = col[j];\n\tecol = bcol + colspan[j];\n\tswidth = 0;\n\tfor (i = bcol; i < ecol; i++)\n\t    swidth += tabwidth[i];\n\n\twidth = cellwidth[j] - (colspan[j] - 1) * space;\n\tif (width > swidth) {\n\t    int w = (width - swidth) / colspan[j];\n\t    int r = (width - swidth) % colspan[j];\n\t    for (i = bcol; i < ecol; i++)\n\t\ttabwidth[i] += w;\n\t    /* dir {0: horizontal, 1: vertical} */\n\t    if (dir == 1 && r > 0)\n\t\tr = colspan[j];\n\t    for (i = 1; i <= r; i++)\n\t\ttabwidth[ecol - i]++;\n\t}\n    }\n}\n\nvoid\ncheck_minimum_width(struct table *t, short *tabwidth)\n{\n    int i;\n    struct table_cell *cell = &t->cell;\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tif (tabwidth[i] < t->minimum_width[i])\n\t    tabwidth[i] = t->minimum_width[i];\n    }\n\n    check_cell_width(tabwidth, cell->minimum_width, cell->col, cell->colspan,\n\t\t     cell->maxcell, cell->index, t->cellspacing, 0);\n}\n\nvoid\ncheck_maximum_width(struct table *t)\n{\n    struct table_cell *cell = &t->cell;\n#ifdef MATRIX\n    int i, j, bcol, ecol;\n    int swidth, width;\n\n    cell->necell = 0;\n    for (j = 0; j <= cell->maxcell; j++) {\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\tswidth = 0;\n\tfor (i = bcol; i < ecol; i++)\n\t    swidth += t->tabwidth[i];\n\n\twidth = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tif (width > swidth) {\n\t    cell->eindex[cell->necell] = j;\n\t    cell->necell++;\n\t}\n    }\n#else\t\t\t\t/* not MATRIX */\n    check_cell_width(t->tabwidth, cell->width, cell->col, cell->colspan,\n\t\t     cell->maxcell, cell->index, t->cellspacing, 0);\n    check_minimum_width(t, t->tabwidth);\n#endif\t\t\t\t/* not MATRIX */\n}\n\n\n#ifdef MATRIX\nstatic void\nset_integered_width(struct table *t, double *dwidth, short *iwidth)\n{\n    int i, j, k, n, bcol, ecol, step;\n    short *indexarray;\n    char *fixed;\n    double *mod;\n    double sum = 0., x = 0.;\n    struct table_cell *cell = &t->cell;\n    int rulewidth = table_rule_width(t);\n\n    indexarray = NewAtom_N(short, t->maxcol + 1);\n    mod = NewAtom_N(double, t->maxcol + 1);\n    for (i = 0; i <= t->maxcol; i++) {\n\tiwidth[i] = ceil_at_intervals(ceil(dwidth[i]), rulewidth);\n\tmod[i] = (double)iwidth[i] - dwidth[i];\n    }\n\n    sum = 0.;\n    for (k = 0; k <= t->maxcol; k++) {\n\tx = mod[k];\n\tsum += x;\n\ti = bsearch_double(x, mod, indexarray, k);\n\tif (k > i) {\n\t    int ii;\n\t    for (ii = k; ii > i; ii--)\n\t\tindexarray[ii] = indexarray[ii - 1];\n\t}\n\tindexarray[i] = k;\n    }\n\n    fixed = NewAtom_N(char, t->maxcol + 1);\n    bzero(fixed, t->maxcol + 1);\n    for (step = 0; step < 2; step++) {\n\tfor (i = 0; i <= t->maxcol; i += n) {\n\t    int nn;\n\t    short *idx;\n\t    double nsum;\n\t    if (sum < 0.5)\n\t\treturn;\n\t    for (n = 0; i + n <= t->maxcol; n++) {\n\t\tint ii = indexarray[i + n];\n\t\tif (n == 0)\n\t\t    x = mod[ii];\n\t\telse if (fabs(mod[ii] - x) > 1e-6)\n\t\t    break;\n\t    }\n\t    for (k = 0; k < n; k++) {\n\t\tint ii = indexarray[i + k];\n\t\tif (fixed[ii] < 2 &&\n\t\t    iwidth[ii] - rulewidth < t->minimum_width[ii])\n\t\t    fixed[ii] = 2;\n\t\tif (fixed[ii] < 1 &&\n\t\t    iwidth[ii] - rulewidth < t->tabwidth[ii] &&\n\t\t    (double)rulewidth - mod[ii] > 0.5)\n\t\t    fixed[ii] = 1;\n\t    }\n\t    idx = NewAtom_N(short, n);\n\t    for (k = 0; k < cell->maxcell; k++) {\n\t\tint kk, w, width, m;\n\t\tj = cell->index[k];\n\t\tbcol = cell->col[j];\n\t\tecol = bcol + cell->colspan[j];\n\t\tm = 0;\n\t\tfor (kk = 0; kk < n; kk++) {\n\t\t    int ii = indexarray[i + kk];\n\t\t    if (ii >= bcol && ii < ecol) {\n\t\t\tidx[m] = ii;\n\t\t\tm++;\n\t\t    }\n\t\t}\n\t\tif (m == 0)\n\t\t    continue;\n\t\twidth = (cell->colspan[j] - 1) * t->cellspacing;\n\t\tfor (kk = bcol; kk < ecol; kk++)\n\t\t    width += iwidth[kk];\n\t\tw = 0;\n\t\tfor (kk = 0; kk < m; kk++) {\n\t\t    if (fixed[(int)idx[kk]] < 2)\n\t\t\tw += rulewidth;\n\t\t}\n\t\tif (width - w < cell->minimum_width[j]) {\n\t\t    for (kk = 0; kk < m; kk++) {\n\t\t\tif (fixed[(int)idx[kk]] < 2)\n\t\t\t    fixed[(int)idx[kk]] = 2;\n\t\t    }\n\t\t}\n\t\tw = 0;\n\t\tfor (kk = 0; kk < m; kk++) {\n\t\t    if (fixed[(int)idx[kk]] < 1 &&\n\t\t\t(double)rulewidth - mod[(int)idx[kk]] > 0.5)\n\t\t\tw += rulewidth;\n\t\t}\n\t\tif (width - w < cell->width[j]) {\n\t\t    for (kk = 0; kk < m; kk++) {\n\t\t\tif (fixed[(int)idx[kk]] < 1 &&\n\t\t\t    (double)rulewidth - mod[(int)idx[kk]] > 0.5)\n\t\t\t    fixed[(int)idx[kk]] = 1;\n\t\t    }\n\t\t}\n\t    }\n\t    nn = 0;\n\t    for (k = 0; k < n; k++) {\n\t\tint ii = indexarray[i + k];\n\t\tif (fixed[ii] <= step)\n\t\t    nn++;\n\t    }\n\t    nsum = sum - (double)(nn * rulewidth);\n\t    if (nsum < 0. && fabs(sum) <= fabs(nsum))\n\t\treturn;\n\t    for (k = 0; k < n; k++) {\n\t\tint ii = indexarray[i + k];\n\t\tif (fixed[ii] <= step) {\n\t\t    iwidth[ii] -= rulewidth;\n\t\t    fixed[ii] = 3;\n\t\t}\n\t    }\n\t    sum = nsum;\n\t}\n    }\n}\n\nstatic double\ncorrelation_coefficient(double sxx, double syy, double sxy)\n{\n    double coe, tmp;\n    tmp = sxx * syy;\n    if (tmp < Tiny)\n\ttmp = Tiny;\n    coe = sxy / sqrt(tmp);\n    if (coe > 1.)\n\treturn 1.;\n    if (coe < -1.)\n\treturn -1.;\n    return coe;\n}\n\nstatic double\ncorrelation_coefficient2(double sxx, double syy, double sxy)\n{\n    double coe, tmp;\n    tmp = (syy + sxx - 2 * sxy) * sxx;\n    if (tmp < Tiny)\n\ttmp = Tiny;\n    coe = (sxx - sxy) / sqrt(tmp);\n    if (coe > 1.)\n\treturn 1.;\n    if (coe < -1.)\n\treturn -1.;\n    return coe;\n}\n\nstatic double\nrecalc_width(double old, double swidth, int cwidth,\n\t     double sxx, double syy, double sxy, int is_inclusive)\n{\n    double delta = swidth - (double)cwidth;\n    double rat = sxy / sxx,\n\tcoe = correlation_coefficient(sxx, syy, sxy), w, ww;\n    if (old < 0.)\n\told = 0.;\n    if (fabs(coe) < 1e-5)\n\treturn old;\n    w = rat * old;\n    ww = delta;\n    if (w > 0.) {\n\tdouble wmin = 5e-3 * sqrt(syy * (1. - coe * coe));\n\tif (swidth < 0.2 && cwidth > 0 && is_inclusive) {\n\t    double coe1 = correlation_coefficient2(sxx, syy, sxy);\n\t    if (coe > 0.9 || coe1 > 0.9)\n\t\treturn 0.;\n\t}\n\tif (wmin > 0.05)\n\t    wmin = 0.05;\n\tif (ww < 0.)\n\t    ww = 0.;\n\tww += wmin;\n    }\n    else {\n\tdouble wmin = 5e-3 * sqrt(syy) * fabs(coe);\n\tif (rat > -0.001)\n\t    return old;\n\tif (wmin > 0.01)\n\t    wmin = 0.01;\n\tif (ww > 0.)\n\t    ww = 0.;\n\tww -= wmin;\n    }\n    if (w > ww)\n\treturn ww / rat;\n    return old;\n}\n\nstatic int\ncheck_compressible_cell(struct table *t, MAT * minv,\n\t\t\tdouble *newwidth, double *swidth, short *cwidth,\n\t\t\tdouble totalwidth, double *Sxx,\n\t\t\tint icol, int icell, double sxx, int corr)\n{\n    struct table_cell *cell = &t->cell;\n    int i, j, k, m, bcol, ecol, span;\n    double delta, owidth;\n    double dmax, dmin, sxy;\n    int rulewidth = table_rule_width(t);\n\n    if (sxx < 10.)\n\treturn corr;\n\n    if (icol >= 0) {\n\towidth = newwidth[icol];\n\tdelta = newwidth[icol] - (double)t->tabwidth[icol];\n\tbcol = icol;\n\tecol = bcol + 1;\n    }\n    else if (icell >= 0) {\n\towidth = swidth[icell];\n\tdelta = swidth[icell] - (double)cwidth[icell];\n\tbcol = cell->col[icell];\n\tecol = bcol + cell->colspan[icell];\n    }\n    else {\n\towidth = totalwidth;\n\tdelta = totalwidth;\n\tbcol = 0;\n\tecol = t->maxcol + 1;\n    }\n\n    dmin = delta;\n    dmax = -1.;\n    for (k = 0; k <= cell->maxcell; k++) {\n\tint bcol1, ecol1;\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tj = cell->index[k];\n\tif (j == icell)\n\t    continue;\n\tbcol1 = cell->col[j];\n\tecol1 = bcol1 + cell->colspan[j];\n\tsxy = 0.;\n\tfor (m = bcol1; m < ecol1; m++) {\n\t    for (i = bcol; i < ecol; i++)\n\t\tsxy += m_entry(minv, i, m);\n\t}\n\tif (bcol1 >= bcol && ecol1 <= ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n    }\n    for (m = 0; m <= t->maxcol; m++) {\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tif (m == icol)\n\t    continue;\n\tsxy = 0.;\n\tfor (i = bcol; i < ecol; i++)\n\t    sxy += m_entry(minv, i, m);\n\tif (m >= bcol && m < ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n    }\n  _end:\n    if (dmax > 0. && dmin > dmax)\n\tdmin = dmax;\n    span = ecol - bcol;\n    if ((span == t->maxcol + 1 && dmin >= 0.) ||\n\t(span != t->maxcol + 1 && dmin > rulewidth * 0.5)) {\n\tint nwidth = ceil_at_intervals(round(owidth - dmin), rulewidth);\n\tcorrect_table_matrix(t, bcol, ecol - bcol, nwidth, 1.);\n\tcorr++;\n    }\n    return corr;\n}\n\n#define MAX_ITERATION 10\nint\ncheck_table_width(struct table *t, double *newwidth, MAT * minv, int itr)\n{\n    int i, j, k, m, bcol, ecol;\n    int corr = 0;\n    struct table_cell *cell = &t->cell;\n#ifdef __GNUC__\n    short orgwidth[t->maxcol + 1], corwidth[t->maxcol + 1];\n    short cwidth[cell->maxcell + 1];\n    double swidth[cell->maxcell + 1];\n#else\t\t\t\t/* __GNUC__ */\n    short orgwidth[MAXCOL], corwidth[MAXCOL];\n    short cwidth[MAXCELL];\n    double swidth[MAXCELL];\n#endif\t\t\t\t/* __GNUC__ */\n    double twidth, sxy, *Sxx, stotal;\n\n    twidth = 0.;\n    stotal = 0.;\n    for (i = 0; i <= t->maxcol; i++) {\n\ttwidth += newwidth[i];\n\tstotal += m_entry(minv, i, i);\n\tfor (m = 0; m < i; m++) {\n\t    stotal += 2 * m_entry(minv, i, m);\n\t}\n    }\n\n    Sxx = NewAtom_N(double, cell->maxcell + 1);\n    for (k = 0; k <= cell->maxcell; k++) {\n\tj = cell->index[k];\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\tswidth[j] = 0.;\n\tfor (i = bcol; i < ecol; i++)\n\t    swidth[j] += newwidth[i];\n\tcwidth[j] = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tSxx[j] = 0.;\n\tfor (i = bcol; i < ecol; i++) {\n\t    Sxx[j] += m_entry(minv, i, i);\n\t    for (m = bcol; m <= ecol; m++) {\n\t\tif (m < i)\n\t\t    Sxx[j] += 2 * m_entry(minv, i, m);\n\t    }\n\t}\n    }\n\n    /* compress table */\n    corr = check_compressible_cell(t, minv, newwidth, swidth,\n\t\t\t\t   cwidth, twidth, Sxx, -1, -1, stotal, corr);\n    if (itr < MAX_ITERATION && corr > 0)\n\treturn corr;\n\n    /* compress multicolumn cell */\n    for (k = cell->maxcell; k >= 0; k--) {\n\tj = cell->index[k];\n\tcorr = check_compressible_cell(t, minv, newwidth, swidth,\n\t\t\t\t       cwidth, twidth, Sxx,\n\t\t\t\t       -1, j, Sxx[j], corr);\n\tif (itr < MAX_ITERATION && corr > 0)\n\t    return corr;\n    }\n\n    /* compress single column cell */\n    for (i = 0; i <= t->maxcol; i++) {\n\tcorr = check_compressible_cell(t, minv, newwidth, swidth,\n\t\t\t\t       cwidth, twidth, Sxx,\n\t\t\t\t       i, -1, m_entry(minv, i, i), corr);\n\tif (itr < MAX_ITERATION && corr > 0)\n\t    return corr;\n    }\n\n\n    for (i = 0; i <= t->maxcol; i++)\n\tcorwidth[i] = orgwidth[i] = round(newwidth[i]);\n\n    check_minimum_width(t, corwidth);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tdouble sx = sqrt(m_entry(minv, i, i));\n\tif (sx < 0.1)\n\t    continue;\n\tif (orgwidth[i] < t->minimum_width[i] &&\n\t    corwidth[i] == t->minimum_width[i]) {\n\t    double w = (sx > 0.5) ? 0.5 : sx * 0.2;\n\t    sxy = 0.;\n\t    for (m = 0; m <= t->maxcol; m++) {\n\t\tif (m == i)\n\t\t    continue;\n\t\tsxy += m_entry(minv, i, m);\n\t    }\n\t    if (sxy <= 0.) {\n\t\tcorrect_table_matrix(t, i, 1, t->minimum_width[i], w);\n\t\tcorr++;\n\t    }\n\t}\n    }\n\n    for (k = 0; k <= cell->maxcell; k++) {\n\tint nwidth = 0, mwidth;\n\tdouble sx;\n\n\tj = cell->index[k];\n\tsx = sqrt(Sxx[j]);\n\tif (sx < 0.1)\n\t    continue;\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\tfor (i = bcol; i < ecol; i++)\n\t    nwidth += corwidth[i];\n\tmwidth =\n\t    cell->minimum_width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tif (mwidth > swidth[j] && mwidth == nwidth) {\n\t    double w = (sx > 0.5) ? 0.5 : sx * 0.2;\n\n\t    sxy = 0.;\n\t    for (i = bcol; i < ecol; i++) {\n\t\tfor (m = 0; m <= t->maxcol; m++) {\n\t\t    if (m >= bcol && m < ecol)\n\t\t\tcontinue;\n\t\t    sxy += m_entry(minv, i, m);\n\t\t}\n\t    }\n\t    if (sxy <= 0.) {\n\t\tcorrect_table_matrix(t, bcol, cell->colspan[j], mwidth, w);\n\t\tcorr++;\n\t    }\n\t}\n    }\n\n    if (itr >= MAX_ITERATION)\n\treturn 0;\n    else\n\treturn corr;\n}\n\n#else\t\t\t\t/* not MATRIX */\nvoid\nset_table_width(struct table *t, short *newwidth, int maxwidth)\n{\n    int i, j, k, bcol, ecol;\n    struct table_cell *cell = &t->cell;\n    char *fixed;\n    int swidth, fwidth, width, nvar;\n    double s;\n    double *dwidth;\n    int try_again;\n\n    fixed = NewAtom_N(char, t->maxcol + 1);\n    bzero(fixed, t->maxcol + 1);\n    dwidth = NewAtom_N(double, t->maxcol + 1);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tdwidth[i] = 0.0;\n\tif (t->fixed_width[i] < 0) {\n\t    t->fixed_width[i] = -t->fixed_width[i] * maxwidth / 100;\n\t}\n\tif (t->fixed_width[i] > 0) {\n\t    newwidth[i] = t->fixed_width[i];\n\t    fixed[i] = 1;\n\t}\n\telse\n\t    newwidth[i] = 0;\n\tif (newwidth[i] < t->minimum_width[i])\n\t    newwidth[i] = t->minimum_width[i];\n    }\n\n    for (k = 0; k <= cell->maxcell; k++) {\n\tj = cell->indexarray[k];\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\n\tif (cell->fixed_width[j] < 0)\n\t    cell->fixed_width[j] = -cell->fixed_width[j] * maxwidth / 100;\n\n\tswidth = 0;\n\tfwidth = 0;\n\tnvar = 0;\n\tfor (i = bcol; i < ecol; i++) {\n\t    if (fixed[i]) {\n\t\tfwidth += newwidth[i];\n\t    }\n\t    else {\n\t\tswidth += newwidth[i];\n\t\tnvar++;\n\t    }\n\t}\n\twidth = max(cell->fixed_width[j], cell->minimum_width[j])\n\t    - (cell->colspan[j] - 1) * t->cellspacing;\n\tif (nvar > 0 && width > fwidth + swidth) {\n\t    s = 0.;\n\t    for (i = bcol; i < ecol; i++) {\n\t\tif (!fixed[i])\n\t\t    s += weight3(t->tabwidth[i]);\n\t    }\n\t    for (i = bcol; i < ecol; i++) {\n\t\tif (!fixed[i])\n\t\t    dwidth[i] = (width - fwidth) * weight3(t->tabwidth[i]) / s;\n\t\telse\n\t\t    dwidth[i] = (double)newwidth[i];\n\t    }\n\t    dv2sv(dwidth, newwidth, cell->colspan[j]);\n\t    if (cell->fixed_width[j] > 0) {\n\t\tfor (i = bcol; i < ecol; i++)\n\t\t    fixed[i] = 1;\n\t    }\n\t}\n    }\n\n    do {\n\tnvar = 0;\n\tswidth = 0;\n\tfwidth = 0;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (fixed[i]) {\n\t\tfwidth += newwidth[i];\n\t    }\n\t    else {\n\t\tswidth += newwidth[i];\n\t\tnvar++;\n\t    }\n\t}\n\twidth = maxwidth - t->maxcol * t->cellspacing;\n\tif (nvar == 0 || width <= fwidth + swidth)\n\t    break;\n\n\ts = 0.;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (!fixed[i])\n\t\ts += weight3(t->tabwidth[i]);\n\t}\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (!fixed[i])\n\t\tdwidth[i] = (width - fwidth) * weight3(t->tabwidth[i]) / s;\n\t    else\n\t\tdwidth[i] = (double)newwidth[i];\n\t}\n\tdv2sv(dwidth, newwidth, t->maxcol + 1);\n\n\ttry_again = 0;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (!fixed[i]) {\n\t\tif (newwidth[i] > t->tabwidth[i]) {\n\t\t    newwidth[i] = t->tabwidth[i];\n\t\t    fixed[i] = 1;\n\t\t    try_again = 1;\n\t\t}\n\t\telse if (newwidth[i] < t->minimum_width[i]) {\n\t\t    newwidth[i] = t->minimum_width[i];\n\t\t    fixed[i] = 1;\n\t\t    try_again = 1;\n\t\t}\n\t    }\n\t}\n    } while (try_again);\n}\n#endif\t\t\t\t/* not MATRIX */\n\nvoid\ncheck_table_height(struct table *t)\n{\n    int i, j, k;\n    struct {\n\tshort *row;\n\tshort *rowspan;\n\tshort *indexarray;\n\tshort maxcell;\n\tshort size;\n\tshort *height;\n    } cell;\n    int space = 0;\n\n    cell.size = 0;\n    cell.maxcell = -1;\n\n    for (j = 0; j <= t->maxrow; j++) {\n\tif (!t->tabattr[j])\n\t    continue;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    int t_dep, rowspan;\n\t    if (t->tabattr[j][i] & (HTT_X | HTT_Y))\n\t\tcontinue;\n\n\t    if (t->tabdata[j][i] == NULL)\n\t\tt_dep = 0;\n\t    else\n\t\tt_dep = t->tabdata[j][i]->nitem;\n\n\t    rowspan = table_rowspan(t, j, i);\n\t    if (rowspan > 1) {\n\t\tint c = cell.maxcell + 1;\n\t\tk = bsearch_2short(rowspan, cell.rowspan,\n\t\t\t\t   j, cell.row, t->maxrow + 1, cell.indexarray,\n\t\t\t\t   c);\n\t\tif (k <= cell.maxcell) {\n\t\t    int idx = cell.indexarray[k];\n\t\t    if (cell.row[idx] == j && cell.rowspan[idx] == rowspan)\n\t\t\tc = idx;\n\t\t}\n\t\tif (c >= MAXROWCELL)\n\t\t    continue;\n\t\tif (c >= cell.size) {\n\t\t    if (cell.size == 0) {\n\t\t\tcell.size = max(MAXCELL, c + 1);\n\t\t\tcell.row = NewAtom_N(short, cell.size);\n\t\t\tcell.rowspan = NewAtom_N(short, cell.size);\n\t\t\tcell.indexarray = NewAtom_N(short, cell.size);\n\t\t\tcell.height = NewAtom_N(short, cell.size);\n\t\t    }\n\t\t    else {\n\t\t\tcell.size = max(cell.size + MAXCELL, c + 1);\n\t\t\tcell.row = New_Reuse(short, cell.row, cell.size);\n\t\t\tcell.rowspan = New_Reuse(short, cell.rowspan,\n\t\t\t\t\t\t cell.size);\n\t\t\tcell.indexarray = New_Reuse(short, cell.indexarray,\n\t\t\t\t\t\t    cell.size);\n\t\t\tcell.height = New_Reuse(short, cell.height, cell.size);\n\t\t    }\n\t\t}\n\t\tif (c > cell.maxcell) {\n\t\t    cell.maxcell++;\n\t\t    cell.row[cell.maxcell] = j;\n\t\t    cell.rowspan[cell.maxcell] = rowspan;\n\t\t    cell.height[cell.maxcell] = 0;\n\t\t    if (cell.maxcell > k) {\n\t\t\tint ii;\n\t\t\tfor (ii = cell.maxcell; ii > k; ii--)\n\t\t\t    cell.indexarray[ii] = cell.indexarray[ii - 1];\n\t\t    }\n\t\t    cell.indexarray[k] = cell.maxcell;\n\t\t}\n\n\t\tif (cell.height[c] < t_dep)\n\t\t    cell.height[c] = t_dep;\n\t\tcontinue;\n\t    }\n\t    if (t->tabheight[j] < t_dep)\n\t\tt->tabheight[j] = t_dep;\n\t}\n    }\n\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\tspace = 1;\n\tbreak;\n    case BORDER_NONE:\n\tspace = 0;\n    }\n    check_cell_width(t->tabheight, cell.height, cell.row, cell.rowspan,\n\t\t     cell.maxcell, cell.indexarray, space, 1);\n}\n\n#define CHECK_MINIMUM\t1\n#define CHECK_FIXED\t2\n\nint\nget_table_width(struct table *t, short *orgwidth, short *cellwidth, int flag)\n{\n#ifdef __GNUC__\n    short newwidth[t->maxcol + 1];\n#else\t\t\t\t/* not __GNUC__ */\n    short newwidth[MAXCOL];\n#endif\t\t\t\t/* not __GNUC__ */\n    int i;\n    int swidth;\n    struct table_cell *cell = &t->cell;\n    int rulewidth = table_rule_width(t);\n\n    for (i = 0; i <= t->maxcol; i++)\n\tnewwidth[i] = max(orgwidth[i], 0);\n\n    if (flag & CHECK_FIXED) {\n#ifdef __GNUC__\n\tshort ccellwidth[cell->maxcell + 1];\n#else\t\t\t\t/* not __GNUC__ */\n\tshort ccellwidth[MAXCELL];\n#endif\t\t\t\t/* not __GNUC__ */\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (newwidth[i] < t->fixed_width[i])\n\t\tnewwidth[i] = t->fixed_width[i];\n\t}\n\tfor (i = 0; i <= cell->maxcell; i++) {\n\t    ccellwidth[i] = cellwidth[i];\n\t    if (ccellwidth[i] < cell->fixed_width[i])\n\t\tccellwidth[i] = cell->fixed_width[i];\n\t}\n\tcheck_cell_width(newwidth, ccellwidth, cell->col, cell->colspan,\n\t\t\t cell->maxcell, cell->index, t->cellspacing, 0);\n    }\n    else {\n\tcheck_cell_width(newwidth, cellwidth, cell->col, cell->colspan,\n\t\t\t cell->maxcell, cell->index, t->cellspacing, 0);\n    }\n    if (flag & CHECK_MINIMUM)\n\tcheck_minimum_width(t, newwidth);\n\n    swidth = 0;\n    for (i = 0; i <= t->maxcol; i++) {\n\tswidth += ceil_at_intervals(newwidth[i], rulewidth);\n    }\n    swidth += table_border_width(t);\n    return swidth;\n}\n\n#define minimum_table_width(t)\\\n(get_table_width(t,t->minimum_width,t->cell.minimum_width,0))\n#define maximum_table_width(t)\\\n  (get_table_width(t,t->tabwidth,t->cell.width,CHECK_FIXED))\n#define fixed_table_width(t)\\\n  (get_table_width(t,t->fixed_width,t->cell.fixed_width,CHECK_MINIMUM))\n\n#define MAX_COTABLE_LEVEL 100\nstatic int cotable_level;\n\nvoid\ninitRenderTable(void)\n{\n    cotable_level = 0;\n}\n\nvoid\nrenderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n\n    if (cotable_level >= MAX_COTABLE_LEVEL)\n\treturn;\t/* workaround to prevent infinite recursion */\n    cotable_level++;\n\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tif (t == NULL)\n\t    continue;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}\n\nstatic void\nmake_caption(struct table *t, struct html_feed_environ *h_env)\n{\n    struct html_feed_environ henv;\n    struct readbuffer obuf;\n    struct environment envs[MAX_ENV_LEVEL];\n    int limit;\n\n    if (t->caption->length <= 0)\n\treturn;\n\n    if (t->total_width > 0)\n\tlimit = t->total_width;\n    else\n\tlimit = h_env->limit;\n    init_henv(&henv, &obuf, envs, MAX_ENV_LEVEL, newTextLineList(),\n\t      limit, h_env->envs[h_env->envc].indent);\n    HTMLlineproc1(\"<center>\", &henv);\n    HTMLlineproc0(t->caption->ptr, &henv, FALSE);\n    HTMLlineproc1(\"</center>\", &henv);\n\n    if (t->total_width < henv.maxlimit)\n\tt->total_width = henv.maxlimit;\n    limit = h_env->limit;\n    h_env->limit = t->total_width;\n    HTMLlineproc1(\"<center>\", h_env);\n    HTMLlineproc0(t->caption->ptr, h_env, FALSE);\n    HTMLlineproc1(\"</center>\", h_env);\n    h_env->limit = limit;\n}\n\nvoid\nrenderTable(struct table *t, int max_width, struct html_feed_environ *h_env)\n{\n    int i, j, w, r, h;\n    Str renderbuf;\n    short new_tabwidth[MAXCOL] = { 0 };\n#ifdef MATRIX\n    int itr;\n    VEC *newwidth;\n    MAT *mat, *minv;\n    PERM *pivot;\n#endif\t\t\t\t/* MATRIX */\n    int width;\n    int rulewidth;\n    Str vrulea = NULL, vruleb = NULL, vrulec = NULL;\n#ifdef ID_EXT\n    Str idtag;\n#endif\t\t\t\t/* ID_EXT */\n\n    t->total_height = 0;\n    if (t->maxcol < 0) {\n\tmake_caption(t, h_env);\n\treturn;\n    }\n\n    if (t->sloppy_width > max_width)\n\tmax_width = t->sloppy_width;\n\n    rulewidth = table_rule_width(t);\n\n    max_width -= table_border_width(t);\n\n    if (rulewidth > 1)\n\tmax_width = floor_at_intervals(max_width, rulewidth);\n\n    if (max_width < rulewidth)\n\tmax_width = rulewidth;\n\n#define MAX_TABWIDTH 10000\n    if (max_width > MAX_TABWIDTH)\n\tmax_width = MAX_TABWIDTH;\n\n    check_maximum_width(t);\n\n#ifdef MATRIX\n    if (t->maxcol == 0) {\n\tif (t->tabwidth[0] > max_width)\n\t    t->tabwidth[0] = max_width;\n\tif (t->total_width > 0)\n\t    t->tabwidth[0] = max_width;\n\telse if (t->fixed_width[0] > 0)\n\t    t->tabwidth[0] = t->fixed_width[0];\n\tif (t->tabwidth[0] < t->minimum_width[0])\n\t    t->tabwidth[0] = t->minimum_width[0];\n    }\n    else {\n\tset_table_matrix(t, max_width);\n\n\titr = 0;\n\tmat = m_get(t->maxcol + 1, t->maxcol + 1);\n\tpivot = px_get(t->maxcol + 1);\n\tnewwidth = v_get(t->maxcol + 1);\n\tminv = m_get(t->maxcol + 1, t->maxcol + 1);\n\tdo {\n\t    m_copy(t->matrix, mat);\n\t    LUfactor(mat, pivot);\n\t    LUsolve(mat, pivot, t->vector, newwidth);\n\t    LUinverse(mat, pivot, minv);\n#ifdef TABLE_DEBUG\n\t    set_integered_width(t, newwidth->ve, new_tabwidth);\n\t    fprintf(stderr, \"itr=%d\\n\", itr);\n\t    fprintf(stderr, \"max_width=%d\\n\", max_width);\n\t    fprintf(stderr, \"minimum : \");\n\t    for (i = 0; i <= t->maxcol; i++)\n\t\tfprintf(stderr, \"%2d \", t->minimum_width[i]);\n\t    fprintf(stderr, \"\\nfixed : \");\n\t    for (i = 0; i <= t->maxcol; i++)\n\t\tfprintf(stderr, \"%2d \", t->fixed_width[i]);\n\t    fprintf(stderr, \"\\ndecided : \");\n\t    for (i = 0; i <= t->maxcol; i++)\n\t\tfprintf(stderr, \"%2d \", new_tabwidth[i]);\n\t    fprintf(stderr, \"\\n\");\n#endif\t\t\t\t/* TABLE_DEBUG */\n\t    itr++;\n\n\t} while (check_table_width(t, newwidth->ve, minv, itr));\n\tset_integered_width(t, newwidth->ve, new_tabwidth);\n\tcheck_minimum_width(t, new_tabwidth);\n\tv_free(newwidth);\n\tpx_free(pivot);\n\tm_free(mat);\n\tm_free(minv);\n\tm_free(t->matrix);\n\tv_free(t->vector);\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    t->tabwidth[i] = new_tabwidth[i];\n\t}\n    }\n#else\t\t\t\t/* not MATRIX */\n    set_table_width(t, new_tabwidth, max_width);\n    for (i = 0; i <= t->maxcol; i++) {\n\tt->tabwidth[i] = new_tabwidth[i];\n    }\n#endif\t\t\t\t/* not MATRIX */\n\n    check_minimum_width(t, t->tabwidth);\n    for (i = 0; i <= t->maxcol; i++)\n\tt->tabwidth[i] = ceil_at_intervals(t->tabwidth[i], rulewidth);\n\n    renderCoTable(t, h_env->limit);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tfor (j = 0; j <= t->maxrow; j++) {\n\t    check_row(t, j);\n\t    if (t->tabattr[j][i] & HTT_Y)\n\t\tcontinue;\n\t    do_refill(t, j, i, h_env->limit);\n\t}\n    }\n\n    check_minimum_width(t, t->tabwidth);\n    t->total_width = 0;\n    for (i = 0; i <= t->maxcol; i++) {\n\tt->tabwidth[i] = ceil_at_intervals(t->tabwidth[i], rulewidth);\n\tt->total_width += t->tabwidth[i];\n    }\n\n    t->total_width += table_border_width(t);\n\n    check_table_height(t);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tfor (j = 0; j <= t->maxrow; j++) {\n\t    TextLineList *l;\n\t    int k;\n\t    if ((t->tabattr[j][i] & HTT_Y) ||\n\t\t(t->tabattr[j][i] & HTT_TOP) || (t->tabdata[j][i] == NULL))\n\t\tcontinue;\n\t    h = t->tabheight[j];\n\t    for (k = j + 1; k <= t->maxrow; k++) {\n\t\tif (!(t->tabattr[k][i] & HTT_Y))\n\t\t    break;\n\t\th += t->tabheight[k];\n\t\tswitch (t->border_mode) {\n\t\tcase BORDER_THIN:\n\t\tcase BORDER_THICK:\n\t\tcase BORDER_NOWIN:\n\t\t    h += 1;\n\t\t    break;\n\t\t}\n\t    }\n\t    h -= t->tabdata[j][i]->nitem;\n\t    if (t->tabattr[j][i] & HTT_MIDDLE)\n\t\th /= 2;\n\t    if (h <= 0)\n\t\tcontinue;\n\t    l = newTextLineList();\n\t    for (k = 0; k < h; k++)\n\t\tpushTextLine(l, newTextLine(NULL, 0));\n\t    t->tabdata[j][i] = appendGeneralList((GeneralList *)l,\n\t\t\t\t\t\t t->tabdata[j][i]);\n\t}\n    }\n\n    /* table output */\n    width = t->total_width;\n\n    make_caption(t, h_env);\n\n    HTMLlineproc1(\"<pre for_table>\", h_env);\n#ifdef ID_EXT\n    if (t->id != NULL) {\n\tidtag = Sprintf(\"<_id id=\\\"%s\\\">\", html_quote((t->id)->ptr));\n\tHTMLlineproc1(idtag->ptr, h_env);\n    }\n#endif\t\t\t\t/* ID_EXT */\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\trenderbuf = Strnew();\n\tprint_sep(t, -1, T_TOP, t->maxcol, renderbuf);\n\tpush_render_image(renderbuf, width, t->total_width, h_env);\n\tt->total_height += 1;\n\tbreak;\n    }\n    vruleb = Strnew();\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\tvrulea = Strnew();\n\tvrulec = Strnew();\n\tpush_symbol(vrulea, TK_VERTICALBAR(t->border_mode), symbol_width, 1);\n\tfor (i = 0; i < t->cellpadding; i++) {\n\t    Strcat_char(vrulea, ' ');\n\t    Strcat_char(vruleb, ' ');\n\t    Strcat_char(vrulec, ' ');\n\t}\n\tpush_symbol(vrulec, TK_VERTICALBAR(t->border_mode), symbol_width, 1);\n    case BORDER_NOWIN:\n\tpush_symbol(vruleb, TK_VERTICALBAR(BORDER_THIN), symbol_width, 1);\n\tfor (i = 0; i < t->cellpadding; i++)\n\t    Strcat_char(vruleb, ' ');\n\tbreak;\n    case BORDER_NONE:\n\tfor (i = 0; i < t->cellspacing; i++)\n\t    Strcat_char(vruleb, ' ');\n    }\n\n    for (r = 0; r <= t->maxrow; r++) {\n\tfor (h = 0; h < t->tabheight[r]; h++) {\n\t    renderbuf = Strnew();\n\t    if (t->border_mode == BORDER_THIN\n\t\t|| t->border_mode == BORDER_THICK)\n\t\tStrcat(renderbuf, vrulea);\n#ifdef ID_EXT\n\t    if (t->tridvalue[r] != NULL && h == 0) {\n\t\tidtag = Sprintf(\"<_id id=\\\"%s\\\">\",\n\t\t\t\thtml_quote((t->tridvalue[r])->ptr));\n\t\tStrcat(renderbuf, idtag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    for (i = 0; i <= t->maxcol; i++) {\n\t\tcheck_row(t, r);\n#ifdef ID_EXT\n\t\tif (t->tabidvalue[r][i] != NULL && h == 0) {\n\t\t    idtag = Sprintf(\"<_id id=\\\"%s\\\">\",\n\t\t\t\t    html_quote((t->tabidvalue[r][i])->ptr));\n\t\t    Strcat(renderbuf, idtag);\n\t\t}\n#endif\t\t\t\t/* ID_EXT */\n\t\tif (!(t->tabattr[r][i] & HTT_X)) {\n\t\t    w = t->tabwidth[i];\n\t\t    for (j = i + 1;\n\t\t\t j <= t->maxcol && (t->tabattr[r][j] & HTT_X); j++)\n\t\t\tw += t->tabwidth[j] + t->cellspacing;\n\t\t    if (t->tabattr[r][i] & HTT_Y) {\n\t\t\tfor (j = r - 1; j >= 0 && t->tabattr[j]\n\t\t\t     && (t->tabattr[j][i] & HTT_Y); j--) ;\n\t\t\tprint_item(t, j, i, w, renderbuf);\n\t\t    }\n\t\t    else\n\t\t\tprint_item(t, r, i, w, renderbuf);\n\t\t}\n\t\tif (i < t->maxcol && !(t->tabattr[r][i + 1] & HTT_X))\n\t\t    Strcat(renderbuf, vruleb);\n\t    }\n\t    switch (t->border_mode) {\n\t    case BORDER_THIN:\n\t    case BORDER_THICK:\n\t\tStrcat(renderbuf, vrulec);\n\t\tt->total_height += 1;\n\t\tbreak;\n\t    }\n\t    push_render_image(renderbuf, width, t->total_width, h_env);\n\t}\n\tif (r < t->maxrow && t->border_mode != BORDER_NONE) {\n\t    renderbuf = Strnew();\n\t    print_sep(t, r, T_MIDDLE, t->maxcol, renderbuf);\n\t    push_render_image(renderbuf, width, t->total_width, h_env);\n\t}\n\tt->total_height += t->tabheight[r];\n    }\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\trenderbuf = Strnew();\n\tprint_sep(t, t->maxrow, T_BOTTOM, t->maxcol, renderbuf);\n\tpush_render_image(renderbuf, width, t->total_width, h_env);\n\tt->total_height += 1;\n\tbreak;\n    }\n    if (t->total_height == 0) {\n       renderbuf = Strnew_charp(\" \");\n\tt->total_height++;\n\tt->total_width = 1;\n\tpush_render_image(renderbuf, 1, t->total_width, h_env);\n    }\n    HTMLlineproc1(\"</pre>\", h_env);\n}\n\n#ifdef TABLE_NO_COMPACT\n#define THR_PADDING 2\n#else\n#define THR_PADDING 4\n#endif\n\nstruct table *\nbegin_table(int border, int spacing, int padding, int vspace)\n{\n    struct table *t;\n    int mincell = minimum_cellspacing(border);\n    int rcellspacing;\n    int mincell_pixels = round(mincell * pixel_per_char);\n    int ppc = round(pixel_per_char);\n\n    t = newTable();\n    t->row = t->col = -1;\n    t->maxcol = -1;\n    t->maxrow = -1;\n    t->border_mode = border;\n    t->flag = 0;\n    if (border == BORDER_NOWIN)\n\tt->flag |= TBL_EXPAND_OK;\n\n    rcellspacing = spacing + 2 * padding;\n    switch (border) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\tt->cellpadding = padding - (mincell_pixels - 4) / 2;\n\tbreak;\n    case BORDER_NONE:\n\tt->cellpadding = rcellspacing - mincell_pixels;\n    }\n    if (t->cellpadding >= ppc)\n\tt->cellpadding /= ppc;\n    else if (t->cellpadding > 0)\n\tt->cellpadding = 1;\n    else\n\tt->cellpadding = 0;\n\n    switch (border) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\tt->cellspacing = 2 * t->cellpadding + mincell;\n\tbreak;\n    case BORDER_NONE:\n\tt->cellspacing = t->cellpadding + mincell;\n    }\n\n    if (border == BORDER_NONE) {\n\tif (rcellspacing / 2 + vspace <= 1)\n\t    t->vspace = 0;\n\telse\n\t    t->vspace = 1;\n    }\n    else {\n\tif (vspace < ppc)\n\t    t->vspace = 0;\n\telse\n\t    t->vspace = 1;\n    }\n\n    if (border == BORDER_NONE) {\n\tif (rcellspacing <= THR_PADDING)\n\t    t->vcellpadding = 0;\n\telse\n\t    t->vcellpadding = 1;\n    }\n    else {\n\tif (padding < 2 * ppc - 2)\n\t    t->vcellpadding = 0;\n\telse\n\t    t->vcellpadding = 1;\n    }\n\n    return t;\n}\n\nvoid\nend_table(struct table *tbl)\n{\n    struct table_cell *cell = &tbl->cell;\n    int i, rulewidth = table_rule_width(tbl);\n    if (rulewidth > 1) {\n\tif (tbl->total_width > 0)\n\t    tbl->total_width = ceil_at_intervals(tbl->total_width, rulewidth);\n\tfor (i = 0; i <= tbl->maxcol; i++) {\n\t    tbl->minimum_width[i] =\n\t\tceil_at_intervals(tbl->minimum_width[i], rulewidth);\n\t    tbl->tabwidth[i] = ceil_at_intervals(tbl->tabwidth[i], rulewidth);\n\t    if (tbl->fixed_width[i] > 0)\n\t\ttbl->fixed_width[i] =\n\t\t    ceil_at_intervals(tbl->fixed_width[i], rulewidth);\n\t}\n\tfor (i = 0; i <= cell->maxcell; i++) {\n\t    cell->minimum_width[i] =\n\t\tceil_at_intervals(cell->minimum_width[i], rulewidth);\n\t    cell->width[i] = ceil_at_intervals(cell->width[i], rulewidth);\n\t    if (cell->fixed_width[i] > 0)\n\t\tcell->fixed_width[i] =\n\t\t    ceil_at_intervals(cell->fixed_width[i], rulewidth);\n\t}\n    }\n    tbl->sloppy_width = fixed_table_width(tbl);\n    if (tbl->total_width > tbl->sloppy_width)\n\ttbl->sloppy_width = tbl->total_width;\n}\n\nstatic void\ncheck_minimum0(struct table *t, int min)\n{\n    int i, w, ww;\n    struct table_cell *cell;\n\n    if (t->col < 0)\n\treturn;\n    if (t->tabwidth[t->col] < 0)\n\treturn;\n    check_row(t, t->row);\n    w = table_colspan(t, t->row, t->col);\n    min += t->indent;\n    if (w == 1)\n\tww = min;\n    else {\n\tcell = &t->cell;\n\tww = 0;\n\tif (cell->icell >= 0 && cell->minimum_width[cell->icell] < min)\n\t    cell->minimum_width[cell->icell] = min;\n    }\n    for (i = t->col;\n\t i <= t->maxcol && (i == t->col || (t->tabattr[t->row][i] & HTT_X));\n\t i++) {\n\tif (t->minimum_width[i] < ww)\n\t    t->minimum_width[i] = ww;\n    }\n}\n\nstatic int\nsetwidth0(struct table *t, struct table_mode *mode)\n{\n    int w;\n    int width = t->tabcontentssize;\n    struct table_cell *cell = &t->cell;\n\n    if (t->col < 0)\n\treturn -1;\n    if (t->tabwidth[t->col] < 0)\n\treturn -1;\n    check_row(t, t->row);\n    if (t->linfo.prev_spaces > 0)\n\twidth -= t->linfo.prev_spaces;\n    w = table_colspan(t, t->row, t->col);\n    if (w == 1) {\n\tif (t->tabwidth[t->col] < width)\n\t    t->tabwidth[t->col] = width;\n    }\n    else if (cell->icell >= 0) {\n\tif (cell->width[cell->icell] < width)\n\t    cell->width[cell->icell] = width;\n    }\n    return width;\n}\n\nstatic void\nsetwidth(struct table *t, struct table_mode *mode)\n{\n    int width = setwidth0(t, mode);\n    if (width < 0)\n\treturn;\n#ifdef NOWRAP\n    if (t->tabattr[t->row][t->col] & HTT_NOWRAP)\n\tcheck_minimum0(t, width);\n#endif\t\t\t\t/* NOWRAP */\n    if (mode->pre_mode & (TBLM_NOBR | TBLM_PRE | TBLM_PRE_INT) &&\n\tmode->nobr_offset >= 0)\n\tcheck_minimum0(t, width - mode->nobr_offset);\n}\n\nstatic void\naddcontentssize(struct table *t, int width)\n{\n\n    if (t->col < 0)\n\treturn;\n    if (t->tabwidth[t->col] < 0)\n\treturn;\n    check_row(t, t->row);\n    t->tabcontentssize += width;\n}\n\nstatic void table_close_anchor0(struct table *tbl, struct table_mode *mode);\n\nstatic void\nclearcontentssize(struct table *t, struct table_mode *mode)\n{\n    table_close_anchor0(t, mode);\n    mode->nobr_offset = 0;\n    t->linfo.prev_spaces = -1;\n    set_space_to_prevchar(t->linfo.prevchar);\n    t->linfo.prev_ctype = PC_ASCII;\n    t->linfo.length = 0;\n    t->tabcontentssize = 0;\n}\n\nstatic void\nbegin_cell(struct table *t, struct table_mode *mode)\n{\n    clearcontentssize(t, mode);\n    mode->indent_level = 0;\n    mode->nobr_level = 0;\n    mode->pre_mode = 0;\n    t->indent = 0;\n    t->flag |= TBL_IN_COL;\n\n    if (t->suspended_data) {\n\tcheck_row(t, t->row);\n\tif (t->tabdata[t->row][t->col] == NULL)\n\t    t->tabdata[t->row][t->col] = newGeneralList();\n\tappendGeneralList(t->tabdata[t->row][t->col],\n\t\t\t  (GeneralList *)t->suspended_data);\n\tt->suspended_data = NULL;\n    }\n}\n\nvoid\ncheck_rowcol(struct table *tbl, struct table_mode *mode)\n{\n    int row = tbl->row, col = tbl->col;\n\n    if (!(tbl->flag & TBL_IN_ROW)) {\n\ttbl->flag |= TBL_IN_ROW;\n\ttbl->row++;\n\tif (tbl->row > tbl->maxrow)\n\t    tbl->maxrow = tbl->row;\n\ttbl->col = -1;\n    }\n    if (tbl->row == -1)\n\ttbl->row = 0;\n    if (tbl->col == -1)\n\ttbl->col = 0;\n\n    for (;; tbl->row++) {\n\tcheck_row(tbl, tbl->row);\n\tfor (; tbl->col < MAXCOL &&\n\t     tbl->tabattr[tbl->row][tbl->col] & (HTT_X | HTT_Y); tbl->col++) ;\n\tif (tbl->col < MAXCOL)\n\t    break;\n\ttbl->col = 0;\n    }\n    if (tbl->row > tbl->maxrow)\n\ttbl->maxrow = tbl->row;\n    if (tbl->col > tbl->maxcol)\n\ttbl->maxcol = tbl->col;\n\n    if (tbl->row != row || tbl->col != col)\n\tbegin_cell(tbl, mode);\n    tbl->flag |= TBL_IN_COL;\n}\n\nint\nskip_space(struct table *t, char *line, struct table_linfo *linfo,\n\t   int checkminimum)\n{\n    int skip = 0, s = linfo->prev_spaces;\n    Lineprop ctype, prev_ctype = linfo->prev_ctype;\n    Str prevchar = linfo->prevchar;\n    int w = linfo->length;\n    int min = 1;\n\n    if (*line == '<' && line[strlen(line) - 1] == '>') {\n\tif (checkminimum)\n\t    check_minimum0(t, visible_length(line));\n\treturn 0;\n    }\n\n    while (*line) {\n\tchar *save = line, *c = line;\n\tint ec, len, wlen, plen;\n\tctype = get_mctype(line);\n\tlen = get_mcwidth(line);\n\twlen = plen = get_mclen(line);\n\n\tif (min < w)\n\t    min = w;\n\tif (ctype == PC_ASCII && IS_SPACE(*c)) {\n\t    w = 0;\n\t    s++;\n\t}\n\telse {\n\t    if (*c == '&') {\n\t\tec = getescapechar(&line);\n\t\tif (ec >= 0) {\n\t\t    c = conv_entity(ec);\n\t\t    ctype = get_mctype(c);\n\t\t    len = get_strwidth(c);\n\t\t    wlen = line - save;\n\t\t    plen = get_mclen(c);\n\t\t}\n\t    }\n\t    if (prevchar->length && is_boundary((unsigned char *)prevchar->ptr,\n\t\t\t\t\t\t(unsigned char *)c)) {\n\t\tw = len;\n\t    }\n\t    else {\n\t\tw += len;\n\t    }\n\t    if (s > 0) {\n#ifdef USE_M17N\n\t\tif (ctype == PC_KANJI1 && prev_ctype == PC_KANJI1)\n\t\t    skip += s;\n\t\telse\n#endif\n\t\t    skip += s - 1;\n\t    }\n\t    s = 0;\n\t    prev_ctype = ctype;\n\t}\n\tset_prevchar(prevchar, c, plen);\n\tline = save + wlen;\n    }\n    if (s > 1) {\n\tskip += s - 1;\n\tlinfo->prev_spaces = 1;\n    }\n    else {\n\tlinfo->prev_spaces = s;\n    }\n    linfo->prev_ctype = prev_ctype;\n    linfo->prevchar = prevchar;\n\n    if (checkminimum) {\n\tif (min < w)\n\t    min = w;\n\tlinfo->length = w;\n\tcheck_minimum0(t, min);\n    }\n    return skip;\n}\n\nstatic void\nfeed_table_inline_tag(struct table *tbl,\n\t\t      char *line, struct table_mode *mode, int width)\n{\n    check_rowcol(tbl, mode);\n    pushdata(tbl, tbl->row, tbl->col, line);\n    if (width >= 0) {\n\tcheck_minimum0(tbl, width);\n\taddcontentssize(tbl, width);\n\tsetwidth(tbl, mode);\n    }\n}\n\nstatic void\nfeed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}\n\nstatic void\ntable_close_select(struct table *tbl, struct table_mode *mode, int width)\n{\n    Str tmp = process_n_select();\n    mode->pre_mode &= ~TBLM_INSELECT;\n    mode->end_tag = 0;\n    feed_table1(tbl, tmp, mode, width);\n}\n\nstatic void\ntable_close_textarea(struct table *tbl, struct table_mode *mode, int width)\n{\n    Str tmp = process_n_textarea();\n    mode->pre_mode &= ~TBLM_INTXTA;\n    mode->end_tag = 0;\n    feed_table1(tbl, tmp, mode, width);\n}\n\nstatic void\ntable_close_anchor0(struct table *tbl, struct table_mode *mode)\n{\n    if (!(mode->pre_mode & TBLM_ANCHOR))\n\treturn;\n    mode->pre_mode &= ~TBLM_ANCHOR;\n    if (tbl->tabcontentssize == mode->anchor_offset) {\n\tcheck_minimum0(tbl, 1);\n\taddcontentssize(tbl, 1);\n\tsetwidth(tbl, mode);\n    }\n    else if (tbl->linfo.prev_spaces > 0 &&\n\t     tbl->tabcontentssize - 1 == mode->anchor_offset) {\n\tif (tbl->linfo.prev_spaces > 0)\n\t    tbl->linfo.prev_spaces = -1;\n    }\n}\n\n#define TAG_ACTION_NONE 0\n#define TAG_ACTION_FEED 1\n#define TAG_ACTION_TABLE 2\n#define TAG_ACTION_N_TABLE 3\n#define TAG_ACTION_PLAIN 4\n\n#define CASE_TABLE_TAG \\\n\tcase HTML_TABLE:\\\n\tcase HTML_N_TABLE:\\\n\tcase HTML_TR:\\\n\tcase HTML_N_TR:\\\n\tcase HTML_TD:\\\n\tcase HTML_N_TD:\\\n\tcase HTML_TH:\\\n\tcase HTML_N_TH:\\\n\tcase HTML_THEAD:\\\n\tcase HTML_N_THEAD:\\\n\tcase HTML_TBODY:\\\n\tcase HTML_N_TBODY:\\\n\tcase HTML_TFOOT:\\\n\tcase HTML_N_TFOOT:\\\n\tcase HTML_COLGROUP:\\\n\tcase HTML_N_COLGROUP:\\\n\tcase HTML_COL\n\n#define ATTR_ROWSPAN_MAX 32766\n\nstatic int\nfeed_table_tag(struct table *tbl, char *line, struct table_mode *mode,\n\t       int width, struct parsed_tag *tag)\n{\n    int cmd;\n#ifdef ID_EXT\n    char *p;\n#endif\n    struct table_cell *cell = &tbl->cell;\n    int colspan, rowspan;\n    int col, prev_col;\n    int i, j, k, v, v0, w, id;\n    Str tok, tmp, anchor;\n    table_attr align, valign;\n\n    cmd = tag->tagid;\n\n    if (mode->pre_mode & TBLM_PLAIN) {\n\tif (mode->end_tag == cmd) {\n\t    mode->pre_mode &= ~TBLM_PLAIN;\n\t    mode->end_tag = 0;\n\t    feed_table_block_tag(tbl, line, mode, 0, cmd);\n\t    return TAG_ACTION_NONE;\n\t}\n\treturn TAG_ACTION_PLAIN;\n    }\n    if (mode->pre_mode & TBLM_INTXTA) {\n\tswitch (cmd) {\n\tCASE_TABLE_TAG:\n\tcase HTML_N_TEXTAREA:\n\t    table_close_textarea(tbl, mode, width);\n\t    if (cmd == HTML_N_TEXTAREA)\n\t\treturn TAG_ACTION_NONE;\n\t    break;\n\tdefault:\n\t    return TAG_ACTION_FEED;\n\t}\n    }\n    if (mode->pre_mode & TBLM_SCRIPT) {\n\tif (mode->end_tag == cmd) {\n\t    mode->pre_mode &= ~TBLM_SCRIPT;\n\t    mode->end_tag = 0;\n\t    return TAG_ACTION_NONE;\n\t}\n\treturn TAG_ACTION_PLAIN;\n    }\n    if (mode->pre_mode & TBLM_STYLE) {\n\tif (mode->end_tag == cmd) {\n\t    mode->pre_mode &= ~TBLM_STYLE;\n\t    mode->end_tag = 0;\n\t    return TAG_ACTION_NONE;\n\t}\n\treturn TAG_ACTION_PLAIN;\n    }\n    /* failsafe: a tag other than <option></option>and </select> in *\n     * <select> environment is regarded as the end of <select>. */\n    if (mode->pre_mode & TBLM_INSELECT) {\n\tswitch (cmd) {\n\t  CASE_TABLE_TAG:\n\tcase HTML_N_FORM:\n\tcase HTML_N_SELECT:\t/* mode->end_tag */\n\t    table_close_select(tbl, mode, width);\n\t    if (cmd == HTML_N_SELECT)\n\t\treturn TAG_ACTION_NONE;\n\t    break;\n\tdefault:\n\t    return TAG_ACTION_FEED;\n\t}\n    }\n    if (mode->caption) {\n\tswitch (cmd) {\n\t  CASE_TABLE_TAG:\n\tcase HTML_N_CAPTION:\n\t    mode->caption = 0;\n\t    if (cmd == HTML_N_CAPTION)\n\t\treturn TAG_ACTION_NONE;\n\t    break;\n\tdefault:\n\t    return TAG_ACTION_FEED;\n\t}\n    }\n\n    if (mode->pre_mode & TBLM_PRE) {\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\tcase HTML_N_NOBR:\n\tcase HTML_PRE_INT:\n\tcase HTML_N_PRE_INT:\n\t    return TAG_ACTION_NONE;\n\t}\n    }\n\n    switch (cmd) {\n    case HTML_TABLE:\n\tcheck_rowcol(tbl, mode);\n\treturn TAG_ACTION_TABLE;\n    case HTML_N_TABLE:\n\tif (tbl->suspended_data)\n\t    check_rowcol(tbl, mode);\n\treturn TAG_ACTION_N_TABLE;\n    case HTML_TR:\n\tif (tbl->col >= 0 && tbl->tabcontentssize > 0)\n\t    setwidth(tbl, mode);\n\ttbl->col = -1;\n\ttbl->row++;\n\ttbl->flag |= TBL_IN_ROW;\n\ttbl->flag &= ~TBL_IN_COL;\n\talign = 0;\n\tvalign = 0;\n\tif (parsedtag_get_value(tag, ATTR_ALIGN, &i)) {\n\t    switch (i) {\n\t    case ALIGN_LEFT:\n\t\talign = (HTT_LEFT | HTT_TRSET);\n\t\tbreak;\n\t    case ALIGN_RIGHT:\n\t\talign = (HTT_RIGHT | HTT_TRSET);\n\t\tbreak;\n\t    case ALIGN_CENTER:\n\t\talign = (HTT_CENTER | HTT_TRSET);\n\t\tbreak;\n\t    }\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALIGN, &i)) {\n\t    switch (i) {\n\t    case VALIGN_TOP:\n\t\tvalign = (HTT_TOP | HTT_VTRSET);\n\t\tbreak;\n\t    case VALIGN_MIDDLE:\n\t\tvalign = (HTT_MIDDLE | HTT_VTRSET);\n\t\tbreak;\n\t    case VALIGN_BOTTOM:\n\t\tvalign = (HTT_BOTTOM | HTT_VTRSET);\n\t\tbreak;\n\t    }\n\t}\n#ifdef ID_EXT\n\tif (parsedtag_get_value(tag, ATTR_ID, &p)) {\n\t    check_row(tbl, tbl->row);\n\t    tbl->tridvalue[tbl->row] = Strnew_charp(p);\n\t}\n#endif\t\t\t\t/* ID_EXT */\n\ttbl->trattr = align | valign;\n\tbreak;\n    case HTML_TH:\n    case HTML_TD:\n\tprev_col = tbl->col;\n\tif (tbl->col >= 0 && tbl->tabcontentssize > 0)\n\t    setwidth(tbl, mode);\n\tif (tbl->row == -1) {\n\t    /* for broken HTML... */\n\t    tbl->row = -1;\n\t    tbl->col = -1;\n\t    tbl->maxrow = tbl->row;\n\t}\n\tif (tbl->col == -1) {\n\t    if (!(tbl->flag & TBL_IN_ROW)) {\n\t\ttbl->row++;\n\t\ttbl->flag |= TBL_IN_ROW;\n\t    }\n\t    if (tbl->row > tbl->maxrow)\n\t\ttbl->maxrow = tbl->row;\n\t}\n\ttbl->col++;\n\tcheck_row(tbl, tbl->row);\n\twhile (tbl->col < MAXCOL && tbl->tabattr[tbl->row][tbl->col]) {\n\t    tbl->col++;\n\t}\n\tif (tbl->col > MAXCOL - 1) {\n\t    tbl->col = prev_col;\n\t    return TAG_ACTION_NONE;\n\t}\n\tif (tbl->col > tbl->maxcol) {\n\t    tbl->maxcol = tbl->col;\n\t}\n\tcolspan = rowspan = 1;\n\tif (tbl->trattr & HTT_TRSET)\n\t    align = (tbl->trattr & HTT_ALIGN);\n\telse if (cmd == HTML_TH)\n\t    align = HTT_CENTER;\n\telse\n\t    align = HTT_LEFT;\n\tif (tbl->trattr & HTT_VTRSET)\n\t    valign = (tbl->trattr & HTT_VALIGN);\n\telse\n\t    valign = HTT_MIDDLE;\n\tif (parsedtag_get_value(tag, ATTR_ROWSPAN, &rowspan)) {\n\t    if(rowspan > ATTR_ROWSPAN_MAX) {\n\t\trowspan = ATTR_ROWSPAN_MAX;\n\t    }\n\t    if ((tbl->row + rowspan) >= tbl->max_rowsize)\n\t\tcheck_row(tbl, tbl->row + rowspan);\n\t}\n\tif (rowspan < 1)\n\t    rowspan = 1;\n\tif (parsedtag_get_value(tag, ATTR_COLSPAN, &colspan)) {\n\t    if ((tbl->col + colspan) >= MAXCOL) {\n\t\t/* Can't expand column */\n\t\tcolspan = MAXCOL - tbl->col;\n\t    }\n\t}\n\tif (colspan < 1)\n\t    colspan = 1;\n\tif (parsedtag_get_value(tag, ATTR_ALIGN, &i)) {\n\t    switch (i) {\n\t    case ALIGN_LEFT:\n\t\talign = HTT_LEFT;\n\t\tbreak;\n\t    case ALIGN_RIGHT:\n\t\talign = HTT_RIGHT;\n\t\tbreak;\n\t    case ALIGN_CENTER:\n\t\talign = HTT_CENTER;\n\t\tbreak;\n\t    }\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALIGN, &i)) {\n\t    switch (i) {\n\t    case VALIGN_TOP:\n\t\tvalign = HTT_TOP;\n\t\tbreak;\n\t    case VALIGN_MIDDLE:\n\t\tvalign = HTT_MIDDLE;\n\t\tbreak;\n\t    case VALIGN_BOTTOM:\n\t\tvalign = HTT_BOTTOM;\n\t\tbreak;\n\t    }\n\t}\n#ifdef NOWRAP\n\tif (parsedtag_exists(tag, ATTR_NOWRAP))\n\t    tbl->tabattr[tbl->row][tbl->col] |= HTT_NOWRAP;\n#endif\t\t\t\t/* NOWRAP */\n\tv = 0;\n\tif (parsedtag_get_value(tag, ATTR_WIDTH, &v)) {\n#ifdef TABLE_EXPAND\n\t    if (v > 0) {\n\t\tif (tbl->real_width > 0)\n\t\t    v = -(v * 100) / (tbl->real_width * pixel_per_char);\n\t\telse\n\t\t    v = (int)(v / pixel_per_char);\n\t    }\n#else\n\t    v = RELATIVE_WIDTH(v);\n#endif\t\t\t\t/* not TABLE_EXPAND */\n\t}\n#ifdef ID_EXT\n\tif (parsedtag_get_value(tag, ATTR_ID, &p))\n\t    tbl->tabidvalue[tbl->row][tbl->col] = Strnew_charp(p);\n#endif\t\t\t\t/* ID_EXT */\n#ifdef NOWRAP\n\tif (v != 0) {\n\t    /* NOWRAP and WIDTH= conflicts each other */\n\t    tbl->tabattr[tbl->row][tbl->col] &= ~HTT_NOWRAP;\n\t}\n#endif\t\t\t\t/* NOWRAP */\n\ttbl->tabattr[tbl->row][tbl->col] &= ~(HTT_ALIGN | HTT_VALIGN);\n\ttbl->tabattr[tbl->row][tbl->col] |= (align | valign);\n\tif (colspan > 1) {\n\t    col = tbl->col;\n\n\t    cell->icell = cell->maxcell + 1;\n\t    k = bsearch_2short(colspan, cell->colspan, col, cell->col, MAXCOL,\n\t\t\t       cell->index, cell->icell);\n\t    if (k <= cell->maxcell) {\n\t\ti = cell->index[k];\n\t\tif (cell->col[i] == col && cell->colspan[i] == colspan)\n\t\t    cell->icell = i;\n\t    }\n\t    if (cell->icell > cell->maxcell && cell->icell < MAXCELL) {\n\t\tcell->maxcell++;\n\t\tcell->col[cell->maxcell] = col;\n\t\tcell->colspan[cell->maxcell] = colspan;\n\t\tcell->width[cell->maxcell] = 0;\n\t\tcell->minimum_width[cell->maxcell] = 0;\n\t\tcell->fixed_width[cell->maxcell] = 0;\n\t\tif (cell->maxcell > k) {\n\t\t    int ii;\n\t\t    for (ii = cell->maxcell; ii > k; ii--)\n\t\t\tcell->index[ii] = cell->index[ii - 1];\n\t\t}\n\t\tcell->index[k] = cell->maxcell;\n\t    }\n\t    if (cell->icell > cell->maxcell)\n\t\tcell->icell = -1;\n\t}\n\tif (v != 0) {\n\t    if (colspan == 1) {\n\t\tv0 = tbl->fixed_width[tbl->col];\n\t\tif (v0 == 0 || (v0 > 0 && v > v0) || (v0 < 0 && v < v0)) {\n#ifdef FEED_TABLE_DEBUG\n\t\t    fprintf(stderr, \"width(%d) = %d\\n\", tbl->col, v);\n#endif\t\t\t\t/* TABLE_DEBUG */\n\t\t    tbl->fixed_width[tbl->col] = v;\n\t\t}\n\t    }\n\t    else if (cell->icell >= 0) {\n\t\tv0 = cell->fixed_width[cell->icell];\n\t\tif (v0 == 0 || (v0 > 0 && v > v0) || (v0 < 0 && v < v0))\n\t\t    cell->fixed_width[cell->icell] = v;\n\t    }\n\t}\n\tfor (i = 0; i < rowspan; i++) {\n\t    check_row(tbl, tbl->row + i);\n\t    for (j = 0; j < colspan; j++) {\n#if 0\n\t\ttbl->tabattr[tbl->row + i][tbl->col + j] &= ~(HTT_X | HTT_Y);\n#endif\n\t\tif (!(tbl->tabattr[tbl->row + i][tbl->col + j] &\n\t\t      (HTT_X | HTT_Y))) {\n\t\t    tbl->tabattr[tbl->row + i][tbl->col + j] |=\n\t\t\t((i > 0) ? HTT_Y : 0) | ((j > 0) ? HTT_X : 0);\n\t\t}\n\t\tif (tbl->col + j > tbl->maxcol) {\n\t\t    tbl->maxcol = tbl->col + j;\n\t\t}\n\t    }\n\t    if (tbl->row + i > tbl->maxrow) {\n\t\ttbl->maxrow = tbl->row + i;\n\t    }\n\t}\n\tbegin_cell(tbl, mode);\n\tbreak;\n    case HTML_N_TR:\n\tsetwidth(tbl, mode);\n\ttbl->col = -1;\n\ttbl->flag &= ~(TBL_IN_ROW | TBL_IN_COL);\n\treturn TAG_ACTION_NONE;\n    case HTML_N_TH:\n    case HTML_N_TD:\n\tsetwidth(tbl, mode);\n\ttbl->flag &= ~TBL_IN_COL;\n#ifdef FEED_TABLE_DEBUG\n\t{\n\t    TextListItem *it;\n\t    int i = tbl->col, j = tbl->row;\n\t    fprintf(stderr, \"(a) row,col: %d, %d\\n\", j, i);\n\t    if (tbl->tabdata[j] && tbl->tabdata[j][i]) {\n\t\tfor (it = ((TextList *)tbl->tabdata[j][i])->first;\n\t\t     it; it = it->next)\n\t\t    fprintf(stderr, \"  [%s] \\n\", it->ptr);\n\t    }\n\t}\n#endif\n\treturn TAG_ACTION_NONE;\n    case HTML_P:\n    case HTML_BR:\n    case HTML_CENTER:\n    case HTML_N_CENTER:\n    case HTML_DIV:\n    case HTML_N_DIV:\n\tif (!(tbl->flag & TBL_IN_ROW))\n\t    break;\n    case HTML_DT:\n    case HTML_DD:\n    case HTML_H:\n    case HTML_N_H:\n    case HTML_LI:\n    case HTML_PRE:\n    case HTML_N_PRE:\n    case HTML_HR:\n    case HTML_LISTING:\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n    case HTML_PRE_PLAIN:\n    case HTML_N_PRE_PLAIN:\n\tfeed_table_block_tag(tbl, line, mode, 0, cmd);\n\tswitch (cmd) {\n\tcase HTML_PRE:\n\tcase HTML_PRE_PLAIN:\n\t    mode->pre_mode |= TBLM_PRE;\n\t    break;\n\tcase HTML_N_PRE:\n\tcase HTML_N_PRE_PLAIN:\n\t    mode->pre_mode &= ~TBLM_PRE;\n\t    break;\n\tcase HTML_LISTING:\n\t    mode->pre_mode |= TBLM_PLAIN;\n\t    mode->end_tag = HTML_N_LISTING;\n\t    break;\n\tcase HTML_XMP:\n\t    mode->pre_mode |= TBLM_PLAIN;\n\t    mode->end_tag = HTML_N_XMP;\n\t    break;\n\tcase HTML_PLAINTEXT:\n\t    mode->pre_mode |= TBLM_PLAIN;\n\t    mode->end_tag = MAX_HTMLTAG;\n\t    break;\n\t}\n\tbreak;\n    case HTML_DL:\n    case HTML_BLQ:\n    case HTML_OL:\n    case HTML_UL:\n\tfeed_table_block_tag(tbl, line, mode, 1, cmd);\n\tbreak;\n    case HTML_N_DL:\n    case HTML_N_BLQ:\n    case HTML_N_OL:\n    case HTML_N_UL:\n\tfeed_table_block_tag(tbl, line, mode, -1, cmd);\n\tbreak;\n    case HTML_NOBR:\n    case HTML_WBR:\n\tif (!(tbl->flag & TBL_IN_ROW))\n\t    break;\n    case HTML_PRE_INT:\n\tfeed_table_inline_tag(tbl, line, mode, -1);\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\t    mode->nobr_level++;\n\t    if (mode->pre_mode & TBLM_NOBR)\n\t\treturn TAG_ACTION_NONE;\n\t    mode->pre_mode |= TBLM_NOBR;\n\t    break;\n\tcase HTML_PRE_INT:\n\t    if (mode->pre_mode & TBLM_PRE_INT)\n\t\treturn TAG_ACTION_NONE;\n\t    mode->pre_mode |= TBLM_PRE_INT;\n\t    tbl->linfo.prev_spaces = 0;\n\t    break;\n\t}\n\tmode->nobr_offset = -1;\n\tif (tbl->linfo.length > 0) {\n\t    check_minimum0(tbl, tbl->linfo.length);\n\t    tbl->linfo.length = 0;\n\t}\n\tbreak;\n    case HTML_N_NOBR:\n\tif (!(tbl->flag & TBL_IN_ROW))\n\t    break;\n\tfeed_table_inline_tag(tbl, line, mode, -1);\n\tif (mode->nobr_level > 0)\n\t    mode->nobr_level--;\n\tif (mode->nobr_level == 0)\n\t    mode->pre_mode &= ~TBLM_NOBR;\n\tbreak;\n    case HTML_N_PRE_INT:\n\tfeed_table_inline_tag(tbl, line, mode, -1);\n\tmode->pre_mode &= ~TBLM_PRE_INT;\n\tbreak;\n    case HTML_IMG:\n\tcheck_rowcol(tbl, mode);\n\tw = tbl->fixed_width[tbl->col];\n\tif (w < 0) {\n\t    if (tbl->total_width > 0)\n\t\tw = -tbl->total_width * w / 100;\n\t    else if (width > 0)\n\t\tw = -width * w / 100;\n\t    else\n\t\tw = 0;\n\t}\n\telse if (w == 0) {\n\t    if (tbl->total_width > 0)\n\t\tw = tbl->total_width;\n\t    else if (width > 0)\n\t\tw = width;\n\t}\n\ttok = process_img(tag, w);\n\tfeed_table1(tbl, tok, mode, width);\n\tbreak;\n    case HTML_FORM:\n\tfeed_table_block_tag(tbl, \"\", mode, 0, cmd);\n\ttmp = process_form(tag);\n\tif (tmp)\n\t    feed_table1(tbl, tmp, mode, width);\n\tbreak;\n    case HTML_N_FORM:\n\tfeed_table_block_tag(tbl, \"\", mode, 0, cmd);\n\tprocess_n_form();\n\tbreak;\n    case HTML_INPUT:\n\ttmp = process_input(tag);\n\tfeed_table1(tbl, tmp, mode, width);\n\tbreak;\n    case HTML_BUTTON:\n       tmp = process_button(tag);\n       feed_table1(tbl, tmp, mode, width);\n       break;\n    case HTML_N_BUTTON:\n       tmp = process_n_button();\n       feed_table1(tbl, tmp, mode, width);\n       break;\n    case HTML_SELECT:\n\ttmp = process_select(tag);\n\tif (tmp)\n\t    feed_table1(tbl, tmp, mode, width);\n\tmode->pre_mode |= TBLM_INSELECT;\n\tmode->end_tag = HTML_N_SELECT;\n\tbreak;\n    case HTML_N_SELECT:\n    case HTML_OPTION:\n\t/* nothing */\n\tbreak;\n    case HTML_TEXTAREA:\n\tw = 0;\n\tcheck_rowcol(tbl, mode);\n\tif (tbl->col + 1 <= tbl->maxcol &&\n\t    tbl->tabattr[tbl->row][tbl->col + 1] & HTT_X) {\n\t    if (cell->icell >= 0 && cell->fixed_width[cell->icell] > 0)\n\t\tw = cell->fixed_width[cell->icell];\n\t}\n\telse {\n\t    if (tbl->fixed_width[tbl->col] > 0)\n\t\tw = tbl->fixed_width[tbl->col];\n\t}\n\ttmp = process_textarea(tag, w);\n\tif (tmp)\n\t    feed_table1(tbl, tmp, mode, width);\n\tmode->pre_mode |= TBLM_INTXTA;\n\tmode->end_tag = HTML_N_TEXTAREA;\n\tbreak;\n    case HTML_A:\n\ttable_close_anchor0(tbl, mode);\n\tanchor = NULL;\n\ti = 0;\n\tparsedtag_get_value(tag, ATTR_HREF, &anchor);\n\tparsedtag_get_value(tag, ATTR_HSEQ, &i);\n\tif (anchor) {\n\t    check_rowcol(tbl, mode);\n\t    if (i == 0) {\n\t\tStr tmp = process_anchor(tag, line);\n    \t\tif (displayLinkNumber)\n\t\t{\n\t\t\tStr t = getLinkNumberStr(-1);\n\t\t\tfeed_table_inline_tag(tbl, NULL, mode, t->length);\n\t\t\tStrcat(tmp, t);\n\t\t}\n\t\tpushdata(tbl, tbl->row, tbl->col, tmp->ptr);\n\t    }\n\t    else\n\t\tpushdata(tbl, tbl->row, tbl->col, line);\n\t    if (i >= 0) {\n\t\tmode->pre_mode |= TBLM_ANCHOR;\n\t\tmode->anchor_offset = tbl->tabcontentssize;\n\t    }\n\t}\n\telse\n\t    suspend_or_pushdata(tbl, line);\n\tbreak;\n    case HTML_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode |= TBLM_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 5);\t/* [DEL: */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_N_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode &= ~TBLM_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 5);\t/* :DEL] */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode |= TBLM_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 3);\t/* [S: */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_N_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode &= ~TBLM_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 3);\t/* :S] */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_INS:\n    case HTML_N_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 5);\t/* [INS:, :INS] */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_SUP:\n    case HTML_SUB:\n    case HTML_N_SUB:\n\tif (!(mode->pre_mode & (TBLM_DEL | TBLM_S)))\n\t    feed_table_inline_tag(tbl, line, mode, 1);\t/* ^, [, ] */\n\tbreak;\n    case HTML_N_SUP:\n\tbreak;\n    case HTML_TABLE_ALT:\n\tid = -1;\n\tparsedtag_get_value(tag, ATTR_TID, &id);\n\tif (id >= 0 && id < tbl->ntable) {\n\t    struct table *tbl1 = tbl->tables[id].ptr;\n\t    feed_table_block_tag(tbl, line, mode, 0, cmd);\n\t    addcontentssize(tbl, maximum_table_width(tbl1));\n\t    check_minimum0(tbl, tbl1->sloppy_width);\n#ifdef TABLE_EXPAND\n\t    w = tbl1->total_width;\n\t    v = 0;\n\t    colspan = table_colspan(tbl, tbl->row, tbl->col);\n\t    if (colspan > 1) {\n\t\tif (cell->icell >= 0)\n\t\t    v = cell->fixed_width[cell->icell];\n\t    }\n\t    else\n\t\tv = tbl->fixed_width[tbl->col];\n\t    if (v < 0 && tbl->real_width > 0 && tbl1->real_width > 0)\n\t\tw = -(tbl1->real_width * 100) / tbl->real_width;\n\t    else\n\t\tw = tbl1->real_width;\n\t    if (w > 0)\n\t\tcheck_minimum0(tbl, w);\n\t    else if (w < 0 && v < w) {\n\t\tif (colspan > 1) {\n\t\t    if (cell->icell >= 0)\n\t\t\tcell->fixed_width[cell->icell] = w;\n\t\t}\n\t\telse\n\t\t    tbl->fixed_width[tbl->col] = w;\n\t    }\n#endif\n\t    setwidth0(tbl, mode);\n\t    clearcontentssize(tbl, mode);\n\t}\n\tbreak;\n    case HTML_CAPTION:\n\tmode->caption = 1;\n\tbreak;\n    case HTML_N_CAPTION:\n    case HTML_THEAD:\n    case HTML_N_THEAD:\n    case HTML_TBODY:\n    case HTML_N_TBODY:\n    case HTML_TFOOT:\n    case HTML_N_TFOOT:\n    case HTML_COLGROUP:\n    case HTML_N_COLGROUP:\n    case HTML_COL:\n\tbreak;\n    case HTML_SCRIPT:\n\tmode->pre_mode |= TBLM_SCRIPT;\n\tmode->end_tag = HTML_N_SCRIPT;\n\tbreak;\n    case HTML_STYLE:\n\tmode->pre_mode |= TBLM_STYLE;\n\tmode->end_tag = HTML_N_STYLE;\n\tbreak;\n    case HTML_N_A:\n\ttable_close_anchor0(tbl, mode);\n    case HTML_FONT:\n    case HTML_N_FONT:\n    case HTML_NOP:\n\tsuspend_or_pushdata(tbl, line);\n\tbreak;\n    case HTML_INTERNAL:\n    case HTML_N_INTERNAL:\n    case HTML_FORM_INT:\n    case HTML_N_FORM_INT:\n    case HTML_INPUT_ALT:\n    case HTML_N_INPUT_ALT:\n    case HTML_SELECT_INT:\n    case HTML_N_SELECT_INT:\n    case HTML_OPTION_INT:\n    case HTML_TEXTAREA_INT:\n    case HTML_N_TEXTAREA_INT:\n    case HTML_IMG_ALT:\n    case HTML_SYMBOL:\n    case HTML_N_SYMBOL:\n    default:\n\t/* unknown tag: put into table */\n\treturn TAG_ACTION_FEED;\n    }\n    return TAG_ACTION_NONE;\n}\n\n\nint\nfeed_table(struct table *tbl, char *line, struct table_mode *mode,\n\t   int width, int internal)\n{\n    int i;\n    char *p;\n    Str tmp;\n    struct table_linfo *linfo = &tbl->linfo;\n\n    if (*line == '<' && line[1] && REALLY_THE_BEGINNING_OF_A_TAG(line)) {\n\tstruct parsed_tag *tag;\n\tp = line;\n\ttag = parse_tag(&p, internal);\n\tif (tag) {\n\t    switch (feed_table_tag(tbl, line, mode, width, tag)) {\n\t    case TAG_ACTION_NONE:\n\t\treturn -1;\n\t    case TAG_ACTION_N_TABLE:\n\t\treturn 0;\n\t    case TAG_ACTION_TABLE:\n\t\treturn 1;\n\t    case TAG_ACTION_PLAIN:\n\t\tbreak;\n\t    case TAG_ACTION_FEED:\n\t    default:\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    line = parsedtag2str(tag)->ptr;\n\t    }\n\t}\n\telse {\n\t    if (!(mode->pre_mode & (TBLM_PLAIN | TBLM_INTXTA | TBLM_INSELECT |\n\t\t\t\t    TBLM_SCRIPT | TBLM_STYLE)))\n\t\treturn -1;\n\t}\n    }\n    else {\n\tif (mode->pre_mode & (TBLM_DEL | TBLM_S))\n\t    return -1;\n    }\n    if (mode->caption) {\n\tStrcat_charp(tbl->caption, line);\n\treturn -1;\n    }\n    if (mode->pre_mode & TBLM_SCRIPT)\n\treturn -1;\n    if (mode->pre_mode & TBLM_STYLE)\n\treturn -1;\n    if (mode->pre_mode & TBLM_INTXTA) {\n\tfeed_textarea(line);\n\treturn -1;\n    }\n    if (mode->pre_mode & TBLM_INSELECT) {\n\tfeed_select(line);\n\treturn -1;\n    }\n    if (!(mode->pre_mode & TBLM_PLAIN) &&\n\t!(*line == '<' && line[strlen(line) - 1] == '>') &&\n\tstrchr(line, '&') != NULL) {\n\ttmp = Strnew();\n\tfor (p = line; *p;) {\n\t    char *q, *r;\n\t    if (*p == '&') {\n\t\tif (!strncasecmp(p, \"&amp;\", 5) ||\n\t\t    !strncasecmp(p, \"&gt;\", 4) || !strncasecmp(p, \"&lt;\", 4)) {\n\t\t    /* do not convert */\n\t\t    Strcat_char(tmp, *p);\n\t\t    p++;\n\t\t}\n\t\telse {\n\t\t    int ec;\n\t\t    q = p;\n\t\t    switch (ec = getescapechar(&p)) {\n\t\t    case '<':\n\t\t\tStrcat_charp(tmp, \"&lt;\");\n\t\t\tbreak;\n\t\t    case '>':\n\t\t\tStrcat_charp(tmp, \"&gt;\");\n\t\t\tbreak;\n\t\t    case '&':\n\t\t\tStrcat_charp(tmp, \"&amp;\");\n\t\t\tbreak;\n\t\t    case '\\r':\n\t\t\tStrcat_char(tmp, '\\n');\n\t\t\tbreak;\n\t\t    default:\n\t\t\tr = conv_entity(ec);\n\t\t\tif (r != NULL && strlen(r) == 1 &&\n\t\t\t    ec == (unsigned char)*r) {\n\t\t\t    Strcat_char(tmp, *r);\n\t\t\t    break;\n\t\t\t}\n\t\t    case -1:\n\t\t\tStrcat_char(tmp, *q);\n\t\t\tp = q + 1;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\tStrcat_char(tmp, *p);\n\t\tp++;\n\t    }\n\t}\n\tline = tmp->ptr;\n    }\n    if (!(mode->pre_mode & (TBLM_SPECIAL & ~TBLM_NOBR))) {\n\tif (!(tbl->flag & TBL_IN_COL) || linfo->prev_spaces != 0)\n\t    while (IS_SPACE(*line))\n\t\tline++;\n\tif (*line == '\\0')\n\t    return -1;\n\tcheck_rowcol(tbl, mode);\n\tif (mode->pre_mode & TBLM_NOBR && mode->nobr_offset < 0)\n\t    mode->nobr_offset = tbl->tabcontentssize;\n\n\t/* count of number of spaces skipped in normal mode */\n\ti = skip_space(tbl, line, linfo, !(mode->pre_mode & TBLM_NOBR));\n\taddcontentssize(tbl, visible_length(line) - i);\n\tsetwidth(tbl, mode);\n\tpushdata(tbl, tbl->row, tbl->col, line);\n    }\n    else if (mode->pre_mode & TBLM_PRE_INT) {\n\tcheck_rowcol(tbl, mode);\n\tif (mode->nobr_offset < 0)\n\t    mode->nobr_offset = tbl->tabcontentssize;\n\taddcontentssize(tbl, maximum_visible_length(line, tbl->tabcontentssize));\n\tsetwidth(tbl, mode);\n\tpushdata(tbl, tbl->row, tbl->col, line);\n    }\n    else {\n\t/* <pre> mode or something like it */\n\tcheck_rowcol(tbl, mode);\n\twhile (*line) {\n\t    int nl = FALSE;\n\t    if ((p = strchr(line, '\\r')) || (p = strchr(line, '\\n'))) {\n\t\tif (*p == '\\r' && p[1] == '\\n')\n\t\t    p++;\n\t\tif (p[1]) {\n\t\t    p++;\n\t\t    tmp = Strnew_charp_n(line, p - line);\n\t\t    line = p;\n\t\t    p = tmp->ptr;\n\t\t}\n\t\telse {\n\t\t    p = line;\n\t\t    line = \"\";\n\t\t}\n\t\tnl = TRUE;\n\t    }\n\t    else {\n\t\tp = line;\n\t\tline = \"\";\n\t    }\n\t    if (mode->pre_mode & TBLM_PLAIN)\n\t\ti = maximum_visible_length_plain(p, tbl->tabcontentssize);\n\t    else\n\t\ti = maximum_visible_length(p, tbl->tabcontentssize);\n\t    addcontentssize(tbl, i);\n\t    setwidth(tbl, mode);\n\t    if (nl)\n\t\tclearcontentssize(tbl, mode);\n\t    pushdata(tbl, tbl->row, tbl->col, p);\n\t}\n    }\n    return -1;\n}\n\nvoid\nfeed_table1(struct table *tbl, Str tok, struct table_mode *mode, int width)\n{\n    Str tokbuf;\n    int status;\n    char *line;\n    if (!tok)\n\treturn;\n    tokbuf = Strnew();\n    status = R_ST_NORMAL;\n    line = tok->ptr;\n    while (read_token\n\t   (tokbuf, &line, &status, mode->pre_mode & TBLM_PREMODE, 0))\n\tfeed_table(tbl, tokbuf->ptr, mode, width, TRUE);\n}\n\nvoid\npushTable(struct table *tbl, struct table *tbl1)\n{\n    int col;\n    int row;\n\n    col = tbl->col;\n    row = tbl->row;\n\n    if (tbl->ntable >= tbl->tables_size) {\n\tstruct table_in *tmp;\n\ttbl->tables_size += MAX_TABLE_N;\n\ttmp = New_N(struct table_in, tbl->tables_size);\n\tif (tbl->tables)\n\t    bcopy(tbl->tables, tmp, tbl->ntable * sizeof(struct table_in));\n\ttbl->tables = tmp;\n    }\n\n    tbl->tables[tbl->ntable].ptr = tbl1;\n    tbl->tables[tbl->ntable].col = col;\n    tbl->tables[tbl->ntable].row = row;\n    tbl->tables[tbl->ntable].indent = tbl->indent;\n    tbl->tables[tbl->ntable].buf = newTextLineList();\n    check_row(tbl, row);\n    if (col + 1 <= tbl->maxcol && tbl->tabattr[row][col + 1] & HTT_X)\n\ttbl->tables[tbl->ntable].cell = tbl->cell.icell;\n    else\n\ttbl->tables[tbl->ntable].cell = -1;\n    tbl->ntable++;\n}\n\n#ifdef MATRIX\nint\ncorrect_table_matrix(struct table *t, int col, int cspan, int a, double b)\n{\n    int i, j;\n    int ecol = col + cspan;\n    double w = 1. / (b * b);\n\n    for (i = col; i < ecol; i++) {\n\tv_add_val(t->vector, i, w * a);\n\tfor (j = i; j < ecol; j++) {\n\t    m_add_val(t->matrix, i, j, w);\n\t    m_set_val(t->matrix, j, i, m_entry(t->matrix, i, j));\n\t}\n    }\n    return i;\n}\n\nstatic void\ncorrect_table_matrix2(struct table *t, int col, int cspan, double s, double b)\n{\n    int i, j;\n    int ecol = col + cspan;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n    double ss;\n\n    for (i = 0; i < size; i++) {\n\tfor (j = i; j < size; j++) {\n\t    if (i >= col && i < ecol && j >= col && j < ecol)\n\t\tss = (1. - s) * (1. - s);\n\t    else if ((i >= col && i < ecol) || (j >= col && j < ecol))\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n\nstatic void\ncorrect_table_matrix3(struct table *t, int col, char *flags, double s,\n\t\t      double b)\n{\n    int i, j;\n    double ss;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n    int flg = (flags[col] == 0);\n\n    for (i = 0; i < size; i++) {\n\tif (!((flg && flags[i] == 0) || (!flg && flags[i] != 0)))\n\t    continue;\n\tfor (j = i; j < size; j++) {\n\t    if (!((flg && flags[j] == 0) || (!flg && flags[j] != 0)))\n\t\tcontinue;\n\t    if (i == col && j == col)\n\t\tss = (1. - s) * (1. - s);\n\t    else if (i == col || j == col)\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n\nstatic void\ncorrect_table_matrix4(struct table *t, int col, int cspan, char *flags,\n\t\t      double s, double b)\n{\n    int i, j;\n    double ss;\n    int ecol = col + cspan;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n\n    for (i = 0; i < size; i++) {\n\tif (flags[i] && !(i >= col && i < ecol))\n\t    continue;\n\tfor (j = i; j < size; j++) {\n\t    if (flags[j] && !(j >= col && j < ecol))\n\t\tcontinue;\n\t    if (i >= col && i < ecol && j >= col && j < ecol)\n\t\tss = (1. - s) * (1. - s);\n\t    else if ((i >= col && i < ecol) || (j >= col && j < ecol))\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n\nstatic void\nset_table_matrix0(struct table *t, int maxwidth)\n{\n    int size = t->maxcol + 1;\n    int i, j, k, bcol, ecol;\n    int width;\n    double w0, w1, w, s, b;\n#ifdef __GNUC__\n    double we[size];\n    char expand[size];\n#else\t\t\t\t/* not __GNUC__ */\n    double we[MAXCOL];\n    char expand[MAXCOL];\n#endif\t\t\t\t/* not __GNUC__ */\n    struct table_cell *cell = &t->cell;\n\n    w0 = 0.;\n    for (i = 0; i < size; i++) {\n\twe[i] = weight(t->tabwidth[i]);\n\tw0 += we[i];\n    }\n    if (w0 <= 0.)\n\tw0 = 1.;\n\n    if (cell->necell == 0) {\n\tfor (i = 0; i < size; i++) {\n\t    s = we[i] / w0;\n\t    b = sigma_td_nw((int)(s * maxwidth));\n\t    correct_table_matrix2(t, i, 1, s, b);\n\t}\n\treturn;\n    }\n\n    bzero(expand, size);\n\n    for (k = 0; k < cell->necell; k++) {\n\tj = cell->eindex[k];\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\twidth = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tw1 = 0.;\n\tfor (i = bcol; i < ecol; i++) {\n\t    w1 += t->tabwidth[i] + 0.1;\n\t    expand[i]++;\n\t}\n\tfor (i = bcol; i < ecol; i++) {\n\t    w = weight(width * (t->tabwidth[i] + 0.1) / w1);\n\t    if (w > we[i])\n\t\twe[i] = w;\n\t}\n    }\n\n    w0 = 0.;\n    w1 = 0.;\n    for (i = 0; i < size; i++) {\n\tw0 += we[i];\n\tif (expand[i] == 0)\n\t    w1 += we[i];\n    }\n    if (w0 <= 0.)\n\tw0 = 1.;\n\n    for (k = 0; k < cell->necell; k++) {\n\tj = cell->eindex[k];\n\tbcol = cell->col[j];\n\twidth = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tw = weight(width);\n\ts = w / (w1 + w);\n\tb = sigma_td_nw((int)(s * maxwidth));\n\tcorrect_table_matrix4(t, bcol, cell->colspan[j], expand, s, b);\n    }\n\n    for (i = 0; i < size; i++) {\n\tif (expand[i] == 0) {\n\t    s = we[i] / max(w1, 1.);\n\t    b = sigma_td_nw((int)(s * maxwidth));\n\t}\n\telse {\n\t    s = we[i] / max(w0 - w1, 1.);\n\t    b = sigma_td_nw(maxwidth);\n\t}\n\tcorrect_table_matrix3(t, i, expand, s, b);\n    }\n}\n\nvoid\ncheck_relative_width(struct table *t, int maxwidth)\n{\n    int i;\n    double rel_total = 0;\n    int size = t->maxcol + 1;\n    double *rcolwidth = New_N(double, size);\n    struct table_cell *cell = &t->cell;\n    int n_leftcol = 0;\n\n    for (i = 0; i < size; i++)\n\trcolwidth[i] = 0;\n\n    for (i = 0; i < size; i++) {\n\tif (t->fixed_width[i] < 0)\n\t    rcolwidth[i] = -(double)t->fixed_width[i] / 100.0;\n\telse if (t->fixed_width[i] > 0)\n\t    rcolwidth[i] = (double)t->fixed_width[i] / maxwidth;\n\telse\n\t    n_leftcol++;\n    }\n    for (i = 0; i <= cell->maxcell; i++) {\n\tif (cell->fixed_width[i] < 0) {\n\t    double w = -(double)cell->fixed_width[i] / 100.0;\n\t    double r;\n\t    int j, k;\n\t    int n_leftcell = 0;\n\t    k = cell->col[i];\n\t    r = 0.0;\n\t    for (j = 0; j < cell->colspan[i]; j++) {\n\t\tif (rcolwidth[j + k] > 0)\n\t\t    r += rcolwidth[j + k];\n\t\telse\n\t\t    n_leftcell++;\n\t    }\n\t    if (n_leftcell == 0) {\n\t\t/* w must be identical to r */\n\t\tif (w != r)\n\t\t    cell->fixed_width[i] = -100 * r;\n\t    }\n\t    else {\n\t\tif (w <= r) {\n\t\t    /* make room for the left(width-unspecified) cell */\n\t\t    /* the next formula is an estimation of required width */\n\t\t    w = r * cell->colspan[i] / (cell->colspan[i] - n_leftcell);\n\t\t    cell->fixed_width[i] = -100 * w;\n\t\t}\n\t\tfor (j = 0; j < cell->colspan[i]; j++) {\n\t\t    if (rcolwidth[j + k] == 0)\n\t\t\trcolwidth[j + k] = (w - r) / n_leftcell;\n\t\t}\n\t    }\n\t}\n\telse if (cell->fixed_width[i] > 0) {\n\t    /* todo */\n\t}\n    }\n    /* sanity check */\n    for (i = 0; i < size; i++)\n\trel_total += rcolwidth[i];\n\n    if ((n_leftcol == 0 && rel_total < 0.9) || 1.1 < rel_total) {\n\tfor (i = 0; i < size; i++) {\n\t    rcolwidth[i] /= rel_total;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t    if (t->fixed_width[i] < 0)\n\t\tt->fixed_width[i] = -rcolwidth[i] * 100;\n\t}\n\tfor (i = 0; i <= cell->maxcell; i++) {\n\t    if (cell->fixed_width[i] < 0) {\n\t\tdouble r;\n\t\tint j, k;\n\t\tk = cell->col[i];\n\t\tr = 0.0;\n\t\tfor (j = 0; j < cell->colspan[i]; j++)\n\t\t    r += rcolwidth[j + k];\n\t\tcell->fixed_width[i] = -r * 100;\n\t    }\n\t}\n    }\n}\n\nvoid\nset_table_matrix(struct table *t, int width)\n{\n    int size = t->maxcol + 1;\n    int i, j;\n    double b, s;\n    int a;\n    struct table_cell *cell = &t->cell;\n\n    if (size < 1)\n\treturn;\n\n    t->matrix = m_get(size, size);\n    t->vector = v_get(size);\n    for (i = 0; i < size; i++) {\n\tfor (j = i; j < size; j++)\n\t    m_set_val(t->matrix, i, j, 0.);\n\tv_set_val(t->vector, i, 0.);\n    }\n\n    check_relative_width(t, width);\n\n    for (i = 0; i < size; i++) {\n\tif (t->fixed_width[i] > 0) {\n\t    a = max(t->fixed_width[i], t->minimum_width[i]);\n\t    b = sigma_td(a);\n\t    correct_table_matrix(t, i, 1, a, b);\n\t}\n\telse if (t->fixed_width[i] < 0) {\n\t    s = -(double)t->fixed_width[i] / 100.;\n\t    b = sigma_td((int)(s * width));\n\t    correct_table_matrix2(t, i, 1, s, b);\n\t}\n    }\n\n    for (j = 0; j <= cell->maxcell; j++) {\n\tif (cell->fixed_width[j] > 0) {\n\t    a = max(cell->fixed_width[j], cell->minimum_width[j]);\n\t    b = sigma_td(a);\n\t    correct_table_matrix(t, cell->col[j], cell->colspan[j], a, b);\n\t}\n\telse if (cell->fixed_width[j] < 0) {\n\t    s = -(double)cell->fixed_width[j] / 100.;\n\t    b = sigma_td((int)(s * width));\n\t    correct_table_matrix2(t, cell->col[j], cell->colspan[j], s, b);\n\t}\n    }\n\n    set_table_matrix0(t, width);\n\n    if (t->total_width > 0) {\n\tb = sigma_table(width);\n    }\n    else {\n\tb = sigma_table_nw(width);\n    }\n    correct_table_matrix(t, 0, size, width, b);\n}\n#endif\t\t\t\t/* MATRIX */\n\n/* Local Variables:    */\n/* c-basic-offset: 4   */\n/* tab-width: 8        */\n/* End:                */\n"], "fixing_code": ["/* $Id: table.c,v 1.58 2010/08/09 11:59:19 htrb Exp $ */\n/* \n * HTML table\n */\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include \"fm.h\"\n#include \"html.h\"\n#include \"parsetagx.h\"\n#include \"Str.h\"\n#include \"myctype.h\"\n\nint symbol_width = 0;\nint symbol_width0 = 0;\n\n#define RULE_WIDTH symbol_width\n#define RULE(mode,n) (((mode) == BORDER_THICK) ? ((n) + 16) : (n))\n#define TK_VERTICALBAR(mode) RULE(mode,5)\n\n#define BORDERWIDTH     2\n#define BORDERHEIGHT    1\n#define NOBORDERWIDTH   1\n#define NOBORDERHEIGHT  0\n\n#define HTT_X   1\n#define HTT_Y   2\n#define HTT_ALIGN  0x30\n#define HTT_LEFT   0x00\n#define HTT_CENTER 0x10\n#define HTT_RIGHT  0x20\n#define HTT_TRSET  0x40\n#define HTT_VALIGN 0x700\n#define HTT_TOP    0x100\n#define HTT_MIDDLE 0x200\n#define HTT_BOTTOM 0x400\n#define HTT_VTRSET 0x800\n#ifdef NOWRAP\n#define HTT_NOWRAP  4\n#endif\t\t\t\t/* NOWRAP */\n#define TAG_IS(s,tag,len) (strncasecmp(s,tag,len)==0&&(s[len] == '>' || IS_SPACE((int)s[len])))\n\n#ifndef max\n#define max(a,b)        ((a) > (b) ? (a) : (b))\n#endif\t\t\t\t/* not max */\n#ifndef min\n#define min(a,b)        ((a) > (b) ? (b) : (a))\n#endif\t\t\t\t/* not min */\n#ifndef abs\n#define abs(a)          ((a) >= 0. ? (a) : -(a))\n#endif\t\t\t\t/* not abs */\n\n#define set_prevchar(x,y,n) Strcopy_charp_n((x),(y),(n))\n#define set_space_to_prevchar(x) Strcopy_charp_n((x),\" \",1)\n\n#ifdef MATRIX\n#ifndef MESCHACH\n#include \"matrix.c\"\n#endif\t\t\t\t/* not MESCHACH */\n#endif\t\t\t\t/* MATRIX */\n\n#ifdef MATRIX\nint correct_table_matrix(struct table *, int, int, int, double);\nvoid set_table_matrix(struct table *, int);\n#endif\t\t\t\t/* MATRIX */\n\n#ifdef MATRIX\nstatic double\nweight(int x)\n{\n\n    if (x < COLS)\n\treturn (double)x;\n    else\n\treturn COLS * (log((double)x / COLS) + 1.);\n}\n\nstatic double\nweight2(int a)\n{\n    return (double)a / COLS * 4 + 1.;\n}\n\n#define sigma_td(a)       (0.5*weight2(a))\t/* <td width=...> */\n#define sigma_td_nw(a)    (32*weight2(a))\t/* <td ...> */\n#define sigma_table(a)    (0.25*weight2(a))\t/* <table width=...> */\n#define sigma_table_nw(a) (2*weight2(a))\t/* <table...> */\n#else\t\t\t\t/* not MATRIX */\n#define LOG_MIN 1.0\nstatic double\nweight3(int x)\n{\n    if (x < 0.1)\n\treturn 0.1;\n    if (x < LOG_MIN)\n\treturn (double)x;\n    else\n\treturn LOG_MIN * (log((double)x / LOG_MIN) + 1.);\n}\n#endif\t\t\t\t/* not MATRIX */\n\nstatic int\nbsearch_2short(short e1, short *ent1, short e2, short *ent2, int base,\n\t       short *indexarray, int nent)\n{\n    int n = nent;\n    int k = 0;\n\n    int e = e1 * base + e2;\n    while (n > 0) {\n\tint nn = n / 2;\n\tint idx = indexarray[k + nn];\n\tint ne = ent1[idx] * base + ent2[idx];\n\tif (ne == e) {\n\t    k += nn;\n\t    break;\n\t}\n\telse if (ne < e) {\n\t    n -= nn + 1;\n\t    k += nn + 1;\n\t}\n\telse {\n\t    n = nn;\n\t}\n    }\n    return k;\n}\n\nstatic int\nbsearch_double(double e, double *ent, short *indexarray, int nent)\n{\n    int n = nent;\n    int k = 0;\n\n    while (n > 0) {\n\tint nn = n / 2;\n\tint idx = indexarray[k + nn];\n\tdouble ne = ent[idx];\n\tif (ne == e) {\n\t    k += nn;\n\t    break;\n\t}\n\telse if (ne > e) {\n\t    n -= nn + 1;\n\t    k += nn + 1;\n\t}\n\telse {\n\t    n = nn;\n\t}\n    }\n    return k;\n}\n\nstatic int\nceil_at_intervals(int x, int step)\n{\n    int mo = x % step;\n    if (mo > 0)\n\tx += step - mo;\n    else if (mo < 0)\n\tx -= mo;\n    return x;\n}\n\nstatic int\nfloor_at_intervals(int x, int step)\n{\n    int mo = x % step;\n    if (mo > 0)\n\tx -= mo;\n    else if (mo < 0)\n\tx += step - mo;\n    return x;\n}\n\n#define round(x) ((int)floor((x)+0.5))\n\n#ifndef MATRIX\nstatic void\ndv2sv(double *dv, short *iv, int size)\n{\n    int i, k, iw;\n    short *indexarray;\n    double *edv;\n    double w = 0., x;\n\n    indexarray = NewAtom_N(short, size);\n    edv = NewAtom_N(double, size);\n    for (i = 0; i < size; i++) {\n\tiv[i] = (short) ceil(dv[i]);\n\tedv[i] = (double)iv[i] - dv[i];\n    }\n\n    w = 0.;\n    for (k = 0; k < size; k++) {\n\tx = edv[k];\n\tw += x;\n\ti = bsearch_double(x, edv, indexarray, k);\n\tif (k > i) {\n\t    int ii;\n\t    for (ii = k; ii > i; ii--)\n\t\tindexarray[ii] = indexarray[ii - 1];\n\t}\n\tindexarray[i] = k;\n    }\n    iw = min((int)(w + 0.5), size);\n    if (iw <= 1)\n\treturn;\n    x = edv[(int)indexarray[iw - 1]];\n    for (i = 0; i < size; i++) {\n\tk = indexarray[i];\n\tif (i >= iw && abs(edv[k] - x) > 1e-6)\n\t    break;\n\tiv[k]--;\n    }\n}\n#endif\n\nstatic int\ntable_colspan(struct table *t, int row, int col)\n{\n    int i;\n    for (i = col + 1; i <= t->maxcol && (t->tabattr[row][i] & HTT_X); i++) ;\n    return i - col;\n}\n\nstatic int\ntable_rowspan(struct table *t, int row, int col)\n{\n    int i;\n    if (!t->tabattr[row])\n\treturn 0;\n    for (i = row + 1; i <= t->maxrow && t->tabattr[i] &&\n\t (t->tabattr[i][col] & HTT_Y); i++) ;\n    return i - row;\n}\n\nstatic int\nminimum_cellspacing(int border_mode)\n{\n    switch (border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\treturn RULE_WIDTH;\n    case BORDER_NONE:\n\treturn 1;\n    default:\n\t/* not reached */\n\treturn 0;\n    }\n}\n\nstatic int\ntable_border_width(struct table *t)\n{\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\treturn t->maxcol * t->cellspacing + 2 * (RULE_WIDTH + t->cellpadding);\n    case BORDER_NOWIN:\n    case BORDER_NONE:\n\treturn t->maxcol * t->cellspacing;\n    default:\n\t/* not reached */\n\treturn 0;\n    }\n}\n\nstruct table *\nnewTable()\n{\n    struct table *t;\n    int i, j;\n\n    t = New(struct table);\n    t->max_rowsize = MAXROW;\n    t->tabdata = New_N(GeneralList **, MAXROW);\n    t->tabattr = New_N(table_attr *, MAXROW);\n    t->tabheight = NewAtom_N(short, MAXROW);\n#ifdef ID_EXT\n    t->tabidvalue = New_N(Str *, MAXROW);\n    t->tridvalue = New_N(Str, MAXROW);\n#endif\t\t\t\t/* ID_EXT */\n\n    for (i = 0; i < MAXROW; i++) {\n\tt->tabdata[i] = NULL;\n\tt->tabattr[i] = 0;\n\tt->tabheight[i] = 0;\n#ifdef ID_EXT\n\tt->tabidvalue[i] = NULL;\n\tt->tridvalue[i] = NULL;\n#endif\t\t\t\t/* ID_EXT */\n    }\n    for (j = 0; j < MAXCOL; j++) {\n\tt->tabwidth[j] = 0;\n\tt->minimum_width[j] = 0;\n\tt->fixed_width[j] = 0;\n    }\n    t->cell.maxcell = -1;\n    t->cell.icell = -1;\n    t->ntable = 0;\n    t->tables_size = 0;\n    t->tables = NULL;\n#ifdef MATRIX\n    t->matrix = NULL;\n    t->vector = NULL;\n#endif\t\t\t\t/* MATRIX */\n#if 0\n    t->tabcontentssize = 0;\n    t->indent = 0;\n    t->linfo.prev_ctype = PC_ASCII;\n    t->linfo.prev_spaces = -1;\n#endif\n    t->linfo.prevchar = Strnew_size(8);\n    set_prevchar(t->linfo.prevchar, \"\", 0);\n    t->trattr = 0;\n\n    t->caption = Strnew();\n    t->suspended_data = NULL;\n#ifdef ID_EXT\n    t->id = NULL;\n#endif\n    return t;\n}\n\nstatic void\ncheck_row(struct table *t, int row)\n{\n    int i, r;\n    GeneralList ***tabdata;\n    table_attr **tabattr;\n    short *tabheight;\n#ifdef ID_EXT\n    Str **tabidvalue;\n    Str *tridvalue;\n#endif\t\t\t\t/* ID_EXT */\n\n    if (row >= t->max_rowsize) {\n\tr = max(t->max_rowsize * 2, row + 1);\n\ttabdata = New_N(GeneralList **, r);\n\ttabattr = New_N(table_attr *, r);\n\ttabheight = NewAtom_N(short, r);\n#ifdef ID_EXT\n\ttabidvalue = New_N(Str *, r);\n\ttridvalue = New_N(Str, r);\n#endif\t\t\t\t/* ID_EXT */\n\tfor (i = 0; i < t->max_rowsize; i++) {\n\t    tabdata[i] = t->tabdata[i];\n\t    tabattr[i] = t->tabattr[i];\n\t    tabheight[i] = t->tabheight[i];\n#ifdef ID_EXT\n\t    tabidvalue[i] = t->tabidvalue[i];\n\t    tridvalue[i] = t->tridvalue[i];\n#endif\t\t\t\t/* ID_EXT */\n\t}\n\tfor (; i < r; i++) {\n\t    tabdata[i] = NULL;\n\t    tabattr[i] = NULL;\n\t    tabheight[i] = 0;\n#ifdef ID_EXT\n\t    tabidvalue[i] = NULL;\n\t    tridvalue[i] = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\t}\n\tt->tabdata = tabdata;\n\tt->tabattr = tabattr;\n\tt->tabheight = tabheight;\n#ifdef ID_EXT\n\tt->tabidvalue = tabidvalue;\n\tt->tridvalue = tridvalue;\n#endif\t\t\t\t/* ID_EXT */\n\tt->max_rowsize = r;\n    }\n\n    if (t->tabdata[row] == NULL) {\n\tt->tabdata[row] = New_N(GeneralList *, MAXCOL);\n\tt->tabattr[row] = NewAtom_N(table_attr, MAXCOL);\n#ifdef ID_EXT\n\tt->tabidvalue[row] = New_N(Str, MAXCOL);\n#endif\t\t\t\t/* ID_EXT */\n\tfor (i = 0; i < MAXCOL; i++) {\n\t    t->tabdata[row][i] = NULL;\n\t    t->tabattr[row][i] = 0;\n#ifdef ID_EXT\n\t    t->tabidvalue[row][i] = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\t}\n    }\n}\n\nvoid\npushdata(struct table *t, int row, int col, char *data)\n{\n    check_row(t, row);\n    if (t->tabdata[row][col] == NULL)\n\tt->tabdata[row][col] = newGeneralList();\n\n    pushText(t->tabdata[row][col], data ? data : \"\");\n}\n\nvoid\nsuspend_or_pushdata(struct table *tbl, char *line)\n{\n    if (tbl->flag & TBL_IN_COL)\n\tpushdata(tbl, tbl->row, tbl->col, line);\n    else {\n\tif (!tbl->suspended_data)\n\t    tbl->suspended_data = newTextList();\n\tpushText(tbl->suspended_data, line ? line : \"\");\n    }\n}\n\n#ifdef USE_M17N\n#define PUSH_TAG(str,n) Strcat_charp_n(tagbuf, str, n)\n#else\n#define PUSH_TAG(str,n) Strcat_char(tagbuf, *str)\n#endif\n\nint visible_length_offset = 0;\nint\nvisible_length(char *str)\n{\n    int len = 0, n, max_len = 0;\n    int status = R_ST_NORMAL;\n    int prev_status = status;\n    Str tagbuf = Strnew();\n    char *t, *r2;\n    int amp_len = 0;\n\n    while (*str) {\n\tprev_status = status;\n\tif (next_status(*str, &status)) {\n#ifdef USE_M17N\n\t    len += get_mcwidth(str);\n\t    n = get_mclen(str);\n\t}\n\telse {\n\t    n = 1;\n\t}\n#else\n\t    len++;\n\t}\n#endif\n\tif (status == R_ST_TAG0) {\n\t    Strclear(tagbuf);\n\t    PUSH_TAG(str, n);\n\t}\n\telse if (status == R_ST_TAG || status == R_ST_DQUOTE\n\t\t || status == R_ST_QUOTE || status == R_ST_EQL\n\t\t || status == R_ST_VALUE) {\n\t    PUSH_TAG(str, n);\n\t}\n\telse if (status == R_ST_AMP) {\n\t    if (prev_status == R_ST_NORMAL) {\n\t\tStrclear(tagbuf);\n\t\tlen--;\n\t\tamp_len = 0;\n\t    }\n\t    else {\n\t\tPUSH_TAG(str, n);\n\t\tamp_len++;\n\t    }\n\t}\n\telse if (status == R_ST_NORMAL && prev_status == R_ST_AMP) {\n\t    PUSH_TAG(str, n);\n\t    r2 = tagbuf->ptr;\n\t    t = getescapecmd(&r2);\n\t    if (!*r2 && (*t == '\\r' || *t == '\\n')) {\n\t\tif (len > max_len)\n\t\t    max_len = len;\n\t\tlen = 0;\n\t    }\n\t    else\n\t\tlen += get_strwidth(t) + get_strwidth(r2);\n\t}\n\telse if (status == R_ST_NORMAL && ST_IS_REAL_TAG(prev_status)) {\n\t    ;\n\t}\n\telse if (*str == '\\t') {\n\t    len--;\n\t    do {\n\t\tlen++;\n\t    } while ((visible_length_offset + len) % Tabstop != 0);\n\t}\n\telse if (*str == '\\r' || *str == '\\n') {\n\t    len--;\n\t    if (len > max_len)\n\t\tmax_len = len;\n\t    len = 0;\n\t}\n#ifdef USE_M17N\n\tstr += n;\n#else\n\tstr++;\n#endif\n    }\n    if (status == R_ST_AMP) {\n\tr2 = tagbuf->ptr;\n\tt = getescapecmd(&r2);\n\tif (*t != '\\r' && *t != '\\n')\n\t    len += get_strwidth(t) + get_strwidth(r2);\n    }\n    return len > max_len ? len : max_len;\n}\n\nint\nvisible_length_plain(char *str)\n{\n    int len = 0, max_len = 0;\n\n    while (*str) {\n\tif (*str == '\\t') {\n\t    do {\n\t\tlen++;\n\t    } while ((visible_length_offset + len) % Tabstop != 0);\n\t    str++;\n\t}\n\telse if (*str == '\\r' || *str == '\\n') {\n\t    if (len > max_len)\n\t\tmax_len = len;\n\t    len = 0;\n\t    str++;\n\t}\n\telse {\n#ifdef USE_M17N\n\t    len += get_mcwidth(str);\n\t    str += get_mclen(str);\n#else\n\t    len++;\n\t    str++;\n#endif\n\t}\n    }\n    return len > max_len ? len : max_len;\n}\n\nstatic int\nmaximum_visible_length(char *str, int offset)\n{\n    visible_length_offset = offset;\n    return visible_length(str);\n}\n\nstatic int\nmaximum_visible_length_plain(char *str, int offset)\n{\n    visible_length_offset = offset;\n    return visible_length_plain(str);\n}\n\nvoid\nalign(TextLine *lbuf, int width, int mode)\n{\n    int i, l, l1, l2;\n    Str buf, line = lbuf->line;\n\n    if (line->length == 0) {\n\tfor (i = 0; i < width; i++)\n\t    Strcat_char(line, ' ');\n\tlbuf->pos = width;\n\treturn;\n    }\n    buf = Strnew();\n    l = width - lbuf->pos;\n    switch (mode) {\n    case ALIGN_CENTER:\n\tl1 = l / 2;\n\tl2 = l - l1;\n\tfor (i = 0; i < l1; i++)\n\t    Strcat_char(buf, ' ');\n\tStrcat(buf, line);\n\tfor (i = 0; i < l2; i++)\n\t    Strcat_char(buf, ' ');\n\tbreak;\n    case ALIGN_LEFT:\n\tStrcat(buf, line);\n\tfor (i = 0; i < l; i++)\n\t    Strcat_char(buf, ' ');\n\tbreak;\n    case ALIGN_RIGHT:\n\tfor (i = 0; i < l; i++)\n\t    Strcat_char(buf, ' ');\n\tStrcat(buf, line);\n\tbreak;\n    default:\n\treturn;\n    }\n    lbuf->line = buf;\n    if (lbuf->pos < width)\n\tlbuf->pos = width;\n}\n\nvoid\nprint_item(struct table *t, int row, int col, int width, Str buf)\n{\n    int alignment;\n    TextLine *lbuf;\n\n    if (t->tabdata[row])\n\tlbuf = popTextLine(t->tabdata[row][col]);\n    else\n\tlbuf = NULL;\n\n    if (lbuf != NULL) {\n\tcheck_row(t, row);\n\talignment = ALIGN_CENTER;\n\tif ((t->tabattr[row][col] & HTT_ALIGN) == HTT_LEFT)\n\t    alignment = ALIGN_LEFT;\n\telse if ((t->tabattr[row][col] & HTT_ALIGN) == HTT_RIGHT)\n\t    alignment = ALIGN_RIGHT;\n\telse if ((t->tabattr[row][col] & HTT_ALIGN) == HTT_CENTER)\n\t    alignment = ALIGN_CENTER;\n\talign(lbuf, width, alignment);\n\tStrcat(buf, lbuf->line);\n    }\n    else {\n\tlbuf = newTextLine(NULL, 0);\n\talign(lbuf, width, ALIGN_CENTER);\n\tStrcat(buf, lbuf->line);\n    }\n}\n\n\n#define T_TOP           0\n#define T_MIDDLE        1\n#define T_BOTTOM        2\n\nvoid\nprint_sep(struct table *t, int row, int type, int maxcol, Str buf)\n{\n    int forbid;\n    int rule_mode;\n    int i, k, l, m;\n\n    if (row >= 0)\n\tcheck_row(t, row);\n    check_row(t, row + 1);\n    if ((type == T_TOP || type == T_BOTTOM) && t->border_mode == BORDER_THICK) {\n\trule_mode = BORDER_THICK;\n    }\n    else {\n\trule_mode = BORDER_THIN;\n    }\n    forbid = 1;\n    if (type == T_TOP)\n\tforbid |= 2;\n    else if (type == T_BOTTOM)\n\tforbid |= 8;\n    else if (t->tabattr[row + 1][0] & HTT_Y) {\n\tforbid |= 4;\n    }\n    if (t->border_mode != BORDER_NOWIN) {\n\tpush_symbol(buf, RULE(t->border_mode, forbid), symbol_width, 1);\n    }\n    for (i = 0; i <= maxcol; i++) {\n\tforbid = 10;\n\tif (type != T_BOTTOM && (t->tabattr[row + 1][i] & HTT_Y)) {\n\t    if (t->tabattr[row + 1][i] & HTT_X) {\n\t\tgoto do_last_sep;\n\t    }\n\t    else {\n\t\tfor (k = row;\n\t\t     k >= 0 && t->tabattr[k] && (t->tabattr[k][i] & HTT_Y);\n\t\t     k--) ;\n\t\tm = t->tabwidth[i] + 2 * t->cellpadding;\n\t\tfor (l = i + 1; l <= t->maxcol && (t->tabattr[row][l] & HTT_X);\n\t\t     l++)\n\t\t    m += t->tabwidth[l] + t->cellspacing;\n\t\tprint_item(t, k, i, m, buf);\n\t    }\n\t}\n\telse {\n\t    int w = t->tabwidth[i] + 2 * t->cellpadding;\n\t    if (RULE_WIDTH == 2)\n\t\tw = (w + 1) / RULE_WIDTH;\n\t    push_symbol(buf, RULE(rule_mode, forbid), symbol_width, w);\n\t}\n      do_last_sep:\n\tif (i < maxcol) {\n\t    forbid = 0;\n\t    if (type == T_TOP)\n\t\tforbid |= 2;\n\t    else if (t->tabattr[row][i + 1] & HTT_X) {\n\t\tforbid |= 2;\n\t    }\n\t    if (type == T_BOTTOM)\n\t\tforbid |= 8;\n\t    else {\n\t\tif (t->tabattr[row + 1][i + 1] & HTT_X) {\n\t\t    forbid |= 8;\n\t\t}\n\t\tif (t->tabattr[row + 1][i + 1] & HTT_Y) {\n\t\t    forbid |= 4;\n\t\t}\n\t\tif (t->tabattr[row + 1][i] & HTT_Y) {\n\t\t    forbid |= 1;\n\t\t}\n\t    }\n\t    if (forbid != 15)\t/* forbid==15 means 'no rule at all' */\n\t\tpush_symbol(buf, RULE(rule_mode, forbid), symbol_width, 1);\n\t}\n    }\n    forbid = 4;\n    if (type == T_TOP)\n\tforbid |= 2;\n    if (type == T_BOTTOM)\n\tforbid |= 8;\n    if (t->tabattr[row + 1][maxcol] & HTT_Y) {\n\tforbid |= 1;\n    }\n    if (t->border_mode != BORDER_NOWIN)\n\tpush_symbol(buf, RULE(t->border_mode, forbid), symbol_width, 1);\n}\n\nstatic int\nget_spec_cell_width(struct table *tbl, int row, int col)\n{\n    int i, w;\n\n    w = tbl->tabwidth[col];\n    for (i = col + 1; i <= tbl->maxcol; i++) {\n\tcheck_row(tbl, row);\n\tif (tbl->tabattr[row][i] & HTT_X)\n\t    w += tbl->tabwidth[i] + tbl->cellspacing;\n\telse\n\t    break;\n    }\n    return w;\n}\n\nvoid\ndo_refill(struct table *tbl, int row, int col, int maxlimit)\n{\n    TextList *orgdata;\n    TextListItem *l;\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    int colspan, icell;\n\n    if (tbl->tabdata[row] == NULL || tbl->tabdata[row][col] == NULL)\n\treturn;\n    orgdata = (TextList *)tbl->tabdata[row][col];\n    tbl->tabdata[row][col] = newGeneralList();\n\n    init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL,\n\t      (TextLineList *)tbl->tabdata[row][col],\n\t      get_spec_cell_width(tbl, row, col), 0);\n    obuf.flag |= RB_INTABLE;\n    if (h_env.limit > maxlimit)\n\th_env.limit = maxlimit;\n    if (tbl->border_mode != BORDER_NONE && tbl->vcellpadding > 0)\n\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n    for (l = orgdata->first; l != NULL; l = l->next) {\n\tif (TAG_IS(l->ptr, \"<table_alt\", 10)) {\n\t    int id = -1;\n\t    char *p = l->ptr;\n\t    struct parsed_tag *tag;\n\t    if ((tag = parse_tag(&p, TRUE)) != NULL)\n\t\tparsedtag_get_value(tag, ATTR_TID, &id);\n\t    if (id >= 0 && id < tbl->ntable && tbl->tables[id].ptr) {\n\t\tint alignment;\n\t\tTextLineListItem *ti;\n\t\tstruct table *t = tbl->tables[id].ptr;\n\t\tint limit = tbl->tables[id].indent + t->total_width;\n\t\ttbl->tables[id].ptr = NULL;\n\t\tsave_fonteffect(&h_env, h_env.obuf);\n\t\tflushline(&h_env, &obuf, 0, 2, h_env.limit);\n\t\tif (t->vspace > 0 && !(obuf.flag & RB_IGNORE_P))\n\t\t    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t\tif (RB_GET_ALIGN(h_env.obuf) == RB_CENTER)\n\t\t    alignment = ALIGN_CENTER;\n\t\telse if (RB_GET_ALIGN(h_env.obuf) == RB_RIGHT)\n\t\t    alignment = ALIGN_RIGHT;\n\t\telse\n\t\t    alignment = ALIGN_LEFT;\n\n\t\tif (alignment != ALIGN_LEFT) {\n\t\t    for (ti = tbl->tables[id].buf->first;\n\t\t\t ti != NULL; ti = ti->next)\n\t\t\talign(ti->ptr, h_env.limit, alignment);\n\t\t}\n\t\tappendTextLineList(h_env.buf, tbl->tables[id].buf);\n\t\tif (h_env.maxlimit < limit)\n\t\t    h_env.maxlimit = limit;\n\t\trestore_fonteffect(&h_env, h_env.obuf);\n\t\tobuf.flag &= ~RB_IGNORE_P;\n\t\th_env.blank_lines = 0;\n\t\tif (t->vspace > 0) {\n\t\t    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t\t    obuf.flag |= RB_IGNORE_P;\n\t\t}\n\t    }\n\t}\n\telse\n\t    HTMLlineproc1(l->ptr, &h_env);\n    }\n    if (obuf.status != R_ST_NORMAL) {\n\tobuf.status = R_ST_EOL;\n\tHTMLlineproc1(\"\\n\", &h_env);\n    }\n    completeHTMLstream(&h_env, &obuf);\n    flushline(&h_env, &obuf, 0, 2, h_env.limit);\n    if (tbl->border_mode == BORDER_NONE) {\n\tint rowspan = table_rowspan(tbl, row, col);\n\tif (row + rowspan <= tbl->maxrow) {\n\t    if (tbl->vcellpadding > 0 && !(obuf.flag & RB_IGNORE_P))\n\t\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t}\n\telse {\n\t    if (tbl->vspace > 0)\n\t\tpurgeline(&h_env);\n\t}\n    }\n    else {\n\tif (tbl->vcellpadding > 0) {\n\t    if (!(obuf.flag & RB_IGNORE_P))\n\t\tdo_blankline(&h_env, &obuf, 0, 0, h_env.limit);\n\t}\n\telse\n\t    purgeline(&h_env);\n    }\n    if ((colspan = table_colspan(tbl, row, col)) > 1) {\n\tstruct table_cell *cell = &tbl->cell;\n\tint k;\n\tk = bsearch_2short(colspan, cell->colspan, col, cell->col, MAXCOL,\n\t\t\t   cell->index, cell->maxcell + 1);\n\ticell = cell->index[k];\n\tif (cell->minimum_width[icell] < h_env.maxlimit)\n\t    cell->minimum_width[icell] = h_env.maxlimit;\n    }\n    else {\n\tif (tbl->minimum_width[col] < h_env.maxlimit)\n\t    tbl->minimum_width[col] = h_env.maxlimit;\n    }\n}\n\nstatic int\ntable_rule_width(struct table *t)\n{\n    if (t->border_mode == BORDER_NONE)\n\treturn 1;\n    return RULE_WIDTH;\n}\n\nstatic void\ncheck_cell_width(short *tabwidth, short *cellwidth,\n\t\t short *col, short *colspan, short maxcell,\n\t\t short *indexarray, int space, int dir)\n{\n    int i, j, k, bcol, ecol;\n    int swidth, width;\n\n    for (k = 0; k <= maxcell; k++) {\n\tj = indexarray[k];\n\tif (cellwidth[j] <= 0)\n\t    continue;\n\tbcol = col[j];\n\tecol = bcol + colspan[j];\n\tswidth = 0;\n\tfor (i = bcol; i < ecol; i++)\n\t    swidth += tabwidth[i];\n\n\twidth = cellwidth[j] - (colspan[j] - 1) * space;\n\tif (width > swidth) {\n\t    int w = (width - swidth) / colspan[j];\n\t    int r = (width - swidth) % colspan[j];\n\t    for (i = bcol; i < ecol; i++)\n\t\ttabwidth[i] += w;\n\t    /* dir {0: horizontal, 1: vertical} */\n\t    if (dir == 1 && r > 0)\n\t\tr = colspan[j];\n\t    for (i = 1; i <= r; i++)\n\t\ttabwidth[ecol - i]++;\n\t}\n    }\n}\n\nvoid\ncheck_minimum_width(struct table *t, short *tabwidth)\n{\n    int i;\n    struct table_cell *cell = &t->cell;\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tif (tabwidth[i] < t->minimum_width[i])\n\t    tabwidth[i] = t->minimum_width[i];\n    }\n\n    check_cell_width(tabwidth, cell->minimum_width, cell->col, cell->colspan,\n\t\t     cell->maxcell, cell->index, t->cellspacing, 0);\n}\n\nvoid\ncheck_maximum_width(struct table *t)\n{\n    struct table_cell *cell = &t->cell;\n#ifdef MATRIX\n    int i, j, bcol, ecol;\n    int swidth, width;\n\n    cell->necell = 0;\n    for (j = 0; j <= cell->maxcell; j++) {\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\tswidth = 0;\n\tfor (i = bcol; i < ecol; i++)\n\t    swidth += t->tabwidth[i];\n\n\twidth = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tif (width > swidth) {\n\t    cell->eindex[cell->necell] = j;\n\t    cell->necell++;\n\t}\n    }\n#else\t\t\t\t/* not MATRIX */\n    check_cell_width(t->tabwidth, cell->width, cell->col, cell->colspan,\n\t\t     cell->maxcell, cell->index, t->cellspacing, 0);\n    check_minimum_width(t, t->tabwidth);\n#endif\t\t\t\t/* not MATRIX */\n}\n\n\n#ifdef MATRIX\nstatic void\nset_integered_width(struct table *t, double *dwidth, short *iwidth)\n{\n    int i, j, k, n, bcol, ecol, step;\n    short *indexarray;\n    char *fixed;\n    double *mod;\n    double sum = 0., x = 0.;\n    struct table_cell *cell = &t->cell;\n    int rulewidth = table_rule_width(t);\n\n    indexarray = NewAtom_N(short, t->maxcol + 1);\n    mod = NewAtom_N(double, t->maxcol + 1);\n    for (i = 0; i <= t->maxcol; i++) {\n\tiwidth[i] = ceil_at_intervals(ceil(dwidth[i]), rulewidth);\n\tmod[i] = (double)iwidth[i] - dwidth[i];\n    }\n\n    sum = 0.;\n    for (k = 0; k <= t->maxcol; k++) {\n\tx = mod[k];\n\tsum += x;\n\ti = bsearch_double(x, mod, indexarray, k);\n\tif (k > i) {\n\t    int ii;\n\t    for (ii = k; ii > i; ii--)\n\t\tindexarray[ii] = indexarray[ii - 1];\n\t}\n\tindexarray[i] = k;\n    }\n\n    fixed = NewAtom_N(char, t->maxcol + 1);\n    bzero(fixed, t->maxcol + 1);\n    for (step = 0; step < 2; step++) {\n\tfor (i = 0; i <= t->maxcol; i += n) {\n\t    int nn;\n\t    short *idx;\n\t    double nsum;\n\t    if (sum < 0.5)\n\t\treturn;\n\t    for (n = 0; i + n <= t->maxcol; n++) {\n\t\tint ii = indexarray[i + n];\n\t\tif (n == 0)\n\t\t    x = mod[ii];\n\t\telse if (fabs(mod[ii] - x) > 1e-6)\n\t\t    break;\n\t    }\n\t    for (k = 0; k < n; k++) {\n\t\tint ii = indexarray[i + k];\n\t\tif (fixed[ii] < 2 &&\n\t\t    iwidth[ii] - rulewidth < t->minimum_width[ii])\n\t\t    fixed[ii] = 2;\n\t\tif (fixed[ii] < 1 &&\n\t\t    iwidth[ii] - rulewidth < t->tabwidth[ii] &&\n\t\t    (double)rulewidth - mod[ii] > 0.5)\n\t\t    fixed[ii] = 1;\n\t    }\n\t    idx = NewAtom_N(short, n);\n\t    for (k = 0; k < cell->maxcell; k++) {\n\t\tint kk, w, width, m;\n\t\tj = cell->index[k];\n\t\tbcol = cell->col[j];\n\t\tecol = bcol + cell->colspan[j];\n\t\tm = 0;\n\t\tfor (kk = 0; kk < n; kk++) {\n\t\t    int ii = indexarray[i + kk];\n\t\t    if (ii >= bcol && ii < ecol) {\n\t\t\tidx[m] = ii;\n\t\t\tm++;\n\t\t    }\n\t\t}\n\t\tif (m == 0)\n\t\t    continue;\n\t\twidth = (cell->colspan[j] - 1) * t->cellspacing;\n\t\tfor (kk = bcol; kk < ecol; kk++)\n\t\t    width += iwidth[kk];\n\t\tw = 0;\n\t\tfor (kk = 0; kk < m; kk++) {\n\t\t    if (fixed[(int)idx[kk]] < 2)\n\t\t\tw += rulewidth;\n\t\t}\n\t\tif (width - w < cell->minimum_width[j]) {\n\t\t    for (kk = 0; kk < m; kk++) {\n\t\t\tif (fixed[(int)idx[kk]] < 2)\n\t\t\t    fixed[(int)idx[kk]] = 2;\n\t\t    }\n\t\t}\n\t\tw = 0;\n\t\tfor (kk = 0; kk < m; kk++) {\n\t\t    if (fixed[(int)idx[kk]] < 1 &&\n\t\t\t(double)rulewidth - mod[(int)idx[kk]] > 0.5)\n\t\t\tw += rulewidth;\n\t\t}\n\t\tif (width - w < cell->width[j]) {\n\t\t    for (kk = 0; kk < m; kk++) {\n\t\t\tif (fixed[(int)idx[kk]] < 1 &&\n\t\t\t    (double)rulewidth - mod[(int)idx[kk]] > 0.5)\n\t\t\t    fixed[(int)idx[kk]] = 1;\n\t\t    }\n\t\t}\n\t    }\n\t    nn = 0;\n\t    for (k = 0; k < n; k++) {\n\t\tint ii = indexarray[i + k];\n\t\tif (fixed[ii] <= step)\n\t\t    nn++;\n\t    }\n\t    nsum = sum - (double)(nn * rulewidth);\n\t    if (nsum < 0. && fabs(sum) <= fabs(nsum))\n\t\treturn;\n\t    for (k = 0; k < n; k++) {\n\t\tint ii = indexarray[i + k];\n\t\tif (fixed[ii] <= step) {\n\t\t    iwidth[ii] -= rulewidth;\n\t\t    fixed[ii] = 3;\n\t\t}\n\t    }\n\t    sum = nsum;\n\t}\n    }\n}\n\nstatic double\ncorrelation_coefficient(double sxx, double syy, double sxy)\n{\n    double coe, tmp;\n    tmp = sxx * syy;\n    if (tmp < Tiny)\n\ttmp = Tiny;\n    coe = sxy / sqrt(tmp);\n    if (coe > 1.)\n\treturn 1.;\n    if (coe < -1.)\n\treturn -1.;\n    return coe;\n}\n\nstatic double\ncorrelation_coefficient2(double sxx, double syy, double sxy)\n{\n    double coe, tmp;\n    tmp = (syy + sxx - 2 * sxy) * sxx;\n    if (tmp < Tiny)\n\ttmp = Tiny;\n    coe = (sxx - sxy) / sqrt(tmp);\n    if (coe > 1.)\n\treturn 1.;\n    if (coe < -1.)\n\treturn -1.;\n    return coe;\n}\n\nstatic double\nrecalc_width(double old, double swidth, int cwidth,\n\t     double sxx, double syy, double sxy, int is_inclusive)\n{\n    double delta = swidth - (double)cwidth;\n    double rat = sxy / sxx,\n\tcoe = correlation_coefficient(sxx, syy, sxy), w, ww;\n    if (old < 0.)\n\told = 0.;\n    if (fabs(coe) < 1e-5)\n\treturn old;\n    w = rat * old;\n    ww = delta;\n    if (w > 0.) {\n\tdouble wmin = 5e-3 * sqrt(syy * (1. - coe * coe));\n\tif (swidth < 0.2 && cwidth > 0 && is_inclusive) {\n\t    double coe1 = correlation_coefficient2(sxx, syy, sxy);\n\t    if (coe > 0.9 || coe1 > 0.9)\n\t\treturn 0.;\n\t}\n\tif (wmin > 0.05)\n\t    wmin = 0.05;\n\tif (ww < 0.)\n\t    ww = 0.;\n\tww += wmin;\n    }\n    else {\n\tdouble wmin = 5e-3 * sqrt(syy) * fabs(coe);\n\tif (rat > -0.001)\n\t    return old;\n\tif (wmin > 0.01)\n\t    wmin = 0.01;\n\tif (ww > 0.)\n\t    ww = 0.;\n\tww -= wmin;\n    }\n    if (w > ww)\n\treturn ww / rat;\n    return old;\n}\n\nstatic int\ncheck_compressible_cell(struct table *t, MAT * minv,\n\t\t\tdouble *newwidth, double *swidth, short *cwidth,\n\t\t\tdouble totalwidth, double *Sxx,\n\t\t\tint icol, int icell, double sxx, int corr)\n{\n    struct table_cell *cell = &t->cell;\n    int i, j, k, m, bcol, ecol, span;\n    double delta, owidth;\n    double dmax, dmin, sxy;\n    int rulewidth = table_rule_width(t);\n\n    if (sxx < 10.)\n\treturn corr;\n\n    if (icol >= 0) {\n\towidth = newwidth[icol];\n\tdelta = newwidth[icol] - (double)t->tabwidth[icol];\n\tbcol = icol;\n\tecol = bcol + 1;\n    }\n    else if (icell >= 0) {\n\towidth = swidth[icell];\n\tdelta = swidth[icell] - (double)cwidth[icell];\n\tbcol = cell->col[icell];\n\tecol = bcol + cell->colspan[icell];\n    }\n    else {\n\towidth = totalwidth;\n\tdelta = totalwidth;\n\tbcol = 0;\n\tecol = t->maxcol + 1;\n    }\n\n    dmin = delta;\n    dmax = -1.;\n    for (k = 0; k <= cell->maxcell; k++) {\n\tint bcol1, ecol1;\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tj = cell->index[k];\n\tif (j == icell)\n\t    continue;\n\tbcol1 = cell->col[j];\n\tecol1 = bcol1 + cell->colspan[j];\n\tsxy = 0.;\n\tfor (m = bcol1; m < ecol1; m++) {\n\t    for (i = bcol; i < ecol; i++)\n\t\tsxy += m_entry(minv, i, m);\n\t}\n\tif (bcol1 >= bcol && ecol1 <= ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n    }\n    for (m = 0; m <= t->maxcol; m++) {\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tif (m == icol)\n\t    continue;\n\tsxy = 0.;\n\tfor (i = bcol; i < ecol; i++)\n\t    sxy += m_entry(minv, i, m);\n\tif (m >= bcol && m < ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n    }\n  _end:\n    if (dmax > 0. && dmin > dmax)\n\tdmin = dmax;\n    span = ecol - bcol;\n    if ((span == t->maxcol + 1 && dmin >= 0.) ||\n\t(span != t->maxcol + 1 && dmin > rulewidth * 0.5)) {\n\tint nwidth = ceil_at_intervals(round(owidth - dmin), rulewidth);\n\tcorrect_table_matrix(t, bcol, ecol - bcol, nwidth, 1.);\n\tcorr++;\n    }\n    return corr;\n}\n\n#define MAX_ITERATION 10\nint\ncheck_table_width(struct table *t, double *newwidth, MAT * minv, int itr)\n{\n    int i, j, k, m, bcol, ecol;\n    int corr = 0;\n    struct table_cell *cell = &t->cell;\n#ifdef __GNUC__\n    short orgwidth[t->maxcol + 1], corwidth[t->maxcol + 1];\n    short cwidth[cell->maxcell + 1];\n    double swidth[cell->maxcell + 1];\n#else\t\t\t\t/* __GNUC__ */\n    short orgwidth[MAXCOL], corwidth[MAXCOL];\n    short cwidth[MAXCELL];\n    double swidth[MAXCELL];\n#endif\t\t\t\t/* __GNUC__ */\n    double twidth, sxy, *Sxx, stotal;\n\n    twidth = 0.;\n    stotal = 0.;\n    for (i = 0; i <= t->maxcol; i++) {\n\ttwidth += newwidth[i];\n\tstotal += m_entry(minv, i, i);\n\tfor (m = 0; m < i; m++) {\n\t    stotal += 2 * m_entry(minv, i, m);\n\t}\n    }\n\n    Sxx = NewAtom_N(double, cell->maxcell + 1);\n    for (k = 0; k <= cell->maxcell; k++) {\n\tj = cell->index[k];\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\tswidth[j] = 0.;\n\tfor (i = bcol; i < ecol; i++)\n\t    swidth[j] += newwidth[i];\n\tcwidth[j] = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tSxx[j] = 0.;\n\tfor (i = bcol; i < ecol; i++) {\n\t    Sxx[j] += m_entry(minv, i, i);\n\t    for (m = bcol; m <= ecol; m++) {\n\t\tif (m < i)\n\t\t    Sxx[j] += 2 * m_entry(minv, i, m);\n\t    }\n\t}\n    }\n\n    /* compress table */\n    corr = check_compressible_cell(t, minv, newwidth, swidth,\n\t\t\t\t   cwidth, twidth, Sxx, -1, -1, stotal, corr);\n    if (itr < MAX_ITERATION && corr > 0)\n\treturn corr;\n\n    /* compress multicolumn cell */\n    for (k = cell->maxcell; k >= 0; k--) {\n\tj = cell->index[k];\n\tcorr = check_compressible_cell(t, minv, newwidth, swidth,\n\t\t\t\t       cwidth, twidth, Sxx,\n\t\t\t\t       -1, j, Sxx[j], corr);\n\tif (itr < MAX_ITERATION && corr > 0)\n\t    return corr;\n    }\n\n    /* compress single column cell */\n    for (i = 0; i <= t->maxcol; i++) {\n\tcorr = check_compressible_cell(t, minv, newwidth, swidth,\n\t\t\t\t       cwidth, twidth, Sxx,\n\t\t\t\t       i, -1, m_entry(minv, i, i), corr);\n\tif (itr < MAX_ITERATION && corr > 0)\n\t    return corr;\n    }\n\n\n    for (i = 0; i <= t->maxcol; i++)\n\tcorwidth[i] = orgwidth[i] = round(newwidth[i]);\n\n    check_minimum_width(t, corwidth);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tdouble sx = sqrt(m_entry(minv, i, i));\n\tif (sx < 0.1)\n\t    continue;\n\tif (orgwidth[i] < t->minimum_width[i] &&\n\t    corwidth[i] == t->minimum_width[i]) {\n\t    double w = (sx > 0.5) ? 0.5 : sx * 0.2;\n\t    sxy = 0.;\n\t    for (m = 0; m <= t->maxcol; m++) {\n\t\tif (m == i)\n\t\t    continue;\n\t\tsxy += m_entry(minv, i, m);\n\t    }\n\t    if (sxy <= 0.) {\n\t\tcorrect_table_matrix(t, i, 1, t->minimum_width[i], w);\n\t\tcorr++;\n\t    }\n\t}\n    }\n\n    for (k = 0; k <= cell->maxcell; k++) {\n\tint nwidth = 0, mwidth;\n\tdouble sx;\n\n\tj = cell->index[k];\n\tsx = sqrt(Sxx[j]);\n\tif (sx < 0.1)\n\t    continue;\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\tfor (i = bcol; i < ecol; i++)\n\t    nwidth += corwidth[i];\n\tmwidth =\n\t    cell->minimum_width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tif (mwidth > swidth[j] && mwidth == nwidth) {\n\t    double w = (sx > 0.5) ? 0.5 : sx * 0.2;\n\n\t    sxy = 0.;\n\t    for (i = bcol; i < ecol; i++) {\n\t\tfor (m = 0; m <= t->maxcol; m++) {\n\t\t    if (m >= bcol && m < ecol)\n\t\t\tcontinue;\n\t\t    sxy += m_entry(minv, i, m);\n\t\t}\n\t    }\n\t    if (sxy <= 0.) {\n\t\tcorrect_table_matrix(t, bcol, cell->colspan[j], mwidth, w);\n\t\tcorr++;\n\t    }\n\t}\n    }\n\n    if (itr >= MAX_ITERATION)\n\treturn 0;\n    else\n\treturn corr;\n}\n\n#else\t\t\t\t/* not MATRIX */\nvoid\nset_table_width(struct table *t, short *newwidth, int maxwidth)\n{\n    int i, j, k, bcol, ecol;\n    struct table_cell *cell = &t->cell;\n    char *fixed;\n    int swidth, fwidth, width, nvar;\n    double s;\n    double *dwidth;\n    int try_again;\n\n    fixed = NewAtom_N(char, t->maxcol + 1);\n    bzero(fixed, t->maxcol + 1);\n    dwidth = NewAtom_N(double, t->maxcol + 1);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tdwidth[i] = 0.0;\n\tif (t->fixed_width[i] < 0) {\n\t    t->fixed_width[i] = -t->fixed_width[i] * maxwidth / 100;\n\t}\n\tif (t->fixed_width[i] > 0) {\n\t    newwidth[i] = t->fixed_width[i];\n\t    fixed[i] = 1;\n\t}\n\telse\n\t    newwidth[i] = 0;\n\tif (newwidth[i] < t->minimum_width[i])\n\t    newwidth[i] = t->minimum_width[i];\n    }\n\n    for (k = 0; k <= cell->maxcell; k++) {\n\tj = cell->indexarray[k];\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\n\tif (cell->fixed_width[j] < 0)\n\t    cell->fixed_width[j] = -cell->fixed_width[j] * maxwidth / 100;\n\n\tswidth = 0;\n\tfwidth = 0;\n\tnvar = 0;\n\tfor (i = bcol; i < ecol; i++) {\n\t    if (fixed[i]) {\n\t\tfwidth += newwidth[i];\n\t    }\n\t    else {\n\t\tswidth += newwidth[i];\n\t\tnvar++;\n\t    }\n\t}\n\twidth = max(cell->fixed_width[j], cell->minimum_width[j])\n\t    - (cell->colspan[j] - 1) * t->cellspacing;\n\tif (nvar > 0 && width > fwidth + swidth) {\n\t    s = 0.;\n\t    for (i = bcol; i < ecol; i++) {\n\t\tif (!fixed[i])\n\t\t    s += weight3(t->tabwidth[i]);\n\t    }\n\t    for (i = bcol; i < ecol; i++) {\n\t\tif (!fixed[i])\n\t\t    dwidth[i] = (width - fwidth) * weight3(t->tabwidth[i]) / s;\n\t\telse\n\t\t    dwidth[i] = (double)newwidth[i];\n\t    }\n\t    dv2sv(dwidth, newwidth, cell->colspan[j]);\n\t    if (cell->fixed_width[j] > 0) {\n\t\tfor (i = bcol; i < ecol; i++)\n\t\t    fixed[i] = 1;\n\t    }\n\t}\n    }\n\n    do {\n\tnvar = 0;\n\tswidth = 0;\n\tfwidth = 0;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (fixed[i]) {\n\t\tfwidth += newwidth[i];\n\t    }\n\t    else {\n\t\tswidth += newwidth[i];\n\t\tnvar++;\n\t    }\n\t}\n\twidth = maxwidth - t->maxcol * t->cellspacing;\n\tif (nvar == 0 || width <= fwidth + swidth)\n\t    break;\n\n\ts = 0.;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (!fixed[i])\n\t\ts += weight3(t->tabwidth[i]);\n\t}\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (!fixed[i])\n\t\tdwidth[i] = (width - fwidth) * weight3(t->tabwidth[i]) / s;\n\t    else\n\t\tdwidth[i] = (double)newwidth[i];\n\t}\n\tdv2sv(dwidth, newwidth, t->maxcol + 1);\n\n\ttry_again = 0;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (!fixed[i]) {\n\t\tif (newwidth[i] > t->tabwidth[i]) {\n\t\t    newwidth[i] = t->tabwidth[i];\n\t\t    fixed[i] = 1;\n\t\t    try_again = 1;\n\t\t}\n\t\telse if (newwidth[i] < t->minimum_width[i]) {\n\t\t    newwidth[i] = t->minimum_width[i];\n\t\t    fixed[i] = 1;\n\t\t    try_again = 1;\n\t\t}\n\t    }\n\t}\n    } while (try_again);\n}\n#endif\t\t\t\t/* not MATRIX */\n\nvoid\ncheck_table_height(struct table *t)\n{\n    int i, j, k;\n    struct {\n\tshort *row;\n\tshort *rowspan;\n\tshort *indexarray;\n\tshort maxcell;\n\tshort size;\n\tshort *height;\n    } cell;\n    int space = 0;\n\n    cell.size = 0;\n    cell.maxcell = -1;\n\n    for (j = 0; j <= t->maxrow; j++) {\n\tif (!t->tabattr[j])\n\t    continue;\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    int t_dep, rowspan;\n\t    if (t->tabattr[j][i] & (HTT_X | HTT_Y))\n\t\tcontinue;\n\n\t    if (t->tabdata[j][i] == NULL)\n\t\tt_dep = 0;\n\t    else\n\t\tt_dep = t->tabdata[j][i]->nitem;\n\n\t    rowspan = table_rowspan(t, j, i);\n\t    if (rowspan > 1) {\n\t\tint c = cell.maxcell + 1;\n\t\tk = bsearch_2short(rowspan, cell.rowspan,\n\t\t\t\t   j, cell.row, t->maxrow + 1, cell.indexarray,\n\t\t\t\t   c);\n\t\tif (k <= cell.maxcell) {\n\t\t    int idx = cell.indexarray[k];\n\t\t    if (cell.row[idx] == j && cell.rowspan[idx] == rowspan)\n\t\t\tc = idx;\n\t\t}\n\t\tif (c >= MAXROWCELL)\n\t\t    continue;\n\t\tif (c >= cell.size) {\n\t\t    if (cell.size == 0) {\n\t\t\tcell.size = max(MAXCELL, c + 1);\n\t\t\tcell.row = NewAtom_N(short, cell.size);\n\t\t\tcell.rowspan = NewAtom_N(short, cell.size);\n\t\t\tcell.indexarray = NewAtom_N(short, cell.size);\n\t\t\tcell.height = NewAtom_N(short, cell.size);\n\t\t    }\n\t\t    else {\n\t\t\tcell.size = max(cell.size + MAXCELL, c + 1);\n\t\t\tcell.row = New_Reuse(short, cell.row, cell.size);\n\t\t\tcell.rowspan = New_Reuse(short, cell.rowspan,\n\t\t\t\t\t\t cell.size);\n\t\t\tcell.indexarray = New_Reuse(short, cell.indexarray,\n\t\t\t\t\t\t    cell.size);\n\t\t\tcell.height = New_Reuse(short, cell.height, cell.size);\n\t\t    }\n\t\t}\n\t\tif (c > cell.maxcell) {\n\t\t    cell.maxcell++;\n\t\t    cell.row[cell.maxcell] = j;\n\t\t    cell.rowspan[cell.maxcell] = rowspan;\n\t\t    cell.height[cell.maxcell] = 0;\n\t\t    if (cell.maxcell > k) {\n\t\t\tint ii;\n\t\t\tfor (ii = cell.maxcell; ii > k; ii--)\n\t\t\t    cell.indexarray[ii] = cell.indexarray[ii - 1];\n\t\t    }\n\t\t    cell.indexarray[k] = cell.maxcell;\n\t\t}\n\n\t\tif (cell.height[c] < t_dep)\n\t\t    cell.height[c] = t_dep;\n\t\tcontinue;\n\t    }\n\t    if (t->tabheight[j] < t_dep)\n\t\tt->tabheight[j] = t_dep;\n\t}\n    }\n\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\tspace = 1;\n\tbreak;\n    case BORDER_NONE:\n\tspace = 0;\n    }\n    check_cell_width(t->tabheight, cell.height, cell.row, cell.rowspan,\n\t\t     cell.maxcell, cell.indexarray, space, 1);\n}\n\n#define CHECK_MINIMUM\t1\n#define CHECK_FIXED\t2\n\nint\nget_table_width(struct table *t, short *orgwidth, short *cellwidth, int flag)\n{\n#ifdef __GNUC__\n    short newwidth[t->maxcol + 1];\n#else\t\t\t\t/* not __GNUC__ */\n    short newwidth[MAXCOL];\n#endif\t\t\t\t/* not __GNUC__ */\n    int i;\n    int swidth;\n    struct table_cell *cell = &t->cell;\n    int rulewidth = table_rule_width(t);\n\n    for (i = 0; i <= t->maxcol; i++)\n\tnewwidth[i] = max(orgwidth[i], 0);\n\n    if (flag & CHECK_FIXED) {\n#ifdef __GNUC__\n\tshort ccellwidth[cell->maxcell + 1];\n#else\t\t\t\t/* not __GNUC__ */\n\tshort ccellwidth[MAXCELL];\n#endif\t\t\t\t/* not __GNUC__ */\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    if (newwidth[i] < t->fixed_width[i])\n\t\tnewwidth[i] = t->fixed_width[i];\n\t}\n\tfor (i = 0; i <= cell->maxcell; i++) {\n\t    ccellwidth[i] = cellwidth[i];\n\t    if (ccellwidth[i] < cell->fixed_width[i])\n\t\tccellwidth[i] = cell->fixed_width[i];\n\t}\n\tcheck_cell_width(newwidth, ccellwidth, cell->col, cell->colspan,\n\t\t\t cell->maxcell, cell->index, t->cellspacing, 0);\n    }\n    else {\n\tcheck_cell_width(newwidth, cellwidth, cell->col, cell->colspan,\n\t\t\t cell->maxcell, cell->index, t->cellspacing, 0);\n    }\n    if (flag & CHECK_MINIMUM)\n\tcheck_minimum_width(t, newwidth);\n\n    swidth = 0;\n    for (i = 0; i <= t->maxcol; i++) {\n\tswidth += ceil_at_intervals(newwidth[i], rulewidth);\n    }\n    swidth += table_border_width(t);\n    return swidth;\n}\n\n#define minimum_table_width(t)\\\n(get_table_width(t,t->minimum_width,t->cell.minimum_width,0))\n#define maximum_table_width(t)\\\n  (get_table_width(t,t->tabwidth,t->cell.width,CHECK_FIXED))\n#define fixed_table_width(t)\\\n  (get_table_width(t,t->fixed_width,t->cell.fixed_width,CHECK_MINIMUM))\n\n#define MAX_COTABLE_LEVEL 100\nstatic int cotable_level;\n\nvoid\ninitRenderTable(void)\n{\n    cotable_level = 0;\n}\n\nvoid\nrenderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n\n    if (cotable_level >= MAX_COTABLE_LEVEL)\n\treturn;\t/* workaround to prevent infinite recursion */\n    cotable_level++;\n\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tif (t == NULL)\n\t    continue;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}\n\nstatic void\nmake_caption(struct table *t, struct html_feed_environ *h_env)\n{\n    struct html_feed_environ henv;\n    struct readbuffer obuf;\n    struct environment envs[MAX_ENV_LEVEL];\n    int limit;\n\n    if (t->caption->length <= 0)\n\treturn;\n\n    if (t->total_width > 0)\n\tlimit = t->total_width;\n    else\n\tlimit = h_env->limit;\n    init_henv(&henv, &obuf, envs, MAX_ENV_LEVEL, newTextLineList(),\n\t      limit, h_env->envs[h_env->envc].indent);\n    HTMLlineproc1(\"<center>\", &henv);\n    HTMLlineproc0(t->caption->ptr, &henv, FALSE);\n    HTMLlineproc1(\"</center>\", &henv);\n\n    if (t->total_width < henv.maxlimit)\n\tt->total_width = henv.maxlimit;\n    limit = h_env->limit;\n    h_env->limit = t->total_width;\n    HTMLlineproc1(\"<center>\", h_env);\n    HTMLlineproc0(t->caption->ptr, h_env, FALSE);\n    HTMLlineproc1(\"</center>\", h_env);\n    h_env->limit = limit;\n}\n\nvoid\nrenderTable(struct table *t, int max_width, struct html_feed_environ *h_env)\n{\n    int i, j, w, r, h;\n    Str renderbuf;\n    short new_tabwidth[MAXCOL] = { 0 };\n#ifdef MATRIX\n    int itr;\n    VEC *newwidth;\n    MAT *mat, *minv;\n    PERM *pivot;\n#endif\t\t\t\t/* MATRIX */\n    int width;\n    int rulewidth;\n    Str vrulea = NULL, vruleb = NULL, vrulec = NULL;\n#ifdef ID_EXT\n    Str idtag;\n#endif\t\t\t\t/* ID_EXT */\n\n    t->total_height = 0;\n    if (t->maxcol < 0) {\n\tmake_caption(t, h_env);\n\treturn;\n    }\n\n    if (t->sloppy_width > max_width)\n\tmax_width = t->sloppy_width;\n\n    rulewidth = table_rule_width(t);\n\n    max_width -= table_border_width(t);\n\n    if (rulewidth > 1)\n\tmax_width = floor_at_intervals(max_width, rulewidth);\n\n    if (max_width < rulewidth)\n\tmax_width = rulewidth;\n\n#define MAX_TABWIDTH 10000\n    if (max_width > MAX_TABWIDTH)\n\tmax_width = MAX_TABWIDTH;\n\n    check_maximum_width(t);\n\n#ifdef MATRIX\n    if (t->maxcol == 0) {\n\tif (t->tabwidth[0] > max_width)\n\t    t->tabwidth[0] = max_width;\n\tif (t->total_width > 0)\n\t    t->tabwidth[0] = max_width;\n\telse if (t->fixed_width[0] > 0)\n\t    t->tabwidth[0] = t->fixed_width[0];\n\tif (t->tabwidth[0] < t->minimum_width[0])\n\t    t->tabwidth[0] = t->minimum_width[0];\n    }\n    else {\n\tset_table_matrix(t, max_width);\n\n\titr = 0;\n\tmat = m_get(t->maxcol + 1, t->maxcol + 1);\n\tpivot = px_get(t->maxcol + 1);\n\tnewwidth = v_get(t->maxcol + 1);\n\tminv = m_get(t->maxcol + 1, t->maxcol + 1);\n\tdo {\n\t    m_copy(t->matrix, mat);\n\t    LUfactor(mat, pivot);\n\t    LUsolve(mat, pivot, t->vector, newwidth);\n\t    LUinverse(mat, pivot, minv);\n#ifdef TABLE_DEBUG\n\t    set_integered_width(t, newwidth->ve, new_tabwidth);\n\t    fprintf(stderr, \"itr=%d\\n\", itr);\n\t    fprintf(stderr, \"max_width=%d\\n\", max_width);\n\t    fprintf(stderr, \"minimum : \");\n\t    for (i = 0; i <= t->maxcol; i++)\n\t\tfprintf(stderr, \"%2d \", t->minimum_width[i]);\n\t    fprintf(stderr, \"\\nfixed : \");\n\t    for (i = 0; i <= t->maxcol; i++)\n\t\tfprintf(stderr, \"%2d \", t->fixed_width[i]);\n\t    fprintf(stderr, \"\\ndecided : \");\n\t    for (i = 0; i <= t->maxcol; i++)\n\t\tfprintf(stderr, \"%2d \", new_tabwidth[i]);\n\t    fprintf(stderr, \"\\n\");\n#endif\t\t\t\t/* TABLE_DEBUG */\n\t    itr++;\n\n\t} while (check_table_width(t, newwidth->ve, minv, itr));\n\tset_integered_width(t, newwidth->ve, new_tabwidth);\n\tcheck_minimum_width(t, new_tabwidth);\n\tv_free(newwidth);\n\tpx_free(pivot);\n\tm_free(mat);\n\tm_free(minv);\n\tm_free(t->matrix);\n\tv_free(t->vector);\n\tfor (i = 0; i <= t->maxcol; i++) {\n\t    t->tabwidth[i] = new_tabwidth[i];\n\t}\n    }\n#else\t\t\t\t/* not MATRIX */\n    set_table_width(t, new_tabwidth, max_width);\n    for (i = 0; i <= t->maxcol; i++) {\n\tt->tabwidth[i] = new_tabwidth[i];\n    }\n#endif\t\t\t\t/* not MATRIX */\n\n    check_minimum_width(t, t->tabwidth);\n    for (i = 0; i <= t->maxcol; i++)\n\tt->tabwidth[i] = ceil_at_intervals(t->tabwidth[i], rulewidth);\n\n    renderCoTable(t, h_env->limit);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tfor (j = 0; j <= t->maxrow; j++) {\n\t    check_row(t, j);\n\t    if (t->tabattr[j][i] & HTT_Y)\n\t\tcontinue;\n\t    do_refill(t, j, i, h_env->limit);\n\t}\n    }\n\n    check_minimum_width(t, t->tabwidth);\n    t->total_width = 0;\n    for (i = 0; i <= t->maxcol; i++) {\n\tt->tabwidth[i] = ceil_at_intervals(t->tabwidth[i], rulewidth);\n\tt->total_width += t->tabwidth[i];\n    }\n\n    t->total_width += table_border_width(t);\n\n    check_table_height(t);\n\n    for (i = 0; i <= t->maxcol; i++) {\n\tfor (j = 0; j <= t->maxrow; j++) {\n\t    TextLineList *l;\n\t    int k;\n\t    if ((t->tabattr[j][i] & HTT_Y) ||\n\t\t(t->tabattr[j][i] & HTT_TOP) || (t->tabdata[j][i] == NULL))\n\t\tcontinue;\n\t    h = t->tabheight[j];\n\t    for (k = j + 1; k <= t->maxrow; k++) {\n\t\tif (!(t->tabattr[k][i] & HTT_Y))\n\t\t    break;\n\t\th += t->tabheight[k];\n\t\tswitch (t->border_mode) {\n\t\tcase BORDER_THIN:\n\t\tcase BORDER_THICK:\n\t\tcase BORDER_NOWIN:\n\t\t    h += 1;\n\t\t    break;\n\t\t}\n\t    }\n\t    h -= t->tabdata[j][i]->nitem;\n\t    if (t->tabattr[j][i] & HTT_MIDDLE)\n\t\th /= 2;\n\t    if (h <= 0)\n\t\tcontinue;\n\t    l = newTextLineList();\n\t    for (k = 0; k < h; k++)\n\t\tpushTextLine(l, newTextLine(NULL, 0));\n\t    t->tabdata[j][i] = appendGeneralList((GeneralList *)l,\n\t\t\t\t\t\t t->tabdata[j][i]);\n\t}\n    }\n\n    /* table output */\n    width = t->total_width;\n\n    make_caption(t, h_env);\n\n    HTMLlineproc1(\"<pre for_table>\", h_env);\n#ifdef ID_EXT\n    if (t->id != NULL) {\n\tidtag = Sprintf(\"<_id id=\\\"%s\\\">\", html_quote((t->id)->ptr));\n\tHTMLlineproc1(idtag->ptr, h_env);\n    }\n#endif\t\t\t\t/* ID_EXT */\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\trenderbuf = Strnew();\n\tprint_sep(t, -1, T_TOP, t->maxcol, renderbuf);\n\tpush_render_image(renderbuf, width, t->total_width, h_env);\n\tt->total_height += 1;\n\tbreak;\n    }\n    vruleb = Strnew();\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\tvrulea = Strnew();\n\tvrulec = Strnew();\n\tpush_symbol(vrulea, TK_VERTICALBAR(t->border_mode), symbol_width, 1);\n\tfor (i = 0; i < t->cellpadding; i++) {\n\t    Strcat_char(vrulea, ' ');\n\t    Strcat_char(vruleb, ' ');\n\t    Strcat_char(vrulec, ' ');\n\t}\n\tpush_symbol(vrulec, TK_VERTICALBAR(t->border_mode), symbol_width, 1);\n    case BORDER_NOWIN:\n\tpush_symbol(vruleb, TK_VERTICALBAR(BORDER_THIN), symbol_width, 1);\n\tfor (i = 0; i < t->cellpadding; i++)\n\t    Strcat_char(vruleb, ' ');\n\tbreak;\n    case BORDER_NONE:\n\tfor (i = 0; i < t->cellspacing; i++)\n\t    Strcat_char(vruleb, ' ');\n    }\n\n    for (r = 0; r <= t->maxrow; r++) {\n\tfor (h = 0; h < t->tabheight[r]; h++) {\n\t    renderbuf = Strnew();\n\t    if (t->border_mode == BORDER_THIN\n\t\t|| t->border_mode == BORDER_THICK)\n\t\tStrcat(renderbuf, vrulea);\n#ifdef ID_EXT\n\t    if (t->tridvalue[r] != NULL && h == 0) {\n\t\tidtag = Sprintf(\"<_id id=\\\"%s\\\">\",\n\t\t\t\thtml_quote((t->tridvalue[r])->ptr));\n\t\tStrcat(renderbuf, idtag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    for (i = 0; i <= t->maxcol; i++) {\n\t\tcheck_row(t, r);\n#ifdef ID_EXT\n\t\tif (t->tabidvalue[r][i] != NULL && h == 0) {\n\t\t    idtag = Sprintf(\"<_id id=\\\"%s\\\">\",\n\t\t\t\t    html_quote((t->tabidvalue[r][i])->ptr));\n\t\t    Strcat(renderbuf, idtag);\n\t\t}\n#endif\t\t\t\t/* ID_EXT */\n\t\tif (!(t->tabattr[r][i] & HTT_X)) {\n\t\t    w = t->tabwidth[i];\n\t\t    for (j = i + 1;\n\t\t\t j <= t->maxcol && (t->tabattr[r][j] & HTT_X); j++)\n\t\t\tw += t->tabwidth[j] + t->cellspacing;\n\t\t    if (t->tabattr[r][i] & HTT_Y) {\n\t\t\tfor (j = r - 1; j >= 0 && t->tabattr[j]\n\t\t\t     && (t->tabattr[j][i] & HTT_Y); j--) ;\n\t\t\tprint_item(t, j, i, w, renderbuf);\n\t\t    }\n\t\t    else\n\t\t\tprint_item(t, r, i, w, renderbuf);\n\t\t}\n\t\tif (i < t->maxcol && !(t->tabattr[r][i + 1] & HTT_X))\n\t\t    Strcat(renderbuf, vruleb);\n\t    }\n\t    switch (t->border_mode) {\n\t    case BORDER_THIN:\n\t    case BORDER_THICK:\n\t\tStrcat(renderbuf, vrulec);\n\t\tt->total_height += 1;\n\t\tbreak;\n\t    }\n\t    push_render_image(renderbuf, width, t->total_width, h_env);\n\t}\n\tif (r < t->maxrow && t->border_mode != BORDER_NONE) {\n\t    renderbuf = Strnew();\n\t    print_sep(t, r, T_MIDDLE, t->maxcol, renderbuf);\n\t    push_render_image(renderbuf, width, t->total_width, h_env);\n\t}\n\tt->total_height += t->tabheight[r];\n    }\n    switch (t->border_mode) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n\trenderbuf = Strnew();\n\tprint_sep(t, t->maxrow, T_BOTTOM, t->maxcol, renderbuf);\n\tpush_render_image(renderbuf, width, t->total_width, h_env);\n\tt->total_height += 1;\n\tbreak;\n    }\n    if (t->total_height == 0) {\n       renderbuf = Strnew_charp(\" \");\n\tt->total_height++;\n\tt->total_width = 1;\n\tpush_render_image(renderbuf, 1, t->total_width, h_env);\n    }\n    HTMLlineproc1(\"</pre>\", h_env);\n}\n\n#ifdef TABLE_NO_COMPACT\n#define THR_PADDING 2\n#else\n#define THR_PADDING 4\n#endif\n\nstruct table *\nbegin_table(int border, int spacing, int padding, int vspace)\n{\n    struct table *t;\n    int mincell = minimum_cellspacing(border);\n    int rcellspacing;\n    int mincell_pixels = round(mincell * pixel_per_char);\n    int ppc = round(pixel_per_char);\n\n    t = newTable();\n    t->row = t->col = -1;\n    t->maxcol = -1;\n    t->maxrow = -1;\n    t->border_mode = border;\n    t->flag = 0;\n    if (border == BORDER_NOWIN)\n\tt->flag |= TBL_EXPAND_OK;\n\n    rcellspacing = spacing + 2 * padding;\n    switch (border) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\tt->cellpadding = padding - (mincell_pixels - 4) / 2;\n\tbreak;\n    case BORDER_NONE:\n\tt->cellpadding = rcellspacing - mincell_pixels;\n    }\n    if (t->cellpadding >= ppc)\n\tt->cellpadding /= ppc;\n    else if (t->cellpadding > 0)\n\tt->cellpadding = 1;\n    else\n\tt->cellpadding = 0;\n\n    switch (border) {\n    case BORDER_THIN:\n    case BORDER_THICK:\n    case BORDER_NOWIN:\n\tt->cellspacing = 2 * t->cellpadding + mincell;\n\tbreak;\n    case BORDER_NONE:\n\tt->cellspacing = t->cellpadding + mincell;\n    }\n\n    if (border == BORDER_NONE) {\n\tif (rcellspacing / 2 + vspace <= 1)\n\t    t->vspace = 0;\n\telse\n\t    t->vspace = 1;\n    }\n    else {\n\tif (vspace < ppc)\n\t    t->vspace = 0;\n\telse\n\t    t->vspace = 1;\n    }\n\n    if (border == BORDER_NONE) {\n\tif (rcellspacing <= THR_PADDING)\n\t    t->vcellpadding = 0;\n\telse\n\t    t->vcellpadding = 1;\n    }\n    else {\n\tif (padding < 2 * ppc - 2)\n\t    t->vcellpadding = 0;\n\telse\n\t    t->vcellpadding = 1;\n    }\n\n    return t;\n}\n\nvoid\nend_table(struct table *tbl)\n{\n    struct table_cell *cell = &tbl->cell;\n    int i, rulewidth = table_rule_width(tbl);\n    if (rulewidth > 1) {\n\tif (tbl->total_width > 0)\n\t    tbl->total_width = ceil_at_intervals(tbl->total_width, rulewidth);\n\tfor (i = 0; i <= tbl->maxcol; i++) {\n\t    tbl->minimum_width[i] =\n\t\tceil_at_intervals(tbl->minimum_width[i], rulewidth);\n\t    tbl->tabwidth[i] = ceil_at_intervals(tbl->tabwidth[i], rulewidth);\n\t    if (tbl->fixed_width[i] > 0)\n\t\ttbl->fixed_width[i] =\n\t\t    ceil_at_intervals(tbl->fixed_width[i], rulewidth);\n\t}\n\tfor (i = 0; i <= cell->maxcell; i++) {\n\t    cell->minimum_width[i] =\n\t\tceil_at_intervals(cell->minimum_width[i], rulewidth);\n\t    cell->width[i] = ceil_at_intervals(cell->width[i], rulewidth);\n\t    if (cell->fixed_width[i] > 0)\n\t\tcell->fixed_width[i] =\n\t\t    ceil_at_intervals(cell->fixed_width[i], rulewidth);\n\t}\n    }\n    tbl->sloppy_width = fixed_table_width(tbl);\n    if (tbl->total_width > tbl->sloppy_width)\n\ttbl->sloppy_width = tbl->total_width;\n}\n\nstatic void\ncheck_minimum0(struct table *t, int min)\n{\n    int i, w, ww;\n    struct table_cell *cell;\n\n    if (t->col < 0)\n\treturn;\n    if (t->tabwidth[t->col] < 0)\n\treturn;\n    check_row(t, t->row);\n    w = table_colspan(t, t->row, t->col);\n    min += t->indent;\n    if (w == 1)\n\tww = min;\n    else {\n\tcell = &t->cell;\n\tww = 0;\n\tif (cell->icell >= 0 && cell->minimum_width[cell->icell] < min)\n\t    cell->minimum_width[cell->icell] = min;\n    }\n    for (i = t->col;\n\t i <= t->maxcol && (i == t->col || (t->tabattr[t->row][i] & HTT_X));\n\t i++) {\n\tif (t->minimum_width[i] < ww)\n\t    t->minimum_width[i] = ww;\n    }\n}\n\nstatic int\nsetwidth0(struct table *t, struct table_mode *mode)\n{\n    int w;\n    int width = t->tabcontentssize;\n    struct table_cell *cell = &t->cell;\n\n    if (t->col < 0)\n\treturn -1;\n    if (t->tabwidth[t->col] < 0)\n\treturn -1;\n    check_row(t, t->row);\n    if (t->linfo.prev_spaces > 0)\n\twidth -= t->linfo.prev_spaces;\n    w = table_colspan(t, t->row, t->col);\n    if (w == 1) {\n\tif (t->tabwidth[t->col] < width)\n\t    t->tabwidth[t->col] = width;\n    }\n    else if (cell->icell >= 0) {\n\tif (cell->width[cell->icell] < width)\n\t    cell->width[cell->icell] = width;\n    }\n    return width;\n}\n\nstatic void\nsetwidth(struct table *t, struct table_mode *mode)\n{\n    int width = setwidth0(t, mode);\n    if (width < 0)\n\treturn;\n#ifdef NOWRAP\n    if (t->tabattr[t->row][t->col] & HTT_NOWRAP)\n\tcheck_minimum0(t, width);\n#endif\t\t\t\t/* NOWRAP */\n    if (mode->pre_mode & (TBLM_NOBR | TBLM_PRE | TBLM_PRE_INT) &&\n\tmode->nobr_offset >= 0)\n\tcheck_minimum0(t, width - mode->nobr_offset);\n}\n\nstatic void\naddcontentssize(struct table *t, int width)\n{\n\n    if (t->col < 0)\n\treturn;\n    if (t->tabwidth[t->col] < 0)\n\treturn;\n    check_row(t, t->row);\n    t->tabcontentssize += width;\n}\n\nstatic void table_close_anchor0(struct table *tbl, struct table_mode *mode);\n\nstatic void\nclearcontentssize(struct table *t, struct table_mode *mode)\n{\n    table_close_anchor0(t, mode);\n    mode->nobr_offset = 0;\n    t->linfo.prev_spaces = -1;\n    set_space_to_prevchar(t->linfo.prevchar);\n    t->linfo.prev_ctype = PC_ASCII;\n    t->linfo.length = 0;\n    t->tabcontentssize = 0;\n}\n\nstatic void\nbegin_cell(struct table *t, struct table_mode *mode)\n{\n    clearcontentssize(t, mode);\n    mode->indent_level = 0;\n    mode->nobr_level = 0;\n    mode->pre_mode = 0;\n    t->indent = 0;\n    t->flag |= TBL_IN_COL;\n\n    if (t->suspended_data) {\n\tcheck_row(t, t->row);\n\tif (t->tabdata[t->row][t->col] == NULL)\n\t    t->tabdata[t->row][t->col] = newGeneralList();\n\tappendGeneralList(t->tabdata[t->row][t->col],\n\t\t\t  (GeneralList *)t->suspended_data);\n\tt->suspended_data = NULL;\n    }\n}\n\nvoid\ncheck_rowcol(struct table *tbl, struct table_mode *mode)\n{\n    int row = tbl->row, col = tbl->col;\n\n    if (!(tbl->flag & TBL_IN_ROW)) {\n\ttbl->flag |= TBL_IN_ROW;\n\ttbl->row++;\n\tif (tbl->row > tbl->maxrow)\n\t    tbl->maxrow = tbl->row;\n\ttbl->col = -1;\n    }\n    if (tbl->row == -1)\n\ttbl->row = 0;\n    if (tbl->col == -1)\n\ttbl->col = 0;\n\n    for (;; tbl->row++) {\n\tcheck_row(tbl, tbl->row);\n\tfor (; tbl->col < MAXCOL &&\n\t     tbl->tabattr[tbl->row][tbl->col] & (HTT_X | HTT_Y); tbl->col++) ;\n\tif (tbl->col < MAXCOL)\n\t    break;\n\ttbl->col = 0;\n    }\n    if (tbl->row > tbl->maxrow)\n\ttbl->maxrow = tbl->row;\n    if (tbl->col > tbl->maxcol)\n\ttbl->maxcol = tbl->col;\n\n    if (tbl->row != row || tbl->col != col)\n\tbegin_cell(tbl, mode);\n    tbl->flag |= TBL_IN_COL;\n}\n\nint\nskip_space(struct table *t, char *line, struct table_linfo *linfo,\n\t   int checkminimum)\n{\n    int skip = 0, s = linfo->prev_spaces;\n    Lineprop ctype, prev_ctype = linfo->prev_ctype;\n    Str prevchar = linfo->prevchar;\n    int w = linfo->length;\n    int min = 1;\n\n    if (*line == '<' && line[strlen(line) - 1] == '>') {\n\tif (checkminimum)\n\t    check_minimum0(t, visible_length(line));\n\treturn 0;\n    }\n\n    while (*line) {\n\tchar *save = line, *c = line;\n\tint ec, len, wlen, plen;\n\tctype = get_mctype(line);\n\tlen = get_mcwidth(line);\n\twlen = plen = get_mclen(line);\n\n\tif (min < w)\n\t    min = w;\n\tif (ctype == PC_ASCII && IS_SPACE(*c)) {\n\t    w = 0;\n\t    s++;\n\t}\n\telse {\n\t    if (*c == '&') {\n\t\tec = getescapechar(&line);\n\t\tif (ec >= 0) {\n\t\t    c = conv_entity(ec);\n\t\t    ctype = get_mctype(c);\n\t\t    len = get_strwidth(c);\n\t\t    wlen = line - save;\n\t\t    plen = get_mclen(c);\n\t\t}\n\t    }\n\t    if (prevchar->length && is_boundary((unsigned char *)prevchar->ptr,\n\t\t\t\t\t\t(unsigned char *)c)) {\n\t\tw = len;\n\t    }\n\t    else {\n\t\tw += len;\n\t    }\n\t    if (s > 0) {\n#ifdef USE_M17N\n\t\tif (ctype == PC_KANJI1 && prev_ctype == PC_KANJI1)\n\t\t    skip += s;\n\t\telse\n#endif\n\t\t    skip += s - 1;\n\t    }\n\t    s = 0;\n\t    prev_ctype = ctype;\n\t}\n\tset_prevchar(prevchar, c, plen);\n\tline = save + wlen;\n    }\n    if (s > 1) {\n\tskip += s - 1;\n\tlinfo->prev_spaces = 1;\n    }\n    else {\n\tlinfo->prev_spaces = s;\n    }\n    linfo->prev_ctype = prev_ctype;\n    linfo->prevchar = prevchar;\n\n    if (checkminimum) {\n\tif (min < w)\n\t    min = w;\n\tlinfo->length = w;\n\tcheck_minimum0(t, min);\n    }\n    return skip;\n}\n\nstatic void\nfeed_table_inline_tag(struct table *tbl,\n\t\t      char *line, struct table_mode *mode, int width)\n{\n    check_rowcol(tbl, mode);\n    pushdata(tbl, tbl->row, tbl->col, line);\n    if (width >= 0) {\n\tcheck_minimum0(tbl, width);\n\taddcontentssize(tbl, width);\n\tsetwidth(tbl, mode);\n    }\n}\n\nstatic void\nfeed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}\n\nstatic void\ntable_close_select(struct table *tbl, struct table_mode *mode, int width)\n{\n    Str tmp = process_n_select();\n    mode->pre_mode &= ~TBLM_INSELECT;\n    mode->end_tag = 0;\n    feed_table1(tbl, tmp, mode, width);\n}\n\nstatic void\ntable_close_textarea(struct table *tbl, struct table_mode *mode, int width)\n{\n    Str tmp = process_n_textarea();\n    mode->pre_mode &= ~TBLM_INTXTA;\n    mode->end_tag = 0;\n    feed_table1(tbl, tmp, mode, width);\n}\n\nstatic void\ntable_close_anchor0(struct table *tbl, struct table_mode *mode)\n{\n    if (!(mode->pre_mode & TBLM_ANCHOR))\n\treturn;\n    mode->pre_mode &= ~TBLM_ANCHOR;\n    if (tbl->tabcontentssize == mode->anchor_offset) {\n\tcheck_minimum0(tbl, 1);\n\taddcontentssize(tbl, 1);\n\tsetwidth(tbl, mode);\n    }\n    else if (tbl->linfo.prev_spaces > 0 &&\n\t     tbl->tabcontentssize - 1 == mode->anchor_offset) {\n\tif (tbl->linfo.prev_spaces > 0)\n\t    tbl->linfo.prev_spaces = -1;\n    }\n}\n\n#define TAG_ACTION_NONE 0\n#define TAG_ACTION_FEED 1\n#define TAG_ACTION_TABLE 2\n#define TAG_ACTION_N_TABLE 3\n#define TAG_ACTION_PLAIN 4\n\n#define CASE_TABLE_TAG \\\n\tcase HTML_TABLE:\\\n\tcase HTML_N_TABLE:\\\n\tcase HTML_TR:\\\n\tcase HTML_N_TR:\\\n\tcase HTML_TD:\\\n\tcase HTML_N_TD:\\\n\tcase HTML_TH:\\\n\tcase HTML_N_TH:\\\n\tcase HTML_THEAD:\\\n\tcase HTML_N_THEAD:\\\n\tcase HTML_TBODY:\\\n\tcase HTML_N_TBODY:\\\n\tcase HTML_TFOOT:\\\n\tcase HTML_N_TFOOT:\\\n\tcase HTML_COLGROUP:\\\n\tcase HTML_N_COLGROUP:\\\n\tcase HTML_COL\n\n#define ATTR_ROWSPAN_MAX 32766\n\nstatic int\nfeed_table_tag(struct table *tbl, char *line, struct table_mode *mode,\n\t       int width, struct parsed_tag *tag)\n{\n    int cmd;\n#ifdef ID_EXT\n    char *p;\n#endif\n    struct table_cell *cell = &tbl->cell;\n    int colspan, rowspan;\n    int col, prev_col;\n    int i, j, k, v, v0, w, id;\n    Str tok, tmp, anchor;\n    table_attr align, valign;\n\n    cmd = tag->tagid;\n\n    if (mode->pre_mode & TBLM_PLAIN) {\n\tif (mode->end_tag == cmd) {\n\t    mode->pre_mode &= ~TBLM_PLAIN;\n\t    mode->end_tag = 0;\n\t    feed_table_block_tag(tbl, line, mode, 0, cmd);\n\t    return TAG_ACTION_NONE;\n\t}\n\treturn TAG_ACTION_PLAIN;\n    }\n    if (mode->pre_mode & TBLM_INTXTA) {\n\tswitch (cmd) {\n\tCASE_TABLE_TAG:\n\tcase HTML_N_TEXTAREA:\n\t    table_close_textarea(tbl, mode, width);\n\t    if (cmd == HTML_N_TEXTAREA)\n\t\treturn TAG_ACTION_NONE;\n\t    break;\n\tdefault:\n\t    return TAG_ACTION_FEED;\n\t}\n    }\n    if (mode->pre_mode & TBLM_SCRIPT) {\n\tif (mode->end_tag == cmd) {\n\t    mode->pre_mode &= ~TBLM_SCRIPT;\n\t    mode->end_tag = 0;\n\t    return TAG_ACTION_NONE;\n\t}\n\treturn TAG_ACTION_PLAIN;\n    }\n    if (mode->pre_mode & TBLM_STYLE) {\n\tif (mode->end_tag == cmd) {\n\t    mode->pre_mode &= ~TBLM_STYLE;\n\t    mode->end_tag = 0;\n\t    return TAG_ACTION_NONE;\n\t}\n\treturn TAG_ACTION_PLAIN;\n    }\n    /* failsafe: a tag other than <option></option>and </select> in *\n     * <select> environment is regarded as the end of <select>. */\n    if (mode->pre_mode & TBLM_INSELECT) {\n\tswitch (cmd) {\n\t  CASE_TABLE_TAG:\n\tcase HTML_N_FORM:\n\tcase HTML_N_SELECT:\t/* mode->end_tag */\n\t    table_close_select(tbl, mode, width);\n\t    if (cmd == HTML_N_SELECT)\n\t\treturn TAG_ACTION_NONE;\n\t    break;\n\tdefault:\n\t    return TAG_ACTION_FEED;\n\t}\n    }\n    if (mode->caption) {\n\tswitch (cmd) {\n\t  CASE_TABLE_TAG:\n\tcase HTML_N_CAPTION:\n\t    mode->caption = 0;\n\t    if (cmd == HTML_N_CAPTION)\n\t\treturn TAG_ACTION_NONE;\n\t    break;\n\tdefault:\n\t    return TAG_ACTION_FEED;\n\t}\n    }\n\n    if (mode->pre_mode & TBLM_PRE) {\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\tcase HTML_N_NOBR:\n\tcase HTML_PRE_INT:\n\tcase HTML_N_PRE_INT:\n\t    return TAG_ACTION_NONE;\n\t}\n    }\n\n    switch (cmd) {\n    case HTML_TABLE:\n\tcheck_rowcol(tbl, mode);\n\treturn TAG_ACTION_TABLE;\n    case HTML_N_TABLE:\n\tif (tbl->suspended_data)\n\t    check_rowcol(tbl, mode);\n\treturn TAG_ACTION_N_TABLE;\n    case HTML_TR:\n\tif (tbl->col >= 0 && tbl->tabcontentssize > 0)\n\t    setwidth(tbl, mode);\n\ttbl->col = -1;\n\ttbl->row++;\n\ttbl->flag |= TBL_IN_ROW;\n\ttbl->flag &= ~TBL_IN_COL;\n\talign = 0;\n\tvalign = 0;\n\tif (parsedtag_get_value(tag, ATTR_ALIGN, &i)) {\n\t    switch (i) {\n\t    case ALIGN_LEFT:\n\t\talign = (HTT_LEFT | HTT_TRSET);\n\t\tbreak;\n\t    case ALIGN_RIGHT:\n\t\talign = (HTT_RIGHT | HTT_TRSET);\n\t\tbreak;\n\t    case ALIGN_CENTER:\n\t\talign = (HTT_CENTER | HTT_TRSET);\n\t\tbreak;\n\t    }\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALIGN, &i)) {\n\t    switch (i) {\n\t    case VALIGN_TOP:\n\t\tvalign = (HTT_TOP | HTT_VTRSET);\n\t\tbreak;\n\t    case VALIGN_MIDDLE:\n\t\tvalign = (HTT_MIDDLE | HTT_VTRSET);\n\t\tbreak;\n\t    case VALIGN_BOTTOM:\n\t\tvalign = (HTT_BOTTOM | HTT_VTRSET);\n\t\tbreak;\n\t    }\n\t}\n#ifdef ID_EXT\n\tif (parsedtag_get_value(tag, ATTR_ID, &p)) {\n\t    check_row(tbl, tbl->row);\n\t    tbl->tridvalue[tbl->row] = Strnew_charp(p);\n\t}\n#endif\t\t\t\t/* ID_EXT */\n\ttbl->trattr = align | valign;\n\tbreak;\n    case HTML_TH:\n    case HTML_TD:\n\tprev_col = tbl->col;\n\tif (tbl->col >= 0 && tbl->tabcontentssize > 0)\n\t    setwidth(tbl, mode);\n\tif (tbl->row == -1) {\n\t    /* for broken HTML... */\n\t    tbl->row = -1;\n\t    tbl->col = -1;\n\t    tbl->maxrow = tbl->row;\n\t}\n\tif (tbl->col == -1) {\n\t    if (!(tbl->flag & TBL_IN_ROW)) {\n\t\ttbl->row++;\n\t\ttbl->flag |= TBL_IN_ROW;\n\t    }\n\t    if (tbl->row > tbl->maxrow)\n\t\ttbl->maxrow = tbl->row;\n\t}\n\ttbl->col++;\n\tcheck_row(tbl, tbl->row);\n\twhile (tbl->col < MAXCOL && tbl->tabattr[tbl->row][tbl->col]) {\n\t    tbl->col++;\n\t}\n\tif (tbl->col > MAXCOL - 1) {\n\t    tbl->col = prev_col;\n\t    return TAG_ACTION_NONE;\n\t}\n\tif (tbl->col > tbl->maxcol) {\n\t    tbl->maxcol = tbl->col;\n\t}\n\tcolspan = rowspan = 1;\n\tif (tbl->trattr & HTT_TRSET)\n\t    align = (tbl->trattr & HTT_ALIGN);\n\telse if (cmd == HTML_TH)\n\t    align = HTT_CENTER;\n\telse\n\t    align = HTT_LEFT;\n\tif (tbl->trattr & HTT_VTRSET)\n\t    valign = (tbl->trattr & HTT_VALIGN);\n\telse\n\t    valign = HTT_MIDDLE;\n\tif (parsedtag_get_value(tag, ATTR_ROWSPAN, &rowspan)) {\n\t    if(rowspan > ATTR_ROWSPAN_MAX) {\n\t\trowspan = ATTR_ROWSPAN_MAX;\n\t    }\n\t    if ((tbl->row + rowspan) >= tbl->max_rowsize)\n\t\tcheck_row(tbl, tbl->row + rowspan);\n\t}\n\tif (rowspan < 1)\n\t    rowspan = 1;\n\tif (parsedtag_get_value(tag, ATTR_COLSPAN, &colspan)) {\n\t    if ((tbl->col + colspan) >= MAXCOL) {\n\t\t/* Can't expand column */\n\t\tcolspan = MAXCOL - tbl->col;\n\t    }\n\t}\n\tif (colspan < 1)\n\t    colspan = 1;\n\tif (parsedtag_get_value(tag, ATTR_ALIGN, &i)) {\n\t    switch (i) {\n\t    case ALIGN_LEFT:\n\t\talign = HTT_LEFT;\n\t\tbreak;\n\t    case ALIGN_RIGHT:\n\t\talign = HTT_RIGHT;\n\t\tbreak;\n\t    case ALIGN_CENTER:\n\t\talign = HTT_CENTER;\n\t\tbreak;\n\t    }\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALIGN, &i)) {\n\t    switch (i) {\n\t    case VALIGN_TOP:\n\t\tvalign = HTT_TOP;\n\t\tbreak;\n\t    case VALIGN_MIDDLE:\n\t\tvalign = HTT_MIDDLE;\n\t\tbreak;\n\t    case VALIGN_BOTTOM:\n\t\tvalign = HTT_BOTTOM;\n\t\tbreak;\n\t    }\n\t}\n#ifdef NOWRAP\n\tif (parsedtag_exists(tag, ATTR_NOWRAP))\n\t    tbl->tabattr[tbl->row][tbl->col] |= HTT_NOWRAP;\n#endif\t\t\t\t/* NOWRAP */\n\tv = 0;\n\tif (parsedtag_get_value(tag, ATTR_WIDTH, &v)) {\n#ifdef TABLE_EXPAND\n\t    if (v > 0) {\n\t\tif (tbl->real_width > 0)\n\t\t    v = -(v * 100) / (tbl->real_width * pixel_per_char);\n\t\telse\n\t\t    v = (int)(v / pixel_per_char);\n\t    }\n#else\n\t    v = RELATIVE_WIDTH(v);\n#endif\t\t\t\t/* not TABLE_EXPAND */\n\t}\n#ifdef ID_EXT\n\tif (parsedtag_get_value(tag, ATTR_ID, &p))\n\t    tbl->tabidvalue[tbl->row][tbl->col] = Strnew_charp(p);\n#endif\t\t\t\t/* ID_EXT */\n#ifdef NOWRAP\n\tif (v != 0) {\n\t    /* NOWRAP and WIDTH= conflicts each other */\n\t    tbl->tabattr[tbl->row][tbl->col] &= ~HTT_NOWRAP;\n\t}\n#endif\t\t\t\t/* NOWRAP */\n\ttbl->tabattr[tbl->row][tbl->col] &= ~(HTT_ALIGN | HTT_VALIGN);\n\ttbl->tabattr[tbl->row][tbl->col] |= (align | valign);\n\tif (colspan > 1) {\n\t    col = tbl->col;\n\n\t    cell->icell = cell->maxcell + 1;\n\t    k = bsearch_2short(colspan, cell->colspan, col, cell->col, MAXCOL,\n\t\t\t       cell->index, cell->icell);\n\t    if (k <= cell->maxcell) {\n\t\ti = cell->index[k];\n\t\tif (cell->col[i] == col && cell->colspan[i] == colspan)\n\t\t    cell->icell = i;\n\t    }\n\t    if (cell->icell > cell->maxcell && cell->icell < MAXCELL) {\n\t\tcell->maxcell++;\n\t\tcell->col[cell->maxcell] = col;\n\t\tcell->colspan[cell->maxcell] = colspan;\n\t\tcell->width[cell->maxcell] = 0;\n\t\tcell->minimum_width[cell->maxcell] = 0;\n\t\tcell->fixed_width[cell->maxcell] = 0;\n\t\tif (cell->maxcell > k) {\n\t\t    int ii;\n\t\t    for (ii = cell->maxcell; ii > k; ii--)\n\t\t\tcell->index[ii] = cell->index[ii - 1];\n\t\t}\n\t\tcell->index[k] = cell->maxcell;\n\t    }\n\t    if (cell->icell > cell->maxcell)\n\t\tcell->icell = -1;\n\t}\n\tif (v != 0) {\n\t    if (colspan == 1) {\n\t\tv0 = tbl->fixed_width[tbl->col];\n\t\tif (v0 == 0 || (v0 > 0 && v > v0) || (v0 < 0 && v < v0)) {\n#ifdef FEED_TABLE_DEBUG\n\t\t    fprintf(stderr, \"width(%d) = %d\\n\", tbl->col, v);\n#endif\t\t\t\t/* TABLE_DEBUG */\n\t\t    tbl->fixed_width[tbl->col] = v;\n\t\t}\n\t    }\n\t    else if (cell->icell >= 0) {\n\t\tv0 = cell->fixed_width[cell->icell];\n\t\tif (v0 == 0 || (v0 > 0 && v > v0) || (v0 < 0 && v < v0))\n\t\t    cell->fixed_width[cell->icell] = v;\n\t    }\n\t}\n\tfor (i = 0; i < rowspan; i++) {\n\t    check_row(tbl, tbl->row + i);\n\t    for (j = 0; j < colspan; j++) {\n#if 0\n\t\ttbl->tabattr[tbl->row + i][tbl->col + j] &= ~(HTT_X | HTT_Y);\n#endif\n\t\tif (!(tbl->tabattr[tbl->row + i][tbl->col + j] &\n\t\t      (HTT_X | HTT_Y))) {\n\t\t    tbl->tabattr[tbl->row + i][tbl->col + j] |=\n\t\t\t((i > 0) ? HTT_Y : 0) | ((j > 0) ? HTT_X : 0);\n\t\t}\n\t\tif (tbl->col + j > tbl->maxcol) {\n\t\t    tbl->maxcol = tbl->col + j;\n\t\t}\n\t    }\n\t    if (tbl->row + i > tbl->maxrow) {\n\t\ttbl->maxrow = tbl->row + i;\n\t    }\n\t}\n\tbegin_cell(tbl, mode);\n\tbreak;\n    case HTML_N_TR:\n\tsetwidth(tbl, mode);\n\ttbl->col = -1;\n\ttbl->flag &= ~(TBL_IN_ROW | TBL_IN_COL);\n\treturn TAG_ACTION_NONE;\n    case HTML_N_TH:\n    case HTML_N_TD:\n\tsetwidth(tbl, mode);\n\ttbl->flag &= ~TBL_IN_COL;\n#ifdef FEED_TABLE_DEBUG\n\t{\n\t    TextListItem *it;\n\t    int i = tbl->col, j = tbl->row;\n\t    fprintf(stderr, \"(a) row,col: %d, %d\\n\", j, i);\n\t    if (tbl->tabdata[j] && tbl->tabdata[j][i]) {\n\t\tfor (it = ((TextList *)tbl->tabdata[j][i])->first;\n\t\t     it; it = it->next)\n\t\t    fprintf(stderr, \"  [%s] \\n\", it->ptr);\n\t    }\n\t}\n#endif\n\treturn TAG_ACTION_NONE;\n    case HTML_P:\n    case HTML_BR:\n    case HTML_CENTER:\n    case HTML_N_CENTER:\n    case HTML_DIV:\n    case HTML_N_DIV:\n\tif (!(tbl->flag & TBL_IN_ROW))\n\t    break;\n    case HTML_DT:\n    case HTML_DD:\n    case HTML_H:\n    case HTML_N_H:\n    case HTML_LI:\n    case HTML_PRE:\n    case HTML_N_PRE:\n    case HTML_HR:\n    case HTML_LISTING:\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n    case HTML_PRE_PLAIN:\n    case HTML_N_PRE_PLAIN:\n\tfeed_table_block_tag(tbl, line, mode, 0, cmd);\n\tswitch (cmd) {\n\tcase HTML_PRE:\n\tcase HTML_PRE_PLAIN:\n\t    mode->pre_mode |= TBLM_PRE;\n\t    break;\n\tcase HTML_N_PRE:\n\tcase HTML_N_PRE_PLAIN:\n\t    mode->pre_mode &= ~TBLM_PRE;\n\t    break;\n\tcase HTML_LISTING:\n\t    mode->pre_mode |= TBLM_PLAIN;\n\t    mode->end_tag = HTML_N_LISTING;\n\t    break;\n\tcase HTML_XMP:\n\t    mode->pre_mode |= TBLM_PLAIN;\n\t    mode->end_tag = HTML_N_XMP;\n\t    break;\n\tcase HTML_PLAINTEXT:\n\t    mode->pre_mode |= TBLM_PLAIN;\n\t    mode->end_tag = MAX_HTMLTAG;\n\t    break;\n\t}\n\tbreak;\n    case HTML_DL:\n    case HTML_BLQ:\n    case HTML_OL:\n    case HTML_UL:\n\tfeed_table_block_tag(tbl, line, mode, 1, cmd);\n\tbreak;\n    case HTML_N_DL:\n    case HTML_N_BLQ:\n    case HTML_N_OL:\n    case HTML_N_UL:\n\tfeed_table_block_tag(tbl, line, mode, -1, cmd);\n\tbreak;\n    case HTML_NOBR:\n    case HTML_WBR:\n\tif (!(tbl->flag & TBL_IN_ROW))\n\t    break;\n    case HTML_PRE_INT:\n\tfeed_table_inline_tag(tbl, line, mode, -1);\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\t    mode->nobr_level++;\n\t    if (mode->pre_mode & TBLM_NOBR)\n\t\treturn TAG_ACTION_NONE;\n\t    mode->pre_mode |= TBLM_NOBR;\n\t    break;\n\tcase HTML_PRE_INT:\n\t    if (mode->pre_mode & TBLM_PRE_INT)\n\t\treturn TAG_ACTION_NONE;\n\t    mode->pre_mode |= TBLM_PRE_INT;\n\t    tbl->linfo.prev_spaces = 0;\n\t    break;\n\t}\n\tmode->nobr_offset = -1;\n\tif (tbl->linfo.length > 0) {\n\t    check_minimum0(tbl, tbl->linfo.length);\n\t    tbl->linfo.length = 0;\n\t}\n\tbreak;\n    case HTML_N_NOBR:\n\tif (!(tbl->flag & TBL_IN_ROW))\n\t    break;\n\tfeed_table_inline_tag(tbl, line, mode, -1);\n\tif (mode->nobr_level > 0)\n\t    mode->nobr_level--;\n\tif (mode->nobr_level == 0)\n\t    mode->pre_mode &= ~TBLM_NOBR;\n\tbreak;\n    case HTML_N_PRE_INT:\n\tfeed_table_inline_tag(tbl, line, mode, -1);\n\tmode->pre_mode &= ~TBLM_PRE_INT;\n\tbreak;\n    case HTML_IMG:\n\tcheck_rowcol(tbl, mode);\n\tw = tbl->fixed_width[tbl->col];\n\tif (w < 0) {\n\t    if (tbl->total_width > 0)\n\t\tw = -tbl->total_width * w / 100;\n\t    else if (width > 0)\n\t\tw = -width * w / 100;\n\t    else\n\t\tw = 0;\n\t}\n\telse if (w == 0) {\n\t    if (tbl->total_width > 0)\n\t\tw = tbl->total_width;\n\t    else if (width > 0)\n\t\tw = width;\n\t}\n\ttok = process_img(tag, w);\n\tfeed_table1(tbl, tok, mode, width);\n\tbreak;\n    case HTML_FORM:\n\tfeed_table_block_tag(tbl, \"\", mode, 0, cmd);\n\ttmp = process_form(tag);\n\tif (tmp)\n\t    feed_table1(tbl, tmp, mode, width);\n\tbreak;\n    case HTML_N_FORM:\n\tfeed_table_block_tag(tbl, \"\", mode, 0, cmd);\n\tprocess_n_form();\n\tbreak;\n    case HTML_INPUT:\n\ttmp = process_input(tag);\n\tfeed_table1(tbl, tmp, mode, width);\n\tbreak;\n    case HTML_BUTTON:\n       tmp = process_button(tag);\n       feed_table1(tbl, tmp, mode, width);\n       break;\n    case HTML_N_BUTTON:\n       tmp = process_n_button();\n       feed_table1(tbl, tmp, mode, width);\n       break;\n    case HTML_SELECT:\n\ttmp = process_select(tag);\n\tif (tmp)\n\t    feed_table1(tbl, tmp, mode, width);\n\tmode->pre_mode |= TBLM_INSELECT;\n\tmode->end_tag = HTML_N_SELECT;\n\tbreak;\n    case HTML_N_SELECT:\n    case HTML_OPTION:\n\t/* nothing */\n\tbreak;\n    case HTML_TEXTAREA:\n\tw = 0;\n\tcheck_rowcol(tbl, mode);\n\tif (tbl->col + 1 <= tbl->maxcol &&\n\t    tbl->tabattr[tbl->row][tbl->col + 1] & HTT_X) {\n\t    if (cell->icell >= 0 && cell->fixed_width[cell->icell] > 0)\n\t\tw = cell->fixed_width[cell->icell];\n\t}\n\telse {\n\t    if (tbl->fixed_width[tbl->col] > 0)\n\t\tw = tbl->fixed_width[tbl->col];\n\t}\n\ttmp = process_textarea(tag, w);\n\tif (tmp)\n\t    feed_table1(tbl, tmp, mode, width);\n\tmode->pre_mode |= TBLM_INTXTA;\n\tmode->end_tag = HTML_N_TEXTAREA;\n\tbreak;\n    case HTML_A:\n\ttable_close_anchor0(tbl, mode);\n\tanchor = NULL;\n\ti = 0;\n\tparsedtag_get_value(tag, ATTR_HREF, &anchor);\n\tparsedtag_get_value(tag, ATTR_HSEQ, &i);\n\tif (anchor) {\n\t    check_rowcol(tbl, mode);\n\t    if (i == 0) {\n\t\tStr tmp = process_anchor(tag, line);\n    \t\tif (displayLinkNumber)\n\t\t{\n\t\t\tStr t = getLinkNumberStr(-1);\n\t\t\tfeed_table_inline_tag(tbl, NULL, mode, t->length);\n\t\t\tStrcat(tmp, t);\n\t\t}\n\t\tpushdata(tbl, tbl->row, tbl->col, tmp->ptr);\n\t    }\n\t    else\n\t\tpushdata(tbl, tbl->row, tbl->col, line);\n\t    if (i >= 0) {\n\t\tmode->pre_mode |= TBLM_ANCHOR;\n\t\tmode->anchor_offset = tbl->tabcontentssize;\n\t    }\n\t}\n\telse\n\t    suspend_or_pushdata(tbl, line);\n\tbreak;\n    case HTML_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode |= TBLM_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 5);\t/* [DEL: */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_N_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode &= ~TBLM_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 5);\t/* :DEL] */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode |= TBLM_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 3);\t/* [S: */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_N_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    mode->pre_mode &= ~TBLM_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 3);\t/* :S] */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_INS:\n    case HTML_N_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    feed_table_inline_tag(tbl, line, mode, 5);\t/* [INS:, :INS] */\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    feed_table_inline_tag(tbl, line, mode, -1);\n\t    break;\n\t}\n\tbreak;\n    case HTML_SUP:\n    case HTML_SUB:\n    case HTML_N_SUB:\n\tif (!(mode->pre_mode & (TBLM_DEL | TBLM_S)))\n\t    feed_table_inline_tag(tbl, line, mode, 1);\t/* ^, [, ] */\n\tbreak;\n    case HTML_N_SUP:\n\tbreak;\n    case HTML_TABLE_ALT:\n\tid = -1;\n\tparsedtag_get_value(tag, ATTR_TID, &id);\n\tif (id >= 0 && id < tbl->ntable) {\n\t    struct table *tbl1 = tbl->tables[id].ptr;\n\t    feed_table_block_tag(tbl, line, mode, 0, cmd);\n\t    addcontentssize(tbl, maximum_table_width(tbl1));\n\t    check_minimum0(tbl, tbl1->sloppy_width);\n#ifdef TABLE_EXPAND\n\t    w = tbl1->total_width;\n\t    v = 0;\n\t    colspan = table_colspan(tbl, tbl->row, tbl->col);\n\t    if (colspan > 1) {\n\t\tif (cell->icell >= 0)\n\t\t    v = cell->fixed_width[cell->icell];\n\t    }\n\t    else\n\t\tv = tbl->fixed_width[tbl->col];\n\t    if (v < 0 && tbl->real_width > 0 && tbl1->real_width > 0)\n\t\tw = -(tbl1->real_width * 100) / tbl->real_width;\n\t    else\n\t\tw = tbl1->real_width;\n\t    if (w > 0)\n\t\tcheck_minimum0(tbl, w);\n\t    else if (w < 0 && v < w) {\n\t\tif (colspan > 1) {\n\t\t    if (cell->icell >= 0)\n\t\t\tcell->fixed_width[cell->icell] = w;\n\t\t}\n\t\telse\n\t\t    tbl->fixed_width[tbl->col] = w;\n\t    }\n#endif\n\t    setwidth0(tbl, mode);\n\t    clearcontentssize(tbl, mode);\n\t}\n\tbreak;\n    case HTML_CAPTION:\n\tmode->caption = 1;\n\tbreak;\n    case HTML_N_CAPTION:\n    case HTML_THEAD:\n    case HTML_N_THEAD:\n    case HTML_TBODY:\n    case HTML_N_TBODY:\n    case HTML_TFOOT:\n    case HTML_N_TFOOT:\n    case HTML_COLGROUP:\n    case HTML_N_COLGROUP:\n    case HTML_COL:\n\tbreak;\n    case HTML_SCRIPT:\n\tmode->pre_mode |= TBLM_SCRIPT;\n\tmode->end_tag = HTML_N_SCRIPT;\n\tbreak;\n    case HTML_STYLE:\n\tmode->pre_mode |= TBLM_STYLE;\n\tmode->end_tag = HTML_N_STYLE;\n\tbreak;\n    case HTML_N_A:\n\ttable_close_anchor0(tbl, mode);\n    case HTML_FONT:\n    case HTML_N_FONT:\n    case HTML_NOP:\n\tsuspend_or_pushdata(tbl, line);\n\tbreak;\n    case HTML_INTERNAL:\n    case HTML_N_INTERNAL:\n    case HTML_FORM_INT:\n    case HTML_N_FORM_INT:\n    case HTML_INPUT_ALT:\n    case HTML_N_INPUT_ALT:\n    case HTML_SELECT_INT:\n    case HTML_N_SELECT_INT:\n    case HTML_OPTION_INT:\n    case HTML_TEXTAREA_INT:\n    case HTML_N_TEXTAREA_INT:\n    case HTML_IMG_ALT:\n    case HTML_SYMBOL:\n    case HTML_N_SYMBOL:\n    default:\n\t/* unknown tag: put into table */\n\treturn TAG_ACTION_FEED;\n    }\n    return TAG_ACTION_NONE;\n}\n\n\nint\nfeed_table(struct table *tbl, char *line, struct table_mode *mode,\n\t   int width, int internal)\n{\n    int i;\n    char *p;\n    Str tmp;\n    struct table_linfo *linfo = &tbl->linfo;\n\n    if (*line == '<' && line[1] && REALLY_THE_BEGINNING_OF_A_TAG(line)) {\n\tstruct parsed_tag *tag;\n\tp = line;\n\ttag = parse_tag(&p, internal);\n\tif (tag) {\n\t    switch (feed_table_tag(tbl, line, mode, width, tag)) {\n\t    case TAG_ACTION_NONE:\n\t\treturn -1;\n\t    case TAG_ACTION_N_TABLE:\n\t\treturn 0;\n\t    case TAG_ACTION_TABLE:\n\t\treturn 1;\n\t    case TAG_ACTION_PLAIN:\n\t\tbreak;\n\t    case TAG_ACTION_FEED:\n\t    default:\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    line = parsedtag2str(tag)->ptr;\n\t    }\n\t}\n\telse {\n\t    if (!(mode->pre_mode & (TBLM_PLAIN | TBLM_INTXTA | TBLM_INSELECT |\n\t\t\t\t    TBLM_SCRIPT | TBLM_STYLE)))\n\t\treturn -1;\n\t}\n    }\n    else {\n\tif (mode->pre_mode & (TBLM_DEL | TBLM_S))\n\t    return -1;\n    }\n    if (mode->caption) {\n\tStrcat_charp(tbl->caption, line);\n\treturn -1;\n    }\n    if (mode->pre_mode & TBLM_SCRIPT)\n\treturn -1;\n    if (mode->pre_mode & TBLM_STYLE)\n\treturn -1;\n    if (mode->pre_mode & TBLM_INTXTA) {\n\tfeed_textarea(line);\n\treturn -1;\n    }\n    if (mode->pre_mode & TBLM_INSELECT) {\n\tfeed_select(line);\n\treturn -1;\n    }\n    if (!(mode->pre_mode & TBLM_PLAIN) &&\n\t!(*line == '<' && line[strlen(line) - 1] == '>') &&\n\tstrchr(line, '&') != NULL) {\n\ttmp = Strnew();\n\tfor (p = line; *p;) {\n\t    char *q, *r;\n\t    if (*p == '&') {\n\t\tif (!strncasecmp(p, \"&amp;\", 5) ||\n\t\t    !strncasecmp(p, \"&gt;\", 4) || !strncasecmp(p, \"&lt;\", 4)) {\n\t\t    /* do not convert */\n\t\t    Strcat_char(tmp, *p);\n\t\t    p++;\n\t\t}\n\t\telse {\n\t\t    int ec;\n\t\t    q = p;\n\t\t    switch (ec = getescapechar(&p)) {\n\t\t    case '<':\n\t\t\tStrcat_charp(tmp, \"&lt;\");\n\t\t\tbreak;\n\t\t    case '>':\n\t\t\tStrcat_charp(tmp, \"&gt;\");\n\t\t\tbreak;\n\t\t    case '&':\n\t\t\tStrcat_charp(tmp, \"&amp;\");\n\t\t\tbreak;\n\t\t    case '\\r':\n\t\t\tStrcat_char(tmp, '\\n');\n\t\t\tbreak;\n\t\t    default:\n\t\t\tr = conv_entity(ec);\n\t\t\tif (r != NULL && strlen(r) == 1 &&\n\t\t\t    ec == (unsigned char)*r) {\n\t\t\t    Strcat_char(tmp, *r);\n\t\t\t    break;\n\t\t\t}\n\t\t    case -1:\n\t\t\tStrcat_char(tmp, *q);\n\t\t\tp = q + 1;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\tStrcat_char(tmp, *p);\n\t\tp++;\n\t    }\n\t}\n\tline = tmp->ptr;\n    }\n    if (!(mode->pre_mode & (TBLM_SPECIAL & ~TBLM_NOBR))) {\n\tif (!(tbl->flag & TBL_IN_COL) || linfo->prev_spaces != 0)\n\t    while (IS_SPACE(*line))\n\t\tline++;\n\tif (*line == '\\0')\n\t    return -1;\n\tcheck_rowcol(tbl, mode);\n\tif (mode->pre_mode & TBLM_NOBR && mode->nobr_offset < 0)\n\t    mode->nobr_offset = tbl->tabcontentssize;\n\n\t/* count of number of spaces skipped in normal mode */\n\ti = skip_space(tbl, line, linfo, !(mode->pre_mode & TBLM_NOBR));\n\taddcontentssize(tbl, visible_length(line) - i);\n\tsetwidth(tbl, mode);\n\tpushdata(tbl, tbl->row, tbl->col, line);\n    }\n    else if (mode->pre_mode & TBLM_PRE_INT) {\n\tcheck_rowcol(tbl, mode);\n\tif (mode->nobr_offset < 0)\n\t    mode->nobr_offset = tbl->tabcontentssize;\n\taddcontentssize(tbl, maximum_visible_length(line, tbl->tabcontentssize));\n\tsetwidth(tbl, mode);\n\tpushdata(tbl, tbl->row, tbl->col, line);\n    }\n    else {\n\t/* <pre> mode or something like it */\n\tcheck_rowcol(tbl, mode);\n\twhile (*line) {\n\t    int nl = FALSE;\n\t    if ((p = strchr(line, '\\r')) || (p = strchr(line, '\\n'))) {\n\t\tif (*p == '\\r' && p[1] == '\\n')\n\t\t    p++;\n\t\tif (p[1]) {\n\t\t    p++;\n\t\t    tmp = Strnew_charp_n(line, p - line);\n\t\t    line = p;\n\t\t    p = tmp->ptr;\n\t\t}\n\t\telse {\n\t\t    p = line;\n\t\t    line = \"\";\n\t\t}\n\t\tnl = TRUE;\n\t    }\n\t    else {\n\t\tp = line;\n\t\tline = \"\";\n\t    }\n\t    if (mode->pre_mode & TBLM_PLAIN)\n\t\ti = maximum_visible_length_plain(p, tbl->tabcontentssize);\n\t    else\n\t\ti = maximum_visible_length(p, tbl->tabcontentssize);\n\t    addcontentssize(tbl, i);\n\t    setwidth(tbl, mode);\n\t    if (nl)\n\t\tclearcontentssize(tbl, mode);\n\t    pushdata(tbl, tbl->row, tbl->col, p);\n\t}\n    }\n    return -1;\n}\n\nvoid\nfeed_table1(struct table *tbl, Str tok, struct table_mode *mode, int width)\n{\n    Str tokbuf;\n    int status;\n    char *line;\n    if (!tok)\n\treturn;\n    tokbuf = Strnew();\n    status = R_ST_NORMAL;\n    line = tok->ptr;\n    while (read_token\n\t   (tokbuf, &line, &status, mode->pre_mode & TBLM_PREMODE, 0))\n\tfeed_table(tbl, tokbuf->ptr, mode, width, TRUE);\n}\n\nvoid\npushTable(struct table *tbl, struct table *tbl1)\n{\n    int col;\n    int row;\n\n    col = tbl->col;\n    row = tbl->row;\n\n    if (tbl->ntable >= tbl->tables_size) {\n\tstruct table_in *tmp;\n\ttbl->tables_size += MAX_TABLE_N;\n\ttmp = New_N(struct table_in, tbl->tables_size);\n\tif (tbl->tables)\n\t    bcopy(tbl->tables, tmp, tbl->ntable * sizeof(struct table_in));\n\ttbl->tables = tmp;\n    }\n\n    tbl->tables[tbl->ntable].ptr = tbl1;\n    tbl->tables[tbl->ntable].col = col;\n    tbl->tables[tbl->ntable].row = row;\n    tbl->tables[tbl->ntable].indent = tbl->indent;\n    tbl->tables[tbl->ntable].buf = newTextLineList();\n    check_row(tbl, row);\n    if (col + 1 <= tbl->maxcol && tbl->tabattr[row][col + 1] & HTT_X)\n\ttbl->tables[tbl->ntable].cell = tbl->cell.icell;\n    else\n\ttbl->tables[tbl->ntable].cell = -1;\n    tbl->ntable++;\n}\n\n#ifdef MATRIX\nint\ncorrect_table_matrix(struct table *t, int col, int cspan, int a, double b)\n{\n    int i, j;\n    int ecol = col + cspan;\n    double w = 1. / (b * b);\n\n    for (i = col; i < ecol; i++) {\n\tv_add_val(t->vector, i, w * a);\n\tfor (j = i; j < ecol; j++) {\n\t    m_add_val(t->matrix, i, j, w);\n\t    m_set_val(t->matrix, j, i, m_entry(t->matrix, i, j));\n\t}\n    }\n    return i;\n}\n\nstatic void\ncorrect_table_matrix2(struct table *t, int col, int cspan, double s, double b)\n{\n    int i, j;\n    int ecol = col + cspan;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n    double ss;\n\n    for (i = 0; i < size; i++) {\n\tfor (j = i; j < size; j++) {\n\t    if (i >= col && i < ecol && j >= col && j < ecol)\n\t\tss = (1. - s) * (1. - s);\n\t    else if ((i >= col && i < ecol) || (j >= col && j < ecol))\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n\nstatic void\ncorrect_table_matrix3(struct table *t, int col, char *flags, double s,\n\t\t      double b)\n{\n    int i, j;\n    double ss;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n    int flg = (flags[col] == 0);\n\n    for (i = 0; i < size; i++) {\n\tif (!((flg && flags[i] == 0) || (!flg && flags[i] != 0)))\n\t    continue;\n\tfor (j = i; j < size; j++) {\n\t    if (!((flg && flags[j] == 0) || (!flg && flags[j] != 0)))\n\t\tcontinue;\n\t    if (i == col && j == col)\n\t\tss = (1. - s) * (1. - s);\n\t    else if (i == col || j == col)\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n\nstatic void\ncorrect_table_matrix4(struct table *t, int col, int cspan, char *flags,\n\t\t      double s, double b)\n{\n    int i, j;\n    double ss;\n    int ecol = col + cspan;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n\n    for (i = 0; i < size; i++) {\n\tif (flags[i] && !(i >= col && i < ecol))\n\t    continue;\n\tfor (j = i; j < size; j++) {\n\t    if (flags[j] && !(j >= col && j < ecol))\n\t\tcontinue;\n\t    if (i >= col && i < ecol && j >= col && j < ecol)\n\t\tss = (1. - s) * (1. - s);\n\t    else if ((i >= col && i < ecol) || (j >= col && j < ecol))\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n\nstatic void\nset_table_matrix0(struct table *t, int maxwidth)\n{\n    int size = t->maxcol + 1;\n    int i, j, k, bcol, ecol;\n    int width;\n    double w0, w1, w, s, b;\n#ifdef __GNUC__\n    double we[size];\n    char expand[size];\n#else\t\t\t\t/* not __GNUC__ */\n    double we[MAXCOL];\n    char expand[MAXCOL];\n#endif\t\t\t\t/* not __GNUC__ */\n    struct table_cell *cell = &t->cell;\n\n    w0 = 0.;\n    for (i = 0; i < size; i++) {\n\twe[i] = weight(t->tabwidth[i]);\n\tw0 += we[i];\n    }\n    if (w0 <= 0.)\n\tw0 = 1.;\n\n    if (cell->necell == 0) {\n\tfor (i = 0; i < size; i++) {\n\t    s = we[i] / w0;\n\t    b = sigma_td_nw((int)(s * maxwidth));\n\t    correct_table_matrix2(t, i, 1, s, b);\n\t}\n\treturn;\n    }\n\n    bzero(expand, size);\n\n    for (k = 0; k < cell->necell; k++) {\n\tj = cell->eindex[k];\n\tbcol = cell->col[j];\n\tecol = bcol + cell->colspan[j];\n\twidth = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tw1 = 0.;\n\tfor (i = bcol; i < ecol; i++) {\n\t    w1 += t->tabwidth[i] + 0.1;\n\t    expand[i]++;\n\t}\n\tfor (i = bcol; i < ecol; i++) {\n\t    w = weight(width * (t->tabwidth[i] + 0.1) / w1);\n\t    if (w > we[i])\n\t\twe[i] = w;\n\t}\n    }\n\n    w0 = 0.;\n    w1 = 0.;\n    for (i = 0; i < size; i++) {\n\tw0 += we[i];\n\tif (expand[i] == 0)\n\t    w1 += we[i];\n    }\n    if (w0 <= 0.)\n\tw0 = 1.;\n\n    for (k = 0; k < cell->necell; k++) {\n\tj = cell->eindex[k];\n\tbcol = cell->col[j];\n\twidth = cell->width[j] - (cell->colspan[j] - 1) * t->cellspacing;\n\tw = weight(width);\n\ts = w / (w1 + w);\n\tb = sigma_td_nw((int)(s * maxwidth));\n\tcorrect_table_matrix4(t, bcol, cell->colspan[j], expand, s, b);\n    }\n\n    for (i = 0; i < size; i++) {\n\tif (expand[i] == 0) {\n\t    s = we[i] / max(w1, 1.);\n\t    b = sigma_td_nw((int)(s * maxwidth));\n\t}\n\telse {\n\t    s = we[i] / max(w0 - w1, 1.);\n\t    b = sigma_td_nw(maxwidth);\n\t}\n\tcorrect_table_matrix3(t, i, expand, s, b);\n    }\n}\n\nvoid\ncheck_relative_width(struct table *t, int maxwidth)\n{\n    int i;\n    double rel_total = 0;\n    int size = t->maxcol + 1;\n    double *rcolwidth = New_N(double, size);\n    struct table_cell *cell = &t->cell;\n    int n_leftcol = 0;\n\n    for (i = 0; i < size; i++)\n\trcolwidth[i] = 0;\n\n    for (i = 0; i < size; i++) {\n\tif (t->fixed_width[i] < 0)\n\t    rcolwidth[i] = -(double)t->fixed_width[i] / 100.0;\n\telse if (t->fixed_width[i] > 0)\n\t    rcolwidth[i] = (double)t->fixed_width[i] / maxwidth;\n\telse\n\t    n_leftcol++;\n    }\n    for (i = 0; i <= cell->maxcell; i++) {\n\tif (cell->fixed_width[i] < 0) {\n\t    double w = -(double)cell->fixed_width[i] / 100.0;\n\t    double r;\n\t    int j, k;\n\t    int n_leftcell = 0;\n\t    k = cell->col[i];\n\t    r = 0.0;\n\t    for (j = 0; j < cell->colspan[i]; j++) {\n\t\tif (rcolwidth[j + k] > 0)\n\t\t    r += rcolwidth[j + k];\n\t\telse\n\t\t    n_leftcell++;\n\t    }\n\t    if (n_leftcell == 0) {\n\t\t/* w must be identical to r */\n\t\tif (w != r)\n\t\t    cell->fixed_width[i] = -100 * r;\n\t    }\n\t    else {\n\t\tif (w <= r) {\n\t\t    /* make room for the left(width-unspecified) cell */\n\t\t    /* the next formula is an estimation of required width */\n\t\t    w = r * cell->colspan[i] / (cell->colspan[i] - n_leftcell);\n\t\t    cell->fixed_width[i] = -100 * w;\n\t\t}\n\t\tfor (j = 0; j < cell->colspan[i]; j++) {\n\t\t    if (rcolwidth[j + k] == 0)\n\t\t\trcolwidth[j + k] = (w - r) / n_leftcell;\n\t\t}\n\t    }\n\t}\n\telse if (cell->fixed_width[i] > 0) {\n\t    /* todo */\n\t}\n    }\n    /* sanity check */\n    for (i = 0; i < size; i++)\n\trel_total += rcolwidth[i];\n\n    if ((n_leftcol == 0 && rel_total < 0.9) || 1.1 < rel_total) {\n\tfor (i = 0; i < size; i++) {\n\t    rcolwidth[i] /= rel_total;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t    if (t->fixed_width[i] < 0)\n\t\tt->fixed_width[i] = -rcolwidth[i] * 100;\n\t}\n\tfor (i = 0; i <= cell->maxcell; i++) {\n\t    if (cell->fixed_width[i] < 0) {\n\t\tdouble r;\n\t\tint j, k;\n\t\tk = cell->col[i];\n\t\tr = 0.0;\n\t\tfor (j = 0; j < cell->colspan[i]; j++)\n\t\t    r += rcolwidth[j + k];\n\t\tcell->fixed_width[i] = -r * 100;\n\t    }\n\t}\n    }\n}\n\nvoid\nset_table_matrix(struct table *t, int width)\n{\n    int size = t->maxcol + 1;\n    int i, j;\n    double b, s;\n    int a;\n    struct table_cell *cell = &t->cell;\n\n    if (size < 1)\n\treturn;\n\n    t->matrix = m_get(size, size);\n    t->vector = v_get(size);\n    for (i = 0; i < size; i++) {\n\tfor (j = i; j < size; j++)\n\t    m_set_val(t->matrix, i, j, 0.);\n\tv_set_val(t->vector, i, 0.);\n    }\n\n    check_relative_width(t, width);\n\n    for (i = 0; i < size; i++) {\n\tif (t->fixed_width[i] > 0) {\n\t    a = max(t->fixed_width[i], t->minimum_width[i]);\n\t    b = sigma_td(a);\n\t    correct_table_matrix(t, i, 1, a, b);\n\t}\n\telse if (t->fixed_width[i] < 0) {\n\t    s = -(double)t->fixed_width[i] / 100.;\n\t    b = sigma_td((int)(s * width));\n\t    correct_table_matrix2(t, i, 1, s, b);\n\t}\n    }\n\n    for (j = 0; j <= cell->maxcell; j++) {\n\tif (cell->fixed_width[j] > 0) {\n\t    a = max(cell->fixed_width[j], cell->minimum_width[j]);\n\t    b = sigma_td(a);\n\t    correct_table_matrix(t, cell->col[j], cell->colspan[j], a, b);\n\t}\n\telse if (cell->fixed_width[j] < 0) {\n\t    s = -(double)cell->fixed_width[j] / 100.;\n\t    b = sigma_td((int)(s * width));\n\t    correct_table_matrix2(t, cell->col[j], cell->colspan[j], s, b);\n\t}\n    }\n\n    set_table_matrix0(t, width);\n\n    if (t->total_width > 0) {\n\tb = sigma_table(width);\n    }\n    else {\n\tb = sigma_table_nw(width);\n    }\n    correct_table_matrix(t, 0, size, width, b);\n}\n#endif\t\t\t\t/* MATRIX */\n\n/* Local Variables:    */\n/* c-basic-offset: 4   */\n/* tab-width: 8        */\n/* End:                */\n"], "filenames": ["table.c"], "buggy_code_start_loc": [2358], "buggy_code_end_loc": [2362], "fixing_code_start_loc": [2359], "fixing_code_end_loc": [2367], "type": "CWE-835", "message": "w3m through 0.5.3 is prone to an infinite recursion flaw in HTMLlineproc0 because the feed_table_block_tag function in table.c does not prevent a negative indent value.", "other": {"cve": {"id": "CVE-2018-6196", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-25T03:29:00.447", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "w3m through 0.5.3 is prone to an infinite recursion flaw in HTMLlineproc0 because the feed_table_block_tag function in table.c does not prevent a negative indent value."}, {"lang": "es", "value": "w3m hasta la versi\u00f3n 0.5.3 es propenso a un error de recursi\u00f3n infinita en HTMLlineproc0 debido a que la funci\u00f3n feed_table_block_tag en table.c no evita un valor negativo de sangr\u00eda."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:w3m_project:w3m:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.3", "matchCriteriaId": "E9ED2413-606A-403C-82FF-A2EB381867AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://github.com/tats/w3m/commit/8354763b90490d4105695df52674d0fcef823e92", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tats/w3m/issues/88", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00025.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3555-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3555-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tats/w3m/commit/8354763b90490d4105695df52674d0fcef823e92"}}