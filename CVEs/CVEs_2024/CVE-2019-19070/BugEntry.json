{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * SPI master driver using generic bitbanged GPIO\n *\n * Copyright (C) 2006,2008 David Brownell\n * Copyright (C) 2017 Linus Walleij\n */\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/spi/spi_gpio.h>\n\n\n/*\n * This bitbanging SPI master driver should help make systems usable\n * when a native hardware SPI engine is not available, perhaps because\n * its driver isn't yet working or because the I/O pins it requires\n * are used for other purposes.\n *\n * platform_device->driver_data ... points to spi_gpio\n *\n * spi->controller_state ... reserved for bitbang framework code\n *\n * spi->master->dev.driver_data ... points to spi_gpio->bitbang\n */\n\nstruct spi_gpio {\n\tstruct spi_bitbang\t\tbitbang;\n\tstruct gpio_desc\t\t*sck;\n\tstruct gpio_desc\t\t*miso;\n\tstruct gpio_desc\t\t*mosi;\n\tstruct gpio_desc\t\t**cs_gpios;\n};\n\n/*----------------------------------------------------------------------*/\n\n/*\n * Because the overhead of going through four GPIO procedure calls\n * per transferred bit can make performance a problem, this code\n * is set up so that you can use it in either of two ways:\n *\n *   - The slow generic way:  set up platform_data to hold the GPIO\n *     numbers used for MISO/MOSI/SCK, and issue procedure calls for\n *     each of them.  This driver can handle several such busses.\n *\n *   - The quicker inlined way:  only helps with platform GPIO code\n *     that inlines operations for constant GPIOs.  This can give\n *     you tight (fast!) inner loops, but each such bus needs a\n *     new driver.  You'll define a new C file, with Makefile and\n *     Kconfig support; the C code can be a total of six lines:\n *\n *\t\t#define DRIVER_NAME\t\"myboard_spi2\"\n *\t\t#define\tSPI_MISO_GPIO\t119\n *\t\t#define\tSPI_MOSI_GPIO\t120\n *\t\t#define\tSPI_SCK_GPIO\t121\n *\t\t#define\tSPI_N_CHIPSEL\t4\n *\t\t#include \"spi-gpio.c\"\n */\n\n#ifndef DRIVER_NAME\n#define DRIVER_NAME\t\"spi_gpio\"\n\n#define GENERIC_BITBANG\t/* vs tight inlines */\n\n#endif\n\n/*----------------------------------------------------------------------*/\n\nstatic inline struct spi_gpio *__pure\nspi_to_spi_gpio(const struct spi_device *spi)\n{\n\tconst struct spi_bitbang\t*bang;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\n\tbang = spi_master_get_devdata(spi->master);\n\tspi_gpio = container_of(bang, struct spi_gpio, bitbang);\n\treturn spi_gpio;\n}\n\n/* These helpers are in turn called by the bitbang inlines */\nstatic inline void setsck(const struct spi_device *spi, int is_on)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tgpiod_set_value_cansleep(spi_gpio->sck, is_on);\n}\n\nstatic inline void setmosi(const struct spi_device *spi, int is_on)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tgpiod_set_value_cansleep(spi_gpio->mosi, is_on);\n}\n\nstatic inline int getmiso(const struct spi_device *spi)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tif (spi->mode & SPI_3WIRE)\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->mosi);\n\telse\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->miso);\n}\n\n/*\n * NOTE:  this clocks \"as fast as we can\".  It \"should\" be a function of the\n * requested device clock.  Software overhead means we usually have trouble\n * reaching even one Mbit/sec (except when we can inline bitops), so for now\n * we'll just assume we never need additional per-bit slowdowns.\n */\n#define spidelay(nsecs)\tdo {} while (0)\n\n#include \"spi-bitbang-txrx.h\"\n\n/*\n * These functions can leverage inline expansion of GPIO calls to shrink\n * costs for a txrx bit, often by factors of around ten (by instruction\n * count).  That is particularly visible for larger word sizes, but helps\n * even with default 8-bit words.\n *\n * REVISIT overheads calling these functions for each word also have\n * significant performance costs.  Having txrx_bufs() calls that inline\n * the txrx_word() logic would help performance, e.g. on larger blocks\n * used with flash storage or MMC/SD.  There should also be ways to make\n * GCC be less stupid about reloading registers inside the I/O loops,\n * even without inlined GPIO calls; __attribute__((hot)) on GCC 4.3?\n */\n\nstatic u32 spi_gpio_txrx_word_mode0(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode1(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode2(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode3(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\n/*\n * These functions do not call setmosi or getmiso if respective flag\n * (SPI_MASTER_NO_RX or SPI_MASTER_NO_TX) is set, so they are safe to\n * call when such pin is not present or defined in the controller.\n * A separate set of callbacks is defined to get highest possible\n * speed in the generic case (when both MISO and MOSI lines are\n * available), as optimiser will remove the checks when argument is\n * constant.\n */\n\nstatic u32 spi_gpio_spec_txrx_word_mode0(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode1(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode2(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode3(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\n/*----------------------------------------------------------------------*/\n\nstatic void spi_gpio_chipselect(struct spi_device *spi, int is_active)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\t/* set initial clock line level */\n\tif (is_active)\n\t\tgpiod_set_value_cansleep(spi_gpio->sck, spi->mode & SPI_CPOL);\n\n\t/* Drive chip select line, if we have one */\n\tif (spi_gpio->cs_gpios) {\n\t\tstruct gpio_desc *cs = spi_gpio->cs_gpios[spi->chip_select];\n\n\t\t/* SPI chip selects are normally active-low */\n\t\tgpiod_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);\n\t}\n}\n\nstatic int spi_gpio_setup(struct spi_device *spi)\n{\n\tstruct gpio_desc\t*cs;\n\tint\t\t\tstatus = 0;\n\tstruct spi_gpio\t\t*spi_gpio = spi_to_spi_gpio(spi);\n\n\t/*\n\t * The CS GPIOs have already been\n\t * initialized from the descriptor lookup.\n\t */\n\tif (spi_gpio->cs_gpios) {\n\t\tcs = spi_gpio->cs_gpios[spi->chip_select];\n\t\tif (!spi->controller_state && cs)\n\t\t\tstatus = gpiod_direction_output(cs,\n\t\t\t\t\t\t  !(spi->mode & SPI_CS_HIGH));\n\t}\n\n\tif (!status)\n\t\tstatus = spi_bitbang_setup(spi);\n\n\treturn status;\n}\n\nstatic int spi_gpio_set_direction(struct spi_device *spi, bool output)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\tint ret;\n\n\tif (output)\n\t\treturn gpiod_direction_output(spi_gpio->mosi, 1);\n\n\tret = gpiod_direction_input(spi_gpio->mosi);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * Send a turnaround high impedance cycle when switching\n\t * from output to input. Theoretically there should be\n\t * a clock delay here, but as has been noted above, the\n\t * nsec delay function for bit-banged GPIO is simply\n\t * {} because bit-banging just doesn't get fast enough\n\t * anyway.\n\t */\n\tif (spi->mode & SPI_3WIRE_HIZ) {\n\t\tgpiod_set_value_cansleep(spi_gpio->sck,\n\t\t\t\t\t !(spi->mode & SPI_CPOL));\n\t\tgpiod_set_value_cansleep(spi_gpio->sck,\n\t\t\t\t\t !!(spi->mode & SPI_CPOL));\n\t}\n\treturn 0;\n}\n\nstatic void spi_gpio_cleanup(struct spi_device *spi)\n{\n\tspi_bitbang_cleanup(spi);\n}\n\n/*\n * It can be convenient to use this driver with pins that have alternate\n * functions associated with a \"native\" SPI controller if a driver for that\n * controller is not available, or is missing important functionality.\n *\n * On platforms which can do so, configure MISO with a weak pullup unless\n * there's an external pullup on that signal.  That saves power by avoiding\n * floating signals.  (A weak pulldown would save power too, but many\n * drivers expect to see all-ones data as the no slave \"response\".)\n */\nstatic int spi_gpio_request(struct device *dev, struct spi_gpio *spi_gpio)\n{\n\tspi_gpio->mosi = devm_gpiod_get_optional(dev, \"mosi\", GPIOD_OUT_LOW);\n\tif (IS_ERR(spi_gpio->mosi))\n\t\treturn PTR_ERR(spi_gpio->mosi);\n\n\tspi_gpio->miso = devm_gpiod_get_optional(dev, \"miso\", GPIOD_IN);\n\tif (IS_ERR(spi_gpio->miso))\n\t\treturn PTR_ERR(spi_gpio->miso);\n\n\tspi_gpio->sck = devm_gpiod_get(dev, \"sck\", GPIOD_OUT_LOW);\n\treturn PTR_ERR_OR_ZERO(spi_gpio->sck);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spi_gpio_dt_ids[] = {\n\t{ .compatible = \"spi-gpio\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spi_gpio_dt_ids);\n\nstatic int spi_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t     struct spi_master *master)\n{\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->use_gpio_descriptors = true;\n\n\treturn 0;\n}\n#else\nstatic inline int spi_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t\t    struct spi_master *master)\n{\n\treturn 0;\n}\n#endif\n\nstatic int spi_gpio_probe_pdata(struct platform_device *pdev,\n\t\t\t\tstruct spi_master *master)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_gpio_platform_data *pdata = dev_get_platdata(dev);\n\tstruct spi_gpio *spi_gpio = spi_master_get_devdata(master);\n\tint i;\n\n#ifdef GENERIC_BITBANG\n\tif (!pdata || !pdata->num_chipselect)\n\t\treturn -ENODEV;\n#endif\n\t/*\n\t * The master needs to think there is a chipselect even if not\n\t * connected\n\t */\n\tmaster->num_chipselect = pdata->num_chipselect ?: 1;\n\n\tspi_gpio->cs_gpios = devm_kcalloc(dev, master->num_chipselect,\n\t\t\t\t\t  sizeof(*spi_gpio->cs_gpios),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!spi_gpio->cs_gpios)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < master->num_chipselect; i++) {\n\t\tspi_gpio->cs_gpios[i] = devm_gpiod_get_index(dev, \"cs\", i,\n\t\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(spi_gpio->cs_gpios[i]))\n\t\t\treturn PTR_ERR(spi_gpio->cs_gpios[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void spi_gpio_put(void *data)\n{\n\tspi_master_put(data);\n}\n\nstatic int spi_gpio_probe(struct platform_device *pdev)\n{\n\tint\t\t\t\tstatus;\n\tstruct spi_master\t\t*master;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct spi_bitbang\t\t*bb;\n\tconst struct of_device_id\t*of_id;\n\n\tof_id = of_match_device(spi_gpio_dt_ids, &pdev->dev);\n\n\tmaster = spi_alloc_master(dev, sizeof(*spi_gpio));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tstatus = devm_add_action_or_reset(&pdev->dev, spi_gpio_put, master);\n\tif (status)\n\t\treturn status;\n\n\tif (of_id)\n\t\tstatus = spi_gpio_probe_dt(pdev, master);\n\telse\n\t\tstatus = spi_gpio_probe_pdata(pdev, master);\n\n\tif (status)\n\t\treturn status;\n\n\tspi_gpio = spi_master_get_devdata(master);\n\n\tstatus = spi_gpio_request(dev, spi_gpio);\n\tif (status)\n\t\treturn status;\n\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\tmaster->mode_bits = SPI_3WIRE | SPI_3WIRE_HIZ | SPI_CPHA | SPI_CPOL |\n\t\t\t    SPI_CS_HIGH;\n\tif (!spi_gpio->mosi) {\n\t\t/* HW configuration without MOSI pin\n\t\t *\n\t\t * No setting SPI_MASTER_NO_RX here - if there is only\n\t\t * a MOSI pin connected the host can still do RX by\n\t\t * changing the direction of the line.\n\t\t */\n\t\tmaster->flags = SPI_MASTER_NO_TX;\n\t}\n\n\tmaster->bus_num = pdev->id;\n\tmaster->setup = spi_gpio_setup;\n\tmaster->cleanup = spi_gpio_cleanup;\n\n\tbb = &spi_gpio->bitbang;\n\tbb->master = master;\n\t/*\n\t * There is some additional business, apart from driving the CS GPIO\n\t * line, that we need to do on selection. This makes the local\n\t * callback for chipselect always get called.\n\t */\n\tmaster->flags |= SPI_MASTER_GPIO_SS;\n\tbb->chipselect = spi_gpio_chipselect;\n\tbb->set_line_direction = spi_gpio_set_direction;\n\n\tif (master->flags & SPI_MASTER_NO_TX) {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;\n\t} else {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;\n\t}\n\tbb->setup_transfer = spi_bitbang_setup_transfer;\n\n\tstatus = spi_bitbang_init(&spi_gpio->bitbang);\n\tif (status)\n\t\treturn status;\n\n\treturn devm_spi_register_master(&pdev->dev, spi_master_get(master));\n}\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n\nstatic struct platform_driver spi_gpio_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(spi_gpio_dt_ids),\n\t},\n\t.probe\t\t= spi_gpio_probe,\n};\nmodule_platform_driver(spi_gpio_driver);\n\nMODULE_DESCRIPTION(\"SPI master driver using generic bitbanged GPIO \");\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * SPI master driver using generic bitbanged GPIO\n *\n * Copyright (C) 2006,2008 David Brownell\n * Copyright (C) 2017 Linus Walleij\n */\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/spi/spi_gpio.h>\n\n\n/*\n * This bitbanging SPI master driver should help make systems usable\n * when a native hardware SPI engine is not available, perhaps because\n * its driver isn't yet working or because the I/O pins it requires\n * are used for other purposes.\n *\n * platform_device->driver_data ... points to spi_gpio\n *\n * spi->controller_state ... reserved for bitbang framework code\n *\n * spi->master->dev.driver_data ... points to spi_gpio->bitbang\n */\n\nstruct spi_gpio {\n\tstruct spi_bitbang\t\tbitbang;\n\tstruct gpio_desc\t\t*sck;\n\tstruct gpio_desc\t\t*miso;\n\tstruct gpio_desc\t\t*mosi;\n\tstruct gpio_desc\t\t**cs_gpios;\n};\n\n/*----------------------------------------------------------------------*/\n\n/*\n * Because the overhead of going through four GPIO procedure calls\n * per transferred bit can make performance a problem, this code\n * is set up so that you can use it in either of two ways:\n *\n *   - The slow generic way:  set up platform_data to hold the GPIO\n *     numbers used for MISO/MOSI/SCK, and issue procedure calls for\n *     each of them.  This driver can handle several such busses.\n *\n *   - The quicker inlined way:  only helps with platform GPIO code\n *     that inlines operations for constant GPIOs.  This can give\n *     you tight (fast!) inner loops, but each such bus needs a\n *     new driver.  You'll define a new C file, with Makefile and\n *     Kconfig support; the C code can be a total of six lines:\n *\n *\t\t#define DRIVER_NAME\t\"myboard_spi2\"\n *\t\t#define\tSPI_MISO_GPIO\t119\n *\t\t#define\tSPI_MOSI_GPIO\t120\n *\t\t#define\tSPI_SCK_GPIO\t121\n *\t\t#define\tSPI_N_CHIPSEL\t4\n *\t\t#include \"spi-gpio.c\"\n */\n\n#ifndef DRIVER_NAME\n#define DRIVER_NAME\t\"spi_gpio\"\n\n#define GENERIC_BITBANG\t/* vs tight inlines */\n\n#endif\n\n/*----------------------------------------------------------------------*/\n\nstatic inline struct spi_gpio *__pure\nspi_to_spi_gpio(const struct spi_device *spi)\n{\n\tconst struct spi_bitbang\t*bang;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\n\tbang = spi_master_get_devdata(spi->master);\n\tspi_gpio = container_of(bang, struct spi_gpio, bitbang);\n\treturn spi_gpio;\n}\n\n/* These helpers are in turn called by the bitbang inlines */\nstatic inline void setsck(const struct spi_device *spi, int is_on)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tgpiod_set_value_cansleep(spi_gpio->sck, is_on);\n}\n\nstatic inline void setmosi(const struct spi_device *spi, int is_on)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tgpiod_set_value_cansleep(spi_gpio->mosi, is_on);\n}\n\nstatic inline int getmiso(const struct spi_device *spi)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tif (spi->mode & SPI_3WIRE)\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->mosi);\n\telse\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->miso);\n}\n\n/*\n * NOTE:  this clocks \"as fast as we can\".  It \"should\" be a function of the\n * requested device clock.  Software overhead means we usually have trouble\n * reaching even one Mbit/sec (except when we can inline bitops), so for now\n * we'll just assume we never need additional per-bit slowdowns.\n */\n#define spidelay(nsecs)\tdo {} while (0)\n\n#include \"spi-bitbang-txrx.h\"\n\n/*\n * These functions can leverage inline expansion of GPIO calls to shrink\n * costs for a txrx bit, often by factors of around ten (by instruction\n * count).  That is particularly visible for larger word sizes, but helps\n * even with default 8-bit words.\n *\n * REVISIT overheads calling these functions for each word also have\n * significant performance costs.  Having txrx_bufs() calls that inline\n * the txrx_word() logic would help performance, e.g. on larger blocks\n * used with flash storage or MMC/SD.  There should also be ways to make\n * GCC be less stupid about reloading registers inside the I/O loops,\n * even without inlined GPIO calls; __attribute__((hot)) on GCC 4.3?\n */\n\nstatic u32 spi_gpio_txrx_word_mode0(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode1(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode2(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 spi_gpio_txrx_word_mode3(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\n/*\n * These functions do not call setmosi or getmiso if respective flag\n * (SPI_MASTER_NO_RX or SPI_MASTER_NO_TX) is set, so they are safe to\n * call when such pin is not present or defined in the controller.\n * A separate set of callbacks is defined to get highest possible\n * speed in the generic case (when both MISO and MOSI lines are\n * available), as optimiser will remove the checks when argument is\n * constant.\n */\n\nstatic u32 spi_gpio_spec_txrx_word_mode0(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode1(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode2(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\n}\n\nstatic u32 spi_gpio_spec_txrx_word_mode3(struct spi_device *spi,\n\t\tunsigned nsecs, u32 word, u8 bits, unsigned flags)\n{\n\tflags = spi->master->flags;\n\treturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\n}\n\n/*----------------------------------------------------------------------*/\n\nstatic void spi_gpio_chipselect(struct spi_device *spi, int is_active)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\t/* set initial clock line level */\n\tif (is_active)\n\t\tgpiod_set_value_cansleep(spi_gpio->sck, spi->mode & SPI_CPOL);\n\n\t/* Drive chip select line, if we have one */\n\tif (spi_gpio->cs_gpios) {\n\t\tstruct gpio_desc *cs = spi_gpio->cs_gpios[spi->chip_select];\n\n\t\t/* SPI chip selects are normally active-low */\n\t\tgpiod_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);\n\t}\n}\n\nstatic int spi_gpio_setup(struct spi_device *spi)\n{\n\tstruct gpio_desc\t*cs;\n\tint\t\t\tstatus = 0;\n\tstruct spi_gpio\t\t*spi_gpio = spi_to_spi_gpio(spi);\n\n\t/*\n\t * The CS GPIOs have already been\n\t * initialized from the descriptor lookup.\n\t */\n\tif (spi_gpio->cs_gpios) {\n\t\tcs = spi_gpio->cs_gpios[spi->chip_select];\n\t\tif (!spi->controller_state && cs)\n\t\t\tstatus = gpiod_direction_output(cs,\n\t\t\t\t\t\t  !(spi->mode & SPI_CS_HIGH));\n\t}\n\n\tif (!status)\n\t\tstatus = spi_bitbang_setup(spi);\n\n\treturn status;\n}\n\nstatic int spi_gpio_set_direction(struct spi_device *spi, bool output)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\tint ret;\n\n\tif (output)\n\t\treturn gpiod_direction_output(spi_gpio->mosi, 1);\n\n\tret = gpiod_direction_input(spi_gpio->mosi);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * Send a turnaround high impedance cycle when switching\n\t * from output to input. Theoretically there should be\n\t * a clock delay here, but as has been noted above, the\n\t * nsec delay function for bit-banged GPIO is simply\n\t * {} because bit-banging just doesn't get fast enough\n\t * anyway.\n\t */\n\tif (spi->mode & SPI_3WIRE_HIZ) {\n\t\tgpiod_set_value_cansleep(spi_gpio->sck,\n\t\t\t\t\t !(spi->mode & SPI_CPOL));\n\t\tgpiod_set_value_cansleep(spi_gpio->sck,\n\t\t\t\t\t !!(spi->mode & SPI_CPOL));\n\t}\n\treturn 0;\n}\n\nstatic void spi_gpio_cleanup(struct spi_device *spi)\n{\n\tspi_bitbang_cleanup(spi);\n}\n\n/*\n * It can be convenient to use this driver with pins that have alternate\n * functions associated with a \"native\" SPI controller if a driver for that\n * controller is not available, or is missing important functionality.\n *\n * On platforms which can do so, configure MISO with a weak pullup unless\n * there's an external pullup on that signal.  That saves power by avoiding\n * floating signals.  (A weak pulldown would save power too, but many\n * drivers expect to see all-ones data as the no slave \"response\".)\n */\nstatic int spi_gpio_request(struct device *dev, struct spi_gpio *spi_gpio)\n{\n\tspi_gpio->mosi = devm_gpiod_get_optional(dev, \"mosi\", GPIOD_OUT_LOW);\n\tif (IS_ERR(spi_gpio->mosi))\n\t\treturn PTR_ERR(spi_gpio->mosi);\n\n\tspi_gpio->miso = devm_gpiod_get_optional(dev, \"miso\", GPIOD_IN);\n\tif (IS_ERR(spi_gpio->miso))\n\t\treturn PTR_ERR(spi_gpio->miso);\n\n\tspi_gpio->sck = devm_gpiod_get(dev, \"sck\", GPIOD_OUT_LOW);\n\treturn PTR_ERR_OR_ZERO(spi_gpio->sck);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spi_gpio_dt_ids[] = {\n\t{ .compatible = \"spi-gpio\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spi_gpio_dt_ids);\n\nstatic int spi_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t     struct spi_master *master)\n{\n\tmaster->dev.of_node = pdev->dev.of_node;\n\tmaster->use_gpio_descriptors = true;\n\n\treturn 0;\n}\n#else\nstatic inline int spi_gpio_probe_dt(struct platform_device *pdev,\n\t\t\t\t    struct spi_master *master)\n{\n\treturn 0;\n}\n#endif\n\nstatic int spi_gpio_probe_pdata(struct platform_device *pdev,\n\t\t\t\tstruct spi_master *master)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct spi_gpio_platform_data *pdata = dev_get_platdata(dev);\n\tstruct spi_gpio *spi_gpio = spi_master_get_devdata(master);\n\tint i;\n\n#ifdef GENERIC_BITBANG\n\tif (!pdata || !pdata->num_chipselect)\n\t\treturn -ENODEV;\n#endif\n\t/*\n\t * The master needs to think there is a chipselect even if not\n\t * connected\n\t */\n\tmaster->num_chipselect = pdata->num_chipselect ?: 1;\n\n\tspi_gpio->cs_gpios = devm_kcalloc(dev, master->num_chipselect,\n\t\t\t\t\t  sizeof(*spi_gpio->cs_gpios),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!spi_gpio->cs_gpios)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < master->num_chipselect; i++) {\n\t\tspi_gpio->cs_gpios[i] = devm_gpiod_get_index(dev, \"cs\", i,\n\t\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(spi_gpio->cs_gpios[i]))\n\t\t\treturn PTR_ERR(spi_gpio->cs_gpios[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void spi_gpio_put(void *data)\n{\n\tspi_master_put(data);\n}\n\nstatic int spi_gpio_probe(struct platform_device *pdev)\n{\n\tint\t\t\t\tstatus;\n\tstruct spi_master\t\t*master;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct spi_bitbang\t\t*bb;\n\tconst struct of_device_id\t*of_id;\n\n\tof_id = of_match_device(spi_gpio_dt_ids, &pdev->dev);\n\n\tmaster = spi_alloc_master(dev, sizeof(*spi_gpio));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tstatus = devm_add_action_or_reset(&pdev->dev, spi_gpio_put, master);\n\tif (status) {\n\t\tspi_master_put(master);\n\t\treturn status;\n\t}\n\n\tif (of_id)\n\t\tstatus = spi_gpio_probe_dt(pdev, master);\n\telse\n\t\tstatus = spi_gpio_probe_pdata(pdev, master);\n\n\tif (status)\n\t\treturn status;\n\n\tspi_gpio = spi_master_get_devdata(master);\n\n\tstatus = spi_gpio_request(dev, spi_gpio);\n\tif (status)\n\t\treturn status;\n\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\tmaster->mode_bits = SPI_3WIRE | SPI_3WIRE_HIZ | SPI_CPHA | SPI_CPOL |\n\t\t\t    SPI_CS_HIGH;\n\tif (!spi_gpio->mosi) {\n\t\t/* HW configuration without MOSI pin\n\t\t *\n\t\t * No setting SPI_MASTER_NO_RX here - if there is only\n\t\t * a MOSI pin connected the host can still do RX by\n\t\t * changing the direction of the line.\n\t\t */\n\t\tmaster->flags = SPI_MASTER_NO_TX;\n\t}\n\n\tmaster->bus_num = pdev->id;\n\tmaster->setup = spi_gpio_setup;\n\tmaster->cleanup = spi_gpio_cleanup;\n\n\tbb = &spi_gpio->bitbang;\n\tbb->master = master;\n\t/*\n\t * There is some additional business, apart from driving the CS GPIO\n\t * line, that we need to do on selection. This makes the local\n\t * callback for chipselect always get called.\n\t */\n\tmaster->flags |= SPI_MASTER_GPIO_SS;\n\tbb->chipselect = spi_gpio_chipselect;\n\tbb->set_line_direction = spi_gpio_set_direction;\n\n\tif (master->flags & SPI_MASTER_NO_TX) {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;\n\t} else {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;\n\t}\n\tbb->setup_transfer = spi_bitbang_setup_transfer;\n\n\tstatus = spi_bitbang_init(&spi_gpio->bitbang);\n\tif (status)\n\t\treturn status;\n\n\treturn devm_spi_register_master(&pdev->dev, spi_master_get(master));\n}\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n\nstatic struct platform_driver spi_gpio_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(spi_gpio_dt_ids),\n\t},\n\t.probe\t\t= spi_gpio_probe,\n};\nmodule_platform_driver(spi_gpio_driver);\n\nMODULE_DESCRIPTION(\"SPI master driver using generic bitbanged GPIO \");\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/spi/spi-gpio.c"], "buggy_code_start_loc": [374], "buggy_code_end_loc": [375], "fixing_code_start_loc": [374], "fixing_code_end_loc": [378], "type": "CWE-401", "message": "** DISPUTED ** A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began.", "other": {"cve": {"id": "CVE-2019-19070", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.983", "lastModified": "2021-06-02T15:38:21.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began."}, {"lang": "es", "value": "** EN DISPUTA ** Una p\u00e9rdida de memoria en la funci\u00f3n spi_gpio_probe() en el archivo drivers/spi/spi-gpio.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n devm_add_action_or_reset(), tambi\u00e9n se conoce como CID-d3b0ffa1d75d. NOTA: Las partes cuestionan la relevancia de esto porque el sistema ya debe haberse quedado sin memoria antes de que comenzara la sonda."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.17", "versionEndExcluding": "5.4.7", "matchCriteriaId": "AB2DA1DD-2169-4901-B161-A364F50C1634"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "17CCD88F-373D-4BB5-B62E-8B55B05E2C31"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1157294", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d3b0ffa1d75d5305ebe34735598993afbb8a869d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d3b0ffa1d75d5305ebe34735598993afbb8a869d"}}