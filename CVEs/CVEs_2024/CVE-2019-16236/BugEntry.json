{"buggy_code": ["using Gee;\n\nnamespace Xmpp.Roster {\n\nprivate const string NS_URI = \"jabber:iq:roster\";\n\npublic class Module : XmppStreamModule, Iq.Handler {\n    public static ModuleIdentity<Module> IDENTITY = new ModuleIdentity<Module>(NS_URI, \"roster_module\");\n\n    public signal void received_roster(XmppStream stream, Collection<Item> roster, Iq.Stanza stanza);\n    public signal void pre_get_roster(XmppStream stream, Iq.Stanza iq);\n    public signal void item_removed(XmppStream stream, Item item, Iq.Stanza iq);\n    public signal void item_updated(XmppStream stream, Item item, Iq.Stanza iq);\n    public signal void mutual_subscription(XmppStream stream, Jid jid);\n\n    public bool interested_resource = true;\n\n    public void add_jid(XmppStream stream, Jid jid, string? handle = null) {\n        Item roster_item = new Item();\n        roster_item.jid = jid;\n        if (handle != null) {\n            roster_item.name = handle;\n        }\n        roster_set(stream, roster_item);\n    }\n\n    public void remove_jid(XmppStream stream, Jid jid) {\n        Item roster_item = new Item();\n        roster_item.jid = jid;\n        roster_item.subscription = Item.SUBSCRIPTION_REMOVE;\n\n        roster_set(stream, roster_item);\n    }\n\n    /**\n     * Set a handle for a jid\n     * @param   handle  Handle to be set. If null, any handle will be removed.\n     */\n    public void set_jid_handle(XmppStream stream, Jid jid, string? handle) {\n        Flag flag = stream.get_flag(Flag.IDENTITY);\n        Item item = flag.get_item(jid) ?? new Item() { jid=jid };\n        item.name = handle != null ? handle : \"\";\n\n        roster_set(stream, item);\n    }\n\n    public void on_iq_set(XmppStream stream, Iq.Stanza iq) {\n        StanzaNode? query_node = iq.stanza.get_subnode(\"query\", NS_URI);\n        if (query_node == null) return;\n\n        Flag flag = stream.get_flag(Flag.IDENTITY);\n        Item item = new Item.from_stanza_node(query_node.get_subnode(\"item\", NS_URI));\n        switch (item.subscription) {\n            case Item.SUBSCRIPTION_REMOVE:\n                flag.roster_items.unset(item.jid);\n                item_removed(stream, item, iq);\n                break;\n            default:\n                bool is_new = false;\n                Item old = flag.get_item(item.jid);\n                is_new = item.subscription == Item.SUBSCRIPTION_BOTH && (old == null || old.subscription == Item.SUBSCRIPTION_BOTH);\n                flag.roster_items[item.jid] = item;\n                item_updated(stream, item,  iq);\n                if(is_new) mutual_subscription(stream, item.jid);\n                break;\n        }\n    }\n\n    public override void attach(XmppStream stream) {\n        stream.get_module(Iq.Module.IDENTITY).register_for_namespace(NS_URI, this);\n        stream.get_module(Presence.Module.IDENTITY).initial_presence_sent.connect(roster_get);\n        stream.add_flag(new Flag());\n    }\n\n    public override void detach(XmppStream stream) {\n        stream.get_module(Presence.Module.IDENTITY).initial_presence_sent.disconnect(roster_get);\n    }\n\n    internal override string get_ns() { return NS_URI; }\n    internal override string get_id() { return IDENTITY.id; }\n\n    private void roster_get(XmppStream stream) {\n        stream.get_flag(Flag.IDENTITY).iq_id = random_uuid();\n        StanzaNode query_node = new StanzaNode.build(\"query\", NS_URI).add_self_xmlns();\n        Iq.Stanza iq = new Iq.Stanza.get(query_node, stream.get_flag(Flag.IDENTITY).iq_id);\n\n        pre_get_roster(stream, iq);\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq, on_roster_get_received);\n    }\n\n    private static void on_roster_get_received(XmppStream stream, Iq.Stanza iq) {\n        Flag flag = stream.get_flag(Flag.IDENTITY);\n        if (iq.id == flag.iq_id) {\n            StanzaNode? query_node = iq.stanza.get_subnode(\"query\", NS_URI);\n            if (query_node != null) {\n                foreach (StanzaNode item_node in query_node.sub_nodes) {\n                    Item item = new Item.from_stanza_node(item_node);\n                    flag.roster_items[item.jid] = item;\n                }\n            }\n            stream.get_module(Module.IDENTITY).received_roster(stream, flag.roster_items.values, iq);\n        }\n    }\n\n    private void roster_set(XmppStream stream, Item roster_item) {\n        StanzaNode query_node = new StanzaNode.build(\"query\", NS_URI).add_self_xmlns()\n                                .put_node(roster_item.stanza_node);\n        Iq.Stanza iq = new Iq.Stanza.set(query_node);\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq);\n    }\n}\n\n}\n"], "fixing_code": ["using Gee;\n\nnamespace Xmpp.Roster {\n\nprivate const string NS_URI = \"jabber:iq:roster\";\n\npublic class Module : XmppStreamModule, Iq.Handler {\n    public static ModuleIdentity<Module> IDENTITY = new ModuleIdentity<Module>(NS_URI, \"roster_module\");\n\n    public signal void received_roster(XmppStream stream, Collection<Item> roster, Iq.Stanza stanza);\n    public signal void pre_get_roster(XmppStream stream, Iq.Stanza iq);\n    public signal void item_removed(XmppStream stream, Item item, Iq.Stanza iq);\n    public signal void item_updated(XmppStream stream, Item item, Iq.Stanza iq);\n    public signal void mutual_subscription(XmppStream stream, Jid jid);\n\n    public bool interested_resource = true;\n\n    public void add_jid(XmppStream stream, Jid jid, string? handle = null) {\n        Item roster_item = new Item();\n        roster_item.jid = jid;\n        if (handle != null) {\n            roster_item.name = handle;\n        }\n        roster_set(stream, roster_item);\n    }\n\n    public void remove_jid(XmppStream stream, Jid jid) {\n        Item roster_item = new Item();\n        roster_item.jid = jid;\n        roster_item.subscription = Item.SUBSCRIPTION_REMOVE;\n\n        roster_set(stream, roster_item);\n    }\n\n    /**\n     * Set a handle for a jid\n     * @param   handle  Handle to be set. If null, any handle will be removed.\n     */\n    public void set_jid_handle(XmppStream stream, Jid jid, string? handle) {\n        Flag flag = stream.get_flag(Flag.IDENTITY);\n        Item item = flag.get_item(jid) ?? new Item() { jid=jid };\n        item.name = handle != null ? handle : \"\";\n\n        roster_set(stream, item);\n    }\n\n    public void on_iq_set(XmppStream stream, Iq.Stanza iq) {\n        StanzaNode? query_node = iq.stanza.get_subnode(\"query\", NS_URI);\n        if (query_node == null) return;\n        if (!iq.from.equals(stream.get_flag(Bind.Flag.IDENTITY).my_jid.bare_jid)) {\n            warning(\"Received alledged roster push from %s, ignoring\", iq.from.to_string());\n            return;\n        }\n\n        Flag flag = stream.get_flag(Flag.IDENTITY);\n        Item item = new Item.from_stanza_node(query_node.get_subnode(\"item\", NS_URI));\n        switch (item.subscription) {\n            case Item.SUBSCRIPTION_REMOVE:\n                flag.roster_items.unset(item.jid);\n                item_removed(stream, item, iq);\n                break;\n            default:\n                bool is_new = false;\n                Item old = flag.get_item(item.jid);\n                is_new = item.subscription == Item.SUBSCRIPTION_BOTH && (old == null || old.subscription == Item.SUBSCRIPTION_BOTH);\n                flag.roster_items[item.jid] = item;\n                item_updated(stream, item,  iq);\n                if(is_new) mutual_subscription(stream, item.jid);\n                break;\n        }\n    }\n\n    public override void attach(XmppStream stream) {\n        stream.get_module(Iq.Module.IDENTITY).register_for_namespace(NS_URI, this);\n        stream.get_module(Presence.Module.IDENTITY).initial_presence_sent.connect(roster_get);\n        stream.add_flag(new Flag());\n    }\n\n    public override void detach(XmppStream stream) {\n        stream.get_module(Presence.Module.IDENTITY).initial_presence_sent.disconnect(roster_get);\n    }\n\n    internal override string get_ns() { return NS_URI; }\n    internal override string get_id() { return IDENTITY.id; }\n\n    private void roster_get(XmppStream stream) {\n        stream.get_flag(Flag.IDENTITY).iq_id = random_uuid();\n        StanzaNode query_node = new StanzaNode.build(\"query\", NS_URI).add_self_xmlns();\n        Iq.Stanza iq = new Iq.Stanza.get(query_node, stream.get_flag(Flag.IDENTITY).iq_id);\n\n        pre_get_roster(stream, iq);\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq, on_roster_get_received);\n    }\n\n    private static void on_roster_get_received(XmppStream stream, Iq.Stanza iq) {\n        Flag flag = stream.get_flag(Flag.IDENTITY);\n        if (iq.id == flag.iq_id) {\n            StanzaNode? query_node = iq.stanza.get_subnode(\"query\", NS_URI);\n            if (query_node != null) {\n                foreach (StanzaNode item_node in query_node.sub_nodes) {\n                    Item item = new Item.from_stanza_node(item_node);\n                    flag.roster_items[item.jid] = item;\n                }\n            }\n            stream.get_module(Module.IDENTITY).received_roster(stream, flag.roster_items.values, iq);\n        }\n    }\n\n    private void roster_set(XmppStream stream, Item roster_item) {\n        StanzaNode query_node = new StanzaNode.build(\"query\", NS_URI).add_self_xmlns()\n                                .put_node(roster_item.stanza_node);\n        Iq.Stanza iq = new Iq.Stanza.set(query_node);\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq);\n    }\n}\n\n}\n"], "filenames": ["xmpp-vala/src/module/roster/module.vala"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [49], "fixing_code_start_loc": [50], "fixing_code_end_loc": [54], "type": "CWE-862", "message": "Dino before 2019-09-10 does not check roster push authorization in module/roster/module.vala.", "other": {"cve": {"id": "CVE-2019-16236", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-11T19:15:11.813", "lastModified": "2020-09-14T14:27:03.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dino before 2019-09-10 does not check roster push authorization in module/roster/module.vala."}, {"lang": "es", "value": "Dino antes del 10-09-2019, no comprueba la autorizaci\u00f3n de inserci\u00f3n de lista en el archivo module/roster/module.vala."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dino:dino:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.0", "matchCriteriaId": "01FE0CAC-943E-461D-93F3-734FFCE3BC79"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/09/12/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/dino/dino/commit/dd33f5f949248d87d34f399e8846d5ee5b8823d9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gultsch.de/dino_multiple.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5TMGQ5Q6QMIFG4NVUWMOWW3GIPGWQZVF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WZBNQAOBWTIOKNO4PIYNX624ACGUXSXQ/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YUBM7GDZBB6MZZALDWYRAPNV6HJNLNMC/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Sep/31", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4306-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4524", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dino/dino/commit/dd33f5f949248d87d34f399e8846d5ee5b8823d9"}}