{"buggy_code": ["const Model = require('objection').Model\nconst _ = require('lodash')\nconst JSBinType = require('js-binary').Type\nconst pageHelper = require('../helpers/page')\nconst path = require('path')\nconst fs = require('fs-extra')\nconst yaml = require('js-yaml')\nconst striptags = require('striptags')\nconst emojiRegex = require('emoji-regex')\nconst he = require('he')\nconst CleanCSS = require('clean-css')\nconst TurndownService = require('turndown')\nconst turndownPluginGfm = require('@joplin/turndown-plugin-gfm').gfm\nconst cheerio = require('cheerio')\n\n/* global WIKI */\n\nconst frontmatterRegex = {\n  html: /^(<!-{2}(?:\\n|\\r)([\\w\\W]+?)(?:\\n|\\r)-{2}>)?(?:\\n|\\r)*([\\w\\W]*)*/,\n  legacy: /^(<!-- TITLE: ?([\\w\\W]+?) ?-{2}>)?(?:\\n|\\r)?(<!-- SUBTITLE: ?([\\w\\W]+?) ?-{2}>)?(?:\\n|\\r)*([\\w\\W]*)*/i,\n  markdown: /^(-{3}(?:\\n|\\r)([\\w\\W]+?)(?:\\n|\\r)-{3})?(?:\\n|\\r)*([\\w\\W]*)*/\n}\n\nconst punctuationRegex = /[!,:;/\\\\_+\\-=()&#@<>$~%^*[\\]{}\"'|]+|(\\.\\s)|(\\s\\.)/ig\n// const htmlEntitiesRegex = /(&#[0-9]{3};)|(&#x[a-zA-Z0-9]{2};)/ig\n\n/**\n * Pages model\n */\nmodule.exports = class Page extends Model {\n  static get tableName() { return 'pages' }\n\n  static get jsonSchema () {\n    return {\n      type: 'object',\n      required: ['path', 'title'],\n\n      properties: {\n        id: {type: 'integer'},\n        path: {type: 'string'},\n        hash: {type: 'string'},\n        title: {type: 'string'},\n        description: {type: 'string'},\n        isPublished: {type: 'boolean'},\n        privateNS: {type: 'string'},\n        publishStartDate: {type: 'string'},\n        publishEndDate: {type: 'string'},\n        content: {type: 'string'},\n        contentType: {type: 'string'},\n\n        createdAt: {type: 'string'},\n        updatedAt: {type: 'string'}\n      }\n    }\n  }\n\n  static get jsonAttributes() {\n    return ['extra']\n  }\n\n  static get relationMappings() {\n    return {\n      tags: {\n        relation: Model.ManyToManyRelation,\n        modelClass: require('./tags'),\n        join: {\n          from: 'pages.id',\n          through: {\n            from: 'pageTags.pageId',\n            to: 'pageTags.tagId'\n          },\n          to: 'tags.id'\n        }\n      },\n      links: {\n        relation: Model.HasManyRelation,\n        modelClass: require('./pageLinks'),\n        join: {\n          from: 'pages.id',\n          to: 'pageLinks.pageId'\n        }\n      },\n      author: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./users'),\n        join: {\n          from: 'pages.authorId',\n          to: 'users.id'\n        }\n      },\n      creator: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./users'),\n        join: {\n          from: 'pages.creatorId',\n          to: 'users.id'\n        }\n      },\n      editor: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./editors'),\n        join: {\n          from: 'pages.editorKey',\n          to: 'editors.key'\n        }\n      },\n      locale: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./locales'),\n        join: {\n          from: 'pages.localeCode',\n          to: 'locales.code'\n        }\n      }\n    }\n  }\n\n  $beforeUpdate() {\n    this.updatedAt = new Date().toISOString()\n  }\n  $beforeInsert() {\n    this.createdAt = new Date().toISOString()\n    this.updatedAt = new Date().toISOString()\n  }\n  /**\n   * Solving the violates foreign key constraint using cascade strategy\n   * using static hooks\n   * @see https://vincit.github.io/objection.js/api/types/#type-statichookarguments\n   */\n  static async beforeDelete({ asFindQuery }) {\n    const page = await asFindQuery().select('id')\n    await WIKI.models.comments.query().delete().where('pageId', page[0].id)\n  }\n  /**\n   * Cache Schema\n   */\n  static get cacheSchema() {\n    return new JSBinType({\n      id: 'uint',\n      authorId: 'uint',\n      authorName: 'string',\n      createdAt: 'string',\n      creatorId: 'uint',\n      creatorName: 'string',\n      description: 'string',\n      editorKey: 'string',\n      isPrivate: 'boolean',\n      isPublished: 'boolean',\n      publishEndDate: 'string',\n      publishStartDate: 'string',\n      render: 'string',\n      tags: [\n        {\n          tag: 'string',\n          title: 'string'\n        }\n      ],\n      extra: {\n        js: 'string',\n        css: 'string'\n      },\n      title: 'string',\n      toc: 'string',\n      updatedAt: 'string'\n    })\n  }\n\n  /**\n   * Inject page metadata into contents\n   *\n   * @returns {string} Page Contents with Injected Metadata\n   */\n  injectMetadata () {\n    return pageHelper.injectPageMetadata(this)\n  }\n\n  /**\n   * Get the page's file extension based on content type\n   *\n   * @returns {string} File Extension\n   */\n  getFileExtension() {\n    return pageHelper.getFileExtension(this.contentType)\n  }\n\n  /**\n   * Parse injected page metadata from raw content\n   *\n   * @param {String} raw Raw file contents\n   * @param {String} contentType Content Type\n   * @returns {Object} Parsed Page Metadata with Raw Content\n   */\n  static parseMetadata (raw, contentType) {\n    let result\n    switch (contentType) {\n      case 'markdown':\n        result = frontmatterRegex.markdown.exec(raw)\n        if (result[2]) {\n          return {\n            ...yaml.safeLoad(result[2]),\n            content: result[3]\n          }\n        } else {\n          // Attempt legacy v1 format\n          result = frontmatterRegex.legacy.exec(raw)\n          if (result[2]) {\n            return {\n              title: result[2],\n              description: result[4],\n              content: result[5]\n            }\n          }\n        }\n        break\n      case 'html':\n        result = frontmatterRegex.html.exec(raw)\n        if (result[2]) {\n          return {\n            ...yaml.safeLoad(result[2]),\n            content: result[3]\n          }\n        }\n        break\n    }\n    return {\n      content: raw\n    }\n  }\n\n  /**\n   * Create a New Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async createPage(opts) {\n    // -> Validate path\n    if (opts.path.includes('.') || opts.path.includes(' ') || opts.path.includes('\\\\') || opts.path.includes('//')) {\n      throw new WIKI.Error.PageIllegalPath()\n    }\n\n    // -> Remove trailing slash\n    if (opts.path.endsWith('/')) {\n      opts.path = opts.path.slice(0, -1)\n    }\n\n    // -> Remove starting slash\n    if (opts.path.startsWith('/')) {\n      opts.path = opts.path.slice(1)\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      throw new WIKI.Error.PageDeleteForbidden()\n    }\n\n    // -> Check for duplicate\n    const dupCheck = await WIKI.models.pages.query().select('id').where('localeCode', opts.locale).where('path', opts.path).first()\n    if (dupCheck) {\n      throw new WIKI.Error.PageDuplicateCreate()\n    }\n\n    // -> Check for empty content\n    if (!opts.content || _.trim(opts.content).length < 1) {\n      throw new WIKI.Error.PageEmptyContent()\n    }\n\n    // -> Format CSS Scripts\n    let scriptCss = ''\n    if (WIKI.auth.checkAccess(opts.user, ['write:styles'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      if (!_.isEmpty(opts.scriptCss)) {\n        scriptCss = new CleanCSS({ inline: false }).minify(opts.scriptCss).styles\n      } else {\n        scriptCss = ''\n      }\n    }\n\n    // -> Format JS Scripts\n    let scriptJs = ''\n    if (WIKI.auth.checkAccess(opts.user, ['write:scripts'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      scriptJs = opts.scriptJs || ''\n    }\n\n    // -> Create page\n    await WIKI.models.pages.query().insert({\n      authorId: opts.user.id,\n      content: opts.content,\n      creatorId: opts.user.id,\n      contentType: _.get(_.find(WIKI.data.editors, ['key', opts.editor]), `contentType`, 'text'),\n      description: opts.description,\n      editorKey: opts.editor,\n      hash: pageHelper.generateHash({ path: opts.path, locale: opts.locale, privateNS: opts.isPrivate ? 'TODO' : '' }),\n      isPrivate: opts.isPrivate,\n      isPublished: opts.isPublished,\n      localeCode: opts.locale,\n      path: opts.path,\n      publishEndDate: opts.publishEndDate || '',\n      publishStartDate: opts.publishStartDate || '',\n      title: opts.title,\n      toc: '[]',\n      extra: JSON.stringify({\n        js: scriptJs,\n        css: scriptCss\n      })\n    })\n    const page = await WIKI.models.pages.getPageFromDb({\n      path: opts.path,\n      locale: opts.locale,\n      userId: opts.user.id,\n      isPrivate: opts.isPrivate\n    })\n\n    // -> Save Tags\n    if (opts.tags && opts.tags.length > 0) {\n      await WIKI.models.tags.associateTags({ tags: opts.tags, page })\n    }\n\n    // -> Render page to HTML\n    await WIKI.models.pages.renderPage(page)\n\n    // -> Rebuild page tree\n    await WIKI.models.pages.rebuildTree()\n\n    // -> Add to Search Index\n    const pageContents = await WIKI.models.pages.query().findById(page.id).select('render')\n    page.safeContent = WIKI.models.pages.cleanHTML(pageContents.render)\n    await WIKI.data.searchEngine.created(page)\n\n    // -> Add to Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'created',\n        page\n      })\n    }\n\n    // -> Reconnect Links\n    await WIKI.models.pages.reconnectLinks({\n      locale: page.localeCode,\n      path: page.path,\n      mode: 'create'\n    })\n\n    // -> Get latest updatedAt\n    page.updatedAt = await WIKI.models.pages.query().findById(page.id).select('updatedAt').then(r => r.updatedAt)\n\n    return page\n  }\n\n  /**\n   * Update an Existing Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async updatePage(opts) {\n    // -> Fetch original page\n    const ogPage = await WIKI.models.pages.query().findById(opts.id)\n    if (!ogPage) {\n      throw new Error('Invalid Page Id')\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      throw new WIKI.Error.PageUpdateForbidden()\n    }\n\n    // -> Check for empty content\n    if (!opts.content || _.trim(opts.content).length < 1) {\n      throw new WIKI.Error.PageEmptyContent()\n    }\n\n    // -> Create version snapshot\n    await WIKI.models.pageHistory.addVersion({\n      ...ogPage,\n      isPublished: ogPage.isPublished === true || ogPage.isPublished === 1,\n      action: opts.action ? opts.action : 'updated',\n      versionDate: ogPage.updatedAt\n    })\n\n    // -> Format Extra Properties\n    if (!_.isPlainObject(ogPage.extra)) {\n      ogPage.extra = {}\n    }\n\n    // -> Format CSS Scripts\n    let scriptCss = _.get(ogPage, 'extra.css', '')\n    if (WIKI.auth.checkAccess(opts.user, ['write:styles'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      if (!_.isEmpty(opts.scriptCss)) {\n        scriptCss = new CleanCSS({ inline: false }).minify(opts.scriptCss).styles\n      } else {\n        scriptCss = ''\n      }\n    }\n\n    // -> Format JS Scripts\n    let scriptJs = _.get(ogPage, 'extra.js', '')\n    if (WIKI.auth.checkAccess(opts.user, ['write:scripts'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      scriptJs = opts.scriptJs || ''\n    }\n\n    // -> Update page\n    await WIKI.models.pages.query().patch({\n      authorId: opts.user.id,\n      content: opts.content,\n      description: opts.description,\n      isPublished: opts.isPublished === true || opts.isPublished === 1,\n      publishEndDate: opts.publishEndDate || '',\n      publishStartDate: opts.publishStartDate || '',\n      title: opts.title,\n      extra: JSON.stringify({\n        ...ogPage.extra,\n        js: scriptJs,\n        css: scriptCss\n      })\n    }).where('id', ogPage.id)\n    let page = await WIKI.models.pages.getPageFromDb(ogPage.id)\n\n    // -> Save Tags\n    await WIKI.models.tags.associateTags({ tags: opts.tags, page })\n\n    // -> Render page to HTML\n    await WIKI.models.pages.renderPage(page)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Update Search Index\n    const pageContents = await WIKI.models.pages.query().findById(page.id).select('render')\n    page.safeContent = WIKI.models.pages.cleanHTML(pageContents.render)\n    await WIKI.data.searchEngine.updated(page)\n\n    // -> Update on Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'updated',\n        page\n      })\n    }\n\n    // -> Perform move?\n    if ((opts.locale && opts.locale !== page.localeCode) || (opts.path && opts.path !== page.path)) {\n      await WIKI.models.pages.movePage({\n        id: page.id,\n        destinationLocale: opts.locale,\n        destinationPath: opts.path,\n        user: opts.user\n      })\n    } else {\n      // -> Update title of page tree entry\n      await WIKI.models.knex.table('pageTree').where({\n        pageId: page.id\n      }).update('title', page.title)\n    }\n\n    // -> Get latest updatedAt\n    page.updatedAt = await WIKI.models.pages.query().findById(page.id).select('updatedAt').then(r => r.updatedAt)\n\n    return page\n  }\n\n  /**\n   * Convert an Existing Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async convertPage(opts) {\n    // -> Fetch original page\n    const ogPage = await WIKI.models.pages.query().findById(opts.id)\n    if (!ogPage) {\n      throw new Error('Invalid Page Id')\n    }\n\n    if (ogPage.editorKey === opts.editor) {\n      throw new Error('Page is already using this editor. Nothing to convert.')\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: ogPage.localeCode,\n      path: ogPage.path\n    })) {\n      throw new WIKI.Error.PageUpdateForbidden()\n    }\n\n    // -> Check content type\n    const sourceContentType = ogPage.contentType\n    const targetContentType = _.get(_.find(WIKI.data.editors, ['key', opts.editor]), `contentType`, 'text')\n    const shouldConvert = sourceContentType !== targetContentType\n    let convertedContent = null\n\n    // -> Convert content\n    if (shouldConvert) {\n      // -> Markdown => HTML\n      if (sourceContentType === 'markdown' && targetContentType === 'html') {\n        if (!ogPage.render) {\n          throw new Error('Aborted conversion because rendered page content is empty!')\n        }\n        convertedContent = ogPage.render\n\n        const $ = cheerio.load(convertedContent, {\n          decodeEntities: true\n        })\n\n        if ($.root().children().length > 0) {\n          // Remove header anchors\n          $('.toc-anchor').remove()\n\n          // Attempt to convert tabsets\n          $('tabset').each((tabI, tabElm) => {\n            const tabHeaders = []\n            // -> Extract templates\n            $(tabElm).children('template').each((tmplI, tmplElm) => {\n              if ($(tmplElm).attr('v-slot:tabs') === '') {\n                $(tabElm).before('<ul class=\"tabset-headers\">' + $(tmplElm).html() + '</ul>')\n              } else {\n                $(tabElm).after('<div class=\"markdown-tabset\">' + $(tmplElm).html() + '</div>')\n              }\n            })\n            // -> Parse tab headers\n            $(tabElm).prev('.tabset-headers').children((i, elm) => {\n              tabHeaders.push($(elm).html())\n            })\n            $(tabElm).prev('.tabset-headers').remove()\n            // -> Inject tab headers\n            $(tabElm).next('.markdown-tabset').children((i, elm) => {\n              if (tabHeaders.length > i) {\n                $(elm).prepend(`<h2>${tabHeaders[i]}</h2>`)\n              }\n            })\n            $(tabElm).next('.markdown-tabset').prepend('<h1>Tabset</h1>')\n            $(tabElm).remove()\n          })\n\n          convertedContent = $.html('body').replace('<body>', '').replace('</body>', '').replace(/&#x([0-9a-f]{1,6});/ig, (entity, code) => {\n            code = parseInt(code, 16)\n\n            // Don't unescape ASCII characters, assuming they're encoded for a good reason\n            if (code < 0x80) return entity\n\n            return String.fromCodePoint(code)\n          })\n        }\n\n      // -> HTML => Markdown\n      } else if (sourceContentType === 'html' && targetContentType === 'markdown') {\n        const td = new TurndownService({\n          bulletListMarker: '-',\n          codeBlockStyle: 'fenced',\n          emDelimiter: '*',\n          fence: '```',\n          headingStyle: 'atx',\n          hr: '---',\n          linkStyle: 'inlined',\n          preformattedCode: true,\n          strongDelimiter: '**'\n        })\n\n        td.use(turndownPluginGfm)\n\n        td.keep(['kbd'])\n\n        td.addRule('subscript', {\n          filter: ['sub'],\n          replacement: c => `~${c}~`\n        })\n\n        td.addRule('superscript', {\n          filter: ['sup'],\n          replacement: c => `^${c}^`\n        })\n\n        td.addRule('underline', {\n          filter: ['u'],\n          replacement: c => `_${c}_`\n        })\n\n        td.addRule('taskList', {\n          filter: (n, o) => {\n            return n.nodeName === 'INPUT' && n.getAttribute('type') === 'checkbox'\n          },\n          replacement: (c, n) => {\n            return n.getAttribute('checked') ? '[x] ' : '[ ] '\n          }\n        })\n\n        td.addRule('removeTocAnchors', {\n          filter: (n, o) => {\n            return n.nodeName === 'A' && n.classList.contains('toc-anchor')\n          },\n          replacement: c => ''\n        })\n\n        convertedContent = td.turndown(ogPage.content)\n      // -> Unsupported\n      } else {\n        throw new Error('Unsupported source / destination content types combination.')\n      }\n    }\n\n    // -> Create version snapshot\n    if (shouldConvert) {\n      await WIKI.models.pageHistory.addVersion({\n        ...ogPage,\n        isPublished: ogPage.isPublished === true || ogPage.isPublished === 1,\n        action: 'updated',\n        versionDate: ogPage.updatedAt\n      })\n    }\n\n    // -> Update page\n    await WIKI.models.pages.query().patch({\n      contentType: targetContentType,\n      editorKey: opts.editor,\n      ...(convertedContent ? { content: convertedContent } : {})\n    }).where('id', ogPage.id)\n    const page = await WIKI.models.pages.getPageFromDb(ogPage.id)\n\n    await WIKI.models.pages.deletePageFromCache(page.hash)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Update on Storage\n    await WIKI.models.storage.pageEvent({\n      event: 'updated',\n      page\n    })\n  }\n\n  /**\n   * Move a Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise with no value\n   */\n  static async movePage(opts) {\n    let page\n    if (_.has(opts, 'id')) {\n      page = await WIKI.models.pages.query().findById(opts.id)\n    } else {\n      page = await WIKI.models.pages.query().findOne({\n        path: opts.path,\n        localeCode: opts.locale\n      })\n    }\n    if (!page) {\n      throw new WIKI.Error.PageNotFound()\n    }\n\n    // -> Validate path\n    if (opts.destinationPath.includes('.') || opts.destinationPath.includes(' ') || opts.destinationPath.includes('\\\\') || opts.destinationPath.includes('//')) {\n      throw new WIKI.Error.PageIllegalPath()\n    }\n\n    // -> Remove trailing slash\n    if (opts.destinationPath.endsWith('/')) {\n      opts.destinationPath = opts.destinationPath.slice(0, -1)\n    }\n\n    // -> Remove starting slash\n    if (opts.destinationPath.startsWith('/')) {\n      opts.destinationPath = opts.destinationPath.slice(1)\n    }\n\n    // -> Check for source page access\n    if (!WIKI.auth.checkAccess(opts.user, ['manage:pages'], {\n      locale: page.localeCode,\n      path: page.path\n    })) {\n      throw new WIKI.Error.PageMoveForbidden()\n    }\n    // -> Check for destination page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: opts.destinationLocale,\n      path: opts.destinationPath\n    })) {\n      throw new WIKI.Error.PageMoveForbidden()\n    }\n\n    // -> Check for existing page at destination path\n    const destPage = await WIKI.models.pages.query().findOne({\n      path: opts.destinationPath,\n      localeCode: opts.destinationLocale\n    })\n    if (destPage) {\n      throw new WIKI.Error.PagePathCollision()\n    }\n\n    // -> Create version snapshot\n    await WIKI.models.pageHistory.addVersion({\n      ...page,\n      action: 'moved',\n      versionDate: page.updatedAt\n    })\n\n    const destinationHash = pageHelper.generateHash({ path: opts.destinationPath, locale: opts.destinationLocale, privateNS: opts.isPrivate ? 'TODO' : '' })\n\n    // -> Move page\n    const destinationTitle = (page.title === page.path ? opts.destinationPath : page.title)\n    await WIKI.models.pages.query().patch({\n      path: opts.destinationPath,\n      localeCode: opts.destinationLocale,\n      title: destinationTitle,\n      hash: destinationHash\n    }).findById(page.id)\n    await WIKI.models.pages.deletePageFromCache(page.hash)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Rebuild page tree\n    await WIKI.models.pages.rebuildTree()\n\n    // -> Rename in Search Index\n    const pageContents = await WIKI.models.pages.query().findById(page.id).select('render')\n    page.safeContent = WIKI.models.pages.cleanHTML(pageContents.render)\n    await WIKI.data.searchEngine.renamed({\n      ...page,\n      destinationPath: opts.destinationPath,\n      destinationLocaleCode: opts.destinationLocale,\n      destinationHash\n    })\n\n    // -> Rename in Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'renamed',\n        page: {\n          ...page,\n          destinationPath: opts.destinationPath,\n          destinationLocaleCode: opts.destinationLocale,\n          destinationHash,\n          moveAuthorId: opts.user.id,\n          moveAuthorName: opts.user.name,\n          moveAuthorEmail: opts.user.email\n        }\n      })\n    }\n\n    // -> Reconnect Links : Changing old links to the new path\n    await WIKI.models.pages.reconnectLinks({\n      sourceLocale: page.localeCode,\n      sourcePath: page.path,\n      locale: opts.destinationLocale,\n      path: opts.destinationPath,\n      mode: 'move'\n    })\n\n    // -> Reconnect Links : Validate invalid links to the new path\n    await WIKI.models.pages.reconnectLinks({\n      locale: opts.destinationLocale,\n      path: opts.destinationPath,\n      mode: 'create'\n    })\n  }\n\n  /**\n   * Delete an Existing Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise with no value\n   */\n  static async deletePage(opts) {\n    let page\n    if (_.has(opts, 'id')) {\n      page = await WIKI.models.pages.query().findById(opts.id)\n    } else {\n      page = await WIKI.models.pages.query().findOne({\n        path: opts.path,\n        localeCode: opts.locale\n      })\n    }\n    if (!page) {\n      throw new WIKI.Error.PageNotFound()\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['delete:pages'], {\n      locale: page.locale,\n      path: page.path\n    })) {\n      throw new WIKI.Error.PageDeleteForbidden()\n    }\n\n    // -> Create version snapshot\n    await WIKI.models.pageHistory.addVersion({\n      ...page,\n      action: 'deleted',\n      versionDate: page.updatedAt\n    })\n\n    // -> Delete page\n    await WIKI.models.pages.query().delete().where('id', page.id)\n    await WIKI.models.pages.deletePageFromCache(page.hash)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Rebuild page tree\n    await WIKI.models.pages.rebuildTree()\n\n    // -> Delete from Search Index\n    await WIKI.data.searchEngine.deleted(page)\n\n    // -> Delete from Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'deleted',\n        page\n      })\n    }\n\n    // -> Reconnect Links\n    await WIKI.models.pages.reconnectLinks({\n      locale: page.localeCode,\n      path: page.path,\n      mode: 'delete'\n    })\n  }\n\n  /**\n   * Reconnect links to new/move/deleted page\n   *\n   * @param {Object} opts - Page parameters\n   * @param {string} opts.path - Page Path\n   * @param {string} opts.locale - Page Locale Code\n   * @param {string} [opts.sourcePath] - Previous Page Path (move only)\n   * @param {string} [opts.sourceLocale] - Previous Page Locale Code (move only)\n   * @param {string} opts.mode - Page Update mode (create, move, delete)\n   * @returns {Promise} Promise with no value\n   */\n  static async reconnectLinks (opts) {\n    const pageHref = `/${opts.locale}/${opts.path}`\n    let replaceArgs = {\n      from: '',\n      to: ''\n    }\n    switch (opts.mode) {\n      case 'create':\n        replaceArgs.from = `<a href=\"${pageHref}\" class=\"is-internal-link is-invalid-page\">`\n        replaceArgs.to = `<a href=\"${pageHref}\" class=\"is-internal-link is-valid-page\">`\n        break\n      case 'move':\n        const prevPageHref = `/${opts.sourceLocale}/${opts.sourcePath}`\n        replaceArgs.from = `<a href=\"${prevPageHref}\" class=\"is-internal-link is-valid-page\">`\n        replaceArgs.to = `<a href=\"${pageHref}\" class=\"is-internal-link is-valid-page\">`\n        break\n      case 'delete':\n        replaceArgs.from = `<a href=\"${pageHref}\" class=\"is-internal-link is-valid-page\">`\n        replaceArgs.to = `<a href=\"${pageHref}\" class=\"is-internal-link is-invalid-page\">`\n        break\n      default:\n        return false\n    }\n\n    let affectedHashes = []\n    // -> Perform replace and return affected page hashes (POSTGRES only)\n    if (WIKI.config.db.type === 'postgres') {\n      const qryHashes = await WIKI.models.pages.query()\n        .returning('hash')\n        .patch({\n          render: WIKI.models.knex.raw('REPLACE(??, ?, ?)', ['render', replaceArgs.from, replaceArgs.to])\n        })\n        .whereIn('pages.id', function () {\n          this.select('pageLinks.pageId').from('pageLinks').where({\n            'pageLinks.path': opts.path,\n            'pageLinks.localeCode': opts.locale\n          })\n        })\n      affectedHashes = qryHashes.map(h => h.hash)\n    } else {\n      // -> Perform replace, then query affected page hashes (MYSQL, MARIADB, MSSQL, SQLITE only)\n      await WIKI.models.pages.query()\n        .patch({\n          render: WIKI.models.knex.raw('REPLACE(??, ?, ?)', ['render', replaceArgs.from, replaceArgs.to])\n        })\n        .whereIn('pages.id', function () {\n          this.select('pageLinks.pageId').from('pageLinks').where({\n            'pageLinks.path': opts.path,\n            'pageLinks.localeCode': opts.locale\n          })\n        })\n      const qryHashes = await WIKI.models.pages.query()\n        .column('hash')\n        .whereIn('pages.id', function () {\n          this.select('pageLinks.pageId').from('pageLinks').where({\n            'pageLinks.path': opts.path,\n            'pageLinks.localeCode': opts.locale\n          })\n        })\n      affectedHashes = qryHashes.map(h => h.hash)\n    }\n    for (const hash of affectedHashes) {\n      await WIKI.models.pages.deletePageFromCache(hash)\n      WIKI.events.outbound.emit('deletePageFromCache', hash)\n    }\n  }\n\n  /**\n   * Rebuild page tree for new/updated/deleted page\n   *\n   * @returns {Promise} Promise with no value\n   */\n  static async rebuildTree() {\n    const rebuildJob = await WIKI.scheduler.registerJob({\n      name: 'rebuild-tree',\n      immediate: true,\n      worker: true\n    })\n    return rebuildJob.finished\n  }\n\n  /**\n   * Trigger the rendering of a page\n   *\n   * @param {Object} page Page Model Instance\n   * @returns {Promise} Promise with no value\n   */\n  static async renderPage(page) {\n    const renderJob = await WIKI.scheduler.registerJob({\n      name: 'render-page',\n      immediate: true,\n      worker: true\n    }, page.id)\n    return renderJob.finished\n  }\n\n  /**\n   * Fetch an Existing Page from Cache if possible, from DB otherwise and save render to Cache\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async getPage(opts) {\n    // -> Get from cache first\n    let page = await WIKI.models.pages.getPageFromCache(opts)\n    if (!page) {\n      // -> Get from DB\n      page = await WIKI.models.pages.getPageFromDb(opts)\n      if (page) {\n        if (page.render) {\n          // -> Save render to cache\n          await WIKI.models.pages.savePageToCache(page)\n        } else {\n          // -> No render? Possible duplicate issue\n          /* TODO: Detect duplicate and delete */\n          throw new Error('Error while fetching page. Duplicate entry detected. Reload the page to try again.')\n        }\n      }\n    }\n    return page\n  }\n\n  /**\n   * Fetch an Existing Page from the Database\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async getPageFromDb(opts) {\n    const queryModeID = _.isNumber(opts)\n    try {\n      return WIKI.models.pages.query()\n        .column([\n          'pages.id',\n          'pages.path',\n          'pages.hash',\n          'pages.title',\n          'pages.description',\n          'pages.isPrivate',\n          'pages.isPublished',\n          'pages.privateNS',\n          'pages.publishStartDate',\n          'pages.publishEndDate',\n          'pages.content',\n          'pages.render',\n          'pages.toc',\n          'pages.contentType',\n          'pages.createdAt',\n          'pages.updatedAt',\n          'pages.editorKey',\n          'pages.localeCode',\n          'pages.authorId',\n          'pages.creatorId',\n          'pages.extra',\n          {\n            authorName: 'author.name',\n            authorEmail: 'author.email',\n            creatorName: 'creator.name',\n            creatorEmail: 'creator.email'\n          }\n        ])\n        .joinRelated('author')\n        .joinRelated('creator')\n        .withGraphJoined('tags')\n        .modifyGraph('tags', builder => {\n          builder.select('tag', 'title')\n        })\n        .where(queryModeID ? {\n          'pages.id': opts\n        } : {\n          'pages.path': opts.path,\n          'pages.localeCode': opts.locale\n        })\n        // .andWhere(builder => {\n        //   if (queryModeID) return\n        //   builder.where({\n        //     'pages.isPublished': true\n        //   }).orWhere({\n        //     'pages.isPublished': false,\n        //     'pages.authorId': opts.userId\n        //   })\n        // })\n        // .andWhere(builder => {\n        //   if (queryModeID) return\n        //   if (opts.isPrivate) {\n        //     builder.where({ 'pages.isPrivate': true, 'pages.privateNS': opts.privateNS })\n        //   } else {\n        //     builder.where({ 'pages.isPrivate': false })\n        //   }\n        // })\n        .first()\n    } catch (err) {\n      WIKI.logger.warn(err)\n      throw err\n    }\n  }\n\n  /**\n   * Save a Page Model Instance to Cache\n   *\n   * @param {Object} page Page Model Instance\n   * @returns {Promise} Promise with no value\n   */\n  static async savePageToCache(page) {\n    const cachePath = path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache/${page.hash}.bin`)\n    await fs.outputFile(cachePath, WIKI.models.pages.cacheSchema.encode({\n      id: page.id,\n      authorId: page.authorId,\n      authorName: page.authorName,\n      createdAt: page.createdAt,\n      creatorId: page.creatorId,\n      creatorName: page.creatorName,\n      description: page.description,\n      editorKey: page.editorKey,\n      extra: {\n        css: _.get(page, 'extra.css', ''),\n        js: _.get(page, 'extra.js', '')\n      },\n      isPrivate: page.isPrivate === 1 || page.isPrivate === true,\n      isPublished: page.isPublished === 1 || page.isPublished === true,\n      publishEndDate: page.publishEndDate,\n      publishStartDate: page.publishStartDate,\n      render: page.render,\n      tags: page.tags.map(t => _.pick(t, ['tag', 'title'])),\n      title: page.title,\n      toc: _.isString(page.toc) ? page.toc : JSON.stringify(page.toc),\n      updatedAt: page.updatedAt\n    }))\n  }\n\n  /**\n   * Fetch an Existing Page from Cache\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async getPageFromCache(opts) {\n    const pageHash = pageHelper.generateHash({ path: opts.path, locale: opts.locale, privateNS: opts.isPrivate ? 'TODO' : '' })\n    const cachePath = path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache/${pageHash}.bin`)\n\n    try {\n      const pageBuffer = await fs.readFile(cachePath)\n      let page = WIKI.models.pages.cacheSchema.decode(pageBuffer)\n      return {\n        ...page,\n        path: opts.path,\n        localeCode: opts.locale,\n        isPrivate: opts.isPrivate\n      }\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return false\n      }\n      WIKI.logger.error(err)\n      throw err\n    }\n  }\n\n  /**\n   * Delete an Existing Page from Cache\n   *\n   * @param {String} page Page Unique Hash\n   * @returns {Promise} Promise with no value\n   */\n  static async deletePageFromCache(hash) {\n    return fs.remove(path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache/${hash}.bin`))\n  }\n\n  /**\n   * Flush the contents of the Cache\n   */\n  static async flushCache() {\n    return fs.emptyDir(path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache`))\n  }\n\n  /**\n   * Migrate all pages from a source locale to the target locale\n   *\n   * @param {Object} opts Migration properties\n   * @param {string} opts.sourceLocale Source Locale Code\n   * @param {string} opts.targetLocale Target Locale Code\n   * @returns {Promise} Promise with no value\n   */\n  static async migrateToLocale({ sourceLocale, targetLocale }) {\n    return WIKI.models.pages.query()\n      .patch({\n        localeCode: targetLocale\n      })\n      .where({\n        localeCode: sourceLocale\n      })\n      .whereNotExists(function() {\n        this.select('id').from('pages AS pagesm').where('pagesm.localeCode', targetLocale).andWhereRaw('pagesm.path = pages.path')\n      })\n  }\n\n  /**\n   * Clean raw HTML from content for use in search engines\n   *\n   * @param {string} rawHTML Raw HTML\n   * @returns {string} Cleaned Content Text\n   */\n  static cleanHTML(rawHTML = '') {\n    let data = striptags(rawHTML || '', [], ' ')\n      .replace(emojiRegex(), '')\n      // .replace(htmlEntitiesRegex, '')\n    return he.decode(data)\n      .replace(punctuationRegex, ' ')\n      .replace(/(\\r\\n|\\n|\\r)/gm, ' ')\n      .replace(/\\s\\s+/g, ' ')\n      .split(' ').filter(w => w.length > 1).join(' ').toLowerCase()\n  }\n\n  /**\n   * Subscribe to HA propagation events\n   */\n  static subscribeToEvents() {\n    WIKI.events.inbound.on('deletePageFromCache', hash => {\n      WIKI.models.pages.deletePageFromCache(hash)\n    })\n    WIKI.events.inbound.on('flushCache', () => {\n      WIKI.models.pages.flushCache()\n    })\n  }\n}\n"], "fixing_code": ["const Model = require('objection').Model\nconst _ = require('lodash')\nconst JSBinType = require('js-binary').Type\nconst pageHelper = require('../helpers/page')\nconst path = require('path')\nconst fs = require('fs-extra')\nconst yaml = require('js-yaml')\nconst striptags = require('striptags')\nconst emojiRegex = require('emoji-regex')\nconst he = require('he')\nconst CleanCSS = require('clean-css')\nconst TurndownService = require('turndown')\nconst turndownPluginGfm = require('@joplin/turndown-plugin-gfm').gfm\nconst cheerio = require('cheerio')\n\n/* global WIKI */\n\nconst frontmatterRegex = {\n  html: /^(<!-{2}(?:\\n|\\r)([\\w\\W]+?)(?:\\n|\\r)-{2}>)?(?:\\n|\\r)*([\\w\\W]*)*/,\n  legacy: /^(<!-- TITLE: ?([\\w\\W]+?) ?-{2}>)?(?:\\n|\\r)?(<!-- SUBTITLE: ?([\\w\\W]+?) ?-{2}>)?(?:\\n|\\r)*([\\w\\W]*)*/i,\n  markdown: /^(-{3}(?:\\n|\\r)([\\w\\W]+?)(?:\\n|\\r)-{3})?(?:\\n|\\r)*([\\w\\W]*)*/\n}\n\nconst punctuationRegex = /[!,:;/\\\\_+\\-=()&#@<>$~%^*[\\]{}\"'|]+|(\\.\\s)|(\\s\\.)/ig\n// const htmlEntitiesRegex = /(&#[0-9]{3};)|(&#x[a-zA-Z0-9]{2};)/ig\n\n/**\n * Pages model\n */\nmodule.exports = class Page extends Model {\n  static get tableName() { return 'pages' }\n\n  static get jsonSchema () {\n    return {\n      type: 'object',\n      required: ['path', 'title'],\n\n      properties: {\n        id: {type: 'integer'},\n        path: {type: 'string'},\n        hash: {type: 'string'},\n        title: {type: 'string'},\n        description: {type: 'string'},\n        isPublished: {type: 'boolean'},\n        privateNS: {type: 'string'},\n        publishStartDate: {type: 'string'},\n        publishEndDate: {type: 'string'},\n        content: {type: 'string'},\n        contentType: {type: 'string'},\n\n        createdAt: {type: 'string'},\n        updatedAt: {type: 'string'}\n      }\n    }\n  }\n\n  static get jsonAttributes() {\n    return ['extra']\n  }\n\n  static get relationMappings() {\n    return {\n      tags: {\n        relation: Model.ManyToManyRelation,\n        modelClass: require('./tags'),\n        join: {\n          from: 'pages.id',\n          through: {\n            from: 'pageTags.pageId',\n            to: 'pageTags.tagId'\n          },\n          to: 'tags.id'\n        }\n      },\n      links: {\n        relation: Model.HasManyRelation,\n        modelClass: require('./pageLinks'),\n        join: {\n          from: 'pages.id',\n          to: 'pageLinks.pageId'\n        }\n      },\n      author: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./users'),\n        join: {\n          from: 'pages.authorId',\n          to: 'users.id'\n        }\n      },\n      creator: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./users'),\n        join: {\n          from: 'pages.creatorId',\n          to: 'users.id'\n        }\n      },\n      editor: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./editors'),\n        join: {\n          from: 'pages.editorKey',\n          to: 'editors.key'\n        }\n      },\n      locale: {\n        relation: Model.BelongsToOneRelation,\n        modelClass: require('./locales'),\n        join: {\n          from: 'pages.localeCode',\n          to: 'locales.code'\n        }\n      }\n    }\n  }\n\n  $beforeUpdate() {\n    this.updatedAt = new Date().toISOString()\n  }\n  $beforeInsert() {\n    this.createdAt = new Date().toISOString()\n    this.updatedAt = new Date().toISOString()\n  }\n  /**\n   * Solving the violates foreign key constraint using cascade strategy\n   * using static hooks\n   * @see https://vincit.github.io/objection.js/api/types/#type-statichookarguments\n   */\n  static async beforeDelete({ asFindQuery }) {\n    const page = await asFindQuery().select('id')\n    await WIKI.models.comments.query().delete().where('pageId', page[0].id)\n  }\n  /**\n   * Cache Schema\n   */\n  static get cacheSchema() {\n    return new JSBinType({\n      id: 'uint',\n      authorId: 'uint',\n      authorName: 'string',\n      createdAt: 'string',\n      creatorId: 'uint',\n      creatorName: 'string',\n      description: 'string',\n      editorKey: 'string',\n      isPrivate: 'boolean',\n      isPublished: 'boolean',\n      publishEndDate: 'string',\n      publishStartDate: 'string',\n      render: 'string',\n      tags: [\n        {\n          tag: 'string',\n          title: 'string'\n        }\n      ],\n      extra: {\n        js: 'string',\n        css: 'string'\n      },\n      title: 'string',\n      toc: 'string',\n      updatedAt: 'string'\n    })\n  }\n\n  /**\n   * Inject page metadata into contents\n   *\n   * @returns {string} Page Contents with Injected Metadata\n   */\n  injectMetadata () {\n    return pageHelper.injectPageMetadata(this)\n  }\n\n  /**\n   * Get the page's file extension based on content type\n   *\n   * @returns {string} File Extension\n   */\n  getFileExtension() {\n    return pageHelper.getFileExtension(this.contentType)\n  }\n\n  /**\n   * Parse injected page metadata from raw content\n   *\n   * @param {String} raw Raw file contents\n   * @param {String} contentType Content Type\n   * @returns {Object} Parsed Page Metadata with Raw Content\n   */\n  static parseMetadata (raw, contentType) {\n    let result\n    switch (contentType) {\n      case 'markdown':\n        result = frontmatterRegex.markdown.exec(raw)\n        if (result[2]) {\n          return {\n            ...yaml.safeLoad(result[2]),\n            content: result[3]\n          }\n        } else {\n          // Attempt legacy v1 format\n          result = frontmatterRegex.legacy.exec(raw)\n          if (result[2]) {\n            return {\n              title: result[2],\n              description: result[4],\n              content: result[5]\n            }\n          }\n        }\n        break\n      case 'html':\n        result = frontmatterRegex.html.exec(raw)\n        if (result[2]) {\n          return {\n            ...yaml.safeLoad(result[2]),\n            content: result[3]\n          }\n        }\n        break\n    }\n    return {\n      content: raw\n    }\n  }\n\n  /**\n   * Create a New Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async createPage(opts) {\n    // -> Validate path\n    if (opts.path.includes('.') || opts.path.includes(' ') || opts.path.includes('\\\\') || opts.path.includes('//')) {\n      throw new WIKI.Error.PageIllegalPath()\n    }\n\n    // -> Remove trailing slash\n    if (opts.path.endsWith('/')) {\n      opts.path = opts.path.slice(0, -1)\n    }\n\n    // -> Remove starting slash\n    if (opts.path.startsWith('/')) {\n      opts.path = opts.path.slice(1)\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      throw new WIKI.Error.PageDeleteForbidden()\n    }\n\n    // -> Check for duplicate\n    const dupCheck = await WIKI.models.pages.query().select('id').where('localeCode', opts.locale).where('path', opts.path).first()\n    if (dupCheck) {\n      throw new WIKI.Error.PageDuplicateCreate()\n    }\n\n    // -> Check for empty content\n    if (!opts.content || _.trim(opts.content).length < 1) {\n      throw new WIKI.Error.PageEmptyContent()\n    }\n\n    // -> Format CSS Scripts\n    let scriptCss = ''\n    if (WIKI.auth.checkAccess(opts.user, ['write:styles'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      if (!_.isEmpty(opts.scriptCss)) {\n        scriptCss = new CleanCSS({ inline: false }).minify(opts.scriptCss).styles\n      } else {\n        scriptCss = ''\n      }\n    }\n\n    // -> Format JS Scripts\n    let scriptJs = ''\n    if (WIKI.auth.checkAccess(opts.user, ['write:scripts'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      scriptJs = opts.scriptJs || ''\n    }\n\n    // -> Create page\n    await WIKI.models.pages.query().insert({\n      authorId: opts.user.id,\n      content: opts.content,\n      creatorId: opts.user.id,\n      contentType: _.get(_.find(WIKI.data.editors, ['key', opts.editor]), `contentType`, 'text'),\n      description: opts.description,\n      editorKey: opts.editor,\n      hash: pageHelper.generateHash({ path: opts.path, locale: opts.locale, privateNS: opts.isPrivate ? 'TODO' : '' }),\n      isPrivate: opts.isPrivate,\n      isPublished: opts.isPublished,\n      localeCode: opts.locale,\n      path: opts.path,\n      publishEndDate: opts.publishEndDate || '',\n      publishStartDate: opts.publishStartDate || '',\n      title: opts.title,\n      toc: '[]',\n      extra: JSON.stringify({\n        js: scriptJs,\n        css: scriptCss\n      })\n    })\n    const page = await WIKI.models.pages.getPageFromDb({\n      path: opts.path,\n      locale: opts.locale,\n      userId: opts.user.id,\n      isPrivate: opts.isPrivate\n    })\n\n    // -> Save Tags\n    if (opts.tags && opts.tags.length > 0) {\n      await WIKI.models.tags.associateTags({ tags: opts.tags, page })\n    }\n\n    // -> Render page to HTML\n    await WIKI.models.pages.renderPage(page)\n\n    // -> Rebuild page tree\n    await WIKI.models.pages.rebuildTree()\n\n    // -> Add to Search Index\n    const pageContents = await WIKI.models.pages.query().findById(page.id).select('render')\n    page.safeContent = WIKI.models.pages.cleanHTML(pageContents.render)\n    await WIKI.data.searchEngine.created(page)\n\n    // -> Add to Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'created',\n        page\n      })\n    }\n\n    // -> Reconnect Links\n    await WIKI.models.pages.reconnectLinks({\n      locale: page.localeCode,\n      path: page.path,\n      mode: 'create'\n    })\n\n    // -> Get latest updatedAt\n    page.updatedAt = await WIKI.models.pages.query().findById(page.id).select('updatedAt').then(r => r.updatedAt)\n\n    return page\n  }\n\n  /**\n   * Update an Existing Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async updatePage(opts) {\n    // -> Fetch original page\n    const ogPage = await WIKI.models.pages.query().findById(opts.id)\n    if (!ogPage) {\n      throw new Error('Invalid Page Id')\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: ogPage.localeCode,\n      path: ogPage.path\n    })) {\n      throw new WIKI.Error.PageUpdateForbidden()\n    }\n\n    // -> Check for empty content\n    if (!opts.content || _.trim(opts.content).length < 1) {\n      throw new WIKI.Error.PageEmptyContent()\n    }\n\n    // -> Create version snapshot\n    await WIKI.models.pageHistory.addVersion({\n      ...ogPage,\n      isPublished: ogPage.isPublished === true || ogPage.isPublished === 1,\n      action: opts.action ? opts.action : 'updated',\n      versionDate: ogPage.updatedAt\n    })\n\n    // -> Format Extra Properties\n    if (!_.isPlainObject(ogPage.extra)) {\n      ogPage.extra = {}\n    }\n\n    // -> Format CSS Scripts\n    let scriptCss = _.get(ogPage, 'extra.css', '')\n    if (WIKI.auth.checkAccess(opts.user, ['write:styles'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      if (!_.isEmpty(opts.scriptCss)) {\n        scriptCss = new CleanCSS({ inline: false }).minify(opts.scriptCss).styles\n      } else {\n        scriptCss = ''\n      }\n    }\n\n    // -> Format JS Scripts\n    let scriptJs = _.get(ogPage, 'extra.js', '')\n    if (WIKI.auth.checkAccess(opts.user, ['write:scripts'], {\n      locale: opts.locale,\n      path: opts.path\n    })) {\n      scriptJs = opts.scriptJs || ''\n    }\n\n    // -> Update page\n    await WIKI.models.pages.query().patch({\n      authorId: opts.user.id,\n      content: opts.content,\n      description: opts.description,\n      isPublished: opts.isPublished === true || opts.isPublished === 1,\n      publishEndDate: opts.publishEndDate || '',\n      publishStartDate: opts.publishStartDate || '',\n      title: opts.title,\n      extra: JSON.stringify({\n        ...ogPage.extra,\n        js: scriptJs,\n        css: scriptCss\n      })\n    }).where('id', ogPage.id)\n    let page = await WIKI.models.pages.getPageFromDb(ogPage.id)\n\n    // -> Save Tags\n    await WIKI.models.tags.associateTags({ tags: opts.tags, page })\n\n    // -> Render page to HTML\n    await WIKI.models.pages.renderPage(page)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Update Search Index\n    const pageContents = await WIKI.models.pages.query().findById(page.id).select('render')\n    page.safeContent = WIKI.models.pages.cleanHTML(pageContents.render)\n    await WIKI.data.searchEngine.updated(page)\n\n    // -> Update on Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'updated',\n        page\n      })\n    }\n\n    // -> Perform move?\n    if ((opts.locale && opts.locale !== page.localeCode) || (opts.path && opts.path !== page.path)) {\n      // -> Check target path access\n      if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n        locale: opts.locale,\n        path: opts.path\n      })) {\n        throw new WIKI.Error.PageMoveForbidden()\n      }\n\n      await WIKI.models.pages.movePage({\n        id: page.id,\n        destinationLocale: opts.locale,\n        destinationPath: opts.path,\n        user: opts.user\n      })\n    } else {\n      // -> Update title of page tree entry\n      await WIKI.models.knex.table('pageTree').where({\n        pageId: page.id\n      }).update('title', page.title)\n    }\n\n    // -> Get latest updatedAt\n    page.updatedAt = await WIKI.models.pages.query().findById(page.id).select('updatedAt').then(r => r.updatedAt)\n\n    return page\n  }\n\n  /**\n   * Convert an Existing Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async convertPage(opts) {\n    // -> Fetch original page\n    const ogPage = await WIKI.models.pages.query().findById(opts.id)\n    if (!ogPage) {\n      throw new Error('Invalid Page Id')\n    }\n\n    if (ogPage.editorKey === opts.editor) {\n      throw new Error('Page is already using this editor. Nothing to convert.')\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: ogPage.localeCode,\n      path: ogPage.path\n    })) {\n      throw new WIKI.Error.PageUpdateForbidden()\n    }\n\n    // -> Check content type\n    const sourceContentType = ogPage.contentType\n    const targetContentType = _.get(_.find(WIKI.data.editors, ['key', opts.editor]), `contentType`, 'text')\n    const shouldConvert = sourceContentType !== targetContentType\n    let convertedContent = null\n\n    // -> Convert content\n    if (shouldConvert) {\n      // -> Markdown => HTML\n      if (sourceContentType === 'markdown' && targetContentType === 'html') {\n        if (!ogPage.render) {\n          throw new Error('Aborted conversion because rendered page content is empty!')\n        }\n        convertedContent = ogPage.render\n\n        const $ = cheerio.load(convertedContent, {\n          decodeEntities: true\n        })\n\n        if ($.root().children().length > 0) {\n          // Remove header anchors\n          $('.toc-anchor').remove()\n\n          // Attempt to convert tabsets\n          $('tabset').each((tabI, tabElm) => {\n            const tabHeaders = []\n            // -> Extract templates\n            $(tabElm).children('template').each((tmplI, tmplElm) => {\n              if ($(tmplElm).attr('v-slot:tabs') === '') {\n                $(tabElm).before('<ul class=\"tabset-headers\">' + $(tmplElm).html() + '</ul>')\n              } else {\n                $(tabElm).after('<div class=\"markdown-tabset\">' + $(tmplElm).html() + '</div>')\n              }\n            })\n            // -> Parse tab headers\n            $(tabElm).prev('.tabset-headers').children((i, elm) => {\n              tabHeaders.push($(elm).html())\n            })\n            $(tabElm).prev('.tabset-headers').remove()\n            // -> Inject tab headers\n            $(tabElm).next('.markdown-tabset').children((i, elm) => {\n              if (tabHeaders.length > i) {\n                $(elm).prepend(`<h2>${tabHeaders[i]}</h2>`)\n              }\n            })\n            $(tabElm).next('.markdown-tabset').prepend('<h1>Tabset</h1>')\n            $(tabElm).remove()\n          })\n\n          convertedContent = $.html('body').replace('<body>', '').replace('</body>', '').replace(/&#x([0-9a-f]{1,6});/ig, (entity, code) => {\n            code = parseInt(code, 16)\n\n            // Don't unescape ASCII characters, assuming they're encoded for a good reason\n            if (code < 0x80) return entity\n\n            return String.fromCodePoint(code)\n          })\n        }\n\n      // -> HTML => Markdown\n      } else if (sourceContentType === 'html' && targetContentType === 'markdown') {\n        const td = new TurndownService({\n          bulletListMarker: '-',\n          codeBlockStyle: 'fenced',\n          emDelimiter: '*',\n          fence: '```',\n          headingStyle: 'atx',\n          hr: '---',\n          linkStyle: 'inlined',\n          preformattedCode: true,\n          strongDelimiter: '**'\n        })\n\n        td.use(turndownPluginGfm)\n\n        td.keep(['kbd'])\n\n        td.addRule('subscript', {\n          filter: ['sub'],\n          replacement: c => `~${c}~`\n        })\n\n        td.addRule('superscript', {\n          filter: ['sup'],\n          replacement: c => `^${c}^`\n        })\n\n        td.addRule('underline', {\n          filter: ['u'],\n          replacement: c => `_${c}_`\n        })\n\n        td.addRule('taskList', {\n          filter: (n, o) => {\n            return n.nodeName === 'INPUT' && n.getAttribute('type') === 'checkbox'\n          },\n          replacement: (c, n) => {\n            return n.getAttribute('checked') ? '[x] ' : '[ ] '\n          }\n        })\n\n        td.addRule('removeTocAnchors', {\n          filter: (n, o) => {\n            return n.nodeName === 'A' && n.classList.contains('toc-anchor')\n          },\n          replacement: c => ''\n        })\n\n        convertedContent = td.turndown(ogPage.content)\n      // -> Unsupported\n      } else {\n        throw new Error('Unsupported source / destination content types combination.')\n      }\n    }\n\n    // -> Create version snapshot\n    if (shouldConvert) {\n      await WIKI.models.pageHistory.addVersion({\n        ...ogPage,\n        isPublished: ogPage.isPublished === true || ogPage.isPublished === 1,\n        action: 'updated',\n        versionDate: ogPage.updatedAt\n      })\n    }\n\n    // -> Update page\n    await WIKI.models.pages.query().patch({\n      contentType: targetContentType,\n      editorKey: opts.editor,\n      ...(convertedContent ? { content: convertedContent } : {})\n    }).where('id', ogPage.id)\n    const page = await WIKI.models.pages.getPageFromDb(ogPage.id)\n\n    await WIKI.models.pages.deletePageFromCache(page.hash)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Update on Storage\n    await WIKI.models.storage.pageEvent({\n      event: 'updated',\n      page\n    })\n  }\n\n  /**\n   * Move a Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise with no value\n   */\n  static async movePage(opts) {\n    let page\n    if (_.has(opts, 'id')) {\n      page = await WIKI.models.pages.query().findById(opts.id)\n    } else {\n      page = await WIKI.models.pages.query().findOne({\n        path: opts.path,\n        localeCode: opts.locale\n      })\n    }\n    if (!page) {\n      throw new WIKI.Error.PageNotFound()\n    }\n\n    // -> Validate path\n    if (opts.destinationPath.includes('.') || opts.destinationPath.includes(' ') || opts.destinationPath.includes('\\\\') || opts.destinationPath.includes('//')) {\n      throw new WIKI.Error.PageIllegalPath()\n    }\n\n    // -> Remove trailing slash\n    if (opts.destinationPath.endsWith('/')) {\n      opts.destinationPath = opts.destinationPath.slice(0, -1)\n    }\n\n    // -> Remove starting slash\n    if (opts.destinationPath.startsWith('/')) {\n      opts.destinationPath = opts.destinationPath.slice(1)\n    }\n\n    // -> Check for source page access\n    if (!WIKI.auth.checkAccess(opts.user, ['manage:pages'], {\n      locale: page.localeCode,\n      path: page.path\n    })) {\n      throw new WIKI.Error.PageMoveForbidden()\n    }\n    // -> Check for destination page access\n    if (!WIKI.auth.checkAccess(opts.user, ['write:pages'], {\n      locale: opts.destinationLocale,\n      path: opts.destinationPath\n    })) {\n      throw new WIKI.Error.PageMoveForbidden()\n    }\n\n    // -> Check for existing page at destination path\n    const destPage = await WIKI.models.pages.query().findOne({\n      path: opts.destinationPath,\n      localeCode: opts.destinationLocale\n    })\n    if (destPage) {\n      throw new WIKI.Error.PagePathCollision()\n    }\n\n    // -> Create version snapshot\n    await WIKI.models.pageHistory.addVersion({\n      ...page,\n      action: 'moved',\n      versionDate: page.updatedAt\n    })\n\n    const destinationHash = pageHelper.generateHash({ path: opts.destinationPath, locale: opts.destinationLocale, privateNS: opts.isPrivate ? 'TODO' : '' })\n\n    // -> Move page\n    const destinationTitle = (page.title === page.path ? opts.destinationPath : page.title)\n    await WIKI.models.pages.query().patch({\n      path: opts.destinationPath,\n      localeCode: opts.destinationLocale,\n      title: destinationTitle,\n      hash: destinationHash\n    }).findById(page.id)\n    await WIKI.models.pages.deletePageFromCache(page.hash)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Rebuild page tree\n    await WIKI.models.pages.rebuildTree()\n\n    // -> Rename in Search Index\n    const pageContents = await WIKI.models.pages.query().findById(page.id).select('render')\n    page.safeContent = WIKI.models.pages.cleanHTML(pageContents.render)\n    await WIKI.data.searchEngine.renamed({\n      ...page,\n      destinationPath: opts.destinationPath,\n      destinationLocaleCode: opts.destinationLocale,\n      destinationHash\n    })\n\n    // -> Rename in Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'renamed',\n        page: {\n          ...page,\n          destinationPath: opts.destinationPath,\n          destinationLocaleCode: opts.destinationLocale,\n          destinationHash,\n          moveAuthorId: opts.user.id,\n          moveAuthorName: opts.user.name,\n          moveAuthorEmail: opts.user.email\n        }\n      })\n    }\n\n    // -> Reconnect Links : Changing old links to the new path\n    await WIKI.models.pages.reconnectLinks({\n      sourceLocale: page.localeCode,\n      sourcePath: page.path,\n      locale: opts.destinationLocale,\n      path: opts.destinationPath,\n      mode: 'move'\n    })\n\n    // -> Reconnect Links : Validate invalid links to the new path\n    await WIKI.models.pages.reconnectLinks({\n      locale: opts.destinationLocale,\n      path: opts.destinationPath,\n      mode: 'create'\n    })\n  }\n\n  /**\n   * Delete an Existing Page\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise with no value\n   */\n  static async deletePage(opts) {\n    let page\n    if (_.has(opts, 'id')) {\n      page = await WIKI.models.pages.query().findById(opts.id)\n    } else {\n      page = await WIKI.models.pages.query().findOne({\n        path: opts.path,\n        localeCode: opts.locale\n      })\n    }\n    if (!page) {\n      throw new WIKI.Error.PageNotFound()\n    }\n\n    // -> Check for page access\n    if (!WIKI.auth.checkAccess(opts.user, ['delete:pages'], {\n      locale: page.locale,\n      path: page.path\n    })) {\n      throw new WIKI.Error.PageDeleteForbidden()\n    }\n\n    // -> Create version snapshot\n    await WIKI.models.pageHistory.addVersion({\n      ...page,\n      action: 'deleted',\n      versionDate: page.updatedAt\n    })\n\n    // -> Delete page\n    await WIKI.models.pages.query().delete().where('id', page.id)\n    await WIKI.models.pages.deletePageFromCache(page.hash)\n    WIKI.events.outbound.emit('deletePageFromCache', page.hash)\n\n    // -> Rebuild page tree\n    await WIKI.models.pages.rebuildTree()\n\n    // -> Delete from Search Index\n    await WIKI.data.searchEngine.deleted(page)\n\n    // -> Delete from Storage\n    if (!opts.skipStorage) {\n      await WIKI.models.storage.pageEvent({\n        event: 'deleted',\n        page\n      })\n    }\n\n    // -> Reconnect Links\n    await WIKI.models.pages.reconnectLinks({\n      locale: page.localeCode,\n      path: page.path,\n      mode: 'delete'\n    })\n  }\n\n  /**\n   * Reconnect links to new/move/deleted page\n   *\n   * @param {Object} opts - Page parameters\n   * @param {string} opts.path - Page Path\n   * @param {string} opts.locale - Page Locale Code\n   * @param {string} [opts.sourcePath] - Previous Page Path (move only)\n   * @param {string} [opts.sourceLocale] - Previous Page Locale Code (move only)\n   * @param {string} opts.mode - Page Update mode (create, move, delete)\n   * @returns {Promise} Promise with no value\n   */\n  static async reconnectLinks (opts) {\n    const pageHref = `/${opts.locale}/${opts.path}`\n    let replaceArgs = {\n      from: '',\n      to: ''\n    }\n    switch (opts.mode) {\n      case 'create':\n        replaceArgs.from = `<a href=\"${pageHref}\" class=\"is-internal-link is-invalid-page\">`\n        replaceArgs.to = `<a href=\"${pageHref}\" class=\"is-internal-link is-valid-page\">`\n        break\n      case 'move':\n        const prevPageHref = `/${opts.sourceLocale}/${opts.sourcePath}`\n        replaceArgs.from = `<a href=\"${prevPageHref}\" class=\"is-internal-link is-valid-page\">`\n        replaceArgs.to = `<a href=\"${pageHref}\" class=\"is-internal-link is-valid-page\">`\n        break\n      case 'delete':\n        replaceArgs.from = `<a href=\"${pageHref}\" class=\"is-internal-link is-valid-page\">`\n        replaceArgs.to = `<a href=\"${pageHref}\" class=\"is-internal-link is-invalid-page\">`\n        break\n      default:\n        return false\n    }\n\n    let affectedHashes = []\n    // -> Perform replace and return affected page hashes (POSTGRES only)\n    if (WIKI.config.db.type === 'postgres') {\n      const qryHashes = await WIKI.models.pages.query()\n        .returning('hash')\n        .patch({\n          render: WIKI.models.knex.raw('REPLACE(??, ?, ?)', ['render', replaceArgs.from, replaceArgs.to])\n        })\n        .whereIn('pages.id', function () {\n          this.select('pageLinks.pageId').from('pageLinks').where({\n            'pageLinks.path': opts.path,\n            'pageLinks.localeCode': opts.locale\n          })\n        })\n      affectedHashes = qryHashes.map(h => h.hash)\n    } else {\n      // -> Perform replace, then query affected page hashes (MYSQL, MARIADB, MSSQL, SQLITE only)\n      await WIKI.models.pages.query()\n        .patch({\n          render: WIKI.models.knex.raw('REPLACE(??, ?, ?)', ['render', replaceArgs.from, replaceArgs.to])\n        })\n        .whereIn('pages.id', function () {\n          this.select('pageLinks.pageId').from('pageLinks').where({\n            'pageLinks.path': opts.path,\n            'pageLinks.localeCode': opts.locale\n          })\n        })\n      const qryHashes = await WIKI.models.pages.query()\n        .column('hash')\n        .whereIn('pages.id', function () {\n          this.select('pageLinks.pageId').from('pageLinks').where({\n            'pageLinks.path': opts.path,\n            'pageLinks.localeCode': opts.locale\n          })\n        })\n      affectedHashes = qryHashes.map(h => h.hash)\n    }\n    for (const hash of affectedHashes) {\n      await WIKI.models.pages.deletePageFromCache(hash)\n      WIKI.events.outbound.emit('deletePageFromCache', hash)\n    }\n  }\n\n  /**\n   * Rebuild page tree for new/updated/deleted page\n   *\n   * @returns {Promise} Promise with no value\n   */\n  static async rebuildTree() {\n    const rebuildJob = await WIKI.scheduler.registerJob({\n      name: 'rebuild-tree',\n      immediate: true,\n      worker: true\n    })\n    return rebuildJob.finished\n  }\n\n  /**\n   * Trigger the rendering of a page\n   *\n   * @param {Object} page Page Model Instance\n   * @returns {Promise} Promise with no value\n   */\n  static async renderPage(page) {\n    const renderJob = await WIKI.scheduler.registerJob({\n      name: 'render-page',\n      immediate: true,\n      worker: true\n    }, page.id)\n    return renderJob.finished\n  }\n\n  /**\n   * Fetch an Existing Page from Cache if possible, from DB otherwise and save render to Cache\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async getPage(opts) {\n    // -> Get from cache first\n    let page = await WIKI.models.pages.getPageFromCache(opts)\n    if (!page) {\n      // -> Get from DB\n      page = await WIKI.models.pages.getPageFromDb(opts)\n      if (page) {\n        if (page.render) {\n          // -> Save render to cache\n          await WIKI.models.pages.savePageToCache(page)\n        } else {\n          // -> No render? Possible duplicate issue\n          /* TODO: Detect duplicate and delete */\n          throw new Error('Error while fetching page. Duplicate entry detected. Reload the page to try again.')\n        }\n      }\n    }\n    return page\n  }\n\n  /**\n   * Fetch an Existing Page from the Database\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async getPageFromDb(opts) {\n    const queryModeID = _.isNumber(opts)\n    try {\n      return WIKI.models.pages.query()\n        .column([\n          'pages.id',\n          'pages.path',\n          'pages.hash',\n          'pages.title',\n          'pages.description',\n          'pages.isPrivate',\n          'pages.isPublished',\n          'pages.privateNS',\n          'pages.publishStartDate',\n          'pages.publishEndDate',\n          'pages.content',\n          'pages.render',\n          'pages.toc',\n          'pages.contentType',\n          'pages.createdAt',\n          'pages.updatedAt',\n          'pages.editorKey',\n          'pages.localeCode',\n          'pages.authorId',\n          'pages.creatorId',\n          'pages.extra',\n          {\n            authorName: 'author.name',\n            authorEmail: 'author.email',\n            creatorName: 'creator.name',\n            creatorEmail: 'creator.email'\n          }\n        ])\n        .joinRelated('author')\n        .joinRelated('creator')\n        .withGraphJoined('tags')\n        .modifyGraph('tags', builder => {\n          builder.select('tag', 'title')\n        })\n        .where(queryModeID ? {\n          'pages.id': opts\n        } : {\n          'pages.path': opts.path,\n          'pages.localeCode': opts.locale\n        })\n        // .andWhere(builder => {\n        //   if (queryModeID) return\n        //   builder.where({\n        //     'pages.isPublished': true\n        //   }).orWhere({\n        //     'pages.isPublished': false,\n        //     'pages.authorId': opts.userId\n        //   })\n        // })\n        // .andWhere(builder => {\n        //   if (queryModeID) return\n        //   if (opts.isPrivate) {\n        //     builder.where({ 'pages.isPrivate': true, 'pages.privateNS': opts.privateNS })\n        //   } else {\n        //     builder.where({ 'pages.isPrivate': false })\n        //   }\n        // })\n        .first()\n    } catch (err) {\n      WIKI.logger.warn(err)\n      throw err\n    }\n  }\n\n  /**\n   * Save a Page Model Instance to Cache\n   *\n   * @param {Object} page Page Model Instance\n   * @returns {Promise} Promise with no value\n   */\n  static async savePageToCache(page) {\n    const cachePath = path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache/${page.hash}.bin`)\n    await fs.outputFile(cachePath, WIKI.models.pages.cacheSchema.encode({\n      id: page.id,\n      authorId: page.authorId,\n      authorName: page.authorName,\n      createdAt: page.createdAt,\n      creatorId: page.creatorId,\n      creatorName: page.creatorName,\n      description: page.description,\n      editorKey: page.editorKey,\n      extra: {\n        css: _.get(page, 'extra.css', ''),\n        js: _.get(page, 'extra.js', '')\n      },\n      isPrivate: page.isPrivate === 1 || page.isPrivate === true,\n      isPublished: page.isPublished === 1 || page.isPublished === true,\n      publishEndDate: page.publishEndDate,\n      publishStartDate: page.publishStartDate,\n      render: page.render,\n      tags: page.tags.map(t => _.pick(t, ['tag', 'title'])),\n      title: page.title,\n      toc: _.isString(page.toc) ? page.toc : JSON.stringify(page.toc),\n      updatedAt: page.updatedAt\n    }))\n  }\n\n  /**\n   * Fetch an Existing Page from Cache\n   *\n   * @param {Object} opts Page Properties\n   * @returns {Promise} Promise of the Page Model Instance\n   */\n  static async getPageFromCache(opts) {\n    const pageHash = pageHelper.generateHash({ path: opts.path, locale: opts.locale, privateNS: opts.isPrivate ? 'TODO' : '' })\n    const cachePath = path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache/${pageHash}.bin`)\n\n    try {\n      const pageBuffer = await fs.readFile(cachePath)\n      let page = WIKI.models.pages.cacheSchema.decode(pageBuffer)\n      return {\n        ...page,\n        path: opts.path,\n        localeCode: opts.locale,\n        isPrivate: opts.isPrivate\n      }\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return false\n      }\n      WIKI.logger.error(err)\n      throw err\n    }\n  }\n\n  /**\n   * Delete an Existing Page from Cache\n   *\n   * @param {String} page Page Unique Hash\n   * @returns {Promise} Promise with no value\n   */\n  static async deletePageFromCache(hash) {\n    return fs.remove(path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache/${hash}.bin`))\n  }\n\n  /**\n   * Flush the contents of the Cache\n   */\n  static async flushCache() {\n    return fs.emptyDir(path.resolve(WIKI.ROOTPATH, WIKI.config.dataPath, `cache`))\n  }\n\n  /**\n   * Migrate all pages from a source locale to the target locale\n   *\n   * @param {Object} opts Migration properties\n   * @param {string} opts.sourceLocale Source Locale Code\n   * @param {string} opts.targetLocale Target Locale Code\n   * @returns {Promise} Promise with no value\n   */\n  static async migrateToLocale({ sourceLocale, targetLocale }) {\n    return WIKI.models.pages.query()\n      .patch({\n        localeCode: targetLocale\n      })\n      .where({\n        localeCode: sourceLocale\n      })\n      .whereNotExists(function() {\n        this.select('id').from('pages AS pagesm').where('pagesm.localeCode', targetLocale).andWhereRaw('pagesm.path = pages.path')\n      })\n  }\n\n  /**\n   * Clean raw HTML from content for use in search engines\n   *\n   * @param {string} rawHTML Raw HTML\n   * @returns {string} Cleaned Content Text\n   */\n  static cleanHTML(rawHTML = '') {\n    let data = striptags(rawHTML || '', [], ' ')\n      .replace(emojiRegex(), '')\n      // .replace(htmlEntitiesRegex, '')\n    return he.decode(data)\n      .replace(punctuationRegex, ' ')\n      .replace(/(\\r\\n|\\n|\\r)/gm, ' ')\n      .replace(/\\s\\s+/g, ' ')\n      .split(' ').filter(w => w.length > 1).join(' ').toLowerCase()\n  }\n\n  /**\n   * Subscribe to HA propagation events\n   */\n  static subscribeToEvents() {\n    WIKI.events.inbound.on('deletePageFromCache', hash => {\n      WIKI.models.pages.deletePageFromCache(hash)\n    })\n    WIKI.events.inbound.on('flushCache', () => {\n      WIKI.models.pages.flushCache()\n    })\n  }\n}\n"], "filenames": ["server/models/pages.js"], "buggy_code_start_loc": [374], "buggy_code_end_loc": [458], "fixing_code_start_loc": [374], "fixing_code_end_loc": [467], "type": "CWE-287", "message": "Wiki.js is a wiki app built on Node.js. In affected versions an authenticated user with write access on a restricted set of paths can update a page outside the allowed paths by specifying a different target page ID while keeping the path intact. The access control incorrectly check the path access against the user-provided values instead of the actual path associated to the page ID. Commit https://github.com/Requarks/wiki/commit/411802ec2f654bb5ed1126c307575b81e2361c6b fixes this vulnerability by checking access control on the path associated with the page ID instead of the user-provided value. When the path is different than the current value, a second access control check is then performed on the user-provided path before the move operation.", "other": {"cve": {"id": "CVE-2022-23654", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T20:15:07.817", "lastModified": "2022-03-01T20:41:04.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wiki.js is a wiki app built on Node.js. In affected versions an authenticated user with write access on a restricted set of paths can update a page outside the allowed paths by specifying a different target page ID while keeping the path intact. The access control incorrectly check the path access against the user-provided values instead of the actual path associated to the page ID. Commit https://github.com/Requarks/wiki/commit/411802ec2f654bb5ed1126c307575b81e2361c6b fixes this vulnerability by checking access control on the path associated with the page ID instead of the user-provided value. When the path is different than the current value, a second access control check is then performed on the user-provided path before the move operation."}, {"lang": "es", "value": "Wiki.js es una aplicaci\u00f3n wiki construida sobre Node.js. En las versiones afectadas, un usuario autenticado con acceso de escritura en un conjunto restringido de rutas puede actualizar una p\u00e1gina fuera de las rutas permitidas especificando un ID de p\u00e1gina de destino diferente mientras mantiene la ruta intacta. El control de acceso comprueba incorrectamente el acceso a la ruta con los valores proporcionados por el usuario en lugar de la ruta real asociada al ID de la p\u00e1gina. El commit https://github.com/Requarks/wiki/commit/411802ec2f654bb5ed1126c307575b81e2361c6b corrige esta vulnerabilidad comprobando el control de acceso en la ruta asociada al ID de la p\u00e1gina en lugar del valor proporcionado por el usuario. Cuando la ruta es diferente al valor actual, se realiza una segunda comprobaci\u00f3n de control de acceso en la ruta proporcionada por el usuario antes de la operaci\u00f3n de movimiento"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:requarks:wiki.js:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.276", "matchCriteriaId": "16272B7A-8766-4D95-8E5D-3CF9EE37283C"}]}]}], "references": [{"url": "https://github.com/Requarks/wiki/commit/411802ec2f654bb5ed1126c307575b81e2361c6b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/security/advisories/GHSA-3cv9-795v-6j7j", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Requarks/wiki/commit/411802ec2f654bb5ed1126c307575b81e2361c6b"}}