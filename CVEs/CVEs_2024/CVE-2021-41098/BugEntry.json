{"buggy_code": ["package nokogiri;\n\nimport static nokogiri.XmlSaxPushParser.terminateExecution;\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.ThreadFactory;\n\nimport nokogiri.internals.*;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\n/**\n * Class for Nokogiri::HTML4::SAX::PushParser\n *\n * @author\n * @author Piotr Szmielew <p.szmielew@ava.waw.pl> - based on Nokogiri::XML::SAX::PushParser\n */\n@JRubyClass(name = \"Nokogiri::HTML4::SAX::PushParser\")\npublic class Html4SaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<Html4SaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n\n  public\n  Html4SaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context,\n                    IRubyObject saxParser,\n                    IRubyObject fileName,\n                    IRubyObject encoding)\n  {\n    // NOTE: Silently skips provided encoding\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk, IRubyObject isLast)\n  {\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.getRuntime().newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      terminateTask(context.runtime);\n      throw XmlSyntaxError.createHTMLSyntaxError(context.runtime).toThrowable(); // Nokogiri::HTML4::SyntaxError\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    if (isLast.isTrue()) {\n      IRubyObject document = invoke(context, this, \"document\");\n      invoke(context, document, \"end_document\");\n      terminateTask(context.runtime);\n    } else {\n      try {\n        Future<Void> task = stream.addChunk(data);\n        task.get();\n      } catch (ClosedStreamException ex) {\n        // this means the stream is closed, ignore this exception\n      } catch (Exception e) {\n        throw context.runtime.newRuntimeError(e.getMessage());\n      }\n\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw parserTask.getLastError();\n    }\n\n    return this;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<Html4SaxParserContext>((Callable) parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"Html4SaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  private static Html4SaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::HTML4::SAX::ParserContext\");\n    return Html4SaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends XmlSaxPushParser.ParserTask /* <Html4SaxPushParser> */\n  {\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      super(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    @Override\n    public Html4SaxParserContext\n    call() throws Exception\n    {\n      return (Html4SaxParserContext) super.call();\n    }\n\n  }\n\n}\n", "package nokogiri;\n\nimport static org.jruby.runtime.Helpers.invoke;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.xerces.parsers.AbstractSAXParser;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyModule;\nimport org.jruby.RubyObjectAdapter;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.javasupport.JavaEmbedUtils;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.SAXParseException;\n\nimport nokogiri.internals.NokogiriHandler;\nimport nokogiri.internals.NokogiriHelpers;\nimport nokogiri.internals.ParserContext;\nimport nokogiri.internals.XmlSaxParser;\n\n/**\n * Base class for the SAX parsers.\n *\n * @author Patrick Mahoney <pat@polycrystal.org>\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name = \"Nokogiri::XML::SAX::ParserContext\")\npublic class XmlSaxParserContext extends ParserContext\n{\n\n  protected static final String FEATURE_NAMESPACES =\n    \"http://xml.org/sax/features/namespaces\";\n  protected static final String FEATURE_NAMESPACE_PREFIXES =\n    \"http://xml.org/sax/features/namespace-prefixes\";\n  protected static final String FEATURE_LOAD_EXTERNAL_DTD =\n    \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n  protected static final String FEATURE_CONTINUE_AFTER_FATAL_ERROR =\n    \"http://apache.org/xml/features/continue-after-fatal-error\";\n\n  protected AbstractSAXParser parser;\n\n  protected NokogiriHandler handler;\n  private boolean replaceEntities = true;\n  private boolean recovery = false;\n\n  public\n  XmlSaxParserContext(final Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  protected void\n  initialize(Ruby runtime)\n  {\n    try {\n      parser = createParser();\n    } catch (SAXException se) {\n      // Unexpected failure in XML subsystem\n      RaiseException ex = runtime.newRuntimeError(se.toString());\n      ex.initCause(se);\n      throw ex;\n    }\n  }\n\n  /**\n   * Create and return a copy of this object.\n   *\n   * @return a clone of this object\n   */\n  @Override\n  public Object\n  clone() throws CloneNotSupportedException\n  {\n    return super.clone();\n  }\n\n  protected AbstractSAXParser\n  createParser() throws SAXException\n  {\n    XmlSaxParser parser = new XmlSaxParser();\n    parser.setFeature(FEATURE_NAMESPACE_PREFIXES, true);\n    parser.setFeature(FEATURE_LOAD_EXTERNAL_DTD, false);\n    return parser;\n  }\n\n  /**\n   * Create a new parser context that will parse the string\n   * <code>data</code>.\n   */\n  @JRubyMethod(name = \"memory\", meta = true)\n  public static IRubyObject\n  parse_memory(ThreadContext context,\n               IRubyObject klazz,\n               IRubyObject data)\n  {\n    final Ruby runtime = context.runtime;\n    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);\n    ctx.initialize(runtime);\n    ctx.setStringInputSource(context, data, runtime.getNil());\n    return ctx;\n  }\n\n  /**\n   * Create a new parser context that will read from the file\n   * <code>data</code> and parse.\n   */\n  @JRubyMethod(name = \"file\", meta = true)\n  public static IRubyObject\n  parse_file(ThreadContext context,\n             IRubyObject klazz,\n             IRubyObject data)\n  {\n    final Ruby runtime = context.runtime;\n    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);\n    ctx.initialize(context.getRuntime());\n    ctx.setInputSourceFile(context, data);\n    return ctx;\n  }\n\n  /**\n   * Create a new parser context that will read from the IO or\n   * StringIO <code>data</code> and parse.\n   *\n   * TODO: Currently ignores encoding <code>enc</code>.\n   */\n  @JRubyMethod(name = \"io\", meta = true)\n  public static IRubyObject\n  parse_io(ThreadContext context,\n           IRubyObject klazz,\n           IRubyObject data,\n           IRubyObject enc)\n  {\n    //int encoding = (int)enc.convertToInteger().getLongValue();\n    final Ruby runtime = context.runtime;\n    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);\n    ctx.initialize(runtime);\n    ctx.setIOInputSource(context, data, runtime.getNil());\n    return ctx;\n  }\n\n  /**\n   * Create a new parser context that will read from a raw input stream.\n   * Meant to be run in a separate thread by XmlSaxPushParser.\n   */\n  static XmlSaxParserContext\n  parse_stream(final Ruby runtime, RubyClass klazz, InputStream stream)\n  {\n    XmlSaxParserContext ctx = newInstance(runtime, klazz);\n    ctx.initialize(runtime);\n    ctx.setInputSource(stream);\n    return ctx;\n  }\n\n  private static XmlSaxParserContext\n  newInstance(final Ruby runtime, final RubyClass klazz)\n  {\n    return (XmlSaxParserContext) NokogiriService.XML_SAXPARSER_CONTEXT_ALLOCATOR.allocate(runtime, klazz);\n  }\n\n  /**\n   * Set a property of the underlying parser.\n   */\n  protected void\n  setProperty(String key, Object val)\n  throws SAXNotRecognizedException, SAXNotSupportedException\n  {\n    parser.setProperty(key, val);\n  }\n\n  protected void\n  setContentHandler(ContentHandler handler)\n  {\n    parser.setContentHandler(handler);\n  }\n\n  protected void\n  setErrorHandler(ErrorHandler handler)\n  {\n    parser.setErrorHandler(handler);\n  }\n\n  public final NokogiriHandler\n  getNokogiriHandler() { return handler; }\n\n  /**\n   * Perform any initialization prior to parsing with the handler\n   * <code>handlerRuby</code>. Convenience hook for subclasses.\n   */\n  protected void\n  preParse(Ruby runtime, IRubyObject handlerRuby, NokogiriHandler handler)\n  {\n    ((XmlSaxParser) parser).setXmlDeclHandler(handler);\n    if (recovery) {\n      try {\n        parser.setFeature(FEATURE_CONTINUE_AFTER_FATAL_ERROR, true);\n      } catch (Exception e) {\n        // Unexpected failure in XML subsystem\n        throw runtime.newRuntimeError(e.getMessage());\n      }\n    }\n  }\n\n  protected void\n  postParse(Ruby runtime, IRubyObject handlerRuby, NokogiriHandler handler)\n  {\n    // noop\n  }\n\n  protected void\n  do_parse() throws SAXException, IOException\n  {\n    parser.parse(getInputSource());\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  parse_with(ThreadContext context, IRubyObject handlerRuby)\n  {\n    final Ruby runtime = context.getRuntime();\n\n    if (!invoke(context, handlerRuby, \"respond_to?\", runtime.newSymbol(\"document\")).isTrue()) {\n      throw runtime.newArgumentError(\"argument must respond_to document\");\n    }\n\n    NokogiriHandler handler = this.handler = new NokogiriHandler(runtime, handlerRuby);\n    preParse(runtime, handlerRuby, handler);\n\n    setContentHandler(handler);\n    setErrorHandler(handler);\n\n    try {\n      setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n    } catch (Exception ex) {\n      throw runtime.newRuntimeError(\"Problem while creating XML SAX Parser: \" + ex.toString());\n    }\n\n    try {\n      try {\n        do_parse();\n      } catch (SAXParseException ex) {\n        // A bad document (<foo><bar></foo>) should call the\n        // error handler instead of raising a SAX exception.\n\n        // However, an EMPTY document should raise a RuntimeError.\n        // This is a bit kludgy, but AFAIK SAX doesn't distinguish\n        // between empty and bad whereas Nokogiri does.\n        String message = ex.getMessage();\n        if (message != null && message.contains(\"Premature end of file.\") && stringDataSize < 1) {\n          throw runtime.newRuntimeError(\"couldn't parse document: \" + message);\n        }\n        handler.error(ex);\n      }\n    } catch (SAXException ex) {\n      // Unexpected failure in XML subsystem\n      throw runtime.newRuntimeError(ex.getMessage());\n    } catch (IOException ex) {\n      throw runtime.newIOErrorFromException(ex);\n    }\n\n    postParse(runtime, handlerRuby, handler);\n\n    //maybeTrimLeadingAndTrailingWhitespace(context, handlerRuby);\n\n    return runtime.getNil();\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  set_replace_entities(ThreadContext context, IRubyObject value)\n  {\n    replaceEntities = value.isTrue();\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  get_replace_entities(ThreadContext context)\n  {\n    return context.runtime.newBoolean(replaceEntities);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"recovery=\")\n  public IRubyObject\n  set_recovery(ThreadContext context, IRubyObject value)\n  {\n    recovery = value.isTrue();\n    return this;\n  }\n\n  @JRubyMethod(name = \"recovery\")\n  public IRubyObject\n  get_recovery(ThreadContext context)\n  {\n    return context.runtime.newBoolean(recovery);\n  }\n\n  /**\n   * If the handler's document is a FragmentHandler, attempt to trim\n   * leading and trailing whitespace.\n   *\n   * This is a bit hackish and depends heavily on the internals of\n   * FragmentHandler.\n   */\n  protected void\n  maybeTrimLeadingAndTrailingWhitespace(ThreadContext context, IRubyObject parser)\n  {\n    RubyObjectAdapter adapter = JavaEmbedUtils.newObjectAdapter();\n    RubyModule mod = context.getRuntime().getClassFromPath(\"Nokogiri::XML::FragmentHandler\");\n\n    IRubyObject handler = adapter.getInstanceVariable(parser, \"@document\");\n    if (handler == null || handler.isNil() || !adapter.isKindOf(handler, mod)) {\n      return;\n    }\n    IRubyObject stack = adapter.getInstanceVariable(handler, \"@stack\");\n    if (stack == null || stack.isNil()) {\n      return;\n    }\n    // doc is finally a DocumentFragment whose nodes we can check\n    IRubyObject doc = adapter.callMethod(stack, \"first\");\n    if (doc == null || doc.isNil()) {\n      return;\n    }\n\n    IRubyObject children;\n\n    for (;;) {\n      children = adapter.callMethod(doc, \"children\");\n      IRubyObject first = adapter.callMethod(children, \"first\");\n      if (NokogiriHelpers.isBlank(first)) { adapter.callMethod(first, \"unlink\"); }\n      else { break; }\n    }\n\n    for (;;) {\n      children = adapter.callMethod(doc, \"children\");\n      IRubyObject last = adapter.callMethod(children, \"last\");\n      if (NokogiriHelpers.isBlank(last)) { adapter.callMethod(last, \"unlink\"); }\n      else { break; }\n    }\n\n    // While we have a document, normalize it.\n    ((XmlNode) doc).normalize();\n  }\n\n  @JRubyMethod(name = \"column\")\n  public IRubyObject\n  column(ThreadContext context)\n  {\n    final Integer number = handler.getColumn();\n    if (number == null) { return context.getRuntime().getNil(); }\n    return RubyFixnum.newFixnum(context.getRuntime(), number.longValue());\n  }\n\n  @JRubyMethod(name = \"line\")\n  public IRubyObject\n  line(ThreadContext context)\n  {\n    final Integer number = handler.getLine();\n    if (number == null) { return context.getRuntime().getNil(); }\n    return RubyFixnum.newFixnum(context.getRuntime(), number.longValue());\n  }\n\n}\n", "package nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.ThreadFactory;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport nokogiri.internals.ClosedStreamException;\nimport nokogiri.internals.NokogiriBlockingQueueInputStream;\nimport nokogiri.internals.NokogiriHandler;\nimport nokogiri.internals.NokogiriHelpers;\nimport nokogiri.internals.ParserContext;\n\n/**\n * Class for Nokogiri::XML::SAX::PushParser\n *\n * @author Patrick Mahoney <pat@polycrystal.org>\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name = \"Nokogiri::XML::SAX::PushParser\")\npublic class XmlSaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<XmlSaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n  RaiseException ex = null;\n\n  public\n  XmlSaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context, IRubyObject saxParser, IRubyObject fileName)\n  {\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  setReplaceEntities(ThreadContext context, IRubyObject value)\n  {\n    // Ignore the value.\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  getReplaceEntities(ThreadContext context)\n  {\n    // The java parser always replaces entities.\n    return context.getRuntime().getTrue();\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk,\n               IRubyObject isLast)\n  {\n    if (ex != null) {\n      // parser has already errored, rethrow the exception\n      throw ex;\n    }\n\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.runtime.newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      return this;\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    try {\n      Future<Void> task = stream.addChunk(data);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // this means the stream is closed, ignore this exception\n    } catch (Exception e) {\n      throw context.runtime.newRuntimeError(e.toString());\n    }\n\n    if (isLast.isTrue()) {\n      parserTask.getNokogiriHandler().endDocument();\n      terminateTask(context.runtime);\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw ex = parserTask.getLastError();\n    }\n\n    return this;\n  }\n\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<XmlSaxParserContext>(parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"XmlSaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  // SHARED for Html4SaxPushParser\n  static void\n  terminateExecution(final ExecutorService executor, final NokogiriBlockingQueueInputStream stream,\n                     final FutureTask<?> futureTask)\n  throws InterruptedException, ExecutionException\n  {\n\n    if (executor == null) { return; }\n\n    try {\n      Future<Void> task = stream.addChunk(NokogiriBlockingQueueInputStream.END);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // ignore this exception, it means the stream was closed\n    }\n    futureTask.cancel(true);\n    executor.shutdown();\n  }\n\n  private static XmlSaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::XML::SAX::ParserContext\");\n    return XmlSaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n  {\n\n    final InputStream stream;\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      this(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    // IMPL with Html4SaxPushParser\n    protected\n    ParserTask(ThreadContext context, IRubyObject handler, XmlSaxParserContext parser, InputStream stream)\n    {\n      super(context, handler, parser);\n      this.stream = stream;\n    }\n\n    @Override\n    public XmlSaxParserContext\n    call() throws Exception\n    {\n      try {\n        parser.parse_with(context, handler);\n      } finally { stream.close(); }\n      // we have to close the stream before exiting, otherwise someone\n      // can add a chunk and block on task.get() forever.\n      return parser;\n    }\n\n    final NokogiriHandler\n    getNokogiriHandler()\n    {\n      return parser.getNokogiriHandler();\n    }\n\n    synchronized final int\n    getErrorCount()\n    {\n      // check for null because thread may not have started yet\n      if (parser.getNokogiriHandler() == null) { return 0; }\n      return parser.getNokogiriHandler().getErrorCount();\n    }\n\n    synchronized final RaiseException\n    getLastError()\n    {\n      return parser.getNokogiriHandler().getLastError();\n    }\n\n  }\n\n}\n", "package nokogiri.internals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\n\nimport nokogiri.internals.ParserContext.Options;\n\nimport org.jruby.Ruby;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.ext.EntityResolver2;\n\n/**\n * An entity resolver aware of the fact that the Ruby runtime can\n * change directory but the JVM cannot.  Thus any file based\n * entity resolution that uses relative paths must be translated\n * to be relative to the current directory of the Ruby runtime.\n */\npublic class NokogiriEntityResolver implements EntityResolver2\n{\n  protected final Ruby runtime;\n  private final NokogiriErrorHandler handler;\n  private final Options options;\n\n  public\n  NokogiriEntityResolver(Ruby runtime, NokogiriErrorHandler handler, Options options)\n  {\n    super();\n    this.runtime = runtime;\n    this.handler = handler;\n    this.options = options;\n  }\n\n  @Override\n  public InputSource\n  getExternalSubset(String name, String baseURI)\n  throws SAXException, IOException\n  {\n    return null;\n  }\n\n  @Override\n  public InputSource\n  resolveEntity(String publicId, String systemId)\n  throws SAXException, IOException\n  {\n    return resolveEntity(runtime, null, publicId, null, systemId);\n  }\n\n  @Override\n  public InputSource\n  resolveEntity(String name,\n                String publicId,\n                String baseURI,\n                String systemId)\n  throws SAXException, IOException\n  {\n    return resolveEntity(runtime, name, publicId, baseURI, systemId);\n  }\n\n  private static File\n  join(String parent, String child)\n  {\n    if (new File(parent).isFile()) {\n      parent = new File(parent).getParent();\n    }\n    return new File(parent, child);\n  }\n\n  private static InputSource\n  emptyInputSource(InputSource source)\n  {\n    source.setByteStream(new ByteArrayInputStream(new byte[0]));\n    return source;\n  }\n\n  private boolean\n  shouldLoadDtd()\n  {\n    return options.dtdLoad || options.dtdValid;\n  }\n\n  private void\n  addError(String errorMessage)\n  {\n    if (handler != null) { handler.errors.add(new Exception(errorMessage)); }\n  }\n\n  /**\n   * Create a file base input source taking into account the current\n   * directory of <code>runtime</code>.\n   * @throws SAXException\n   */\n  protected InputSource\n  resolveEntity(Ruby runtime, String name, String publicId, String baseURI, String systemId)\n  throws IOException, SAXException\n  {\n    InputSource s = new InputSource();\n    if (name.equals(\"[dtd]\") && !shouldLoadDtd()) {\n      return emptyInputSource(s);\n    } else if (!name.equals(\"[dtd]\") && !options.noEnt) {\n      return emptyInputSource(s);\n    }\n    String adjustedSystemId;\n    URI uri = URI.create(systemId);\n    if (options.noNet && uri.getHost() != null) {\n      addError(\"Attempt to load network entity \" + systemId);\n      return emptyInputSource(s);\n    }\n    // if this is a url or absolute file name then use it\n    if (uri.isAbsolute() && !uri.isOpaque()) {\n      adjustedSystemId = uri.toURL().toString();\n    } else if (new File(uri.getPath()).isAbsolute()) {\n      adjustedSystemId = uri.getPath();\n    } else if (baseURI != null) {\n      URI baseuri = URI.create(baseURI);\n      if (options.noNet && baseuri.getHost() != null) {\n        addError(\"Attempt to load network entity \" + systemId);\n        return emptyInputSource(s);\n      }\n      if (baseuri.getHost() == null) {\n        // this is a local file\n        adjustedSystemId = join(baseuri.getPath(), uri.getPath()).getCanonicalPath();\n      } else {\n        // this is a url, then resolve uri using baseuri\n        adjustedSystemId = baseuri.resolve(systemId).toURL().toString();\n      }\n    } else {\n      // baseURI is null we have to use the current working directory to resolve the entity\n      String pwd = runtime.getCurrentDirectory();\n      adjustedSystemId = join(pwd, uri.getPath()).getCanonicalPath();\n    }\n    s.setSystemId(adjustedSystemId);\n    s.setPublicId(publicId);\n    return s;\n  }\n\n}\n", "package nokogiri.internals;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.xerces.xni.parser.XMLErrorHandler;\nimport org.xml.sax.ErrorHandler;\n\n/**\n * Super class of error handlers.\n *\n * XMLErrorHandler is used by nokogiri.internals.HtmlDomParserContext since NekoHtml\n * uses this type of the error handler.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n{\n  protected final List<Exception> errors;\n  protected boolean noerror;\n  protected boolean nowarning;\n\n  public\n  NokogiriErrorHandler(boolean noerror, boolean nowarning)\n  {\n    this.errors = new ArrayList<Exception>(4);\n    this.noerror = noerror;\n    this.nowarning = nowarning;\n  }\n\n  List<Exception>\n  getErrors() { return errors; }\n\n  public void\n  addError(Exception ex) { errors.add(ex); }\n\n  protected boolean\n  usesNekoHtml(String domain)\n  {\n    return \"http://cyberneko.org/html\".equals(domain);\n  }\n\n}\n", "package nokogiri.internals;\n\nimport static nokogiri.internals.NokogiriHelpers.getLocalPart;\nimport static nokogiri.internals.NokogiriHelpers.getPrefix;\nimport static nokogiri.internals.NokogiriHelpers.isNamespace;\nimport static nokogiri.internals.NokogiriHelpers.stringOrNil;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Set;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyClass;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.ext.DefaultHandler2;\n\nimport nokogiri.XmlSyntaxError;\n\n/**\n * A handler for SAX parsing.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n{\n\n  StringBuilder charactersBuilder;\n  private final Ruby runtime;\n  private final RubyClass attrClass;\n  private final IRubyObject object;\n\n  /**\n   * Stores parse errors with the most-recent error last.\n   *\n   * TODO: should these be stored in the document 'errors' array?\n   * Currently only string messages are stored there.\n   */\n  private final LinkedList<RaiseException> errors = new LinkedList<RaiseException>();\n\n  private Locator locator;\n  private boolean needEmptyAttrCheck;\n\n  public\n  NokogiriHandler(Ruby runtime, IRubyObject object)\n  {\n    assert object != null;\n    this.runtime = runtime;\n    this.attrClass = (RubyClass) runtime.getClassFromPath(\"Nokogiri::XML::SAX::Parser::Attribute\");\n    this.object = object;\n    charactersBuilder = new StringBuilder();\n    String objectName = object.getMetaClass().getName();\n    if (\"Nokogiri::HTML4::SAX::Parser\".equals(objectName)) { needEmptyAttrCheck = true; }\n  }\n\n  @Override\n  public void\n  skippedEntity(String skippedEntity)\n  {\n    call(\"error\", runtime.newString(\"Entity '\" + skippedEntity + \"' not defined\\n\"));\n  }\n\n  @Override\n  public void\n  setDocumentLocator(Locator locator)\n  {\n    this.locator = locator;\n  }\n\n  @Override\n  public void\n  startDocument()\n  {\n    call(\"start_document\");\n  }\n\n  @Override\n  public void\n  xmlDecl(String version, String encoding, String standalone)\n  {\n    call(\"xmldecl\", stringOrNil(runtime, version), stringOrNil(runtime, encoding), stringOrNil(runtime, standalone));\n  }\n\n  @Override\n  public void\n  endDocument()\n  {\n    populateCharacters();\n    call(\"end_document\");\n  }\n\n  @Override\n  public void\n  processingInstruction(String target, String data)\n  {\n    call(\"processing_instruction\", runtime.newString(target), runtime.newString(data));\n  }\n\n  /*\n   * This calls \"start_element_namespace\".\n   *\n   * Attributes that define namespaces are passed in a separate\n   * array of <code>[:prefix, :uri]</code> arrays and are not\n   * passed with the other attributes.\n   */\n  @Override\n  public void\n  startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException\n  {\n    final Ruby runtime = this.runtime;\n    final ThreadContext context = runtime.getCurrentContext();\n\n    // for attributes other than namespace attrs\n    RubyArray rubyAttr = RubyArray.newArray(runtime);\n    // for namespace defining attributes\n    RubyArray rubyNSAttr = RubyArray.newArray(runtime);\n\n    boolean fromFragmentHandler = false; // isFromFragmentHandler();\n\n    for (int i = 0; i < attrs.getLength(); i++) {\n      String u = attrs.getURI(i);\n      String qn = attrs.getQName(i);\n      String ln = attrs.getLocalName(i);\n      String val = attrs.getValue(i);\n      String pre;\n\n      pre = getPrefix(qn);\n      if (ln == null || ln.isEmpty()) { ln = getLocalPart(qn); }\n\n      if (isNamespace(qn) && !fromFragmentHandler) {\n        // I haven't figured the reason out yet, but, in somewhere,\n        // namespace is converted to array in array and cause\n        // TypeError at line 45 in fragment_handler.rb\n        if (ln.equals(\"xmlns\")) { ln = null; }\n        rubyNSAttr.append(runtime.newArray(stringOrNil(runtime, ln), runtime.newString(val)));\n      } else {\n        IRubyObject[] args = null;\n        if (needEmptyAttrCheck) {\n          if (isEmptyAttr(ln)) {\n            args = new IRubyObject[] {\n              stringOrNil(runtime, ln),\n              stringOrNil(runtime, pre),\n              stringOrNil(runtime, u)\n            };\n          }\n        }\n        if (args == null) {\n          args = new IRubyObject[] {\n            stringOrNil(runtime, ln),\n            stringOrNil(runtime, pre),\n            stringOrNil(runtime, u),\n            stringOrNil(runtime, val)\n          };\n        }\n\n        rubyAttr.append(Helpers.invoke(context, attrClass, \"new\", args));\n      }\n    }\n\n    if (localName == null || localName.isEmpty()) { localName = getLocalPart(qName); }\n    populateCharacters();\n    call(\"start_element_namespace\",\n         stringOrNil(runtime, localName),\n         rubyAttr,\n         stringOrNil(runtime, getPrefix(qName)),\n         stringOrNil(runtime, uri),\n         rubyNSAttr);\n  }\n\n  static final Set<String> EMPTY_ATTRS;\n  static\n  {\n    final String[] emptyAttrs = {\n      \"checked\", \"compact\", \"declare\", \"defer\", \"disabled\", \"ismap\", \"multiple\",\n      \"noresize\", \"nohref\", \"noshade\", \"nowrap\", \"readonly\", \"selected\"\n    };\n    EMPTY_ATTRS = new HashSet<String>(Arrays.asList(emptyAttrs));\n  }\n\n  private static boolean\n  isEmptyAttr(String name)\n  {\n    return EMPTY_ATTRS.contains(name);\n  }\n\n  public final Integer\n  getLine()   // -1 if none is available\n  {\n    final int line = locator.getLineNumber();\n    return line == -1 ? null : line;\n  }\n\n  public final Integer\n  getColumn()   // -1 if none is available\n  {\n    final int column = locator.getColumnNumber();\n    return column == -1 ? null : column - 1;\n  }\n\n  @Override\n  public void\n  endElement(String uri, String localName, String qName)\n  {\n    populateCharacters();\n    call(\"end_element_namespace\",\n         stringOrNil(runtime, localName),\n         stringOrNil(runtime, getPrefix(qName)),\n         stringOrNil(runtime, uri));\n  }\n\n  @Override\n  public void\n  characters(char[] ch, int start, int length)\n  {\n    charactersBuilder.append(ch, start, length);\n  }\n\n  @Override\n  public void\n  comment(char[] ch, int start, int length)\n  {\n    populateCharacters();\n    call(\"comment\", runtime.newString(new String(ch, start, length)));\n  }\n\n  @Override\n  public void\n  startCDATA()\n  {\n    populateCharacters();\n  }\n\n  @Override\n  public void\n  endCDATA()\n  {\n    call(\"cdata_block\", runtime.newString(charactersBuilder.toString()));\n    charactersBuilder.setLength(0);\n  }\n\n  void\n  handleError(SAXParseException ex)\n  {\n    try {\n      final String msg = ex.getMessage();\n      call(\"error\", runtime.newString(msg == null ? \"\" : msg));\n      addError(XmlSyntaxError.createError(runtime, ex).toThrowable());\n    } catch (RaiseException e) {\n      addError(e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void\n  error(SAXParseException ex)\n  {\n    handleError(ex);\n  }\n\n  @Override\n  public void\n  fatalError(SAXParseException ex)\n  {\n    handleError(ex);\n  }\n\n  @Override\n  public void\n  warning(SAXParseException ex)\n  {\n    final String msg = ex.getMessage();\n    call(\"warning\", runtime.newString(msg == null ? \"\" : msg));\n  }\n\n  protected synchronized void\n  addError(RaiseException e)\n  {\n    errors.add(e);\n  }\n\n  public synchronized int\n  getErrorCount()\n  {\n    return errors.size();\n  }\n\n  public synchronized RaiseException\n  getLastError()\n  {\n    return errors.getLast();\n  }\n\n  private void\n  call(String methodName)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName);\n  }\n\n  private void\n  call(String methodName, IRubyObject argument)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, argument);\n  }\n\n  private void\n  call(String methodName, IRubyObject arg1, IRubyObject arg2)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, arg1, arg2);\n  }\n\n  private void\n  call(String methodName, IRubyObject arg1, IRubyObject arg2, IRubyObject arg3)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, arg1, arg2, arg3);\n  }\n\n  private void\n  call(String methodName,\n       IRubyObject arg0,\n       IRubyObject arg1,\n       IRubyObject arg2,\n       IRubyObject arg3,\n       IRubyObject arg4)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, arg0, arg1, arg2, arg3, arg4);\n  }\n\n  private IRubyObject\n  document(ThreadContext context)\n  {\n    return object.getInstanceVariables().getInstanceVariable(\"@document\");\n  }\n\n  protected void\n  populateCharacters()\n  {\n    if (charactersBuilder.length() > 0) {\n      call(\"characters\", runtime.newString(charactersBuilder.toString()));\n      charactersBuilder.setLength(0);\n    }\n  }\n}\n", "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Error Handler for XML document when recover is true (default).\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriNonStrictErrorHandler(boolean noerror, boolean nowarning)\n  {\n    super(noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    // fix #837\n    // Xerces won't skip the reference entity (and other invalid) constructs\n    // found in the prolog, instead it will keep calling this method and we'll\n    // keep inserting the error in the document errors array until we run\n    // out of memory\n    errors.add(ex);\n    String message = ex.getMessage();\n\n    // The problem with Xerces is that some errors will cause the\n    // parser not to advance the reader and it will keep reporting\n    // the same error over and over, which will cause the parser\n    // to enter an infinite loop unless we throw the exception.\n    if (message != null && isFatal(message)) {\n      throw ex;\n    }\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /*\n   * Determine whether this is a fatal error that should cause\n   * the parsing to stop, or an error that can be ignored.\n   */\n  private static boolean\n  isFatal(String msg)\n  {\n    String msgLowerCase = msg.toLowerCase();\n    return\n      msgLowerCase.contains(\"in prolog\") ||\n      msgLowerCase.contains(\"limit\") ||\n      msgLowerCase.contains(\"preceding the root element must be well-formed\") ||\n      msgLowerCase.contains(\"following the root element must be well-formed\");\n  }\n}\n", "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Non-strict error handler for NekoHtml.\n *\n * NekoHtml adds too many warnings, which makes later processing hard. For example,\n * Nokogiri wants to know whether number of errors have been increased or not to judge\n * availability of creating NodeSet from a given fragment. When the fragment nodes\n * are to be created from HTML document, which means NekoHtml is used, always errors\n * increases. As a result, even though the given fragment is correct HTML, NodeSet\n * base on the given fragment won't be created. This is why all warnings are eliminated.\n *\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n{\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(boolean nowarning)\n  {\n    super(false, nowarning);\n  }\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(boolean noerror, boolean nowarning)\n  {\n    super(noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    //noop. NekoHtml adds too many warnings.\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    errors.add(ex);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the fatal error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The fatal error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the warning. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The warning key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    errors.add(e);\n  }\n\n}\n", "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Strict error handler. Even though strict is specified, Nokogiri allows to go further\n * when NOERROR or/both NOWARNING is/are true.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriStrictErrorHandler(boolean noerror, boolean nowarning)\n  {\n    super(noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException spex) throws SAXException\n  {\n    if (!nowarning) { throw spex; }\n    else { errors.add(spex); }\n  }\n\n  public void\n  error(SAXParseException spex) throws SAXException\n  {\n    if (!noerror) { throw spex; }\n    else { errors.add(spex); }\n  }\n\n  public void\n  fatalError(SAXParseException spex) throws SAXException\n  {\n    throw spex;\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e) throws XMLParseException\n  {\n    if (!noerror) { throw e; }\n    else { errors.add(e); }\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e) throws XMLParseException\n  {\n    throw e;\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e) throws XMLParseException\n  {\n    if (!nowarning) { throw e; }\n    if (!usesNekoHtml(domain)) { errors.add(e); }\n  }\n}\n", "package nokogiri.internals;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static nokogiri.internals.NokogiriHelpers.isBlank;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.xerces.parsers.DOMParser;\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyFixnum;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport nokogiri.NokogiriService;\nimport nokogiri.XmlDocument;\nimport nokogiri.XmlDtd;\nimport nokogiri.XmlSyntaxError;\n\n/**\n * Parser class for XML DOM processing. This class actually parses XML document\n * and creates DOM tree in Java side. However, DOM tree in Ruby side is not since\n * we delay creating objects for performance.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class XmlDomParserContext extends ParserContext\n{\n\n  protected static final String FEATURE_LOAD_EXTERNAL_DTD =\n    \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n  protected static final String FEATURE_LOAD_DTD_GRAMMAR =\n    \"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\";\n  protected static final String FEATURE_INCLUDE_IGNORABLE_WHITESPACE =\n    \"http://apache.org/xml/features/dom/include-ignorable-whitespace\";\n  protected static final String CONTINUE_AFTER_FATAL_ERROR =\n    \"http://apache.org/xml/features/continue-after-fatal-error\";\n  protected static final String FEATURE_NOT_EXPAND_ENTITY =\n    \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n  protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n  private static final String XINCLUDE_FEATURE_ID = \"http://apache.org/xml/features/xinclude\";\n  private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n\n  protected ParserContext.Options options;\n  protected DOMParser parser;\n  protected NokogiriErrorHandler errorHandler;\n  protected IRubyObject ruby_encoding;\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject options)\n  {\n    this(runtime, runtime.getNil(), options);\n  }\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject encoding, IRubyObject options)\n  {\n    super(runtime);\n    this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n    java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n    ruby_encoding = encoding;\n    initErrorHandler();\n    initParser(runtime);\n  }\n\n  protected void\n  initErrorHandler()\n  {\n    if (options.recover) {\n      errorHandler = new NokogiriNonStrictErrorHandler(options.noError, options.noWarning);\n    } else {\n      errorHandler = new NokogiriStrictErrorHandler(options.noError, options.noWarning);\n    }\n  }\n\n  protected void\n  initParser(Ruby runtime)\n  {\n    if (options.xInclude) {\n      System.setProperty(\"org.apache.xerces.xni.parser.XMLParserConfiguration\",\n                         \"org.apache.xerces.parsers.XIncludeParserConfiguration\");\n    }\n\n    parser = new NokogiriDomParser(options);\n    parser.setErrorHandler(errorHandler);\n\n    // Fix for Issue#586.  This limits entity expansion up to 100000 and nodes up to 3000.\n    setProperty(SECURITY_MANAGER, new org.apache.xerces.util.SecurityManager());\n\n    if (options.noBlanks) {\n      setFeature(FEATURE_INCLUDE_IGNORABLE_WHITESPACE, false);\n    }\n\n    if (options.recover) {\n      setFeature(CONTINUE_AFTER_FATAL_ERROR, true);\n    }\n\n    if (options.dtdValid) {\n      setFeature(FEATURE_VALIDATION, true);\n    }\n\n    if (!options.noEnt) {\n      setFeature(FEATURE_NOT_EXPAND_ENTITY, true);\n    }\n    // If we turn off loading of external DTDs complete, we don't\n    // getthe publicID.  Instead of turning off completely, we use\n    // an entity resolver that returns empty documents.\n    if (options.dtdLoad) {\n      setFeature(FEATURE_LOAD_EXTERNAL_DTD, true);\n      setFeature(FEATURE_LOAD_DTD_GRAMMAR, true);\n    }\n    parser.setEntityResolver(new NokogiriEntityResolver(runtime, errorHandler, options));\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setFeature(String feature, boolean value)\n  {\n    try {\n      parser.setFeature(feature, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setProperty(String property, Object value)\n  {\n    try {\n      parser.setProperty(property, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  public void\n  addErrorsIfNecessary(ThreadContext context, XmlDocument doc)\n  {\n    doc.setInstanceVariable(\"@errors\", mapErrors(context, errorHandler));\n  }\n\n\n  public static RubyArray\n  mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n  {\n    final Ruby runtime = context.runtime;\n    final List<Exception> errors = errorHandler.getErrors();\n    final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n    for (int i = 0; i < errors.size(); i++) {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(runtime);\n      xmlSyntaxError.setException(errors.get(i));\n      errorsAry[i] = xmlSyntaxError;\n    }\n    return runtime.newArrayNoCopy(errorsAry);\n  }\n\n  public XmlDocument\n  getDocumentWithErrorsOrRaiseException(ThreadContext context, RubyClass klazz, Exception ex)\n  {\n    if (options.recover) {\n      XmlDocument xmlDocument = getInterruptedOrNewXmlDocument(context, klazz);\n      this.addErrorsIfNecessary(context, xmlDocument);\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      ((RubyArray) xmlDocument.getInstanceVariable(\"@errors\")).append(xmlSyntaxError);\n      return xmlDocument;\n    } else {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      throw xmlSyntaxError.toThrowable();\n    }\n  }\n\n  private XmlDocument\n  getInterruptedOrNewXmlDocument(ThreadContext context, RubyClass klass)\n  {\n    Document document = parser.getDocument();\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, document);\n    xmlDocument.setEncoding(ruby_encoding);\n    return xmlDocument;\n  }\n\n  /**\n   * This method is broken out so that HtmlDomParserContext can\n   * override it.\n   */\n  protected XmlDocument\n  wrapDocument(ThreadContext context, RubyClass klass, Document doc)\n  {\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, doc);\n    Helpers.invoke(context, xmlDocument, \"initialize\");\n    xmlDocument.setEncoding(ruby_encoding);\n\n    if (options.dtdLoad) {\n      IRubyObject dtd = XmlDtd.newFromExternalSubset(context.runtime, doc);\n      if (!dtd.isNil()) {\n        doc.setUserData(XmlDocument.DTD_EXTERNAL_SUBSET, (XmlDtd) dtd, null);\n      }\n    }\n    return xmlDocument;\n  }\n\n  /**\n   * Must call setInputSource() before this method.\n   */\n  public XmlDocument\n  parse(ThreadContext context, RubyClass klass, IRubyObject url)\n  {\n    XmlDocument xmlDoc;\n    try {\n      Document doc = do_parse();\n      xmlDoc = wrapDocument(context, klass, doc);\n      xmlDoc.setUrl(url);\n      addErrorsIfNecessary(context, xmlDoc);\n      return xmlDoc;\n    } catch (SAXException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    } catch (IOException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    }\n  }\n\n  protected Document\n  do_parse() throws SAXException, IOException\n  {\n    try {\n      parser.parse(getInputSource());\n    } catch (NullPointerException ex) {\n      // FIXME: this is really a hack to fix #838. Xerces will throw a NullPointerException\n      // if we tried to parse '<? ?>'. We should submit a patch to Xerces.\n    }\n    if (options.noBlanks) {\n      List<Node> emptyNodes = new ArrayList<Node>();\n      findEmptyTexts(parser.getDocument(), emptyNodes);\n      if (emptyNodes.size() > 0) {\n        for (Node node : emptyNodes) {\n          node.getParentNode().removeChild(node);\n        }\n      }\n    }\n    return parser.getDocument();\n  }\n\n  private static void\n  findEmptyTexts(Node node, List<Node> emptyNodes)\n  {\n    if (node.getNodeType() == Node.TEXT_NODE && isBlank(node.getTextContent())) {\n      emptyNodes.add(node);\n    } else {\n      NodeList children = node.getChildNodes();\n      for (int i = 0; i < children.getLength(); i++) {\n        findEmptyTexts(children.item(i), emptyNodes);\n      }\n    }\n  }\n}\n", "# frozen_string_literal: true\n\nrequire \"helper\"\n\nmodule Nokogiri\n  module XML\n    module SAX\n      class TestParser < Nokogiri::SAX::TestCase\n        def setup\n          super\n          @parser = XML::SAX::Parser.new(Doc.new)\n        end\n\n        def test_parser_context_yielded_io\n          doc = Doc.new\n          parser = XML::SAX::Parser.new(doc)\n          xml = \"<foo a='&amp;b'/>\"\n\n          block_called = false\n          parser.parse(StringIO.new(xml)) do |ctx|\n            block_called = true\n            ctx.replace_entities = true\n          end\n\n          assert(block_called)\n\n          assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n        end\n\n        def test_parser_context_yielded_in_memory\n          doc = Doc.new\n          parser = XML::SAX::Parser.new(doc)\n          xml = \"<foo a='&amp;b'/>\"\n\n          block_called = false\n          parser.parse(xml) do |ctx|\n            block_called = true\n            ctx.replace_entities = true\n          end\n\n          assert(block_called)\n\n          assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n        end\n\n        def test_empty_decl\n          parser = XML::SAX::Parser.new(Doc.new)\n\n          xml = \"<root />\"\n          parser.parse(xml)\n          assert(parser.document.start_document_called, xml)\n          assert_nil(parser.document.xmldecls, xml)\n        end\n\n        def test_xml_decl\n          [\n            ['<?xml version=\"1.0\" ?>', [\"1.0\"]],\n            ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],\n            ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],\n            ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],\n            ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],\n            ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],\n          ].each do |decl, value|\n            parser = XML::SAX::Parser.new(Doc.new)\n\n            xml = \"#{decl}\\n<root />\"\n            parser.parse(xml)\n            assert(parser.document.start_document_called, xml)\n            assert_equal(value, parser.document.xmldecls, xml)\n          end\n        end\n\n        def test_parse_empty\n          assert_raises(RuntimeError) do\n            @parser.parse(\"\")\n          end\n        end\n\n        def test_namespace_declaration_order_is_saved\n          @parser.parse(<<~eoxml)\n            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n              <a foo:bar='hello' />\n            </root>\n          eoxml\n          assert_equal(2, @parser.document.start_elements_namespace.length)\n          el = @parser.document.start_elements_namespace.first\n          namespaces = el.last\n          assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)\n          assert_equal([nil, \"http://example.com/\"], namespaces.last)\n        end\n\n        def test_bad_document_calls_error_handler\n          @parser.parse(\"<foo><bar></foo>\")\n          assert(@parser.document.errors)\n          assert(@parser.document.errors.length > 0)\n        end\n\n        def test_namespace_are_super_fun_to_parse\n          @parser.parse(<<~eoxml)\n            <root xmlns:foo='http://foo.example.com/'>\n              <a foo:bar='hello' />\n              <b xmlns:foo='http://bar.example.com/'>\n                <a foo:bar='hello' />\n              </b>\n              <foo:bar>hello world</foo:bar>\n            </root>\n          eoxml\n\n          assert(@parser.document.start_elements_namespace.length > 0)\n          el = @parser.document.start_elements_namespace[1]\n          assert_equal(\"a\", el.first)\n          assert_equal(1, el[1].length)\n\n          attribute = el[1].first\n          assert_equal(\"bar\", attribute.localname)\n          assert_equal(\"foo\", attribute.prefix)\n          assert_equal(\"hello\", attribute.value)\n          assert_equal(\"http://foo.example.com/\", attribute.uri)\n        end\n\n        def test_sax_v1_namespace_attribute_declarations\n          @parser.parse(<<~eoxml)\n            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n              <a foo:bar='hello' />\n              <b xmlns:foo='http://bar.example.com/'>\n                <a foo:bar='hello' />\n              </b>\n              <foo:bar>hello world</foo:bar>\n            </root>\n          eoxml\n          assert(@parser.document.start_elements.length > 0)\n          elm = @parser.document.start_elements.first\n          assert_equal(\"root\", elm.first)\n          assert(elm[1].include?([\"xmlns:foo\", \"http://foo.example.com/\"]))\n          assert(elm[1].include?([\"xmlns\", \"http://example.com/\"]))\n        end\n\n        def test_sax_v1_namespace_nodes\n          @parser.parse(<<~eoxml)\n            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n              <a foo:bar='hello' />\n              <b xmlns:foo='http://bar.example.com/'>\n                <a foo:bar='hello' />\n              </b>\n              <foo:bar>hello world</foo:bar>\n            </root>\n          eoxml\n          assert_equal(5, @parser.document.start_elements.length)\n          assert(@parser.document.start_elements.map(&:first).include?(\"foo:bar\"))\n          assert(@parser.document.end_elements.map(&:first).include?(\"foo:bar\"))\n        end\n\n        def test_start_is_called_without_namespace\n          @parser.parse(<<~eoxml)\n            <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n            <foo:f><bar></foo:f>\n            </root>\n          eoxml\n          assert_equal([\"root\", \"foo:f\", \"bar\"],\n                       @parser.document.start_elements.map(&:first))\n        end\n\n        def test_parser_sets_encoding\n          parser = XML::SAX::Parser.new(Doc.new, \"UTF-8\")\n          assert_equal(\"UTF-8\", parser.encoding)\n        end\n\n        def test_errors_set_after_parsing_bad_dom\n          doc = Nokogiri::XML(\"<foo><bar></foo>\")\n          assert(doc.errors)\n\n          @parser.parse(\"<foo><bar></foo>\")\n          assert(@parser.document.errors)\n          assert(@parser.document.errors.length > 0)\n\n          doc.errors.each do |error|\n            assert_equal(\"UTF-8\", error.message.encoding.name)\n          end\n\n          # when using JRuby Nokogiri, more errors will be generated as the DOM\n          # parser continue to parse an ill formed document, while the sax parser\n          # will stop at the first error\n          unless Nokogiri.jruby?\n            assert_equal(doc.errors.length, @parser.document.errors.length)\n          end\n        end\n\n        def test_parse_with_memory_argument\n          @parser.parse(File.read(XML_FILE))\n          assert(@parser.document.cdata_blocks.length > 0)\n        end\n\n        def test_parse_with_io_argument\n          File.open(XML_FILE, \"rb\") do |f|\n            @parser.parse(f)\n          end\n          assert(@parser.document.cdata_blocks.length > 0)\n        end\n\n        def test_parse_io\n          call_parse_io_with_encoding(\"UTF-8\")\n        end\n\n        # issue #828\n        def test_parse_io_lower_case_encoding\n          call_parse_io_with_encoding(\"utf-8\")\n        end\n\n        def call_parse_io_with_encoding(encoding)\n          File.open(XML_FILE, \"rb\") do |f|\n            @parser.parse_io(f, encoding)\n          end\n          assert(@parser.document.cdata_blocks.length > 0)\n\n          called = false\n          @parser.document.start_elements.flatten.each do |thing|\n            assert_equal(\"UTF-8\", thing.encoding.name)\n            called = true\n          end\n          assert(called)\n\n          called = false\n          @parser.document.end_elements.flatten.each do |thing|\n            assert_equal(\"UTF-8\", thing.encoding.name)\n            called = true\n          end\n          assert(called)\n\n          called = false\n          @parser.document.data.each do |thing|\n            assert_equal(\"UTF-8\", thing.encoding.name)\n            called = true\n          end\n          assert(called)\n\n          called = false\n          @parser.document.comments.flatten.each do |thing|\n            assert_equal(\"UTF-8\", thing.encoding.name)\n            called = true\n          end\n          assert(called)\n\n          called = false\n          @parser.document.cdata_blocks.flatten.each do |thing|\n            assert_equal(\"UTF-8\", thing.encoding.name)\n            called = true\n          end\n          assert(called)\n        end\n\n        def test_parse_file\n          @parser.parse_file(XML_FILE)\n\n          assert_raises(ArgumentError) do\n            @parser.parse_file(nil)\n          end\n\n          assert_raises(Errno::ENOENT) do\n            @parser.parse_file(\"\")\n          end\n          assert_raises(Errno::EISDIR) do\n            @parser.parse_file(File.expand_path(File.dirname(__FILE__)))\n          end\n        end\n\n        def test_render_parse_nil_param\n          assert_raises(ArgumentError) { @parser.parse_memory(nil) }\n        end\n\n        def test_bad_encoding_args\n          assert_raises(ArgumentError) { XML::SAX::Parser.new(Doc.new, \"not an encoding\") }\n          assert_raises(ArgumentError) { @parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }\n        end\n\n        def test_ctag\n          @parser.parse_memory(<<~eoxml)\n            <p id=\"asdfasdf\">\n              <![CDATA[ This is a comment ]]>\n              Paragraph 1\n            </p>\n          eoxml\n          assert_equal([\" This is a comment \"], @parser.document.cdata_blocks)\n        end\n\n        def test_comment\n          @parser.parse_memory(<<~eoxml)\n            <p id=\"asdfasdf\">\n              <!-- This is a comment -->\n              Paragraph 1\n            </p>\n          eoxml\n          assert_equal([\" This is a comment \"], @parser.document.comments)\n        end\n\n        def test_characters\n          @parser.parse_memory(<<~eoxml)\n            <p id=\"asdfasdf\">Paragraph 1</p>\n          eoxml\n          assert_equal([\"Paragraph 1\"], @parser.document.data)\n        end\n\n        def test_end_document\n          @parser.parse_memory(<<~eoxml)\n            <p id=\"asdfasdf\">Paragraph 1</p>\n          eoxml\n          assert(@parser.document.end_document_called)\n        end\n\n        def test_end_element\n          @parser.parse_memory(<<~eoxml)\n            <p id=\"asdfasdf\">Paragraph 1</p>\n          eoxml\n          assert_equal([[\"p\"]], @parser.document.end_elements)\n        end\n\n        def test_start_element_attrs\n          @parser.parse_memory(<<~eoxml)\n            <p id=\"asdfasdf\">Paragraph 1</p>\n          eoxml\n          assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], @parser.document.start_elements)\n        end\n\n        def test_start_element_attrs_include_namespaces\n          @parser.parse_memory(<<~eoxml)\n            <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>\n          eoxml\n          assert_equal([[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n                       @parser.document.start_elements)\n        end\n\n        def test_processing_instruction\n          @parser.parse_memory(<<~eoxml)\n            <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>\n            <?xml version=\"1.0\"?>\n          eoxml\n          assert_equal([[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],\n                       @parser.document.processing_instructions)\n        end\n\n        def test_parse_document\n          skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")\n          @parser.parse_memory(<<~eoxml)\n            <p>Paragraph 1</p>\n            <p>Paragraph 2</p>\n          eoxml\n        end\n\n        def test_parser_attributes\n          xml = <<~eoxml\n            <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>\n          eoxml\n\n          block_called = false\n          @parser.parse(xml) do |ctx|\n            block_called = true\n            ctx.replace_entities = true\n          end\n\n          assert(block_called)\n\n          assert_equal([[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], @parser.document.start_elements)\n        end\n\n        def test_recovery_from_incorrect_xml\n          xml = <<~eoxml\n            <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>\n          eoxml\n\n          block_called = false\n          @parser.parse(xml) do |ctx|\n            block_called = true\n            ctx.recovery = true\n          end\n\n          assert(block_called)\n\n          assert_equal([[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],\n                       @parser.document.start_elements)\n        end\n\n        def test_square_bracket_in_text # issue 1261\n          xml = <<~eoxml\n            <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">\n              <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>\n              <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>\n            </tu>\n          eoxml\n          @parser.parse(xml)\n          assert_includes(@parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")\n        end\n\n        def test_large_cdata_is_handled\n          # see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200\n          skip(\"Upstream libxml2 <= 2.9.10 needs to be patched\") if Nokogiri::VersionInfo.instance.libxml2_using_system?\n\n          template = <<~EOF\n            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">\n               <soapenv:Header>\n                  <AuthHeader xsi:type=\"ns:vAuthHeader\">\n                  <userName xsi:type=\"xsd:string\">gorilla</userName>\n                  <password xsi:type=\"xsd:string\">secret</password>\n                </AuthHeader>\n               </soapenv:Header>\n              <soapenv:Body>\n                <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n                  <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>\n                </ns:checkToken>\n               </soapenv:Body>\n            </soapenv:Envelope>\n          EOF\n\n          factor = 10\n          huge_data = \"a\" * (1024 * 1024 * factor)\n          xml = StringIO.new(template % (huge_data))\n\n          handler = Nokogiri::SAX::TestCase::Doc.new\n          parser = Nokogiri::XML::SAX::Parser.new(handler)\n          parser.parse(xml)\n\n          assert_predicate(handler.errors, :empty?)\n        end\n      end\n    end\n  end\nend\n", "# -*- coding: utf-8 -*-\n\nrequire \"helper\"\n\nmodule Nokogiri\n  module XML\n    module SAX\n      class TestPushParser < Nokogiri::SAX::TestCase\n        def setup\n          super\n          @parser = XML::SAX::PushParser.new(Doc.new)\n        end\n\n        def test_exception\n          assert_raises(SyntaxError) do\n            @parser << \"<foo /><foo />\"\n          end\n\n          assert_raises(SyntaxError) do\n            @parser << nil\n          end\n        end\n\n        def test_early_finish\n          @parser << \"<foo>\"\n          assert_raises(SyntaxError) do\n            @parser.finish\n          end\n        end\n\n        def test_write_last_chunk\n          @parser << \"<foo>\"\n          @parser.write \"</foo>\", true\n          assert_equal [[\"foo\", []]], @parser.document.start_elements\n          assert_equal [[\"foo\"]], @parser.document.end_elements\n        end\n\n        def test_empty_doc\n          @parser.options |= XML::ParseOptions::RECOVER\n          @parser.write \"\", true\n          assert_nil @parser.document.start_elements\n          assert_nil @parser.document.end_elements\n        end\n\n\n        def test_finish_should_rethrow_last_error\n          begin\n            @parser << \"</foo>\"\n          rescue => e\n            expected = e\n          end\n\n          begin\n            @parser.finish\n          rescue => e\n            actual = e\n          end\n\n          assert_equal actual.message, expected.message\n        end\n\n        def test_should_throw_error_returned_by_document\n          doc = Doc.new\n          class << doc\n            def error msg\n              raise \"parse error\"\n            end\n          end\n\n          @parser = XML::SAX::PushParser.new(doc)\n          begin\n            @parser << \"</foo>\"\n          rescue => e\n            actual = e\n          end\n          fail 'PushParser should throw error when fed ill-formed data' if actual.nil?\n\n          assert_equal actual.message, \"parse error\"\n        end\n\n        def test_writing_nil\n          assert_equal @parser.write(nil), @parser\n        end\n\n        def test_end_document_called\n          @parser.<<(<<-eoxml)\n            <p id=\"asdfasdf\">\n              <!-- This is a comment -->\n              Paragraph 1\n            </p>\n          eoxml\n          assert ! @parser.document.end_document_called\n          @parser.finish\n          assert @parser.document.end_document_called\n        end\n\n        def test_start_element\n          @parser.<<(<<-eoxml)\n            <p id=\"asdfasdf\">\n          eoxml\n\n          assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],\n            @parser.document.start_elements\n\n          @parser.<<(<<-eoxml)\n              <!-- This is a comment -->\n              Paragraph 1\n            </p>\n          eoxml\n          assert_equal [' This is a comment '], @parser.document.comments\n          @parser.finish\n        end\n\n        def test_start_element_with_namespaces\n          @parser.<<(<<-eoxml)\n            <p xmlns:foo=\"http://foo.example.com/\">\n          eoxml\n\n          assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n            @parser.document.start_elements\n\n          @parser.<<(<<-eoxml)\n              <!-- This is a comment -->\n              Paragraph 1\n            </p>\n          eoxml\n          assert_equal [' This is a comment '], @parser.document.comments\n          @parser.finish\n        end\n\n        def test_start_element_ns\n          @parser.<<(<<-eoxml)\n            <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>\n          eoxml\n\n          assert_equal 1, @parser.document.start_elements_namespace.length\n          el = @parser.document.start_elements_namespace.first\n\n          assert_equal 'stream', el.first\n          assert_equal 2, el[1].length\n          assert_equal [['version', '1.0'], ['size', 'large']],\n            el[1].map { |x| [x.localname, x.value] }\n\n          assert_equal 'stream', el[2]\n          assert_equal 'http://etherx.jabber.org/streams', el[3]\n          @parser.finish\n        end\n\n        def test_end_element_ns\n          @parser.<<(<<-eoxml)\n            <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>\n          eoxml\n\n          assert_equal [['stream', 'stream', 'http://etherx.jabber.org/streams']],\n            @parser.document.end_elements_namespace\n          @parser.finish\n        end\n\n        def test_chevron_partial_xml\n          @parser.<<(<<-eoxml)\n            <p id=\"asdfasdf\">\n          eoxml\n\n          @parser.<<(<<-eoxml)\n              <!-- This is a comment -->\n              Paragraph 1\n            </p>\n          eoxml\n          assert_equal [' This is a comment '], @parser.document.comments\n          @parser.finish\n        end\n\n        def test_chevron\n          @parser.<<(<<-eoxml)\n            <p id=\"asdfasdf\">\n              <!-- This is a comment -->\n              Paragraph 1\n            </p>\n          eoxml\n          @parser.finish\n          assert_equal [' This is a comment '], @parser.document.comments\n        end\n\n        def test_default_options\n          assert_equal 0, @parser.options\n        end\n\n        def test_recover\n          @parser.options |= XML::ParseOptions::RECOVER\n          @parser.<<(<<-eoxml)\n            <p>\n              Foo\n              <bar>\n              Bar\n            </p>\n          eoxml\n          @parser.finish\n          assert(@parser.document.errors.size >= 1)\n          assert_equal [[\"p\", []], [\"bar\", []]], @parser.document.start_elements\n          assert_equal \"FooBar\", @parser.document.data.map { |x|\n            x.gsub(/\\s/, '')\n          }.join\n        end\n\n        def test_broken_encoding\n          skip_unless_libxml2(\"ultra hard to fix for pure Java version\")\n          @parser.options |= XML::ParseOptions::RECOVER\n          # This is ISO_8859-1:\n          @parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"\n          @parser.finish\n          assert(@parser.document.errors.size >= 1)\n          assert_equal \"Gau\\337\", @parser.document.data.join\n          assert_equal [[\"r\"]], @parser.document.end_elements\n        end\n\n        def test_replace_entities_attribute_behavior\n          if Nokogiri.uses_libxml?\n            # initially false\n            assert_equal false, @parser.replace_entities\n\n            # can be set to true\n            @parser.replace_entities = true\n            assert_equal true, @parser.replace_entities\n\n            # can be set to false\n            @parser.replace_entities = false\n            assert_equal false, @parser.replace_entities\n          else\n            # initially true\n            assert_equal true, @parser.replace_entities\n\n            # ignore attempts to set to false\n            @parser.replace_entities = false # TODO: should we raise an exception here?\n            assert_equal true, @parser.replace_entities\n          end\n        end\n\n        def test_untouched_entities\n          skip_unless_libxml2(\"entities are always replaced in pure Java version\")\n          @parser.<<(<<-eoxml)\n            <p id=\"asdf&amp;asdf\">\n              <!-- This is a comment -->\n              Paragraph 1 &amp; 2\n            </p>\n          eoxml\n          @parser.finish\n          assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], @parser.document.start_elements\n          assert_equal \"Paragraph 1 & 2\", @parser.document.data.join.strip\n        end\n\n        def test_replaced_entities\n          @parser.replace_entities = true\n          @parser.<<(<<-eoxml)\n            <p id=\"asdf&amp;asdf\">\n              <!-- This is a comment -->\n              Paragraph 1 &amp; 2\n            </p>\n          eoxml\n          @parser.finish\n          assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], @parser.document.start_elements\n          assert_equal \"Paragraph 1 & 2\", @parser.document.data.join.strip\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["package nokogiri;\n\nimport nokogiri.internals.ClosedStreamException;\nimport nokogiri.internals.NokogiriBlockingQueueInputStream;\nimport nokogiri.internals.NokogiriHelpers;\nimport nokogiri.internals.ParserContext;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.*;\n\nimport static nokogiri.XmlSaxPushParser.terminateExecution;\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\n/**\n * Class for Nokogiri::HTML4::SAX::PushParser\n *\n * @author\n * @author Piotr Szmielew <p.szmielew@ava.waw.pl> - based on Nokogiri::XML::SAX::PushParser\n */\n@JRubyClass(name = \"Nokogiri::HTML4::SAX::PushParser\")\npublic class Html4SaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<Html4SaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n\n  public\n  Html4SaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context,\n                    IRubyObject saxParser,\n                    IRubyObject fileName,\n                    IRubyObject encoding)\n  {\n    // NOTE: Silently skips provided encoding\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk, IRubyObject isLast)\n  {\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.getRuntime().newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      terminateTask(context.runtime);\n      throw XmlSyntaxError.createHTMLSyntaxError(context.runtime).toThrowable(); // Nokogiri::HTML4::SyntaxError\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    if (isLast.isTrue()) {\n      IRubyObject document = invoke(context, this, \"document\");\n      invoke(context, document, \"end_document\");\n      terminateTask(context.runtime);\n    } else {\n      try {\n        Future<Void> task = stream.addChunk(data);\n        task.get();\n      } catch (ClosedStreamException ex) {\n        // this means the stream is closed, ignore this exception\n      } catch (Exception e) {\n        throw context.runtime.newRuntimeError(e.getMessage());\n      }\n\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      throw parserTask.getLastError().toThrowable();\n    }\n\n    return this;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<Html4SaxParserContext>((Callable) parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"Html4SaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  private static Html4SaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::HTML4::SAX::ParserContext\");\n    return Html4SaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends XmlSaxPushParser.ParserTask /* <Html4SaxPushParser> */\n  {\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      super(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    @Override\n    public Html4SaxParserContext\n    call() throws Exception\n    {\n      return (Html4SaxParserContext) super.call();\n    }\n\n  }\n\n}\n", "package nokogiri;\n\nimport nokogiri.internals.*;\nimport org.apache.xerces.parsers.AbstractSAXParser;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyFixnum;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static org.jruby.runtime.Helpers.invoke;\n\n/**\n * Base class for the SAX parsers.\n *\n * @author Patrick Mahoney <pat@polycrystal.org>\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name = \"Nokogiri::XML::SAX::ParserContext\")\npublic class XmlSaxParserContext extends ParserContext\n{\n\n  protected static final String FEATURE_NAMESPACES =\n    \"http://xml.org/sax/features/namespaces\";\n  protected static final String FEATURE_NAMESPACE_PREFIXES =\n    \"http://xml.org/sax/features/namespace-prefixes\";\n  protected static final String FEATURE_LOAD_EXTERNAL_DTD =\n    \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n  protected static final String FEATURE_CONTINUE_AFTER_FATAL_ERROR =\n    \"http://apache.org/xml/features/continue-after-fatal-error\";\n\n  protected AbstractSAXParser parser;\n\n  protected NokogiriHandler handler;\n  protected NokogiriErrorHandler errorHandler;\n  private boolean replaceEntities = true;\n  private boolean recovery = false;\n\n  public\n  XmlSaxParserContext(final Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  protected void\n  initialize(Ruby runtime)\n  {\n    try {\n      parser = createParser();\n    } catch (SAXException se) {\n      // Unexpected failure in XML subsystem\n      RaiseException ex = runtime.newRuntimeError(se.toString());\n      ex.initCause(se);\n      throw ex;\n    }\n  }\n\n  /**\n   * Create and return a copy of this object.\n   *\n   * @return a clone of this object\n   */\n  @Override\n  public Object\n  clone() throws CloneNotSupportedException\n  {\n    return super.clone();\n  }\n\n  protected AbstractSAXParser\n  createParser() throws SAXException\n  {\n    XmlSaxParser parser = new XmlSaxParser();\n    parser.setFeature(FEATURE_NAMESPACE_PREFIXES, true);\n    parser.setFeature(FEATURE_LOAD_EXTERNAL_DTD, false);\n    return parser;\n  }\n\n  /**\n   * Create a new parser context that will parse the string\n   * <code>data</code>.\n   */\n  @JRubyMethod(name = \"memory\", meta = true)\n  public static IRubyObject\n  parse_memory(ThreadContext context,\n               IRubyObject klazz,\n               IRubyObject data)\n  {\n    final Ruby runtime = context.runtime;\n    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);\n    ctx.initialize(runtime);\n    ctx.setStringInputSource(context, data, runtime.getNil());\n    return ctx;\n  }\n\n  /**\n   * Create a new parser context that will read from the file\n   * <code>data</code> and parse.\n   */\n  @JRubyMethod(name = \"file\", meta = true)\n  public static IRubyObject\n  parse_file(ThreadContext context,\n             IRubyObject klazz,\n             IRubyObject data)\n  {\n    final Ruby runtime = context.runtime;\n    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);\n    ctx.initialize(context.getRuntime());\n    ctx.setInputSourceFile(context, data);\n    return ctx;\n  }\n\n  /**\n   * Create a new parser context that will read from the IO or\n   * StringIO <code>data</code> and parse.\n   *\n   * TODO: Currently ignores encoding <code>enc</code>.\n   */\n  @JRubyMethod(name = \"io\", meta = true)\n  public static IRubyObject\n  parse_io(ThreadContext context,\n           IRubyObject klazz,\n           IRubyObject data,\n           IRubyObject enc)\n  {\n    //int encoding = (int)enc.convertToInteger().getLongValue();\n    final Ruby runtime = context.runtime;\n    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);\n    ctx.initialize(runtime);\n    ctx.setIOInputSource(context, data, runtime.getNil());\n    return ctx;\n  }\n\n  /**\n   * Create a new parser context that will read from a raw input stream.\n   * Meant to be run in a separate thread by XmlSaxPushParser.\n   */\n  static XmlSaxParserContext\n  parse_stream(final Ruby runtime, RubyClass klazz, InputStream stream)\n  {\n    XmlSaxParserContext ctx = newInstance(runtime, klazz);\n    ctx.initialize(runtime);\n    ctx.setInputSource(stream);\n    return ctx;\n  }\n\n  private static XmlSaxParserContext\n  newInstance(final Ruby runtime, final RubyClass klazz)\n  {\n    return (XmlSaxParserContext) NokogiriService.XML_SAXPARSER_CONTEXT_ALLOCATOR.allocate(runtime, klazz);\n  }\n\n  public final NokogiriHandler\n  getNokogiriHandler() { return handler; }\n\n  public final NokogiriErrorHandler\n  getNokogiriErrorHandler() { return errorHandler; }\n\n  /**\n   * Perform any initialization prior to parsing with the handler\n   * <code>handlerRuby</code>. Convenience hook for subclasses.\n   */\n  protected void\n  preParse(Ruby runtime, IRubyObject handlerRuby, NokogiriHandler handler)\n  {\n    ((XmlSaxParser) parser).setXmlDeclHandler(handler);\n    if (recovery) {\n      try {\n        parser.setFeature(FEATURE_CONTINUE_AFTER_FATAL_ERROR, true);\n      } catch (Exception e) {\n        // Unexpected failure in XML subsystem\n        throw runtime.newRuntimeError(e.getMessage());\n      }\n    }\n  }\n\n  protected void\n  postParse(Ruby runtime, IRubyObject handlerRuby, NokogiriHandler handler)\n  {\n    // noop\n  }\n\n  protected void\n  do_parse() throws SAXException, IOException\n  {\n    parser.parse(getInputSource());\n  }\n\n  protected static Options\n  defaultParseOptions(ThreadContext context)\n  {\n    return new ParserContext.Options(\n             RubyFixnum.fix2long(Helpers.invoke(context,\n                                 ((RubyClass)context.getRuntime().getClassFromPath(\"Nokogiri::XML::ParseOptions\"))\n                                 .getConstant(\"DEFAULT_XML\"),\n                                 \"to_i\"))\n           );\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  parse_with(ThreadContext context, IRubyObject handlerRuby)\n  {\n    final Ruby runtime = context.getRuntime();\n\n    if (!invoke(context, handlerRuby, \"respond_to?\", runtime.newSymbol(\"document\")).isTrue()) {\n      throw runtime.newArgumentError(\"argument must respond_to document\");\n    }\n\n    /* TODO: how should we pass in parse options? */\n    ParserContext.Options options = defaultParseOptions(context);\n\n    errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n    handler = new NokogiriHandler(runtime, handlerRuby, errorHandler);\n\n    preParse(runtime, handlerRuby, handler);\n    parser.setContentHandler(handler);\n    parser.setErrorHandler(handler);\n    parser.setEntityResolver(new NokogiriEntityResolver(runtime, errorHandler, options));\n\n    try {\n      parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n    } catch (Exception ex) {\n      throw runtime.newRuntimeError(\"Problem while creating XML SAX Parser: \" + ex.toString());\n    }\n\n    try {\n      try {\n        do_parse();\n      } catch (SAXParseException ex) {\n        // A bad document (<foo><bar></foo>) should call the\n        // error handler instead of raising a SAX exception.\n\n        // However, an EMPTY document should raise a RuntimeError.\n        // This is a bit kludgy, but AFAIK SAX doesn't distinguish\n        // between empty and bad whereas Nokogiri does.\n        String message = ex.getMessage();\n        if (message != null && message.contains(\"Premature end of file.\") && stringDataSize < 1) {\n          throw runtime.newRuntimeError(\"couldn't parse document: \" + message);\n        }\n        handler.error(ex);\n      }\n    } catch (SAXException ex) {\n      // Unexpected failure in XML subsystem\n      throw runtime.newRuntimeError(ex.getMessage());\n    } catch (IOException ex) {\n      throw runtime.newIOErrorFromException(ex);\n    }\n\n    postParse(runtime, handlerRuby, handler);\n\n    return runtime.getNil();\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  set_replace_entities(ThreadContext context, IRubyObject value)\n  {\n    replaceEntities = value.isTrue();\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  get_replace_entities(ThreadContext context)\n  {\n    return context.runtime.newBoolean(replaceEntities);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"recovery=\")\n  public IRubyObject\n  set_recovery(ThreadContext context, IRubyObject value)\n  {\n    recovery = value.isTrue();\n    return this;\n  }\n\n  @JRubyMethod(name = \"recovery\")\n  public IRubyObject\n  get_recovery(ThreadContext context)\n  {\n    return context.runtime.newBoolean(recovery);\n  }\n\n  @JRubyMethod(name = \"column\")\n  public IRubyObject\n  column(ThreadContext context)\n  {\n    final Integer number = handler.getColumn();\n    if (number == null) { return context.getRuntime().getNil(); }\n    return RubyFixnum.newFixnum(context.getRuntime(), number.longValue());\n  }\n\n  @JRubyMethod(name = \"line\")\n  public IRubyObject\n  line(ThreadContext context)\n  {\n    final Integer number = handler.getLine();\n    if (number == null) { return context.getRuntime().getNil(); }\n    return RubyFixnum.newFixnum(context.getRuntime(), number.longValue());\n  }\n}\n", "package nokogiri;\n\nimport nokogiri.internals.*;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyException;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.concurrent.*;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\nimport static org.jruby.runtime.Helpers.invoke;\n\n/**\n * Class for Nokogiri::XML::SAX::PushParser\n *\n * @author Patrick Mahoney <pat@polycrystal.org>\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name = \"Nokogiri::XML::SAX::PushParser\")\npublic class XmlSaxPushParser extends RubyObject\n{\n  ParserContext.Options options;\n  IRubyObject saxParser;\n\n  NokogiriBlockingQueueInputStream stream;\n\n  private ParserTask parserTask = null;\n  private FutureTask<XmlSaxParserContext> futureTask = null;\n  private ExecutorService executor = null;\n  RaiseException ex = null;\n\n  public\n  XmlSaxPushParser(Ruby ruby, RubyClass rubyClass)\n  {\n    super(ruby, rubyClass);\n  }\n\n  @Override\n  public void\n  finalize()\n  {\n    try {\n      terminateImpl();\n    } catch (Exception e) { /* ignored */ }\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  initialize_native(final ThreadContext context, IRubyObject saxParser, IRubyObject fileName)\n  {\n    options = new ParserContext.Options(0);\n    this.saxParser = saxParser;\n    return this;\n  }\n\n  private transient IRubyObject parse_options;\n\n  private IRubyObject\n  parse_options(final ThreadContext context)\n  {\n    if (parse_options == null) {\n      parse_options = invoke(context, context.runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\"), \"new\");\n    }\n    return parse_options;\n  }\n\n  @JRubyMethod(name = \"options\")\n  public IRubyObject\n  getOptions(ThreadContext context)\n  {\n    return invoke(context, parse_options(context), \"options\");\n  }\n\n  @JRubyMethod(name = \"options=\")\n  public IRubyObject\n  setOptions(ThreadContext context, IRubyObject opts)\n  {\n    invoke(context, parse_options(context), \"options=\", opts);\n    options = new ParserContext.Options(opts.convertToInteger().getLongValue());\n    return getOptions(context);\n  }\n\n  /**\n   * Can take a boolean assignment.\n   *\n   * @param context\n   * @param value\n   * @return\n   */\n  @JRubyMethod(name = \"replace_entities=\")\n  public IRubyObject\n  setReplaceEntities(ThreadContext context, IRubyObject value)\n  {\n    // Ignore the value.\n    return this;\n  }\n\n  @JRubyMethod(name = \"replace_entities\")\n  public IRubyObject\n  getReplaceEntities(ThreadContext context)\n  {\n    // The java parser always replaces entities.\n    return context.getRuntime().getTrue();\n  }\n\n  @JRubyMethod\n  public IRubyObject\n  native_write(ThreadContext context, IRubyObject chunk,\n               IRubyObject isLast)\n  {\n    if (ex != null) {\n      // parser has already errored, rethrow the exception\n      throw ex;\n    }\n\n    try {\n      initialize_task(context);\n    } catch (IOException e) {\n      throw context.runtime.newRuntimeError(e.getMessage());\n    }\n    final ByteArrayInputStream data = NokogiriHelpers.stringBytesToStream(chunk);\n    if (data == null) {\n      return this;\n    }\n\n    int errorCount0 = parserTask.getErrorCount();\n\n    try {\n      Future<Void> task = stream.addChunk(data);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // this means the stream is closed, ignore this exception\n    } catch (Exception e) {\n      throw context.runtime.newRuntimeError(e.toString());\n    }\n\n    if (isLast.isTrue()) {\n      parserTask.getNokogiriHandler().endDocument();\n      terminateTask(context.runtime);\n    }\n\n    if (!options.recover && parserTask.getErrorCount() > errorCount0) {\n      terminateTask(context.runtime);\n      ex = parserTask.getLastError().toThrowable();\n      throw ex;\n    }\n\n    return this;\n  }\n\n  private void\n  initialize_task(ThreadContext context) throws IOException\n  {\n    if (futureTask == null || stream == null) {\n      stream = new NokogiriBlockingQueueInputStream();\n\n      assert saxParser != null : \"saxParser null\";\n      parserTask = new ParserTask(context, saxParser, stream);\n      futureTask = new FutureTask<XmlSaxParserContext>(parserTask);\n      executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n          Thread t = new Thread(r);\n          t.setName(\"XmlSaxPushParser\");\n          t.setDaemon(true);\n          return t;\n        }\n      });\n      executor.submit(futureTask);\n    }\n  }\n\n  private void\n  terminateTask(final Ruby runtime)\n  {\n    if (executor == null) { return; }\n\n    try {\n      terminateImpl();\n    } catch (InterruptedException e) {\n      throw runtime.newRuntimeError(e.toString());\n    } catch (Exception e) {\n      throw runtime.newRuntimeError(e.toString());\n    }\n  }\n\n  private synchronized void\n  terminateImpl() throws InterruptedException, ExecutionException\n  {\n    terminateExecution(executor, stream, futureTask);\n\n    executor = null;\n    stream = null;\n    futureTask = null;\n  }\n\n  // SHARED for Html4SaxPushParser\n  static void\n  terminateExecution(final ExecutorService executor, final NokogiriBlockingQueueInputStream stream,\n                     final FutureTask<?> futureTask)\n  throws InterruptedException, ExecutionException\n  {\n\n    if (executor == null) { return; }\n\n    try {\n      Future<Void> task = stream.addChunk(NokogiriBlockingQueueInputStream.END);\n      task.get();\n    } catch (ClosedStreamException ex) {\n      // ignore this exception, it means the stream was closed\n    }\n    futureTask.cancel(true);\n    executor.shutdown();\n  }\n\n  private static XmlSaxParserContext\n  parse(final Ruby runtime, final InputStream stream)\n  {\n    RubyClass klazz = getNokogiriClass(runtime, \"Nokogiri::XML::SAX::ParserContext\");\n    return XmlSaxParserContext.parse_stream(runtime, klazz, stream);\n  }\n\n  static class ParserTask extends ParserContext.ParserTask<XmlSaxParserContext>\n  {\n\n    final InputStream stream;\n\n    private\n    ParserTask(ThreadContext context, IRubyObject handler, InputStream stream)\n    {\n      this(context, handler, parse(context.runtime, stream), stream);\n    }\n\n    // IMPL with Html4SaxPushParser\n    protected\n    ParserTask(ThreadContext context, IRubyObject handler, XmlSaxParserContext parser, InputStream stream)\n    {\n      super(context, handler, parser);\n      this.stream = stream;\n    }\n\n    @Override\n    public XmlSaxParserContext\n    call() throws Exception\n    {\n      try {\n        parser.parse_with(context, handler);\n      } finally { stream.close(); }\n      // we have to close the stream before exiting, otherwise someone\n      // can add a chunk and block on task.get() forever.\n      return parser;\n    }\n\n    final NokogiriHandler\n    getNokogiriHandler()\n    {\n      return parser.getNokogiriHandler();\n    }\n\n    synchronized final int\n    getErrorCount()\n    {\n      // check for null because thread may not have started yet\n      if (parser.getNokogiriErrorHandler() == null) { return 0; }\n      return parser.getNokogiriErrorHandler().getErrors().size();\n    }\n\n    synchronized final RubyException\n    getLastError()\n    {\n      List<RubyException> errors = parser.getNokogiriErrorHandler().getErrors();\n      return errors.get(errors.size() - 1);\n    }\n  }\n}\n", "package nokogiri.internals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\n\nimport nokogiri.internals.ParserContext.Options;\n\nimport org.jruby.Ruby;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.ext.EntityResolver2;\n\n/**\n * An entity resolver aware of the fact that the Ruby runtime can\n * change directory but the JVM cannot.  Thus any file based\n * entity resolution that uses relative paths must be translated\n * to be relative to the current directory of the Ruby runtime.\n */\npublic class NokogiriEntityResolver implements EntityResolver2\n{\n  protected final Ruby runtime;\n  private final NokogiriErrorHandler handler;\n  private final Options options;\n\n  public\n  NokogiriEntityResolver(Ruby runtime, NokogiriErrorHandler handler, Options options)\n  {\n    super();\n    this.runtime = runtime;\n    this.handler = handler;\n    this.options = options;\n  }\n\n  @Override\n  public InputSource\n  getExternalSubset(String name, String baseURI)\n  throws SAXException, IOException\n  {\n    return null;\n  }\n\n  @Override\n  public InputSource\n  resolveEntity(String publicId, String systemId)\n  throws SAXException, IOException\n  {\n    return resolveEntity(runtime, null, publicId, null, systemId);\n  }\n\n  @Override\n  public InputSource\n  resolveEntity(String name,\n                String publicId,\n                String baseURI,\n                String systemId)\n  throws SAXException, IOException\n  {\n    return resolveEntity(runtime, name, publicId, baseURI, systemId);\n  }\n\n  private static File\n  join(String parent, String child)\n  {\n    if (new File(parent).isFile()) {\n      parent = new File(parent).getParent();\n    }\n    return new File(parent, child);\n  }\n\n  private static InputSource\n  emptyInputSource(InputSource source)\n  {\n    source.setByteStream(new ByteArrayInputStream(new byte[0]));\n    return source;\n  }\n\n  private boolean\n  shouldLoadDtd()\n  {\n    return options.dtdLoad || options.dtdValid;\n  }\n\n  private void\n  addError(String errorMessage)\n  {\n    if (handler != null) { handler.addError(new Exception(errorMessage)); }\n  }\n\n  /**\n   * Create a file base input source taking into account the current\n   * directory of <code>runtime</code>.\n   * @throws SAXException\n   */\n  protected InputSource\n  resolveEntity(Ruby runtime, String name, String publicId, String baseURI, String systemId)\n  throws IOException, SAXException\n  {\n    InputSource s = new InputSource();\n    if (name.equals(\"[dtd]\") && !shouldLoadDtd()) {\n      return emptyInputSource(s);\n    } else if (!name.equals(\"[dtd]\") && !options.noEnt) {\n      return emptyInputSource(s);\n    }\n    String adjustedSystemId;\n    URI uri = URI.create(systemId);\n    if (options.noNet && uri.getHost() != null) {\n      addError(\"Attempt to load network entity \" + systemId);\n      return emptyInputSource(s);\n    }\n    // if this is a url or absolute file name then use it\n    if (uri.isAbsolute() && !uri.isOpaque()) {\n      adjustedSystemId = uri.toURL().toString();\n    } else if (new File(uri.getPath()).isAbsolute()) {\n      adjustedSystemId = uri.getPath();\n    } else if (baseURI != null) {\n      URI baseuri = URI.create(baseURI);\n      if (options.noNet && baseuri.getHost() != null) {\n        addError(\"Attempt to load network entity \" + systemId);\n        return emptyInputSource(s);\n      }\n      if (baseuri.getHost() == null) {\n        // this is a local file\n        adjustedSystemId = join(baseuri.getPath(), uri.getPath()).getCanonicalPath();\n      } else {\n        // this is a url, then resolve uri using baseuri\n        adjustedSystemId = baseuri.resolve(systemId).toURL().toString();\n      }\n    } else {\n      // baseURI is null we have to use the current working directory to resolve the entity\n      String pwd = runtime.getCurrentDirectory();\n      adjustedSystemId = join(pwd, uri.getPath()).getCanonicalPath();\n    }\n    s.setSystemId(adjustedSystemId);\n    s.setPublicId(publicId);\n    return s;\n  }\n\n}\n", "package nokogiri.internals;\n\nimport nokogiri.XmlSyntaxError;\nimport org.apache.xerces.xni.parser.XMLErrorHandler;\nimport org.jruby.Ruby;\nimport org.jruby.RubyException;\nimport org.jruby.exceptions.RaiseException;\nimport org.xml.sax.ErrorHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Super class of error handlers.\n *\n * XMLErrorHandler is used by nokogiri.internals.HtmlDomParserContext since NekoHtml\n * uses this type of the error handler.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic abstract class NokogiriErrorHandler implements ErrorHandler, XMLErrorHandler\n{\n  private final Ruby runtime;\n  protected final List<RubyException> errors;\n  protected boolean noerror;\n  protected boolean nowarning;\n\n  public\n  NokogiriErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    this.runtime = runtime;\n    this.errors = new ArrayList<RubyException>(4);\n    this.noerror = noerror;\n    this.nowarning = nowarning;\n  }\n\n  public List<RubyException>\n  getErrors() { return errors; }\n\n  public void\n  addError(Exception ex)\n  {\n    addError(XmlSyntaxError.createXMLSyntaxError(runtime, ex));\n  }\n\n  public void\n  addError(RubyException ex)\n  {\n    errors.add(ex);\n  }\n\n  public void\n  addError(RaiseException ex)\n  {\n    addError(ex.getException());\n  }\n\n  protected boolean\n  usesNekoHtml(String domain)\n  {\n    return \"http://cyberneko.org/html\".equals(domain);\n  }\n\n}\n", "package nokogiri.internals;\n\nimport static nokogiri.internals.NokogiriHelpers.getLocalPart;\nimport static nokogiri.internals.NokogiriHelpers.getPrefix;\nimport static nokogiri.internals.NokogiriHelpers.isNamespace;\nimport static nokogiri.internals.NokogiriHelpers.stringOrNil;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Set;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyClass;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.ext.DefaultHandler2;\n\nimport nokogiri.XmlSyntaxError;\n\n/**\n * A handler for SAX parsing.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriHandler extends DefaultHandler2 implements XmlDeclHandler\n{\n\n  StringBuilder charactersBuilder;\n  private final Ruby runtime;\n  private final RubyClass attrClass;\n  private final IRubyObject object;\n  private NokogiriErrorHandler errorHandler;\n\n  private Locator locator;\n  private boolean needEmptyAttrCheck;\n\n  public\n  NokogiriHandler(Ruby runtime, IRubyObject object, NokogiriErrorHandler errorHandler)\n  {\n    assert object != null;\n    this.runtime = runtime;\n    this.attrClass = (RubyClass) runtime.getClassFromPath(\"Nokogiri::XML::SAX::Parser::Attribute\");\n    this.object = object;\n    this.errorHandler = errorHandler;\n    charactersBuilder = new StringBuilder();\n    String objectName = object.getMetaClass().getName();\n    if (\"Nokogiri::HTML4::SAX::Parser\".equals(objectName)) { needEmptyAttrCheck = true; }\n  }\n\n  @Override\n  public void\n  skippedEntity(String skippedEntity)\n  {\n    call(\"error\", runtime.newString(\"Entity '\" + skippedEntity + \"' not defined\\n\"));\n  }\n\n  @Override\n  public void\n  setDocumentLocator(Locator locator)\n  {\n    this.locator = locator;\n  }\n\n  @Override\n  public void\n  startDocument()\n  {\n    call(\"start_document\");\n  }\n\n  @Override\n  public void\n  xmlDecl(String version, String encoding, String standalone)\n  {\n    call(\"xmldecl\", stringOrNil(runtime, version), stringOrNil(runtime, encoding), stringOrNil(runtime, standalone));\n  }\n\n  @Override\n  public void\n  endDocument()\n  {\n    populateCharacters();\n    call(\"end_document\");\n  }\n\n  @Override\n  public void\n  processingInstruction(String target, String data)\n  {\n    call(\"processing_instruction\", runtime.newString(target), runtime.newString(data));\n  }\n\n  /*\n   * This calls \"start_element_namespace\".\n   *\n   * Attributes that define namespaces are passed in a separate\n   * array of <code>[:prefix, :uri]</code> arrays and are not\n   * passed with the other attributes.\n   */\n  @Override\n  public void\n  startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException\n  {\n    final Ruby runtime = this.runtime;\n    final ThreadContext context = runtime.getCurrentContext();\n\n    // for attributes other than namespace attrs\n    RubyArray rubyAttr = RubyArray.newArray(runtime);\n    // for namespace defining attributes\n    RubyArray rubyNSAttr = RubyArray.newArray(runtime);\n\n    boolean fromFragmentHandler = false; // isFromFragmentHandler();\n\n    for (int i = 0; i < attrs.getLength(); i++) {\n      String u = attrs.getURI(i);\n      String qn = attrs.getQName(i);\n      String ln = attrs.getLocalName(i);\n      String val = attrs.getValue(i);\n      String pre;\n\n      pre = getPrefix(qn);\n      if (ln == null || ln.isEmpty()) { ln = getLocalPart(qn); }\n\n      if (isNamespace(qn) && !fromFragmentHandler) {\n        // I haven't figured the reason out yet, but, in somewhere,\n        // namespace is converted to array in array and cause\n        // TypeError at line 45 in fragment_handler.rb\n        if (ln.equals(\"xmlns\")) { ln = null; }\n        rubyNSAttr.append(runtime.newArray(stringOrNil(runtime, ln), runtime.newString(val)));\n      } else {\n        IRubyObject[] args = null;\n        if (needEmptyAttrCheck) {\n          if (isEmptyAttr(ln)) {\n            args = new IRubyObject[] {\n              stringOrNil(runtime, ln),\n              stringOrNil(runtime, pre),\n              stringOrNil(runtime, u)\n            };\n          }\n        }\n        if (args == null) {\n          args = new IRubyObject[] {\n            stringOrNil(runtime, ln),\n            stringOrNil(runtime, pre),\n            stringOrNil(runtime, u),\n            stringOrNil(runtime, val)\n          };\n        }\n\n        rubyAttr.append(Helpers.invoke(context, attrClass, \"new\", args));\n      }\n    }\n\n    if (localName == null || localName.isEmpty()) { localName = getLocalPart(qName); }\n    populateCharacters();\n    call(\"start_element_namespace\",\n         stringOrNil(runtime, localName),\n         rubyAttr,\n         stringOrNil(runtime, getPrefix(qName)),\n         stringOrNil(runtime, uri),\n         rubyNSAttr);\n  }\n\n  static final Set<String> EMPTY_ATTRS;\n  static\n  {\n    final String[] emptyAttrs = {\n      \"checked\", \"compact\", \"declare\", \"defer\", \"disabled\", \"ismap\", \"multiple\",\n      \"noresize\", \"nohref\", \"noshade\", \"nowrap\", \"readonly\", \"selected\"\n    };\n    EMPTY_ATTRS = new HashSet<String>(Arrays.asList(emptyAttrs));\n  }\n\n  private static boolean\n  isEmptyAttr(String name)\n  {\n    return EMPTY_ATTRS.contains(name);\n  }\n\n  public final Integer\n  getLine()   // -1 if none is available\n  {\n    final int line = locator.getLineNumber();\n    return line == -1 ? null : line;\n  }\n\n  public final Integer\n  getColumn()   // -1 if none is available\n  {\n    final int column = locator.getColumnNumber();\n    return column == -1 ? null : column - 1;\n  }\n\n  @Override\n  public void\n  endElement(String uri, String localName, String qName)\n  {\n    populateCharacters();\n    call(\"end_element_namespace\",\n         stringOrNil(runtime, localName),\n         stringOrNil(runtime, getPrefix(qName)),\n         stringOrNil(runtime, uri));\n  }\n\n  @Override\n  public void\n  characters(char[] ch, int start, int length)\n  {\n    charactersBuilder.append(ch, start, length);\n  }\n\n  @Override\n  public void\n  comment(char[] ch, int start, int length)\n  {\n    populateCharacters();\n    call(\"comment\", runtime.newString(new String(ch, start, length)));\n  }\n\n  @Override\n  public void\n  startCDATA()\n  {\n    populateCharacters();\n  }\n\n  @Override\n  public void\n  endCDATA()\n  {\n    call(\"cdata_block\", runtime.newString(charactersBuilder.toString()));\n    charactersBuilder.setLength(0);\n  }\n\n  void\n  handleError(SAXParseException ex)\n  {\n    try {\n      final String msg = ex.getMessage();\n      call(\"error\", runtime.newString(msg == null ? \"\" : msg));\n      errorHandler.addError(ex);\n    } catch (RaiseException e) {\n      errorHandler.addError(e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void\n  error(SAXParseException ex)\n  {\n    handleError(ex);\n  }\n\n  @Override\n  public void\n  fatalError(SAXParseException ex)\n  {\n    handleError(ex);\n  }\n\n  @Override\n  public void\n  warning(SAXParseException ex)\n  {\n    final String msg = ex.getMessage();\n    call(\"warning\", runtime.newString(msg == null ? \"\" : msg));\n  }\n\n  public synchronized int\n  getErrorCount()\n  {\n    return errorHandler.getErrors().size();\n  }\n\n  private void\n  call(String methodName)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName);\n  }\n\n  private void\n  call(String methodName, IRubyObject argument)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, argument);\n  }\n\n  private void\n  call(String methodName, IRubyObject arg1, IRubyObject arg2)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, arg1, arg2);\n  }\n\n  private void\n  call(String methodName, IRubyObject arg1, IRubyObject arg2, IRubyObject arg3)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, arg1, arg2, arg3);\n  }\n\n  private void\n  call(String methodName,\n       IRubyObject arg0,\n       IRubyObject arg1,\n       IRubyObject arg2,\n       IRubyObject arg3,\n       IRubyObject arg4)\n  {\n    ThreadContext context = runtime.getCurrentContext();\n    Helpers.invoke(context, document(context), methodName, arg0, arg1, arg2, arg3, arg4);\n  }\n\n  private IRubyObject\n  document(ThreadContext context)\n  {\n    return object.getInstanceVariables().getInstanceVariable(\"@document\");\n  }\n\n  protected void\n  populateCharacters()\n  {\n    if (charactersBuilder.length() > 0) {\n      call(\"characters\", runtime.newString(charactersBuilder.toString()));\n      charactersBuilder.setLength(0);\n    }\n  }\n}\n", "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.jruby.Ruby;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Error Handler for XML document when recover is true (default).\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriNonStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    super(runtime, noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    // fix #837\n    // Xerces won't skip the reference entity (and other invalid) constructs\n    // found in the prolog, instead it will keep calling this method and we'll\n    // keep inserting the error in the document errors array until we run\n    // out of memory\n    addError(ex);\n    String message = ex.getMessage();\n\n    // The problem with Xerces is that some errors will cause the\n    // parser not to advance the reader and it will keep reporting\n    // the same error over and over, which will cause the parser\n    // to enter an infinite loop unless we throw the exception.\n    if (message != null && isFatal(message)) {\n      throw ex;\n    }\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /*\n   * Determine whether this is a fatal error that should cause\n   * the parsing to stop, or an error that can be ignored.\n   */\n  private static boolean\n  isFatal(String msg)\n  {\n    String msgLowerCase = msg.toLowerCase();\n    return\n      msgLowerCase.contains(\"in prolog\") ||\n      msgLowerCase.contains(\"limit\") ||\n      msgLowerCase.contains(\"preceding the root element must be well-formed\") ||\n      msgLowerCase.contains(\"following the root element must be well-formed\");\n  }\n}\n", "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.jruby.Ruby;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Non-strict error handler for NekoHtml.\n *\n * NekoHtml adds too many warnings, which makes later processing hard. For example,\n * Nokogiri wants to know whether number of errors have been increased or not to judge\n * availability of creating NodeSet from a given fragment. When the fragment nodes\n * are to be created from HTML document, which means NekoHtml is used, always errors\n * increases. As a result, even though the given fragment is correct HTML, NodeSet\n * base on the given fragment won't be created. This is why all warnings are eliminated.\n *\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriNonStrictErrorHandler4NekoHtml extends NokogiriErrorHandler\n{\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean nowarning)\n  {\n    super(runtime, false, nowarning);\n  }\n\n  public\n  NokogiriNonStrictErrorHandler4NekoHtml(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    super(runtime, noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException ex) throws SAXException\n  {\n    //noop. NekoHtml adds too many warnings.\n  }\n\n  public void\n  error(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  public void\n  fatalError(SAXParseException ex) throws SAXException\n  {\n    addError(ex);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  error(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the fatal error. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The fatal error key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  fatalError(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n  /**\n   * Implementation of org.apache.xerces.xni.parser.XMLErrorHandler. This method\n   * is invoked during parsing fired by HtmlDomParserContext and is a NekoHtml requirement.\n   *\n   * @param domain The domain of the warning. The domain can be any string but is\n   *               suggested to be a valid URI. The domain can be used to conveniently\n   *               specify a web site location of the relevant specification or\n   *               document pertaining to this warning.\n   * @param key The warning key. This key can be any string and is implementation\n   *            dependent.\n   * @param e Exception.\n   */\n  public void\n  warning(String domain, String key, XMLParseException e)\n  {\n    addError(e);\n  }\n\n}\n", "package nokogiri.internals;\n\nimport org.apache.xerces.xni.parser.XMLParseException;\nimport org.jruby.Ruby;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Strict error handler. Even though strict is specified, Nokogiri allows to go further\n * when NOERROR or/both NOWARNING is/are true.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class NokogiriStrictErrorHandler extends NokogiriErrorHandler\n{\n  public\n  NokogiriStrictErrorHandler(Ruby runtime, boolean noerror, boolean nowarning)\n  {\n    super(runtime, noerror, nowarning);\n  }\n\n  public void\n  warning(SAXParseException spex) throws SAXException\n  {\n    if (!nowarning) { throw spex; }\n    else { addError(spex); }\n  }\n\n  public void\n  error(SAXParseException spex) throws SAXException\n  {\n    if (!noerror) { throw spex; }\n    else { addError(spex); }\n  }\n\n  public void\n  fatalError(SAXParseException spex) throws SAXException\n  {\n    throw spex;\n  }\n\n  public void\n  error(String domain, String key, XMLParseException e) throws XMLParseException\n  {\n    if (!noerror) { throw e; }\n    else { addError(e); }\n  }\n\n  public void\n  fatalError(String domain, String key, XMLParseException e) throws XMLParseException\n  {\n    throw e;\n  }\n\n  public void\n  warning(String domain, String key, XMLParseException e) throws XMLParseException\n  {\n    if (!nowarning) { throw e; }\n    if (!usesNekoHtml(domain)) { addError(e); }\n  }\n}\n", "package nokogiri.internals;\n\nimport nokogiri.XmlDocument;\nimport nokogiri.XmlDtd;\nimport nokogiri.XmlSyntaxError;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.jruby.*;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static nokogiri.internals.NokogiriHelpers.isBlank;\n\n/**\n * Parser class for XML DOM processing. This class actually parses XML document\n * and creates DOM tree in Java side. However, DOM tree in Ruby side is not since\n * we delay creating objects for performance.\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\npublic class XmlDomParserContext extends ParserContext\n{\n\n  protected static final String FEATURE_LOAD_EXTERNAL_DTD =\n    \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\n  protected static final String FEATURE_LOAD_DTD_GRAMMAR =\n    \"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\";\n  protected static final String FEATURE_INCLUDE_IGNORABLE_WHITESPACE =\n    \"http://apache.org/xml/features/dom/include-ignorable-whitespace\";\n  protected static final String CONTINUE_AFTER_FATAL_ERROR =\n    \"http://apache.org/xml/features/continue-after-fatal-error\";\n  protected static final String FEATURE_NOT_EXPAND_ENTITY =\n    \"http://apache.org/xml/features/dom/create-entity-ref-nodes\";\n  protected static final String FEATURE_VALIDATION = \"http://xml.org/sax/features/validation\";\n  private static final String SECURITY_MANAGER = \"http://apache.org/xml/properties/security-manager\";\n\n  protected ParserContext.Options options;\n  protected DOMParser parser;\n  protected NokogiriErrorHandler errorHandler;\n  protected IRubyObject ruby_encoding;\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject options)\n  {\n    this(runtime, runtime.getNil(), options);\n  }\n\n  public\n  XmlDomParserContext(Ruby runtime, IRubyObject encoding, IRubyObject options)\n  {\n    super(runtime);\n    this.options = new ParserContext.Options(RubyFixnum.fix2long(options));\n    java_encoding = NokogiriHelpers.getValidEncodingOrNull(encoding);\n    ruby_encoding = encoding;\n    initErrorHandler(runtime);\n    initParser(runtime);\n  }\n\n  protected void\n  initErrorHandler(Ruby runtime)\n  {\n    if (options.recover) {\n      errorHandler = new NokogiriNonStrictErrorHandler(runtime, options.noError, options.noWarning);\n    } else {\n      errorHandler = new NokogiriStrictErrorHandler(runtime, options.noError, options.noWarning);\n    }\n  }\n\n  protected void\n  initParser(Ruby runtime)\n  {\n    if (options.xInclude) {\n      System.setProperty(\"org.apache.xerces.xni.parser.XMLParserConfiguration\",\n                         \"org.apache.xerces.parsers.XIncludeParserConfiguration\");\n    }\n\n    parser = new NokogiriDomParser(options);\n    parser.setErrorHandler(errorHandler);\n\n    // Fix for Issue#586.  This limits entity expansion up to 100000 and nodes up to 3000.\n    setProperty(SECURITY_MANAGER, new org.apache.xerces.util.SecurityManager());\n\n    if (options.noBlanks) {\n      setFeature(FEATURE_INCLUDE_IGNORABLE_WHITESPACE, false);\n    }\n\n    if (options.recover) {\n      setFeature(CONTINUE_AFTER_FATAL_ERROR, true);\n    }\n\n    if (options.dtdValid) {\n      setFeature(FEATURE_VALIDATION, true);\n    }\n\n    if (!options.noEnt) {\n      setFeature(FEATURE_NOT_EXPAND_ENTITY, true);\n    }\n    // If we turn off loading of external DTDs complete, we don't\n    // getthe publicID.  Instead of turning off completely, we use\n    // an entity resolver that returns empty documents.\n    if (options.dtdLoad) {\n      setFeature(FEATURE_LOAD_EXTERNAL_DTD, true);\n      setFeature(FEATURE_LOAD_DTD_GRAMMAR, true);\n    }\n    parser.setEntityResolver(new NokogiriEntityResolver(runtime, errorHandler, options));\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setFeature(String feature, boolean value)\n  {\n    try {\n      parser.setFeature(feature, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  /**\n   * Convenience method that catches and ignores SAXException\n   * (unrecognized and unsupported exceptions).\n   */\n  protected void\n  setProperty(String property, Object value)\n  {\n    try {\n      parser.setProperty(property, value);\n    } catch (SAXException e) {\n      // ignore\n    }\n  }\n\n  public void\n  addErrorsIfNecessary(ThreadContext context, XmlDocument doc)\n  {\n    doc.setInstanceVariable(\"@errors\", mapErrors(context, errorHandler));\n  }\n\n\n  public static RubyArray\n  mapErrors(ThreadContext context, NokogiriErrorHandler errorHandler)\n  {\n    final Ruby runtime = context.runtime;\n    final List<RubyException> errors = errorHandler.getErrors();\n    final IRubyObject[] errorsAry = new IRubyObject[errors.size()];\n    for (int i = 0; i < errors.size(); i++) {\n      errorsAry[i] = errors.get(i);\n    }\n    return runtime.newArrayNoCopy(errorsAry);\n  }\n\n  public XmlDocument\n  getDocumentWithErrorsOrRaiseException(ThreadContext context, RubyClass klazz, Exception ex)\n  {\n    if (options.recover) {\n      XmlDocument xmlDocument = getInterruptedOrNewXmlDocument(context, klazz);\n      this.addErrorsIfNecessary(context, xmlDocument);\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      ((RubyArray) xmlDocument.getInstanceVariable(\"@errors\")).append(xmlSyntaxError);\n      return xmlDocument;\n    } else {\n      XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n      xmlSyntaxError.setException(ex);\n      throw xmlSyntaxError.toThrowable();\n    }\n  }\n\n  private XmlDocument\n  getInterruptedOrNewXmlDocument(ThreadContext context, RubyClass klass)\n  {\n    Document document = parser.getDocument();\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, document);\n    xmlDocument.setEncoding(ruby_encoding);\n    return xmlDocument;\n  }\n\n  /**\n   * This method is broken out so that HtmlDomParserContext can\n   * override it.\n   */\n  protected XmlDocument\n  wrapDocument(ThreadContext context, RubyClass klass, Document doc)\n  {\n    XmlDocument xmlDocument = new XmlDocument(context.runtime, klass, doc);\n    Helpers.invoke(context, xmlDocument, \"initialize\");\n    xmlDocument.setEncoding(ruby_encoding);\n\n    if (options.dtdLoad) {\n      IRubyObject dtd = XmlDtd.newFromExternalSubset(context.runtime, doc);\n      if (!dtd.isNil()) {\n        doc.setUserData(XmlDocument.DTD_EXTERNAL_SUBSET, (XmlDtd) dtd, null);\n      }\n    }\n    return xmlDocument;\n  }\n\n  /**\n   * Must call setInputSource() before this method.\n   */\n  public XmlDocument\n  parse(ThreadContext context, RubyClass klass, IRubyObject url)\n  {\n    XmlDocument xmlDoc;\n    try {\n      Document doc = do_parse();\n      xmlDoc = wrapDocument(context, klass, doc);\n      xmlDoc.setUrl(url);\n      addErrorsIfNecessary(context, xmlDoc);\n      return xmlDoc;\n    } catch (SAXException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    } catch (IOException e) {\n      return getDocumentWithErrorsOrRaiseException(context, klass, e);\n    }\n  }\n\n  protected Document\n  do_parse() throws SAXException, IOException\n  {\n    try {\n      parser.parse(getInputSource());\n    } catch (NullPointerException ex) {\n      // FIXME: this is really a hack to fix #838. Xerces will throw a NullPointerException\n      // if we tried to parse '<? ?>'. We should submit a patch to Xerces.\n    }\n    if (options.noBlanks) {\n      List<Node> emptyNodes = new ArrayList<Node>();\n      findEmptyTexts(parser.getDocument(), emptyNodes);\n      if (emptyNodes.size() > 0) {\n        for (Node node : emptyNodes) {\n          node.getParentNode().removeChild(node);\n        }\n      }\n    }\n    return parser.getDocument();\n  }\n\n  private static void\n  findEmptyTexts(Node node, List<Node> emptyNodes)\n  {\n    if (node.getNodeType() == Node.TEXT_NODE && isBlank(node.getTextContent())) {\n      emptyNodes.add(node);\n    } else {\n      NodeList children = node.getChildNodes();\n      for (int i = 0; i < children.getLength(); i++) {\n        findEmptyTexts(children.item(i), emptyNodes);\n      }\n    }\n  }\n}\n", "# frozen_string_literal: true\n\nrequire \"helper\"\n\nclass Nokogiri::SAX::TestCase\n  describe Nokogiri::XML::SAX::Parser do\n    let(:parser) { Nokogiri::XML::SAX::Parser.new(Doc.new) }\n\n    it :test_parser_context_yielded_io do\n      doc = Doc.new\n      parser = Nokogiri::XML::SAX::Parser.new(doc)\n      xml = \"<foo a='&amp;b'/>\"\n\n      block_called = false\n      parser.parse(StringIO.new(xml)) do |ctx|\n        block_called = true\n        ctx.replace_entities = true\n      end\n\n      assert(block_called)\n\n      assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n    end\n\n    it :test_parser_context_yielded_in_memory do\n      doc = Doc.new\n      parser = Nokogiri::XML::SAX::Parser.new(doc)\n      xml = \"<foo a='&amp;b'/>\"\n\n      block_called = false\n      parser.parse(xml) do |ctx|\n        block_called = true\n        ctx.replace_entities = true\n      end\n\n      assert(block_called)\n\n      assert_equal([[\"foo\", [[\"a\", \"&b\"]]]], doc.start_elements)\n    end\n\n    it :test_empty_decl do\n      parser = Nokogiri::XML::SAX::Parser.new(Doc.new)\n\n      xml = \"<root />\"\n      parser.parse(xml)\n      assert(parser.document.start_document_called, xml)\n      assert_nil(parser.document.xmldecls, xml)\n    end\n\n    it :test_xml_decl do\n      [\n        ['<?xml version=\"1.0\" ?>', [\"1.0\"]],\n        ['<?xml version=\"1.0\" encoding=\"UTF-8\" ?>', [\"1.0\", \"UTF-8\"]],\n        ['<?xml version=\"1.0\" standalone=\"yes\"?>', [\"1.0\", \"yes\"]],\n        ['<?xml version=\"1.0\" standalone=\"no\"?>', [\"1.0\", \"no\"]],\n        ['<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>', [\"1.0\", \"UTF-8\", \"no\"]],\n        ['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>', [\"1.0\", \"ISO-8859-1\", \"yes\"]],\n      ].each do |decl, value|\n        parser = Nokogiri::XML::SAX::Parser.new(Doc.new)\n\n        xml = \"#{decl}\\n<root />\"\n        parser.parse(xml)\n        assert(parser.document.start_document_called, xml)\n        assert_equal(value, parser.document.xmldecls, xml)\n      end\n    end\n\n    it :test_parse_empty do\n      assert_raises(RuntimeError) do\n        parser.parse(\"\")\n      end\n    end\n\n    it :test_namespace_declaration_order_is_saved do\n      parser.parse(<<~EOF)\n        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n          <a foo:bar='hello' />\n        </root>\n      EOF\n      assert_equal(2, parser.document.start_elements_namespace.length)\n      el = parser.document.start_elements_namespace.first\n      namespaces = el.last\n      assert_equal([\"foo\", \"http://foo.example.com/\"], namespaces.first)\n      assert_equal([nil, \"http://example.com/\"], namespaces.last)\n    end\n\n    it :test_bad_document_calls_error_handler do\n      parser.parse(\"<foo><bar></foo>\")\n      assert(parser.document.errors)\n      assert(parser.document.errors.length > 0)\n    end\n\n    it :test_namespace_are_super_fun_to_parse do\n      parser.parse(<<~EOF)\n        <root xmlns:foo='http://foo.example.com/'>\n          <a foo:bar='hello' />\n          <b xmlns:foo='http://bar.example.com/'>\n            <a foo:bar='hello' />\n          </b>\n          <foo:bar>hello world</foo:bar>\n        </root>\n      EOF\n\n      assert(parser.document.start_elements_namespace.length > 0)\n      el = parser.document.start_elements_namespace[1]\n      assert_equal(\"a\", el.first)\n      assert_equal(1, el[1].length)\n\n      attribute = el[1].first\n      assert_equal(\"bar\", attribute.localname)\n      assert_equal(\"foo\", attribute.prefix)\n      assert_equal(\"hello\", attribute.value)\n      assert_equal(\"http://foo.example.com/\", attribute.uri)\n    end\n\n    it :test_sax_v1_namespace_attribute_declarations do\n      parser.parse(<<~EOF)\n        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n          <a foo:bar='hello' />\n          <b xmlns:foo='http://bar.example.com/'>\n            <a foo:bar='hello' />\n          </b>\n          <foo:bar>hello world</foo:bar>\n        </root>\n      EOF\n      assert(parser.document.start_elements.length > 0)\n      elm = parser.document.start_elements.first\n      assert_equal(\"root\", elm.first)\n      assert(elm[1].include?([\"xmlns:foo\", \"http://foo.example.com/\"]))\n      assert(elm[1].include?([\"xmlns\", \"http://example.com/\"]))\n    end\n\n    it :test_sax_v1_namespace_nodes do\n      parser.parse(<<~EOF)\n        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n          <a foo:bar='hello' />\n          <b xmlns:foo='http://bar.example.com/'>\n            <a foo:bar='hello' />\n          </b>\n          <foo:bar>hello world</foo:bar>\n        </root>\n      EOF\n      assert_equal(5, parser.document.start_elements.length)\n      assert(parser.document.start_elements.map(&:first).include?(\"foo:bar\"))\n      assert(parser.document.end_elements.map(&:first).include?(\"foo:bar\"))\n    end\n\n    it :test_start_is_called_without_namespace do\n      parser.parse(<<~EOF)\n        <root xmlns:foo='http://foo.example.com/' xmlns='http://example.com/'>\n        <foo:f><bar></foo:f>\n        </root>\n      EOF\n      assert_equal(\n        [\"root\", \"foo:f\", \"bar\"],\n        parser.document.start_elements.map(&:first)\n      )\n    end\n\n    it :test_parser_sets_encoding do\n      parser = Nokogiri::XML::SAX::Parser.new(Doc.new, \"UTF-8\")\n      assert_equal(\"UTF-8\", parser.encoding)\n    end\n\n    it :test_errors_set_after_parsing_bad_dom do\n      doc = Nokogiri::XML(\"<foo><bar></foo>\")\n      assert(doc.errors)\n\n      parser.parse(\"<foo><bar></foo>\")\n      assert(parser.document.errors)\n      assert(parser.document.errors.length > 0)\n\n      doc.errors.each do |error|\n        assert_equal(\"UTF-8\", error.message.encoding.name)\n      end\n\n      # when using JRuby Nokogiri, more errors will be generated as the DOM\n      # parser continue to parse an ill formed document, while the sax parser\n      # will stop at the first error\n      unless Nokogiri.jruby?\n        assert_equal(doc.errors.length, parser.document.errors.length)\n      end\n    end\n\n    it :test_parse_with_memory_argument do\n      parser.parse(File.read(XML_FILE))\n      assert(parser.document.cdata_blocks.length > 0)\n    end\n\n    it :test_parse_with_io_argument do\n      File.open(XML_FILE, \"rb\") do |f|\n        parser.parse(f)\n      end\n      assert(parser.document.cdata_blocks.length > 0)\n    end\n\n    it :test_parse_io do\n      call_parse_io_with_encoding(\"UTF-8\")\n    end\n\n    # issue #828\n    it :test_parse_io_lower_case_encoding do\n      call_parse_io_with_encoding(\"utf-8\")\n    end\n\n    def call_parse_io_with_encoding(encoding)\n      File.open(XML_FILE, \"rb\") do |f|\n        parser.parse_io(f, encoding)\n      end\n      assert(parser.document.cdata_blocks.length > 0)\n\n      called = false\n      parser.document.start_elements.flatten.each do |thing|\n        assert_equal(\"UTF-8\", thing.encoding.name)\n        called = true\n      end\n      assert(called)\n\n      called = false\n      parser.document.end_elements.flatten.each do |thing|\n        assert_equal(\"UTF-8\", thing.encoding.name)\n        called = true\n      end\n      assert(called)\n\n      called = false\n      parser.document.data.each do |thing|\n        assert_equal(\"UTF-8\", thing.encoding.name)\n        called = true\n      end\n      assert(called)\n\n      called = false\n      parser.document.comments.flatten.each do |thing|\n        assert_equal(\"UTF-8\", thing.encoding.name)\n        called = true\n      end\n      assert(called)\n\n      called = false\n      parser.document.cdata_blocks.flatten.each do |thing|\n        assert_equal(\"UTF-8\", thing.encoding.name)\n        called = true\n      end\n      assert(called)\n    end\n\n    it :test_parse_file do\n      parser.parse_file(XML_FILE)\n\n      assert_raises(ArgumentError) do\n        parser.parse_file(nil)\n      end\n\n      assert_raises(Errno::ENOENT) do\n        parser.parse_file(\"\")\n      end\n      assert_raises(Errno::EISDIR) do\n        parser.parse_file(File.expand_path(File.dirname(__FILE__)))\n      end\n    end\n\n    it :test_render_parse_nil_param do\n      assert_raises(ArgumentError) { parser.parse_memory(nil) }\n    end\n\n    it :test_bad_encoding_args do\n      assert_raises(ArgumentError) { Nokogiri::XML::SAX::Parser.new(Doc.new, \"not an encoding\") }\n      assert_raises(ArgumentError) { parser.parse_io(StringIO.new(\"<root/>\"), \"not an encoding\") }\n    end\n\n    it :test_ctag do\n      parser.parse_memory(<<~EOF)\n        <p id=\"asdfasdf\">\n          <![CDATA[ This is a comment ]]>\n          Paragraph 1\n        </p>\n      EOF\n      assert_equal([\" This is a comment \"], parser.document.cdata_blocks)\n    end\n\n    it :test_comment do\n      parser.parse_memory(<<~EOF)\n        <p id=\"asdfasdf\">\n          <!-- This is a comment -->\n          Paragraph 1\n        </p>\n      EOF\n      assert_equal([\" This is a comment \"], parser.document.comments)\n    end\n\n    it :test_characters do\n      parser.parse_memory(<<~EOF)\n        <p id=\"asdfasdf\">Paragraph 1</p>\n      EOF\n      assert_equal([\"Paragraph 1\"], parser.document.data)\n    end\n\n    it :test_end_document do\n      parser.parse_memory(<<~EOF)\n        <p id=\"asdfasdf\">Paragraph 1</p>\n      EOF\n      assert(parser.document.end_document_called)\n    end\n\n    it :test_end_element do\n      parser.parse_memory(<<~EOF)\n        <p id=\"asdfasdf\">Paragraph 1</p>\n      EOF\n      assert_equal([[\"p\"]], parser.document.end_elements)\n    end\n\n    it :test_start_element_attrs do\n      parser.parse_memory(<<~EOF)\n        <p id=\"asdfasdf\">Paragraph 1</p>\n      EOF\n      assert_equal([[\"p\", [[\"id\", \"asdfasdf\"]]]], parser.document.start_elements)\n    end\n\n    it :test_start_element_attrs_include_namespaces do\n      parser.parse_memory(<<~EOF)\n        <p xmlns:foo='http://foo.example.com/'>Paragraph 1</p>\n      EOF\n      assert_equal(\n        [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n        parser.document.start_elements\n      )\n    end\n\n    it :test_processing_instruction do\n      parser.parse_memory(<<~EOF)\n        <?xml-stylesheet href=\"a.xsl\" type=\"text/xsl\"?>\n        <?xml version=\"1.0\"?>\n      EOF\n      assert_equal(\n        [[\"xml-stylesheet\", 'href=\"a.xsl\" type=\"text/xsl\"']],\n        parser.document.processing_instructions\n      )\n    end\n\n    it :test_parse_document do\n      skip_unless_libxml2(\"JRuby SAXParser only parses well-formed XML documents\")\n      parser.parse_memory(<<~EOF)\n        <p>Paragraph 1</p>\n        <p>Paragraph 2</p>\n      EOF\n    end\n\n    it :test_parser_attributes do\n      xml = <<~EOF\n        <?xml version=\"1.0\" ?><root><foo a=\"&amp;b\" c=\"&gt;d\" /></root>\n      EOF\n\n      block_called = false\n      parser.parse(xml) do |ctx|\n        block_called = true\n        ctx.replace_entities = true\n      end\n\n      assert(block_called)\n\n      assert_equal(\n        [[\"root\", []], [\"foo\", [[\"a\", \"&b\"], [\"c\", \">d\"]]]], parser.document.start_elements\n      )\n    end\n\n    it :test_recovery_from_incorrect_xml do\n      xml = <<~EOF\n        <?xml version=\"1.0\" ?><Root><Data><?xml version='1.0'?><Item>hey</Item></Data><Data><Item>hey yourself</Item></Data></Root>\n      EOF\n\n      block_called = false\n      parser.parse(xml) do |ctx|\n        block_called = true\n        ctx.recovery = true\n      end\n\n      assert(block_called)\n\n      assert_equal(\n        [[\"Root\", []], [\"Data\", []], [\"Item\", []], [\"Data\", []], [\"Item\", []]],\n        parser.document.start_elements\n      )\n    end\n\n    it :test_square_bracket_in_text do\n      # issue 1261\n      xml = <<~EOF\n        <tu tuid=\"87dea04cf60af103ff09d1dba36ae820\" segtype=\"block\">\n          <prop type=\"x-smartling-string-variant\">en:#:home_page:#:stories:#:[6]:#:name</prop>\n          <tuv xml:lang=\"en-US\"><seg>Sandy S.</seg></tuv>\n        </tu>\n      EOF\n      parser.parse(xml)\n      assert_includes(parser.document.data, \"en:#:home_page:#:stories:#:[6]:#:name\")\n    end\n\n    it :test_large_cdata_is_handled do\n      # see #2132 and https://gitlab.gnome.org/GNOME/libxml2/-/issues/200\n      skip(\"Upstream libxml2 <= 2.9.10 needs to be patched\") if Nokogiri::VersionInfo.instance.libxml2_using_system?\n\n      template = <<~EOF\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns=\"http://example.com\">\n           <soapenv:Header>\n              <AuthHeader xsi:type=\"ns:vAuthHeader\">\n              <userName xsi:type=\"xsd:string\">gorilla</userName>\n              <password xsi:type=\"xsd:string\">secret</password>\n            </AuthHeader>\n           </soapenv:Header>\n          <soapenv:Body>\n            <ns:checkToken soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n              <checkToken xsi:type=\"xsd:string\"><![CDATA[%s]]></checkToken>\n            </ns:checkToken>\n           </soapenv:Body>\n        </soapenv:Envelope>\n      EOF\n\n      factor = 10\n      huge_data = \"a\" * (1024 * 1024 * factor)\n      xml = StringIO.new(template % huge_data)\n\n      handler = Nokogiri::SAX::TestCase::Doc.new\n      parser = Nokogiri::XML::SAX::Parser.new(handler)\n      parser.parse(xml)\n\n      assert_predicate(handler.errors, :empty?)\n    end\n\n    it \"does not resolve entities by default\" do\n      xml = <<~EOF\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE doc [\n          <!ENTITY local SYSTEM \"file:///#{File.expand_path(__FILE__)}\">\n          <!ENTITY custom \"resolved>\n        ]>\n        <doc><foo>&local;</foo><foo>&custom;</foo></doc>\n      EOF\n\n      doc = Doc.new\n      parser = Nokogiri::XML::SAX::Parser.new(doc)\n      parser.parse(xml)\n\n      assert_nil(doc.data)\n    end\n\n    it \"does not resolve network external entities by default\" do\n      xml = <<~EOF\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE doc [\n          <!ENTITY remote SYSTEM \"http://0.0.0.0:8080/evil.dtd\">\n        ]>\n        <doc><foo>&remote;</foo></doc>\n      EOF\n\n      doc = Doc.new\n      parser = Nokogiri::XML::SAX::Parser.new(doc)\n      parser.parse(xml)\n\n      assert_nil(doc.data)\n    end\n  end\nend\n", "# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n\nrequire \"helper\"\n\nclass Nokogiri::SAX::TestCase\n  describe Nokogiri::XML::SAX::PushParser do\n    let(:parser) { Nokogiri::XML::SAX::PushParser.new(Doc.new) }\n\n    it :test_exception do\n      assert_raises(Nokogiri::XML::SyntaxError) do\n        parser << \"<foo /><foo />\"\n      end\n\n      assert_raises(Nokogiri::XML::SyntaxError) do\n        parser << nil\n      end\n    end\n\n    it :test_early_finish do\n      parser << \"<foo>\"\n      assert_raises(Nokogiri::XML::SyntaxError) do\n        parser.finish\n      end\n    end\n\n    it :test_write_last_chunk do\n      parser << \"<foo>\"\n      parser.write(\"</foo>\", true)\n      assert_equal [[\"foo\", []]], parser.document.start_elements\n      assert_equal [[\"foo\"]], parser.document.end_elements\n    end\n\n    it :test_empty_doc do\n      parser.options |= Nokogiri::XML::ParseOptions::RECOVER\n      parser.write(\"\", true)\n      assert_nil parser.document.start_elements\n      assert_nil parser.document.end_elements\n    end\n\n    it :test_finish_should_rethrow_last_error do\n      expected = assert_raise(Nokogiri::XML::SyntaxError) { parser << \"</foo>\" }\n      actual = assert_raise(Nokogiri::XML::SyntaxError) { parser.finish }\n      assert_equal actual.message, expected.message\n    end\n\n    it :test_should_throw_error_returned_by_document do\n      doc = Doc.new\n      class << doc\n        def error(msg)\n          raise \"parse error\"\n        end\n      end\n      parser = Nokogiri::XML::SAX::PushParser.new(doc)\n\n      exception = assert_raise(RuntimeError) { parser << \"</foo>\" }\n      assert_equal exception.message, \"parse error\"\n    end\n\n    it :test_writing_nil do\n      assert_equal parser.write(nil), parser\n    end\n\n    it :test_end_document_called do\n      parser.<<(<<~EOF)\n        <p id=\"asdfasdf\">\n          <!-- This is a comment -->\n          Paragraph 1\n        </p>\n      EOF\n      assert !parser.document.end_document_called\n      parser.finish\n      assert parser.document.end_document_called\n    end\n\n    it :test_start_element do\n      parser.<<(<<~EOF)\n        <p id=\"asdfasdf\">\n      EOF\n\n      assert_equal [[\"p\", [[\"id\", \"asdfasdf\"]]]],\n        parser.document.start_elements\n\n      parser.<<(<<~EOF)\n          <!-- This is a comment -->\n          Paragraph 1\n        </p>\n      EOF\n      assert_equal [\" This is a comment \"], parser.document.comments\n      parser.finish\n    end\n\n    it :test_start_element_with_namespaces do\n      parser.<<(<<~EOF)\n        <p xmlns:foo=\"http://foo.example.com/\">\n      EOF\n\n      assert_equal [[\"p\", [[\"xmlns:foo\", \"http://foo.example.com/\"]]]],\n        parser.document.start_elements\n\n      parser.<<(<<~EOF)\n          <!-- This is a comment -->\n          Paragraph 1\n        </p>\n      EOF\n      assert_equal [\" This is a comment \"], parser.document.comments\n      parser.finish\n    end\n\n    it :test_start_element_ns do\n      parser.<<(<<~EOF)\n        <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' size='large'></stream:stream>\n      EOF\n\n      assert_equal 1, parser.document.start_elements_namespace.length\n      el = parser.document.start_elements_namespace.first\n\n      assert_equal \"stream\", el.first\n      assert_equal 2, el[1].length\n      assert_equal [[\"version\", \"1.0\"], [\"size\", \"large\"]],\n        el[1].map { |x| [x.localname, x.value] }\n\n      assert_equal \"stream\", el[2]\n      assert_equal \"http://etherx.jabber.org/streams\", el[3]\n      parser.finish\n    end\n\n    it :test_end_element_ns do\n      parser.<<(<<~EOF)\n        <stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'></stream:stream>\n      EOF\n\n      assert_equal [[\"stream\", \"stream\", \"http://etherx.jabber.org/streams\"]],\n        parser.document.end_elements_namespace\n      parser.finish\n    end\n\n    it :test_chevron_partial_xml do\n      parser.<<(<<~EOF)\n        <p id=\"asdfasdf\">\n      EOF\n\n      parser.<<(<<~EOF)\n          <!-- This is a comment -->\n          Paragraph 1\n        </p>\n      EOF\n      assert_equal [\" This is a comment \"], parser.document.comments\n      parser.finish\n    end\n\n    it :test_chevron do\n      parser.<<(<<~EOF)\n        <p id=\"asdfasdf\">\n          <!-- This is a comment -->\n          Paragraph 1\n        </p>\n      EOF\n      parser.finish\n      assert_equal [\" This is a comment \"], parser.document.comments\n    end\n\n    it :test_default_options do\n      assert_equal 0, parser.options\n    end\n\n    it :test_recover do\n      parser.options |= Nokogiri::XML::ParseOptions::RECOVER\n      parser.<<(<<~EOF)\n        <p>\n          Foo\n          <bar>\n          Bar\n        </p>\n      EOF\n      parser.finish\n      assert(parser.document.errors.size >= 1)\n      assert_equal [[\"p\", []], [\"bar\", []]], parser.document.start_elements\n      assert_equal \"FooBar\", parser.document.data.map { |x|\n        x.gsub(/\\s/, \"\")\n      }.join\n    end\n\n    it :test_broken_encoding do\n      skip_unless_libxml2(\"ultra hard to fix for pure Java version\")\n      parser.options |= Nokogiri::XML::ParseOptions::RECOVER\n      # This is ISO_8859-1:\n      parser.<< \"<?xml version='1.0' encoding='UTF-8'?><r>Gau\\337</r>\"\n      parser.finish\n      assert(parser.document.errors.size >= 1)\n      assert_equal \"Gau\\337\", parser.document.data.join\n      assert_equal [[\"r\"]], parser.document.end_elements\n    end\n\n    it :test_replace_entities_attribute_behavior do\n      if Nokogiri.uses_libxml?\n        # initially false\n        assert_equal false, parser.replace_entities\n\n        # can be set to true\n        parser.replace_entities = true\n        assert_equal true, parser.replace_entities\n\n        # can be set to false\n        parser.replace_entities = false\n        assert_equal false, parser.replace_entities\n      else\n        # initially true\n        assert_equal true, parser.replace_entities\n\n        # ignore attempts to set to false\n        parser.replace_entities = false # TODO: should we raise an exception here?\n        assert_equal true, parser.replace_entities\n      end\n    end\n\n    it :test_untouched_entities do\n      skip_unless_libxml2(\"entities are always replaced in pure Java version\")\n      parser.<<(<<~EOF)\n        <p id=\"asdf&amp;asdf\">\n          <!-- This is a comment -->\n          Paragraph 1 &amp; 2\n        </p>\n      EOF\n      parser.finish\n      assert_equal [[\"p\", [[\"id\", \"asdf&#38;asdf\"]]]], parser.document.start_elements\n      assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip\n    end\n\n    it :test_replaced_entities do\n      parser.replace_entities = true\n      parser.<<(<<~EOF)\n        <p id=\"asdf&amp;asdf\">\n          <!-- This is a comment -->\n          Paragraph 1 &amp; 2\n        </p>\n      EOF\n      parser.finish\n      assert_equal [[\"p\", [[\"id\", \"asdf&asdf\"]]]], parser.document.start_elements\n      assert_equal \"Paragraph 1 & 2\", parser.document.data.join.strip\n    end\n  end\nend\n"], "filenames": ["ext/java/nokogiri/Html4SaxPushParser.java", "ext/java/nokogiri/XmlSaxParserContext.java", "ext/java/nokogiri/XmlSaxPushParser.java", "ext/java/nokogiri/internals/NokogiriEntityResolver.java", "ext/java/nokogiri/internals/NokogiriErrorHandler.java", "ext/java/nokogiri/internals/NokogiriHandler.java", "ext/java/nokogiri/internals/NokogiriNonStrictErrorHandler.java", "ext/java/nokogiri/internals/NokogiriNonStrictErrorHandler4NekoHtml.java", "ext/java/nokogiri/internals/NokogiriStrictErrorHandler.java", "ext/java/nokogiri/internals/XmlDomParserContext.java", "test/xml/sax/test_parser.rb", "test/xml/sax/test_push_parser.rb"], "buggy_code_start_loc": [3, 3, 3, 88, 1, 41, 3, 3, 3, 3, 5, 1], "buggy_code_end_loc": [138, 387, 293, 89, 37, 301, 69, 104, 60, 170, 424, 264], "fixing_code_start_loc": [3, 3, 3, 88, 2, 41, 4, 4, 4, 3, 5, 2], "fixing_code_end_loc": [133, 324, 285, 89, 58, 283, 70, 105, 61, 161, 461, 241], "type": "CWE-611", "message": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected.", "other": {"cve": {"id": "CVE-2021-41098", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-27T20:15:07.397", "lastModified": "2021-10-06T20:17:08.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri v1.12.4 and earlier, on JRuby only, the SAX parser resolves external entities by default. Users of Nokogiri on JRuby who parse untrusted documents using any of these classes are affected: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser or its alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, and Nokogiri::HTML4::SAX::PushParser or its alias Nokogiri::HTML::SAX::PushParser. JRuby users should upgrade to Nokogiri v1.12.5 or later to receive a patch for this issue. There are no workarounds available for v1.12.4 or earlier. CRuby users are not affected."}, {"lang": "es", "value": "Nokogiri es un Rubygem proporcionando analizadores de HTML, XML, SAX y Reader con soporte de selector XPath y CSS. En Nokogiri versiones v1.12.4 y anteriores, s\u00f3lo en JRuby, el analizador SAX resuelve las entidades externas por defecto. Los usuarios de Nokogiri en JRuby que analizan documentos no confiables usando cualquiera de estas clases se ven afectados: Nokogiri::XML::SAX::Parse, Nokogiri::HTML4::SAX::Parser o su alias Nokogiri::HTML::SAX::Parser, Nokogiri::XML::SAX::PushParser, y Nokogiri::HTML4::SAX::PushParser o su alias Nokogiri::HTML::SAX::PushParser. Los usuarios de JRuby deben actualizar a Nokogiri versi\u00f3n v1.12.5 o posterior, para recibir un parche para este problema. No hay soluciones disponibles para la versi\u00f3n v1.12.4 o anteriores. Los usuarios de CRuby no est\u00e1n afectados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nokogiri:nokogiri:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.12.5", "matchCriteriaId": "8617E11C-328F-490E-BB49-8922E5D2A121"}]}]}], "references": [{"url": "https://github.com/sparklemotion/nokogiri/commit/5bf729ff3cc84709ee3c3248c981584088bf9f6d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-2rr5-8q37-2w7h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sparklemotion/nokogiri/commit/5bf729ff3cc84709ee3c3248c981584088bf9f6d"}}