{"buggy_code": ["/* Generic associative array implementation.\n *\n * See Documentation/core-api/assoc_array.rst for information.\n *\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n//#define DEBUG\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/assoc_array_priv.h>\n\n/*\n * Iterate over an associative array.  The caller must hold the RCU read lock\n * or better.\n */\nstatic int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,\n\t\t\t\t       const struct assoc_array_ptr *stop,\n\t\t\t\t       int (*iterator)(const void *leaf,\n\t\t\t\t\t\t       void *iterator_data),\n\t\t\t\t       void *iterator_data)\n{\n\tconst struct assoc_array_shortcut *shortcut;\n\tconst struct assoc_array_node *node;\n\tconst struct assoc_array_ptr *cursor, *ptr, *parent;\n\tunsigned long has_meta;\n\tint slot, ret;\n\n\tcursor = root;\n\nbegin_node:\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\t/* Descend through a shortcut */\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tsmp_read_barrier_depends();\n\t\tcursor = ACCESS_ONCE(shortcut->next_node);\n\t}\n\n\tnode = assoc_array_ptr_to_node(cursor);\n\tsmp_read_barrier_depends();\n\tslot = 0;\n\n\t/* We perform two passes of each node.\n\t *\n\t * The first pass does all the leaves in this node.  This means we\n\t * don't miss any leaves if the node is split up by insertion whilst\n\t * we're iterating over the branches rooted here (we may, however, see\n\t * some leaves twice).\n\t */\n\thas_meta = 0;\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\thas_meta |= (unsigned long)ptr;\n\t\tif (ptr && assoc_array_ptr_is_leaf(ptr)) {\n\t\t\t/* We need a barrier between the read of the pointer\n\t\t\t * and dereferencing the pointer - but only if we are\n\t\t\t * actually going to dereference it.\n\t\t\t */\n\t\t\tsmp_read_barrier_depends();\n\n\t\t\t/* Invoke the callback */\n\t\t\tret = iterator(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t       iterator_data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The second pass attends to all the metadata pointers.  If we follow\n\t * one of these we may find that we don't come back here, but rather go\n\t * back to a replacement node with the leaves in a different layout.\n\t *\n\t * We are guaranteed to make progress, however, as the slot number for\n\t * a particular portion of the key space cannot change - and we\n\t * continue at the back pointer + 1.\n\t */\n\tif (!(has_meta & ASSOC_ARRAY_PTR_META_TYPE))\n\t\tgoto finished_node;\n\tslot = 0;\n\ncontinue_node:\n\tnode = assoc_array_ptr_to_node(cursor);\n\tsmp_read_barrier_depends();\n\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tcursor = ptr;\n\t\t\tgoto begin_node;\n\t\t}\n\t}\n\nfinished_node:\n\t/* Move up to the parent (may need to skip back over a shortcut) */\n\tparent = ACCESS_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\tif (parent == stop)\n\t\treturn 0;\n\n\tif (assoc_array_ptr_is_shortcut(parent)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(parent);\n\t\tsmp_read_barrier_depends();\n\t\tcursor = parent;\n\t\tparent = ACCESS_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t\tif (parent == stop)\n\t\t\treturn 0;\n\t}\n\n\t/* Ascend to next slot in parent node */\n\tcursor = parent;\n\tslot++;\n\tgoto continue_node;\n}\n\n/**\n * assoc_array_iterate - Pass all objects in the array to a callback\n * @array: The array to iterate over.\n * @iterator: The callback function.\n * @iterator_data: Private data for the callback function.\n *\n * Iterate over all the objects in an associative array.  Each one will be\n * presented to the iterator function.\n *\n * If the array is being modified concurrently with the iteration then it is\n * possible that some objects in the array will be passed to the iterator\n * callback more than once - though every object should be passed at least\n * once.  If this is undesirable then the caller must lock against modification\n * for the duration of this function.\n *\n * The function will return 0 if no objects were in the array or else it will\n * return the result of the last iterator function called.  Iteration stops\n * immediately if any call to the iteration function results in a non-zero\n * return.\n *\n * The caller should hold the RCU read lock or better if concurrent\n * modification is possible.\n */\nint assoc_array_iterate(const struct assoc_array *array,\n\t\t\tint (*iterator)(const void *object,\n\t\t\t\t\tvoid *iterator_data),\n\t\t\tvoid *iterator_data)\n{\n\tstruct assoc_array_ptr *root = ACCESS_ONCE(array->root);\n\n\tif (!root)\n\t\treturn 0;\n\treturn assoc_array_subtree_iterate(root, NULL, iterator, iterator_data);\n}\n\nenum assoc_array_walk_status {\n\tassoc_array_walk_tree_empty,\n\tassoc_array_walk_found_terminal_node,\n\tassoc_array_walk_found_wrong_shortcut,\n};\n\nstruct assoc_array_walk_result {\n\tstruct {\n\t\tstruct assoc_array_node\t*node;\t/* Node in which leaf might be found */\n\t\tint\t\tlevel;\n\t\tint\t\tslot;\n\t} terminal_node;\n\tstruct {\n\t\tstruct assoc_array_shortcut *shortcut;\n\t\tint\t\tlevel;\n\t\tint\t\tsc_level;\n\t\tunsigned long\tsc_segments;\n\t\tunsigned long\tdissimilarity;\n\t} wrong_shortcut;\n};\n\n/*\n * Navigate through the internal tree looking for the closest node to the key.\n */\nstatic enum assoc_array_walk_status\nassoc_array_walk(const struct assoc_array *array,\n\t\t const struct assoc_array_ops *ops,\n\t\t const void *index_key,\n\t\t struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *cursor, *ptr;\n\tunsigned long sc_segments, dissimilarity;\n\tunsigned long segments;\n\tint level, sc_level, next_sc_level;\n\tint slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tcursor = ACCESS_ONCE(array->root);\n\tif (!cursor)\n\t\treturn assoc_array_walk_tree_empty;\n\n\tlevel = 0;\n\n\t/* Use segments from the key for the new leaf to navigate through the\n\t * internal tree, skipping through nodes and shortcuts that are on\n\t * route to the destination.  Eventually we'll come to a slot that is\n\t * either empty or contains a leaf at which point we've found a node in\n\t * which the leaf we're looking for might be found or into which it\n\t * should be inserted.\n\t */\njumped:\n\tsegments = ops->get_key_chunk(index_key, level);\n\tpr_devel(\"segments[%d]: %lx\\n\", level, segments);\n\n\tif (assoc_array_ptr_is_shortcut(cursor))\n\t\tgoto follow_shortcut;\n\nconsider_node:\n\tnode = assoc_array_ptr_to_node(cursor);\n\tsmp_read_barrier_depends();\n\n\tslot = segments >> (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tslot &= ASSOC_ARRAY_FAN_MASK;\n\tptr = ACCESS_ONCE(node->slots[slot]);\n\n\tpr_devel(\"consider slot %x [ix=%d type=%lu]\\n\",\n\t\t slot, level, (unsigned long)ptr & 3);\n\n\tif (!assoc_array_ptr_is_meta(ptr)) {\n\t\t/* The node doesn't have a node/shortcut pointer in the slot\n\t\t * corresponding to the index key that we have to follow.\n\t\t */\n\t\tresult->terminal_node.node = node;\n\t\tresult->terminal_node.level = level;\n\t\tresult->terminal_node.slot = slot;\n\t\tpr_devel(\"<--%s() = terminal_node\\n\", __func__);\n\t\treturn assoc_array_walk_found_terminal_node;\n\t}\n\n\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t/* There is a pointer to a node in the slot corresponding to\n\t\t * this index key segment, so we need to follow it.\n\t\t */\n\t\tcursor = ptr;\n\t\tlevel += ASSOC_ARRAY_LEVEL_STEP;\n\t\tif ((level & ASSOC_ARRAY_KEY_CHUNK_MASK) != 0)\n\t\t\tgoto consider_node;\n\t\tgoto jumped;\n\t}\n\n\t/* There is a shortcut in the slot corresponding to the index key\n\t * segment.  We follow the shortcut if its partial index key matches\n\t * this leaf's.  Otherwise we need to split the shortcut.\n\t */\n\tcursor = ptr;\nfollow_shortcut:\n\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\tsmp_read_barrier_depends();\n\tpr_devel(\"shortcut to %d\\n\", shortcut->skip_to_level);\n\tsc_level = level + ASSOC_ARRAY_LEVEL_STEP;\n\tBUG_ON(sc_level > shortcut->skip_to_level);\n\n\tdo {\n\t\t/* Check the leaf against the shortcut's index key a word at a\n\t\t * time, trimming the final word (the shortcut stores the index\n\t\t * key completely from the root to the shortcut's target).\n\t\t */\n\t\tif ((sc_level & ASSOC_ARRAY_KEY_CHUNK_MASK) == 0)\n\t\t\tsegments = ops->get_key_chunk(index_key, sc_level);\n\n\t\tsc_segments = shortcut->index_key[sc_level >> ASSOC_ARRAY_KEY_CHUNK_SHIFT];\n\t\tdissimilarity = segments ^ sc_segments;\n\n\t\tif (round_up(sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE) > shortcut->skip_to_level) {\n\t\t\t/* Trim segments that are beyond the shortcut */\n\t\t\tint shift = shortcut->skip_to_level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\t\tdissimilarity &= ~(ULONG_MAX << shift);\n\t\t\tnext_sc_level = shortcut->skip_to_level;\n\t\t} else {\n\t\t\tnext_sc_level = sc_level + ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\t\t\tnext_sc_level = round_down(next_sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\t}\n\n\t\tif (dissimilarity != 0) {\n\t\t\t/* This shortcut points elsewhere */\n\t\t\tresult->wrong_shortcut.shortcut = shortcut;\n\t\t\tresult->wrong_shortcut.level = level;\n\t\t\tresult->wrong_shortcut.sc_level = sc_level;\n\t\t\tresult->wrong_shortcut.sc_segments = sc_segments;\n\t\t\tresult->wrong_shortcut.dissimilarity = dissimilarity;\n\t\t\treturn assoc_array_walk_found_wrong_shortcut;\n\t\t}\n\n\t\tsc_level = next_sc_level;\n\t} while (sc_level < shortcut->skip_to_level);\n\n\t/* The shortcut matches the leaf's index to this point. */\n\tcursor = ACCESS_ONCE(shortcut->next_node);\n\tif (((level ^ sc_level) & ~ASSOC_ARRAY_KEY_CHUNK_MASK) != 0) {\n\t\tlevel = sc_level;\n\t\tgoto jumped;\n\t} else {\n\t\tlevel = sc_level;\n\t\tgoto consider_node;\n\t}\n}\n\n/**\n * assoc_array_find - Find an object by index key\n * @array: The associative array to search.\n * @ops: The operations to use.\n * @index_key: The key to the object.\n *\n * Find an object in an associative array by walking through the internal tree\n * to the node that should contain the object and then searching the leaves\n * there.  NULL is returned if the requested object was not found in the array.\n *\n * The caller must hold the RCU read lock or better.\n */\nvoid *assoc_array_find(const struct assoc_array *array,\n\t\t       const struct assoc_array_ops *ops,\n\t\t       const void *index_key)\n{\n\tstruct assoc_array_walk_result result;\n\tconst struct assoc_array_node *node;\n\tconst struct assoc_array_ptr *ptr;\n\tconst void *leaf;\n\tint slot;\n\n\tif (assoc_array_walk(array, ops, index_key, &result) !=\n\t    assoc_array_walk_found_terminal_node)\n\t\treturn NULL;\n\n\tnode = result.terminal_node.node;\n\tsmp_read_barrier_depends();\n\n\t/* If the target key is available to us, it's has to be pointed to by\n\t * the terminal node.\n\t */\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\tif (ptr && assoc_array_ptr_is_leaf(ptr)) {\n\t\t\t/* We need a barrier between the read of the pointer\n\t\t\t * and dereferencing the pointer - but only if we are\n\t\t\t * actually going to dereference it.\n\t\t\t */\n\t\t\tleaf = assoc_array_ptr_to_leaf(ptr);\n\t\t\tsmp_read_barrier_depends();\n\t\t\tif (ops->compare_object(leaf, index_key))\n\t\t\t\treturn (void *)leaf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Destructively iterate over an associative array.  The caller must prevent\n * other simultaneous accesses.\n */\nstatic void assoc_array_destroy_subtree(struct assoc_array_ptr *root,\n\t\t\t\t\tconst struct assoc_array_ops *ops)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *cursor, *parent = NULL;\n\tint slot = -1;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tcursor = root;\n\tif (!cursor) {\n\t\tpr_devel(\"empty\\n\");\n\t\treturn;\n\t}\n\nmove_to_meta:\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\t/* Descend through a shortcut */\n\t\tpr_devel(\"[%d] shortcut\\n\", slot);\n\t\tBUG_ON(!assoc_array_ptr_is_shortcut(cursor));\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tBUG_ON(shortcut->back_pointer != parent);\n\t\tBUG_ON(slot != -1 && shortcut->parent_slot != slot);\n\t\tparent = cursor;\n\t\tcursor = shortcut->next_node;\n\t\tslot = -1;\n\t\tBUG_ON(!assoc_array_ptr_is_node(cursor));\n\t}\n\n\tpr_devel(\"[%d] node\\n\", slot);\n\tnode = assoc_array_ptr_to_node(cursor);\n\tBUG_ON(node->back_pointer != parent);\n\tBUG_ON(slot != -1 && node->parent_slot != slot);\n\tslot = 0;\n\ncontinue_node:\n\tpr_devel(\"Node %p [back=%p]\\n\", node, node->back_pointer);\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tstruct assoc_array_ptr *ptr = node->slots[slot];\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tparent = cursor;\n\t\t\tcursor = ptr;\n\t\t\tgoto move_to_meta;\n\t\t}\n\n\t\tif (ops) {\n\t\t\tpr_devel(\"[%d] free leaf\\n\", slot);\n\t\t\tops->free_object(assoc_array_ptr_to_leaf(ptr));\n\t\t}\n\t}\n\n\tparent = node->back_pointer;\n\tslot = node->parent_slot;\n\tpr_devel(\"free node\\n\");\n\tkfree(node);\n\tif (!parent)\n\t\treturn; /* Done */\n\n\t/* Move back up to the parent (may need to free a shortcut on\n\t * the way up) */\n\tif (assoc_array_ptr_is_shortcut(parent)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(parent);\n\t\tBUG_ON(shortcut->next_node != cursor);\n\t\tcursor = parent;\n\t\tparent = shortcut->back_pointer;\n\t\tslot = shortcut->parent_slot;\n\t\tpr_devel(\"free shortcut\\n\");\n\t\tkfree(shortcut);\n\t\tif (!parent)\n\t\t\treturn;\n\n\t\tBUG_ON(!assoc_array_ptr_is_node(parent));\n\t}\n\n\t/* Ascend to next slot in parent node */\n\tpr_devel(\"ascend to %p[%d]\\n\", parent, slot);\n\tcursor = parent;\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot++;\n\tgoto continue_node;\n}\n\n/**\n * assoc_array_destroy - Destroy an associative array\n * @array: The array to destroy.\n * @ops: The operations to use.\n *\n * Discard all metadata and free all objects in an associative array.  The\n * array will be empty and ready to use again upon completion.  This function\n * cannot fail.\n *\n * The caller must prevent all other accesses whilst this takes place as no\n * attempt is made to adjust pointers gracefully to permit RCU readlock-holding\n * accesses to continue.  On the other hand, no memory allocation is required.\n */\nvoid assoc_array_destroy(struct assoc_array *array,\n\t\t\t const struct assoc_array_ops *ops)\n{\n\tassoc_array_destroy_subtree(array->root, ops);\n\tarray->root = NULL;\n}\n\n/*\n * Handle insertion into an empty tree.\n */\nstatic bool assoc_array_insert_in_empty_tree(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_node *new_n0;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[0];\n\tedit->adjust_count_on = new_n0;\n\tedit->set[0].ptr = &edit->array->root;\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\n\tpr_devel(\"<--%s() = ok [no root]\\n\", __func__);\n\treturn true;\n}\n\n/*\n * Handle insertion into a terminal node.\n */\nstatic bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise we can just insert a new node ahead of the old\n\t\t * one.\n\t\t */\n\t\tgoto present_leaves_cluster_but_not_new_leaf;\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node; we know that the node doesn't\n\t * simply contain a full set of leaves that cluster together (it\n\t * contains meta pointers and/or non-clustering leaves).\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\npresent_leaves_cluster_but_not_new_leaf:\n\t/* All the old leaves cluster in the same slot, but the new leaf wants\n\t * to go into a different slot, so we create a new node to hold the new\n\t * leaf and a pointer to a new node holding all the old leaves.\n\t */\n\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = edit->segment_cache[0];\n\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tedit->adjust_count_on = new_n0;\n\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tnew_n1->slots[i] = node->slots[i];\n\n\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n\n\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}\n\n/*\n * Handle insertion into the middle of a shortcut.\n */\nstatic bool assoc_array_insert_mid_shortcut(struct assoc_array_edit *edit,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0, *new_s1;\n\tstruct assoc_array_node *node, *new_n0, *side;\n\tunsigned long sc_segments, dissimilarity, blank;\n\tsize_t keylen;\n\tint level, sc_level, diff;\n\tint sc_slot;\n\n\tshortcut\t= result->wrong_shortcut.shortcut;\n\tlevel\t\t= result->wrong_shortcut.level;\n\tsc_level\t= result->wrong_shortcut.sc_level;\n\tsc_segments\t= result->wrong_shortcut.sc_segments;\n\tdissimilarity\t= result->wrong_shortcut.dissimilarity;\n\n\tpr_devel(\"-->%s(ix=%d dis=%lx scix=%d)\\n\",\n\t\t __func__, level, dissimilarity, sc_level);\n\n\t/* We need to split a shortcut and insert a node between the two\n\t * pieces.  Zero-length pieces will be dispensed with entirely.\n\t *\n\t * First of all, we need to find out in which level the first\n\t * difference was.\n\t */\n\tdiff = __ffs(dissimilarity);\n\tdiff &= ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tdiff += sc_level & ~ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tpr_devel(\"diff=%d\\n\", diff);\n\n\tif (!shortcut->back_pointer) {\n\t\tedit->set[0].ptr = &edit->array->root;\n\t} else if (assoc_array_ptr_is_node(shortcut->back_pointer)) {\n\t\tnode = assoc_array_ptr_to_node(shortcut->back_pointer);\n\t\tedit->set[0].ptr = &node->slots[shortcut->parent_slot];\n\t} else {\n\t\tBUG();\n\t}\n\n\tedit->excised_meta[0] = assoc_array_shortcut_to_ptr(shortcut);\n\n\t/* Create a new node now since we're going to need it anyway */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tedit->adjust_count_on = new_n0;\n\n\t/* Insert a new shortcut before the new node if this segment isn't of\n\t * zero length - otherwise we just connect the new node directly to the\n\t * parent.\n\t */\n\tlevel += ASSOC_ARRAY_LEVEL_STEP;\n\tif (diff > level) {\n\t\tpr_devel(\"pre-shortcut %d...%d\\n\", level, diff);\n\t\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\t\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\t\tif (!new_s0)\n\t\t\treturn false;\n\t\tedit->new_meta[1] = assoc_array_shortcut_to_ptr(new_s0);\n\t\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\t\tnew_s0->back_pointer = shortcut->back_pointer;\n\t\tnew_s0->parent_slot = shortcut->parent_slot;\n\t\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\t\tnew_s0->skip_to_level = diff;\n\n\t\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\t\tnew_n0->parent_slot = 0;\n\n\t\tmemcpy(new_s0->index_key, shortcut->index_key,\n\t\t       keylen * sizeof(unsigned long));\n\n\t\tblank = ULONG_MAX << (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\t\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, diff, blank);\n\t\tnew_s0->index_key[keylen - 1] &= ~blank;\n\t} else {\n\t\tpr_devel(\"no pre-shortcut\\n\");\n\t\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\t\tnew_n0->back_pointer = shortcut->back_pointer;\n\t\tnew_n0->parent_slot = shortcut->parent_slot;\n\t}\n\n\tside = assoc_array_ptr_to_node(shortcut->next_node);\n\tnew_n0->nr_leaves_on_branch = side->nr_leaves_on_branch;\n\n\t/* We need to know which slot in the new node is going to take a\n\t * metadata pointer.\n\t */\n\tsc_slot = sc_segments >> (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tsc_slot &= ASSOC_ARRAY_FAN_MASK;\n\n\tpr_devel(\"new slot %lx >> %d -> %d\\n\",\n\t\t sc_segments, diff & ASSOC_ARRAY_KEY_CHUNK_MASK, sc_slot);\n\n\t/* Determine whether we need to follow the new node with a replacement\n\t * for the current shortcut.  We could in theory reuse the current\n\t * shortcut if its parent slot number doesn't change - but that's a\n\t * 1-in-16 chance so not worth expending the code upon.\n\t */\n\tlevel = diff + ASSOC_ARRAY_LEVEL_STEP;\n\tif (level < shortcut->skip_to_level) {\n\t\tpr_devel(\"post-shortcut %d...%d\\n\", level, shortcut->skip_to_level);\n\t\tkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\t\tnew_s1 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\t\tif (!new_s1)\n\t\t\treturn false;\n\t\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s1);\n\n\t\tnew_s1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\t\tnew_s1->parent_slot = sc_slot;\n\t\tnew_s1->next_node = shortcut->next_node;\n\t\tnew_s1->skip_to_level = shortcut->skip_to_level;\n\n\t\tnew_n0->slots[sc_slot] = assoc_array_shortcut_to_ptr(new_s1);\n\n\t\tmemcpy(new_s1->index_key, shortcut->index_key,\n\t\t       keylen * sizeof(unsigned long));\n\n\t\tedit->set[1].ptr = &side->back_pointer;\n\t\tedit->set[1].to = assoc_array_shortcut_to_ptr(new_s1);\n\t} else {\n\t\tpr_devel(\"no post-shortcut\\n\");\n\n\t\t/* We don't have to replace the pointed-to node as long as we\n\t\t * use memory barriers to make sure the parent slot number is\n\t\t * changed before the back pointer (the parent slot number is\n\t\t * irrelevant to the old parent shortcut).\n\t\t */\n\t\tnew_n0->slots[sc_slot] = shortcut->next_node;\n\t\tedit->set_parent_slot[0].p = &side->parent_slot;\n\t\tedit->set_parent_slot[0].to = sc_slot;\n\t\tedit->set[1].ptr = &side->back_pointer;\n\t\tedit->set[1].to = assoc_array_node_to_ptr(new_n0);\n\t}\n\n\t/* Install the new leaf in a spare slot in the new node. */\n\tif (sc_slot == 0)\n\t\tedit->leaf_p = &new_n0->slots[1];\n\telse\n\t\tedit->leaf_p = &new_n0->slots[0];\n\n\tpr_devel(\"<--%s() = ok [split shortcut]\\n\", __func__);\n\treturn edit;\n}\n\n/**\n * assoc_array_insert - Script insertion of an object into an associative array\n * @array: The array to insert into.\n * @ops: The operations to use.\n * @index_key: The key to insert at.\n * @object: The object to insert.\n *\n * Precalculate and preallocate a script for the insertion or replacement of an\n * object in an associative array.  This results in an edit script that can\n * either be applied or cancelled.\n *\n * The function returns a pointer to an edit script or -ENOMEM.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nstruct assoc_array_edit *assoc_array_insert(struct assoc_array *array,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    const void *index_key,\n\t\t\t\t\t    void *object)\n{\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_edit *edit;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* The leaf pointer we're given must not have the bottom bit set as we\n\t * use those for type-marking the pointer.  NULL pointers are also not\n\t * allowed as they indicate an empty slot but we have to allow them\n\t * here as they can be updated later.\n\t */\n\tBUG_ON(assoc_array_ptr_is_meta(object));\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->leaf = assoc_array_leaf_to_ptr(object);\n\tedit->adjust_count_by = 1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_tree_empty:\n\t\t/* Allocate a root node if there isn't one yet */\n\t\tif (!assoc_array_insert_in_empty_tree(edit))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\n\tcase assoc_array_walk_found_terminal_node:\n\t\t/* We found a node that doesn't have a node/shortcut pointer in\n\t\t * the slot corresponding to the index key that we have to\n\t\t * follow.\n\t\t */\n\t\tif (!assoc_array_insert_into_terminal_node(edit, ops, index_key,\n\t\t\t\t\t\t\t   &result))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\n\tcase assoc_array_walk_found_wrong_shortcut:\n\t\t/* We found a shortcut that didn't match our key in a slot we\n\t\t * needed to follow.\n\t\t */\n\t\tif (!assoc_array_insert_mid_shortcut(edit, ops, &result))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\t}\n\nenomem:\n\t/* Clean up after an out of memory error */\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_cancel_edit(edit);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n/**\n * assoc_array_insert_set_object - Set the new object pointer in an edit script\n * @edit: The edit script to modify.\n * @object: The object pointer to set.\n *\n * Change the object to be inserted in an edit script.  The object pointed to\n * by the old object is not freed.  This must be done prior to applying the\n * script.\n */\nvoid assoc_array_insert_set_object(struct assoc_array_edit *edit, void *object)\n{\n\tBUG_ON(!object);\n\tedit->leaf = assoc_array_leaf_to_ptr(object);\n}\n\nstruct assoc_array_delete_collapse_context {\n\tstruct assoc_array_node\t*node;\n\tconst void\t\t*skip_leaf;\n\tint\t\t\tslot;\n};\n\n/*\n * Subtree collapse to node iterator.\n */\nstatic int assoc_array_delete_collapse_iterator(const void *leaf,\n\t\t\t\t\t\tvoid *iterator_data)\n{\n\tstruct assoc_array_delete_collapse_context *collapse = iterator_data;\n\n\tif (leaf == collapse->skip_leaf)\n\t\treturn 0;\n\n\tBUG_ON(collapse->slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tcollapse->node->slots[collapse->slot++] = assoc_array_leaf_to_ptr(leaf);\n\treturn 0;\n}\n\n/**\n * assoc_array_delete - Script deletion of an object from an associative array\n * @array: The array to search.\n * @ops: The operations to use.\n * @index_key: The key to the object.\n *\n * Precalculate and preallocate a script for the deletion of an object from an\n * associative array.  This results in an edit script that can either be\n * applied or cancelled.\n *\n * The function returns a pointer to an edit script if the object was found,\n * NULL if the object was not found or -ENOMEM.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nstruct assoc_array_edit *assoc_array_delete(struct assoc_array *array,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    const void *index_key)\n{\n\tstruct assoc_array_delete_collapse_context collapse;\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_node *node, *new_n0;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *ptr;\n\tbool has_meta;\n\tint slot, i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->adjust_count_by = -1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_found_terminal_node:\n\t\t/* We found a node that should contain the leaf we've been\n\t\t * asked to remove - *if* it's in the tree.\n\t\t */\n\t\tpr_devel(\"terminal_node\\n\");\n\t\tnode = result.terminal_node.node;\n\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\t\tptr = node->slots[slot];\n\t\t\tif (ptr &&\n\t\t\t    assoc_array_ptr_is_leaf(ptr) &&\n\t\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\tindex_key))\n\t\t\t\tgoto found_leaf;\n\t\t}\n\tcase assoc_array_walk_tree_empty:\n\tcase assoc_array_walk_found_wrong_shortcut:\n\tdefault:\n\t\tassoc_array_cancel_edit(edit);\n\t\tpr_devel(\"not found\\n\");\n\t\treturn NULL;\n\t}\n\nfound_leaf:\n\tBUG_ON(array->nr_leaves_on_tree <= 0);\n\n\t/* In the simplest form of deletion we just clear the slot and release\n\t * the leaf after a suitable interval.\n\t */\n\tedit->dead_leaf = node->slots[slot];\n\tedit->set[0].ptr = &node->slots[slot];\n\tedit->set[0].to = NULL;\n\tedit->adjust_count_on = node;\n\n\t/* If that concludes erasure of the last leaf, then delete the entire\n\t * internal array.\n\t */\n\tif (array->nr_leaves_on_tree == 1) {\n\t\tedit->set[1].ptr = &array->root;\n\t\tedit->set[1].to = NULL;\n\t\tedit->adjust_count_on = NULL;\n\t\tedit->excised_subtree = array->root;\n\t\tpr_devel(\"all gone\\n\");\n\t\treturn edit;\n\t}\n\n\t/* However, we'd also like to clear up some metadata blocks if we\n\t * possibly can.\n\t *\n\t * We go for a simple algorithm of: if this node has FAN_OUT or fewer\n\t * leaves in it, then attempt to collapse it - and attempt to\n\t * recursively collapse up the tree.\n\t *\n\t * We could also try and collapse in partially filled subtrees to take\n\t * up space in this node.\n\t */\n\tif (node->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n\t\tstruct assoc_array_node *parent, *grandparent;\n\t\tstruct assoc_array_ptr *ptr;\n\n\t\t/* First of all, we need to know if this node has metadata so\n\t\t * that we don't try collapsing if all the leaves are already\n\t\t * here.\n\t\t */\n\t\thas_meta = false;\n\t\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\t\tptr = node->slots[i];\n\t\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\t\thas_meta = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpr_devel(\"leaves: %ld [m=%d]\\n\",\n\t\t\t node->nr_leaves_on_branch - 1, has_meta);\n\n\t\t/* Look further up the tree to see if we can collapse this node\n\t\t * into a more proximal node too.\n\t\t */\n\t\tparent = node;\n\tcollapse_up:\n\t\tpr_devel(\"collapse subtree: %ld\\n\", parent->nr_leaves_on_branch);\n\n\t\tptr = parent->back_pointer;\n\t\tif (!ptr)\n\t\t\tgoto do_collapse;\n\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\tstruct assoc_array_shortcut *s = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tptr = s->back_pointer;\n\t\t\tif (!ptr)\n\t\t\t\tgoto do_collapse;\n\t\t}\n\n\t\tgrandparent = assoc_array_ptr_to_node(ptr);\n\t\tif (grandparent->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n\t\t\tparent = grandparent;\n\t\t\tgoto collapse_up;\n\t\t}\n\n\tdo_collapse:\n\t\t/* There's no point collapsing if the original node has no meta\n\t\t * pointers to discard and if we didn't merge into one of that\n\t\t * node's ancestry.\n\t\t */\n\t\tif (has_meta || parent != node) {\n\t\t\tnode = parent;\n\n\t\t\t/* Create a new node to collapse into */\n\t\t\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\t\t\tif (!new_n0)\n\t\t\t\tgoto enomem;\n\t\t\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\n\t\t\tnew_n0->back_pointer = node->back_pointer;\n\t\t\tnew_n0->parent_slot = node->parent_slot;\n\t\t\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\t\t\tedit->adjust_count_on = new_n0;\n\n\t\t\tcollapse.node = new_n0;\n\t\t\tcollapse.skip_leaf = assoc_array_ptr_to_leaf(edit->dead_leaf);\n\t\t\tcollapse.slot = 0;\n\t\t\tassoc_array_subtree_iterate(assoc_array_node_to_ptr(node),\n\t\t\t\t\t\t    node->back_pointer,\n\t\t\t\t\t\t    assoc_array_delete_collapse_iterator,\n\t\t\t\t\t\t    &collapse);\n\t\t\tpr_devel(\"collapsed %d,%lu\\n\", collapse.slot, new_n0->nr_leaves_on_branch);\n\t\t\tBUG_ON(collapse.slot != new_n0->nr_leaves_on_branch - 1);\n\n\t\t\tif (!node->back_pointer) {\n\t\t\t\tedit->set[1].ptr = &array->root;\n\t\t\t} else if (assoc_array_ptr_is_leaf(node->back_pointer)) {\n\t\t\t\tBUG();\n\t\t\t} else if (assoc_array_ptr_is_node(node->back_pointer)) {\n\t\t\t\tstruct assoc_array_node *p =\n\t\t\t\t\tassoc_array_ptr_to_node(node->back_pointer);\n\t\t\t\tedit->set[1].ptr = &p->slots[node->parent_slot];\n\t\t\t} else if (assoc_array_ptr_is_shortcut(node->back_pointer)) {\n\t\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\t\tassoc_array_ptr_to_shortcut(node->back_pointer);\n\t\t\t\tedit->set[1].ptr = &s->next_node;\n\t\t\t}\n\t\t\tedit->set[1].to = assoc_array_node_to_ptr(new_n0);\n\t\t\tedit->excised_subtree = assoc_array_node_to_ptr(node);\n\t\t}\n\t}\n\n\treturn edit;\n\nenomem:\n\t/* Clean up after an out of memory error */\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_cancel_edit(edit);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n/**\n * assoc_array_clear - Script deletion of all objects from an associative array\n * @array: The array to clear.\n * @ops: The operations to use.\n *\n * Precalculate and preallocate a script for the deletion of all the objects\n * from an associative array.  This results in an edit script that can either\n * be applied or cancelled.\n *\n * The function returns a pointer to an edit script if there are objects to be\n * deleted, NULL if there are no objects in the array or -ENOMEM.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nstruct assoc_array_edit *assoc_array_clear(struct assoc_array *array,\n\t\t\t\t\t   const struct assoc_array_ops *ops)\n{\n\tstruct assoc_array_edit *edit;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (!array->root)\n\t\treturn NULL;\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->set[1].ptr = &array->root;\n\tedit->set[1].to = NULL;\n\tedit->excised_subtree = array->root;\n\tedit->ops_for_excised_subtree = ops;\n\tpr_devel(\"all gone\\n\");\n\treturn edit;\n}\n\n/*\n * Handle the deferred destruction after an applied edit.\n */\nstatic void assoc_array_rcu_cleanup(struct rcu_head *head)\n{\n\tstruct assoc_array_edit *edit =\n\t\tcontainer_of(head, struct assoc_array_edit, rcu);\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (edit->dead_leaf)\n\t\tedit->ops->free_object(assoc_array_ptr_to_leaf(edit->dead_leaf));\n\tfor (i = 0; i < ARRAY_SIZE(edit->excised_meta); i++)\n\t\tif (edit->excised_meta[i])\n\t\t\tkfree(assoc_array_ptr_to_node(edit->excised_meta[i]));\n\n\tif (edit->excised_subtree) {\n\t\tBUG_ON(assoc_array_ptr_is_leaf(edit->excised_subtree));\n\t\tif (assoc_array_ptr_is_node(edit->excised_subtree)) {\n\t\t\tstruct assoc_array_node *n =\n\t\t\t\tassoc_array_ptr_to_node(edit->excised_subtree);\n\t\t\tn->back_pointer = NULL;\n\t\t} else {\n\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\tassoc_array_ptr_to_shortcut(edit->excised_subtree);\n\t\t\ts->back_pointer = NULL;\n\t\t}\n\t\tassoc_array_destroy_subtree(edit->excised_subtree,\n\t\t\t\t\t    edit->ops_for_excised_subtree);\n\t}\n\n\tkfree(edit);\n}\n\n/**\n * assoc_array_apply_edit - Apply an edit script to an associative array\n * @edit: The script to apply.\n *\n * Apply an edit script to an associative array to effect an insertion,\n * deletion or clearance.  As the edit script includes preallocated memory,\n * this is guaranteed not to fail.\n *\n * The edit script, dead objects and dead metadata will be scheduled for\n * destruction after an RCU grace period to permit those doing read-only\n * accesses on the array to continue to do so under the RCU read lock whilst\n * the edit is taking place.\n */\nvoid assoc_array_apply_edit(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tsmp_wmb();\n\tif (edit->leaf_p)\n\t\t*edit->leaf_p = edit->leaf;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set_parent_slot); i++)\n\t\tif (edit->set_parent_slot[i].p)\n\t\t\t*edit->set_parent_slot[i].p = edit->set_parent_slot[i].to;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set_backpointers); i++)\n\t\tif (edit->set_backpointers[i])\n\t\t\t*edit->set_backpointers[i] = edit->set_backpointers_to;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set); i++)\n\t\tif (edit->set[i].ptr)\n\t\t\t*edit->set[i].ptr = edit->set[i].to;\n\n\tif (edit->array->root == NULL) {\n\t\tedit->array->nr_leaves_on_tree = 0;\n\t} else if (edit->adjust_count_on) {\n\t\tnode = edit->adjust_count_on;\n\t\tfor (;;) {\n\t\t\tnode->nr_leaves_on_branch += edit->adjust_count_by;\n\n\t\t\tptr = node->back_pointer;\n\t\t\tif (!ptr)\n\t\t\t\tbreak;\n\t\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tptr = shortcut->back_pointer;\n\t\t\t\tif (!ptr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\t}\n\n\t\tedit->array->nr_leaves_on_tree += edit->adjust_count_by;\n\t}\n\n\tcall_rcu(&edit->rcu, assoc_array_rcu_cleanup);\n}\n\n/**\n * assoc_array_cancel_edit - Discard an edit script.\n * @edit: The script to discard.\n *\n * Free an edit script and all the preallocated data it holds without making\n * any changes to the associative array it was intended for.\n *\n * NOTE!  In the case of an insertion script, this does _not_ release the leaf\n * that was to be inserted.  That is left to the caller.\n */\nvoid assoc_array_cancel_edit(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_ptr *ptr;\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* Clean up after an out of memory error */\n\tfor (i = 0; i < ARRAY_SIZE(edit->new_meta); i++) {\n\t\tptr = edit->new_meta[i];\n\t\tif (ptr) {\n\t\t\tif (assoc_array_ptr_is_node(ptr))\n\t\t\t\tkfree(assoc_array_ptr_to_node(ptr));\n\t\t\telse\n\t\t\t\tkfree(assoc_array_ptr_to_shortcut(ptr));\n\t\t}\n\t}\n\tkfree(edit);\n}\n\n/**\n * assoc_array_gc - Garbage collect an associative array.\n * @array: The array to clean.\n * @ops: The operations to use.\n * @iterator: A callback function to pass judgement on each object.\n * @iterator_data: Private data for the callback function.\n *\n * Collect garbage from an associative array and pack down the internal tree to\n * save memory.\n *\n * The iterator function is asked to pass judgement upon each object in the\n * array.  If it returns false, the object is discard and if it returns true,\n * the object is kept.  If it returns true, it must increment the object's\n * usage count (or whatever it needs to do to retain it) before returning.\n *\n * This function returns 0 if successful or -ENOMEM if out of memory.  In the\n * latter case, the array is not changed.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nint assoc_array_gc(struct assoc_array *array,\n\t\t   const struct assoc_array_ops *ops,\n\t\t   bool (*iterator)(void *object, void *iterator_data),\n\t\t   void *iterator_data)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s;\n\tstruct assoc_array_node *node, *new_n;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *cursor, *ptr;\n\tstruct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;\n\tunsigned long nr_leaves_on_tree;\n\tint keylen, slot, nr_free, next_slot, i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (!array->root)\n\t\treturn 0;\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn -ENOMEM;\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->ops_for_excised_subtree = ops;\n\tedit->set[0].ptr = &array->root;\n\tedit->excised_subtree = array->root;\n\n\tnew_root = new_parent = NULL;\n\tnew_ptr_pp = &new_root;\n\tcursor = array->root;\n\ndescend:\n\t/* If this point is a shortcut, then we need to duplicate it and\n\t * advance the target cursor.\n\t */\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\t\tnew_s = kmalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t\tkeylen * sizeof(unsigned long), GFP_KERNEL);\n\t\tif (!new_s)\n\t\t\tgoto enomem;\n\t\tpr_devel(\"dup shortcut %p -> %p\\n\", shortcut, new_s);\n\t\tmemcpy(new_s, shortcut, (sizeof(struct assoc_array_shortcut) +\n\t\t\t\t\t keylen * sizeof(unsigned long)));\n\t\tnew_s->back_pointer = new_parent;\n\t\tnew_s->parent_slot = shortcut->parent_slot;\n\t\t*new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr(new_s);\n\t\tnew_ptr_pp = &new_s->next_node;\n\t\tcursor = shortcut->next_node;\n\t}\n\n\t/* Duplicate the node at this position */\n\tnode = assoc_array_ptr_to_node(cursor);\n\tnew_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n)\n\t\tgoto enomem;\n\tpr_devel(\"dup node %p -> %p\\n\", node, new_n);\n\tnew_n->back_pointer = new_parent;\n\tnew_n->parent_slot = node->parent_slot;\n\t*new_ptr_pp = new_parent = assoc_array_node_to_ptr(new_n);\n\tnew_ptr_pp = NULL;\n\tslot = 0;\n\ncontinue_node:\n\t/* Filter across any leaves and gc any subtrees */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = node->slots[slot];\n\t\tif (!ptr)\n\t\t\tcontinue;\n\n\t\tif (assoc_array_ptr_is_leaf(ptr)) {\n\t\t\tif (iterator(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t     iterator_data))\n\t\t\t\t/* The iterator will have done any reference\n\t\t\t\t * counting on the object for us.\n\t\t\t\t */\n\t\t\t\tnew_n->slots[slot] = ptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_ptr_pp = &new_n->slots[slot];\n\t\tcursor = ptr;\n\t\tgoto descend;\n\t}\n\n\tpr_devel(\"-- compress node %p --\\n\", new_n);\n\n\t/* Count up the number of empty slots in this node and work out the\n\t * subtree leaf count.\n\t */\n\tnew_n->nr_leaves_on_branch = 0;\n\tnr_free = 0;\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = new_n->slots[slot];\n\t\tif (!ptr)\n\t\t\tnr_free++;\n\t\telse if (assoc_array_ptr_is_leaf(ptr))\n\t\t\tnew_n->nr_leaves_on_branch++;\n\t}\n\tpr_devel(\"free=%d, leaves=%lu\\n\", nr_free, new_n->nr_leaves_on_branch);\n\n\t/* See what we can fold in */\n\tnext_slot = 0;\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tstruct assoc_array_shortcut *s;\n\t\tstruct assoc_array_node *child;\n\n\t\tptr = new_n->slots[slot];\n\t\tif (!ptr || assoc_array_ptr_is_leaf(ptr))\n\t\t\tcontinue;\n\n\t\ts = NULL;\n\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\ts = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tptr = s->next_node;\n\t\t}\n\n\t\tchild = assoc_array_ptr_to_node(ptr);\n\t\tnew_n->nr_leaves_on_branch += child->nr_leaves_on_branch;\n\n\t\tif (child->nr_leaves_on_branch <= nr_free + 1) {\n\t\t\t/* Fold the child node into this one */\n\t\t\tpr_devel(\"[%d] fold node %lu/%d [nx %d]\\n\",\n\t\t\t\t slot, child->nr_leaves_on_branch, nr_free + 1,\n\t\t\t\t next_slot);\n\n\t\t\t/* We would already have reaped an intervening shortcut\n\t\t\t * on the way back up the tree.\n\t\t\t */\n\t\t\tBUG_ON(s);\n\n\t\t\tnew_n->slots[slot] = NULL;\n\t\t\tnr_free++;\n\t\t\tif (slot < next_slot)\n\t\t\t\tnext_slot = slot;\n\t\t\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\t\t\tstruct assoc_array_ptr *p = child->slots[i];\n\t\t\t\tif (!p)\n\t\t\t\t\tcontinue;\n\t\t\t\tBUG_ON(assoc_array_ptr_is_meta(p));\n\t\t\t\twhile (new_n->slots[next_slot])\n\t\t\t\t\tnext_slot++;\n\t\t\t\tBUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);\n\t\t\t\tnew_n->slots[next_slot++] = p;\n\t\t\t\tnr_free--;\n\t\t\t}\n\t\t\tkfree(child);\n\t\t} else {\n\t\t\tpr_devel(\"[%d] retain node %lu/%d [nx %d]\\n\",\n\t\t\t\t slot, child->nr_leaves_on_branch, nr_free + 1,\n\t\t\t\t next_slot);\n\t\t}\n\t}\n\n\tpr_devel(\"after: %lu\\n\", new_n->nr_leaves_on_branch);\n\n\tnr_leaves_on_tree = new_n->nr_leaves_on_branch;\n\n\t/* Excise this node if it is singly occupied by a shortcut */\n\tif (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)\n\t\t\tif ((ptr = new_n->slots[slot]))\n\t\t\t\tbreak;\n\n\t\tif (assoc_array_ptr_is_meta(ptr) &&\n\t\t    assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\tpr_devel(\"excise node %p with 1 shortcut\\n\", new_n);\n\t\t\tnew_s = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tnew_parent = new_n->back_pointer;\n\t\t\tslot = new_n->parent_slot;\n\t\t\tkfree(new_n);\n\t\t\tif (!new_parent) {\n\t\t\t\tnew_s->back_pointer = NULL;\n\t\t\t\tnew_s->parent_slot = 0;\n\t\t\t\tnew_root = ptr;\n\t\t\t\tgoto gc_complete;\n\t\t\t}\n\n\t\t\tif (assoc_array_ptr_is_shortcut(new_parent)) {\n\t\t\t\t/* We can discard any preceding shortcut also */\n\t\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\t\tassoc_array_ptr_to_shortcut(new_parent);\n\n\t\t\t\tpr_devel(\"excise preceding shortcut\\n\");\n\n\t\t\t\tnew_parent = new_s->back_pointer = s->back_pointer;\n\t\t\t\tslot = new_s->parent_slot = s->parent_slot;\n\t\t\t\tkfree(s);\n\t\t\t\tif (!new_parent) {\n\t\t\t\t\tnew_s->back_pointer = NULL;\n\t\t\t\t\tnew_s->parent_slot = 0;\n\t\t\t\t\tnew_root = ptr;\n\t\t\t\t\tgoto gc_complete;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_s->back_pointer = new_parent;\n\t\t\tnew_s->parent_slot = slot;\n\t\t\tnew_n = assoc_array_ptr_to_node(new_parent);\n\t\t\tnew_n->slots[slot] = ptr;\n\t\t\tgoto ascend_old_tree;\n\t\t}\n\t}\n\n\t/* Excise any shortcuts we might encounter that point to nodes that\n\t * only contain leaves.\n\t */\n\tptr = new_n->back_pointer;\n\tif (!ptr)\n\t\tgoto gc_complete;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tnew_s = assoc_array_ptr_to_shortcut(ptr);\n\t\tnew_parent = new_s->back_pointer;\n\t\tslot = new_s->parent_slot;\n\n\t\tif (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\n\t\t\tstruct assoc_array_node *n;\n\n\t\t\tpr_devel(\"excise shortcut\\n\");\n\t\t\tnew_n->back_pointer = new_parent;\n\t\t\tnew_n->parent_slot = slot;\n\t\t\tkfree(new_s);\n\t\t\tif (!new_parent) {\n\t\t\t\tnew_root = assoc_array_node_to_ptr(new_n);\n\t\t\t\tgoto gc_complete;\n\t\t\t}\n\n\t\t\tn = assoc_array_ptr_to_node(new_parent);\n\t\t\tn->slots[slot] = assoc_array_node_to_ptr(new_n);\n\t\t}\n\t} else {\n\t\tnew_parent = ptr;\n\t}\n\tnew_n = assoc_array_ptr_to_node(new_parent);\n\nascend_old_tree:\n\tptr = node->back_pointer;\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tslot = shortcut->parent_slot;\n\t\tcursor = shortcut->back_pointer;\n\t\tif (!cursor)\n\t\t\tgoto gc_complete;\n\t} else {\n\t\tslot = node->parent_slot;\n\t\tcursor = ptr;\n\t}\n\tBUG_ON(!cursor);\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot++;\n\tgoto continue_node;\n\ngc_complete:\n\tedit->set[0].to = new_root;\n\tassoc_array_apply_edit(edit);\n\tarray->nr_leaves_on_tree = nr_leaves_on_tree;\n\treturn 0;\n\nenomem:\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_destroy_subtree(new_root, edit->ops);\n\tkfree(edit);\n\treturn -ENOMEM;\n}\n"], "fixing_code": ["/* Generic associative array implementation.\n *\n * See Documentation/core-api/assoc_array.rst for information.\n *\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n//#define DEBUG\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/assoc_array_priv.h>\n\n/*\n * Iterate over an associative array.  The caller must hold the RCU read lock\n * or better.\n */\nstatic int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,\n\t\t\t\t       const struct assoc_array_ptr *stop,\n\t\t\t\t       int (*iterator)(const void *leaf,\n\t\t\t\t\t\t       void *iterator_data),\n\t\t\t\t       void *iterator_data)\n{\n\tconst struct assoc_array_shortcut *shortcut;\n\tconst struct assoc_array_node *node;\n\tconst struct assoc_array_ptr *cursor, *ptr, *parent;\n\tunsigned long has_meta;\n\tint slot, ret;\n\n\tcursor = root;\n\nbegin_node:\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\t/* Descend through a shortcut */\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tsmp_read_barrier_depends();\n\t\tcursor = ACCESS_ONCE(shortcut->next_node);\n\t}\n\n\tnode = assoc_array_ptr_to_node(cursor);\n\tsmp_read_barrier_depends();\n\tslot = 0;\n\n\t/* We perform two passes of each node.\n\t *\n\t * The first pass does all the leaves in this node.  This means we\n\t * don't miss any leaves if the node is split up by insertion whilst\n\t * we're iterating over the branches rooted here (we may, however, see\n\t * some leaves twice).\n\t */\n\thas_meta = 0;\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\thas_meta |= (unsigned long)ptr;\n\t\tif (ptr && assoc_array_ptr_is_leaf(ptr)) {\n\t\t\t/* We need a barrier between the read of the pointer\n\t\t\t * and dereferencing the pointer - but only if we are\n\t\t\t * actually going to dereference it.\n\t\t\t */\n\t\t\tsmp_read_barrier_depends();\n\n\t\t\t/* Invoke the callback */\n\t\t\tret = iterator(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t       iterator_data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The second pass attends to all the metadata pointers.  If we follow\n\t * one of these we may find that we don't come back here, but rather go\n\t * back to a replacement node with the leaves in a different layout.\n\t *\n\t * We are guaranteed to make progress, however, as the slot number for\n\t * a particular portion of the key space cannot change - and we\n\t * continue at the back pointer + 1.\n\t */\n\tif (!(has_meta & ASSOC_ARRAY_PTR_META_TYPE))\n\t\tgoto finished_node;\n\tslot = 0;\n\ncontinue_node:\n\tnode = assoc_array_ptr_to_node(cursor);\n\tsmp_read_barrier_depends();\n\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tcursor = ptr;\n\t\t\tgoto begin_node;\n\t\t}\n\t}\n\nfinished_node:\n\t/* Move up to the parent (may need to skip back over a shortcut) */\n\tparent = ACCESS_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\tif (parent == stop)\n\t\treturn 0;\n\n\tif (assoc_array_ptr_is_shortcut(parent)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(parent);\n\t\tsmp_read_barrier_depends();\n\t\tcursor = parent;\n\t\tparent = ACCESS_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t\tif (parent == stop)\n\t\t\treturn 0;\n\t}\n\n\t/* Ascend to next slot in parent node */\n\tcursor = parent;\n\tslot++;\n\tgoto continue_node;\n}\n\n/**\n * assoc_array_iterate - Pass all objects in the array to a callback\n * @array: The array to iterate over.\n * @iterator: The callback function.\n * @iterator_data: Private data for the callback function.\n *\n * Iterate over all the objects in an associative array.  Each one will be\n * presented to the iterator function.\n *\n * If the array is being modified concurrently with the iteration then it is\n * possible that some objects in the array will be passed to the iterator\n * callback more than once - though every object should be passed at least\n * once.  If this is undesirable then the caller must lock against modification\n * for the duration of this function.\n *\n * The function will return 0 if no objects were in the array or else it will\n * return the result of the last iterator function called.  Iteration stops\n * immediately if any call to the iteration function results in a non-zero\n * return.\n *\n * The caller should hold the RCU read lock or better if concurrent\n * modification is possible.\n */\nint assoc_array_iterate(const struct assoc_array *array,\n\t\t\tint (*iterator)(const void *object,\n\t\t\t\t\tvoid *iterator_data),\n\t\t\tvoid *iterator_data)\n{\n\tstruct assoc_array_ptr *root = ACCESS_ONCE(array->root);\n\n\tif (!root)\n\t\treturn 0;\n\treturn assoc_array_subtree_iterate(root, NULL, iterator, iterator_data);\n}\n\nenum assoc_array_walk_status {\n\tassoc_array_walk_tree_empty,\n\tassoc_array_walk_found_terminal_node,\n\tassoc_array_walk_found_wrong_shortcut,\n};\n\nstruct assoc_array_walk_result {\n\tstruct {\n\t\tstruct assoc_array_node\t*node;\t/* Node in which leaf might be found */\n\t\tint\t\tlevel;\n\t\tint\t\tslot;\n\t} terminal_node;\n\tstruct {\n\t\tstruct assoc_array_shortcut *shortcut;\n\t\tint\t\tlevel;\n\t\tint\t\tsc_level;\n\t\tunsigned long\tsc_segments;\n\t\tunsigned long\tdissimilarity;\n\t} wrong_shortcut;\n};\n\n/*\n * Navigate through the internal tree looking for the closest node to the key.\n */\nstatic enum assoc_array_walk_status\nassoc_array_walk(const struct assoc_array *array,\n\t\t const struct assoc_array_ops *ops,\n\t\t const void *index_key,\n\t\t struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *cursor, *ptr;\n\tunsigned long sc_segments, dissimilarity;\n\tunsigned long segments;\n\tint level, sc_level, next_sc_level;\n\tint slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tcursor = ACCESS_ONCE(array->root);\n\tif (!cursor)\n\t\treturn assoc_array_walk_tree_empty;\n\n\tlevel = 0;\n\n\t/* Use segments from the key for the new leaf to navigate through the\n\t * internal tree, skipping through nodes and shortcuts that are on\n\t * route to the destination.  Eventually we'll come to a slot that is\n\t * either empty or contains a leaf at which point we've found a node in\n\t * which the leaf we're looking for might be found or into which it\n\t * should be inserted.\n\t */\njumped:\n\tsegments = ops->get_key_chunk(index_key, level);\n\tpr_devel(\"segments[%d]: %lx\\n\", level, segments);\n\n\tif (assoc_array_ptr_is_shortcut(cursor))\n\t\tgoto follow_shortcut;\n\nconsider_node:\n\tnode = assoc_array_ptr_to_node(cursor);\n\tsmp_read_barrier_depends();\n\n\tslot = segments >> (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tslot &= ASSOC_ARRAY_FAN_MASK;\n\tptr = ACCESS_ONCE(node->slots[slot]);\n\n\tpr_devel(\"consider slot %x [ix=%d type=%lu]\\n\",\n\t\t slot, level, (unsigned long)ptr & 3);\n\n\tif (!assoc_array_ptr_is_meta(ptr)) {\n\t\t/* The node doesn't have a node/shortcut pointer in the slot\n\t\t * corresponding to the index key that we have to follow.\n\t\t */\n\t\tresult->terminal_node.node = node;\n\t\tresult->terminal_node.level = level;\n\t\tresult->terminal_node.slot = slot;\n\t\tpr_devel(\"<--%s() = terminal_node\\n\", __func__);\n\t\treturn assoc_array_walk_found_terminal_node;\n\t}\n\n\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t/* There is a pointer to a node in the slot corresponding to\n\t\t * this index key segment, so we need to follow it.\n\t\t */\n\t\tcursor = ptr;\n\t\tlevel += ASSOC_ARRAY_LEVEL_STEP;\n\t\tif ((level & ASSOC_ARRAY_KEY_CHUNK_MASK) != 0)\n\t\t\tgoto consider_node;\n\t\tgoto jumped;\n\t}\n\n\t/* There is a shortcut in the slot corresponding to the index key\n\t * segment.  We follow the shortcut if its partial index key matches\n\t * this leaf's.  Otherwise we need to split the shortcut.\n\t */\n\tcursor = ptr;\nfollow_shortcut:\n\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\tsmp_read_barrier_depends();\n\tpr_devel(\"shortcut to %d\\n\", shortcut->skip_to_level);\n\tsc_level = level + ASSOC_ARRAY_LEVEL_STEP;\n\tBUG_ON(sc_level > shortcut->skip_to_level);\n\n\tdo {\n\t\t/* Check the leaf against the shortcut's index key a word at a\n\t\t * time, trimming the final word (the shortcut stores the index\n\t\t * key completely from the root to the shortcut's target).\n\t\t */\n\t\tif ((sc_level & ASSOC_ARRAY_KEY_CHUNK_MASK) == 0)\n\t\t\tsegments = ops->get_key_chunk(index_key, sc_level);\n\n\t\tsc_segments = shortcut->index_key[sc_level >> ASSOC_ARRAY_KEY_CHUNK_SHIFT];\n\t\tdissimilarity = segments ^ sc_segments;\n\n\t\tif (round_up(sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE) > shortcut->skip_to_level) {\n\t\t\t/* Trim segments that are beyond the shortcut */\n\t\t\tint shift = shortcut->skip_to_level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\t\tdissimilarity &= ~(ULONG_MAX << shift);\n\t\t\tnext_sc_level = shortcut->skip_to_level;\n\t\t} else {\n\t\t\tnext_sc_level = sc_level + ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\t\t\tnext_sc_level = round_down(next_sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\t}\n\n\t\tif (dissimilarity != 0) {\n\t\t\t/* This shortcut points elsewhere */\n\t\t\tresult->wrong_shortcut.shortcut = shortcut;\n\t\t\tresult->wrong_shortcut.level = level;\n\t\t\tresult->wrong_shortcut.sc_level = sc_level;\n\t\t\tresult->wrong_shortcut.sc_segments = sc_segments;\n\t\t\tresult->wrong_shortcut.dissimilarity = dissimilarity;\n\t\t\treturn assoc_array_walk_found_wrong_shortcut;\n\t\t}\n\n\t\tsc_level = next_sc_level;\n\t} while (sc_level < shortcut->skip_to_level);\n\n\t/* The shortcut matches the leaf's index to this point. */\n\tcursor = ACCESS_ONCE(shortcut->next_node);\n\tif (((level ^ sc_level) & ~ASSOC_ARRAY_KEY_CHUNK_MASK) != 0) {\n\t\tlevel = sc_level;\n\t\tgoto jumped;\n\t} else {\n\t\tlevel = sc_level;\n\t\tgoto consider_node;\n\t}\n}\n\n/**\n * assoc_array_find - Find an object by index key\n * @array: The associative array to search.\n * @ops: The operations to use.\n * @index_key: The key to the object.\n *\n * Find an object in an associative array by walking through the internal tree\n * to the node that should contain the object and then searching the leaves\n * there.  NULL is returned if the requested object was not found in the array.\n *\n * The caller must hold the RCU read lock or better.\n */\nvoid *assoc_array_find(const struct assoc_array *array,\n\t\t       const struct assoc_array_ops *ops,\n\t\t       const void *index_key)\n{\n\tstruct assoc_array_walk_result result;\n\tconst struct assoc_array_node *node;\n\tconst struct assoc_array_ptr *ptr;\n\tconst void *leaf;\n\tint slot;\n\n\tif (assoc_array_walk(array, ops, index_key, &result) !=\n\t    assoc_array_walk_found_terminal_node)\n\t\treturn NULL;\n\n\tnode = result.terminal_node.node;\n\tsmp_read_barrier_depends();\n\n\t/* If the target key is available to us, it's has to be pointed to by\n\t * the terminal node.\n\t */\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\tif (ptr && assoc_array_ptr_is_leaf(ptr)) {\n\t\t\t/* We need a barrier between the read of the pointer\n\t\t\t * and dereferencing the pointer - but only if we are\n\t\t\t * actually going to dereference it.\n\t\t\t */\n\t\t\tleaf = assoc_array_ptr_to_leaf(ptr);\n\t\t\tsmp_read_barrier_depends();\n\t\t\tif (ops->compare_object(leaf, index_key))\n\t\t\t\treturn (void *)leaf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Destructively iterate over an associative array.  The caller must prevent\n * other simultaneous accesses.\n */\nstatic void assoc_array_destroy_subtree(struct assoc_array_ptr *root,\n\t\t\t\t\tconst struct assoc_array_ops *ops)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *cursor, *parent = NULL;\n\tint slot = -1;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tcursor = root;\n\tif (!cursor) {\n\t\tpr_devel(\"empty\\n\");\n\t\treturn;\n\t}\n\nmove_to_meta:\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\t/* Descend through a shortcut */\n\t\tpr_devel(\"[%d] shortcut\\n\", slot);\n\t\tBUG_ON(!assoc_array_ptr_is_shortcut(cursor));\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tBUG_ON(shortcut->back_pointer != parent);\n\t\tBUG_ON(slot != -1 && shortcut->parent_slot != slot);\n\t\tparent = cursor;\n\t\tcursor = shortcut->next_node;\n\t\tslot = -1;\n\t\tBUG_ON(!assoc_array_ptr_is_node(cursor));\n\t}\n\n\tpr_devel(\"[%d] node\\n\", slot);\n\tnode = assoc_array_ptr_to_node(cursor);\n\tBUG_ON(node->back_pointer != parent);\n\tBUG_ON(slot != -1 && node->parent_slot != slot);\n\tslot = 0;\n\ncontinue_node:\n\tpr_devel(\"Node %p [back=%p]\\n\", node, node->back_pointer);\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tstruct assoc_array_ptr *ptr = node->slots[slot];\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tparent = cursor;\n\t\t\tcursor = ptr;\n\t\t\tgoto move_to_meta;\n\t\t}\n\n\t\tif (ops) {\n\t\t\tpr_devel(\"[%d] free leaf\\n\", slot);\n\t\t\tops->free_object(assoc_array_ptr_to_leaf(ptr));\n\t\t}\n\t}\n\n\tparent = node->back_pointer;\n\tslot = node->parent_slot;\n\tpr_devel(\"free node\\n\");\n\tkfree(node);\n\tif (!parent)\n\t\treturn; /* Done */\n\n\t/* Move back up to the parent (may need to free a shortcut on\n\t * the way up) */\n\tif (assoc_array_ptr_is_shortcut(parent)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(parent);\n\t\tBUG_ON(shortcut->next_node != cursor);\n\t\tcursor = parent;\n\t\tparent = shortcut->back_pointer;\n\t\tslot = shortcut->parent_slot;\n\t\tpr_devel(\"free shortcut\\n\");\n\t\tkfree(shortcut);\n\t\tif (!parent)\n\t\t\treturn;\n\n\t\tBUG_ON(!assoc_array_ptr_is_node(parent));\n\t}\n\n\t/* Ascend to next slot in parent node */\n\tpr_devel(\"ascend to %p[%d]\\n\", parent, slot);\n\tcursor = parent;\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot++;\n\tgoto continue_node;\n}\n\n/**\n * assoc_array_destroy - Destroy an associative array\n * @array: The array to destroy.\n * @ops: The operations to use.\n *\n * Discard all metadata and free all objects in an associative array.  The\n * array will be empty and ready to use again upon completion.  This function\n * cannot fail.\n *\n * The caller must prevent all other accesses whilst this takes place as no\n * attempt is made to adjust pointers gracefully to permit RCU readlock-holding\n * accesses to continue.  On the other hand, no memory allocation is required.\n */\nvoid assoc_array_destroy(struct assoc_array *array,\n\t\t\t const struct assoc_array_ops *ops)\n{\n\tassoc_array_destroy_subtree(array->root, ops);\n\tarray->root = NULL;\n}\n\n/*\n * Handle insertion into an empty tree.\n */\nstatic bool assoc_array_insert_in_empty_tree(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_node *new_n0;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[0];\n\tedit->adjust_count_on = new_n0;\n\tedit->set[0].ptr = &edit->array->root;\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\n\tpr_devel(\"<--%s() = ok [no root]\\n\", __func__);\n\treturn true;\n}\n\n/*\n * Handle insertion into a terminal node.\n */\nstatic bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* We arrived at a node which doesn't have an onward node or shortcut\n\t * pointer that we have to follow.  This means that (a) the leaf we\n\t * want must go here (either by insertion or replacement) or (b) we\n\t * need to split this node and insert in one of the fragments.\n\t */\n\tfree_slot = -1;\n\n\t/* Firstly, we have to check the leaves in this node to see if there's\n\t * a matching one we should replace in place.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* If there is a free slot in this node then we can just insert the\n\t * leaf here.\n\t */\n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t/* The node has no spare slots - so we're either going to have to split\n\t * it or insert another node before it.\n\t *\n\t * Whatever, we're going to need at least two new nodes - so allocate\n\t * those now.  We may also need a new shortcut, but we deal with that\n\t * when we need it.\n\t */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t/* We need to find out how similar the leaves are. */\n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t/* The node contains only leaves */\n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t/* The old leaves all cluster in the same slot.  We will need\n\t\t * to insert a shortcut if the new node wants to cluster with them.\n\t\t */\n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t/* Otherwise all the old leaves cluster in the same slot, but\n\t\t * the new leaf wants to go into a different slot - so we\n\t\t * create a new node (n0) to hold the new leaf and a pointer to\n\t\t * a new node (n1) holding all the old leaves.\n\t\t *\n\t\t * This can be done by falling through to the node splitting\n\t\t * path.\n\t\t */\n\t\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t/* We need to split the current node.  The node must contain anything\n\t * from a single leaf (in the one leaf case, this leaf will cluster\n\t * with the new leaf) and the rest meta-pointers, to all leaves, some\n\t * of which may cluster.\n\t *\n\t * It won't contain the case in which all the current leaves plus the\n\t * new leaves want to cluster in the same slot.\n\t *\n\t * We need to expel at least two leaves out of a set consisting of the\n\t * leaves in the node and the new leaf.  The current meta pointers can\n\t * just be copied as they shouldn't cluster with any of the leaves.\n\t *\n\t * We need a new node (n0) to replace the current one and a new node to\n\t * take the expelled nodes (n1).\n\t */\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t/* Begin by finding two matching leaves.  There have to be at least two\n\t * that match - even if there are meta pointers - because any leaf that\n\t * would match a slot with a meta pointer in it must be somewhere\n\t * behind that meta pointer and cannot be here.  Further, given N\n\t * remaining leaf slots, we now have N+1 leaves to go in them.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t/* Metadata pointers cannot change slot */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t/* Filter the leaf pointers between the new nodes */\n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t/* All the leaves, new and old, want to cluster together in this node\n\t * in the same slot, so we have to replace this node with a shortcut to\n\t * skip over the identical parts of the key and then place a pair of\n\t * nodes, one inside the other, at the end of the shortcut and\n\t * distribute the keys between them.\n\t *\n\t * Firstly we need to work out where the leaves start diverging as a\n\t * bit position into their keys so that we know how big the shortcut\n\t * needs to be.\n\t *\n\t * We only need to make a single pass of N of the N+1 leaves because if\n\t * any keys differ between themselves at bit X then at least one of\n\t * them must also differ with the base key at bit X or before.\n\t */\n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1; /* Need to calculate this */\n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\tnew_s0->index_key[keylen - 1] &= ~blank;\n\n\t/* This now reduces to a node splitting exercise for which we'll need\n\t * to regenerate the disparity table.\n\t */\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}\n\n/*\n * Handle insertion into the middle of a shortcut.\n */\nstatic bool assoc_array_insert_mid_shortcut(struct assoc_array_edit *edit,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0, *new_s1;\n\tstruct assoc_array_node *node, *new_n0, *side;\n\tunsigned long sc_segments, dissimilarity, blank;\n\tsize_t keylen;\n\tint level, sc_level, diff;\n\tint sc_slot;\n\n\tshortcut\t= result->wrong_shortcut.shortcut;\n\tlevel\t\t= result->wrong_shortcut.level;\n\tsc_level\t= result->wrong_shortcut.sc_level;\n\tsc_segments\t= result->wrong_shortcut.sc_segments;\n\tdissimilarity\t= result->wrong_shortcut.dissimilarity;\n\n\tpr_devel(\"-->%s(ix=%d dis=%lx scix=%d)\\n\",\n\t\t __func__, level, dissimilarity, sc_level);\n\n\t/* We need to split a shortcut and insert a node between the two\n\t * pieces.  Zero-length pieces will be dispensed with entirely.\n\t *\n\t * First of all, we need to find out in which level the first\n\t * difference was.\n\t */\n\tdiff = __ffs(dissimilarity);\n\tdiff &= ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tdiff += sc_level & ~ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tpr_devel(\"diff=%d\\n\", diff);\n\n\tif (!shortcut->back_pointer) {\n\t\tedit->set[0].ptr = &edit->array->root;\n\t} else if (assoc_array_ptr_is_node(shortcut->back_pointer)) {\n\t\tnode = assoc_array_ptr_to_node(shortcut->back_pointer);\n\t\tedit->set[0].ptr = &node->slots[shortcut->parent_slot];\n\t} else {\n\t\tBUG();\n\t}\n\n\tedit->excised_meta[0] = assoc_array_shortcut_to_ptr(shortcut);\n\n\t/* Create a new node now since we're going to need it anyway */\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tedit->adjust_count_on = new_n0;\n\n\t/* Insert a new shortcut before the new node if this segment isn't of\n\t * zero length - otherwise we just connect the new node directly to the\n\t * parent.\n\t */\n\tlevel += ASSOC_ARRAY_LEVEL_STEP;\n\tif (diff > level) {\n\t\tpr_devel(\"pre-shortcut %d...%d\\n\", level, diff);\n\t\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\t\tnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\t\tif (!new_s0)\n\t\t\treturn false;\n\t\tedit->new_meta[1] = assoc_array_shortcut_to_ptr(new_s0);\n\t\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\t\tnew_s0->back_pointer = shortcut->back_pointer;\n\t\tnew_s0->parent_slot = shortcut->parent_slot;\n\t\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\t\tnew_s0->skip_to_level = diff;\n\n\t\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\t\tnew_n0->parent_slot = 0;\n\n\t\tmemcpy(new_s0->index_key, shortcut->index_key,\n\t\t       keylen * sizeof(unsigned long));\n\n\t\tblank = ULONG_MAX << (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\t\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, diff, blank);\n\t\tnew_s0->index_key[keylen - 1] &= ~blank;\n\t} else {\n\t\tpr_devel(\"no pre-shortcut\\n\");\n\t\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\t\tnew_n0->back_pointer = shortcut->back_pointer;\n\t\tnew_n0->parent_slot = shortcut->parent_slot;\n\t}\n\n\tside = assoc_array_ptr_to_node(shortcut->next_node);\n\tnew_n0->nr_leaves_on_branch = side->nr_leaves_on_branch;\n\n\t/* We need to know which slot in the new node is going to take a\n\t * metadata pointer.\n\t */\n\tsc_slot = sc_segments >> (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tsc_slot &= ASSOC_ARRAY_FAN_MASK;\n\n\tpr_devel(\"new slot %lx >> %d -> %d\\n\",\n\t\t sc_segments, diff & ASSOC_ARRAY_KEY_CHUNK_MASK, sc_slot);\n\n\t/* Determine whether we need to follow the new node with a replacement\n\t * for the current shortcut.  We could in theory reuse the current\n\t * shortcut if its parent slot number doesn't change - but that's a\n\t * 1-in-16 chance so not worth expending the code upon.\n\t */\n\tlevel = diff + ASSOC_ARRAY_LEVEL_STEP;\n\tif (level < shortcut->skip_to_level) {\n\t\tpr_devel(\"post-shortcut %d...%d\\n\", level, shortcut->skip_to_level);\n\t\tkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\t\tnew_s1 = kzalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t\t keylen * sizeof(unsigned long), GFP_KERNEL);\n\t\tif (!new_s1)\n\t\t\treturn false;\n\t\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s1);\n\n\t\tnew_s1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\t\tnew_s1->parent_slot = sc_slot;\n\t\tnew_s1->next_node = shortcut->next_node;\n\t\tnew_s1->skip_to_level = shortcut->skip_to_level;\n\n\t\tnew_n0->slots[sc_slot] = assoc_array_shortcut_to_ptr(new_s1);\n\n\t\tmemcpy(new_s1->index_key, shortcut->index_key,\n\t\t       keylen * sizeof(unsigned long));\n\n\t\tedit->set[1].ptr = &side->back_pointer;\n\t\tedit->set[1].to = assoc_array_shortcut_to_ptr(new_s1);\n\t} else {\n\t\tpr_devel(\"no post-shortcut\\n\");\n\n\t\t/* We don't have to replace the pointed-to node as long as we\n\t\t * use memory barriers to make sure the parent slot number is\n\t\t * changed before the back pointer (the parent slot number is\n\t\t * irrelevant to the old parent shortcut).\n\t\t */\n\t\tnew_n0->slots[sc_slot] = shortcut->next_node;\n\t\tedit->set_parent_slot[0].p = &side->parent_slot;\n\t\tedit->set_parent_slot[0].to = sc_slot;\n\t\tedit->set[1].ptr = &side->back_pointer;\n\t\tedit->set[1].to = assoc_array_node_to_ptr(new_n0);\n\t}\n\n\t/* Install the new leaf in a spare slot in the new node. */\n\tif (sc_slot == 0)\n\t\tedit->leaf_p = &new_n0->slots[1];\n\telse\n\t\tedit->leaf_p = &new_n0->slots[0];\n\n\tpr_devel(\"<--%s() = ok [split shortcut]\\n\", __func__);\n\treturn edit;\n}\n\n/**\n * assoc_array_insert - Script insertion of an object into an associative array\n * @array: The array to insert into.\n * @ops: The operations to use.\n * @index_key: The key to insert at.\n * @object: The object to insert.\n *\n * Precalculate and preallocate a script for the insertion or replacement of an\n * object in an associative array.  This results in an edit script that can\n * either be applied or cancelled.\n *\n * The function returns a pointer to an edit script or -ENOMEM.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nstruct assoc_array_edit *assoc_array_insert(struct assoc_array *array,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    const void *index_key,\n\t\t\t\t\t    void *object)\n{\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_edit *edit;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* The leaf pointer we're given must not have the bottom bit set as we\n\t * use those for type-marking the pointer.  NULL pointers are also not\n\t * allowed as they indicate an empty slot but we have to allow them\n\t * here as they can be updated later.\n\t */\n\tBUG_ON(assoc_array_ptr_is_meta(object));\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->leaf = assoc_array_leaf_to_ptr(object);\n\tedit->adjust_count_by = 1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_tree_empty:\n\t\t/* Allocate a root node if there isn't one yet */\n\t\tif (!assoc_array_insert_in_empty_tree(edit))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\n\tcase assoc_array_walk_found_terminal_node:\n\t\t/* We found a node that doesn't have a node/shortcut pointer in\n\t\t * the slot corresponding to the index key that we have to\n\t\t * follow.\n\t\t */\n\t\tif (!assoc_array_insert_into_terminal_node(edit, ops, index_key,\n\t\t\t\t\t\t\t   &result))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\n\tcase assoc_array_walk_found_wrong_shortcut:\n\t\t/* We found a shortcut that didn't match our key in a slot we\n\t\t * needed to follow.\n\t\t */\n\t\tif (!assoc_array_insert_mid_shortcut(edit, ops, &result))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\t}\n\nenomem:\n\t/* Clean up after an out of memory error */\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_cancel_edit(edit);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n/**\n * assoc_array_insert_set_object - Set the new object pointer in an edit script\n * @edit: The edit script to modify.\n * @object: The object pointer to set.\n *\n * Change the object to be inserted in an edit script.  The object pointed to\n * by the old object is not freed.  This must be done prior to applying the\n * script.\n */\nvoid assoc_array_insert_set_object(struct assoc_array_edit *edit, void *object)\n{\n\tBUG_ON(!object);\n\tedit->leaf = assoc_array_leaf_to_ptr(object);\n}\n\nstruct assoc_array_delete_collapse_context {\n\tstruct assoc_array_node\t*node;\n\tconst void\t\t*skip_leaf;\n\tint\t\t\tslot;\n};\n\n/*\n * Subtree collapse to node iterator.\n */\nstatic int assoc_array_delete_collapse_iterator(const void *leaf,\n\t\t\t\t\t\tvoid *iterator_data)\n{\n\tstruct assoc_array_delete_collapse_context *collapse = iterator_data;\n\n\tif (leaf == collapse->skip_leaf)\n\t\treturn 0;\n\n\tBUG_ON(collapse->slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tcollapse->node->slots[collapse->slot++] = assoc_array_leaf_to_ptr(leaf);\n\treturn 0;\n}\n\n/**\n * assoc_array_delete - Script deletion of an object from an associative array\n * @array: The array to search.\n * @ops: The operations to use.\n * @index_key: The key to the object.\n *\n * Precalculate and preallocate a script for the deletion of an object from an\n * associative array.  This results in an edit script that can either be\n * applied or cancelled.\n *\n * The function returns a pointer to an edit script if the object was found,\n * NULL if the object was not found or -ENOMEM.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nstruct assoc_array_edit *assoc_array_delete(struct assoc_array *array,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    const void *index_key)\n{\n\tstruct assoc_array_delete_collapse_context collapse;\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_node *node, *new_n0;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *ptr;\n\tbool has_meta;\n\tint slot, i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->adjust_count_by = -1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_found_terminal_node:\n\t\t/* We found a node that should contain the leaf we've been\n\t\t * asked to remove - *if* it's in the tree.\n\t\t */\n\t\tpr_devel(\"terminal_node\\n\");\n\t\tnode = result.terminal_node.node;\n\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\t\tptr = node->slots[slot];\n\t\t\tif (ptr &&\n\t\t\t    assoc_array_ptr_is_leaf(ptr) &&\n\t\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\tindex_key))\n\t\t\t\tgoto found_leaf;\n\t\t}\n\tcase assoc_array_walk_tree_empty:\n\tcase assoc_array_walk_found_wrong_shortcut:\n\tdefault:\n\t\tassoc_array_cancel_edit(edit);\n\t\tpr_devel(\"not found\\n\");\n\t\treturn NULL;\n\t}\n\nfound_leaf:\n\tBUG_ON(array->nr_leaves_on_tree <= 0);\n\n\t/* In the simplest form of deletion we just clear the slot and release\n\t * the leaf after a suitable interval.\n\t */\n\tedit->dead_leaf = node->slots[slot];\n\tedit->set[0].ptr = &node->slots[slot];\n\tedit->set[0].to = NULL;\n\tedit->adjust_count_on = node;\n\n\t/* If that concludes erasure of the last leaf, then delete the entire\n\t * internal array.\n\t */\n\tif (array->nr_leaves_on_tree == 1) {\n\t\tedit->set[1].ptr = &array->root;\n\t\tedit->set[1].to = NULL;\n\t\tedit->adjust_count_on = NULL;\n\t\tedit->excised_subtree = array->root;\n\t\tpr_devel(\"all gone\\n\");\n\t\treturn edit;\n\t}\n\n\t/* However, we'd also like to clear up some metadata blocks if we\n\t * possibly can.\n\t *\n\t * We go for a simple algorithm of: if this node has FAN_OUT or fewer\n\t * leaves in it, then attempt to collapse it - and attempt to\n\t * recursively collapse up the tree.\n\t *\n\t * We could also try and collapse in partially filled subtrees to take\n\t * up space in this node.\n\t */\n\tif (node->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n\t\tstruct assoc_array_node *parent, *grandparent;\n\t\tstruct assoc_array_ptr *ptr;\n\n\t\t/* First of all, we need to know if this node has metadata so\n\t\t * that we don't try collapsing if all the leaves are already\n\t\t * here.\n\t\t */\n\t\thas_meta = false;\n\t\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\t\tptr = node->slots[i];\n\t\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\t\thas_meta = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpr_devel(\"leaves: %ld [m=%d]\\n\",\n\t\t\t node->nr_leaves_on_branch - 1, has_meta);\n\n\t\t/* Look further up the tree to see if we can collapse this node\n\t\t * into a more proximal node too.\n\t\t */\n\t\tparent = node;\n\tcollapse_up:\n\t\tpr_devel(\"collapse subtree: %ld\\n\", parent->nr_leaves_on_branch);\n\n\t\tptr = parent->back_pointer;\n\t\tif (!ptr)\n\t\t\tgoto do_collapse;\n\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\tstruct assoc_array_shortcut *s = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tptr = s->back_pointer;\n\t\t\tif (!ptr)\n\t\t\t\tgoto do_collapse;\n\t\t}\n\n\t\tgrandparent = assoc_array_ptr_to_node(ptr);\n\t\tif (grandparent->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n\t\t\tparent = grandparent;\n\t\t\tgoto collapse_up;\n\t\t}\n\n\tdo_collapse:\n\t\t/* There's no point collapsing if the original node has no meta\n\t\t * pointers to discard and if we didn't merge into one of that\n\t\t * node's ancestry.\n\t\t */\n\t\tif (has_meta || parent != node) {\n\t\t\tnode = parent;\n\n\t\t\t/* Create a new node to collapse into */\n\t\t\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\t\t\tif (!new_n0)\n\t\t\t\tgoto enomem;\n\t\t\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\n\t\t\tnew_n0->back_pointer = node->back_pointer;\n\t\t\tnew_n0->parent_slot = node->parent_slot;\n\t\t\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\t\t\tedit->adjust_count_on = new_n0;\n\n\t\t\tcollapse.node = new_n0;\n\t\t\tcollapse.skip_leaf = assoc_array_ptr_to_leaf(edit->dead_leaf);\n\t\t\tcollapse.slot = 0;\n\t\t\tassoc_array_subtree_iterate(assoc_array_node_to_ptr(node),\n\t\t\t\t\t\t    node->back_pointer,\n\t\t\t\t\t\t    assoc_array_delete_collapse_iterator,\n\t\t\t\t\t\t    &collapse);\n\t\t\tpr_devel(\"collapsed %d,%lu\\n\", collapse.slot, new_n0->nr_leaves_on_branch);\n\t\t\tBUG_ON(collapse.slot != new_n0->nr_leaves_on_branch - 1);\n\n\t\t\tif (!node->back_pointer) {\n\t\t\t\tedit->set[1].ptr = &array->root;\n\t\t\t} else if (assoc_array_ptr_is_leaf(node->back_pointer)) {\n\t\t\t\tBUG();\n\t\t\t} else if (assoc_array_ptr_is_node(node->back_pointer)) {\n\t\t\t\tstruct assoc_array_node *p =\n\t\t\t\t\tassoc_array_ptr_to_node(node->back_pointer);\n\t\t\t\tedit->set[1].ptr = &p->slots[node->parent_slot];\n\t\t\t} else if (assoc_array_ptr_is_shortcut(node->back_pointer)) {\n\t\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\t\tassoc_array_ptr_to_shortcut(node->back_pointer);\n\t\t\t\tedit->set[1].ptr = &s->next_node;\n\t\t\t}\n\t\t\tedit->set[1].to = assoc_array_node_to_ptr(new_n0);\n\t\t\tedit->excised_subtree = assoc_array_node_to_ptr(node);\n\t\t}\n\t}\n\n\treturn edit;\n\nenomem:\n\t/* Clean up after an out of memory error */\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_cancel_edit(edit);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n/**\n * assoc_array_clear - Script deletion of all objects from an associative array\n * @array: The array to clear.\n * @ops: The operations to use.\n *\n * Precalculate and preallocate a script for the deletion of all the objects\n * from an associative array.  This results in an edit script that can either\n * be applied or cancelled.\n *\n * The function returns a pointer to an edit script if there are objects to be\n * deleted, NULL if there are no objects in the array or -ENOMEM.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nstruct assoc_array_edit *assoc_array_clear(struct assoc_array *array,\n\t\t\t\t\t   const struct assoc_array_ops *ops)\n{\n\tstruct assoc_array_edit *edit;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (!array->root)\n\t\treturn NULL;\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->set[1].ptr = &array->root;\n\tedit->set[1].to = NULL;\n\tedit->excised_subtree = array->root;\n\tedit->ops_for_excised_subtree = ops;\n\tpr_devel(\"all gone\\n\");\n\treturn edit;\n}\n\n/*\n * Handle the deferred destruction after an applied edit.\n */\nstatic void assoc_array_rcu_cleanup(struct rcu_head *head)\n{\n\tstruct assoc_array_edit *edit =\n\t\tcontainer_of(head, struct assoc_array_edit, rcu);\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (edit->dead_leaf)\n\t\tedit->ops->free_object(assoc_array_ptr_to_leaf(edit->dead_leaf));\n\tfor (i = 0; i < ARRAY_SIZE(edit->excised_meta); i++)\n\t\tif (edit->excised_meta[i])\n\t\t\tkfree(assoc_array_ptr_to_node(edit->excised_meta[i]));\n\n\tif (edit->excised_subtree) {\n\t\tBUG_ON(assoc_array_ptr_is_leaf(edit->excised_subtree));\n\t\tif (assoc_array_ptr_is_node(edit->excised_subtree)) {\n\t\t\tstruct assoc_array_node *n =\n\t\t\t\tassoc_array_ptr_to_node(edit->excised_subtree);\n\t\t\tn->back_pointer = NULL;\n\t\t} else {\n\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\tassoc_array_ptr_to_shortcut(edit->excised_subtree);\n\t\t\ts->back_pointer = NULL;\n\t\t}\n\t\tassoc_array_destroy_subtree(edit->excised_subtree,\n\t\t\t\t\t    edit->ops_for_excised_subtree);\n\t}\n\n\tkfree(edit);\n}\n\n/**\n * assoc_array_apply_edit - Apply an edit script to an associative array\n * @edit: The script to apply.\n *\n * Apply an edit script to an associative array to effect an insertion,\n * deletion or clearance.  As the edit script includes preallocated memory,\n * this is guaranteed not to fail.\n *\n * The edit script, dead objects and dead metadata will be scheduled for\n * destruction after an RCU grace period to permit those doing read-only\n * accesses on the array to continue to do so under the RCU read lock whilst\n * the edit is taking place.\n */\nvoid assoc_array_apply_edit(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tsmp_wmb();\n\tif (edit->leaf_p)\n\t\t*edit->leaf_p = edit->leaf;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set_parent_slot); i++)\n\t\tif (edit->set_parent_slot[i].p)\n\t\t\t*edit->set_parent_slot[i].p = edit->set_parent_slot[i].to;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set_backpointers); i++)\n\t\tif (edit->set_backpointers[i])\n\t\t\t*edit->set_backpointers[i] = edit->set_backpointers_to;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set); i++)\n\t\tif (edit->set[i].ptr)\n\t\t\t*edit->set[i].ptr = edit->set[i].to;\n\n\tif (edit->array->root == NULL) {\n\t\tedit->array->nr_leaves_on_tree = 0;\n\t} else if (edit->adjust_count_on) {\n\t\tnode = edit->adjust_count_on;\n\t\tfor (;;) {\n\t\t\tnode->nr_leaves_on_branch += edit->adjust_count_by;\n\n\t\t\tptr = node->back_pointer;\n\t\t\tif (!ptr)\n\t\t\t\tbreak;\n\t\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tptr = shortcut->back_pointer;\n\t\t\t\tif (!ptr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\t}\n\n\t\tedit->array->nr_leaves_on_tree += edit->adjust_count_by;\n\t}\n\n\tcall_rcu(&edit->rcu, assoc_array_rcu_cleanup);\n}\n\n/**\n * assoc_array_cancel_edit - Discard an edit script.\n * @edit: The script to discard.\n *\n * Free an edit script and all the preallocated data it holds without making\n * any changes to the associative array it was intended for.\n *\n * NOTE!  In the case of an insertion script, this does _not_ release the leaf\n * that was to be inserted.  That is left to the caller.\n */\nvoid assoc_array_cancel_edit(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_ptr *ptr;\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t/* Clean up after an out of memory error */\n\tfor (i = 0; i < ARRAY_SIZE(edit->new_meta); i++) {\n\t\tptr = edit->new_meta[i];\n\t\tif (ptr) {\n\t\t\tif (assoc_array_ptr_is_node(ptr))\n\t\t\t\tkfree(assoc_array_ptr_to_node(ptr));\n\t\t\telse\n\t\t\t\tkfree(assoc_array_ptr_to_shortcut(ptr));\n\t\t}\n\t}\n\tkfree(edit);\n}\n\n/**\n * assoc_array_gc - Garbage collect an associative array.\n * @array: The array to clean.\n * @ops: The operations to use.\n * @iterator: A callback function to pass judgement on each object.\n * @iterator_data: Private data for the callback function.\n *\n * Collect garbage from an associative array and pack down the internal tree to\n * save memory.\n *\n * The iterator function is asked to pass judgement upon each object in the\n * array.  If it returns false, the object is discard and if it returns true,\n * the object is kept.  If it returns true, it must increment the object's\n * usage count (or whatever it needs to do to retain it) before returning.\n *\n * This function returns 0 if successful or -ENOMEM if out of memory.  In the\n * latter case, the array is not changed.\n *\n * The caller should lock against other modifications and must continue to hold\n * the lock until assoc_array_apply_edit() has been called.\n *\n * Accesses to the tree may take place concurrently with this function,\n * provided they hold the RCU read lock.\n */\nint assoc_array_gc(struct assoc_array *array,\n\t\t   const struct assoc_array_ops *ops,\n\t\t   bool (*iterator)(void *object, void *iterator_data),\n\t\t   void *iterator_data)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s;\n\tstruct assoc_array_node *node, *new_n;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *cursor, *ptr;\n\tstruct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;\n\tunsigned long nr_leaves_on_tree;\n\tint keylen, slot, nr_free, next_slot, i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (!array->root)\n\t\treturn 0;\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn -ENOMEM;\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->ops_for_excised_subtree = ops;\n\tedit->set[0].ptr = &array->root;\n\tedit->excised_subtree = array->root;\n\n\tnew_root = new_parent = NULL;\n\tnew_ptr_pp = &new_root;\n\tcursor = array->root;\n\ndescend:\n\t/* If this point is a shortcut, then we need to duplicate it and\n\t * advance the target cursor.\n\t */\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\t\tnew_s = kmalloc(sizeof(struct assoc_array_shortcut) +\n\t\t\t\tkeylen * sizeof(unsigned long), GFP_KERNEL);\n\t\tif (!new_s)\n\t\t\tgoto enomem;\n\t\tpr_devel(\"dup shortcut %p -> %p\\n\", shortcut, new_s);\n\t\tmemcpy(new_s, shortcut, (sizeof(struct assoc_array_shortcut) +\n\t\t\t\t\t keylen * sizeof(unsigned long)));\n\t\tnew_s->back_pointer = new_parent;\n\t\tnew_s->parent_slot = shortcut->parent_slot;\n\t\t*new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr(new_s);\n\t\tnew_ptr_pp = &new_s->next_node;\n\t\tcursor = shortcut->next_node;\n\t}\n\n\t/* Duplicate the node at this position */\n\tnode = assoc_array_ptr_to_node(cursor);\n\tnew_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n)\n\t\tgoto enomem;\n\tpr_devel(\"dup node %p -> %p\\n\", node, new_n);\n\tnew_n->back_pointer = new_parent;\n\tnew_n->parent_slot = node->parent_slot;\n\t*new_ptr_pp = new_parent = assoc_array_node_to_ptr(new_n);\n\tnew_ptr_pp = NULL;\n\tslot = 0;\n\ncontinue_node:\n\t/* Filter across any leaves and gc any subtrees */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = node->slots[slot];\n\t\tif (!ptr)\n\t\t\tcontinue;\n\n\t\tif (assoc_array_ptr_is_leaf(ptr)) {\n\t\t\tif (iterator(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t     iterator_data))\n\t\t\t\t/* The iterator will have done any reference\n\t\t\t\t * counting on the object for us.\n\t\t\t\t */\n\t\t\t\tnew_n->slots[slot] = ptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_ptr_pp = &new_n->slots[slot];\n\t\tcursor = ptr;\n\t\tgoto descend;\n\t}\n\n\tpr_devel(\"-- compress node %p --\\n\", new_n);\n\n\t/* Count up the number of empty slots in this node and work out the\n\t * subtree leaf count.\n\t */\n\tnew_n->nr_leaves_on_branch = 0;\n\tnr_free = 0;\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = new_n->slots[slot];\n\t\tif (!ptr)\n\t\t\tnr_free++;\n\t\telse if (assoc_array_ptr_is_leaf(ptr))\n\t\t\tnew_n->nr_leaves_on_branch++;\n\t}\n\tpr_devel(\"free=%d, leaves=%lu\\n\", nr_free, new_n->nr_leaves_on_branch);\n\n\t/* See what we can fold in */\n\tnext_slot = 0;\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tstruct assoc_array_shortcut *s;\n\t\tstruct assoc_array_node *child;\n\n\t\tptr = new_n->slots[slot];\n\t\tif (!ptr || assoc_array_ptr_is_leaf(ptr))\n\t\t\tcontinue;\n\n\t\ts = NULL;\n\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\ts = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tptr = s->next_node;\n\t\t}\n\n\t\tchild = assoc_array_ptr_to_node(ptr);\n\t\tnew_n->nr_leaves_on_branch += child->nr_leaves_on_branch;\n\n\t\tif (child->nr_leaves_on_branch <= nr_free + 1) {\n\t\t\t/* Fold the child node into this one */\n\t\t\tpr_devel(\"[%d] fold node %lu/%d [nx %d]\\n\",\n\t\t\t\t slot, child->nr_leaves_on_branch, nr_free + 1,\n\t\t\t\t next_slot);\n\n\t\t\t/* We would already have reaped an intervening shortcut\n\t\t\t * on the way back up the tree.\n\t\t\t */\n\t\t\tBUG_ON(s);\n\n\t\t\tnew_n->slots[slot] = NULL;\n\t\t\tnr_free++;\n\t\t\tif (slot < next_slot)\n\t\t\t\tnext_slot = slot;\n\t\t\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\t\t\tstruct assoc_array_ptr *p = child->slots[i];\n\t\t\t\tif (!p)\n\t\t\t\t\tcontinue;\n\t\t\t\tBUG_ON(assoc_array_ptr_is_meta(p));\n\t\t\t\twhile (new_n->slots[next_slot])\n\t\t\t\t\tnext_slot++;\n\t\t\t\tBUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);\n\t\t\t\tnew_n->slots[next_slot++] = p;\n\t\t\t\tnr_free--;\n\t\t\t}\n\t\t\tkfree(child);\n\t\t} else {\n\t\t\tpr_devel(\"[%d] retain node %lu/%d [nx %d]\\n\",\n\t\t\t\t slot, child->nr_leaves_on_branch, nr_free + 1,\n\t\t\t\t next_slot);\n\t\t}\n\t}\n\n\tpr_devel(\"after: %lu\\n\", new_n->nr_leaves_on_branch);\n\n\tnr_leaves_on_tree = new_n->nr_leaves_on_branch;\n\n\t/* Excise this node if it is singly occupied by a shortcut */\n\tif (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)\n\t\t\tif ((ptr = new_n->slots[slot]))\n\t\t\t\tbreak;\n\n\t\tif (assoc_array_ptr_is_meta(ptr) &&\n\t\t    assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\tpr_devel(\"excise node %p with 1 shortcut\\n\", new_n);\n\t\t\tnew_s = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tnew_parent = new_n->back_pointer;\n\t\t\tslot = new_n->parent_slot;\n\t\t\tkfree(new_n);\n\t\t\tif (!new_parent) {\n\t\t\t\tnew_s->back_pointer = NULL;\n\t\t\t\tnew_s->parent_slot = 0;\n\t\t\t\tnew_root = ptr;\n\t\t\t\tgoto gc_complete;\n\t\t\t}\n\n\t\t\tif (assoc_array_ptr_is_shortcut(new_parent)) {\n\t\t\t\t/* We can discard any preceding shortcut also */\n\t\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\t\tassoc_array_ptr_to_shortcut(new_parent);\n\n\t\t\t\tpr_devel(\"excise preceding shortcut\\n\");\n\n\t\t\t\tnew_parent = new_s->back_pointer = s->back_pointer;\n\t\t\t\tslot = new_s->parent_slot = s->parent_slot;\n\t\t\t\tkfree(s);\n\t\t\t\tif (!new_parent) {\n\t\t\t\t\tnew_s->back_pointer = NULL;\n\t\t\t\t\tnew_s->parent_slot = 0;\n\t\t\t\t\tnew_root = ptr;\n\t\t\t\t\tgoto gc_complete;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_s->back_pointer = new_parent;\n\t\t\tnew_s->parent_slot = slot;\n\t\t\tnew_n = assoc_array_ptr_to_node(new_parent);\n\t\t\tnew_n->slots[slot] = ptr;\n\t\t\tgoto ascend_old_tree;\n\t\t}\n\t}\n\n\t/* Excise any shortcuts we might encounter that point to nodes that\n\t * only contain leaves.\n\t */\n\tptr = new_n->back_pointer;\n\tif (!ptr)\n\t\tgoto gc_complete;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tnew_s = assoc_array_ptr_to_shortcut(ptr);\n\t\tnew_parent = new_s->back_pointer;\n\t\tslot = new_s->parent_slot;\n\n\t\tif (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\n\t\t\tstruct assoc_array_node *n;\n\n\t\t\tpr_devel(\"excise shortcut\\n\");\n\t\t\tnew_n->back_pointer = new_parent;\n\t\t\tnew_n->parent_slot = slot;\n\t\t\tkfree(new_s);\n\t\t\tif (!new_parent) {\n\t\t\t\tnew_root = assoc_array_node_to_ptr(new_n);\n\t\t\t\tgoto gc_complete;\n\t\t\t}\n\n\t\t\tn = assoc_array_ptr_to_node(new_parent);\n\t\t\tn->slots[slot] = assoc_array_node_to_ptr(new_n);\n\t\t}\n\t} else {\n\t\tnew_parent = ptr;\n\t}\n\tnew_n = assoc_array_ptr_to_node(new_parent);\n\nascend_old_tree:\n\tptr = node->back_pointer;\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tslot = shortcut->parent_slot;\n\t\tcursor = shortcut->back_pointer;\n\t\tif (!cursor)\n\t\t\tgoto gc_complete;\n\t} else {\n\t\tslot = node->parent_slot;\n\t\tcursor = ptr;\n\t}\n\tBUG_ON(!cursor);\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot++;\n\tgoto continue_node;\n\ngc_complete:\n\tedit->set[0].to = new_root;\n\tassoc_array_apply_edit(edit);\n\tarray->nr_leaves_on_tree = nr_leaves_on_tree;\n\treturn 0;\n\nenomem:\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_destroy_subtree(new_root, edit->ops);\n\tkfree(edit);\n\treturn -ENOMEM;\n}\n"], "filenames": ["lib/assoc_array.c"], "buggy_code_start_loc": [601], "buggy_code_end_loc": [745], "fixing_code_start_loc": [601], "fixing_code_end_loc": [727], "type": "CWE-476", "message": "The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.13.11 mishandles node splitting, which allows local users to cause a denial of service (NULL pointer dereference and panic) via a crafted application, as demonstrated by the keyring key type, and key addition and link creation operations.", "other": {"cve": {"id": "CVE-2017-12193", "sourceIdentifier": "secalert@redhat.com", "published": "2017-11-22T18:29:00.553", "lastModified": "2023-02-12T23:28:05.030", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.13.11 mishandles node splitting, which allows local users to cause a denial of service (NULL pointer dereference and panic) via a crafted application, as demonstrated by the keyring key type, and key addition and link creation operations."}, {"lang": "es", "value": "La funci\u00f3n assoc_array_insert_into_terminal_node en lib/assoc_array.c en el kernel de Linux en versiones anteriores a la 4.13.11 gestiona de manera incorrecta la divisi\u00f3n de nodos, lo que permite que usuarios locales provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL y p\u00e1nico) mediante una aplicaci\u00f3n manipulada, tal y como demuestra el tipo de clave de conjunto de claves, as\u00ed como las operaciones de suma de claves y creaci\u00f3n de enlaces."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.13.11", "matchCriteriaId": "DAB98E23-155F-4466-8A60-D988039C3147"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ea6789980fdaa610d7eb63602c746bf6ec70cd2b", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.11", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "http://www.securityfocus.com/bid/101678", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0151", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1501215", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/ea6789980fdaa610d7eb63602c746bf6ec70cd2b", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/3698-1/", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3698-2/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ea6789980fdaa610d7eb63602c746bf6ec70cd2b"}}