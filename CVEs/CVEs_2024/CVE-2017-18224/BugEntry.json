{"buggy_code": ["/* -*- mode: c; c-basic-offset: 8; -*-\n * vim: noexpandtab sw=8 ts=8 sts=0:\n *\n * Copyright (C) 2002, 2004 Oracle.  All rights reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <asm/byteorder.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mpage.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"aops.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"symlink.h\"\n#include \"refcounttree.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"namei.h\"\n#include \"sysfile.h\"\n\nstatic int ocfs2_symlink_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t   struct buffer_head *bh_result, int create)\n{\n\tint err = -EIO;\n\tint status;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *buffer_cache_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tvoid *kaddr;\n\n\ttrace_ocfs2_symlink_get_block(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)iblock, bh_result, create);\n\n\tBUG_ON(ocfs2_inode_is_fast_symlink(inode));\n\n\tif ((iblock << inode->i_sb->s_blocksize_bits) > PATH_MAX + 1) {\n\t\tmlog(ML_ERROR, \"block offset > PATH_MAX: %llu\",\n\t\t     (unsigned long long)iblock);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tif ((u64)iblock >= ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(fe->i_clusters))) {\n\t\terr = -ENOMEM;\n\t\tmlog(ML_ERROR, \"block offset is outside the allocated size: \"\n\t\t     \"%llu\\n\", (unsigned long long)iblock);\n\t\tgoto bail;\n\t}\n\n\t/* We don't use the page cache to create symlink data, so if\n\t * need be, copy it over from the buffer cache. */\n\tif (!buffer_uptodate(bh_result) && ocfs2_inode_is_new(inode)) {\n\t\tu64 blkno = le64_to_cpu(fe->id2.i_list.l_recs[0].e_blkno) +\n\t\t\t    iblock;\n\t\tbuffer_cache_bh = sb_getblk(osb->sb, blkno);\n\t\tif (!buffer_cache_bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tmlog(ML_ERROR, \"couldn't getblock for symlink!\\n\");\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* we haven't locked out transactions, so a commit\n\t\t * could've happened. Since we've got a reference on\n\t\t * the bh, even if it commits while we're doing the\n\t\t * copy, the data is still good. */\n\t\tif (buffer_jbd(buffer_cache_bh)\n\t\t    && ocfs2_inode_is_new(inode)) {\n\t\t\tkaddr = kmap_atomic(bh_result->b_page);\n\t\t\tif (!kaddr) {\n\t\t\t\tmlog(ML_ERROR, \"couldn't kmap!\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(kaddr + (bh_result->b_size * iblock),\n\t\t\t       buffer_cache_bh->b_data,\n\t\t\t       bh_result->b_size);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t}\n\t\tbrelse(buffer_cache_bh);\n\t}\n\n\tmap_bh(bh_result, inode->i_sb,\n\t       le64_to_cpu(fe->id2.i_list.l_recs[0].e_blkno) + iblock);\n\n\terr = 0;\n\nbail:\n\tbrelse(bh);\n\n\treturn err;\n}\n\nint ocfs2_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint err = 0;\n\tunsigned int ext_flags;\n\tu64 max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tu64 p_blkno, count, past_eof;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_get_block((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t      (unsigned long long)iblock, bh_result, create);\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE)\n\t\tmlog(ML_NOTICE, \"get_block on system inode 0x%p (%lu)\\n\",\n\t\t     inode, inode->i_ino);\n\n\tif (S_ISLNK(inode->i_mode)) {\n\t\t/* this always does I/O for some reason. */\n\t\terr = ocfs2_symlink_get_block(inode, iblock, bh_result, create);\n\t\tgoto bail;\n\t}\n\n\terr = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno, &count,\n\t\t\t\t\t  &ext_flags);\n\tif (err) {\n\t\tmlog(ML_ERROR, \"Error %d from get_blocks(0x%p, %llu, 1, \"\n\t\t     \"%llu, NULL)\\n\", err, inode, (unsigned long long)iblock,\n\t\t     (unsigned long long)p_blkno);\n\t\tgoto bail;\n\t}\n\n\tif (max_blocks < count)\n\t\tcount = max_blocks;\n\n\t/*\n\t * ocfs2 never allocates in this function - the only time we\n\t * need to use BH_New is when we're extending i_size on a file\n\t * system which doesn't support holes, in which case BH_New\n\t * allows __block_write_begin() to zero.\n\t *\n\t * If we see this on a sparse file system, then a truncate has\n\t * raced us and removed the cluster. In this case, we clear\n\t * the buffers dirty and uptodate bits and let the buffer code\n\t * ignore it as a hole.\n\t */\n\tif (create && p_blkno == 0 && ocfs2_sparse_alloc(osb)) {\n\t\tclear_buffer_dirty(bh_result);\n\t\tclear_buffer_uptodate(bh_result);\n\t\tgoto bail;\n\t}\n\n\t/* Treat the unwritten extent as a hole for zeroing purposes. */\n\tif (p_blkno && !(ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\n\tbh_result->b_size = count << inode->i_blkbits;\n\n\tif (!ocfs2_sparse_alloc(osb)) {\n\t\tif (p_blkno == 0) {\n\t\t\terr = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"iblock = %llu p_blkno = %llu blkno=(%llu)\\n\",\n\t\t\t     (unsigned long long)iblock,\n\t\t\t     (unsigned long long)p_blkno,\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t\tmlog(ML_ERROR, \"Size %llu, clusters %u\\n\", (unsigned long long)i_size_read(inode), OCFS2_I(inode)->ip_clusters);\n\t\t\tdump_stack();\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tpast_eof = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\n\ttrace_ocfs2_get_block_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)past_eof);\n\tif (create && (iblock >= past_eof))\n\t\tset_buffer_new(bh_result);\n\nbail:\n\tif (err < 0)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nint ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}\n\nstatic int ocfs2_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_inline_data(inode, page, di_bh);\nout:\n\tunlock_page(page);\n\n\tbrelse(di_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tloff_t start = (loff_t)page->index << PAGE_SHIFT;\n\tint ret, unlock = 1;\n\n\ttrace_ocfs2_readpage((unsigned long long)oi->ip_blkno,\n\t\t\t     (page ? page->index : 0));\n\n\tret = ocfs2_inode_lock_with_page(inode, NULL, 0, page);\n\tif (ret != 0) {\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tunlock = 0;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (down_read_trylock(&oi->ip_alloc_sem) == 0) {\n\t\t/*\n\t\t * Unlock the page and cycle ip_alloc_sem so that we don't\n\t\t * busyloop waiting for ip_alloc_sem to unlock\n\t\t */\n\t\tret = AOP_TRUNCATED_PAGE;\n\t\tunlock_page(page);\n\t\tunlock = 0;\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * i_size might have just been updated as we grabed the meta lock.  We\n\t * might now be discovering a truncate that hit on another node.\n\t * block_read_full_page->get_block freaks out if it is asked to read\n\t * beyond the end of a file, so we check here.  Callers\n\t * (generic_file_read, vm_ops->fault) are clever enough to check i_size\n\t * and notice that the page they just read isn't needed.\n\t *\n\t * XXX sys_readahead() seems to get that wrong?\n\t */\n\tif (start >= i_size_read(inode)) {\n\t\tzero_user(page, 0, PAGE_SIZE);\n\t\tSetPageUptodate(page);\n\t\tret = 0;\n\t\tgoto out_alloc;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tret = ocfs2_readpage_inline(inode, page);\n\telse\n\t\tret = block_read_full_page(page, ocfs2_get_block);\n\tunlock = 0;\n\nout_alloc:\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\nout_inode_unlock:\n\tocfs2_inode_unlock(inode, 0);\nout:\n\tif (unlock)\n\t\tunlock_page(page);\n\treturn ret;\n}\n\n/*\n * This is used only for read-ahead. Failures or difficult to handle\n * situations are safe to ignore.\n *\n * Right now, we don't bother with BH_Boundary - in-inode extent lists\n * are quite large (243 extents on 4k blocks), so most inodes don't\n * grow out to a tree. If need be, detecting boundary extents could\n * trivially be added in a future version of ocfs2_get_block().\n */\nstatic int ocfs2_readpages(struct file *filp, struct address_space *mapping,\n\t\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\tint ret, err = -EIO;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tloff_t start;\n\tstruct page *last;\n\n\t/*\n\t * Use the nonblocking flag for the dlm code to avoid page\n\t * lock inversion, but don't bother with retrying.\n\t */\n\tret = ocfs2_inode_lock_full(inode, NULL, 0, OCFS2_LOCK_NONBLOCK);\n\tif (ret)\n\t\treturn err;\n\n\tif (down_read_trylock(&oi->ip_alloc_sem) == 0) {\n\t\tocfs2_inode_unlock(inode, 0);\n\t\treturn err;\n\t}\n\n\t/*\n\t * Don't bother with inline-data. There isn't anything\n\t * to read-ahead in that case anyway...\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check whether a remote node truncated this file - we just\n\t * drop out in that case as it's not worth handling here.\n\t */\n\tlast = list_entry(pages->prev, struct page, lru);\n\tstart = (loff_t)last->index << PAGE_SHIFT;\n\tif (start >= i_size_read(inode))\n\t\tgoto out_unlock;\n\n\terr = mpage_readpages(mapping, pages, nr_pages, ocfs2_get_block);\n\nout_unlock:\n\tup_read(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 0);\n\n\treturn err;\n}\n\n/* Note: Because we don't support holes, our allocation has\n * already happened (allocation writes zeros to the file data)\n * so we don't have to worry about ordered writes in\n * ocfs2_writepage.\n *\n * ->writepage is called during the process of invalidating the page cache\n * during blocked lock processing.  It can't block on any cluster locks\n * to during block mapping.  It's relying on the fact that the block\n * mapping can't have disappeared under the dirty pages that it is\n * being asked to write back.\n */\nstatic int ocfs2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\ttrace_ocfs2_writepage(\n\t\t(unsigned long long)OCFS2_I(page->mapping->host)->ip_blkno,\n\t\tpage->index);\n\n\treturn block_write_full_page(page, ocfs2_get_block, wbc);\n}\n\n/* Taken from ext3. We don't necessarily need the full blown\n * functionality yet, but IMHO it's better to cut and paste the whole\n * thing so we can avoid introducing our own bugs (and easily pick up\n * their fixes when they happen) --Mark */\nint walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n\nstatic sector_t ocfs2_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t status;\n\tu64 p_blkno = 0;\n\tint err = 0;\n\tstruct inode *inode = mapping->host;\n\n\ttrace_ocfs2_bmap((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t (unsigned long long)block);\n\n\t/*\n\t * The swap code (ab-)uses ->bmap to get a block mapping and then\n\t * bypasse\u0455 the file system for actual I/O.  We really can't allow\n\t * that on refcounted inodes, so we have to skip out here.  And yes,\n\t * 0 is the magic code for a bmap error..\n\t */\n\tif (ocfs2_is_refcount_inode(inode))\n\t\treturn 0;\n\n\t/* We don't need to lock journal system files, since they aren't\n\t * accessed concurrently from multiple nodes.\n\t */\n\tif (!INODE_JOURNAL(inode)) {\n\t\terr = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tmlog_errno(err);\n\t\t\tgoto bail;\n\t\t}\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))\n\t\terr = ocfs2_extent_map_get_blocks(inode, block, &p_blkno, NULL,\n\t\t\t\t\t\t  NULL);\n\n\tif (!INODE_JOURNAL(inode)) {\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tocfs2_inode_unlock(inode, 0);\n\t}\n\n\tif (err) {\n\t\tmlog(ML_ERROR, \"get_blocks() failed, block = %llu\\n\",\n\t\t     (unsigned long long)block);\n\t\tmlog_errno(err);\n\t\tgoto bail;\n\t}\n\nbail:\n\tstatus = err ? 0 : p_blkno;\n\n\treturn status;\n}\n\nstatic int ocfs2_releasepage(struct page *page, gfp_t wait)\n{\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\treturn try_to_free_buffers(page);\n}\n\nstatic void ocfs2_figure_cluster_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\t    u32 cpos,\n\t\t\t\t\t    unsigned int *start,\n\t\t\t\t\t    unsigned int *end)\n{\n\tunsigned int cluster_start = 0, cluster_end = PAGE_SIZE;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits)) {\n\t\tunsigned int cpp;\n\n\t\tcpp = 1 << (PAGE_SHIFT - osb->s_clustersize_bits);\n\n\t\tcluster_start = cpos % cpp;\n\t\tcluster_start = cluster_start << osb->s_clustersize_bits;\n\n\t\tcluster_end = cluster_start + osb->s_clustersize;\n\t}\n\n\tBUG_ON(cluster_start > PAGE_SIZE);\n\tBUG_ON(cluster_end > PAGE_SIZE);\n\n\tif (start)\n\t\t*start = cluster_start;\n\tif (end)\n\t\t*end = cluster_end;\n}\n\n/*\n * 'from' and 'to' are the region in the page to avoid zeroing.\n *\n * If pagesize > clustersize, this function will avoid zeroing outside\n * of the cluster boundary.\n *\n * from == to == 0 is code for \"zero the entire cluster region\"\n */\nstatic void ocfs2_clear_page_regions(struct page *page,\n\t\t\t\t     struct ocfs2_super *osb, u32 cpos,\n\t\t\t\t     unsigned from, unsigned to)\n{\n\tvoid *kaddr;\n\tunsigned int cluster_start, cluster_end;\n\n\tocfs2_figure_cluster_boundaries(osb, cpos, &cluster_start, &cluster_end);\n\n\tkaddr = kmap_atomic(page);\n\n\tif (from || to) {\n\t\tif (from > cluster_start)\n\t\t\tmemset(kaddr + cluster_start, 0, from - cluster_start);\n\t\tif (to < cluster_end)\n\t\t\tmemset(kaddr + to, 0, cluster_end - to);\n\t} else {\n\t\tmemset(kaddr + cluster_start, 0, cluster_end - cluster_start);\n\t}\n\n\tkunmap_atomic(kaddr);\n}\n\n/*\n * Nonsparse file systems fully allocate before we get to the write\n * code. This prevents ocfs2_write() from tagging the write as an\n * allocating one, which means ocfs2_map_page_blocks() might try to\n * read-in the blocks at the tail of our file. Avoid reading them by\n * testing i_size against each block offset.\n */\nstatic int ocfs2_should_read_blk(struct inode *inode, struct page *page,\n\t\t\t\t unsigned int block_start)\n{\n\tu64 offset = page_offset(page) + block_start;\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\treturn 1;\n\n\tif (i_size_read(inode) > offset)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n * Some of this taken from __block_write_begin(). We already have our\n * mapping by now though, and the entire write will be allocating or\n * it won't, so not much need to use BH_New.\n *\n * This will also skip zeroing, which is handled externally.\n */\nint ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = i_blocksize(inode);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t/*\n\t\t * Ignore blocks outside of our i/o range -\n\t\t * they may belong to unallocated clusters.\n\t\t */\n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For an allocating write with cluster size >= page\n\t\t * size, we always write the entire page.\n\t\t */\n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tclean_bdev_bh_alias(bh);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t/*\n\t * If we get -EIO above, zero out any newly allocated blocks\n\t * to avoid exposing stale data.\n\t */\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}\n\n#if (PAGE_SIZE >= OCFS2_MAX_CLUSTERSIZE)\n#define OCFS2_MAX_CTXT_PAGES\t1\n#else\n#define OCFS2_MAX_CTXT_PAGES\t(OCFS2_MAX_CLUSTERSIZE / PAGE_SIZE)\n#endif\n\n#define OCFS2_MAX_CLUSTERS_PER_PAGE\t(PAGE_SIZE / OCFS2_MIN_CLUSTERSIZE)\n\nstruct ocfs2_unwritten_extent {\n\tstruct list_head\tue_node;\n\tstruct list_head\tue_ip_node;\n\tu32\t\t\tue_cpos;\n\tu32\t\t\tue_phys;\n};\n\n/*\n * Describe the state of a single cluster to be written to.\n */\nstruct ocfs2_write_cluster_desc {\n\tu32\t\tc_cpos;\n\tu32\t\tc_phys;\n\t/*\n\t * Give this a unique field because c_phys eventually gets\n\t * filled.\n\t */\n\tunsigned\tc_new;\n\tunsigned\tc_clear_unwritten;\n\tunsigned\tc_needs_zero;\n};\n\nstruct ocfs2_write_ctxt {\n\t/* Logical cluster position / len of write */\n\tu32\t\t\t\tw_cpos;\n\tu32\t\t\t\tw_clen;\n\n\t/* First cluster allocated in a nonsparse extend */\n\tu32\t\t\t\tw_first_new_cpos;\n\n\t/* Type of caller. Must be one of buffer, mmap, direct.  */\n\tocfs2_write_type_t\t\tw_type;\n\n\tstruct ocfs2_write_cluster_desc\tw_desc[OCFS2_MAX_CLUSTERS_PER_PAGE];\n\n\t/*\n\t * This is true if page_size > cluster_size.\n\t *\n\t * It triggers a set of special cases during write which might\n\t * have to deal with allocating writes to partial pages.\n\t */\n\tunsigned int\t\t\tw_large_pages;\n\n\t/*\n\t * Pages involved in this write.\n\t *\n\t * w_target_page is the page being written to by the user.\n\t *\n\t * w_pages is an array of pages which always contains\n\t * w_target_page, and in the case of an allocating write with\n\t * page_size < cluster size, it will contain zero'd and mapped\n\t * pages adjacent to w_target_page which need to be written\n\t * out in so that future reads from that region will get\n\t * zero's.\n\t */\n\tunsigned int\t\t\tw_num_pages;\n\tstruct page\t\t\t*w_pages[OCFS2_MAX_CTXT_PAGES];\n\tstruct page\t\t\t*w_target_page;\n\n\t/*\n\t * w_target_locked is used for page_mkwrite path indicating no unlocking\n\t * against w_target_page in ocfs2_write_end_nolock.\n\t */\n\tunsigned int\t\t\tw_target_locked:1;\n\n\t/*\n\t * ocfs2_write_end() uses this to know what the real range to\n\t * write in the target should be.\n\t */\n\tunsigned int\t\t\tw_target_from;\n\tunsigned int\t\t\tw_target_to;\n\n\t/*\n\t * We could use journal_current_handle() but this is cleaner,\n\t * IMHO -Mark\n\t */\n\thandle_t\t\t\t*w_handle;\n\n\tstruct buffer_head\t\t*w_di_bh;\n\n\tstruct ocfs2_cached_dealloc_ctxt w_dealloc;\n\n\tstruct list_head\t\tw_unwritten_list;\n};\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}\n\nstatic void ocfs2_free_unwritten_list(struct inode *inode,\n\t\t\t\t struct list_head *head)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL, *tmp = NULL;\n\n\tlist_for_each_entry_safe(ue, tmp, head, ue_node) {\n\t\tlist_del(&ue->ue_node);\n\t\tspin_lock(&oi->ip_lock);\n\t\tlist_del(&ue->ue_ip_node);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tkfree(ue);\n\t}\n}\n\nstatic void ocfs2_free_write_ctxt(struct inode *inode,\n\t\t\t\t  struct ocfs2_write_ctxt *wc)\n{\n\tocfs2_free_unwritten_list(inode, &wc->w_unwritten_list);\n\tocfs2_unlock_pages(wc);\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n}\n\nstatic int ocfs2_alloc_write_ctxt(struct ocfs2_write_ctxt **wcp,\n\t\t\t\t  struct ocfs2_super *osb, loff_t pos,\n\t\t\t\t  unsigned len, ocfs2_write_type_t type,\n\t\t\t\t  struct buffer_head *di_bh)\n{\n\tu32 cend;\n\tstruct ocfs2_write_ctxt *wc;\n\n\twc = kzalloc(sizeof(struct ocfs2_write_ctxt), GFP_NOFS);\n\tif (!wc)\n\t\treturn -ENOMEM;\n\n\twc->w_cpos = pos >> osb->s_clustersize_bits;\n\twc->w_first_new_cpos = UINT_MAX;\n\tcend = (pos + len - 1) >> osb->s_clustersize_bits;\n\twc->w_clen = cend - wc->w_cpos + 1;\n\tget_bh(di_bh);\n\twc->w_di_bh = di_bh;\n\twc->w_type = type;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits))\n\t\twc->w_large_pages = 1;\n\telse\n\t\twc->w_large_pages = 0;\n\n\tocfs2_init_dealloc_ctxt(&wc->w_dealloc);\n\tINIT_LIST_HEAD(&wc->w_unwritten_list);\n\n\t*wcp = wc;\n\n\treturn 0;\n}\n\n/*\n * If a page has any new buffers, zero them out here, and mark them uptodate\n * and dirty so they'll be written out (in order to prevent uninitialised\n * block data from leaking). And clear the new bit.\n */\nstatic void ocfs2_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, end;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tend = min(to, block_end);\n\n\t\t\t\t\tzero_user_segment(page, start, end);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}\n\n/*\n * Only called when we have a failure during allocating write to write\n * zero's to the newly allocated region.\n */\nstatic void ocfs2_write_failure(struct inode *inode,\n\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\tloff_t user_pos, unsigned user_len)\n{\n\tint i;\n\tunsigned from = user_pos & (PAGE_SIZE - 1),\n\t\tto = user_pos + user_len;\n\tstruct page *tmppage;\n\n\tif (wc->w_target_page)\n\t\tocfs2_zero_new_buffers(wc->w_target_page, from, to);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\tif (tmppage && page_has_buffers(tmppage)) {\n\t\t\tif (ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_file_inode(wc->w_handle, inode);\n\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n}\n\nstatic int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\n\t/* treat the write as new if the a hole/lseek spanned across\n\t * the page boundary.\n\t */\n\tnew = new | ((i_size_read(inode) <= page_offset(page)) &&\n\t\t\t(page_offset(page) <= user_pos));\n\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we haven't allocated the new page yet, we\n\t\t * shouldn't be writing it out without copying user\n\t\t * data. This is likely a math error from the caller.\n\t\t */\n\t\tBUG_ON(!new);\n\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Parts of newly allocated pages need to be zero'd.\n\t *\n\t * Above, we have also rewritten 'to' and 'from' - as far as\n\t * the rest of the function is concerned, the entire cluster\n\t * range inside of a page needs to be written.\n\t *\n\t * We can skip this if the page is up to date - it's already\n\t * been zero'd from being read in as a hole.\n\t */\n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\n\tflush_dcache_page(page);\n\nout:\n\treturn ret;\n}\n\n/*\n * This function will only grab one clusters worth of pages.\n */\nstatic int ocfs2_grab_pages_for_write(struct address_space *mapping,\n\t\t\t\t      struct ocfs2_write_ctxt *wc,\n\t\t\t\t      u32 cpos, loff_t user_pos,\n\t\t\t\t      unsigned user_len, int new,\n\t\t\t\t      struct page *mmap_page)\n{\n\tint ret = 0, i;\n\tunsigned long start, target_index, end_index, index;\n\tstruct inode *inode = mapping->host;\n\tloff_t last_byte;\n\n\ttarget_index = user_pos >> PAGE_SHIFT;\n\n\t/*\n\t * Figure out how many pages we'll be manipulating here. For\n\t * non allocating write, we just change the one\n\t * page. Otherwise, we'll need a whole clusters worth.  If we're\n\t * writing past i_size, we only need enough pages to cover the\n\t * last page of the write.\n\t */\n\tif (new) {\n\t\twc->w_num_pages = ocfs2_pages_per_cluster(inode->i_sb);\n\t\tstart = ocfs2_align_clusters_to_page_index(inode->i_sb, cpos);\n\t\t/*\n\t\t * We need the index *past* the last page we could possibly\n\t\t * touch.  This is the page past the end of the write or\n\t\t * i_size, whichever is greater.\n\t\t */\n\t\tlast_byte = max(user_pos + user_len, i_size_read(inode));\n\t\tBUG_ON(last_byte < 1);\n\t\tend_index = ((last_byte - 1) >> PAGE_SHIFT) + 1;\n\t\tif ((start + wc->w_num_pages) > end_index)\n\t\t\twc->w_num_pages = end_index - start;\n\t} else {\n\t\twc->w_num_pages = 1;\n\t\tstart = target_index;\n\t}\n\tend_index = (user_pos + user_len - 1) >> PAGE_SHIFT;\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\tindex = start + i;\n\n\t\tif (index >= target_index && index <= end_index &&\n\t\t    wc->w_type == OCFS2_WRITE_MMAP) {\n\t\t\t/*\n\t\t\t * ocfs2_pagemkwrite() is a little different\n\t\t\t * and wants us to directly use the page\n\t\t\t * passed in.\n\t\t\t */\n\t\t\tlock_page(mmap_page);\n\n\t\t\t/* Exit and let the caller retry */\n\t\t\tif (mmap_page->mapping != mapping) {\n\t\t\t\tWARN_ON(mmap_page->mapping);\n\t\t\t\tunlock_page(mmap_page);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tget_page(mmap_page);\n\t\t\twc->w_pages[i] = mmap_page;\n\t\t\twc->w_target_locked = true;\n\t\t} else if (index >= target_index && index <= end_index &&\n\t\t\t   wc->w_type == OCFS2_WRITE_DIRECT) {\n\t\t\t/* Direct write has no mapping page. */\n\t\t\twc->w_pages[i] = NULL;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\twc->w_pages[i] = find_or_create_page(mapping, index,\n\t\t\t\t\t\t\t     GFP_NOFS);\n\t\t\tif (!wc->w_pages[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\twait_for_stable_page(wc->w_pages[i]);\n\n\t\tif (index == target_index)\n\t\t\twc->w_target_page = wc->w_pages[i];\n\t}\nout:\n\tif (ret)\n\t\twc->w_target_locked = false;\n\treturn ret;\n}\n\n/*\n * Prepare a single cluster for write one cluster into the file.\n */\nstatic int ocfs2_write_cluster(struct address_space *mapping,\n\t\t\t       u32 *phys, unsigned int new,\n\t\t\t       unsigned int clear_unwritten,\n\t\t\t       unsigned int should_zero,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct ocfs2_write_ctxt *wc, u32 cpos,\n\t\t\t       loff_t user_pos, unsigned user_len)\n{\n\tint ret, i;\n\tu64 p_blkno;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_extent_tree et;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (new) {\n\t\tu32 tmp_pos;\n\n\t\t/*\n\t\t * This is safe to call with the page locks - it won't take\n\t\t * any additional semaphores or cluster locks.\n\t\t */\n\t\ttmp_pos = cpos;\n\t\tret = ocfs2_add_inode_data(OCFS2_SB(inode->i_sb), inode,\n\t\t\t\t\t   &tmp_pos, 1, !clear_unwritten,\n\t\t\t\t\t   wc->w_di_bh, wc->w_handle,\n\t\t\t\t\t   data_ac, meta_ac, NULL);\n\t\t/*\n\t\t * This shouldn't happen because we must have already\n\t\t * calculated the correct meta data allocation required. The\n\t\t * internal tree allocation code should know how to increase\n\t\t * transaction credits itself.\n\t\t *\n\t\t * If need be, we could handle -EAGAIN for a\n\t\t * RESTART_TRANS here.\n\t\t */\n\t\tmlog_bug_on_msg(ret == -EAGAIN,\n\t\t\t\t\"Inode %llu: EAGAIN return during allocation.\\n\",\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (clear_unwritten) {\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_mark_extent_written(inode, &et,\n\t\t\t\t\t\twc->w_handle, cpos, 1, *phys,\n\t\t\t\t\t\tmeta_ac, &wc->w_dealloc);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * The only reason this should fail is due to an inability to\n\t * find the extent added.\n\t */\n\tret = ocfs2_get_clusters(inode, cpos, phys, NULL, NULL);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Get physical blkno failed for inode %llu, \"\n\t\t\t    \"at logical cluster %u\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno, cpos);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(*phys == 0);\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *phys);\n\tif (!should_zero)\n\t\tp_blkno += (user_pos >> inode->i_sb->s_blocksize_bits) & (u64)(bpc - 1);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\tint tmpret;\n\n\t\t/* This is the direct io target page. */\n\t\tif (wc->w_pages[i] == NULL) {\n\t\t\tp_blkno++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmpret = ocfs2_prepare_page_for_write(inode, &p_blkno, wc,\n\t\t\t\t\t\t      wc->w_pages[i], cpos,\n\t\t\t\t\t\t      user_pos, user_len,\n\t\t\t\t\t\t      should_zero);\n\t\tif (tmpret) {\n\t\t\tmlog_errno(tmpret);\n\t\t\tif (ret == 0)\n\t\t\t\tret = tmpret;\n\t\t}\n\t}\n\n\t/*\n\t * We only have cleanup to do in case of allocating write.\n\t */\n\tif (ret && new)\n\t\tocfs2_write_failure(inode, wc, user_pos, user_len);\n\nout:\n\n\treturn ret;\n}\n\nstatic int ocfs2_write_cluster_by_desc(struct address_space *mapping,\n\t\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t       struct ocfs2_write_ctxt *wc,\n\t\t\t\t       loff_t pos, unsigned len)\n{\n\tint ret, i;\n\tloff_t cluster_off;\n\tunsigned int local_len = len;\n\tstruct ocfs2_write_cluster_desc *desc;\n\tstruct ocfs2_super *osb = OCFS2_SB(mapping->host->i_sb);\n\n\tfor (i = 0; i < wc->w_clen; i++) {\n\t\tdesc = &wc->w_desc[i];\n\n\t\t/*\n\t\t * We have to make sure that the total write passed in\n\t\t * doesn't extend past a single cluster.\n\t\t */\n\t\tlocal_len = len;\n\t\tcluster_off = pos & (osb->s_clustersize - 1);\n\t\tif ((cluster_off + local_len) > osb->s_clustersize)\n\t\t\tlocal_len = osb->s_clustersize - cluster_off;\n\n\t\tret = ocfs2_write_cluster(mapping, &desc->c_phys,\n\t\t\t\t\t  desc->c_new,\n\t\t\t\t\t  desc->c_clear_unwritten,\n\t\t\t\t\t  desc->c_needs_zero,\n\t\t\t\t\t  data_ac, meta_ac,\n\t\t\t\t\t  wc, desc->c_cpos, pos, local_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen -= local_len;\n\t\tpos += local_len;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n/*\n * ocfs2_write_end() wants to know which parts of the target page it\n * should complete the write on. It's easiest to compute them ahead of\n * time when a more complete view of the write is available.\n */\nstatic void ocfs2_set_target_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tloff_t pos, unsigned len, int alloc)\n{\n\tstruct ocfs2_write_cluster_desc *desc;\n\n\twc->w_target_from = pos & (PAGE_SIZE - 1);\n\twc->w_target_to = wc->w_target_from + len;\n\n\tif (alloc == 0)\n\t\treturn;\n\n\t/*\n\t * Allocating write - we may have different boundaries based\n\t * on page size and cluster size.\n\t *\n\t * NOTE: We can no longer compute one value from the other as\n\t * the actual write length and user provided length may be\n\t * different.\n\t */\n\n\tif (wc->w_large_pages) {\n\t\t/*\n\t\t * We only care about the 1st and last cluster within\n\t\t * our range and whether they should be zero'd or not. Either\n\t\t * value may be extended out to the start/end of a\n\t\t * newly allocated cluster.\n\t\t */\n\t\tdesc = &wc->w_desc[0];\n\t\tif (desc->c_needs_zero)\n\t\t\tocfs2_figure_cluster_boundaries(osb,\n\t\t\t\t\t\t\tdesc->c_cpos,\n\t\t\t\t\t\t\t&wc->w_target_from,\n\t\t\t\t\t\t\tNULL);\n\n\t\tdesc = &wc->w_desc[wc->w_clen - 1];\n\t\tif (desc->c_needs_zero)\n\t\t\tocfs2_figure_cluster_boundaries(osb,\n\t\t\t\t\t\t\tdesc->c_cpos,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&wc->w_target_to);\n\t} else {\n\t\twc->w_target_from = 0;\n\t\twc->w_target_to = PAGE_SIZE;\n\t}\n}\n\n/*\n * Check if this extent is marked UNWRITTEN by direct io. If so, we need not to\n * do the zero work. And should not to clear UNWRITTEN since it will be cleared\n * by the direct io procedure.\n * If this is a new extent that allocated by direct io, we should mark it in\n * the ip_unwritten_list.\n */\nstatic int ocfs2_unwritten_check(struct inode *inode,\n\t\t\t\t struct ocfs2_write_ctxt *wc,\n\t\t\t\t struct ocfs2_write_cluster_desc *desc)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL, *new = NULL;\n\tint ret = 0;\n\n\tif (!desc->c_needs_zero)\n\t\treturn 0;\n\nretry:\n\tspin_lock(&oi->ip_lock);\n\t/* Needs not to zero no metter buffer or direct. The one who is zero\n\t * the cluster is doing zero. And he will clear unwritten after all\n\t * cluster io finished. */\n\tlist_for_each_entry(ue, &oi->ip_unwritten_list, ue_ip_node) {\n\t\tif (desc->c_cpos == ue->ue_cpos) {\n\t\t\tBUG_ON(desc->c_new);\n\t\t\tdesc->c_needs_zero = 0;\n\t\t\tdesc->c_clear_unwritten = 0;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (wc->w_type != OCFS2_WRITE_DIRECT)\n\t\tgoto unlock;\n\n\tif (new == NULL) {\n\t\tspin_unlock(&oi->ip_lock);\n\t\tnew = kmalloc(sizeof(struct ocfs2_unwritten_extent),\n\t\t\t     GFP_NOFS);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry;\n\t}\n\t/* This direct write will doing zero. */\n\tnew->ue_cpos = desc->c_cpos;\n\tnew->ue_phys = desc->c_phys;\n\tdesc->c_clear_unwritten = 0;\n\tlist_add_tail(&new->ue_ip_node, &oi->ip_unwritten_list);\n\tlist_add_tail(&new->ue_node, &wc->w_unwritten_list);\n\tnew = NULL;\nunlock:\n\tspin_unlock(&oi->ip_lock);\nout:\n\tif (new)\n\t\tkfree(new);\n\treturn ret;\n}\n\n/*\n * Populate each single-cluster write descriptor in the write context\n * with information about the i/o to be done.\n *\n * Returns the number of clusters that will have to be allocated, as\n * well as a worst case estimate of the number of extent records that\n * would have to be created during a write to an unwritten region.\n */\nstatic int ocfs2_populate_write_desc(struct inode *inode,\n\t\t\t\t     struct ocfs2_write_ctxt *wc,\n\t\t\t\t     unsigned int *clusters_to_alloc,\n\t\t\t\t     unsigned int *extents_to_split)\n{\n\tint ret;\n\tstruct ocfs2_write_cluster_desc *desc;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\tu32 phys = 0;\n\tint i;\n\n\t*clusters_to_alloc = 0;\n\t*extents_to_split = 0;\n\n\tfor (i = 0; i < wc->w_clen; i++) {\n\t\tdesc = &wc->w_desc[i];\n\t\tdesc->c_cpos = wc->w_cpos + i;\n\n\t\tif (num_clusters == 0) {\n\t\t\t/*\n\t\t\t * Need to look up the next extent record.\n\t\t\t */\n\t\t\tret = ocfs2_get_clusters(inode, desc->c_cpos, &phys,\n\t\t\t\t\t\t &num_clusters, &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* We should already CoW the refcountd extent. */\n\t\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\t\t/*\n\t\t\t * Assume worst case - that we're writing in\n\t\t\t * the middle of the extent.\n\t\t\t *\n\t\t\t * We can assume that the write proceeds from\n\t\t\t * left to right, in which case the extent\n\t\t\t * insert code is smart enough to coalesce the\n\t\t\t * next splits into the previous records created.\n\t\t\t */\n\t\t\tif (ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\t\t\t*extents_to_split = *extents_to_split + 2;\n\t\t} else if (phys) {\n\t\t\t/*\n\t\t\t * Only increment phys if it doesn't describe\n\t\t\t * a hole.\n\t\t\t */\n\t\t\tphys++;\n\t\t}\n\n\t\t/*\n\t\t * If w_first_new_cpos is < UINT_MAX, we have a non-sparse\n\t\t * file that got extended.  w_first_new_cpos tells us\n\t\t * where the newly allocated clusters are so we can\n\t\t * zero them.\n\t\t */\n\t\tif (desc->c_cpos >= wc->w_first_new_cpos) {\n\t\t\tBUG_ON(phys == 0);\n\t\t\tdesc->c_needs_zero = 1;\n\t\t}\n\n\t\tdesc->c_phys = phys;\n\t\tif (phys == 0) {\n\t\t\tdesc->c_new = 1;\n\t\t\tdesc->c_needs_zero = 1;\n\t\t\tdesc->c_clear_unwritten = 1;\n\t\t\t*clusters_to_alloc = *clusters_to_alloc + 1;\n\t\t}\n\n\t\tif (ext_flags & OCFS2_EXT_UNWRITTEN) {\n\t\t\tdesc->c_clear_unwritten = 1;\n\t\t\tdesc->c_needs_zero = 1;\n\t\t}\n\n\t\tret = ocfs2_unwritten_check(inode, wc, desc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_clusters--;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_write_begin_inline(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct page *page;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, 0, GFP_NOFS);\n\tif (!page) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\t/*\n\t * If we don't set w_num_pages then this page won't get unlocked\n\t * and freed on cleanup of the write context.\n\t */\n\twc->w_pages[0] = wc->w_target_page = page;\n\twc->w_num_pages = 1;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))\n\t\tocfs2_set_inode_data_inline(inode, di);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ocfs2_read_inline_data(inode, page, wc->w_di_bh);\n\t\tif (ret) {\n\t\t\tocfs2_commit_trans(osb, handle);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twc->w_handle = handle;\nout:\n\treturn ret;\n}\n\nint ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ocfs2_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t\t  struct inode *inode, loff_t pos,\n\t\t\t\t\t  unsigned len, struct page *mmap_page,\n\t\t\t\t\t  struct ocfs2_write_ctxt *wc)\n{\n\tint ret, written = 0;\n\tloff_t end = pos + len;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = NULL;\n\n\ttrace_ocfs2_try_to_write_inline_data((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     len, (unsigned long long)pos,\n\t\t\t\t\t     oi->ip_dyn_features);\n\n\t/*\n\t * Handle inodes which already have inline data 1st.\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (mmap_page == NULL &&\n\t\t    ocfs2_size_fits_inline_data(wc->w_di_bh, end))\n\t\t\tgoto do_inline_write;\n\n\t\t/*\n\t\t * The write won't fit - we have to give this inode an\n\t\t * inline extent list now.\n\t\t */\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, wc->w_di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check whether the inode can accept inline data.\n\t */\n\tif (oi->ip_clusters != 0 || i_size_read(inode) != 0)\n\t\treturn 0;\n\n\t/*\n\t * Check whether the write can fit.\n\t */\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\tif (mmap_page ||\n\t    end > ocfs2_max_inline_data_with_xattr(inode->i_sb, di))\n\t\treturn 0;\n\ndo_inline_write:\n\tret = ocfs2_write_begin_inline(mapping, inode, wc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This signals to the caller that the data can be written\n\t * inline.\n\t */\n\twritten = 1;\nout:\n\treturn written ? written : ret;\n}\n\n/*\n * This function only does anything for file systems which can't\n * handle sparse files.\n *\n * What we want to do here is fill in any hole between the current end\n * of allocation and the end of our write. That way the rest of the\n * write path can treat it as an non-allocating write, which has no\n * special case code for sparse/nonsparse files.\n */\nstatic int ocfs2_expand_nonsparse_inode(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *di_bh,\n\t\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tloff_t newsize = pos + len;\n\n\tBUG_ON(ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\n\tif (newsize <= i_size_read(inode))\n\t\treturn 0;\n\n\tret = ocfs2_extend_no_holes(inode, di_bh, newsize, pos);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t/* There is no wc if this is call from direct. */\n\tif (wc)\n\t\twc->w_first_new_cpos =\n\t\t\tocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\treturn ret;\n}\n\nstatic int ocfs2_zero_tail(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t   loff_t pos)\n{\n\tint ret = 0;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\tif (pos > i_size_read(inode))\n\t\tret = ocfs2_zero_extend(inode, di_bh, pos);\n\n\treturn ret;\n}\n\nint ocfs2_write_begin_nolock(struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, ocfs2_write_type_t type,\n\t\t\t     struct page **pagep, void **fsdata,\n\t\t\t     struct buffer_head *di_bh, struct page *mmap_page)\n{\n\tint ret, cluster_of_pages, credits = OCFS2_INODE_UPDATE_CREDITS;\n\tunsigned int clusters_to_alloc, extents_to_split, clusters_need = 0;\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tint try_free = 1, ret1;\n\ntry_again:\n\tret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, type, di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (ocfs2_supports_inline_data(osb)) {\n\t\tret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t     mmap_page, wc);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto success;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Direct io change i_size late, should not zero tail here. */\n\tif (type != OCFS2_WRITE_DIRECT) {\n\t\tif (ocfs2_sparse_alloc(osb))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   len, wc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_check_range_for_refcount(inode, pos, len);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tclusters_need = wc->w_clen;\n\t\tret = ocfs2_refcount_cow(inode, di_bh,\n\t\t\t\t\t wc->w_cpos, wc->w_clen, UINT_MAX);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,\n\t\t\t\t\t&extents_to_split);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tclusters_need += clusters_to_alloc;\n\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\ttrace_ocfs2_write_begin_nolock(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(long long)i_size_read(inode),\n\t\t\tle32_to_cpu(di->i_clusters),\n\t\t\tpos, len, type, mmap_page,\n\t\t\tclusters_to_alloc, extents_to_split);\n\n\t/*\n\t * We set w_target_from, w_target_to here so that\n\t * ocfs2_write_end() knows which range in the target page to\n\t * write out. An allocation requires that we write the entire\n\t * cluster range.\n\t */\n\tif (clusters_to_alloc || extents_to_split) {\n\t\t/*\n\t\t * XXX: We are stretching the limits of\n\t\t * ocfs2_lock_allocators(). It greatly over-estimates\n\t\t * the work to be done.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_lock_allocators(inode, &et,\n\t\t\t\t\t    clusters_to_alloc, extents_to_split,\n\t\t\t\t\t    &data_ac, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (data_ac)\n\t\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t    &di->id2.i_list);\n\t} else if (type == OCFS2_WRITE_DIRECT)\n\t\t/* direct write needs not to start trans if no extents alloc. */\n\t\tgoto success;\n\n\t/*\n\t * We have to zero sparse allocated clusters, unwritten extent clusters,\n\t * and non-sparse clusters we just extended.  For non-sparse writes,\n\t * we know zeros will only be needed in the first and/or last cluster.\n\t */\n\tif (wc->w_clen && (wc->w_desc[0].c_needs_zero ||\n\t\t\t   wc->w_desc[wc->w_clen - 1].c_needs_zero))\n\t\tcluster_of_pages = 1;\n\telse\n\t\tcluster_of_pages = 0;\n\n\tocfs2_set_target_boundaries(osb, wc, pos, len, cluster_of_pages);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twc->w_handle = handle;\n\n\tif (clusters_to_alloc) {\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * Fill our page array first. That way we've grabbed enough so\n\t * that we can zero and flush if we error after adding the\n\t * extent.\n\t */\n\tret = ocfs2_grab_pages_for_write(mapping, wc, wc->w_cpos, pos, len,\n\t\t\t\t\t cluster_of_pages, mmap_page);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * ocfs2_grab_pages_for_write() returns -EAGAIN if it could not lock\n\t * the target page. In this case, we exit with no error and no target\n\t * page. This will trigger the caller, page_mkwrite(), to re-try\n\t * the operation.\n\t */\n\tif (ret == -EAGAIN) {\n\t\tBUG_ON(wc->w_target_page);\n\t\tret = 0;\n\t\tgoto out_quota;\n\t}\n\n\tret = ocfs2_write_cluster_by_desc(mapping, data_ac, meta_ac, wc, pos,\n\t\t\t\t\t  len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\nsuccess:\n\tif (pagep)\n\t\t*pagep = wc->w_target_page;\n\t*fsdata = wc;\n\treturn 0;\nout_quota:\n\tif (clusters_to_alloc)\n\t\tdquot_free_space(inode,\n\t\t\t  ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\t/*\n\t * The mmapped page won't be unlocked in ocfs2_free_write_ctxt(),\n\t * even in case of error here like ENOSPC and ENOMEM. So, we need\n\t * to unlock the target page manually to prevent deadlocks when\n\t * retrying again on ENOSPC, or when returning non-VM_FAULT_LOCKED\n\t * to VM code.\n\t */\n\tif (wc->w_target_locked)\n\t\tunlock_page(mmap_page);\n\n\tocfs2_free_write_ctxt(inode, wc);\n\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\n\tif (ret == -ENOSPC && try_free) {\n\t\t/*\n\t\t * Try to free some truncate log so that we can have enough\n\t\t * clusters to allocate.\n\t\t */\n\t\ttry_free = 0;\n\n\t\tret1 = ocfs2_try_to_free_truncate_log(osb, clusters_need);\n\t\tif (ret1 == 1)\n\t\t\tgoto try_again;\n\n\t\tif (ret1 < 0)\n\t\t\tmlog_errno(ret1);\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct inode *inode = mapping->host;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Take alloc sem here to prevent concurrent lookups. That way\n\t * the mapping, zeroing and tree manipulation within\n\t * ocfs2_write() will be safe against ->readpage(). This\n\t * should also serve to lock out allocation from a shared\n\t * writeable region.\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tret = ocfs2_write_begin_nolock(mapping, pos, len, OCFS2_WRITE_BUFFER,\n\t\t\t\t       pagep, fsdata, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_fail;\n\t}\n\n\tbrelse(di_bh);\n\n\treturn 0;\n\nout_fail:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\n\n\treturn ret;\n}\n\nstatic void ocfs2_write_end_inline(struct inode *inode, loff_t pos,\n\t\t\t\t   unsigned len, unsigned *copied,\n\t\t\t\t   struct ocfs2_dinode *di,\n\t\t\t\t   struct ocfs2_write_ctxt *wc)\n{\n\tvoid *kaddr;\n\n\tif (unlikely(*copied < len)) {\n\t\tif (!PageUptodate(wc->w_target_page)) {\n\t\t\t*copied = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(wc->w_target_page);\n\tmemcpy(di->id2.i_data.id_data + pos, kaddr + pos, *copied);\n\tkunmap_atomic(kaddr);\n\n\ttrace_ocfs2_write_end_inline(\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)pos, *copied,\n\t     le16_to_cpu(di->id2.i_data.id_count),\n\t     le16_to_cpu(di->i_dyn_features));\n}\n\nint ocfs2_write_end_nolock(struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied, void *fsdata)\n{\n\tint i, ret;\n\tunsigned from, to, start = pos & (PAGE_SIZE - 1);\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_write_ctxt *wc = fsdata;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\thandle_t *handle = wc->w_handle;\n\tstruct page *tmppage;\n\n\tBUG_ON(!list_empty(&wc->w_unwritten_list));\n\n\tif (handle) {\n\t\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\twc->w_di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tcopied = ret;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tocfs2_write_end_inline(inode, pos, len, &copied, di, wc);\n\t\tgoto out_write_size;\n\t}\n\n\tif (unlikely(copied < len) && wc->w_target_page) {\n\t\tif (!PageUptodate(wc->w_target_page))\n\t\t\tcopied = 0;\n\n\t\tocfs2_zero_new_buffers(wc->w_target_page, start+copied,\n\t\t\t\t       start+len);\n\t}\n\tif (wc->w_target_page)\n\t\tflush_dcache_page(wc->w_target_page);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\t/* This is the direct io target page. */\n\t\tif (tmppage == NULL)\n\t\t\tcontinue;\n\n\t\tif (tmppage == wc->w_target_page) {\n\t\t\tfrom = wc->w_target_from;\n\t\t\tto = wc->w_target_to;\n\n\t\t\tBUG_ON(from > PAGE_SIZE ||\n\t\t\t       to > PAGE_SIZE ||\n\t\t\t       to < from);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Pages adjacent to the target (if any) imply\n\t\t\t * a hole-filling write in which case we want\n\t\t\t * to flush their entire range.\n\t\t\t */\n\t\t\tfrom = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t}\n\n\t\tif (page_has_buffers(tmppage)) {\n\t\t\tif (handle && ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_file_inode(handle, inode);\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n\nout_write_size:\n\t/* Direct io do not update i_size here. */\n\tif (wc->w_type != OCFS2_WRITE_DIRECT) {\n\t\tpos += copied;\n\t\tif (pos > i_size_read(inode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\t\tinode->i_mtime = inode->i_ctime = current_time(inode);\n\t\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\t\tdi->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\tif (handle)\n\t\tocfs2_journal_dirty(handle, wc->w_di_bh);\n\nout:\n\t/* unlock pages before dealloc since it needs acquiring j_trans_barrier\n\t * lock, or it will cause a deadlock since journal commit threads holds\n\t * this lock and will ask for the page lock when flushing the data.\n\t * put it here to preserve the unlock order.\n\t */\n\tocfs2_unlock_pages(wc);\n\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_run_deallocs(osb, &wc->w_dealloc);\n\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n\n\treturn copied;\n}\n\nstatic int ocfs2_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tint ret;\n\tstruct inode *inode = mapping->host;\n\n\tret = ocfs2_write_end_nolock(mapping, pos, len, copied, fsdata);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\n\treturn ret;\n}\n\nstruct ocfs2_dio_write_ctxt {\n\tstruct list_head\tdw_zero_list;\n\tunsigned\t\tdw_zero_count;\n\tint\t\t\tdw_orphaned;\n\tpid_t\t\t\tdw_writer_pid;\n};\n\nstatic struct ocfs2_dio_write_ctxt *\nocfs2_dio_alloc_write_ctx(struct buffer_head *bh, int *alloc)\n{\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\n\tif (bh->b_private)\n\t\treturn bh->b_private;\n\n\tdwc = kmalloc(sizeof(struct ocfs2_dio_write_ctxt), GFP_NOFS);\n\tif (dwc == NULL)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&dwc->dw_zero_list);\n\tdwc->dw_zero_count = 0;\n\tdwc->dw_orphaned = 0;\n\tdwc->dw_writer_pid = task_pid_nr(current);\n\tbh->b_private = dwc;\n\t*alloc = 1;\n\n\treturn dwc;\n}\n\nstatic void ocfs2_dio_free_write_ctx(struct inode *inode,\n\t\t\t\t     struct ocfs2_dio_write_ctxt *dwc)\n{\n\tocfs2_free_unwritten_list(inode, &dwc->dw_zero_list);\n\tkfree(dwc);\n}\n\n/*\n * TODO: Make this into a generic get_blocks function.\n *\n * From do_direct_io in direct-io.c:\n *  \"So what we do is to permit the ->get_blocks function to populate\n *   bh.b_size with the size of IO which is permitted at this offset and\n *   this i_blkbits.\"\n *\n * This function is called directly from get_more_blocks in direct-io.c.\n *\n * called like this: dio->get_blocks(dio->inode, fs_startblk,\n * \t\t\t\t\tfs_count, map_bh, dio->rw == WRITE);\n */\nstatic int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,\n\t\t\t       struct buffer_head *bh_result, int create)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n\t * while file size will be changed.\n\t */\n\tif (pos + total_len <= i_size_read(inode)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\n\t\tup_read(&oi->ip_alloc_sem);\n\n\t\tif (buffer_mapped(bh_result) &&\n\t\t    !buffer_new(bh_result) &&\n\t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n\nstatic int ocfs2_dio_end_io_write(struct inode *inode,\n\t\t\t\t  struct ocfs2_dio_write_ctxt *dwc,\n\t\t\t\t  loff_t offset,\n\t\t\t\t  ssize_t bytes)\n{\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tloff_t end = offset + bytes;\n\tint ret = 0, credits = 0, locked = 0;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\t/* We do clear unwritten, delete orphan, change i_size here. If neither\n\t * of these happen, we can skip all this. */\n\tif (list_empty(&dwc->dw_zero_list) &&\n\t    end <= i_size_read(inode) &&\n\t    !dwc->dw_orphaned)\n\t\tgoto out;\n\n\t/* ocfs2_file_write_iter will get i_mutex, so we need not lock if we\n\t * are in that context. */\n\tif (dwc->dw_writer_pid != task_pid_nr(current)) {\n\t\tinode_lock(inode);\n\t\tlocked = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\t/* Delete orphan before acquire i_mutex. */\n\tif (dwc->dw_orphaned) {\n\t\tBUG_ON(dwc->dw_writer_pid != task_pid_nr(current));\n\n\t\tend = end > i_size_read(inode) ? end : 0;\n\n\t\tret = ocfs2_del_inode_from_orphan(osb, inode, di_bh,\n\t\t\t\t!!end, end);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, dwc->dw_zero_count*2,\n\t\t\t\t    &data_ac, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(inode->i_sb, &di->id2.i_list);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto commit;\n\t}\n\n\tlist_for_each_entry(ue, &dwc->dw_zero_list, ue_node) {\n\t\tret = ocfs2_mark_extent_written(inode, &et, handle,\n\t\t\t\t\t\tue->ue_cpos, 1,\n\t\t\t\t\t\tue->ue_phys,\n\t\t\t\t\t\tmeta_ac, &dealloc);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (end > i_size_read(inode)) {\n\t\tret = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\ncommit:\n\tocfs2_commit_trans(osb, handle);\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tocfs2_run_deallocs(osb, &dealloc);\n\tif (locked)\n\t\tinode_unlock(inode);\n\tocfs2_dio_free_write_ctx(inode, dwc);\n\n\treturn ret;\n}\n\n/*\n * ocfs2_dio_end_io is called by the dio core when a dio is finished.  We're\n * particularly interested in the aio/dio case.  We use the rw_lock DLM lock\n * to protect io on one node from truncation on another.\n */\nstatic int ocfs2_dio_end_io(struct kiocb *iocb,\n\t\t\t    loff_t offset,\n\t\t\t    ssize_t bytes,\n\t\t\t    void *private)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tint level;\n\tint ret = 0;\n\n\t/* this io's submitter should not have unlocked this before we could */\n\tBUG_ON(!ocfs2_iocb_is_rw_locked(iocb));\n\n\tif (bytes > 0 && private)\n\t\tret = ocfs2_dio_end_io_write(inode, private, offset, bytes);\n\n\tocfs2_iocb_clear_rw_locked(iocb);\n\n\tlevel = ocfs2_iocb_rw_locked_level(iocb);\n\tocfs2_rw_unlock(inode, level);\n\treturn ret;\n}\n\nstatic ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\n\t/*\n\t * Fallback to buffered I/O if we see an inode without\n\t * extents.\n\t */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t/* Fallback to buffered I/O if we do not support append dio. */\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}\n\nconst struct address_space_operations ocfs2_aops = {\n\t.readpage\t\t= ocfs2_readpage,\n\t.readpages\t\t= ocfs2_readpages,\n\t.writepage\t\t= ocfs2_writepage,\n\t.write_begin\t\t= ocfs2_write_begin,\n\t.write_end\t\t= ocfs2_write_end,\n\t.bmap\t\t\t= ocfs2_bmap,\n\t.direct_IO\t\t= ocfs2_direct_IO,\n\t.invalidatepage\t\t= block_invalidatepage,\n\t.releasepage\t\t= ocfs2_releasepage,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 8; -*-\n * vim: noexpandtab sw=8 ts=8 sts=0:\n *\n * Copyright (C) 2002, 2004 Oracle.  All rights reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <asm/byteorder.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mpage.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n\n#include <cluster/masklog.h>\n\n#include \"ocfs2.h\"\n\n#include \"alloc.h\"\n#include \"aops.h\"\n#include \"dlmglue.h\"\n#include \"extent_map.h\"\n#include \"file.h\"\n#include \"inode.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"super.h\"\n#include \"symlink.h\"\n#include \"refcounttree.h\"\n#include \"ocfs2_trace.h\"\n\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"namei.h\"\n#include \"sysfile.h\"\n\nstatic int ocfs2_symlink_get_block(struct inode *inode, sector_t iblock,\n\t\t\t\t   struct buffer_head *bh_result, int create)\n{\n\tint err = -EIO;\n\tint status;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *buffer_cache_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tvoid *kaddr;\n\n\ttrace_ocfs2_symlink_get_block(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)iblock, bh_result, create);\n\n\tBUG_ON(ocfs2_inode_is_fast_symlink(inode));\n\n\tif ((iblock << inode->i_sb->s_blocksize_bits) > PATH_MAX + 1) {\n\t\tmlog(ML_ERROR, \"block offset > PATH_MAX: %llu\",\n\t\t     (unsigned long long)iblock);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tif ((u64)iblock >= ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(fe->i_clusters))) {\n\t\terr = -ENOMEM;\n\t\tmlog(ML_ERROR, \"block offset is outside the allocated size: \"\n\t\t     \"%llu\\n\", (unsigned long long)iblock);\n\t\tgoto bail;\n\t}\n\n\t/* We don't use the page cache to create symlink data, so if\n\t * need be, copy it over from the buffer cache. */\n\tif (!buffer_uptodate(bh_result) && ocfs2_inode_is_new(inode)) {\n\t\tu64 blkno = le64_to_cpu(fe->id2.i_list.l_recs[0].e_blkno) +\n\t\t\t    iblock;\n\t\tbuffer_cache_bh = sb_getblk(osb->sb, blkno);\n\t\tif (!buffer_cache_bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tmlog(ML_ERROR, \"couldn't getblock for symlink!\\n\");\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* we haven't locked out transactions, so a commit\n\t\t * could've happened. Since we've got a reference on\n\t\t * the bh, even if it commits while we're doing the\n\t\t * copy, the data is still good. */\n\t\tif (buffer_jbd(buffer_cache_bh)\n\t\t    && ocfs2_inode_is_new(inode)) {\n\t\t\tkaddr = kmap_atomic(bh_result->b_page);\n\t\t\tif (!kaddr) {\n\t\t\t\tmlog(ML_ERROR, \"couldn't kmap!\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(kaddr + (bh_result->b_size * iblock),\n\t\t\t       buffer_cache_bh->b_data,\n\t\t\t       bh_result->b_size);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t}\n\t\tbrelse(buffer_cache_bh);\n\t}\n\n\tmap_bh(bh_result, inode->i_sb,\n\t       le64_to_cpu(fe->id2.i_list.l_recs[0].e_blkno) + iblock);\n\n\terr = 0;\n\nbail:\n\tbrelse(bh);\n\n\treturn err;\n}\n\nstatic int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\n\treturn ret;\n}\n\nint ocfs2_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint err = 0;\n\tunsigned int ext_flags;\n\tu64 max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tu64 p_blkno, count, past_eof;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\ttrace_ocfs2_get_block((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t      (unsigned long long)iblock, bh_result, create);\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE)\n\t\tmlog(ML_NOTICE, \"get_block on system inode 0x%p (%lu)\\n\",\n\t\t     inode, inode->i_ino);\n\n\tif (S_ISLNK(inode->i_mode)) {\n\t\t/* this always does I/O for some reason. */\n\t\terr = ocfs2_symlink_get_block(inode, iblock, bh_result, create);\n\t\tgoto bail;\n\t}\n\n\terr = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno, &count,\n\t\t\t\t\t  &ext_flags);\n\tif (err) {\n\t\tmlog(ML_ERROR, \"Error %d from get_blocks(0x%p, %llu, 1, \"\n\t\t     \"%llu, NULL)\\n\", err, inode, (unsigned long long)iblock,\n\t\t     (unsigned long long)p_blkno);\n\t\tgoto bail;\n\t}\n\n\tif (max_blocks < count)\n\t\tcount = max_blocks;\n\n\t/*\n\t * ocfs2 never allocates in this function - the only time we\n\t * need to use BH_New is when we're extending i_size on a file\n\t * system which doesn't support holes, in which case BH_New\n\t * allows __block_write_begin() to zero.\n\t *\n\t * If we see this on a sparse file system, then a truncate has\n\t * raced us and removed the cluster. In this case, we clear\n\t * the buffers dirty and uptodate bits and let the buffer code\n\t * ignore it as a hole.\n\t */\n\tif (create && p_blkno == 0 && ocfs2_sparse_alloc(osb)) {\n\t\tclear_buffer_dirty(bh_result);\n\t\tclear_buffer_uptodate(bh_result);\n\t\tgoto bail;\n\t}\n\n\t/* Treat the unwritten extent as a hole for zeroing purposes. */\n\tif (p_blkno && !(ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\n\tbh_result->b_size = count << inode->i_blkbits;\n\n\tif (!ocfs2_sparse_alloc(osb)) {\n\t\tif (p_blkno == 0) {\n\t\t\terr = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"iblock = %llu p_blkno = %llu blkno=(%llu)\\n\",\n\t\t\t     (unsigned long long)iblock,\n\t\t\t     (unsigned long long)p_blkno,\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\t\tmlog(ML_ERROR, \"Size %llu, clusters %u\\n\", (unsigned long long)i_size_read(inode), OCFS2_I(inode)->ip_clusters);\n\t\t\tdump_stack();\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tpast_eof = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\n\ttrace_ocfs2_get_block_end((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)past_eof);\n\tif (create && (iblock >= past_eof))\n\t\tset_buffer_new(bh_result);\n\nbail:\n\tif (err < 0)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nint ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}\n\nstatic int ocfs2_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_inline_data(inode, page, di_bh);\nout:\n\tunlock_page(page);\n\n\tbrelse(di_bh);\n\treturn ret;\n}\n\nstatic int ocfs2_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tloff_t start = (loff_t)page->index << PAGE_SHIFT;\n\tint ret, unlock = 1;\n\n\ttrace_ocfs2_readpage((unsigned long long)oi->ip_blkno,\n\t\t\t     (page ? page->index : 0));\n\n\tret = ocfs2_inode_lock_with_page(inode, NULL, 0, page);\n\tif (ret != 0) {\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tunlock = 0;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (down_read_trylock(&oi->ip_alloc_sem) == 0) {\n\t\t/*\n\t\t * Unlock the page and cycle ip_alloc_sem so that we don't\n\t\t * busyloop waiting for ip_alloc_sem to unlock\n\t\t */\n\t\tret = AOP_TRUNCATED_PAGE;\n\t\tunlock_page(page);\n\t\tunlock = 0;\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * i_size might have just been updated as we grabed the meta lock.  We\n\t * might now be discovering a truncate that hit on another node.\n\t * block_read_full_page->get_block freaks out if it is asked to read\n\t * beyond the end of a file, so we check here.  Callers\n\t * (generic_file_read, vm_ops->fault) are clever enough to check i_size\n\t * and notice that the page they just read isn't needed.\n\t *\n\t * XXX sys_readahead() seems to get that wrong?\n\t */\n\tif (start >= i_size_read(inode)) {\n\t\tzero_user(page, 0, PAGE_SIZE);\n\t\tSetPageUptodate(page);\n\t\tret = 0;\n\t\tgoto out_alloc;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tret = ocfs2_readpage_inline(inode, page);\n\telse\n\t\tret = block_read_full_page(page, ocfs2_get_block);\n\tunlock = 0;\n\nout_alloc:\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\nout_inode_unlock:\n\tocfs2_inode_unlock(inode, 0);\nout:\n\tif (unlock)\n\t\tunlock_page(page);\n\treturn ret;\n}\n\n/*\n * This is used only for read-ahead. Failures or difficult to handle\n * situations are safe to ignore.\n *\n * Right now, we don't bother with BH_Boundary - in-inode extent lists\n * are quite large (243 extents on 4k blocks), so most inodes don't\n * grow out to a tree. If need be, detecting boundary extents could\n * trivially be added in a future version of ocfs2_get_block().\n */\nstatic int ocfs2_readpages(struct file *filp, struct address_space *mapping,\n\t\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\tint ret, err = -EIO;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tloff_t start;\n\tstruct page *last;\n\n\t/*\n\t * Use the nonblocking flag for the dlm code to avoid page\n\t * lock inversion, but don't bother with retrying.\n\t */\n\tret = ocfs2_inode_lock_full(inode, NULL, 0, OCFS2_LOCK_NONBLOCK);\n\tif (ret)\n\t\treturn err;\n\n\tif (down_read_trylock(&oi->ip_alloc_sem) == 0) {\n\t\tocfs2_inode_unlock(inode, 0);\n\t\treturn err;\n\t}\n\n\t/*\n\t * Don't bother with inline-data. There isn't anything\n\t * to read-ahead in that case anyway...\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check whether a remote node truncated this file - we just\n\t * drop out in that case as it's not worth handling here.\n\t */\n\tlast = list_entry(pages->prev, struct page, lru);\n\tstart = (loff_t)last->index << PAGE_SHIFT;\n\tif (start >= i_size_read(inode))\n\t\tgoto out_unlock;\n\n\terr = mpage_readpages(mapping, pages, nr_pages, ocfs2_get_block);\n\nout_unlock:\n\tup_read(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 0);\n\n\treturn err;\n}\n\n/* Note: Because we don't support holes, our allocation has\n * already happened (allocation writes zeros to the file data)\n * so we don't have to worry about ordered writes in\n * ocfs2_writepage.\n *\n * ->writepage is called during the process of invalidating the page cache\n * during blocked lock processing.  It can't block on any cluster locks\n * to during block mapping.  It's relying on the fact that the block\n * mapping can't have disappeared under the dirty pages that it is\n * being asked to write back.\n */\nstatic int ocfs2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\ttrace_ocfs2_writepage(\n\t\t(unsigned long long)OCFS2_I(page->mapping->host)->ip_blkno,\n\t\tpage->index);\n\n\treturn block_write_full_page(page, ocfs2_get_block, wbc);\n}\n\n/* Taken from ext3. We don't necessarily need the full blown\n * functionality yet, but IMHO it's better to cut and paste the whole\n * thing so we can avoid introducing our own bugs (and easily pick up\n * their fixes when they happen) --Mark */\nint walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n\nstatic sector_t ocfs2_bmap(struct address_space *mapping, sector_t block)\n{\n\tsector_t status;\n\tu64 p_blkno = 0;\n\tint err = 0;\n\tstruct inode *inode = mapping->host;\n\n\ttrace_ocfs2_bmap((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t (unsigned long long)block);\n\n\t/*\n\t * The swap code (ab-)uses ->bmap to get a block mapping and then\n\t * bypasse\u0455 the file system for actual I/O.  We really can't allow\n\t * that on refcounted inodes, so we have to skip out here.  And yes,\n\t * 0 is the magic code for a bmap error..\n\t */\n\tif (ocfs2_is_refcount_inode(inode))\n\t\treturn 0;\n\n\t/* We don't need to lock journal system files, since they aren't\n\t * accessed concurrently from multiple nodes.\n\t */\n\tif (!INODE_JOURNAL(inode)) {\n\t\terr = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tmlog_errno(err);\n\t\t\tgoto bail;\n\t\t}\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))\n\t\terr = ocfs2_extent_map_get_blocks(inode, block, &p_blkno, NULL,\n\t\t\t\t\t\t  NULL);\n\n\tif (!INODE_JOURNAL(inode)) {\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tocfs2_inode_unlock(inode, 0);\n\t}\n\n\tif (err) {\n\t\tmlog(ML_ERROR, \"get_blocks() failed, block = %llu\\n\",\n\t\t     (unsigned long long)block);\n\t\tmlog_errno(err);\n\t\tgoto bail;\n\t}\n\nbail:\n\tstatus = err ? 0 : p_blkno;\n\n\treturn status;\n}\n\nstatic int ocfs2_releasepage(struct page *page, gfp_t wait)\n{\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\treturn try_to_free_buffers(page);\n}\n\nstatic void ocfs2_figure_cluster_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\t    u32 cpos,\n\t\t\t\t\t    unsigned int *start,\n\t\t\t\t\t    unsigned int *end)\n{\n\tunsigned int cluster_start = 0, cluster_end = PAGE_SIZE;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits)) {\n\t\tunsigned int cpp;\n\n\t\tcpp = 1 << (PAGE_SHIFT - osb->s_clustersize_bits);\n\n\t\tcluster_start = cpos % cpp;\n\t\tcluster_start = cluster_start << osb->s_clustersize_bits;\n\n\t\tcluster_end = cluster_start + osb->s_clustersize;\n\t}\n\n\tBUG_ON(cluster_start > PAGE_SIZE);\n\tBUG_ON(cluster_end > PAGE_SIZE);\n\n\tif (start)\n\t\t*start = cluster_start;\n\tif (end)\n\t\t*end = cluster_end;\n}\n\n/*\n * 'from' and 'to' are the region in the page to avoid zeroing.\n *\n * If pagesize > clustersize, this function will avoid zeroing outside\n * of the cluster boundary.\n *\n * from == to == 0 is code for \"zero the entire cluster region\"\n */\nstatic void ocfs2_clear_page_regions(struct page *page,\n\t\t\t\t     struct ocfs2_super *osb, u32 cpos,\n\t\t\t\t     unsigned from, unsigned to)\n{\n\tvoid *kaddr;\n\tunsigned int cluster_start, cluster_end;\n\n\tocfs2_figure_cluster_boundaries(osb, cpos, &cluster_start, &cluster_end);\n\n\tkaddr = kmap_atomic(page);\n\n\tif (from || to) {\n\t\tif (from > cluster_start)\n\t\t\tmemset(kaddr + cluster_start, 0, from - cluster_start);\n\t\tif (to < cluster_end)\n\t\t\tmemset(kaddr + to, 0, cluster_end - to);\n\t} else {\n\t\tmemset(kaddr + cluster_start, 0, cluster_end - cluster_start);\n\t}\n\n\tkunmap_atomic(kaddr);\n}\n\n/*\n * Nonsparse file systems fully allocate before we get to the write\n * code. This prevents ocfs2_write() from tagging the write as an\n * allocating one, which means ocfs2_map_page_blocks() might try to\n * read-in the blocks at the tail of our file. Avoid reading them by\n * testing i_size against each block offset.\n */\nstatic int ocfs2_should_read_blk(struct inode *inode, struct page *page,\n\t\t\t\t unsigned int block_start)\n{\n\tu64 offset = page_offset(page) + block_start;\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\treturn 1;\n\n\tif (i_size_read(inode) > offset)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n * Some of this taken from __block_write_begin(). We already have our\n * mapping by now though, and the entire write will be allocating or\n * it won't, so not much need to use BH_New.\n *\n * This will also skip zeroing, which is handled externally.\n */\nint ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = i_blocksize(inode);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t/*\n\t\t * Ignore blocks outside of our i/o range -\n\t\t * they may belong to unallocated clusters.\n\t\t */\n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For an allocating write with cluster size >= page\n\t\t * size, we always write the entire page.\n\t\t */\n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tclean_bdev_bh_alias(bh);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t/*\n\t * If we get -EIO above, zero out any newly allocated blocks\n\t * to avoid exposing stale data.\n\t */\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}\n\n#if (PAGE_SIZE >= OCFS2_MAX_CLUSTERSIZE)\n#define OCFS2_MAX_CTXT_PAGES\t1\n#else\n#define OCFS2_MAX_CTXT_PAGES\t(OCFS2_MAX_CLUSTERSIZE / PAGE_SIZE)\n#endif\n\n#define OCFS2_MAX_CLUSTERS_PER_PAGE\t(PAGE_SIZE / OCFS2_MIN_CLUSTERSIZE)\n\nstruct ocfs2_unwritten_extent {\n\tstruct list_head\tue_node;\n\tstruct list_head\tue_ip_node;\n\tu32\t\t\tue_cpos;\n\tu32\t\t\tue_phys;\n};\n\n/*\n * Describe the state of a single cluster to be written to.\n */\nstruct ocfs2_write_cluster_desc {\n\tu32\t\tc_cpos;\n\tu32\t\tc_phys;\n\t/*\n\t * Give this a unique field because c_phys eventually gets\n\t * filled.\n\t */\n\tunsigned\tc_new;\n\tunsigned\tc_clear_unwritten;\n\tunsigned\tc_needs_zero;\n};\n\nstruct ocfs2_write_ctxt {\n\t/* Logical cluster position / len of write */\n\tu32\t\t\t\tw_cpos;\n\tu32\t\t\t\tw_clen;\n\n\t/* First cluster allocated in a nonsparse extend */\n\tu32\t\t\t\tw_first_new_cpos;\n\n\t/* Type of caller. Must be one of buffer, mmap, direct.  */\n\tocfs2_write_type_t\t\tw_type;\n\n\tstruct ocfs2_write_cluster_desc\tw_desc[OCFS2_MAX_CLUSTERS_PER_PAGE];\n\n\t/*\n\t * This is true if page_size > cluster_size.\n\t *\n\t * It triggers a set of special cases during write which might\n\t * have to deal with allocating writes to partial pages.\n\t */\n\tunsigned int\t\t\tw_large_pages;\n\n\t/*\n\t * Pages involved in this write.\n\t *\n\t * w_target_page is the page being written to by the user.\n\t *\n\t * w_pages is an array of pages which always contains\n\t * w_target_page, and in the case of an allocating write with\n\t * page_size < cluster size, it will contain zero'd and mapped\n\t * pages adjacent to w_target_page which need to be written\n\t * out in so that future reads from that region will get\n\t * zero's.\n\t */\n\tunsigned int\t\t\tw_num_pages;\n\tstruct page\t\t\t*w_pages[OCFS2_MAX_CTXT_PAGES];\n\tstruct page\t\t\t*w_target_page;\n\n\t/*\n\t * w_target_locked is used for page_mkwrite path indicating no unlocking\n\t * against w_target_page in ocfs2_write_end_nolock.\n\t */\n\tunsigned int\t\t\tw_target_locked:1;\n\n\t/*\n\t * ocfs2_write_end() uses this to know what the real range to\n\t * write in the target should be.\n\t */\n\tunsigned int\t\t\tw_target_from;\n\tunsigned int\t\t\tw_target_to;\n\n\t/*\n\t * We could use journal_current_handle() but this is cleaner,\n\t * IMHO -Mark\n\t */\n\thandle_t\t\t\t*w_handle;\n\n\tstruct buffer_head\t\t*w_di_bh;\n\n\tstruct ocfs2_cached_dealloc_ctxt w_dealloc;\n\n\tstruct list_head\t\tw_unwritten_list;\n};\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}\n\nstatic void ocfs2_free_unwritten_list(struct inode *inode,\n\t\t\t\t struct list_head *head)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL, *tmp = NULL;\n\n\tlist_for_each_entry_safe(ue, tmp, head, ue_node) {\n\t\tlist_del(&ue->ue_node);\n\t\tspin_lock(&oi->ip_lock);\n\t\tlist_del(&ue->ue_ip_node);\n\t\tspin_unlock(&oi->ip_lock);\n\t\tkfree(ue);\n\t}\n}\n\nstatic void ocfs2_free_write_ctxt(struct inode *inode,\n\t\t\t\t  struct ocfs2_write_ctxt *wc)\n{\n\tocfs2_free_unwritten_list(inode, &wc->w_unwritten_list);\n\tocfs2_unlock_pages(wc);\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n}\n\nstatic int ocfs2_alloc_write_ctxt(struct ocfs2_write_ctxt **wcp,\n\t\t\t\t  struct ocfs2_super *osb, loff_t pos,\n\t\t\t\t  unsigned len, ocfs2_write_type_t type,\n\t\t\t\t  struct buffer_head *di_bh)\n{\n\tu32 cend;\n\tstruct ocfs2_write_ctxt *wc;\n\n\twc = kzalloc(sizeof(struct ocfs2_write_ctxt), GFP_NOFS);\n\tif (!wc)\n\t\treturn -ENOMEM;\n\n\twc->w_cpos = pos >> osb->s_clustersize_bits;\n\twc->w_first_new_cpos = UINT_MAX;\n\tcend = (pos + len - 1) >> osb->s_clustersize_bits;\n\twc->w_clen = cend - wc->w_cpos + 1;\n\tget_bh(di_bh);\n\twc->w_di_bh = di_bh;\n\twc->w_type = type;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits))\n\t\twc->w_large_pages = 1;\n\telse\n\t\twc->w_large_pages = 0;\n\n\tocfs2_init_dealloc_ctxt(&wc->w_dealloc);\n\tINIT_LIST_HEAD(&wc->w_unwritten_list);\n\n\t*wcp = wc;\n\n\treturn 0;\n}\n\n/*\n * If a page has any new buffers, zero them out here, and mark them uptodate\n * and dirty so they'll be written out (in order to prevent uninitialised\n * block data from leaking). And clear the new bit.\n */\nstatic void ocfs2_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, end;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tend = min(to, block_end);\n\n\t\t\t\t\tzero_user_segment(page, start, end);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}\n\n/*\n * Only called when we have a failure during allocating write to write\n * zero's to the newly allocated region.\n */\nstatic void ocfs2_write_failure(struct inode *inode,\n\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\tloff_t user_pos, unsigned user_len)\n{\n\tint i;\n\tunsigned from = user_pos & (PAGE_SIZE - 1),\n\t\tto = user_pos + user_len;\n\tstruct page *tmppage;\n\n\tif (wc->w_target_page)\n\t\tocfs2_zero_new_buffers(wc->w_target_page, from, to);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\tif (tmppage && page_has_buffers(tmppage)) {\n\t\t\tif (ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_file_inode(wc->w_handle, inode);\n\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n}\n\nstatic int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\n\t/* treat the write as new if the a hole/lseek spanned across\n\t * the page boundary.\n\t */\n\tnew = new | ((i_size_read(inode) <= page_offset(page)) &&\n\t\t\t(page_offset(page) <= user_pos));\n\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we haven't allocated the new page yet, we\n\t\t * shouldn't be writing it out without copying user\n\t\t * data. This is likely a math error from the caller.\n\t\t */\n\t\tBUG_ON(!new);\n\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Parts of newly allocated pages need to be zero'd.\n\t *\n\t * Above, we have also rewritten 'to' and 'from' - as far as\n\t * the rest of the function is concerned, the entire cluster\n\t * range inside of a page needs to be written.\n\t *\n\t * We can skip this if the page is up to date - it's already\n\t * been zero'd from being read in as a hole.\n\t */\n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\n\tflush_dcache_page(page);\n\nout:\n\treturn ret;\n}\n\n/*\n * This function will only grab one clusters worth of pages.\n */\nstatic int ocfs2_grab_pages_for_write(struct address_space *mapping,\n\t\t\t\t      struct ocfs2_write_ctxt *wc,\n\t\t\t\t      u32 cpos, loff_t user_pos,\n\t\t\t\t      unsigned user_len, int new,\n\t\t\t\t      struct page *mmap_page)\n{\n\tint ret = 0, i;\n\tunsigned long start, target_index, end_index, index;\n\tstruct inode *inode = mapping->host;\n\tloff_t last_byte;\n\n\ttarget_index = user_pos >> PAGE_SHIFT;\n\n\t/*\n\t * Figure out how many pages we'll be manipulating here. For\n\t * non allocating write, we just change the one\n\t * page. Otherwise, we'll need a whole clusters worth.  If we're\n\t * writing past i_size, we only need enough pages to cover the\n\t * last page of the write.\n\t */\n\tif (new) {\n\t\twc->w_num_pages = ocfs2_pages_per_cluster(inode->i_sb);\n\t\tstart = ocfs2_align_clusters_to_page_index(inode->i_sb, cpos);\n\t\t/*\n\t\t * We need the index *past* the last page we could possibly\n\t\t * touch.  This is the page past the end of the write or\n\t\t * i_size, whichever is greater.\n\t\t */\n\t\tlast_byte = max(user_pos + user_len, i_size_read(inode));\n\t\tBUG_ON(last_byte < 1);\n\t\tend_index = ((last_byte - 1) >> PAGE_SHIFT) + 1;\n\t\tif ((start + wc->w_num_pages) > end_index)\n\t\t\twc->w_num_pages = end_index - start;\n\t} else {\n\t\twc->w_num_pages = 1;\n\t\tstart = target_index;\n\t}\n\tend_index = (user_pos + user_len - 1) >> PAGE_SHIFT;\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\tindex = start + i;\n\n\t\tif (index >= target_index && index <= end_index &&\n\t\t    wc->w_type == OCFS2_WRITE_MMAP) {\n\t\t\t/*\n\t\t\t * ocfs2_pagemkwrite() is a little different\n\t\t\t * and wants us to directly use the page\n\t\t\t * passed in.\n\t\t\t */\n\t\t\tlock_page(mmap_page);\n\n\t\t\t/* Exit and let the caller retry */\n\t\t\tif (mmap_page->mapping != mapping) {\n\t\t\t\tWARN_ON(mmap_page->mapping);\n\t\t\t\tunlock_page(mmap_page);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tget_page(mmap_page);\n\t\t\twc->w_pages[i] = mmap_page;\n\t\t\twc->w_target_locked = true;\n\t\t} else if (index >= target_index && index <= end_index &&\n\t\t\t   wc->w_type == OCFS2_WRITE_DIRECT) {\n\t\t\t/* Direct write has no mapping page. */\n\t\t\twc->w_pages[i] = NULL;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\twc->w_pages[i] = find_or_create_page(mapping, index,\n\t\t\t\t\t\t\t     GFP_NOFS);\n\t\t\tif (!wc->w_pages[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\twait_for_stable_page(wc->w_pages[i]);\n\n\t\tif (index == target_index)\n\t\t\twc->w_target_page = wc->w_pages[i];\n\t}\nout:\n\tif (ret)\n\t\twc->w_target_locked = false;\n\treturn ret;\n}\n\n/*\n * Prepare a single cluster for write one cluster into the file.\n */\nstatic int ocfs2_write_cluster(struct address_space *mapping,\n\t\t\t       u32 *phys, unsigned int new,\n\t\t\t       unsigned int clear_unwritten,\n\t\t\t       unsigned int should_zero,\n\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t       struct ocfs2_write_ctxt *wc, u32 cpos,\n\t\t\t       loff_t user_pos, unsigned user_len)\n{\n\tint ret, i;\n\tu64 p_blkno;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_extent_tree et;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (new) {\n\t\tu32 tmp_pos;\n\n\t\t/*\n\t\t * This is safe to call with the page locks - it won't take\n\t\t * any additional semaphores or cluster locks.\n\t\t */\n\t\ttmp_pos = cpos;\n\t\tret = ocfs2_add_inode_data(OCFS2_SB(inode->i_sb), inode,\n\t\t\t\t\t   &tmp_pos, 1, !clear_unwritten,\n\t\t\t\t\t   wc->w_di_bh, wc->w_handle,\n\t\t\t\t\t   data_ac, meta_ac, NULL);\n\t\t/*\n\t\t * This shouldn't happen because we must have already\n\t\t * calculated the correct meta data allocation required. The\n\t\t * internal tree allocation code should know how to increase\n\t\t * transaction credits itself.\n\t\t *\n\t\t * If need be, we could handle -EAGAIN for a\n\t\t * RESTART_TRANS here.\n\t\t */\n\t\tmlog_bug_on_msg(ret == -EAGAIN,\n\t\t\t\t\"Inode %llu: EAGAIN return during allocation.\\n\",\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (clear_unwritten) {\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_mark_extent_written(inode, &et,\n\t\t\t\t\t\twc->w_handle, cpos, 1, *phys,\n\t\t\t\t\t\tmeta_ac, &wc->w_dealloc);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * The only reason this should fail is due to an inability to\n\t * find the extent added.\n\t */\n\tret = ocfs2_get_clusters(inode, cpos, phys, NULL, NULL);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Get physical blkno failed for inode %llu, \"\n\t\t\t    \"at logical cluster %u\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno, cpos);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(*phys == 0);\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *phys);\n\tif (!should_zero)\n\t\tp_blkno += (user_pos >> inode->i_sb->s_blocksize_bits) & (u64)(bpc - 1);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\tint tmpret;\n\n\t\t/* This is the direct io target page. */\n\t\tif (wc->w_pages[i] == NULL) {\n\t\t\tp_blkno++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmpret = ocfs2_prepare_page_for_write(inode, &p_blkno, wc,\n\t\t\t\t\t\t      wc->w_pages[i], cpos,\n\t\t\t\t\t\t      user_pos, user_len,\n\t\t\t\t\t\t      should_zero);\n\t\tif (tmpret) {\n\t\t\tmlog_errno(tmpret);\n\t\t\tif (ret == 0)\n\t\t\t\tret = tmpret;\n\t\t}\n\t}\n\n\t/*\n\t * We only have cleanup to do in case of allocating write.\n\t */\n\tif (ret && new)\n\t\tocfs2_write_failure(inode, wc, user_pos, user_len);\n\nout:\n\n\treturn ret;\n}\n\nstatic int ocfs2_write_cluster_by_desc(struct address_space *mapping,\n\t\t\t\t       struct ocfs2_alloc_context *data_ac,\n\t\t\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t       struct ocfs2_write_ctxt *wc,\n\t\t\t\t       loff_t pos, unsigned len)\n{\n\tint ret, i;\n\tloff_t cluster_off;\n\tunsigned int local_len = len;\n\tstruct ocfs2_write_cluster_desc *desc;\n\tstruct ocfs2_super *osb = OCFS2_SB(mapping->host->i_sb);\n\n\tfor (i = 0; i < wc->w_clen; i++) {\n\t\tdesc = &wc->w_desc[i];\n\n\t\t/*\n\t\t * We have to make sure that the total write passed in\n\t\t * doesn't extend past a single cluster.\n\t\t */\n\t\tlocal_len = len;\n\t\tcluster_off = pos & (osb->s_clustersize - 1);\n\t\tif ((cluster_off + local_len) > osb->s_clustersize)\n\t\t\tlocal_len = osb->s_clustersize - cluster_off;\n\n\t\tret = ocfs2_write_cluster(mapping, &desc->c_phys,\n\t\t\t\t\t  desc->c_new,\n\t\t\t\t\t  desc->c_clear_unwritten,\n\t\t\t\t\t  desc->c_needs_zero,\n\t\t\t\t\t  data_ac, meta_ac,\n\t\t\t\t\t  wc, desc->c_cpos, pos, local_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen -= local_len;\n\t\tpos += local_len;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n/*\n * ocfs2_write_end() wants to know which parts of the target page it\n * should complete the write on. It's easiest to compute them ahead of\n * time when a more complete view of the write is available.\n */\nstatic void ocfs2_set_target_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tloff_t pos, unsigned len, int alloc)\n{\n\tstruct ocfs2_write_cluster_desc *desc;\n\n\twc->w_target_from = pos & (PAGE_SIZE - 1);\n\twc->w_target_to = wc->w_target_from + len;\n\n\tif (alloc == 0)\n\t\treturn;\n\n\t/*\n\t * Allocating write - we may have different boundaries based\n\t * on page size and cluster size.\n\t *\n\t * NOTE: We can no longer compute one value from the other as\n\t * the actual write length and user provided length may be\n\t * different.\n\t */\n\n\tif (wc->w_large_pages) {\n\t\t/*\n\t\t * We only care about the 1st and last cluster within\n\t\t * our range and whether they should be zero'd or not. Either\n\t\t * value may be extended out to the start/end of a\n\t\t * newly allocated cluster.\n\t\t */\n\t\tdesc = &wc->w_desc[0];\n\t\tif (desc->c_needs_zero)\n\t\t\tocfs2_figure_cluster_boundaries(osb,\n\t\t\t\t\t\t\tdesc->c_cpos,\n\t\t\t\t\t\t\t&wc->w_target_from,\n\t\t\t\t\t\t\tNULL);\n\n\t\tdesc = &wc->w_desc[wc->w_clen - 1];\n\t\tif (desc->c_needs_zero)\n\t\t\tocfs2_figure_cluster_boundaries(osb,\n\t\t\t\t\t\t\tdesc->c_cpos,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&wc->w_target_to);\n\t} else {\n\t\twc->w_target_from = 0;\n\t\twc->w_target_to = PAGE_SIZE;\n\t}\n}\n\n/*\n * Check if this extent is marked UNWRITTEN by direct io. If so, we need not to\n * do the zero work. And should not to clear UNWRITTEN since it will be cleared\n * by the direct io procedure.\n * If this is a new extent that allocated by direct io, we should mark it in\n * the ip_unwritten_list.\n */\nstatic int ocfs2_unwritten_check(struct inode *inode,\n\t\t\t\t struct ocfs2_write_ctxt *wc,\n\t\t\t\t struct ocfs2_write_cluster_desc *desc)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL, *new = NULL;\n\tint ret = 0;\n\n\tif (!desc->c_needs_zero)\n\t\treturn 0;\n\nretry:\n\tspin_lock(&oi->ip_lock);\n\t/* Needs not to zero no metter buffer or direct. The one who is zero\n\t * the cluster is doing zero. And he will clear unwritten after all\n\t * cluster io finished. */\n\tlist_for_each_entry(ue, &oi->ip_unwritten_list, ue_ip_node) {\n\t\tif (desc->c_cpos == ue->ue_cpos) {\n\t\t\tBUG_ON(desc->c_new);\n\t\t\tdesc->c_needs_zero = 0;\n\t\t\tdesc->c_clear_unwritten = 0;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (wc->w_type != OCFS2_WRITE_DIRECT)\n\t\tgoto unlock;\n\n\tif (new == NULL) {\n\t\tspin_unlock(&oi->ip_lock);\n\t\tnew = kmalloc(sizeof(struct ocfs2_unwritten_extent),\n\t\t\t     GFP_NOFS);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry;\n\t}\n\t/* This direct write will doing zero. */\n\tnew->ue_cpos = desc->c_cpos;\n\tnew->ue_phys = desc->c_phys;\n\tdesc->c_clear_unwritten = 0;\n\tlist_add_tail(&new->ue_ip_node, &oi->ip_unwritten_list);\n\tlist_add_tail(&new->ue_node, &wc->w_unwritten_list);\n\tnew = NULL;\nunlock:\n\tspin_unlock(&oi->ip_lock);\nout:\n\tif (new)\n\t\tkfree(new);\n\treturn ret;\n}\n\n/*\n * Populate each single-cluster write descriptor in the write context\n * with information about the i/o to be done.\n *\n * Returns the number of clusters that will have to be allocated, as\n * well as a worst case estimate of the number of extent records that\n * would have to be created during a write to an unwritten region.\n */\nstatic int ocfs2_populate_write_desc(struct inode *inode,\n\t\t\t\t     struct ocfs2_write_ctxt *wc,\n\t\t\t\t     unsigned int *clusters_to_alloc,\n\t\t\t\t     unsigned int *extents_to_split)\n{\n\tint ret;\n\tstruct ocfs2_write_cluster_desc *desc;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\tu32 phys = 0;\n\tint i;\n\n\t*clusters_to_alloc = 0;\n\t*extents_to_split = 0;\n\n\tfor (i = 0; i < wc->w_clen; i++) {\n\t\tdesc = &wc->w_desc[i];\n\t\tdesc->c_cpos = wc->w_cpos + i;\n\n\t\tif (num_clusters == 0) {\n\t\t\t/*\n\t\t\t * Need to look up the next extent record.\n\t\t\t */\n\t\t\tret = ocfs2_get_clusters(inode, desc->c_cpos, &phys,\n\t\t\t\t\t\t &num_clusters, &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* We should already CoW the refcountd extent. */\n\t\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\t\t/*\n\t\t\t * Assume worst case - that we're writing in\n\t\t\t * the middle of the extent.\n\t\t\t *\n\t\t\t * We can assume that the write proceeds from\n\t\t\t * left to right, in which case the extent\n\t\t\t * insert code is smart enough to coalesce the\n\t\t\t * next splits into the previous records created.\n\t\t\t */\n\t\t\tif (ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\t\t\t*extents_to_split = *extents_to_split + 2;\n\t\t} else if (phys) {\n\t\t\t/*\n\t\t\t * Only increment phys if it doesn't describe\n\t\t\t * a hole.\n\t\t\t */\n\t\t\tphys++;\n\t\t}\n\n\t\t/*\n\t\t * If w_first_new_cpos is < UINT_MAX, we have a non-sparse\n\t\t * file that got extended.  w_first_new_cpos tells us\n\t\t * where the newly allocated clusters are so we can\n\t\t * zero them.\n\t\t */\n\t\tif (desc->c_cpos >= wc->w_first_new_cpos) {\n\t\t\tBUG_ON(phys == 0);\n\t\t\tdesc->c_needs_zero = 1;\n\t\t}\n\n\t\tdesc->c_phys = phys;\n\t\tif (phys == 0) {\n\t\t\tdesc->c_new = 1;\n\t\t\tdesc->c_needs_zero = 1;\n\t\t\tdesc->c_clear_unwritten = 1;\n\t\t\t*clusters_to_alloc = *clusters_to_alloc + 1;\n\t\t}\n\n\t\tif (ext_flags & OCFS2_EXT_UNWRITTEN) {\n\t\t\tdesc->c_clear_unwritten = 1;\n\t\t\tdesc->c_needs_zero = 1;\n\t\t}\n\n\t\tret = ocfs2_unwritten_check(inode, wc, desc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_clusters--;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int ocfs2_write_begin_inline(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct page *page;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, 0, GFP_NOFS);\n\tif (!page) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\t/*\n\t * If we don't set w_num_pages then this page won't get unlocked\n\t * and freed on cleanup of the write context.\n\t */\n\twc->w_pages[0] = wc->w_target_page = page;\n\twc->w_num_pages = 1;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))\n\t\tocfs2_set_inode_data_inline(inode, di);\n\n\tif (!PageUptodate(page)) {\n\t\tret = ocfs2_read_inline_data(inode, page, wc->w_di_bh);\n\t\tif (ret) {\n\t\t\tocfs2_commit_trans(osb, handle);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twc->w_handle = handle;\nout:\n\treturn ret;\n}\n\nint ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ocfs2_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t\t  struct inode *inode, loff_t pos,\n\t\t\t\t\t  unsigned len, struct page *mmap_page,\n\t\t\t\t\t  struct ocfs2_write_ctxt *wc)\n{\n\tint ret, written = 0;\n\tloff_t end = pos + len;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = NULL;\n\n\ttrace_ocfs2_try_to_write_inline_data((unsigned long long)oi->ip_blkno,\n\t\t\t\t\t     len, (unsigned long long)pos,\n\t\t\t\t\t     oi->ip_dyn_features);\n\n\t/*\n\t * Handle inodes which already have inline data 1st.\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (mmap_page == NULL &&\n\t\t    ocfs2_size_fits_inline_data(wc->w_di_bh, end))\n\t\t\tgoto do_inline_write;\n\n\t\t/*\n\t\t * The write won't fit - we have to give this inode an\n\t\t * inline extent list now.\n\t\t */\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, wc->w_di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check whether the inode can accept inline data.\n\t */\n\tif (oi->ip_clusters != 0 || i_size_read(inode) != 0)\n\t\treturn 0;\n\n\t/*\n\t * Check whether the write can fit.\n\t */\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\tif (mmap_page ||\n\t    end > ocfs2_max_inline_data_with_xattr(inode->i_sb, di))\n\t\treturn 0;\n\ndo_inline_write:\n\tret = ocfs2_write_begin_inline(mapping, inode, wc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This signals to the caller that the data can be written\n\t * inline.\n\t */\n\twritten = 1;\nout:\n\treturn written ? written : ret;\n}\n\n/*\n * This function only does anything for file systems which can't\n * handle sparse files.\n *\n * What we want to do here is fill in any hole between the current end\n * of allocation and the end of our write. That way the rest of the\n * write path can treat it as an non-allocating write, which has no\n * special case code for sparse/nonsparse files.\n */\nstatic int ocfs2_expand_nonsparse_inode(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *di_bh,\n\t\t\t\t\tloff_t pos, unsigned len,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc)\n{\n\tint ret;\n\tloff_t newsize = pos + len;\n\n\tBUG_ON(ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\n\tif (newsize <= i_size_read(inode))\n\t\treturn 0;\n\n\tret = ocfs2_extend_no_holes(inode, di_bh, newsize, pos);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t/* There is no wc if this is call from direct. */\n\tif (wc)\n\t\twc->w_first_new_cpos =\n\t\t\tocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\treturn ret;\n}\n\nstatic int ocfs2_zero_tail(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t   loff_t pos)\n{\n\tint ret = 0;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)));\n\tif (pos > i_size_read(inode))\n\t\tret = ocfs2_zero_extend(inode, di_bh, pos);\n\n\treturn ret;\n}\n\nint ocfs2_write_begin_nolock(struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, ocfs2_write_type_t type,\n\t\t\t     struct page **pagep, void **fsdata,\n\t\t\t     struct buffer_head *di_bh, struct page *mmap_page)\n{\n\tint ret, cluster_of_pages, credits = OCFS2_INODE_UPDATE_CREDITS;\n\tunsigned int clusters_to_alloc, extents_to_split, clusters_need = 0;\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tint try_free = 1, ret1;\n\ntry_again:\n\tret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, type, di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (ocfs2_supports_inline_data(osb)) {\n\t\tret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t     mmap_page, wc);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto success;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Direct io change i_size late, should not zero tail here. */\n\tif (type != OCFS2_WRITE_DIRECT) {\n\t\tif (ocfs2_sparse_alloc(osb))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   len, wc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_check_range_for_refcount(inode, pos, len);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tclusters_need = wc->w_clen;\n\t\tret = ocfs2_refcount_cow(inode, di_bh,\n\t\t\t\t\t wc->w_cpos, wc->w_clen, UINT_MAX);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,\n\t\t\t\t\t&extents_to_split);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tclusters_need += clusters_to_alloc;\n\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\ttrace_ocfs2_write_begin_nolock(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(long long)i_size_read(inode),\n\t\t\tle32_to_cpu(di->i_clusters),\n\t\t\tpos, len, type, mmap_page,\n\t\t\tclusters_to_alloc, extents_to_split);\n\n\t/*\n\t * We set w_target_from, w_target_to here so that\n\t * ocfs2_write_end() knows which range in the target page to\n\t * write out. An allocation requires that we write the entire\n\t * cluster range.\n\t */\n\tif (clusters_to_alloc || extents_to_split) {\n\t\t/*\n\t\t * XXX: We are stretching the limits of\n\t\t * ocfs2_lock_allocators(). It greatly over-estimates\n\t\t * the work to be done.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_lock_allocators(inode, &et,\n\t\t\t\t\t    clusters_to_alloc, extents_to_split,\n\t\t\t\t\t    &data_ac, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (data_ac)\n\t\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t    &di->id2.i_list);\n\t} else if (type == OCFS2_WRITE_DIRECT)\n\t\t/* direct write needs not to start trans if no extents alloc. */\n\t\tgoto success;\n\n\t/*\n\t * We have to zero sparse allocated clusters, unwritten extent clusters,\n\t * and non-sparse clusters we just extended.  For non-sparse writes,\n\t * we know zeros will only be needed in the first and/or last cluster.\n\t */\n\tif (wc->w_clen && (wc->w_desc[0].c_needs_zero ||\n\t\t\t   wc->w_desc[wc->w_clen - 1].c_needs_zero))\n\t\tcluster_of_pages = 1;\n\telse\n\t\tcluster_of_pages = 0;\n\n\tocfs2_set_target_boundaries(osb, wc, pos, len, cluster_of_pages);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twc->w_handle = handle;\n\n\tif (clusters_to_alloc) {\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * Fill our page array first. That way we've grabbed enough so\n\t * that we can zero and flush if we error after adding the\n\t * extent.\n\t */\n\tret = ocfs2_grab_pages_for_write(mapping, wc, wc->w_cpos, pos, len,\n\t\t\t\t\t cluster_of_pages, mmap_page);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * ocfs2_grab_pages_for_write() returns -EAGAIN if it could not lock\n\t * the target page. In this case, we exit with no error and no target\n\t * page. This will trigger the caller, page_mkwrite(), to re-try\n\t * the operation.\n\t */\n\tif (ret == -EAGAIN) {\n\t\tBUG_ON(wc->w_target_page);\n\t\tret = 0;\n\t\tgoto out_quota;\n\t}\n\n\tret = ocfs2_write_cluster_by_desc(mapping, data_ac, meta_ac, wc, pos,\n\t\t\t\t\t  len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\nsuccess:\n\tif (pagep)\n\t\t*pagep = wc->w_target_page;\n\t*fsdata = wc;\n\treturn 0;\nout_quota:\n\tif (clusters_to_alloc)\n\t\tdquot_free_space(inode,\n\t\t\t  ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\t/*\n\t * The mmapped page won't be unlocked in ocfs2_free_write_ctxt(),\n\t * even in case of error here like ENOSPC and ENOMEM. So, we need\n\t * to unlock the target page manually to prevent deadlocks when\n\t * retrying again on ENOSPC, or when returning non-VM_FAULT_LOCKED\n\t * to VM code.\n\t */\n\tif (wc->w_target_locked)\n\t\tunlock_page(mmap_page);\n\n\tocfs2_free_write_ctxt(inode, wc);\n\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\n\tif (ret == -ENOSPC && try_free) {\n\t\t/*\n\t\t * Try to free some truncate log so that we can have enough\n\t\t * clusters to allocate.\n\t\t */\n\t\ttry_free = 0;\n\n\t\tret1 = ocfs2_try_to_free_truncate_log(osb, clusters_need);\n\t\tif (ret1 == 1)\n\t\t\tgoto try_again;\n\n\t\tif (ret1 < 0)\n\t\t\tmlog_errno(ret1);\n\t}\n\n\treturn ret;\n}\n\nstatic int ocfs2_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct inode *inode = mapping->host;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Take alloc sem here to prevent concurrent lookups. That way\n\t * the mapping, zeroing and tree manipulation within\n\t * ocfs2_write() will be safe against ->readpage(). This\n\t * should also serve to lock out allocation from a shared\n\t * writeable region.\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tret = ocfs2_write_begin_nolock(mapping, pos, len, OCFS2_WRITE_BUFFER,\n\t\t\t\t       pagep, fsdata, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_fail;\n\t}\n\n\tbrelse(di_bh);\n\n\treturn 0;\n\nout_fail:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\n\n\treturn ret;\n}\n\nstatic void ocfs2_write_end_inline(struct inode *inode, loff_t pos,\n\t\t\t\t   unsigned len, unsigned *copied,\n\t\t\t\t   struct ocfs2_dinode *di,\n\t\t\t\t   struct ocfs2_write_ctxt *wc)\n{\n\tvoid *kaddr;\n\n\tif (unlikely(*copied < len)) {\n\t\tif (!PageUptodate(wc->w_target_page)) {\n\t\t\t*copied = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(wc->w_target_page);\n\tmemcpy(di->id2.i_data.id_data + pos, kaddr + pos, *copied);\n\tkunmap_atomic(kaddr);\n\n\ttrace_ocfs2_write_end_inline(\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)pos, *copied,\n\t     le16_to_cpu(di->id2.i_data.id_count),\n\t     le16_to_cpu(di->i_dyn_features));\n}\n\nint ocfs2_write_end_nolock(struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied, void *fsdata)\n{\n\tint i, ret;\n\tunsigned from, to, start = pos & (PAGE_SIZE - 1);\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_write_ctxt *wc = fsdata;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\thandle_t *handle = wc->w_handle;\n\tstruct page *tmppage;\n\n\tBUG_ON(!list_empty(&wc->w_unwritten_list));\n\n\tif (handle) {\n\t\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\twc->w_di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tcopied = ret;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tocfs2_write_end_inline(inode, pos, len, &copied, di, wc);\n\t\tgoto out_write_size;\n\t}\n\n\tif (unlikely(copied < len) && wc->w_target_page) {\n\t\tif (!PageUptodate(wc->w_target_page))\n\t\t\tcopied = 0;\n\n\t\tocfs2_zero_new_buffers(wc->w_target_page, start+copied,\n\t\t\t\t       start+len);\n\t}\n\tif (wc->w_target_page)\n\t\tflush_dcache_page(wc->w_target_page);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\t/* This is the direct io target page. */\n\t\tif (tmppage == NULL)\n\t\t\tcontinue;\n\n\t\tif (tmppage == wc->w_target_page) {\n\t\t\tfrom = wc->w_target_from;\n\t\t\tto = wc->w_target_to;\n\n\t\t\tBUG_ON(from > PAGE_SIZE ||\n\t\t\t       to > PAGE_SIZE ||\n\t\t\t       to < from);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Pages adjacent to the target (if any) imply\n\t\t\t * a hole-filling write in which case we want\n\t\t\t * to flush their entire range.\n\t\t\t */\n\t\t\tfrom = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t}\n\n\t\tif (page_has_buffers(tmppage)) {\n\t\t\tif (handle && ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_file_inode(handle, inode);\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n\nout_write_size:\n\t/* Direct io do not update i_size here. */\n\tif (wc->w_type != OCFS2_WRITE_DIRECT) {\n\t\tpos += copied;\n\t\tif (pos > i_size_read(inode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\t\tinode->i_mtime = inode->i_ctime = current_time(inode);\n\t\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\t\tdi->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\tif (handle)\n\t\tocfs2_journal_dirty(handle, wc->w_di_bh);\n\nout:\n\t/* unlock pages before dealloc since it needs acquiring j_trans_barrier\n\t * lock, or it will cause a deadlock since journal commit threads holds\n\t * this lock and will ask for the page lock when flushing the data.\n\t * put it here to preserve the unlock order.\n\t */\n\tocfs2_unlock_pages(wc);\n\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_run_deallocs(osb, &wc->w_dealloc);\n\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n\n\treturn copied;\n}\n\nstatic int ocfs2_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tint ret;\n\tstruct inode *inode = mapping->host;\n\n\tret = ocfs2_write_end_nolock(mapping, pos, len, copied, fsdata);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\n\treturn ret;\n}\n\nstruct ocfs2_dio_write_ctxt {\n\tstruct list_head\tdw_zero_list;\n\tunsigned\t\tdw_zero_count;\n\tint\t\t\tdw_orphaned;\n\tpid_t\t\t\tdw_writer_pid;\n};\n\nstatic struct ocfs2_dio_write_ctxt *\nocfs2_dio_alloc_write_ctx(struct buffer_head *bh, int *alloc)\n{\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\n\tif (bh->b_private)\n\t\treturn bh->b_private;\n\n\tdwc = kmalloc(sizeof(struct ocfs2_dio_write_ctxt), GFP_NOFS);\n\tif (dwc == NULL)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&dwc->dw_zero_list);\n\tdwc->dw_zero_count = 0;\n\tdwc->dw_orphaned = 0;\n\tdwc->dw_writer_pid = task_pid_nr(current);\n\tbh->b_private = dwc;\n\t*alloc = 1;\n\n\treturn dwc;\n}\n\nstatic void ocfs2_dio_free_write_ctx(struct inode *inode,\n\t\t\t\t     struct ocfs2_dio_write_ctxt *dwc)\n{\n\tocfs2_free_unwritten_list(inode, &dwc->dw_zero_list);\n\tkfree(dwc);\n}\n\n/*\n * TODO: Make this into a generic get_blocks function.\n *\n * From do_direct_io in direct-io.c:\n *  \"So what we do is to permit the ->get_blocks function to populate\n *   bh.b_size with the size of IO which is permitted at this offset and\n *   this i_blkbits.\"\n *\n * This function is called directly from get_more_blocks in direct-io.c.\n *\n * called like this: dio->get_blocks(dio->inode, fs_startblk,\n * \t\t\t\t\tfs_count, map_bh, dio->rw == WRITE);\n */\nstatic int ocfs2_dio_wr_get_block(struct inode *inode, sector_t iblock,\n\t\t\t       struct buffer_head *bh_result, int create)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n\t * while file size will be changed.\n\t */\n\tif (pos + total_len <= i_size_read(inode)) {\n\n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_lock_get_block(inode, iblock, bh_result, create);\n\t\tif (buffer_mapped(bh_result) &&\n\t\t    !buffer_new(bh_result) &&\n\t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n\nstatic int ocfs2_dio_end_io_write(struct inode *inode,\n\t\t\t\t  struct ocfs2_dio_write_ctxt *dwc,\n\t\t\t\t  loff_t offset,\n\t\t\t\t  ssize_t bytes)\n{\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_unwritten_extent *ue = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle = NULL;\n\tloff_t end = offset + bytes;\n\tint ret = 0, credits = 0, locked = 0;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\t/* We do clear unwritten, delete orphan, change i_size here. If neither\n\t * of these happen, we can skip all this. */\n\tif (list_empty(&dwc->dw_zero_list) &&\n\t    end <= i_size_read(inode) &&\n\t    !dwc->dw_orphaned)\n\t\tgoto out;\n\n\t/* ocfs2_file_write_iter will get i_mutex, so we need not lock if we\n\t * are in that context. */\n\tif (dwc->dw_writer_pid != task_pid_nr(current)) {\n\t\tinode_lock(inode);\n\t\tlocked = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\t/* Delete orphan before acquire i_mutex. */\n\tif (dwc->dw_orphaned) {\n\t\tBUG_ON(dwc->dw_writer_pid != task_pid_nr(current));\n\n\t\tend = end > i_size_read(inode) ? end : 0;\n\n\t\tret = ocfs2_del_inode_from_orphan(osb, inode, di_bh,\n\t\t\t\t!!end, end);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, dwc->dw_zero_count*2,\n\t\t\t\t    &data_ac, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(inode->i_sb, &di->id2.i_list);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto commit;\n\t}\n\n\tlist_for_each_entry(ue, &dwc->dw_zero_list, ue_node) {\n\t\tret = ocfs2_mark_extent_written(inode, &et, handle,\n\t\t\t\t\t\tue->ue_cpos, 1,\n\t\t\t\t\t\tue->ue_phys,\n\t\t\t\t\t\tmeta_ac, &dealloc);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (end > i_size_read(inode)) {\n\t\tret = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\ncommit:\n\tocfs2_commit_trans(osb, handle);\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tocfs2_run_deallocs(osb, &dealloc);\n\tif (locked)\n\t\tinode_unlock(inode);\n\tocfs2_dio_free_write_ctx(inode, dwc);\n\n\treturn ret;\n}\n\n/*\n * ocfs2_dio_end_io is called by the dio core when a dio is finished.  We're\n * particularly interested in the aio/dio case.  We use the rw_lock DLM lock\n * to protect io on one node from truncation on another.\n */\nstatic int ocfs2_dio_end_io(struct kiocb *iocb,\n\t\t\t    loff_t offset,\n\t\t\t    ssize_t bytes,\n\t\t\t    void *private)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tint level;\n\tint ret = 0;\n\n\t/* this io's submitter should not have unlocked this before we could */\n\tBUG_ON(!ocfs2_iocb_is_rw_locked(iocb));\n\n\tif (bytes > 0 && private)\n\t\tret = ocfs2_dio_end_io_write(inode, private, offset, bytes);\n\n\tocfs2_iocb_clear_rw_locked(iocb);\n\n\tlevel = ocfs2_iocb_rw_locked_level(iocb);\n\tocfs2_rw_unlock(inode, level);\n\treturn ret;\n}\n\nstatic ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\n\t/*\n\t * Fallback to buffered I/O if we see an inode without\n\t * extents.\n\t */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t/* Fallback to buffered I/O if we do not support append dio. */\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_lock_get_block;\n\telse\n\t\tget_block = ocfs2_dio_wr_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}\n\nconst struct address_space_operations ocfs2_aops = {\n\t.readpage\t\t= ocfs2_readpage,\n\t.readpages\t\t= ocfs2_readpages,\n\t.writepage\t\t= ocfs2_writepage,\n\t.write_begin\t\t= ocfs2_write_begin,\n\t.write_end\t\t= ocfs2_write_end,\n\t.bmap\t\t\t= ocfs2_bmap,\n\t.direct_IO\t\t= ocfs2_direct_IO,\n\t.invalidatepage\t\t= block_invalidatepage,\n\t.releasepage\t\t= ocfs2_releasepage,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n"], "filenames": ["fs/ocfs2/aops.c"], "buggy_code_start_loc": [134], "buggy_code_end_loc": [2430], "fixing_code_start_loc": [135], "fixing_code_end_loc": [2440], "type": "CWE-362", "message": "In the Linux kernel before 4.15, fs/ocfs2/aops.c omits use of a semaphore and consequently has a race condition for access to the extent tree during read operations in DIRECT mode, which allows local users to cause a denial of service (BUG) by modifying a certain e_cpos field.", "other": {"cve": {"id": "CVE-2017-18224", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-12T03:29:00.260", "lastModified": "2018-05-03T01:29:37.367", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.15, fs/ocfs2/aops.c omits use of a semaphore and consequently has a race condition for access to the extent tree during read operations in DIRECT mode, which allows local users to cause a denial of service (BUG) by modifying a certain e_cpos field."}, {"lang": "es", "value": "En el kernel de Linux, en versiones anteriores a la 4.15, fs/ocfs2/aops.c omite el uso de un sem\u00e1foro y, por consiguiente, tiene una condici\u00f3n de carrera al acceder al \u00e1rbol extent durante las operaciones de lectura en modo DIRECT. Esto permite que usuarios locales provoquen una denegaci\u00f3n de servicio (bug) modificando cierto campo e_cpos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.15", "matchCriteriaId": "A4344060-7D43-4A74-A2EF-DE9A6F8457A6"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3e4c56d41eef5595035872a2ec5a483f42e8917f", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/103353", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f"}}