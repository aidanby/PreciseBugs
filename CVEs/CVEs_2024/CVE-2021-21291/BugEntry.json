{"buggy_code": ["package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/justinas/alice\"\n\tipapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/ip\"\n\tmiddlewareapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/middleware\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\tsessionsapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/authentication/basic\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/cookies\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/encryption\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/ip\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/middleware\"\n\trequestutil \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/requests/util\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/upstream\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/providers\"\n)\n\nconst (\n\tschemeHTTPS     = \"https\"\n\tapplicationJSON = \"application/json\"\n)\n\nvar (\n\t// ErrNeedsLogin means the user should be redirected to the login page\n\tErrNeedsLogin = errors.New(\"redirect to login page\")\n\n\t// ErrAccessDenied means the user should receive a 401 Unauthorized response\n\tErrAccessDenied = errors.New(\"access denied\")\n\n\t// Used to check final redirects are not susceptible to open redirects.\n\t// Matches //, /\\ and both of these with whitespace in between (eg / / or / \\).\n\tinvalidRedirectRegex = regexp.MustCompile(`[/\\\\](?:[\\s\\v]*|\\.{1,2})[/\\\\]`)\n)\n\n// allowedRoute manages method + path based allowlists\ntype allowedRoute struct {\n\tmethod    string\n\tpathRegex *regexp.Regexp\n}\n\n// OAuthProxy is the main authentication proxy\ntype OAuthProxy struct {\n\tCookieSeed     string\n\tCookieName     string\n\tCSRFCookieName string\n\tCookieDomains  []string\n\tCookiePath     string\n\tCookieSecure   bool\n\tCookieHTTPOnly bool\n\tCookieExpire   time.Duration\n\tCookieRefresh  time.Duration\n\tCookieSameSite string\n\tValidator      func(string) bool\n\n\tRobotsPath        string\n\tSignInPath        string\n\tSignOutPath       string\n\tOAuthStartPath    string\n\tOAuthCallbackPath string\n\tAuthOnlyPath      string\n\tUserInfoPath      string\n\n\tallowedRoutes        []allowedRoute\n\tredirectURL          *url.URL // the url to receive requests at\n\twhitelistDomains     []string\n\tprovider             providers.Provider\n\tproviderNameOverride string\n\tsessionStore         sessionsapi.SessionStore\n\tProxyPrefix          string\n\tSignInMessage        string\n\tbasicAuthValidator   basic.Validator\n\tdisplayHtpasswdForm  bool\n\tserveMux             http.Handler\n\tSetXAuthRequest      bool\n\tPassBasicAuth        bool\n\tSetBasicAuth         bool\n\tSkipProviderButton   bool\n\tPassUserHeaders      bool\n\tBasicAuthPassword    string\n\tPassAccessToken      bool\n\tSetAuthorization     bool\n\tPassAuthorization    bool\n\tPreferEmailToUser    bool\n\tskipAuthPreflight    bool\n\tskipJwtBearerTokens  bool\n\ttemplates            *template.Template\n\trealClientIPParser   ipapi.RealClientIPParser\n\ttrustedIPs           *ip.NetSet\n\tBanner               string\n\tFooter               string\n\n\tsessionChain alice.Chain\n\theadersChain alice.Chain\n\tpreAuthChain alice.Chain\n}\n\n// NewOAuthProxy creates a new instance of OAuthProxy from the options provided\nfunc NewOAuthProxy(opts *options.Options, validator func(string) bool) (*OAuthProxy, error) {\n\tsessionStore, err := sessions.NewSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising session store: %v\", err)\n\t}\n\n\ttemplates := loadTemplates(opts.CustomTemplatesDir)\n\tproxyErrorHandler := upstream.NewProxyErrorHandler(templates.Lookup(\"error.html\"), opts.ProxyPrefix)\n\tupstreamProxy, err := upstream.NewProxy(opts.UpstreamServers, opts.GetSignatureData(), proxyErrorHandler)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising upstream proxy: %v\", err)\n\t}\n\n\tif opts.SkipJwtBearerTokens {\n\t\tlogger.Printf(\"Skipping JWT tokens from configured OIDC issuer: %q\", opts.OIDCIssuerURL)\n\t\tfor _, issuer := range opts.ExtraJwtIssuers {\n\t\t\tlogger.Printf(\"Skipping JWT tokens from extra JWT issuer: %q\", issuer)\n\t\t}\n\t}\n\tredirectURL := opts.GetRedirectURL()\n\tif redirectURL.Path == \"\" {\n\t\tredirectURL.Path = fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix)\n\t}\n\n\tlogger.Printf(\"OAuthProxy configured for %s Client ID: %s\", opts.GetProvider().Data().ProviderName, opts.ClientID)\n\trefresh := \"disabled\"\n\tif opts.Cookie.Refresh != time.Duration(0) {\n\t\trefresh = fmt.Sprintf(\"after %s\", opts.Cookie.Refresh)\n\t}\n\n\tlogger.Printf(\"Cookie settings: name:%s secure(https):%v httponly:%v expiry:%s domains:%s path:%s samesite:%s refresh:%s\", opts.Cookie.Name, opts.Cookie.Secure, opts.Cookie.HTTPOnly, opts.Cookie.Expire, strings.Join(opts.Cookie.Domains, \",\"), opts.Cookie.Path, opts.Cookie.SameSite, refresh)\n\n\ttrustedIPs := ip.NewNetSet()\n\tfor _, ipStr := range opts.TrustedIPs {\n\t\tif ipNet := ip.ParseIPNet(ipStr); ipNet != nil {\n\t\t\ttrustedIPs.AddIPNet(*ipNet)\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"could not parse IP network (%s)\", ipStr)\n\t\t}\n\t}\n\n\tvar basicAuthValidator basic.Validator\n\tif opts.HtpasswdFile != \"\" {\n\t\tlogger.Printf(\"using htpasswd file: %s\", opts.HtpasswdFile)\n\t\tvar err error\n\t\tbasicAuthValidator, err = basic.NewHTPasswdValidator(opts.HtpasswdFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not load htpasswdfile: %v\", err)\n\t\t}\n\t}\n\n\tallowedRoutes, err := buildRoutesAllowlist(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpreAuthChain, err := buildPreAuthChain(opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not build pre-auth chain: %v\", err)\n\t}\n\tsessionChain := buildSessionChain(opts, sessionStore, basicAuthValidator)\n\theadersChain, err := buildHeadersChain(opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not build headers chain: %v\", err)\n\t}\n\n\treturn &OAuthProxy{\n\t\tCookieName:     opts.Cookie.Name,\n\t\tCSRFCookieName: fmt.Sprintf(\"%v_%v\", opts.Cookie.Name, \"csrf\"),\n\t\tCookieSeed:     opts.Cookie.Secret,\n\t\tCookieDomains:  opts.Cookie.Domains,\n\t\tCookiePath:     opts.Cookie.Path,\n\t\tCookieSecure:   opts.Cookie.Secure,\n\t\tCookieHTTPOnly: opts.Cookie.HTTPOnly,\n\t\tCookieExpire:   opts.Cookie.Expire,\n\t\tCookieRefresh:  opts.Cookie.Refresh,\n\t\tCookieSameSite: opts.Cookie.SameSite,\n\t\tValidator:      validator,\n\n\t\tRobotsPath:        \"/robots.txt\",\n\t\tSignInPath:        fmt.Sprintf(\"%s/sign_in\", opts.ProxyPrefix),\n\t\tSignOutPath:       fmt.Sprintf(\"%s/sign_out\", opts.ProxyPrefix),\n\t\tOAuthStartPath:    fmt.Sprintf(\"%s/start\", opts.ProxyPrefix),\n\t\tOAuthCallbackPath: fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix),\n\t\tAuthOnlyPath:      fmt.Sprintf(\"%s/auth\", opts.ProxyPrefix),\n\t\tUserInfoPath:      fmt.Sprintf(\"%s/userinfo\", opts.ProxyPrefix),\n\n\t\tProxyPrefix:          opts.ProxyPrefix,\n\t\tprovider:             opts.GetProvider(),\n\t\tproviderNameOverride: opts.ProviderName,\n\t\tsessionStore:         sessionStore,\n\t\tserveMux:             upstreamProxy,\n\t\tredirectURL:          redirectURL,\n\t\tallowedRoutes:        allowedRoutes,\n\t\twhitelistDomains:     opts.WhitelistDomains,\n\t\tskipAuthPreflight:    opts.SkipAuthPreflight,\n\t\tskipJwtBearerTokens:  opts.SkipJwtBearerTokens,\n\t\trealClientIPParser:   opts.GetRealClientIPParser(),\n\t\tSkipProviderButton:   opts.SkipProviderButton,\n\t\ttemplates:            templates,\n\t\ttrustedIPs:           trustedIPs,\n\t\tBanner:               opts.Banner,\n\t\tFooter:               opts.Footer,\n\t\tSignInMessage:        buildSignInMessage(opts),\n\n\t\tbasicAuthValidator:  basicAuthValidator,\n\t\tdisplayHtpasswdForm: basicAuthValidator != nil && opts.DisplayHtpasswdForm,\n\t\tsessionChain:        sessionChain,\n\t\theadersChain:        headersChain,\n\t\tpreAuthChain:        preAuthChain,\n\t}, nil\n}\n\n// buildPreAuthChain constructs a chain that should process every request before\n// the OAuth2 Proxy authentication logic kicks in.\n// For example forcing HTTPS or health checks.\nfunc buildPreAuthChain(opts *options.Options) (alice.Chain, error) {\n\tchain := alice.New(middleware.NewScope(opts.ReverseProxy))\n\n\tif opts.ForceHTTPS {\n\t\t_, httpsPort, err := net.SplitHostPort(opts.HTTPSAddress)\n\t\tif err != nil {\n\t\t\treturn alice.Chain{}, fmt.Errorf(\"invalid HTTPS address %q: %v\", opts.HTTPAddress, err)\n\t\t}\n\t\tchain = chain.Append(middleware.NewRedirectToHTTPS(httpsPort))\n\t}\n\n\thealthCheckPaths := []string{opts.PingPath}\n\thealthCheckUserAgents := []string{opts.PingUserAgent}\n\tif opts.GCPHealthChecks {\n\t\thealthCheckPaths = append(healthCheckPaths, \"/liveness_check\", \"/readiness_check\")\n\t\thealthCheckUserAgents = append(healthCheckUserAgents, \"GoogleHC/1.0\")\n\t}\n\n\t// To silence logging of health checks, register the health check handler before\n\t// the logging handler\n\tif opts.Logging.SilencePing {\n\t\tchain = chain.Append(middleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents), LoggingHandler)\n\t} else {\n\t\tchain = chain.Append(LoggingHandler, middleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents))\n\t}\n\n\treturn chain, nil\n}\n\nfunc buildSessionChain(opts *options.Options, sessionStore sessionsapi.SessionStore, validator basic.Validator) alice.Chain {\n\tchain := alice.New()\n\n\tif opts.SkipJwtBearerTokens {\n\t\tsessionLoaders := []middlewareapi.TokenToSessionFunc{\n\t\t\topts.GetProvider().CreateSessionFromToken,\n\t\t}\n\n\t\tfor _, verifier := range opts.GetJWTBearerVerifiers() {\n\t\t\tsessionLoaders = append(sessionLoaders,\n\t\t\t\tmiddlewareapi.CreateTokenToSessionFunc(verifier.Verify))\n\t\t}\n\n\t\tchain = chain.Append(middleware.NewJwtSessionLoader(sessionLoaders))\n\t}\n\n\tif validator != nil {\n\t\tchain = chain.Append(middleware.NewBasicAuthSessionLoader(validator))\n\t}\n\n\tchain = chain.Append(middleware.NewStoredSessionLoader(&middleware.StoredSessionLoaderOptions{\n\t\tSessionStore:           sessionStore,\n\t\tRefreshPeriod:          opts.Cookie.Refresh,\n\t\tRefreshSessionIfNeeded: opts.GetProvider().RefreshSessionIfNeeded,\n\t\tValidateSessionState:   opts.GetProvider().ValidateSession,\n\t}))\n\n\treturn chain\n}\n\nfunc buildHeadersChain(opts *options.Options) (alice.Chain, error) {\n\trequestInjector, err := middleware.NewRequestHeaderInjector(opts.InjectRequestHeaders)\n\tif err != nil {\n\t\treturn alice.Chain{}, fmt.Errorf(\"error constructing request header injector: %v\", err)\n\t}\n\n\tresponseInjector, err := middleware.NewResponseHeaderInjector(opts.InjectResponseHeaders)\n\tif err != nil {\n\t\treturn alice.Chain{}, fmt.Errorf(\"error constructing request header injector: %v\", err)\n\t}\n\n\treturn alice.New(requestInjector, responseInjector), nil\n}\n\nfunc buildSignInMessage(opts *options.Options) string {\n\tvar msg string\n\tif len(opts.Banner) >= 1 {\n\t\tif opts.Banner == \"-\" {\n\t\t\tmsg = \"\"\n\t\t} else {\n\t\t\tmsg = opts.Banner\n\t\t}\n\t} else if len(opts.EmailDomains) != 0 && opts.AuthenticatedEmailsFile == \"\" {\n\t\tif len(opts.EmailDomains) > 1 {\n\t\t\tmsg = fmt.Sprintf(\"Authenticate using one of the following domains: %v\", strings.Join(opts.EmailDomains, \", \"))\n\t\t} else if opts.EmailDomains[0] != \"*\" {\n\t\t\tmsg = fmt.Sprintf(\"Authenticate using %v\", opts.EmailDomains[0])\n\t\t}\n\t}\n\treturn msg\n}\n\n// buildRoutesAllowlist builds an []allowedRoute  list from either the legacy\n// SkipAuthRegex option (paths only support) or newer SkipAuthRoutes option\n// (method=path support)\nfunc buildRoutesAllowlist(opts *options.Options) ([]allowedRoute, error) {\n\troutes := make([]allowedRoute, 0, len(opts.SkipAuthRegex)+len(opts.SkipAuthRoutes))\n\n\tfor _, path := range opts.SkipAuthRegex {\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"Skipping auth - Method: ALL | Path: %s\", path)\n\t\troutes = append(routes, allowedRoute{\n\t\t\tmethod:    \"\",\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\tfor _, methodPath := range opts.SkipAuthRoutes {\n\t\tvar (\n\t\t\tmethod string\n\t\t\tpath   string\n\t\t)\n\n\t\tparts := strings.SplitN(methodPath, \"=\", 2)\n\t\tif len(parts) == 1 {\n\t\t\tmethod = \"\"\n\t\t\tpath = parts[0]\n\t\t} else {\n\t\t\tmethod = strings.ToUpper(parts[0])\n\t\t\tpath = parts[1]\n\t\t}\n\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"Skipping auth - Method: %s | Path: %s\", method, path)\n\t\troutes = append(routes, allowedRoute{\n\t\t\tmethod:    method,\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\treturn routes, nil\n}\n\n// MakeCSRFCookie creates a cookie for CSRF\nfunc (p *OAuthProxy) MakeCSRFCookie(req *http.Request, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\treturn p.makeCookie(req, p.CSRFCookieName, value, expiration, now)\n}\n\nfunc (p *OAuthProxy) makeCookie(req *http.Request, name string, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\tcookieDomain := cookies.GetCookieDomain(req, p.CookieDomains)\n\n\tif cookieDomain != \"\" {\n\t\tdomain := requestutil.GetRequestHost(req)\n\t\tif h, _, err := net.SplitHostPort(domain); err == nil {\n\t\t\tdomain = h\n\t\t}\n\t\tif !strings.HasSuffix(domain, cookieDomain) {\n\t\t\tlogger.Errorf(\"Warning: request host is %q but using configured cookie domain of %q\", domain, cookieDomain)\n\t\t}\n\t}\n\n\treturn &http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tPath:     p.CookiePath,\n\t\tDomain:   cookieDomain,\n\t\tHttpOnly: p.CookieHTTPOnly,\n\t\tSecure:   p.CookieSecure,\n\t\tExpires:  now.Add(expiration),\n\t\tSameSite: cookies.ParseSameSite(p.CookieSameSite),\n\t}\n}\n\n// ClearCSRFCookie creates a cookie to unset the CSRF cookie stored in the user's\n// session\nfunc (p *OAuthProxy) ClearCSRFCookie(rw http.ResponseWriter, req *http.Request) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, \"\", time.Hour*-1, time.Now()))\n}\n\n// SetCSRFCookie adds a CSRF cookie to the response\nfunc (p *OAuthProxy) SetCSRFCookie(rw http.ResponseWriter, req *http.Request, val string) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, val, p.CookieExpire, time.Now()))\n}\n\n// ClearSessionCookie creates a cookie to unset the user's authentication cookie\n// stored in the user's session\nfunc (p *OAuthProxy) ClearSessionCookie(rw http.ResponseWriter, req *http.Request) error {\n\treturn p.sessionStore.Clear(rw, req)\n}\n\n// LoadCookiedSession reads the user's authentication details from the request\nfunc (p *OAuthProxy) LoadCookiedSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\treturn p.sessionStore.Load(req)\n}\n\n// SaveSession creates a new session cookie value and sets this on the response\nfunc (p *OAuthProxy) SaveSession(rw http.ResponseWriter, req *http.Request, s *sessionsapi.SessionState) error {\n\treturn p.sessionStore.Save(rw, req, s)\n}\n\n// IsValidRedirect checks whether the redirect URL is whitelisted\nfunc (p *OAuthProxy) IsValidRedirect(redirect string) bool {\n\tswitch {\n\tcase redirect == \"\":\n\t\t// The user didn't specify a redirect, should fallback to `/`\n\t\treturn false\n\tcase strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !invalidRedirectRegex.MatchString(redirect):\n\t\treturn true\n\tcase strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):\n\t\tredirectURL, err := url.Parse(redirect)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", redirect)\n\t\t\treturn false\n\t\t}\n\t\tredirectHostname := redirectURL.Hostname()\n\n\t\tfor _, domain := range p.whitelistDomains {\n\t\t\tdomainHostname, domainPort := splitHostPort(strings.TrimLeft(domain, \".\"))\n\t\t\tif domainHostname == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, domainHostname)) {\n\t\t\t\t// the domain names match, now validate the ports\n\t\t\t\t// if the whitelisted domain's port is '*', allow all ports\n\t\t\t\t// if the whitelisted domain contains a specific port, only allow that port\n\t\t\t\t// if the whitelisted domain doesn't contain a port at all, only allow empty redirect ports ie http and https\n\t\t\t\tredirectPort := redirectURL.Port()\n\t\t\t\tif (domainPort == \"*\") ||\n\t\t\t\t\t(domainPort == redirectPort) ||\n\t\t\t\t\t(domainPort == \"\" && redirectPort == \"\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", redirect)\n\t\treturn false\n\tdefault:\n\t\tlogger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", redirect)\n\t\treturn false\n\t}\n}\n\nfunc (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tp.preAuthChain.Then(http.HandlerFunc(p.serveHTTP)).ServeHTTP(rw, req)\n}\n\nfunc (p *OAuthProxy) serveHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif req.URL.Path != p.AuthOnlyPath && strings.HasPrefix(req.URL.Path, p.ProxyPrefix) {\n\t\tprepareNoCache(rw)\n\t}\n\n\tswitch path := req.URL.Path; {\n\tcase path == p.RobotsPath:\n\t\tp.RobotsTxt(rw)\n\tcase p.IsAllowedRequest(req):\n\t\tp.SkipAuthProxy(rw, req)\n\tcase path == p.SignInPath:\n\t\tp.SignIn(rw, req)\n\tcase path == p.SignOutPath:\n\t\tp.SignOut(rw, req)\n\tcase path == p.OAuthStartPath:\n\t\tp.OAuthStart(rw, req)\n\tcase path == p.OAuthCallbackPath:\n\t\tp.OAuthCallback(rw, req)\n\tcase path == p.AuthOnlyPath:\n\t\tp.AuthOnly(rw, req)\n\tcase path == p.UserInfoPath:\n\t\tp.UserInfo(rw, req)\n\tdefault:\n\t\tp.Proxy(rw, req)\n\t}\n}\n\n// RobotsTxt disallows scraping pages from the OAuthProxy\nfunc (p *OAuthProxy) RobotsTxt(rw http.ResponseWriter) {\n\t_, err := fmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")\n\tif err != nil {\n\t\tlogger.Printf(\"Error writing robots.txt: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\trw.WriteHeader(http.StatusOK)\n}\n\n// ErrorPage writes an error response\nfunc (p *OAuthProxy) ErrorPage(rw http.ResponseWriter, code int, title string, message string) {\n\trw.WriteHeader(code)\n\tt := struct {\n\t\tTitle       string\n\t\tMessage     string\n\t\tProxyPrefix string\n\t}{\n\t\tTitle:       fmt.Sprintf(\"%d %s\", code, title),\n\t\tMessage:     message,\n\t\tProxyPrefix: p.ProxyPrefix,\n\t}\n\terr := p.templates.ExecuteTemplate(rw, \"error.html\", t)\n\tif err != nil {\n\t\tlogger.Printf(\"Error rendering error.html template: %v\", err)\n\t\thttp.Error(rw, \"Internal Server Error\", http.StatusInternalServerError)\n\t}\n}\n\n// IsAllowedRequest is used to check if auth should be skipped for this request\nfunc (p *OAuthProxy) IsAllowedRequest(req *http.Request) bool {\n\tisPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"\n\treturn isPreflightRequestAllowed || p.isAllowedRoute(req) || p.isTrustedIP(req)\n}\n\n// IsAllowedRoute is used to check if the request method & path is allowed without auth\nfunc (p *OAuthProxy) isAllowedRoute(req *http.Request) bool {\n\tfor _, route := range p.allowedRoutes {\n\t\tif (route.method == \"\" || req.Method == route.method) && route.pathRegex.MatchString(req.URL.Path) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isTrustedIP is used to check if a request comes from a trusted client IP address.\nfunc (p *OAuthProxy) isTrustedIP(req *http.Request) bool {\n\tif p.trustedIPs == nil {\n\t\treturn false\n\t}\n\n\tremoteAddr, err := ip.GetClientIP(p.realClientIPParser, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining real IP for trusted IP list: %v\", err)\n\t\t// Possibly spoofed X-Real-IP header\n\t\treturn false\n\t}\n\n\tif remoteAddr == nil {\n\t\treturn false\n\t}\n\n\treturn p.trustedIPs.Has(remoteAddr)\n}\n\n// SignInPage writes the sing in template to the response\nfunc (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {\n\tprepareNoCache(rw)\n\terr := p.ClearSessionCookie(rw, req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error clearing session cookie: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\trw.WriteHeader(code)\n\n\tredirectURL, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\n\tif redirectURL == p.SignInPath {\n\t\tredirectURL = \"/\"\n\t}\n\n\t// We allow unescaped template.HTML since it is user configured options\n\t/* #nosec G203 */\n\tt := struct {\n\t\tProviderName  string\n\t\tSignInMessage template.HTML\n\t\tCustomLogin   bool\n\t\tRedirect      string\n\t\tVersion       string\n\t\tProxyPrefix   string\n\t\tFooter        template.HTML\n\t}{\n\t\tProviderName:  p.provider.Data().ProviderName,\n\t\tSignInMessage: template.HTML(p.SignInMessage),\n\t\tCustomLogin:   p.displayHtpasswdForm,\n\t\tRedirect:      redirectURL,\n\t\tVersion:       VERSION,\n\t\tProxyPrefix:   p.ProxyPrefix,\n\t\tFooter:        template.HTML(p.Footer),\n\t}\n\tif p.providerNameOverride != \"\" {\n\t\tt.ProviderName = p.providerNameOverride\n\t}\n\terr = p.templates.ExecuteTemplate(rw, \"sign_in.html\", t)\n\tif err != nil {\n\t\tlogger.Printf(\"Error rendering sign_in.html template: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t}\n}\n\n// ManualSignIn handles basic auth logins to the proxy\nfunc (p *OAuthProxy) ManualSignIn(req *http.Request) (string, bool) {\n\tif req.Method != \"POST\" || p.basicAuthValidator == nil {\n\t\treturn \"\", false\n\t}\n\tuser := req.FormValue(\"username\")\n\tpasswd := req.FormValue(\"password\")\n\tif user == \"\" {\n\t\treturn \"\", false\n\t}\n\t// check auth\n\tif p.basicAuthValidator.Validate(user, passwd) {\n\t\tlogger.PrintAuthf(user, req, logger.AuthSuccess, \"Authenticated via HtpasswdFile\")\n\t\treturn user, true\n\t}\n\tlogger.PrintAuthf(user, req, logger.AuthFailure, \"Invalid authentication via HtpasswdFile\")\n\treturn \"\", false\n}\n\n// SignIn serves a page prompting users to sign in\nfunc (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\n\tuser, ok := p.ManualSignIn(req)\n\tif ok {\n\t\tsession := &sessionsapi.SessionState{User: user}\n\t\terr = p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error saving session: %v\", err)\n\t\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, http.StatusFound)\n\t} else {\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusOK)\n\t\t}\n\t}\n}\n\n//UserInfo endpoint outputs session email and preferred username in JSON format\nfunc (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {\n\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tuserInfo := struct {\n\t\tUser              string   `json:\"user\"`\n\t\tEmail             string   `json:\"email\"`\n\t\tGroups            []string `json:\"groups,omitempty\"`\n\t\tPreferredUsername string   `json:\"preferredUsername,omitempty\"`\n\t}{\n\t\tUser:              session.User,\n\t\tEmail:             session.Email,\n\t\tGroups:            session.Groups,\n\t\tPreferredUsername: session.PreferredUsername,\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\trw.WriteHeader(http.StatusOK)\n\terr = json.NewEncoder(rw).Encode(userInfo)\n\tif err != nil {\n\t\tlogger.Printf(\"Error encoding user info: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t}\n}\n\n// SignOut sends a response to clear the authentication cookie\nfunc (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\terr = p.ClearSessionCookie(rw, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error clearing session cookie: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\thttp.Redirect(rw, req, redirect, http.StatusFound)\n}\n\n// OAuthStart starts the OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthStart(rw http.ResponseWriter, req *http.Request) {\n\tprepareNoCache(rw)\n\tnonce, err := encryption.Nonce()\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining nonce: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\tp.SetCSRFCookie(rw, req, nonce)\n\tredirect, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\tredirectURI := p.getOAuthRedirectURI(req)\n\thttp.Redirect(rw, req, p.provider.GetLoginURL(redirectURI, fmt.Sprintf(\"%v:%v\", nonce, redirect)), http.StatusFound)\n}\n\n// OAuthCallback is the OAuth2 authentication flow callback that finishes the\n// OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthCallback(rw http.ResponseWriter, req *http.Request) {\n\tremoteAddr := ip.GetClientString(p.realClientIPParser, req, true)\n\n\t// finish the oauth cycle\n\terr := req.ParseForm()\n\tif err != nil {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\terrorString := req.Form.Get(\"error\")\n\tif errorString != \"\" {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 callback: %s\", errorString)\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", errorString)\n\t\treturn\n\t}\n\n\tsession, err := p.redeemCode(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error redeeming code during OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Internal Error\")\n\t\treturn\n\t}\n\n\terr = p.enrichSessionState(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error creating session during OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Internal Error\")\n\t\treturn\n\t}\n\n\tstate := strings.SplitN(req.Form.Get(\"state\"), \":\", 2)\n\tif len(state) != 2 {\n\t\tlogger.Error(\"Error while parsing OAuth2 state: invalid length\")\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Invalid State\")\n\t\treturn\n\t}\n\tnonce := state[0]\n\tredirect := state[1]\n\tc, err := req.Cookie(p.CSRFCookieName)\n\tif err != nil {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unable to obtain CSRF cookie\")\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", err.Error())\n\t\treturn\n\t}\n\tp.ClearCSRFCookie(rw, req)\n\tif c.Value != nonce {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: CSRF token mismatch, potential attack\")\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", \"CSRF Failed\")\n\t\treturn\n\t}\n\n\tif !p.IsValidRedirect(redirect) {\n\t\tredirect = \"/\"\n\t}\n\n\t// set cookie, or deny\n\tauthorized, err := p.provider.Authorize(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error with authorization: %v\", err)\n\t}\n\tif p.Validator(session.Email) && authorized {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthSuccess, \"Authenticated via OAuth2: %s\", session)\n\t\terr := p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error saving session state for %s: %v\", remoteAddr, err)\n\t\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, http.StatusFound)\n\t} else {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unauthorized\")\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", \"Invalid Account\")\n\t}\n}\n\nfunc (p *OAuthProxy) redeemCode(req *http.Request) (*sessionsapi.SessionState, error) {\n\tcode := req.Form.Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, providers.ErrMissingCode\n\t}\n\n\tredirectURI := p.getOAuthRedirectURI(req)\n\ts, err := p.provider.Redeem(req.Context(), redirectURI, code)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}\n\nfunc (p *OAuthProxy) enrichSessionState(ctx context.Context, s *sessionsapi.SessionState) error {\n\tvar err error\n\tif s.Email == \"\" {\n\t\ts.Email, err = p.provider.GetEmailAddress(ctx, s)\n\t\tif err != nil && !errors.Is(err, providers.ErrNotImplemented) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn p.provider.EnrichSession(ctx, s)\n}\n\n// AuthOnly checks whether the user is currently logged in (both authentication\n// and optional authorization).\nfunc (p *OAuthProxy) AuthOnly(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Unauthorized cases need to return 403 to prevent infinite redirects with\n\t// subrequest architectures\n\tif !authOnlyAuthorize(req, session) {\n\t\thttp.Error(rw, http.StatusText(http.StatusForbidden), http.StatusForbidden)\n\t\treturn\n\t}\n\n\t// we are authenticated\n\tp.addHeadersForProxying(rw, session)\n\tp.headersChain.Then(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n\t\trw.WriteHeader(http.StatusAccepted)\n\t})).ServeHTTP(rw, req)\n}\n\n// SkipAuthProxy proxies allowlisted requests and skips authentication\nfunc (p *OAuthProxy) SkipAuthProxy(rw http.ResponseWriter, req *http.Request) {\n\tp.headersChain.Then(p.serveMux).ServeHTTP(rw, req)\n}\n\n// Proxy proxies the user request if the user is authenticated else it prompts\n// them to authenticate\nfunc (p *OAuthProxy) Proxy(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tswitch err {\n\tcase nil:\n\t\t// we are authenticated\n\t\tp.addHeadersForProxying(rw, session)\n\t\tp.headersChain.Then(p.serveMux).ServeHTTP(rw, req)\n\tcase ErrNeedsLogin:\n\t\t// we need to send the user to a login screen\n\t\tif isAjax(req) {\n\t\t\t// no point redirecting an AJAX request\n\t\t\tp.errorJSON(rw, http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusForbidden)\n\t\t}\n\n\tcase ErrAccessDenied:\n\t\tp.ErrorPage(rw, http.StatusUnauthorized, \"Permission Denied\", \"Unauthorized\")\n\n\tdefault:\n\t\t// unknown error\n\t\tlogger.Errorf(\"Unexpected internal error: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError,\n\t\t\t\"Internal Error\", \"Internal Error\")\n\t}\n}\n\n// See https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en\nvar noCacheHeaders = map[string]string{\n\t\"Expires\":         time.Unix(0, 0).Format(time.RFC1123),\n\t\"Cache-Control\":   \"no-cache, no-store, must-revalidate, max-age=0\",\n\t\"X-Accel-Expires\": \"0\", // https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/\n}\n\n// prepareNoCache prepares headers for preventing browser caching.\nfunc prepareNoCache(w http.ResponseWriter) {\n\t// Set NoCache headers\n\tfor k, v := range noCacheHeaders {\n\t\tw.Header().Set(k, v)\n\t}\n}\n\n// getOAuthRedirectURI returns the redirectURL that the upstream OAuth Provider will\n// redirect clients to once authenticated.\n// This is usually the OAuthProxy callback URL.\nfunc (p *OAuthProxy) getOAuthRedirectURI(req *http.Request) string {\n\t// if `p.redirectURL` already has a host, return it\n\tif p.redirectURL.Host != \"\" {\n\t\treturn p.redirectURL.String()\n\t}\n\n\t// Otherwise figure out the scheme + host from the request\n\trd := *p.redirectURL\n\trd.Host = requestutil.GetRequestHost(req)\n\trd.Scheme = requestutil.GetRequestProto(req)\n\n\t// If CookieSecure is true, return `https` no matter what\n\t// Not all reverse proxies set X-Forwarded-Proto\n\tif p.CookieSecure {\n\t\trd.Scheme = schemeHTTPS\n\t}\n\treturn rd.String()\n}\n\n// getAppRedirect determines the full URL or URI path to redirect clients to\n// once authenticated with the OAuthProxy\n// Strategy priority (first legal result is used):\n// - `rd` querysting parameter\n// - `X-Auth-Request-Redirect` header\n// - `X-Forwarded-(Proto|Host|Uri)` headers (when ReverseProxy mode is enabled)\n// - `X-Forwarded-(Proto|Host)` if `Uri` has the ProxyPath (i.e. /oauth2/*)\n// - `X-Forwarded-Uri` direct URI path (when ReverseProxy mode is enabled)\n// - `req.URL.RequestURI` if not under the ProxyPath (i.e. /oauth2/*)\n// - `/`\nfunc (p *OAuthProxy) getAppRedirect(req *http.Request) (string, error) {\n\terr := req.ParseForm()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// These redirect getter functions are strategies ordered by priority\n\t// for figuring out the redirect URL.\n\ttype redirectGetter func(req *http.Request) string\n\tfor _, rdGetter := range []redirectGetter{\n\t\tp.getRdQuerystringRedirect,\n\t\tp.getXAuthRequestRedirect,\n\t\tp.getXForwardedHeadersRedirect,\n\t\tp.getURIRedirect,\n\t} {\n\t\tredirect := rdGetter(req)\n\t\t// Call `p.IsValidRedirect` again here a final time to be safe\n\t\tif redirect != \"\" && p.IsValidRedirect(redirect) {\n\t\t\treturn redirect, nil\n\t\t}\n\t}\n\n\treturn \"/\", nil\n}\n\nfunc isForwardedRequest(req *http.Request) bool {\n\treturn requestutil.IsProxied(req) &&\n\t\treq.Host != requestutil.GetRequestHost(req)\n}\n\nfunc (p *OAuthProxy) hasProxyPrefix(path string) bool {\n\treturn strings.HasPrefix(path, fmt.Sprintf(\"%s/\", p.ProxyPrefix))\n}\n\nfunc (p *OAuthProxy) validateRedirect(redirect string, errorFormat string) string {\n\tif p.IsValidRedirect(redirect) {\n\t\treturn redirect\n\t}\n\tif redirect != \"\" {\n\t\tlogger.Errorf(errorFormat, redirect)\n\t}\n\treturn \"\"\n}\n\n// getRdQuerystringRedirect handles this getAppRedirect strategy:\n// - `rd` querysting parameter\nfunc (p *OAuthProxy) getRdQuerystringRedirect(req *http.Request) string {\n\treturn p.validateRedirect(\n\t\treq.Form.Get(\"rd\"),\n\t\t\"Invalid redirect provided in rd querystring parameter: %s\",\n\t)\n}\n\n// getXAuthRequestRedirect handles this getAppRedirect strategy:\n// - `X-Auth-Request-Redirect` Header\nfunc (p *OAuthProxy) getXAuthRequestRedirect(req *http.Request) string {\n\treturn p.validateRedirect(\n\t\treq.Header.Get(\"X-Auth-Request-Redirect\"),\n\t\t\"Invalid redirect provided in X-Auth-Request-Redirect header: %s\",\n\t)\n}\n\n// getXForwardedHeadersRedirect handles these getAppRedirect strategies:\n// - `X-Forwarded-(Proto|Host|Uri)` headers (when ReverseProxy mode is enabled)\n// - `X-Forwarded-(Proto|Host)` if `Uri` has the ProxyPath (i.e. /oauth2/*)\nfunc (p *OAuthProxy) getXForwardedHeadersRedirect(req *http.Request) string {\n\tif !isForwardedRequest(req) {\n\t\treturn \"\"\n\t}\n\n\turi := requestutil.GetRequestURI(req)\n\tif p.hasProxyPrefix(uri) {\n\t\turi = \"/\"\n\t}\n\n\tredirect := fmt.Sprintf(\n\t\t\"%s://%s%s\",\n\t\trequestutil.GetRequestProto(req),\n\t\trequestutil.GetRequestHost(req),\n\t\turi,\n\t)\n\n\treturn p.validateRedirect(redirect,\n\t\t\"Invalid redirect generated from X-Forwarded-* headers: %s\")\n}\n\n// getURIRedirect handles these getAppRedirect strategies:\n// - `X-Forwarded-Uri` direct URI path (when ReverseProxy mode is enabled)\n// - `req.URL.RequestURI` if not under the ProxyPath (i.e. /oauth2/*)\n// - `/`\nfunc (p *OAuthProxy) getURIRedirect(req *http.Request) string {\n\tredirect := p.validateRedirect(\n\t\trequestutil.GetRequestURI(req),\n\t\t\"Invalid redirect generated from X-Forwarded-Uri header: %s\",\n\t)\n\tif redirect == \"\" {\n\t\tredirect = req.URL.RequestURI()\n\t}\n\n\tif p.hasProxyPrefix(redirect) {\n\t\treturn \"/\"\n\t}\n\treturn redirect\n}\n\n// splitHostPort separates host and port. If the port is not valid, it returns\n// the entire input as host, and it doesn't check the validity of the host.\n// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.\n// *** taken from net/url, modified validOptionalPort() to accept \":*\"\nfunc splitHostPort(hostport string) (host, port string) {\n\thost = hostport\n\n\tcolon := strings.LastIndexByte(host, ':')\n\tif colon != -1 && validOptionalPort(host[colon:]) {\n\t\thost, port = host[:colon], host[colon+1:]\n\t}\n\n\tif strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {\n\t\thost = host[1 : len(host)-1]\n\t}\n\n\treturn\n}\n\n// validOptionalPort reports whether port is either an empty string\n// or matches /^:\\d*$/\n// *** taken from net/url, modified to accept \":*\"\nfunc validOptionalPort(port string) bool {\n\tif port == \"\" || port == \":*\" {\n\t\treturn true\n\t}\n\tif port[0] != ':' {\n\t\treturn false\n\t}\n\tfor _, b := range port[1:] {\n\t\tif b < '0' || b > '9' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// getAuthenticatedSession checks whether a user is authenticated and returns a session object and nil error if so\n// Returns:\n// - `nil, ErrNeedsLogin` if user needs to login.\n// - `nil, ErrAccessDenied` if the authenticated user is not authorized\n// Set-Cookie headers may be set on the response as a side-effect of calling this method.\nfunc (p *OAuthProxy) getAuthenticatedSession(rw http.ResponseWriter, req *http.Request) (*sessionsapi.SessionState, error) {\n\tvar session *sessionsapi.SessionState\n\n\tgetSession := p.sessionChain.Then(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n\t\tsession = middlewareapi.GetRequestScope(req).Session\n\t}))\n\tgetSession.ServeHTTP(rw, req)\n\n\tif session == nil {\n\t\treturn nil, ErrNeedsLogin\n\t}\n\n\tinvalidEmail := session.Email != \"\" && !p.Validator(session.Email)\n\tauthorized, err := p.provider.Authorize(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error with authorization: %v\", err)\n\t}\n\n\tif invalidEmail || !authorized {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authorization via session: removing session %s\", session)\n\t\t// Invalid session, clear it\n\t\terr := p.ClearSessionCookie(rw, req)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error clearing session cookie: %v\", err)\n\t\t}\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\treturn session, nil\n}\n\n// authOnlyAuthorize handles special authorization logic that is only done\n// on the AuthOnly endpoint for use with Nginx subrequest architectures.\n//\n// TODO (@NickMeves): This method is a placeholder to be extended but currently\n// fails the linter. Remove the nolint when functionality expands.\n//\n//nolint:S1008\nfunc authOnlyAuthorize(req *http.Request, s *sessionsapi.SessionState) bool {\n\t// Allow secondary group restrictions based on the `allowed_groups`\n\t// querystring parameter\n\tif !checkAllowedGroups(req, s) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc checkAllowedGroups(req *http.Request, s *sessionsapi.SessionState) bool {\n\tallowedGroups := extractAllowedGroups(req)\n\tif len(allowedGroups) == 0 {\n\t\treturn true\n\t}\n\n\tfor _, group := range s.Groups {\n\t\tif _, ok := allowedGroups[group]; ok {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc extractAllowedGroups(req *http.Request) map[string]struct{} {\n\tgroups := map[string]struct{}{}\n\n\tquery := req.URL.Query()\n\tfor _, allowedGroups := range query[\"allowed_groups\"] {\n\t\tfor _, group := range strings.Split(allowedGroups, \",\") {\n\t\t\tif group != \"\" {\n\t\t\t\tgroups[group] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn groups\n}\n\n// addHeadersForProxying adds the appropriate headers the request / response for proxying\nfunc (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, session *sessionsapi.SessionState) {\n\tif session.Email == \"\" {\n\t\trw.Header().Set(\"GAP-Auth\", session.User)\n\t} else {\n\t\trw.Header().Set(\"GAP-Auth\", session.Email)\n\t}\n}\n\n// isAjax checks if a request is an ajax request\nfunc isAjax(req *http.Request) bool {\n\tacceptValues := req.Header.Values(\"Accept\")\n\tconst ajaxReq = applicationJSON\n\t// Iterate over multiple Accept headers, i.e.\n\t// Accept: application/json\n\t// Accept: text/plain\n\tfor _, mimeTypes := range acceptValues {\n\t\t// Iterate over multiple mimetypes in a single header, i.e.\n\t\t// Accept: application/json, text/plain, */*\n\t\tfor _, mimeType := range strings.Split(mimeTypes, \",\") {\n\t\t\tmimeType = strings.TrimSpace(mimeType)\n\t\t\tif mimeType == ajaxReq {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// errorJSON returns the error code with an application/json mime type\nfunc (p *OAuthProxy) errorJSON(rw http.ResponseWriter, code int) {\n\trw.Header().Set(\"Content-Type\", applicationJSON)\n\trw.WriteHeader(code)\n}\n", "package main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/mbland/hmacauth\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/middleware\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\tsessionscookie \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/sessions/cookie\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/upstream\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/validation\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/providers\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\t// The rawCookieSecret is 32 bytes and the base64CookieSecret is the base64\n\t// encoded version of this.\n\trawCookieSecret    = \"secretthirtytwobytes+abcdefghijk\"\n\tbase64CookieSecret = \"c2VjcmV0dGhpcnR5dHdvYnl0ZXMrYWJjZGVmZ2hpams\"\n\tclientID           = \"3984n253984d7348dm8234yf982t\"\n\tclientSecret       = \"gv3498mfc9t23y23974dm2394dm9\"\n)\n\nfunc init() {\n\tlogger.SetFlags(logger.Lshortfile)\n}\n\nfunc TestRobotsTxt(t *testing.T) {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/robots.txt\", nil)\n\tproxy.ServeHTTP(rw, req)\n\tassert.Equal(t, 200, rw.Code)\n\tassert.Equal(t, \"User-agent: *\\nDisallow: /\", rw.Body.String())\n}\n\nfunc TestIsValidRedirect(t *testing.T) {\n\topts := baseTestOptions()\n\t// Should match domains that are exactly foo.bar and any subdomain of bar.foo\n\topts.WhitelistDomains = []string{\n\t\t\"foo.bar\",\n\t\t\".bar.foo\",\n\t\t\"port.bar:8080\",\n\t\t\".sub.port.bar:8080\",\n\t\t\"anyport.bar:*\",\n\t\t\".sub.anyport.bar:*\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tDesc, Redirect string\n\t\tExpectedResult bool\n\t}{\n\t\t{\n\t\t\tDesc:           \"noRD\",\n\t\t\tRedirect:       \"\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"singleSlash\",\n\t\t\tRedirect:       \"/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"doubleSlash\",\n\t\t\tRedirect:       \"//redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTP\",\n\t\t\tRedirect:       \"http://foo.bar/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPS\",\n\t\t\tRedirect:       \"https://foo.bar/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPSubdomain\",\n\t\t\tRedirect:       \"http://baz.foo.bar/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPSSubdomain\",\n\t\t\tRedirect:       \"https://baz.foo.bar/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPSubdomain\",\n\t\t\tRedirect:       \"http://baz.bar.foo/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPSSubdomain\",\n\t\t\tRedirect:       \"https://baz.bar.foo/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPDomain\",\n\t\t\tRedirect:       \"http://bar.foo/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTP1\",\n\t\t\tRedirect:       \"http://foo.bar.evil.corp/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPS1\",\n\t\t\tRedirect:       \"https://foo.bar.evil.corp/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTP2\",\n\t\t\tRedirect:       \"http://evil.corp/redirect?rd=foo.bar\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPS2\",\n\t\t\tRedirect:       \"https://evil.corp/redirect?rd=foo.bar\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidPort\",\n\t\t\tRedirect:       \"https://evil.corp:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidEmptyPort\",\n\t\t\tRedirect:       \"http://foo.bar:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidEmptyPortSubdomain\",\n\t\t\tRedirect:       \"http://baz.bar.foo:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validSpecificPort\",\n\t\t\tRedirect:       \"http://port.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidSpecificPort\",\n\t\t\tRedirect:       \"http://port.bar:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validSpecificPortSubdomain\",\n\t\t\tRedirect:       \"http://foo.sub.port.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidSpecificPortSubdomain\",\n\t\t\tRedirect:       \"http://foo.sub.port.bar:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPort1\",\n\t\t\tRedirect:       \"http://anyport.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPort2\",\n\t\t\tRedirect:       \"http://anyport.bar:8081/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPortSubdomain1\",\n\t\t\tRedirect:       \"http://a.sub.anyport.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPortSubdomain2\",\n\t\t\tRedirect:       \"http://a.sub.anyport.bar:8081/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirect1\",\n\t\t\tRedirect:       \"/\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectSpace1\",\n\t\t\tRedirect:       \"/ /evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectSpace2\",\n\t\t\tRedirect:       \"/ \\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTab1\",\n\t\t\tRedirect:       \"/\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTab2\",\n\t\t\tRedirect:       \"/\\t\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectVerticalTab1\",\n\t\t\tRedirect:       \"/\\v/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectVerticalTab2\",\n\t\t\tRedirect:       \"/\\v\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectNewLine1\",\n\t\t\tRedirect:       \"/\\n/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectNewLine2\",\n\t\t\tRedirect:       \"/\\n\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectCarriageReturn1\",\n\t\t\tRedirect:       \"/\\r/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectCarriageReturn2\",\n\t\t\tRedirect:       \"/\\r\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTripleTab\",\n\t\t\tRedirect:       \"/\\t\\t/\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTripleTab2\",\n\t\t\tRedirect:       \"/\\t\\t\\\\\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectQuadTab1\",\n\t\t\tRedirect:       \"/\\t\\t/\\t\\t\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectQuadTab2\",\n\t\t\tRedirect:       \"/\\t\\t\\\\\\t\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectPeriod1\",\n\t\t\tRedirect:       \"/./\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectPeriod2\",\n\t\t\tRedirect:       \"/./../../\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectDoubleTab\",\n\t\t\tRedirect:       \"/\\t/\\t\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.Desc, func(t *testing.T) {\n\t\t\tresult := proxy.IsValidRedirect(tc.Redirect)\n\n\t\t\tif result != tc.ExpectedResult {\n\t\t\t\tt.Errorf(\"expected %t got %t\", tc.ExpectedResult, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpenRedirects(t *testing.T) {\n\topts := baseTestOptions()\n\t// Should match domains that are exactly foo.bar and any subdomain of bar.foo\n\topts.WhitelistDomains = []string{\n\t\t\"foo.bar\",\n\t\t\".bar.foo\",\n\t\t\"port.bar:8080\",\n\t\t\".sub.port.bar:8080\",\n\t\t\"anyport.bar:*\",\n\t\t\".sub.anyport.bar:*\",\n\t\t\"www.whitelisteddomain.tld\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfile, err := os.Open(\"./testdata/openredirects.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func(t *testing.T) {\n\t\tif err := file.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}(t)\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\trd := scanner.Text()\n\t\tt.Run(rd, func(t *testing.T) {\n\t\t\trdUnescaped, err := url.QueryUnescape(rd)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif proxy.IsValidRedirect(rdUnescaped) {\n\t\t\t\tt.Errorf(\"Expected %q to not be valid (unescaped: %q)\", rd, rdUnescaped)\n\t\t\t}\n\t\t})\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype TestProvider struct {\n\t*providers.ProviderData\n\tEmailAddress   string\n\tValidToken     bool\n\tGroupValidator func(string) bool\n}\n\nvar _ providers.Provider = (*TestProvider)(nil)\n\nfunc NewTestProvider(providerURL *url.URL, emailAddress string) *TestProvider {\n\treturn &TestProvider{\n\t\tProviderData: &providers.ProviderData{\n\t\t\tProviderName: \"Test Provider\",\n\t\t\tLoginURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/oauth/authorize\",\n\t\t\t},\n\t\t\tRedeemURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/oauth/token\",\n\t\t\t},\n\t\t\tProfileURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/api/v1/profile\",\n\t\t\t},\n\t\t\tScope: \"profile.email\",\n\t\t},\n\t\tEmailAddress: emailAddress,\n\t\tGroupValidator: func(s string) bool {\n\t\t\treturn true\n\t\t},\n\t}\n}\n\nfunc (tp *TestProvider) GetEmailAddress(_ context.Context, _ *sessions.SessionState) (string, error) {\n\treturn tp.EmailAddress, nil\n}\n\nfunc (tp *TestProvider) ValidateSession(_ context.Context, _ *sessions.SessionState) bool {\n\treturn tp.ValidToken\n}\n\nfunc Test_redeemCode(t *testing.T) {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t_, err = proxy.redeemCode(req)\n\tassert.Equal(t, providers.ErrMissingCode, err)\n}\n\nfunc Test_enrichSession(t *testing.T) {\n\tconst (\n\t\tsessionUser   = \"Mr Session\"\n\t\tsessionEmail  = \"session@example.com\"\n\t\tproviderEmail = \"provider@example.com\"\n\t)\n\n\ttestCases := map[string]struct {\n\t\tsession       *sessions.SessionState\n\t\texpectedUser  string\n\t\texpectedEmail string\n\t}{\n\t\t\"Session already has enrichable fields\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:  sessionUser,\n\t\t\t\tEmail: sessionEmail,\n\t\t\t},\n\t\t\texpectedUser:  sessionUser,\n\t\t\texpectedEmail: sessionEmail,\n\t\t},\n\t\t\"Session is missing Email and GetEmailAddress is implemented\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser: sessionUser,\n\t\t\t},\n\t\t\texpectedUser:  sessionUser,\n\t\t\texpectedEmail: providerEmail,\n\t\t},\n\t\t\"Session is missing User and GetUserName is not implemented\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tEmail: sessionEmail,\n\t\t\t},\n\t\t\texpectedUser:  \"\",\n\t\t\texpectedEmail: sessionEmail,\n\t\t},\n\t}\n\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\topts := baseTestOptions()\n\t\t\terr := validation.Validate(opts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\t// intentionally set after validation.Validate(opts) since it will clobber\n\t\t\t// our TestProvider and call `providers.New` defaulting to `providers.GoogleProvider`\n\t\t\topts.SetProvider(NewTestProvider(&url.URL{Host: \"www.example.com\"}, providerEmail))\n\t\t\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = proxy.enrichSessionState(context.Background(), tc.session)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectedUser, tc.session.User)\n\t\t\tassert.Equal(t, tc.expectedEmail, tc.session.Email)\n\t\t})\n\t}\n}\n\nfunc TestBasicAuthPassword(t *testing.T) {\n\tproviderServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlogger.Printf(\"%#v\", r)\n\t\tvar payload string\n\t\tswitch r.URL.Path {\n\t\tcase \"/oauth/token\":\n\t\t\tpayload = `{\"access_token\": \"my_auth_token\"}`\n\t\tdefault:\n\t\t\tpayload = r.Header.Get(\"Authorization\")\n\t\t\tif payload == \"\" {\n\t\t\t\tpayload = \"No Authorization header found.\"\n\t\t\t}\n\t\t}\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(payload))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\n\tbasicAuthPassword := \"This is a secure password\"\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   providerServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  providerServer.URL,\n\t\t},\n\t}\n\n\topts.Cookie.Secure = false\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(basicAuthPassword),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproviderURL, _ := url.Parse(providerServer.URL)\n\tconst emailAddress = \"john.doe@example.com\"\n\n\topts.SetProvider(NewTestProvider(providerURL, emailAddress))\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Save the required session\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\terr = proxy.sessionStore.Save(rw, req, &sessions.SessionState{\n\t\tEmail: emailAddress,\n\t})\n\tassert.NoError(t, err)\n\n\t// Extract the cookie value to inject into the test request\n\tcookie := rw.Header().Values(\"Set-Cookie\")[0]\n\n\treq, _ = http.NewRequest(\"GET\", \"/\", nil)\n\treq.Header.Set(\"Cookie\", cookie)\n\trw = httptest.NewRecorder()\n\tproxy.ServeHTTP(rw, req)\n\n\t// The username in the basic auth credentials is expected to be equal to the email address from the\n\t// auth response, so we use the same variable here.\n\texpectedHeader := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(emailAddress+\":\"+basicAuthPassword))\n\tassert.Equal(t, expectedHeader, rw.Body.String())\n\tproviderServer.Close()\n}\n\nfunc TestPassGroupsHeadersWithGroups(t *testing.T) {\n\topts := baseTestOptions()\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Forwarded-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tconst emailAddress = \"john.doe@example.com\"\n\tconst userName = \"9fcab5c9b889a557\"\n\n\tgroups := []string{\"a\", \"b\"}\n\tcreated := time.Now()\n\tsession := &sessions.SessionState{\n\t\tUser:        userName,\n\t\tGroups:      groups,\n\t\tEmail:       emailAddress,\n\t\tAccessToken: \"oauth_token\",\n\t\tCreatedAt:   &created,\n\t}\n\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tassert.NoError(t, err)\n\n\t// Save the required session\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\terr = proxy.sessionStore.Save(rw, req, session)\n\tassert.NoError(t, err)\n\n\t// Extract the cookie value to inject into the test request\n\tcookie := rw.Header().Values(\"Set-Cookie\")[0]\n\n\treq, _ = http.NewRequest(\"GET\", \"/\", nil)\n\treq.Header.Set(\"Cookie\", cookie)\n\trw = httptest.NewRecorder()\n\tproxy.ServeHTTP(rw, req)\n\n\tassert.Equal(t, []string{\"a,b\"}, req.Header[\"X-Forwarded-Groups\"])\n}\n\ntype PassAccessTokenTest struct {\n\tproviderServer *httptest.Server\n\tproxy          *OAuthProxy\n\topts           *options.Options\n}\n\ntype PassAccessTokenTestOptions struct {\n\tPassAccessToken bool\n\tProxyUpstream   options.Upstream\n}\n\nfunc NewPassAccessTokenTest(opts PassAccessTokenTestOptions) (*PassAccessTokenTest, error) {\n\tpatt := &PassAccessTokenTest{}\n\n\tpatt.providerServer = httptest.NewServer(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tvar payload string\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/oauth/token\":\n\t\t\t\tpayload = `{\"access_token\": \"my_auth_token\"}`\n\t\t\tdefault:\n\t\t\t\tpayload = r.Header.Get(\"X-Forwarded-Access-Token\")\n\t\t\t\tif payload == \"\" {\n\t\t\t\t\tpayload = \"No access token found.\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.WriteHeader(200)\n\t\t\t_, err := w.Write([]byte(payload))\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}))\n\n\tpatt.opts = baseTestOptions()\n\tpatt.opts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   patt.providerServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  patt.providerServer.URL,\n\t\t},\n\t}\n\tif opts.ProxyUpstream.ID != \"\" {\n\t\tpatt.opts.UpstreamServers = append(patt.opts.UpstreamServers, opts.ProxyUpstream)\n\t}\n\n\tpatt.opts.Cookie.Secure = false\n\tif opts.PassAccessToken {\n\t\tpatt.opts.InjectRequestHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-Access-Token\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"access_token\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\terr := validation.Validate(patt.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproviderURL, _ := url.Parse(patt.providerServer.URL)\n\tconst emailAddress = \"michael.bland@gsa.gov\"\n\n\tpatt.opts.SetProvider(NewTestProvider(providerURL, emailAddress))\n\tpatt.proxy, err = NewOAuthProxy(patt.opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn patt, nil\n}\n\nfunc (patTest *PassAccessTokenTest) Close() {\n\tpatTest.providerServer.Close()\n}\n\nfunc (patTest *PassAccessTokenTest) getCallbackEndpoint() (httpCode int,\n\tcookie string) {\n\trw := httptest.NewRecorder()\n\treq, err := http.NewRequest(\"GET\", \"/oauth2/callback?code=callback_code&state=nonce:\",\n\t\tstrings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, \"\"\n\t}\n\treq.AddCookie(patTest.proxy.MakeCSRFCookie(req, \"nonce\", time.Hour, time.Now()))\n\tpatTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Header().Values(\"Set-Cookie\")[1]\n}\n\n// getEndpointWithCookie makes a requests againt the oauthproxy with passed requestPath\n// and cookie and returns body and status code.\nfunc (patTest *PassAccessTokenTest) getEndpointWithCookie(cookie string, endpoint string) (httpCode int, accessToken string) {\n\tcookieName := patTest.proxy.CookieName\n\tvar value string\n\tkeyPrefix := cookieName + \"=\"\n\n\tfor _, field := range strings.Split(cookie, \"; \") {\n\t\tvalue = strings.TrimPrefix(field, keyPrefix)\n\t\tif value != field {\n\t\t\tbreak\n\t\t} else {\n\t\t\tvalue = \"\"\n\t\t}\n\t}\n\tif value == \"\" {\n\t\treturn 0, \"\"\n\t}\n\n\treq, err := http.NewRequest(\"GET\", endpoint, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, \"\"\n\t}\n\treq.AddCookie(&http.Cookie{\n\t\tName:     cookieName,\n\t\tValue:    value,\n\t\tPath:     \"/\",\n\t\tExpires:  time.Now().Add(time.Duration(24)),\n\t\tHttpOnly: true,\n\t})\n\n\trw := httptest.NewRecorder()\n\tpatTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Body.String()\n}\n\nfunc TestForwardAccessTokenUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotNil(t, cookie)\n\n\t// Now we make a regular request; the access_token from the cookie is\n\t// forwarded as the \"X-Forwarded-Access-Token\" header. The token is\n\t// read by the test provider server and written in the response body.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"my_auth_token\", payload)\n}\n\nfunc TestStaticProxyUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: true,\n\t\tProxyUpstream: options.Upstream{\n\t\t\tID:     \"static-proxy\",\n\t\t\tPath:   \"/static-proxy\",\n\t\t\tStatic: true,\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotEqual(t, nil, cookie)\n\n\t// Now we make a regular request against the upstream proxy; And validate\n\t// the returned status code through the static proxy.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/static-proxy\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"Authenticated\", payload)\n}\n\nfunc TestDoNotForwardAccessTokenUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: false,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotEqual(t, nil, cookie)\n\n\t// Now we make a regular request, but the access token header should\n\t// not be present.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"No access token found.\", payload)\n}\n\ntype SignInPageTest struct {\n\topts                 *options.Options\n\tproxy                *OAuthProxy\n\tsignInRegexp         *regexp.Regexp\n\tsignInProviderRegexp *regexp.Regexp\n}\n\nconst signInRedirectPattern = `<input type=\"hidden\" name=\"rd\" value=\"(.*)\">`\nconst signInSkipProvider = `>Found<`\n\nfunc NewSignInPageTest(skipProvider bool) (*SignInPageTest, error) {\n\tvar sipTest SignInPageTest\n\n\tsipTest.opts = baseTestOptions()\n\tsipTest.opts.SkipProviderButton = skipProvider\n\terr := validation.Validate(sipTest.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsipTest.proxy, err = NewOAuthProxy(sipTest.opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsipTest.signInRegexp = regexp.MustCompile(signInRedirectPattern)\n\tsipTest.signInProviderRegexp = regexp.MustCompile(signInSkipProvider)\n\n\treturn &sipTest, nil\n}\n\nfunc (sipTest *SignInPageTest) GetEndpoint(endpoint string) (int, string) {\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", endpoint, strings.NewReader(\"\"))\n\tsipTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Body.String()\n}\n\nfunc TestSignInPageIncludesTargetRedirect(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst endpoint = \"/some/random/endpoint\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 403, code)\n\n\tmatch := sipTest.signInRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInRedirectPattern + \"\\nBody:\\n\" + body)\n\t}\n\tif match[1] != endpoint {\n\t\tt.Fatal(`expected redirect to \"` + endpoint +\n\t\t\t`\", but was \"` + match[1] + `\"`)\n\t}\n}\n\nfunc TestSignInPageDirectAccessRedirectsToRoot(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, body := sipTest.GetEndpoint(\"/oauth2/sign_in\")\n\tassert.Equal(t, 200, code)\n\n\tmatch := sipTest.signInRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInRedirectPattern + \"\\nBody:\\n\" + body)\n\t}\n\tif match[1] != \"/\" {\n\t\tt.Fatal(`expected redirect to \"/\", but was \"` + match[1] + `\"`)\n\t}\n}\n\nfunc TestSignInPageSkipProvider(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tendpoint := \"/some/random/endpoint\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 302, code)\n\n\tmatch := sipTest.signInProviderRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInSkipProvider + \"\\nBody:\\n\" + body)\n\t}\n}\n\nfunc TestSignInPageSkipProviderDirect(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tendpoint := \"/sign_in\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 302, code)\n\n\tmatch := sipTest.signInProviderRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInSkipProvider + \"\\nBody:\\n\" + body)\n\t}\n}\n\ntype ProcessCookieTest struct {\n\topts         *options.Options\n\tproxy        *OAuthProxy\n\trw           *httptest.ResponseRecorder\n\treq          *http.Request\n\tvalidateUser bool\n}\n\ntype ProcessCookieTestOpts struct {\n\tproviderValidateCookieResponse bool\n}\n\ntype OptionsModifier func(*options.Options)\n\nfunc NewProcessCookieTest(opts ProcessCookieTestOpts, modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tfor _, modifier := range modifiers {\n\t\tmodifier(pcTest.opts)\n\t}\n\t// First, set the CookieRefresh option so proxy.AesCipher is created,\n\t// needed to encrypt the access_token.\n\tpcTest.opts.Cookie.Refresh = time.Hour\n\terr := validation.Validate(pcTest.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   opts.providerValidateCookieResponse,\n\t}\n\tpcTest.proxy.provider.(*TestProvider).SetAllowedGroups(pcTest.opts.AllowedGroups)\n\n\t// Now, zero-out proxy.CookieRefresh for the cases that don't involve\n\t// access_token validation.\n\tpcTest.proxy.CookieRefresh = time.Duration(0)\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\", \"/\", strings.NewReader(\"\"))\n\tpcTest.validateUser = true\n\treturn &pcTest, nil\n}\n\nfunc NewProcessCookieTestWithDefaults() (*ProcessCookieTest, error) {\n\treturn NewProcessCookieTest(ProcessCookieTestOpts{\n\t\tproviderValidateCookieResponse: true,\n\t})\n}\n\nfunc NewProcessCookieTestWithOptionsModifiers(modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\treturn NewProcessCookieTest(ProcessCookieTestOpts{\n\t\tproviderValidateCookieResponse: true,\n\t}, modifiers...)\n}\n\nfunc (p *ProcessCookieTest) SaveSession(s *sessions.SessionState) error {\n\terr := p.proxy.SaveSession(p.rw, p.req, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, cookie := range p.rw.Result().Cookies() {\n\t\tp.req.AddCookie(cookie)\n\t}\n\treturn nil\n}\n\nfunc (p *ProcessCookieTest) LoadCookiedSession() (*sessions.SessionState, error) {\n\treturn p.proxy.LoadCookiedSession(p.req)\n}\n\nfunc TestLoadCookiedSession(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{Email: \"john.doe@example.com\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassert.Equal(t, startSession.Email, session.Email)\n\tassert.Equal(t, \"\", session.User)\n\tassert.Equal(t, startSession.AccessToken, session.AccessToken)\n}\n\nfunc TestProcessCookieNoCookieError(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.Error(t, err, \"cookie \\\"_oauth2_proxy\\\" not present\")\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session. got %#v\", session)\n\t}\n}\n\nfunc TestProcessCookieRefreshNotSet(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(23) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(-2) * time.Hour)\n\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.Equal(t, nil, err)\n\tif session.Age() < time.Duration(-2)*time.Hour {\n\t\tt.Errorf(\"cookie too young %v\", session.Age())\n\t}\n\tassert.Equal(t, startSession.Email, session.Email)\n}\n\nfunc TestProcessCookieFailIfCookieExpired(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.NotEqual(t, nil, err)\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session %#v\", session)\n\t}\n}\n\nfunc TestProcessCookieFailIfRefreshSetAndCookieExpired(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.CookieRefresh = time.Hour\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.NotEqual(t, nil, err)\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session %#v\", session)\n\t}\n}\n\nfunc NewUserInfoEndpointTest() (*ProcessCookieTest, error) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/userinfo\", nil)\n\treturn pcTest, nil\n}\n\nfunc TestUserInfoEndpointAccepted(t *testing.T) {\n\ttestCases := []struct {\n\t\tname             string\n\t\tsession          *sessions.SessionState\n\t\texpectedResponse string\n\t}{\n\t\t{\n\t\t\tname: \"Full session\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:        \"john.doe\",\n\t\t\t\tEmail:       \"john.doe@example.com\",\n\t\t\t\tGroups:      []string{\"example\", \"groups\"},\n\t\t\t\tAccessToken: \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"Minimal session\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:   \"john.doe\",\n\t\t\t\tEmail:  \"john.doe@example.com\",\n\t\t\t\tGroups: []string{\"example\", \"groups\"},\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"No groups\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:        \"john.doe\",\n\t\t\t\tEmail:       \"john.doe@example.com\",\n\t\t\t\tAccessToken: \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"With Preferred Username\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:              \"john.doe\",\n\t\t\t\tPreferredUsername: \"john\",\n\t\t\t\tEmail:             \"john.doe@example.com\",\n\t\t\t\tGroups:            []string{\"example\", \"groups\"},\n\t\t\t\tAccessToken:       \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"],\\\"preferredUsername\\\":\\\"john\\\"}\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest, err := NewUserInfoEndpointTest()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terr = test.SaveSession(tc.session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\t\t\tassert.Equal(t, http.StatusOK, test.rw.Code)\n\t\t\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\t\t\tassert.Equal(t, tc.expectedResponse, string(bodyBytes))\n\t\t})\n\t}\n}\n\nfunc TestUserInfoEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {\n\ttest, err := NewUserInfoEndpointTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n}\n\nfunc NewAuthOnlyEndpointTest(querystring string, modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(modifiers...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.req, _ = http.NewRequest(\n\t\t\"GET\",\n\t\tfmt.Sprintf(\"%s/auth%s\", pcTest.opts.ProxyPrefix, querystring),\n\t\tnil)\n\treturn pcTest, nil\n}\n\nfunc TestAuthOnlyEndpointAccepted(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusAccepted, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnExpiration(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\", func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnEmailValidationFailure(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\ttest.validateUser = false\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointSetXAuthRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tpcTest.opts.AllowedGroups = []string{\"oauth_groups\"}\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/auth\", nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Groups: []string{\"oauth_groups\"}, Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Get(\"X-Auth-Request-User\"))\n\tassert.Equal(t, startSession.Groups, pcTest.rw.Header().Values(\"X-Auth-Request-Groups\"))\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Get(\"X-Auth-Request-Email\"))\n}\n\nfunc TestAuthOnlyEndpointSetBasicAuthTrueRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(\"This is a secure password\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/auth\", nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Values(\"X-Auth-Request-User\")[0])\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Values(\"X-Auth-Request-Email\")[0])\n\texpectedHeader := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"oauth_user:This is a secure password\"))\n\tassert.Equal(t, expectedHeader, pcTest.rw.Header().Values(\"Authorization\")[0])\n}\n\nfunc TestAuthOnlyEndpointSetBasicAuthFalseRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/auth\", nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Values(\"X-Auth-Request-User\")[0])\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Values(\"X-Auth-Request-Email\")[0])\n\tassert.Equal(t, 0, len(pcTest.rw.Header().Values(\"Authorization\")), \"should not have Authorization header entries\")\n}\n\nfunc TestAuthSkippedForPreflightRequests(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"response\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\topts.SkipAuthPreflight = true\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tupstreamURL, _ := url.Parse(upstreamServer.URL)\n\topts.SetProvider(NewTestProvider(upstreamURL, \"\"))\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return false })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"OPTIONS\", \"/preflight-request\", nil)\n\tproxy.ServeHTTP(rw, req)\n\n\tassert.Equal(t, 200, rw.Code)\n\tassert.Equal(t, \"response\", rw.Body.String())\n}\n\ntype SignatureAuthenticator struct {\n\tauth hmacauth.HmacAuth\n}\n\nfunc (v *SignatureAuthenticator) Authenticate(w http.ResponseWriter, r *http.Request) {\n\tresult, headerSig, computedSig := v.auth.AuthenticateRequest(r)\n\n\tvar msg string\n\tswitch result {\n\tcase hmacauth.ResultNoSignature:\n\t\tmsg = \"no signature received\"\n\tcase hmacauth.ResultMatch:\n\t\tmsg = \"signatures match\"\n\tcase hmacauth.ResultMismatch:\n\t\tmsg = fmt.Sprintf(\n\t\t\t\"signatures do not match:\\n  received: %s\\n  computed: %s\",\n\t\t\theaderSig,\n\t\t\tcomputedSig)\n\tdefault:\n\t\tpanic(\"unknown result value: \" + result.String())\n\t}\n\n\t_, err := w.Write([]byte(msg))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\ntype SignatureTest struct {\n\topts          *options.Options\n\tupstream      *httptest.Server\n\tupstreamHost  string\n\tprovider      *httptest.Server\n\theader        http.Header\n\trw            *httptest.ResponseRecorder\n\tauthenticator *SignatureAuthenticator\n}\n\nfunc NewSignatureTest() (*SignatureTest, error) {\n\topts := baseTestOptions()\n\topts.EmailDomains = []string{\"acm.org\"}\n\n\tauthenticator := &SignatureAuthenticator{}\n\tupstreamServer := httptest.NewServer(\n\t\thttp.HandlerFunc(authenticator.Authenticate))\n\tupstreamURL, err := url.Parse(upstreamServer.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\n\tproviderHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := w.Write([]byte(`{\"access_token\": \"my_auth_token\"}`))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tprovider := httptest.NewServer(http.HandlerFunc(providerHandler))\n\tproviderURL, err := url.Parse(provider.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts.SetProvider(NewTestProvider(providerURL, \"mbland@acm.org\"))\n\n\treturn &SignatureTest{\n\t\topts,\n\t\tupstreamServer,\n\t\tupstreamURL.Host,\n\t\tprovider,\n\t\tmake(http.Header),\n\t\thttptest.NewRecorder(),\n\t\tauthenticator,\n\t}, nil\n}\n\nfunc (st *SignatureTest) Close() {\n\tst.provider.Close()\n\tst.upstream.Close()\n}\n\n// fakeNetConn simulates an http.Request.Body buffer that will be consumed\n// when it is read by the hmacauth.HmacAuth if not handled properly. See:\n//   https://github.com/18F/hmacauth/pull/4\ntype fakeNetConn struct {\n\treqBody string\n}\n\nfunc (fnc *fakeNetConn) Read(p []byte) (n int, err error) {\n\tif bodyLen := len(fnc.reqBody); bodyLen != 0 {\n\t\tcopy(p, fnc.reqBody)\n\t\tfnc.reqBody = \"\"\n\t\treturn bodyLen, io.EOF\n\t}\n\treturn 0, io.EOF\n}\n\nfunc (st *SignatureTest) MakeRequestWithExpectedKey(method, body, key string) error {\n\terr := validation.Validate(st.opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy, err := NewOAuthProxy(st.opts, func(email string) bool { return true })\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar bodyBuf io.ReadCloser\n\tif body != \"\" {\n\t\tbodyBuf = ioutil.NopCloser(&fakeNetConn{reqBody: body})\n\t}\n\treq := httptest.NewRequest(method, \"/foo/bar\", bodyBuf)\n\treq.Header = st.header\n\n\tstate := &sessions.SessionState{\n\t\tEmail: \"mbland@acm.org\", AccessToken: \"my_access_token\"}\n\terr = proxy.SaveSession(st.rw, req, state)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, c := range st.rw.Result().Cookies() {\n\t\treq.AddCookie(c)\n\t}\n\t// This is used by the upstream to validate the signature.\n\tst.authenticator.auth = hmacauth.NewHmacAuth(\n\t\tcrypto.SHA1, []byte(key), upstream.SignatureHeader, upstream.SignatureHeaders)\n\tproxy.ServeHTTP(st.rw, req)\n\n\treturn nil\n}\n\nfunc TestRequestSignature(t *testing.T) {\n\ttestCases := map[string]struct {\n\t\tmethod string\n\t\tbody   string\n\t\tkey    string\n\t\tresp   string\n\t}{\n\t\t\"No request signature\": {\n\t\t\tmethod: \"GET\",\n\t\t\tbody:   \"\",\n\t\t\tkey:    \"\",\n\t\t\tresp:   \"no signature received\",\n\t\t},\n\t\t\"Get request\": {\n\t\t\tmethod: \"GET\",\n\t\t\tbody:   \"\",\n\t\t\tkey:    \"7d9e1aa87a5954e6f9fc59266b3af9d7c35fda2d\",\n\t\t\tresp:   \"signatures match\",\n\t\t},\n\t\t\"Post request\": {\n\t\t\tmethod: \"POST\",\n\t\t\tbody:   `{ \"hello\": \"world!\" }`,\n\t\t\tkey:    \"d90df39e2d19282840252612dd7c81421a372f61\",\n\t\t\tresp:   \"signatures match\",\n\t\t},\n\t}\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tst, err := NewSignatureTest()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tt.Cleanup(st.Close)\n\t\t\tif tc.key != \"\" {\n\t\t\t\tst.opts.SignatureKey = fmt.Sprintf(\"sha1:%s\", tc.key)\n\t\t\t}\n\t\t\terr = st.MakeRequestWithExpectedKey(tc.method, tc.body, tc.key)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, 200, st.rw.Code)\n\t\t\tassert.Equal(t, tc.resp, st.rw.Body.String())\n\t\t})\n\t}\n}\n\nfunc Test_getAppRedirect(t *testing.T) {\n\topts := baseTestOptions()\n\topts.WhitelistDomains = append(opts.WhitelistDomains, \".example.com\", \".example.com:8443\")\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\trequire.NotEmpty(t, opts.ProxyPrefix)\n\tproxy, err := NewOAuthProxy(opts, func(s string) bool { return false })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\tname             string\n\t\turl              string\n\t\theaders          map[string]string\n\t\treverseProxy     bool\n\t\texpectedRedirect string\n\t}{\n\t\t{\n\t\t\tname:             \"request outside of ProxyPrefix redirects to original URL\",\n\t\t\turl:              \"/foo/bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"request with query preserves query\",\n\t\t\turl:              \"/foo?bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"request under ProxyPrefix redirects to root\",\n\t\t\turl:              proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request outside of ProxyPrefix redirects to proxied URL\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"non-proxied request with spoofed proxy headers wouldn't redirect\",\n\t\t\turl:  \"https://oauth.example.com/foo?bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request under ProxyPrefix redirects to root\",\n\t\t\turl:  \"https://oauth.example.com\" + proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with port under ProxyPrefix redirects to root\",\n\t\t\turl:  \"https://oauth.example.com\" + proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com:8443\",\n\t\t\t\t\"X-Forwarded-Uri\":   proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com:8443/\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with missing uri header would still redirect to desired redirect\",\n\t\t\turl:  \"https://oauth.example.com/foo?bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"request with headers proxy not being set (and reverse proxy enabled) would still redirect to desired redirect\",\n\t\t\turl:              \"https://oauth.example.com/foo?bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with X-Auth-Request-Redirect being set outside of ProxyPrefix redirects to proxied URL\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Auth-Request-Redirect\": \"https://a-service.example.com/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"proxied request with rd query string redirects to proxied URL\",\n\t\t\turl:              \"https://oauth.example.com/foo/bar?rd=https%3A%2F%2Fa%2Dservice%2Eexample%2Ecom%2Ffoo%2Fbar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with rd query string and all headers set (and reverse proxy not enabled) redirects to proxied URL on rd query string\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar?rd=https%3A%2F%2Fa%2Dservice%2Eexample%2Ecom%2Ffoo%2Fjazz\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Auth-Request-Redirect\": \"https://a-service.example.com/foo/baz\",\n\t\t\t\t\"X-Forwarded-Proto\":       \"http\",\n\t\t\t\t\"X-Forwarded-Host\":        \"another-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":         \"/seasons/greetings\",\n\t\t\t},\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/jazz\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with rd query string and some headers set redirects to proxied URL on rd query string\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar?rd=https%3A%2F%2Fa%2Dservice%2Eexample%2Ecom%2Ffoo%2Fbaz\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"another-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   \"/seasons/greetings\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/baz\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\treq, _ := http.NewRequest(\"GET\", tt.url, nil)\n\t\t\tfor header, value := range tt.headers {\n\t\t\t\tif value != \"\" {\n\t\t\t\t\treq.Header.Add(header, value)\n\t\t\t\t}\n\t\t\t}\n\t\t\treq = middleware.AddRequestScope(req, &middleware.RequestScope{\n\t\t\t\tReverseProxy: tt.reverseProxy,\n\t\t\t})\n\t\t\tredirect, err := proxy.getAppRedirect(req)\n\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tt.expectedRedirect, redirect)\n\t\t})\n\t}\n}\n\ntype ajaxRequestTest struct {\n\topts  *options.Options\n\tproxy *OAuthProxy\n}\n\nfunc newAjaxRequestTest() (*ajaxRequestTest, error) {\n\ttest := &ajaxRequestTest{}\n\ttest.opts = baseTestOptions()\n\terr := validation.Validate(test.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttest.proxy, err = NewOAuthProxy(test.opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn test, nil\n}\n\nfunc (test *ajaxRequestTest) getEndpoint(endpoint string, header http.Header) (int, http.Header, error) {\n\trw := httptest.NewRecorder()\n\treq, err := http.NewRequest(http.MethodGet, endpoint, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\treq.Header = header\n\ttest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Header(), nil\n}\n\nfunc testAjaxUnauthorizedRequest(t *testing.T, header http.Header) {\n\ttest, err := newAjaxRequestTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tendpoint := \"/test\"\n\n\tcode, rh, err := test.getEndpoint(endpoint, header)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusUnauthorized, code)\n\tmime := rh.Get(\"Content-Type\")\n\tassert.Equal(t, applicationJSON, mime)\n}\nfunc TestAjaxUnauthorizedRequest1(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"accept\", applicationJSON)\n\n\ttestAjaxUnauthorizedRequest(t, header)\n}\n\nfunc TestAjaxUnauthorizedRequest2(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"Accept\", applicationJSON)\n\n\ttestAjaxUnauthorizedRequest(t, header)\n}\n\nfunc TestAjaxUnauthorizedRequestAccept1(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"Accept\", \"application/json, text/plain, */*\")\n\n\ttestAjaxUnauthorizedRequest(t, header)\n}\n\nfunc TestAjaxForbiddendRequest(t *testing.T) {\n\ttest, err := newAjaxRequestTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tendpoint := \"/test\"\n\theader := make(http.Header)\n\tcode, rh, err := test.getEndpoint(endpoint, header)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusForbidden, code)\n\tmime := rh.Get(\"Content-Type\")\n\tassert.NotEqual(t, applicationJSON, mime)\n}\n\nfunc TestClearSplitCookie(t *testing.T) {\n\topts := baseTestOptions()\n\topts.Cookie.Secret = base64CookieSecret\n\topts.Cookie.Name = \"oauth2\"\n\topts.Cookie.Domains = []string{\"abc\"}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tstore, err := sessionscookie.NewCookieSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := OAuthProxy{CookieName: opts.Cookie.Name, CookieDomains: opts.Cookie.Domains, sessionStore: store}\n\tvar rw = httptest.NewRecorder()\n\treq := httptest.NewRequest(\"get\", \"/\", nil)\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"test1\",\n\t\tValue: \"test1\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2_0\",\n\t\tValue: \"oauth2_0\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2_1\",\n\t\tValue: \"oauth2_1\",\n\t})\n\n\terr = p.ClearSessionCookie(rw, req)\n\tassert.NoError(t, err)\n\theader := rw.Header()\n\n\tassert.Equal(t, 2, len(header[\"Set-Cookie\"]), \"should have 3 set-cookie header entries\")\n}\n\nfunc TestClearSingleCookie(t *testing.T) {\n\topts := baseTestOptions()\n\topts.Cookie.Name = \"oauth2\"\n\topts.Cookie.Domains = []string{\"abc\"}\n\tstore, err := sessionscookie.NewCookieSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := OAuthProxy{CookieName: opts.Cookie.Name, CookieDomains: opts.Cookie.Domains, sessionStore: store}\n\tvar rw = httptest.NewRecorder()\n\treq := httptest.NewRequest(\"get\", \"/\", nil)\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"test1\",\n\t\tValue: \"test1\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2\",\n\t\tValue: \"oauth2\",\n\t})\n\n\terr = p.ClearSessionCookie(rw, req)\n\tassert.NoError(t, err)\n\theader := rw.Header()\n\n\tassert.Equal(t, 1, len(header[\"Set-Cookie\"]), \"should have 1 set-cookie header entries\")\n}\n\ntype NoOpKeySet struct {\n}\n\nfunc (NoOpKeySet) VerifySignature(_ context.Context, jwt string) (payload []byte, err error) {\n\tsplitStrings := strings.Split(jwt, \".\")\n\tpayloadString := splitStrings[1]\n\treturn base64.RawURLEncoding.DecodeString(payloadString)\n}\n\nfunc TestGetJwtSession(t *testing.T) {\n\t/* token payload:\n\t{\n\t  \"sub\": \"1234567890\",\n\t  \"aud\": \"https://test.myapp.com\",\n\t  \"name\": \"John Doe\",\n\t  \"email\": \"john@example.com\",\n\t  \"iss\": \"https://issuer.example.com\",\n\t  \"iat\": 1553691215,\n\t  \"exp\": 1912151821\n\t}\n\t*/\n\tgoodJwt := \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\" +\n\t\t\"eyJzdWIiOiIxMjM0NTY3ODkwIiwiYXVkIjoiaHR0cHM6Ly90ZXN0Lm15YXBwLmNvbSIsIm5hbWUiOiJKb2huIERvZSIsImVtY\" +\n\t\t\"WlsIjoiam9obkBleGFtcGxlLmNvbSIsImlzcyI6Imh0dHBzOi8vaXNzdWVyLmV4YW1wbGUuY29tIiwiaWF0IjoxNTUzNjkxMj\" +\n\t\t\"E1LCJleHAiOjE5MTIxNTE4MjF9.\" +\n\t\t\"rLVyzOnEldUq_pNkfa-WiV8TVJYWyZCaM2Am_uo8FGg11zD7l-qmz3x1seTvqpH6Y0Ty00fmv6dJnGnC8WMnPXQiodRTfhBSe\" +\n\t\t\"OKZMu0HkMD2sg52zlKkbfLTO6ic5VnbVgwjjrB8am_Ta6w7kyFUaB5C1BsIrrLMldkWEhynbb8\"\n\n\tkeyset := NoOpKeySet{}\n\tverifier := oidc.NewVerifier(\"https://issuer.example.com\", keyset,\n\t\t&oidc.Config{ClientID: \"https://test.myapp.com\", SkipExpiryCheck: true})\n\n\ttest, err := NewAuthOnlyEndpointTest(\"\", func(opts *options.Options) {\n\t\topts.InjectRequestHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"Authorization\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim:  \"id_token\",\n\t\t\t\t\t\t\tPrefix: \"Bearer \",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-User\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-Email\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\topts.InjectResponseHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"Authorization\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim:  \"id_token\",\n\t\t\t\t\t\t\tPrefix: \"Bearer \",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Auth-Request-User\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\topts.SkipJwtBearerTokens = true\n\t\topts.SetJWTBearerVerifiers(append(opts.GetJWTBearerVerifiers(), verifier))\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttp, _ := test.proxy.provider.(*TestProvider)\n\ttp.GroupValidator = func(s string) bool {\n\t\treturn true\n\t}\n\n\tauthHeader := fmt.Sprintf(\"Bearer %s\", goodJwt)\n\ttest.req.Header = map[string][]string{\n\t\t\"Authorization\": {authHeader},\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tif test.rw.Code >= 400 {\n\t\tt.Fatalf(\"expected 3xx got %d\", test.rw.Code)\n\t}\n\n\t// Check PassAuthorization, should overwrite Basic header\n\tassert.Equal(t, test.req.Header.Get(\"Authorization\"), authHeader)\n\tassert.Equal(t, test.req.Header.Get(\"X-Forwarded-User\"), \"1234567890\")\n\tassert.Equal(t, test.req.Header.Get(\"X-Forwarded-Email\"), \"john@example.com\")\n\n\t// SetAuthorization and SetXAuthRequest\n\tassert.Equal(t, test.rw.Header().Get(\"Authorization\"), authHeader)\n\tassert.Equal(t, test.rw.Header().Get(\"X-Auth-Request-User\"), \"1234567890\")\n\tassert.Equal(t, test.rw.Header().Get(\"X-Auth-Request-Email\"), \"john@example.com\")\n}\n\nfunc Test_prepareNoCache(t *testing.T) {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprepareNoCache(w)\n\t})\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", handler)\n\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tmux.ServeHTTP(rec, req)\n\n\tfor k, v := range noCacheHeaders {\n\t\tassert.Equal(t, rec.Header().Get(k), v)\n\t}\n}\n\nfunc Test_noCacheHeaders(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := w.Write([]byte(\"upstream\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\".*\"}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tt.Run(\"not exist in response from upstream\", func(t *testing.T) {\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, \"/upstream\", nil)\n\t\tproxy.ServeHTTP(rec, req)\n\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"upstream\", rec.Body.String())\n\n\t\t// checking noCacheHeaders does not exists in response headers from upstream\n\t\tfor k := range noCacheHeaders {\n\t\t\tassert.Equal(t, \"\", rec.Header().Get(k))\n\t\t}\n\t})\n\n\tt.Run(\"has no-cache\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tpath       string\n\t\t\thasNoCache bool\n\t\t}{\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/sign_in\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/sign_out\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/start\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/callback\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/auth\",\n\t\t\t\thasNoCache: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/userinfo\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/upstream\",\n\t\t\t\thasNoCache: false,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.path, func(t *testing.T) {\n\t\t\t\trec := httptest.NewRecorder()\n\t\t\t\treq := httptest.NewRequest(http.MethodGet, tt.path, nil)\n\t\t\t\tproxy.ServeHTTP(rec, req)\n\t\t\t\tcacheControl := rec.Result().Header.Get(\"Cache-Control\")\n\t\t\t\tif tt.hasNoCache != (strings.Contains(cacheControl, \"no-cache\")) {\n\t\t\t\t\tt.Errorf(`unexpected \"Cache-Control\" header: %s`, cacheControl)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t})\n}\n\nfunc baseTestOptions() *options.Options {\n\topts := options.NewOptions()\n\topts.Cookie.Secret = rawCookieSecret\n\topts.ClientID = clientID\n\topts.ClientSecret = clientSecret\n\topts.EmailDomains = []string{\"*\"}\n\n\t// Default injected headers for legacy configuration\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(base64.StdEncoding.EncodeToString([]byte(\"This is a secure password\"))),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\treturn opts\n}\n\nfunc TestTrustedIPs(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\ttrustedIPs         []string\n\t\treverseProxy       bool\n\t\trealClientIPHeader string\n\t\treq                *http.Request\n\t\texpectTrusted      bool\n\t}{\n\t\t// Check unconfigured behavior.\n\t\t{\n\t\t\tname:               \"Default\",\n\t\t\ttrustedIPs:         nil,\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check using req.RemoteAddr (Options.ReverseProxy == false).\n\t\t{\n\t\t\tname:               \"WithRemoteAddr\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.1\"},\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"127.0.0.1:43670\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check ignores req.RemoteAddr match when behind a reverse proxy / missing header.\n\t\t{\n\t\t\tname:               \"IgnoresRemoteAddrInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"127.0.0.1:44324\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check successful trusting of localhost in IPv4.\n\t\t{\n\t\t\tname:               \"TrustsLocalhostInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"127.0.0.1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check successful trusting of localhost in IPv6.\n\t\t{\n\t\t\tname:               \"TrustsIP6LocalostInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"::1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check does not trust random IPv4 address.\n\t\t{\n\t\t\tname:               \"DoesNotTrustRandomIP4Address\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"12.34.56.78\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check does not trust random IPv6 address.\n\t\t{\n\t\t\tname:               \"DoesNotTrustRandomIP6Address\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"::2\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check respects correct header.\n\t\t{\n\t\t\tname:               \"RespectsCorrectHeaderInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Real-IP\", \"::1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check doesn't trust if garbage is provided.\n\t\t{\n\t\t\tname:               \"DoesNotTrustGarbageInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"adsfljk29242as!!\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check doesn't trust if garbage is provided (no reverse-proxy).\n\t\t{\n\t\t\tname:               \"DoesNotTrustGarbage\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"adsfljk29242as!!\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\topts := baseTestOptions()\n\t\t\topts.UpstreamServers = options.Upstreams{\n\t\t\t\t{\n\t\t\t\t\tID:     \"static\",\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t\tStatic: true,\n\t\t\t\t},\n\t\t\t}\n\t\t\topts.TrustedIPs = tt.trustedIPs\n\t\t\topts.ReverseProxy = tt.reverseProxy\n\t\t\topts.RealClientIPHeader = tt.realClientIPHeader\n\t\t\terr := validation.Validate(opts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\t\t\tassert.NoError(t, err)\n\t\t\trw := httptest.NewRecorder()\n\n\t\t\tproxy.ServeHTTP(rw, tt.req)\n\t\t\tif tt.expectTrusted {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_buildRoutesAllowlist(t *testing.T) {\n\ttype expectedAllowedRoute struct {\n\t\tmethod      string\n\t\tregexString string\n\t}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tskipAuthRegex  []string\n\t\tskipAuthRoutes []string\n\t\texpectedRoutes []expectedAllowedRoute\n\t\tshouldError    bool\n\t}{\n\t\t{\n\t\t\tname:           \"No skip auth configured\",\n\t\t\tskipAuthRegex:  []string{},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"Only skipAuthRegex configured\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar\",\n\t\t\t\t\"^/baz/[0-9]+/thing\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname:          \"Only skipAuthRoutes configured\",\n\t\t\tskipAuthRegex: []string{},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t\t\"WEIRD=^/methods/are/allowed\",\n\t\t\t\t\"PATCH=/second/equals?are=handled&just=fine\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"GET\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"POST\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/all/methods$\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"WEIRD\",\n\t\t\t\t\tregexString: \"^/methods/are/allowed\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"PATCH\",\n\t\t\t\t\tregexString: \"/second/equals?are=handled&just=fine\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Both skipAuthRegexes and skipAuthRoutes configured\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar/regex\",\n\t\t\t\t\"^/baz/[0-9]+/thing/regex\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/foo/bar/regex\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing/regex\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"GET\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"POST\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/all/methods$\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid skipAuthRegex entry\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar\",\n\t\t\t\t\"^/baz/[0-9]+/thing\",\n\t\t\t\t\"(bad[regex\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    true,\n\t\t},\n\t\t{\n\t\t\tname:          \"Invalid skipAuthRoutes entry\",\n\t\t\tskipAuthRegex: []string{},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t\t\"PUT=(bad[regex\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\topts := &options.Options{\n\t\t\t\tSkipAuthRegex:  tc.skipAuthRegex,\n\t\t\t\tSkipAuthRoutes: tc.skipAuthRoutes,\n\t\t\t}\n\t\t\troutes, err := buildRoutesAllowlist(opts)\n\t\t\tif tc.shouldError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.NoError(t, err)\n\n\t\t\tfor i, route := range routes {\n\t\t\t\tassert.Greater(t, len(tc.expectedRoutes), i)\n\t\t\t\tassert.Equal(t, route.method, tc.expectedRoutes[i].method)\n\t\t\t\tassert.Equal(t, route.pathRegex.String(), tc.expectedRoutes[i].regexString)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllowedRequest(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"Allowed Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\n\t\t\"^/skip/auth/regex$\",\n\t}\n\topts.SkipAuthRoutes = []string{\n\t\t\"GET=^/skip/auth/routes/get\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\turl     string\n\t\tallowed bool\n\t}{\n\t\t{\n\t\t\tname:    \"Regex GET allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST allowed \",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex denied\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/wrong/denied\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong method\",\n\t\t\tmethod:  \"PATCH\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong path\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/wrong/path\",\n\t\t\tallowed: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(tc.method, tc.url, nil)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.allowed, proxy.isAllowedRoute(req))\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.allowed {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t\tassert.Equal(t, \"Allowed Request\", rw.Body.String())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProxyAllowedGroups(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tallowedGroups      []string\n\t\tgroups             []string\n\t\texpectUnauthorized bool\n\t}{\n\t\t{\"NoAllowedGroups\", []string{}, []string{}, false},\n\t\t{\"NoAllowedGroupsUserHasGroups\", []string{}, []string{\"a\", \"b\"}, false},\n\t\t{\"UserInAllowedGroup\", []string{\"a\"}, []string{\"a\", \"b\"}, false},\n\t\t{\"UserNotInAllowedGroup\", []string{\"a\"}, []string{\"c\"}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\temailAddress := \"test\"\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      tt.groups,\n\t\t\t\tEmail:       emailAddress,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.WriteHeader(200)\n\t\t\t}))\n\t\t\tt.Cleanup(upstreamServer.Close)\n\n\t\t\ttest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\t\t\topts.AllowedGroups = tt.allowedGroups\n\t\t\t\topts.UpstreamServers = options.Upstreams{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\t\t\tPath: \"/\",\n\t\t\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\ttest.req, _ = http.NewRequest(\"GET\", \"/\", nil)\n\n\t\t\ttest.req.Header.Add(\"accept\", applicationJSON)\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tif tt.expectUnauthorized {\n\t\t\t\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, http.StatusOK, test.rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAuthOnlyAllowedGroups(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\tallowedGroups      []string\n\t\tgroups             []string\n\t\tquerystring        string\n\t\texpectedStatusCode int\n\t}{\n\t\t{\n\t\t\tname:               \"NoAllowedGroups\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"NoAllowedGroupsUserHasGroups\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"a\", \"b\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedGroup\",\n\t\t\tallowedGroups:      []string{\"a\"},\n\t\t\tgroups:             []string{\"a\", \"b\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedGroup\",\n\t\t\tallowedGroups:      []string{\"a\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusUnauthorized,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInMultiParamQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"b\"},\n\t\t\tquerystring:        \"?allowed_groups=a&allowed_groups=b,d\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInOnlyQuerystringGroup\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInDelimitedQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\", \"c\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,c\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInConfigGroupNotInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\", \"c\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInQuerystringGroupNotInConfigGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=b,c\",\n\t\t\texpectedStatusCode: http.StatusUnauthorized,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\temailAddress := \"test\"\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      tc.groups,\n\t\t\t\tEmail:       emailAddress,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\ttest, err := NewAuthOnlyEndpointTest(tc.querystring, func(opts *options.Options) {\n\t\t\t\topts.AllowedGroups = tc.allowedGroups\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tassert.Equal(t, tc.expectedStatusCode, test.rw.Code)\n\t\t})\n\t}\n}\n"], "fixing_code": ["package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/justinas/alice\"\n\tipapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/ip\"\n\tmiddlewareapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/middleware\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\tsessionsapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/authentication/basic\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/cookies\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/encryption\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/ip\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/middleware\"\n\trequestutil \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/requests/util\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/upstream\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/providers\"\n)\n\nconst (\n\tschemeHTTPS     = \"https\"\n\tapplicationJSON = \"application/json\"\n)\n\nvar (\n\t// ErrNeedsLogin means the user should be redirected to the login page\n\tErrNeedsLogin = errors.New(\"redirect to login page\")\n\n\t// ErrAccessDenied means the user should receive a 401 Unauthorized response\n\tErrAccessDenied = errors.New(\"access denied\")\n\n\t// Used to check final redirects are not susceptible to open redirects.\n\t// Matches //, /\\ and both of these with whitespace in between (eg / / or / \\).\n\tinvalidRedirectRegex = regexp.MustCompile(`[/\\\\](?:[\\s\\v]*|\\.{1,2})[/\\\\]`)\n)\n\n// allowedRoute manages method + path based allowlists\ntype allowedRoute struct {\n\tmethod    string\n\tpathRegex *regexp.Regexp\n}\n\n// OAuthProxy is the main authentication proxy\ntype OAuthProxy struct {\n\tCookieSeed     string\n\tCookieName     string\n\tCSRFCookieName string\n\tCookieDomains  []string\n\tCookiePath     string\n\tCookieSecure   bool\n\tCookieHTTPOnly bool\n\tCookieExpire   time.Duration\n\tCookieRefresh  time.Duration\n\tCookieSameSite string\n\tValidator      func(string) bool\n\n\tRobotsPath        string\n\tSignInPath        string\n\tSignOutPath       string\n\tOAuthStartPath    string\n\tOAuthCallbackPath string\n\tAuthOnlyPath      string\n\tUserInfoPath      string\n\n\tallowedRoutes        []allowedRoute\n\tredirectURL          *url.URL // the url to receive requests at\n\twhitelistDomains     []string\n\tprovider             providers.Provider\n\tproviderNameOverride string\n\tsessionStore         sessionsapi.SessionStore\n\tProxyPrefix          string\n\tSignInMessage        string\n\tbasicAuthValidator   basic.Validator\n\tdisplayHtpasswdForm  bool\n\tserveMux             http.Handler\n\tSetXAuthRequest      bool\n\tPassBasicAuth        bool\n\tSetBasicAuth         bool\n\tSkipProviderButton   bool\n\tPassUserHeaders      bool\n\tBasicAuthPassword    string\n\tPassAccessToken      bool\n\tSetAuthorization     bool\n\tPassAuthorization    bool\n\tPreferEmailToUser    bool\n\tskipAuthPreflight    bool\n\tskipJwtBearerTokens  bool\n\ttemplates            *template.Template\n\trealClientIPParser   ipapi.RealClientIPParser\n\ttrustedIPs           *ip.NetSet\n\tBanner               string\n\tFooter               string\n\n\tsessionChain alice.Chain\n\theadersChain alice.Chain\n\tpreAuthChain alice.Chain\n}\n\n// NewOAuthProxy creates a new instance of OAuthProxy from the options provided\nfunc NewOAuthProxy(opts *options.Options, validator func(string) bool) (*OAuthProxy, error) {\n\tsessionStore, err := sessions.NewSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising session store: %v\", err)\n\t}\n\n\ttemplates := loadTemplates(opts.CustomTemplatesDir)\n\tproxyErrorHandler := upstream.NewProxyErrorHandler(templates.Lookup(\"error.html\"), opts.ProxyPrefix)\n\tupstreamProxy, err := upstream.NewProxy(opts.UpstreamServers, opts.GetSignatureData(), proxyErrorHandler)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising upstream proxy: %v\", err)\n\t}\n\n\tif opts.SkipJwtBearerTokens {\n\t\tlogger.Printf(\"Skipping JWT tokens from configured OIDC issuer: %q\", opts.OIDCIssuerURL)\n\t\tfor _, issuer := range opts.ExtraJwtIssuers {\n\t\t\tlogger.Printf(\"Skipping JWT tokens from extra JWT issuer: %q\", issuer)\n\t\t}\n\t}\n\tredirectURL := opts.GetRedirectURL()\n\tif redirectURL.Path == \"\" {\n\t\tredirectURL.Path = fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix)\n\t}\n\n\tlogger.Printf(\"OAuthProxy configured for %s Client ID: %s\", opts.GetProvider().Data().ProviderName, opts.ClientID)\n\trefresh := \"disabled\"\n\tif opts.Cookie.Refresh != time.Duration(0) {\n\t\trefresh = fmt.Sprintf(\"after %s\", opts.Cookie.Refresh)\n\t}\n\n\tlogger.Printf(\"Cookie settings: name:%s secure(https):%v httponly:%v expiry:%s domains:%s path:%s samesite:%s refresh:%s\", opts.Cookie.Name, opts.Cookie.Secure, opts.Cookie.HTTPOnly, opts.Cookie.Expire, strings.Join(opts.Cookie.Domains, \",\"), opts.Cookie.Path, opts.Cookie.SameSite, refresh)\n\n\ttrustedIPs := ip.NewNetSet()\n\tfor _, ipStr := range opts.TrustedIPs {\n\t\tif ipNet := ip.ParseIPNet(ipStr); ipNet != nil {\n\t\t\ttrustedIPs.AddIPNet(*ipNet)\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"could not parse IP network (%s)\", ipStr)\n\t\t}\n\t}\n\n\tvar basicAuthValidator basic.Validator\n\tif opts.HtpasswdFile != \"\" {\n\t\tlogger.Printf(\"using htpasswd file: %s\", opts.HtpasswdFile)\n\t\tvar err error\n\t\tbasicAuthValidator, err = basic.NewHTPasswdValidator(opts.HtpasswdFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not load htpasswdfile: %v\", err)\n\t\t}\n\t}\n\n\tallowedRoutes, err := buildRoutesAllowlist(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpreAuthChain, err := buildPreAuthChain(opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not build pre-auth chain: %v\", err)\n\t}\n\tsessionChain := buildSessionChain(opts, sessionStore, basicAuthValidator)\n\theadersChain, err := buildHeadersChain(opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not build headers chain: %v\", err)\n\t}\n\n\treturn &OAuthProxy{\n\t\tCookieName:     opts.Cookie.Name,\n\t\tCSRFCookieName: fmt.Sprintf(\"%v_%v\", opts.Cookie.Name, \"csrf\"),\n\t\tCookieSeed:     opts.Cookie.Secret,\n\t\tCookieDomains:  opts.Cookie.Domains,\n\t\tCookiePath:     opts.Cookie.Path,\n\t\tCookieSecure:   opts.Cookie.Secure,\n\t\tCookieHTTPOnly: opts.Cookie.HTTPOnly,\n\t\tCookieExpire:   opts.Cookie.Expire,\n\t\tCookieRefresh:  opts.Cookie.Refresh,\n\t\tCookieSameSite: opts.Cookie.SameSite,\n\t\tValidator:      validator,\n\n\t\tRobotsPath:        \"/robots.txt\",\n\t\tSignInPath:        fmt.Sprintf(\"%s/sign_in\", opts.ProxyPrefix),\n\t\tSignOutPath:       fmt.Sprintf(\"%s/sign_out\", opts.ProxyPrefix),\n\t\tOAuthStartPath:    fmt.Sprintf(\"%s/start\", opts.ProxyPrefix),\n\t\tOAuthCallbackPath: fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix),\n\t\tAuthOnlyPath:      fmt.Sprintf(\"%s/auth\", opts.ProxyPrefix),\n\t\tUserInfoPath:      fmt.Sprintf(\"%s/userinfo\", opts.ProxyPrefix),\n\n\t\tProxyPrefix:          opts.ProxyPrefix,\n\t\tprovider:             opts.GetProvider(),\n\t\tproviderNameOverride: opts.ProviderName,\n\t\tsessionStore:         sessionStore,\n\t\tserveMux:             upstreamProxy,\n\t\tredirectURL:          redirectURL,\n\t\tallowedRoutes:        allowedRoutes,\n\t\twhitelistDomains:     opts.WhitelistDomains,\n\t\tskipAuthPreflight:    opts.SkipAuthPreflight,\n\t\tskipJwtBearerTokens:  opts.SkipJwtBearerTokens,\n\t\trealClientIPParser:   opts.GetRealClientIPParser(),\n\t\tSkipProviderButton:   opts.SkipProviderButton,\n\t\ttemplates:            templates,\n\t\ttrustedIPs:           trustedIPs,\n\t\tBanner:               opts.Banner,\n\t\tFooter:               opts.Footer,\n\t\tSignInMessage:        buildSignInMessage(opts),\n\n\t\tbasicAuthValidator:  basicAuthValidator,\n\t\tdisplayHtpasswdForm: basicAuthValidator != nil && opts.DisplayHtpasswdForm,\n\t\tsessionChain:        sessionChain,\n\t\theadersChain:        headersChain,\n\t\tpreAuthChain:        preAuthChain,\n\t}, nil\n}\n\n// buildPreAuthChain constructs a chain that should process every request before\n// the OAuth2 Proxy authentication logic kicks in.\n// For example forcing HTTPS or health checks.\nfunc buildPreAuthChain(opts *options.Options) (alice.Chain, error) {\n\tchain := alice.New(middleware.NewScope(opts.ReverseProxy))\n\n\tif opts.ForceHTTPS {\n\t\t_, httpsPort, err := net.SplitHostPort(opts.HTTPSAddress)\n\t\tif err != nil {\n\t\t\treturn alice.Chain{}, fmt.Errorf(\"invalid HTTPS address %q: %v\", opts.HTTPAddress, err)\n\t\t}\n\t\tchain = chain.Append(middleware.NewRedirectToHTTPS(httpsPort))\n\t}\n\n\thealthCheckPaths := []string{opts.PingPath}\n\thealthCheckUserAgents := []string{opts.PingUserAgent}\n\tif opts.GCPHealthChecks {\n\t\thealthCheckPaths = append(healthCheckPaths, \"/liveness_check\", \"/readiness_check\")\n\t\thealthCheckUserAgents = append(healthCheckUserAgents, \"GoogleHC/1.0\")\n\t}\n\n\t// To silence logging of health checks, register the health check handler before\n\t// the logging handler\n\tif opts.Logging.SilencePing {\n\t\tchain = chain.Append(middleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents), LoggingHandler)\n\t} else {\n\t\tchain = chain.Append(LoggingHandler, middleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents))\n\t}\n\n\treturn chain, nil\n}\n\nfunc buildSessionChain(opts *options.Options, sessionStore sessionsapi.SessionStore, validator basic.Validator) alice.Chain {\n\tchain := alice.New()\n\n\tif opts.SkipJwtBearerTokens {\n\t\tsessionLoaders := []middlewareapi.TokenToSessionFunc{\n\t\t\topts.GetProvider().CreateSessionFromToken,\n\t\t}\n\n\t\tfor _, verifier := range opts.GetJWTBearerVerifiers() {\n\t\t\tsessionLoaders = append(sessionLoaders,\n\t\t\t\tmiddlewareapi.CreateTokenToSessionFunc(verifier.Verify))\n\t\t}\n\n\t\tchain = chain.Append(middleware.NewJwtSessionLoader(sessionLoaders))\n\t}\n\n\tif validator != nil {\n\t\tchain = chain.Append(middleware.NewBasicAuthSessionLoader(validator))\n\t}\n\n\tchain = chain.Append(middleware.NewStoredSessionLoader(&middleware.StoredSessionLoaderOptions{\n\t\tSessionStore:           sessionStore,\n\t\tRefreshPeriod:          opts.Cookie.Refresh,\n\t\tRefreshSessionIfNeeded: opts.GetProvider().RefreshSessionIfNeeded,\n\t\tValidateSessionState:   opts.GetProvider().ValidateSession,\n\t}))\n\n\treturn chain\n}\n\nfunc buildHeadersChain(opts *options.Options) (alice.Chain, error) {\n\trequestInjector, err := middleware.NewRequestHeaderInjector(opts.InjectRequestHeaders)\n\tif err != nil {\n\t\treturn alice.Chain{}, fmt.Errorf(\"error constructing request header injector: %v\", err)\n\t}\n\n\tresponseInjector, err := middleware.NewResponseHeaderInjector(opts.InjectResponseHeaders)\n\tif err != nil {\n\t\treturn alice.Chain{}, fmt.Errorf(\"error constructing request header injector: %v\", err)\n\t}\n\n\treturn alice.New(requestInjector, responseInjector), nil\n}\n\nfunc buildSignInMessage(opts *options.Options) string {\n\tvar msg string\n\tif len(opts.Banner) >= 1 {\n\t\tif opts.Banner == \"-\" {\n\t\t\tmsg = \"\"\n\t\t} else {\n\t\t\tmsg = opts.Banner\n\t\t}\n\t} else if len(opts.EmailDomains) != 0 && opts.AuthenticatedEmailsFile == \"\" {\n\t\tif len(opts.EmailDomains) > 1 {\n\t\t\tmsg = fmt.Sprintf(\"Authenticate using one of the following domains: %v\", strings.Join(opts.EmailDomains, \", \"))\n\t\t} else if opts.EmailDomains[0] != \"*\" {\n\t\t\tmsg = fmt.Sprintf(\"Authenticate using %v\", opts.EmailDomains[0])\n\t\t}\n\t}\n\treturn msg\n}\n\n// buildRoutesAllowlist builds an []allowedRoute  list from either the legacy\n// SkipAuthRegex option (paths only support) or newer SkipAuthRoutes option\n// (method=path support)\nfunc buildRoutesAllowlist(opts *options.Options) ([]allowedRoute, error) {\n\troutes := make([]allowedRoute, 0, len(opts.SkipAuthRegex)+len(opts.SkipAuthRoutes))\n\n\tfor _, path := range opts.SkipAuthRegex {\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"Skipping auth - Method: ALL | Path: %s\", path)\n\t\troutes = append(routes, allowedRoute{\n\t\t\tmethod:    \"\",\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\tfor _, methodPath := range opts.SkipAuthRoutes {\n\t\tvar (\n\t\t\tmethod string\n\t\t\tpath   string\n\t\t)\n\n\t\tparts := strings.SplitN(methodPath, \"=\", 2)\n\t\tif len(parts) == 1 {\n\t\t\tmethod = \"\"\n\t\t\tpath = parts[0]\n\t\t} else {\n\t\t\tmethod = strings.ToUpper(parts[0])\n\t\t\tpath = parts[1]\n\t\t}\n\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"Skipping auth - Method: %s | Path: %s\", method, path)\n\t\troutes = append(routes, allowedRoute{\n\t\t\tmethod:    method,\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\treturn routes, nil\n}\n\n// MakeCSRFCookie creates a cookie for CSRF\nfunc (p *OAuthProxy) MakeCSRFCookie(req *http.Request, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\treturn p.makeCookie(req, p.CSRFCookieName, value, expiration, now)\n}\n\nfunc (p *OAuthProxy) makeCookie(req *http.Request, name string, value string, expiration time.Duration, now time.Time) *http.Cookie {\n\tcookieDomain := cookies.GetCookieDomain(req, p.CookieDomains)\n\n\tif cookieDomain != \"\" {\n\t\tdomain := requestutil.GetRequestHost(req)\n\t\tif h, _, err := net.SplitHostPort(domain); err == nil {\n\t\t\tdomain = h\n\t\t}\n\t\tif !strings.HasSuffix(domain, cookieDomain) {\n\t\t\tlogger.Errorf(\"Warning: request host is %q but using configured cookie domain of %q\", domain, cookieDomain)\n\t\t}\n\t}\n\n\treturn &http.Cookie{\n\t\tName:     name,\n\t\tValue:    value,\n\t\tPath:     p.CookiePath,\n\t\tDomain:   cookieDomain,\n\t\tHttpOnly: p.CookieHTTPOnly,\n\t\tSecure:   p.CookieSecure,\n\t\tExpires:  now.Add(expiration),\n\t\tSameSite: cookies.ParseSameSite(p.CookieSameSite),\n\t}\n}\n\n// ClearCSRFCookie creates a cookie to unset the CSRF cookie stored in the user's\n// session\nfunc (p *OAuthProxy) ClearCSRFCookie(rw http.ResponseWriter, req *http.Request) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, \"\", time.Hour*-1, time.Now()))\n}\n\n// SetCSRFCookie adds a CSRF cookie to the response\nfunc (p *OAuthProxy) SetCSRFCookie(rw http.ResponseWriter, req *http.Request, val string) {\n\thttp.SetCookie(rw, p.MakeCSRFCookie(req, val, p.CookieExpire, time.Now()))\n}\n\n// ClearSessionCookie creates a cookie to unset the user's authentication cookie\n// stored in the user's session\nfunc (p *OAuthProxy) ClearSessionCookie(rw http.ResponseWriter, req *http.Request) error {\n\treturn p.sessionStore.Clear(rw, req)\n}\n\n// LoadCookiedSession reads the user's authentication details from the request\nfunc (p *OAuthProxy) LoadCookiedSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\treturn p.sessionStore.Load(req)\n}\n\n// SaveSession creates a new session cookie value and sets this on the response\nfunc (p *OAuthProxy) SaveSession(rw http.ResponseWriter, req *http.Request, s *sessionsapi.SessionState) error {\n\treturn p.sessionStore.Save(rw, req, s)\n}\n\n// IsValidRedirect checks whether the redirect URL is whitelisted\nfunc (p *OAuthProxy) IsValidRedirect(redirect string) bool {\n\tswitch {\n\tcase redirect == \"\":\n\t\t// The user didn't specify a redirect, should fallback to `/`\n\t\treturn false\n\tcase strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !invalidRedirectRegex.MatchString(redirect):\n\t\treturn true\n\tcase strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):\n\t\tredirectURL, err := url.Parse(redirect)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", redirect)\n\t\t\treturn false\n\t\t}\n\t\tredirectHostname := redirectURL.Hostname()\n\n\t\tfor _, allowedDomain := range p.whitelistDomains {\n\t\t\tallowedHost, allowedPort := splitHostPort(allowedDomain)\n\t\t\tif allowedHost == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif redirectHostname == strings.TrimPrefix(allowedHost, \".\") ||\n\t\t\t\t(strings.HasPrefix(allowedHost, \".\") &&\n\t\t\t\t\tstrings.HasSuffix(redirectHostname, allowedHost)) {\n\t\t\t\t// the domain names match, now validate the ports\n\t\t\t\t// if the whitelisted domain's port is '*', allow all ports\n\t\t\t\t// if the whitelisted domain contains a specific port, only allow that port\n\t\t\t\t// if the whitelisted domain doesn't contain a port at all, only allow empty redirect ports ie http and https\n\t\t\t\tredirectPort := redirectURL.Port()\n\t\t\t\tif allowedPort == \"*\" ||\n\t\t\t\t\tallowedPort == redirectPort ||\n\t\t\t\t\t(allowedPort == \"\" && redirectPort == \"\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", redirect)\n\t\treturn false\n\tdefault:\n\t\tlogger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", redirect)\n\t\treturn false\n\t}\n}\n\nfunc (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tp.preAuthChain.Then(http.HandlerFunc(p.serveHTTP)).ServeHTTP(rw, req)\n}\n\nfunc (p *OAuthProxy) serveHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif req.URL.Path != p.AuthOnlyPath && strings.HasPrefix(req.URL.Path, p.ProxyPrefix) {\n\t\tprepareNoCache(rw)\n\t}\n\n\tswitch path := req.URL.Path; {\n\tcase path == p.RobotsPath:\n\t\tp.RobotsTxt(rw)\n\tcase p.IsAllowedRequest(req):\n\t\tp.SkipAuthProxy(rw, req)\n\tcase path == p.SignInPath:\n\t\tp.SignIn(rw, req)\n\tcase path == p.SignOutPath:\n\t\tp.SignOut(rw, req)\n\tcase path == p.OAuthStartPath:\n\t\tp.OAuthStart(rw, req)\n\tcase path == p.OAuthCallbackPath:\n\t\tp.OAuthCallback(rw, req)\n\tcase path == p.AuthOnlyPath:\n\t\tp.AuthOnly(rw, req)\n\tcase path == p.UserInfoPath:\n\t\tp.UserInfo(rw, req)\n\tdefault:\n\t\tp.Proxy(rw, req)\n\t}\n}\n\n// RobotsTxt disallows scraping pages from the OAuthProxy\nfunc (p *OAuthProxy) RobotsTxt(rw http.ResponseWriter) {\n\t_, err := fmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")\n\tif err != nil {\n\t\tlogger.Printf(\"Error writing robots.txt: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\trw.WriteHeader(http.StatusOK)\n}\n\n// ErrorPage writes an error response\nfunc (p *OAuthProxy) ErrorPage(rw http.ResponseWriter, code int, title string, message string) {\n\trw.WriteHeader(code)\n\tt := struct {\n\t\tTitle       string\n\t\tMessage     string\n\t\tProxyPrefix string\n\t}{\n\t\tTitle:       fmt.Sprintf(\"%d %s\", code, title),\n\t\tMessage:     message,\n\t\tProxyPrefix: p.ProxyPrefix,\n\t}\n\terr := p.templates.ExecuteTemplate(rw, \"error.html\", t)\n\tif err != nil {\n\t\tlogger.Printf(\"Error rendering error.html template: %v\", err)\n\t\thttp.Error(rw, \"Internal Server Error\", http.StatusInternalServerError)\n\t}\n}\n\n// IsAllowedRequest is used to check if auth should be skipped for this request\nfunc (p *OAuthProxy) IsAllowedRequest(req *http.Request) bool {\n\tisPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"\n\treturn isPreflightRequestAllowed || p.isAllowedRoute(req) || p.isTrustedIP(req)\n}\n\n// IsAllowedRoute is used to check if the request method & path is allowed without auth\nfunc (p *OAuthProxy) isAllowedRoute(req *http.Request) bool {\n\tfor _, route := range p.allowedRoutes {\n\t\tif (route.method == \"\" || req.Method == route.method) && route.pathRegex.MatchString(req.URL.Path) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isTrustedIP is used to check if a request comes from a trusted client IP address.\nfunc (p *OAuthProxy) isTrustedIP(req *http.Request) bool {\n\tif p.trustedIPs == nil {\n\t\treturn false\n\t}\n\n\tremoteAddr, err := ip.GetClientIP(p.realClientIPParser, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining real IP for trusted IP list: %v\", err)\n\t\t// Possibly spoofed X-Real-IP header\n\t\treturn false\n\t}\n\n\tif remoteAddr == nil {\n\t\treturn false\n\t}\n\n\treturn p.trustedIPs.Has(remoteAddr)\n}\n\n// SignInPage writes the sing in template to the response\nfunc (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {\n\tprepareNoCache(rw)\n\terr := p.ClearSessionCookie(rw, req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error clearing session cookie: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\trw.WriteHeader(code)\n\n\tredirectURL, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\n\tif redirectURL == p.SignInPath {\n\t\tredirectURL = \"/\"\n\t}\n\n\t// We allow unescaped template.HTML since it is user configured options\n\t/* #nosec G203 */\n\tt := struct {\n\t\tProviderName  string\n\t\tSignInMessage template.HTML\n\t\tCustomLogin   bool\n\t\tRedirect      string\n\t\tVersion       string\n\t\tProxyPrefix   string\n\t\tFooter        template.HTML\n\t}{\n\t\tProviderName:  p.provider.Data().ProviderName,\n\t\tSignInMessage: template.HTML(p.SignInMessage),\n\t\tCustomLogin:   p.displayHtpasswdForm,\n\t\tRedirect:      redirectURL,\n\t\tVersion:       VERSION,\n\t\tProxyPrefix:   p.ProxyPrefix,\n\t\tFooter:        template.HTML(p.Footer),\n\t}\n\tif p.providerNameOverride != \"\" {\n\t\tt.ProviderName = p.providerNameOverride\n\t}\n\terr = p.templates.ExecuteTemplate(rw, \"sign_in.html\", t)\n\tif err != nil {\n\t\tlogger.Printf(\"Error rendering sign_in.html template: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t}\n}\n\n// ManualSignIn handles basic auth logins to the proxy\nfunc (p *OAuthProxy) ManualSignIn(req *http.Request) (string, bool) {\n\tif req.Method != \"POST\" || p.basicAuthValidator == nil {\n\t\treturn \"\", false\n\t}\n\tuser := req.FormValue(\"username\")\n\tpasswd := req.FormValue(\"password\")\n\tif user == \"\" {\n\t\treturn \"\", false\n\t}\n\t// check auth\n\tif p.basicAuthValidator.Validate(user, passwd) {\n\t\tlogger.PrintAuthf(user, req, logger.AuthSuccess, \"Authenticated via HtpasswdFile\")\n\t\treturn user, true\n\t}\n\tlogger.PrintAuthf(user, req, logger.AuthFailure, \"Invalid authentication via HtpasswdFile\")\n\treturn \"\", false\n}\n\n// SignIn serves a page prompting users to sign in\nfunc (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\n\tuser, ok := p.ManualSignIn(req)\n\tif ok {\n\t\tsession := &sessionsapi.SessionState{User: user}\n\t\terr = p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error saving session: %v\", err)\n\t\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, http.StatusFound)\n\t} else {\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusOK)\n\t\t}\n\t}\n}\n\n//UserInfo endpoint outputs session email and preferred username in JSON format\nfunc (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {\n\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tuserInfo := struct {\n\t\tUser              string   `json:\"user\"`\n\t\tEmail             string   `json:\"email\"`\n\t\tGroups            []string `json:\"groups,omitempty\"`\n\t\tPreferredUsername string   `json:\"preferredUsername,omitempty\"`\n\t}{\n\t\tUser:              session.User,\n\t\tEmail:             session.Email,\n\t\tGroups:            session.Groups,\n\t\tPreferredUsername: session.PreferredUsername,\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\trw.WriteHeader(http.StatusOK)\n\terr = json.NewEncoder(rw).Encode(userInfo)\n\tif err != nil {\n\t\tlogger.Printf(\"Error encoding user info: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t}\n}\n\n// SignOut sends a response to clear the authentication cookie\nfunc (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\terr = p.ClearSessionCookie(rw, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error clearing session cookie: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\thttp.Redirect(rw, req, redirect, http.StatusFound)\n}\n\n// OAuthStart starts the OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthStart(rw http.ResponseWriter, req *http.Request) {\n\tprepareNoCache(rw)\n\tnonce, err := encryption.Nonce()\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining nonce: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\tp.SetCSRFCookie(rw, req, nonce)\n\tredirect, err := p.getAppRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\tredirectURI := p.getOAuthRedirectURI(req)\n\thttp.Redirect(rw, req, p.provider.GetLoginURL(redirectURI, fmt.Sprintf(\"%v:%v\", nonce, redirect)), http.StatusFound)\n}\n\n// OAuthCallback is the OAuth2 authentication flow callback that finishes the\n// OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthCallback(rw http.ResponseWriter, req *http.Request) {\n\tremoteAddr := ip.GetClientString(p.realClientIPParser, req, true)\n\n\t// finish the oauth cycle\n\terr := req.ParseForm()\n\tif err != nil {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\treturn\n\t}\n\terrorString := req.Form.Get(\"error\")\n\tif errorString != \"\" {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 callback: %s\", errorString)\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", errorString)\n\t\treturn\n\t}\n\n\tsession, err := p.redeemCode(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error redeeming code during OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Internal Error\")\n\t\treturn\n\t}\n\n\terr = p.enrichSessionState(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error creating session during OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Internal Error\")\n\t\treturn\n\t}\n\n\tstate := strings.SplitN(req.Form.Get(\"state\"), \":\", 2)\n\tif len(state) != 2 {\n\t\tlogger.Error(\"Error while parsing OAuth2 state: invalid length\")\n\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Invalid State\")\n\t\treturn\n\t}\n\tnonce := state[0]\n\tredirect := state[1]\n\tc, err := req.Cookie(p.CSRFCookieName)\n\tif err != nil {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unable to obtain CSRF cookie\")\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", err.Error())\n\t\treturn\n\t}\n\tp.ClearCSRFCookie(rw, req)\n\tif c.Value != nonce {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: CSRF token mismatch, potential attack\")\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", \"CSRF Failed\")\n\t\treturn\n\t}\n\n\tif !p.IsValidRedirect(redirect) {\n\t\tredirect = \"/\"\n\t}\n\n\t// set cookie, or deny\n\tauthorized, err := p.provider.Authorize(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error with authorization: %v\", err)\n\t}\n\tif p.Validator(session.Email) && authorized {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthSuccess, \"Authenticated via OAuth2: %s\", session)\n\t\terr := p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error saving session state for %s: %v\", remoteAddr, err)\n\t\t\tp.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, http.StatusFound)\n\t} else {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unauthorized\")\n\t\tp.ErrorPage(rw, http.StatusForbidden, \"Permission Denied\", \"Invalid Account\")\n\t}\n}\n\nfunc (p *OAuthProxy) redeemCode(req *http.Request) (*sessionsapi.SessionState, error) {\n\tcode := req.Form.Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, providers.ErrMissingCode\n\t}\n\n\tredirectURI := p.getOAuthRedirectURI(req)\n\ts, err := p.provider.Redeem(req.Context(), redirectURI, code)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}\n\nfunc (p *OAuthProxy) enrichSessionState(ctx context.Context, s *sessionsapi.SessionState) error {\n\tvar err error\n\tif s.Email == \"\" {\n\t\ts.Email, err = p.provider.GetEmailAddress(ctx, s)\n\t\tif err != nil && !errors.Is(err, providers.ErrNotImplemented) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn p.provider.EnrichSession(ctx, s)\n}\n\n// AuthOnly checks whether the user is currently logged in (both authentication\n// and optional authorization).\nfunc (p *OAuthProxy) AuthOnly(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Unauthorized cases need to return 403 to prevent infinite redirects with\n\t// subrequest architectures\n\tif !authOnlyAuthorize(req, session) {\n\t\thttp.Error(rw, http.StatusText(http.StatusForbidden), http.StatusForbidden)\n\t\treturn\n\t}\n\n\t// we are authenticated\n\tp.addHeadersForProxying(rw, session)\n\tp.headersChain.Then(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n\t\trw.WriteHeader(http.StatusAccepted)\n\t})).ServeHTTP(rw, req)\n}\n\n// SkipAuthProxy proxies allowlisted requests and skips authentication\nfunc (p *OAuthProxy) SkipAuthProxy(rw http.ResponseWriter, req *http.Request) {\n\tp.headersChain.Then(p.serveMux).ServeHTTP(rw, req)\n}\n\n// Proxy proxies the user request if the user is authenticated else it prompts\n// them to authenticate\nfunc (p *OAuthProxy) Proxy(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tswitch err {\n\tcase nil:\n\t\t// we are authenticated\n\t\tp.addHeadersForProxying(rw, session)\n\t\tp.headersChain.Then(p.serveMux).ServeHTTP(rw, req)\n\tcase ErrNeedsLogin:\n\t\t// we need to send the user to a login screen\n\t\tif isAjax(req) {\n\t\t\t// no point redirecting an AJAX request\n\t\t\tp.errorJSON(rw, http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusForbidden)\n\t\t}\n\n\tcase ErrAccessDenied:\n\t\tp.ErrorPage(rw, http.StatusUnauthorized, \"Permission Denied\", \"Unauthorized\")\n\n\tdefault:\n\t\t// unknown error\n\t\tlogger.Errorf(\"Unexpected internal error: %v\", err)\n\t\tp.ErrorPage(rw, http.StatusInternalServerError,\n\t\t\t\"Internal Error\", \"Internal Error\")\n\t}\n}\n\n// See https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en\nvar noCacheHeaders = map[string]string{\n\t\"Expires\":         time.Unix(0, 0).Format(time.RFC1123),\n\t\"Cache-Control\":   \"no-cache, no-store, must-revalidate, max-age=0\",\n\t\"X-Accel-Expires\": \"0\", // https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/\n}\n\n// prepareNoCache prepares headers for preventing browser caching.\nfunc prepareNoCache(w http.ResponseWriter) {\n\t// Set NoCache headers\n\tfor k, v := range noCacheHeaders {\n\t\tw.Header().Set(k, v)\n\t}\n}\n\n// getOAuthRedirectURI returns the redirectURL that the upstream OAuth Provider will\n// redirect clients to once authenticated.\n// This is usually the OAuthProxy callback URL.\nfunc (p *OAuthProxy) getOAuthRedirectURI(req *http.Request) string {\n\t// if `p.redirectURL` already has a host, return it\n\tif p.redirectURL.Host != \"\" {\n\t\treturn p.redirectURL.String()\n\t}\n\n\t// Otherwise figure out the scheme + host from the request\n\trd := *p.redirectURL\n\trd.Host = requestutil.GetRequestHost(req)\n\trd.Scheme = requestutil.GetRequestProto(req)\n\n\t// If CookieSecure is true, return `https` no matter what\n\t// Not all reverse proxies set X-Forwarded-Proto\n\tif p.CookieSecure {\n\t\trd.Scheme = schemeHTTPS\n\t}\n\treturn rd.String()\n}\n\n// getAppRedirect determines the full URL or URI path to redirect clients to\n// once authenticated with the OAuthProxy\n// Strategy priority (first legal result is used):\n// - `rd` querysting parameter\n// - `X-Auth-Request-Redirect` header\n// - `X-Forwarded-(Proto|Host|Uri)` headers (when ReverseProxy mode is enabled)\n// - `X-Forwarded-(Proto|Host)` if `Uri` has the ProxyPath (i.e. /oauth2/*)\n// - `X-Forwarded-Uri` direct URI path (when ReverseProxy mode is enabled)\n// - `req.URL.RequestURI` if not under the ProxyPath (i.e. /oauth2/*)\n// - `/`\nfunc (p *OAuthProxy) getAppRedirect(req *http.Request) (string, error) {\n\terr := req.ParseForm()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// These redirect getter functions are strategies ordered by priority\n\t// for figuring out the redirect URL.\n\ttype redirectGetter func(req *http.Request) string\n\tfor _, rdGetter := range []redirectGetter{\n\t\tp.getRdQuerystringRedirect,\n\t\tp.getXAuthRequestRedirect,\n\t\tp.getXForwardedHeadersRedirect,\n\t\tp.getURIRedirect,\n\t} {\n\t\tredirect := rdGetter(req)\n\t\t// Call `p.IsValidRedirect` again here a final time to be safe\n\t\tif redirect != \"\" && p.IsValidRedirect(redirect) {\n\t\t\treturn redirect, nil\n\t\t}\n\t}\n\n\treturn \"/\", nil\n}\n\nfunc isForwardedRequest(req *http.Request) bool {\n\treturn requestutil.IsProxied(req) &&\n\t\treq.Host != requestutil.GetRequestHost(req)\n}\n\nfunc (p *OAuthProxy) hasProxyPrefix(path string) bool {\n\treturn strings.HasPrefix(path, fmt.Sprintf(\"%s/\", p.ProxyPrefix))\n}\n\nfunc (p *OAuthProxy) validateRedirect(redirect string, errorFormat string) string {\n\tif p.IsValidRedirect(redirect) {\n\t\treturn redirect\n\t}\n\tif redirect != \"\" {\n\t\tlogger.Errorf(errorFormat, redirect)\n\t}\n\treturn \"\"\n}\n\n// getRdQuerystringRedirect handles this getAppRedirect strategy:\n// - `rd` querysting parameter\nfunc (p *OAuthProxy) getRdQuerystringRedirect(req *http.Request) string {\n\treturn p.validateRedirect(\n\t\treq.Form.Get(\"rd\"),\n\t\t\"Invalid redirect provided in rd querystring parameter: %s\",\n\t)\n}\n\n// getXAuthRequestRedirect handles this getAppRedirect strategy:\n// - `X-Auth-Request-Redirect` Header\nfunc (p *OAuthProxy) getXAuthRequestRedirect(req *http.Request) string {\n\treturn p.validateRedirect(\n\t\treq.Header.Get(\"X-Auth-Request-Redirect\"),\n\t\t\"Invalid redirect provided in X-Auth-Request-Redirect header: %s\",\n\t)\n}\n\n// getXForwardedHeadersRedirect handles these getAppRedirect strategies:\n// - `X-Forwarded-(Proto|Host|Uri)` headers (when ReverseProxy mode is enabled)\n// - `X-Forwarded-(Proto|Host)` if `Uri` has the ProxyPath (i.e. /oauth2/*)\nfunc (p *OAuthProxy) getXForwardedHeadersRedirect(req *http.Request) string {\n\tif !isForwardedRequest(req) {\n\t\treturn \"\"\n\t}\n\n\turi := requestutil.GetRequestURI(req)\n\tif p.hasProxyPrefix(uri) {\n\t\turi = \"/\"\n\t}\n\n\tredirect := fmt.Sprintf(\n\t\t\"%s://%s%s\",\n\t\trequestutil.GetRequestProto(req),\n\t\trequestutil.GetRequestHost(req),\n\t\turi,\n\t)\n\n\treturn p.validateRedirect(redirect,\n\t\t\"Invalid redirect generated from X-Forwarded-* headers: %s\")\n}\n\n// getURIRedirect handles these getAppRedirect strategies:\n// - `X-Forwarded-Uri` direct URI path (when ReverseProxy mode is enabled)\n// - `req.URL.RequestURI` if not under the ProxyPath (i.e. /oauth2/*)\n// - `/`\nfunc (p *OAuthProxy) getURIRedirect(req *http.Request) string {\n\tredirect := p.validateRedirect(\n\t\trequestutil.GetRequestURI(req),\n\t\t\"Invalid redirect generated from X-Forwarded-Uri header: %s\",\n\t)\n\tif redirect == \"\" {\n\t\tredirect = req.URL.RequestURI()\n\t}\n\n\tif p.hasProxyPrefix(redirect) {\n\t\treturn \"/\"\n\t}\n\treturn redirect\n}\n\n// splitHostPort separates host and port. If the port is not valid, it returns\n// the entire input as host, and it doesn't check the validity of the host.\n// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.\n// *** taken from net/url, modified validOptionalPort() to accept \":*\"\nfunc splitHostPort(hostport string) (host, port string) {\n\thost = hostport\n\n\tcolon := strings.LastIndexByte(host, ':')\n\tif colon != -1 && validOptionalPort(host[colon:]) {\n\t\thost, port = host[:colon], host[colon+1:]\n\t}\n\n\tif strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {\n\t\thost = host[1 : len(host)-1]\n\t}\n\n\treturn\n}\n\n// validOptionalPort reports whether port is either an empty string\n// or matches /^:\\d*$/\n// *** taken from net/url, modified to accept \":*\"\nfunc validOptionalPort(port string) bool {\n\tif port == \"\" || port == \":*\" {\n\t\treturn true\n\t}\n\tif port[0] != ':' {\n\t\treturn false\n\t}\n\tfor _, b := range port[1:] {\n\t\tif b < '0' || b > '9' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// getAuthenticatedSession checks whether a user is authenticated and returns a session object and nil error if so\n// Returns:\n// - `nil, ErrNeedsLogin` if user needs to login.\n// - `nil, ErrAccessDenied` if the authenticated user is not authorized\n// Set-Cookie headers may be set on the response as a side-effect of calling this method.\nfunc (p *OAuthProxy) getAuthenticatedSession(rw http.ResponseWriter, req *http.Request) (*sessionsapi.SessionState, error) {\n\tvar session *sessionsapi.SessionState\n\n\tgetSession := p.sessionChain.Then(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n\t\tsession = middlewareapi.GetRequestScope(req).Session\n\t}))\n\tgetSession.ServeHTTP(rw, req)\n\n\tif session == nil {\n\t\treturn nil, ErrNeedsLogin\n\t}\n\n\tinvalidEmail := session.Email != \"\" && !p.Validator(session.Email)\n\tauthorized, err := p.provider.Authorize(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error with authorization: %v\", err)\n\t}\n\n\tif invalidEmail || !authorized {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authorization via session: removing session %s\", session)\n\t\t// Invalid session, clear it\n\t\terr := p.ClearSessionCookie(rw, req)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error clearing session cookie: %v\", err)\n\t\t}\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\treturn session, nil\n}\n\n// authOnlyAuthorize handles special authorization logic that is only done\n// on the AuthOnly endpoint for use with Nginx subrequest architectures.\n//\n// TODO (@NickMeves): This method is a placeholder to be extended but currently\n// fails the linter. Remove the nolint when functionality expands.\n//\n//nolint:S1008\nfunc authOnlyAuthorize(req *http.Request, s *sessionsapi.SessionState) bool {\n\t// Allow secondary group restrictions based on the `allowed_groups`\n\t// querystring parameter\n\tif !checkAllowedGroups(req, s) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc checkAllowedGroups(req *http.Request, s *sessionsapi.SessionState) bool {\n\tallowedGroups := extractAllowedGroups(req)\n\tif len(allowedGroups) == 0 {\n\t\treturn true\n\t}\n\n\tfor _, group := range s.Groups {\n\t\tif _, ok := allowedGroups[group]; ok {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc extractAllowedGroups(req *http.Request) map[string]struct{} {\n\tgroups := map[string]struct{}{}\n\n\tquery := req.URL.Query()\n\tfor _, allowedGroups := range query[\"allowed_groups\"] {\n\t\tfor _, group := range strings.Split(allowedGroups, \",\") {\n\t\t\tif group != \"\" {\n\t\t\t\tgroups[group] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn groups\n}\n\n// addHeadersForProxying adds the appropriate headers the request / response for proxying\nfunc (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, session *sessionsapi.SessionState) {\n\tif session.Email == \"\" {\n\t\trw.Header().Set(\"GAP-Auth\", session.User)\n\t} else {\n\t\trw.Header().Set(\"GAP-Auth\", session.Email)\n\t}\n}\n\n// isAjax checks if a request is an ajax request\nfunc isAjax(req *http.Request) bool {\n\tacceptValues := req.Header.Values(\"Accept\")\n\tconst ajaxReq = applicationJSON\n\t// Iterate over multiple Accept headers, i.e.\n\t// Accept: application/json\n\t// Accept: text/plain\n\tfor _, mimeTypes := range acceptValues {\n\t\t// Iterate over multiple mimetypes in a single header, i.e.\n\t\t// Accept: application/json, text/plain, */*\n\t\tfor _, mimeType := range strings.Split(mimeTypes, \",\") {\n\t\t\tmimeType = strings.TrimSpace(mimeType)\n\t\t\tif mimeType == ajaxReq {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// errorJSON returns the error code with an application/json mime type\nfunc (p *OAuthProxy) errorJSON(rw http.ResponseWriter, code int) {\n\trw.Header().Set(\"Content-Type\", applicationJSON)\n\trw.WriteHeader(code)\n}\n", "package main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/mbland/hmacauth\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/middleware\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\tsessionscookie \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/sessions/cookie\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/upstream\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/validation\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/providers\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\t// The rawCookieSecret is 32 bytes and the base64CookieSecret is the base64\n\t// encoded version of this.\n\trawCookieSecret    = \"secretthirtytwobytes+abcdefghijk\"\n\tbase64CookieSecret = \"c2VjcmV0dGhpcnR5dHdvYnl0ZXMrYWJjZGVmZ2hpams\"\n\tclientID           = \"3984n253984d7348dm8234yf982t\"\n\tclientSecret       = \"gv3498mfc9t23y23974dm2394dm9\"\n)\n\nfunc init() {\n\tlogger.SetFlags(logger.Lshortfile)\n}\n\nfunc TestRobotsTxt(t *testing.T) {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/robots.txt\", nil)\n\tproxy.ServeHTTP(rw, req)\n\tassert.Equal(t, 200, rw.Code)\n\tassert.Equal(t, \"User-agent: *\\nDisallow: /\", rw.Body.String())\n}\n\nfunc TestIsValidRedirect(t *testing.T) {\n\topts := baseTestOptions()\n\t// Should match domains that are exactly foo.bar and any subdomain of bar.foo\n\topts.WhitelistDomains = []string{\n\t\t\"foo.bar\",\n\t\t\".bar.foo\",\n\t\t\"port.bar:8080\",\n\t\t\".sub.port.bar:8080\",\n\t\t\"anyport.bar:*\",\n\t\t\".sub.anyport.bar:*\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tDesc, Redirect string\n\t\tExpectedResult bool\n\t}{\n\t\t{\n\t\t\tDesc:           \"noRD\",\n\t\t\tRedirect:       \"\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"singleSlash\",\n\t\t\tRedirect:       \"/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"doubleSlash\",\n\t\t\tRedirect:       \"//redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTP\",\n\t\t\tRedirect:       \"http://foo.bar/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPS\",\n\t\t\tRedirect:       \"https://foo.bar/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPSubdomain\",\n\t\t\tRedirect:       \"http://baz.foo.bar/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPSSubdomain\",\n\t\t\tRedirect:       \"https://baz.foo.bar/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPSubdomain\",\n\t\t\tRedirect:       \"http://baz.bar.foo/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPSSubdomain\",\n\t\t\tRedirect:       \"https://baz.bar.foo/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validHTTPDomain\",\n\t\t\tRedirect:       \"http://bar.foo/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTP1\",\n\t\t\tRedirect:       \"http://foo.bar.evil.corp/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPS1\",\n\t\t\tRedirect:       \"https://foo.bar.evil.corp/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTP2\",\n\t\t\tRedirect:       \"http://evil.corp/redirect?rd=foo.bar\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidHTTPS2\",\n\t\t\tRedirect:       \"https://evil.corp/redirect?rd=foo.bar\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidPort\",\n\t\t\tRedirect:       \"https://evil.corp:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidEmptyPort\",\n\t\t\tRedirect:       \"http://foo.bar:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidEmptyPortSubdomain\",\n\t\t\tRedirect:       \"http://baz.bar.foo:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validSpecificPort\",\n\t\t\tRedirect:       \"http://port.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidSpecificPort\",\n\t\t\tRedirect:       \"http://port.bar:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validSpecificPortSubdomain\",\n\t\t\tRedirect:       \"http://foo.sub.port.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"invalidSpecificPortSubdomain\",\n\t\t\tRedirect:       \"http://foo.sub.port.bar:3838/redirect\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPort1\",\n\t\t\tRedirect:       \"http://anyport.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPort2\",\n\t\t\tRedirect:       \"http://anyport.bar:8081/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPortSubdomain1\",\n\t\t\tRedirect:       \"http://a.sub.anyport.bar:8080/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"validAnyPortSubdomain2\",\n\t\t\tRedirect:       \"http://a.sub.anyport.bar:8081/redirect\",\n\t\t\tExpectedResult: true,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirect1\",\n\t\t\tRedirect:       \"/\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectSpace1\",\n\t\t\tRedirect:       \"/ /evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectSpace2\",\n\t\t\tRedirect:       \"/ \\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTab1\",\n\t\t\tRedirect:       \"/\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTab2\",\n\t\t\tRedirect:       \"/\\t\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectVerticalTab1\",\n\t\t\tRedirect:       \"/\\v/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectVerticalTab2\",\n\t\t\tRedirect:       \"/\\v\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectNewLine1\",\n\t\t\tRedirect:       \"/\\n/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectNewLine2\",\n\t\t\tRedirect:       \"/\\n\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectCarriageReturn1\",\n\t\t\tRedirect:       \"/\\r/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectCarriageReturn2\",\n\t\t\tRedirect:       \"/\\r\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTripleTab\",\n\t\t\tRedirect:       \"/\\t\\t/\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectTripleTab2\",\n\t\t\tRedirect:       \"/\\t\\t\\\\\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectQuadTab1\",\n\t\t\tRedirect:       \"/\\t\\t/\\t\\t\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectQuadTab2\",\n\t\t\tRedirect:       \"/\\t\\t\\\\\\t\\t/evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectPeriod1\",\n\t\t\tRedirect:       \"/./\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectPeriod2\",\n\t\t\tRedirect:       \"/./../../\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectDoubleTab\",\n\t\t\tRedirect:       \"/\\t/\\t\\\\evil.com\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t\t{\n\t\t\tDesc:           \"openRedirectPartialSubdomain\",\n\t\t\tRedirect:       \"http://evilbar.foo\",\n\t\t\tExpectedResult: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.Desc, func(t *testing.T) {\n\t\t\tresult := proxy.IsValidRedirect(tc.Redirect)\n\n\t\t\tif result != tc.ExpectedResult {\n\t\t\t\tt.Errorf(\"expected %t got %t\", tc.ExpectedResult, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpenRedirects(t *testing.T) {\n\topts := baseTestOptions()\n\t// Should match domains that are exactly foo.bar and any subdomain of bar.foo\n\topts.WhitelistDomains = []string{\n\t\t\"foo.bar\",\n\t\t\".bar.foo\",\n\t\t\"port.bar:8080\",\n\t\t\".sub.port.bar:8080\",\n\t\t\"anyport.bar:*\",\n\t\t\".sub.anyport.bar:*\",\n\t\t\"www.whitelisteddomain.tld\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfile, err := os.Open(\"./testdata/openredirects.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func(t *testing.T) {\n\t\tif err := file.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}(t)\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\trd := scanner.Text()\n\t\tt.Run(rd, func(t *testing.T) {\n\t\t\trdUnescaped, err := url.QueryUnescape(rd)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif proxy.IsValidRedirect(rdUnescaped) {\n\t\t\t\tt.Errorf(\"Expected %q to not be valid (unescaped: %q)\", rd, rdUnescaped)\n\t\t\t}\n\t\t})\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype TestProvider struct {\n\t*providers.ProviderData\n\tEmailAddress   string\n\tValidToken     bool\n\tGroupValidator func(string) bool\n}\n\nvar _ providers.Provider = (*TestProvider)(nil)\n\nfunc NewTestProvider(providerURL *url.URL, emailAddress string) *TestProvider {\n\treturn &TestProvider{\n\t\tProviderData: &providers.ProviderData{\n\t\t\tProviderName: \"Test Provider\",\n\t\t\tLoginURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/oauth/authorize\",\n\t\t\t},\n\t\t\tRedeemURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/oauth/token\",\n\t\t\t},\n\t\t\tProfileURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/api/v1/profile\",\n\t\t\t},\n\t\t\tScope: \"profile.email\",\n\t\t},\n\t\tEmailAddress: emailAddress,\n\t\tGroupValidator: func(s string) bool {\n\t\t\treturn true\n\t\t},\n\t}\n}\n\nfunc (tp *TestProvider) GetEmailAddress(_ context.Context, _ *sessions.SessionState) (string, error) {\n\treturn tp.EmailAddress, nil\n}\n\nfunc (tp *TestProvider) ValidateSession(_ context.Context, _ *sessions.SessionState) bool {\n\treturn tp.ValidToken\n}\n\nfunc Test_redeemCode(t *testing.T) {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t_, err = proxy.redeemCode(req)\n\tassert.Equal(t, providers.ErrMissingCode, err)\n}\n\nfunc Test_enrichSession(t *testing.T) {\n\tconst (\n\t\tsessionUser   = \"Mr Session\"\n\t\tsessionEmail  = \"session@example.com\"\n\t\tproviderEmail = \"provider@example.com\"\n\t)\n\n\ttestCases := map[string]struct {\n\t\tsession       *sessions.SessionState\n\t\texpectedUser  string\n\t\texpectedEmail string\n\t}{\n\t\t\"Session already has enrichable fields\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:  sessionUser,\n\t\t\t\tEmail: sessionEmail,\n\t\t\t},\n\t\t\texpectedUser:  sessionUser,\n\t\t\texpectedEmail: sessionEmail,\n\t\t},\n\t\t\"Session is missing Email and GetEmailAddress is implemented\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser: sessionUser,\n\t\t\t},\n\t\t\texpectedUser:  sessionUser,\n\t\t\texpectedEmail: providerEmail,\n\t\t},\n\t\t\"Session is missing User and GetUserName is not implemented\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tEmail: sessionEmail,\n\t\t\t},\n\t\t\texpectedUser:  \"\",\n\t\t\texpectedEmail: sessionEmail,\n\t\t},\n\t}\n\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\topts := baseTestOptions()\n\t\t\terr := validation.Validate(opts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\t// intentionally set after validation.Validate(opts) since it will clobber\n\t\t\t// our TestProvider and call `providers.New` defaulting to `providers.GoogleProvider`\n\t\t\topts.SetProvider(NewTestProvider(&url.URL{Host: \"www.example.com\"}, providerEmail))\n\t\t\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = proxy.enrichSessionState(context.Background(), tc.session)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectedUser, tc.session.User)\n\t\t\tassert.Equal(t, tc.expectedEmail, tc.session.Email)\n\t\t})\n\t}\n}\n\nfunc TestBasicAuthPassword(t *testing.T) {\n\tproviderServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlogger.Printf(\"%#v\", r)\n\t\tvar payload string\n\t\tswitch r.URL.Path {\n\t\tcase \"/oauth/token\":\n\t\t\tpayload = `{\"access_token\": \"my_auth_token\"}`\n\t\tdefault:\n\t\t\tpayload = r.Header.Get(\"Authorization\")\n\t\t\tif payload == \"\" {\n\t\t\t\tpayload = \"No Authorization header found.\"\n\t\t\t}\n\t\t}\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(payload))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\n\tbasicAuthPassword := \"This is a secure password\"\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   providerServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  providerServer.URL,\n\t\t},\n\t}\n\n\topts.Cookie.Secure = false\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(basicAuthPassword),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproviderURL, _ := url.Parse(providerServer.URL)\n\tconst emailAddress = \"john.doe@example.com\"\n\n\topts.SetProvider(NewTestProvider(providerURL, emailAddress))\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Save the required session\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\terr = proxy.sessionStore.Save(rw, req, &sessions.SessionState{\n\t\tEmail: emailAddress,\n\t})\n\tassert.NoError(t, err)\n\n\t// Extract the cookie value to inject into the test request\n\tcookie := rw.Header().Values(\"Set-Cookie\")[0]\n\n\treq, _ = http.NewRequest(\"GET\", \"/\", nil)\n\treq.Header.Set(\"Cookie\", cookie)\n\trw = httptest.NewRecorder()\n\tproxy.ServeHTTP(rw, req)\n\n\t// The username in the basic auth credentials is expected to be equal to the email address from the\n\t// auth response, so we use the same variable here.\n\texpectedHeader := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(emailAddress+\":\"+basicAuthPassword))\n\tassert.Equal(t, expectedHeader, rw.Body.String())\n\tproviderServer.Close()\n}\n\nfunc TestPassGroupsHeadersWithGroups(t *testing.T) {\n\topts := baseTestOptions()\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Forwarded-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tconst emailAddress = \"john.doe@example.com\"\n\tconst userName = \"9fcab5c9b889a557\"\n\n\tgroups := []string{\"a\", \"b\"}\n\tcreated := time.Now()\n\tsession := &sessions.SessionState{\n\t\tUser:        userName,\n\t\tGroups:      groups,\n\t\tEmail:       emailAddress,\n\t\tAccessToken: \"oauth_token\",\n\t\tCreatedAt:   &created,\n\t}\n\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tassert.NoError(t, err)\n\n\t// Save the required session\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\terr = proxy.sessionStore.Save(rw, req, session)\n\tassert.NoError(t, err)\n\n\t// Extract the cookie value to inject into the test request\n\tcookie := rw.Header().Values(\"Set-Cookie\")[0]\n\n\treq, _ = http.NewRequest(\"GET\", \"/\", nil)\n\treq.Header.Set(\"Cookie\", cookie)\n\trw = httptest.NewRecorder()\n\tproxy.ServeHTTP(rw, req)\n\n\tassert.Equal(t, []string{\"a,b\"}, req.Header[\"X-Forwarded-Groups\"])\n}\n\ntype PassAccessTokenTest struct {\n\tproviderServer *httptest.Server\n\tproxy          *OAuthProxy\n\topts           *options.Options\n}\n\ntype PassAccessTokenTestOptions struct {\n\tPassAccessToken bool\n\tProxyUpstream   options.Upstream\n}\n\nfunc NewPassAccessTokenTest(opts PassAccessTokenTestOptions) (*PassAccessTokenTest, error) {\n\tpatt := &PassAccessTokenTest{}\n\n\tpatt.providerServer = httptest.NewServer(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tvar payload string\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/oauth/token\":\n\t\t\t\tpayload = `{\"access_token\": \"my_auth_token\"}`\n\t\t\tdefault:\n\t\t\t\tpayload = r.Header.Get(\"X-Forwarded-Access-Token\")\n\t\t\t\tif payload == \"\" {\n\t\t\t\t\tpayload = \"No access token found.\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.WriteHeader(200)\n\t\t\t_, err := w.Write([]byte(payload))\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}))\n\n\tpatt.opts = baseTestOptions()\n\tpatt.opts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   patt.providerServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  patt.providerServer.URL,\n\t\t},\n\t}\n\tif opts.ProxyUpstream.ID != \"\" {\n\t\tpatt.opts.UpstreamServers = append(patt.opts.UpstreamServers, opts.ProxyUpstream)\n\t}\n\n\tpatt.opts.Cookie.Secure = false\n\tif opts.PassAccessToken {\n\t\tpatt.opts.InjectRequestHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-Access-Token\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"access_token\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\terr := validation.Validate(patt.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproviderURL, _ := url.Parse(patt.providerServer.URL)\n\tconst emailAddress = \"michael.bland@gsa.gov\"\n\n\tpatt.opts.SetProvider(NewTestProvider(providerURL, emailAddress))\n\tpatt.proxy, err = NewOAuthProxy(patt.opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn patt, nil\n}\n\nfunc (patTest *PassAccessTokenTest) Close() {\n\tpatTest.providerServer.Close()\n}\n\nfunc (patTest *PassAccessTokenTest) getCallbackEndpoint() (httpCode int,\n\tcookie string) {\n\trw := httptest.NewRecorder()\n\treq, err := http.NewRequest(\"GET\", \"/oauth2/callback?code=callback_code&state=nonce:\",\n\t\tstrings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, \"\"\n\t}\n\treq.AddCookie(patTest.proxy.MakeCSRFCookie(req, \"nonce\", time.Hour, time.Now()))\n\tpatTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Header().Values(\"Set-Cookie\")[1]\n}\n\n// getEndpointWithCookie makes a requests againt the oauthproxy with passed requestPath\n// and cookie and returns body and status code.\nfunc (patTest *PassAccessTokenTest) getEndpointWithCookie(cookie string, endpoint string) (httpCode int, accessToken string) {\n\tcookieName := patTest.proxy.CookieName\n\tvar value string\n\tkeyPrefix := cookieName + \"=\"\n\n\tfor _, field := range strings.Split(cookie, \"; \") {\n\t\tvalue = strings.TrimPrefix(field, keyPrefix)\n\t\tif value != field {\n\t\t\tbreak\n\t\t} else {\n\t\t\tvalue = \"\"\n\t\t}\n\t}\n\tif value == \"\" {\n\t\treturn 0, \"\"\n\t}\n\n\treq, err := http.NewRequest(\"GET\", endpoint, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, \"\"\n\t}\n\treq.AddCookie(&http.Cookie{\n\t\tName:     cookieName,\n\t\tValue:    value,\n\t\tPath:     \"/\",\n\t\tExpires:  time.Now().Add(time.Duration(24)),\n\t\tHttpOnly: true,\n\t})\n\n\trw := httptest.NewRecorder()\n\tpatTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Body.String()\n}\n\nfunc TestForwardAccessTokenUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotNil(t, cookie)\n\n\t// Now we make a regular request; the access_token from the cookie is\n\t// forwarded as the \"X-Forwarded-Access-Token\" header. The token is\n\t// read by the test provider server and written in the response body.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"my_auth_token\", payload)\n}\n\nfunc TestStaticProxyUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: true,\n\t\tProxyUpstream: options.Upstream{\n\t\t\tID:     \"static-proxy\",\n\t\t\tPath:   \"/static-proxy\",\n\t\t\tStatic: true,\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotEqual(t, nil, cookie)\n\n\t// Now we make a regular request against the upstream proxy; And validate\n\t// the returned status code through the static proxy.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/static-proxy\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"Authenticated\", payload)\n}\n\nfunc TestDoNotForwardAccessTokenUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: false,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotEqual(t, nil, cookie)\n\n\t// Now we make a regular request, but the access token header should\n\t// not be present.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"No access token found.\", payload)\n}\n\ntype SignInPageTest struct {\n\topts                 *options.Options\n\tproxy                *OAuthProxy\n\tsignInRegexp         *regexp.Regexp\n\tsignInProviderRegexp *regexp.Regexp\n}\n\nconst signInRedirectPattern = `<input type=\"hidden\" name=\"rd\" value=\"(.*)\">`\nconst signInSkipProvider = `>Found<`\n\nfunc NewSignInPageTest(skipProvider bool) (*SignInPageTest, error) {\n\tvar sipTest SignInPageTest\n\n\tsipTest.opts = baseTestOptions()\n\tsipTest.opts.SkipProviderButton = skipProvider\n\terr := validation.Validate(sipTest.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsipTest.proxy, err = NewOAuthProxy(sipTest.opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsipTest.signInRegexp = regexp.MustCompile(signInRedirectPattern)\n\tsipTest.signInProviderRegexp = regexp.MustCompile(signInSkipProvider)\n\n\treturn &sipTest, nil\n}\n\nfunc (sipTest *SignInPageTest) GetEndpoint(endpoint string) (int, string) {\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", endpoint, strings.NewReader(\"\"))\n\tsipTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Body.String()\n}\n\nfunc TestSignInPageIncludesTargetRedirect(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst endpoint = \"/some/random/endpoint\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 403, code)\n\n\tmatch := sipTest.signInRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInRedirectPattern + \"\\nBody:\\n\" + body)\n\t}\n\tif match[1] != endpoint {\n\t\tt.Fatal(`expected redirect to \"` + endpoint +\n\t\t\t`\", but was \"` + match[1] + `\"`)\n\t}\n}\n\nfunc TestSignInPageDirectAccessRedirectsToRoot(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, body := sipTest.GetEndpoint(\"/oauth2/sign_in\")\n\tassert.Equal(t, 200, code)\n\n\tmatch := sipTest.signInRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInRedirectPattern + \"\\nBody:\\n\" + body)\n\t}\n\tif match[1] != \"/\" {\n\t\tt.Fatal(`expected redirect to \"/\", but was \"` + match[1] + `\"`)\n\t}\n}\n\nfunc TestSignInPageSkipProvider(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tendpoint := \"/some/random/endpoint\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 302, code)\n\n\tmatch := sipTest.signInProviderRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInSkipProvider + \"\\nBody:\\n\" + body)\n\t}\n}\n\nfunc TestSignInPageSkipProviderDirect(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tendpoint := \"/sign_in\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 302, code)\n\n\tmatch := sipTest.signInProviderRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(\"Did not find pattern in body: \" +\n\t\t\tsignInSkipProvider + \"\\nBody:\\n\" + body)\n\t}\n}\n\ntype ProcessCookieTest struct {\n\topts         *options.Options\n\tproxy        *OAuthProxy\n\trw           *httptest.ResponseRecorder\n\treq          *http.Request\n\tvalidateUser bool\n}\n\ntype ProcessCookieTestOpts struct {\n\tproviderValidateCookieResponse bool\n}\n\ntype OptionsModifier func(*options.Options)\n\nfunc NewProcessCookieTest(opts ProcessCookieTestOpts, modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tfor _, modifier := range modifiers {\n\t\tmodifier(pcTest.opts)\n\t}\n\t// First, set the CookieRefresh option so proxy.AesCipher is created,\n\t// needed to encrypt the access_token.\n\tpcTest.opts.Cookie.Refresh = time.Hour\n\terr := validation.Validate(pcTest.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   opts.providerValidateCookieResponse,\n\t}\n\tpcTest.proxy.provider.(*TestProvider).SetAllowedGroups(pcTest.opts.AllowedGroups)\n\n\t// Now, zero-out proxy.CookieRefresh for the cases that don't involve\n\t// access_token validation.\n\tpcTest.proxy.CookieRefresh = time.Duration(0)\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\", \"/\", strings.NewReader(\"\"))\n\tpcTest.validateUser = true\n\treturn &pcTest, nil\n}\n\nfunc NewProcessCookieTestWithDefaults() (*ProcessCookieTest, error) {\n\treturn NewProcessCookieTest(ProcessCookieTestOpts{\n\t\tproviderValidateCookieResponse: true,\n\t})\n}\n\nfunc NewProcessCookieTestWithOptionsModifiers(modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\treturn NewProcessCookieTest(ProcessCookieTestOpts{\n\t\tproviderValidateCookieResponse: true,\n\t}, modifiers...)\n}\n\nfunc (p *ProcessCookieTest) SaveSession(s *sessions.SessionState) error {\n\terr := p.proxy.SaveSession(p.rw, p.req, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, cookie := range p.rw.Result().Cookies() {\n\t\tp.req.AddCookie(cookie)\n\t}\n\treturn nil\n}\n\nfunc (p *ProcessCookieTest) LoadCookiedSession() (*sessions.SessionState, error) {\n\treturn p.proxy.LoadCookiedSession(p.req)\n}\n\nfunc TestLoadCookiedSession(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{Email: \"john.doe@example.com\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassert.Equal(t, startSession.Email, session.Email)\n\tassert.Equal(t, \"\", session.User)\n\tassert.Equal(t, startSession.AccessToken, session.AccessToken)\n}\n\nfunc TestProcessCookieNoCookieError(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.Error(t, err, \"cookie \\\"_oauth2_proxy\\\" not present\")\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session. got %#v\", session)\n\t}\n}\n\nfunc TestProcessCookieRefreshNotSet(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(23) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(-2) * time.Hour)\n\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.Equal(t, nil, err)\n\tif session.Age() < time.Duration(-2)*time.Hour {\n\t\tt.Errorf(\"cookie too young %v\", session.Age())\n\t}\n\tassert.Equal(t, startSession.Email, session.Email)\n}\n\nfunc TestProcessCookieFailIfCookieExpired(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.NotEqual(t, nil, err)\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session %#v\", session)\n\t}\n}\n\nfunc TestProcessCookieFailIfRefreshSetAndCookieExpired(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.CookieRefresh = time.Hour\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.NotEqual(t, nil, err)\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session %#v\", session)\n\t}\n}\n\nfunc NewUserInfoEndpointTest() (*ProcessCookieTest, error) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/userinfo\", nil)\n\treturn pcTest, nil\n}\n\nfunc TestUserInfoEndpointAccepted(t *testing.T) {\n\ttestCases := []struct {\n\t\tname             string\n\t\tsession          *sessions.SessionState\n\t\texpectedResponse string\n\t}{\n\t\t{\n\t\t\tname: \"Full session\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:        \"john.doe\",\n\t\t\t\tEmail:       \"john.doe@example.com\",\n\t\t\t\tGroups:      []string{\"example\", \"groups\"},\n\t\t\t\tAccessToken: \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"Minimal session\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:   \"john.doe\",\n\t\t\t\tEmail:  \"john.doe@example.com\",\n\t\t\t\tGroups: []string{\"example\", \"groups\"},\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"No groups\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:        \"john.doe\",\n\t\t\t\tEmail:       \"john.doe@example.com\",\n\t\t\t\tAccessToken: \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"With Preferred Username\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:              \"john.doe\",\n\t\t\t\tPreferredUsername: \"john\",\n\t\t\t\tEmail:             \"john.doe@example.com\",\n\t\t\t\tGroups:            []string{\"example\", \"groups\"},\n\t\t\t\tAccessToken:       \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"],\\\"preferredUsername\\\":\\\"john\\\"}\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest, err := NewUserInfoEndpointTest()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terr = test.SaveSession(tc.session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\t\t\tassert.Equal(t, http.StatusOK, test.rw.Code)\n\t\t\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\t\t\tassert.Equal(t, tc.expectedResponse, string(bodyBytes))\n\t\t})\n\t}\n}\n\nfunc TestUserInfoEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {\n\ttest, err := NewUserInfoEndpointTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n}\n\nfunc NewAuthOnlyEndpointTest(querystring string, modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(modifiers...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.req, _ = http.NewRequest(\n\t\t\"GET\",\n\t\tfmt.Sprintf(\"%s/auth%s\", pcTest.opts.ProxyPrefix, querystring),\n\t\tnil)\n\treturn pcTest, nil\n}\n\nfunc TestAuthOnlyEndpointAccepted(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusAccepted, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnExpiration(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\", func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnEmailValidationFailure(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\ttest.validateUser = false\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := ioutil.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointSetXAuthRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tpcTest.opts.AllowedGroups = []string{\"oauth_groups\"}\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/auth\", nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Groups: []string{\"oauth_groups\"}, Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Get(\"X-Auth-Request-User\"))\n\tassert.Equal(t, startSession.Groups, pcTest.rw.Header().Values(\"X-Auth-Request-Groups\"))\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Get(\"X-Auth-Request-Email\"))\n}\n\nfunc TestAuthOnlyEndpointSetBasicAuthTrueRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(\"This is a secure password\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/auth\", nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Values(\"X-Auth-Request-User\")[0])\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Values(\"X-Auth-Request-Email\")[0])\n\texpectedHeader := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"oauth_user:This is a secure password\"))\n\tassert.Equal(t, expectedHeader, pcTest.rw.Header().Values(\"Authorization\")[0])\n}\n\nfunc TestAuthOnlyEndpointSetBasicAuthFalseRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/auth\", nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Values(\"X-Auth-Request-User\")[0])\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Values(\"X-Auth-Request-Email\")[0])\n\tassert.Equal(t, 0, len(pcTest.rw.Header().Values(\"Authorization\")), \"should not have Authorization header entries\")\n}\n\nfunc TestAuthSkippedForPreflightRequests(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"response\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\topts.SkipAuthPreflight = true\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tupstreamURL, _ := url.Parse(upstreamServer.URL)\n\topts.SetProvider(NewTestProvider(upstreamURL, \"\"))\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return false })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"OPTIONS\", \"/preflight-request\", nil)\n\tproxy.ServeHTTP(rw, req)\n\n\tassert.Equal(t, 200, rw.Code)\n\tassert.Equal(t, \"response\", rw.Body.String())\n}\n\ntype SignatureAuthenticator struct {\n\tauth hmacauth.HmacAuth\n}\n\nfunc (v *SignatureAuthenticator) Authenticate(w http.ResponseWriter, r *http.Request) {\n\tresult, headerSig, computedSig := v.auth.AuthenticateRequest(r)\n\n\tvar msg string\n\tswitch result {\n\tcase hmacauth.ResultNoSignature:\n\t\tmsg = \"no signature received\"\n\tcase hmacauth.ResultMatch:\n\t\tmsg = \"signatures match\"\n\tcase hmacauth.ResultMismatch:\n\t\tmsg = fmt.Sprintf(\n\t\t\t\"signatures do not match:\\n  received: %s\\n  computed: %s\",\n\t\t\theaderSig,\n\t\t\tcomputedSig)\n\tdefault:\n\t\tpanic(\"unknown result value: \" + result.String())\n\t}\n\n\t_, err := w.Write([]byte(msg))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\ntype SignatureTest struct {\n\topts          *options.Options\n\tupstream      *httptest.Server\n\tupstreamHost  string\n\tprovider      *httptest.Server\n\theader        http.Header\n\trw            *httptest.ResponseRecorder\n\tauthenticator *SignatureAuthenticator\n}\n\nfunc NewSignatureTest() (*SignatureTest, error) {\n\topts := baseTestOptions()\n\topts.EmailDomains = []string{\"acm.org\"}\n\n\tauthenticator := &SignatureAuthenticator{}\n\tupstreamServer := httptest.NewServer(\n\t\thttp.HandlerFunc(authenticator.Authenticate))\n\tupstreamURL, err := url.Parse(upstreamServer.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\n\tproviderHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := w.Write([]byte(`{\"access_token\": \"my_auth_token\"}`))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tprovider := httptest.NewServer(http.HandlerFunc(providerHandler))\n\tproviderURL, err := url.Parse(provider.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts.SetProvider(NewTestProvider(providerURL, \"mbland@acm.org\"))\n\n\treturn &SignatureTest{\n\t\topts,\n\t\tupstreamServer,\n\t\tupstreamURL.Host,\n\t\tprovider,\n\t\tmake(http.Header),\n\t\thttptest.NewRecorder(),\n\t\tauthenticator,\n\t}, nil\n}\n\nfunc (st *SignatureTest) Close() {\n\tst.provider.Close()\n\tst.upstream.Close()\n}\n\n// fakeNetConn simulates an http.Request.Body buffer that will be consumed\n// when it is read by the hmacauth.HmacAuth if not handled properly. See:\n//   https://github.com/18F/hmacauth/pull/4\ntype fakeNetConn struct {\n\treqBody string\n}\n\nfunc (fnc *fakeNetConn) Read(p []byte) (n int, err error) {\n\tif bodyLen := len(fnc.reqBody); bodyLen != 0 {\n\t\tcopy(p, fnc.reqBody)\n\t\tfnc.reqBody = \"\"\n\t\treturn bodyLen, io.EOF\n\t}\n\treturn 0, io.EOF\n}\n\nfunc (st *SignatureTest) MakeRequestWithExpectedKey(method, body, key string) error {\n\terr := validation.Validate(st.opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy, err := NewOAuthProxy(st.opts, func(email string) bool { return true })\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar bodyBuf io.ReadCloser\n\tif body != \"\" {\n\t\tbodyBuf = ioutil.NopCloser(&fakeNetConn{reqBody: body})\n\t}\n\treq := httptest.NewRequest(method, \"/foo/bar\", bodyBuf)\n\treq.Header = st.header\n\n\tstate := &sessions.SessionState{\n\t\tEmail: \"mbland@acm.org\", AccessToken: \"my_access_token\"}\n\terr = proxy.SaveSession(st.rw, req, state)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, c := range st.rw.Result().Cookies() {\n\t\treq.AddCookie(c)\n\t}\n\t// This is used by the upstream to validate the signature.\n\tst.authenticator.auth = hmacauth.NewHmacAuth(\n\t\tcrypto.SHA1, []byte(key), upstream.SignatureHeader, upstream.SignatureHeaders)\n\tproxy.ServeHTTP(st.rw, req)\n\n\treturn nil\n}\n\nfunc TestRequestSignature(t *testing.T) {\n\ttestCases := map[string]struct {\n\t\tmethod string\n\t\tbody   string\n\t\tkey    string\n\t\tresp   string\n\t}{\n\t\t\"No request signature\": {\n\t\t\tmethod: \"GET\",\n\t\t\tbody:   \"\",\n\t\t\tkey:    \"\",\n\t\t\tresp:   \"no signature received\",\n\t\t},\n\t\t\"Get request\": {\n\t\t\tmethod: \"GET\",\n\t\t\tbody:   \"\",\n\t\t\tkey:    \"7d9e1aa87a5954e6f9fc59266b3af9d7c35fda2d\",\n\t\t\tresp:   \"signatures match\",\n\t\t},\n\t\t\"Post request\": {\n\t\t\tmethod: \"POST\",\n\t\t\tbody:   `{ \"hello\": \"world!\" }`,\n\t\t\tkey:    \"d90df39e2d19282840252612dd7c81421a372f61\",\n\t\t\tresp:   \"signatures match\",\n\t\t},\n\t}\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tst, err := NewSignatureTest()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tt.Cleanup(st.Close)\n\t\t\tif tc.key != \"\" {\n\t\t\t\tst.opts.SignatureKey = fmt.Sprintf(\"sha1:%s\", tc.key)\n\t\t\t}\n\t\t\terr = st.MakeRequestWithExpectedKey(tc.method, tc.body, tc.key)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, 200, st.rw.Code)\n\t\t\tassert.Equal(t, tc.resp, st.rw.Body.String())\n\t\t})\n\t}\n}\n\nfunc Test_getAppRedirect(t *testing.T) {\n\topts := baseTestOptions()\n\topts.WhitelistDomains = append(opts.WhitelistDomains, \".example.com\", \".example.com:8443\")\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\trequire.NotEmpty(t, opts.ProxyPrefix)\n\tproxy, err := NewOAuthProxy(opts, func(s string) bool { return false })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\tname             string\n\t\turl              string\n\t\theaders          map[string]string\n\t\treverseProxy     bool\n\t\texpectedRedirect string\n\t}{\n\t\t{\n\t\t\tname:             \"request outside of ProxyPrefix redirects to original URL\",\n\t\t\turl:              \"/foo/bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"request with query preserves query\",\n\t\t\turl:              \"/foo?bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"request under ProxyPrefix redirects to root\",\n\t\t\turl:              proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request outside of ProxyPrefix redirects to proxied URL\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"non-proxied request with spoofed proxy headers wouldn't redirect\",\n\t\t\turl:  \"https://oauth.example.com/foo?bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request under ProxyPrefix redirects to root\",\n\t\t\turl:  \"https://oauth.example.com\" + proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with port under ProxyPrefix redirects to root\",\n\t\t\turl:  \"https://oauth.example.com\" + proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com:8443\",\n\t\t\t\t\"X-Forwarded-Uri\":   proxy.ProxyPrefix + \"/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com:8443/\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with missing uri header would still redirect to desired redirect\",\n\t\t\turl:  \"https://oauth.example.com/foo?bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"a-service.example.com\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"request with headers proxy not being set (and reverse proxy enabled) would still redirect to desired redirect\",\n\t\t\turl:              \"https://oauth.example.com/foo?bar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"/foo?bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with X-Auth-Request-Redirect being set outside of ProxyPrefix redirects to proxied URL\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Auth-Request-Redirect\": \"https://a-service.example.com/foo/bar\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname:             \"proxied request with rd query string redirects to proxied URL\",\n\t\t\turl:              \"https://oauth.example.com/foo/bar?rd=https%3A%2F%2Fa%2Dservice%2Eexample%2Ecom%2Ffoo%2Fbar\",\n\t\t\theaders:          nil,\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with rd query string and all headers set (and reverse proxy not enabled) redirects to proxied URL on rd query string\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar?rd=https%3A%2F%2Fa%2Dservice%2Eexample%2Ecom%2Ffoo%2Fjazz\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Auth-Request-Redirect\": \"https://a-service.example.com/foo/baz\",\n\t\t\t\t\"X-Forwarded-Proto\":       \"http\",\n\t\t\t\t\"X-Forwarded-Host\":        \"another-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":         \"/seasons/greetings\",\n\t\t\t},\n\t\t\treverseProxy:     false,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/jazz\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxied request with rd query string and some headers set redirects to proxied URL on rd query string\",\n\t\t\turl:  \"https://oauth.example.com/foo/bar?rd=https%3A%2F%2Fa%2Dservice%2Eexample%2Ecom%2Ffoo%2Fbaz\",\n\t\t\theaders: map[string]string{\n\t\t\t\t\"X-Forwarded-Proto\": \"https\",\n\t\t\t\t\"X-Forwarded-Host\":  \"another-service.example.com\",\n\t\t\t\t\"X-Forwarded-Uri\":   \"/seasons/greetings\",\n\t\t\t},\n\t\t\treverseProxy:     true,\n\t\t\texpectedRedirect: \"https://a-service.example.com/foo/baz\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\treq, _ := http.NewRequest(\"GET\", tt.url, nil)\n\t\t\tfor header, value := range tt.headers {\n\t\t\t\tif value != \"\" {\n\t\t\t\t\treq.Header.Add(header, value)\n\t\t\t\t}\n\t\t\t}\n\t\t\treq = middleware.AddRequestScope(req, &middleware.RequestScope{\n\t\t\t\tReverseProxy: tt.reverseProxy,\n\t\t\t})\n\t\t\tredirect, err := proxy.getAppRedirect(req)\n\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tt.expectedRedirect, redirect)\n\t\t})\n\t}\n}\n\ntype ajaxRequestTest struct {\n\topts  *options.Options\n\tproxy *OAuthProxy\n}\n\nfunc newAjaxRequestTest() (*ajaxRequestTest, error) {\n\ttest := &ajaxRequestTest{}\n\ttest.opts = baseTestOptions()\n\terr := validation.Validate(test.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttest.proxy, err = NewOAuthProxy(test.opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn test, nil\n}\n\nfunc (test *ajaxRequestTest) getEndpoint(endpoint string, header http.Header) (int, http.Header, error) {\n\trw := httptest.NewRecorder()\n\treq, err := http.NewRequest(http.MethodGet, endpoint, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\treq.Header = header\n\ttest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Header(), nil\n}\n\nfunc testAjaxUnauthorizedRequest(t *testing.T, header http.Header) {\n\ttest, err := newAjaxRequestTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tendpoint := \"/test\"\n\n\tcode, rh, err := test.getEndpoint(endpoint, header)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusUnauthorized, code)\n\tmime := rh.Get(\"Content-Type\")\n\tassert.Equal(t, applicationJSON, mime)\n}\nfunc TestAjaxUnauthorizedRequest1(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"accept\", applicationJSON)\n\n\ttestAjaxUnauthorizedRequest(t, header)\n}\n\nfunc TestAjaxUnauthorizedRequest2(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"Accept\", applicationJSON)\n\n\ttestAjaxUnauthorizedRequest(t, header)\n}\n\nfunc TestAjaxUnauthorizedRequestAccept1(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"Accept\", \"application/json, text/plain, */*\")\n\n\ttestAjaxUnauthorizedRequest(t, header)\n}\n\nfunc TestAjaxForbiddendRequest(t *testing.T) {\n\ttest, err := newAjaxRequestTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tendpoint := \"/test\"\n\theader := make(http.Header)\n\tcode, rh, err := test.getEndpoint(endpoint, header)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusForbidden, code)\n\tmime := rh.Get(\"Content-Type\")\n\tassert.NotEqual(t, applicationJSON, mime)\n}\n\nfunc TestClearSplitCookie(t *testing.T) {\n\topts := baseTestOptions()\n\topts.Cookie.Secret = base64CookieSecret\n\topts.Cookie.Name = \"oauth2\"\n\topts.Cookie.Domains = []string{\"abc\"}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tstore, err := sessionscookie.NewCookieSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := OAuthProxy{CookieName: opts.Cookie.Name, CookieDomains: opts.Cookie.Domains, sessionStore: store}\n\tvar rw = httptest.NewRecorder()\n\treq := httptest.NewRequest(\"get\", \"/\", nil)\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"test1\",\n\t\tValue: \"test1\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2_0\",\n\t\tValue: \"oauth2_0\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2_1\",\n\t\tValue: \"oauth2_1\",\n\t})\n\n\terr = p.ClearSessionCookie(rw, req)\n\tassert.NoError(t, err)\n\theader := rw.Header()\n\n\tassert.Equal(t, 2, len(header[\"Set-Cookie\"]), \"should have 3 set-cookie header entries\")\n}\n\nfunc TestClearSingleCookie(t *testing.T) {\n\topts := baseTestOptions()\n\topts.Cookie.Name = \"oauth2\"\n\topts.Cookie.Domains = []string{\"abc\"}\n\tstore, err := sessionscookie.NewCookieSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := OAuthProxy{CookieName: opts.Cookie.Name, CookieDomains: opts.Cookie.Domains, sessionStore: store}\n\tvar rw = httptest.NewRecorder()\n\treq := httptest.NewRequest(\"get\", \"/\", nil)\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"test1\",\n\t\tValue: \"test1\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2\",\n\t\tValue: \"oauth2\",\n\t})\n\n\terr = p.ClearSessionCookie(rw, req)\n\tassert.NoError(t, err)\n\theader := rw.Header()\n\n\tassert.Equal(t, 1, len(header[\"Set-Cookie\"]), \"should have 1 set-cookie header entries\")\n}\n\ntype NoOpKeySet struct {\n}\n\nfunc (NoOpKeySet) VerifySignature(_ context.Context, jwt string) (payload []byte, err error) {\n\tsplitStrings := strings.Split(jwt, \".\")\n\tpayloadString := splitStrings[1]\n\treturn base64.RawURLEncoding.DecodeString(payloadString)\n}\n\nfunc TestGetJwtSession(t *testing.T) {\n\t/* token payload:\n\t{\n\t  \"sub\": \"1234567890\",\n\t  \"aud\": \"https://test.myapp.com\",\n\t  \"name\": \"John Doe\",\n\t  \"email\": \"john@example.com\",\n\t  \"iss\": \"https://issuer.example.com\",\n\t  \"iat\": 1553691215,\n\t  \"exp\": 1912151821\n\t}\n\t*/\n\tgoodJwt := \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\" +\n\t\t\"eyJzdWIiOiIxMjM0NTY3ODkwIiwiYXVkIjoiaHR0cHM6Ly90ZXN0Lm15YXBwLmNvbSIsIm5hbWUiOiJKb2huIERvZSIsImVtY\" +\n\t\t\"WlsIjoiam9obkBleGFtcGxlLmNvbSIsImlzcyI6Imh0dHBzOi8vaXNzdWVyLmV4YW1wbGUuY29tIiwiaWF0IjoxNTUzNjkxMj\" +\n\t\t\"E1LCJleHAiOjE5MTIxNTE4MjF9.\" +\n\t\t\"rLVyzOnEldUq_pNkfa-WiV8TVJYWyZCaM2Am_uo8FGg11zD7l-qmz3x1seTvqpH6Y0Ty00fmv6dJnGnC8WMnPXQiodRTfhBSe\" +\n\t\t\"OKZMu0HkMD2sg52zlKkbfLTO6ic5VnbVgwjjrB8am_Ta6w7kyFUaB5C1BsIrrLMldkWEhynbb8\"\n\n\tkeyset := NoOpKeySet{}\n\tverifier := oidc.NewVerifier(\"https://issuer.example.com\", keyset,\n\t\t&oidc.Config{ClientID: \"https://test.myapp.com\", SkipExpiryCheck: true})\n\n\ttest, err := NewAuthOnlyEndpointTest(\"\", func(opts *options.Options) {\n\t\topts.InjectRequestHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"Authorization\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim:  \"id_token\",\n\t\t\t\t\t\t\tPrefix: \"Bearer \",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-User\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-Email\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\topts.InjectResponseHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"Authorization\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim:  \"id_token\",\n\t\t\t\t\t\t\tPrefix: \"Bearer \",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Auth-Request-User\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\topts.SkipJwtBearerTokens = true\n\t\topts.SetJWTBearerVerifiers(append(opts.GetJWTBearerVerifiers(), verifier))\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttp, _ := test.proxy.provider.(*TestProvider)\n\ttp.GroupValidator = func(s string) bool {\n\t\treturn true\n\t}\n\n\tauthHeader := fmt.Sprintf(\"Bearer %s\", goodJwt)\n\ttest.req.Header = map[string][]string{\n\t\t\"Authorization\": {authHeader},\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tif test.rw.Code >= 400 {\n\t\tt.Fatalf(\"expected 3xx got %d\", test.rw.Code)\n\t}\n\n\t// Check PassAuthorization, should overwrite Basic header\n\tassert.Equal(t, test.req.Header.Get(\"Authorization\"), authHeader)\n\tassert.Equal(t, test.req.Header.Get(\"X-Forwarded-User\"), \"1234567890\")\n\tassert.Equal(t, test.req.Header.Get(\"X-Forwarded-Email\"), \"john@example.com\")\n\n\t// SetAuthorization and SetXAuthRequest\n\tassert.Equal(t, test.rw.Header().Get(\"Authorization\"), authHeader)\n\tassert.Equal(t, test.rw.Header().Get(\"X-Auth-Request-User\"), \"1234567890\")\n\tassert.Equal(t, test.rw.Header().Get(\"X-Auth-Request-Email\"), \"john@example.com\")\n}\n\nfunc Test_prepareNoCache(t *testing.T) {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprepareNoCache(w)\n\t})\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", handler)\n\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tmux.ServeHTTP(rec, req)\n\n\tfor k, v := range noCacheHeaders {\n\t\tassert.Equal(t, rec.Header().Get(k), v)\n\t}\n}\n\nfunc Test_noCacheHeaders(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := w.Write([]byte(\"upstream\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\".*\"}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tt.Run(\"not exist in response from upstream\", func(t *testing.T) {\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, \"/upstream\", nil)\n\t\tproxy.ServeHTTP(rec, req)\n\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"upstream\", rec.Body.String())\n\n\t\t// checking noCacheHeaders does not exists in response headers from upstream\n\t\tfor k := range noCacheHeaders {\n\t\t\tassert.Equal(t, \"\", rec.Header().Get(k))\n\t\t}\n\t})\n\n\tt.Run(\"has no-cache\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tpath       string\n\t\t\thasNoCache bool\n\t\t}{\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/sign_in\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/sign_out\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/start\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/callback\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/auth\",\n\t\t\t\thasNoCache: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/userinfo\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/upstream\",\n\t\t\t\thasNoCache: false,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.path, func(t *testing.T) {\n\t\t\t\trec := httptest.NewRecorder()\n\t\t\t\treq := httptest.NewRequest(http.MethodGet, tt.path, nil)\n\t\t\t\tproxy.ServeHTTP(rec, req)\n\t\t\t\tcacheControl := rec.Result().Header.Get(\"Cache-Control\")\n\t\t\t\tif tt.hasNoCache != (strings.Contains(cacheControl, \"no-cache\")) {\n\t\t\t\t\tt.Errorf(`unexpected \"Cache-Control\" header: %s`, cacheControl)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t})\n}\n\nfunc baseTestOptions() *options.Options {\n\topts := options.NewOptions()\n\topts.Cookie.Secret = rawCookieSecret\n\topts.ClientID = clientID\n\topts.ClientSecret = clientSecret\n\topts.EmailDomains = []string{\"*\"}\n\n\t// Default injected headers for legacy configuration\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(base64.StdEncoding.EncodeToString([]byte(\"This is a secure password\"))),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\treturn opts\n}\n\nfunc TestTrustedIPs(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\ttrustedIPs         []string\n\t\treverseProxy       bool\n\t\trealClientIPHeader string\n\t\treq                *http.Request\n\t\texpectTrusted      bool\n\t}{\n\t\t// Check unconfigured behavior.\n\t\t{\n\t\t\tname:               \"Default\",\n\t\t\ttrustedIPs:         nil,\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check using req.RemoteAddr (Options.ReverseProxy == false).\n\t\t{\n\t\t\tname:               \"WithRemoteAddr\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.1\"},\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"127.0.0.1:43670\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check ignores req.RemoteAddr match when behind a reverse proxy / missing header.\n\t\t{\n\t\t\tname:               \"IgnoresRemoteAddrInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"127.0.0.1:44324\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check successful trusting of localhost in IPv4.\n\t\t{\n\t\t\tname:               \"TrustsLocalhostInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"127.0.0.1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check successful trusting of localhost in IPv6.\n\t\t{\n\t\t\tname:               \"TrustsIP6LocalostInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"::1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check does not trust random IPv4 address.\n\t\t{\n\t\t\tname:               \"DoesNotTrustRandomIP4Address\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"12.34.56.78\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check does not trust random IPv6 address.\n\t\t{\n\t\t\tname:               \"DoesNotTrustRandomIP6Address\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"::2\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check respects correct header.\n\t\t{\n\t\t\tname:               \"RespectsCorrectHeaderInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Real-IP\", \"::1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check doesn't trust if garbage is provided.\n\t\t{\n\t\t\tname:               \"DoesNotTrustGarbageInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"adsfljk29242as!!\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check doesn't trust if garbage is provided (no reverse-proxy).\n\t\t{\n\t\t\tname:               \"DoesNotTrustGarbage\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"adsfljk29242as!!\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\topts := baseTestOptions()\n\t\t\topts.UpstreamServers = options.Upstreams{\n\t\t\t\t{\n\t\t\t\t\tID:     \"static\",\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t\tStatic: true,\n\t\t\t\t},\n\t\t\t}\n\t\t\topts.TrustedIPs = tt.trustedIPs\n\t\t\topts.ReverseProxy = tt.reverseProxy\n\t\t\topts.RealClientIPHeader = tt.realClientIPHeader\n\t\t\terr := validation.Validate(opts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\t\t\tassert.NoError(t, err)\n\t\t\trw := httptest.NewRecorder()\n\n\t\t\tproxy.ServeHTTP(rw, tt.req)\n\t\t\tif tt.expectTrusted {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_buildRoutesAllowlist(t *testing.T) {\n\ttype expectedAllowedRoute struct {\n\t\tmethod      string\n\t\tregexString string\n\t}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tskipAuthRegex  []string\n\t\tskipAuthRoutes []string\n\t\texpectedRoutes []expectedAllowedRoute\n\t\tshouldError    bool\n\t}{\n\t\t{\n\t\t\tname:           \"No skip auth configured\",\n\t\t\tskipAuthRegex:  []string{},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"Only skipAuthRegex configured\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar\",\n\t\t\t\t\"^/baz/[0-9]+/thing\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname:          \"Only skipAuthRoutes configured\",\n\t\t\tskipAuthRegex: []string{},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t\t\"WEIRD=^/methods/are/allowed\",\n\t\t\t\t\"PATCH=/second/equals?are=handled&just=fine\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"GET\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"POST\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/all/methods$\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"WEIRD\",\n\t\t\t\t\tregexString: \"^/methods/are/allowed\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"PATCH\",\n\t\t\t\t\tregexString: \"/second/equals?are=handled&just=fine\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Both skipAuthRegexes and skipAuthRoutes configured\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar/regex\",\n\t\t\t\t\"^/baz/[0-9]+/thing/regex\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/foo/bar/regex\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing/regex\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"GET\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"POST\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/all/methods$\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid skipAuthRegex entry\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar\",\n\t\t\t\t\"^/baz/[0-9]+/thing\",\n\t\t\t\t\"(bad[regex\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    true,\n\t\t},\n\t\t{\n\t\t\tname:          \"Invalid skipAuthRoutes entry\",\n\t\t\tskipAuthRegex: []string{},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t\t\"PUT=(bad[regex\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\topts := &options.Options{\n\t\t\t\tSkipAuthRegex:  tc.skipAuthRegex,\n\t\t\t\tSkipAuthRoutes: tc.skipAuthRoutes,\n\t\t\t}\n\t\t\troutes, err := buildRoutesAllowlist(opts)\n\t\t\tif tc.shouldError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.NoError(t, err)\n\n\t\t\tfor i, route := range routes {\n\t\t\t\tassert.Greater(t, len(tc.expectedRoutes), i)\n\t\t\t\tassert.Equal(t, route.method, tc.expectedRoutes[i].method)\n\t\t\t\tassert.Equal(t, route.pathRegex.String(), tc.expectedRoutes[i].regexString)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllowedRequest(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"Allowed Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.Upstreams{\n\t\t{\n\t\t\tID:   upstreamServer.URL,\n\t\t\tPath: \"/\",\n\t\t\tURI:  upstreamServer.URL,\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\n\t\t\"^/skip/auth/regex$\",\n\t}\n\topts.SkipAuthRoutes = []string{\n\t\t\"GET=^/skip/auth/routes/get\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\turl     string\n\t\tallowed bool\n\t}{\n\t\t{\n\t\t\tname:    \"Regex GET allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST allowed \",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex denied\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/wrong/denied\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong method\",\n\t\t\tmethod:  \"PATCH\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong path\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/wrong/path\",\n\t\t\tallowed: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(tc.method, tc.url, nil)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.allowed, proxy.isAllowedRoute(req))\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.allowed {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t\tassert.Equal(t, \"Allowed Request\", rw.Body.String())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProxyAllowedGroups(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tallowedGroups      []string\n\t\tgroups             []string\n\t\texpectUnauthorized bool\n\t}{\n\t\t{\"NoAllowedGroups\", []string{}, []string{}, false},\n\t\t{\"NoAllowedGroupsUserHasGroups\", []string{}, []string{\"a\", \"b\"}, false},\n\t\t{\"UserInAllowedGroup\", []string{\"a\"}, []string{\"a\", \"b\"}, false},\n\t\t{\"UserNotInAllowedGroup\", []string{\"a\"}, []string{\"c\"}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\temailAddress := \"test\"\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      tt.groups,\n\t\t\t\tEmail:       emailAddress,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.WriteHeader(200)\n\t\t\t}))\n\t\t\tt.Cleanup(upstreamServer.Close)\n\n\t\t\ttest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\t\t\topts.AllowedGroups = tt.allowedGroups\n\t\t\t\topts.UpstreamServers = options.Upstreams{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\t\t\tPath: \"/\",\n\t\t\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\ttest.req, _ = http.NewRequest(\"GET\", \"/\", nil)\n\n\t\t\ttest.req.Header.Add(\"accept\", applicationJSON)\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tif tt.expectUnauthorized {\n\t\t\t\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, http.StatusOK, test.rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAuthOnlyAllowedGroups(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\tallowedGroups      []string\n\t\tgroups             []string\n\t\tquerystring        string\n\t\texpectedStatusCode int\n\t}{\n\t\t{\n\t\t\tname:               \"NoAllowedGroups\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"NoAllowedGroupsUserHasGroups\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"a\", \"b\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedGroup\",\n\t\t\tallowedGroups:      []string{\"a\"},\n\t\t\tgroups:             []string{\"a\", \"b\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedGroup\",\n\t\t\tallowedGroups:      []string{\"a\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusUnauthorized,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInMultiParamQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"b\"},\n\t\t\tquerystring:        \"?allowed_groups=a&allowed_groups=b,d\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInOnlyQuerystringGroup\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInDelimitedQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\", \"c\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,c\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInConfigGroupNotInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\", \"c\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInQuerystringGroupNotInConfigGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=b,c\",\n\t\t\texpectedStatusCode: http.StatusUnauthorized,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\temailAddress := \"test\"\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      tc.groups,\n\t\t\t\tEmail:       emailAddress,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\ttest, err := NewAuthOnlyEndpointTest(tc.querystring, func(opts *options.Options) {\n\t\t\t\topts.AllowedGroups = tc.allowedGroups\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tassert.Equal(t, tc.expectedStatusCode, test.rw.Code)\n\t\t})\n\t}\n}\n"], "filenames": ["oauthproxy.go", "oauthproxy_test.go"], "buggy_code_start_loc": [440, 298], "buggy_code_end_loc": [455, 298], "fixing_code_start_loc": [440, 299], "fixing_code_end_loc": [457, 304], "type": "CWE-601", "message": "OAuth2 Proxy is an open-source reverse proxy and static file server that provides authentication using Providers (Google, GitHub, and others) to validate accounts by email, domain or group. In OAuth2 Proxy before version 7.0.0, for users that use the whitelist domain feature, a domain that ended in a similar way to the intended domain could have been allowed as a redirect. For example, if a whitelist domain was configured for \".example.com\", the intention is that subdomains of example.com are allowed. Instead, \"example.com\" and \"badexample.com\" could also match. This is fixed in version 7.0.0 onwards. As a workaround, one can disable the whitelist domain feature and run separate OAuth2 Proxy instances for each subdomain.", "other": {"cve": {"id": "CVE-2021-21291", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-02T19:15:14.330", "lastModified": "2021-02-08T16:36:46.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OAuth2 Proxy is an open-source reverse proxy and static file server that provides authentication using Providers (Google, GitHub, and others) to validate accounts by email, domain or group. In OAuth2 Proxy before version 7.0.0, for users that use the whitelist domain feature, a domain that ended in a similar way to the intended domain could have been allowed as a redirect. For example, if a whitelist domain was configured for \".example.com\", the intention is that subdomains of example.com are allowed. Instead, \"example.com\" and \"badexample.com\" could also match. This is fixed in version 7.0.0 onwards. As a workaround, one can disable the whitelist domain feature and run separate OAuth2 Proxy instances for each subdomain."}, {"lang": "es", "value": "OAuth2 Proxy es un proxy inverso de c\u00f3digo abierto y un servidor de archivos est\u00e1ticos que proporciona autenticaci\u00f3n usando Proveedores (Google, GitHub y otros) para comprobar cuentas por correo electr\u00f3nico, dominio o grupo.&#xa0;En OAuth2 Proxy versiones anteriores a 7.0.0, para los usuarios que usan la funcionalidad whitelist domain, se podr\u00eda haber permitido como redireccionamiento un dominio que terminara de manera similar al dominio deseado.&#xa0;Por ejemplo, si se configur\u00f3 un dominio de lista blanca para \".example.com\", la intenci\u00f3n es que se permitan los subdominios de example.com.&#xa0;En su lugar, \"example.com\" y \"badexample.com\" tambi\u00e9n podr\u00edan coincidir.&#xa0;Esto es corregido en versi\u00f3n 7.0.0 en adelante.&#xa0;Como soluci\u00f3n alternativa, se puede deshabilitar la funcionalidad whitelist domain y ejecutar instancias de proxy OAuth2 separadas para cada subdominio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oauth2_proxy_project:oauth2_proxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0", "matchCriteriaId": "C5387BEC-6842-4C28-8A24-ED8A37A18BCD"}]}]}], "references": [{"url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/780ae4f3c99b579cb2ea9845121caebb6192f725", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/oauth2-proxy/oauth2-proxy/releases/tag/v7.0.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-4mf2-f3wh-gvf2", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/github.com/oauth2-proxy/oauth2-proxy/v7", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/780ae4f3c99b579cb2ea9845121caebb6192f725"}}