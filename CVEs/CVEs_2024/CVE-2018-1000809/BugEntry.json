{"buggy_code": ["Version 2.23.1, 2018-09-06\n\n  Fixes:\n  * Fix PassOnNoUser in combination with event handler (#1206)\n  * Fix loading of Event handler detail view (#1210)\n  * Fix Challenge-Response login at Web UI (#1216)\n  * Fix triggerchallenge to only use active tokens (#1217)\n  * Write all installed package to diagnostics file and\n    also write the resolver config in privacyidea-diag\n\nVersion 2.23, 2018-08-29\n\n  Features:\n  * Add periodic tasks including a privacyidea-cron script. (#992) \n  * Add task module \"Simple Stats\" to generate time series of certain \n    important statistics values in privacyIDEA (#1105)\n  * Add task module \"Event Counter\" that allows to create time series of \n    any arbitrary event. (#1029)\n  * New token type: TAN list, that can also import a prefefined\n    list of TANs (#1057)\n  * Add Event Handler Pre-Handling, that e.g. allows for\n    even more easy token enrollment concepts (#747)\n\n  Enhancements:\n  * Improve performance by adding SQL pooling for SQL Audit \n    and SQL Resolvers. (#1167, #1140)\n  * Improve SQL Resolver to also verify bcrypt-hash passwords (#1172)\n  * Allow multiple WHERE conditions in SQL Resolver (#1039)\n  * Allow objectGUID as loginname in LDAP resolver for better \n    ownCloud support (#1076)\n  * Add command in pi-manage to dump audit log information (#1120)\n  * Add script to allow generation of AES keys on HSM (#1159)\n  * Improve recovery mechanism from a lost HSM connection (#1069)\n  * Improve Debug Logging to hide passwords in SQL connect strings (#1162)\n  * Add script for easy privacyIDEA standalone setup (#1093)\n  * ldap3, pyasn1, croniter updated in Ubuntu Launchpad repo (#1085)\n  * Add a script that easily gathers support and diagnostic information (#829)\n  * Add event handler management to pi-manage (#1119)\n  * Allow to customize the challenge text for challenge response tokens (#1096)\n  * Add user information to OATH CSV token import file (#998)\n  * Improve migration scripts from LinOTP to also update counter values (#1075)\n  * Add priority to policies to avoid contradicting policies (#1031)\n  * The token event handler now can delete tokeninfo (#988)\n  * Make the import of OATH CSV token specific, so that each \n    tokentype can define its own import strategy (#1066)\n  * The Event Counter module now allows to decrease the counter (#991)\n  * Allow time deltas to also contain seconds (#1033)\n\n  Fixes:\n  * Allow to use unicode passwords with non-ascii characters for the\n    connect string in SQL Resolvers (#1181)\n  * Fix problem that a wrong password hash was used, if user is created\n    in SQL Resolver (#1114)\n  * Fix performance issue with slow token listing (#1123)\n  * Fix the QR code regeneration if the user already has the maximum number\n    of allowed tokens (#1153)\n  * Fix problem with privacyidea-pip-update in case of pip version 10 (#1128)\n  * Fix problem if max_token_per_user was higher than 9 (#1117)\n  * Fix hash algorithm in QR Code (#1088)\n  * Set focus in username field in the login dialog (#205)\n  * Fix disappearing scrollbar issue (#1020)\n  * Fix import of SHA256 tokens (#1061)\n  * Convert string values to unicode in the database model to \n    avoid misleading \"error\" messages (#1000)\n  * Fix truncation of audit log in case of authentication failure (#1034)\n  * Shorten audit information to fit into the database column (#1037)\n  * Fix the RADIUS configuration test (#1042)\n\n\nVersion 2.22.1, 2018-04-20\n\n  Fixes in WebUI:\n  * Allow to display the messages of several C/R tokens (#995, #1004)\n  * Use ng-if instead of ng-show to avoid errors in the javascript console (#963)\n  * Remove reference to not-used system.addons.js to avoid errors in the javascript console\n  * Remove reference to not-used system.addons.html to avoid errors in the javascript console\n  * Use ng-src instead of src to avoid errors in the javascript console\n  * Avoid request to /false is image is not existing - avoid error in the javascript console\n  * Fix handling of U2F token in the WebUI login\n  * Require serial number in the assignment form (#1011)\n  * Fix PIN comparison in token enroll and token assign (#1010)\n  * Fix the empty username in token enroll or assign (#918)\n\n  Fixes in Server:\n  * Add check for serial number present (#1011)\n  * Fix validation of OCRA and TiQR token (#1008)\n  * Add retry to cope with HSM issues (#1003)\n  * Fix unicode in resolverconf database table with Oracle (#999)\n\n\nVersion 2.22, 2018-03-27\n\n  Features:\n  * Add automatic offline refill for Offline OTP tokens (#839)\n  * Return realm and resolver of the user and allow mapping\n    group membership to the RADIUS protocol (#896)\n  * Add new tokenkind (hardware, software, virtual) for all tokens (#828)\n  * Support Vasco tokens via Import and via Web Enrollment (#904, #903, #891)\n  * Add arbitrary tokeninfo field to authorization policy (#873)\n  * New SMPP SMS provider (#878)\n  * New event handler Counter for counting events for statistics and monitoring (#951)\n\n  Enhancements:\n  * Enhance the statistics possibilities in WebUI (#950)\n  * Allow reencryption of the database by importing PSKC to\n    a new database (#940)\n  * Allow token janitor to export \"PW\" token type to PSKC (#942)\n  * Also export and import the counter values of HOTP/TOTP to PSKC (#943)\n  * SMS token can dynamically read phone number from user source (#932)\n  * Email token can dynamically read email address from user source (#932)\n  * Add policy to ignore the validity of a U2F attestation certificate (#926)\n  * Improve the speed of the LinOTP migration script to cope with tens of\n    thousands of tokens (#914)\n  * pi-manage can create API tokens with a chosen validity time (#931)\n  * Allow user to set token description for HOTP and TOTP tokens \n    during enrollment (#928) (Thanks to Taylor Chase for this contribution!)\n  * Add timeout to SMTP server configuration (#919)\n  * Allow complex email templates for email tokens (#684)\n  * LDAP resolver now supports arbitrary multivalue attributes (#881)\n  * Allow Event Handler to match failing authentication (#971)\n\n  Fixes:\n  * Several fixes in LDAP resolver to cope with ldap3/pyasn1 version issues and\n    other issues (#911, #980, #982, #887)\n  * Skip misguiding LDAP error \"AttributeError NonType\" in log file (#948)\n  * Add missing validity time in /validate/check response for email tokens (#946)\n    (Thanks to Kleber Rocha/klinux for this contribution!)\n  * Fix the handling of the SMS expiration date (#937)\n  * Fix serial length in the audit table to match the serial length in the token table (#929)\n    (Thanks to Salvo Rapisarda for this contribution!)\n  * Fix Mail content sent by email token is rendered as attachment (#915)\n  * Fix Editing SMTP Server definition clears the password (#923)\n  * Fix pi-manage backup crash (Thanks to Pavol Ipoth for this contribution!)\n\n\nVersion 2.21.4, 2018-01-24\n\n  Fixes:\n  * HTTP Timeout of HTTP SMS Gateway (#889)\n  * Remove console.log from webui\n\n\nVersion 2.21.1, 2018-01-09\n\n  Fixes:\n  * Allow to use TLS1.1 and TLS1.2 for LDAP Resolver (#876)\n\nVersion 2.21, 2017-12-20\n\n  Features:\n\n   * Allow export of tokens to PKSC file (#790)\n   * Implement two-step enrollment of HOTP/TOTP tokens (#797, #863, #865, #866)\n   * Allow WebUI customization via policies (#795)\n\n  Enhancements:\n\n   * Add script to decrypt safeword tokens\n   * Allow using tags in the tokenissuer of smartphone tokens\n   * Try to re-establish lost HSM connections (#787)\n   * Allow to rotate audit log based on multiple conditions (#780, #833)\n   * Add dry-run option to audit log rotation (#801)\n   * Allow dots in realm names (#808)\n   * Mark empty but required fields in WebUI (#810)\n   * Display success information after PIN is set (#822)\n   * Add further tags to the user notification event handler (#824)\n   * Add number of users to the subscription view (#800)\n   * Add HTTP/HTTPS proxy settings to HTTP SMS Provider (#835)\n   * Federation Handler allows to forward the authorization token (#838)\n   * Use token janitor to export a user list (#852)\n   * Use HSM for random key generation if possible (#783)\n   * HTTP SMS Provider now takes TIMEOUT parameter into account\n   * Allow to configure length of generated serial numbers (#583)\n\n  Fixes:\n\n   * Fix handling of only_realm option in token event handler (#809)\n   * Fix scrollbar issues in WebUI (#806, #823)\n   * Fix OTP counter of offline token (#840)\n   * Fix conflicts between check_tokentype and passthru policies (#846)\n   * Properly reset tab tile after session has been locked (#850)\n   * Fix handling of fixed key size during enrollment (#820)\n   * Make sure that only active policies are honored (#825)\n   * Fix various bugs with non-ASCII data (#754)\n   * Fix failcounter_clear_timeout (#831)\n   * Only remove apache host definitions on first installation (#834)\n\nVersion 2.20.1, 2017-10-30\n\n  Fixes:\n   * /token/init allows to pass otpkey AND genkey=false (#793)\n   * Cast date to string, to fix audit search for postgresql (#786)\n   * Optimize the LDAP Resolver Redundancy to avoid LdapServerPoolExhaustedErrors (#802)\n   * Preset default realm in token enrollment (#804)\n   * Fix PassOnNoUser and PassOnNoToken (#798)\n   * Fix genkey=0 error during token enrollment (#793)\n\nVersion 2.20, 2017-09-27\n\n  Features:\n\n   * New Token-Type OCRA and DisplayTAN to support \n     transaction signing for online banking (#767)\n   * Federation Handler allows to forward authentication\n     requests and other REST API requests to a child\n     privacyIDEA system (#711)\n   * Improved Subscription Handling \n   * Allow to login with multiple loginnames (#713)\n   * Authentication Cache policy (#729)\n\n  Enhancements:\n\n   * !!!NOTE!!! following policies now also honor the resolvers,\n    which they did not previously:\n    (AUTH, challenge_response), (AUTH, otppin), \n    (AUTHZ, auth_max_success), (AUTHZ, auth_max_fail),\n    (AUTHZ, last_auth), (WEBUI, login_mode),\n    (ENROLL,losttoken_pw_contents), (ENROLL,losttoken_validity),\n    (ENROLL, losttoken_pw_len) (#736)\n   * User can regenerate the QR Code during enrollment\n     of smartphone app (#766)\n   * Administrator can define remote privacyIDEA servers\n     centrally (#711)\n   * Events can now be ordered. This is important for the\n     federation handling (#711)\n   * Specify the hash algorithm that is used to save \n     SQL users passwords (#745)\n   * Add welcome dialog for administrator (#716)\n   * Allow creating oracle DB (#752)\n   * Event Handler can use timestamps and time offsets in\n     conditions (#741)\n   * Use challenge/response token to unlock the screen of \n     the web UI (#702)\n   * Support multiple challenge/response token at the same\n     time (#722)\n   * GPG keys are generated during package installation and\n     show the GPG key in the import dialog (#742)\n   * Failcounter clearing timeout in UI (#719)\n   * Allow to send challenge data (like banking transaction) in\n     email text and SMS text.\n\n  Fixes:\n\n   * Set default loglevel from DEBUG to INFO (#765)\n   * Fixed PIN logging, which could lead to exceptions\n   * Fixed unicode handling in log messages\n   * Make LDAP Resolver work with utf8 (#738)\n   * User can only choose hash algo according to policy (#723)\n   * Add time period 30/60s to rollout URI (#744)\n   * Fix deprecation warning for flask_migrate (#734)\n   * Allow multiple tries for challenge/response (#708)\n   * Fix problem with certificate serial number (#737)\n\n\nVersion 2.19.1, 2017-07-02\n\n  Enhancements:\n\n  * Add \"pi-manage policy load\" and \"pi-manage policy export\". (#721)\n  * Allow customization via pi.cfg file.\n  * Add {username} and {realm} as tags for the tokenhandler. (#735)\n\n Fixes:\n\n  * Fix pi-manage file permission for backup\n  * Fix search for resolver in audit log\n  * Allow to read old legacy time from validity period\n  * Fix wrong enddate with lost_token\n  * Fix typos\n  * Improve documentation for yubikey\n  * Improve documentation for cache decorator\n  * Improve documentation for webui policy\n\n\nVersion 2.19, 2017-05-25\n\n  Features:\n  * Add generic User Cache to speed up authentication (#670, #683)\n  * Support multiple challenge-response tokens with the same PIN (#654)\n  * Restrict U2F registration based on assertion certificte (#648)\n  * Restrict authentication with U2F devices based on assertion \n    certificate (#648)\n  * Add privacyidea-token-janitor script, that can clean orpaned or \n    expired tokens (#692)\n  * Add API for mutual key generation during enrollment for easy \n    Smartphone App development by introducing a generic \n    2-step-rollout process (#627)\n  * Add /validate/radiuscheck which works with rlm_rest and only uses \n    HTTP return codes. (#703)\n\n  Enhancements:\n\n  * Allow to unset token validity period and other tokeninfo\n    fields (#691)\n  * Add a quick-resolver test for LDAP resolvers (#688)\n  * Add additional tokeninfo tags {client_ip}, {ua_browser}, \n    {ua_string} in token handler (#687)\n  * Allow to set decription of U2F tokens during enrollment (#685)\n  * Reduce the number of LDAP requests to increase authentication\n    performance (#664, #655, #650)\n  * Realm administrator is only allowed to see actions on this allowed\n    user realms (#663)\n  * Add audit rotation to pi-manage (#657)\n  * Speed up Audit Log calls by adding a second index (#656)\n  * Allow to either lock und logout the UI after timeout (#653)\n  * Allow string format {user}, {realm}, {serial}, {surname} in \n    tokenlabel policy (#646)\n  * Move to a consistent time format for validity period and all other \n    user specific times also containing the timezone (#644)\n  * Add TLS certificate check to LDAP machine resolver (#638)\n  * Make TLS certificate the default option in LDAP resolvers (#639)\n  * Allow to use privacyIDEA ownCloud App without subscription\n    file with up to 50 users.\n\n  Fixes:\n  * Fix the datepicker for the token validity period (#644 / #693)\n  * Fix LDAP resolver to respect all boolean configuration \n    options (#658)\n  * Fix serial number in challenge response validation response (#649)\n\n  Commits added in version 2.19 by:\n  (In the order of appearance)\n  * Cornelius K\u00f6lbel\n  * Quynh Nguyen\n  * Friedrich Weber\n  * Quoc Doan\n  * blinkiz\n  * Bernd Nicklas\n\nVersion 2.18, 2017-03-09\n\n  Features:\n  * Allow to disable the WebUI (#605)\n  * The WebUI will lock the screen after a timeout instead of  \n    logging out the user. This allows to easily continue\n    configuration work. (#621)\n  * Improve the creation and handling of local CAs (#630, #632, #633)\n    Allow certificate template for certificates with different runtime\n    and x509v3 extensions.\n\n  Enhancements\n  Enhancements in Policies:\n  * Allow regular expressions in usernames in policies. (#581)\n  * Improve Policy creation with pi-manage from JSON formatted file.\n  * WebUI: Add action grouping in policies.\n  * WebUI: Add action filter in policy view.\n  * Allow token specific PIN policies: The SPASS token can now\n    have dedicated PIN policies.\n  * Add PIN policies for administrators during enrollment and\n    during assignment.\n  * Add WebUI policy: only search on enter being pressed (#617)\n\n  Enhancements in Event Handlers:\n  * Add token_validity_period condition to event handlers. (#618)\n  * Add additional options in token handler when creating \n    SMS, Email or mOTP tokens.\n  * Allow tokenhandler to set tokeninfo field.\n  * Allow tokenhandler to set syncwindow.\n  * Add event handler condition for count_auth_success and\n    cound_auth_fail\n  * Add event handler condition for last_auth.\n  * Improve Audit Log for Event Handler. Each triggered action \n    will now also create an audit entry. (#609)\n  * Allow the use of {current_time} in tokenevent handler. (#628)\n\n  Enhancements in LDAP Resolver:\n  * Upgrade dependency to ldap3 version >=2.1.1 to improve LDAP \n    performance in regards to redundancy and security\n  * LDAP Resolver: Use get_info in bind requests to avoid querying \n    of subschema. (#585)\n  * LDAP Resolver: Support StartTLS over Port 389.\n  * Simplify LDAP Resolver: Remove username from Attribute Mapping.\n  * Simplefy LDAP Resolver: Remove reverse filter.\n\n  Misc Enhancements:\n  * Automatically add user's mobile number if tokentype is SMS.\n  * Add example configuration for GTX messaging SMS gateway.\n  * Add a script \"privacyidea-get-unused-tokens\" to find\n    unused tokens\n  * WebUI: Add a busy indicator spinner.\n  * Improve the pi-manage script in regards to backup and restore.\n    Let you choose whether to backup encryption key or not.\n    Better handling for individual pathes. (#626, #623)\n\n  Fixes:\n  * LDAP Resolver: Verify SSL Certificate (Security)\n  * LDAP Resolver: Allow special characters in NTLM password\n  * LDAP Resolver: Allow searching for users with German umlaut\n  * Remove the \"unsafe\" notation in the QR-Code link, so that \n    a smartphone may import the key during HOTP/TOTP token enrollment\n    by clicking the link. (#620)\n  * Use defusexml to avoid XML bombs on token import (Security)\n  * Replace eval with ast.literal_evel (Security)\n  * Add missing attributes for U2F tokens in \n    validate/triggerchallenge API\n  * Let /validate/triggerchallenge write to audit log.\n  * Fix mangle policy for users and realms\n  * Avoid logging of password in check_user_pass in debug level \n    (level=10)\n  * Set encrypted PIN on enrollment for certificate tokens (#625)\n  * Remove unused policy action \"motp_webprovision\"\n  * Allow emailtext policy in triggerchallenge API (#642)\n \n\nVersion 2.17, 2016-12-29\n\n  Features\n  * Token Handler. Using the token handler the administrator\n    can defined actions in response to events, to modify tokens\n    like deleting, modifying, initilizing... tokens (#532)\n  * Script Event Handler or Shell Event Handler allows to\n    trigger an external shell script, if some event occurs. (#536)\n  * Add additional endpoint to trigger a challenge response\n    like the sending of an SMS, if the token PIN is not\n    available (#531)\n  * Policy Handling to also check for secondary resolvers of\n    a user. This way a user can authenticate with his primary \n    resolver but policy will also work for secondary resolvers (#543)\n\n  Enhancements\n  * The event handler conditions also determine a serial number\n    even if there is no serial number in the request:\n    If the user from the request only has one token assigned. (#571)\n  * Allow event definitions to be disabled (#537)\n  * Allow event to be addressed by a destinct name (#522)\n  * Improving LDAP performace by addressing different functionality \n    of ldap3 version 1.x and 2.x. (#549)\n  * Improve SQL Audit by adding the SQL Audit table to the schema.\n    Table is not created during HTTP request. (#557)\n  * Limit audit log entry age. Users may only view audit\n    log entries up to a certain age. (#541)\n  * Add checkbox to only display used actions in a policy (#573)\n  * In event handler: Use serial number of a user's token if the \n    user has only one token (#571)\n  * Download a filtered audit log (#539)\n\n  Fixes\n  * Add missing token serial number to audit log if token is\n    deletes (#546)\n  * Fix event handler saving (#551)\n  * HttpSMSProvider accepts status codes 201 and 202 in addition\n    to 200 (#562)\n  * Fix checkbox bug in NOREFERRALS of LDAP resolver (#563)\n  * Add documentation for SMS provider (#566)\n  * Remove 301 redirects from WebUI (#576)\n\n\nVersion 2.16, 2016-11-10\n\n  Featurs\n  * Add HSM support via AES keys (#534)\n  * Improved Event Handler for flexible notification (#511)\n  * Signed subscription files for adding and checking\n    for extra functionality during authentication request (#502)\n\n  Enhancements\n  * Allow additional filter attributes in the Audit Log (#519)\n  * Show or hide realms in the login dialog via policy (#517)\n  * Improve UI if admin is not allowed for certain actions (#516, #512)\n  * Disable OTP PIN during enrollment via policy (#439)\n  * Allow automatic sending of registration code via email (#514)\n\n  Fixes\n  * Allow compatibility with ldap3 >= 2.0.7 (#533 #535)\n  * Fix problem with Notification when no tokenowner is available (#528)\n  * Fix confusion of client HTTP parameters (#529)\n  * Fix enabled flag with certain database types (#527)\n  * Catch error in case of faulty overrideClient definition (#526)\n  * Truncate Audit lines, that are too long for the DB table (#525)\n\n\nVersion 2.15, 2016-10-06\n\n  Features\n  * Client Overview. Display the type of the requesting\n    authenticating clients (#489)\n  * Support for NitroKey OTP mode (admin client)\n\n  Enhancements\n  * Performance enhancements using Caching singletons for\n    Config, Realm, Resolver and Policies\n  * Allow configuration of the registration email text (#494)\n  * Return SAML attributes only in case of successful\n    authentication (#500)\n  * Policy \"reset_all_user_tokens\" allow to reset all\n    failcounters on successful authentication (#471)\n  * Client rewrite mapping also checks for\n    X-Forwarded-For (#395, #495)\n\n  Fixes\n  * Fixing RemoteUser fails to display WebUI (#499)\n  * String comparison in HOSTS resolver (#484)\n\n\nVersion 2.14, 2016-08-17\n\n  Features\n  * Import PGP encrypted seed files\n  * Allow UserNotification for user actions\n  * Allow UserNotification on validate/check events,\n    to notify the user on a failed authentication or\n    a locked token.\n\n  Enhancements\n  * Add thread ID in REST API Response\n  * Performance improvement: Cache LDAP Requests #473\n  * Performance improvement: Optimize resolver iteration #474\n  * Add \"Check OTP only\" in WebUI\n  * Improve \"get serial by OTP\" in WebUI\n  * Add script to get serial by OTP\n\n  Fixes\n  * Restrict GET /user for corresponding admins #460\n\n\nVersion 2.13, 2016-06-30\n\n  Features\n  * Allow central definition of SMS gateways \n    to be used with tokens. #392\n  * User SMS for User Notificaton Event Handler. #435\n  * Add PIN change setting for each token. #429\n  * Force PIN change in web UI. #432\n\n  Enhancements\n  * Performence enhancements\n    * speed up loading of audit log in web UI.\n    * avoid double loadin of tokens and audit entries in web UI. #436\n  * Additional log level (enhanced Debug) to even log passwords in \n    debug mode.\n  * Add new logo. #430\n  * Add quick actions in the token list: reset failcounter, \n    toggle active. #426\n  * REST API returns OTP length on successful authentication. #407\n  * Add intelligent OverrideAuthorizationClient system setting,\n    that allows defined proxies to reset the client IP. #395\n\n  Fixes\n  * Display token count in web UI. #437\n  * Use correct default_tokentype in token enrollment. #427\n  * Fix HOTP resync problems. #412\n  \n\n\nVersion 2.12, 2016-05-24\n\n  Features\n  * Event Handler Framework #360\n  * local CA connector can enroll certificates\n    for users. Users can download PKCS12 file. #383\n  * Add and edit users in LDAP resolvers #372\n  * Hardware Security Module support via PKCS11\n  * Time dependent policies #358\n\n  Enhancements\n  * Policy for web UI enrollment wizard #402\n  * Realm dropdown box at login screen #400\n  * Apply user policy settings #390\n  * Improve QR Code for TOTP token enrollment #384\n  * Add documentation for enrollment wizard #381\n  * Improve pi-manage backup to use pymysql #375\n  * Use X-Forwarded-For HTTP header as client IP #356\n  * Add meta-package privacyidea-mysql #376\n\n  Fixes\n  * Adduser honors resolver setting in policy #403\n  * Add documentation for SPASS token #399\n  * Hide enrollment link (WebUI) is user can not enroll #398\n  * Fix getSerial for TOTP tokens #393\n  * Fix system config checkboxes #378\n  * Allow a realm to be remove from a token #363\n  * Improve the date handling in emails #352\n  * Sending test emails #350\n  * Authentication with active token not possible if\n    the user has a disabled token #339\n\n \nVersion 2.11, 2016-03-29\n\n  Features\n  * RADIUS Servers: Allow central definition of RADIUS servers\n  * RADIUS passthru policy: Authentication requests for users\n    with no tokens can be forwarded to a specified RADIUS server\n\n  Enhancements\n  * Allow objectGUID in LDAP-Resolver of Active Directory\n  * Use paged searches in LDAP. LDAP resolver will find all\n    users in the LDAP directory.\n  * Allow privacyIDEA instance name to be configured for\n    the AUDIT log\n  * Allow special characters in LDAP loginnames and passwords\n  * Add arbitrary attributes to SAML Authentication response\n  * Enhance the handling of YUBICO mode yubikeys with the\n    YUBICO API. The prefix is handled correctly.\n  * Allow in get_tokens to be filtered for tokeninfo.\n  * Add paged search in LDAP resolver. This allows responses\n    with more than 1000 objects.\n\n  Fixes\n  * Fix SMTP authentication\n  * Fix Enrollment Wizard for non-default realm users\n  * Registration process: If an email can not be delivered,\n    the token is deleted, since it can not be used.\n\n\nVersion 2.10, 2016-02-11\n\n  Features\n  * User Registration: A user may register himself and thus create\n    his new user account.\n  * Password Reset: Using a recovery token a user may issue a \n    password reset without bothering the administrator or the \n    help desk.\n  * Enrollment Wizard for easy user token enrollment\n  * SMTP Servers: Define several system wide SMTP settings and use\n    these for \n    * Email token,\n    * SMTP SMS Provider, \n    * registration process,\n    * or password reset.\n\n  Enhancements\n  * Ease the Smartphone App (Google Authenticator) rollout.\n    Hide otplen, hash, timestep in the UI if a policy is defined.\n  * Add import of Aladdin/SafeNet XML file.\n  * Add import of password encrypted PSKC files.\n  * Add import of key encrypted PSKC files.\n\n  Fixes\n  * Support LDAP passwords with special non-ascii characters.\n  * Support LDAP BIND with special non-ascii characters.\n  * Fix problem with encrypted encryption key.\n  * Fix upgrading DB Schema for postgresql+psycopg2.\n  * Fix UI displaying of saved SMS Provider.\n  * Do not start challenge response with a locked/disabled token.\n\nVersion 2.9, 2015-12-21\n\n  Features\n  * New token type: Security questions or questionnaire token.\n  * New token type: Paper token. OTP values printed on a piece of paper.\n  * Yubico Validation API: The yubikey tokens can authenticate via\n    /ttype/yubikey which follows the Yubico Validation Protocol.\n\n  Enhancements\n  * Add Web UI view to display the active challenges.\n  * The issuer for the Google Authenticator app can be configured.\n  * The LDAP machine resolver uses an LDAP server pool.\n  * The LDAP user resolver returns a list of mobile numbers.\n\n  Fixes\n  * The test email for the email token now has a sent date.\n  * Fix problem when using encrypted encryption key.\n  * Fix upper case problem when logging in to web UI\n    with REMOTE_USER.\n  * Fix allow set an empty PIN in the web UI.\n  * Fix import of token file in Web UI.\n\nVersion 2.8, 2015-11-26\n\n  Features\n  * Improve U2F support with trusted facets\n  * Add Challenge Response and U2F support to SAML\n  * Add Web UI theming\n  * Add possibility to use REMOTE_USER for authentication at Web UI\n  * Fuzzy Authentication: restrict time since last authentication\n\n  Enhancements\n  * Allow mangle policy when fetching ssh keys\n  * Add realm support to ownCloud plugin\n  * Support Drupal passwords in SQL resolver\n  * Add validity period to token enrollment\n  * Set default enrollment token type in Web UI\n  * Add scope to LDAP resolver\n\n  Fixes\n  * Fix failcounter reset for challenge response tokens\n  * Fix confusing DB errors (column exist) during installation\n  * Fix email token TLS checkbox saving\n  * Fix TOTP testing in Web UI\n  * Fix SMS config loading in Web UI\n\n\nVersion 2.7, 2015-10-03\n\n  Features\n  * Add support for U2F tokens\n  * Add signature to the API JSON response. Thus\n    the client can verify the response.\n\n  Enhancements\n  * When importing tokens, a realm can be chosen, so that all imported\n    tokens are immediately inserted into this realm.\n  * The user is able to change his password in the WebUI.\n  * The user can assign a token in the WebUI.\n  * Avoid the requiring of a PIN for some tokentypes like SSH\n  * Migrate to pymysql, the pure python mysql implementation\n  * The Audit Log tells if a previous OTP value was used again.\n\n  Fixes\n  * Enable login to WebUI with a loginname containing an @ sign.\n  * Fix the writing of logfile privacyidea.log\n\nVersion 2.6, 2015-09-09\n\n  Features\n  * Add OCRA base TiQR token to authenticate by scanning\n    a QR code.\n  * Add Challenge Response authentication to Web UI\n  * Add 4-Eyes token, to enable two man policy. Two tokens\n    of two users are needed to authenticate.\n  * \"Revoke Token\" lets you perform special action on token types.\n    Tokens can be revoke, meaning they are blocked an can not\n    be unblocked anymore.\n\n  Enhancements\n  * Add HA information in the documentation.\n  * Add OpenVPN documentation.\n  * Add challenge response policy, to define if e.g. HOTP or TOTP are \n    allowed to be used in challenge response mode.\n  * Add hotkeys for easier use of Web Ui.\n  * Remove wrong system wide PassOnNoUser and PassOnNoToken.\n  * Set default language to \"en\" in Web UI.\n\n  Fixes\n  * Fix LDAP bug #179, which allows authentication with\n    wrong password under certain conditions\n  * Small fixes in coverage tests\n  * Fix username in web UI during enrollment\n  * Fix link to privacyIDEA logo in Web UI\n  * Fixed bug, that user was not able to resync his own tokens.\n\n\nVersion 2.5, 2015-07-23\n  Features\n  * Add statistics\n  * Add German translation\n  * Add PinHandler in case of random PIN used\n  * Add automatic documentation of system setup\n  * Add ownCloud plugin\n  \n  Enhancements\n  * Preset Email and SMS of a user when enrolling token\n  * Enable LDAP anonymous bind\n  * Add Hashalgorithms and digits to QR Code\n  * Add support for CentOS 6 and 7\n  \n  Fixes\n  * Fix registration token\n  * Fix mOTP reuse problem\n\nVersion 2.4, 2015-06-24\n\n  * Add User Management\n  * Add Admin Realms to policies, to allow better policies in bigger setups\n  * Add API key, that can be used for accessing /validate/check\n  * Load PSKC Token seed files.\n  * Add more sophisticated logging. Severe errors via Email\n  * WebUI: Registrtion token can be enrolled in WebUI\n  * WebUI: The token seed can be displayed in WebUI after generation\n  * WebUI: Only the token types that are allowed to be enrolled are displayed\n  * WebUI: Login_Mode Policy: Disable access to WebUI for certain users\n  * WebUI: Add reload button in Audit view\n  * SQLResolver: The Where statement is used in all cases\n  * SSH-Token Application: Only fetch keys of the requested user\n  * Apache client can work with several hosts on one machine\n  * Documentation: Tokentypes and Supported Hardware Tokens\n  * Improve RADIUS module\n  * WebUI: Fix download of audit log\n  * Fix missing access right of user to GET /caconnector\n\n\nVersion 2.3, 2015-05-22\n\n  * Add connector to remote Certificate Authority\n  * Add Tokentype \"certificate\" to manage certificates for users\n    Certificates or Certificate Requests can be uploaded.\n    Certificate Requests (Keypair) can be generated in the browser.\n  * Add Tokentype \"registration\" for easier enrollment scenarios.\n  * Add TokenType \"Email\" to send OTP via Email.\n  * Add \"First Steps\" to online documentation\n  * Add handling of validity period of token\n  * Enable download of Audit log as CSV\n  * Add Resolver Priority, to handle a duplicate user in a realm\n  * Add TYPO3 Plugin to enable OTP with TYPO3\n  * Add SCIM Resolver to fetch users from SCIM services\n  * Fix Failcounter issue\n  * Fix NTLM password check\n  * Fix timestep during enrollment\n\nVersion 2.2, 2015-04-09\n\n  * pi-manage.py: create resolvers and realms\n  * pi-manage.py: manage policies\n  * Add LostToken UI\n  * Add Offline Application\n  * Add PAM authentication module with offline support\n  * Add getSerialByOTP. You can determine the Token by providing an OTP value.\n  * Add auth_count_max and auth_success_max for each token.\n  * Add PIN encryption policy\n  * Add API for SAML\n  * Add bash script for ssh key fetching\n  * Make WebUI logout time configurable via webui policy.\n  * Add NTLM authentication to the LDAP resolver.\n\n\nVersion 2.1, 2015-03-10\n\n  * Add Machine-Application framework to support LUKS and SSH\n    to manage SSH keys and provide Yubikeys to boot LUKS\n    encrypted machines. #100, #10\n  * Add Machine Resolvers for hosts and LDAP/AD #96\n  * Migrate more policies like SMS policies. #95\n  * Restructure WebUI code to ease development #97\n  * Fix logout problem of user #92\n  * Fix user list for AD (referrals) #99\n  * Fix max_token_per_user policy #101\n\n\nVersion 2.0, 2015-02-21\n\n  * Migrate privacyIDEA to Flask Web framework\n  * The WebUI was migrated to bootstrap and angularJS\n  * The database model was restructered to allow an easier handling and\n    programming\n  * Use the pi-manage.py tool to migrate old data\n  * provide ubuntu packages for privacyidea base package and\n    privacyidea-apache2 and privacyidea-nginx\n  * provide pi-manage.py tool to manage the installation and create new admins.\n  * policies are restructered. Internally the policies now use decorators to\n    have a minimum code impact. No all policies are migrated, yet.\n  * OCRA token and Email token is not migrated, yet.\n\n\nVersion 1.5.1, 2015-01-12\n\n  * Fix splitting the @-sign to allow users like user@email.com@realm1\n\n\nVersion 1.5, 2014-12-25\n\n  * Fix the postinstall script for not broken repoze.who\n  * adapt the dependency for python webob\n  * add fix for users in policies.\n  * Working on #61\n  * Closing #63, allow upper and lower case DN in LDAP resolver\n  * Fix the empty result audit search problem\n  * Fix the port problem with SQL resolver\n\n\nVersion 1.4, 2014-10-06\n\n  * Add \"wrong password\" message on login screen\n  * Add simplesamlphp module and deb package\n  * Add helper dialog to easily setup first realm\n  * Add QR enrollment of mOTP token (Token2)\n  * Add admin/checkserial policy\n  * Add help on logon screen\n  * Fixed the session timeout bug in the management UI\n\n\nVersion 1.3.2, 2014-09-22\n\n * Add uwsgi and nginx configuration\n * Add nginx package\n * Add meta packages to easily install radius dependencies. (#33)\n * Add package for appliance\n * Add appliance style: privacyidea-setup-tui\n * Add privacyidea-otrs and remove the authmodules from the\n   core package\n * Add first implementation of Token2 token type\n * Change depend in builddepend\n * Add missing SSL certificate\n * Add missing python-dialog dependency\n * Remove pylons download link, that caused timeout problems.\n\nVersion 1.3, 2014-08-18\n\n * add support for Daplug dongle in keyboard mode\n * Allow login with admin@realm, even with RealmBox.  (#26)\n * inactive tokens will not work with the machine-app\n * Added MachineUser database model\n * PEP8 beautify\n * Add about dialog\n * added recommends for mysql and salt\n\nVersion 1.2, 2014-07-15\n\n * added application for machines like LUKS and SSH\n * send SMS via sipgate\n * add RADIUS support\n * SQL audit janitor\n * improved SMS provider UI\n * added possibility to do basic authentication instead of session auth.\n\nVersion 1.1, 2014-06-25\n\n * Added documentation and in-UI-context-help.:q\n * Fixed the token config to be filled with sensible data, so \n   that you do not need to configure ALL token types.\n * Added script to clean up old audit logs.\n\n", "info:\n\t@echo \"make clean        - remove all automatically created files\"\n\t@echo \"make epydoc       - create the API documentation\"\n\t@echo \"make doc-man      - create the documentation as man-page\"\n\t@echo \"make doc-html     - create the documentation as html\"\n\t@echo \"make pypi         - upload package to pypi\"\n\t@echo \"make debianzie    - prepare the debian build environment in DEBUILD\"\n\t@echo \"make builddeb     - build .deb file locally on ubuntu 14.04LTS!\"\n\t@echo \"make centos       - build .rpm file to be used with CentOS 7\"\n\t@echo \"make venvdeb      - build .deb file, that contains the whole setup in a virtualenv.\"\n\t@echo \"make linitian     - run lintian on debian package\"\n\t@echo \"make translate    - translate WebUI\"\n\t@echo \"                    This is to be used with debian Wheezy\"\n\t@echo \"make ppa-dev      - upload to launchpad development repo\"\n\t@echo \"make ppa          - upload to launchpad stable repo\"\n\t\n#VERSION=1.3~dev5\nSHORT_VERSION=2.23.1\n#SHORT_VERSION=2.10~dev7\nVERSION_JESSIE=${SHORT_VERSION}\nVERSION=${SHORT_VERSION}\nLOCAL_SERIES=`lsb_release -a | grep Codename | cut -f2`\nSRCDIRS=deploy authmodules migrations doc tests tools privacyidea \nSRCFILES=setup.py MANIFEST.in Makefile Changelog LICENSE pi-manage requirements.txt\n\nclean:\n\tfind . -name \\*.pyc -exec rm {} \\;\n\trm -fr build/\n\trm -fr dist/\n\trm -fr DEBUILD\n\trm -fr RHBUILD\n\trm -fr cover\n\trm -f .coverage\n\t(cd doc; make clean)\n\nsetversion:\n\tvim Makefile\n\tvim setup.py\n\tvim deploy/debian-ubuntu/changelog\n\tvim deploy/debian-virtualenv/changelog\n\tvim doc/conf.py\n\tvim Changelog\n\t@echo \"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n\t@echo \"Please set a tag like:  git tag 3.17\"\n\ntranslate:\n\tgrunt nggettext_extract\n\t(cd po; msgmerge de.po template.pot > tmp.po; mv tmp.po de.po)\n#\t(cd po; msgmerge it.po template.pot > tmp.po; mv tmp.po it.po)\n\tpoedit po/de.po\n#\tpoedit po/it.po\n\tgrunt nggettext_compile\n\ntranslate-server:\n\t(cd privacyidea; pybabel extract -F babel.cfg -o messages.pot .)\n\t# pybabel init -i messages.pot -d translations -l de\n\t(cd privacyidea; pybabel update -i messages.pot -d translations)\n\t(poedit privacyidea/translations/de/LC_MESSAGES/messages.po)\n\t# create the .mo file\n\t(cd privacyidea; pybabel compile -d translations)\n\npypi:\n\tmake doc-man\n\tpython setup.py sdist upload\n\nepydoc:\n\t#pydoctor --add-package privacyidea --make-html \n\tepydoc --html privacyidea -o API\ndepdoc:\n\t#sfood privacyidea | sfood-graph | dot -Tpng -o graph.png\t\n\tdot -Tpng dependencies.dot -o dependencies.png\n\ndoc-man:\n\t(cd doc; make man)\n\t(cd doc/installation/system/pimanage; make man)\n\ndoc-html:\n\t(cd doc; make html)\n\ncentos:\n\tmake clean\n\tmkdir RHBUILD\n\tmkdir -p RHBUILD/{BUILD,RPMS,SOURCES,SPECS,SRPMS}\n\t# create tarball\n\tmkdir -p RHBUILD/SOURCES/privacyidea-${VERSION}\n\trsync -a --exclude=\".*\" --exclude=\"privacyIDEA.egg-info\" --exclude=\"RHBUILD\" --exclude=\"debian\" --exclude=\"dist\" --exclude=\"build\" \\\n                --exclude=\"tests\" . RHBUILD/SOURCES/privacyidea-${VERSION} || true\n\t# We are using the same config file as in debia an replace it in setup.py\n\tcp deploy/centos/pi.cfg RHBUILD/SOURCES/privacyidea-${VERSION}/deploy/centos/\n\t# pack the modified source\n\t(cd RHBUILD/SOURCES/; tar -zcf privacyidea-${VERSION}.tar.gz privacyidea-${VERSION})\n\trm -fr RHBUILD/SOURCES/privacyidea-${VERSION}\n\t# copy spec file\n\tcp deploy/centos/privacyidea.spec RHBUILD/SPECS\n\t# build it\n\trpmbuild --define \"_topdir $(CURDIR)/RHBUILD\" -ba RHBUILD/SPECS/privacyidea.spec\n\n\ndebianize:\n\tmake clean\n\tmake doc-man\n\tmkdir -p DEBUILD/privacyidea.org/debian\n\tcp -r ${SRCDIRS} ${SRCFILES} DEBUILD/privacyidea.org || true\n\t# remove the requirement for pyOpenSSL otherwise we get a breaking dependency for trusty\n\tgrep -v pyOpenSSL setup.py > DEBUILD/privacyidea.org/setup.py\n\t# We need to touch this, so that our config files \n\t# are written to /etc\n\ttouch DEBUILD/privacyidea.org/PRIVACYIDEA_PACKAGE\n\tcp LICENSE DEBUILD/privacyidea.org/debian/copyright\n\tcp LICENSE DEBUILD/privacyidea.org/debian/python-privacyidea.copyright\n\tcp LICENSE DEBUILD/privacyidea.org/debian/privacyidea-all.copyright\n\tcp authmodules/FreeRADIUS/copyright DEBUILD/privacyidea.org/debian/privacyidea-radius.copyright\n\tcp authmodules/simpleSAMLphp/LICENSE DEBUILD/privacyidea.org/debian/privacyidea-simplesamlphp.copyright\n\t(cd DEBUILD; tar -zcf python-privacyidea_${SHORT_VERSION}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\t(cd DEBUILD; tar -zcf python-privacyidea_${VERSION}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\t(cd DEBUILD; tar -zcf python-privacyidea_${VERSION_JESSIE}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\t(cd DEBUILD; tar -zcf privacyidea-venv_${VERSION}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\nbuilddeb-nosign:\n\tmake debianize\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\tsed -e s/\"trusty) trusty; urgency\"/\"$(LOCAL_SERIES)) $(LOCAL_SERIES); urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -b -i -us -uc)\n\nbuilddeb:\n\tmake debianize\n\t################## Renew the changelog\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\tsed -e s/\"trusty) trusty; urgency\"/\"$(LOCAL_SERIES)) $(LOCAL_SERIES); urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t################# Build\n\t(cd DEBUILD/privacyidea.org; debuild --no-lintian)\n\nvenvdeb:\n\tmake debianize\n\tcp -r deploy/debian-virtualenv/* DEBUILD/privacyidea.org/debian/\n\tsed -e s/\"trusty) trusty; urgency\"/\"$(LOCAL_SERIES)) $(LOCAL_SERIES); urgency\"/g deploy/debian-virtualenv/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; DH_VIRTUALENV_INSTALL_ROOT=/opt/privacyidea dpkg-buildpackage -us -uc)\n\nlintian:\n\t(cd DEBUILD; lintian -i -I --show-overrides python-privacyidea_2.*_amd64.changes)\n\nppa-dev:\n\tmake debianize\n\t# trusty\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\t# xenial\n\tsed -e s/\"trusty) trusty; urgency\"/\"xenial) xenial; urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\t# bionic\n\tsed -e s/\"trusty) trusty; urgency\"/\"bionic) bionic; urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\tdput ppa:privacyidea/privacyidea-dev DEBUILD/python-privacyidea_${VERSION}*_source.changes\n\nppa:\n\tmake debianize\n\t# trusty\n\tcp deploy/debian-ubuntu/changelog DEBUILD/privacyidea.org/debian/\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\t# xenial\n\tsed -e s/\"trusty) trusty; urgency\"/\"xenial) xenial; urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\tdput ppa:privacyidea/privacyidea DEBUILD/python-privacyidea_${VERSION}*_source.changes\n", "python-privacyidea (2.23.1-1trusty) trusty; urgency=medium\n\n  Fixes:\n  * Fix PassOnNoUser in combination with event handler (#1206)\n  * Fix loading of Event handler detail view (#1210)\n  * Fix Challenge-Response login at Web UI (#1216)\n  * Fix triggerchallenge to only use active tokens (#1217)\n  * Write all installed package to diagnostics file and\n    also write the resolver config in privacyidea-diag\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 06 Sep 2018 10:00:00 +0200\n\npython-privacyidea (2.23-1trusty) trusty; urgency=medium\n\n  Features:\n  * Add periodic tasks including a privacyidea-cron script. (#992) \n  * Add task module \"Simple Stats\" to generate time series of certain \n    important statistics values in privacyIDEA (#1105)\n  * Add task module \"Event Counter\" that allows to create time series of \n    any arbitrary event. (#1029)\n  * New token type: TAN list, that can also import a prefefined\n    list of TANs (#1057)\n  * Add Event Handler Pre-Handling, that e.g. allows for\n    even more easy token enrollment concepts (#747)\n\n  Enhancements:\n  * Improve performance by adding SQL pooling for SQL Audit \n    and SQL Resolvers. (#1167, #1140)\n  * Improve SQL Resolver to also verify bcrypt-hash passwords (#1172)\n  * Allow multiple WHERE conditions in SQL Resolver (#1039)\n  * Allow objectGUID as loginname in LDAP resolver for better \n    ownCloud support (#1076)\n  * Add command in pi-manage to dump audit log information (#1120)\n  * Add script to allow generation of AES keys on HSM (#1159)\n  * Improve recovery mechanism from a lost HSM connection (#1069)\n  * Improve Debug Logging to hide passwords in SQL connect strings (#1162)\n  * Add script for easy privacyIDEA standalone setup (#1093)\n  * ldap3, pyasn1, croniter updated in Ubuntu Launchpad repo (#1085)\n  * Add a script that easily gathers support and diagnostic information (#829)\n  * Add event handler management to pi-manage (#1119)\n  * Allow to customize the challenge text for challenge response tokens (#1096)\n  * Add user information to OATH CSV token import file (#998)\n  * Improve migration scripts from LinOTP to also update counter values (#1075)\n  * Add priority to policies to avoid contradicting policies (#1031)\n  * The token event handler now can delete tokeninfo (#988)\n  * Make the import of OATH CSV token specific, so that each \n    tokentype can define its own import strategy (#1066)\n  * The Event Counter module now allows to decrease the counter (#991)\n  * Allow time deltas to also contain seconds (#1033)\n\n  Fixes:\n  * Allow to use unicode passwords with non-ascii characters for the\n    connect string in SQL Resolvers (#1181)\n  * Fix problem that a wrong password hash was used, if user is created\n    in SQL Resolver (#1114)\n  * Fix performance issue with slow token listing (#1123)\n  * Fix the QR code regeneration if the user already has the maximum number\n    of allowed tokens (#1153)\n  * Fix problem with privacyidea-pip-update in case of pip version 10 (#1128)\n  * Fix problem if max_token_per_user was higher than 9 (#1117)\n  * Fix hash algorithm in QR Code (#1088)\n  * Set focus in username field in the login dialog (#205)\n  * Fix disappearing scrollbar issue (#1020)\n  * Fix import of SHA256 tokens (#1061)\n  * Convert string values to unicode in the database model to \n    avoid misleading \"error\" messages (#1000)\n  * Fix truncation of audit log in case of authentication failure (#1034)\n  * Shorten audit information to fit into the database column (#1037)\n  * Fix the RADIUS configuration test (#1042)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 29 Aug 2018 09:00:00 +0200\n\npython-privacyidea (2.23~dev9-trusty) trusty; urgency=medium\n\n  Development release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 28 Aug 2018 07:15:00 +0200\n\npython-privacyidea (2.23~dev8-trusty) trusty; urgency=medium\n\n  Development release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 22 Aug 2018 09:15:00 +0200\n\npython-privacyidea (2.23~dev7-trusty) trusty; urgency=medium\n\n  Development release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 16 Aug 2018 21:50:00 +0200\n\npython-privacyidea (2.23~dev6-trusty) trusty; urgency=medium\n\n  Development release \n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 16 Aug 2018 12:00:00 +0200\n\npython-privacyidea (2.23~dev4-trusty) trusty; urgency=medium\n\n  Development Release to test periodic tasks \n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Mon, 13 Aug 2018 21:30:00 +0200\n\npython-privacyidea (2.23~dev3-trusty) trusty; urgency=medium\n\n  Development Release to test periodic tasks and pre-handling\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 07 Aug 2018 17:00:00 +0200\n\npython-privacyidea (2.23~dev2-trusty) trusty; urgency=medium\n\n  Development Release to test with bionic beaver\n \n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 20 Jun 2018 08:00:00 +0200\n\n\npython-privacyidea (2.23~dev1-trusty) trusty; urgency=medium\n\n  Development Release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 30 May 2018 12:15:00 +0200\n  \npython-privacyidea (2.22.1-1trusty) trusty; urgency=medium\n\n  Fixes in WebUI:\n  * Allow to display the messages of several C/R tokens (#995, #1004)\n  * Use ng-if instead of ng-show to avoid errors in the javascript console (#963)\n  * Remove reference to not-used system.addons.js to avoid errors in the javascript console\n  * Remove reference to not-used system.addons.html to avoid errors in the javascript console\n  * Use ng-src instead of src to avoid errors in the javascript console\n  * Avoid request to /false is image is not existing - avoid error in the javascript console\n  * Fix handling of U2F token in the WebUI login\n  * Require serial number in the assignment form (#1011)\n  * Fix PIN comparison in token enroll and token assign (#1010)\n  * Fix the empty username in token enroll or assign (#918)\n\n  Fixes in Server:\n  * Add check for serial number present (#1011)\n  * Fix validation of OCRA and TiQR token (#1008)\n  * Add retry to cope with HSM issues (#1003)\n  * Fix unicode in resolverconf database table with Oracle (#999)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Fri, 20 Apr 2018 15:00:00 +0200\n\n\npython-privacyidea (2.22-1trusty) trusty; urgency=low\n\n  Features:\n  * Add automatic offline refill for Offline OTP tokens (#839)\n  * Return realm and resolver of the user and allow mapping\n    group membership to the RADIUS protocol (#896)\n  * Add new tokenkind (hardware, software, virtual) for all tokens (#828)\n  * Support Vasco tokens via Import and via Web Enrollment (#904, #903, #891)\n  * Add arbitrary tokeninfo field to authorization policy (#873)\n  * New SMPP SMS provider (#878)\n  * New event handler Counter for counting events for statistics and monitoring (#951)\n\n  Enhancements:\n  * Enhance the statistics possibilities in WebUI (#950)\n  * Allow reencryption of the database by importing PSKC to\n    a new database (#940)\n  * Allow token janitor to export \"PW\" token type to PSKC (#942)\n  * Also export and import the counter values of HOTP/TOTP to PSKC (#943)\n  * SMS token can dynamically read phone number from user source (#932)\n  * Email token can dynamically read email address from user source (#932)\n  * Add policy to ignore the validity of a U2F attestation certificate (#926)\n  * Improve the speed of the LinOTP migration script to cope with tens of\n    thousands of tokens (#914)\n  * pi-manage can create API tokens with a chosen validity time (#931)\n  * Allow user to set token description for HOTP and TOTP tokens \n    during enrollment (#928) (Thanks to Taylor Chase for this contribution!)\n  * Add timeout to SMTP server configuration (#919)\n  * Allow complex email templates for email tokens (#684)\n  * LDAP resolver now supports arbitrary multivalue attributes (#881)\n  * Allow Event Handler to match failing authentication (#971)\n\n  Fixes:\n  * Several fixes in LDAP resolver to cope with ldap3/pyasn1 version issues and\n    other issues (#911, #980, #982, #887)\n  * Skip misguiding LDAP error \"AttributeError NonType\" in log file (#948)\n  * Add missing validity time in /validate/check response for email tokens (#946)\n    (Thanks to Kleber Rocha/klinux for this contribution!)\n  * Fix the handling of the SMS expiration date (#937)\n  * Fix serial length in the audit table to match the serial length in the token table (#929)\n    (Thanks to Salvo Rapisarda for this contribution!)\n  * Fix Mail content sent by email token is rendered as attachment (#915)\n  * Fix Editing SMTP Server definition clears the password (#923)\n  * Fix pi-manage backup crash (Thanks to Pavol Ipoth for this contribution!)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 26 Mar 2018 09:30:00 +0200\n\npython-privacyidea (2.21.4-1trusty) trusty; urgency=low\n\n  Fixes:\n  * HTTP Timeout of HTTP SMS Gateway\n  * Remove console.log from webui\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 24 Jan 2018 16:30:00 +0200\n\n\npython-privacyidea (2.21-1trusty) trusty; urgency=low\n\n  Features:\n   * Allow export of tokens to PKSC file (#790)\n   * Implement two-step enrollment of HOTP/TOTP tokens (#797, #863, #865, #866)\n   * Allow WebUI customization via policies (#795)\n\n  Enhancements:\n   * Add script to decrypt safeword tokens\n   * Allow using tags in the tokenissuer of smartphone tokens\n   * Try to re-establish lost HSM connections (#787)\n   * Allow to rotate audit log based on multiple conditions (#780, #833)\n   * Add dry-run option to audit log rotation (#801)\n   * Allow dots in realm names (#808)\n   * Mark empty but required fields in WebUI (#810)\n   * Display success information after PIN is set (#822)\n   * Add further tags to the user notification event handler (#824)\n   * Add number of users to the subscription view (#800)\n   * Add HTTP/HTTPS proxy settings to HTTP SMS Provider (#835)\n   * Federation Handler allows to forward the authorization token (#838)\n   * Use token janitor to export a user list (#852)\n   * Use HSM for random key generation if possible (#783)\n   * HTTP SMS Provider now takes TIMEOUT parameter into account\n   * Allow to configure length of generated serial numbers (#583)\n\n  Fixes:\n   * Fix handling of only_realm option in token event handler (#809)\n   * Fix scrollbar issues in WebUI (#806, #823)\n   * Fix OTP counter of offline token (#840)\n   * Fix conflicts between check_tokentype and passthru policies (#846)\n   * Properly reset tab tile after session has been locked (#850)\n   * Fix handling of fixed key size during enrollment (#820)\n   * Make sure that only active policies are honored (#825)\n   * Fix various bugs with non-ASCII data (#754)\n   * Fix failcounter_clear_timeout (#831)\n   * Only remove apache host definitions on first installation (#834)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 20 Dec 2017 00:30:00 +0200\n\npython-privacyidea (2.20.1-1trusty) trusty; urgency=low\n\n  Fixes:\n   * /token/init allows to pass otpkey AND genkey=false (#793)\n   * Cast date to string, to fix audit search for postgresql (#786)\n   * Optimize the LDAP Resolver Redundancy to avoid LdapServerPoolExhaustedErrors (#802)\n   * Preset default realm in token enrollment (#804)\n   * Fix PassOnNoUser and PassOnNoToken (#798)\n   * Fix genkey=0 error during token enrollment (#793)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Mon, 30 Oct 2017 11:30:00 +0200\n\npython-privacyidea (2.20-1trusty) trusty; urgency=low\n\n  Features:\n   * New Token-Type OCRA and DisplayTAN to support \n     transaction signing for online banking (#767)\n   * Federation Handler allows to forward authentication\n     requests and other REST API requests to a child\n     privacyIDEA system (#711)\n   * Improved Subscription Handling \n   * Allow to login with multiple loginnames (#713)\n   * Authentication Cache policy (#729)\n\n  Enhancements:\n   * !!!NOTE!!! following policies now also honor the resolvers,\n    which they did not previously:\n    (AUTH, challenge_response), (AUTH, otppin), \n    (AUTHZ, auth_max_success), (AUTHZ, auth_max_fail),\n    (AUTHZ, last_auth), (WEBUI, login_mode),\n    (ENROLL,losttoken_pw_contents), (ENROLL,losttoken_validity),\n    (ENROLL, losttoken_pw_len) (#736)\n   * User can regenerate the QR Code during enrollment\n     of smartphone app (#766)\n   * Administrator can define remote privacyIDEA servers\n     centrally (#711)\n   * Events can now be ordered. This is important for the\n     federation handling (#711)\n   * Specify the hash algorithm that is used to save \n     SQL users passwords (#745)\n   * Add welcome dialog for administrator (#716)\n   * Allow creating oracle DB (#752)\n   * Event Handler can use timestamps and time offsets in\n     conditions (#741)\n   * Use challenge/response token to unlock the screen of \n     the web UI (#702)\n   * Support multiple challenge/response token at the same\n     time (#722)\n   * GPG keys are generated during package installation and\n     show the GPG key in the import dialog (#742)\n   * Failcounter clearing timeout in UI (#719)\n   * Allow to send challenge data (like banking transaction) in\n     email text and SMS text.\n\n  Fixes:\n   * Set default loglevel from DEBUG to INFO (#765)\n   * Fixed PIN logging, which could lead to exceptions\n   * Fixed unicode handling in log messages\n   * Make LDAP Resolver work with utf8 (#738)\n   * User can only choose hash algo according to policy (#723)\n   * Add time period 30/60s to rollout URI (#744)\n   * Fix deprecation warning for flask_migrate (#734)\n   * Allow multiple tries for challenge/response (#708)\n   * Fix problem with certificate serial number (#737)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 27 Sep 2017 11:30:00 +0200\n\npython-privacyidea (2.19.1-1trusty) trusty; urgency=low\n\n  Enhancements:\n  * Add \"pi-manage policy load\" and \"pi-manage policy export\". (#721)\n  * Allow customization via pi.cfg file.\n  * Add {username} and {realm} as tags for the tokenhandler. (#735)\n\n  Fixes:\n  * Fix pi-manage file permission for backup\n  * Fix search for resolver in audit log\n  * Allow to read old legacy time from validity period\n  * Fix wrong enddate with lost_token\n  * Fix typos\n  * Improve documentation for yubikey\n  * Improve documentation for cache decorator\n  * Improve documentation for webui policy\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sun, 02 Jul 2017 08:00:00 +0200\n\npython-privacyidea (2.19-1trusty) trusty; urgency=low\n\n  Features:\n  * Add generic User Cache to speed up authentication (#670, #683)\n  * Support multiple challenge-response tokens with the same PIN (#654)\n  * Restrict U2F registration based on assertion certificte (#648)\n  * Restrict authentication with U2F devices based on assertion \n    certificate (#648)\n  * Add privacyidea-token-janitor script, that can clean orpaned or \n    expired tokens (#692)\n  * Add API for mutual key generation during enrollment for easy \n    Smartphone App development by introducing a generic \n    2-step-rollout process (#627)\n  * Add /validate/radiuscheck which works with rlm_rest and only uses \n    HTTP return codes. (#703)\n\n  Enhancements:\n  * Allow to unset token validity period and other tokeninfo\n    fields (#691)\n  * Add a quick-resolver test for LDAP resolvers (#688)\n  * Add additional tokeninfo tags {client_ip}, {ua_browser}, \n    {ua_string} in token handler (#687)\n  * Allow to set decription of U2F tokens during enrollment (#685)\n  * Reduce the number of LDAP requests to increase authentication\n    performance (#664, #655, #650)\n  * Realm administrator is only allowed to see actions on this allowed\n    user realms (#663)\n  * Add audit rotation to pi-manage (#657)\n  * Speed up Audit Log calls by adding a second index (#656)\n  * Allow to either lock und logout the UI after timeout (#653)\n  * Allow string format {user}, {realm}, {serial}, {surname} in \n    tokenlabel policy (#646)\n  * Move to a consistent time format for validity period and all other \n    user specific times also containing the timezone (#644)\n  * Add TLS certificate check to LDAP machine resolver (#638)\n  * Make TLS certificate the default option in LDAP resolvers (#639)\n  * Allow to use privacyIDEA ownCloud App without subscription\n    file with up to 50 users.\n\n  Fixes:\n  * Fix the datepicker for the token validity period (#644 / #693)\n  * Fix LDAP resolver to respect all boolean configuration \n    options (#658)\n  * Fix serial number in challenge response validation response (#649)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 26 May 2017 08:30:00 +0200\n\npython-privacyidea (2.19~dev5-1trusty) trusty; urgency=low\n\n  * Allow {givenname} and {surname} in tokenlabel (#646)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 16 May 2017 16:30:00 +0200\n\npython-privacyidea (2.18-1trusty) trusty; urgency=low\n\n  Features:\n  * Allow to disable the WebUI (#605)\n  * The WebUI will lock the screen after a timeout instead of  \n    logging out the user. This allows to easily continue\n    configuration work. (#621)\n  * Improve the creation and handling of local CAs (#630, #632, #633)\n    Allow certificate template for certificates with different runtime\n    and x509v3 extensions.\n\n  Enhancements\n  Enhancements in Policies:\n  * Allow regular expressions in usernames in policies. (#581)\n  * Improve Policy creation with pi-manage from JSON formatted file.\n  * WebUI: Add action grouping in policies.\n  * WebUI: Add action filter in policy view.\n  * Allow token specific PIN policies: The SPASS token can now\n    have dedicated PIN policies.\n  * Add PIN policies for administrators during enrollment and\n    during assignment.\n  * Add WebUI policy: only search on enter being pressed (#617)\n\n  Enhancements in Event Handlers:\n  * Add token_validity_period condition to event handlers. (#618)\n  * Add additional options in token handler when creating \n    SMS, Email or mOTP tokens.\n  * Allow tokenhandler to set tokeninfo field.\n  * Allow tokenhandler to set syncwindow.\n  * Add event handler condition for count_auth_success and\n    cound_auth_fail\n  * Add event handler condition for last_auth.\n  * Improve Audit Log for Event Handler. Each triggered action \n    will now also create an audit entry. (#609)\n  * Allow the use of {current_time} in tokenevent handler. (#628)\n\n  Enhancements in LDAP Resolver:\n  * Upgrade dependency to ldap3 version >=2.1.1 to improve LDAP \n    performance in regards to redundancy and security\n  * LDAP Resolver: Use get_info in bind requests to avoid querying \n    of subschema. (#585)\n  * LDAP Resolver: Support StartTLS over Port 389.\n  * Simplify LDAP Resolver: Remove username from Attribute Mapping.\n  * Simplefy LDAP Resolver: Remove reverse filter.\n\n  Misc Enhancements:\n  * Automatically add user's mobile number if tokentype is SMS.\n  * Add example configuration for GTX messaging SMS gateway.\n  * Add a script \"privacyidea-get-unused-tokens\" to find\n    unused tokens\n  * WebUI: Add a busy indicator spinner.\n  * Improve the pi-manage script in regards to backup and restore.\n    Let you choose whether to backup encryption key or not.\n    Better handling for individual pathes. (#626, #623)\n\n  Fixes:\n  * LDAP Resolver: Verify SSL Certificate (Security)\n  * LDAP Resolver: Allow special characters in NTLM password\n  * LDAP Resolver: Allow searching for users with German umlaut\n  * Remove the \"unsafe\" notation in the QR-Code link, so that \n    a smartphone may import the key during HOTP/TOTP token enrollment\n    by clicking the link. (#620)\n  * Use defusexml to avoid XML bombs on token import (Security)\n  * Replace eval with ast.literal_evel (Security)\n  * Add missing attributes for U2F tokens in \n    validate/triggerchallenge API\n  * Let /validate/triggerchallenge write to audit log.\n  * Fix mangle policy for users and realms\n  * Avoid logging of password in check_user_pass in debug level \n    (level=10)\n  * Set encrypted PIN on enrollment for certificate tokens (#625)\n  * Remove unused policy action \"motp_webprovision\"\n  * Allow emailtext policy in triggerchallenge API (#642)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Mar 2017 12:00:00 +0200\n\npython-privacyidea (2.17-1trusty) trusty; urgency=low\n\n  Features\n  * Token Handler. Using the token handler the administrator\n    can defined actions in response to events, to modify tokens\n    like deleting, modifying, initilizing... tokens (#532)\n  * Script Event Handler or Shell Event Handler allows to\n    trigger an external shell script, if some event occurs. (#536)\n  * Add additional endpoint to trigger a challenge response\n    like the sending of an SMS, if the token PIN is not\n    available (#531)\n  * Policy Handling to also check for secondary resolvers of\n    a user. This way a user can authenticate with his primary \n    resolver but policy will also work for secondary resolvers (#543)\n\n  Enhancements\n  * The event handler conditions also determine a serial number\n    even if there is no serial number in the request:\n    If the user from the request only has one token assigned. (#571)\n  * Allow event definitions to be disabled (#537)\n  * Allow event to be addressed by a destinct name (#522)\n  * Improving LDAP performace by addressing different functionality \n    of ldap3 version 1.x and 2.x. (#549)\n  * Improve SQL Audit by adding the SQL Audit table to the schema.\n    Table is not created during HTTP request. (#557)\n  * Limit audit log entry age. Users may only view audit\n    log entries up to a certain age. (#541)\n  * Add checkbox to only display used actions in a policy (#573)\n  * In event handler: Use serial number of a user's token if the \n    user has only one token (#571)\n  * Download a filtered audit log (#539)\n\n  Fixes\n  * Add missing token serial number to audit log if token is\n    deletes (#546)\n  * Fix event handler saving (#551)\n  * HttpSMSProvider accepts status codes 201 and 202 in addition\n    to 200 (#562)\n  * Fix checkbox bug in NOREFERRALS of LDAP resolver (#563)\n  * Add documentation for SMS provider (#566)\n  * Remove 301 redirects from WebUI (#576)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 29 Dec 2016 16:00:00 +0200\n\npython-privacyidea (2.16-1trusty) trusty; urgency=low\n\n  Featurs\n  * Add HSM support via AES keys (#534)\n  * Improved Event Handler for flexible notification (#511)\n  * Signed subscription files for adding and checking\n    for extra functionality during authentication request (#502)\n\n  Enhancements\n  * Allow additional filter attributes in the Audit Log (#519)\n  * Show or hide realms in the login dialog via policy (#517)\n  * Improve UI if admin is not allowed for certain actions (#516, #512)\n  * Disable OTP PIN during enrollment via policy (#439)\n  * Allow automatic sending of registration code via email (#514)\n\n  Fixes\n  * Allow compatibility with ldap3 >= 2.0.7 (#533 #535)\n  * Fix problem with Notification when no tokenowner is available (#528)\n  * Fix confusion of client HTTP parameters (#529)\n  * Fix enabled flag with certain database types (#527)\n  * Catch error in case of faulty overrideClient definition (#526)\n  * Truncate Audit lines, that are too long for the DB table (#525)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 10 Nov 2016 15:00:00 +0200\n\npython-privacyidea (2.15-1trusty) trusty; urgency=low\n \n  Features\n  * Client Overview. Display the type of the requesting\n    authenticating clients (#489)\n  * Support for NitroKey OTP mode (admin client)\n\n  Enhancements\n  * Builds on Ubuntu 16.04 Xenial\n  * Performance enhancements using Caching singletons for\n    Config, Realm, Resolver and Policies\n  * Allow configuration of the registration email text (#494)\n  * Return SAML attributes only in case of successful\n    authentication (#500)\n  * Policy \"reset_all_user_tokens\" allow to reset all\n    failcounters on successful authentication (#471)\n  * Client rewrite mapping also checks for\n    X-Forwarded-For (#395, #495)\n\n  Fixes\n  * Fixing RemoteUser fails to display WebUI (#499)\n  * String comparison in HOSTS resolver (#484)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 06 Oct 2016 08:30:00 +0200\n\npython-privacyidea (2.14-1trusty) trusty; urgency=low\n\n  Features\n  * Import PGP encrypted seed files\n  * Allow UserNotification for user actions\n  * Allow UserNotification on validate/check events,\n    to notify the user on a failed authentication or\n    a locked token.\n\n  Enhancements\n  * Add thread ID in REST API Response\n  * Performence improvement: Cache LDAP Requests #473\n  * Performance improvement: Optimize resolver iteration #474\n  * Add \"Check OTP only\" in WebUI\n  * Improve \"get serial by OTP\" in WebUI\n  * Add script to get serial by OTP\n\n  Fixes\n  * Restrict GET /user for corresponding admins #460\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 15 Aug 2016 00:03:00 +0200\n\npython-privacyidea (2.13-1trusty) trusty; urgency=low\n\n  Features\n  * Allow central definition of SMS gateways \n    to be used with tokens. #392\n  * User SMS for User Notificaton Event Handler. #435\n  * Add PIN change setting for each token. #429\n  * Force PIN change in web UI. #432\n\n  Enhancements\n  * Performence enhancements\n    * speed up loading of audit log in web UI.\n    * avoid double loadin of tokens and audit entries in web UI. #436\n  * Additional log level (enhanced Debug) to even log passwords in \n    debug mode.\n  * Add new logo. #430\n  * Add quick actions in the token list: reset failcounter, \n    toggle active. #426\n  * REST API returns OTP length on successful authentication. #407\n  * Add intelligent OverrideAuthorizationClient system setting,\n    that allows defined proxies to reset the client IP. #395\n\n  Fixes\n  * Display token count in web UI. #437\n  * Use correct default_tokentype in token enrollment. #427\n  * Fix HOTP resync problems. #412\n  \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 30 Jun 2016 12:00:00 +0200\n\npython-privacyidea (2.12-1trusty) trusty; urgency=low\n\n  Features\n  * Event Handler Framework #360\n  * local CA connector can enroll certificates\n    for users. Users can download PKCS12 file. #383\n  * Add and edit users in LDAP resolvers #372\n  * Time dependent policies #358\n\n  Enhancements\n  * Policy for web UI enrollment wizard #402\n  * Realm dropdown box at login screen #400\n  * Apply user policy settings #390\n  * Improve QR Code for TOTP token enrollment #384\n  * Add documentation for enrollment wizard #381\n  * Improve pi-manage backup to use pymysql #375\n  * Use X-Forwarded-For HTTP header as client IP #356\n  * Add meta-package privacyidea-mysql #376\n\n  Fixes\n  * Adduser honors resolver setting in policy #403\n  * Add documentation for SPASS token #399\n  * Hide enrollment link (WebUI) is user can not enroll #398\n  * Fix getSerial for TOTP tokens #393\n  * Fix system config checkboxes #378\n  * Allow a realm to be remove from a token #363\n  * Improve the date handling in emails #352\n  * Sending test emails #350\n  * Authentication with active token not possible if\n    the user has a disabled token #339\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 24 May 2016 16:00:00 +0200\n\npython-privacyidea (2.11-1trusty) trusty; urgency=low\n\n  Features\n  * RADIUS Servers: Allow central definition of RADIUS servers\n  * RADIUS passthru policy: Authentication requests for users\n    with no tokens can be forwarded to a specified RADIUS server\n\n  Enhancements\n  * Allow objectGUID in LDAP-Resolver of Active Directory\n  * Use paged searches in LDAP. LDAP resolver will find all\n    users in the LDAP directory.\n  * Allow privacyIDEA instance name to be configured for\n    the AUDIT log\n  * Allow special characters in LDAP loginnames and passwords\n  * Add arbitrary attributes to SAML Authentication response\n  * Enhance the handling of YUBICO mode yubikeys with the\n    YUBICO API. The prefix is handled correctly.\n  * Allow in get_tokens to be filtered for tokeninfo.\n  * Add paged search in LDAP resolver. This allows responses\n    with more than 1000 objects.\n\n  Fixes\n  * Fix SMTP authentication\n  * Fix Enrollment Wizard for non-default realm users\n  * Registration process: If an email can not be delivered,\n    the token is deleted, since it can not be used.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 29 Mar 2016 08:30:00 +0200\n\npython-privacyidea (2.10-1trusty) trusty; urgency=low\n\n  Features\n  * User Registration: A user may register himself and thus create\n    his new user account.\n  * Password Reset: Using a recovery token a user may issue a\n    password reset without bothering the administrator or the\n    help desk.\n  * Enrollment Wizard for easy user token enrollment\n  * SMTP Servers: Define several system wide SMTP settings and use\n    these for\n    * Email token,\n    * SMTP SMS Provider, \n    * registration process,\n    * or password reset.\n\n  Enhancements\n  * Ease the Smartphone App (Google Authenticator) rollout.\n    Hide otplen, hash, timestep in the UI if a policy is defined.\n  * Add import of Aladdin/SafeNet XML file.\n  * Add import of password encrypted PSKC files.\n  * Add import of key encrypted PSKC files.\n\n  Fixes\n  * Support LDAP passwords with special non-ascii characters.\n  * Support LDAP BIND with special non-ascii characters.\n  * Fix problem with encrypted encryption key.\n  * Fix upgrading DB Schema for postgresql+psycopg2.\n  * Fix UI displaying of saved SMS Provider.\n  * Do not start challenge response with a locked/disabled token.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 11 Feb 2016 00:01:00 +0200\n\npython-privacyidea (2.9-1trusty) trusty; urgency=low\n\n\n  Features\n  * New token type: Security questions or questionnaire token.\n  * New token type: Paper token. OTP values printed on a piece of paper.\n  * Yubico Validation API: The yubikey tokens can authenticate via\n    /ttype/yubikey which follows the Yubico Validation Protocol.\n\n  Enhancements\n  * Add Web UI view to display the active challenges.\n  * The issuer for the Google Authenticator app can be configured.\n  * The LDAP machine resolver uses an LDAP server pool.\n  * The LDAP user resolver returns a list of mobile numbers.\n\n  Fixes\n  * The test email for the email token now has a sent date.\n  * Fix problem when using encrypted encryption key.\n  * Fix upper case problem when logging in to web UI\n    with REMOTE_USER.\n  * Fix allow set an empty PIN in the web UI.\n  * Fix import of token file in Web UI.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 21 Dec 2015 18:00:00 +0200\n\npython-privacyidea (2.8-1trusty) trusty; urgency=low\n\n  Features\n  * Improve U2F support with trusted facets\n  * Add Challenge Response and U2F support to SAML\n  * Add Web UI theming\n  * Add possibility to use REMOTE_USER for authentication at Web UI\n  * Fuzzy Authentication: restrict time since last authentication\n\n  Enhancements\n  * Allow mangle policy when fetching ssh keys\n  * Add realm support to ownCloud plugin\n  * Support Drupal passwords in SQL resolver\n  * Add validity period to token enrollment\n  * Set default enrollment token type in Web UI\n  * Add scope to LDAP resolver\n\n  Fixes\n  * Fix failcounter reset for challenge response tokens\n  * Fix confusing DB errors (column exist) during installation\n  * Fix email token TLS checkbox saving\n  * Fix TOTP testing in Web UI\n  * Fix SMS config loading in Web UI\n  * start new version\n  * Add Challenge Response support to SAML\n  * Add U2F support to SAML\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 26 Nov 2015 23:30:00 +0200\n\npython-privacyidea (2.7-1trusty) trusty; urgency=low\n\n  Features\n  * Add support for U2F tokens\n  * Add signature to the API JSON response. Thus\n    the client can verify the response.\n\n  Enhancements\n  * When importing tokens, a realm can be chosen, so that all imported\n    tokens are immediately inserted into this realm.\n  * The user is able to change his password in the WebUI.\n  * The user can assign a token in the WebUI.\n  * Avoid the requiring of a PIN for some tokentypes like SSH\n  * Migrate to pymysql, the pure python mysql implementation\n  * The Audit Log tells if a previous OTP value was used again.\n\n  Fixes\n  * Enable login to WebUI with a loginname containing an @ sign.\n  * Fix the writing of logfile privacyidea.log\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 07 Oct 2015 08:00:00 +0200\n\npython-privacyidea (2.6-1trusty) trusty; urgency=low\n\n  Features\n  * Add OCRA base TiQR token to authenticate by scanning\n    a QR code.\n  * Add Challenge Response authentication to Web UI\n  * Add 4-Eyes token, to enable two man policy. Two tokens\n    of two users are needed to authenticate.\n  * \"Revoke Token\" lets you perform special action on token types.\n    Tokens can be revoke, meaning they are blocked an can not\n    be unblocked anymore.\n\n  Enhancements\n  * Add HA information in the documentation.\n  * Add OpenVPN documentation.\n  * Add challenge response policy, to define if e.g. HOTP or TOTP are \n    allowed to be used in challenge response mode.\n  * Add hotkeys for easier use of Web Ui.\n  * Remove wrong system wide PassOnNoUser and PassOnNoToken.\n  * Set default language to \"en\" in Web UI.\n\n  Fixes\n  * Fix LDAP bug #179, which allows authentication with\n    wrong password under certain conditions\n  * Small fixes in coverage tests\n  * Fix username in web UI during enrollment\n  * Fix link to privacyIDEA logo in Web UI\n  * Fixed bug, that user was not able to resync his own tokens.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 09 Sep 2015 09:30:00 +0200\n\n\npython-privacyidea (2.5-1trusty) trusty; urgency=low\n\n  Features\n  * Add statistics\n  * Add German translation\n  * Add PinHandler in case of random PIN used\n  * Add automatic documentation of system setup\n  * Add ownCloud plugin\n  \n  Enhancements\n  * Preset Email and SMS of a user when enrolling token\n  * Enable LDAP anonymous bind\n  * Add Hashalgorithms and digits to QR Code\n  * Add support for CentOS 6 and 7\n  \n  Fixes\n  * Fix registration token\n  * Fix mOTP reuse problem\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 22 Jul 2015 17:00:00 +0200\n\npython-privacyidea (2.4-1trusty) trusty; urgency=low\n\n  * Add User Management\n  * Add Admin Realms to policies, to allow better policies in bigger setups\n  * Add API key, that can be used for accessing /validate/check\n  * Load PSKC Token seed files.\n  * Add more sophisticated logging.\n  * WebUI: Registrtion token can be enrolled in WebUI\n  * WebUI: The token seed can be displayed in WebUI after generation\n  * WebUI: Only the token types that are allowed to be enrolled are displayed\n  * WebUI: Login_Mode Policy: Disable access to WebUI for certain users\n  * WebUI: Add reload button in Audit view\n  * SQLResolver: The Where statement is used in all cases\n  * SSH-Token Application: Only fetch keys of the requested user\n  * Apache client can work with several hosts on one machine\n  * Documentation: Tokentypes and Supported Hardware Tokens\n  * Improve RADIUS module\n  * WebUI: Fix download of audit log\n  * Fix missing access right of user to GET /caconnector\n  * Fix SMS token\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Jun 2015 09:30:00 +0200\n\npython-privacyidea (2.3-1trusty) trusty; urgency=low\n\n  * Add connector to remote Certificate Authority\n  * Add Tokentype \"certificate\" to manage certificates for users\n    Certificates or Certificate Requests can be uploaded.\n    Certificate Requests (Keypair) can be generated in the browser.\n  * Add Tokentype \"registration\" for easier enrollment scenarios.\n  * Add TokenType \"Email\" to send OTP via Email.\n  * Add \"First Steps\" to online documentation\n  * Add handling of validity period of token\n  * Enable download of Audit log as CSV\n  * Add Resolver Priority, to handle a duplicate user in a realm\n  * Add TYPO3 Plugin to enable OTP with TYPO3\n  * Add SCIM Resolver to fetch users from SCIM services\n  * Fix Failcounter issue\n  * Fix NTLM password check\n  * Fix timestep during enrollment\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 22 May 2015 15:30:00 +0200\n\npython-privacyidea (2.2-1trusty) trusty; urgency=low\n\n  * pi-manage: create resolvers and realms\n  * pi-manage: manage policies\n  * Add LostToken UI\n  * Add Offline Application\n  * Add PAM authentication module with offline support\n  * Add getSerialByOTP. You can determine the Token by providing an OTP value.\n  * Add auth_count_max and auth_success_max for each token.\n  * Add PIN encryption policy\n  * Add API for SAML\n  * Add bash script for ssh key fetching\n  * Make WebUI logout time configurable via webui policy.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Apr 2015 12:10:00 +0200\n\npython-privacyidea (2.1-1trusty) trusty; urgency=low\n\n  * Add Machine-Application framework to support LUKS and SSH\n    to manage SSH keys and provide Yubikeys to boot LUKS \n    encrypted machines. #100, #10\n  * Add Machine Resolvers for hosts and LDAP/AD #96\n  * Migrate more policies like SMS policies. #95 \n  * Restructure WebUI code to ease development #97\n  * Fix logout problem of user #92\n  * Fix user list for AD (referrals) #99\n  * Fix max_token_per_user policy #101\n  \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 10 Mar 2015 10:30:00 +0200\n\npython-privacyidea (2.1~dev1) trusty; urgency=low\n\n  * Fix logout problem of user\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 16:00:00 +0200\n\npython-privacyidea (2.0-1) trusty; urgency=low\n\n  * Migrate to flask\n  * change the name of the debian package as the package only\n    contains the python module.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 14:00:00 +0200\n\n\nprivacyidea (1.5.1-1trusty) trusty; urgency=low\n\n  * Fix splitting the @-sign to allow users like user@email.com\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 02 Feb 2015 09:08:00 +0200\n\n\nprivacyidea (1.5-1trusty) trusty; urgency=low\n\n  * Fix the postinstall script for not broken repoze.who\n  * adapt the dependency for python webob\n  * add fix for users in policies.\n  * Working on #61\n  * Closing #63, allow upper and lower case DN in LDAP resolver\n  * Fix the empty result audit search problem\n  * Fix the port problem with SQL resolver\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 25 Dec 2014 16:30:00 +0200\n\nprivacyidea (1.4-1) trusty; urgency=low\n\n  * Add \"wrong password\" message on login screen\n  * Speed up tests\n  * Add help on logon screen.\n  * Add helper dialog to setup first realm\n  * Add simplesamlphp module and deb package\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 16:50:00 +0200\n\nprivacyidea (1.4~dev5-1) trusty; urgency=low\n\n  * Add wrong password message on login screen\n  * Speed up tests\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 09:10:00 +0200\n\nprivacyidea (1.4~dev4-1) trusty; urgency=low\n\n  * Add help on logon screen.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 02 Oct 2014 11:20:00 +0200\n\nprivacyidea (1.4~dev3-1) trusty; urgency=low\n\n  * Add helper dialog to setup first realm\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 30 Sep 2014 11:10:00 +0200\n\nprivacyidea (1.4~dev2-1) trusty; urgency=low\n\n  * Add simplesamlphp module and deb package\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 29 Sep 2014 11:40:00 +0200\n\nprivacyidea (1.4~dev1-1) trusty; urgency=low\n\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Sep 2014 19:10:00 +0200\n\nprivacyidea (1.3.2-1) trusty; urgency=low\n\n  * Add uwsgi and nginx configuration\n  * Add nginx package\n  * Add meta packages to easily install radius dependencies. (#33)\n  * Add package for appliance\n  * Add appliance style: privacyidea-setup-tui\n  * Add privacyidea-otrs and remove the authmodules from the\n    core package\n  * Add first implementation of Token2 token type\n  * Change depend in builddepend\n  * Add missing SSL certificate\n  * Add missing python-dialog dependency\n  * Remove pylons download link, that caused timeout problems.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 22 Sep 2014 10:00:00 +0200\n\nprivacyidea (1.3.1-1) trusty; urgency=low\n\n  * Fixed bug, that avoided to delete MachineTokens with options (#27)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 20 Aug 2014 18:30:00 +0200\n\nprivacyidea (1.3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n  * inactive tokens will not work with the machine-app\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 18 Aug 2014 17:00:00 +0200\n\nprivacyidea (1.3~dev5-1) trusty; urgency=low\n\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 15 Aug 2014 15:37:00 +0200\n\nprivacyidea (1.3~dev4-1) trusty; urgency=low\n\n  * fix minor bugs in selfservice portal\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 13 Aug 2014 17:40:00 +0200\n\nprivacyidea (1.3~dev3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 12 Aug 2014 18:32:00 +0200\n\nprivacyidea (1.3~dev2-1) trusty; urgency=low\n\n  * machine requires IP address\n  * the machine-app listing also returns the information, if the token\n    is active\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 11 Aug 2014 10:40:00 +0200\n\n\nprivacyidea (1.3~dev1-1) trusty; urgency=low\n\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 06 Aug 2014 14:14:00 +0200\n\nprivacyidea (1.3~dev0-2) trusty; urgency=low\n\n  * Fixed the missing run directory (#23)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 31 Jul 2014 09:28:00 +0200\n \nprivacyidea (1.3~dev0-1) trusty; urgency=low\n\n  * Fix resolver error #22\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 30 Jul 2014 16:24:00 +0200\n\nprivacyidea (1.2.2-1) trusty; urgency=low\n\n  * Fixed the sqlsoup dependency\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 23 Jul 2014 17:57:00 +0200\n\n\nprivacyidea (1.2.1-1) trusty; urgency=low\n\n  * machine controller: make the challenge usable also in normal mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 18 Jul 2014 16:51:00 +0200\n\n\nprivacyidea (1.2-1) trusty; urgency=low\n\n  * Added \n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 15 Jul 2014 15:15:55 +0200\n\nprivacyidea (1.2~dev2-1) trusty; urgency=low\n\n  * initial ubuntu release\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 14 Jul 2014 18:56:55 +0200\n", "privacyidea-venv (2.23.1-1) jessie; urgency=medium\n\n  Fixes:\n  * Fix PassOnNoUser in combination with event handler (#1206)\n  * Fix loading of Event handler detail view (#1210)\n  * Fix Challenge-Response login at Web UI (#1216)\n  * Fix triggerchallenge to only use active tokens (#1217)\n  * Write all installed package to diagnostics file and\n    also write the resolver config in privacyidea-diag\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 06 Sep 2018 10:00:00 +0200\n\nprivacyidea-venv (2.23-1) jessie; urgency=medium\n\n  Features:\n  * Add periodic tasks including a privacyidea-cron script. (#992) \n  * Add task module \"Simple Stats\" to generate time series of certain \n    important statistics values in privacyIDEA (#1105)\n  * Add task module \"Event Counter\" that allows to create time series of \n    any arbitrary event. (#1029)\n  * New token type: TAN list, that can also import a prefefined\n    list of TANs (#1057)\n  * Add Event Handler Pre-Handling, that e.g. allows for\n    even more easy token enrollment concepts (#747)\n\n  Enhancements:\n  * Improve performance by adding SQL pooling for SQL Audit \n    and SQL Resolvers. (#1167, #1140)\n  * Improve SQL Resolver to also verify bcrypt-hash passwords (#1172)\n  * Allow multiple WHERE conditions in SQL Resolver (#1039)\n  * Allow objectGUID as loginname in LDAP resolver for better \n    ownCloud support (#1076)\n  * Add command in pi-manage to dump audit log information (#1120)\n  * Add script to allow generation of AES keys on HSM (#1159)\n  * Improve recovery mechanism from a lost HSM connection (#1069)\n  * Improve Debug Logging to hide passwords in SQL connect strings (#1162)\n  * Add script for easy privacyIDEA standalone setup (#1093)\n  * ldap3, pyasn1, croniter updated in Ubuntu Launchpad repo (#1085)\n  * Add a script that easily gathers support and diagnostic information (#829)\n  * Add event handler management to pi-manage (#1119)\n  * Allow to customize the challenge text for challenge response tokens (#1096)\n  * Add user information to OATH CSV token import file (#998)\n  * Improve migration scripts from LinOTP to also update counter values (#1075)\n  * Add priority to policies to avoid contradicting policies (#1031)\n  * The token event handler now can delete tokeninfo (#988)\n  * Make the import of OATH CSV token specific, so that each \n    tokentype can define its own import strategy (#1066)\n  * The Event Counter module now allows to decrease the counter (#991)\n  * Allow time deltas to also contain seconds (#1033)\n\n  Fixes:\n  * Allow to use unicode passwords with non-ascii characters for the\n    connect string in SQL Resolvers (#1181)\n  * Fix problem that a wrong password hash was used, if user is created\n    in SQL Resolver (#1114)\n  * Fix performance issue with slow token listing (#1123)\n  * Fix the QR code regeneration if the user already has the maximum number\n    of allowed tokens (#1153)\n  * Fix problem with privacyidea-pip-update in case of pip version 10 (#1128)\n  * Fix problem if max_token_per_user was higher than 9 (#1117)\n  * Fix hash algorithm in QR Code (#1088)\n  * Set focus in username field in the login dialog (#205)\n  * Fix disappearing scrollbar issue (#1020)\n  * Fix import of SHA256 tokens (#1061)\n  * Convert string values to unicode in the database model to \n    avoid misleading \"error\" messages (#1000)\n  * Fix truncation of audit log in case of authentication failure (#1034)\n  * Shorten audit information to fit into the database column (#1037)\n  * Fix the RADIUS configuration test (#1042)\n\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 29 Aug 2018 09:00:00 +0200\n\nprivacyidea-venv (2.23~dev9-1) jessie; urgency=medium\n\n  * Development version\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 28 Aug 2018 07:30:00 +0200\n\nprivacyidea-venv (2.23~dev8-1) jessie; urgency=medium\n\n  * Development version\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 22 Aug 2018 13:00:00 +0200\n\n\nprivacyidea-venv (2.22.1-1) jessie; urgency=medium\n\n  Fixes in WebUI:\n  * Allow to display the messages of several C/R tokens (#995, #1004)\n  * Use ng-if instead of ng-show to avoid errors in the javascript console (#963)\n  * Remove reference to not-used system.addons.js to avoid errors in the javascript console\n  * Remove reference to not-used system.addons.html to avoid errors in the javascript console\n  * Use ng-src instead of src to avoid errors in the javascript console\n  * Avoid request to /false is image is not existing - avoid error in the javascript console\n  * Fix handling of U2F token in the WebUI login\n  * Require serial number in the assignment form (#1011)\n  * Fix PIN comparison in token enroll and token assign (#1010)\n  * Fix the empty username in token enroll or assign (#918)\n\n  Fixes in Server:\n  * Add check for serial number present (#1011)\n  * Fix validation of OCRA and TiQR token (#1008)\n  * Add retry to cope with HSM issues (#1003)\n  * Fix unicode in resolverconf database table with Oracle (#999)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Fri, 20 Apr 2018 15:00:00 +0200\n\nprivacyidea-venv (2.22-1) jessie; urgency=low\n\n  Features:\n  * Add automatic offline refill for Offline OTP tokens (#839)\n  * Return realm and resolver of the user and allow mapping\n    group membership to the RADIUS protocol (#896)\n  * Add new tokenkind (hardware, software, virtual) for all tokens (#828)\n  * Support Vasco tokens via Import and via Web Enrollment (#904, #903, #891)\n  * Add arbitrary tokeninfo field to authorization policy (#873)\n  * New SMPP SMS provider (#878)\n  * New event handler Counter for counting events for statistics and monitoring (#951)\n\n  Enhancements:\n  * Enhance the statistics possibilities in WebUI (#950)\n  * Allow reencryption of the database by importing PSKC to\n    a new database (#940)\n  * Allow token janitor to export \"PW\" token type to PSKC (#942)\n  * Also export and import the counter values of HOTP/TOTP to PSKC (#943)\n  * SMS token can dynamically read phone number from user source (#932)\n  * Email token can dynamically read email address from user source (#932)\n  * Add policy to ignore the validity of a U2F attestation certificate (#926)\n  * Improve the speed of the LinOTP migration script to cope with tens of\n    thousands of tokens (#914)\n  * pi-manage can create API tokens with a chosen validity time (#931)\n  * Allow user to set token description for HOTP and TOTP tokens \n    during enrollment (#928) (Thanks to Taylor Chase for this contribution!)\n  * Add timeout to SMTP server configuration (#919)\n  * Allow complex email templates for email tokens (#684)\n  * LDAP resolver now supports arbitrary multivalue attributes (#881)\n  * Allow Event Handler to match failing authentication (#971)\n\n  Fixes:\n  * Several fixes in LDAP resolver to cope with ldap3/pyasn1 version issues and\n    other issues (#911, #980, #982, #887)\n  * Skip misguiding LDAP error \"AttributeError NonType\" in log file (#948)\n  * Add missing validity time in /validate/check response for email tokens (#946)\n    (Thanks to Kleber Rocha/klinux for this contribution!)\n  * Fix the handling of the SMS expiration date (#937)\n  * Fix serial length in the audit table to match the serial length in the token table (#929)\n    (Thanks to Salvo Rapisarda for this contribution!)\n  * Fix Mail content sent by email token is rendered as attachment (#915)\n  * Fix Editing SMTP Server definition clears the password (#923)\n  * Fix pi-manage backup crash (Thanks to Pavol Ipoth for this contribution!)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 26 Mar 2018 09:30:00 +0200\n\n\nprivacyidea-venv (2.21.1-1) jessie; urgency=low\n\n  Features:\n   * Allow export of tokens to PKSC file (#790)\n   * Implement two-step enrollment of HOTP/TOTP tokens (#797, #863, #865, #866)\n   * Allow WebUI customization via policies (#795)\n\n  Enhancements:\n   * Add script to decrypt safeword tokens\n   * Allow using tags in the tokenissuer of smartphone tokens\n   * Try to re-establish lost HSM connections (#787)\n   * Allow to rotate audit log based on multiple conditions (#780, #833)\n   * Add dry-run option to audit log rotation (#801)\n   * Allow dots in realm names (#808)\n   * Mark empty but required fields in WebUI (#810)\n   * Display success information after PIN is set (#822)\n   * Add further tags to the user notification event handler (#824)\n   * Add number of users to the subscription view (#800)\n   * Add HTTP/HTTPS proxy settings to HTTP SMS Provider (#835)\n   * Federation Handler allows to forward the authorization token (#838)\n   * Use token janitor to export a user list (#852)\n   * Use HSM for random key generation if possible (#783)\n   * HTTP SMS Provider now takes TIMEOUT parameter into account\n   * Allow to configure length of generated serial numbers (#583)\n\n  Fixes:\n   * Fix handling of only_realm option in token event handler (#809)\n   * Fix scrollbar issues in WebUI (#806, #823)\n   * Fix OTP counter of offline token (#840)\n   * Fix conflicts between check_tokentype and passthru policies (#846)\n   * Properly reset tab tile after session has been locked (#850)\n   * Fix handling of fixed key size during enrollment (#820)\n   * Make sure that only active policies are honored (#825)\n   * Fix various bugs with non-ASCII data (#754)\n   * Fix failcounter_clear_timeout (#831)\n   * Only remove apache host definitions on first installation (#834)\n   * Allow to use TLS1.1 and TLS1.2 for LDAP Resolver (#876)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 09 Jan 2018 12:30:00 +0200\n\nprivacyidea-venv (2.20.1-1) jessie; urgency=low\n\n  Fixes:\n   * /token/init allows to pass otpkey AND genkey=false (#793)\n   * Cast date to string, to fix audit search for postgresql (#786)\n   * Optimize the LDAP Resolver Redundancy to avoid LdapServerPoolExhaustedErrors (#802)\n   * Preset default realm in token enrollment (#804)\n   * Fix PassOnNoUser and PassOnNoToken (#798)\n   * Fix genkey=0 error during token enrollment (#793)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Mon, 30 Oct 2017 11:30:00 +0200\n\n\nprivacyidea-venv (2.19.1-1) jessie; urgency=low\n\n  Enhancements:\n  * Add \"pi-manage policy load\" and \"pi-manage policy export\". (#721)\n  * Allow customization via pi.cfg file.\n  * Add {username} and {realm} as tags for the tokenhandler. (#735)\n\n  Fixes:\n  * Fix pi-manage file permission for backup\n  * Fix search for resolver in audit log\n  * Allow to read old legacy time from validity period\n  * Fix wrong enddate with lost_token\n  * Fix typos\n  * Improve documentation for yubikey\n  * Improve documentation for cache decorator\n  * Improve documentation for webui policy\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sun, 02 Jul 2017 08:00:00 +0200\n\nprivacyidea-venv (2.19-1) wheezy; urgency=low\n\n  Features:\n  * Add generic User Cache to speed up authentication (#670, #683)\n  * Support multiple challenge-response tokens with the same PIN (#654)\n  * Restrict U2F registration based on assertion certificte (#648)\n  * Restrict authentication with U2F devices based on assertion \n    certificate (#648)\n  * Add privacyidea-token-janitor script, that can clean orpaned or \n    expired tokens (#692)\n  * Add API for mutual key generation during enrollment for easy \n    Smartphone App development by introducing a generic \n    2-step-rollout process (#627)\n  * Add /validate/radiuscheck which works with rlm_rest and only uses \n    HTTP return codes. (#703)\n\n  Enhancements:\n  * Allow to unset token validity period and other tokeninfo\n    fields (#691)\n  * Add a quick-resolver test for LDAP resolvers (#688)\n  * Add additional tokeninfo tags {client_ip}, {ua_browser}, \n    {ua_string} in token handler (#687)\n  * Allow to set decription of U2F tokens during enrollment (#685)\n  * Reduce the number of LDAP requests to increase authentication\n    performance (#664, #655, #650)\n  * Realm administrator is only allowed to see actions on this allowed\n    user realms (#663)\n  * Add audit rotation to pi-manage (#657)\n  * Speed up Audit Log calls by adding a second index (#656)\n  * Allow to either lock und logout the UI after timeout (#653)\n  * Allow string format {user}, {realm}, {serial}, {surname} in \n    tokenlabel policy (#646)\n  * Move to a consistent time format for validity period and all other \n    user specific times also containing the timezone (#644)\n  * Add TLS certificate check to LDAP machine resolver (#638)\n  * Make TLS certificate the default option in LDAP resolvers (#639)\n  * Allow to use privacyIDEA ownCloud App without subscription\n    file with up to 50 users.\n\n  Fixes:\n  * Fix the datepicker for the token validity period (#644 / #693)\n  * Fix LDAP resolver to respect all boolean configuration \n    options (#658)\n  * Fix serial number in challenge response validation response (#649)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 26 May 2017 08:30:00 +0200\n\nprivacyidea-venv (2.18-1) wheezy; urgency=low\n\n  Features:\n  * Allow to disable the WebUI (#605)\n  * The WebUI will lock the screen after a timeout instead of  \n    logging out the user. This allows to easily continue\n    configuration work. (#621)\n  * Improve the creation and handling of local CAs (#630, #632, #633)\n    Allow certificate template for certificates with different runtime\n    and x509v3 extensions.\n\n  Enhancements\n  Enhancements in Policies:\n  * Allow regular expressions in usernames in policies. (#581)\n  * Improve Policy creation with pi-manage from JSON formatted file.\n  * WebUI: Add action grouping in policies.\n  * WebUI: Add action filter in policy view.\n  * Allow token specific PIN policies: The SPASS token can now\n    have dedicated PIN policies.\n  * Add PIN policies for administrators during enrollment and\n    during assignment.\n  * Add WebUI policy: only search on enter being pressed (#617)\n\n  Enhancements in Event Handlers:\n  * Add token_validity_period condition to event handlers. (#618)\n  * Add additional options in token handler when creating \n    SMS, Email or mOTP tokens.\n  * Allow tokenhandler to set tokeninfo field.\n  * Allow tokenhandler to set syncwindow.\n  * Add event handler condition for count_auth_success and\n    cound_auth_fail\n  * Add event handler condition for last_auth.\n  * Improve Audit Log for Event Handler. Each triggered action \n    will now also create an audit entry. (#609)\n  * Allow the use of {current_time} in tokenevent handler. (#628)\n\n  Enhancements in LDAP Resolver:\n  * Upgrade dependency to ldap3 version >=2.1.1 to improve LDAP \n    performance in regards to redundancy and security\n  * LDAP Resolver: Use get_info in bind requests to avoid querying \n    of subschema. (#585)\n  * LDAP Resolver: Support StartTLS over Port 389.\n  * Simplify LDAP Resolver: Remove username from Attribute Mapping.\n  * Simplefy LDAP Resolver: Remove reverse filter.\n\n  Misc Enhancements:\n  * Automatically add user's mobile number if tokentype is SMS.\n  * Add example configuration for GTX messaging SMS gateway.\n  * Add a script \"privacyidea-get-unused-tokens\" to find\n    unused tokens\n  * WebUI: Add a busy indicator spinner.\n  * Improve the pi-manage script in regards to backup and restore.\n    Let you choose whether to backup encryption key or not.\n    Better handling for individual pathes. (#626, #623)\n\n  Fixes:\n  * LDAP Resolver: Verify SSL Certificate (Security)\n  * LDAP Resolver: Allow special characters in NTLM password\n  * LDAP Resolver: Allow searching for users with German umlaut\n  * Remove the \"unsafe\" notation in the QR-Code link, so that \n    a smartphone may import the key during HOTP/TOTP token enrollment\n    by clicking the link. (#620)\n  * Use defusexml to avoid XML bombs on token import (Security)\n  * Replace eval with ast.literal_evel (Security)\n  * Add missing attributes for U2F tokens in \n    validate/triggerchallenge API\n  * Let /validate/triggerchallenge write to audit log.\n  * Fix mangle policy for users and realms\n  * Avoid logging of password in check_user_pass in debug level \n    (level=10)\n  * Set encrypted PIN on enrollment for certificate tokens (#625)\n  * Remove unused policy action \"motp_webprovision\"\n  * Allow emailtext policy in triggerchallenge API (#642)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Mar 2017 12:00:00 +0200\n\nprivacyidea-venv (2.17-1) wheezy; urgency=low\n\n  Features\n  * Token Handler. Using the token handler the administrator\n    can defined actions in response to events, to modify tokens\n    like deleting, modifying, initilizing... tokens (#532)\n  * Script Event Handler or Shell Event Handler allows to\n    trigger an external shell script, if some event occurs. (#536)\n  * Add additional endpoint to trigger a challenge response\n    like the sending of an SMS, if the token PIN is not\n    available (#531)\n  * Policy Handling to also check for secondary resolvers of\n    a user. This way a user can authenticate with his primary \n    resolver but policy will also work for secondary resolvers (#543)\n\n  Enhancements\n  * The event handler conditions also determine a serial number\n    even if there is no serial number in the request:\n    If the user from the request only has one token assigned. (#571)\n  * Allow event definitions to be disabled (#537)\n  * Allow event to be addressed by a destinct name (#522)\n  * Improving LDAP performace by addressing different functionality \n    of ldap3 version 1.x and 2.x. (#549)\n  * Improve SQL Audit by adding the SQL Audit table to the schema.\n    Table is not created during HTTP request. (#557)\n  * Limit audit log entry age. Users may only view audit\n    log entries up to a certain age. (#541)\n  * Add checkbox to only display used actions in a policy (#573)\n  * In event handler: Use serial number of a user's token if the \n    user has only one token (#571)\n  * Download a filtered audit log (#539)\n\n  Fixes\n  * Add missing token serial number to audit log if token is\n    deletes (#546)\n  * Fix event handler saving (#551)\n  * HttpSMSProvider accepts status codes 201 and 202 in addition\n    to 200 (#562)\n  * Fix checkbox bug in NOREFERRALS of LDAP resolver (#563)\n  * Add documentation for SMS provider (#566)\n  * Remove 301 redirects from WebUI (#576)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 29 Dec 2016 16:30:00 +0200\n\n\nprivacyidea-venv (2.16-1) wheezy; urgency=low\n\n  Featurs\n  * Add HSM support via AES keys (#534)\n  * Improved Event Handler for flexible notification (#511)\n  * Signed subscription files for adding and checking\n    for extra functionality during authentication request (#502)\n\n  Enhancements\n  * Allow additional filter attributes in the Audit Log (#519)\n  * Show or hide realms in the login dialog via policy (#517)\n  * Improve UI if admin is not allowed for certain actions (#516, #512)\n  * Disable OTP PIN during enrollment via policy (#439)\n  * Allow automatic sending of registration code via email (#514)\n\n  Fixes\n  * Allow compatibility with ldap3 >= 2.0.7 (#533 #535)\n  * Fix problem with Notification when no tokenowner is available (#528)\n  * Fix confusion of client HTTP parameters (#529)\n  * Fix enabled flag with certain database types (#527)\n  * Catch error in case of faulty overrideClient definition (#526)\n  * Truncate Audit lines, that are too long for the DB table (#525)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 10 Nov 2016 16:30:00 +0200\n\n\nprivacyidea-venv (2.15-1) wheezy; urgency=low\n\n  Features\n  * Client Overview. Display the type of the requesting\n    authenticating clients (#489)\n  * Support for NitroKey OTP mode (admin client)\n\n  Enhancements\n  * Builds on Ubuntu 16.04 Xenial\n  * Performance enhancements using Caching singletons for\n    Config, Realm, Resolver and Policies\n  * Allow configuration of the registration email text (#494)\n  * Return SAML attributes only in case of successful\n    authentication (#500)\n  * Policy \"reset_all_user_tokens\" allow to reset all\n    failcounters on successful authentication (#471)\n  * Client rewrite mapping also checks for\n    X-Forwarded-For (#395, #495)\n\n  Fixes\n  * Fixing RemoteUser fails to display WebUI (#499)\n  * String comparison in HOSTS resolver (#484)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 06 Oct 2016 08:30:00 +0200\n\n\nprivacyidea-venv (2.14-1) wheezy; urgency=low\n\n  Features\n  * Import PGP encrypted seed files\n  * Allow UserNotification for user actions\n  * Allow UserNotification on validate/check events,\n    to notify the user on a failed authentication or\n    a locked token.\n\n  Enhancements\n  * Add thread ID in REST API Response\n  * Performence improvement: Cache LDAP Requests #473\n  * Performance improvement: Optimize resolver iteration #474\n  * Add \"Check OTP only\" in WebUI\n  * Improve \"get serial by OTP\" in WebUI\n  * Add script to get serial by OTP\n\n  Fixes\n  * Restrict GET /user for corresponding admins #460\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 17 Aug 2016 00:03:00 +0200\n\n\nprivacyidea-venv (2.13-1) wheezy; urgency=low\n\n  Features\n  * Allow central definition of SMS gateways \n    to be used with tokens. #392\n  * User SMS for User Notificaton Event Handler. #435\n  * Add PIN change setting for each token. #429\n  * Force PIN change in web UI. #432\n\n  Enhancements\n  * Performence enhancements\n    * speed up loading of audit log in web UI.\n    * avoid double loadin of tokens and audit entries in web UI. #436\n  * Additional log level (enhanced Debug) to even log passwords in \n    debug mode.\n  * Add new logo. #430\n  * Add quick actions in the token list: reset failcounter, \n    toggle active. #426\n  * REST API returns OTP length on successful authentication. #407\n  * Add intelligent OverrideAuthorizationClient system setting,\n    that allows defined proxies to reset the client IP. #395\n\n  Fixes\n  * Display token count in web UI. #437\n  * Use correct default_tokentype in token enrollment. #427\n  * Fix HOTP resync problems. #412\n  \n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 30 Jun 2016 12:00:00 +0200\n\nprivacyidea-venv (2.12-1) wheezy; urgency=low\n\n  Features\n  * Event Handler Framework #360\n  * local CA connector can enroll certificates\n    for users. Users can download PKCS12 file. #383\n  * Add and edit users in LDAP resolvers #372\n  * Time dependent policies #358\n\n  Enhancements\n  * Policy for web UI enrollment wizard #402\n  * Realm dropdown box at login screen #400\n  * Apply user policy settings #390\n  * Improve QR Code for TOTP token enrollment #384\n  * Add documentation for enrollment wizard #381\n  * Improve pi-manage backup to use pymysql #375\n  * Use X-Forwarded-For HTTP header as client IP #356\n  * Add meta-package privacyidea-mysql #376\n\n  Fixes\n  * Adduser honors resolver setting in policy #403\n  * Add documentation for SPASS token #399\n  * Hide enrollment link (WebUI) is user can not enroll #398\n  * Fix getSerial for TOTP tokens #393\n  * Fix system config checkboxes #378\n  * Allow a realm to be remove from a token #363\n  * Improve the date handling in emails #352\n  * Sending test emails #350\n  * Authentication with active token not possible if\n    the user has a disabled token #339\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 24 May 2016 16:00:00 +0200\n\n\nprivacyidea-venv (2.11-1) wheezy; urgency=low\n\n  Features\n  * RADIUS Servers: Allow central definition of RADIUS servers\n  * RADIUS passthru policy: Authentication requests for users\n    with no tokens can be forwarded to a specified RADIUS server\n\n  Enhancements\n  * Allow objectGUID in LDAP-Resolver of Active Directory\n  * Use paged searches in LDAP. LDAP resolver will find all\n    users in the LDAP directory.\n  * Allow privacyIDEA instance name to be configured for\n    the AUDIT log\n  * Allow special characters in LDAP loginnames and passwords\n  * Add arbitrary attributes to SAML Authentication response\n  * Enhance the handling of YUBICO mode yubikeys with the\n    YUBICO API. The prefix is handled correctly.\n  * Allow in get_tokens to be filtered for tokeninfo.\n  * Add paged search in LDAP resolver. This allows responses\n    with more than 1000 objects.\n\n  Fixes\n  * Fix SMTP authentication\n  * Fix Enrollment Wizard for non-default realm users\n  * Registration process: If an email can not be delivered,\n    the token is deleted, since it can not be used.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 29 Mar 2016 08:30:00 +0200\n\nprivacyidea-venv (2.10-1) wheezy; urgency=low\n\n  Features\n  * User Registration: A user may register himself and thus create\n    his new user account.\n  * Password Reset: Using a recovery token a user may issue a\n    password reset without bothering the administrator or the\n    help desk.\n  * Enrollment Wizard for easy user token enrollment\n  * SMTP Servers: Define several system wide SMTP settings and use\n    these for\n    * Email token,\n    * SMTP SMS Provider, \n    * registration process,\n    * or password reset.\n\n  Enhancements\n  * Ease the Smartphone App (Google Authenticator) rollout.\n    Hide otplen, hash, timestep in the UI if a policy is defined.\n  * Add import of Aladdin/SafeNet XML file.\n  * Add import of password encrypted PSKC files.\n  * Add import of key encrypted PSKC files.\n\n  Fixes\n  * Support LDAP passwords with special non-ascii characters.\n  * Support LDAP BIND with special non-ascii characters.\n  * Fix problem with encrypted encryption key.\n  * Fix upgrading DB Schema for postgresql+psycopg2.\n  * Fix UI displaying of saved SMS Provider.\n  * Do not start challenge response with a locked/disabled token.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 11 Feb 2016 00:01:00 +0200\n\nprivacyidea-venv (2.9-1) wheezy; urgency=low\n\n  Features\n  * New token type: Security questions or questionnaire token.\n  * New token type: Paper token. OTP values printed on a piece of paper.\n  * Yubico Validation API: The yubikey tokens can authenticate via\n    /ttype/yubikey which follows the Yubico Validation Protocol.\n\n  Enhancements\n  * Add Web UI view to display the active challenges.\n  * The issuer for the Google Authenticator app can be configured.\n  * The LDAP machine resolver uses an LDAP server pool.\n  * The LDAP user resolver returns a list of mobile numbers.\n\n  Fixes\n  * The test email for the email token now has a sent date.\n  * Fix problem when using encrypted encryption key.\n  * Fix upper case problem when logging in to web UI\n    with REMOTE_USER.\n  * Fix allow set an empty PIN in the web UI.\n  * Fix import of token file in Web UI.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 21 Dec 2015 18:00:00 +0200\n\nprivacyidea-venv (2.8-1) wheezy; urgency=low\n\n  Features\n  * Improve U2F support with trusted facets\n  * Add Challenge Response and U2F support to SAML\n  * Add Web UI theming\n  * Add possibility to use REMOTE_USER for authentication at Web UI\n  * Fuzzy Authentication: restrict time since last authentication\n\n  Enhancements\n  * Allow mangle policy when fetching ssh keys\n  * Add realm support to ownCloud plugin\n  * Support Drupal passwords in SQL resolver\n  * Add validity period to token enrollment\n  * Set default enrollment token type in Web UI\n  * Add scope to LDAP resolver\n\n  Fixes\n  * Fix failcounter reset for challenge response tokens\n  * Fix confusing DB errors (column exist) during installation\n  * Fix email token TLS checkbox saving\n  * Fix TOTP testing in Web UI\n  * Fix SMS config loading in Web UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 26 Nov 2015 23:30:00 +0200\n\nprivacyidea-venv (2.7-1) wheezy; urgency=low\n\n  Features\n  * Add support for U2F tokens\n  * Add signature to the API JSON response. Thus\n    the client can verify the response.\n\n  Enhancements\n  * When importing tokens, a realm can be chosen, so that all imported\n    tokens are immediately inserted into this realm.\n  * The user is able to change his password in the WebUI.\n  * The user can assign a token in the WebUI.\n  * Avoid the requiring of a PIN for some tokentypes like SSH\n  * Migrate to pymysql, the pure python mysql implementation\n  * The Audit Log tells if a previous OTP value was used again.\n\n  Fixes\n  * Enable login to WebUI with a loginname containing an @ sign.\n  * Fix the writing of logfile privacyidea.log\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 07 Oct 2015 08:00:00 +0200\n\n\nprivacyidea-venv (2.6-1) wheezy; urgency=low\n\n  Features\n  * Add OCRA base TiQR token to authenticate by scanning\n    a QR code.\n  * Add Challenge Response authentication to Web UI\n  * Add 4-Eyes token, to enable two man policy. Two tokens\n    of two users are needed to authenticate.\n  * \"Revoke Token\" lets you perform special action on token types.\n    Tokens can be revoke, meaning they are blocked an can not\n    be unblocked anymore.\n\n  Enhancements\n  * Add HA information in the documentation.\n  * Add OpenVPN documentation.\n  * Add challenge response policy, to define if e.g. HOTP or TOTP are \n    allowed to be used in challenge response mode.\n  * Add hotkeys for easier use of Web Ui.\n  * Remove wrong system wide PassOnNoUser and PassOnNoToken.\n  * Set default language to \"en\" in Web UI.\n\n  Fixes\n  * Fix LDAP bug #179, which allows authentication with\n    wrong password under certain conditions\n  * Small fixes in coverage tests\n  * Fix username in web UI during enrollment\n  * Fix link to privacyIDEA logo in Web UI\n  * Fixed bug, that user was not able to resync his own tokens.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 09 Sep 2015 09:30:00 +0200\n\nprivacyidea-venv (2.5-1) wheezy; urgency=low\n\n  Features\n  * Add statistics\n  * Add German translation\n  * Add PinHandler in case of random PIN used\n  * Add automatic documentation of system setup\n  * Add ownCloud plugin\n  \n  Enhancements\n  * Preset Email and SMS of a user when enrolling token\n  * Enable LDAP anonymous bind\n  * Add Hashalgorithms and digits to QR Code\n  * Add support for CentOS 6 and 7\n  \n  Fixes\n  * Fix registration token\n  * Fix mOTP reuse problem\n\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 22 Jul 2015 17:00:00 +0200\n\n\nprivacyidea-venv (2.4-1) wheezy; urgency=low\n\n  * Add User Management\n  * Add Admin Realms to policies, to allow better policies in bigger setups\n  * Add API key, that can be used for accessing /validate/check\n  * Load PSKC Token seed files.\n  * WebUI: Registrtion token can be enrolled in WebUI\n  * WebUI: The token seed can be displayed in WebUI after generation\n  * WebUI: Only the token types that are allowed to be enrolled are displayed\n  * WebUI: Login_Mode Policy: Disable access to WebUI for certain users\n  * WebUI: Add reload button in Audit view\n  * SQLResolver: The Where statement is used in all cases\n  * SSH-Token Application: Only fetch keys of the requested user\n  * Apache client can work with several hosts on one machine\n  * Documentation: Tokentypes and Supported Hardware Tokens\n  * Improve RADIUS module\n  * WebUI: Fix download of audit log\n  * Fix missing access right of user to GET /caconnector\n  * Fix SMS token\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Jun 2015 09:30:00 +0200\n\nprivacyidea-venv (2.3-1) wheezy; urgency=low\n\n  * Add connector to remote Certificate Authority\n  * Add Tokentype \"certificate\" to manage certificates for users\n    Certificates or Certificate Requests can be uploaded.\n    Certificate Requests (Keypair) can be generated in the browser.\n  * Add Tokentype \"registration\" for easier enrollment scenarios.\n  * Add TokenType \"Email\" to send OTP via Email.\n  * Add \"First Steps\" to online documentation\n  * Add handling of validity period of token\n  * Enable download of Audit log as CSV\n  * Add Resolver Priority, to handle a duplicate user in a realm\n  * Add TYPO3 Plugin to enable OTP with TYPO3\n  * Add SCIM Resolver to fetch users from SCIM services\n  * Fix Failcounter issue\n  * Fix NTLM password check\n  * Fix timestep during enrollment\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 22 May 2015 15:30:00 +0200\n\nprivacyidea-venv (2.2-1) wheezy; urgency=low\n\n  * pi-manage: create resolvers and realms\n  * pi-manage: maange policies\n  * Add LostToken UI\n  * Add Offline Application\n  * Add PAM authentication module with offline support\n  * Add getSerialByOTP. You can determine the Token by providing an OTP value.\n  * Add auth_count_max and auth_success_max for each token.\n  * Add PIN encryption policy\n  * Add API for SAML\n  * Add bash script for ssh key fetching\n  * Make WebUI logout time configurable via webui policy.\n  \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Apr 2015 12:10:00 +0200\n\nprivacyidea-venv (2.1-1) wheezy; urgency=low\n\n  * Add Machine-Application framework to support LUKS and SSH\n    to manage SSH keys and provide Yubikeys to boot LUKS\n    encrypted machines. #100, #10\n  * Add Machine Resolvers for hosts and LDAP/AD #96\n  * Migrate more policies like SMS policies. #95\n  * Restructure WebUI code to ease development #97\n  * Fix logout problem of user #92\n  * Fix user list for AD (referrals) #99\n  * Fix max_token_per_user policy #101\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 10 Mar 2015 10:30:00 +0200\n\nprivacyidea-venv (2.1~dev2) trusty; urgency=low\n\n  * Add MachineTokens to Token.Details and Machine.Details view.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 02 Mar 2015 15:50:00 +0200\n\nprivacyidea-venv (2.1~dev1) trusty; urgency=low\n\n  * Fix logout problem of user\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 16:00:00 +0200\n\npython-privacyidea (2.0-1) trusty; urgency=low\n\n  * Migrate to flask\n  * change the name of the debian package as the package only\n    contains the python module.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 14:00:00 +0200\n\n\nprivacyidea (1.5.1-1trusty) trusty; urgency=low\n\n  * Fix splitting the @-sign to allow users like user@email.com\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 02 Feb 2015 09:08:00 +0200\n\n\nprivacyidea (1.5-1trusty) trusty; urgency=low\n\n  * Fix the postinstall script for not broken repoze.who\n  * adapt the dependency for python webob\n  * add fix for users in policies.\n  * Working on #61\n  * Closing #63, allow upper and lower case DN in LDAP resolver\n  * Fix the empty result audit search problem\n  * Fix the port problem with SQL resolver\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 25 Dec 2014 16:30:00 +0200\n\nprivacyidea (1.4-1) trusty; urgency=low\n\n  * Add \"wrong password\" message on login screen\n  * Speed up tests\n  * Add help on logon screen.\n  * Add helper dialog to setup first realm\n  * Add simplesamlphp module and deb package\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 16:50:00 +0200\n\nprivacyidea (1.4~dev5-1) trusty; urgency=low\n\n  * Add wrong password message on login screen\n  * Speed up tests\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 09:10:00 +0200\n\nprivacyidea (1.4~dev4-1) trusty; urgency=low\n\n  * Add help on logon screen.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 02 Oct 2014 11:20:00 +0200\n\nprivacyidea (1.4~dev3-1) trusty; urgency=low\n\n  * Add helper dialog to setup first realm\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 30 Sep 2014 11:10:00 +0200\n\nprivacyidea (1.4~dev2-1) trusty; urgency=low\n\n  * Add simplesamlphp module and deb package\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 29 Sep 2014 11:40:00 +0200\n\nprivacyidea (1.4~dev1-1) trusty; urgency=low\n\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Sep 2014 19:10:00 +0200\n\nprivacyidea (1.3.2-1) trusty; urgency=low\n\n  * Add uwsgi and nginx configuration\n  * Add nginx package\n  * Add meta packages to easily install radius dependencies. (#33)\n  * Add package for appliance\n  * Add appliance style: privacyidea-setup-tui\n  * Add privacyidea-otrs and remove the authmodules from the\n    core package\n  * Add first implementation of Token2 token type\n  * Change depend in builddepend\n  * Add missing SSL certificate\n  * Add missing python-dialog dependency\n  * Remove pylons download link, that caused timeout problems.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 22 Sep 2014 10:00:00 +0200\n\nprivacyidea (1.3.1-1) trusty; urgency=low\n\n  * Fixed bug, that avoided to delete MachineTokens with options (#27)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 20 Aug 2014 18:30:00 +0200\n\nprivacyidea (1.3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n  * inactive tokens will not work with the machine-app\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 18 Aug 2014 17:00:00 +0200\n\nprivacyidea (1.3~dev5-1) trusty; urgency=low\n\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 15 Aug 2014 15:37:00 +0200\n\nprivacyidea (1.3~dev4-1) trusty; urgency=low\n\n  * fix minor bugs in selfservice portal\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 13 Aug 2014 17:40:00 +0200\n\nprivacyidea (1.3~dev3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 12 Aug 2014 18:32:00 +0200\n\nprivacyidea (1.3~dev2-1) trusty; urgency=low\n\n  * machine requires IP address\n  * the machine-app listing also returns the information, if the token\n    is active\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 11 Aug 2014 10:40:00 +0200\n\n\nprivacyidea (1.3~dev1-1) trusty; urgency=low\n\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 06 Aug 2014 14:14:00 +0200\n\nprivacyidea (1.3~dev0-2) trusty; urgency=low\n\n  * Fixed the missing run directory (#23)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 31 Jul 2014 09:28:00 +0200\n \nprivacyidea (1.3~dev0-1) trusty; urgency=low\n\n  * Fix resolver error #22\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 30 Jul 2014 16:24:00 +0200\n\nprivacyidea (1.2.2-1) trusty; urgency=low\n\n  * Fixed the sqlsoup dependency\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 23 Jul 2014 17:57:00 +0200\n\n\nprivacyidea (1.2.1-1) trusty; urgency=low\n\n  * machine controller: make the challenge usable also in normal mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 18 Jul 2014 16:51:00 +0200\n\n\nprivacyidea (1.2-1) trusty; urgency=low\n\n  * Added \n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 15 Jul 2014 15:15:55 +0200\n\nprivacyidea (1.2~dev2-1) trusty; urgency=low\n\n  * initial ubuntu release\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 14 Jul 2014 18:56:55 +0200\n", "#!/usr/bin/make -f\n\n# This file was automatically generated by stdeb 0.6.0+git at\n# Mon, 14 Jul 2014 18:56:55 +0200\n\n%:\n\tdh $@ --with python-virtualenv \n\noverride_dh_virtualenv:\n\tdh_virtualenv --upgrade-pip\n\noverride_dh_shlibdeps:\n\tdh_shlibdeps --exclude=numpy --exclude=psycopg2 --exclude=libz --exclude=png16\n\n\n", "# -*- coding: utf-8 -*-\n#\n# privacyIDEA documentation build configuration file, created by\n# sphinx-quickstart on Fri Jun 13 07:31:01 2014.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '2.23.1'\n# The full version, including alpha/beta/rc tags.\n#release = '2.16dev5'\nrelease = version\n\n\nimport sys\nimport os\nfrom mock import Mock as MagicMock\n\nclass Mock(MagicMock):\n    @classmethod\n    def __getattr__(cls, name):\n            return MagicMock()\n\n#MOCK_MODULES = ['pandas', 'pyOpenSSL']\nMOCK_MODULES = []\nsys.modules.update((mod_name, Mock()) for mod_name in MOCK_MODULES)\n\n\n# Monkey-patch functools.wraps\n# http://stackoverflow.com/questions/28366818/preserve-default-arguments-of-wrapped-decorated-python-function-in-sphinx-docume\nimport functools\n\ndef no_op_wraps(func):\n    \"\"\"Replaces functools.wraps in order to undo wrapping.\n\n    Can be used to preserve the decorated function's signature\n    in the documentation generated by Sphinx.\n\n    \"\"\"\n    def wrapper(decorator):\n        return func\n    return wrapper\n\nfunctools.wraps = no_op_wraps\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath('..'))\nsys.path.append(os.path.abspath('_themes/flask-sphinx-themes'))\nsys.path.insert(0, os.path.abspath('../privacyidea'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.imgmath', 'sphinx.ext.viewcode', \n              'sphinxcontrib.autohttp.flask']\nhttp_index_ignore_prefixes = ['/token']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'privacyIDEA'\ncopyright = u'2014-2017, Cornelius K\u00f6lbel'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\nadd_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#html_theme = 'sphinxdoc'\n#html_theme = 'sphinx_rtd_theme'\n#html_theme = 'agogo'\nhtml_theme = 'flask'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = ['_themes/flask-sphinx-themes']\n\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\nhtml_logo = \"images/privacyidea-color.png\"\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'privacyIDEAdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('index', 'privacyIDEA.tex', u'privacyIDEA Authentication System',\n   u'Cornelius K\u00f6lbel', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'privacyidea-server', u'privacyIDEA Authentication System',\n     [u'Cornelius K\u00f6lbel'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'privacyIDEA', u'privacyIDEA AUthentication System',\n   u'Cornelius K\u00f6lbel', 'privacyIDEA', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n", "# -*- coding: utf-8 -*-\n#\n# http://www.privacyidea.org\n# (c) cornelius k\u00f6lbel, privacyidea.org\n#\n# 2018-01-22 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            Add offline refill\n# 2016-12-20 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            Add triggerchallenge endpoint\n# 2016-10-23 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            Add subscription decorator\n# 2016-09-05 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            SAML attributes on fail\n# 2016-08-30 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            save client application type to database\n# 2016-08-09 Cornelius K\u00f6lbel <cornelius@privacyidea.org>\n#            Add possiblity to check OTP only\n# 2015-11-19 Cornelius K\u00f6lbel <cornelius@privacyidea.org>\n#            Add support for transaction_id to saml_check\n# 2015-06-17 Cornelius K\u00f6lbel <cornelius@privacyidea.org>\n#            Add policy decorator for API key requirement\n# 2014-12-08 Cornelius K\u00f6lbel, <cornelius@privacyidea.org>\n#            Complete rewrite during flask migration\n#            Try to provide REST API\n#\n# This code is free software; you can redistribute it and/or\n# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n# License as published by the Free Software Foundation; either\n# version 3 of the License, or any later version.\n#\n# This code is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU AFFERO GENERAL PUBLIC LICENSE for more details.\n#\n# You should have received a copy of the GNU Affero General Public\n# License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n__doc__ = \"\"\"This module contains the REST API for doing authentication.\nThe methods are tested in the file tests/test_api_validate.py\n\nAuthentication is either done by providing a username and a password or a\nserial number and a password.\n\n**Authentication workflow**\n\nAuthentication workflow is like this:\n\nIn case of authenticating a user:\n\n * :func:`privacyidea.lib.token.check_user_pass`\n * :func:`privacyidea.lib.token.check_token_list`\n * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`\n\nIn case if authenitcating a serial number:\n\n * :func:`privacyidea.lib.token.check_serial_pass`\n * :func:`privacyidea.lib.token.check_token_list`\n * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`\n\n\"\"\"\nfrom flask import (Blueprint, request, g, current_app)\nfrom privacyidea.lib.user import get_user_from_param\nfrom .lib.utils import send_result, getParam\nfrom ..lib.decorators import (check_user_or_serial_in_request)\nfrom .lib.utils import required\nfrom privacyidea.lib.error import ParameterError\nfrom privacyidea.lib.token import (check_user_pass, check_serial_pass,\n                                   check_otp)\nfrom privacyidea.api.lib.utils import get_all_params\nfrom privacyidea.lib.config import (return_saml_attributes, get_from_config,\n                                    return_saml_attributes_on_fail,\n                                    SYSCONF)\nfrom privacyidea.lib.audit import getAudit\nfrom privacyidea.api.lib.prepolicy import (prepolicy, set_realm,\n                                           api_key_required, mangle,\n                                           save_client_application_type,\n                                           check_base_action)\nfrom privacyidea.api.lib.postpolicy import (postpolicy,\n                                            check_tokentype, check_serial,\n                                            check_tokeninfo,\n                                            no_detail_on_fail,\n                                            no_detail_on_success, autoassign,\n                                            offline_info,\n                                            add_user_detail_to_response, construct_radius_response)\nfrom privacyidea.lib.policy import PolicyClass\nfrom privacyidea.lib.config import ConfigClass\nfrom privacyidea.lib.event import EventConfiguration\nimport logging\nfrom privacyidea.api.lib.postpolicy import postrequest, sign_response\nfrom privacyidea.api.auth import jwtauth\nfrom privacyidea.api.register import register_blueprint\nfrom privacyidea.api.recover import recover_blueprint\nfrom privacyidea.lib.utils import get_client_ip\nfrom privacyidea.lib.event import event\nfrom privacyidea.lib.subscriptions import CheckSubscription\nfrom privacyidea.api.auth import admin_required\nfrom privacyidea.lib.policy import ACTION\nfrom privacyidea.lib.token import get_tokens\nfrom privacyidea.lib.machine import list_token_machines\nfrom privacyidea.lib.applications.offline import MachineApplication\nimport json\n\nlog = logging.getLogger(__name__)\n\nvalidate_blueprint = Blueprint('validate_blueprint', __name__)\n\n\n@validate_blueprint.before_request\n@register_blueprint.before_request\n@recover_blueprint.before_request\ndef before_request():\n    \"\"\"\n    This is executed before the request\n    \"\"\"\n    g.config_object = ConfigClass()\n    request.all_data = get_all_params(request.values, request.data)\n    request.User = get_user_from_param(request.all_data)\n    privacyidea_server = current_app.config.get(\"PI_AUDIT_SERVERNAME\") or \\\n                         request.host\n    # Create a policy_object, that reads the database audit settings\n    # and contains the complete policy definition during the request.\n    # This audit_object can be used in the postpolicy and prepolicy and it\n    # can be passed to the innerpolicies.\n\n    g.policy_object = PolicyClass()\n\n    g.audit_object = getAudit(current_app.config)\n    g.event_config = EventConfiguration()\n    # access_route contains the ip addresses of all clients, hops and proxies.\n    g.client_ip = get_client_ip(request, get_from_config(SYSCONF.OVERRIDECLIENT))\n    g.audit_object.log({\"success\": False,\n                        \"action_detail\": \"\",\n                        \"client\": g.client_ip,\n                        \"client_user_agent\": request.user_agent.browser,\n                        \"privacyidea_server\": privacyidea_server,\n                        \"action\": \"{0!s} {1!s}\".format(request.method, request.url_rule),\n                        \"info\": \"\"})\n\n\n@validate_blueprint.after_request\n@register_blueprint.after_request\n@recover_blueprint.after_request\n@jwtauth.after_request\n@postrequest(sign_response, request=request)\ndef after_request(response):\n    \"\"\"\n    This function is called after a request\n    :return: The response\n    \"\"\"\n    # In certain error cases the before_request was not handled\n    # completely so that we do not have an audit_object\n    if \"audit_object\" in g:\n        g.audit_object.finalize_log()\n\n    # No caching!\n    response.headers['Cache-Control'] = 'no-cache'\n    return response\n\n\n@validate_blueprint.route('/offlinerefill', methods=['POST'])\n@event(\"validate_offlinerefill\", request, g)\ndef offlinerefill():\n    \"\"\"\n    This endpoint allows to fetch new offline OTP values for a token,\n    that is already offline.\n    According to the definition it will send the missing OTP values, so that\n    the client will have as much otp values as defined.\n\n    :param serial: The serial number of the token, that should be refilled.\n    :param refilltoken: The authorization token, that allows refilling.\n    :param pass: the last password (maybe password+OTP) entered by the user\n    :return:\n    \"\"\"\n    result = False\n    otps = {}\n    serial = getParam(request.all_data, \"serial\", required)\n    refilltoken = getParam(request.all_data, \"refilltoken\", required)\n    password = getParam(request.all_data, \"pass\", required)\n    tokenobj_list = get_tokens(serial=serial)\n    if len(tokenobj_list) != 1:\n        raise ParameterError(\"The token does not exist\")\n    else:\n        tokenobj = tokenobj_list[0]\n        machine_defs = list_token_machines(serial)\n        # check if is still an offline token:\n        for mdef in machine_defs:\n            if mdef.get(\"application\") == \"offline\":\n                # check refill token:\n                if tokenobj.get_tokeninfo(\"refilltoken\") == refilltoken:\n                    # refill\n                    otps = MachineApplication.get_refill(tokenobj, password, mdef.get(\"options\"))\n                    refilltoken = MachineApplication.generate_new_refilltoken(tokenobj)\n                    response = send_result(True)\n                    content = json.loads(response.data)\n                    content[\"auth_items\"] = {\"offline\": [{\"refilltoken\": refilltoken,\n                                                          \"response\": otps}]}\n                    response.data = json.dumps(content)\n                    return response\n        raise ParameterError(\"Token is not an offline token or refill token is incorrect\")\n\n\n@validate_blueprint.route('/check', methods=['POST', 'GET'])\n@validate_blueprint.route('/radiuscheck', methods=['POST', 'GET'])\n@postpolicy(construct_radius_response, request=request)\n@postpolicy(no_detail_on_fail, request=request)\n@postpolicy(no_detail_on_success, request=request)\n@postpolicy(add_user_detail_to_response, request=request)\n@postpolicy(offline_info, request=request)\n@postpolicy(check_tokeninfo, request=request)\n@postpolicy(check_tokentype, request=request)\n@postpolicy(check_serial, request=request)\n@postpolicy(autoassign, request=request)\n@prepolicy(set_realm, request=request)\n@prepolicy(mangle, request=request)\n@prepolicy(save_client_application_type, request=request)\n@check_user_or_serial_in_request(request)\n@CheckSubscription(request)\n@prepolicy(api_key_required, request=request)\n@event(\"validate_check\", request, g)\ndef check():\n    \"\"\"\n    check the authentication for a user or a serial number.\n    Either a ``serial`` or a ``user`` is required to authenticate.\n    The PIN and OTP value is sent in the parameter ``pass``.\n    In case of successful authentication it returns ``result->value: true``.\n\n    In case of a challenge response authentication a parameter ``exception=1``\n    can be passed. This would result in a HTTP 500 Server Error response if\n    an error occurred during sending of SMS or Email.\n\n    In case ``/validate/radiuscheck`` is requested, the responses are\n    modified as follows: A successful authentication returns an empty HTTP\n    204 response. An unsuccessful authentication returns an empty HTTP\n    400 response. Error responses are the same responses as for the\n    ``/validate/check`` endpoint.\n\n    :param serial: The serial number of the token, that tries to authenticate.\n    :param user: The loginname/username of the user, who tries to authenticate.\n    :param realm: The realm of the user, who tries to authenticate. If the\n        realm is omitted, the user is looked up in the default realm.\n    :param pass: The password, that consists of the OTP PIN and the OTP value.\n    :param otponly: If set to 1, only the OTP value is verified. This is used\n        in the management UI. Only used with the parameter serial.\n    :param transaction_id: The transaction ID for a response to a challenge\n        request\n    :param state: The state ID for a response to a challenge request\n\n    :return: a json result with a boolean \"result\": true\n\n    **Example Validation Request**:\n\n        .. sourcecode:: http\n\n           POST /validate/check HTTP/1.1\n           Host: example.com\n           Accept: application/json\n\n           user=user\n           realm=realm1\n           pass=s3cret123456\n\n    **Example response** for a successful authentication:\n\n       .. sourcecode:: http\n\n           HTTP/1.1 200 OK\n           Content-Type: application/json\n\n            {\n              \"detail\": {\n                \"message\": \"matching 1 tokens\",\n                \"serial\": \"PISP0000AB00\",\n                \"type\": \"spass\"\n              },\n              \"id\": 1,\n              \"jsonrpc\": \"2.0\",\n              \"result\": {\n                \"status\": true,\n                \"value\": true\n              },\n              \"version\": \"privacyIDEA unknown\"\n            }\n\n    **Example response** for this first part of a challenge response\n    authentication:\n\n       .. sourcecode:: http\n\n           HTTP/1.1 200 OK\n           Content-Type: application/json\n\n            {\n              \"detail\": {\n                \"serial\": \"PIEM0000AB00\",\n                \"type\": \"email\",\n                \"transaction_id\": \"12345678901234567890\",\n                \"multi_challenge: [ {\"serial\": \"PIEM0000AB00\",\n                                     \"transaction_id\":  \"12345678901234567890\",\n                                     \"message\": \"Please enter otp from your\n                                     email\"},\n                                    {\"serial\": \"PISM12345678\",\n                                     \"transaction_id\": \"12345678901234567890\",\n                                     \"message\": \"Please enter otp from your\n                                     SMS\"}\n                ]\n              },\n              \"id\": 1,\n              \"jsonrpc\": \"2.0\",\n              \"result\": {\n                \"status\": true,\n                \"value\": false\n              },\n              \"version\": \"privacyIDEA unknown\"\n            }\n\n    In this example two challenges are triggered, one with an email and one\n    with an SMS. The application and thus the user has to decide, which one\n    to use. They can use either.\n\n    .. note:: All challenge response tokens have the same transaction_id in\n       this case.\n    \"\"\"\n    #user = get_user_from_param(request.all_data)\n    user = request.User\n    serial = getParam(request.all_data, \"serial\")\n    password = getParam(request.all_data, \"pass\", required)\n    otp_only = getParam(request.all_data, \"otponly\")\n    options = {\"g\": g,\n               \"clientip\": g.client_ip}\n    # Add all params to the options\n    for key, value in request.all_data.items():\n            if value and key not in [\"g\", \"clientip\"]:\n                options[key] = value\n\n    g.audit_object.log({\"user\": user.login,\n                        \"resolver\": user.resolver,\n                        \"realm\": user.realm})\n\n    if serial:\n        if not otp_only:\n            result, details = check_serial_pass(serial, password, options=options)\n        else:\n            result, details = check_otp(serial, password)\n\n    else:\n        result, details = check_user_pass(user, password, options=options)\n\n    g.audit_object.log({\"info\": details.get(\"message\"),\n                        \"success\": result,\n                        \"serial\": serial or details.get(\"serial\"),\n                        \"tokentype\": details.get(\"type\")})\n    return send_result(result, details=details)\n\n\n@validate_blueprint.route('/samlcheck', methods=['POST', 'GET'])\n@postpolicy(no_detail_on_fail, request=request)\n@postpolicy(no_detail_on_success, request=request)\n@postpolicy(add_user_detail_to_response, request=request)\n@postpolicy(check_tokeninfo, request=request)\n@postpolicy(check_tokentype, request=request)\n@postpolicy(check_serial, request=request)\n@postpolicy(autoassign, request=request)\n@prepolicy(set_realm, request=request)\n@prepolicy(mangle, request=request)\n@prepolicy(save_client_application_type, request=request)\n@check_user_or_serial_in_request(request)\n@CheckSubscription(request)\n@prepolicy(api_key_required, request=request)\n@event(\"validate_check\", request, g)\ndef samlcheck():\n    \"\"\"\n    Authenticate the user and return the SAML user information.\n\n    :param user: The loginname/username of the user, who tries to authenticate.\n    :param realm: The realm of the user, who tries to authenticate. If the\n        realm is omitted, the user is looked up in the default realm.\n    :param pass: The password, that consists of the OTP PIN and the OTP value.\n\n    :return: a json result with a boolean \"result\": true\n\n    **Example response** for a successful authentication:\n\n       .. sourcecode:: http\n\n           HTTP/1.1 200 OK\n           Content-Type: application/json\n\n            {\n              \"detail\": {\n                \"message\": \"matching 1 tokens\",\n                \"serial\": \"PISP0000AB00\",\n                \"type\": \"spass\"\n              },\n              \"id\": 1,\n              \"jsonrpc\": \"2.0\",\n              \"result\": {\n                \"status\": true,\n                \"value\": {\"attributes\": {\n                            \"username\": \"koelbel\",\n                            \"realm\": \"themis\",\n                            \"mobile\": null,\n                            \"phone\": null,\n                            \"myOwn\": \"/data/file/home/koelbel\",\n                            \"resolver\": \"themis\",\n                            \"surname\": \"K\u00f6lbel\",\n                            \"givenname\": \"Cornelius\",\n                            \"email\": null},\n                          \"auth\": true}\n              },\n              \"version\": \"privacyIDEA unknown\"\n            }\n\n    The response in value->attributes can contain additional attributes\n    (like \"myOwn\") which you can define in the LDAP resolver in the attribute\n    mapping.\n    \"\"\"\n    user = get_user_from_param(request.all_data)\n    password = getParam(request.all_data, \"pass\", required)\n    options = {\"g\": g,\n               \"clientip\": g.client_ip}\n    # Add all params to the options\n    for key, value in request.all_data.items():\n            if value and key not in [\"g\", \"clientip\"]:\n                options[key] = value\n\n    auth, details = check_user_pass(user, password, options=options)\n    ui = user.info\n    result_obj = {\"auth\": auth,\n                  \"attributes\": {}}\n    if return_saml_attributes():\n        if auth or return_saml_attributes_on_fail():\n            # privacyIDEA's own attribute map\n            result_obj[\"attributes\"] = {\"username\": ui.get(\"username\"),\n                                        \"realm\": user.realm,\n                                        \"resolver\": user.resolver,\n                                        \"email\": ui.get(\"email\"),\n                                        \"surname\": ui.get(\"surname\"),\n                                        \"givenname\": ui.get(\"givenname\"),\n                                        \"mobile\": ui.get(\"mobile\"),\n                                        \"phone\": ui.get(\"phone\")\n                                        }\n            # additional attributes\n            for k, v in ui.iteritems():\n                result_obj[\"attributes\"][k] = v\n\n    g.audit_object.log({\"info\": details.get(\"message\"),\n                        \"success\": auth,\n                        \"serial\": details.get(\"serial\"),\n                        \"tokentype\": details.get(\"type\"),\n                        \"user\": user.login,\n                        \"resolver\": user.resolver,\n                        \"realm\": user.realm})\n    return send_result(result_obj, details=details)\n\n\n@validate_blueprint.route('/triggerchallenge', methods=['POST', 'GET'])\n@admin_required\n@check_user_or_serial_in_request(request)\n@prepolicy(check_base_action, request, action=ACTION.TRIGGERCHALLENGE)\n@event(\"validate_triggerchallenge\", request, g)\ndef trigger_challenge():\n    \"\"\"\n    An administrator can call this endpoint if he has the right of\n    ``triggerchallenge`` (scope: admin).\n    He can pass a ``user`` name and or a ``serial`` number.\n    privacyIDEA will trigger challenges for all native challenges response\n    tokens, possessed by this user or only for the given serial number.\n\n    The request needs to contain a valid PI-Authorization header.\n\n    :param user: The loginname/username of the user, who tries to authenticate.\n    :param realm: The realm of the user, who tries to authenticate. If the\n        realm is omitted, the user is looked up in the default realm.\n    :param serial: The serial number of the token.\n\n    :return: a json result with a \"result\" of the number of matching\n        challenge response tokens\n\n    **Example response** for a successful triggering of challenge:\n\n       .. sourcecode:: http\n\n           {\"jsonrpc\": \"2.0\",\n            \"signature\": \"1939...146964\",\n            \"detail\": {\"transaction_ids\": [\"03921966357577766962\"],\n                       \"messages\": [\"Enter the OTP from the SMS:\"],\n                       \"threadid\": 140422378276608},\n            \"versionnumber\": \"unknown\",\n            \"version\": \"privacyIDEA unknown\",\n            \"result\": {\"status\": true,\n                       \"value\": 1},\n            \"time\": 1482223663.517212,\n            \"id\": 1}\n\n    **Example response** for response, if the user has no challenge token:\n\n       .. sourcecode:: http\n\n           {\"detail\": {\"messages\": [],\n                       \"threadid\": 140031212377856,\n                       \"transaction_ids\": []},\n            \"id\": 1,\n            \"jsonrpc\": \"2.0\",\n            \"result\": {\"status\": true,\n                       \"value\": 0},\n            \"signature\": \"205530282...54508\",\n            \"time\": 1484303812.346576,\n            \"version\": \"privacyIDEA 2.17\",\n            \"versionnumber\": \"2.17\"}\n\n    **Example response** for a failed triggering of a challenge. In this case\n        the ``status`` will be ``false``.\n\n       .. sourcecode:: http\n\n           {\"detail\": null,\n            \"id\": 1,\n            \"jsonrpc\": \"2.0\",\n            \"result\": {\"error\": {\"code\": 905,\n                                 \"message\": \"ERR905: The user can not be\n                                 found in any resolver in this realm!\"},\n                       \"status\": false},\n            \"signature\": \"14468...081555\",\n            \"time\": 1484303933.72481,\n            \"version\": \"privacyIDEA 2.17\"}\n\n    \"\"\"\n    user = request.User\n    serial = getParam(request.all_data, \"serial\")\n    result_obj = 0\n    details = {\"messages\": [],\n               \"transaction_ids\": []}\n    options = {\"g\": g,\n               \"clientip\": g.client_ip,\n               \"user\": user}\n\n    token_objs = get_tokens(serial=serial, user=user, active=True, revoked=False, locked=False)\n    for token_obj in token_objs:\n        if \"challenge\" in token_obj.mode:\n            # If this is a challenge response token, we create a challenge\n            success, return_message, transactionid, attributes = \\\n                token_obj.create_challenge(options=options)\n            if attributes:\n                details[\"attributes\"] = attributes\n            if success:\n                result_obj += 1\n                details.get(\"transaction_ids\").append(transactionid)\n                # This will write only the serial of the token that was processed last to the audit log\n                g.audit_object.log({\n                    \"serial\": token_obj.token.serial,\n                })\n            details.get(\"messages\").append(return_message)\n\n    g.audit_object.log({\n        \"user\": user.login,\n        \"resolver\": user.resolver,\n        \"realm\": user.realm,\n        \"success\": result_obj > 0,\n        \"info\": \"triggered {0!s} challenges\".format(result_obj),\n    })\n\n    return send_result(result_obj, details=details)\n\n", "# -*- coding: utf-8 -*-\n#\n#  (c) Cornelius K\u00f6lbel\n#  License:  AGPLv3\n#  contact:  http://www.privacyidea.org\n#\n# This code is free software; you can redistribute it and/or\n# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n# License as published by the Free Software Foundation; either\n# version 3 of the License, or any later version.\n#\n# This code is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU AFFERO GENERAL PUBLIC LICENSE for more details.\n#\n# You should have received a copy of the GNU Affero General Public\n# License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nimport logging\nimport functools\nfrom privacyidea.lib.error import TokenAdminError\nfrom privacyidea.lib.error import ParameterError\nfrom privacyidea.lib import _\nlog = logging.getLogger(__name__)\n\n\ndef check_token_locked(func):\n    \"\"\"\n    Decorator to check if a token is locked or not.\n    The decorator is to be used in token class methods.\n    It can be used to avoid performing an action on a locked token.\n\n    If the token is locked, a TokenAdminError is raised.\n    \"\"\"\n    @functools.wraps(func)\n    def token_locked_wrapper(*args, **kwds):\n        # The token object\n        token = args[0]\n        if token.is_locked():\n            raise TokenAdminError(_(\"This action is not possible, since the \"\n                                    \"token is locked\"), id=1007)\n        f_result = func(*args, **kwds)\n        return f_result\n\n    return token_locked_wrapper\n\n\ndef check_user_or_serial(func):\n    \"\"\"\n    Decorator to check user and serial at the beginning of a function\n    The wrapper will check the parameters user and serial and verify that\n    not both parameters are None. Otherwise it will throw an exception\n    ParameterError.\n    \"\"\"\n    @functools.wraps(func)\n    def user_or_serial_wrapper(*args, **kwds):\n        # If there is no user and serial keyword parameter and if\n        # there is no normal argument, we do not have enough information\n        serial = kwds.get(\"serial\")\n        user = kwds.get(\"user\")\n        # We have no serial! The serial would be the first arg\n        if (serial is None and (len(args) == 0 or args[0] is None) and\n                (user is None or (user is not None and user.is_empty()))):\n            # We either have an empty User object or None\n            raise ParameterError(ParameterError.USER_OR_SERIAL)\n\n        f_result = func(*args, **kwds)\n        return f_result\n\n    return user_or_serial_wrapper\n\n\nclass check_user_or_serial_in_request(object):\n    \"\"\"\n    Decorator to check user and serial in a request.\n    If the request does not contain a serial number (serial) or a user\n    (user) it will throw a ParameterError.\n    \"\"\"\n    def __init__(self, request):\n        self.request = request\n\n    def __call__(self, func):\n        @functools.wraps(func)\n        def check_user_or_serial_in_request_wrapper(*args, **kwds):\n            user = self.request.all_data.get(\"user\")\n            serial = self.request.all_data.get(\"serial\")\n            if not serial and not user:\n                raise ParameterError(_(\"You need to specify a serial or a user.\"))\n            f_result = func(*args, **kwds)\n            return f_result\n\n        return check_user_or_serial_in_request_wrapper\n\n\ndef check_copy_serials(func):\n    \"\"\"\n    Decorator to check if the serial_from and serial_to exist.\n    If the serials are not unique, we raise an error\n    \"\"\"\n    from privacyidea.lib.token import get_tokens\n    @functools.wraps(func)\n    def check_serial_wrapper(*args, **kwds):\n        tokenobject_list_from = get_tokens(serial=args[0])\n        tokenobject_list_to = get_tokens(serial=args[1])\n        if len(tokenobject_list_from) != 1:\n            log.error(\"not a unique token to copy from found\")\n            raise(TokenAdminError(\"No unique token to copy from found\",\n                                   id=1016))\n        if len(tokenobject_list_to) != 1:\n            log.error(\"not a unique token to copy to found\")\n            raise(TokenAdminError(\"No unique token to copy to found\",\n                                   id=1017))\n\n        f_result = func(*args, **kwds)\n        return f_result\n\n    return check_serial_wrapper\n\n", "# -*- coding: utf-8 -*-\nfrom setuptools import setup, find_packages\nimport os\nimport stat\nimport sys\n\n#VERSION=\"2.1dev4\"\nVERSION=\"2.23.1\"\n\n# Taken from kennethreitz/requests/setup.py\npackage_directory = os.path.realpath(os.path.dirname(__file__))\n\n\ndef get_file_contents(file_path):\n    \"\"\"Get the context of the file using full path name.\"\"\"\n    content = \"\"\n    try:\n        full_path = os.path.join(package_directory, file_path)\n        content = open(full_path, 'r').read()\n    except:\n        print >> sys.stderr, \"### could not open file {0!r}\".format(file_path)\n    return content\n\ndef get_file_list(file_path):\n    full_path = os.path.join(package_directory, file_path)\n    file_list = os.listdir(full_path)\n    # now we need to add the path to the files\n    return [ file_path + f for f in file_list ]\n\n\ninstall_requires = [\"Flask>=0.10.1\",\n                    \"Flask-Migrate>=1.2.0\",\n                    \"Flask-SQLAlchemy>=2.0\",\n                    \"Flask-Script>=2.0.5\",\n                    \"Jinja2>=2.7.3\",\n                    \"Mako>=0.9.1\",\n                    \"MarkupSafe>=0.23\",\n                    \"PyMySQL>=0.6.6\",\n                    \"Pillow>=2.6.1\",\n                    \"PyJWT>=1.3.0\",\n                    \"PyYAML>=3.11\",\n                    \"Pygments>=2.0.2\",\n                    \"SQLAlchemy>=1.0.5\",\n                    \"Werkzeug>=0.10.4\",\n                    \"alembic>=0.6.7\",\n                    \"argparse>=1.2.1\",\n                    \"bcrypt>=1.1.0\",\n                    \"beautifulsoup4>=4.3.2\",\n                    \"cffi>=0.8.6\",\n                    \"configobj>=5.0.6\",\n                    \"docutils>=0.12\",\n                    \"funcparserlib>=0.3.6\",\n                    \"itsdangerous>=0.24\",\n                    \"ldap3>=2.5\",\n                    \"netaddr>=0.7.12\",\n                    \"passlib>=1.6.2\",\n                    \"pyasn1>=0.4.2\",\n                    \"pyOpenSSL>=0.15.1\",\n                    \"pycparser>=2.10\",\n                    \"pycrypto>=2.6.1\",\n                    \"pyrad>=2.0\",\n                    \"pyusb>=1.0.0b2\",\n                    \"qrcode>=5.1\",\n                    \"requests>=2.7.0\",\n                    \"sqlsoup>=0.9.0\",\n                    \"ecdsa>=0.13\",\n                    \"lxml>=3.3\",\n                    \"python-gnupg>=0.3.8\",\n                    \"defusedxml>=0.4.1\",\n                    \"flask-babel>=0.9\",\n                    \"croniter>=0.3.8\"\n                    ]\n\n# For python 2.6 we need additional dependency importlib\ntry:\n    import importlib\nexcept ImportError:\n    install_requires.append('importlib')\n\n\ndef get_man_pages(dir):\n    \"\"\"\n    Get man pages in a directory.\n    :param dir: \n    :return: list of file names\n    \"\"\"\n    files = os.listdir(dir)\n    r_files = []\n    for file in files:\n        if file.endswith(\".1\"):\n            r_files.append(dir + \"/\" + file)\n    return r_files\n\n\ndef get_scripts(dir):\n    \"\"\"\n    Get files that are executable\n    :param dir: \n    :return: list of file names\n    \"\"\"\n    files = os.listdir(dir)\n    r_files = []\n    for file in files:\n        if os.stat(dir + \"/\" + file)[stat.ST_MODE] & stat.S_IEXEC:\n            r_files.append(dir + \"/\" + file)\n    return r_files\n\n\nsetup(\n    name='privacyIDEA',\n    version=VERSION,\n    description='privacyIDEA: identity, multifactor authentication (OTP), '\n                'authorization, audit',\n    author='privacyidea.org',\n    license='AGPLv3',\n    author_email='cornelius@privacyidea.org',\n    url='http://www.privacyidea.org',\n    keywords='OTP, two factor authentication, management, security',\n    packages=find_packages(),\n    scripts=[\"pi-manage\"] + get_scripts(\"tools\"),\n    extras_require={\n        'dev': [\"Sphinx>=1.3.1\",\n                \"sphinxcontrib-httpdomain>=1.3.0\"],\n        'test': [\"coverage>=3.7.1\",\n                 \"mock>=1.0.1\",\n                 \"pyparsing>=2.0.3\",\n                 \"nose>=1.3.4\",\n                 \"responses>=0.4.0\",\n                 \"six>=1.8.0\"],\n    },\n    install_requires=install_requires,\n    include_package_data=True,\n    data_files=[('etc/privacyidea/',\n                 ['deploy/apache/privacyideaapp.wsgi',\n                  'deploy/privacyidea/dictionary',\n                  'deploy/privacyidea/enckey',\n                  'deploy/privacyidea/private.pem',\n                  'deploy/privacyidea/public.pem']),\n                ('share/man/man1', get_man_pages(\"tools\")),\n                ('lib/privacyidea/authmodules/FreeRADIUS',\n                 [\"authmodules/FreeRADIUS/LICENSE\",\n                  \"authmodules/FreeRADIUS/privacyidea_radius.pm\"]),\n               ('lib/privacyidea/authmodules/OTRS',\n                 [\"authmodules/OTRS/privacyIDEA.pm\"]),\n                ('lib/privacyidea/migrations',\n                 [\"migrations/alembic.ini\",\n                  \"migrations/env.py\",\n                  \"migrations/README\",\n                  \"migrations/script.py.mako\"]),\n                ('lib/privacyidea/migrations/versions',\n                 get_file_list(\"migrations/versions/\"))\n                ],\n    classifiers=[\"Framework :: Flask\",\n                 \"License :: OSI Approved :: \"\n                 \"GNU Affero General Public License v3\",\n                 \"Programming Language :: Python\",\n                 \"Development Status :: 5 - Production/Stable\",\n                 \"Topic :: Internet\",\n                 \"Topic :: Security\",\n                 \"Topic :: System ::\"\n                 \" Systems Administration :: Authentication/Directory\"\n                 ],\n    #message_extractors={'privacyidea': [\n    #        ('**.py', 'python', None),\n    #        ('static/**.html', 'html', {'input_encoding': 'utf-8'})]},\n    zip_safe=False,\n    long_description=get_file_contents('README.rst')\n)\n", "# -*- coding: utf-8 -*-\nfrom urllib import urlencode\nimport json\n\nfrom .base import MyTestCase\nfrom privacyidea.lib.user import (User)\nfrom privacyidea.lib.tokens.totptoken import HotpTokenClass\nfrom privacyidea.models import (Token, Challenge)\nfrom privacyidea.lib.config import (set_privacyidea_config, get_token_types,\n                                    get_inc_fail_count_on_false_pin,\n                                    delete_privacyidea_config)\nfrom privacyidea.lib.token import (get_tokens, init_token, remove_token,\n                                   reset_token, enable_token, revoke_token,\n                                   set_pin)\nfrom privacyidea.lib.policy import SCOPE, ACTION, set_policy, delete_policy\nfrom privacyidea.lib.event import set_event\nfrom privacyidea.lib.event import delete_event\nfrom privacyidea.lib.error import ERROR\nfrom privacyidea.lib.resolver import save_resolver, get_resolver_list\nfrom privacyidea.lib.realm import set_realm, set_default_realm\nfrom privacyidea.lib import _\n\nimport smtpmock, ldap3mock, responses\n\n\nPWFILE = \"tests/testdata/passwords\"\nHOSTSFILE = \"tests/testdata/hosts\"\n\nLDAPDirectory = [{\"dn\": \"cn=alice,ou=example,o=test\",\n                 \"attributes\": {'cn': 'alice',\n                                \"sn\": \"Cooper\",\n                                \"givenName\": \"Alice\",\n                                'userPassword': 'alicepw',\n                                'oid': \"2\",\n                                \"homeDirectory\": \"/home/alice\",\n                                \"email\": \"alice@test.com\",\n                                \"accountExpires\": 131024988000000000,\n                                \"objectGUID\": '\\xef6\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rM1',\n                                'mobile': [\"1234\", \"45678\"]}},\n                {\"dn\": 'cn=bob,ou=example,o=test',\n                 \"attributes\": {'cn': 'bob',\n                                \"sn\": \"Marley\",\n                                \"givenName\": \"Robert\",\n                                \"email\": \"bob@example.com\",\n                                \"mobile\": \"123456\",\n                                \"homeDirectory\": \"/home/bob\",\n                                'userPassword': 'bobpw\u00e9\u00e9\u00e9',\n                                \"accountExpires\": 9223372036854775807,\n                                \"objectGUID\": '\\xef6\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rMw',\n                                'oid': \"3\"}},\n                {\"dn\": 'cn=manager,ou=example,o=test',\n                 \"attributes\": {'cn': 'manager',\n                                \"givenName\": \"Corny\",\n                                \"sn\": \"keule\",\n                                \"email\": \"ck@o\",\n                                \"mobile\": \"123354\",\n                                'userPassword': 'ldaptest',\n                                \"accountExpires\": 9223372036854775807,\n                                \"objectGUID\": '\\xef6\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rMT',\n                                'oid': \"1\"}},\n                {\"dn\": 'cn=frank,ou=sales,o=test',\n                 \"attributes\": {'cn': 'frank',\n                                \"givenName\": \"Frank\",\n                                \"sn\": \"Hause\",\n                                \"email\": \"fh@o\",\n                                \"mobile\": \"123354\",\n                                'userPassword': 'ldaptest',\n                                \"accountExpires\": 9223372036854775807,\n                                \"objectGUID\": '\\xef7\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rMT',\n                                'oid': \"5\"}}\n                 ]\n\n\nclass AuthorizationPolicyTestCase(MyTestCase):\n    \"\"\"\n    This tests the catch all resolvers and resolvers which also contain the\n    user.\n    A user may authenticate with the default resolver, but the user may also\n    be contained in other resolver. we check these other resolvers, too.\n\n    Testcase for issue\n    https://github.com/privacyidea/privacyidea/issues/543\n    \"\"\"\n    @ldap3mock.activate\n    def test_00_create_realm(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n        params = {'LDAPURI': 'ldap://localhost',\n                  'LDAPBASE': 'o=test',\n                  'BINDDN': 'cn=manager,ou=example,o=test',\n                  'BINDPW': 'ldaptest',\n                  'LOGINNAMEATTRIBUTE': 'cn',\n                  'LDAPSEARCHFILTER': '(cn=*)',\n                  'USERINFO': '{ \"username\": \"cn\",'\n                                  '\"phone\" : \"telephoneNumber\", '\n                                  '\"mobile\" : \"mobile\"'\n                                  ', \"email\" : \"mail\", '\n                                  '\"surname\" : \"sn\", '\n                                  '\"givenname\" : \"givenName\" }',\n                  'UIDTYPE': 'DN',\n                  \"resolver\": \"catchall\",\n                  \"type\": \"ldapresolver\"}\n\n        r = save_resolver(params)\n        self.assertTrue(r > 0)\n\n        params = {'LDAPURI': 'ldap://localhost',\n                  'LDAPBASE': 'ou=sales,o=test',\n                  'BINDDN': 'cn=manager,ou=example,o=test',\n                  'BINDPW': 'ldaptest',\n                  'LOGINNAMEATTRIBUTE': 'cn',\n                  'LDAPSEARCHFILTER': '(cn=*)',\n                  'USERINFO': '{ \"username\": \"cn\",'\n                              '\"phone\" : \"telephoneNumber\", '\n                              '\"mobile\" : \"mobile\"'\n                              ', \"email\" : \"mail\", '\n                              '\"surname\" : \"sn\", '\n                              '\"givenname\" : \"givenName\" }',\n                  'UIDTYPE': 'DN',\n                  \"resolver\": \"sales\",\n                  \"type\": \"ldapresolver\"}\n\n        r = save_resolver(params)\n        self.assertTrue(r > 0)\n\n        rl = get_resolver_list()\n        self.assertTrue(\"catchall\" in rl)\n        self.assertTrue(\"sales\" in rl)\n\n    @ldap3mock.activate\n    def test_01_resolving_user(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n        # create realm\n        # If the sales resolver comes first, frank is found in sales!\n        r = set_realm(\"ldaprealm\", resolvers=[\"catchall\", \"sales\"],\n                      priority={\"catchall\": 2, \"sales\": 1})\n        set_default_realm(\"ldaprealm\")\n        self.assertEqual(r, ([\"catchall\", \"sales\"], []))\n\n        u = User(\"alice\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"catchall\")\n        u = User(\"frank\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"sales\")\n\n        # Catch all has the lower priority and contains all users\n        # ldap2 only contains sales\n        r = set_realm(\"ldaprealm\", resolvers=[\"catchall\", \"sales\"],\n                      priority={\"catchall\": 1, \"sales\": 2})\n        self.assertEqual(r, ([\"catchall\", \"sales\"], []))\n\n        # Both users are found in the resolver \"catchall\n        u = User(\"alice\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"catchall\")\n        u = User(\"frank\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"catchall\")\n\n    @ldap3mock.activate\n    def test_02_enroll_tokens(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n        r = init_token({\"type\": \"spass\", \"pin\": \"spass\"}, user=User(\n            login=\"alice\", realm=\"ldaprealm\"))\n        self.assertTrue(r)\n        # The token gets assigned to frank in the resolver catchall\n        r = init_token({\"type\": \"spass\", \"pin\": \"spass\"}, user=User(\n            login=\"frank\", realm=\"ldaprealm\"))\n        self.assertTrue(r)\n        self.assertEqual(\"{0!s}\".format(r.user), \"<frank.catchall@ldaprealm>\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"frank\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\"))\n            self.assertTrue(result.get(\"value\"))\n\n    @ldap3mock.activate\n    def test_03_classic_policies(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n\n        # This policy will not match, since frank is in resolver \"catchall\".\n        set_policy(name=\"HOTPonly\",\n                   action=\"tokentype=spass\",\n                   scope=SCOPE.AUTHZ,\n                   resolver=\"sales\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"frank\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\"))\n            self.assertTrue(result.get(\"value\"))\n\n        # If users in resolver sales are required to use HOTP, then frank still\n        # can login with a SPASS token, since he is identified as user in\n        # resolver catchall\n        set_policy(name=\"HOTPonly\",\n                   action=\"tokentype=hotp\",\n                   scope=SCOPE.AUTHZ,\n                   resolver=\"sales\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"frank\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n\n        # Alice - not in sales - is allowed to login\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"alice\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\"))\n            self.assertTrue(result.get(\"value\"))\n\n\nclass DisplayTANTestCase(MyTestCase):\n\n    def test_00_run_complete_workflow(self):\n        # This is a standard workflow of a display TAN token.\n\n        # Import OCRA Token file\n        IMPORTFILE = \"tests/testdata/ocra.csv\"\n        with self.app.test_request_context('/token/load/ocra.csv',\n                                            method=\"POST\",\n                                            data={\"type\": \"oathcsv\",\n                                                  \"file\": (IMPORTFILE,\n                                                           \"oath.csv\")},\n                                            headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            value = result.get(\"value\")\n            self.assertTrue(value == 1, result)\n\n        from privacyidea.lib.token import set_pin\n        set_pin(\"ocra1234\", \"test\")\n\n        # Issue a challenge response\n        challenge = \"83507112  ~320,00~1399458665_G6HNVF\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": \"test\",\n                                                 \"hashchallenge\": 1,\n                                                 \"challenge\": challenge}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            hex_challenge = detail.get(\"attributes\").get(\"challenge\")\n            self.assertEqual(hex_challenge, \"7196501689c356046867728f4feb74458dcfd079\")\n\n        # Issue an authentication request\n        otpvalue = \"90065298\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": otpvalue,\n                                                 \"transaction_id\":\n                                                     transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n\n        # The second request will fail\n        otpvalue = \"90065298\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": otpvalue,\n                                                 \"transcation_id\":\n                                                     transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n\n        # Get another challenge with a random nonce\n        challenge = \"83507112  ~320,00~\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": \"test\",\n                                                 \"hashchallenge\": 1,\n                                                 \"addrandomchallenge\": 20,\n                                                 \"challenge\": challenge}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            hex_challenge = detail.get(\"attributes\").get(\"challenge\")\n            self.assertEqual(len(hex_challenge), 40)\n\n        remove_token(\"ocra1234\")\n\n\nclass AValidateOfflineTestCase(MyTestCase):\n    \"\"\"\n    Test api.validate endpoints that are responsible for offline auth.\n    \"\"\"\n    def test_00_create_realms(self):\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n\n        # create a  token and assign it to the user\n        db_token = Token(self.serials[0], tokentype=\"hotp\")\n        db_token.update_otpkey(self.otpkey)\n        db_token.save()\n        token = HotpTokenClass(db_token)\n        self.assertTrue(token.token.serial == self.serials[0], token)\n        token.set_user(User(\"cornelius\", self.realm1))\n        token.set_pin(\"pin\")\n        self.assertTrue(token.token.user_id == \"1000\", token.token.user_id)\n\n    def test_01_validate_offline(self):\n        pass\n        # create offline app\n        #tokenobj = get_tokens(self.serials[0])[0]\n        from privacyidea.lib.applications.offline import REFILLTOKEN_LENGTH\n        from privacyidea.lib.machine import attach_token, detach_token\n        from privacyidea.lib.machineresolver import save_resolver, delete_resolver\n        mr_obj = save_resolver({\"name\": \"testresolver\",\n                                \"type\": \"hosts\",\n                                \"filename\": HOSTSFILE,\n                                \"type.filename\": \"string\",\n                                \"desc.filename\": \"the filename with the \"\n                                                 \"hosts\",\n                                \"pw\": \"secret\",\n                                \"type.pw\": \"password\"})\n        self.assertTrue(mr_obj > 0)\n        # Attach the offline app to pippin\n        r = attach_token(self.serials[0], \"offline\", hostname=\"pippin\",\n                         resolver_name=\"testresolver\")\n\n        # first online validation\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin287082\"},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            result = data.get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"otplen\"), 6)\n            auth_items = json.loads(res.data).get(\"auth_items\")\n            offline = auth_items.get(\"offline\")[0]\n            # Check the number of OTP values\n            self.assertEqual(len(offline.get(\"response\")), 100)\n            self.assertEqual(offline.get(\"username\"), \"cornelius\")\n            refilltoken_1 = offline.get(\"refilltoken\")\n            self.assertEqual(len(refilltoken_1), 2 * REFILLTOKEN_LENGTH)\n            # check the token counter\n            tok = get_tokens(serial=self.serials[0])[0]\n            self.assertEqual(tok.token.count, 102)\n\n        # first refill with the 5th value\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin338314\",\n                                                 \"refilltoken\": refilltoken_1},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            auth_items = json.loads(res.data).get(\"auth_items\")\n            offline = auth_items.get(\"offline\")[0]\n            # Check the number of OTP values\n            self.assertEqual(len(offline.get(\"response\")), 3)\n            self.assertTrue(\"102\" in offline.get(\"response\"))\n            self.assertTrue(\"103\" in offline.get(\"response\"))\n            self.assertTrue(\"104\" in offline.get(\"response\"))\n            refilltoken_2 = offline.get(\"refilltoken\")\n            self.assertEqual(len(refilltoken_2), 2 * REFILLTOKEN_LENGTH)\n            # check the token counter\n            tok = get_tokens(serial=self.serials[0])[0]\n            self.assertEqual(tok.token.count, 105)\n            # The refilltoken changes each time\n            self.assertNotEqual(refilltoken_1, refilltoken_2)\n\n        # refill with wrong refill token fails\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin520489\",\n                                                 \"refilltoken\": 'a' * 2 * REFILLTOKEN_LENGTH},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            data = json.loads(res.data)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR905: Token is not an offline token or refill token is incorrect\")\n\n        # 2nd refill with 10th value\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin520489\",\n                                                 \"refilltoken\": refilltoken_2},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            auth_items = json.loads(res.data).get(\"auth_items\")\n            offline = auth_items.get(\"offline\")[0]\n            # Check the number of OTP values\n            self.assertEqual(len(offline.get(\"response\")), 5)\n            self.assertTrue(\"105\" in offline.get(\"response\"))\n            self.assertTrue(\"106\" in offline.get(\"response\"))\n            self.assertTrue(\"107\" in offline.get(\"response\"))\n            self.assertTrue(\"108\" in offline.get(\"response\"))\n            self.assertTrue(\"109\" in offline.get(\"response\"))\n            refilltoken_3 = offline.get(\"refilltoken\")\n            self.assertEqual(len(refilltoken_3), 2 * REFILLTOKEN_LENGTH)\n            # check the token counter\n            tok = get_tokens(serial=self.serials[0])[0]\n            self.assertEqual(tok.token.count, 110)\n            # The refilltoken changes each time\n            self.assertNotEqual(refilltoken_2, refilltoken_3)\n            self.assertNotEqual(refilltoken_1, refilltoken_3)\n\n        # A refill with a totally wrong OTP value fails\n        token_obj = get_tokens(serial=self.serials[0])[0]\n        old_counter = token_obj.token.count\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin000000\",\n                                                 \"refilltoken\": refilltoken_3},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            data = json.loads(res.data)\n            self.assertTrue(res.status_code == 400, res)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR401: You provided a wrong OTP value.\")\n        # The failed refill should not modify the token counter!\n        self.assertEqual(old_counter, token_obj.token.count)\n\n        # A refill with a wrong serial number fails\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": 'ABCDEF123',\n                                                 \"pass\": \"pin000000\",\n                                                 \"refilltoken\": refilltoken_3},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            data = json.loads(res.data)\n            self.assertTrue(res.status_code == 400, res)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR905: The token does not exist\")\n\n        # Detach the token, refill should then fail\n        r = detach_token(self.serials[0], \"offline\", \"pippin\")\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin520489\",\n                                                 \"refilltoken\": refilltoken_3},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            data = json.loads(res.data)\n            self.assertTrue(res.status_code == 400, res)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR905: Token is not an offline token or refill token is incorrect\")\n\n\nclass ValidateAPITestCase(MyTestCase):\n    \"\"\"\n    test the api.validate endpoints\n    \"\"\"\n\n    def test_00_create_realms(self):\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n\n        # create a  token and assign it to the user\n        db_token = Token(self.serials[0], tokentype=\"hotp\")\n        db_token.update_otpkey(self.otpkey)\n        db_token.save()\n        token = HotpTokenClass(db_token)\n        self.assertTrue(token.token.serial == self.serials[0], token)\n        token.set_user(User(\"cornelius\", self.realm1))\n        token.set_pin(\"pin\")\n        self.assertTrue(token.token.user_id == \"1000\", token.token.user_id)\n\n    def test_02_validate_check(self):\n        # is the token still assigned?\n        tokenbject_list = get_tokens(serial=self.serials[0])\n        tokenobject = tokenbject_list[0]\n        self.assertTrue(tokenobject.token.user_id == \"1000\",\n                        tokenobject.token.user_id)\n\n        \"\"\"                  Truncated\n           Count    Hexadecimal    Decimal        HOTP\n           0        4c93cf18       1284755224     755224\n           1        41397eea       1094287082     287082\n           2         82fef30        137359152     359152\n           3        66ef7655       1726969429     969429\n           4        61c5938a       1640338314     338314\n           5        33c083d4        868254676     254676\n           6        7256c032       1918287922     287922\n           7         4e5b397         82162583     162583\n           8        2823443f        673399871     399871\n           9        2679dc69        645520489     520489\n        \"\"\"\n        # test for missing parameter user\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        # test for missing parameter serial\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        # test for missing parameter \"pass\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n    def test_03_check_user(self):\n        # get the original counter\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        count_1 = hotp_tokenobject.token.count\n\n        # test successful authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"otplen\"), 6)\n\n        # Check that the counter is increased!\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        count_2 = hotp_tokenobject.token.count\n        self.assertTrue(count_2 > count_1, (hotp_tokenobject.token.serial,\n                                            hotp_tokenobject.token.count,\n                                            count_1,\n                                            count_2))\n\n        # test authentication fails with the same OTP\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n\n    def test_03a_check_user_get(self):\n        # Reset the counter!\n        count_1 = 0\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        hotp_tokenobject.token.count = count_1\n        hotp_tokenobject.token.save()\n\n        # test successful authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='GET',\n                                           query_string=urlencode(\n                                                    {\"user\": \"cornelius\",\n                                                     \"pass\": \"pin287082\"})):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"otplen\"), 6)\n\n        # Check that the counter is increased!\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        count_2 = hotp_tokenobject.token.count\n        self.assertTrue(count_2 > count_1, (hotp_tokenobject.token.serial,\n                                            hotp_tokenobject.token.count,\n                                            count_1,\n                                            count_2))\n\n        # test authentication fails with the same OTP\n        with self.app.test_request_context('/validate/check',\n                                           method='GET',\n                                           query_string=urlencode(\n                                                    {\"user\": \"cornelius\",\n                                                     \"pass\": \"pin287082\"})):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n\n    def test_04_check_serial(self):\n        # test authentication successful with serial\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin969429\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n\n        # test authentication fails with serial with same OTP\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin969429\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            details = json.loads(res.data).get(\"detail\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n            self.assertEqual(details.get(\"message\"), \"wrong otp value. \"\n                                                     \"previous otp used again\")\n\n    def test_05_check_serial_with_no_user(self):\n        # Check a token per serial when the token has no user assigned.\n        init_token({\"serial\": \"nouser\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"pin\"})\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"nouser\",\n                                                 \"pass\": \"pin359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            details = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"status\"), True)\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_05_check_serial_with_no_user(self):\n        # Check a token per serial when the token has no user assigned.\n        init_token({\"serial\": \"nouser\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"pin\"})\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"nouser\",\n                                                 \"pass\": \"pin359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            details = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"status\"), True)\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_05a_check_otp_only(self):\n        # Check the OTP of the token without PIN\n        init_token({\"serial\": \"otponly\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"pin\"})\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"otponly\",\n                                                 \"otponly\": \"1\",\n                                                 \"pass\": \"359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"status\"), True)\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_06_fail_counter(self):\n        # test if a user has several tokens that the fail counter is increased\n        # reset the failcounter\n        reset_token(serial=\"SE1\")\n        init_token({\"serial\": \"s2\",\n                    \"genkey\": 1,\n                    \"pin\": \"test\"}, user=User(\"cornelius\", self.realm1))\n        init_token({\"serial\": \"s3\",\n                    \"genkey\": 1,\n                    \"pin\": \"test\"}, user=User(\"cornelius\", self.realm1))\n        # Now the user cornelius has 3 tokens.\n        # SE1 with pin \"pin\"\n        # token s2 with pin \"test\" and\n        # token s3 with pin \"test\".\n\n        self.assertTrue(get_inc_fail_count_on_false_pin())\n        # We give an OTP PIN that does not match any token.\n        # The failcounter of all tokens will be increased\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"XXXX123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n\n        # Now we give the matching OTP PIN of one token.\n        # Only one failcounter will be increased\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"serial\"), \"SE1\")\n            self.assertEqual(detail.get(\"message\"), \"wrong otp value\")\n\n        # Only the failcounter of SE1 (the PIN matching token) is increased!\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 2)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n\n        set_privacyidea_config(\"IncFailCountOnFalsePin\", False)\n        self.assertFalse(get_inc_fail_count_on_false_pin())\n        reset_token(serial=\"SE1\")\n        reset_token(serial=\"s2\")\n        reset_token(serial=\"s3\")\n        # If we try to authenticate with an OTP PIN that does not match any\n        # token NO failcounter is increased!\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"XXXX123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n\n        # Now we give the matching OTP PIN of one token.\n        # Only one failcounter will be increased\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"serial\"), \"SE1\")\n            self.assertEqual(detail.get(\"message\"), \"wrong otp value\")\n\n        # Only the failcounter of SE1 (the PIN matching token) is increased!\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n\n    def test_07_authentication_counter_exceeded(self):\n        token_obj = init_token({\"serial\": \"pass1\", \"pin\": \"123456\",\n                                \"type\": \"spass\"})\n        token_obj.set_count_auth_max(5)\n\n        for i in range(1, 5):\n            with self.app.test_request_context('/validate/check',\n                                               method='POST',\n                                               data={\"serial\": \"pass1\",\n                                                     \"pass\": \"123456\"}):\n                res = self.app.full_dispatch_request()\n                self.assertTrue(res.status_code == 200, res)\n                result = json.loads(res.data).get(\"result\")\n                self.assertEqual(result.get(\"value\"), True)\n\n        # The 6th authentication will fail\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"pass1\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"value\"), False)\n            self.assertTrue(\"Authentication counter exceeded\"\n                            in detail.get(\"message\"))\n\n    def test_08_failcounter_counter_exceeded(self):\n        token_obj = init_token({\"serial\": \"pass2\", \"pin\": \"123456\",\n                                \"type\": \"spass\"})\n        token_obj.set_maxfail(5)\n        token_obj.set_failcount(5)\n        # a valid authentication will fail\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"pass2\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"value\"), False)\n            self.assertEqual(detail.get(\"message\"), \"matching 1 tokens, \"\n                                                    \"Failcounter exceeded\")\n\n    def test_10_saml_check(self):\n        # test successful authentication\n        set_privacyidea_config(\"ReturnSamlAttributes\", \"0\")\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin338314\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), True)\n            # No SAML return attributes\n            self.assertEqual(attributes.get(\"email\"), None)\n\n        set_privacyidea_config(\"ReturnSamlAttributes\", \"1\")\n\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin254676\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), True)\n            self.assertEqual(attributes.get(\"email\"),\n                             \"user@localhost.localdomain\")\n            self.assertEqual(attributes.get(\"givenname\"), \"Cornelius\")\n            self.assertEqual(attributes.get(\"mobile\"), \"+491111111\")\n            self.assertEqual(attributes.get(\"phone\"),  \"+491234566\")\n            self.assertEqual(attributes.get(\"realm\"),  \"realm1\")\n            self.assertEqual(attributes.get(\"username\"),  \"cornelius\")\n\n        # Return SAML attributes On Fail\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin254676\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), False)\n            self.assertEqual(attributes.get(\"email\"), None)\n            self.assertEqual(attributes.get(\"givenname\"), None)\n            self.assertEqual(attributes.get(\"mobile\"), None)\n            self.assertEqual(attributes.get(\"phone\"), None)\n            self.assertEqual(attributes.get(\"realm\"), None)\n            self.assertEqual(attributes.get(\"username\"), None)\n\n        set_privacyidea_config(\"ReturnSamlAttributesOnFail\", \"1\")\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin254676\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), False)\n            self.assertEqual(attributes.get(\"email\"),\n                             \"user@localhost.localdomain\")\n            self.assertEqual(attributes.get(\"givenname\"), \"Cornelius\")\n            self.assertEqual(attributes.get(\"mobile\"), \"+491111111\")\n            self.assertEqual(attributes.get(\"phone\"), \"+491234566\")\n            self.assertEqual(attributes.get(\"realm\"), \"realm1\")\n            self.assertEqual(attributes.get(\"username\"), \"cornelius\")\n\n    def test_11_challenge_response_hotp(self):\n        # set a chalresp policy for HOTP\n        with self.app.test_request_context('/policy/pol_chal_resp',\n                                           data={'action':\n                                                     \"challenge_response=hotp\",\n                                                 'scope': \"authentication\",\n                                                 'realm': '',\n                                                 'active': True},\n                                           method='POST',\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result[\"status\"] is True, result)\n            self.assertTrue('\"setPolicy pol_chal_resp\": 1' in res.data,\n                            res.data)\n\n        serial = \"CHALRESP1\"\n        pin = \"chalresp1\"\n        # create a token and assign to the user\n        db_token = Token(serial, tokentype=\"hotp\")\n        db_token.update_otpkey(self.otpkey)\n        db_token.save()\n        token = HotpTokenClass(db_token)\n        token.set_user(User(\"cornelius\", self.realm1))\n        token.set_pin(pin)\n        # Set the failcounter\n        token.set_failcount(5)\n        # create the challenge by authenticating with the OTP PIN\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertEqual(detail.get(\"message\"), _(\"please enter otp: \"))\n            transaction_id = detail.get(\"transaction_id\")\n        self.assertEqual(token.get_failcount(), 5)\n\n        # send the OTP value\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": \"359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertTrue(result.get(\"value\"))\n\n        self.assertEqual(token.get_failcount(), 0)\n        # delete the token\n        remove_token(serial=serial)\n\n    def test_12_challenge_response_sms(self):\n        # set a chalresp policy for SMS\n        with self.app.test_request_context('/policy/pol_chal_resp',\n                                           data={'action':\n                                                     \"challenge_response=sms\",\n                                                 'scope': \"authentication\",\n                                                 'realm': '',\n                                                 'active': True},\n                                           method='POST',\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result[\"status\"] is True, result)\n            self.assertTrue('\"setPolicy pol_chal_resp\": 1' in res.data,\n                            res.data)\n\n        serial = \"CHALRESP2\"\n        pin = \"chalresp2\"\n        # create a token and assign to the user\n        init_token({\"serial\": serial,\n                    \"type\": \"sms\",\n                    \"otpkey\": self.otpkey,\n                    \"phone\": \"123456\",\n                    \"pin\": pin}, user=User(\"cornelius\", self.realm1))\n        # create the challenge by authenticating with the OTP PIN\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertTrue(\"The PIN was correct, \"\n                            \"but the SMS could not be sent\" in\n                            detail.get(\"message\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # disable the token. The detail->message should be empty\n        r = enable_token(serial=serial, enable=False)\n        self.assertEqual(r, True)\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertEqual(detail.get(\"message\"),\n                             \"No active challenge response token found\")\n\n        # delete the token\n        remove_token(serial=serial)\n\n    @smtpmock.activate\n    def test_13_challenge_response_email(self):\n        smtpmock.setdata(response={\"hans@dampf.com\": (200, 'OK')})\n        # set a chalresp policy for Email\n        with self.app.test_request_context('/policy/pol_chal_resp',\n                                           data={'action':\n                                                     \"challenge_response=email\",\n                                                 'scope': \"authentication\",\n                                                 'realm': '',\n                                                 'active': True},\n                                           method='POST',\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result[\"status\"] is True, result)\n            self.assertTrue('\"setPolicy pol_chal_resp\": 1' in res.data,\n                            res.data)\n\n        serial = \"CHALRESP3\"\n        pin = \"chalresp3\"\n        # create a token and assign to the user\n        init_token({\"serial\": serial,\n                    \"type\": \"email\",\n                    \"otpkey\": self.otpkey,\n                    \"email\": \"hans@dampf.com\",\n                    \"pin\": pin}, user=User(\"cornelius\", self.realm1))\n        # create the challenge by authenticating with the OTP PIN\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertEqual(detail.get(\"message\"), _(\"Enter the OTP from the Email:\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # send the OTP value\n        # Test with parameter state.\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"state\":\n                                                     transaction_id,\n                                                 \"pass\": \"359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertTrue(result.get(\"value\"))\n\n        # delete the token\n        remove_token(serial=serial)\n\n    def test_14_check_validity_period(self):\n        serial = \"VP001\"\n        password = serial\n        init_token({\"serial\": serial,\n                    \"type\": \"spass\",\n                    \"pin\": password}, user=User(\"cornelius\", self.realm1))\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": password}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n        # Set validity period\n        token_obj = get_tokens(serial=serial)[0]\n        token_obj.set_validity_period_end(\"2015-01-01T10:00+0200\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": password}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"value\"))\n            details = json.loads(res.data).get(\"detail\")\n            self.assertTrue(\"Outside validity period\" in details.get(\"message\"))\n\n        token_obj.set_validity_period_end(\"1999-01-01T10:00+0200\")\n        token_obj.set_validity_period_start(\"1998-01-01T10:00+0200\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": password}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"value\"))\n            details = json.loads(res.data).get(\"detail\")\n            self.assertTrue(\"Outside validity period\" in details.get(\"message\"))\n\n        # delete the token\n        remove_token(serial=\"VP001\")\n\n    def test_15_validate_at_sign(self):\n        serial1 = \"Split001\"\n        serial2 = \"Split002\"\n        init_token({\"serial\": serial1,\n                    \"type\": \"spass\",\n                    \"pin\": serial1}, user=User(\"cornelius\", self.realm1))\n\n        init_token({\"serial\": serial2,\n                    \"type\": \"spass\",\n                    \"pin\": serial2}, user=User(\"cornelius\", self.realm2))\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": serial1}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n        set_privacyidea_config(\"splitAtSign\", \"0\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": serial2}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        set_privacyidea_config(\"splitAtSign\", \"1\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": serial2}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n        # The default behaviour - if the config entry does not exist,\n        # is to split the @Sign\n        delete_privacyidea_config(\"splitAtSign\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": serial2}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n    def test_16_autoresync_hotp(self):\n        serial = \"autosync1\"\n        token = init_token({\"serial\": serial,\n                            \"otpkey\": self.otpkey,\n                            \"pin\": \"async\"}, User(\"cornelius\", self.realm2))\n        set_privacyidea_config(\"AutoResync\", True)\n        token.set_sync_window(10)\n        token.set_count_window(5)\n        # counter = 8, is out of sync\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": \"async399871\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n\n        # counter = 9, will be autosynced.\n        # Authentication is successful\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": \"async520489\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_privacyidea_config(\"AutoResync\")\n\n    def test_17_auth_timelimit_success(self):\n        user = User(\"timelimituser\", realm=self.realm2)\n        pin = \"spass\"\n        # create a token\n        token = init_token({\"type\": \"spass\",\n                            \"pin\": pin}, user=user)\n\n        # set policy for timelimit\n        set_policy(name=\"pol_time1\",\n                   scope=SCOPE.AUTHZ,\n                   action=\"{0!s}=2/20s\".format(ACTION.AUTHMAXSUCCESS))\n\n        for i in [1, 2]:\n            with self.app.test_request_context('/validate/check',\n                                               method='POST',\n                                               data={\"user\": \"timelimituser\",\n                                                     \"realm\": self.realm2,\n                                                     \"pass\": pin}):\n                res = self.app.full_dispatch_request()\n                self.assertTrue(res.status_code == 200, res)\n                result = json.loads(res.data).get(\"result\")\n                self.assertEqual(result.get(\"value\"), True)\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"timelimituser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n\n        delete_policy(\"pol_time1\")\n        remove_token(token.token.serial)\n\n    def test_18_auth_timelimit_fail(self):\n        user = User(\"timelimituser\", realm=self.realm2)\n        pin = \"spass\"\n        # create a token\n        token = init_token({\"type\": \"spass\", \"pin\": pin}, user=user)\n\n        # set policy for timelimit\n        set_policy(name=\"pol_time1\",\n                   scope=SCOPE.AUTHZ,\n                   action=\"{0!s}=2/20s\".format(ACTION.AUTHMAXFAIL))\n\n        for i in [1, 2]:\n            with self.app.test_request_context('/validate/check',\n                                               method='POST',\n                                               data={\"user\": \"timelimituser\",\n                                                     \"realm\": self.realm2,\n                                                     \"pass\": \"wrongpin\"}):\n                res = self.app.full_dispatch_request()\n                self.assertTrue(res.status_code == 200, res)\n                result = json.loads(res.data).get(\"result\")\n                self.assertEqual(result.get(\"value\"), False)\n\n        # Now we do the correct authentication, but\n        # as already two authentications failed, this will fail, too\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"timelimituser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            details = json.loads(res.data).get(\"detail\")\n            self.assertEqual(details.get(\"message\"),\n                             \"Only 2 failed authentications per 0:00:20\")\n\n        delete_policy(\"pol_time1\")\n        remove_token(token.token.serial)\n\n    def test_19_validate_passthru(self):\n        # user passthru, realm: self.realm2, passwd: pthru\n        set_policy(name=\"pthru\", scope=SCOPE.AUTH, action=ACTION.PASSTHRU)\n\n        # Passthru with GET request\n        with self.app.test_request_context(\n                '/validate/check',\n                method='GET',\n                query_string=urlencode({\"user\": \"passthru\",\n                                        \"realm\": self.realm2,\n                                        \"pass\": \"pthru\"})):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # Passthru with POST Request\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"passthru\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"pthru\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # Test if the policies \"reset_all_tokens\" and \"passthru\" work out fine at the same time\n        set_policy(name=\"reset_all_tokens\", scope=SCOPE.AUTH, action=ACTION.RESETALLTOKENS)\n        # Passthru with POST Request\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"passthru\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"pthru\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_policy(\"reset_all_tokens\")\n        delete_policy(\"pthru\")\n\n    def test_20_questionnaire(self):\n        pin = \"pin\"\n        serial = \"QUST1234\"\n        questions = {\"frage1\": \"antwort1\",\n                     \"frage2\": \"antwort2\",\n                     \"frage3\": \"antwort3\"}\n        j_questions = json.dumps(questions)\n\n        with self.app.test_request_context('/token/init',\n                                           method='POST',\n                                           data={\"type\": \"question\",\n                                                 \"pin\": pin,\n                                                 \"serial\": serial,\n                                                 \"questions\": j_questions},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        set_privacyidea_config(\"question.num_answers\", 2)\n        with self.app.test_request_context('/token/init',\n                                           method='POST',\n                                           data={\"type\": \"question\",\n                                                 \"pin\": pin,\n                                                 \"serial\": serial,\n                                                 \"questions\": j_questions},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            value = result.get(\"value\")\n            self.assertEqual(value, True)\n\n        # Start a challenge\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": serial,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"value\"))\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            question = detail.get(\"message\")\n            self.assertTrue(question in questions)\n\n        # Respond to the challenge\n        answer = questions[question]\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": serial,\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": answer}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_21_validate_disabled(self):\n        # test a user with two tokens and otppin=userstore.\n        # One token is disabled. But the user must be able to login with the\n        # 2nd token\n        # user disableduser, realm: self.realm2, passwd: superSecret\n        set_policy(name=\"disabled\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0!s}={1!s}\".format(ACTION.OTPPIN, \"userstore\"))\n        # enroll two tokens\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass1d\"},\n                       user=User(\"disableduser\", self.realm2))\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass2d\"},\n                       user=User(\"disableduser\", self.realm2))\n        # disable first token\n        r = enable_token(\"spass1d\", False)\n        self.assertEqual(r, True)\n        # Check that the user still can authenticate with the 2nd token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"disableduser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"superSecret\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # disable 2nd token\n        r = enable_token(\"spass2d\", False)\n        r = enable_token(\"spass1d\")\n        self.assertEqual(r, True)\n        # Check that the user still can authenticate with the first token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"disableduser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"superSecret\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_policy(\"disabled\")\n\n    def test_22_validate_locked(self):\n        # test a user with two tokens\n        # One token is locked/revoked.\n        #  But the user must be able to login with the 2nd token\n        # user lockeduser, realm: self.realm2\n        # enroll two tokens\n        user = \"lockeduser\"\n        set_policy(name=\"locked\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0!s}={1!s}\".format(ACTION.OTPPIN, \"tokenpin\"))\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass1l\",\n                        \"pin\": \"locked\"},\n                       user=User(user, self.realm2))\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass2l\",\n                        \"pin\": \"locked\"},\n                       user=User(user, self.realm2))\n        # disable first token\n        r = revoke_token(\"spass1l\")\n        self.assertEqual(r, True)\n        # Check that the user still can authenticate with the 2nd token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"locked\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        remove_token(\"spass1l\")\n        remove_token(\"spass2l\")\n        delete_policy(\"locked\")\n\n    def test_23_pass_no_user_and_pass_no_token(self):\n        # Test with pass_no_user AND with pass_no_token.\n        user = \"passthru\"\n        user_no_token = \"usernotoken\"\n        pin = \"mypin\"\n        serial = \"t23\"\n        set_policy(name=\"pass_no\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0!s},{1!s}\".format(ACTION.PASSNOTOKEN,\n                                               ACTION.PASSNOUSER))\n\n        r = init_token({\"type\": \"spass\", \"serial\": serial,\n                        \"pin\": pin}, user=User(user, self.realm2))\n        self.assertTrue(r)\n\n        r = get_tokens(user=User(user, self.realm2), count=True)\n        self.assertEqual(r, 1)\n        # User can authenticate with his SPASS token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"serial\"), serial)\n\n        # User that does not exist, can authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"doesNotExist\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u\"user does not exist, accepted \"\n                             u\"due to 'pass_no'\")\n\n        # Creating a notification event. The non-existing user must\n        # still be able to pass!\n        eid = set_event(\"notify\", event=[\"validate_check\"], action=\"sendmail\",\n                  handlermodule=\"UserNotification\", conditions={\"token_locked\": True})\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"doesNotExist\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u\"user does not exist, accepted \"\n                             u\"due to 'pass_no'\")\n\n        delete_event(eid)\n\n        r = get_tokens(user=User(user, self.realm2), count=True)\n        self.assertEqual(r, 1)\n        # User with no token can authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user_no_token,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u\"user has no token, \"\n                             u\"accepted due to 'pass_no'\")\n\n        r = get_tokens(user=User(user, self.realm2), count=True)\n        self.assertEqual(r, 1)\n\n        # user with wrong password fails to authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"wrongPiN\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             \"wrong otp pin\")\n\n        delete_policy(\"pass_no\")\n        remove_token(serial)\n\n        # User that does not exist, can NOT authenticate after removing the\n        # policy\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"doesNotExist\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail, None)\n\n    def test_23a_pass_no_user_resolver(self):\n        # Now we set a policy, that a non existing user will authenticate\n        set_policy(name=\"pol1\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0}, {1}, {2}, {3}=none\".format(\n                       ACTION.RESETALLTOKENS,\n                       ACTION.PASSNOUSER,\n                       ACTION.PASSNOTOKEN,\n                       ACTION.OTPPIN\n                   ),\n                   realm=self.realm1)\n        # Check that the non existing user MisterX is allowed to authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"MisterX\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": \"secret\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u'user does not exist, accepted due to \\'pol1\\'')\n        delete_policy(\"pol1\")\n\n    @responses.activate\n    def test_24_trigger_challenge(self):\n        from privacyidea.lib.smsprovider.SMSProvider import set_smsgateway\n        from privacyidea.lib.config import set_privacyidea_config\n        post_url = \"http://smsgateway.com/sms_send_api.cgi\"\n        success_body = \"ID 12345\"\n\n        identifier = \"myGW\"\n        provider_module = \"privacyidea.lib.smsprovider.HttpSMSProvider\" \\\n                          \".HttpSMSProvider\"\n        id = set_smsgateway(identifier, provider_module, description=\"test\",\n                            options={\"HTTP_METHOD\": \"POST\",\n                                     \"URL\": post_url,\n                                     \"RETURN_SUCCESS\": \"ID\",\n                                     \"text\": \"{otp}\",\n                                     \"phone\": \"{phone}\"})\n        self.assertTrue(id > 0)\n        # set config sms.identifier = myGW\n        r = set_privacyidea_config(\"sms.identifier\", identifier)\n        self.assertEqual(r, \"insert\")\n\n        responses.add(responses.POST,\n                      post_url,\n                      body=success_body)\n\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n        serial = \"sms01\"\n        pin = \"pin\"\n        user = \"passthru\"\n        r = init_token({\"type\": \"sms\", \"serial\": serial,\n                        \"otpkey\": self.otpkey,\n                        \"phone\": \"123456\",\n                        \"pin\": pin}, user=User(user, self.realm2))\n        self.assertTrue(r)\n\n        # Trigger challenge for serial number\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"serial\": serial},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), 1)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"messages\")[0],\n                             _(\"Enter the OTP from the SMS:\"))\n            transaction_id = detail.get(\"transaction_ids\")[0]\n\n        # Check authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": \"287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # Trigger challenge for user\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2},\n                                           headers={\n                                               'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), 1)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"messages\")[0],\n                             _(\"Enter the OTP from the SMS:\"))\n            transaction_id = detail.get(\"transaction_ids\")[0]\n\n        # Check authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": \"969429\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        remove_token(serial)\n\n    @smtpmock.activate\n    def test_25_trigger_challenge_smtp(self):\n        smtpmock.setdata(response={\"hans@dampf.com\": (200, 'OK')})\n        from privacyidea.lib.tokens.emailtoken import EMAILACTION\n\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n        serial = \"smtp01\"\n        pin = \"pin\"\n        user = \"passthru\"\n        r = init_token({\"type\": \"email\", \"serial\": serial,\n                        \"otpkey\": self.otpkey,\n                        \"email\": \"hans@dampf.com\",\n                        \"pin\": pin}, user=User(user, self.realm2))\n        self.assertTrue(r)\n\n        set_policy(\"emailtext\", scope=SCOPE.AUTH,\n                   action=\"{0!s}=Dein <otp>\".format(EMAILACTION.EMAILTEXT))\n        set_policy(\"emailsubject\", scope=SCOPE.AUTH,\n                   action=\"{0!s}=Dein OTP\".format(EMAILACTION.EMAILSUBJECT))\n\n        # Trigger challenge for serial number\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"serial\": serial},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), 1)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"messages\")[0],\n                             _(\"Enter the OTP from the Email:\"))\n            transaction_id = detail.get(\"transaction_ids\")[0]\n            # check the sent message\n            sent_message = smtpmock.get_sent_message()\n            self.assertTrue(\"RGVpbiAyODcwODI=\" in sent_message)\n            self.assertTrue(\"Subject: Dein OTP\" in sent_message)\n\n        remove_token(serial)\n        delete_policy(\"emailtext\")\n\n    def test_26_multiple_challenge_response(self):\n        # Test the challenges for multiple active tokens\n        self.setUp_user_realms()\n        OTPKE2 = \"31323334353637383930313233343536373839AA\"\n        user = User(\"multichal\", self.realm1)\n        pin = \"test49\"\n        token_a = init_token({\"serial\": \"CR2A\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": OTPKE2,\n                              \"pin\": pin}, user)\n        token_b = init_token({\"serial\": \"CR2B\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pin}, user)\n        set_policy(\"test49\", scope=SCOPE.AUTH, action=\"{0!s}=HOTP\".format(\n            ACTION.CHALLENGERESPONSE))\n        # both tokens will be a valid challenge response token!\n\n        transaction_id = None\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            multi_challenge = detail.get(\"multi_challenge\")\n            self.assertEqual(multi_challenge[0].get(\"serial\"), \"CR2A\")\n            self.assertEqual(transaction_id,\n                             multi_challenge[0].get(\"transaction_id\"))\n            self.assertEqual(transaction_id,\n                             multi_challenge[1].get(\"transaction_id\"))\n            self.assertEqual(multi_challenge[1].get(\"serial\"), \"CR2B\")\n\n        # There are two challenges in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 2)\n\n        # Check the second response to the challenge, the second step in\n        # challenge response:\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": \"287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            serial = detail.get(\"serial\")\n            self.assertEqual(serial, \"CR2B\")\n\n        # No challenges in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 0)\n\n        remove_token(\"CR2A\")\n        remove_token(\"CR2B\")\n        delete_policy(\"test49\")\n\n    def test_27_multiple_challenge_response_different_pin(self):\n        # Test the challenges for multiple active tokens with different PINs\n        # Test issue #649\n        self.setUp_user_realms()\n        OTPKE2 = \"31323334353637383930313233343536373839AA\"\n        user = User(\"multichal\", self.realm1)\n        pinA = \"testA\"\n        pinB = \"testB\"\n        token_a = init_token({\"serial\": \"CR2A\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": OTPKE2,\n                              \"pin\": pinA}, user)\n        token_b = init_token({\"serial\": \"CR2B\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pinB}, user)\n        set_policy(\"test48\", scope=SCOPE.AUTH, action=\"{0!s}=HOTP\".format(\n            ACTION.CHALLENGERESPONSE))\n        # both tokens will be a valid challenge response token!\n\n        transaction_id = None\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": pinB}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            multi_challenge = detail.get(\"multi_challenge\")\n            self.assertEqual(multi_challenge[0].get(\"serial\"), \"CR2B\")\n            self.assertEqual(transaction_id,\n                             multi_challenge[0].get(\"transaction_id\"))\n            self.assertEqual(len(multi_challenge), 1)\n\n        # There is ONE challenge in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 1)\n\n        # Check the second response to the challenge, the second step in\n        # challenge response:\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": \"287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            serial = detail.get(\"serial\")\n            self.assertEqual(serial, \"CR2B\")\n\n        # No challenges in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 0)\n\n        remove_token(\"CR2A\")\n        remove_token(\"CR2B\")\n        delete_policy(\"test49\")\n\n    def test_28_validate_radiuscheck(self):\n        # setup a spass token\n        token_obj = init_token({\"serial\": \"pass3\", \"pin\": \"123456\",\n                                \"type\": \"spass\"})\n\n        # test successful authentication\n        with self.app.test_request_context('/validate/radiuscheck',\n                                           method='POST',\n                                           data={\"serial\": \"pass3\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            # HTTP 204 status code signals a successful authentication\n            self.assertEqual(res.status_code, 204)\n            self.assertEqual(res.data, '')\n\n        # test authentication fails with wrong PIN\n        with self.app.test_request_context('/validate/radiuscheck',\n                                           method='POST',\n                                           data={\"serial\": \"pass3\",\n                                                 \"pass\": \"wrong\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 400)\n            self.assertEqual(res.data, '')\n\n        # test authentication fails with an unknown user\n        # here, we get an ordinary JSON response\n        with self.app.test_request_context('/validate/radiuscheck',\n                                           method='POST',\n                                           data={\"user\": \"unknown\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 400)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"status\"))\n\n    def test_29_several_CR_one_locked(self):\n        # A user has several CR tokens. One of the tokens is locked.\n        self.setUp_user_realms()\n        user = User(\"multichal\", self.realm1)\n        pin = \"test\"\n        token_a = init_token({\"serial\": \"CR2A\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pin}, user)\n        token_b = init_token({\"serial\": \"CR2B\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pin}, user)\n        set_policy(\"test48\", scope=SCOPE.AUTH, action=\"{0!s}=HOTP\".format(\n            ACTION.CHALLENGERESPONSE))\n        # both tokens will be a valid challenge response token!\n\n        # One token is locked\n        revoke_token(\"CR2B\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            # This is a challene, the value is False\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            serial = detail.get(\"serial\")\n            self.assertEqual(serial, \"CR2A\")\n            # Only one challenge, the 2nd token was revoked.\n            self.assertEqual(len(detail.get(\"multi_challenge\")), 1)\n\n        delete_policy(\"test48\")\n        remove_token(\"CR2A\")\n        remove_token(\"CR2B\")\n\n    def test_30_return_different_tokentypes(self):\n        \"\"\"\n        Return different tokentypes\n\n        If there are more than one matching tokens, the check_token_list in lib/token.py\n        returns a tokentype:\n        1. a specific tokentype if all matching tokens are of the same type\n        2. an \"undetermined\" tokentype, if the matching tokens are of\n           different type.\n        \"\"\"\n        self.setUp_user_realms()\n        user = User(\"cornelius\", self.realm1)\n\n        # two different token types\n        init_token({\"serial\": \"SPASS1\",\n                    \"type\": \"spass\",\n                    \"pin\": \"hallo123\"}, user)\n        init_token({\"serial\": \"PW1\",\n                    \"type\": \"pw\",\n                    \"otpkey\": \"123\",\n                    \"pin\": \"hallo\"}, user)\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"type\"), \"undetermined\")\n\n        # two same token types.\n        remove_token(\"PW1\")\n        init_token({\"serial\": \"SPASS2\",\n                    \"type\": \"spass\",\n                    \"pin\": \"hallo123\"}, user)\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"type\"), \"spass\")\n\n        # A user has one HOTP token and two spass tokens.\n        init_token({\"serial\": \"HOTP1\",\n                    \"type\": \"hotp\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"hallo\"}, user)\n        # Without policy he can authenticate with the spass token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"type\"), \"spass\")\n\n        # policy only allows HOTP.\n        set_policy(\"onlyHOTP\", scope=SCOPE.AUTHZ,\n                   action=\"{0!s}=hotp\".format(ACTION.TOKENTYPE))\n\n        # He can not authenticate with the spass token!\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 403)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"status\"), False)\n            self.assertEqual(result.get(\"error\").get(\"code\"), ERROR.POLICY)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail, None)\n\n        # Define a passthru policy\n        set_policy(\"passthru\", scope=SCOPE.AUTH,\n                   action=\"{0!s}=userstore\".format(ACTION.PASSTHRU))\n\n        # A user with a passthru policy can authenticate, since he has not tokentype\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"passthru\",\n                                                 \"pass\": \"pthru\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_policy(\"onlyHOTP\")\n        delete_policy(\"onlyHOTP\")\n        delete_policy(\"passthru\")\n        remove_token(\"SPASS1\")\n        remove_token(\"SPASS2\")\n        remove_token(\"HOTP1\")\n\n    @responses.activate\n    @smtpmock.activate\n    def test_30_challenge_text(self):\n        \"\"\"\n        Set a policy for a different challengetext and run a C/R for sms and email.\n        :return:\n        \"\"\"\n        smtpmock.setdata(response={\"hallo@example.com\": (200, 'OK')})\n\n        # Configure the SMS Gateway\n        from privacyidea.lib.smsprovider.SMSProvider import set_smsgateway\n        from privacyidea.lib.config import set_privacyidea_config\n        post_url = \"http://smsgateway.com/sms_send_api.cgi\"\n        success_body = \"ID 12345\"\n\n        identifier = \"myGW\"\n        provider_module = \"privacyidea.lib.smsprovider.HttpSMSProvider\" \\\n                          \".HttpSMSProvider\"\n        id = set_smsgateway(identifier, provider_module, description=\"test\",\n                            options={\"HTTP_METHOD\": \"POST\",\n                                     \"URL\": post_url,\n                                     \"RETURN_SUCCESS\": \"ID\",\n                                     \"text\": \"{otp}\",\n                                     \"phone\": \"{phone}\"})\n        self.assertTrue(id > 0)\n        # set config sms.identifier = myGW\n        r = set_privacyidea_config(\"sms.identifier\", identifier)\n        self.assertTrue(r in [\"insert\", \"update\"])\n        responses.add(responses.POST,\n                      post_url,\n                      body=success_body)\n\n\n\n        self.setUp_user_realms()\n        user = User(\"cornelius\", self.realm1)\n\n        # two different token types\n        init_token({\"serial\": \"CHAL1\",\n                    \"type\": \"sms\",\n                    \"phone\": \"123456\",\n                    \"pin\": \"sms\"}, user)\n        init_token({\"serial\": \"CHAL2\",\n                    \"type\": \"email\",\n                    \"email\": \"hallo@example.com\",\n                    \"pin\": \"email\"}, user)\n\n        set_policy(\"chalsms\", SCOPE.AUTH, \"sms_{0!s}=check your sms\".format(ACTION.CHALLENGETEXT))\n        set_policy(\"chalemail\", SCOPE.AUTH, \"email_{0!s}=check your email\".format(ACTION.CHALLENGETEXT))\n\n        # Challenge Response with email\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"email\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            resp = json.loads(res.data)\n            self.assertEqual(resp.get(\"detail\").get(\"message\"), \"check your email\")\n\n        # Challenge Response with SMS\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"sms\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            resp = json.loads(res.data)\n            self.assertEqual(resp.get(\"detail\").get(\"message\"), \"check your sms\")\n\n        # Two different token types that are triggered by the same PIN:\n        init_token({\"serial\": \"CHAL3\",\n                    \"type\": \"sms\",\n                    \"phone\": \"123456\",\n                    \"pin\": \"PIN\"}, user)\n        init_token({\"serial\": \"CHAL4\",\n                    \"type\": \"email\",\n                    \"email\": \"hallo@example.com\",\n                    \"pin\": \"PIN\"}, user)\n\n        # Challenge Response with SMS and Email. The challenge message contains both hints\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"PIN\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            resp = json.loads(res.data)\n            self.assertEqual(resp.get(\"detail\").get(\"message\"), \"check your sms, check your email\")\n\n        delete_policy(\"chalsms\")\n        delete_policy(\"chalemail\")\n        remove_token(\"CHAL1\")\n        remove_token(\"CHAL2\")\n        remove_token(\"CHAL3\")\n        remove_token(\"CHAL4\")\n\n\nclass AChallengeResponse(MyTestCase):\n\n    serial = \"hotp1\"\n    serial_email = \"email1\"\n\n    def setUp(self):\n        MyTestCase.setUp(self)\n        self.setUp_user_realms()\n\n    def test_01_challenge_response_token_deactivate(self):\n        # New token for the user \"selfservice\"\n        Token(\"hotp1\", \"hotp\", otpkey=self.otpkey, userid=1004, resolver=self.resolvername1,\n              realm=self.realm1).save()\n        # Define HOTP token to be challenge response\n        set_policy(name=\"pol_cr\", scope=SCOPE.AUTH, action=\"{0!s}=hotp\".format(ACTION.CHALLENGERESPONSE))\n        set_pin(self.serial, \"pin\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertTrue(\"enter otp\" in detail.get(\"message\"), detail.get(\"message\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # Now we try to provide the OTP value\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": self.valid_otp_values[0],\n                                                 \"transaction_id\": transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"value\"))\n\n        # Now we send the challenge and then we disable the token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertTrue(\"enter otp\" in detail.get(\"message\"), detail.get(\"message\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # disable the token\n        enable_token(self.serial, False)\n\n        # Now we try to provide the OTP value, but authentication must fail, since the token is disabled\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": self.valid_otp_values[1],\n                                                 \"transaction_id\": transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertEqual(detail.get(\"message\"), \"Challenge matches, but token is inactive.\")\n\n        # The token is still disabled. We are checking, if we can do a challenge response\n        # for a disabled token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertTrue(\"No active challenge response\" in detail.get(\"message\"), detail.get(\"message\"))\n\n    @smtpmock.activate\n    def test_02_two_challenge_response_tokens(self):\n        smtpmock.setdata(response={\"bla@example.com\": (200, 'OK')})\n        # We test two challenge response tokens. One is active, one is disabled.\n        # Enroll an Email-Token to the user\n        init_token(user=User(\"selfservice\", self.realm1),\n                   param={\"serial\": self.serial_email,\n                          \"type\": \"email\",\n                          \"email\": \"bla@example.com\",\n                          \"otpkey\": self.otpkey})\n        set_pin(self.serial_email, \"pin\")\n\n        toks = get_tokens(user=User(\"selfservice\", self.realm1))\n        self.assertEqual(len(toks), 2)\n        self.assertFalse(toks[0].token.active)\n        self.assertTrue(toks[1].token.active)\n\n        # Now we create a challenge with two tokens\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            # Only the email token is active and creates a challenge!\n            self.assertEqual(u\"Enter the OTP from the Email:\", detail.get(\"message\"))\n\n        # Now test with triggerchallenge\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\"},\n                                           headers={\"Authorization\": self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            # Triggerchallenge returns the numbers of tokens in the \"value\n            self.assertEqual(data.get(\"result\").get(\"value\"), 1)\n            detail = data.get(\"detail\")\n            # Only the email token is active and creates a challenge!\n            self.assertEqual(u\"Enter the OTP from the Email:\", detail.get(\"messages\")[0])"], "fixing_code": ["Version 2.23.2, 2018-09-07\n\n  Fixes:\n  * Fix problem with empty username (#1227)\n\nVersion 2.23.1, 2018-09-06\n\n  Fixes:\n  * Fix PassOnNoUser in combination with event handler (#1206)\n  * Fix loading of Event handler detail view (#1210)\n  * Fix Challenge-Response login at Web UI (#1216)\n  * Fix triggerchallenge to only use active tokens (#1217)\n  * Write all installed package to diagnostics file and\n    also write the resolver config in privacyidea-diag\n\nVersion 2.23, 2018-08-29\n\n  Features:\n  * Add periodic tasks including a privacyidea-cron script. (#992) \n  * Add task module \"Simple Stats\" to generate time series of certain \n    important statistics values in privacyIDEA (#1105)\n  * Add task module \"Event Counter\" that allows to create time series of \n    any arbitrary event. (#1029)\n  * New token type: TAN list, that can also import a prefefined\n    list of TANs (#1057)\n  * Add Event Handler Pre-Handling, that e.g. allows for\n    even more easy token enrollment concepts (#747)\n\n  Enhancements:\n  * Improve performance by adding SQL pooling for SQL Audit \n    and SQL Resolvers. (#1167, #1140)\n  * Improve SQL Resolver to also verify bcrypt-hash passwords (#1172)\n  * Allow multiple WHERE conditions in SQL Resolver (#1039)\n  * Allow objectGUID as loginname in LDAP resolver for better \n    ownCloud support (#1076)\n  * Add command in pi-manage to dump audit log information (#1120)\n  * Add script to allow generation of AES keys on HSM (#1159)\n  * Improve recovery mechanism from a lost HSM connection (#1069)\n  * Improve Debug Logging to hide passwords in SQL connect strings (#1162)\n  * Add script for easy privacyIDEA standalone setup (#1093)\n  * ldap3, pyasn1, croniter updated in Ubuntu Launchpad repo (#1085)\n  * Add a script that easily gathers support and diagnostic information (#829)\n  * Add event handler management to pi-manage (#1119)\n  * Allow to customize the challenge text for challenge response tokens (#1096)\n  * Add user information to OATH CSV token import file (#998)\n  * Improve migration scripts from LinOTP to also update counter values (#1075)\n  * Add priority to policies to avoid contradicting policies (#1031)\n  * The token event handler now can delete tokeninfo (#988)\n  * Make the import of OATH CSV token specific, so that each \n    tokentype can define its own import strategy (#1066)\n  * The Event Counter module now allows to decrease the counter (#991)\n  * Allow time deltas to also contain seconds (#1033)\n\n  Fixes:\n  * Allow to use unicode passwords with non-ascii characters for the\n    connect string in SQL Resolvers (#1181)\n  * Fix problem that a wrong password hash was used, if user is created\n    in SQL Resolver (#1114)\n  * Fix performance issue with slow token listing (#1123)\n  * Fix the QR code regeneration if the user already has the maximum number\n    of allowed tokens (#1153)\n  * Fix problem with privacyidea-pip-update in case of pip version 10 (#1128)\n  * Fix problem if max_token_per_user was higher than 9 (#1117)\n  * Fix hash algorithm in QR Code (#1088)\n  * Set focus in username field in the login dialog (#205)\n  * Fix disappearing scrollbar issue (#1020)\n  * Fix import of SHA256 tokens (#1061)\n  * Convert string values to unicode in the database model to \n    avoid misleading \"error\" messages (#1000)\n  * Fix truncation of audit log in case of authentication failure (#1034)\n  * Shorten audit information to fit into the database column (#1037)\n  * Fix the RADIUS configuration test (#1042)\n\n\nVersion 2.22.1, 2018-04-20\n\n  Fixes in WebUI:\n  * Allow to display the messages of several C/R tokens (#995, #1004)\n  * Use ng-if instead of ng-show to avoid errors in the javascript console (#963)\n  * Remove reference to not-used system.addons.js to avoid errors in the javascript console\n  * Remove reference to not-used system.addons.html to avoid errors in the javascript console\n  * Use ng-src instead of src to avoid errors in the javascript console\n  * Avoid request to /false is image is not existing - avoid error in the javascript console\n  * Fix handling of U2F token in the WebUI login\n  * Require serial number in the assignment form (#1011)\n  * Fix PIN comparison in token enroll and token assign (#1010)\n  * Fix the empty username in token enroll or assign (#918)\n\n  Fixes in Server:\n  * Add check for serial number present (#1011)\n  * Fix validation of OCRA and TiQR token (#1008)\n  * Add retry to cope with HSM issues (#1003)\n  * Fix unicode in resolverconf database table with Oracle (#999)\n\n\nVersion 2.22, 2018-03-27\n\n  Features:\n  * Add automatic offline refill for Offline OTP tokens (#839)\n  * Return realm and resolver of the user and allow mapping\n    group membership to the RADIUS protocol (#896)\n  * Add new tokenkind (hardware, software, virtual) for all tokens (#828)\n  * Support Vasco tokens via Import and via Web Enrollment (#904, #903, #891)\n  * Add arbitrary tokeninfo field to authorization policy (#873)\n  * New SMPP SMS provider (#878)\n  * New event handler Counter for counting events for statistics and monitoring (#951)\n\n  Enhancements:\n  * Enhance the statistics possibilities in WebUI (#950)\n  * Allow reencryption of the database by importing PSKC to\n    a new database (#940)\n  * Allow token janitor to export \"PW\" token type to PSKC (#942)\n  * Also export and import the counter values of HOTP/TOTP to PSKC (#943)\n  * SMS token can dynamically read phone number from user source (#932)\n  * Email token can dynamically read email address from user source (#932)\n  * Add policy to ignore the validity of a U2F attestation certificate (#926)\n  * Improve the speed of the LinOTP migration script to cope with tens of\n    thousands of tokens (#914)\n  * pi-manage can create API tokens with a chosen validity time (#931)\n  * Allow user to set token description for HOTP and TOTP tokens \n    during enrollment (#928) (Thanks to Taylor Chase for this contribution!)\n  * Add timeout to SMTP server configuration (#919)\n  * Allow complex email templates for email tokens (#684)\n  * LDAP resolver now supports arbitrary multivalue attributes (#881)\n  * Allow Event Handler to match failing authentication (#971)\n\n  Fixes:\n  * Several fixes in LDAP resolver to cope with ldap3/pyasn1 version issues and\n    other issues (#911, #980, #982, #887)\n  * Skip misguiding LDAP error \"AttributeError NonType\" in log file (#948)\n  * Add missing validity time in /validate/check response for email tokens (#946)\n    (Thanks to Kleber Rocha/klinux for this contribution!)\n  * Fix the handling of the SMS expiration date (#937)\n  * Fix serial length in the audit table to match the serial length in the token table (#929)\n    (Thanks to Salvo Rapisarda for this contribution!)\n  * Fix Mail content sent by email token is rendered as attachment (#915)\n  * Fix Editing SMTP Server definition clears the password (#923)\n  * Fix pi-manage backup crash (Thanks to Pavol Ipoth for this contribution!)\n\n\nVersion 2.21.4, 2018-01-24\n\n  Fixes:\n  * HTTP Timeout of HTTP SMS Gateway (#889)\n  * Remove console.log from webui\n\n\nVersion 2.21.1, 2018-01-09\n\n  Fixes:\n  * Allow to use TLS1.1 and TLS1.2 for LDAP Resolver (#876)\n\nVersion 2.21, 2017-12-20\n\n  Features:\n\n   * Allow export of tokens to PKSC file (#790)\n   * Implement two-step enrollment of HOTP/TOTP tokens (#797, #863, #865, #866)\n   * Allow WebUI customization via policies (#795)\n\n  Enhancements:\n\n   * Add script to decrypt safeword tokens\n   * Allow using tags in the tokenissuer of smartphone tokens\n   * Try to re-establish lost HSM connections (#787)\n   * Allow to rotate audit log based on multiple conditions (#780, #833)\n   * Add dry-run option to audit log rotation (#801)\n   * Allow dots in realm names (#808)\n   * Mark empty but required fields in WebUI (#810)\n   * Display success information after PIN is set (#822)\n   * Add further tags to the user notification event handler (#824)\n   * Add number of users to the subscription view (#800)\n   * Add HTTP/HTTPS proxy settings to HTTP SMS Provider (#835)\n   * Federation Handler allows to forward the authorization token (#838)\n   * Use token janitor to export a user list (#852)\n   * Use HSM for random key generation if possible (#783)\n   * HTTP SMS Provider now takes TIMEOUT parameter into account\n   * Allow to configure length of generated serial numbers (#583)\n\n  Fixes:\n\n   * Fix handling of only_realm option in token event handler (#809)\n   * Fix scrollbar issues in WebUI (#806, #823)\n   * Fix OTP counter of offline token (#840)\n   * Fix conflicts between check_tokentype and passthru policies (#846)\n   * Properly reset tab tile after session has been locked (#850)\n   * Fix handling of fixed key size during enrollment (#820)\n   * Make sure that only active policies are honored (#825)\n   * Fix various bugs with non-ASCII data (#754)\n   * Fix failcounter_clear_timeout (#831)\n   * Only remove apache host definitions on first installation (#834)\n\nVersion 2.20.1, 2017-10-30\n\n  Fixes:\n   * /token/init allows to pass otpkey AND genkey=false (#793)\n   * Cast date to string, to fix audit search for postgresql (#786)\n   * Optimize the LDAP Resolver Redundancy to avoid LdapServerPoolExhaustedErrors (#802)\n   * Preset default realm in token enrollment (#804)\n   * Fix PassOnNoUser and PassOnNoToken (#798)\n   * Fix genkey=0 error during token enrollment (#793)\n\nVersion 2.20, 2017-09-27\n\n  Features:\n\n   * New Token-Type OCRA and DisplayTAN to support \n     transaction signing for online banking (#767)\n   * Federation Handler allows to forward authentication\n     requests and other REST API requests to a child\n     privacyIDEA system (#711)\n   * Improved Subscription Handling \n   * Allow to login with multiple loginnames (#713)\n   * Authentication Cache policy (#729)\n\n  Enhancements:\n\n   * !!!NOTE!!! following policies now also honor the resolvers,\n    which they did not previously:\n    (AUTH, challenge_response), (AUTH, otppin), \n    (AUTHZ, auth_max_success), (AUTHZ, auth_max_fail),\n    (AUTHZ, last_auth), (WEBUI, login_mode),\n    (ENROLL,losttoken_pw_contents), (ENROLL,losttoken_validity),\n    (ENROLL, losttoken_pw_len) (#736)\n   * User can regenerate the QR Code during enrollment\n     of smartphone app (#766)\n   * Administrator can define remote privacyIDEA servers\n     centrally (#711)\n   * Events can now be ordered. This is important for the\n     federation handling (#711)\n   * Specify the hash algorithm that is used to save \n     SQL users passwords (#745)\n   * Add welcome dialog for administrator (#716)\n   * Allow creating oracle DB (#752)\n   * Event Handler can use timestamps and time offsets in\n     conditions (#741)\n   * Use challenge/response token to unlock the screen of \n     the web UI (#702)\n   * Support multiple challenge/response token at the same\n     time (#722)\n   * GPG keys are generated during package installation and\n     show the GPG key in the import dialog (#742)\n   * Failcounter clearing timeout in UI (#719)\n   * Allow to send challenge data (like banking transaction) in\n     email text and SMS text.\n\n  Fixes:\n\n   * Set default loglevel from DEBUG to INFO (#765)\n   * Fixed PIN logging, which could lead to exceptions\n   * Fixed unicode handling in log messages\n   * Make LDAP Resolver work with utf8 (#738)\n   * User can only choose hash algo according to policy (#723)\n   * Add time period 30/60s to rollout URI (#744)\n   * Fix deprecation warning for flask_migrate (#734)\n   * Allow multiple tries for challenge/response (#708)\n   * Fix problem with certificate serial number (#737)\n\n\nVersion 2.19.1, 2017-07-02\n\n  Enhancements:\n\n  * Add \"pi-manage policy load\" and \"pi-manage policy export\". (#721)\n  * Allow customization via pi.cfg file.\n  * Add {username} and {realm} as tags for the tokenhandler. (#735)\n\n Fixes:\n\n  * Fix pi-manage file permission for backup\n  * Fix search for resolver in audit log\n  * Allow to read old legacy time from validity period\n  * Fix wrong enddate with lost_token\n  * Fix typos\n  * Improve documentation for yubikey\n  * Improve documentation for cache decorator\n  * Improve documentation for webui policy\n\n\nVersion 2.19, 2017-05-25\n\n  Features:\n  * Add generic User Cache to speed up authentication (#670, #683)\n  * Support multiple challenge-response tokens with the same PIN (#654)\n  * Restrict U2F registration based on assertion certificte (#648)\n  * Restrict authentication with U2F devices based on assertion \n    certificate (#648)\n  * Add privacyidea-token-janitor script, that can clean orpaned or \n    expired tokens (#692)\n  * Add API for mutual key generation during enrollment for easy \n    Smartphone App development by introducing a generic \n    2-step-rollout process (#627)\n  * Add /validate/radiuscheck which works with rlm_rest and only uses \n    HTTP return codes. (#703)\n\n  Enhancements:\n\n  * Allow to unset token validity period and other tokeninfo\n    fields (#691)\n  * Add a quick-resolver test for LDAP resolvers (#688)\n  * Add additional tokeninfo tags {client_ip}, {ua_browser}, \n    {ua_string} in token handler (#687)\n  * Allow to set decription of U2F tokens during enrollment (#685)\n  * Reduce the number of LDAP requests to increase authentication\n    performance (#664, #655, #650)\n  * Realm administrator is only allowed to see actions on this allowed\n    user realms (#663)\n  * Add audit rotation to pi-manage (#657)\n  * Speed up Audit Log calls by adding a second index (#656)\n  * Allow to either lock und logout the UI after timeout (#653)\n  * Allow string format {user}, {realm}, {serial}, {surname} in \n    tokenlabel policy (#646)\n  * Move to a consistent time format for validity period and all other \n    user specific times also containing the timezone (#644)\n  * Add TLS certificate check to LDAP machine resolver (#638)\n  * Make TLS certificate the default option in LDAP resolvers (#639)\n  * Allow to use privacyIDEA ownCloud App without subscription\n    file with up to 50 users.\n\n  Fixes:\n  * Fix the datepicker for the token validity period (#644 / #693)\n  * Fix LDAP resolver to respect all boolean configuration \n    options (#658)\n  * Fix serial number in challenge response validation response (#649)\n\n  Commits added in version 2.19 by:\n  (In the order of appearance)\n  * Cornelius K\u00f6lbel\n  * Quynh Nguyen\n  * Friedrich Weber\n  * Quoc Doan\n  * blinkiz\n  * Bernd Nicklas\n\nVersion 2.18, 2017-03-09\n\n  Features:\n  * Allow to disable the WebUI (#605)\n  * The WebUI will lock the screen after a timeout instead of  \n    logging out the user. This allows to easily continue\n    configuration work. (#621)\n  * Improve the creation and handling of local CAs (#630, #632, #633)\n    Allow certificate template for certificates with different runtime\n    and x509v3 extensions.\n\n  Enhancements\n  Enhancements in Policies:\n  * Allow regular expressions in usernames in policies. (#581)\n  * Improve Policy creation with pi-manage from JSON formatted file.\n  * WebUI: Add action grouping in policies.\n  * WebUI: Add action filter in policy view.\n  * Allow token specific PIN policies: The SPASS token can now\n    have dedicated PIN policies.\n  * Add PIN policies for administrators during enrollment and\n    during assignment.\n  * Add WebUI policy: only search on enter being pressed (#617)\n\n  Enhancements in Event Handlers:\n  * Add token_validity_period condition to event handlers. (#618)\n  * Add additional options in token handler when creating \n    SMS, Email or mOTP tokens.\n  * Allow tokenhandler to set tokeninfo field.\n  * Allow tokenhandler to set syncwindow.\n  * Add event handler condition for count_auth_success and\n    cound_auth_fail\n  * Add event handler condition for last_auth.\n  * Improve Audit Log for Event Handler. Each triggered action \n    will now also create an audit entry. (#609)\n  * Allow the use of {current_time} in tokenevent handler. (#628)\n\n  Enhancements in LDAP Resolver:\n  * Upgrade dependency to ldap3 version >=2.1.1 to improve LDAP \n    performance in regards to redundancy and security\n  * LDAP Resolver: Use get_info in bind requests to avoid querying \n    of subschema. (#585)\n  * LDAP Resolver: Support StartTLS over Port 389.\n  * Simplify LDAP Resolver: Remove username from Attribute Mapping.\n  * Simplefy LDAP Resolver: Remove reverse filter.\n\n  Misc Enhancements:\n  * Automatically add user's mobile number if tokentype is SMS.\n  * Add example configuration for GTX messaging SMS gateway.\n  * Add a script \"privacyidea-get-unused-tokens\" to find\n    unused tokens\n  * WebUI: Add a busy indicator spinner.\n  * Improve the pi-manage script in regards to backup and restore.\n    Let you choose whether to backup encryption key or not.\n    Better handling for individual pathes. (#626, #623)\n\n  Fixes:\n  * LDAP Resolver: Verify SSL Certificate (Security)\n  * LDAP Resolver: Allow special characters in NTLM password\n  * LDAP Resolver: Allow searching for users with German umlaut\n  * Remove the \"unsafe\" notation in the QR-Code link, so that \n    a smartphone may import the key during HOTP/TOTP token enrollment\n    by clicking the link. (#620)\n  * Use defusexml to avoid XML bombs on token import (Security)\n  * Replace eval with ast.literal_evel (Security)\n  * Add missing attributes for U2F tokens in \n    validate/triggerchallenge API\n  * Let /validate/triggerchallenge write to audit log.\n  * Fix mangle policy for users and realms\n  * Avoid logging of password in check_user_pass in debug level \n    (level=10)\n  * Set encrypted PIN on enrollment for certificate tokens (#625)\n  * Remove unused policy action \"motp_webprovision\"\n  * Allow emailtext policy in triggerchallenge API (#642)\n \n\nVersion 2.17, 2016-12-29\n\n  Features\n  * Token Handler. Using the token handler the administrator\n    can defined actions in response to events, to modify tokens\n    like deleting, modifying, initilizing... tokens (#532)\n  * Script Event Handler or Shell Event Handler allows to\n    trigger an external shell script, if some event occurs. (#536)\n  * Add additional endpoint to trigger a challenge response\n    like the sending of an SMS, if the token PIN is not\n    available (#531)\n  * Policy Handling to also check for secondary resolvers of\n    a user. This way a user can authenticate with his primary \n    resolver but policy will also work for secondary resolvers (#543)\n\n  Enhancements\n  * The event handler conditions also determine a serial number\n    even if there is no serial number in the request:\n    If the user from the request only has one token assigned. (#571)\n  * Allow event definitions to be disabled (#537)\n  * Allow event to be addressed by a destinct name (#522)\n  * Improving LDAP performace by addressing different functionality \n    of ldap3 version 1.x and 2.x. (#549)\n  * Improve SQL Audit by adding the SQL Audit table to the schema.\n    Table is not created during HTTP request. (#557)\n  * Limit audit log entry age. Users may only view audit\n    log entries up to a certain age. (#541)\n  * Add checkbox to only display used actions in a policy (#573)\n  * In event handler: Use serial number of a user's token if the \n    user has only one token (#571)\n  * Download a filtered audit log (#539)\n\n  Fixes\n  * Add missing token serial number to audit log if token is\n    deletes (#546)\n  * Fix event handler saving (#551)\n  * HttpSMSProvider accepts status codes 201 and 202 in addition\n    to 200 (#562)\n  * Fix checkbox bug in NOREFERRALS of LDAP resolver (#563)\n  * Add documentation for SMS provider (#566)\n  * Remove 301 redirects from WebUI (#576)\n\n\nVersion 2.16, 2016-11-10\n\n  Featurs\n  * Add HSM support via AES keys (#534)\n  * Improved Event Handler for flexible notification (#511)\n  * Signed subscription files for adding and checking\n    for extra functionality during authentication request (#502)\n\n  Enhancements\n  * Allow additional filter attributes in the Audit Log (#519)\n  * Show or hide realms in the login dialog via policy (#517)\n  * Improve UI if admin is not allowed for certain actions (#516, #512)\n  * Disable OTP PIN during enrollment via policy (#439)\n  * Allow automatic sending of registration code via email (#514)\n\n  Fixes\n  * Allow compatibility with ldap3 >= 2.0.7 (#533 #535)\n  * Fix problem with Notification when no tokenowner is available (#528)\n  * Fix confusion of client HTTP parameters (#529)\n  * Fix enabled flag with certain database types (#527)\n  * Catch error in case of faulty overrideClient definition (#526)\n  * Truncate Audit lines, that are too long for the DB table (#525)\n\n\nVersion 2.15, 2016-10-06\n\n  Features\n  * Client Overview. Display the type of the requesting\n    authenticating clients (#489)\n  * Support for NitroKey OTP mode (admin client)\n\n  Enhancements\n  * Performance enhancements using Caching singletons for\n    Config, Realm, Resolver and Policies\n  * Allow configuration of the registration email text (#494)\n  * Return SAML attributes only in case of successful\n    authentication (#500)\n  * Policy \"reset_all_user_tokens\" allow to reset all\n    failcounters on successful authentication (#471)\n  * Client rewrite mapping also checks for\n    X-Forwarded-For (#395, #495)\n\n  Fixes\n  * Fixing RemoteUser fails to display WebUI (#499)\n  * String comparison in HOSTS resolver (#484)\n\n\nVersion 2.14, 2016-08-17\n\n  Features\n  * Import PGP encrypted seed files\n  * Allow UserNotification for user actions\n  * Allow UserNotification on validate/check events,\n    to notify the user on a failed authentication or\n    a locked token.\n\n  Enhancements\n  * Add thread ID in REST API Response\n  * Performance improvement: Cache LDAP Requests #473\n  * Performance improvement: Optimize resolver iteration #474\n  * Add \"Check OTP only\" in WebUI\n  * Improve \"get serial by OTP\" in WebUI\n  * Add script to get serial by OTP\n\n  Fixes\n  * Restrict GET /user for corresponding admins #460\n\n\nVersion 2.13, 2016-06-30\n\n  Features\n  * Allow central definition of SMS gateways \n    to be used with tokens. #392\n  * User SMS for User Notificaton Event Handler. #435\n  * Add PIN change setting for each token. #429\n  * Force PIN change in web UI. #432\n\n  Enhancements\n  * Performence enhancements\n    * speed up loading of audit log in web UI.\n    * avoid double loadin of tokens and audit entries in web UI. #436\n  * Additional log level (enhanced Debug) to even log passwords in \n    debug mode.\n  * Add new logo. #430\n  * Add quick actions in the token list: reset failcounter, \n    toggle active. #426\n  * REST API returns OTP length on successful authentication. #407\n  * Add intelligent OverrideAuthorizationClient system setting,\n    that allows defined proxies to reset the client IP. #395\n\n  Fixes\n  * Display token count in web UI. #437\n  * Use correct default_tokentype in token enrollment. #427\n  * Fix HOTP resync problems. #412\n  \n\n\nVersion 2.12, 2016-05-24\n\n  Features\n  * Event Handler Framework #360\n  * local CA connector can enroll certificates\n    for users. Users can download PKCS12 file. #383\n  * Add and edit users in LDAP resolvers #372\n  * Hardware Security Module support via PKCS11\n  * Time dependent policies #358\n\n  Enhancements\n  * Policy for web UI enrollment wizard #402\n  * Realm dropdown box at login screen #400\n  * Apply user policy settings #390\n  * Improve QR Code for TOTP token enrollment #384\n  * Add documentation for enrollment wizard #381\n  * Improve pi-manage backup to use pymysql #375\n  * Use X-Forwarded-For HTTP header as client IP #356\n  * Add meta-package privacyidea-mysql #376\n\n  Fixes\n  * Adduser honors resolver setting in policy #403\n  * Add documentation for SPASS token #399\n  * Hide enrollment link (WebUI) is user can not enroll #398\n  * Fix getSerial for TOTP tokens #393\n  * Fix system config checkboxes #378\n  * Allow a realm to be remove from a token #363\n  * Improve the date handling in emails #352\n  * Sending test emails #350\n  * Authentication with active token not possible if\n    the user has a disabled token #339\n\n \nVersion 2.11, 2016-03-29\n\n  Features\n  * RADIUS Servers: Allow central definition of RADIUS servers\n  * RADIUS passthru policy: Authentication requests for users\n    with no tokens can be forwarded to a specified RADIUS server\n\n  Enhancements\n  * Allow objectGUID in LDAP-Resolver of Active Directory\n  * Use paged searches in LDAP. LDAP resolver will find all\n    users in the LDAP directory.\n  * Allow privacyIDEA instance name to be configured for\n    the AUDIT log\n  * Allow special characters in LDAP loginnames and passwords\n  * Add arbitrary attributes to SAML Authentication response\n  * Enhance the handling of YUBICO mode yubikeys with the\n    YUBICO API. The prefix is handled correctly.\n  * Allow in get_tokens to be filtered for tokeninfo.\n  * Add paged search in LDAP resolver. This allows responses\n    with more than 1000 objects.\n\n  Fixes\n  * Fix SMTP authentication\n  * Fix Enrollment Wizard for non-default realm users\n  * Registration process: If an email can not be delivered,\n    the token is deleted, since it can not be used.\n\n\nVersion 2.10, 2016-02-11\n\n  Features\n  * User Registration: A user may register himself and thus create\n    his new user account.\n  * Password Reset: Using a recovery token a user may issue a \n    password reset without bothering the administrator or the \n    help desk.\n  * Enrollment Wizard for easy user token enrollment\n  * SMTP Servers: Define several system wide SMTP settings and use\n    these for \n    * Email token,\n    * SMTP SMS Provider, \n    * registration process,\n    * or password reset.\n\n  Enhancements\n  * Ease the Smartphone App (Google Authenticator) rollout.\n    Hide otplen, hash, timestep in the UI if a policy is defined.\n  * Add import of Aladdin/SafeNet XML file.\n  * Add import of password encrypted PSKC files.\n  * Add import of key encrypted PSKC files.\n\n  Fixes\n  * Support LDAP passwords with special non-ascii characters.\n  * Support LDAP BIND with special non-ascii characters.\n  * Fix problem with encrypted encryption key.\n  * Fix upgrading DB Schema for postgresql+psycopg2.\n  * Fix UI displaying of saved SMS Provider.\n  * Do not start challenge response with a locked/disabled token.\n\nVersion 2.9, 2015-12-21\n\n  Features\n  * New token type: Security questions or questionnaire token.\n  * New token type: Paper token. OTP values printed on a piece of paper.\n  * Yubico Validation API: The yubikey tokens can authenticate via\n    /ttype/yubikey which follows the Yubico Validation Protocol.\n\n  Enhancements\n  * Add Web UI view to display the active challenges.\n  * The issuer for the Google Authenticator app can be configured.\n  * The LDAP machine resolver uses an LDAP server pool.\n  * The LDAP user resolver returns a list of mobile numbers.\n\n  Fixes\n  * The test email for the email token now has a sent date.\n  * Fix problem when using encrypted encryption key.\n  * Fix upper case problem when logging in to web UI\n    with REMOTE_USER.\n  * Fix allow set an empty PIN in the web UI.\n  * Fix import of token file in Web UI.\n\nVersion 2.8, 2015-11-26\n\n  Features\n  * Improve U2F support with trusted facets\n  * Add Challenge Response and U2F support to SAML\n  * Add Web UI theming\n  * Add possibility to use REMOTE_USER for authentication at Web UI\n  * Fuzzy Authentication: restrict time since last authentication\n\n  Enhancements\n  * Allow mangle policy when fetching ssh keys\n  * Add realm support to ownCloud plugin\n  * Support Drupal passwords in SQL resolver\n  * Add validity period to token enrollment\n  * Set default enrollment token type in Web UI\n  * Add scope to LDAP resolver\n\n  Fixes\n  * Fix failcounter reset for challenge response tokens\n  * Fix confusing DB errors (column exist) during installation\n  * Fix email token TLS checkbox saving\n  * Fix TOTP testing in Web UI\n  * Fix SMS config loading in Web UI\n\n\nVersion 2.7, 2015-10-03\n\n  Features\n  * Add support for U2F tokens\n  * Add signature to the API JSON response. Thus\n    the client can verify the response.\n\n  Enhancements\n  * When importing tokens, a realm can be chosen, so that all imported\n    tokens are immediately inserted into this realm.\n  * The user is able to change his password in the WebUI.\n  * The user can assign a token in the WebUI.\n  * Avoid the requiring of a PIN for some tokentypes like SSH\n  * Migrate to pymysql, the pure python mysql implementation\n  * The Audit Log tells if a previous OTP value was used again.\n\n  Fixes\n  * Enable login to WebUI with a loginname containing an @ sign.\n  * Fix the writing of logfile privacyidea.log\n\nVersion 2.6, 2015-09-09\n\n  Features\n  * Add OCRA base TiQR token to authenticate by scanning\n    a QR code.\n  * Add Challenge Response authentication to Web UI\n  * Add 4-Eyes token, to enable two man policy. Two tokens\n    of two users are needed to authenticate.\n  * \"Revoke Token\" lets you perform special action on token types.\n    Tokens can be revoke, meaning they are blocked an can not\n    be unblocked anymore.\n\n  Enhancements\n  * Add HA information in the documentation.\n  * Add OpenVPN documentation.\n  * Add challenge response policy, to define if e.g. HOTP or TOTP are \n    allowed to be used in challenge response mode.\n  * Add hotkeys for easier use of Web Ui.\n  * Remove wrong system wide PassOnNoUser and PassOnNoToken.\n  * Set default language to \"en\" in Web UI.\n\n  Fixes\n  * Fix LDAP bug #179, which allows authentication with\n    wrong password under certain conditions\n  * Small fixes in coverage tests\n  * Fix username in web UI during enrollment\n  * Fix link to privacyIDEA logo in Web UI\n  * Fixed bug, that user was not able to resync his own tokens.\n\n\nVersion 2.5, 2015-07-23\n  Features\n  * Add statistics\n  * Add German translation\n  * Add PinHandler in case of random PIN used\n  * Add automatic documentation of system setup\n  * Add ownCloud plugin\n  \n  Enhancements\n  * Preset Email and SMS of a user when enrolling token\n  * Enable LDAP anonymous bind\n  * Add Hashalgorithms and digits to QR Code\n  * Add support for CentOS 6 and 7\n  \n  Fixes\n  * Fix registration token\n  * Fix mOTP reuse problem\n\nVersion 2.4, 2015-06-24\n\n  * Add User Management\n  * Add Admin Realms to policies, to allow better policies in bigger setups\n  * Add API key, that can be used for accessing /validate/check\n  * Load PSKC Token seed files.\n  * Add more sophisticated logging. Severe errors via Email\n  * WebUI: Registrtion token can be enrolled in WebUI\n  * WebUI: The token seed can be displayed in WebUI after generation\n  * WebUI: Only the token types that are allowed to be enrolled are displayed\n  * WebUI: Login_Mode Policy: Disable access to WebUI for certain users\n  * WebUI: Add reload button in Audit view\n  * SQLResolver: The Where statement is used in all cases\n  * SSH-Token Application: Only fetch keys of the requested user\n  * Apache client can work with several hosts on one machine\n  * Documentation: Tokentypes and Supported Hardware Tokens\n  * Improve RADIUS module\n  * WebUI: Fix download of audit log\n  * Fix missing access right of user to GET /caconnector\n\n\nVersion 2.3, 2015-05-22\n\n  * Add connector to remote Certificate Authority\n  * Add Tokentype \"certificate\" to manage certificates for users\n    Certificates or Certificate Requests can be uploaded.\n    Certificate Requests (Keypair) can be generated in the browser.\n  * Add Tokentype \"registration\" for easier enrollment scenarios.\n  * Add TokenType \"Email\" to send OTP via Email.\n  * Add \"First Steps\" to online documentation\n  * Add handling of validity period of token\n  * Enable download of Audit log as CSV\n  * Add Resolver Priority, to handle a duplicate user in a realm\n  * Add TYPO3 Plugin to enable OTP with TYPO3\n  * Add SCIM Resolver to fetch users from SCIM services\n  * Fix Failcounter issue\n  * Fix NTLM password check\n  * Fix timestep during enrollment\n\nVersion 2.2, 2015-04-09\n\n  * pi-manage.py: create resolvers and realms\n  * pi-manage.py: manage policies\n  * Add LostToken UI\n  * Add Offline Application\n  * Add PAM authentication module with offline support\n  * Add getSerialByOTP. You can determine the Token by providing an OTP value.\n  * Add auth_count_max and auth_success_max for each token.\n  * Add PIN encryption policy\n  * Add API for SAML\n  * Add bash script for ssh key fetching\n  * Make WebUI logout time configurable via webui policy.\n  * Add NTLM authentication to the LDAP resolver.\n\n\nVersion 2.1, 2015-03-10\n\n  * Add Machine-Application framework to support LUKS and SSH\n    to manage SSH keys and provide Yubikeys to boot LUKS\n    encrypted machines. #100, #10\n  * Add Machine Resolvers for hosts and LDAP/AD #96\n  * Migrate more policies like SMS policies. #95\n  * Restructure WebUI code to ease development #97\n  * Fix logout problem of user #92\n  * Fix user list for AD (referrals) #99\n  * Fix max_token_per_user policy #101\n\n\nVersion 2.0, 2015-02-21\n\n  * Migrate privacyIDEA to Flask Web framework\n  * The WebUI was migrated to bootstrap and angularJS\n  * The database model was restructered to allow an easier handling and\n    programming\n  * Use the pi-manage.py tool to migrate old data\n  * provide ubuntu packages for privacyidea base package and\n    privacyidea-apache2 and privacyidea-nginx\n  * provide pi-manage.py tool to manage the installation and create new admins.\n  * policies are restructered. Internally the policies now use decorators to\n    have a minimum code impact. No all policies are migrated, yet.\n  * OCRA token and Email token is not migrated, yet.\n\n\nVersion 1.5.1, 2015-01-12\n\n  * Fix splitting the @-sign to allow users like user@email.com@realm1\n\n\nVersion 1.5, 2014-12-25\n\n  * Fix the postinstall script for not broken repoze.who\n  * adapt the dependency for python webob\n  * add fix for users in policies.\n  * Working on #61\n  * Closing #63, allow upper and lower case DN in LDAP resolver\n  * Fix the empty result audit search problem\n  * Fix the port problem with SQL resolver\n\n\nVersion 1.4, 2014-10-06\n\n  * Add \"wrong password\" message on login screen\n  * Add simplesamlphp module and deb package\n  * Add helper dialog to easily setup first realm\n  * Add QR enrollment of mOTP token (Token2)\n  * Add admin/checkserial policy\n  * Add help on logon screen\n  * Fixed the session timeout bug in the management UI\n\n\nVersion 1.3.2, 2014-09-22\n\n * Add uwsgi and nginx configuration\n * Add nginx package\n * Add meta packages to easily install radius dependencies. (#33)\n * Add package for appliance\n * Add appliance style: privacyidea-setup-tui\n * Add privacyidea-otrs and remove the authmodules from the\n   core package\n * Add first implementation of Token2 token type\n * Change depend in builddepend\n * Add missing SSL certificate\n * Add missing python-dialog dependency\n * Remove pylons download link, that caused timeout problems.\n\nVersion 1.3, 2014-08-18\n\n * add support for Daplug dongle in keyboard mode\n * Allow login with admin@realm, even with RealmBox.  (#26)\n * inactive tokens will not work with the machine-app\n * Added MachineUser database model\n * PEP8 beautify\n * Add about dialog\n * added recommends for mysql and salt\n\nVersion 1.2, 2014-07-15\n\n * added application for machines like LUKS and SSH\n * send SMS via sipgate\n * add RADIUS support\n * SQL audit janitor\n * improved SMS provider UI\n * added possibility to do basic authentication instead of session auth.\n\nVersion 1.1, 2014-06-25\n\n * Added documentation and in-UI-context-help.:q\n * Fixed the token config to be filled with sensible data, so \n   that you do not need to configure ALL token types.\n * Added script to clean up old audit logs.\n\n", "info:\n\t@echo \"make clean        - remove all automatically created files\"\n\t@echo \"make epydoc       - create the API documentation\"\n\t@echo \"make doc-man      - create the documentation as man-page\"\n\t@echo \"make doc-html     - create the documentation as html\"\n\t@echo \"make pypi         - upload package to pypi\"\n\t@echo \"make debianzie    - prepare the debian build environment in DEBUILD\"\n\t@echo \"make builddeb     - build .deb file locally on ubuntu 14.04LTS!\"\n\t@echo \"make centos       - build .rpm file to be used with CentOS 7\"\n\t@echo \"make venvdeb      - build .deb file, that contains the whole setup in a virtualenv.\"\n\t@echo \"make linitian     - run lintian on debian package\"\n\t@echo \"make translate    - translate WebUI\"\n\t@echo \"                    This is to be used with debian Wheezy\"\n\t@echo \"make ppa-dev      - upload to launchpad development repo\"\n\t@echo \"make ppa          - upload to launchpad stable repo\"\n\t\n#VERSION=1.3~dev5\nSHORT_VERSION=2.23.2\n#SHORT_VERSION=2.10~dev7\nVERSION_JESSIE=${SHORT_VERSION}\nVERSION=${SHORT_VERSION}\nLOCAL_SERIES=`lsb_release -a | grep Codename | cut -f2`\nSRCDIRS=deploy authmodules migrations doc tests tools privacyidea \nSRCFILES=setup.py MANIFEST.in Makefile Changelog LICENSE pi-manage requirements.txt\n\nclean:\n\tfind . -name \\*.pyc -exec rm {} \\;\n\trm -fr build/\n\trm -fr dist/\n\trm -fr DEBUILD\n\trm -fr RHBUILD\n\trm -fr cover\n\trm -f .coverage\n\t(cd doc; make clean)\n\nsetversion:\n\tvim Makefile\n\tvim setup.py\n\tvim deploy/debian-ubuntu/changelog\n\tvim deploy/debian-virtualenv/changelog\n\tvim doc/conf.py\n\tvim Changelog\n\t@echo \"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n\t@echo \"Please set a tag like:  git tag 3.17\"\n\ntranslate:\n\tgrunt nggettext_extract\n\t(cd po; msgmerge de.po template.pot > tmp.po; mv tmp.po de.po)\n#\t(cd po; msgmerge it.po template.pot > tmp.po; mv tmp.po it.po)\n\tpoedit po/de.po\n#\tpoedit po/it.po\n\tgrunt nggettext_compile\n\ntranslate-server:\n\t(cd privacyidea; pybabel extract -F babel.cfg -o messages.pot .)\n\t# pybabel init -i messages.pot -d translations -l de\n\t(cd privacyidea; pybabel update -i messages.pot -d translations)\n\t(poedit privacyidea/translations/de/LC_MESSAGES/messages.po)\n\t# create the .mo file\n\t(cd privacyidea; pybabel compile -d translations)\n\npypi:\n\tmake doc-man\n\tpython setup.py sdist upload\n\nepydoc:\n\t#pydoctor --add-package privacyidea --make-html \n\tepydoc --html privacyidea -o API\ndepdoc:\n\t#sfood privacyidea | sfood-graph | dot -Tpng -o graph.png\t\n\tdot -Tpng dependencies.dot -o dependencies.png\n\ndoc-man:\n\t(cd doc; make man)\n\t(cd doc/installation/system/pimanage; make man)\n\ndoc-html:\n\t(cd doc; make html)\n\ncentos:\n\tmake clean\n\tmkdir RHBUILD\n\tmkdir -p RHBUILD/{BUILD,RPMS,SOURCES,SPECS,SRPMS}\n\t# create tarball\n\tmkdir -p RHBUILD/SOURCES/privacyidea-${VERSION}\n\trsync -a --exclude=\".*\" --exclude=\"privacyIDEA.egg-info\" --exclude=\"RHBUILD\" --exclude=\"debian\" --exclude=\"dist\" --exclude=\"build\" \\\n                --exclude=\"tests\" . RHBUILD/SOURCES/privacyidea-${VERSION} || true\n\t# We are using the same config file as in debia an replace it in setup.py\n\tcp deploy/centos/pi.cfg RHBUILD/SOURCES/privacyidea-${VERSION}/deploy/centos/\n\t# pack the modified source\n\t(cd RHBUILD/SOURCES/; tar -zcf privacyidea-${VERSION}.tar.gz privacyidea-${VERSION})\n\trm -fr RHBUILD/SOURCES/privacyidea-${VERSION}\n\t# copy spec file\n\tcp deploy/centos/privacyidea.spec RHBUILD/SPECS\n\t# build it\n\trpmbuild --define \"_topdir $(CURDIR)/RHBUILD\" -ba RHBUILD/SPECS/privacyidea.spec\n\n\ndebianize:\n\tmake clean\n\tmake doc-man\n\tmkdir -p DEBUILD/privacyidea.org/debian\n\tcp -r ${SRCDIRS} ${SRCFILES} DEBUILD/privacyidea.org || true\n\t# remove the requirement for pyOpenSSL otherwise we get a breaking dependency for trusty\n\tgrep -v pyOpenSSL setup.py > DEBUILD/privacyidea.org/setup.py\n\t# We need to touch this, so that our config files \n\t# are written to /etc\n\ttouch DEBUILD/privacyidea.org/PRIVACYIDEA_PACKAGE\n\tcp LICENSE DEBUILD/privacyidea.org/debian/copyright\n\tcp LICENSE DEBUILD/privacyidea.org/debian/python-privacyidea.copyright\n\tcp LICENSE DEBUILD/privacyidea.org/debian/privacyidea-all.copyright\n\tcp authmodules/FreeRADIUS/copyright DEBUILD/privacyidea.org/debian/privacyidea-radius.copyright\n\tcp authmodules/simpleSAMLphp/LICENSE DEBUILD/privacyidea.org/debian/privacyidea-simplesamlphp.copyright\n\t(cd DEBUILD; tar -zcf python-privacyidea_${SHORT_VERSION}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\t(cd DEBUILD; tar -zcf python-privacyidea_${VERSION}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\t(cd DEBUILD; tar -zcf python-privacyidea_${VERSION_JESSIE}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\t(cd DEBUILD; tar -zcf privacyidea-venv_${VERSION}.orig.tar.gz --exclude=privacyidea.org/debian privacyidea.org)\n\nbuilddeb-nosign:\n\tmake debianize\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\tsed -e s/\"trusty) trusty; urgency\"/\"$(LOCAL_SERIES)) $(LOCAL_SERIES); urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -b -i -us -uc)\n\nbuilddeb:\n\tmake debianize\n\t################## Renew the changelog\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\tsed -e s/\"trusty) trusty; urgency\"/\"$(LOCAL_SERIES)) $(LOCAL_SERIES); urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t################# Build\n\t(cd DEBUILD/privacyidea.org; debuild --no-lintian)\n\nvenvdeb:\n\tmake debianize\n\tcp -r deploy/debian-virtualenv/* DEBUILD/privacyidea.org/debian/\n\tsed -e s/\"trusty) trusty; urgency\"/\"$(LOCAL_SERIES)) $(LOCAL_SERIES); urgency\"/g deploy/debian-virtualenv/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; DH_VIRTUALENV_INSTALL_ROOT=/opt/privacyidea dpkg-buildpackage -us -uc)\n\nlintian:\n\t(cd DEBUILD; lintian -i -I --show-overrides python-privacyidea_2.*_amd64.changes)\n\nppa-dev:\n\tmake debianize\n\t# trusty\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\t# xenial\n\tsed -e s/\"trusty) trusty; urgency\"/\"xenial) xenial; urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\t# bionic\n\tsed -e s/\"trusty) trusty; urgency\"/\"bionic) bionic; urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\tdput ppa:privacyidea/privacyidea-dev DEBUILD/python-privacyidea_${VERSION}*_source.changes\n\nppa:\n\tmake debianize\n\t# trusty\n\tcp deploy/debian-ubuntu/changelog DEBUILD/privacyidea.org/debian/\n\tcp -r deploy/debian-ubuntu/* DEBUILD/privacyidea.org/debian/\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\t# xenial\n\tsed -e s/\"trusty) trusty; urgency\"/\"xenial) xenial; urgency\"/g deploy/debian-ubuntu/changelog > DEBUILD/privacyidea.org/debian/changelog\n\t(cd DEBUILD/privacyidea.org; debuild -sa -S)\n\tdput ppa:privacyidea/privacyidea DEBUILD/python-privacyidea_${VERSION}*_source.changes\n", "python-privacyidea (2.23.2-1trusty) trusty; urgency=medium\n\n  Fixes:\n  * Fix problem with empty username (#1227)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Fri, 07 Sep 2018 12:00:00 +0200\n\npython-privacyidea (2.23.1-1trusty) trusty; urgency=medium\n\n  Fixes:\n  * Fix PassOnNoUser in combination with event handler (#1206)\n  * Fix loading of Event handler detail view (#1210)\n  * Fix Challenge-Response login at Web UI (#1216)\n  * Fix triggerchallenge to only use active tokens (#1217)\n  * Write all installed package to diagnostics file and\n    also write the resolver config in privacyidea-diag\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 06 Sep 2018 10:00:00 +0200\n\npython-privacyidea (2.23-1trusty) trusty; urgency=medium\n\n  Features:\n  * Add periodic tasks including a privacyidea-cron script. (#992) \n  * Add task module \"Simple Stats\" to generate time series of certain \n    important statistics values in privacyIDEA (#1105)\n  * Add task module \"Event Counter\" that allows to create time series of \n    any arbitrary event. (#1029)\n  * New token type: TAN list, that can also import a prefefined\n    list of TANs (#1057)\n  * Add Event Handler Pre-Handling, that e.g. allows for\n    even more easy token enrollment concepts (#747)\n\n  Enhancements:\n  * Improve performance by adding SQL pooling for SQL Audit \n    and SQL Resolvers. (#1167, #1140)\n  * Improve SQL Resolver to also verify bcrypt-hash passwords (#1172)\n  * Allow multiple WHERE conditions in SQL Resolver (#1039)\n  * Allow objectGUID as loginname in LDAP resolver for better \n    ownCloud support (#1076)\n  * Add command in pi-manage to dump audit log information (#1120)\n  * Add script to allow generation of AES keys on HSM (#1159)\n  * Improve recovery mechanism from a lost HSM connection (#1069)\n  * Improve Debug Logging to hide passwords in SQL connect strings (#1162)\n  * Add script for easy privacyIDEA standalone setup (#1093)\n  * ldap3, pyasn1, croniter updated in Ubuntu Launchpad repo (#1085)\n  * Add a script that easily gathers support and diagnostic information (#829)\n  * Add event handler management to pi-manage (#1119)\n  * Allow to customize the challenge text for challenge response tokens (#1096)\n  * Add user information to OATH CSV token import file (#998)\n  * Improve migration scripts from LinOTP to also update counter values (#1075)\n  * Add priority to policies to avoid contradicting policies (#1031)\n  * The token event handler now can delete tokeninfo (#988)\n  * Make the import of OATH CSV token specific, so that each \n    tokentype can define its own import strategy (#1066)\n  * The Event Counter module now allows to decrease the counter (#991)\n  * Allow time deltas to also contain seconds (#1033)\n\n  Fixes:\n  * Allow to use unicode passwords with non-ascii characters for the\n    connect string in SQL Resolvers (#1181)\n  * Fix problem that a wrong password hash was used, if user is created\n    in SQL Resolver (#1114)\n  * Fix performance issue with slow token listing (#1123)\n  * Fix the QR code regeneration if the user already has the maximum number\n    of allowed tokens (#1153)\n  * Fix problem with privacyidea-pip-update in case of pip version 10 (#1128)\n  * Fix problem if max_token_per_user was higher than 9 (#1117)\n  * Fix hash algorithm in QR Code (#1088)\n  * Set focus in username field in the login dialog (#205)\n  * Fix disappearing scrollbar issue (#1020)\n  * Fix import of SHA256 tokens (#1061)\n  * Convert string values to unicode in the database model to \n    avoid misleading \"error\" messages (#1000)\n  * Fix truncation of audit log in case of authentication failure (#1034)\n  * Shorten audit information to fit into the database column (#1037)\n  * Fix the RADIUS configuration test (#1042)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 29 Aug 2018 09:00:00 +0200\n\npython-privacyidea (2.23~dev9-trusty) trusty; urgency=medium\n\n  Development release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 28 Aug 2018 07:15:00 +0200\n\npython-privacyidea (2.23~dev8-trusty) trusty; urgency=medium\n\n  Development release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 22 Aug 2018 09:15:00 +0200\n\npython-privacyidea (2.23~dev7-trusty) trusty; urgency=medium\n\n  Development release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 16 Aug 2018 21:50:00 +0200\n\npython-privacyidea (2.23~dev6-trusty) trusty; urgency=medium\n\n  Development release \n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 16 Aug 2018 12:00:00 +0200\n\npython-privacyidea (2.23~dev4-trusty) trusty; urgency=medium\n\n  Development Release to test periodic tasks \n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Mon, 13 Aug 2018 21:30:00 +0200\n\npython-privacyidea (2.23~dev3-trusty) trusty; urgency=medium\n\n  Development Release to test periodic tasks and pre-handling\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 07 Aug 2018 17:00:00 +0200\n\npython-privacyidea (2.23~dev2-trusty) trusty; urgency=medium\n\n  Development Release to test with bionic beaver\n \n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 20 Jun 2018 08:00:00 +0200\n\n\npython-privacyidea (2.23~dev1-trusty) trusty; urgency=medium\n\n  Development Release\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 30 May 2018 12:15:00 +0200\n  \npython-privacyidea (2.22.1-1trusty) trusty; urgency=medium\n\n  Fixes in WebUI:\n  * Allow to display the messages of several C/R tokens (#995, #1004)\n  * Use ng-if instead of ng-show to avoid errors in the javascript console (#963)\n  * Remove reference to not-used system.addons.js to avoid errors in the javascript console\n  * Remove reference to not-used system.addons.html to avoid errors in the javascript console\n  * Use ng-src instead of src to avoid errors in the javascript console\n  * Avoid request to /false is image is not existing - avoid error in the javascript console\n  * Fix handling of U2F token in the WebUI login\n  * Require serial number in the assignment form (#1011)\n  * Fix PIN comparison in token enroll and token assign (#1010)\n  * Fix the empty username in token enroll or assign (#918)\n\n  Fixes in Server:\n  * Add check for serial number present (#1011)\n  * Fix validation of OCRA and TiQR token (#1008)\n  * Add retry to cope with HSM issues (#1003)\n  * Fix unicode in resolverconf database table with Oracle (#999)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Fri, 20 Apr 2018 15:00:00 +0200\n\n\npython-privacyidea (2.22-1trusty) trusty; urgency=low\n\n  Features:\n  * Add automatic offline refill for Offline OTP tokens (#839)\n  * Return realm and resolver of the user and allow mapping\n    group membership to the RADIUS protocol (#896)\n  * Add new tokenkind (hardware, software, virtual) for all tokens (#828)\n  * Support Vasco tokens via Import and via Web Enrollment (#904, #903, #891)\n  * Add arbitrary tokeninfo field to authorization policy (#873)\n  * New SMPP SMS provider (#878)\n  * New event handler Counter for counting events for statistics and monitoring (#951)\n\n  Enhancements:\n  * Enhance the statistics possibilities in WebUI (#950)\n  * Allow reencryption of the database by importing PSKC to\n    a new database (#940)\n  * Allow token janitor to export \"PW\" token type to PSKC (#942)\n  * Also export and import the counter values of HOTP/TOTP to PSKC (#943)\n  * SMS token can dynamically read phone number from user source (#932)\n  * Email token can dynamically read email address from user source (#932)\n  * Add policy to ignore the validity of a U2F attestation certificate (#926)\n  * Improve the speed of the LinOTP migration script to cope with tens of\n    thousands of tokens (#914)\n  * pi-manage can create API tokens with a chosen validity time (#931)\n  * Allow user to set token description for HOTP and TOTP tokens \n    during enrollment (#928) (Thanks to Taylor Chase for this contribution!)\n  * Add timeout to SMTP server configuration (#919)\n  * Allow complex email templates for email tokens (#684)\n  * LDAP resolver now supports arbitrary multivalue attributes (#881)\n  * Allow Event Handler to match failing authentication (#971)\n\n  Fixes:\n  * Several fixes in LDAP resolver to cope with ldap3/pyasn1 version issues and\n    other issues (#911, #980, #982, #887)\n  * Skip misguiding LDAP error \"AttributeError NonType\" in log file (#948)\n  * Add missing validity time in /validate/check response for email tokens (#946)\n    (Thanks to Kleber Rocha/klinux for this contribution!)\n  * Fix the handling of the SMS expiration date (#937)\n  * Fix serial length in the audit table to match the serial length in the token table (#929)\n    (Thanks to Salvo Rapisarda for this contribution!)\n  * Fix Mail content sent by email token is rendered as attachment (#915)\n  * Fix Editing SMTP Server definition clears the password (#923)\n  * Fix pi-manage backup crash (Thanks to Pavol Ipoth for this contribution!)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 26 Mar 2018 09:30:00 +0200\n\npython-privacyidea (2.21.4-1trusty) trusty; urgency=low\n\n  Fixes:\n  * HTTP Timeout of HTTP SMS Gateway\n  * Remove console.log from webui\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 24 Jan 2018 16:30:00 +0200\n\n\npython-privacyidea (2.21-1trusty) trusty; urgency=low\n\n  Features:\n   * Allow export of tokens to PKSC file (#790)\n   * Implement two-step enrollment of HOTP/TOTP tokens (#797, #863, #865, #866)\n   * Allow WebUI customization via policies (#795)\n\n  Enhancements:\n   * Add script to decrypt safeword tokens\n   * Allow using tags in the tokenissuer of smartphone tokens\n   * Try to re-establish lost HSM connections (#787)\n   * Allow to rotate audit log based on multiple conditions (#780, #833)\n   * Add dry-run option to audit log rotation (#801)\n   * Allow dots in realm names (#808)\n   * Mark empty but required fields in WebUI (#810)\n   * Display success information after PIN is set (#822)\n   * Add further tags to the user notification event handler (#824)\n   * Add number of users to the subscription view (#800)\n   * Add HTTP/HTTPS proxy settings to HTTP SMS Provider (#835)\n   * Federation Handler allows to forward the authorization token (#838)\n   * Use token janitor to export a user list (#852)\n   * Use HSM for random key generation if possible (#783)\n   * HTTP SMS Provider now takes TIMEOUT parameter into account\n   * Allow to configure length of generated serial numbers (#583)\n\n  Fixes:\n   * Fix handling of only_realm option in token event handler (#809)\n   * Fix scrollbar issues in WebUI (#806, #823)\n   * Fix OTP counter of offline token (#840)\n   * Fix conflicts between check_tokentype and passthru policies (#846)\n   * Properly reset tab tile after session has been locked (#850)\n   * Fix handling of fixed key size during enrollment (#820)\n   * Make sure that only active policies are honored (#825)\n   * Fix various bugs with non-ASCII data (#754)\n   * Fix failcounter_clear_timeout (#831)\n   * Only remove apache host definitions on first installation (#834)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 20 Dec 2017 00:30:00 +0200\n\npython-privacyidea (2.20.1-1trusty) trusty; urgency=low\n\n  Fixes:\n   * /token/init allows to pass otpkey AND genkey=false (#793)\n   * Cast date to string, to fix audit search for postgresql (#786)\n   * Optimize the LDAP Resolver Redundancy to avoid LdapServerPoolExhaustedErrors (#802)\n   * Preset default realm in token enrollment (#804)\n   * Fix PassOnNoUser and PassOnNoToken (#798)\n   * Fix genkey=0 error during token enrollment (#793)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Mon, 30 Oct 2017 11:30:00 +0200\n\npython-privacyidea (2.20-1trusty) trusty; urgency=low\n\n  Features:\n   * New Token-Type OCRA and DisplayTAN to support \n     transaction signing for online banking (#767)\n   * Federation Handler allows to forward authentication\n     requests and other REST API requests to a child\n     privacyIDEA system (#711)\n   * Improved Subscription Handling \n   * Allow to login with multiple loginnames (#713)\n   * Authentication Cache policy (#729)\n\n  Enhancements:\n   * !!!NOTE!!! following policies now also honor the resolvers,\n    which they did not previously:\n    (AUTH, challenge_response), (AUTH, otppin), \n    (AUTHZ, auth_max_success), (AUTHZ, auth_max_fail),\n    (AUTHZ, last_auth), (WEBUI, login_mode),\n    (ENROLL,losttoken_pw_contents), (ENROLL,losttoken_validity),\n    (ENROLL, losttoken_pw_len) (#736)\n   * User can regenerate the QR Code during enrollment\n     of smartphone app (#766)\n   * Administrator can define remote privacyIDEA servers\n     centrally (#711)\n   * Events can now be ordered. This is important for the\n     federation handling (#711)\n   * Specify the hash algorithm that is used to save \n     SQL users passwords (#745)\n   * Add welcome dialog for administrator (#716)\n   * Allow creating oracle DB (#752)\n   * Event Handler can use timestamps and time offsets in\n     conditions (#741)\n   * Use challenge/response token to unlock the screen of \n     the web UI (#702)\n   * Support multiple challenge/response token at the same\n     time (#722)\n   * GPG keys are generated during package installation and\n     show the GPG key in the import dialog (#742)\n   * Failcounter clearing timeout in UI (#719)\n   * Allow to send challenge data (like banking transaction) in\n     email text and SMS text.\n\n  Fixes:\n   * Set default loglevel from DEBUG to INFO (#765)\n   * Fixed PIN logging, which could lead to exceptions\n   * Fixed unicode handling in log messages\n   * Make LDAP Resolver work with utf8 (#738)\n   * User can only choose hash algo according to policy (#723)\n   * Add time period 30/60s to rollout URI (#744)\n   * Fix deprecation warning for flask_migrate (#734)\n   * Allow multiple tries for challenge/response (#708)\n   * Fix problem with certificate serial number (#737)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 27 Sep 2017 11:30:00 +0200\n\npython-privacyidea (2.19.1-1trusty) trusty; urgency=low\n\n  Enhancements:\n  * Add \"pi-manage policy load\" and \"pi-manage policy export\". (#721)\n  * Allow customization via pi.cfg file.\n  * Add {username} and {realm} as tags for the tokenhandler. (#735)\n\n  Fixes:\n  * Fix pi-manage file permission for backup\n  * Fix search for resolver in audit log\n  * Allow to read old legacy time from validity period\n  * Fix wrong enddate with lost_token\n  * Fix typos\n  * Improve documentation for yubikey\n  * Improve documentation for cache decorator\n  * Improve documentation for webui policy\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sun, 02 Jul 2017 08:00:00 +0200\n\npython-privacyidea (2.19-1trusty) trusty; urgency=low\n\n  Features:\n  * Add generic User Cache to speed up authentication (#670, #683)\n  * Support multiple challenge-response tokens with the same PIN (#654)\n  * Restrict U2F registration based on assertion certificte (#648)\n  * Restrict authentication with U2F devices based on assertion \n    certificate (#648)\n  * Add privacyidea-token-janitor script, that can clean orpaned or \n    expired tokens (#692)\n  * Add API for mutual key generation during enrollment for easy \n    Smartphone App development by introducing a generic \n    2-step-rollout process (#627)\n  * Add /validate/radiuscheck which works with rlm_rest and only uses \n    HTTP return codes. (#703)\n\n  Enhancements:\n  * Allow to unset token validity period and other tokeninfo\n    fields (#691)\n  * Add a quick-resolver test for LDAP resolvers (#688)\n  * Add additional tokeninfo tags {client_ip}, {ua_browser}, \n    {ua_string} in token handler (#687)\n  * Allow to set decription of U2F tokens during enrollment (#685)\n  * Reduce the number of LDAP requests to increase authentication\n    performance (#664, #655, #650)\n  * Realm administrator is only allowed to see actions on this allowed\n    user realms (#663)\n  * Add audit rotation to pi-manage (#657)\n  * Speed up Audit Log calls by adding a second index (#656)\n  * Allow to either lock und logout the UI after timeout (#653)\n  * Allow string format {user}, {realm}, {serial}, {surname} in \n    tokenlabel policy (#646)\n  * Move to a consistent time format for validity period and all other \n    user specific times also containing the timezone (#644)\n  * Add TLS certificate check to LDAP machine resolver (#638)\n  * Make TLS certificate the default option in LDAP resolvers (#639)\n  * Allow to use privacyIDEA ownCloud App without subscription\n    file with up to 50 users.\n\n  Fixes:\n  * Fix the datepicker for the token validity period (#644 / #693)\n  * Fix LDAP resolver to respect all boolean configuration \n    options (#658)\n  * Fix serial number in challenge response validation response (#649)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 26 May 2017 08:30:00 +0200\n\npython-privacyidea (2.19~dev5-1trusty) trusty; urgency=low\n\n  * Allow {givenname} and {surname} in tokenlabel (#646)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 16 May 2017 16:30:00 +0200\n\npython-privacyidea (2.18-1trusty) trusty; urgency=low\n\n  Features:\n  * Allow to disable the WebUI (#605)\n  * The WebUI will lock the screen after a timeout instead of  \n    logging out the user. This allows to easily continue\n    configuration work. (#621)\n  * Improve the creation and handling of local CAs (#630, #632, #633)\n    Allow certificate template for certificates with different runtime\n    and x509v3 extensions.\n\n  Enhancements\n  Enhancements in Policies:\n  * Allow regular expressions in usernames in policies. (#581)\n  * Improve Policy creation with pi-manage from JSON formatted file.\n  * WebUI: Add action grouping in policies.\n  * WebUI: Add action filter in policy view.\n  * Allow token specific PIN policies: The SPASS token can now\n    have dedicated PIN policies.\n  * Add PIN policies for administrators during enrollment and\n    during assignment.\n  * Add WebUI policy: only search on enter being pressed (#617)\n\n  Enhancements in Event Handlers:\n  * Add token_validity_period condition to event handlers. (#618)\n  * Add additional options in token handler when creating \n    SMS, Email or mOTP tokens.\n  * Allow tokenhandler to set tokeninfo field.\n  * Allow tokenhandler to set syncwindow.\n  * Add event handler condition for count_auth_success and\n    cound_auth_fail\n  * Add event handler condition for last_auth.\n  * Improve Audit Log for Event Handler. Each triggered action \n    will now also create an audit entry. (#609)\n  * Allow the use of {current_time} in tokenevent handler. (#628)\n\n  Enhancements in LDAP Resolver:\n  * Upgrade dependency to ldap3 version >=2.1.1 to improve LDAP \n    performance in regards to redundancy and security\n  * LDAP Resolver: Use get_info in bind requests to avoid querying \n    of subschema. (#585)\n  * LDAP Resolver: Support StartTLS over Port 389.\n  * Simplify LDAP Resolver: Remove username from Attribute Mapping.\n  * Simplefy LDAP Resolver: Remove reverse filter.\n\n  Misc Enhancements:\n  * Automatically add user's mobile number if tokentype is SMS.\n  * Add example configuration for GTX messaging SMS gateway.\n  * Add a script \"privacyidea-get-unused-tokens\" to find\n    unused tokens\n  * WebUI: Add a busy indicator spinner.\n  * Improve the pi-manage script in regards to backup and restore.\n    Let you choose whether to backup encryption key or not.\n    Better handling for individual pathes. (#626, #623)\n\n  Fixes:\n  * LDAP Resolver: Verify SSL Certificate (Security)\n  * LDAP Resolver: Allow special characters in NTLM password\n  * LDAP Resolver: Allow searching for users with German umlaut\n  * Remove the \"unsafe\" notation in the QR-Code link, so that \n    a smartphone may import the key during HOTP/TOTP token enrollment\n    by clicking the link. (#620)\n  * Use defusexml to avoid XML bombs on token import (Security)\n  * Replace eval with ast.literal_evel (Security)\n  * Add missing attributes for U2F tokens in \n    validate/triggerchallenge API\n  * Let /validate/triggerchallenge write to audit log.\n  * Fix mangle policy for users and realms\n  * Avoid logging of password in check_user_pass in debug level \n    (level=10)\n  * Set encrypted PIN on enrollment for certificate tokens (#625)\n  * Remove unused policy action \"motp_webprovision\"\n  * Allow emailtext policy in triggerchallenge API (#642)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Mar 2017 12:00:00 +0200\n\npython-privacyidea (2.17-1trusty) trusty; urgency=low\n\n  Features\n  * Token Handler. Using the token handler the administrator\n    can defined actions in response to events, to modify tokens\n    like deleting, modifying, initilizing... tokens (#532)\n  * Script Event Handler or Shell Event Handler allows to\n    trigger an external shell script, if some event occurs. (#536)\n  * Add additional endpoint to trigger a challenge response\n    like the sending of an SMS, if the token PIN is not\n    available (#531)\n  * Policy Handling to also check for secondary resolvers of\n    a user. This way a user can authenticate with his primary \n    resolver but policy will also work for secondary resolvers (#543)\n\n  Enhancements\n  * The event handler conditions also determine a serial number\n    even if there is no serial number in the request:\n    If the user from the request only has one token assigned. (#571)\n  * Allow event definitions to be disabled (#537)\n  * Allow event to be addressed by a destinct name (#522)\n  * Improving LDAP performace by addressing different functionality \n    of ldap3 version 1.x and 2.x. (#549)\n  * Improve SQL Audit by adding the SQL Audit table to the schema.\n    Table is not created during HTTP request. (#557)\n  * Limit audit log entry age. Users may only view audit\n    log entries up to a certain age. (#541)\n  * Add checkbox to only display used actions in a policy (#573)\n  * In event handler: Use serial number of a user's token if the \n    user has only one token (#571)\n  * Download a filtered audit log (#539)\n\n  Fixes\n  * Add missing token serial number to audit log if token is\n    deletes (#546)\n  * Fix event handler saving (#551)\n  * HttpSMSProvider accepts status codes 201 and 202 in addition\n    to 200 (#562)\n  * Fix checkbox bug in NOREFERRALS of LDAP resolver (#563)\n  * Add documentation for SMS provider (#566)\n  * Remove 301 redirects from WebUI (#576)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 29 Dec 2016 16:00:00 +0200\n\npython-privacyidea (2.16-1trusty) trusty; urgency=low\n\n  Featurs\n  * Add HSM support via AES keys (#534)\n  * Improved Event Handler for flexible notification (#511)\n  * Signed subscription files for adding and checking\n    for extra functionality during authentication request (#502)\n\n  Enhancements\n  * Allow additional filter attributes in the Audit Log (#519)\n  * Show or hide realms in the login dialog via policy (#517)\n  * Improve UI if admin is not allowed for certain actions (#516, #512)\n  * Disable OTP PIN during enrollment via policy (#439)\n  * Allow automatic sending of registration code via email (#514)\n\n  Fixes\n  * Allow compatibility with ldap3 >= 2.0.7 (#533 #535)\n  * Fix problem with Notification when no tokenowner is available (#528)\n  * Fix confusion of client HTTP parameters (#529)\n  * Fix enabled flag with certain database types (#527)\n  * Catch error in case of faulty overrideClient definition (#526)\n  * Truncate Audit lines, that are too long for the DB table (#525)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 10 Nov 2016 15:00:00 +0200\n\npython-privacyidea (2.15-1trusty) trusty; urgency=low\n \n  Features\n  * Client Overview. Display the type of the requesting\n    authenticating clients (#489)\n  * Support for NitroKey OTP mode (admin client)\n\n  Enhancements\n  * Builds on Ubuntu 16.04 Xenial\n  * Performance enhancements using Caching singletons for\n    Config, Realm, Resolver and Policies\n  * Allow configuration of the registration email text (#494)\n  * Return SAML attributes only in case of successful\n    authentication (#500)\n  * Policy \"reset_all_user_tokens\" allow to reset all\n    failcounters on successful authentication (#471)\n  * Client rewrite mapping also checks for\n    X-Forwarded-For (#395, #495)\n\n  Fixes\n  * Fixing RemoteUser fails to display WebUI (#499)\n  * String comparison in HOSTS resolver (#484)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 06 Oct 2016 08:30:00 +0200\n\npython-privacyidea (2.14-1trusty) trusty; urgency=low\n\n  Features\n  * Import PGP encrypted seed files\n  * Allow UserNotification for user actions\n  * Allow UserNotification on validate/check events,\n    to notify the user on a failed authentication or\n    a locked token.\n\n  Enhancements\n  * Add thread ID in REST API Response\n  * Performence improvement: Cache LDAP Requests #473\n  * Performance improvement: Optimize resolver iteration #474\n  * Add \"Check OTP only\" in WebUI\n  * Improve \"get serial by OTP\" in WebUI\n  * Add script to get serial by OTP\n\n  Fixes\n  * Restrict GET /user for corresponding admins #460\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 15 Aug 2016 00:03:00 +0200\n\npython-privacyidea (2.13-1trusty) trusty; urgency=low\n\n  Features\n  * Allow central definition of SMS gateways \n    to be used with tokens. #392\n  * User SMS for User Notificaton Event Handler. #435\n  * Add PIN change setting for each token. #429\n  * Force PIN change in web UI. #432\n\n  Enhancements\n  * Performence enhancements\n    * speed up loading of audit log in web UI.\n    * avoid double loadin of tokens and audit entries in web UI. #436\n  * Additional log level (enhanced Debug) to even log passwords in \n    debug mode.\n  * Add new logo. #430\n  * Add quick actions in the token list: reset failcounter, \n    toggle active. #426\n  * REST API returns OTP length on successful authentication. #407\n  * Add intelligent OverrideAuthorizationClient system setting,\n    that allows defined proxies to reset the client IP. #395\n\n  Fixes\n  * Display token count in web UI. #437\n  * Use correct default_tokentype in token enrollment. #427\n  * Fix HOTP resync problems. #412\n  \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 30 Jun 2016 12:00:00 +0200\n\npython-privacyidea (2.12-1trusty) trusty; urgency=low\n\n  Features\n  * Event Handler Framework #360\n  * local CA connector can enroll certificates\n    for users. Users can download PKCS12 file. #383\n  * Add and edit users in LDAP resolvers #372\n  * Time dependent policies #358\n\n  Enhancements\n  * Policy for web UI enrollment wizard #402\n  * Realm dropdown box at login screen #400\n  * Apply user policy settings #390\n  * Improve QR Code for TOTP token enrollment #384\n  * Add documentation for enrollment wizard #381\n  * Improve pi-manage backup to use pymysql #375\n  * Use X-Forwarded-For HTTP header as client IP #356\n  * Add meta-package privacyidea-mysql #376\n\n  Fixes\n  * Adduser honors resolver setting in policy #403\n  * Add documentation for SPASS token #399\n  * Hide enrollment link (WebUI) is user can not enroll #398\n  * Fix getSerial for TOTP tokens #393\n  * Fix system config checkboxes #378\n  * Allow a realm to be remove from a token #363\n  * Improve the date handling in emails #352\n  * Sending test emails #350\n  * Authentication with active token not possible if\n    the user has a disabled token #339\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 24 May 2016 16:00:00 +0200\n\npython-privacyidea (2.11-1trusty) trusty; urgency=low\n\n  Features\n  * RADIUS Servers: Allow central definition of RADIUS servers\n  * RADIUS passthru policy: Authentication requests for users\n    with no tokens can be forwarded to a specified RADIUS server\n\n  Enhancements\n  * Allow objectGUID in LDAP-Resolver of Active Directory\n  * Use paged searches in LDAP. LDAP resolver will find all\n    users in the LDAP directory.\n  * Allow privacyIDEA instance name to be configured for\n    the AUDIT log\n  * Allow special characters in LDAP loginnames and passwords\n  * Add arbitrary attributes to SAML Authentication response\n  * Enhance the handling of YUBICO mode yubikeys with the\n    YUBICO API. The prefix is handled correctly.\n  * Allow in get_tokens to be filtered for tokeninfo.\n  * Add paged search in LDAP resolver. This allows responses\n    with more than 1000 objects.\n\n  Fixes\n  * Fix SMTP authentication\n  * Fix Enrollment Wizard for non-default realm users\n  * Registration process: If an email can not be delivered,\n    the token is deleted, since it can not be used.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 29 Mar 2016 08:30:00 +0200\n\npython-privacyidea (2.10-1trusty) trusty; urgency=low\n\n  Features\n  * User Registration: A user may register himself and thus create\n    his new user account.\n  * Password Reset: Using a recovery token a user may issue a\n    password reset without bothering the administrator or the\n    help desk.\n  * Enrollment Wizard for easy user token enrollment\n  * SMTP Servers: Define several system wide SMTP settings and use\n    these for\n    * Email token,\n    * SMTP SMS Provider, \n    * registration process,\n    * or password reset.\n\n  Enhancements\n  * Ease the Smartphone App (Google Authenticator) rollout.\n    Hide otplen, hash, timestep in the UI if a policy is defined.\n  * Add import of Aladdin/SafeNet XML file.\n  * Add import of password encrypted PSKC files.\n  * Add import of key encrypted PSKC files.\n\n  Fixes\n  * Support LDAP passwords with special non-ascii characters.\n  * Support LDAP BIND with special non-ascii characters.\n  * Fix problem with encrypted encryption key.\n  * Fix upgrading DB Schema for postgresql+psycopg2.\n  * Fix UI displaying of saved SMS Provider.\n  * Do not start challenge response with a locked/disabled token.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 11 Feb 2016 00:01:00 +0200\n\npython-privacyidea (2.9-1trusty) trusty; urgency=low\n\n\n  Features\n  * New token type: Security questions or questionnaire token.\n  * New token type: Paper token. OTP values printed on a piece of paper.\n  * Yubico Validation API: The yubikey tokens can authenticate via\n    /ttype/yubikey which follows the Yubico Validation Protocol.\n\n  Enhancements\n  * Add Web UI view to display the active challenges.\n  * The issuer for the Google Authenticator app can be configured.\n  * The LDAP machine resolver uses an LDAP server pool.\n  * The LDAP user resolver returns a list of mobile numbers.\n\n  Fixes\n  * The test email for the email token now has a sent date.\n  * Fix problem when using encrypted encryption key.\n  * Fix upper case problem when logging in to web UI\n    with REMOTE_USER.\n  * Fix allow set an empty PIN in the web UI.\n  * Fix import of token file in Web UI.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 21 Dec 2015 18:00:00 +0200\n\npython-privacyidea (2.8-1trusty) trusty; urgency=low\n\n  Features\n  * Improve U2F support with trusted facets\n  * Add Challenge Response and U2F support to SAML\n  * Add Web UI theming\n  * Add possibility to use REMOTE_USER for authentication at Web UI\n  * Fuzzy Authentication: restrict time since last authentication\n\n  Enhancements\n  * Allow mangle policy when fetching ssh keys\n  * Add realm support to ownCloud plugin\n  * Support Drupal passwords in SQL resolver\n  * Add validity period to token enrollment\n  * Set default enrollment token type in Web UI\n  * Add scope to LDAP resolver\n\n  Fixes\n  * Fix failcounter reset for challenge response tokens\n  * Fix confusing DB errors (column exist) during installation\n  * Fix email token TLS checkbox saving\n  * Fix TOTP testing in Web UI\n  * Fix SMS config loading in Web UI\n  * start new version\n  * Add Challenge Response support to SAML\n  * Add U2F support to SAML\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 26 Nov 2015 23:30:00 +0200\n\npython-privacyidea (2.7-1trusty) trusty; urgency=low\n\n  Features\n  * Add support for U2F tokens\n  * Add signature to the API JSON response. Thus\n    the client can verify the response.\n\n  Enhancements\n  * When importing tokens, a realm can be chosen, so that all imported\n    tokens are immediately inserted into this realm.\n  * The user is able to change his password in the WebUI.\n  * The user can assign a token in the WebUI.\n  * Avoid the requiring of a PIN for some tokentypes like SSH\n  * Migrate to pymysql, the pure python mysql implementation\n  * The Audit Log tells if a previous OTP value was used again.\n\n  Fixes\n  * Enable login to WebUI with a loginname containing an @ sign.\n  * Fix the writing of logfile privacyidea.log\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 07 Oct 2015 08:00:00 +0200\n\npython-privacyidea (2.6-1trusty) trusty; urgency=low\n\n  Features\n  * Add OCRA base TiQR token to authenticate by scanning\n    a QR code.\n  * Add Challenge Response authentication to Web UI\n  * Add 4-Eyes token, to enable two man policy. Two tokens\n    of two users are needed to authenticate.\n  * \"Revoke Token\" lets you perform special action on token types.\n    Tokens can be revoke, meaning they are blocked an can not\n    be unblocked anymore.\n\n  Enhancements\n  * Add HA information in the documentation.\n  * Add OpenVPN documentation.\n  * Add challenge response policy, to define if e.g. HOTP or TOTP are \n    allowed to be used in challenge response mode.\n  * Add hotkeys for easier use of Web Ui.\n  * Remove wrong system wide PassOnNoUser and PassOnNoToken.\n  * Set default language to \"en\" in Web UI.\n\n  Fixes\n  * Fix LDAP bug #179, which allows authentication with\n    wrong password under certain conditions\n  * Small fixes in coverage tests\n  * Fix username in web UI during enrollment\n  * Fix link to privacyIDEA logo in Web UI\n  * Fixed bug, that user was not able to resync his own tokens.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 09 Sep 2015 09:30:00 +0200\n\n\npython-privacyidea (2.5-1trusty) trusty; urgency=low\n\n  Features\n  * Add statistics\n  * Add German translation\n  * Add PinHandler in case of random PIN used\n  * Add automatic documentation of system setup\n  * Add ownCloud plugin\n  \n  Enhancements\n  * Preset Email and SMS of a user when enrolling token\n  * Enable LDAP anonymous bind\n  * Add Hashalgorithms and digits to QR Code\n  * Add support for CentOS 6 and 7\n  \n  Fixes\n  * Fix registration token\n  * Fix mOTP reuse problem\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 22 Jul 2015 17:00:00 +0200\n\npython-privacyidea (2.4-1trusty) trusty; urgency=low\n\n  * Add User Management\n  * Add Admin Realms to policies, to allow better policies in bigger setups\n  * Add API key, that can be used for accessing /validate/check\n  * Load PSKC Token seed files.\n  * Add more sophisticated logging.\n  * WebUI: Registrtion token can be enrolled in WebUI\n  * WebUI: The token seed can be displayed in WebUI after generation\n  * WebUI: Only the token types that are allowed to be enrolled are displayed\n  * WebUI: Login_Mode Policy: Disable access to WebUI for certain users\n  * WebUI: Add reload button in Audit view\n  * SQLResolver: The Where statement is used in all cases\n  * SSH-Token Application: Only fetch keys of the requested user\n  * Apache client can work with several hosts on one machine\n  * Documentation: Tokentypes and Supported Hardware Tokens\n  * Improve RADIUS module\n  * WebUI: Fix download of audit log\n  * Fix missing access right of user to GET /caconnector\n  * Fix SMS token\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Jun 2015 09:30:00 +0200\n\npython-privacyidea (2.3-1trusty) trusty; urgency=low\n\n  * Add connector to remote Certificate Authority\n  * Add Tokentype \"certificate\" to manage certificates for users\n    Certificates or Certificate Requests can be uploaded.\n    Certificate Requests (Keypair) can be generated in the browser.\n  * Add Tokentype \"registration\" for easier enrollment scenarios.\n  * Add TokenType \"Email\" to send OTP via Email.\n  * Add \"First Steps\" to online documentation\n  * Add handling of validity period of token\n  * Enable download of Audit log as CSV\n  * Add Resolver Priority, to handle a duplicate user in a realm\n  * Add TYPO3 Plugin to enable OTP with TYPO3\n  * Add SCIM Resolver to fetch users from SCIM services\n  * Fix Failcounter issue\n  * Fix NTLM password check\n  * Fix timestep during enrollment\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 22 May 2015 15:30:00 +0200\n\npython-privacyidea (2.2-1trusty) trusty; urgency=low\n\n  * pi-manage: create resolvers and realms\n  * pi-manage: manage policies\n  * Add LostToken UI\n  * Add Offline Application\n  * Add PAM authentication module with offline support\n  * Add getSerialByOTP. You can determine the Token by providing an OTP value.\n  * Add auth_count_max and auth_success_max for each token.\n  * Add PIN encryption policy\n  * Add API for SAML\n  * Add bash script for ssh key fetching\n  * Make WebUI logout time configurable via webui policy.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Apr 2015 12:10:00 +0200\n\npython-privacyidea (2.1-1trusty) trusty; urgency=low\n\n  * Add Machine-Application framework to support LUKS and SSH\n    to manage SSH keys and provide Yubikeys to boot LUKS \n    encrypted machines. #100, #10\n  * Add Machine Resolvers for hosts and LDAP/AD #96\n  * Migrate more policies like SMS policies. #95 \n  * Restructure WebUI code to ease development #97\n  * Fix logout problem of user #92\n  * Fix user list for AD (referrals) #99\n  * Fix max_token_per_user policy #101\n  \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 10 Mar 2015 10:30:00 +0200\n\npython-privacyidea (2.1~dev1) trusty; urgency=low\n\n  * Fix logout problem of user\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 16:00:00 +0200\n\npython-privacyidea (2.0-1) trusty; urgency=low\n\n  * Migrate to flask\n  * change the name of the debian package as the package only\n    contains the python module.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 14:00:00 +0200\n\n\nprivacyidea (1.5.1-1trusty) trusty; urgency=low\n\n  * Fix splitting the @-sign to allow users like user@email.com\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 02 Feb 2015 09:08:00 +0200\n\n\nprivacyidea (1.5-1trusty) trusty; urgency=low\n\n  * Fix the postinstall script for not broken repoze.who\n  * adapt the dependency for python webob\n  * add fix for users in policies.\n  * Working on #61\n  * Closing #63, allow upper and lower case DN in LDAP resolver\n  * Fix the empty result audit search problem\n  * Fix the port problem with SQL resolver\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 25 Dec 2014 16:30:00 +0200\n\nprivacyidea (1.4-1) trusty; urgency=low\n\n  * Add \"wrong password\" message on login screen\n  * Speed up tests\n  * Add help on logon screen.\n  * Add helper dialog to setup first realm\n  * Add simplesamlphp module and deb package\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 16:50:00 +0200\n\nprivacyidea (1.4~dev5-1) trusty; urgency=low\n\n  * Add wrong password message on login screen\n  * Speed up tests\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 09:10:00 +0200\n\nprivacyidea (1.4~dev4-1) trusty; urgency=low\n\n  * Add help on logon screen.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 02 Oct 2014 11:20:00 +0200\n\nprivacyidea (1.4~dev3-1) trusty; urgency=low\n\n  * Add helper dialog to setup first realm\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 30 Sep 2014 11:10:00 +0200\n\nprivacyidea (1.4~dev2-1) trusty; urgency=low\n\n  * Add simplesamlphp module and deb package\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 29 Sep 2014 11:40:00 +0200\n\nprivacyidea (1.4~dev1-1) trusty; urgency=low\n\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Sep 2014 19:10:00 +0200\n\nprivacyidea (1.3.2-1) trusty; urgency=low\n\n  * Add uwsgi and nginx configuration\n  * Add nginx package\n  * Add meta packages to easily install radius dependencies. (#33)\n  * Add package for appliance\n  * Add appliance style: privacyidea-setup-tui\n  * Add privacyidea-otrs and remove the authmodules from the\n    core package\n  * Add first implementation of Token2 token type\n  * Change depend in builddepend\n  * Add missing SSL certificate\n  * Add missing python-dialog dependency\n  * Remove pylons download link, that caused timeout problems.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 22 Sep 2014 10:00:00 +0200\n\nprivacyidea (1.3.1-1) trusty; urgency=low\n\n  * Fixed bug, that avoided to delete MachineTokens with options (#27)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 20 Aug 2014 18:30:00 +0200\n\nprivacyidea (1.3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n  * inactive tokens will not work with the machine-app\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 18 Aug 2014 17:00:00 +0200\n\nprivacyidea (1.3~dev5-1) trusty; urgency=low\n\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 15 Aug 2014 15:37:00 +0200\n\nprivacyidea (1.3~dev4-1) trusty; urgency=low\n\n  * fix minor bugs in selfservice portal\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 13 Aug 2014 17:40:00 +0200\n\nprivacyidea (1.3~dev3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 12 Aug 2014 18:32:00 +0200\n\nprivacyidea (1.3~dev2-1) trusty; urgency=low\n\n  * machine requires IP address\n  * the machine-app listing also returns the information, if the token\n    is active\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 11 Aug 2014 10:40:00 +0200\n\n\nprivacyidea (1.3~dev1-1) trusty; urgency=low\n\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 06 Aug 2014 14:14:00 +0200\n\nprivacyidea (1.3~dev0-2) trusty; urgency=low\n\n  * Fixed the missing run directory (#23)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 31 Jul 2014 09:28:00 +0200\n \nprivacyidea (1.3~dev0-1) trusty; urgency=low\n\n  * Fix resolver error #22\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 30 Jul 2014 16:24:00 +0200\n\nprivacyidea (1.2.2-1) trusty; urgency=low\n\n  * Fixed the sqlsoup dependency\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 23 Jul 2014 17:57:00 +0200\n\n\nprivacyidea (1.2.1-1) trusty; urgency=low\n\n  * machine controller: make the challenge usable also in normal mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 18 Jul 2014 16:51:00 +0200\n\n\nprivacyidea (1.2-1) trusty; urgency=low\n\n  * Added \n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 15 Jul 2014 15:15:55 +0200\n\nprivacyidea (1.2~dev2-1) trusty; urgency=low\n\n  * initial ubuntu release\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 14 Jul 2014 18:56:55 +0200\n", "privacyidea-venv (2.23.2-1) jessie; urgency=medium\n\n  Fixes:\n  * Fix problem with empty username (#1227)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Fri, 07 Sep 2018 12:00:00 +0200\n\nprivacyidea-venv (2.23.1-1) jessie; urgency=medium\n\n  Fixes:\n  * Fix PassOnNoUser in combination with event handler (#1206)\n  * Fix loading of Event handler detail view (#1210)\n  * Fix Challenge-Response login at Web UI (#1216)\n  * Fix triggerchallenge to only use active tokens (#1217)\n  * Write all installed package to diagnostics file and\n    also write the resolver config in privacyidea-diag\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Thu, 06 Sep 2018 10:00:00 +0200\n\nprivacyidea-venv (2.23-1) jessie; urgency=medium\n\n  Features:\n  * Add periodic tasks including a privacyidea-cron script. (#992) \n  * Add task module \"Simple Stats\" to generate time series of certain \n    important statistics values in privacyIDEA (#1105)\n  * Add task module \"Event Counter\" that allows to create time series of \n    any arbitrary event. (#1029)\n  * New token type: TAN list, that can also import a prefefined\n    list of TANs (#1057)\n  * Add Event Handler Pre-Handling, that e.g. allows for\n    even more easy token enrollment concepts (#747)\n\n  Enhancements:\n  * Improve performance by adding SQL pooling for SQL Audit \n    and SQL Resolvers. (#1167, #1140)\n  * Improve SQL Resolver to also verify bcrypt-hash passwords (#1172)\n  * Allow multiple WHERE conditions in SQL Resolver (#1039)\n  * Allow objectGUID as loginname in LDAP resolver for better \n    ownCloud support (#1076)\n  * Add command in pi-manage to dump audit log information (#1120)\n  * Add script to allow generation of AES keys on HSM (#1159)\n  * Improve recovery mechanism from a lost HSM connection (#1069)\n  * Improve Debug Logging to hide passwords in SQL connect strings (#1162)\n  * Add script for easy privacyIDEA standalone setup (#1093)\n  * ldap3, pyasn1, croniter updated in Ubuntu Launchpad repo (#1085)\n  * Add a script that easily gathers support and diagnostic information (#829)\n  * Add event handler management to pi-manage (#1119)\n  * Allow to customize the challenge text for challenge response tokens (#1096)\n  * Add user information to OATH CSV token import file (#998)\n  * Improve migration scripts from LinOTP to also update counter values (#1075)\n  * Add priority to policies to avoid contradicting policies (#1031)\n  * The token event handler now can delete tokeninfo (#988)\n  * Make the import of OATH CSV token specific, so that each \n    tokentype can define its own import strategy (#1066)\n  * The Event Counter module now allows to decrease the counter (#991)\n  * Allow time deltas to also contain seconds (#1033)\n\n  Fixes:\n  * Allow to use unicode passwords with non-ascii characters for the\n    connect string in SQL Resolvers (#1181)\n  * Fix problem that a wrong password hash was used, if user is created\n    in SQL Resolver (#1114)\n  * Fix performance issue with slow token listing (#1123)\n  * Fix the QR code regeneration if the user already has the maximum number\n    of allowed tokens (#1153)\n  * Fix problem with privacyidea-pip-update in case of pip version 10 (#1128)\n  * Fix problem if max_token_per_user was higher than 9 (#1117)\n  * Fix hash algorithm in QR Code (#1088)\n  * Set focus in username field in the login dialog (#205)\n  * Fix disappearing scrollbar issue (#1020)\n  * Fix import of SHA256 tokens (#1061)\n  * Convert string values to unicode in the database model to \n    avoid misleading \"error\" messages (#1000)\n  * Fix truncation of audit log in case of authentication failure (#1034)\n  * Shorten audit information to fit into the database column (#1037)\n  * Fix the RADIUS configuration test (#1042)\n\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 29 Aug 2018 09:00:00 +0200\n\nprivacyidea-venv (2.23~dev9-1) jessie; urgency=medium\n\n  * Development version\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 28 Aug 2018 07:30:00 +0200\n\nprivacyidea-venv (2.23~dev8-1) jessie; urgency=medium\n\n  * Development version\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Wed, 22 Aug 2018 13:00:00 +0200\n\n\nprivacyidea-venv (2.22.1-1) jessie; urgency=medium\n\n  Fixes in WebUI:\n  * Allow to display the messages of several C/R tokens (#995, #1004)\n  * Use ng-if instead of ng-show to avoid errors in the javascript console (#963)\n  * Remove reference to not-used system.addons.js to avoid errors in the javascript console\n  * Remove reference to not-used system.addons.html to avoid errors in the javascript console\n  * Use ng-src instead of src to avoid errors in the javascript console\n  * Avoid request to /false is image is not existing - avoid error in the javascript console\n  * Fix handling of U2F token in the WebUI login\n  * Require serial number in the assignment form (#1011)\n  * Fix PIN comparison in token enroll and token assign (#1010)\n  * Fix the empty username in token enroll or assign (#918)\n\n  Fixes in Server:\n  * Add check for serial number present (#1011)\n  * Fix validation of OCRA and TiQR token (#1008)\n  * Add retry to cope with HSM issues (#1003)\n  * Fix unicode in resolverconf database table with Oracle (#999)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Fri, 20 Apr 2018 15:00:00 +0200\n\nprivacyidea-venv (2.22-1) jessie; urgency=low\n\n  Features:\n  * Add automatic offline refill for Offline OTP tokens (#839)\n  * Return realm and resolver of the user and allow mapping\n    group membership to the RADIUS protocol (#896)\n  * Add new tokenkind (hardware, software, virtual) for all tokens (#828)\n  * Support Vasco tokens via Import and via Web Enrollment (#904, #903, #891)\n  * Add arbitrary tokeninfo field to authorization policy (#873)\n  * New SMPP SMS provider (#878)\n  * New event handler Counter for counting events for statistics and monitoring (#951)\n\n  Enhancements:\n  * Enhance the statistics possibilities in WebUI (#950)\n  * Allow reencryption of the database by importing PSKC to\n    a new database (#940)\n  * Allow token janitor to export \"PW\" token type to PSKC (#942)\n  * Also export and import the counter values of HOTP/TOTP to PSKC (#943)\n  * SMS token can dynamically read phone number from user source (#932)\n  * Email token can dynamically read email address from user source (#932)\n  * Add policy to ignore the validity of a U2F attestation certificate (#926)\n  * Improve the speed of the LinOTP migration script to cope with tens of\n    thousands of tokens (#914)\n  * pi-manage can create API tokens with a chosen validity time (#931)\n  * Allow user to set token description for HOTP and TOTP tokens \n    during enrollment (#928) (Thanks to Taylor Chase for this contribution!)\n  * Add timeout to SMTP server configuration (#919)\n  * Allow complex email templates for email tokens (#684)\n  * LDAP resolver now supports arbitrary multivalue attributes (#881)\n  * Allow Event Handler to match failing authentication (#971)\n\n  Fixes:\n  * Several fixes in LDAP resolver to cope with ldap3/pyasn1 version issues and\n    other issues (#911, #980, #982, #887)\n  * Skip misguiding LDAP error \"AttributeError NonType\" in log file (#948)\n  * Add missing validity time in /validate/check response for email tokens (#946)\n    (Thanks to Kleber Rocha/klinux for this contribution!)\n  * Fix the handling of the SMS expiration date (#937)\n  * Fix serial length in the audit table to match the serial length in the token table (#929)\n    (Thanks to Salvo Rapisarda for this contribution!)\n  * Fix Mail content sent by email token is rendered as attachment (#915)\n  * Fix Editing SMTP Server definition clears the password (#923)\n  * Fix pi-manage backup crash (Thanks to Pavol Ipoth for this contribution!)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 26 Mar 2018 09:30:00 +0200\n\n\nprivacyidea-venv (2.21.1-1) jessie; urgency=low\n\n  Features:\n   * Allow export of tokens to PKSC file (#790)\n   * Implement two-step enrollment of HOTP/TOTP tokens (#797, #863, #865, #866)\n   * Allow WebUI customization via policies (#795)\n\n  Enhancements:\n   * Add script to decrypt safeword tokens\n   * Allow using tags in the tokenissuer of smartphone tokens\n   * Try to re-establish lost HSM connections (#787)\n   * Allow to rotate audit log based on multiple conditions (#780, #833)\n   * Add dry-run option to audit log rotation (#801)\n   * Allow dots in realm names (#808)\n   * Mark empty but required fields in WebUI (#810)\n   * Display success information after PIN is set (#822)\n   * Add further tags to the user notification event handler (#824)\n   * Add number of users to the subscription view (#800)\n   * Add HTTP/HTTPS proxy settings to HTTP SMS Provider (#835)\n   * Federation Handler allows to forward the authorization token (#838)\n   * Use token janitor to export a user list (#852)\n   * Use HSM for random key generation if possible (#783)\n   * HTTP SMS Provider now takes TIMEOUT parameter into account\n   * Allow to configure length of generated serial numbers (#583)\n\n  Fixes:\n   * Fix handling of only_realm option in token event handler (#809)\n   * Fix scrollbar issues in WebUI (#806, #823)\n   * Fix OTP counter of offline token (#840)\n   * Fix conflicts between check_tokentype and passthru policies (#846)\n   * Properly reset tab tile after session has been locked (#850)\n   * Fix handling of fixed key size during enrollment (#820)\n   * Make sure that only active policies are honored (#825)\n   * Fix various bugs with non-ASCII data (#754)\n   * Fix failcounter_clear_timeout (#831)\n   * Only remove apache host definitions on first installation (#834)\n   * Allow to use TLS1.1 and TLS1.2 for LDAP Resolver (#876)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Tue, 09 Jan 2018 12:30:00 +0200\n\nprivacyidea-venv (2.20.1-1) jessie; urgency=low\n\n  Fixes:\n   * /token/init allows to pass otpkey AND genkey=false (#793)\n   * Cast date to string, to fix audit search for postgresql (#786)\n   * Optimize the LDAP Resolver Redundancy to avoid LdapServerPoolExhaustedErrors (#802)\n   * Preset default realm in token enrollment (#804)\n   * Fix PassOnNoUser and PassOnNoToken (#798)\n   * Fix genkey=0 error during token enrollment (#793)\n\n -- Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>  Mon, 30 Oct 2017 11:30:00 +0200\n\n\nprivacyidea-venv (2.19.1-1) jessie; urgency=low\n\n  Enhancements:\n  * Add \"pi-manage policy load\" and \"pi-manage policy export\". (#721)\n  * Allow customization via pi.cfg file.\n  * Add {username} and {realm} as tags for the tokenhandler. (#735)\n\n  Fixes:\n  * Fix pi-manage file permission for backup\n  * Fix search for resolver in audit log\n  * Allow to read old legacy time from validity period\n  * Fix wrong enddate with lost_token\n  * Fix typos\n  * Improve documentation for yubikey\n  * Improve documentation for cache decorator\n  * Improve documentation for webui policy\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sun, 02 Jul 2017 08:00:00 +0200\n\nprivacyidea-venv (2.19-1) wheezy; urgency=low\n\n  Features:\n  * Add generic User Cache to speed up authentication (#670, #683)\n  * Support multiple challenge-response tokens with the same PIN (#654)\n  * Restrict U2F registration based on assertion certificte (#648)\n  * Restrict authentication with U2F devices based on assertion \n    certificate (#648)\n  * Add privacyidea-token-janitor script, that can clean orpaned or \n    expired tokens (#692)\n  * Add API for mutual key generation during enrollment for easy \n    Smartphone App development by introducing a generic \n    2-step-rollout process (#627)\n  * Add /validate/radiuscheck which works with rlm_rest and only uses \n    HTTP return codes. (#703)\n\n  Enhancements:\n  * Allow to unset token validity period and other tokeninfo\n    fields (#691)\n  * Add a quick-resolver test for LDAP resolvers (#688)\n  * Add additional tokeninfo tags {client_ip}, {ua_browser}, \n    {ua_string} in token handler (#687)\n  * Allow to set decription of U2F tokens during enrollment (#685)\n  * Reduce the number of LDAP requests to increase authentication\n    performance (#664, #655, #650)\n  * Realm administrator is only allowed to see actions on this allowed\n    user realms (#663)\n  * Add audit rotation to pi-manage (#657)\n  * Speed up Audit Log calls by adding a second index (#656)\n  * Allow to either lock und logout the UI after timeout (#653)\n  * Allow string format {user}, {realm}, {serial}, {surname} in \n    tokenlabel policy (#646)\n  * Move to a consistent time format for validity period and all other \n    user specific times also containing the timezone (#644)\n  * Add TLS certificate check to LDAP machine resolver (#638)\n  * Make TLS certificate the default option in LDAP resolvers (#639)\n  * Allow to use privacyIDEA ownCloud App without subscription\n    file with up to 50 users.\n\n  Fixes:\n  * Fix the datepicker for the token validity period (#644 / #693)\n  * Fix LDAP resolver to respect all boolean configuration \n    options (#658)\n  * Fix serial number in challenge response validation response (#649)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 26 May 2017 08:30:00 +0200\n\nprivacyidea-venv (2.18-1) wheezy; urgency=low\n\n  Features:\n  * Allow to disable the WebUI (#605)\n  * The WebUI will lock the screen after a timeout instead of  \n    logging out the user. This allows to easily continue\n    configuration work. (#621)\n  * Improve the creation and handling of local CAs (#630, #632, #633)\n    Allow certificate template for certificates with different runtime\n    and x509v3 extensions.\n\n  Enhancements\n  Enhancements in Policies:\n  * Allow regular expressions in usernames in policies. (#581)\n  * Improve Policy creation with pi-manage from JSON formatted file.\n  * WebUI: Add action grouping in policies.\n  * WebUI: Add action filter in policy view.\n  * Allow token specific PIN policies: The SPASS token can now\n    have dedicated PIN policies.\n  * Add PIN policies for administrators during enrollment and\n    during assignment.\n  * Add WebUI policy: only search on enter being pressed (#617)\n\n  Enhancements in Event Handlers:\n  * Add token_validity_period condition to event handlers. (#618)\n  * Add additional options in token handler when creating \n    SMS, Email or mOTP tokens.\n  * Allow tokenhandler to set tokeninfo field.\n  * Allow tokenhandler to set syncwindow.\n  * Add event handler condition for count_auth_success and\n    cound_auth_fail\n  * Add event handler condition for last_auth.\n  * Improve Audit Log for Event Handler. Each triggered action \n    will now also create an audit entry. (#609)\n  * Allow the use of {current_time} in tokenevent handler. (#628)\n\n  Enhancements in LDAP Resolver:\n  * Upgrade dependency to ldap3 version >=2.1.1 to improve LDAP \n    performance in regards to redundancy and security\n  * LDAP Resolver: Use get_info in bind requests to avoid querying \n    of subschema. (#585)\n  * LDAP Resolver: Support StartTLS over Port 389.\n  * Simplify LDAP Resolver: Remove username from Attribute Mapping.\n  * Simplefy LDAP Resolver: Remove reverse filter.\n\n  Misc Enhancements:\n  * Automatically add user's mobile number if tokentype is SMS.\n  * Add example configuration for GTX messaging SMS gateway.\n  * Add a script \"privacyidea-get-unused-tokens\" to find\n    unused tokens\n  * WebUI: Add a busy indicator spinner.\n  * Improve the pi-manage script in regards to backup and restore.\n    Let you choose whether to backup encryption key or not.\n    Better handling for individual pathes. (#626, #623)\n\n  Fixes:\n  * LDAP Resolver: Verify SSL Certificate (Security)\n  * LDAP Resolver: Allow special characters in NTLM password\n  * LDAP Resolver: Allow searching for users with German umlaut\n  * Remove the \"unsafe\" notation in the QR-Code link, so that \n    a smartphone may import the key during HOTP/TOTP token enrollment\n    by clicking the link. (#620)\n  * Use defusexml to avoid XML bombs on token import (Security)\n  * Replace eval with ast.literal_evel (Security)\n  * Add missing attributes for U2F tokens in \n    validate/triggerchallenge API\n  * Let /validate/triggerchallenge write to audit log.\n  * Fix mangle policy for users and realms\n  * Avoid logging of password in check_user_pass in debug level \n    (level=10)\n  * Set encrypted PIN on enrollment for certificate tokens (#625)\n  * Remove unused policy action \"motp_webprovision\"\n  * Allow emailtext policy in triggerchallenge API (#642)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Mar 2017 12:00:00 +0200\n\nprivacyidea-venv (2.17-1) wheezy; urgency=low\n\n  Features\n  * Token Handler. Using the token handler the administrator\n    can defined actions in response to events, to modify tokens\n    like deleting, modifying, initilizing... tokens (#532)\n  * Script Event Handler or Shell Event Handler allows to\n    trigger an external shell script, if some event occurs. (#536)\n  * Add additional endpoint to trigger a challenge response\n    like the sending of an SMS, if the token PIN is not\n    available (#531)\n  * Policy Handling to also check for secondary resolvers of\n    a user. This way a user can authenticate with his primary \n    resolver but policy will also work for secondary resolvers (#543)\n\n  Enhancements\n  * The event handler conditions also determine a serial number\n    even if there is no serial number in the request:\n    If the user from the request only has one token assigned. (#571)\n  * Allow event definitions to be disabled (#537)\n  * Allow event to be addressed by a destinct name (#522)\n  * Improving LDAP performace by addressing different functionality \n    of ldap3 version 1.x and 2.x. (#549)\n  * Improve SQL Audit by adding the SQL Audit table to the schema.\n    Table is not created during HTTP request. (#557)\n  * Limit audit log entry age. Users may only view audit\n    log entries up to a certain age. (#541)\n  * Add checkbox to only display used actions in a policy (#573)\n  * In event handler: Use serial number of a user's token if the \n    user has only one token (#571)\n  * Download a filtered audit log (#539)\n\n  Fixes\n  * Add missing token serial number to audit log if token is\n    deletes (#546)\n  * Fix event handler saving (#551)\n  * HttpSMSProvider accepts status codes 201 and 202 in addition\n    to 200 (#562)\n  * Fix checkbox bug in NOREFERRALS of LDAP resolver (#563)\n  * Add documentation for SMS provider (#566)\n  * Remove 301 redirects from WebUI (#576)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 29 Dec 2016 16:30:00 +0200\n\n\nprivacyidea-venv (2.16-1) wheezy; urgency=low\n\n  Featurs\n  * Add HSM support via AES keys (#534)\n  * Improved Event Handler for flexible notification (#511)\n  * Signed subscription files for adding and checking\n    for extra functionality during authentication request (#502)\n\n  Enhancements\n  * Allow additional filter attributes in the Audit Log (#519)\n  * Show or hide realms in the login dialog via policy (#517)\n  * Improve UI if admin is not allowed for certain actions (#516, #512)\n  * Disable OTP PIN during enrollment via policy (#439)\n  * Allow automatic sending of registration code via email (#514)\n\n  Fixes\n  * Allow compatibility with ldap3 >= 2.0.7 (#533 #535)\n  * Fix problem with Notification when no tokenowner is available (#528)\n  * Fix confusion of client HTTP parameters (#529)\n  * Fix enabled flag with certain database types (#527)\n  * Catch error in case of faulty overrideClient definition (#526)\n  * Truncate Audit lines, that are too long for the DB table (#525)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 10 Nov 2016 16:30:00 +0200\n\n\nprivacyidea-venv (2.15-1) wheezy; urgency=low\n\n  Features\n  * Client Overview. Display the type of the requesting\n    authenticating clients (#489)\n  * Support for NitroKey OTP mode (admin client)\n\n  Enhancements\n  * Builds on Ubuntu 16.04 Xenial\n  * Performance enhancements using Caching singletons for\n    Config, Realm, Resolver and Policies\n  * Allow configuration of the registration email text (#494)\n  * Return SAML attributes only in case of successful\n    authentication (#500)\n  * Policy \"reset_all_user_tokens\" allow to reset all\n    failcounters on successful authentication (#471)\n  * Client rewrite mapping also checks for\n    X-Forwarded-For (#395, #495)\n\n  Fixes\n  * Fixing RemoteUser fails to display WebUI (#499)\n  * String comparison in HOSTS resolver (#484)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 06 Oct 2016 08:30:00 +0200\n\n\nprivacyidea-venv (2.14-1) wheezy; urgency=low\n\n  Features\n  * Import PGP encrypted seed files\n  * Allow UserNotification for user actions\n  * Allow UserNotification on validate/check events,\n    to notify the user on a failed authentication or\n    a locked token.\n\n  Enhancements\n  * Add thread ID in REST API Response\n  * Performence improvement: Cache LDAP Requests #473\n  * Performance improvement: Optimize resolver iteration #474\n  * Add \"Check OTP only\" in WebUI\n  * Improve \"get serial by OTP\" in WebUI\n  * Add script to get serial by OTP\n\n  Fixes\n  * Restrict GET /user for corresponding admins #460\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 17 Aug 2016 00:03:00 +0200\n\n\nprivacyidea-venv (2.13-1) wheezy; urgency=low\n\n  Features\n  * Allow central definition of SMS gateways \n    to be used with tokens. #392\n  * User SMS for User Notificaton Event Handler. #435\n  * Add PIN change setting for each token. #429\n  * Force PIN change in web UI. #432\n\n  Enhancements\n  * Performence enhancements\n    * speed up loading of audit log in web UI.\n    * avoid double loadin of tokens and audit entries in web UI. #436\n  * Additional log level (enhanced Debug) to even log passwords in \n    debug mode.\n  * Add new logo. #430\n  * Add quick actions in the token list: reset failcounter, \n    toggle active. #426\n  * REST API returns OTP length on successful authentication. #407\n  * Add intelligent OverrideAuthorizationClient system setting,\n    that allows defined proxies to reset the client IP. #395\n\n  Fixes\n  * Display token count in web UI. #437\n  * Use correct default_tokentype in token enrollment. #427\n  * Fix HOTP resync problems. #412\n  \n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 30 Jun 2016 12:00:00 +0200\n\nprivacyidea-venv (2.12-1) wheezy; urgency=low\n\n  Features\n  * Event Handler Framework #360\n  * local CA connector can enroll certificates\n    for users. Users can download PKCS12 file. #383\n  * Add and edit users in LDAP resolvers #372\n  * Time dependent policies #358\n\n  Enhancements\n  * Policy for web UI enrollment wizard #402\n  * Realm dropdown box at login screen #400\n  * Apply user policy settings #390\n  * Improve QR Code for TOTP token enrollment #384\n  * Add documentation for enrollment wizard #381\n  * Improve pi-manage backup to use pymysql #375\n  * Use X-Forwarded-For HTTP header as client IP #356\n  * Add meta-package privacyidea-mysql #376\n\n  Fixes\n  * Adduser honors resolver setting in policy #403\n  * Add documentation for SPASS token #399\n  * Hide enrollment link (WebUI) is user can not enroll #398\n  * Fix getSerial for TOTP tokens #393\n  * Fix system config checkboxes #378\n  * Allow a realm to be remove from a token #363\n  * Improve the date handling in emails #352\n  * Sending test emails #350\n  * Authentication with active token not possible if\n    the user has a disabled token #339\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 24 May 2016 16:00:00 +0200\n\n\nprivacyidea-venv (2.11-1) wheezy; urgency=low\n\n  Features\n  * RADIUS Servers: Allow central definition of RADIUS servers\n  * RADIUS passthru policy: Authentication requests for users\n    with no tokens can be forwarded to a specified RADIUS server\n\n  Enhancements\n  * Allow objectGUID in LDAP-Resolver of Active Directory\n  * Use paged searches in LDAP. LDAP resolver will find all\n    users in the LDAP directory.\n  * Allow privacyIDEA instance name to be configured for\n    the AUDIT log\n  * Allow special characters in LDAP loginnames and passwords\n  * Add arbitrary attributes to SAML Authentication response\n  * Enhance the handling of YUBICO mode yubikeys with the\n    YUBICO API. The prefix is handled correctly.\n  * Allow in get_tokens to be filtered for tokeninfo.\n  * Add paged search in LDAP resolver. This allows responses\n    with more than 1000 objects.\n\n  Fixes\n  * Fix SMTP authentication\n  * Fix Enrollment Wizard for non-default realm users\n  * Registration process: If an email can not be delivered,\n    the token is deleted, since it can not be used.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 29 Mar 2016 08:30:00 +0200\n\nprivacyidea-venv (2.10-1) wheezy; urgency=low\n\n  Features\n  * User Registration: A user may register himself and thus create\n    his new user account.\n  * Password Reset: Using a recovery token a user may issue a\n    password reset without bothering the administrator or the\n    help desk.\n  * Enrollment Wizard for easy user token enrollment\n  * SMTP Servers: Define several system wide SMTP settings and use\n    these for\n    * Email token,\n    * SMTP SMS Provider, \n    * registration process,\n    * or password reset.\n\n  Enhancements\n  * Ease the Smartphone App (Google Authenticator) rollout.\n    Hide otplen, hash, timestep in the UI if a policy is defined.\n  * Add import of Aladdin/SafeNet XML file.\n  * Add import of password encrypted PSKC files.\n  * Add import of key encrypted PSKC files.\n\n  Fixes\n  * Support LDAP passwords with special non-ascii characters.\n  * Support LDAP BIND with special non-ascii characters.\n  * Fix problem with encrypted encryption key.\n  * Fix upgrading DB Schema for postgresql+psycopg2.\n  * Fix UI displaying of saved SMS Provider.\n  * Do not start challenge response with a locked/disabled token.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 11 Feb 2016 00:01:00 +0200\n\nprivacyidea-venv (2.9-1) wheezy; urgency=low\n\n  Features\n  * New token type: Security questions or questionnaire token.\n  * New token type: Paper token. OTP values printed on a piece of paper.\n  * Yubico Validation API: The yubikey tokens can authenticate via\n    /ttype/yubikey which follows the Yubico Validation Protocol.\n\n  Enhancements\n  * Add Web UI view to display the active challenges.\n  * The issuer for the Google Authenticator app can be configured.\n  * The LDAP machine resolver uses an LDAP server pool.\n  * The LDAP user resolver returns a list of mobile numbers.\n\n  Fixes\n  * The test email for the email token now has a sent date.\n  * Fix problem when using encrypted encryption key.\n  * Fix upper case problem when logging in to web UI\n    with REMOTE_USER.\n  * Fix allow set an empty PIN in the web UI.\n  * Fix import of token file in Web UI.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 21 Dec 2015 18:00:00 +0200\n\nprivacyidea-venv (2.8-1) wheezy; urgency=low\n\n  Features\n  * Improve U2F support with trusted facets\n  * Add Challenge Response and U2F support to SAML\n  * Add Web UI theming\n  * Add possibility to use REMOTE_USER for authentication at Web UI\n  * Fuzzy Authentication: restrict time since last authentication\n\n  Enhancements\n  * Allow mangle policy when fetching ssh keys\n  * Add realm support to ownCloud plugin\n  * Support Drupal passwords in SQL resolver\n  * Add validity period to token enrollment\n  * Set default enrollment token type in Web UI\n  * Add scope to LDAP resolver\n\n  Fixes\n  * Fix failcounter reset for challenge response tokens\n  * Fix confusing DB errors (column exist) during installation\n  * Fix email token TLS checkbox saving\n  * Fix TOTP testing in Web UI\n  * Fix SMS config loading in Web UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 26 Nov 2015 23:30:00 +0200\n\nprivacyidea-venv (2.7-1) wheezy; urgency=low\n\n  Features\n  * Add support for U2F tokens\n  * Add signature to the API JSON response. Thus\n    the client can verify the response.\n\n  Enhancements\n  * When importing tokens, a realm can be chosen, so that all imported\n    tokens are immediately inserted into this realm.\n  * The user is able to change his password in the WebUI.\n  * The user can assign a token in the WebUI.\n  * Avoid the requiring of a PIN for some tokentypes like SSH\n  * Migrate to pymysql, the pure python mysql implementation\n  * The Audit Log tells if a previous OTP value was used again.\n\n  Fixes\n  * Enable login to WebUI with a loginname containing an @ sign.\n  * Fix the writing of logfile privacyidea.log\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 07 Oct 2015 08:00:00 +0200\n\n\nprivacyidea-venv (2.6-1) wheezy; urgency=low\n\n  Features\n  * Add OCRA base TiQR token to authenticate by scanning\n    a QR code.\n  * Add Challenge Response authentication to Web UI\n  * Add 4-Eyes token, to enable two man policy. Two tokens\n    of two users are needed to authenticate.\n  * \"Revoke Token\" lets you perform special action on token types.\n    Tokens can be revoke, meaning they are blocked an can not\n    be unblocked anymore.\n\n  Enhancements\n  * Add HA information in the documentation.\n  * Add OpenVPN documentation.\n  * Add challenge response policy, to define if e.g. HOTP or TOTP are \n    allowed to be used in challenge response mode.\n  * Add hotkeys for easier use of Web Ui.\n  * Remove wrong system wide PassOnNoUser and PassOnNoToken.\n  * Set default language to \"en\" in Web UI.\n\n  Fixes\n  * Fix LDAP bug #179, which allows authentication with\n    wrong password under certain conditions\n  * Small fixes in coverage tests\n  * Fix username in web UI during enrollment\n  * Fix link to privacyIDEA logo in Web UI\n  * Fixed bug, that user was not able to resync his own tokens.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 09 Sep 2015 09:30:00 +0200\n\nprivacyidea-venv (2.5-1) wheezy; urgency=low\n\n  Features\n  * Add statistics\n  * Add German translation\n  * Add PinHandler in case of random PIN used\n  * Add automatic documentation of system setup\n  * Add ownCloud plugin\n  \n  Enhancements\n  * Preset Email and SMS of a user when enrolling token\n  * Enable LDAP anonymous bind\n  * Add Hashalgorithms and digits to QR Code\n  * Add support for CentOS 6 and 7\n  \n  Fixes\n  * Fix registration token\n  * Fix mOTP reuse problem\n\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 22 Jul 2015 17:00:00 +0200\n\n\nprivacyidea-venv (2.4-1) wheezy; urgency=low\n\n  * Add User Management\n  * Add Admin Realms to policies, to allow better policies in bigger setups\n  * Add API key, that can be used for accessing /validate/check\n  * Load PSKC Token seed files.\n  * WebUI: Registrtion token can be enrolled in WebUI\n  * WebUI: The token seed can be displayed in WebUI after generation\n  * WebUI: Only the token types that are allowed to be enrolled are displayed\n  * WebUI: Login_Mode Policy: Disable access to WebUI for certain users\n  * WebUI: Add reload button in Audit view\n  * SQLResolver: The Where statement is used in all cases\n  * SSH-Token Application: Only fetch keys of the requested user\n  * Apache client can work with several hosts on one machine\n  * Documentation: Tokentypes and Supported Hardware Tokens\n  * Improve RADIUS module\n  * WebUI: Fix download of audit log\n  * Fix missing access right of user to GET /caconnector\n  * Fix SMS token\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Jun 2015 09:30:00 +0200\n\nprivacyidea-venv (2.3-1) wheezy; urgency=low\n\n  * Add connector to remote Certificate Authority\n  * Add Tokentype \"certificate\" to manage certificates for users\n    Certificates or Certificate Requests can be uploaded.\n    Certificate Requests (Keypair) can be generated in the browser.\n  * Add Tokentype \"registration\" for easier enrollment scenarios.\n  * Add TokenType \"Email\" to send OTP via Email.\n  * Add \"First Steps\" to online documentation\n  * Add handling of validity period of token\n  * Enable download of Audit log as CSV\n  * Add Resolver Priority, to handle a duplicate user in a realm\n  * Add TYPO3 Plugin to enable OTP with TYPO3\n  * Add SCIM Resolver to fetch users from SCIM services\n  * Fix Failcounter issue\n  * Fix NTLM password check\n  * Fix timestep during enrollment\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 22 May 2015 15:30:00 +0200\n\nprivacyidea-venv (2.2-1) wheezy; urgency=low\n\n  * pi-manage: create resolvers and realms\n  * pi-manage: maange policies\n  * Add LostToken UI\n  * Add Offline Application\n  * Add PAM authentication module with offline support\n  * Add getSerialByOTP. You can determine the Token by providing an OTP value.\n  * Add auth_count_max and auth_success_max for each token.\n  * Add PIN encryption policy\n  * Add API for SAML\n  * Add bash script for ssh key fetching\n  * Make WebUI logout time configurable via webui policy.\n  \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 09 Apr 2015 12:10:00 +0200\n\nprivacyidea-venv (2.1-1) wheezy; urgency=low\n\n  * Add Machine-Application framework to support LUKS and SSH\n    to manage SSH keys and provide Yubikeys to boot LUKS\n    encrypted machines. #100, #10\n  * Add Machine Resolvers for hosts and LDAP/AD #96\n  * Migrate more policies like SMS policies. #95\n  * Restructure WebUI code to ease development #97\n  * Fix logout problem of user #92\n  * Fix user list for AD (referrals) #99\n  * Fix max_token_per_user policy #101\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 10 Mar 2015 10:30:00 +0200\n\nprivacyidea-venv (2.1~dev2) trusty; urgency=low\n\n  * Add MachineTokens to Token.Details and Machine.Details view.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 02 Mar 2015 15:50:00 +0200\n\nprivacyidea-venv (2.1~dev1) trusty; urgency=low\n\n  * Fix logout problem of user\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 16:00:00 +0200\n\npython-privacyidea (2.0-1) trusty; urgency=low\n\n  * Migrate to flask\n  * change the name of the debian package as the package only\n    contains the python module.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Sat, 21 Feb 2015 14:00:00 +0200\n\n\nprivacyidea (1.5.1-1trusty) trusty; urgency=low\n\n  * Fix splitting the @-sign to allow users like user@email.com\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 02 Feb 2015 09:08:00 +0200\n\n\nprivacyidea (1.5-1trusty) trusty; urgency=low\n\n  * Fix the postinstall script for not broken repoze.who\n  * adapt the dependency for python webob\n  * add fix for users in policies.\n  * Working on #61\n  * Closing #63, allow upper and lower case DN in LDAP resolver\n  * Fix the empty result audit search problem\n  * Fix the port problem with SQL resolver\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 25 Dec 2014 16:30:00 +0200\n\nprivacyidea (1.4-1) trusty; urgency=low\n\n  * Add \"wrong password\" message on login screen\n  * Speed up tests\n  * Add help on logon screen.\n  * Add helper dialog to setup first realm\n  * Add simplesamlphp module and deb package\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 16:50:00 +0200\n\nprivacyidea (1.4~dev5-1) trusty; urgency=low\n\n  * Add wrong password message on login screen\n  * Speed up tests\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 06 Oct 2014 09:10:00 +0200\n\nprivacyidea (1.4~dev4-1) trusty; urgency=low\n\n  * Add help on logon screen.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 02 Oct 2014 11:20:00 +0200\n\nprivacyidea (1.4~dev3-1) trusty; urgency=low\n\n  * Add helper dialog to setup first realm\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 30 Sep 2014 11:10:00 +0200\n\nprivacyidea (1.4~dev2-1) trusty; urgency=low\n\n  * Add simplesamlphp module and deb package\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 29 Sep 2014 11:40:00 +0200\n\nprivacyidea (1.4~dev1-1) trusty; urgency=low\n\n  * Fixed the session timeout bug in the management UI\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 24 Sep 2014 19:10:00 +0200\n\nprivacyidea (1.3.2-1) trusty; urgency=low\n\n  * Add uwsgi and nginx configuration\n  * Add nginx package\n  * Add meta packages to easily install radius dependencies. (#33)\n  * Add package for appliance\n  * Add appliance style: privacyidea-setup-tui\n  * Add privacyidea-otrs and remove the authmodules from the\n    core package\n  * Add first implementation of Token2 token type\n  * Change depend in builddepend\n  * Add missing SSL certificate\n  * Add missing python-dialog dependency\n  * Remove pylons download link, that caused timeout problems.\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 22 Sep 2014 10:00:00 +0200\n\nprivacyidea (1.3.1-1) trusty; urgency=low\n\n  * Fixed bug, that avoided to delete MachineTokens with options (#27)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 20 Aug 2014 18:30:00 +0200\n\nprivacyidea (1.3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n  * inactive tokens will not work with the machine-app\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 18 Aug 2014 17:00:00 +0200\n\nprivacyidea (1.3~dev5-1) trusty; urgency=low\n\n  * Allow login with admin@realm, even with RealmBox.  (#26)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 15 Aug 2014 15:37:00 +0200\n\nprivacyidea (1.3~dev4-1) trusty; urgency=low\n\n  * fix minor bugs in selfservice portal\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 13 Aug 2014 17:40:00 +0200\n\nprivacyidea (1.3~dev3-1) trusty; urgency=low\n\n  * add support for Daplug dongle in keyboard mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 12 Aug 2014 18:32:00 +0200\n\nprivacyidea (1.3~dev2-1) trusty; urgency=low\n\n  * machine requires IP address\n  * the machine-app listing also returns the information, if the token\n    is active\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 11 Aug 2014 10:40:00 +0200\n\n\nprivacyidea (1.3~dev1-1) trusty; urgency=low\n\n  * Added MachineUser database moduel\n  * PEP8 beautify\n  * Add about dialog\n  * added recommends for mysql and salt\n \n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 06 Aug 2014 14:14:00 +0200\n\nprivacyidea (1.3~dev0-2) trusty; urgency=low\n\n  * Fixed the missing run directory (#23)\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Thu, 31 Jul 2014 09:28:00 +0200\n \nprivacyidea (1.3~dev0-1) trusty; urgency=low\n\n  * Fix resolver error #22\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 30 Jul 2014 16:24:00 +0200\n\nprivacyidea (1.2.2-1) trusty; urgency=low\n\n  * Fixed the sqlsoup dependency\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Wed, 23 Jul 2014 17:57:00 +0200\n\n\nprivacyidea (1.2.1-1) trusty; urgency=low\n\n  * machine controller: make the challenge usable also in normal mode\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Fri, 18 Jul 2014 16:51:00 +0200\n\n\nprivacyidea (1.2-1) trusty; urgency=low\n\n  * Added \n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Tue, 15 Jul 2014 15:15:55 +0200\n\nprivacyidea (1.2~dev2-1) trusty; urgency=low\n\n  * initial ubuntu release\n\n -- Cornelius K\u00f6lbel <cornelius@privacyidea.org>  Mon, 14 Jul 2014 18:56:55 +0200\n", "#!/usr/bin/make -f\n\n# This file was automatically generated by stdeb 0.6.0+git at\n# Mon, 14 Jul 2014 18:56:55 +0200\n\n%:\n\tdh $@ --with python-virtualenv \n\noverride_dh_virtualenv:\n\tdh_virtualenv --upgrade-pip\n\noverride_dh_shlibdeps:\n\tdh_shlibdeps --exclude=numpy --exclude=psycopg2 --exclude=libz --exclude=png16\n\noverride_dh_strip:\n\tdh_strip --exclude=cffi --exclude=PIL --exclude=Pillow\n\n\n", "# -*- coding: utf-8 -*-\n#\n# privacyIDEA documentation build configuration file, created by\n# sphinx-quickstart on Fri Jun 13 07:31:01 2014.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '2.23.2'\n# The full version, including alpha/beta/rc tags.\n#release = '2.16dev5'\nrelease = version\n\n\nimport sys\nimport os\nfrom mock import Mock as MagicMock\n\nclass Mock(MagicMock):\n    @classmethod\n    def __getattr__(cls, name):\n            return MagicMock()\n\n#MOCK_MODULES = ['pandas', 'pyOpenSSL']\nMOCK_MODULES = []\nsys.modules.update((mod_name, Mock()) for mod_name in MOCK_MODULES)\n\n\n# Monkey-patch functools.wraps\n# http://stackoverflow.com/questions/28366818/preserve-default-arguments-of-wrapped-decorated-python-function-in-sphinx-docume\nimport functools\n\ndef no_op_wraps(func):\n    \"\"\"Replaces functools.wraps in order to undo wrapping.\n\n    Can be used to preserve the decorated function's signature\n    in the documentation generated by Sphinx.\n\n    \"\"\"\n    def wrapper(decorator):\n        return func\n    return wrapper\n\nfunctools.wraps = no_op_wraps\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath('..'))\nsys.path.append(os.path.abspath('_themes/flask-sphinx-themes'))\nsys.path.insert(0, os.path.abspath('../privacyidea'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.imgmath', 'sphinx.ext.viewcode', \n              'sphinxcontrib.autohttp.flask']\nhttp_index_ignore_prefixes = ['/token']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'privacyIDEA'\ncopyright = u'2014-2017, Cornelius K\u00f6lbel'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\nadd_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#html_theme = 'sphinxdoc'\n#html_theme = 'sphinx_rtd_theme'\n#html_theme = 'agogo'\nhtml_theme = 'flask'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = ['_themes/flask-sphinx-themes']\n\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\nhtml_logo = \"images/privacyidea-color.png\"\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'privacyIDEAdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('index', 'privacyIDEA.tex', u'privacyIDEA Authentication System',\n   u'Cornelius K\u00f6lbel', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'privacyidea-server', u'privacyIDEA Authentication System',\n     [u'Cornelius K\u00f6lbel'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'privacyIDEA', u'privacyIDEA AUthentication System',\n   u'Cornelius K\u00f6lbel', 'privacyIDEA', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n", "# -*- coding: utf-8 -*-\n#\n# http://www.privacyidea.org\n# (c) cornelius k\u00f6lbel, privacyidea.org\n#\n# 2018-01-22 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            Add offline refill\n# 2016-12-20 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            Add triggerchallenge endpoint\n# 2016-10-23 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            Add subscription decorator\n# 2016-09-05 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            SAML attributes on fail\n# 2016-08-30 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>\n#            save client application type to database\n# 2016-08-09 Cornelius K\u00f6lbel <cornelius@privacyidea.org>\n#            Add possiblity to check OTP only\n# 2015-11-19 Cornelius K\u00f6lbel <cornelius@privacyidea.org>\n#            Add support for transaction_id to saml_check\n# 2015-06-17 Cornelius K\u00f6lbel <cornelius@privacyidea.org>\n#            Add policy decorator for API key requirement\n# 2014-12-08 Cornelius K\u00f6lbel, <cornelius@privacyidea.org>\n#            Complete rewrite during flask migration\n#            Try to provide REST API\n#\n# This code is free software; you can redistribute it and/or\n# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n# License as published by the Free Software Foundation; either\n# version 3 of the License, or any later version.\n#\n# This code is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU AFFERO GENERAL PUBLIC LICENSE for more details.\n#\n# You should have received a copy of the GNU Affero General Public\n# License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n__doc__ = \"\"\"This module contains the REST API for doing authentication.\nThe methods are tested in the file tests/test_api_validate.py\n\nAuthentication is either done by providing a username and a password or a\nserial number and a password.\n\n**Authentication workflow**\n\nAuthentication workflow is like this:\n\nIn case of authenticating a user:\n\n * :func:`privacyidea.lib.token.check_user_pass`\n * :func:`privacyidea.lib.token.check_token_list`\n * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`\n\nIn case if authenitcating a serial number:\n\n * :func:`privacyidea.lib.token.check_serial_pass`\n * :func:`privacyidea.lib.token.check_token_list`\n * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`\n * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`\n\n\"\"\"\nfrom flask import (Blueprint, request, g, current_app)\nfrom privacyidea.lib.user import get_user_from_param\nfrom .lib.utils import send_result, getParam\nfrom ..lib.decorators import (check_user_or_serial_in_request)\nfrom .lib.utils import required\nfrom privacyidea.lib.error import ParameterError\nfrom privacyidea.lib.token import (check_user_pass, check_serial_pass,\n                                   check_otp)\nfrom privacyidea.api.lib.utils import get_all_params\nfrom privacyidea.lib.config import (return_saml_attributes, get_from_config,\n                                    return_saml_attributes_on_fail,\n                                    SYSCONF)\nfrom privacyidea.lib.audit import getAudit\nfrom privacyidea.api.lib.prepolicy import (prepolicy, set_realm,\n                                           api_key_required, mangle,\n                                           save_client_application_type,\n                                           check_base_action)\nfrom privacyidea.api.lib.postpolicy import (postpolicy,\n                                            check_tokentype, check_serial,\n                                            check_tokeninfo,\n                                            no_detail_on_fail,\n                                            no_detail_on_success, autoassign,\n                                            offline_info,\n                                            add_user_detail_to_response, construct_radius_response)\nfrom privacyidea.lib.policy import PolicyClass\nfrom privacyidea.lib.config import ConfigClass\nfrom privacyidea.lib.event import EventConfiguration\nimport logging\nfrom privacyidea.api.lib.postpolicy import postrequest, sign_response\nfrom privacyidea.api.auth import jwtauth\nfrom privacyidea.api.register import register_blueprint\nfrom privacyidea.api.recover import recover_blueprint\nfrom privacyidea.lib.utils import get_client_ip\nfrom privacyidea.lib.event import event\nfrom privacyidea.lib.subscriptions import CheckSubscription\nfrom privacyidea.api.auth import admin_required\nfrom privacyidea.lib.policy import ACTION\nfrom privacyidea.lib.token import get_tokens\nfrom privacyidea.lib.machine import list_token_machines\nfrom privacyidea.lib.applications.offline import MachineApplication\nimport json\n\nlog = logging.getLogger(__name__)\n\nvalidate_blueprint = Blueprint('validate_blueprint', __name__)\n\n\n@validate_blueprint.before_request\n@register_blueprint.before_request\n@recover_blueprint.before_request\ndef before_request():\n    \"\"\"\n    This is executed before the request\n    \"\"\"\n    g.config_object = ConfigClass()\n    request.all_data = get_all_params(request.values, request.data)\n    request.User = get_user_from_param(request.all_data)\n    privacyidea_server = current_app.config.get(\"PI_AUDIT_SERVERNAME\") or \\\n                         request.host\n    # Create a policy_object, that reads the database audit settings\n    # and contains the complete policy definition during the request.\n    # This audit_object can be used in the postpolicy and prepolicy and it\n    # can be passed to the innerpolicies.\n\n    g.policy_object = PolicyClass()\n\n    g.audit_object = getAudit(current_app.config)\n    g.event_config = EventConfiguration()\n    # access_route contains the ip addresses of all clients, hops and proxies.\n    g.client_ip = get_client_ip(request, get_from_config(SYSCONF.OVERRIDECLIENT))\n    g.audit_object.log({\"success\": False,\n                        \"action_detail\": \"\",\n                        \"client\": g.client_ip,\n                        \"client_user_agent\": request.user_agent.browser,\n                        \"privacyidea_server\": privacyidea_server,\n                        \"action\": \"{0!s} {1!s}\".format(request.method, request.url_rule),\n                        \"info\": \"\"})\n\n\n@validate_blueprint.after_request\n@register_blueprint.after_request\n@recover_blueprint.after_request\n@jwtauth.after_request\n@postrequest(sign_response, request=request)\ndef after_request(response):\n    \"\"\"\n    This function is called after a request\n    :return: The response\n    \"\"\"\n    # In certain error cases the before_request was not handled\n    # completely so that we do not have an audit_object\n    if \"audit_object\" in g:\n        g.audit_object.finalize_log()\n\n    # No caching!\n    response.headers['Cache-Control'] = 'no-cache'\n    return response\n\n\n@validate_blueprint.route('/offlinerefill', methods=['POST'])\n@check_user_or_serial_in_request(request)\n@event(\"validate_offlinerefill\", request, g)\ndef offlinerefill():\n    \"\"\"\n    This endpoint allows to fetch new offline OTP values for a token,\n    that is already offline.\n    According to the definition it will send the missing OTP values, so that\n    the client will have as much otp values as defined.\n\n    :param serial: The serial number of the token, that should be refilled.\n    :param refilltoken: The authorization token, that allows refilling.\n    :param pass: the last password (maybe password+OTP) entered by the user\n    :return:\n    \"\"\"\n    result = False\n    otps = {}\n    serial = getParam(request.all_data, \"serial\", required)\n    refilltoken = getParam(request.all_data, \"refilltoken\", required)\n    password = getParam(request.all_data, \"pass\", required)\n    tokenobj_list = get_tokens(serial=serial)\n    if len(tokenobj_list) != 1:\n        raise ParameterError(\"The token does not exist\")\n    else:\n        tokenobj = tokenobj_list[0]\n        machine_defs = list_token_machines(serial)\n        # check if is still an offline token:\n        for mdef in machine_defs:\n            if mdef.get(\"application\") == \"offline\":\n                # check refill token:\n                if tokenobj.get_tokeninfo(\"refilltoken\") == refilltoken:\n                    # refill\n                    otps = MachineApplication.get_refill(tokenobj, password, mdef.get(\"options\"))\n                    refilltoken = MachineApplication.generate_new_refilltoken(tokenobj)\n                    response = send_result(True)\n                    content = json.loads(response.data)\n                    content[\"auth_items\"] = {\"offline\": [{\"refilltoken\": refilltoken,\n                                                          \"response\": otps}]}\n                    response.data = json.dumps(content)\n                    return response\n        raise ParameterError(\"Token is not an offline token or refill token is incorrect\")\n\n\n@validate_blueprint.route('/check', methods=['POST', 'GET'])\n@validate_blueprint.route('/radiuscheck', methods=['POST', 'GET'])\n@postpolicy(construct_radius_response, request=request)\n@postpolicy(no_detail_on_fail, request=request)\n@postpolicy(no_detail_on_success, request=request)\n@postpolicy(add_user_detail_to_response, request=request)\n@postpolicy(offline_info, request=request)\n@postpolicy(check_tokeninfo, request=request)\n@postpolicy(check_tokentype, request=request)\n@postpolicy(check_serial, request=request)\n@postpolicy(autoassign, request=request)\n@prepolicy(set_realm, request=request)\n@prepolicy(mangle, request=request)\n@prepolicy(save_client_application_type, request=request)\n@check_user_or_serial_in_request(request)\n@CheckSubscription(request)\n@prepolicy(api_key_required, request=request)\n@event(\"validate_check\", request, g)\ndef check():\n    \"\"\"\n    check the authentication for a user or a serial number.\n    Either a ``serial`` or a ``user`` is required to authenticate.\n    The PIN and OTP value is sent in the parameter ``pass``.\n    In case of successful authentication it returns ``result->value: true``.\n\n    In case of a challenge response authentication a parameter ``exception=1``\n    can be passed. This would result in a HTTP 500 Server Error response if\n    an error occurred during sending of SMS or Email.\n\n    In case ``/validate/radiuscheck`` is requested, the responses are\n    modified as follows: A successful authentication returns an empty HTTP\n    204 response. An unsuccessful authentication returns an empty HTTP\n    400 response. Error responses are the same responses as for the\n    ``/validate/check`` endpoint.\n\n    :param serial: The serial number of the token, that tries to authenticate.\n    :param user: The loginname/username of the user, who tries to authenticate.\n    :param realm: The realm of the user, who tries to authenticate. If the\n        realm is omitted, the user is looked up in the default realm.\n    :param pass: The password, that consists of the OTP PIN and the OTP value.\n    :param otponly: If set to 1, only the OTP value is verified. This is used\n        in the management UI. Only used with the parameter serial.\n    :param transaction_id: The transaction ID for a response to a challenge\n        request\n    :param state: The state ID for a response to a challenge request\n\n    :return: a json result with a boolean \"result\": true\n\n    **Example Validation Request**:\n\n        .. sourcecode:: http\n\n           POST /validate/check HTTP/1.1\n           Host: example.com\n           Accept: application/json\n\n           user=user\n           realm=realm1\n           pass=s3cret123456\n\n    **Example response** for a successful authentication:\n\n       .. sourcecode:: http\n\n           HTTP/1.1 200 OK\n           Content-Type: application/json\n\n            {\n              \"detail\": {\n                \"message\": \"matching 1 tokens\",\n                \"serial\": \"PISP0000AB00\",\n                \"type\": \"spass\"\n              },\n              \"id\": 1,\n              \"jsonrpc\": \"2.0\",\n              \"result\": {\n                \"status\": true,\n                \"value\": true\n              },\n              \"version\": \"privacyIDEA unknown\"\n            }\n\n    **Example response** for this first part of a challenge response\n    authentication:\n\n       .. sourcecode:: http\n\n           HTTP/1.1 200 OK\n           Content-Type: application/json\n\n            {\n              \"detail\": {\n                \"serial\": \"PIEM0000AB00\",\n                \"type\": \"email\",\n                \"transaction_id\": \"12345678901234567890\",\n                \"multi_challenge: [ {\"serial\": \"PIEM0000AB00\",\n                                     \"transaction_id\":  \"12345678901234567890\",\n                                     \"message\": \"Please enter otp from your\n                                     email\"},\n                                    {\"serial\": \"PISM12345678\",\n                                     \"transaction_id\": \"12345678901234567890\",\n                                     \"message\": \"Please enter otp from your\n                                     SMS\"}\n                ]\n              },\n              \"id\": 1,\n              \"jsonrpc\": \"2.0\",\n              \"result\": {\n                \"status\": true,\n                \"value\": false\n              },\n              \"version\": \"privacyIDEA unknown\"\n            }\n\n    In this example two challenges are triggered, one with an email and one\n    with an SMS. The application and thus the user has to decide, which one\n    to use. They can use either.\n\n    .. note:: All challenge response tokens have the same transaction_id in\n       this case.\n    \"\"\"\n    #user = get_user_from_param(request.all_data)\n    user = request.User\n    serial = getParam(request.all_data, \"serial\")\n    password = getParam(request.all_data, \"pass\", required)\n    otp_only = getParam(request.all_data, \"otponly\")\n    options = {\"g\": g,\n               \"clientip\": g.client_ip}\n    # Add all params to the options\n    for key, value in request.all_data.items():\n            if value and key not in [\"g\", \"clientip\"]:\n                options[key] = value\n\n    g.audit_object.log({\"user\": user.login,\n                        \"resolver\": user.resolver,\n                        \"realm\": user.realm})\n\n    if serial:\n        if not otp_only:\n            result, details = check_serial_pass(serial, password, options=options)\n        else:\n            result, details = check_otp(serial, password)\n\n    else:\n        result, details = check_user_pass(user, password, options=options)\n\n    g.audit_object.log({\"info\": details.get(\"message\"),\n                        \"success\": result,\n                        \"serial\": serial or details.get(\"serial\"),\n                        \"tokentype\": details.get(\"type\")})\n    return send_result(result, details=details)\n\n\n@validate_blueprint.route('/samlcheck', methods=['POST', 'GET'])\n@postpolicy(no_detail_on_fail, request=request)\n@postpolicy(no_detail_on_success, request=request)\n@postpolicy(add_user_detail_to_response, request=request)\n@postpolicy(check_tokeninfo, request=request)\n@postpolicy(check_tokentype, request=request)\n@postpolicy(check_serial, request=request)\n@postpolicy(autoassign, request=request)\n@prepolicy(set_realm, request=request)\n@prepolicy(mangle, request=request)\n@prepolicy(save_client_application_type, request=request)\n@check_user_or_serial_in_request(request)\n@CheckSubscription(request)\n@prepolicy(api_key_required, request=request)\n@event(\"validate_check\", request, g)\ndef samlcheck():\n    \"\"\"\n    Authenticate the user and return the SAML user information.\n\n    :param user: The loginname/username of the user, who tries to authenticate.\n    :param realm: The realm of the user, who tries to authenticate. If the\n        realm is omitted, the user is looked up in the default realm.\n    :param pass: The password, that consists of the OTP PIN and the OTP value.\n\n    :return: a json result with a boolean \"result\": true\n\n    **Example response** for a successful authentication:\n\n       .. sourcecode:: http\n\n           HTTP/1.1 200 OK\n           Content-Type: application/json\n\n            {\n              \"detail\": {\n                \"message\": \"matching 1 tokens\",\n                \"serial\": \"PISP0000AB00\",\n                \"type\": \"spass\"\n              },\n              \"id\": 1,\n              \"jsonrpc\": \"2.0\",\n              \"result\": {\n                \"status\": true,\n                \"value\": {\"attributes\": {\n                            \"username\": \"koelbel\",\n                            \"realm\": \"themis\",\n                            \"mobile\": null,\n                            \"phone\": null,\n                            \"myOwn\": \"/data/file/home/koelbel\",\n                            \"resolver\": \"themis\",\n                            \"surname\": \"K\u00f6lbel\",\n                            \"givenname\": \"Cornelius\",\n                            \"email\": null},\n                          \"auth\": true}\n              },\n              \"version\": \"privacyIDEA unknown\"\n            }\n\n    The response in value->attributes can contain additional attributes\n    (like \"myOwn\") which you can define in the LDAP resolver in the attribute\n    mapping.\n    \"\"\"\n    user = get_user_from_param(request.all_data)\n    password = getParam(request.all_data, \"pass\", required)\n    options = {\"g\": g,\n               \"clientip\": g.client_ip}\n    # Add all params to the options\n    for key, value in request.all_data.items():\n            if value and key not in [\"g\", \"clientip\"]:\n                options[key] = value\n\n    auth, details = check_user_pass(user, password, options=options)\n    ui = user.info\n    result_obj = {\"auth\": auth,\n                  \"attributes\": {}}\n    if return_saml_attributes():\n        if auth or return_saml_attributes_on_fail():\n            # privacyIDEA's own attribute map\n            result_obj[\"attributes\"] = {\"username\": ui.get(\"username\"),\n                                        \"realm\": user.realm,\n                                        \"resolver\": user.resolver,\n                                        \"email\": ui.get(\"email\"),\n                                        \"surname\": ui.get(\"surname\"),\n                                        \"givenname\": ui.get(\"givenname\"),\n                                        \"mobile\": ui.get(\"mobile\"),\n                                        \"phone\": ui.get(\"phone\")\n                                        }\n            # additional attributes\n            for k, v in ui.iteritems():\n                result_obj[\"attributes\"][k] = v\n\n    g.audit_object.log({\"info\": details.get(\"message\"),\n                        \"success\": auth,\n                        \"serial\": details.get(\"serial\"),\n                        \"tokentype\": details.get(\"type\"),\n                        \"user\": user.login,\n                        \"resolver\": user.resolver,\n                        \"realm\": user.realm})\n    return send_result(result_obj, details=details)\n\n\n@validate_blueprint.route('/triggerchallenge', methods=['POST', 'GET'])\n@admin_required\n@check_user_or_serial_in_request(request)\n@prepolicy(check_base_action, request, action=ACTION.TRIGGERCHALLENGE)\n@event(\"validate_triggerchallenge\", request, g)\ndef trigger_challenge():\n    \"\"\"\n    An administrator can call this endpoint if he has the right of\n    ``triggerchallenge`` (scope: admin).\n    He can pass a ``user`` name and or a ``serial`` number.\n    privacyIDEA will trigger challenges for all native challenges response\n    tokens, possessed by this user or only for the given serial number.\n\n    The request needs to contain a valid PI-Authorization header.\n\n    :param user: The loginname/username of the user, who tries to authenticate.\n    :param realm: The realm of the user, who tries to authenticate. If the\n        realm is omitted, the user is looked up in the default realm.\n    :param serial: The serial number of the token.\n\n    :return: a json result with a \"result\" of the number of matching\n        challenge response tokens\n\n    **Example response** for a successful triggering of challenge:\n\n       .. sourcecode:: http\n\n           {\"jsonrpc\": \"2.0\",\n            \"signature\": \"1939...146964\",\n            \"detail\": {\"transaction_ids\": [\"03921966357577766962\"],\n                       \"messages\": [\"Enter the OTP from the SMS:\"],\n                       \"threadid\": 140422378276608},\n            \"versionnumber\": \"unknown\",\n            \"version\": \"privacyIDEA unknown\",\n            \"result\": {\"status\": true,\n                       \"value\": 1},\n            \"time\": 1482223663.517212,\n            \"id\": 1}\n\n    **Example response** for response, if the user has no challenge token:\n\n       .. sourcecode:: http\n\n           {\"detail\": {\"messages\": [],\n                       \"threadid\": 140031212377856,\n                       \"transaction_ids\": []},\n            \"id\": 1,\n            \"jsonrpc\": \"2.0\",\n            \"result\": {\"status\": true,\n                       \"value\": 0},\n            \"signature\": \"205530282...54508\",\n            \"time\": 1484303812.346576,\n            \"version\": \"privacyIDEA 2.17\",\n            \"versionnumber\": \"2.17\"}\n\n    **Example response** for a failed triggering of a challenge. In this case\n        the ``status`` will be ``false``.\n\n       .. sourcecode:: http\n\n           {\"detail\": null,\n            \"id\": 1,\n            \"jsonrpc\": \"2.0\",\n            \"result\": {\"error\": {\"code\": 905,\n                                 \"message\": \"ERR905: The user can not be\n                                 found in any resolver in this realm!\"},\n                       \"status\": false},\n            \"signature\": \"14468...081555\",\n            \"time\": 1484303933.72481,\n            \"version\": \"privacyIDEA 2.17\"}\n\n    \"\"\"\n    user = request.User\n    serial = getParam(request.all_data, \"serial\")\n    result_obj = 0\n    details = {\"messages\": [],\n               \"transaction_ids\": []}\n    options = {\"g\": g,\n               \"clientip\": g.client_ip,\n               \"user\": user}\n\n    token_objs = get_tokens(serial=serial, user=user, active=True, revoked=False, locked=False)\n    for token_obj in token_objs:\n        if \"challenge\" in token_obj.mode:\n            # If this is a challenge response token, we create a challenge\n            success, return_message, transactionid, attributes = \\\n                token_obj.create_challenge(options=options)\n            if attributes:\n                details[\"attributes\"] = attributes\n            if success:\n                result_obj += 1\n                details.get(\"transaction_ids\").append(transactionid)\n                # This will write only the serial of the token that was processed last to the audit log\n                g.audit_object.log({\n                    \"serial\": token_obj.token.serial,\n                })\n            details.get(\"messages\").append(return_message)\n\n    g.audit_object.log({\n        \"user\": user.login,\n        \"resolver\": user.resolver,\n        \"realm\": user.realm,\n        \"success\": result_obj > 0,\n        \"info\": \"triggered {0!s} challenges\".format(result_obj),\n    })\n\n    return send_result(result_obj, details=details)\n\n", "# -*- coding: utf-8 -*-\n#\n#  (c) Cornelius K\u00f6lbel\n#  License:  AGPLv3\n#  contact:  http://www.privacyidea.org\n#\n# This code is free software; you can redistribute it and/or\n# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE\n# License as published by the Free Software Foundation; either\n# version 3 of the License, or any later version.\n#\n# This code is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU AFFERO GENERAL PUBLIC LICENSE for more details.\n#\n# You should have received a copy of the GNU Affero General Public\n# License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nimport logging\nimport functools\nfrom privacyidea.lib.error import TokenAdminError\nfrom privacyidea.lib.error import ParameterError\nfrom privacyidea.lib import _\nlog = logging.getLogger(__name__)\n\n\ndef check_token_locked(func):\n    \"\"\"\n    Decorator to check if a token is locked or not.\n    The decorator is to be used in token class methods.\n    It can be used to avoid performing an action on a locked token.\n\n    If the token is locked, a TokenAdminError is raised.\n    \"\"\"\n    @functools.wraps(func)\n    def token_locked_wrapper(*args, **kwds):\n        # The token object\n        token = args[0]\n        if token.is_locked():\n            raise TokenAdminError(_(\"This action is not possible, since the \"\n                                    \"token is locked\"), id=1007)\n        f_result = func(*args, **kwds)\n        return f_result\n\n    return token_locked_wrapper\n\n\ndef check_user_or_serial(func):\n    \"\"\"\n    Decorator to check user and serial at the beginning of a function\n    The wrapper will check the parameters user and serial and verify that\n    not both parameters are None. Otherwise it will throw an exception\n    ParameterError.\n    \"\"\"\n    @functools.wraps(func)\n    def user_or_serial_wrapper(*args, **kwds):\n        # If there is no user and serial keyword parameter and if\n        # there is no normal argument, we do not have enough information\n        serial = kwds.get(\"serial\")\n        user = kwds.get(\"user\")\n        # We have no serial! The serial would be the first arg\n        if (serial is None and (len(args) == 0 or args[0] is None) and\n                (user is None or (user is not None and user.is_empty()))):\n            # We either have an empty User object or None\n            raise ParameterError(ParameterError.USER_OR_SERIAL)\n\n        f_result = func(*args, **kwds)\n        return f_result\n\n    return user_or_serial_wrapper\n\n\nclass check_user_or_serial_in_request(object):\n    \"\"\"\n    Decorator to check user and serial in a request.\n    If the request does not contain a serial number (serial) or a user\n    (user) it will throw a ParameterError.\n    \"\"\"\n    def __init__(self, request):\n        self.request = request\n\n    def __call__(self, func):\n        @functools.wraps(func)\n        def check_user_or_serial_in_request_wrapper(*args, **kwds):\n            user = self.request.all_data.get(\"user\", \"\").strip()\n            serial = self.request.all_data.get(\"serial\", \"\").strip()\n            if not serial and not user:\n                raise ParameterError(_(\"You need to specify a serial or a user.\"))\n            if \"*\" in serial:\n                raise ParameterError(_(\"Invalid serial number.\"))\n            if \"%\" in user:\n                raise ParameterError(_(\"Invalid user.\"))\n\n            f_result = func(*args, **kwds)\n            return f_result\n\n        return check_user_or_serial_in_request_wrapper\n\n\ndef check_copy_serials(func):\n    \"\"\"\n    Decorator to check if the serial_from and serial_to exist.\n    If the serials are not unique, we raise an error\n    \"\"\"\n    from privacyidea.lib.token import get_tokens\n    @functools.wraps(func)\n    def check_serial_wrapper(*args, **kwds):\n        tokenobject_list_from = get_tokens(serial=args[0])\n        tokenobject_list_to = get_tokens(serial=args[1])\n        if len(tokenobject_list_from) != 1:\n            log.error(\"not a unique token to copy from found\")\n            raise(TokenAdminError(\"No unique token to copy from found\",\n                                   id=1016))\n        if len(tokenobject_list_to) != 1:\n            log.error(\"not a unique token to copy to found\")\n            raise(TokenAdminError(\"No unique token to copy to found\",\n                                   id=1017))\n\n        f_result = func(*args, **kwds)\n        return f_result\n\n    return check_serial_wrapper\n\n", "# -*- coding: utf-8 -*-\nfrom setuptools import setup, find_packages\nimport os\nimport stat\nimport sys\n\n#VERSION=\"2.1dev4\"\nVERSION=\"2.23.2\"\n\n# Taken from kennethreitz/requests/setup.py\npackage_directory = os.path.realpath(os.path.dirname(__file__))\n\n\ndef get_file_contents(file_path):\n    \"\"\"Get the context of the file using full path name.\"\"\"\n    content = \"\"\n    try:\n        full_path = os.path.join(package_directory, file_path)\n        content = open(full_path, 'r').read()\n    except:\n        print >> sys.stderr, \"### could not open file {0!r}\".format(file_path)\n    return content\n\ndef get_file_list(file_path):\n    full_path = os.path.join(package_directory, file_path)\n    file_list = os.listdir(full_path)\n    # now we need to add the path to the files\n    return [ file_path + f for f in file_list ]\n\n\ninstall_requires = [\"Flask>=0.10.1\",\n                    \"Flask-Migrate>=1.2.0\",\n                    \"Flask-SQLAlchemy>=2.0\",\n                    \"Flask-Script>=2.0.5\",\n                    \"Jinja2>=2.7.3\",\n                    \"Mako>=0.9.1\",\n                    \"MarkupSafe>=0.23\",\n                    \"PyMySQL>=0.6.6\",\n                    \"Pillow>=2.6.1\",\n                    \"PyJWT>=1.3.0\",\n                    \"PyYAML>=3.11\",\n                    \"Pygments>=2.0.2\",\n                    \"SQLAlchemy>=1.0.5\",\n                    \"Werkzeug>=0.10.4\",\n                    \"alembic>=0.6.7\",\n                    \"argparse>=1.2.1\",\n                    \"bcrypt>=1.1.0\",\n                    \"beautifulsoup4>=4.3.2\",\n                    \"cffi>=0.8.6\",\n                    \"configobj>=5.0.6\",\n                    \"docutils>=0.12\",\n                    \"funcparserlib>=0.3.6\",\n                    \"itsdangerous>=0.24\",\n                    \"ldap3>=2.5\",\n                    \"netaddr>=0.7.12\",\n                    \"passlib>=1.6.2\",\n                    \"pyasn1>=0.4.2\",\n                    \"pyOpenSSL>=0.15.1\",\n                    \"pycparser>=2.10\",\n                    \"pycrypto>=2.6.1\",\n                    \"pyrad>=2.0\",\n                    \"pyusb>=1.0.0b2\",\n                    \"qrcode>=5.1\",\n                    \"requests>=2.7.0\",\n                    \"sqlsoup>=0.9.0\",\n                    \"ecdsa>=0.13\",\n                    \"lxml>=3.3\",\n                    \"python-gnupg>=0.3.8\",\n                    \"defusedxml>=0.4.1\",\n                    \"flask-babel>=0.9\",\n                    \"croniter>=0.3.8\"\n                    ]\n\n# For python 2.6 we need additional dependency importlib\ntry:\n    import importlib\nexcept ImportError:\n    install_requires.append('importlib')\n\n\ndef get_man_pages(dir):\n    \"\"\"\n    Get man pages in a directory.\n    :param dir: \n    :return: list of file names\n    \"\"\"\n    files = os.listdir(dir)\n    r_files = []\n    for file in files:\n        if file.endswith(\".1\"):\n            r_files.append(dir + \"/\" + file)\n    return r_files\n\n\ndef get_scripts(dir):\n    \"\"\"\n    Get files that are executable\n    :param dir: \n    :return: list of file names\n    \"\"\"\n    files = os.listdir(dir)\n    r_files = []\n    for file in files:\n        if os.stat(dir + \"/\" + file)[stat.ST_MODE] & stat.S_IEXEC:\n            r_files.append(dir + \"/\" + file)\n    return r_files\n\n\nsetup(\n    name='privacyIDEA',\n    version=VERSION,\n    description='privacyIDEA: identity, multifactor authentication (OTP), '\n                'authorization, audit',\n    author='privacyidea.org',\n    license='AGPLv3',\n    author_email='cornelius@privacyidea.org',\n    url='http://www.privacyidea.org',\n    keywords='OTP, two factor authentication, management, security',\n    packages=find_packages(),\n    scripts=[\"pi-manage\"] + get_scripts(\"tools\"),\n    extras_require={\n        'dev': [\"Sphinx>=1.3.1\",\n                \"sphinxcontrib-httpdomain>=1.3.0\"],\n        'test': [\"coverage>=3.7.1\",\n                 \"mock>=1.0.1\",\n                 \"pyparsing>=2.0.3\",\n                 \"nose>=1.3.4\",\n                 \"responses>=0.4.0\",\n                 \"six>=1.8.0\"],\n    },\n    install_requires=install_requires,\n    include_package_data=True,\n    data_files=[('etc/privacyidea/',\n                 ['deploy/apache/privacyideaapp.wsgi',\n                  'deploy/privacyidea/dictionary',\n                  'deploy/privacyidea/enckey',\n                  'deploy/privacyidea/private.pem',\n                  'deploy/privacyidea/public.pem']),\n                ('share/man/man1', get_man_pages(\"tools\")),\n                ('lib/privacyidea/authmodules/FreeRADIUS',\n                 [\"authmodules/FreeRADIUS/LICENSE\",\n                  \"authmodules/FreeRADIUS/privacyidea_radius.pm\"]),\n               ('lib/privacyidea/authmodules/OTRS',\n                 [\"authmodules/OTRS/privacyIDEA.pm\"]),\n                ('lib/privacyidea/migrations',\n                 [\"migrations/alembic.ini\",\n                  \"migrations/env.py\",\n                  \"migrations/README\",\n                  \"migrations/script.py.mako\"]),\n                ('lib/privacyidea/migrations/versions',\n                 get_file_list(\"migrations/versions/\"))\n                ],\n    classifiers=[\"Framework :: Flask\",\n                 \"License :: OSI Approved :: \"\n                 \"GNU Affero General Public License v3\",\n                 \"Programming Language :: Python\",\n                 \"Development Status :: 5 - Production/Stable\",\n                 \"Topic :: Internet\",\n                 \"Topic :: Security\",\n                 \"Topic :: System ::\"\n                 \" Systems Administration :: Authentication/Directory\"\n                 ],\n    #message_extractors={'privacyidea': [\n    #        ('**.py', 'python', None),\n    #        ('static/**.html', 'html', {'input_encoding': 'utf-8'})]},\n    zip_safe=False,\n    long_description=get_file_contents('README.rst')\n)\n", "# -*- coding: utf-8 -*-\nfrom urllib import urlencode\nimport json\n\nfrom .base import MyTestCase\nfrom privacyidea.lib.user import (User)\nfrom privacyidea.lib.tokens.totptoken import HotpTokenClass\nfrom privacyidea.models import (Token, Challenge)\nfrom privacyidea.lib.config import (set_privacyidea_config, get_token_types,\n                                    get_inc_fail_count_on_false_pin,\n                                    delete_privacyidea_config)\nfrom privacyidea.lib.token import (get_tokens, init_token, remove_token,\n                                   reset_token, enable_token, revoke_token,\n                                   set_pin)\nfrom privacyidea.lib.policy import SCOPE, ACTION, set_policy, delete_policy\nfrom privacyidea.lib.event import set_event\nfrom privacyidea.lib.event import delete_event\nfrom privacyidea.lib.error import ERROR\nfrom privacyidea.lib.resolver import save_resolver, get_resolver_list\nfrom privacyidea.lib.realm import set_realm, set_default_realm\nfrom privacyidea.lib import _\n\nimport smtpmock, ldap3mock, responses\n\n\nPWFILE = \"tests/testdata/passwords\"\nHOSTSFILE = \"tests/testdata/hosts\"\n\nLDAPDirectory = [{\"dn\": \"cn=alice,ou=example,o=test\",\n                 \"attributes\": {'cn': 'alice',\n                                \"sn\": \"Cooper\",\n                                \"givenName\": \"Alice\",\n                                'userPassword': 'alicepw',\n                                'oid': \"2\",\n                                \"homeDirectory\": \"/home/alice\",\n                                \"email\": \"alice@test.com\",\n                                \"accountExpires\": 131024988000000000,\n                                \"objectGUID\": '\\xef6\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rM1',\n                                'mobile': [\"1234\", \"45678\"]}},\n                {\"dn\": 'cn=bob,ou=example,o=test',\n                 \"attributes\": {'cn': 'bob',\n                                \"sn\": \"Marley\",\n                                \"givenName\": \"Robert\",\n                                \"email\": \"bob@example.com\",\n                                \"mobile\": \"123456\",\n                                \"homeDirectory\": \"/home/bob\",\n                                'userPassword': 'bobpw\u00e9\u00e9\u00e9',\n                                \"accountExpires\": 9223372036854775807,\n                                \"objectGUID\": '\\xef6\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rMw',\n                                'oid': \"3\"}},\n                {\"dn\": 'cn=manager,ou=example,o=test',\n                 \"attributes\": {'cn': 'manager',\n                                \"givenName\": \"Corny\",\n                                \"sn\": \"keule\",\n                                \"email\": \"ck@o\",\n                                \"mobile\": \"123354\",\n                                'userPassword': 'ldaptest',\n                                \"accountExpires\": 9223372036854775807,\n                                \"objectGUID\": '\\xef6\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rMT',\n                                'oid': \"1\"}},\n                {\"dn\": 'cn=frank,ou=sales,o=test',\n                 \"attributes\": {'cn': 'frank',\n                                \"givenName\": \"Frank\",\n                                \"sn\": \"Hause\",\n                                \"email\": \"fh@o\",\n                                \"mobile\": \"123354\",\n                                'userPassword': 'ldaptest',\n                                \"accountExpires\": 9223372036854775807,\n                                \"objectGUID\": '\\xef7\\x9b\\x03\\xc0\\xe7\\xf3B'\n                                              '\\x9b\\xf9\\xcajl\\rMT',\n                                'oid': \"5\"}}\n                 ]\n\n\nclass AuthorizationPolicyTestCase(MyTestCase):\n    \"\"\"\n    This tests the catch all resolvers and resolvers which also contain the\n    user.\n    A user may authenticate with the default resolver, but the user may also\n    be contained in other resolver. we check these other resolvers, too.\n\n    Testcase for issue\n    https://github.com/privacyidea/privacyidea/issues/543\n    \"\"\"\n    @ldap3mock.activate\n    def test_00_create_realm(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n        params = {'LDAPURI': 'ldap://localhost',\n                  'LDAPBASE': 'o=test',\n                  'BINDDN': 'cn=manager,ou=example,o=test',\n                  'BINDPW': 'ldaptest',\n                  'LOGINNAMEATTRIBUTE': 'cn',\n                  'LDAPSEARCHFILTER': '(cn=*)',\n                  'USERINFO': '{ \"username\": \"cn\",'\n                                  '\"phone\" : \"telephoneNumber\", '\n                                  '\"mobile\" : \"mobile\"'\n                                  ', \"email\" : \"mail\", '\n                                  '\"surname\" : \"sn\", '\n                                  '\"givenname\" : \"givenName\" }',\n                  'UIDTYPE': 'DN',\n                  \"resolver\": \"catchall\",\n                  \"type\": \"ldapresolver\"}\n\n        r = save_resolver(params)\n        self.assertTrue(r > 0)\n\n        params = {'LDAPURI': 'ldap://localhost',\n                  'LDAPBASE': 'ou=sales,o=test',\n                  'BINDDN': 'cn=manager,ou=example,o=test',\n                  'BINDPW': 'ldaptest',\n                  'LOGINNAMEATTRIBUTE': 'cn',\n                  'LDAPSEARCHFILTER': '(cn=*)',\n                  'USERINFO': '{ \"username\": \"cn\",'\n                              '\"phone\" : \"telephoneNumber\", '\n                              '\"mobile\" : \"mobile\"'\n                              ', \"email\" : \"mail\", '\n                              '\"surname\" : \"sn\", '\n                              '\"givenname\" : \"givenName\" }',\n                  'UIDTYPE': 'DN',\n                  \"resolver\": \"sales\",\n                  \"type\": \"ldapresolver\"}\n\n        r = save_resolver(params)\n        self.assertTrue(r > 0)\n\n        rl = get_resolver_list()\n        self.assertTrue(\"catchall\" in rl)\n        self.assertTrue(\"sales\" in rl)\n\n    @ldap3mock.activate\n    def test_01_resolving_user(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n        # create realm\n        # If the sales resolver comes first, frank is found in sales!\n        r = set_realm(\"ldaprealm\", resolvers=[\"catchall\", \"sales\"],\n                      priority={\"catchall\": 2, \"sales\": 1})\n        set_default_realm(\"ldaprealm\")\n        self.assertEqual(r, ([\"catchall\", \"sales\"], []))\n\n        u = User(\"alice\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"catchall\")\n        u = User(\"frank\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"sales\")\n\n        # Catch all has the lower priority and contains all users\n        # ldap2 only contains sales\n        r = set_realm(\"ldaprealm\", resolvers=[\"catchall\", \"sales\"],\n                      priority={\"catchall\": 1, \"sales\": 2})\n        self.assertEqual(r, ([\"catchall\", \"sales\"], []))\n\n        # Both users are found in the resolver \"catchall\n        u = User(\"alice\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"catchall\")\n        u = User(\"frank\", \"ldaprealm\")\n        uid, rtype, resolver = u.get_user_identifiers()\n        self.assertEqual(resolver, \"catchall\")\n\n    @ldap3mock.activate\n    def test_02_enroll_tokens(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n        r = init_token({\"type\": \"spass\", \"pin\": \"spass\"}, user=User(\n            login=\"alice\", realm=\"ldaprealm\"))\n        self.assertTrue(r)\n        # The token gets assigned to frank in the resolver catchall\n        r = init_token({\"type\": \"spass\", \"pin\": \"spass\"}, user=User(\n            login=\"frank\", realm=\"ldaprealm\"))\n        self.assertTrue(r)\n        self.assertEqual(\"{0!s}\".format(r.user), \"<frank.catchall@ldaprealm>\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"frank\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\"))\n            self.assertTrue(result.get(\"value\"))\n\n    @ldap3mock.activate\n    def test_03_classic_policies(self):\n        ldap3mock.setLDAPDirectory(LDAPDirectory)\n\n        # This policy will not match, since frank is in resolver \"catchall\".\n        set_policy(name=\"HOTPonly\",\n                   action=\"tokentype=spass\",\n                   scope=SCOPE.AUTHZ,\n                   resolver=\"sales\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"frank\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\"))\n            self.assertTrue(result.get(\"value\"))\n\n        # If users in resolver sales are required to use HOTP, then frank still\n        # can login with a SPASS token, since he is identified as user in\n        # resolver catchall\n        set_policy(name=\"HOTPonly\",\n                   action=\"tokentype=hotp\",\n                   scope=SCOPE.AUTHZ,\n                   resolver=\"sales\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"frank\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n\n        # Alice - not in sales - is allowed to login\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"alice\",\n                                                 \"pass\": \"spass\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\"))\n            self.assertTrue(result.get(\"value\"))\n\n\nclass DisplayTANTestCase(MyTestCase):\n\n    def test_00_run_complete_workflow(self):\n        # This is a standard workflow of a display TAN token.\n\n        # Import OCRA Token file\n        IMPORTFILE = \"tests/testdata/ocra.csv\"\n        with self.app.test_request_context('/token/load/ocra.csv',\n                                            method=\"POST\",\n                                            data={\"type\": \"oathcsv\",\n                                                  \"file\": (IMPORTFILE,\n                                                           \"oath.csv\")},\n                                            headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            value = result.get(\"value\")\n            self.assertTrue(value == 1, result)\n\n        from privacyidea.lib.token import set_pin\n        set_pin(\"ocra1234\", \"test\")\n\n        # Issue a challenge response\n        challenge = \"83507112  ~320,00~1399458665_G6HNVF\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": \"test\",\n                                                 \"hashchallenge\": 1,\n                                                 \"challenge\": challenge}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            hex_challenge = detail.get(\"attributes\").get(\"challenge\")\n            self.assertEqual(hex_challenge, \"7196501689c356046867728f4feb74458dcfd079\")\n\n        # Issue an authentication request\n        otpvalue = \"90065298\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": otpvalue,\n                                                 \"transaction_id\":\n                                                     transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n\n        # The second request will fail\n        otpvalue = \"90065298\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": otpvalue,\n                                                 \"transcation_id\":\n                                                     transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n\n        # Get another challenge with a random nonce\n        challenge = \"83507112  ~320,00~\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"ocra1234\",\n                                                 \"pass\": \"test\",\n                                                 \"hashchallenge\": 1,\n                                                 \"addrandomchallenge\": 20,\n                                                 \"challenge\": challenge}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            hex_challenge = detail.get(\"attributes\").get(\"challenge\")\n            self.assertEqual(len(hex_challenge), 40)\n\n        remove_token(\"ocra1234\")\n\n\nclass AValidateOfflineTestCase(MyTestCase):\n    \"\"\"\n    Test api.validate endpoints that are responsible for offline auth.\n    \"\"\"\n    def test_00_create_realms(self):\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n\n        # create a  token and assign it to the user\n        db_token = Token(self.serials[0], tokentype=\"hotp\")\n        db_token.update_otpkey(self.otpkey)\n        db_token.save()\n        token = HotpTokenClass(db_token)\n        self.assertTrue(token.token.serial == self.serials[0], token)\n        token.set_user(User(\"cornelius\", self.realm1))\n        token.set_pin(\"pin\")\n        self.assertTrue(token.token.user_id == \"1000\", token.token.user_id)\n\n    def test_01_validate_offline(self):\n        pass\n        # create offline app\n        #tokenobj = get_tokens(self.serials[0])[0]\n        from privacyidea.lib.applications.offline import REFILLTOKEN_LENGTH\n        from privacyidea.lib.machine import attach_token, detach_token\n        from privacyidea.lib.machineresolver import save_resolver, delete_resolver\n        mr_obj = save_resolver({\"name\": \"testresolver\",\n                                \"type\": \"hosts\",\n                                \"filename\": HOSTSFILE,\n                                \"type.filename\": \"string\",\n                                \"desc.filename\": \"the filename with the \"\n                                                 \"hosts\",\n                                \"pw\": \"secret\",\n                                \"type.pw\": \"password\"})\n        self.assertTrue(mr_obj > 0)\n        # Attach the offline app to pippin\n        r = attach_token(self.serials[0], \"offline\", hostname=\"pippin\",\n                         resolver_name=\"testresolver\")\n\n        # first online validation\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin287082\"},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            result = data.get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"otplen\"), 6)\n            auth_items = json.loads(res.data).get(\"auth_items\")\n            offline = auth_items.get(\"offline\")[0]\n            # Check the number of OTP values\n            self.assertEqual(len(offline.get(\"response\")), 100)\n            self.assertEqual(offline.get(\"username\"), \"cornelius\")\n            refilltoken_1 = offline.get(\"refilltoken\")\n            self.assertEqual(len(refilltoken_1), 2 * REFILLTOKEN_LENGTH)\n            # check the token counter\n            tok = get_tokens(serial=self.serials[0])[0]\n            self.assertEqual(tok.token.count, 102)\n\n        # first refill with the 5th value\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin338314\",\n                                                 \"refilltoken\": refilltoken_1},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            auth_items = json.loads(res.data).get(\"auth_items\")\n            offline = auth_items.get(\"offline\")[0]\n            # Check the number of OTP values\n            self.assertEqual(len(offline.get(\"response\")), 3)\n            self.assertTrue(\"102\" in offline.get(\"response\"))\n            self.assertTrue(\"103\" in offline.get(\"response\"))\n            self.assertTrue(\"104\" in offline.get(\"response\"))\n            refilltoken_2 = offline.get(\"refilltoken\")\n            self.assertEqual(len(refilltoken_2), 2 * REFILLTOKEN_LENGTH)\n            # check the token counter\n            tok = get_tokens(serial=self.serials[0])[0]\n            self.assertEqual(tok.token.count, 105)\n            # The refilltoken changes each time\n            self.assertNotEqual(refilltoken_1, refilltoken_2)\n\n        # refill with wrong refill token fails\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin520489\",\n                                                 \"refilltoken\": 'a' * 2 * REFILLTOKEN_LENGTH},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            data = json.loads(res.data)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR905: Token is not an offline token or refill token is incorrect\")\n\n        # 2nd refill with 10th value\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin520489\",\n                                                 \"refilltoken\": refilltoken_2},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            auth_items = json.loads(res.data).get(\"auth_items\")\n            offline = auth_items.get(\"offline\")[0]\n            # Check the number of OTP values\n            self.assertEqual(len(offline.get(\"response\")), 5)\n            self.assertTrue(\"105\" in offline.get(\"response\"))\n            self.assertTrue(\"106\" in offline.get(\"response\"))\n            self.assertTrue(\"107\" in offline.get(\"response\"))\n            self.assertTrue(\"108\" in offline.get(\"response\"))\n            self.assertTrue(\"109\" in offline.get(\"response\"))\n            refilltoken_3 = offline.get(\"refilltoken\")\n            self.assertEqual(len(refilltoken_3), 2 * REFILLTOKEN_LENGTH)\n            # check the token counter\n            tok = get_tokens(serial=self.serials[0])[0]\n            self.assertEqual(tok.token.count, 110)\n            # The refilltoken changes each time\n            self.assertNotEqual(refilltoken_2, refilltoken_3)\n            self.assertNotEqual(refilltoken_1, refilltoken_3)\n\n        # A refill with a totally wrong OTP value fails\n        token_obj = get_tokens(serial=self.serials[0])[0]\n        old_counter = token_obj.token.count\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin000000\",\n                                                 \"refilltoken\": refilltoken_3},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            data = json.loads(res.data)\n            self.assertTrue(res.status_code == 400, res)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR401: You provided a wrong OTP value.\")\n        # The failed refill should not modify the token counter!\n        self.assertEqual(old_counter, token_obj.token.count)\n\n        # A refill with a wrong serial number fails\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": 'ABCDEF123',\n                                                 \"pass\": \"pin000000\",\n                                                 \"refilltoken\": refilltoken_3},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            data = json.loads(res.data)\n            self.assertTrue(res.status_code == 400, res)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR905: The token does not exist\")\n\n        # Detach the token, refill should then fail\n        r = detach_token(self.serials[0], \"offline\", \"pippin\")\n        with self.app.test_request_context('/validate/offlinerefill',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin520489\",\n                                                 \"refilltoken\": refilltoken_3},\n                                           environ_base={'REMOTE_ADDR': '192.168.0.2'}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            data = json.loads(res.data)\n            self.assertTrue(res.status_code == 400, res)\n            self.assertEqual(data.get(\"result\").get(\"error\").get(\"message\"),\n                             u\"ERR905: Token is not an offline token or refill token is incorrect\")\n\n\nclass ValidateAPITestCase(MyTestCase):\n    \"\"\"\n    test the api.validate endpoints\n    \"\"\"\n\n    def test_00_create_realms(self):\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n\n        # create a  token and assign it to the user\n        db_token = Token(self.serials[0], tokentype=\"hotp\")\n        db_token.update_otpkey(self.otpkey)\n        db_token.save()\n        token = HotpTokenClass(db_token)\n        self.assertTrue(token.token.serial == self.serials[0], token)\n        token.set_user(User(\"cornelius\", self.realm1))\n        token.set_pin(\"pin\")\n        self.assertTrue(token.token.user_id == \"1000\", token.token.user_id)\n\n    def test_02_validate_check(self):\n        # is the token still assigned?\n        tokenbject_list = get_tokens(serial=self.serials[0])\n        tokenobject = tokenbject_list[0]\n        self.assertTrue(tokenobject.token.user_id == \"1000\",\n                        tokenobject.token.user_id)\n\n        \"\"\"                  Truncated\n           Count    Hexadecimal    Decimal        HOTP\n           0        4c93cf18       1284755224     755224\n           1        41397eea       1094287082     287082\n           2         82fef30        137359152     359152\n           3        66ef7655       1726969429     969429\n           4        61c5938a       1640338314     338314\n           5        33c083d4        868254676     254676\n           6        7256c032       1918287922     287922\n           7         4e5b397         82162583     162583\n           8        2823443f        673399871     399871\n           9        2679dc69        645520489     520489\n        \"\"\"\n        # test for missing parameter user\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        # test for missing parameter serial\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        # test for missing parameter \"pass\"\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n    def test_03_check_user(self):\n        # get the original counter\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        count_1 = hotp_tokenobject.token.count\n\n        # test successful authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"otplen\"), 6)\n\n        # Check that the counter is increased!\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        count_2 = hotp_tokenobject.token.count\n        self.assertTrue(count_2 > count_1, (hotp_tokenobject.token.serial,\n                                            hotp_tokenobject.token.count,\n                                            count_1,\n                                            count_2))\n\n        # test authentication fails with the same OTP\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n\n    def test_03a_check_user_get(self):\n        # Reset the counter!\n        count_1 = 0\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        hotp_tokenobject.token.count = count_1\n        hotp_tokenobject.token.save()\n\n        # test successful authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='GET',\n                                           query_string=urlencode(\n                                                    {\"user\": \"cornelius\",\n                                                     \"pass\": \"pin287082\"})):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"otplen\"), 6)\n\n        # Check that the counter is increased!\n        tokenobject_list = get_tokens(serial=self.serials[0])\n        hotp_tokenobject = tokenobject_list[0]\n        count_2 = hotp_tokenobject.token.count\n        self.assertTrue(count_2 > count_1, (hotp_tokenobject.token.serial,\n                                            hotp_tokenobject.token.count,\n                                            count_1,\n                                            count_2))\n\n        # test authentication fails with the same OTP\n        with self.app.test_request_context('/validate/check',\n                                           method='GET',\n                                           query_string=urlencode(\n                                                    {\"user\": \"cornelius\",\n                                                     \"pass\": \"pin287082\"})):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n\n    def test_04_check_serial(self):\n        # test authentication successful with serial\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin969429\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is True, result)\n\n        # test authentication fails with serial with same OTP\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": self.serials[0],\n                                                 \"pass\": \"pin969429\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            details = json.loads(res.data).get(\"detail\")\n            self.assertTrue(result.get(\"status\") is True, result)\n            self.assertTrue(result.get(\"value\") is False, result)\n            self.assertEqual(details.get(\"message\"), \"wrong otp value. \"\n                                                     \"previous otp used again\")\n\n    def test_05_check_serial_with_no_user(self):\n        # Check a token per serial when the token has no user assigned.\n        init_token({\"serial\": \"nouser\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"pin\"})\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"nouser\",\n                                                 \"pass\": \"pin359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            details = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"status\"), True)\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_05_check_serial_with_no_user(self):\n        # Check a token per serial when the token has no user assigned.\n        init_token({\"serial\": \"nouser\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"pin\"})\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"nouser\",\n                                                 \"pass\": \"pin359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            details = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"status\"), True)\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_05a_check_otp_only(self):\n        # Check the OTP of the token without PIN\n        init_token({\"serial\": \"otponly\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"pin\"})\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"otponly\",\n                                                 \"otponly\": \"1\",\n                                                 \"pass\": \"359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"status\"), True)\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_06_fail_counter(self):\n        # test if a user has several tokens that the fail counter is increased\n        # reset the failcounter\n        reset_token(serial=\"SE1\")\n        init_token({\"serial\": \"s2\",\n                    \"genkey\": 1,\n                    \"pin\": \"test\"}, user=User(\"cornelius\", self.realm1))\n        init_token({\"serial\": \"s3\",\n                    \"genkey\": 1,\n                    \"pin\": \"test\"}, user=User(\"cornelius\", self.realm1))\n        # Now the user cornelius has 3 tokens.\n        # SE1 with pin \"pin\"\n        # token s2 with pin \"test\" and\n        # token s3 with pin \"test\".\n\n        self.assertTrue(get_inc_fail_count_on_false_pin())\n        # We give an OTP PIN that does not match any token.\n        # The failcounter of all tokens will be increased\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"XXXX123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n\n        # Now we give the matching OTP PIN of one token.\n        # Only one failcounter will be increased\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"serial\"), \"SE1\")\n            self.assertEqual(detail.get(\"message\"), \"wrong otp value\")\n\n        # Only the failcounter of SE1 (the PIN matching token) is increased!\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 2)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n\n        set_privacyidea_config(\"IncFailCountOnFalsePin\", False)\n        self.assertFalse(get_inc_fail_count_on_false_pin())\n        reset_token(serial=\"SE1\")\n        reset_token(serial=\"s2\")\n        reset_token(serial=\"s3\")\n        # If we try to authenticate with an OTP PIN that does not match any\n        # token NO failcounter is increased!\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"XXXX123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n\n        # Now we give the matching OTP PIN of one token.\n        # Only one failcounter will be increased\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"serial\"), \"SE1\")\n            self.assertEqual(detail.get(\"message\"), \"wrong otp value\")\n\n        # Only the failcounter of SE1 (the PIN matching token) is increased!\n        tok = get_tokens(serial=\"SE1\")[0]\n        self.assertEqual(tok.token.failcount, 1)\n        tok = get_tokens(serial=\"s2\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n        tok = get_tokens(serial=\"s3\")[0]\n        self.assertEqual(tok.token.failcount, 0)\n\n    def test_07_authentication_counter_exceeded(self):\n        token_obj = init_token({\"serial\": \"pass1\", \"pin\": \"123456\",\n                                \"type\": \"spass\"})\n        token_obj.set_count_auth_max(5)\n\n        for i in range(1, 5):\n            with self.app.test_request_context('/validate/check',\n                                               method='POST',\n                                               data={\"serial\": \"pass1\",\n                                                     \"pass\": \"123456\"}):\n                res = self.app.full_dispatch_request()\n                self.assertTrue(res.status_code == 200, res)\n                result = json.loads(res.data).get(\"result\")\n                self.assertEqual(result.get(\"value\"), True)\n\n        # The 6th authentication will fail\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"pass1\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"value\"), False)\n            self.assertTrue(\"Authentication counter exceeded\"\n                            in detail.get(\"message\"))\n\n    def test_08_failcounter_counter_exceeded(self):\n        token_obj = init_token({\"serial\": \"pass2\", \"pin\": \"123456\",\n                                \"type\": \"spass\"})\n        token_obj.set_maxfail(5)\n        token_obj.set_failcount(5)\n        # a valid authentication will fail\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"pass2\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(result.get(\"value\"), False)\n            self.assertEqual(detail.get(\"message\"), \"matching 1 tokens, \"\n                                                    \"Failcounter exceeded\")\n\n    def test_10_saml_check(self):\n        # test successful authentication\n        set_privacyidea_config(\"ReturnSamlAttributes\", \"0\")\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin338314\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), True)\n            # No SAML return attributes\n            self.assertEqual(attributes.get(\"email\"), None)\n\n        set_privacyidea_config(\"ReturnSamlAttributes\", \"1\")\n\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin254676\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), True)\n            self.assertEqual(attributes.get(\"email\"),\n                             \"user@localhost.localdomain\")\n            self.assertEqual(attributes.get(\"givenname\"), \"Cornelius\")\n            self.assertEqual(attributes.get(\"mobile\"), \"+491111111\")\n            self.assertEqual(attributes.get(\"phone\"),  \"+491234566\")\n            self.assertEqual(attributes.get(\"realm\"),  \"realm1\")\n            self.assertEqual(attributes.get(\"username\"),  \"cornelius\")\n\n        # Return SAML attributes On Fail\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin254676\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), False)\n            self.assertEqual(attributes.get(\"email\"), None)\n            self.assertEqual(attributes.get(\"givenname\"), None)\n            self.assertEqual(attributes.get(\"mobile\"), None)\n            self.assertEqual(attributes.get(\"phone\"), None)\n            self.assertEqual(attributes.get(\"realm\"), None)\n            self.assertEqual(attributes.get(\"username\"), None)\n\n        set_privacyidea_config(\"ReturnSamlAttributesOnFail\", \"1\")\n        with self.app.test_request_context('/validate/samlcheck',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"pin254676\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            value = result.get(\"value\")\n            attributes = value.get(\"attributes\")\n            self.assertEqual(value.get(\"auth\"), False)\n            self.assertEqual(attributes.get(\"email\"),\n                             \"user@localhost.localdomain\")\n            self.assertEqual(attributes.get(\"givenname\"), \"Cornelius\")\n            self.assertEqual(attributes.get(\"mobile\"), \"+491111111\")\n            self.assertEqual(attributes.get(\"phone\"), \"+491234566\")\n            self.assertEqual(attributes.get(\"realm\"), \"realm1\")\n            self.assertEqual(attributes.get(\"username\"), \"cornelius\")\n\n    def test_11_challenge_response_hotp(self):\n        # set a chalresp policy for HOTP\n        with self.app.test_request_context('/policy/pol_chal_resp',\n                                           data={'action':\n                                                     \"challenge_response=hotp\",\n                                                 'scope': \"authentication\",\n                                                 'realm': '',\n                                                 'active': True},\n                                           method='POST',\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result[\"status\"] is True, result)\n            self.assertTrue('\"setPolicy pol_chal_resp\": 1' in res.data,\n                            res.data)\n\n        serial = \"CHALRESP1\"\n        pin = \"chalresp1\"\n        # create a token and assign to the user\n        db_token = Token(serial, tokentype=\"hotp\")\n        db_token.update_otpkey(self.otpkey)\n        db_token.save()\n        token = HotpTokenClass(db_token)\n        token.set_user(User(\"cornelius\", self.realm1))\n        token.set_pin(pin)\n        # Set the failcounter\n        token.set_failcount(5)\n        # create the challenge by authenticating with the OTP PIN\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertEqual(detail.get(\"message\"), _(\"please enter otp: \"))\n            transaction_id = detail.get(\"transaction_id\")\n        self.assertEqual(token.get_failcount(), 5)\n\n        # send the OTP value\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": \"359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertTrue(result.get(\"value\"))\n\n        self.assertEqual(token.get_failcount(), 0)\n        # delete the token\n        remove_token(serial=serial)\n\n    def test_12_challenge_response_sms(self):\n        # set a chalresp policy for SMS\n        with self.app.test_request_context('/policy/pol_chal_resp',\n                                           data={'action':\n                                                     \"challenge_response=sms\",\n                                                 'scope': \"authentication\",\n                                                 'realm': '',\n                                                 'active': True},\n                                           method='POST',\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result[\"status\"] is True, result)\n            self.assertTrue('\"setPolicy pol_chal_resp\": 1' in res.data,\n                            res.data)\n\n        serial = \"CHALRESP2\"\n        pin = \"chalresp2\"\n        # create a token and assign to the user\n        init_token({\"serial\": serial,\n                    \"type\": \"sms\",\n                    \"otpkey\": self.otpkey,\n                    \"phone\": \"123456\",\n                    \"pin\": pin}, user=User(\"cornelius\", self.realm1))\n        # create the challenge by authenticating with the OTP PIN\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertTrue(\"The PIN was correct, \"\n                            \"but the SMS could not be sent\" in\n                            detail.get(\"message\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # disable the token. The detail->message should be empty\n        r = enable_token(serial=serial, enable=False)\n        self.assertEqual(r, True)\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertEqual(detail.get(\"message\"),\n                             \"No active challenge response token found\")\n\n        # delete the token\n        remove_token(serial=serial)\n\n    @smtpmock.activate\n    def test_13_challenge_response_email(self):\n        smtpmock.setdata(response={\"hans@dampf.com\": (200, 'OK')})\n        # set a chalresp policy for Email\n        with self.app.test_request_context('/policy/pol_chal_resp',\n                                           data={'action':\n                                                     \"challenge_response=email\",\n                                                 'scope': \"authentication\",\n                                                 'realm': '',\n                                                 'active': True},\n                                           method='POST',\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result[\"status\"] is True, result)\n            self.assertTrue('\"setPolicy pol_chal_resp\": 1' in res.data,\n                            res.data)\n\n        serial = \"CHALRESP3\"\n        pin = \"chalresp3\"\n        # create a token and assign to the user\n        init_token({\"serial\": serial,\n                    \"type\": \"email\",\n                    \"otpkey\": self.otpkey,\n                    \"email\": \"hans@dampf.com\",\n                    \"pin\": pin}, user=User(\"cornelius\", self.realm1))\n        # create the challenge by authenticating with the OTP PIN\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertFalse(result.get(\"value\"))\n            self.assertEqual(detail.get(\"message\"), _(\"Enter the OTP from the Email:\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # send the OTP value\n        # Test with parameter state.\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"state\":\n                                                     transaction_id,\n                                                 \"pass\": \"359152\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertTrue(result.get(\"value\"))\n\n        # delete the token\n        remove_token(serial=serial)\n\n    def test_14_check_validity_period(self):\n        serial = \"VP001\"\n        password = serial\n        init_token({\"serial\": serial,\n                    \"type\": \"spass\",\n                    \"pin\": password}, user=User(\"cornelius\", self.realm1))\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": password}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n        # Set validity period\n        token_obj = get_tokens(serial=serial)[0]\n        token_obj.set_validity_period_end(\"2015-01-01T10:00+0200\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": password}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"value\"))\n            details = json.loads(res.data).get(\"detail\")\n            self.assertTrue(\"Outside validity period\" in details.get(\"message\"))\n\n        token_obj.set_validity_period_end(\"1999-01-01T10:00+0200\")\n        token_obj.set_validity_period_start(\"1998-01-01T10:00+0200\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": password}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"value\"))\n            details = json.loads(res.data).get(\"detail\")\n            self.assertTrue(\"Outside validity period\" in details.get(\"message\"))\n\n        # delete the token\n        remove_token(serial=\"VP001\")\n\n    def test_15_validate_at_sign(self):\n        serial1 = \"Split001\"\n        serial2 = \"Split002\"\n        init_token({\"serial\": serial1,\n                    \"type\": \"spass\",\n                    \"pin\": serial1}, user=User(\"cornelius\", self.realm1))\n\n        init_token({\"serial\": serial2,\n                    \"type\": \"spass\",\n                    \"pin\": serial2}, user=User(\"cornelius\", self.realm2))\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": serial1}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n        set_privacyidea_config(\"splitAtSign\", \"0\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": serial2}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        set_privacyidea_config(\"splitAtSign\", \"1\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": serial2}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n        # The default behaviour - if the config entry does not exist,\n        # is to split the @Sign\n        delete_privacyidea_config(\"splitAtSign\")\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": serial2}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertTrue(result.get(\"value\"))\n\n    def test_16_autoresync_hotp(self):\n        serial = \"autosync1\"\n        token = init_token({\"serial\": serial,\n                            \"otpkey\": self.otpkey,\n                            \"pin\": \"async\"}, User(\"cornelius\", self.realm2))\n        set_privacyidea_config(\"AutoResync\", True)\n        token.set_sync_window(10)\n        token.set_count_window(5)\n        # counter = 8, is out of sync\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": \"async399871\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n\n        # counter = 9, will be autosynced.\n        # Authentication is successful\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\":\n                                                    \"cornelius@\"+self.realm2,\n                                                 \"pass\": \"async520489\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_privacyidea_config(\"AutoResync\")\n\n    def test_17_auth_timelimit_success(self):\n        user = User(\"timelimituser\", realm=self.realm2)\n        pin = \"spass\"\n        # create a token\n        token = init_token({\"type\": \"spass\",\n                            \"pin\": pin}, user=user)\n\n        # set policy for timelimit\n        set_policy(name=\"pol_time1\",\n                   scope=SCOPE.AUTHZ,\n                   action=\"{0!s}=2/20s\".format(ACTION.AUTHMAXSUCCESS))\n\n        for i in [1, 2]:\n            with self.app.test_request_context('/validate/check',\n                                               method='POST',\n                                               data={\"user\": \"timelimituser\",\n                                                     \"realm\": self.realm2,\n                                                     \"pass\": pin}):\n                res = self.app.full_dispatch_request()\n                self.assertTrue(res.status_code == 200, res)\n                result = json.loads(res.data).get(\"result\")\n                self.assertEqual(result.get(\"value\"), True)\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"timelimituser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n\n        delete_policy(\"pol_time1\")\n        remove_token(token.token.serial)\n\n    def test_18_auth_timelimit_fail(self):\n        user = User(\"timelimituser\", realm=self.realm2)\n        pin = \"spass\"\n        # create a token\n        token = init_token({\"type\": \"spass\", \"pin\": pin}, user=user)\n\n        # set policy for timelimit\n        set_policy(name=\"pol_time1\",\n                   scope=SCOPE.AUTHZ,\n                   action=\"{0!s}=2/20s\".format(ACTION.AUTHMAXFAIL))\n\n        for i in [1, 2]:\n            with self.app.test_request_context('/validate/check',\n                                               method='POST',\n                                               data={\"user\": \"timelimituser\",\n                                                     \"realm\": self.realm2,\n                                                     \"pass\": \"wrongpin\"}):\n                res = self.app.full_dispatch_request()\n                self.assertTrue(res.status_code == 200, res)\n                result = json.loads(res.data).get(\"result\")\n                self.assertEqual(result.get(\"value\"), False)\n\n        # Now we do the correct authentication, but\n        # as already two authentications failed, this will fail, too\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"timelimituser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            details = json.loads(res.data).get(\"detail\")\n            self.assertEqual(details.get(\"message\"),\n                             \"Only 2 failed authentications per 0:00:20\")\n\n        delete_policy(\"pol_time1\")\n        remove_token(token.token.serial)\n\n    def test_19_validate_passthru(self):\n        # user passthru, realm: self.realm2, passwd: pthru\n        set_policy(name=\"pthru\", scope=SCOPE.AUTH, action=ACTION.PASSTHRU)\n\n        # Passthru with GET request\n        with self.app.test_request_context(\n                '/validate/check',\n                method='GET',\n                query_string=urlencode({\"user\": \"passthru\",\n                                        \"realm\": self.realm2,\n                                        \"pass\": \"pthru\"})):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # Passthru with POST Request\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"passthru\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"pthru\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # Test if the policies \"reset_all_tokens\" and \"passthru\" work out fine at the same time\n        set_policy(name=\"reset_all_tokens\", scope=SCOPE.AUTH, action=ACTION.RESETALLTOKENS)\n        # Passthru with POST Request\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"passthru\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"pthru\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_policy(\"reset_all_tokens\")\n        delete_policy(\"pthru\")\n\n    def test_20_questionnaire(self):\n        pin = \"pin\"\n        serial = \"QUST1234\"\n        questions = {\"frage1\": \"antwort1\",\n                     \"frage2\": \"antwort2\",\n                     \"frage3\": \"antwort3\"}\n        j_questions = json.dumps(questions)\n\n        with self.app.test_request_context('/token/init',\n                                           method='POST',\n                                           data={\"type\": \"question\",\n                                                 \"pin\": pin,\n                                                 \"serial\": serial,\n                                                 \"questions\": j_questions},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n\n        set_privacyidea_config(\"question.num_answers\", 2)\n        with self.app.test_request_context('/token/init',\n                                           method='POST',\n                                           data={\"type\": \"question\",\n                                                 \"pin\": pin,\n                                                 \"serial\": serial,\n                                                 \"questions\": j_questions},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            value = result.get(\"value\")\n            self.assertEqual(value, True)\n\n        # Start a challenge\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": serial,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"value\"))\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            question = detail.get(\"message\")\n            self.assertTrue(question in questions)\n\n        # Respond to the challenge\n        answer = questions[question]\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": serial,\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": answer}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n    def test_21_validate_disabled(self):\n        # test a user with two tokens and otppin=userstore.\n        # One token is disabled. But the user must be able to login with the\n        # 2nd token\n        # user disableduser, realm: self.realm2, passwd: superSecret\n        set_policy(name=\"disabled\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0!s}={1!s}\".format(ACTION.OTPPIN, \"userstore\"))\n        # enroll two tokens\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass1d\"},\n                       user=User(\"disableduser\", self.realm2))\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass2d\"},\n                       user=User(\"disableduser\", self.realm2))\n        # disable first token\n        r = enable_token(\"spass1d\", False)\n        self.assertEqual(r, True)\n        # Check that the user still can authenticate with the 2nd token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"disableduser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"superSecret\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # disable 2nd token\n        r = enable_token(\"spass2d\", False)\n        r = enable_token(\"spass1d\")\n        self.assertEqual(r, True)\n        # Check that the user still can authenticate with the first token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"disableduser\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"superSecret\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_policy(\"disabled\")\n\n    def test_22_validate_locked(self):\n        # test a user with two tokens\n        # One token is locked/revoked.\n        #  But the user must be able to login with the 2nd token\n        # user lockeduser, realm: self.realm2\n        # enroll two tokens\n        user = \"lockeduser\"\n        set_policy(name=\"locked\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0!s}={1!s}\".format(ACTION.OTPPIN, \"tokenpin\"))\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass1l\",\n                        \"pin\": \"locked\"},\n                       user=User(user, self.realm2))\n        r = init_token({\"type\": \"spass\", \"serial\": \"spass2l\",\n                        \"pin\": \"locked\"},\n                       user=User(user, self.realm2))\n        # disable first token\n        r = revoke_token(\"spass1l\")\n        self.assertEqual(r, True)\n        # Check that the user still can authenticate with the 2nd token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"locked\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        remove_token(\"spass1l\")\n        remove_token(\"spass2l\")\n        delete_policy(\"locked\")\n\n    def test_23_pass_no_user_and_pass_no_token(self):\n        # Test with pass_no_user AND with pass_no_token.\n        user = \"passthru\"\n        user_no_token = \"usernotoken\"\n        pin = \"mypin\"\n        serial = \"t23\"\n        set_policy(name=\"pass_no\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0!s},{1!s}\".format(ACTION.PASSNOTOKEN,\n                                               ACTION.PASSNOUSER))\n\n        r = init_token({\"type\": \"spass\", \"serial\": serial,\n                        \"pin\": pin}, user=User(user, self.realm2))\n        self.assertTrue(r)\n\n        r = get_tokens(user=User(user, self.realm2), count=True)\n        self.assertEqual(r, 1)\n        # User can authenticate with his SPASS token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"serial\"), serial)\n\n        # User that does not exist, can authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"doesNotExist\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u\"user does not exist, accepted \"\n                             u\"due to 'pass_no'\")\n\n        # Creating a notification event. The non-existing user must\n        # still be able to pass!\n        eid = set_event(\"notify\", event=[\"validate_check\"], action=\"sendmail\",\n                  handlermodule=\"UserNotification\", conditions={\"token_locked\": True})\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"doesNotExist\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u\"user does not exist, accepted \"\n                             u\"due to 'pass_no'\")\n\n        delete_event(eid)\n\n        r = get_tokens(user=User(user, self.realm2), count=True)\n        self.assertEqual(r, 1)\n        # User with no token can authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user_no_token,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u\"user has no token, \"\n                             u\"accepted due to 'pass_no'\")\n\n        r = get_tokens(user=User(user, self.realm2), count=True)\n        self.assertEqual(r, 1)\n\n        # user with wrong password fails to authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": \"wrongPiN\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             \"wrong otp pin\")\n\n        delete_policy(\"pass_no\")\n        remove_token(serial)\n\n        # User that does not exist, can NOT authenticate after removing the\n        # policy\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"doesNotExist\",\n                                                 \"realm\": self.realm2,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail, None)\n\n    def test_23a_pass_no_user_resolver(self):\n        # Now we set a policy, that a non existing user will authenticate\n        set_policy(name=\"pol1\",\n                   scope=SCOPE.AUTH,\n                   action=\"{0}, {1}, {2}, {3}=none\".format(\n                       ACTION.RESETALLTOKENS,\n                       ACTION.PASSNOUSER,\n                       ACTION.PASSNOTOKEN,\n                       ACTION.OTPPIN\n                   ),\n                   realm=self.realm1)\n        # Check that the non existing user MisterX is allowed to authenticate\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"MisterX\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": \"secret\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"message\"),\n                             u'user does not exist, accepted due to \\'pol1\\'')\n        delete_policy(\"pol1\")\n\n    @responses.activate\n    def test_24_trigger_challenge(self):\n        from privacyidea.lib.smsprovider.SMSProvider import set_smsgateway\n        from privacyidea.lib.config import set_privacyidea_config\n        post_url = \"http://smsgateway.com/sms_send_api.cgi\"\n        success_body = \"ID 12345\"\n\n        identifier = \"myGW\"\n        provider_module = \"privacyidea.lib.smsprovider.HttpSMSProvider\" \\\n                          \".HttpSMSProvider\"\n        id = set_smsgateway(identifier, provider_module, description=\"test\",\n                            options={\"HTTP_METHOD\": \"POST\",\n                                     \"URL\": post_url,\n                                     \"RETURN_SUCCESS\": \"ID\",\n                                     \"text\": \"{otp}\",\n                                     \"phone\": \"{phone}\"})\n        self.assertTrue(id > 0)\n        # set config sms.identifier = myGW\n        r = set_privacyidea_config(\"sms.identifier\", identifier)\n        self.assertEqual(r, \"insert\")\n\n        responses.add(responses.POST,\n                      post_url,\n                      body=success_body)\n\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n        serial = \"sms01\"\n        pin = \"pin\"\n        user = \"passthru\"\n        r = init_token({\"type\": \"sms\", \"serial\": serial,\n                        \"otpkey\": self.otpkey,\n                        \"phone\": \"123456\",\n                        \"pin\": pin}, user=User(user, self.realm2))\n        self.assertTrue(r)\n\n        # Trigger challenge for serial number\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"serial\": serial},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), 1)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"messages\")[0],\n                             _(\"Enter the OTP from the SMS:\"))\n            transaction_id = detail.get(\"transaction_ids\")[0]\n\n        # Check authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": \"287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        # Trigger challenge for user\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2},\n                                           headers={\n                                               'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), 1)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"messages\")[0],\n                             _(\"Enter the OTP from the SMS:\"))\n            transaction_id = detail.get(\"transaction_ids\")[0]\n\n        # Check authentication\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": user,\n                                                 \"realm\": self.realm2,\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"pass\": \"969429\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        remove_token(serial)\n\n    @smtpmock.activate\n    def test_25_trigger_challenge_smtp(self):\n        smtpmock.setdata(response={\"hans@dampf.com\": (200, 'OK')})\n        from privacyidea.lib.tokens.emailtoken import EMAILACTION\n\n        self.setUp_user_realms()\n        self.setUp_user_realm2()\n        serial = \"smtp01\"\n        pin = \"pin\"\n        user = \"passthru\"\n        r = init_token({\"type\": \"email\", \"serial\": serial,\n                        \"otpkey\": self.otpkey,\n                        \"email\": \"hans@dampf.com\",\n                        \"pin\": pin}, user=User(user, self.realm2))\n        self.assertTrue(r)\n\n        set_policy(\"emailtext\", scope=SCOPE.AUTH,\n                   action=\"{0!s}=Dein <otp>\".format(EMAILACTION.EMAILTEXT))\n        set_policy(\"emailsubject\", scope=SCOPE.AUTH,\n                   action=\"{0!s}=Dein OTP\".format(EMAILACTION.EMAILSUBJECT))\n\n        # Trigger challenge for serial number\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"serial\": serial},\n                                           headers={'Authorization': self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), 1)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"messages\")[0],\n                             _(\"Enter the OTP from the Email:\"))\n            transaction_id = detail.get(\"transaction_ids\")[0]\n            # check the sent message\n            sent_message = smtpmock.get_sent_message()\n            self.assertTrue(\"RGVpbiAyODcwODI=\" in sent_message)\n            self.assertTrue(\"Subject: Dein OTP\" in sent_message)\n\n        remove_token(serial)\n        delete_policy(\"emailtext\")\n\n    def test_26_multiple_challenge_response(self):\n        # Test the challenges for multiple active tokens\n        self.setUp_user_realms()\n        OTPKE2 = \"31323334353637383930313233343536373839AA\"\n        user = User(\"multichal\", self.realm1)\n        pin = \"test49\"\n        token_a = init_token({\"serial\": \"CR2A\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": OTPKE2,\n                              \"pin\": pin}, user)\n        token_b = init_token({\"serial\": \"CR2B\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pin}, user)\n        set_policy(\"test49\", scope=SCOPE.AUTH, action=\"{0!s}=HOTP\".format(\n            ACTION.CHALLENGERESPONSE))\n        # both tokens will be a valid challenge response token!\n\n        transaction_id = None\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            multi_challenge = detail.get(\"multi_challenge\")\n            self.assertEqual(multi_challenge[0].get(\"serial\"), \"CR2A\")\n            self.assertEqual(transaction_id,\n                             multi_challenge[0].get(\"transaction_id\"))\n            self.assertEqual(transaction_id,\n                             multi_challenge[1].get(\"transaction_id\"))\n            self.assertEqual(multi_challenge[1].get(\"serial\"), \"CR2B\")\n\n        # There are two challenges in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 2)\n\n        # Check the second response to the challenge, the second step in\n        # challenge response:\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": \"287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            serial = detail.get(\"serial\")\n            self.assertEqual(serial, \"CR2B\")\n\n        # No challenges in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 0)\n\n        remove_token(\"CR2A\")\n        remove_token(\"CR2B\")\n        delete_policy(\"test49\")\n\n    def test_27_multiple_challenge_response_different_pin(self):\n        # Test the challenges for multiple active tokens with different PINs\n        # Test issue #649\n        self.setUp_user_realms()\n        OTPKE2 = \"31323334353637383930313233343536373839AA\"\n        user = User(\"multichal\", self.realm1)\n        pinA = \"testA\"\n        pinB = \"testB\"\n        token_a = init_token({\"serial\": \"CR2A\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": OTPKE2,\n                              \"pin\": pinA}, user)\n        token_b = init_token({\"serial\": \"CR2B\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pinB}, user)\n        set_policy(\"test48\", scope=SCOPE.AUTH, action=\"{0!s}=HOTP\".format(\n            ACTION.CHALLENGERESPONSE))\n        # both tokens will be a valid challenge response token!\n\n        transaction_id = None\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": pinB}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            transaction_id = detail.get(\"transaction_id\")\n            multi_challenge = detail.get(\"multi_challenge\")\n            self.assertEqual(multi_challenge[0].get(\"serial\"), \"CR2B\")\n            self.assertEqual(transaction_id,\n                             multi_challenge[0].get(\"transaction_id\"))\n            self.assertEqual(len(multi_challenge), 1)\n\n        # There is ONE challenge in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 1)\n\n        # Check the second response to the challenge, the second step in\n        # challenge response:\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"transaction_id\":\n                                                     transaction_id,\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": \"287082\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            serial = detail.get(\"serial\")\n            self.assertEqual(serial, \"CR2B\")\n\n        # No challenges in the database\n        r = Challenge.query.filter(Challenge.transaction_id ==\n                                   transaction_id).all()\n        self.assertEqual(len(r), 0)\n\n        remove_token(\"CR2A\")\n        remove_token(\"CR2B\")\n        delete_policy(\"test49\")\n\n    def test_28_validate_radiuscheck(self):\n        # setup a spass token\n        token_obj = init_token({\"serial\": \"pass3\", \"pin\": \"123456\",\n                                \"type\": \"spass\"})\n\n        # test successful authentication\n        with self.app.test_request_context('/validate/radiuscheck',\n                                           method='POST',\n                                           data={\"serial\": \"pass3\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            # HTTP 204 status code signals a successful authentication\n            self.assertEqual(res.status_code, 204)\n            self.assertEqual(res.data, '')\n\n        # test authentication fails with wrong PIN\n        with self.app.test_request_context('/validate/radiuscheck',\n                                           method='POST',\n                                           data={\"serial\": \"pass3\",\n                                                 \"pass\": \"wrong\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 400)\n            self.assertEqual(res.data, '')\n\n        # test authentication fails with an unknown user\n        # here, we get an ordinary JSON response\n        with self.app.test_request_context('/validate/radiuscheck',\n                                           method='POST',\n                                           data={\"user\": \"unknown\",\n                                                 \"pass\": \"123456\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 400)\n            result = json.loads(res.data).get(\"result\")\n            self.assertFalse(result.get(\"status\"))\n\n    def test_29_several_CR_one_locked(self):\n        # A user has several CR tokens. One of the tokens is locked.\n        self.setUp_user_realms()\n        user = User(\"multichal\", self.realm1)\n        pin = \"test\"\n        token_a = init_token({\"serial\": \"CR2A\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pin}, user)\n        token_b = init_token({\"serial\": \"CR2B\",\n                              \"type\": \"hotp\",\n                              \"otpkey\": self.otpkey,\n                              \"pin\": pin}, user)\n        set_policy(\"test48\", scope=SCOPE.AUTH, action=\"{0!s}=HOTP\".format(\n            ACTION.CHALLENGERESPONSE))\n        # both tokens will be a valid challenge response token!\n\n        # One token is locked\n        revoke_token(\"CR2B\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"multichal\",\n                                                 \"realm\": self.realm1,\n                                                 \"pass\": pin}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            # This is a challene, the value is False\n            self.assertEqual(result.get(\"value\"), False)\n            detail = json.loads(res.data).get(\"detail\")\n            serial = detail.get(\"serial\")\n            self.assertEqual(serial, \"CR2A\")\n            # Only one challenge, the 2nd token was revoked.\n            self.assertEqual(len(detail.get(\"multi_challenge\")), 1)\n\n        delete_policy(\"test48\")\n        remove_token(\"CR2A\")\n        remove_token(\"CR2B\")\n\n    def test_30_return_different_tokentypes(self):\n        \"\"\"\n        Return different tokentypes\n\n        If there are more than one matching tokens, the check_token_list in lib/token.py\n        returns a tokentype:\n        1. a specific tokentype if all matching tokens are of the same type\n        2. an \"undetermined\" tokentype, if the matching tokens are of\n           different type.\n        \"\"\"\n        self.setUp_user_realms()\n        user = User(\"cornelius\", self.realm1)\n\n        # two different token types\n        init_token({\"serial\": \"SPASS1\",\n                    \"type\": \"spass\",\n                    \"pin\": \"hallo123\"}, user)\n        init_token({\"serial\": \"PW1\",\n                    \"type\": \"pw\",\n                    \"otpkey\": \"123\",\n                    \"pin\": \"hallo\"}, user)\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"type\"), \"undetermined\")\n\n        # two same token types.\n        remove_token(\"PW1\")\n        init_token({\"serial\": \"SPASS2\",\n                    \"type\": \"spass\",\n                    \"pin\": \"hallo123\"}, user)\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"type\"), \"spass\")\n\n        # A user has one HOTP token and two spass tokens.\n        init_token({\"serial\": \"HOTP1\",\n                    \"type\": \"hotp\",\n                    \"otpkey\": self.otpkey,\n                    \"pin\": \"hallo\"}, user)\n        # Without policy he can authenticate with the spass token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail.get(\"type\"), \"spass\")\n\n        # policy only allows HOTP.\n        set_policy(\"onlyHOTP\", scope=SCOPE.AUTHZ,\n                   action=\"{0!s}=hotp\".format(ACTION.TOKENTYPE))\n\n        # He can not authenticate with the spass token!\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"hallo123\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 403)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"status\"), False)\n            self.assertEqual(result.get(\"error\").get(\"code\"), ERROR.POLICY)\n            detail = json.loads(res.data).get(\"detail\")\n            self.assertEqual(detail, None)\n\n        # Define a passthru policy\n        set_policy(\"passthru\", scope=SCOPE.AUTH,\n                   action=\"{0!s}=userstore\".format(ACTION.PASSTHRU))\n\n        # A user with a passthru policy can authenticate, since he has not tokentype\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"passthru\",\n                                                 \"pass\": \"pthru\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            result = json.loads(res.data).get(\"result\")\n            self.assertEqual(result.get(\"value\"), True)\n\n        delete_policy(\"onlyHOTP\")\n        delete_policy(\"onlyHOTP\")\n        delete_policy(\"passthru\")\n        remove_token(\"SPASS1\")\n        remove_token(\"SPASS2\")\n        remove_token(\"HOTP1\")\n\n    @responses.activate\n    @smtpmock.activate\n    def test_30_challenge_text(self):\n        \"\"\"\n        Set a policy for a different challengetext and run a C/R for sms and email.\n        :return:\n        \"\"\"\n        smtpmock.setdata(response={\"hallo@example.com\": (200, 'OK')})\n\n        # Configure the SMS Gateway\n        from privacyidea.lib.smsprovider.SMSProvider import set_smsgateway\n        from privacyidea.lib.config import set_privacyidea_config\n        post_url = \"http://smsgateway.com/sms_send_api.cgi\"\n        success_body = \"ID 12345\"\n\n        identifier = \"myGW\"\n        provider_module = \"privacyidea.lib.smsprovider.HttpSMSProvider\" \\\n                          \".HttpSMSProvider\"\n        id = set_smsgateway(identifier, provider_module, description=\"test\",\n                            options={\"HTTP_METHOD\": \"POST\",\n                                     \"URL\": post_url,\n                                     \"RETURN_SUCCESS\": \"ID\",\n                                     \"text\": \"{otp}\",\n                                     \"phone\": \"{phone}\"})\n        self.assertTrue(id > 0)\n        # set config sms.identifier = myGW\n        r = set_privacyidea_config(\"sms.identifier\", identifier)\n        self.assertTrue(r in [\"insert\", \"update\"])\n        responses.add(responses.POST,\n                      post_url,\n                      body=success_body)\n\n\n\n        self.setUp_user_realms()\n        user = User(\"cornelius\", self.realm1)\n\n        # two different token types\n        init_token({\"serial\": \"CHAL1\",\n                    \"type\": \"sms\",\n                    \"phone\": \"123456\",\n                    \"pin\": \"sms\"}, user)\n        init_token({\"serial\": \"CHAL2\",\n                    \"type\": \"email\",\n                    \"email\": \"hallo@example.com\",\n                    \"pin\": \"email\"}, user)\n\n        set_policy(\"chalsms\", SCOPE.AUTH, \"sms_{0!s}=check your sms\".format(ACTION.CHALLENGETEXT))\n        set_policy(\"chalemail\", SCOPE.AUTH, \"email_{0!s}=check your email\".format(ACTION.CHALLENGETEXT))\n\n        # Challenge Response with email\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"email\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            resp = json.loads(res.data)\n            self.assertEqual(resp.get(\"detail\").get(\"message\"), \"check your email\")\n\n        # Challenge Response with SMS\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"sms\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            resp = json.loads(res.data)\n            self.assertEqual(resp.get(\"detail\").get(\"message\"), \"check your sms\")\n\n        # Two different token types that are triggered by the same PIN:\n        init_token({\"serial\": \"CHAL3\",\n                    \"type\": \"sms\",\n                    \"phone\": \"123456\",\n                    \"pin\": \"PIN\"}, user)\n        init_token({\"serial\": \"CHAL4\",\n                    \"type\": \"email\",\n                    \"email\": \"hallo@example.com\",\n                    \"pin\": \"PIN\"}, user)\n\n        # Challenge Response with SMS and Email. The challenge message contains both hints\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"cornelius\",\n                                                 \"pass\": \"PIN\"}):\n            res = self.app.full_dispatch_request()\n            self.assertEqual(res.status_code, 200)\n            resp = json.loads(res.data)\n            self.assertEqual(resp.get(\"detail\").get(\"message\"), \"check your sms, check your email\")\n\n        delete_policy(\"chalsms\")\n        delete_policy(\"chalemail\")\n        remove_token(\"CHAL1\")\n        remove_token(\"CHAL2\")\n        remove_token(\"CHAL3\")\n        remove_token(\"CHAL4\")\n\n    def test_01_check_invalid_input(self):\n        # Empty username\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \" \",\n                                                 \"pass\": \"\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            result = json.loads(res.data).get(\"result\")\n            error_msg = result.get(\"error\").get(\"message\")\n            self.assertEqual(\"ERR905: You need to specify a serial or a user.\", error_msg)\n\n        # wrong username\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"h%h\",\n                                                 \"pass\": \"\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            result = json.loads(res.data).get(\"result\")\n            error_msg = result.get(\"error\").get(\"message\")\n            self.assertEqual(\"ERR905: Invalid user.\", error_msg)\n\n        # wrong serial\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"serial\": \"*\",\n                                                 \"pass\": \"\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 400, res)\n            result = json.loads(res.data).get(\"result\")\n            error_msg = result.get(\"error\").get(\"message\")\n            self.assertEqual(\"ERR905: Invalid serial number.\", error_msg)\n\n\nclass AChallengeResponse(MyTestCase):\n\n    serial = \"hotp1\"\n    serial_email = \"email1\"\n\n    def setUp(self):\n        MyTestCase.setUp(self)\n        self.setUp_user_realms()\n\n    def test_01_challenge_response_token_deactivate(self):\n        # New token for the user \"selfservice\"\n        Token(\"hotp1\", \"hotp\", otpkey=self.otpkey, userid=1004, resolver=self.resolvername1,\n              realm=self.realm1).save()\n        # Define HOTP token to be challenge response\n        set_policy(name=\"pol_cr\", scope=SCOPE.AUTH, action=\"{0!s}=hotp\".format(ACTION.CHALLENGERESPONSE))\n        set_pin(self.serial, \"pin\")\n\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertTrue(\"enter otp\" in detail.get(\"message\"), detail.get(\"message\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # Now we try to provide the OTP value\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": self.valid_otp_values[0],\n                                                 \"transaction_id\": transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"value\"))\n\n        # Now we send the challenge and then we disable the token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertTrue(\"enter otp\" in detail.get(\"message\"), detail.get(\"message\"))\n            transaction_id = detail.get(\"transaction_id\")\n\n        # disable the token\n        enable_token(self.serial, False)\n\n        # Now we try to provide the OTP value, but authentication must fail, since the token is disabled\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": self.valid_otp_values[1],\n                                                 \"transaction_id\": transaction_id}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertEqual(detail.get(\"message\"), \"Challenge matches, but token is inactive.\")\n\n        # The token is still disabled. We are checking, if we can do a challenge response\n        # for a disabled token\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            self.assertTrue(\"No active challenge response\" in detail.get(\"message\"), detail.get(\"message\"))\n\n    @smtpmock.activate\n    def test_02_two_challenge_response_tokens(self):\n        smtpmock.setdata(response={\"bla@example.com\": (200, 'OK')})\n        # We test two challenge response tokens. One is active, one is disabled.\n        # Enroll an Email-Token to the user\n        init_token(user=User(\"selfservice\", self.realm1),\n                   param={\"serial\": self.serial_email,\n                          \"type\": \"email\",\n                          \"email\": \"bla@example.com\",\n                          \"otpkey\": self.otpkey})\n        set_pin(self.serial_email, \"pin\")\n\n        toks = get_tokens(user=User(\"selfservice\", self.realm1))\n        self.assertEqual(len(toks), 2)\n        self.assertFalse(toks[0].token.active)\n        self.assertTrue(toks[1].token.active)\n\n        # Now we create a challenge with two tokens\n        with self.app.test_request_context('/validate/check',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\",\n                                                 \"pass\": \"pin\"}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            self.assertFalse(data.get(\"result\").get(\"value\"))\n            detail = data.get(\"detail\")\n            # Only the email token is active and creates a challenge!\n            self.assertEqual(u\"Enter the OTP from the Email:\", detail.get(\"message\"))\n\n        # Now test with triggerchallenge\n        with self.app.test_request_context('/validate/triggerchallenge',\n                                           method='POST',\n                                           data={\"user\": \"selfservice\"},\n                                           headers={\"Authorization\": self.at}):\n            res = self.app.full_dispatch_request()\n            self.assertTrue(res.status_code == 200, res)\n            data = json.loads(res.data)\n            self.assertTrue(data.get(\"result\").get(\"status\"))\n            # Triggerchallenge returns the numbers of tokens in the \"value\n            self.assertEqual(data.get(\"result\").get(\"value\"), 1)\n            detail = data.get(\"detail\")\n            # Only the email token is active and creates a challenge!\n            self.assertEqual(u\"Enter the OTP from the Email:\", detail.get(\"messages\")[0])"], "filenames": ["Changelog", "Makefile", "deploy/debian-ubuntu/changelog", "deploy/debian-virtualenv/changelog", "deploy/debian-virtualenv/rules", "doc/conf.py", "privacyidea/api/validate.py", "privacyidea/lib/decorators.py", "setup.py", "tests/test_api_validate.py"], "buggy_code_start_loc": [0, 18, 0, 0, 14, 20, 166, 87, 8, 2195], "buggy_code_end_loc": [0, 19, 0, 0, 15, 21, 166, 90, 9, 2195], "fixing_code_start_loc": [1, 18, 1, 1, 15, 20, 167, 87, 8, 2196], "fixing_code_end_loc": [6, 19, 8, 8, 19, 21, 168, 96, 9, 2230], "type": "CWE-20", "message": "privacyIDEA version 2.23.1 and earlier contains a Improper Input Validation vulnerability in token validation api that can result in Denial-of-Service. This attack appear to be exploitable via http request with user=<space>&pass= to /validate/check url. This vulnerability appears to have been fixed in 2.23.2.", "other": {"cve": {"id": "CVE-2018-1000809", "sourceIdentifier": "cve@mitre.org", "published": "2018-10-08T15:29:01.057", "lastModified": "2019-01-08T16:27:54.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "privacyIDEA version 2.23.1 and earlier contains a Improper Input Validation vulnerability in token validation api that can result in Denial-of-Service. This attack appear to be exploitable via http request with user=<space>&pass= to /validate/check url. This vulnerability appears to have been fixed in 2.23.2."}, {"lang": "es", "value": "privacyIDEA en versiones 2.23.1 y anteriores contiene una validaci\u00f3n incorrecta de validaci\u00f3n de entradas incorrecta en la API de validaci\u00f3n de tokens que puede resultar en una denegaci\u00f3n de servicio (DoS). Este ataque parece ser explotable mediante una petici\u00f3n HTTP con user=pass= en la URL /validate/check. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 2.23.2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:privacyidea:privacyidea:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.23.1", "matchCriteriaId": "A2F0738D-4CC2-40E8-AE07-0D70461519D4"}]}]}], "references": [{"url": "https://github.com/privacyidea/privacyidea/commit/a3edc09beffa2104f357fe24971ea3211ce40751", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/privacyidea/privacyidea/issues/1227", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/privacyidea/privacyidea/commit/a3edc09beffa2104f357fe24971ea3211ce40751"}}