{"buggy_code": ["/*\n * Copyright (C) 2020 HAW Hamburg\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n/**\n * @ingroup     sys_uri_parser\n * @{\n *\n * @file\n * @brief       A minimal, non-destructive URI parser.\n *              @see https://tools.ietf.org/html/rfc3986\n *\n * @author      Cenk G\u00fcndo\u011fan <cenk.guendogan@haw-hamburg.de>\n *\n * @}\n */\n\n#include <assert.h>\n\n#include \"uri_parser.h\"\n\n#define ENABLE_DEBUG 0\n#include \"debug.h\"\n\n/* strchr for non-Null-terminated strings (buffers) */\nstatic char *_strchrb(char *start, char *stop, char c)\n{\n    for (; start < stop; start++) {\n        if (*start == c) {\n            return start;\n        }\n    }\n    return NULL;\n}\n\nstatic char *_consume_scheme(uri_parser_result_t *result, char *uri,\n                             char *uri_end, bool *has_authority)\n{\n    assert(uri);\n\n    /* assume no authority section first */\n    *has_authority = false;\n\n    /* cannot have empty scheme */\n    if (uri[0] == ':') {\n        return NULL;\n    }\n\n    char *p = _strchrb(uri, uri_end, ':');\n\n    result->scheme = uri;\n    result->scheme_len = p - uri;\n\n    /* check if authority part exists '://' */\n    if ((p[1] != '\\0') && (p[2] != '\\0') && (p[1] == '/') && (p[2] == '/')) {\n        *has_authority = true;\n        /* skip '://' */\n        return p + 3;\n    }\n\n    /* skip ':' */\n    return p + 1;\n}\n\nvoid _consume_userinfo(uri_parser_result_t *result, char *uri,\n                       char *authority_end)\n{\n    /* check for userinfo within authority */\n    char *userinfo_end = _strchrb(uri, authority_end, '@');\n\n    /* check if match */\n    if (userinfo_end) {\n        result->userinfo = uri;\n        result->userinfo_len = userinfo_end - uri;\n        /* shift host part beyond userinfo and '@' */\n        result->host += result->userinfo_len + 1;\n        result->host_len -= result->userinfo_len + 1;\n    }\n}\n\nbool _consume_port(uri_parser_result_t *result, char *ipv6_end,\n                   char *authority_end)\n{\n    /* check for port after host part */\n    char *port_begin = NULL;\n    /* repeat until last ':' in authority section */\n    /* if ipv6 address, check after ipv6 end marker */\n    char *p = (ipv6_end ? ipv6_end : result->host);\n    while (p != NULL && (p < authority_end)) {\n        port_begin = p;\n        p = _strchrb(p + 1, authority_end, ':');\n    }\n\n    /* check if match */\n    if (port_begin && (port_begin[0] == ':')) {\n        /* port should be at least one character, => + 1 */\n        if (port_begin + 1 == authority_end) {\n            return false;\n        }\n        result->port = port_begin + 1;\n        result->port_len = authority_end - result->port;\n        /* cut host part before port and ':' */\n        result->host_len -= result->port_len + 1;\n    }\n\n    return true;\n}\n\nstatic char *_consume_authority(uri_parser_result_t *result, char *uri,\n                                char *uri_end)\n{\n    assert(uri);\n\n    /* search until first '/' */\n    char *authority_end = _strchrb(uri, uri_end, '/');\n    if (!authority_end) {\n        authority_end = uri_end;\n    }\n    result->host = uri;\n    result->host_len = authority_end - uri;\n\n    /* consume userinfo, if available */\n    _consume_userinfo(result, uri, authority_end);\n\n    char *ipv6_end = NULL;\n    /* validate IPv6 form */\n    if (result->host[0] == '[') {\n        ipv6_end = _strchrb(result->host, uri_end, ']');\n        /* found end marker of IPv6 form beyond authority part */\n        if (ipv6_end >= authority_end) {\n            return NULL;\n        }\n\n        char *zoneid_start = _strchrb(result->host, ipv6_end, '%');\n        if (zoneid_start) {\n            /* skip % */\n            result->zoneid = zoneid_start + 1;\n            result->zoneid_len = ipv6_end - result->zoneid;\n\n            /* zoneid cannot be empty */\n            if (result->zoneid_len == 0) {\n                return NULL;\n            }\n        }\n\n        /* remove '[', ']', and '%' zoneid from ipv6addr */\n        result->ipv6addr = result->host + 1;\n        result->ipv6addr_len = ipv6_end - result->ipv6addr;\n        if (result->zoneid) {\n            result->ipv6addr_len -= result->zoneid_len + 1;\n        }\n    }\n\n    /* consume port, if available */\n    if (!_consume_port(result, ipv6_end, authority_end)) {\n        return NULL;\n    }\n\n    /* do not allow empty host if userinfo or port are set */\n    if ((result->host_len == 0) &&\n        (result->userinfo || result->port)) {\n        return NULL;\n    }\n\n    /* this includes the '/' */\n    return authority_end;\n}\n\nstatic char *_consume_path(uri_parser_result_t *result, char *uri,\n                           char *uri_end)\n{\n    assert(uri);\n\n    result->path = uri;\n    result->path_len = (uri_end - uri);\n\n    /* check for query start '?' */\n    char *path_end = _strchrb(uri, uri_end, '?');\n\n    /* no query string found, return! */\n    if (!path_end) {\n        return (result->path + result->path_len);\n    }\n\n    /* there is a query string */\n    result->query = path_end + 1;\n    /* do not count '?' */\n    result->query_len = result->path_len - (path_end - uri) - 1;\n    /* cut path part before query and '?' */\n    result->path_len -= result->query_len + 1;\n\n    return (result->query + result->query_len);\n}\n\nstatic int _parse_relative(uri_parser_result_t *result, char *uri,\n                           char *uri_end)\n{\n    uri = _consume_path(result, uri, uri_end);\n    /* uri should point to uri_end, otherwise there's something left\n     * to consume ... */\n    if (uri != uri_end) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int _parse_absolute(uri_parser_result_t *result, char *uri,\n                           char *uri_end)\n{\n    bool has_authority;\n\n    uri = _consume_scheme(result, uri, uri_end, &has_authority);\n    if (uri == NULL) {\n        return -1;\n    }\n\n    if (has_authority) {\n        uri = _consume_authority(result, uri, uri_end);\n        if (uri == NULL) {\n            return -1;\n        }\n    }\n\n    /* parsing the path, starting with '/' */\n    return _parse_relative(result, uri, uri_end);\n}\n\nbool uri_parser_is_absolute(const char *uri, size_t uri_len)\n{\n    char *colon = _strchrb((char *)uri, (char *)(uri + uri_len), ':');\n\n    /* potentially absolute, if ':' exists */\n    if (colon) {\n        /* first character should be ALPHA */\n        if (!(((uri[0] >= 'A') && (uri[0] <= 'Z')) ||\n              ((uri[0] >= 'a') && (uri[0] <= 'z')))) {\n            /* relative */\n            return false;\n        }\n        for (int i = 0; &uri[i] < colon; ++i) {\n            if (!(((uri[i] >= 'A') && (uri[i] <= 'Z')) ||\n                  ((uri[i] >= 'a') && (uri[i] <= 'z')) ||\n                  ((uri[i] >= '0') && (uri[i] <= '9')) ||\n                  (uri[i] == '+') ||\n                  (uri[i] == '-') ||\n                  (uri[i] == '.'))) {\n                /* relative */\n                return false;\n            }\n        }\n\n        /* absolute */\n        return true;\n    }\n\n    /* relative */\n    return false;\n}\n\nbool uri_parser_is_absolute_string(const char *uri)\n{\n    return uri_parser_is_absolute(uri, strlen(uri));\n}\n\nint uri_parser_process(uri_parser_result_t *result, const char *uri,\n                       size_t uri_len)\n{\n    /* uri cannot be empty */\n    if ((NULL == uri) || (uri[0] == '\\0')) {\n        return -1;\n    }\n\n    memset(result, 0, sizeof(*result));\n\n    if (uri_parser_is_absolute(uri, uri_len)) {\n        return _parse_absolute(result, (char *)uri, (char *)(uri + uri_len));\n    }\n    else {\n        return _parse_relative(result, (char *)uri, (char *)(uri + uri_len));\n    }\n\n    return 0;\n}\n\nint uri_parser_process_string(uri_parser_result_t *result, const char *uri)\n{\n    return uri_parser_process(result, uri, strlen(uri));\n}\n", "/*\n * Copyright (C) 2020 HAW Hamburg\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n */\n\n#include <stdio.h>\n#include <stdbool.h>\n#include \"embUnit.h\"\n\n#include \"uri_parser.h\"\n\n#include \"unittests-constants.h\"\n#include \"tests-uri_parser.h\"\n\n#define VEC(u, f, s, us, h, v6a, z, po, pa, q, e)                           \\\n    { .uri = u, .full_uri = f, .scheme = s, .userinfo = us, .host = h,      \\\n      .ipv6addr = v6a, .zoneid = z, .port = po, .path = pa,                 \\\n      .query = q, .expected = e}\n\n#define VEC_CHECK(comp, i, vec_msg)                                         \\\n    do {                                                                    \\\n        if (ures.comp == NULL) {                                            \\\n            TEST_ASSERT(validate_uris[i].comp[0] == '\\0');                  \\\n        }                                                                   \\\n        else {                                                              \\\n            TEST_ASSERT_EQUAL_INT(strlen(validate_uris[i].comp),            \\\n                                  ures.comp##_len);                         \\\n            vec_msg[0] = '\\0';                                              \\\n            stdimpl_strcat(vec_msg, \"Unexpected \" # comp \" member \\\"\");     \\\n            stdimpl_strcat(vec_msg, validate_uris[i].comp);                 \\\n            stdimpl_strcat(vec_msg, \"\\\" for \\\"\");                           \\\n            stdimpl_strcat(vec_msg, validate_uris[i].uri);                  \\\n            stdimpl_strcat(vec_msg, \"\\\"\");                                  \\\n            TEST_ASSERT_MESSAGE(0 ==                                        \\\n                                  strncmp(ures.comp,                        \\\n                                          validate_uris[i].comp,            \\\n                                          strlen(validate_uris[i].comp)),   \\\n                                vec_msg);                                   \\\n        }                                                                   \\\n    } while (0)\n\n#define VEC_MSG_LEN (sizeof(\"Unexpected userinfo member \\\"\\\" for \\\"\\\"\") + \\\n                     64U + 8U)\n\ntypedef struct {\n    char uri[64];\n    bool full_uri;\n    char scheme[8];\n    char userinfo[16];\n    char host[24];\n    char ipv6addr[16];\n    char zoneid[8];\n    char port[32];\n    char path[48];\n    char query[32];\n    int expected;\n} validate_t;\n\n/*\n  VEC(uri_to_parse,\n      scheme, userinfo, host, port,\n      path, query, expected return value)\n*/\nstatic const validate_t validate_uris[] = {\n        /* uri to parse */\n    VEC(\"coap://RIOT:test@[fe80:db8::1%tap0]:5683/.well-known/core?v=1\",\n        /* is URI */\n        true,\n        /* parsed scheme */\n        \"coap\",\n        /* parsed userinfo */\n        \"RIOT:test\",\n        /* parsed host */\n        \"[fe80:db8::1%tap0]\",\n        /* parsed host without zoneid */\n        \"fe80:db8::1\",\n        /* parsed zoneid */\n        \"tap0\",\n        /* parsed port */\n        \"5683\",\n        /* parsed path */\n        \"/.well-known/core\",\n        /* parsed query */\n        \"v=1\",\n        /* expected return value */\n        0),\n    VEC(\"coap://RIOT:test@[fe80:db8::1%]:5683/.well-known/core?v=1\",\n        true,\n        \"coap\",\n        \"RIOT:test\",\n        \"[fe80:db8::1%]\",\n        \"fe80:db8::1\",\n        \"\",\n        \"5683\",\n        \"/.well-known/core\",\n        \"v=1\",\n        -1),\n    VEC(\"coap://[fe80::1]/foo%20bar\",\n        true,\n        \"coap\",\n        \"\",\n        \"[fe80::1]\",\n        \"fe80::1\",\n        \"\",\n        \"\",\n        \"/foo%20bar\",\n        \"\",\n        0),\n    VEC(\"/.well-known/core?v=1\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"/.well-known/core\",\n        \"v=1\",\n        0),\n    VEC(\"coap://R@[2001:db8::1]:5own/v=1\",\n        true,\n        \"coap\",\n        \"R\",\n        \"[2001:db8::1]\",\n        \"2001:db8::1\",\n        \"\",\n        \"5own\",\n        \"/v=1\",\n        \"\",\n        0),\n    VEC(\"coap://R@[2001:db8::1]:5own/:v=1\",\n        true,\n        \"coap\",\n        \"R\",\n        \"[2001:db8::1]\",\n        \"2001:db8::1\",\n        \"\",\n        \"5own\",\n        \"/:v=1\",\n        \"\",\n        0),\n    VEC(\"cap://R@[2001:db8::1]:5own/?v=1\",\n        true,\n        \"cap\",\n        \"R\",\n        \"[2001:db8::1]\",\n        \"2001:db8::1\",\n        \"\",\n        \"5own\",\n        \"/\",\n        \"v=1\",\n        0),\n    VEC(\"oap://Y2001:db8::1]:5own/av=1\",\n        true,\n        \"oap\",\n        \"\",\n        \"Y2001:db8::1]\",\n        \"\",\n        \"\",\n        \"5own\",\n        \"/av=1\",\n        \"\",\n        0),\n    VEC(\"//Rb[\u02b000J:d/5v=0\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"//Rb[\u02b000J:d/5v=0\",\n        \"\",\n        0),\n    VEC(\"coap://oap://P@[2001:b\",\n        true,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        -1),\n    VEC(\"coap:///R@[2008::1]:5own//R@[2008::1]:5own/?v=1\",\n        true,\n        \"coap\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"/R@[2008::1]:5own//R@[2008::1]:5own/\",\n        \"v=1\",\n        0),\n    VEC(\"coaP://R/RZ[2001[8:01[8::1]:5o:1]:5oTMv=1\",\n        true,\n        \"coaP\",\n        \"\",\n        \"R\",\n        \"\",\n        \"\",\n        \"\",\n        \"/RZ[2001[8:01[8::1]:5o:1]:5oTMv=1\",\n        \"\",\n        0),\n    VEC(\"coap://R@////////////////7///v=1\",\n        true,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        -1),\n    VEC(\"coa[:////[2001:db5ow:5own/Ov=1\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"coa[:////[2001:db5ow:5own/Ov=1\",\n        \"\",\n        0),\n    VEC(\"tel:+1-816-555-1212\",\n        true,\n        \"tel\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"+1-816-555-1212\",\n        \"\",\n        0),\n    VEC(\"sms:+15105550101,+15105550102?body=hello%20there\",\n        true,\n        \"sms\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"+15105550101,+15105550102\",\n        \"body=hello%20there\",\n        0),\n    VEC(\"a\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"a\",\n        \"\",\n        0),\n    VEC(\"mailto:test@example.com\",\n        true,\n        \"mailto\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"test@example.com\",\n        \"\",\n        0),\n    VEC(\"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n        true,\n        \"ftp\",\n        \"\",\n        \"ftp.is.co.za\",\n        \"\",\n        \"\",\n        \"\",\n        \"/rfc/rfc1808.txt\",\n        \"\",\n        0),\n    VEC(\"http://www.ietf.org/rfc/rfc2396.txt\",\n        true,\n        \"http\",\n        \"\",\n        \"www.ietf.org\",\n        \"\",\n        \"\",\n        \"\",\n        \"/rfc/rfc2396.txt\",\n        \"\",\n        0),\n    VEC(\"ldap://[2001:db8::7]/c=GB?objectClass?one\",\n        true,\n        \"ldap\",\n        \"\",\n        \"[2001:db8::7]\",\n        \"2001:db8::7\",\n        \"\",\n        \"\",\n        \"/c=GB\",\n        \"objectClass?one\",\n        0),\n    VEC(\"mailto:John.Doe@example.com\",\n        true,\n        \"mailto\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"John.Doe@example.com\",\n        \"\",\n        0),\n    VEC(\"news:comp.infosystems.www.servers.unix\",\n        true,\n        \"news\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"comp.infosystems.www.servers.unix\",\n        \"\",\n        0),\n    VEC(\"tel:+1-816-555-1212\",\n        true,\n        \"tel\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"+1-816-555-1212\",\n        \"\",\n        0),\n    VEC(\"telnet://192.0.2.16:80/\",\n        true,\n        \"telnet\",\n        \"\",\n        \"192.0.2.16\",\n        \"\",\n        \"\",\n        \"80\",\n        \"/\",\n        \"\",\n        0),\n    VEC(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        true,\n        \"urn\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        \"\",\n        0),\n    VEC(\"\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        -1),\n    VEC(\"/\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"/\",\n        \"\",\n        0),\n    VEC(\"./this:that\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"./this:that\",\n        \"\",\n        0),\n};\n\nstatic char _failure_msg[VEC_MSG_LEN];\n\nstatic void test_uri_parser__validate(void)\n{\n    uri_parser_result_t ures;\n    for (unsigned i = 0; i < ARRAY_SIZE(validate_uris); i++) {\n        int res = uri_parser_process_string(&ures, validate_uris[i].uri);\n        TEST_ASSERT_EQUAL_INT(validate_uris[i].full_uri,\n               uri_parser_is_absolute_string(validate_uris[i].uri));\n        TEST_ASSERT_EQUAL_INT(validate_uris[i].expected, res);\n        if (res == 0) {\n            VEC_CHECK(scheme, i, _failure_msg);\n            VEC_CHECK(userinfo, i, _failure_msg);\n            VEC_CHECK(host, i, _failure_msg);\n            VEC_CHECK(ipv6addr, i, _failure_msg);\n            VEC_CHECK(zoneid, i, _failure_msg);\n            VEC_CHECK(port, i, _failure_msg);\n            VEC_CHECK(path, i, _failure_msg);\n            VEC_CHECK(query, i, _failure_msg);\n        }\n    }\n}\n\nstatic void test_uri_parser__unterminated_string(void)\n{\n    uri_parser_result_t ures;\n    char uri[64];\n    /* initialize with a non-null character */\n    memset(uri, 'Z', sizeof(uri));\n\n    memcpy(uri, validate_uris[0].uri, strlen(validate_uris[0].uri));\n\n    int res = uri_parser_process(&ures, uri, strlen(validate_uris[0].uri));\n\n    TEST_ASSERT_EQUAL_INT(0, res);\n    VEC_CHECK(scheme, 0, _failure_msg);\n    VEC_CHECK(userinfo, 0, _failure_msg);\n    VEC_CHECK(host, 0, _failure_msg);\n    VEC_CHECK(ipv6addr, 0, _failure_msg);\n    VEC_CHECK(zoneid, 0, _failure_msg);\n    VEC_CHECK(port, 0, _failure_msg);\n    VEC_CHECK(path, 0, _failure_msg);\n    VEC_CHECK(query, 0, _failure_msg);\n}\n\nTest *tests_uri_parser_tests(void)\n{\n    EMB_UNIT_TESTFIXTURES(fixtures) {\n        new_TestFixture(test_uri_parser__validate),\n        new_TestFixture(test_uri_parser__unterminated_string),\n    };\n\n    EMB_UNIT_TESTCALLER(uri_parser_tests, NULL, NULL, fixtures);\n\n    return (Test *)&uri_parser_tests;\n}\n\nvoid tests_uri_parser(void)\n{\n    TESTS_RUN(tests_uri_parser_tests());\n}\n/** @} */\n"], "fixing_code": ["/*\n * Copyright (C) 2020 HAW Hamburg\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n/**\n * @ingroup     sys_uri_parser\n * @{\n *\n * @file\n * @brief       A minimal, non-destructive URI parser.\n *              @see https://tools.ietf.org/html/rfc3986\n *\n * @author      Cenk G\u00fcndo\u011fan <cenk.guendogan@haw-hamburg.de>\n *\n * @}\n */\n\n#include <assert.h>\n\n#include \"uri_parser.h\"\n\n#define ENABLE_DEBUG 0\n#include \"debug.h\"\n\n/* strchr for non-Null-terminated strings (buffers) */\nstatic char *_strchrb(char *start, char *stop, char c)\n{\n    for (; start < stop; start++) {\n        if (*start == c) {\n            return start;\n        }\n    }\n    return NULL;\n}\n\nstatic char *_consume_scheme(uri_parser_result_t *result, char *uri,\n                             char *uri_end, bool *has_authority)\n{\n    assert(uri);\n\n    /* assume no authority section first */\n    *has_authority = false;\n\n    /* cannot have empty scheme */\n    if (uri[0] == ':') {\n        return NULL;\n    }\n\n    char *p = _strchrb(uri, uri_end, ':');\n\n    result->scheme = uri;\n    result->scheme_len = p - uri;\n\n    /* check if authority part exists '://' */\n    if (((uri_end - p) > 2) && (p[1] == '/') && (p[2] == '/')) {\n        *has_authority = true;\n        /* skip '://' */\n        return p + 3;\n    }\n\n    /* skip ':' */\n    return p + 1;\n}\n\nvoid _consume_userinfo(uri_parser_result_t *result, char *uri,\n                       char *authority_end)\n{\n    /* check for userinfo within authority */\n    char *userinfo_end = _strchrb(uri, authority_end, '@');\n\n    /* check if match */\n    if (userinfo_end) {\n        result->userinfo = uri;\n        result->userinfo_len = userinfo_end - uri;\n        /* shift host part beyond userinfo and '@' */\n        result->host += result->userinfo_len + 1;\n        result->host_len -= result->userinfo_len + 1;\n    }\n}\n\nbool _consume_port(uri_parser_result_t *result, char *ipv6_end,\n                   char *authority_end)\n{\n    /* check for port after host part */\n    char *port_begin = NULL;\n    /* repeat until last ':' in authority section */\n    /* if ipv6 address, check after ipv6 end marker */\n    char *p = (ipv6_end ? ipv6_end : result->host);\n    while (p != NULL && (p < authority_end)) {\n        port_begin = p;\n        p = _strchrb(p + 1, authority_end, ':');\n    }\n\n    /* check if match */\n    if (port_begin && (port_begin[0] == ':')) {\n        /* port should be at least one character, => + 1 */\n        if (port_begin + 1 == authority_end) {\n            return false;\n        }\n        result->port = port_begin + 1;\n        result->port_len = authority_end - result->port;\n        /* cut host part before port and ':' */\n        result->host_len -= result->port_len + 1;\n    }\n\n    return true;\n}\n\nstatic char *_consume_authority(uri_parser_result_t *result, char *uri,\n                                char *uri_end)\n{\n    assert(uri);\n\n    /* search until first '/' */\n    char *authority_end = _strchrb(uri, uri_end, '/');\n    if (!authority_end) {\n        authority_end = uri_end;\n    }\n    result->host = uri;\n    result->host_len = authority_end - uri;\n\n    /* consume userinfo, if available */\n    _consume_userinfo(result, uri, authority_end);\n\n    char *ipv6_end = NULL;\n    /* validate IPv6 form */\n    if (result->host[0] == '[') {\n        ipv6_end = _strchrb(result->host, uri_end, ']');\n        /* found end marker of IPv6 form beyond authority part */\n        if (ipv6_end >= authority_end) {\n            return NULL;\n        }\n\n        char *zoneid_start = _strchrb(result->host, ipv6_end, '%');\n        if (zoneid_start) {\n            /* skip % */\n            result->zoneid = zoneid_start + 1;\n            result->zoneid_len = ipv6_end - result->zoneid;\n\n            /* zoneid cannot be empty */\n            if (result->zoneid_len == 0) {\n                return NULL;\n            }\n        }\n\n        /* remove '[', ']', and '%' zoneid from ipv6addr */\n        result->ipv6addr = result->host + 1;\n        result->ipv6addr_len = ipv6_end - result->ipv6addr;\n        if (result->zoneid) {\n            result->ipv6addr_len -= result->zoneid_len + 1;\n        }\n    }\n\n    /* consume port, if available */\n    if (!_consume_port(result, ipv6_end, authority_end)) {\n        return NULL;\n    }\n\n    /* do not allow empty host if userinfo or port are set */\n    if ((result->host_len == 0) &&\n        (result->userinfo || result->port)) {\n        return NULL;\n    }\n\n    /* this includes the '/' */\n    return authority_end;\n}\n\nstatic char *_consume_path(uri_parser_result_t *result, char *uri,\n                           char *uri_end)\n{\n    assert(uri);\n\n    result->path = uri;\n    result->path_len = (uri_end - uri);\n\n    /* check for query start '?' */\n    char *path_end = _strchrb(uri, uri_end, '?');\n\n    /* no query string found, return! */\n    if (!path_end) {\n        return (result->path + result->path_len);\n    }\n\n    /* there is a query string */\n    result->query = path_end + 1;\n    /* do not count '?' */\n    result->query_len = result->path_len - (path_end - uri) - 1;\n    /* cut path part before query and '?' */\n    result->path_len -= result->query_len + 1;\n\n    return (result->query + result->query_len);\n}\n\nstatic int _parse_relative(uri_parser_result_t *result, char *uri,\n                           char *uri_end)\n{\n    uri = _consume_path(result, uri, uri_end);\n    /* uri should point to uri_end, otherwise there's something left\n     * to consume ... */\n    if (uri != uri_end) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int _parse_absolute(uri_parser_result_t *result, char *uri,\n                           char *uri_end)\n{\n    bool has_authority;\n\n    uri = _consume_scheme(result, uri, uri_end, &has_authority);\n    if (uri == NULL) {\n        return -1;\n    }\n\n    if (has_authority) {\n        uri = _consume_authority(result, uri, uri_end);\n        if (uri == NULL) {\n            return -1;\n        }\n    }\n\n    /* parsing the path, starting with '/' */\n    return _parse_relative(result, uri, uri_end);\n}\n\nbool uri_parser_is_absolute(const char *uri, size_t uri_len)\n{\n    char *colon = _strchrb((char *)uri, (char *)(uri + uri_len), ':');\n\n    /* potentially absolute, if ':' exists */\n    if (colon) {\n        /* first character should be ALPHA */\n        if (!(((uri[0] >= 'A') && (uri[0] <= 'Z')) ||\n              ((uri[0] >= 'a') && (uri[0] <= 'z')))) {\n            /* relative */\n            return false;\n        }\n        for (int i = 0; &uri[i] < colon; ++i) {\n            if (!(((uri[i] >= 'A') && (uri[i] <= 'Z')) ||\n                  ((uri[i] >= 'a') && (uri[i] <= 'z')) ||\n                  ((uri[i] >= '0') && (uri[i] <= '9')) ||\n                  (uri[i] == '+') ||\n                  (uri[i] == '-') ||\n                  (uri[i] == '.'))) {\n                /* relative */\n                return false;\n            }\n        }\n\n        /* absolute */\n        return true;\n    }\n\n    /* relative */\n    return false;\n}\n\nbool uri_parser_is_absolute_string(const char *uri)\n{\n    return uri_parser_is_absolute(uri, strlen(uri));\n}\n\nint uri_parser_process(uri_parser_result_t *result, const char *uri,\n                       size_t uri_len)\n{\n    /* uri cannot be empty */\n    if ((NULL == uri) || (uri[0] == '\\0')) {\n        return -1;\n    }\n\n    memset(result, 0, sizeof(*result));\n\n    if (uri_parser_is_absolute(uri, uri_len)) {\n        return _parse_absolute(result, (char *)uri, (char *)(uri + uri_len));\n    }\n    else {\n        return _parse_relative(result, (char *)uri, (char *)(uri + uri_len));\n    }\n\n    return 0;\n}\n\nint uri_parser_process_string(uri_parser_result_t *result, const char *uri)\n{\n    return uri_parser_process(result, uri, strlen(uri));\n}\n", "/*\n * Copyright (C) 2020 HAW Hamburg\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n */\n\n#include <stdio.h>\n#include <stdbool.h>\n#include \"embUnit.h\"\n\n#include \"uri_parser.h\"\n\n#include \"unittests-constants.h\"\n#include \"tests-uri_parser.h\"\n\n#define VEC(u, f, s, us, h, v6a, z, po, pa, q, e)                           \\\n    { .uri = u, .full_uri = f, .scheme = s, .userinfo = us, .host = h,      \\\n      .ipv6addr = v6a, .zoneid = z, .port = po, .path = pa,                 \\\n      .query = q, .expected = e}\n\n#define VEC_CHECK(comp, i, vec_msg)                                         \\\n    do {                                                                    \\\n        if (ures.comp == NULL) {                                            \\\n            TEST_ASSERT(validate_uris[i].comp[0] == '\\0');                  \\\n        }                                                                   \\\n        else {                                                              \\\n            TEST_ASSERT_EQUAL_INT(strlen(validate_uris[i].comp),            \\\n                                  ures.comp##_len);                         \\\n            vec_msg[0] = '\\0';                                              \\\n            stdimpl_strcat(vec_msg, \"Unexpected \" # comp \" member \\\"\");     \\\n            stdimpl_strcat(vec_msg, validate_uris[i].comp);                 \\\n            stdimpl_strcat(vec_msg, \"\\\" for \\\"\");                           \\\n            stdimpl_strcat(vec_msg, validate_uris[i].uri);                  \\\n            stdimpl_strcat(vec_msg, \"\\\"\");                                  \\\n            TEST_ASSERT_MESSAGE(0 ==                                        \\\n                                  strncmp(ures.comp,                        \\\n                                          validate_uris[i].comp,            \\\n                                          strlen(validate_uris[i].comp)),   \\\n                                vec_msg);                                   \\\n        }                                                                   \\\n    } while (0)\n\n#define VEC_MSG_LEN (sizeof(\"Unexpected userinfo member \\\"\\\" for \\\"\\\"\") + \\\n                     64U + 8U)\n\ntypedef struct {\n    char uri[64];\n    bool full_uri;\n    char scheme[8];\n    char userinfo[16];\n    char host[24];\n    char ipv6addr[16];\n    char zoneid[8];\n    char port[32];\n    char path[48];\n    char query[32];\n    int expected;\n} validate_t;\n\n/*\n  VEC(uri_to_parse,\n      scheme, userinfo, host, port,\n      path, query, expected return value)\n*/\nstatic const validate_t validate_uris[] = {\n        /* uri to parse */\n    VEC(\"coap://RIOT:test@[fe80:db8::1%tap0]:5683/.well-known/core?v=1\",\n        /* is URI */\n        true,\n        /* parsed scheme */\n        \"coap\",\n        /* parsed userinfo */\n        \"RIOT:test\",\n        /* parsed host */\n        \"[fe80:db8::1%tap0]\",\n        /* parsed host without zoneid */\n        \"fe80:db8::1\",\n        /* parsed zoneid */\n        \"tap0\",\n        /* parsed port */\n        \"5683\",\n        /* parsed path */\n        \"/.well-known/core\",\n        /* parsed query */\n        \"v=1\",\n        /* expected return value */\n        0),\n    VEC(\"coap://RIOT:test@[fe80:db8::1%]:5683/.well-known/core?v=1\",\n        true,\n        \"coap\",\n        \"RIOT:test\",\n        \"[fe80:db8::1%]\",\n        \"fe80:db8::1\",\n        \"\",\n        \"5683\",\n        \"/.well-known/core\",\n        \"v=1\",\n        -1),\n    VEC(\"coap://[fe80::1]/foo%20bar\",\n        true,\n        \"coap\",\n        \"\",\n        \"[fe80::1]\",\n        \"fe80::1\",\n        \"\",\n        \"\",\n        \"/foo%20bar\",\n        \"\",\n        0),\n    VEC(\"/.well-known/core?v=1\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"/.well-known/core\",\n        \"v=1\",\n        0),\n    VEC(\"coap://R@[2001:db8::1]:5own/v=1\",\n        true,\n        \"coap\",\n        \"R\",\n        \"[2001:db8::1]\",\n        \"2001:db8::1\",\n        \"\",\n        \"5own\",\n        \"/v=1\",\n        \"\",\n        0),\n    VEC(\"coap://R@[2001:db8::1]:5own/:v=1\",\n        true,\n        \"coap\",\n        \"R\",\n        \"[2001:db8::1]\",\n        \"2001:db8::1\",\n        \"\",\n        \"5own\",\n        \"/:v=1\",\n        \"\",\n        0),\n    VEC(\"cap://R@[2001:db8::1]:5own/?v=1\",\n        true,\n        \"cap\",\n        \"R\",\n        \"[2001:db8::1]\",\n        \"2001:db8::1\",\n        \"\",\n        \"5own\",\n        \"/\",\n        \"v=1\",\n        0),\n    VEC(\"oap://Y2001:db8::1]:5own/av=1\",\n        true,\n        \"oap\",\n        \"\",\n        \"Y2001:db8::1]\",\n        \"\",\n        \"\",\n        \"5own\",\n        \"/av=1\",\n        \"\",\n        0),\n    VEC(\"//Rb[\u02b000J:d/5v=0\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"//Rb[\u02b000J:d/5v=0\",\n        \"\",\n        0),\n    VEC(\"coap://oap://P@[2001:b\",\n        true,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        -1),\n    VEC(\"coap:///R@[2008::1]:5own//R@[2008::1]:5own/?v=1\",\n        true,\n        \"coap\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"/R@[2008::1]:5own//R@[2008::1]:5own/\",\n        \"v=1\",\n        0),\n    VEC(\"coaP://R/RZ[2001[8:01[8::1]:5o:1]:5oTMv=1\",\n        true,\n        \"coaP\",\n        \"\",\n        \"R\",\n        \"\",\n        \"\",\n        \"\",\n        \"/RZ[2001[8:01[8::1]:5o:1]:5oTMv=1\",\n        \"\",\n        0),\n    VEC(\"coap://R@////////////////7///v=1\",\n        true,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        -1),\n    VEC(\"coa[:////[2001:db5ow:5own/Ov=1\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"coa[:////[2001:db5ow:5own/Ov=1\",\n        \"\",\n        0),\n    VEC(\"tel:+1-816-555-1212\",\n        true,\n        \"tel\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"+1-816-555-1212\",\n        \"\",\n        0),\n    VEC(\"sms:+15105550101,+15105550102?body=hello%20there\",\n        true,\n        \"sms\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"+15105550101,+15105550102\",\n        \"body=hello%20there\",\n        0),\n    VEC(\"a\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"a\",\n        \"\",\n        0),\n    VEC(\"mailto:test@example.com\",\n        true,\n        \"mailto\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"test@example.com\",\n        \"\",\n        0),\n    VEC(\"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n        true,\n        \"ftp\",\n        \"\",\n        \"ftp.is.co.za\",\n        \"\",\n        \"\",\n        \"\",\n        \"/rfc/rfc1808.txt\",\n        \"\",\n        0),\n    VEC(\"http://www.ietf.org/rfc/rfc2396.txt\",\n        true,\n        \"http\",\n        \"\",\n        \"www.ietf.org\",\n        \"\",\n        \"\",\n        \"\",\n        \"/rfc/rfc2396.txt\",\n        \"\",\n        0),\n    VEC(\"ldap://[2001:db8::7]/c=GB?objectClass?one\",\n        true,\n        \"ldap\",\n        \"\",\n        \"[2001:db8::7]\",\n        \"2001:db8::7\",\n        \"\",\n        \"\",\n        \"/c=GB\",\n        \"objectClass?one\",\n        0),\n    VEC(\"mailto:John.Doe@example.com\",\n        true,\n        \"mailto\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"John.Doe@example.com\",\n        \"\",\n        0),\n    VEC(\"news:comp.infosystems.www.servers.unix\",\n        true,\n        \"news\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"comp.infosystems.www.servers.unix\",\n        \"\",\n        0),\n    VEC(\"tel:+1-816-555-1212\",\n        true,\n        \"tel\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"+1-816-555-1212\",\n        \"\",\n        0),\n    VEC(\"telnet://192.0.2.16:80/\",\n        true,\n        \"telnet\",\n        \"\",\n        \"192.0.2.16\",\n        \"\",\n        \"\",\n        \"80\",\n        \"/\",\n        \"\",\n        0),\n    VEC(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        true,\n        \"urn\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        \"\",\n        0),\n    VEC(\"\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        -1),\n    VEC(\"/\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"/\",\n        \"\",\n        0),\n    VEC(\"./this:that\",\n        false,\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"./this:that\",\n        \"\",\n        0),\n    VEC(\"pP://\",\n        true,\n        \"pP\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        0),\n};\n\nstatic char _failure_msg[VEC_MSG_LEN];\n\nstatic void test_uri_parser__validate(void)\n{\n    uri_parser_result_t ures;\n    for (unsigned i = 0; i < ARRAY_SIZE(validate_uris); i++) {\n        int res = uri_parser_process_string(&ures, validate_uris[i].uri);\n        TEST_ASSERT_EQUAL_INT(validate_uris[i].full_uri,\n               uri_parser_is_absolute_string(validate_uris[i].uri));\n        TEST_ASSERT_EQUAL_INT(validate_uris[i].expected, res);\n        if (res == 0) {\n            VEC_CHECK(scheme, i, _failure_msg);\n            VEC_CHECK(userinfo, i, _failure_msg);\n            VEC_CHECK(host, i, _failure_msg);\n            VEC_CHECK(ipv6addr, i, _failure_msg);\n            VEC_CHECK(zoneid, i, _failure_msg);\n            VEC_CHECK(port, i, _failure_msg);\n            VEC_CHECK(path, i, _failure_msg);\n            VEC_CHECK(query, i, _failure_msg);\n        }\n    }\n}\n\nstatic void test_uri_parser__unterminated_string(void)\n{\n    uri_parser_result_t ures;\n    char uri[64];\n    /* initialize with a non-null character */\n    memset(uri, 'Z', sizeof(uri));\n\n    memcpy(uri, validate_uris[0].uri, strlen(validate_uris[0].uri));\n\n    int res = uri_parser_process(&ures, uri, strlen(validate_uris[0].uri));\n\n    TEST_ASSERT_EQUAL_INT(0, res);\n    VEC_CHECK(scheme, 0, _failure_msg);\n    VEC_CHECK(userinfo, 0, _failure_msg);\n    VEC_CHECK(host, 0, _failure_msg);\n    VEC_CHECK(ipv6addr, 0, _failure_msg);\n    VEC_CHECK(zoneid, 0, _failure_msg);\n    VEC_CHECK(port, 0, _failure_msg);\n    VEC_CHECK(path, 0, _failure_msg);\n    VEC_CHECK(query, 0, _failure_msg);\n}\n\nTest *tests_uri_parser_tests(void)\n{\n    EMB_UNIT_TESTFIXTURES(fixtures) {\n        new_TestFixture(test_uri_parser__validate),\n        new_TestFixture(test_uri_parser__unterminated_string),\n    };\n\n    EMB_UNIT_TESTCALLER(uri_parser_tests, NULL, NULL, fixtures);\n\n    return (Test *)&uri_parser_tests;\n}\n\nvoid tests_uri_parser(void)\n{\n    TESTS_RUN(tests_uri_parser_tests());\n}\n/** @} */\n"], "filenames": ["sys/uri_parser/uri_parser.c", "tests/unittests/tests-uri_parser/tests-uri_parser.c"], "buggy_code_start_loc": [58, 403], "buggy_code_end_loc": [59, 403], "fixing_code_start_loc": [58, 404], "fixing_code_end_loc": [59, 415], "type": "CWE-120", "message": "RIOT-OS 2021.01 before commit 07f1254d8537497552e7dce80364aaead9266bbe contains a buffer overflow which could allow attackers to obtain sensitive information.", "other": {"cve": {"id": "CVE-2021-31662", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-18T22:15:11.937", "lastModified": "2021-06-22T15:46:48.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RIOT-OS 2021.01 before commit 07f1254d8537497552e7dce80364aaead9266bbe contains a buffer overflow which could allow attackers to obtain sensitive information."}, {"lang": "es", "value": "RIOT-OS 2021.01 anterior al commit 07f1254d8537497552e7dce80364aaead9266bbe, contiene un desbordamiento de b\u00fafer que podr\u00eda permitir a atacantes obtener informaci\u00f3n confidencial"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:riot-os:riot:2021.01:-:*:*:*:*:*:*", "matchCriteriaId": "21164D26-DC7F-423B-9832-2C4C494307E0"}]}]}], "references": [{"url": "https://github.com/RIOT-OS/RIOT/commit/07f1254d8537497552e7dce80364aaead9266bbe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/RIOT-OS/RIOT/pull/15930", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/RIOT-OS/RIOT/commit/07f1254d8537497552e7dce80364aaead9266bbe"}}