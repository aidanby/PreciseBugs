{"buggy_code": ["\"\"\"DWC Network Server Emulator\n\n    Copyright (C) 2014 polaris-\n    Copyright (C) 2014 ToadKing\n    Copyright (C) 2014 AdmiralCurtiss\n    Copyright (C) 2015 Sepalani\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as\n    published by the Free Software Foundation, either version 3 of the\n    License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\nimport sqlite3\nimport hashlib\nimport itertools\nimport json\nimport time\nimport logging\nfrom contextlib import closing\n\nimport other.utils as utils\nimport gamespy.gs_utility as gs_utils\n\n# Logger settings\nSQL_LOGLEVEL = logging.DEBUG\nlogger_output_to_console = True\nlogger_output_to_file = True\nlogger_name = \"GamespyDatabase\"\nlogger_filename = \"gamespy_database.log\"\nlogger = utils.create_logger(logger_name, logger_filename, -1,\n                             logger_output_to_console, logger_output_to_file)\n\n\nclass Transaction(object):\n    def __init__(self, connection):\n        self.conn = connection\n        self.databaseAltered = False\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        if self.databaseAltered:\n            self.conn.commit()\n        return\n\n    def _executeAndMeasure(self, cursor, statement, parameters):\n        logTransactionId = utils.generate_random_str(8)\n\n        logger.log(SQL_LOGLEVEL, \"[%s] STARTING: \" % logTransactionId +\n                                 statement.replace('?', '%s') % parameters)\n\n        timeStart = time.time()\n        clockStart = time.clock()\n\n        cursor.execute(statement, parameters)\n\n        clockEnd = time.clock()\n        timeEnd = time.time()\n        timeDiff = timeEnd - timeStart\n\n        logger.log(SQL_LOGLEVEL,\n                   \"[%s] DONE: Took %s real time / %s processor time\",\n                   logTransactionId, timeDiff, clockEnd - clockStart)\n        if timeDiff > 1.0:\n            logger.log(logging.WARNING,\n                       \"[%s] WARNING: SQL Statement took %s seconds!\",\n                       logTransactionId, timeDiff)\n            logger.log(logging.WARNING,\n                       \"[%s] \" % logTransactionId +\n                       statement.replace('?', '%s') % parameters)\n        return\n\n    def queryall(self, statement, parameters=()):\n        with closing(self.conn.cursor()) as cursor:\n            self._executeAndMeasure(cursor, statement, parameters)\n            rows = cursor.fetchall()\n            return rows\n        return []\n\n    def queryone(self, statement, parameters=()):\n        with closing(self.conn.cursor()) as cursor:\n            self._executeAndMeasure(cursor, statement, parameters)\n            row = cursor.fetchone()\n            return row\n        return []\n\n    def nonquery(self, statement, parameters=()):\n        with closing(self.conn.cursor()) as cursor:\n            self._executeAndMeasure(cursor, statement, parameters)\n            self.databaseAltered = True\n        return\n\n\nclass GamespyDatabase(object):\n    def __init__(self, filename='gpcm.db'):\n        self.conn = sqlite3.connect(filename, timeout=10.0)\n        self.conn.row_factory = sqlite3.Row\n\n        # self.initialize_database()\n\n    def __del__(self):\n        self.close()\n\n    def close(self):\n        if self.conn is not None:\n            self.conn.close()\n            self.conn = None\n\n    def initialize_database(self):\n        with Transaction(self.conn) as tx:\n            # I highly doubt having everything in a database be of the type\n            # TEXT is a good practice, but I'm not good with databases and\n            # I'm not 100% positive that, for instance, that all user id's\n            # will be ints, or all passwords will be ints, etc, despite not\n            # seeing any evidence yet to say otherwise as far as Nintendo\n            # DS games go.\n\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS users\"\n                        \" (profileid INT, userid TEXT, password TEXT,\"\n                        \" gsbrcd TEXT, email TEXT, uniquenick TEXT,\"\n                        \" pid TEXT, lon TEXT, lat TEXT, loc TEXT,\"\n                        \" firstname TEXT, lastname TEXT, stat TEXT,\"\n                        \" partnerid TEXT, console INT, csnum TEXT,\"\n                        \" cfc TEXT, bssid TEXT, devname BLOB, birth TEXT,\"\n                        \" gameid TEXT, enabled INT, zipcode TEXT, aim TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS sessions\"\n                        \" (session TEXT, profileid INT, loginticket TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS buddies\"\n                        \" (userProfileId INT, buddyProfileId INT, time INT,\"\n                        \" status INT, notified INT, gameid TEXT,\"\n                        \" blocked INT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS pending_messages\"\n                        \" (sourceid INT, targetid INT, msg TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS gamestat_profile\"\n                        \" (profileid INT, dindex TEXT, ptype TEXT,\"\n                        \" data TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS gameinfo\"\n                        \" (profileid INT, dindex TEXT, ptype TEXT,\"\n                        \" data TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS nas_logins\"\n                        \" (userid TEXT, authtoken TEXT, data TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS banned\"\n                        \" (gameid TEXT, ipaddr TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS pending (macadr TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS registered (macadr TEXT)\")\n\n            # Create some indexes for performance.\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" gamestatprofile_triple\"\n                        \" ON gamestat_profile(profileid,dindex,ptype)\")\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" users_profileid_idx ON users (profileid)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" users_userid_idx ON users (userid)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" pending_messages_targetid_idx\"\n                        \" ON pending_messages (targetid)\")\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" sessions_session_idx ON sessions (session)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" sessions_loginticket_idx ON sessions (loginticket)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" sessions_profileid_idx ON sessions (profileid)\")\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" nas_logins_authtoken_idx ON nas_logins (authtoken)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" nas_logins_userid_idx ON nas_logins (userid)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" buddies_userProfileId_idx\"\n                        \" ON buddies (userProfileId)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" buddies_buddyProfileId_idx\"\n                        \" ON buddies (buddyProfileId)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" gamestat_profile_profileid_idx\"\n                        \" ON gamestat_profile (profileid)\")\n\n    def get_dict(self, row):\n        if not row:\n            return None\n\n        return dict(itertools.izip(row.keys(), row))\n\n    # User functions\n    def get_next_free_profileid(self):\n        \"\"\"TODO: Make profile ids start at 1 for each game?\n\n        TODO: This leads to a race condition if two users try to create\n        accounts at the same time. Instead, it's better to create a new row\n        and return the sqlite ROWID instead.\n        \"\"\"\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\"SELECT max(profileid) AS m FROM users\")\n            r = self.get_dict(row)\n\n        profileid = 1  # Cannot be 0 or else it freezes the game.\n        if r is not None and r['m'] is not None:\n            profileid = int(r['m']) + 1\n\n        return profileid\n\n    def check_user_exists(self, userid, gsbrcd):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM users WHERE userid = ? AND gsbrcd = ?\",\n                (userid, gsbrcd)\n            )\n            count = int(row[0])\n        return count > 0\n\n    def check_user_enabled(self, userid, gsbrcd):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT enabled FROM users WHERE userid = ? AND gsbrcd = ?\",\n                (userid, gsbrcd)\n            )\n            enabled = int(row[0])\n        return enabled > 0\n\n    def check_profile_exists(self, profileid):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM users WHERE profileid = ?\",\n                (profileid,)\n            )\n            count = int(row[0])\n        return count > 0\n\n    def get_profile_from_profileid(self, profileid):\n        profile = {}\n        if profileid:\n            with Transaction(self.conn) as tx:\n                row = tx.queryone(\n                    \"SELECT * FROM users WHERE profileid = ?\",\n                    (profileid,)\n                )\n                profile = self.get_dict(row)\n        return profile\n\n    def perform_login(self, userid, password, gsbrcd):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT * FROM users WHERE userid = ? and gsbrcd = ?\",\n                (userid, gsbrcd)\n            )\n            r = self.get_dict(row)\n\n        profileid = None  # Default, user doesn't exist\n        if r is not None:\n            # md5 = hashlib.md5()\n            # md5.update(password)\n\n            # if r['password'] == md5.hexdigest():\n            #     profileid = r['profileid']  # Valid password\n\n            if r['enabled'] == 1 and r['gsbrcd'] == gsbrcd:\n                profileid = r['profileid']  # Valid password\n\n        return profileid\n\n    def create_user(self, userid, password, email, uniquenick, gsbrcd,\n                    console, csnum, cfc, bssid, devname, birth, gameid,\n                    macadr):\n        if not self.check_user_exists(userid, gsbrcd):\n            profileid = self.get_next_free_profileid()\n\n            # Always 11??? Is this important? Not to be confused with dwc_pid.\n            # The three games I found it in (Tetris DS, Advance Wars - Days of\n            # Ruin, and Animal Crossing: Wild World) all use \\pid\\11.\n            pid = \"11\"\n            lon = \"0.000000\"  # Always 0.000000?\n            lat = \"0.000000\"  # Always 0.000000?\n            loc = \"\"\n            firstname = \"\"\n            lastname = \"\"\n            stat = \"\"\n            partnerid = \"\"\n            enabled = 1\n            zipcode = \"\"\n            aim = \"\"\n\n            # Hash password before entering it into the database.\n            # For now I'm using a very simple MD5 hash.\n            # TODO: Replace with something stronger later, although it's\n            # overkill for the NDS.\n            md5 = hashlib.md5()\n            md5.update(password)\n            password = md5.hexdigest()\n\n            with Transaction(self.conn) as tx:\n                q = \"INSERT INTO users VALUES\" \\\n                    \" (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"\n                tx.nonquery(q, (profileid, str(userid), password, gsbrcd,\n                                email, uniquenick, pid, lon, lat, loc,\n                                firstname, lastname, stat, partnerid,\n                                console, csnum, cfc, bssid, devname, birth,\n                                gameid, enabled, zipcode, aim))\n\n            return profileid\n        return None\n\n    def import_user(self, profileid, uniquenick, firstname, lastname, email,\n                    gsbrcd, gameid, console):\n        if not self.check_profile_exists(profileid):\n            pid = \"11\"\n            lon = \"0.000000\"\n            lat = \"0.000000\"\n            loc = \"\"\n            stat = \"\"\n            partnerid = \"\"\n            password = \"\"\n            userid = \"\"\n\n            csnum = \"\"\n            cfc = \"\"\n            bssid = \"\"\n            devname = \"\"\n            birth = \"\"\n            zipcode = \"\"\n            aim = \"\"\n\n            enabled = 1\n\n            with Transaction(self.conn) as tx:\n                q = \"INSERT INTO users VALUES\" \\\n                    \" (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"\n                tx.nonquery(q, (profileid, str(userid), password, gsbrcd,\n                                email, uniquenick, pid, lon, lat, loc,\n                                firstname, lastname, stat, partnerid,\n                                console, csnum, cfc, bssid, devname, birth,\n                                gameid, enabled, zipcode, aim))\n\n            return profileid\n\n    def get_user_list(self):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\"SELECT * FROM users\")\n\n        return [self.get_dict(row) for row in rows]\n\n    def save_pending_message(self, sourceid, targetid, msg):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\"INSERT INTO pending_messages VALUES (?,?,?)\",\n                        (sourceid, targetid, msg))\n\n    def get_pending_messages(self, profileid):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM pending_messages WHERE targetid = ?\",\n                (profileid,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def update_profile(self, profileid, field):\n        \"\"\"Found profile id associated with session key.\n\n        Start replacing each field one by one.\n        TODO: Optimize this so it's done all in one update.\n        FIXME: Possible security issue due to embedding an unsanitized\n        string directly into the statement.\n        \"\"\"\n        with Transaction(self.conn) as tx:\n            q = \"UPDATE users SET \\\"%s\\\" = ? WHERE profileid = ?\"\n            tx.nonquery(q % field[0], (field[1], profileid))\n\n    # Session functions\n    # TODO: Cache session keys so we don't have to query the database every\n    # time we get a profile id.\n    def get_profileid_from_session_key(self, session_key):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT profileid FROM sessions WHERE session = ?\",\n                (session_key,)\n            )\n            r = self.get_dict(row)\n\n        profileid = -1  # Default, invalid session key\n        if r is not None:\n            profileid = r['profileid']\n\n        return profileid\n\n    def get_profileid_from_loginticket(self, loginticket):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT profileid FROM sessions WHERE loginticket = ?\",\n                (loginticket,)\n            )\n\n        profileid = -1\n        if row:\n            profileid = int(row[0])\n\n        return profileid\n\n    def get_profile_from_session_key(self, session_key):\n        profileid = self.get_profileid_from_session_key(session_key)\n\n        profile = {}\n        if profileid:\n            with Transaction(self.conn) as tx:\n                row = tx.queryone(\n                    \"SELECT profileid FROM sessions WHERE session = ?\",\n                    (session_key,)\n                )\n                profile = self.get_dict(row)\n\n        return profile\n\n    def generate_session_key(self, min_size):\n        \"\"\"Generate session key.\n\n        TODO: There's probably a better way to do this.\n        The point is preventing duplicate session keys.\n        \"\"\"\n        while True:\n            with Transaction(self.conn) as tx:\n                session_key = utils.generate_random_number_str(min_size)\n                row = tx.queryone(\n                    \"SELECT COUNT(*) FROM sessions WHERE session = ?\",\n                    (session_key,)\n                )\n                count = int(row[0])\n                if not count:\n                    return session_key\n\n    def delete_session(self, profileid):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"DELETE FROM sessions WHERE profileid = ?\",\n                (profileid,)\n            )\n\n    def create_session(self, profileid, loginticket):\n        if profileid is not None and not self.check_profile_exists(profileid):\n            return None\n\n        # Remove any old sessions associated with this user id\n        self.delete_session(profileid)\n\n        # Create new session\n        session_key = self.generate_session_key(8)\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"INSERT INTO sessions VALUES (?, ?, ?)\",\n                (session_key, profileid, loginticket)\n            )\n\n        return session_key\n\n    def get_session_list(self, profileid=None):\n        with Transaction(self.conn) as tx:\n            if profileid is not None:\n                r = tx.queryall(\n                    \"SELECT * FROM sessions WHERE profileid = ?\",\n                    (profileid,)\n                )\n            else:\n                r = tx.queryall(\"SELECT * FROM sessions\")\n\n        return [self.get_dict(row) for row in r]\n\n    # nas server functions\n    def get_nas_login(self, authtoken):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT data FROM nas_logins WHERE authtoken = ?\",\n                (authtoken,)\n            )\n            r = self.get_dict(row)\n\n        if r is None:\n            return None\n        else:\n            return json.loads(r[\"data\"])\n\n    def get_nas_login_from_userid(self, userid):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT data FROM nas_logins WHERE userid = ?\",\n                (userid,)\n            )\n            r = self.get_dict(row)\n\n        if r is None:\n            return None\n        else:\n            return json.loads(r[\"data\"])\n\n    def is_banned(self, postdata):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM banned WHERE gameid = ? AND ipaddr = ?\",\n                (postdata['gamecd'][:-1], postdata['ipaddr'])\n            )\n        return int(row[0]) > 0\n\n    def pending(self, postdata):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM pending WHERE macadr = ?\",\n                (postdata['macadr'],)\n            )\n            return int(row[0]) > 0\n\n    def registered(self, postdata):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM registered WHERE macadr = ?\",\n                (postdata['macadr'],)\n            )\n            return int(row[0]) > 0\n\n    def get_next_available_userid(self):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\"SELECT max(userid) AS maxuser FROM users\")\n            r = self.get_dict(row)\n        if r is None or r['maxuser'] is None:\n            # Because all zeroes means Dolphin. Don't wanna get confused\n            # during debugging later.\n            return '0000000000002'\n        else:\n            userid = str(int(r['maxuser']) + 1)\n            while len(userid) < 13:\n                userid = \"0\" + userid\n            return userid\n\n    def generate_authtoken(self, userid, data):\n        \"\"\"Generate authentication token.\n\n        Since the auth token passed back to the game will be random, we can\n        make it small enough that there should never be a crash due to the\n        size of the token.\n        ^ real authtoken is 80 + 3 bytes though and I want to figure out\n        what's causing the 52200 so I'm matching everything as closely as\n        possible to the real thing.\n        \"\"\"\n        size = 80\n\n        # TODO: Another one of those questionable dupe-preventations\n        while True:\n            with Transaction(self.conn) as tx:\n                authtoken = \"NDS\" + utils.generate_random_str(size)\n                row = tx.queryone(\n                    \"SELECT COUNT(*) FROM nas_logins WHERE authtoken = ?\",\n                    (authtoken,)\n                )\n                count = int(row[0])\n                if not count:\n                    break\n\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT * FROM nas_logins WHERE userid = ?\",\n                (userid,)\n            )\n            r = self.get_dict(row)\n\n        if \"devname\" in data:\n            data[\"devname\"] = gs_utils.base64_encode(data[\"devname\"])\n        if \"ingamesn\" in data:\n            data[\"ingamesn\"] = gs_utils.base64_encode(data[\"ingamesn\"])\n\n        data = json.dumps(data)\n\n        with Transaction(self.conn) as tx:\n            if r is None:  # no row, add it\n                tx.nonquery(\n                    \"INSERT INTO nas_logins VALUES (?, ?, ?)\",\n                    (userid, authtoken, data)\n                )\n            else:\n                tx.nonquery(\n                    \"UPDATE nas_logins SET authtoken = ?, data = ?\"\n                    \" WHERE userid = ?\",\n                    (authtoken, data, userid)\n                )\n\n        return authtoken\n\n    # Buddy functions\n    def add_buddy(self, userProfileId, buddyProfileId):\n        now = int(time.time())\n\n        # status == 0 -> not authorized\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"INSERT INTO buddies VALUES (?, ?, ?, ?, ?, ?, ?)\",\n                (userProfileId, buddyProfileId, now, 0, 0, \"\", 0)\n            )\n\n    def auth_buddy(self, userProfileId, buddyProfileId):\n        # status == 1 -> authorized\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET status = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (1, userProfileId, buddyProfileId)\n            )\n\n    def block_buddy(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET blocked = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (1, userProfileId, buddyProfileId)\n            )\n\n    def unblock_buddy(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET blocked = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (0, userProfileId, buddyProfileId)\n            )\n\n    def get_buddy(self, userProfileId, buddyProfileId):\n        if userProfileId and buddyProfileId:\n            with Transaction(self.conn) as tx:\n                row = tx.queryone(\n                    \"SELECT * FROM buddies\"\n                    \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                    (userProfileId, buddyProfileId)\n                )\n                return self.get_dict(row)\n        return {}\n\n    def delete_buddy(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"DELETE FROM buddies\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (userProfileId, buddyProfileId)\n            )\n\n    def get_buddy_list(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE userProfileId = ? AND blocked = 0\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def get_blocked_list(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE userProfileId = ? AND blocked = 1\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def get_pending_buddy_requests(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE buddyProfileId = ? AND status = 0\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def buddy_need_auth_message(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE buddyProfileId = ? AND status = 1 AND notified = 0\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def buddy_sent_auth_message(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET notified = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (1, userProfileId, buddyProfileId)\n            )\n\n    # Gamestats-related functions\n    def pd_insert(self, profileid, dindex, ptype, data):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM gamestat_profile\"\n                \" WHERE profileid = ? AND dindex = ? AND ptype = ?\",\n                (profileid, dindex, ptype)\n            )\n            count = int(row[0])\n            if count > 0:\n                tx.nonquery(\n                    \"UPDATE gamestat_profile SET data = ?\"\n                    \" WHERE profileid = ? AND dindex = ? AND ptype = ?\",\n                    (data, profileid, dindex, ptype)\n                )\n            else:\n                tx.nonquery(\n                    \"INSERT INTO gamestat_profile\"\n                    \" (profileid, dindex, ptype, data) VALUES(?,?,?,?)\",\n                    (profileid, dindex, ptype, data)\n                )\n\n    def pd_get(self, profileid, dindex, ptype):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT * FROM gamestat_profile\"\n                \" WHERE profileid = ? AND dindex = ? AND ptype = ?\",\n                (profileid, dindex, ptype)\n            )\n        return self.get_dict(row)\n"], "fixing_code": ["\"\"\"DWC Network Server Emulator\n\n    Copyright (C) 2014 polaris-\n    Copyright (C) 2014 ToadKing\n    Copyright (C) 2014 AdmiralCurtiss\n    Copyright (C) 2015 Sepalani\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as\n    published by the Free Software Foundation, either version 3 of the\n    License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\nimport sqlite3\nimport hashlib\nimport itertools\nimport json\nimport time\nimport logging\nfrom contextlib import closing\n\nimport other.utils as utils\nimport gamespy.gs_utility as gs_utils\n\n# Logger settings\nSQL_LOGLEVEL = logging.DEBUG\nlogger_output_to_console = True\nlogger_output_to_file = True\nlogger_name = \"GamespyDatabase\"\nlogger_filename = \"gamespy_database.log\"\nlogger = utils.create_logger(logger_name, logger_filename, -1,\n                             logger_output_to_console, logger_output_to_file)\n\n\nclass Transaction(object):\n    def __init__(self, connection):\n        self.conn = connection\n        self.databaseAltered = False\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        if self.databaseAltered:\n            self.conn.commit()\n        return\n\n    def _executeAndMeasure(self, cursor, statement, parameters):\n        logTransactionId = utils.generate_random_str(8)\n\n        logger.log(SQL_LOGLEVEL, \"[%s] STARTING: \" % logTransactionId +\n                                 statement.replace('?', '%s') % parameters)\n\n        timeStart = time.time()\n        clockStart = time.clock()\n\n        cursor.execute(statement, parameters)\n\n        clockEnd = time.clock()\n        timeEnd = time.time()\n        timeDiff = timeEnd - timeStart\n\n        logger.log(SQL_LOGLEVEL,\n                   \"[%s] DONE: Took %s real time / %s processor time\",\n                   logTransactionId, timeDiff, clockEnd - clockStart)\n        if timeDiff > 1.0:\n            logger.log(logging.WARNING,\n                       \"[%s] WARNING: SQL Statement took %s seconds!\",\n                       logTransactionId, timeDiff)\n            logger.log(logging.WARNING,\n                       \"[%s] \" % logTransactionId +\n                       statement.replace('?', '%s') % parameters)\n        return\n\n    def queryall(self, statement, parameters=()):\n        with closing(self.conn.cursor()) as cursor:\n            self._executeAndMeasure(cursor, statement, parameters)\n            rows = cursor.fetchall()\n            return rows\n        return []\n\n    def queryone(self, statement, parameters=()):\n        with closing(self.conn.cursor()) as cursor:\n            self._executeAndMeasure(cursor, statement, parameters)\n            row = cursor.fetchone()\n            return row\n        return []\n\n    def nonquery(self, statement, parameters=()):\n        with closing(self.conn.cursor()) as cursor:\n            self._executeAndMeasure(cursor, statement, parameters)\n            self.databaseAltered = True\n        return\n\n\nclass GamespyDatabase(object):\n    def __init__(self, filename='gpcm.db'):\n        self.conn = sqlite3.connect(filename, timeout=10.0)\n        self.conn.row_factory = sqlite3.Row\n\n        # self.initialize_database()\n\n    def __del__(self):\n        self.close()\n\n    def close(self):\n        if self.conn is not None:\n            self.conn.close()\n            self.conn = None\n\n    def initialize_database(self):\n        with Transaction(self.conn) as tx:\n            # I highly doubt having everything in a database be of the type\n            # TEXT is a good practice, but I'm not good with databases and\n            # I'm not 100% positive that, for instance, that all user id's\n            # will be ints, or all passwords will be ints, etc, despite not\n            # seeing any evidence yet to say otherwise as far as Nintendo\n            # DS games go.\n\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS users\"\n                        \" (profileid INT, userid TEXT, password TEXT,\"\n                        \" gsbrcd TEXT, email TEXT, uniquenick TEXT,\"\n                        \" pid TEXT, lon TEXT, lat TEXT, loc TEXT,\"\n                        \" firstname TEXT, lastname TEXT, stat TEXT,\"\n                        \" partnerid TEXT, console INT, csnum TEXT,\"\n                        \" cfc TEXT, bssid TEXT, devname BLOB, birth TEXT,\"\n                        \" gameid TEXT, enabled INT, zipcode TEXT, aim TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS sessions\"\n                        \" (session TEXT, profileid INT, loginticket TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS buddies\"\n                        \" (userProfileId INT, buddyProfileId INT, time INT,\"\n                        \" status INT, notified INT, gameid TEXT,\"\n                        \" blocked INT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS pending_messages\"\n                        \" (sourceid INT, targetid INT, msg TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS gamestat_profile\"\n                        \" (profileid INT, dindex TEXT, ptype TEXT,\"\n                        \" data TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS gameinfo\"\n                        \" (profileid INT, dindex TEXT, ptype TEXT,\"\n                        \" data TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS nas_logins\"\n                        \" (userid TEXT, authtoken TEXT, data TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS banned\"\n                        \" (gameid TEXT, ipaddr TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS pending (macadr TEXT)\")\n            tx.nonquery(\"CREATE TABLE IF NOT EXISTS registered (macadr TEXT)\")\n\n            # Create some indexes for performance.\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" gamestatprofile_triple\"\n                        \" ON gamestat_profile(profileid,dindex,ptype)\")\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" users_profileid_idx ON users (profileid)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" users_userid_idx ON users (userid)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" pending_messages_targetid_idx\"\n                        \" ON pending_messages (targetid)\")\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" sessions_session_idx ON sessions (session)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" sessions_loginticket_idx ON sessions (loginticket)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" sessions_profileid_idx ON sessions (profileid)\")\n            tx.nonquery(\"CREATE UNIQUE INDEX IF NOT EXISTS\"\n                        \" nas_logins_authtoken_idx ON nas_logins (authtoken)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" nas_logins_userid_idx ON nas_logins (userid)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" buddies_userProfileId_idx\"\n                        \" ON buddies (userProfileId)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" buddies_buddyProfileId_idx\"\n                        \" ON buddies (buddyProfileId)\")\n            tx.nonquery(\"CREATE INDEX IF NOT EXISTS\"\n                        \" gamestat_profile_profileid_idx\"\n                        \" ON gamestat_profile (profileid)\")\n\n    def get_dict(self, row):\n        if not row:\n            return None\n\n        return dict(itertools.izip(row.keys(), row))\n\n    # User functions\n    def get_next_free_profileid(self):\n        \"\"\"TODO: Make profile ids start at 1 for each game?\n\n        TODO: This leads to a race condition if two users try to create\n        accounts at the same time. Instead, it's better to create a new row\n        and return the sqlite ROWID instead.\n        \"\"\"\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\"SELECT max(profileid) AS m FROM users\")\n            r = self.get_dict(row)\n\n        profileid = 1  # Cannot be 0 or else it freezes the game.\n        if r is not None and r['m'] is not None:\n            profileid = int(r['m']) + 1\n\n        return profileid\n\n    def check_user_exists(self, userid, gsbrcd):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM users WHERE userid = ? AND gsbrcd = ?\",\n                (userid, gsbrcd)\n            )\n            count = int(row[0])\n        return count > 0\n\n    def check_user_enabled(self, userid, gsbrcd):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT enabled FROM users WHERE userid = ? AND gsbrcd = ?\",\n                (userid, gsbrcd)\n            )\n            enabled = int(row[0])\n        return enabled > 0\n\n    def check_profile_exists(self, profileid):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM users WHERE profileid = ?\",\n                (profileid,)\n            )\n            count = int(row[0])\n        return count > 0\n\n    def get_profile_from_profileid(self, profileid):\n        profile = {}\n        if profileid:\n            with Transaction(self.conn) as tx:\n                row = tx.queryone(\n                    \"SELECT * FROM users WHERE profileid = ?\",\n                    (profileid,)\n                )\n                profile = self.get_dict(row)\n        return profile\n\n    def perform_login(self, userid, password, gsbrcd):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT * FROM users WHERE userid = ? and gsbrcd = ?\",\n                (userid, gsbrcd)\n            )\n            r = self.get_dict(row)\n\n        profileid = None  # Default, user doesn't exist\n        if r is not None:\n            # md5 = hashlib.md5()\n            # md5.update(password)\n\n            # if r['password'] == md5.hexdigest():\n            #     profileid = r['profileid']  # Valid password\n\n            if r['enabled'] == 1 and r['gsbrcd'] == gsbrcd:\n                profileid = r['profileid']  # Valid password\n\n        return profileid\n\n    def create_user(self, userid, password, email, uniquenick, gsbrcd,\n                    console, csnum, cfc, bssid, devname, birth, gameid,\n                    macadr):\n        if not self.check_user_exists(userid, gsbrcd):\n            profileid = self.get_next_free_profileid()\n\n            # Always 11??? Is this important? Not to be confused with dwc_pid.\n            # The three games I found it in (Tetris DS, Advance Wars - Days of\n            # Ruin, and Animal Crossing: Wild World) all use \\pid\\11.\n            pid = \"11\"\n            lon = \"0.000000\"  # Always 0.000000?\n            lat = \"0.000000\"  # Always 0.000000?\n            loc = \"\"\n            firstname = \"\"\n            lastname = \"\"\n            stat = \"\"\n            partnerid = \"\"\n            enabled = 1\n            zipcode = \"\"\n            aim = \"\"\n\n            # Hash password before entering it into the database.\n            # For now I'm using a very simple MD5 hash.\n            # TODO: Replace with something stronger later, although it's\n            # overkill for the NDS.\n            md5 = hashlib.md5()\n            md5.update(password)\n            password = md5.hexdigest()\n\n            with Transaction(self.conn) as tx:\n                q = \"INSERT INTO users VALUES\" \\\n                    \" (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"\n                tx.nonquery(q, (profileid, str(userid), password, gsbrcd,\n                                email, uniquenick, pid, lon, lat, loc,\n                                firstname, lastname, stat, partnerid,\n                                console, csnum, cfc, bssid, devname, birth,\n                                gameid, enabled, zipcode, aim))\n\n            return profileid\n        return None\n\n    def import_user(self, profileid, uniquenick, firstname, lastname, email,\n                    gsbrcd, gameid, console):\n        if not self.check_profile_exists(profileid):\n            pid = \"11\"\n            lon = \"0.000000\"\n            lat = \"0.000000\"\n            loc = \"\"\n            stat = \"\"\n            partnerid = \"\"\n            password = \"\"\n            userid = \"\"\n\n            csnum = \"\"\n            cfc = \"\"\n            bssid = \"\"\n            devname = \"\"\n            birth = \"\"\n            zipcode = \"\"\n            aim = \"\"\n\n            enabled = 1\n\n            with Transaction(self.conn) as tx:\n                q = \"INSERT INTO users VALUES\" \\\n                    \" (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"\n                tx.nonquery(q, (profileid, str(userid), password, gsbrcd,\n                                email, uniquenick, pid, lon, lat, loc,\n                                firstname, lastname, stat, partnerid,\n                                console, csnum, cfc, bssid, devname, birth,\n                                gameid, enabled, zipcode, aim))\n\n            return profileid\n\n    def get_user_list(self):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\"SELECT * FROM users\")\n\n        return [self.get_dict(row) for row in rows]\n\n    def save_pending_message(self, sourceid, targetid, msg):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\"INSERT INTO pending_messages VALUES (?,?,?)\",\n                        (sourceid, targetid, msg))\n\n    def get_pending_messages(self, profileid):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM pending_messages WHERE targetid = ?\",\n                (profileid,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def update_profile(self, profileid, field):\n        \"\"\"Found profile id associated with session key.\n\n        Start replacing each field one by one.\n        TODO: Optimize this so it's done all in one update.\n        TODO: Check if other values than firstname/lastname are set using this\n        \"\"\"\n        if field[0] in [\"firstname\", \"lastname\"]:\n            with Transaction(self.conn) as tx:\n                q = \"UPDATE users SET \\\"%s\\\" = ? WHERE profileid = ?\"\n                tx.nonquery(q % field[0], (field[1], profileid))\n\n    # Session functions\n    # TODO: Cache session keys so we don't have to query the database every\n    # time we get a profile id.\n    def get_profileid_from_session_key(self, session_key):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT profileid FROM sessions WHERE session = ?\",\n                (session_key,)\n            )\n            r = self.get_dict(row)\n\n        profileid = -1  # Default, invalid session key\n        if r is not None:\n            profileid = r['profileid']\n\n        return profileid\n\n    def get_profileid_from_loginticket(self, loginticket):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT profileid FROM sessions WHERE loginticket = ?\",\n                (loginticket,)\n            )\n\n        profileid = -1\n        if row:\n            profileid = int(row[0])\n\n        return profileid\n\n    def get_profile_from_session_key(self, session_key):\n        profileid = self.get_profileid_from_session_key(session_key)\n\n        profile = {}\n        if profileid:\n            with Transaction(self.conn) as tx:\n                row = tx.queryone(\n                    \"SELECT profileid FROM sessions WHERE session = ?\",\n                    (session_key,)\n                )\n                profile = self.get_dict(row)\n\n        return profile\n\n    def generate_session_key(self, min_size):\n        \"\"\"Generate session key.\n\n        TODO: There's probably a better way to do this.\n        The point is preventing duplicate session keys.\n        \"\"\"\n        while True:\n            with Transaction(self.conn) as tx:\n                session_key = utils.generate_random_number_str(min_size)\n                row = tx.queryone(\n                    \"SELECT COUNT(*) FROM sessions WHERE session = ?\",\n                    (session_key,)\n                )\n                count = int(row[0])\n                if not count:\n                    return session_key\n\n    def delete_session(self, profileid):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"DELETE FROM sessions WHERE profileid = ?\",\n                (profileid,)\n            )\n\n    def create_session(self, profileid, loginticket):\n        if profileid is not None and not self.check_profile_exists(profileid):\n            return None\n\n        # Remove any old sessions associated with this user id\n        self.delete_session(profileid)\n\n        # Create new session\n        session_key = self.generate_session_key(8)\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"INSERT INTO sessions VALUES (?, ?, ?)\",\n                (session_key, profileid, loginticket)\n            )\n\n        return session_key\n\n    def get_session_list(self, profileid=None):\n        with Transaction(self.conn) as tx:\n            if profileid is not None:\n                r = tx.queryall(\n                    \"SELECT * FROM sessions WHERE profileid = ?\",\n                    (profileid,)\n                )\n            else:\n                r = tx.queryall(\"SELECT * FROM sessions\")\n\n        return [self.get_dict(row) for row in r]\n\n    # nas server functions\n    def get_nas_login(self, authtoken):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT data FROM nas_logins WHERE authtoken = ?\",\n                (authtoken,)\n            )\n            r = self.get_dict(row)\n\n        if r is None:\n            return None\n        else:\n            return json.loads(r[\"data\"])\n\n    def get_nas_login_from_userid(self, userid):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT data FROM nas_logins WHERE userid = ?\",\n                (userid,)\n            )\n            r = self.get_dict(row)\n\n        if r is None:\n            return None\n        else:\n            return json.loads(r[\"data\"])\n\n    def is_banned(self, postdata):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM banned WHERE gameid = ? AND ipaddr = ?\",\n                (postdata['gamecd'][:-1], postdata['ipaddr'])\n            )\n        return int(row[0]) > 0\n\n    def pending(self, postdata):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM pending WHERE macadr = ?\",\n                (postdata['macadr'],)\n            )\n            return int(row[0]) > 0\n\n    def registered(self, postdata):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM registered WHERE macadr = ?\",\n                (postdata['macadr'],)\n            )\n            return int(row[0]) > 0\n\n    def get_next_available_userid(self):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\"SELECT max(userid) AS maxuser FROM users\")\n            r = self.get_dict(row)\n        if r is None or r['maxuser'] is None:\n            # Because all zeroes means Dolphin. Don't wanna get confused\n            # during debugging later.\n            return '0000000000002'\n        else:\n            userid = str(int(r['maxuser']) + 1)\n            while len(userid) < 13:\n                userid = \"0\" + userid\n            return userid\n\n    def generate_authtoken(self, userid, data):\n        \"\"\"Generate authentication token.\n\n        Since the auth token passed back to the game will be random, we can\n        make it small enough that there should never be a crash due to the\n        size of the token.\n        ^ real authtoken is 80 + 3 bytes though and I want to figure out\n        what's causing the 52200 so I'm matching everything as closely as\n        possible to the real thing.\n        \"\"\"\n        size = 80\n\n        # TODO: Another one of those questionable dupe-preventations\n        while True:\n            with Transaction(self.conn) as tx:\n                authtoken = \"NDS\" + utils.generate_random_str(size)\n                row = tx.queryone(\n                    \"SELECT COUNT(*) FROM nas_logins WHERE authtoken = ?\",\n                    (authtoken,)\n                )\n                count = int(row[0])\n                if not count:\n                    break\n\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT * FROM nas_logins WHERE userid = ?\",\n                (userid,)\n            )\n            r = self.get_dict(row)\n\n        if \"devname\" in data:\n            data[\"devname\"] = gs_utils.base64_encode(data[\"devname\"])\n        if \"ingamesn\" in data:\n            data[\"ingamesn\"] = gs_utils.base64_encode(data[\"ingamesn\"])\n\n        data = json.dumps(data)\n\n        with Transaction(self.conn) as tx:\n            if r is None:  # no row, add it\n                tx.nonquery(\n                    \"INSERT INTO nas_logins VALUES (?, ?, ?)\",\n                    (userid, authtoken, data)\n                )\n            else:\n                tx.nonquery(\n                    \"UPDATE nas_logins SET authtoken = ?, data = ?\"\n                    \" WHERE userid = ?\",\n                    (authtoken, data, userid)\n                )\n\n        return authtoken\n\n    # Buddy functions\n    def add_buddy(self, userProfileId, buddyProfileId):\n        now = int(time.time())\n\n        # status == 0 -> not authorized\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"INSERT INTO buddies VALUES (?, ?, ?, ?, ?, ?, ?)\",\n                (userProfileId, buddyProfileId, now, 0, 0, \"\", 0)\n            )\n\n    def auth_buddy(self, userProfileId, buddyProfileId):\n        # status == 1 -> authorized\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET status = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (1, userProfileId, buddyProfileId)\n            )\n\n    def block_buddy(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET blocked = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (1, userProfileId, buddyProfileId)\n            )\n\n    def unblock_buddy(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET blocked = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (0, userProfileId, buddyProfileId)\n            )\n\n    def get_buddy(self, userProfileId, buddyProfileId):\n        if userProfileId and buddyProfileId:\n            with Transaction(self.conn) as tx:\n                row = tx.queryone(\n                    \"SELECT * FROM buddies\"\n                    \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                    (userProfileId, buddyProfileId)\n                )\n                return self.get_dict(row)\n        return {}\n\n    def delete_buddy(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"DELETE FROM buddies\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (userProfileId, buddyProfileId)\n            )\n\n    def get_buddy_list(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE userProfileId = ? AND blocked = 0\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def get_blocked_list(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE userProfileId = ? AND blocked = 1\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def get_pending_buddy_requests(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE buddyProfileId = ? AND status = 0\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def buddy_need_auth_message(self, userProfileId):\n        with Transaction(self.conn) as tx:\n            rows = tx.queryall(\n                \"SELECT * FROM buddies\"\n                \" WHERE buddyProfileId = ? AND status = 1 AND notified = 0\",\n                (userProfileId,)\n            )\n\n        return [self.get_dict(row) for row in rows]\n\n    def buddy_sent_auth_message(self, userProfileId, buddyProfileId):\n        with Transaction(self.conn) as tx:\n            tx.nonquery(\n                \"UPDATE buddies SET notified = ?\"\n                \" WHERE userProfileId = ? AND buddyProfileId = ?\",\n                (1, userProfileId, buddyProfileId)\n            )\n\n    # Gamestats-related functions\n    def pd_insert(self, profileid, dindex, ptype, data):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT COUNT(*) FROM gamestat_profile\"\n                \" WHERE profileid = ? AND dindex = ? AND ptype = ?\",\n                (profileid, dindex, ptype)\n            )\n            count = int(row[0])\n            if count > 0:\n                tx.nonquery(\n                    \"UPDATE gamestat_profile SET data = ?\"\n                    \" WHERE profileid = ? AND dindex = ? AND ptype = ?\",\n                    (data, profileid, dindex, ptype)\n                )\n            else:\n                tx.nonquery(\n                    \"INSERT INTO gamestat_profile\"\n                    \" (profileid, dindex, ptype, data) VALUES(?,?,?,?)\",\n                    (profileid, dindex, ptype, data)\n                )\n\n    def pd_get(self, profileid, dindex, ptype):\n        with Transaction(self.conn) as tx:\n            row = tx.queryone(\n                \"SELECT * FROM gamestat_profile\"\n                \" WHERE profileid = ? AND dindex = ? AND ptype = ?\",\n                (profileid, dindex, ptype)\n            )\n        return self.get_dict(row)\n"], "filenames": ["gamespy/gs_database.py"], "buggy_code_start_loc": [370], "buggy_code_end_loc": [376], "fixing_code_start_loc": [370], "fixing_code_end_loc": [376], "type": "CWE-89", "message": "A vulnerability was found in barronwaffles dwc_network_server_emulator. It has been declared as critical. This vulnerability affects the function update_profile of the file gamespy/gs_database.py. The manipulation of the argument firstname/lastname leads to sql injection. The attack can be initiated remotely. The name of the patch is f70eb21394f75019886fbc2fb536de36161ba422. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216772.", "other": {"cve": {"id": "CVE-2020-36631", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-25T20:15:25.210", "lastModified": "2023-01-05T01:57:29.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in barronwaffles dwc_network_server_emulator. It has been declared as critical. This vulnerability affects the function update_profile of the file gamespy/gs_database.py. The manipulation of the argument firstname/lastname leads to sql injection. The attack can be initiated remotely. The name of the patch is f70eb21394f75019886fbc2fb536de36161ba422. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216772."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dwc_network_server_emulator_project:dwc_network_server_emulator:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-07-10", "matchCriteriaId": "7DBA6961-C6C8-4B43-AAB2-E4C58D2A240C"}]}]}], "references": [{"url": "https://github.com/barronwaffles/dwc_network_server_emulator/commit/f70eb21394f75019886fbc2fb536de36161ba422", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/barronwaffles/dwc_network_server_emulator/pull/538", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216772", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216772", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/barronwaffles/dwc_network_server_emulator/commit/f70eb21394f75019886fbc2fb536de36161ba422"}}