{"buggy_code": ["import re\nimport secrets\nfrom typing import Any, Dict, Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom rest_framework import status\nfrom sentry_sdk import capture_exception\nfrom statshog.defaults.django import statsd\n\nfrom posthog.api.utils import get_token\nfrom posthog.exceptions import RequestParsingError, generate_exception_response\nfrom posthog.models import Team, User\nfrom posthog.models.feature_flag import get_overridden_feature_flags\nfrom posthog.utils import cors_response, load_data_from_request\n\nfrom .utils import get_project_id\n\n\ndef on_permitted_domain(team: Team, request: HttpRequest) -> bool:\n    permitted_domains = [\"127.0.0.1\", \"localhost\"]\n\n    for url in team.app_urls:\n        hostname = parse_domain(url)\n        if hostname:\n            permitted_domains.append(hostname)\n\n    origin = parse_domain(request.headers.get(\"Origin\"))\n    referer = parse_domain(request.headers.get(\"Referer\"))\n    for permitted_domain in permitted_domains:\n        if \"*\" in permitted_domain:\n            pattern = \"^{}$\".format(permitted_domain.replace(\".\", \"\\\\.\").replace(\"*\", \"(.*)\"))\n            if (origin and re.search(pattern, origin)) or (referer and re.search(pattern, referer)):\n                return True\n        else:\n            if permitted_domain == origin or permitted_domain == referer:\n                return True\n    return False\n\n\ndef decide_editor_params(request: HttpRequest) -> Tuple[Dict[str, Any], bool]:\n    if request.user.is_anonymous:\n        return {}, False\n\n    team = request.user.team\n    if team and on_permitted_domain(team, request):\n        response: Dict[str, Any] = {\"isAuthenticated\": True}\n        editor_params = {}\n\n        if request.user.toolbar_mode != \"disabled\":\n            editor_params[\"toolbarVersion\"] = \"toolbar\"\n\n        if settings.JS_URL:\n            editor_params[\"jsURL\"] = settings.JS_URL\n\n        response[\"editorParams\"] = editor_params\n        return response, not request.user.temporary_token\n    else:\n        return {}, False\n\n\ndef parse_domain(url: Any) -> Optional[str]:\n    return urlparse(url).hostname\n\n\n@csrf_exempt\ndef get_decide(request: HttpRequest):\n    response = {\n        \"config\": {\"enable_collect_everything\": True},\n        \"editorParams\": {},\n        \"isAuthenticated\": False,\n        \"supportedCompression\": [\"gzip\", \"gzip-js\", \"lz64\"],\n    }\n\n    if request.COOKIES.get(settings.TOOLBAR_COOKIE_NAME) and request.user.is_authenticated:\n        response[\"isAuthenticated\"] = True\n        if settings.JS_URL and request.user.toolbar_mode == User.TOOLBAR:\n            response[\"editorParams\"] = {\"jsURL\": settings.JS_URL, \"toolbarVersion\": \"toolbar\"}\n\n    if request.user.is_authenticated:\n        r, update_user_token = decide_editor_params(request)\n        response.update(r)\n        if update_user_token:\n            request.user.temporary_token = secrets.token_urlsafe(32)\n            request.user.save()\n\n    response[\"featureFlags\"] = []\n    response[\"sessionRecording\"] = False\n\n    if request.method == \"POST\":\n        try:\n            data = load_data_from_request(request)\n            api_version_string = request.GET.get(\"v\")\n            # NOTE: This does not support semantic versioning e.g. 2.1.0\n            api_version = int(api_version_string) if api_version_string else 1\n        except ValueError:\n            # default value added because of bug in posthog-js 1.19.0\n            # see https://sentry.io/organizations/posthog2/issues/2738865125/?project=1899813\n            # as a tombstone if the below statsd counter hasn't seen errors for N days\n            # then it is likely that no clients are running posthog-js 1.19.0\n            # and this defaulting could be removed\n            statsd.incr(\n                f\"posthog_cloud_decide_defaulted_api_version_on_value_error\",\n                tags={\"endpoint\": \"decide\", \"api_version_string\": api_version_string},\n            )\n            api_version = 2\n        except RequestParsingError as error:\n            capture_exception(error)  # We still capture this on Sentry to identify actual potential bugs\n            return cors_response(\n                request,\n                generate_exception_response(\"decide\", f\"Malformed request data: {error}\", code=\"malformed_data\"),\n            )\n\n        token = get_token(data, request)\n        team = Team.objects.get_team_from_token(token)\n        if team is None and token:\n            project_id = get_project_id(data, request)\n\n            if not project_id:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Project API key invalid. You can find your project API key in PostHog project settings.\",\n                        code=\"invalid_api_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n\n            user = User.objects.get_from_personal_api_key(token)\n            if user is None:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Invalid Personal API key.\",\n                        code=\"invalid_personal_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n            team = user.teams.get(id=project_id)\n\n        if team:\n            feature_flags = get_overridden_feature_flags(team.pk, data[\"distinct_id\"], data.get(\"groups\", {}))\n            response[\"featureFlags\"] = feature_flags if api_version >= 2 else list(feature_flags.keys())\n\n            if team.session_recording_opt_in and (on_permitted_domain(team, request) or len(team.app_urls) == 0):\n                response[\"sessionRecording\"] = {\"endpoint\": \"/s/\"}\n    statsd.incr(\n        f\"posthog_cloud_raw_endpoint_success\", tags={\"endpoint\": \"decide\",},\n    )\n    return cors_response(request, JsonResponse(response))\n", "import uuid\n\nfrom rest_framework import status\n\nfrom posthog.test.base import APIBaseTest\n\n\nclass TestUrls(APIBaseTest):\n    def test_logout_temporary_token_reset(self):\n\n        # update temporary token\n        self.user.temporary_token = \"token123\"\n        self.user.save()\n\n        # logout\n        with self.settings(TEST=False):\n            response = self.client.post(\"/logout\", follow=True)\n            self.assertRedirects(response, \"/login\")\n\n        # no more token\n        self.user.refresh_from_db()\n        self.assertEqual(self.user.temporary_token, None)\n\n    def test_logged_out_user_is_redirected_to_login(self):\n        self.client.logout()\n\n        response = self.client.get(\"/events\")\n        self.assertRedirects(response, \"/login?next=/events\")\n\n        # Complex URL\n        response = self.client.get(\n            '/insights/new?interval=day&display=ActionsLineGraph&events=[{\"id\":\"$pageview\",\"name\":\"$pageview\",\"type\":\"events\",\"order\":0}]&properties=[]',\n        )\n\n        # Test that the URL is properly encoded to redirect the user to the final destination\n        self.assertRedirects(\n            response,\n            \"/login?next=/insights/new%3Finterval%3Dday%26display%3DActionsLineGraph%26events%3D%5B%257B%2522id%2522%3A%2522%24pageview%2522%2C%2522name%2522%3A%2522%24pageview%2522%2C%2522type%2522%3A%2522events%2522%2C%2522order%2522%3A0%257D%5D%26properties%3D%5B%5D\",\n            fetch_redirect_response=False,\n        )\n\n    def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n\n        self.client.logout()\n\n        response = self.client.get(\"/signup\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)  # no redirect\n\n        response = self.client.get(f\"/signup/{uuid.uuid4()}\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/preflight\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/login\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n    def test_authorize_and_redirect_domain(self):\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same domain as the referer: not.com\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=http://domain.com\", HTTP_REFERER=\"https://domain.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same scheme as the referer: https\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com:443\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: 443\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com/no-port\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: no port in URL\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com/sdf\", HTTP_REFERER=\"https://domain.com/asd\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        # TODO: build frontend before backend tests, or find a way to mock the template\n        # self.assertContains(\n        #     response,\n        #     \"Do you want to give the PostHog Toolbar on <strong>https://domain.com/sdf</strong> access to your PostHog data?\",\n        # )\n", "from typing import Any, Callable, List, Optional\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpResponse\nfrom django.urls import URLPattern, include, path, re_path\nfrom django.views.decorators import csrf\nfrom django.views.decorators.csrf import csrf_exempt\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularRedocView, SpectacularSwaggerView\n\nfrom posthog.api import (\n    api_not_found,\n    authentication,\n    capture,\n    dashboard,\n    decide,\n    organizations_router,\n    project_dashboards_router,\n    projects_router,\n    router,\n    signup,\n    user,\n)\nfrom posthog.demo import demo\n\nfrom .utils import render_template\nfrom .views import health, login_required, preflight_check, robots_txt, security_txt, sso_login, stats\n\nee_urlpatterns: List[Any] = []\ntry:\n    from ee.urls import extend_api_router\n    from ee.urls import urlpatterns as ee_urlpatterns\nexcept ImportError:\n    pass\nelse:\n    extend_api_router(router, projects_router=projects_router, project_dashboards_router=project_dashboards_router)\n\n\ntry:\n    # See https://github.com/PostHog/posthog-cloud/blob/master/multi_tenancy/router.py\n    from multi_tenancy.router import extend_api_router as extend_api_router_cloud  # noqa\nexcept ImportError:\n    pass\nelse:\n    extend_api_router_cloud(router, organizations_router=organizations_router, projects_router=projects_router)\n\n\n@csrf.ensure_csrf_cookie\ndef home(request, *args, **kwargs):\n    return render_template(\"index.html\", request)\n\n\ndef authorize_and_redirect(request):\n    if not request.GET.get(\"redirect\"):\n        return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n    if not request.META.get(\"HTTP_REFERER\"):\n        return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n\n    referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n    redirect_url = urlparse(request.GET[\"redirect\"])\n\n    if referer_url.hostname != redirect_url.hostname:\n        return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n\n    if referer_url.scheme != redirect_url.scheme:\n        return HttpResponse(f\"Can only redirect to the same scheme as the referer: {referer_url.scheme}\", status=400)\n\n    if referer_url.port != redirect_url.port:\n        return HttpResponse(\n            f\"Can only redirect to the same port as the referer: {referer_url.port or 'no port in URL'}\", status=400\n        )\n\n    return render_template(\n        \"authorize_and_redirect.html\",\n        request=request,\n        context={\"domain\": redirect_url.hostname, \"redirect_url\": request.GET[\"redirect\"]},\n    )\n\n\ndef opt_slash_path(route: str, view: Callable, name: Optional[str] = None) -> URLPattern:\n    \"\"\"Catches path with or without trailing slash, taking into account query param and hash.\"\"\"\n    # Ignoring the type because while name can be optional on re_path, mypy doesn't agree\n    return re_path(fr\"^{route}/?(?:[?#].*)?$\", view, name=name)  # type: ignore\n\n\nurlpatterns = [\n    path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n    # Optional UI:\n    path(\"api/schema/swagger-ui/\", SpectacularSwaggerView.as_view(url_name=\"schema\"), name=\"swagger-ui\"),\n    path(\"api/schema/redoc/\", SpectacularRedocView.as_view(url_name=\"schema\"), name=\"redoc\"),\n    # Health check probe endpoints for K8s\n    # NOTE: We have _health, livez, and _readyz. _health is deprecated and\n    # is only included for compatability with old installations. For new\n    # operations livez and readyz should be used.\n    opt_slash_path(\"_health\", health),\n    opt_slash_path(\"_stats\", stats),\n    opt_slash_path(\"_preflight\", preflight_check),\n    # ee\n    *ee_urlpatterns,\n    # api\n    path(\"api/\", include(router.urls)),\n    opt_slash_path(\"api/user/redirect_to_site\", user.redirect_to_site),\n    opt_slash_path(\"api/user/test_slack_webhook\", user.test_slack_webhook),\n    opt_slash_path(\"api/signup\", signup.SignupViewset.as_view()),\n    opt_slash_path(\"api/social_signup\", signup.SocialSignupViewset.as_view()),\n    path(\"api/signup/<str:invite_id>/\", signup.InviteSignupViewset.as_view()),\n    path(\n        \"api/reset/<str:user_uuid>/\",\n        authentication.PasswordResetCompleteViewSet.as_view({\"get\": \"retrieve\", \"post\": \"create\"}),\n    ),\n    re_path(r\"^api.+\", api_not_found),\n    path(\"authorize_and_redirect/\", login_required(authorize_and_redirect)),\n    path(\"shared_dashboard/<str:share_token>\", dashboard.shared_dashboard),\n    re_path(r\"^demo.*\", login_required(demo)),\n    # ingestion\n    opt_slash_path(\"decide\", decide.get_decide),\n    opt_slash_path(\"e\", capture.get_event),\n    opt_slash_path(\"engage\", capture.get_event),\n    opt_slash_path(\"track\", capture.get_event),\n    opt_slash_path(\"capture\", capture.get_event),\n    opt_slash_path(\"batch\", capture.get_event),\n    opt_slash_path(\"s\", capture.get_event),  # session recordings\n    opt_slash_path(\"robots.txt\", robots_txt),\n    opt_slash_path(\".well-known/security.txt\", security_txt),\n    # auth\n    path(\"logout\", authentication.logout, name=\"login\"),\n    path(\"signup/finish/\", signup.finish_social_signup, name=\"signup_finish\"),\n    path(\n        \"login/<str:backend>/\", sso_login, name=\"social_begin\"\n    ),  # overrides from `social_django.urls` to validate proper license\n    path(\"\", include(\"social_django.urls\", namespace=\"social\")),\n]\n\nif settings.TEST:\n\n    # Used in posthog-js e2e tests\n    @csrf_exempt\n    def delete_events(request):\n        from ee.clickhouse.sql.events import TRUNCATE_EVENTS_TABLE_SQL\n        from posthog.client import sync_execute\n\n        sync_execute(TRUNCATE_EVENTS_TABLE_SQL())\n        return HttpResponse()\n\n    urlpatterns.append(path(\"delete_events/\", delete_events))\n\n\n# Routes added individually to remove login requirement\nfrontend_unauthenticated_routes = [\n    \"preflight\",\n    \"signup\",\n    r\"signup\\/[A-Za-z0-9\\-]*\",\n    \"reset\",\n    \"organization/billing/subscribed\",\n    \"login\",\n]\nfor route in frontend_unauthenticated_routes:\n    urlpatterns.append(re_path(route, home))\n\nurlpatterns.append(re_path(r\"^.*\", login_required(home)))\n"], "fixing_code": ["import re\nimport secrets\nfrom typing import Any, Dict, Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom rest_framework import status\nfrom sentry_sdk import capture_exception\nfrom statshog.defaults.django import statsd\n\nfrom posthog.api.utils import get_token\nfrom posthog.exceptions import RequestParsingError, generate_exception_response\nfrom posthog.models import Team, User\nfrom posthog.models.feature_flag import get_overridden_feature_flags\nfrom posthog.utils import cors_response, load_data_from_request\n\nfrom .utils import get_project_id\n\n\ndef on_permitted_domain(team: Team, request: HttpRequest) -> bool:\n    origin = parse_domain(request.headers.get(\"Origin\"))\n    referer = parse_domain(request.headers.get(\"Referer\"))\n    return hostname_in_app_urls(team, origin) or hostname_in_app_urls(team, referer)\n\n\ndef hostname_in_app_urls(team: Team, hostname: Optional[str]) -> bool:\n    if not hostname:\n        return False\n\n    permitted_domains = [\"127.0.0.1\", \"localhost\"]\n\n    for url in team.app_urls:\n        host = parse_domain(url)\n        if host:\n            permitted_domains.append(host)\n\n    for permitted_domain in permitted_domains:\n        if \"*\" in permitted_domain:\n            pattern = \"^{}$\".format(re.escape(permitted_domain).replace(\"\\\\*\", \"(.*)\"))\n            if re.search(pattern, hostname):\n                return True\n        elif permitted_domain == hostname:\n            return True\n\n    return False\n\n\ndef decide_editor_params(request: HttpRequest) -> Tuple[Dict[str, Any], bool]:\n    if request.user.is_anonymous:\n        return {}, False\n\n    team = request.user.team\n    if team and on_permitted_domain(team, request):\n        response: Dict[str, Any] = {\"isAuthenticated\": True}\n        editor_params = {}\n\n        if request.user.toolbar_mode != \"disabled\":\n            editor_params[\"toolbarVersion\"] = \"toolbar\"\n\n        if settings.JS_URL:\n            editor_params[\"jsURL\"] = settings.JS_URL\n\n        response[\"editorParams\"] = editor_params\n        return response, not request.user.temporary_token\n    else:\n        return {}, False\n\n\ndef parse_domain(url: Any) -> Optional[str]:\n    return urlparse(url).hostname\n\n\n@csrf_exempt\ndef get_decide(request: HttpRequest):\n    response = {\n        \"config\": {\"enable_collect_everything\": True},\n        \"editorParams\": {},\n        \"isAuthenticated\": False,\n        \"supportedCompression\": [\"gzip\", \"gzip-js\", \"lz64\"],\n    }\n\n    if request.COOKIES.get(settings.TOOLBAR_COOKIE_NAME) and request.user.is_authenticated:\n        response[\"isAuthenticated\"] = True\n        if settings.JS_URL and request.user.toolbar_mode == User.TOOLBAR:\n            response[\"editorParams\"] = {\"jsURL\": settings.JS_URL, \"toolbarVersion\": \"toolbar\"}\n\n    if request.user.is_authenticated:\n        r, update_user_token = decide_editor_params(request)\n        response.update(r)\n        if update_user_token:\n            request.user.temporary_token = secrets.token_urlsafe(32)\n            request.user.save()\n\n    response[\"featureFlags\"] = []\n    response[\"sessionRecording\"] = False\n\n    if request.method == \"POST\":\n        try:\n            data = load_data_from_request(request)\n            api_version_string = request.GET.get(\"v\")\n            # NOTE: This does not support semantic versioning e.g. 2.1.0\n            api_version = int(api_version_string) if api_version_string else 1\n        except ValueError:\n            # default value added because of bug in posthog-js 1.19.0\n            # see https://sentry.io/organizations/posthog2/issues/2738865125/?project=1899813\n            # as a tombstone if the below statsd counter hasn't seen errors for N days\n            # then it is likely that no clients are running posthog-js 1.19.0\n            # and this defaulting could be removed\n            statsd.incr(\n                f\"posthog_cloud_decide_defaulted_api_version_on_value_error\",\n                tags={\"endpoint\": \"decide\", \"api_version_string\": api_version_string},\n            )\n            api_version = 2\n        except RequestParsingError as error:\n            capture_exception(error)  # We still capture this on Sentry to identify actual potential bugs\n            return cors_response(\n                request,\n                generate_exception_response(\"decide\", f\"Malformed request data: {error}\", code=\"malformed_data\"),\n            )\n\n        token = get_token(data, request)\n        team = Team.objects.get_team_from_token(token)\n        if team is None and token:\n            project_id = get_project_id(data, request)\n\n            if not project_id:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Project API key invalid. You can find your project API key in PostHog project settings.\",\n                        code=\"invalid_api_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n\n            user = User.objects.get_from_personal_api_key(token)\n            if user is None:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Invalid Personal API key.\",\n                        code=\"invalid_personal_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n            team = user.teams.get(id=project_id)\n\n        if team:\n            feature_flags = get_overridden_feature_flags(team.pk, data[\"distinct_id\"], data.get(\"groups\", {}))\n            response[\"featureFlags\"] = feature_flags if api_version >= 2 else list(feature_flags.keys())\n\n            if team.session_recording_opt_in and (on_permitted_domain(team, request) or len(team.app_urls) == 0):\n                response[\"sessionRecording\"] = {\"endpoint\": \"/s/\"}\n    statsd.incr(\n        f\"posthog_cloud_raw_endpoint_success\", tags={\"endpoint\": \"decide\",},\n    )\n    return cors_response(request, JsonResponse(response))\n", "import uuid\n\nfrom rest_framework import status\n\nfrom posthog.test.base import APIBaseTest\n\n\nclass TestUrls(APIBaseTest):\n    def test_logout_temporary_token_reset(self):\n\n        # update temporary token\n        self.user.temporary_token = \"token123\"\n        self.user.save()\n\n        # logout\n        with self.settings(TEST=False):\n            response = self.client.post(\"/logout\", follow=True)\n            self.assertRedirects(response, \"/login\")\n\n        # no more token\n        self.user.refresh_from_db()\n        self.assertEqual(self.user.temporary_token, None)\n\n    def test_logged_out_user_is_redirected_to_login(self):\n        self.client.logout()\n\n        response = self.client.get(\"/events\")\n        self.assertRedirects(response, \"/login?next=/events\")\n\n        # Complex URL\n        response = self.client.get(\n            '/insights/new?interval=day&display=ActionsLineGraph&events=[{\"id\":\"$pageview\",\"name\":\"$pageview\",\"type\":\"events\",\"order\":0}]&properties=[]',\n        )\n\n        # Test that the URL is properly encoded to redirect the user to the final destination\n        self.assertRedirects(\n            response,\n            \"/login?next=/insights/new%3Finterval%3Dday%26display%3DActionsLineGraph%26events%3D%5B%257B%2522id%2522%3A%2522%24pageview%2522%2C%2522name%2522%3A%2522%24pageview%2522%2C%2522type%2522%3A%2522events%2522%2C%2522order%2522%3A0%257D%5D%26properties%3D%5B%5D\",\n            fetch_redirect_response=False,\n        )\n\n    def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n\n        self.client.logout()\n\n        response = self.client.get(\"/signup\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)  # no redirect\n\n        response = self.client.get(f\"/signup/{uuid.uuid4()}\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/preflight\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/login\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n    def test_authorize_and_redirect_domain(self):\n        self.team.app_urls = [\"https://domain.com\", \"https://not.com\"]\n        self.team.save()\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://not-permitted.com\", HTTP_REFERER=\"https://not-permitted.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to a permitted domain.\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same domain as the referer: not.com\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=http://domain.com\", HTTP_REFERER=\"https://domain.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same scheme as the referer: https\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com:443\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: 443\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com/no-port\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: no port in URL\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com/sdf\", HTTP_REFERER=\"https://domain.com/asd\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        # TODO: build frontend before backend tests, or find a way to mock the template\n        # self.assertContains(\n        #     response,\n        #     \"Do you want to give the PostHog Toolbar on <strong>https://domain.com/sdf</strong> access to your PostHog data?\",\n        # )\n", "from typing import Any, Callable, List, Optional, cast\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom django.urls import URLPattern, include, path, re_path\nfrom django.views.decorators import csrf\nfrom django.views.decorators.csrf import csrf_exempt\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularRedocView, SpectacularSwaggerView\n\nfrom posthog.api import (\n    api_not_found,\n    authentication,\n    capture,\n    dashboard,\n    decide,\n    organizations_router,\n    project_dashboards_router,\n    projects_router,\n    router,\n    signup,\n    user,\n)\nfrom posthog.api.decide import hostname_in_app_urls\nfrom posthog.demo import demo\nfrom posthog.models import User\n\nfrom .utils import render_template\nfrom .views import health, login_required, preflight_check, robots_txt, security_txt, sso_login, stats\n\nee_urlpatterns: List[Any] = []\ntry:\n    from ee.urls import extend_api_router\n    from ee.urls import urlpatterns as ee_urlpatterns\nexcept ImportError:\n    pass\nelse:\n    extend_api_router(router, projects_router=projects_router, project_dashboards_router=project_dashboards_router)\n\n\ntry:\n    # See https://github.com/PostHog/posthog-cloud/blob/master/multi_tenancy/router.py\n    from multi_tenancy.router import extend_api_router as extend_api_router_cloud  # noqa\nexcept ImportError:\n    pass\nelse:\n    extend_api_router_cloud(router, organizations_router=organizations_router, projects_router=projects_router)\n\n\n@csrf.ensure_csrf_cookie\ndef home(request, *args, **kwargs):\n    return render_template(\"index.html\", request)\n\n\ndef authorize_and_redirect(request: HttpRequest) -> HttpResponse:\n    if not request.GET.get(\"redirect\"):\n        return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n    if not request.META.get(\"HTTP_REFERER\"):\n        return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n\n    current_team = cast(User, request.user).team\n    referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n    redirect_url = urlparse(request.GET[\"redirect\"])\n\n    if not current_team or not hostname_in_app_urls(current_team, redirect_url.hostname):\n        return HttpResponse(f\"Can only redirect to a permitted domain.\", status=400)\n\n    if referer_url.hostname != redirect_url.hostname:\n        return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n\n    if referer_url.scheme != redirect_url.scheme:\n        return HttpResponse(f\"Can only redirect to the same scheme as the referer: {referer_url.scheme}\", status=400)\n\n    if referer_url.port != redirect_url.port:\n        return HttpResponse(\n            f\"Can only redirect to the same port as the referer: {referer_url.port or 'no port in URL'}\", status=400\n        )\n\n    return render_template(\n        \"authorize_and_redirect.html\",\n        request=request,\n        context={\"domain\": redirect_url.hostname, \"redirect_url\": request.GET[\"redirect\"]},\n    )\n\n\ndef opt_slash_path(route: str, view: Callable, name: Optional[str] = None) -> URLPattern:\n    \"\"\"Catches path with or without trailing slash, taking into account query param and hash.\"\"\"\n    # Ignoring the type because while name can be optional on re_path, mypy doesn't agree\n    return re_path(fr\"^{route}/?(?:[?#].*)?$\", view, name=name)  # type: ignore\n\n\nurlpatterns = [\n    path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n    # Optional UI:\n    path(\"api/schema/swagger-ui/\", SpectacularSwaggerView.as_view(url_name=\"schema\"), name=\"swagger-ui\"),\n    path(\"api/schema/redoc/\", SpectacularRedocView.as_view(url_name=\"schema\"), name=\"redoc\"),\n    # Health check probe endpoints for K8s\n    # NOTE: We have _health, livez, and _readyz. _health is deprecated and\n    # is only included for compatability with old installations. For new\n    # operations livez and readyz should be used.\n    opt_slash_path(\"_health\", health),\n    opt_slash_path(\"_stats\", stats),\n    opt_slash_path(\"_preflight\", preflight_check),\n    # ee\n    *ee_urlpatterns,\n    # api\n    path(\"api/\", include(router.urls)),\n    opt_slash_path(\"api/user/redirect_to_site\", user.redirect_to_site),\n    opt_slash_path(\"api/user/test_slack_webhook\", user.test_slack_webhook),\n    opt_slash_path(\"api/signup\", signup.SignupViewset.as_view()),\n    opt_slash_path(\"api/social_signup\", signup.SocialSignupViewset.as_view()),\n    path(\"api/signup/<str:invite_id>/\", signup.InviteSignupViewset.as_view()),\n    path(\n        \"api/reset/<str:user_uuid>/\",\n        authentication.PasswordResetCompleteViewSet.as_view({\"get\": \"retrieve\", \"post\": \"create\"}),\n    ),\n    re_path(r\"^api.+\", api_not_found),\n    path(\"authorize_and_redirect/\", login_required(authorize_and_redirect)),\n    path(\"shared_dashboard/<str:share_token>\", dashboard.shared_dashboard),\n    re_path(r\"^demo.*\", login_required(demo)),\n    # ingestion\n    opt_slash_path(\"decide\", decide.get_decide),\n    opt_slash_path(\"e\", capture.get_event),\n    opt_slash_path(\"engage\", capture.get_event),\n    opt_slash_path(\"track\", capture.get_event),\n    opt_slash_path(\"capture\", capture.get_event),\n    opt_slash_path(\"batch\", capture.get_event),\n    opt_slash_path(\"s\", capture.get_event),  # session recordings\n    opt_slash_path(\"robots.txt\", robots_txt),\n    opt_slash_path(\".well-known/security.txt\", security_txt),\n    # auth\n    path(\"logout\", authentication.logout, name=\"login\"),\n    path(\"signup/finish/\", signup.finish_social_signup, name=\"signup_finish\"),\n    path(\n        \"login/<str:backend>/\", sso_login, name=\"social_begin\"\n    ),  # overrides from `social_django.urls` to validate proper license\n    path(\"\", include(\"social_django.urls\", namespace=\"social\")),\n]\n\nif settings.TEST:\n\n    # Used in posthog-js e2e tests\n    @csrf_exempt\n    def delete_events(request):\n        from ee.clickhouse.sql.events import TRUNCATE_EVENTS_TABLE_SQL\n        from posthog.client import sync_execute\n\n        sync_execute(TRUNCATE_EVENTS_TABLE_SQL())\n        return HttpResponse()\n\n    urlpatterns.append(path(\"delete_events/\", delete_events))\n\n\n# Routes added individually to remove login requirement\nfrontend_unauthenticated_routes = [\n    \"preflight\",\n    \"signup\",\n    r\"signup\\/[A-Za-z0-9\\-]*\",\n    \"reset\",\n    \"organization/billing/subscribed\",\n    \"login\",\n]\nfor route in frontend_unauthenticated_routes:\n    urlpatterns.append(re_path(route, home))\n\nurlpatterns.append(re_path(r\"^.*\", login_required(home)))\n"], "filenames": ["posthog/api/decide.py", "posthog/test/test_urls.py", "posthog/urls.py"], "buggy_code_start_loc": [22, 58, 1], "buggy_code_end_loc": [40, 58, 60], "fixing_code_start_loc": [23, 59, 1], "fixing_code_end_loc": [47, 68, 67], "type": "CWE-601", "message": "Open redirect vulnerability via endpoint authorize_and_redirect/?redirect= in GitHub repository posthog/posthog prior to 1.34.1.", "other": {"cve": {"id": "CVE-2022-0645", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-19T12:15:15.943", "lastModified": "2022-04-27T15:25:20.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open redirect vulnerability via endpoint authorize_and_redirect/?redirect= in GitHub repository posthog/posthog prior to 1.34.1."}, {"lang": "es", "value": "Una Vulnerabilidad de redireccionamiento abierto por medio del endpoint authorize_and_redirect/?redirect= en el repositorio de GitHub posthog/posthog versiones anteriores a 1.34.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:posthog:posthog:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.34.1", "matchCriteriaId": "FF8A2BD6-295F-4AB5-AAE9-A33BD307810D"}]}]}], "references": [{"url": "https://github.com/posthog/posthog/commit/859d8ed9ac7c5026db09714a26c85c1458abb038", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c13258a2-30e3-4261-9a3b-2f39c49a8bd6", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/posthog/posthog/commit/859d8ed9ac7c5026db09714a26c85c1458abb038"}}