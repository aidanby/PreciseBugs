{"buggy_code": ["/*\n *  gendisk handling\n */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/genhd.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/kobj_map.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/log2.h>\n#include <linux/pm_runtime.h>\n#include <linux/badblocks.h>\n\n#include \"blk.h\"\n\nstatic DEFINE_MUTEX(block_class_lock);\nstruct kobject *block_depr;\n\n/* for extended dynamic devt allocation, currently only one major is used */\n#define NR_EXT_DEVT\t\t(1 << MINORBITS)\n\n/* For extended devt allocation.  ext_devt_lock prevents look up\n * results from going away underneath its user.\n */\nstatic DEFINE_SPINLOCK(ext_devt_lock);\nstatic DEFINE_IDR(ext_devt_idr);\n\nstatic struct device_type disk_type;\n\nstatic void disk_check_events(struct disk_events *ev,\n\t\t\t      unsigned int *clearing_ptr);\nstatic void disk_alloc_events(struct gendisk *disk);\nstatic void disk_add_events(struct gendisk *disk);\nstatic void disk_del_events(struct gendisk *disk);\nstatic void disk_release_events(struct gendisk *disk);\n\n/**\n * disk_get_part - get partition\n * @disk: disk to look partition from\n * @partno: partition number\n *\n * Look for partition @partno from @disk.  If found, increment\n * reference count and return it.\n *\n * CONTEXT:\n * Don't care.\n *\n * RETURNS:\n * Pointer to the found partition on success, NULL if not found.\n */\nstruct hd_struct *disk_get_part(struct gendisk *disk, int partno)\n{\n\tstruct hd_struct *part = NULL;\n\tstruct disk_part_tbl *ptbl;\n\n\tif (unlikely(partno < 0))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tptbl = rcu_dereference(disk->part_tbl);\n\tif (likely(partno < ptbl->len)) {\n\t\tpart = rcu_dereference(ptbl->part[partno]);\n\t\tif (part)\n\t\t\tget_device(part_to_dev(part));\n\t}\n\n\trcu_read_unlock();\n\n\treturn part;\n}\nEXPORT_SYMBOL_GPL(disk_get_part);\n\n/**\n * disk_part_iter_init - initialize partition iterator\n * @piter: iterator to initialize\n * @disk: disk to iterate over\n * @flags: DISK_PITER_* flags\n *\n * Initialize @piter so that it iterates over partitions of @disk.\n *\n * CONTEXT:\n * Don't care.\n */\nvoid disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\n\tpiter->flags = flags;\n\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(disk_part_iter_init);\n\n/**\n * disk_part_iter_next - proceed iterator to the next partition and return it\n * @piter: iterator of interest\n *\n * Proceed @piter to the next partition and return it.\n *\n * CONTEXT:\n * Don't care.\n */\nstruct hd_struct *disk_part_iter_next(struct disk_part_iter *piter)\n{\n\tstruct disk_part_tbl *ptbl;\n\tint inc, end;\n\n\t/* put the last partition */\n\tdisk_put_part(piter->part);\n\tpiter->part = NULL;\n\n\t/* get part_tbl */\n\trcu_read_lock();\n\tptbl = rcu_dereference(piter->disk->part_tbl);\n\n\t/* determine iteration parameters */\n\tif (piter->flags & DISK_PITER_REVERSE) {\n\t\tinc = -1;\n\t\tif (piter->flags & (DISK_PITER_INCL_PART0 |\n\t\t\t\t    DISK_PITER_INCL_EMPTY_PART0))\n\t\t\tend = -1;\n\t\telse\n\t\t\tend = 0;\n\t} else {\n\t\tinc = 1;\n\t\tend = ptbl->len;\n\t}\n\n\t/* iterate to the next partition */\n\tfor (; piter->idx != end; piter->idx += inc) {\n\t\tstruct hd_struct *part;\n\n\t\tpart = rcu_dereference(ptbl->part[piter->idx]);\n\t\tif (!part)\n\t\t\tcontinue;\n\t\tif (!part_nr_sects_read(part) &&\n\t\t    !(piter->flags & DISK_PITER_INCL_EMPTY) &&\n\t\t    !(piter->flags & DISK_PITER_INCL_EMPTY_PART0 &&\n\t\t      piter->idx == 0))\n\t\t\tcontinue;\n\n\t\tget_device(part_to_dev(part));\n\t\tpiter->part = part;\n\t\tpiter->idx += inc;\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn piter->part;\n}\nEXPORT_SYMBOL_GPL(disk_part_iter_next);\n\n/**\n * disk_part_iter_exit - finish up partition iteration\n * @piter: iter of interest\n *\n * Called when iteration is over.  Cleans up @piter.\n *\n * CONTEXT:\n * Don't care.\n */\nvoid disk_part_iter_exit(struct disk_part_iter *piter)\n{\n\tdisk_put_part(piter->part);\n\tpiter->part = NULL;\n}\nEXPORT_SYMBOL_GPL(disk_part_iter_exit);\n\nstatic inline int sector_in_part(struct hd_struct *part, sector_t sector)\n{\n\treturn part->start_sect <= sector &&\n\t\tsector < part->start_sect + part_nr_sects_read(part);\n}\n\n/**\n * disk_map_sector_rcu - map sector to partition\n * @disk: gendisk of interest\n * @sector: sector to map\n *\n * Find out which partition @sector maps to on @disk.  This is\n * primarily used for stats accounting.\n *\n * CONTEXT:\n * RCU read locked.  The returned partition pointer is valid only\n * while preemption is disabled.\n *\n * RETURNS:\n * Found partition on success, part0 is returned if no partition matches\n */\nstruct hd_struct *disk_map_sector_rcu(struct gendisk *disk, sector_t sector)\n{\n\tstruct disk_part_tbl *ptbl;\n\tstruct hd_struct *part;\n\tint i;\n\n\tptbl = rcu_dereference(disk->part_tbl);\n\n\tpart = rcu_dereference(ptbl->last_lookup);\n\tif (part && sector_in_part(part, sector))\n\t\treturn part;\n\n\tfor (i = 1; i < ptbl->len; i++) {\n\t\tpart = rcu_dereference(ptbl->part[i]);\n\n\t\tif (part && sector_in_part(part, sector)) {\n\t\t\trcu_assign_pointer(ptbl->last_lookup, part);\n\t\t\treturn part;\n\t\t}\n\t}\n\treturn &disk->part0;\n}\nEXPORT_SYMBOL_GPL(disk_map_sector_rcu);\n\n/*\n * Can be deleted altogether. Later.\n *\n */\nstatic struct blk_major_name {\n\tstruct blk_major_name *next;\n\tint major;\n\tchar name[16];\n} *major_names[BLKDEV_MAJOR_HASH_SIZE];\n\n/* index in the above - for now: assume no multimajor ranges */\nstatic inline int major_to_index(unsigned major)\n{\n\treturn major % BLKDEV_MAJOR_HASH_SIZE;\n}\n\n#ifdef CONFIG_PROC_FS\nvoid blkdev_show(struct seq_file *seqf, off_t offset)\n{\n\tstruct blk_major_name *dp;\n\n\tif (offset < BLKDEV_MAJOR_HASH_SIZE) {\n\t\tmutex_lock(&block_class_lock);\n\t\tfor (dp = major_names[offset]; dp; dp = dp->next)\n\t\t\tseq_printf(seqf, \"%3d %s\\n\", dp->major, dp->name);\n\t\tmutex_unlock(&block_class_lock);\n\t}\n}\n#endif /* CONFIG_PROC_FS */\n\n/**\n * register_blkdev - register a new block device\n *\n * @major: the requested major device number [1..255]. If @major=0, try to\n *         allocate any unused major number.\n * @name: the name of the new block device as a zero terminated string\n *\n * The @name must be unique within the system.\n *\n * The return value depends on the @major input parameter.\n *  - if a major device number was requested in range [1..255] then the\n *    function returns zero on success, or a negative error code\n *  - if any unused major number was requested with @major=0 parameter\n *    then the return value is the allocated major number in range\n *    [1..255] or a negative error code otherwise\n */\nint register_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n, *p;\n\tint index, ret = 0;\n\n\tmutex_lock(&block_class_lock);\n\n\t/* temporary */\n\tif (major == 0) {\n\t\tfor (index = ARRAY_SIZE(major_names)-1; index > 0; index--) {\n\t\t\tif (major_names[index] == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (index == 0) {\n\t\t\tprintk(\"register_blkdev: failed to get major for %s\\n\",\n\t\t\t       name);\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmajor = index;\n\t\tret = major;\n\t}\n\n\tp = kmalloc(sizeof(struct blk_major_name), GFP_KERNEL);\n\tif (p == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->major = major;\n\tstrlcpy(p->name, name, sizeof(p->name));\n\tp->next = NULL;\n\tindex = major_to_index(major);\n\n\tfor (n = &major_names[index]; *n; n = &(*n)->next) {\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\t}\n\tif (!*n)\n\t\t*n = p;\n\telse\n\t\tret = -EBUSY;\n\n\tif (ret < 0) {\n\t\tprintk(\"register_blkdev: cannot get major %d for %s\\n\",\n\t\t       major, name);\n\t\tkfree(p);\n\t}\nout:\n\tmutex_unlock(&block_class_lock);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(register_blkdev);\n\nvoid unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\n\tmutex_lock(&block_class_lock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tmutex_unlock(&block_class_lock);\n\tkfree(p);\n}\n\nEXPORT_SYMBOL(unregister_blkdev);\n\nstatic struct kobj_map *bdev_map;\n\n/**\n * blk_mangle_minor - scatter minor numbers apart\n * @minor: minor number to mangle\n *\n * Scatter consecutively allocated @minor number apart if MANGLE_DEVT\n * is enabled.  Mangling twice gives the original value.\n *\n * RETURNS:\n * Mangled value.\n *\n * CONTEXT:\n * Don't care.\n */\nstatic int blk_mangle_minor(int minor)\n{\n#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT\n\tint i;\n\n\tfor (i = 0; i < MINORBITS / 2; i++) {\n\t\tint low = minor & (1 << i);\n\t\tint high = minor & (1 << (MINORBITS - 1 - i));\n\t\tint distance = MINORBITS - 1 - 2 * i;\n\n\t\tminor ^= low | high;\t/* clear both bits */\n\t\tlow <<= distance;\t/* swap the positions */\n\t\thigh >>= distance;\n\t\tminor |= low | high;\t/* and set */\n\t}\n#endif\n\treturn minor;\n}\n\n/**\n * blk_alloc_devt - allocate a dev_t for a partition\n * @part: partition to allocate dev_t for\n * @devt: out parameter for resulting dev_t\n *\n * Allocate a dev_t for block device.\n *\n * RETURNS:\n * 0 on success, allocated dev_t is returned in *@devt.  -errno on\n * failure.\n *\n * CONTEXT:\n * Might sleep.\n */\nint blk_alloc_devt(struct hd_struct *part, dev_t *devt)\n{\n\tstruct gendisk *disk = part_to_disk(part);\n\tint idx;\n\n\t/* in consecutive minor range? */\n\tif (part->partno < disk->minors) {\n\t\t*devt = MKDEV(disk->major, disk->first_minor + part->partno);\n\t\treturn 0;\n\t}\n\n\t/* allocate ext devt */\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_bh(&ext_devt_lock);\n\tidx = idr_alloc(&ext_devt_idr, part, 0, NR_EXT_DEVT, GFP_NOWAIT);\n\tspin_unlock_bh(&ext_devt_lock);\n\n\tidr_preload_end();\n\tif (idx < 0)\n\t\treturn idx == -ENOSPC ? -EBUSY : idx;\n\n\t*devt = MKDEV(BLOCK_EXT_MAJOR, blk_mangle_minor(idx));\n\treturn 0;\n}\n\n/**\n * blk_free_devt - free a dev_t\n * @devt: dev_t to free\n *\n * Free @devt which was allocated using blk_alloc_devt().\n *\n * CONTEXT:\n * Might sleep.\n */\nvoid blk_free_devt(dev_t devt)\n{\n\tif (devt == MKDEV(0, 0))\n\t\treturn;\n\n\tif (MAJOR(devt) == BLOCK_EXT_MAJOR) {\n\t\tspin_lock_bh(&ext_devt_lock);\n\t\tidr_remove(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\n\t\tspin_unlock_bh(&ext_devt_lock);\n\t}\n}\n\nstatic char *bdevt_str(dev_t devt, char *buf)\n{\n\tif (MAJOR(devt) <= 0xff && MINOR(devt) <= 0xff) {\n\t\tchar tbuf[BDEVT_SIZE];\n\t\tsnprintf(tbuf, BDEVT_SIZE, \"%02x%02x\", MAJOR(devt), MINOR(devt));\n\t\tsnprintf(buf, BDEVT_SIZE, \"%-9s\", tbuf);\n\t} else\n\t\tsnprintf(buf, BDEVT_SIZE, \"%03x:%05x\", MAJOR(devt), MINOR(devt));\n\n\treturn buf;\n}\n\n/*\n * Register device numbers dev..(dev+range-1)\n * range must be nonzero\n * The hash chain is sorted on range, so that subranges can override.\n */\nvoid blk_register_region(dev_t devt, unsigned long range, struct module *module,\n\t\t\t struct kobject *(*probe)(dev_t, int *, void *),\n\t\t\t int (*lock)(dev_t, void *), void *data)\n{\n\tkobj_map(bdev_map, devt, range, module, probe, lock, data);\n}\n\nEXPORT_SYMBOL(blk_register_region);\n\nvoid blk_unregister_region(dev_t devt, unsigned long range)\n{\n\tkobj_unmap(bdev_map, devt, range);\n}\n\nEXPORT_SYMBOL(blk_unregister_region);\n\nstatic struct kobject *exact_match(dev_t devt, int *partno, void *data)\n{\n\tstruct gendisk *p = data;\n\n\treturn &disk_to_dev(p)->kobj;\n}\n\nstatic int exact_lock(dev_t devt, void *data)\n{\n\tstruct gendisk *p = data;\n\n\tif (!get_disk(p))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void register_disk(struct device *parent, struct gendisk *disk)\n{\n\tstruct device *ddev = disk_to_dev(disk);\n\tstruct block_device *bdev;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\tint err;\n\n\tddev->parent = parent;\n\n\tdev_set_name(ddev, \"%s\", disk->disk_name);\n\n\t/* delay uevents, until we scanned partition table */\n\tdev_set_uevent_suppress(ddev, 1);\n\n\tif (device_add(ddev))\n\t\treturn;\n\tif (!sysfs_deprecated) {\n\t\terr = sysfs_create_link(block_depr, &ddev->kobj,\n\t\t\t\t\tkobject_name(&ddev->kobj));\n\t\tif (err) {\n\t\t\tdevice_del(ddev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * avoid probable deadlock caused by allocating memory with\n\t * GFP_KERNEL in runtime_resume callback of its all ancestor\n\t * devices\n\t */\n\tpm_runtime_set_memalloc_noio(ddev, true);\n\n\tdisk->part0.holder_dir = kobject_create_and_add(\"holders\", &ddev->kobj);\n\tdisk->slave_dir = kobject_create_and_add(\"slaves\", &ddev->kobj);\n\n\t/* No minors to use for partitions */\n\tif (!disk_part_scan_enabled(disk))\n\t\tgoto exit;\n\n\t/* No such device (e.g., media were just removed) */\n\tif (!get_capacity(disk))\n\t\tgoto exit;\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\tgoto exit;\n\n\tbdev->bd_invalidated = 1;\n\terr = blkdev_get(bdev, FMODE_READ, NULL);\n\tif (err < 0)\n\t\tgoto exit;\n\tblkdev_put(bdev, FMODE_READ);\n\nexit:\n\t/* announce disk after possible partitions are created */\n\tdev_set_uevent_suppress(ddev, 0);\n\tkobject_uevent(&ddev->kobj, KOBJ_ADD);\n\n\t/* announce possible partitions */\n\tdisk_part_iter_init(&piter, disk, 0);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tkobject_uevent(&part_to_dev(part)->kobj, KOBJ_ADD);\n\tdisk_part_iter_exit(&piter);\n}\n\n/**\n * device_add_disk - add partitioning information to kernel list\n * @parent: parent device for the disk\n * @disk: per-device partitioning information\n *\n * This function registers the partitioning information in @disk\n * with the kernel.\n *\n * FIXME: error handling\n */\nvoid device_add_disk(struct device *parent, struct gendisk *disk)\n{\n\tstruct backing_dev_info *bdi;\n\tdev_t devt;\n\tint retval;\n\n\t/* minors == 0 indicates to use ext devt from part0 and should\n\t * be accompanied with EXT_DEVT flag.  Make sure all\n\t * parameters make sense.\n\t */\n\tWARN_ON(disk->minors && !(disk->major || disk->first_minor));\n\tWARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));\n\n\tdisk->flags |= GENHD_FL_UP;\n\n\tretval = blk_alloc_devt(&disk->part0, &devt);\n\tif (retval) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tdisk_to_dev(disk)->devt = devt;\n\n\t/* ->major and ->first_minor aren't supposed to be\n\t * dereferenced from here on, but set them just in case.\n\t */\n\tdisk->major = MAJOR(devt);\n\tdisk->first_minor = MINOR(devt);\n\n\tdisk_alloc_events(disk);\n\n\t/* Register BDI before referencing it from bdev */\n\tbdi = &disk->queue->backing_dev_info;\n\tbdi_register_dev(bdi, disk_devt(disk));\n\n\tblk_register_region(disk_devt(disk), disk->minors, NULL,\n\t\t\t    exact_match, exact_lock, disk);\n\tregister_disk(parent, disk);\n\tblk_register_queue(disk);\n\n\t/*\n\t * Take an extra ref on queue which will be put on disk_release()\n\t * so that it sticks around as long as @disk is there.\n\t */\n\tWARN_ON_ONCE(!blk_get_queue(disk->queue));\n\n\tretval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,\n\t\t\t\t   \"bdi\");\n\tWARN_ON(retval);\n\n\tdisk_add_events(disk);\n\tblk_integrity_add(disk);\n}\nEXPORT_SYMBOL(device_add_disk);\n\nvoid del_gendisk(struct gendisk *disk)\n{\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\n\tblk_integrity_del(disk);\n\tdisk_del_events(disk);\n\n\t/* invalidate stuff */\n\tdisk_part_iter_init(&piter, disk,\n\t\t\t     DISK_PITER_INCL_EMPTY | DISK_PITER_REVERSE);\n\twhile ((part = disk_part_iter_next(&piter))) {\n\t\tinvalidate_partition(disk, part->partno);\n\t\tdelete_partition(disk, part->partno);\n\t}\n\tdisk_part_iter_exit(&piter);\n\n\tinvalidate_partition(disk, 0);\n\tset_capacity(disk, 0);\n\tdisk->flags &= ~GENHD_FL_UP;\n\n\tsysfs_remove_link(&disk_to_dev(disk)->kobj, \"bdi\");\n\tblk_unregister_queue(disk);\n\tblk_unregister_region(disk_devt(disk), disk->minors);\n\n\tpart_stat_set_all(&disk->part0, 0);\n\tdisk->part0.stamp = 0;\n\n\tkobject_put(disk->part0.holder_dir);\n\tkobject_put(disk->slave_dir);\n\tif (!sysfs_deprecated)\n\t\tsysfs_remove_link(block_depr, dev_name(disk_to_dev(disk)));\n\tpm_runtime_set_memalloc_noio(disk_to_dev(disk), false);\n\tdevice_del(disk_to_dev(disk));\n}\nEXPORT_SYMBOL(del_gendisk);\n\n/* sysfs access to bad-blocks list. */\nstatic ssize_t disk_badblocks_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->bb)\n\t\treturn sprintf(page, \"\\n\");\n\n\treturn badblocks_show(disk->bb, page, 0);\n}\n\nstatic ssize_t disk_badblocks_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *page, size_t len)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->bb)\n\t\treturn -ENXIO;\n\n\treturn badblocks_store(disk->bb, page, len, 0);\n}\n\n/**\n * get_gendisk - get partitioning information for a given device\n * @devt: device to get partitioning information for\n * @partno: returned partition index\n *\n * This function gets the structure containing partitioning\n * information for the given device @devt.\n */\nstruct gendisk *get_gendisk(dev_t devt, int *partno)\n{\n\tstruct gendisk *disk = NULL;\n\n\tif (MAJOR(devt) != BLOCK_EXT_MAJOR) {\n\t\tstruct kobject *kobj;\n\n\t\tkobj = kobj_lookup(bdev_map, devt, partno);\n\t\tif (kobj)\n\t\t\tdisk = dev_to_disk(kobj_to_dev(kobj));\n\t} else {\n\t\tstruct hd_struct *part;\n\n\t\tspin_lock_bh(&ext_devt_lock);\n\t\tpart = idr_find(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\n\t\tif (part && get_disk(part_to_disk(part))) {\n\t\t\t*partno = part->partno;\n\t\t\tdisk = part_to_disk(part);\n\t\t}\n\t\tspin_unlock_bh(&ext_devt_lock);\n\t}\n\n\treturn disk;\n}\nEXPORT_SYMBOL(get_gendisk);\n\n/**\n * bdget_disk - do bdget() by gendisk and partition number\n * @disk: gendisk of interest\n * @partno: partition number\n *\n * Find partition @partno from @disk, do bdget() on it.\n *\n * CONTEXT:\n * Don't care.\n *\n * RETURNS:\n * Resulting block_device on success, NULL on failure.\n */\nstruct block_device *bdget_disk(struct gendisk *disk, int partno)\n{\n\tstruct hd_struct *part;\n\tstruct block_device *bdev = NULL;\n\n\tpart = disk_get_part(disk, partno);\n\tif (part)\n\t\tbdev = bdget(part_devt(part));\n\tdisk_put_part(part);\n\n\treturn bdev;\n}\nEXPORT_SYMBOL(bdget_disk);\n\n/*\n * print a full list of all partitions - intended for places where the root\n * filesystem can't be mounted and thus to give the victim some idea of what\n * went wrong\n */\nvoid __init printk_all_partitions(void)\n{\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct disk_part_iter piter;\n\t\tstruct hd_struct *part;\n\t\tchar name_buf[BDEVNAME_SIZE];\n\t\tchar devt_buf[BDEVT_SIZE];\n\n\t\t/*\n\t\t * Don't show empty devices or things that have been\n\t\t * suppressed\n\t\t */\n\t\tif (get_capacity(disk) == 0 ||\n\t\t    (disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note, unlike /proc/partitions, I am showing the\n\t\t * numbers in hex - the same format as the root=\n\t\t * option takes.\n\t\t */\n\t\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\n\t\twhile ((part = disk_part_iter_next(&piter))) {\n\t\t\tbool is_part0 = part == &disk->part0;\n\n\t\t\tprintk(\"%s%s %10llu %s %s\", is_part0 ? \"\" : \"  \",\n\t\t\t       bdevt_str(part_devt(part), devt_buf),\n\t\t\t       (unsigned long long)part_nr_sects_read(part) >> 1\n\t\t\t       , disk_name(disk, part->partno, name_buf),\n\t\t\t       part->info ? part->info->uuid : \"\");\n\t\t\tif (is_part0) {\n\t\t\t\tif (dev->parent && dev->parent->driver)\n\t\t\t\t\tprintk(\" driver: %s\\n\",\n\t\t\t\t\t      dev->parent->driver->name);\n\t\t\t\telse\n\t\t\t\t\tprintk(\" (driver?)\\n\");\n\t\t\t} else\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tdisk_part_iter_exit(&piter);\n\t}\n\tclass_dev_iter_exit(&iter);\n}\n\n#ifdef CONFIG_PROC_FS\n/* iterator */\nstatic void *disk_seqf_start(struct seq_file *seqf, loff_t *pos)\n{\n\tloff_t skip = *pos;\n\tstruct class_dev_iter *iter;\n\tstruct device *dev;\n\n\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tseqf->private = iter;\n\tclass_dev_iter_init(iter, &block_class, NULL, &disk_type);\n\tdo {\n\t\tdev = class_dev_iter_next(iter);\n\t\tif (!dev)\n\t\t\treturn NULL;\n\t} while (skip--);\n\n\treturn dev_to_disk(dev);\n}\n\nstatic void *disk_seqf_next(struct seq_file *seqf, void *v, loff_t *pos)\n{\n\tstruct device *dev;\n\n\t(*pos)++;\n\tdev = class_dev_iter_next(seqf->private);\n\tif (dev)\n\t\treturn dev_to_disk(dev);\n\n\treturn NULL;\n}\n\nstatic void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n}\n\nstatic void *show_partition_start(struct seq_file *seqf, loff_t *pos)\n{\n\tvoid *p;\n\n\tp = disk_seqf_start(seqf, pos);\n\tif (!IS_ERR_OR_NULL(p) && !*pos)\n\t\tseq_puts(seqf, \"major minor  #blocks  name\\n\\n\");\n\treturn p;\n}\n\nstatic int show_partition(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *sgp = v;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\tchar buf[BDEVNAME_SIZE];\n\n\t/* Don't show non-partitionable removeable devices or empty devices */\n\tif (!get_capacity(sgp) || (!disk_max_parts(sgp) &&\n\t\t\t\t   (sgp->flags & GENHD_FL_REMOVABLE)))\n\t\treturn 0;\n\tif (sgp->flags & GENHD_FL_SUPPRESS_PARTITION_INFO)\n\t\treturn 0;\n\n\t/* show the full disk and all non-0 size partitions of it */\n\tdisk_part_iter_init(&piter, sgp, DISK_PITER_INCL_PART0);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tseq_printf(seqf, \"%4d  %7d %10llu %s\\n\",\n\t\t\t   MAJOR(part_devt(part)), MINOR(part_devt(part)),\n\t\t\t   (unsigned long long)part_nr_sects_read(part) >> 1,\n\t\t\t   disk_name(sgp, part->partno, buf));\n\tdisk_part_iter_exit(&piter);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations partitions_op = {\n\t.start\t= show_partition_start,\n\t.next\t= disk_seqf_next,\n\t.stop\t= disk_seqf_stop,\n\t.show\t= show_partition\n};\n\nstatic int partitions_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &partitions_op);\n}\n\nstatic const struct file_operations proc_partitions_operations = {\n\t.open\t\t= partitions_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n#endif\n\n\nstatic struct kobject *base_probe(dev_t devt, int *partno, void *data)\n{\n\tif (request_module(\"block-major-%d-%d\", MAJOR(devt), MINOR(devt)) > 0)\n\t\t/* Make old-style 2.4 aliases work */\n\t\trequest_module(\"block-major-%d\", MAJOR(devt));\n\treturn NULL;\n}\n\nstatic int __init genhd_device_init(void)\n{\n\tint error;\n\n\tblock_class.dev_kobj = sysfs_dev_block_kobj;\n\terror = class_register(&block_class);\n\tif (unlikely(error))\n\t\treturn error;\n\tbdev_map = kobj_map_init(base_probe, &block_class_lock);\n\tblk_dev_init();\n\n\tregister_blkdev(BLOCK_EXT_MAJOR, \"blkext\");\n\n\t/* create top-level block dir */\n\tif (!sysfs_deprecated)\n\t\tblock_depr = kobject_create_and_add(\"block\", NULL);\n\treturn 0;\n}\n\nsubsys_initcall(genhd_device_init);\n\nstatic ssize_t disk_range_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", disk->minors);\n}\n\nstatic ssize_t disk_ext_range_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", disk_max_parts(disk));\n}\n\nstatic ssize_t disk_removable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       (disk->flags & GENHD_FL_REMOVABLE ? 1 : 0));\n}\n\nstatic ssize_t disk_ro_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", get_disk_ro(disk) ? 1 : 0);\n}\n\nstatic ssize_t disk_capability_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%x\\n\", disk->flags);\n}\n\nstatic ssize_t disk_alignment_offset_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", queue_alignment_offset(disk->queue));\n}\n\nstatic ssize_t disk_discard_alignment_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", queue_discard_alignment(disk->queue));\n}\n\nstatic DEVICE_ATTR(range, S_IRUGO, disk_range_show, NULL);\nstatic DEVICE_ATTR(ext_range, S_IRUGO, disk_ext_range_show, NULL);\nstatic DEVICE_ATTR(removable, S_IRUGO, disk_removable_show, NULL);\nstatic DEVICE_ATTR(ro, S_IRUGO, disk_ro_show, NULL);\nstatic DEVICE_ATTR(size, S_IRUGO, part_size_show, NULL);\nstatic DEVICE_ATTR(alignment_offset, S_IRUGO, disk_alignment_offset_show, NULL);\nstatic DEVICE_ATTR(discard_alignment, S_IRUGO, disk_discard_alignment_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(capability, S_IRUGO, disk_capability_show, NULL);\nstatic DEVICE_ATTR(stat, S_IRUGO, part_stat_show, NULL);\nstatic DEVICE_ATTR(inflight, S_IRUGO, part_inflight_show, NULL);\nstatic DEVICE_ATTR(badblocks, S_IRUGO | S_IWUSR, disk_badblocks_show,\n\t\tdisk_badblocks_store);\n#ifdef CONFIG_FAIL_MAKE_REQUEST\nstatic struct device_attribute dev_attr_fail =\n\t__ATTR(make-it-fail, S_IRUGO|S_IWUSR, part_fail_show, part_fail_store);\n#endif\n#ifdef CONFIG_FAIL_IO_TIMEOUT\nstatic struct device_attribute dev_attr_fail_timeout =\n\t__ATTR(io-timeout-fail,  S_IRUGO|S_IWUSR, part_timeout_show,\n\t\tpart_timeout_store);\n#endif\n\nstatic struct attribute *disk_attrs[] = {\n\t&dev_attr_range.attr,\n\t&dev_attr_ext_range.attr,\n\t&dev_attr_removable.attr,\n\t&dev_attr_ro.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_alignment_offset.attr,\n\t&dev_attr_discard_alignment.attr,\n\t&dev_attr_capability.attr,\n\t&dev_attr_stat.attr,\n\t&dev_attr_inflight.attr,\n\t&dev_attr_badblocks.attr,\n#ifdef CONFIG_FAIL_MAKE_REQUEST\n\t&dev_attr_fail.attr,\n#endif\n#ifdef CONFIG_FAIL_IO_TIMEOUT\n\t&dev_attr_fail_timeout.attr,\n#endif\n\tNULL\n};\n\nstatic struct attribute_group disk_attr_group = {\n\t.attrs = disk_attrs,\n};\n\nstatic const struct attribute_group *disk_attr_groups[] = {\n\t&disk_attr_group,\n\tNULL\n};\n\n/**\n * disk_replace_part_tbl - replace disk->part_tbl in RCU-safe way\n * @disk: disk to replace part_tbl for\n * @new_ptbl: new part_tbl to install\n *\n * Replace disk->part_tbl with @new_ptbl in RCU-safe way.  The\n * original ptbl is freed using RCU callback.\n *\n * LOCKING:\n * Matching bd_mutx locked.\n */\nstatic void disk_replace_part_tbl(struct gendisk *disk,\n\t\t\t\t  struct disk_part_tbl *new_ptbl)\n{\n\tstruct disk_part_tbl *old_ptbl = disk->part_tbl;\n\n\trcu_assign_pointer(disk->part_tbl, new_ptbl);\n\n\tif (old_ptbl) {\n\t\trcu_assign_pointer(old_ptbl->last_lookup, NULL);\n\t\tkfree_rcu(old_ptbl, rcu_head);\n\t}\n}\n\n/**\n * disk_expand_part_tbl - expand disk->part_tbl\n * @disk: disk to expand part_tbl for\n * @partno: expand such that this partno can fit in\n *\n * Expand disk->part_tbl such that @partno can fit in.  disk->part_tbl\n * uses RCU to allow unlocked dereferencing for stats and other stuff.\n *\n * LOCKING:\n * Matching bd_mutex locked, might sleep.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nint disk_expand_part_tbl(struct gendisk *disk, int partno)\n{\n\tstruct disk_part_tbl *old_ptbl = disk->part_tbl;\n\tstruct disk_part_tbl *new_ptbl;\n\tint len = old_ptbl ? old_ptbl->len : 0;\n\tint i, target;\n\tsize_t size;\n\n\t/*\n\t * check for int overflow, since we can get here from blkpg_ioctl()\n\t * with a user passed 'partno'.\n\t */\n\ttarget = partno + 1;\n\tif (target < 0)\n\t\treturn -EINVAL;\n\n\t/* disk_max_parts() is zero during initialization, ignore if so */\n\tif (disk_max_parts(disk) && target > disk_max_parts(disk))\n\t\treturn -EINVAL;\n\n\tif (target <= len)\n\t\treturn 0;\n\n\tsize = sizeof(*new_ptbl) + target * sizeof(new_ptbl->part[0]);\n\tnew_ptbl = kzalloc_node(size, GFP_KERNEL, disk->node_id);\n\tif (!new_ptbl)\n\t\treturn -ENOMEM;\n\n\tnew_ptbl->len = target;\n\n\tfor (i = 0; i < len; i++)\n\t\trcu_assign_pointer(new_ptbl->part[i], old_ptbl->part[i]);\n\n\tdisk_replace_part_tbl(disk, new_ptbl);\n\treturn 0;\n}\n\nstatic void disk_release(struct device *dev)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tblk_free_devt(dev->devt);\n\tdisk_release_events(disk);\n\tkfree(disk->random);\n\tdisk_replace_part_tbl(disk, NULL);\n\thd_free_part(&disk->part0);\n\tif (disk->queue)\n\t\tblk_put_queue(disk->queue);\n\tkfree(disk);\n}\nstruct class block_class = {\n\t.name\t\t= \"block\",\n};\n\nstatic char *block_devnode(struct device *dev, umode_t *mode,\n\t\t\t   kuid_t *uid, kgid_t *gid)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (disk->devnode)\n\t\treturn disk->devnode(disk, mode);\n\treturn NULL;\n}\n\nstatic struct device_type disk_type = {\n\t.name\t\t= \"disk\",\n\t.groups\t\t= disk_attr_groups,\n\t.release\t= disk_release,\n\t.devnode\t= block_devnode,\n};\n\n#ifdef CONFIG_PROC_FS\n/*\n * aggregate disk stat collector.  Uses the same stats that the sysfs\n * entries do, above, but makes them available through one seq_file.\n *\n * The output looks suspiciously like /proc/partitions with a bunch of\n * extra fields.\n */\nstatic int diskstats_show(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *gp = v;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *hd;\n\tchar buf[BDEVNAME_SIZE];\n\tint cpu;\n\n\t/*\n\tif (&disk_to_dev(gp)->kobj.entry == block_class.devices.next)\n\t\tseq_puts(seqf,\t\"major minor name\"\n\t\t\t\t\"     rio rmerge rsect ruse wio wmerge \"\n\t\t\t\t\"wsect wuse running use aveq\"\n\t\t\t\t\"\\n\\n\");\n\t*/\n\n\tdisk_part_iter_init(&piter, gp, DISK_PITER_INCL_EMPTY_PART0);\n\twhile ((hd = disk_part_iter_next(&piter))) {\n\t\tcpu = part_stat_lock();\n\t\tpart_round_stats(cpu, hd);\n\t\tpart_stat_unlock();\n\t\tseq_printf(seqf, \"%4d %7d %s %lu %lu %lu \"\n\t\t\t   \"%u %lu %lu %lu %u %u %u %u\\n\",\n\t\t\t   MAJOR(part_devt(hd)), MINOR(part_devt(hd)),\n\t\t\t   disk_name(gp, hd->partno, buf),\n\t\t\t   part_stat_read(hd, ios[READ]),\n\t\t\t   part_stat_read(hd, merges[READ]),\n\t\t\t   part_stat_read(hd, sectors[READ]),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, ticks[READ])),\n\t\t\t   part_stat_read(hd, ios[WRITE]),\n\t\t\t   part_stat_read(hd, merges[WRITE]),\n\t\t\t   part_stat_read(hd, sectors[WRITE]),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),\n\t\t\t   part_in_flight(hd),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, io_ticks)),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, time_in_queue))\n\t\t\t);\n\t}\n\tdisk_part_iter_exit(&piter);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations diskstats_op = {\n\t.start\t= disk_seqf_start,\n\t.next\t= disk_seqf_next,\n\t.stop\t= disk_seqf_stop,\n\t.show\t= diskstats_show\n};\n\nstatic int diskstats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &diskstats_op);\n}\n\nstatic const struct file_operations proc_diskstats_operations = {\n\t.open\t\t= diskstats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init proc_genhd_init(void)\n{\n\tproc_create(\"diskstats\", 0, NULL, &proc_diskstats_operations);\n\tproc_create(\"partitions\", 0, NULL, &proc_partitions_operations);\n\treturn 0;\n}\nmodule_init(proc_genhd_init);\n#endif /* CONFIG_PROC_FS */\n\ndev_t blk_lookup_devt(const char *name, int partno)\n{\n\tdev_t devt = MKDEV(0, 0);\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct hd_struct *part;\n\n\t\tif (strcmp(dev_name(dev), name))\n\t\t\tcontinue;\n\n\t\tif (partno < disk->minors) {\n\t\t\t/* We need to return the right devno, even\n\t\t\t * if the partition doesn't exist yet.\n\t\t\t */\n\t\t\tdevt = MKDEV(MAJOR(dev->devt),\n\t\t\t\t     MINOR(dev->devt) + partno);\n\t\t\tbreak;\n\t\t}\n\t\tpart = disk_get_part(disk, partno);\n\t\tif (part) {\n\t\t\tdevt = part_devt(part);\n\t\t\tdisk_put_part(part);\n\t\t\tbreak;\n\t\t}\n\t\tdisk_put_part(part);\n\t}\n\tclass_dev_iter_exit(&iter);\n\treturn devt;\n}\nEXPORT_SYMBOL(blk_lookup_devt);\n\nstruct gendisk *alloc_disk(int minors)\n{\n\treturn alloc_disk_node(minors, NUMA_NO_NODE);\n}\nEXPORT_SYMBOL(alloc_disk);\n\nstruct gendisk *alloc_disk_node(int minors, int node_id)\n{\n\tstruct gendisk *disk;\n\n\tdisk = kzalloc_node(sizeof(struct gendisk), GFP_KERNEL, node_id);\n\tif (disk) {\n\t\tif (!init_part_stats(&disk->part0)) {\n\t\t\tkfree(disk);\n\t\t\treturn NULL;\n\t\t}\n\t\tdisk->node_id = node_id;\n\t\tif (disk_expand_part_tbl(disk, 0)) {\n\t\t\tfree_part_stats(&disk->part0);\n\t\t\tkfree(disk);\n\t\t\treturn NULL;\n\t\t}\n\t\tdisk->part_tbl->part[0] = &disk->part0;\n\n\t\t/*\n\t\t * set_capacity() and get_capacity() currently don't use\n\t\t * seqcounter to read/update the part0->nr_sects. Still init\n\t\t * the counter as we can read the sectors in IO submission\n\t\t * patch using seqence counters.\n\t\t *\n\t\t * TODO: Ideally set_capacity() and get_capacity() should be\n\t\t * converted to make use of bd_mutex and sequence counters.\n\t\t */\n\t\tseqcount_init(&disk->part0.nr_sects_seq);\n\t\tif (hd_ref_init(&disk->part0)) {\n\t\t\thd_free_part(&disk->part0);\n\t\t\tkfree(disk);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdisk->minors = minors;\n\t\trand_initialize_disk(disk);\n\t\tdisk_to_dev(disk)->class = &block_class;\n\t\tdisk_to_dev(disk)->type = &disk_type;\n\t\tdevice_initialize(disk_to_dev(disk));\n\t}\n\treturn disk;\n}\nEXPORT_SYMBOL(alloc_disk_node);\n\nstruct kobject *get_disk(struct gendisk *disk)\n{\n\tstruct module *owner;\n\tstruct kobject *kobj;\n\n\tif (!disk->fops)\n\t\treturn NULL;\n\towner = disk->fops->owner;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&disk_to_dev(disk)->kobj);\n\tif (kobj == NULL) {\n\t\tmodule_put(owner);\n\t\treturn NULL;\n\t}\n\treturn kobj;\n\n}\n\nEXPORT_SYMBOL(get_disk);\n\nvoid put_disk(struct gendisk *disk)\n{\n\tif (disk)\n\t\tkobject_put(&disk_to_dev(disk)->kobj);\n}\n\nEXPORT_SYMBOL(put_disk);\n\nstatic void set_disk_ro_uevent(struct gendisk *gd, int ro)\n{\n\tchar event[] = \"DISK_RO=1\";\n\tchar *envp[] = { event, NULL };\n\n\tif (!ro)\n\t\tevent[8] = '0';\n\tkobject_uevent_env(&disk_to_dev(gd)->kobj, KOBJ_CHANGE, envp);\n}\n\nvoid set_device_ro(struct block_device *bdev, int flag)\n{\n\tbdev->bd_part->policy = flag;\n}\n\nEXPORT_SYMBOL(set_device_ro);\n\nvoid set_disk_ro(struct gendisk *disk, int flag)\n{\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\n\tif (disk->part0.policy != flag) {\n\t\tset_disk_ro_uevent(disk, flag);\n\t\tdisk->part0.policy = flag;\n\t}\n\n\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tpart->policy = flag;\n\tdisk_part_iter_exit(&piter);\n}\n\nEXPORT_SYMBOL(set_disk_ro);\n\nint bdev_read_only(struct block_device *bdev)\n{\n\tif (!bdev)\n\t\treturn 0;\n\treturn bdev->bd_part->policy;\n}\n\nEXPORT_SYMBOL(bdev_read_only);\n\nint invalidate_partition(struct gendisk *disk, int partno)\n{\n\tint res = 0;\n\tstruct block_device *bdev = bdget_disk(disk, partno);\n\tif (bdev) {\n\t\tfsync_bdev(bdev);\n\t\tres = __invalidate_device(bdev, true);\n\t\tbdput(bdev);\n\t}\n\treturn res;\n}\n\nEXPORT_SYMBOL(invalidate_partition);\n\n/*\n * Disk events - monitor disk events like media change and eject request.\n */\nstruct disk_events {\n\tstruct list_head\tnode;\t\t/* all disk_event's */\n\tstruct gendisk\t\t*disk;\t\t/* the associated disk */\n\tspinlock_t\t\tlock;\n\n\tstruct mutex\t\tblock_mutex;\t/* protects blocking */\n\tint\t\t\tblock;\t\t/* event blocking depth */\n\tunsigned int\t\tpending;\t/* events already sent out */\n\tunsigned int\t\tclearing;\t/* events being cleared */\n\n\tlong\t\t\tpoll_msecs;\t/* interval, -1 for default */\n\tstruct delayed_work\tdwork;\n};\n\nstatic const char *disk_events_strs[] = {\n\t[ilog2(DISK_EVENT_MEDIA_CHANGE)]\t= \"media_change\",\n\t[ilog2(DISK_EVENT_EJECT_REQUEST)]\t= \"eject_request\",\n};\n\nstatic char *disk_uevents[] = {\n\t[ilog2(DISK_EVENT_MEDIA_CHANGE)]\t= \"DISK_MEDIA_CHANGE=1\",\n\t[ilog2(DISK_EVENT_EJECT_REQUEST)]\t= \"DISK_EJECT_REQUEST=1\",\n};\n\n/* list of all disk_events */\nstatic DEFINE_MUTEX(disk_events_mutex);\nstatic LIST_HEAD(disk_events);\n\n/* disable in-kernel polling by default */\nstatic unsigned long disk_events_dfl_poll_msecs;\n\nstatic unsigned long disk_events_poll_jiffies(struct gendisk *disk)\n{\n\tstruct disk_events *ev = disk->ev;\n\tlong intv_msecs = 0;\n\n\t/*\n\t * If device-specific poll interval is set, always use it.  If\n\t * the default is being used, poll iff there are events which\n\t * can't be monitored asynchronously.\n\t */\n\tif (ev->poll_msecs >= 0)\n\t\tintv_msecs = ev->poll_msecs;\n\telse if (disk->events & ~disk->async_events)\n\t\tintv_msecs = disk_events_dfl_poll_msecs;\n\n\treturn msecs_to_jiffies(intv_msecs);\n}\n\n/**\n * disk_block_events - block and flush disk event checking\n * @disk: disk to block events for\n *\n * On return from this function, it is guaranteed that event checking\n * isn't in progress and won't happen until unblocked by\n * disk_unblock_events().  Events blocking is counted and the actual\n * unblocking happens after the matching number of unblocks are done.\n *\n * Note that this intentionally does not block event checking from\n * disk_clear_events().\n *\n * CONTEXT:\n * Might sleep.\n */\nvoid disk_block_events(struct gendisk *disk)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned long flags;\n\tbool cancel;\n\n\tif (!ev)\n\t\treturn;\n\n\t/*\n\t * Outer mutex ensures that the first blocker completes canceling\n\t * the event work before further blockers are allowed to finish.\n\t */\n\tmutex_lock(&ev->block_mutex);\n\n\tspin_lock_irqsave(&ev->lock, flags);\n\tcancel = !ev->block++;\n\tspin_unlock_irqrestore(&ev->lock, flags);\n\n\tif (cancel)\n\t\tcancel_delayed_work_sync(&disk->ev->dwork);\n\n\tmutex_unlock(&ev->block_mutex);\n}\n\nstatic void __disk_unblock_events(struct gendisk *disk, bool check_now)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned long intv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ev->lock, flags);\n\n\tif (WARN_ON_ONCE(ev->block <= 0))\n\t\tgoto out_unlock;\n\n\tif (--ev->block)\n\t\tgoto out_unlock;\n\n\tintv = disk_events_poll_jiffies(disk);\n\tif (check_now)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, 0);\n\telse if (intv)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, intv);\nout_unlock:\n\tspin_unlock_irqrestore(&ev->lock, flags);\n}\n\n/**\n * disk_unblock_events - unblock disk event checking\n * @disk: disk to unblock events for\n *\n * Undo disk_block_events().  When the block count reaches zero, it\n * starts events polling if configured.\n *\n * CONTEXT:\n * Don't care.  Safe to call from irq context.\n */\nvoid disk_unblock_events(struct gendisk *disk)\n{\n\tif (disk->ev)\n\t\t__disk_unblock_events(disk, false);\n}\n\n/**\n * disk_flush_events - schedule immediate event checking and flushing\n * @disk: disk to check and flush events for\n * @mask: events to flush\n *\n * Schedule immediate event checking on @disk if not blocked.  Events in\n * @mask are scheduled to be cleared from the driver.  Note that this\n * doesn't clear the events from @disk->ev.\n *\n * CONTEXT:\n * If @mask is non-zero must be called with bdev->bd_mutex held.\n */\nvoid disk_flush_events(struct gendisk *disk, unsigned int mask)\n{\n\tstruct disk_events *ev = disk->ev;\n\n\tif (!ev)\n\t\treturn;\n\n\tspin_lock_irq(&ev->lock);\n\tev->clearing |= mask;\n\tif (!ev->block)\n\t\tmod_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, 0);\n\tspin_unlock_irq(&ev->lock);\n}\n\n/**\n * disk_clear_events - synchronously check, clear and return pending events\n * @disk: disk to fetch and clear events from\n * @mask: mask of events to be fetched and cleared\n *\n * Disk events are synchronously checked and pending events in @mask\n * are cleared and returned.  This ignores the block count.\n *\n * CONTEXT:\n * Might sleep.\n */\nunsigned int disk_clear_events(struct gendisk *disk, unsigned int mask)\n{\n\tconst struct block_device_operations *bdops = disk->fops;\n\tstruct disk_events *ev = disk->ev;\n\tunsigned int pending;\n\tunsigned int clearing = mask;\n\n\tif (!ev) {\n\t\t/* for drivers still using the old ->media_changed method */\n\t\tif ((mask & DISK_EVENT_MEDIA_CHANGE) &&\n\t\t    bdops->media_changed && bdops->media_changed(disk))\n\t\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\t\treturn 0;\n\t}\n\n\tdisk_block_events(disk);\n\n\t/*\n\t * store the union of mask and ev->clearing on the stack so that the\n\t * race with disk_flush_events does not cause ambiguity (ev->clearing\n\t * can still be modified even if events are blocked).\n\t */\n\tspin_lock_irq(&ev->lock);\n\tclearing |= ev->clearing;\n\tev->clearing = 0;\n\tspin_unlock_irq(&ev->lock);\n\n\tdisk_check_events(ev, &clearing);\n\t/*\n\t * if ev->clearing is not 0, the disk_flush_events got called in the\n\t * middle of this function, so we want to run the workfn without delay.\n\t */\n\t__disk_unblock_events(disk, ev->clearing ? true : false);\n\n\t/* then, fetch and clear pending events */\n\tspin_lock_irq(&ev->lock);\n\tpending = ev->pending & mask;\n\tev->pending &= ~mask;\n\tspin_unlock_irq(&ev->lock);\n\tWARN_ON_ONCE(clearing & mask);\n\n\treturn pending;\n}\n\n/*\n * Separate this part out so that a different pointer for clearing_ptr can be\n * passed in for disk_clear_events.\n */\nstatic void disk_events_workfn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct disk_events *ev = container_of(dwork, struct disk_events, dwork);\n\n\tdisk_check_events(ev, &ev->clearing);\n}\n\nstatic void disk_check_events(struct disk_events *ev,\n\t\t\t      unsigned int *clearing_ptr)\n{\n\tstruct gendisk *disk = ev->disk;\n\tchar *envp[ARRAY_SIZE(disk_uevents) + 1] = { };\n\tunsigned int clearing = *clearing_ptr;\n\tunsigned int events;\n\tunsigned long intv;\n\tint nr_events = 0, i;\n\n\t/* check events */\n\tevents = disk->fops->check_events(disk, clearing);\n\n\t/* accumulate pending events and schedule next poll if necessary */\n\tspin_lock_irq(&ev->lock);\n\n\tevents &= ~ev->pending;\n\tev->pending |= events;\n\t*clearing_ptr &= ~clearing;\n\n\tintv = disk_events_poll_jiffies(disk);\n\tif (!ev->block && intv)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, intv);\n\n\tspin_unlock_irq(&ev->lock);\n\n\t/*\n\t * Tell userland about new events.  Only the events listed in\n\t * @disk->events are reported.  Unlisted events are processed the\n\t * same internally but never get reported to userland.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(disk_uevents); i++)\n\t\tif (events & disk->events & (1 << i))\n\t\t\tenvp[nr_events++] = disk_uevents[i];\n\n\tif (nr_events)\n\t\tkobject_uevent_env(&disk_to_dev(disk)->kobj, KOBJ_CHANGE, envp);\n}\n\n/*\n * A disk events enabled device has the following sysfs nodes under\n * its /sys/block/X/ directory.\n *\n * events\t\t: list of all supported events\n * events_async\t\t: list of events which can be detected w/o polling\n * events_poll_msecs\t: polling interval, 0: disable, -1: system default\n */\nstatic ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}\n\nstatic ssize_t disk_events_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn __disk_events_show(disk->events, buf);\n}\n\nstatic ssize_t disk_events_async_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn __disk_events_show(disk->async_events, buf);\n}\n\nstatic ssize_t disk_events_poll_msecs_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%ld\\n\", disk->ev->poll_msecs);\n}\n\nstatic ssize_t disk_events_poll_msecs_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tlong intv;\n\n\tif (!count || !sscanf(buf, \"%ld\", &intv))\n\t\treturn -EINVAL;\n\n\tif (intv < 0 && intv != -1)\n\t\treturn -EINVAL;\n\n\tdisk_block_events(disk);\n\tdisk->ev->poll_msecs = intv;\n\t__disk_unblock_events(disk, true);\n\n\treturn count;\n}\n\nstatic const DEVICE_ATTR(events, S_IRUGO, disk_events_show, NULL);\nstatic const DEVICE_ATTR(events_async, S_IRUGO, disk_events_async_show, NULL);\nstatic const DEVICE_ATTR(events_poll_msecs, S_IRUGO|S_IWUSR,\n\t\t\t disk_events_poll_msecs_show,\n\t\t\t disk_events_poll_msecs_store);\n\nstatic const struct attribute *disk_events_attrs[] = {\n\t&dev_attr_events.attr,\n\t&dev_attr_events_async.attr,\n\t&dev_attr_events_poll_msecs.attr,\n\tNULL,\n};\n\n/*\n * The default polling interval can be specified by the kernel\n * parameter block.events_dfl_poll_msecs which defaults to 0\n * (disable).  This can also be modified runtime by writing to\n * /sys/module/block/events_dfl_poll_msecs.\n */\nstatic int disk_events_set_dfl_poll_msecs(const char *val,\n\t\t\t\t\t  const struct kernel_param *kp)\n{\n\tstruct disk_events *ev;\n\tint ret;\n\n\tret = param_set_ulong(val, kp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&disk_events_mutex);\n\n\tlist_for_each_entry(ev, &disk_events, node)\n\t\tdisk_flush_events(ev->disk, 0);\n\n\tmutex_unlock(&disk_events_mutex);\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops disk_events_dfl_poll_msecs_param_ops = {\n\t.set\t= disk_events_set_dfl_poll_msecs,\n\t.get\t= param_get_ulong,\n};\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX\t\"block.\"\n\nmodule_param_cb(events_dfl_poll_msecs, &disk_events_dfl_poll_msecs_param_ops,\n\t\t&disk_events_dfl_poll_msecs, 0644);\n\n/*\n * disk_{alloc|add|del|release}_events - initialize and destroy disk_events.\n */\nstatic void disk_alloc_events(struct gendisk *disk)\n{\n\tstruct disk_events *ev;\n\n\tif (!disk->fops->check_events)\n\t\treturn;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tpr_warn(\"%s: failed to initialize events\\n\", disk->disk_name);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&ev->node);\n\tev->disk = disk;\n\tspin_lock_init(&ev->lock);\n\tmutex_init(&ev->block_mutex);\n\tev->block = 1;\n\tev->poll_msecs = -1;\n\tINIT_DELAYED_WORK(&ev->dwork, disk_events_workfn);\n\n\tdisk->ev = ev;\n}\n\nstatic void disk_add_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\n\t/* FIXME: error handling */\n\tif (sysfs_create_files(&disk_to_dev(disk)->kobj, disk_events_attrs) < 0)\n\t\tpr_warn(\"%s: failed to create sysfs files for events\\n\",\n\t\t\tdisk->disk_name);\n\n\tmutex_lock(&disk_events_mutex);\n\tlist_add_tail(&disk->ev->node, &disk_events);\n\tmutex_unlock(&disk_events_mutex);\n\n\t/*\n\t * Block count is initialized to 1 and the following initial\n\t * unblock kicks it into action.\n\t */\n\t__disk_unblock_events(disk, true);\n}\n\nstatic void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\n\tdisk_block_events(disk);\n\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}\n\nstatic void disk_release_events(struct gendisk *disk)\n{\n\t/* the block count should be 1 from disk_del_events() */\n\tWARN_ON_ONCE(disk->ev && disk->ev->block != 1);\n\tkfree(disk->ev);\n}\n"], "fixing_code": ["/*\n *  gendisk handling\n */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/genhd.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/kobj_map.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/log2.h>\n#include <linux/pm_runtime.h>\n#include <linux/badblocks.h>\n\n#include \"blk.h\"\n\nstatic DEFINE_MUTEX(block_class_lock);\nstruct kobject *block_depr;\n\n/* for extended dynamic devt allocation, currently only one major is used */\n#define NR_EXT_DEVT\t\t(1 << MINORBITS)\n\n/* For extended devt allocation.  ext_devt_lock prevents look up\n * results from going away underneath its user.\n */\nstatic DEFINE_SPINLOCK(ext_devt_lock);\nstatic DEFINE_IDR(ext_devt_idr);\n\nstatic struct device_type disk_type;\n\nstatic void disk_check_events(struct disk_events *ev,\n\t\t\t      unsigned int *clearing_ptr);\nstatic void disk_alloc_events(struct gendisk *disk);\nstatic void disk_add_events(struct gendisk *disk);\nstatic void disk_del_events(struct gendisk *disk);\nstatic void disk_release_events(struct gendisk *disk);\n\n/**\n * disk_get_part - get partition\n * @disk: disk to look partition from\n * @partno: partition number\n *\n * Look for partition @partno from @disk.  If found, increment\n * reference count and return it.\n *\n * CONTEXT:\n * Don't care.\n *\n * RETURNS:\n * Pointer to the found partition on success, NULL if not found.\n */\nstruct hd_struct *disk_get_part(struct gendisk *disk, int partno)\n{\n\tstruct hd_struct *part = NULL;\n\tstruct disk_part_tbl *ptbl;\n\n\tif (unlikely(partno < 0))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tptbl = rcu_dereference(disk->part_tbl);\n\tif (likely(partno < ptbl->len)) {\n\t\tpart = rcu_dereference(ptbl->part[partno]);\n\t\tif (part)\n\t\t\tget_device(part_to_dev(part));\n\t}\n\n\trcu_read_unlock();\n\n\treturn part;\n}\nEXPORT_SYMBOL_GPL(disk_get_part);\n\n/**\n * disk_part_iter_init - initialize partition iterator\n * @piter: iterator to initialize\n * @disk: disk to iterate over\n * @flags: DISK_PITER_* flags\n *\n * Initialize @piter so that it iterates over partitions of @disk.\n *\n * CONTEXT:\n * Don't care.\n */\nvoid disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\n\tpiter->flags = flags;\n\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(disk_part_iter_init);\n\n/**\n * disk_part_iter_next - proceed iterator to the next partition and return it\n * @piter: iterator of interest\n *\n * Proceed @piter to the next partition and return it.\n *\n * CONTEXT:\n * Don't care.\n */\nstruct hd_struct *disk_part_iter_next(struct disk_part_iter *piter)\n{\n\tstruct disk_part_tbl *ptbl;\n\tint inc, end;\n\n\t/* put the last partition */\n\tdisk_put_part(piter->part);\n\tpiter->part = NULL;\n\n\t/* get part_tbl */\n\trcu_read_lock();\n\tptbl = rcu_dereference(piter->disk->part_tbl);\n\n\t/* determine iteration parameters */\n\tif (piter->flags & DISK_PITER_REVERSE) {\n\t\tinc = -1;\n\t\tif (piter->flags & (DISK_PITER_INCL_PART0 |\n\t\t\t\t    DISK_PITER_INCL_EMPTY_PART0))\n\t\t\tend = -1;\n\t\telse\n\t\t\tend = 0;\n\t} else {\n\t\tinc = 1;\n\t\tend = ptbl->len;\n\t}\n\n\t/* iterate to the next partition */\n\tfor (; piter->idx != end; piter->idx += inc) {\n\t\tstruct hd_struct *part;\n\n\t\tpart = rcu_dereference(ptbl->part[piter->idx]);\n\t\tif (!part)\n\t\t\tcontinue;\n\t\tif (!part_nr_sects_read(part) &&\n\t\t    !(piter->flags & DISK_PITER_INCL_EMPTY) &&\n\t\t    !(piter->flags & DISK_PITER_INCL_EMPTY_PART0 &&\n\t\t      piter->idx == 0))\n\t\t\tcontinue;\n\n\t\tget_device(part_to_dev(part));\n\t\tpiter->part = part;\n\t\tpiter->idx += inc;\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn piter->part;\n}\nEXPORT_SYMBOL_GPL(disk_part_iter_next);\n\n/**\n * disk_part_iter_exit - finish up partition iteration\n * @piter: iter of interest\n *\n * Called when iteration is over.  Cleans up @piter.\n *\n * CONTEXT:\n * Don't care.\n */\nvoid disk_part_iter_exit(struct disk_part_iter *piter)\n{\n\tdisk_put_part(piter->part);\n\tpiter->part = NULL;\n}\nEXPORT_SYMBOL_GPL(disk_part_iter_exit);\n\nstatic inline int sector_in_part(struct hd_struct *part, sector_t sector)\n{\n\treturn part->start_sect <= sector &&\n\t\tsector < part->start_sect + part_nr_sects_read(part);\n}\n\n/**\n * disk_map_sector_rcu - map sector to partition\n * @disk: gendisk of interest\n * @sector: sector to map\n *\n * Find out which partition @sector maps to on @disk.  This is\n * primarily used for stats accounting.\n *\n * CONTEXT:\n * RCU read locked.  The returned partition pointer is valid only\n * while preemption is disabled.\n *\n * RETURNS:\n * Found partition on success, part0 is returned if no partition matches\n */\nstruct hd_struct *disk_map_sector_rcu(struct gendisk *disk, sector_t sector)\n{\n\tstruct disk_part_tbl *ptbl;\n\tstruct hd_struct *part;\n\tint i;\n\n\tptbl = rcu_dereference(disk->part_tbl);\n\n\tpart = rcu_dereference(ptbl->last_lookup);\n\tif (part && sector_in_part(part, sector))\n\t\treturn part;\n\n\tfor (i = 1; i < ptbl->len; i++) {\n\t\tpart = rcu_dereference(ptbl->part[i]);\n\n\t\tif (part && sector_in_part(part, sector)) {\n\t\t\trcu_assign_pointer(ptbl->last_lookup, part);\n\t\t\treturn part;\n\t\t}\n\t}\n\treturn &disk->part0;\n}\nEXPORT_SYMBOL_GPL(disk_map_sector_rcu);\n\n/*\n * Can be deleted altogether. Later.\n *\n */\nstatic struct blk_major_name {\n\tstruct blk_major_name *next;\n\tint major;\n\tchar name[16];\n} *major_names[BLKDEV_MAJOR_HASH_SIZE];\n\n/* index in the above - for now: assume no multimajor ranges */\nstatic inline int major_to_index(unsigned major)\n{\n\treturn major % BLKDEV_MAJOR_HASH_SIZE;\n}\n\n#ifdef CONFIG_PROC_FS\nvoid blkdev_show(struct seq_file *seqf, off_t offset)\n{\n\tstruct blk_major_name *dp;\n\n\tif (offset < BLKDEV_MAJOR_HASH_SIZE) {\n\t\tmutex_lock(&block_class_lock);\n\t\tfor (dp = major_names[offset]; dp; dp = dp->next)\n\t\t\tseq_printf(seqf, \"%3d %s\\n\", dp->major, dp->name);\n\t\tmutex_unlock(&block_class_lock);\n\t}\n}\n#endif /* CONFIG_PROC_FS */\n\n/**\n * register_blkdev - register a new block device\n *\n * @major: the requested major device number [1..255]. If @major=0, try to\n *         allocate any unused major number.\n * @name: the name of the new block device as a zero terminated string\n *\n * The @name must be unique within the system.\n *\n * The return value depends on the @major input parameter.\n *  - if a major device number was requested in range [1..255] then the\n *    function returns zero on success, or a negative error code\n *  - if any unused major number was requested with @major=0 parameter\n *    then the return value is the allocated major number in range\n *    [1..255] or a negative error code otherwise\n */\nint register_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n, *p;\n\tint index, ret = 0;\n\n\tmutex_lock(&block_class_lock);\n\n\t/* temporary */\n\tif (major == 0) {\n\t\tfor (index = ARRAY_SIZE(major_names)-1; index > 0; index--) {\n\t\t\tif (major_names[index] == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (index == 0) {\n\t\t\tprintk(\"register_blkdev: failed to get major for %s\\n\",\n\t\t\t       name);\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmajor = index;\n\t\tret = major;\n\t}\n\n\tp = kmalloc(sizeof(struct blk_major_name), GFP_KERNEL);\n\tif (p == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->major = major;\n\tstrlcpy(p->name, name, sizeof(p->name));\n\tp->next = NULL;\n\tindex = major_to_index(major);\n\n\tfor (n = &major_names[index]; *n; n = &(*n)->next) {\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\t}\n\tif (!*n)\n\t\t*n = p;\n\telse\n\t\tret = -EBUSY;\n\n\tif (ret < 0) {\n\t\tprintk(\"register_blkdev: cannot get major %d for %s\\n\",\n\t\t       major, name);\n\t\tkfree(p);\n\t}\nout:\n\tmutex_unlock(&block_class_lock);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(register_blkdev);\n\nvoid unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\n\tmutex_lock(&block_class_lock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tmutex_unlock(&block_class_lock);\n\tkfree(p);\n}\n\nEXPORT_SYMBOL(unregister_blkdev);\n\nstatic struct kobj_map *bdev_map;\n\n/**\n * blk_mangle_minor - scatter minor numbers apart\n * @minor: minor number to mangle\n *\n * Scatter consecutively allocated @minor number apart if MANGLE_DEVT\n * is enabled.  Mangling twice gives the original value.\n *\n * RETURNS:\n * Mangled value.\n *\n * CONTEXT:\n * Don't care.\n */\nstatic int blk_mangle_minor(int minor)\n{\n#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT\n\tint i;\n\n\tfor (i = 0; i < MINORBITS / 2; i++) {\n\t\tint low = minor & (1 << i);\n\t\tint high = minor & (1 << (MINORBITS - 1 - i));\n\t\tint distance = MINORBITS - 1 - 2 * i;\n\n\t\tminor ^= low | high;\t/* clear both bits */\n\t\tlow <<= distance;\t/* swap the positions */\n\t\thigh >>= distance;\n\t\tminor |= low | high;\t/* and set */\n\t}\n#endif\n\treturn minor;\n}\n\n/**\n * blk_alloc_devt - allocate a dev_t for a partition\n * @part: partition to allocate dev_t for\n * @devt: out parameter for resulting dev_t\n *\n * Allocate a dev_t for block device.\n *\n * RETURNS:\n * 0 on success, allocated dev_t is returned in *@devt.  -errno on\n * failure.\n *\n * CONTEXT:\n * Might sleep.\n */\nint blk_alloc_devt(struct hd_struct *part, dev_t *devt)\n{\n\tstruct gendisk *disk = part_to_disk(part);\n\tint idx;\n\n\t/* in consecutive minor range? */\n\tif (part->partno < disk->minors) {\n\t\t*devt = MKDEV(disk->major, disk->first_minor + part->partno);\n\t\treturn 0;\n\t}\n\n\t/* allocate ext devt */\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_bh(&ext_devt_lock);\n\tidx = idr_alloc(&ext_devt_idr, part, 0, NR_EXT_DEVT, GFP_NOWAIT);\n\tspin_unlock_bh(&ext_devt_lock);\n\n\tidr_preload_end();\n\tif (idx < 0)\n\t\treturn idx == -ENOSPC ? -EBUSY : idx;\n\n\t*devt = MKDEV(BLOCK_EXT_MAJOR, blk_mangle_minor(idx));\n\treturn 0;\n}\n\n/**\n * blk_free_devt - free a dev_t\n * @devt: dev_t to free\n *\n * Free @devt which was allocated using blk_alloc_devt().\n *\n * CONTEXT:\n * Might sleep.\n */\nvoid blk_free_devt(dev_t devt)\n{\n\tif (devt == MKDEV(0, 0))\n\t\treturn;\n\n\tif (MAJOR(devt) == BLOCK_EXT_MAJOR) {\n\t\tspin_lock_bh(&ext_devt_lock);\n\t\tidr_remove(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\n\t\tspin_unlock_bh(&ext_devt_lock);\n\t}\n}\n\nstatic char *bdevt_str(dev_t devt, char *buf)\n{\n\tif (MAJOR(devt) <= 0xff && MINOR(devt) <= 0xff) {\n\t\tchar tbuf[BDEVT_SIZE];\n\t\tsnprintf(tbuf, BDEVT_SIZE, \"%02x%02x\", MAJOR(devt), MINOR(devt));\n\t\tsnprintf(buf, BDEVT_SIZE, \"%-9s\", tbuf);\n\t} else\n\t\tsnprintf(buf, BDEVT_SIZE, \"%03x:%05x\", MAJOR(devt), MINOR(devt));\n\n\treturn buf;\n}\n\n/*\n * Register device numbers dev..(dev+range-1)\n * range must be nonzero\n * The hash chain is sorted on range, so that subranges can override.\n */\nvoid blk_register_region(dev_t devt, unsigned long range, struct module *module,\n\t\t\t struct kobject *(*probe)(dev_t, int *, void *),\n\t\t\t int (*lock)(dev_t, void *), void *data)\n{\n\tkobj_map(bdev_map, devt, range, module, probe, lock, data);\n}\n\nEXPORT_SYMBOL(blk_register_region);\n\nvoid blk_unregister_region(dev_t devt, unsigned long range)\n{\n\tkobj_unmap(bdev_map, devt, range);\n}\n\nEXPORT_SYMBOL(blk_unregister_region);\n\nstatic struct kobject *exact_match(dev_t devt, int *partno, void *data)\n{\n\tstruct gendisk *p = data;\n\n\treturn &disk_to_dev(p)->kobj;\n}\n\nstatic int exact_lock(dev_t devt, void *data)\n{\n\tstruct gendisk *p = data;\n\n\tif (!get_disk(p))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void register_disk(struct device *parent, struct gendisk *disk)\n{\n\tstruct device *ddev = disk_to_dev(disk);\n\tstruct block_device *bdev;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\tint err;\n\n\tddev->parent = parent;\n\n\tdev_set_name(ddev, \"%s\", disk->disk_name);\n\n\t/* delay uevents, until we scanned partition table */\n\tdev_set_uevent_suppress(ddev, 1);\n\n\tif (device_add(ddev))\n\t\treturn;\n\tif (!sysfs_deprecated) {\n\t\terr = sysfs_create_link(block_depr, &ddev->kobj,\n\t\t\t\t\tkobject_name(&ddev->kobj));\n\t\tif (err) {\n\t\t\tdevice_del(ddev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * avoid probable deadlock caused by allocating memory with\n\t * GFP_KERNEL in runtime_resume callback of its all ancestor\n\t * devices\n\t */\n\tpm_runtime_set_memalloc_noio(ddev, true);\n\n\tdisk->part0.holder_dir = kobject_create_and_add(\"holders\", &ddev->kobj);\n\tdisk->slave_dir = kobject_create_and_add(\"slaves\", &ddev->kobj);\n\n\t/* No minors to use for partitions */\n\tif (!disk_part_scan_enabled(disk))\n\t\tgoto exit;\n\n\t/* No such device (e.g., media were just removed) */\n\tif (!get_capacity(disk))\n\t\tgoto exit;\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\tgoto exit;\n\n\tbdev->bd_invalidated = 1;\n\terr = blkdev_get(bdev, FMODE_READ, NULL);\n\tif (err < 0)\n\t\tgoto exit;\n\tblkdev_put(bdev, FMODE_READ);\n\nexit:\n\t/* announce disk after possible partitions are created */\n\tdev_set_uevent_suppress(ddev, 0);\n\tkobject_uevent(&ddev->kobj, KOBJ_ADD);\n\n\t/* announce possible partitions */\n\tdisk_part_iter_init(&piter, disk, 0);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tkobject_uevent(&part_to_dev(part)->kobj, KOBJ_ADD);\n\tdisk_part_iter_exit(&piter);\n}\n\n/**\n * device_add_disk - add partitioning information to kernel list\n * @parent: parent device for the disk\n * @disk: per-device partitioning information\n *\n * This function registers the partitioning information in @disk\n * with the kernel.\n *\n * FIXME: error handling\n */\nvoid device_add_disk(struct device *parent, struct gendisk *disk)\n{\n\tstruct backing_dev_info *bdi;\n\tdev_t devt;\n\tint retval;\n\n\t/* minors == 0 indicates to use ext devt from part0 and should\n\t * be accompanied with EXT_DEVT flag.  Make sure all\n\t * parameters make sense.\n\t */\n\tWARN_ON(disk->minors && !(disk->major || disk->first_minor));\n\tWARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));\n\n\tdisk->flags |= GENHD_FL_UP;\n\n\tretval = blk_alloc_devt(&disk->part0, &devt);\n\tif (retval) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tdisk_to_dev(disk)->devt = devt;\n\n\t/* ->major and ->first_minor aren't supposed to be\n\t * dereferenced from here on, but set them just in case.\n\t */\n\tdisk->major = MAJOR(devt);\n\tdisk->first_minor = MINOR(devt);\n\n\tdisk_alloc_events(disk);\n\n\t/* Register BDI before referencing it from bdev */\n\tbdi = &disk->queue->backing_dev_info;\n\tbdi_register_dev(bdi, disk_devt(disk));\n\n\tblk_register_region(disk_devt(disk), disk->minors, NULL,\n\t\t\t    exact_match, exact_lock, disk);\n\tregister_disk(parent, disk);\n\tblk_register_queue(disk);\n\n\t/*\n\t * Take an extra ref on queue which will be put on disk_release()\n\t * so that it sticks around as long as @disk is there.\n\t */\n\tWARN_ON_ONCE(!blk_get_queue(disk->queue));\n\n\tretval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,\n\t\t\t\t   \"bdi\");\n\tWARN_ON(retval);\n\n\tdisk_add_events(disk);\n\tblk_integrity_add(disk);\n}\nEXPORT_SYMBOL(device_add_disk);\n\nvoid del_gendisk(struct gendisk *disk)\n{\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\n\tblk_integrity_del(disk);\n\tdisk_del_events(disk);\n\n\t/* invalidate stuff */\n\tdisk_part_iter_init(&piter, disk,\n\t\t\t     DISK_PITER_INCL_EMPTY | DISK_PITER_REVERSE);\n\twhile ((part = disk_part_iter_next(&piter))) {\n\t\tinvalidate_partition(disk, part->partno);\n\t\tdelete_partition(disk, part->partno);\n\t}\n\tdisk_part_iter_exit(&piter);\n\n\tinvalidate_partition(disk, 0);\n\tset_capacity(disk, 0);\n\tdisk->flags &= ~GENHD_FL_UP;\n\n\tsysfs_remove_link(&disk_to_dev(disk)->kobj, \"bdi\");\n\tblk_unregister_queue(disk);\n\tblk_unregister_region(disk_devt(disk), disk->minors);\n\n\tpart_stat_set_all(&disk->part0, 0);\n\tdisk->part0.stamp = 0;\n\n\tkobject_put(disk->part0.holder_dir);\n\tkobject_put(disk->slave_dir);\n\tif (!sysfs_deprecated)\n\t\tsysfs_remove_link(block_depr, dev_name(disk_to_dev(disk)));\n\tpm_runtime_set_memalloc_noio(disk_to_dev(disk), false);\n\tdevice_del(disk_to_dev(disk));\n}\nEXPORT_SYMBOL(del_gendisk);\n\n/* sysfs access to bad-blocks list. */\nstatic ssize_t disk_badblocks_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->bb)\n\t\treturn sprintf(page, \"\\n\");\n\n\treturn badblocks_show(disk->bb, page, 0);\n}\n\nstatic ssize_t disk_badblocks_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *page, size_t len)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->bb)\n\t\treturn -ENXIO;\n\n\treturn badblocks_store(disk->bb, page, len, 0);\n}\n\n/**\n * get_gendisk - get partitioning information for a given device\n * @devt: device to get partitioning information for\n * @partno: returned partition index\n *\n * This function gets the structure containing partitioning\n * information for the given device @devt.\n */\nstruct gendisk *get_gendisk(dev_t devt, int *partno)\n{\n\tstruct gendisk *disk = NULL;\n\n\tif (MAJOR(devt) != BLOCK_EXT_MAJOR) {\n\t\tstruct kobject *kobj;\n\n\t\tkobj = kobj_lookup(bdev_map, devt, partno);\n\t\tif (kobj)\n\t\t\tdisk = dev_to_disk(kobj_to_dev(kobj));\n\t} else {\n\t\tstruct hd_struct *part;\n\n\t\tspin_lock_bh(&ext_devt_lock);\n\t\tpart = idr_find(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\n\t\tif (part && get_disk(part_to_disk(part))) {\n\t\t\t*partno = part->partno;\n\t\t\tdisk = part_to_disk(part);\n\t\t}\n\t\tspin_unlock_bh(&ext_devt_lock);\n\t}\n\n\treturn disk;\n}\nEXPORT_SYMBOL(get_gendisk);\n\n/**\n * bdget_disk - do bdget() by gendisk and partition number\n * @disk: gendisk of interest\n * @partno: partition number\n *\n * Find partition @partno from @disk, do bdget() on it.\n *\n * CONTEXT:\n * Don't care.\n *\n * RETURNS:\n * Resulting block_device on success, NULL on failure.\n */\nstruct block_device *bdget_disk(struct gendisk *disk, int partno)\n{\n\tstruct hd_struct *part;\n\tstruct block_device *bdev = NULL;\n\n\tpart = disk_get_part(disk, partno);\n\tif (part)\n\t\tbdev = bdget(part_devt(part));\n\tdisk_put_part(part);\n\n\treturn bdev;\n}\nEXPORT_SYMBOL(bdget_disk);\n\n/*\n * print a full list of all partitions - intended for places where the root\n * filesystem can't be mounted and thus to give the victim some idea of what\n * went wrong\n */\nvoid __init printk_all_partitions(void)\n{\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct disk_part_iter piter;\n\t\tstruct hd_struct *part;\n\t\tchar name_buf[BDEVNAME_SIZE];\n\t\tchar devt_buf[BDEVT_SIZE];\n\n\t\t/*\n\t\t * Don't show empty devices or things that have been\n\t\t * suppressed\n\t\t */\n\t\tif (get_capacity(disk) == 0 ||\n\t\t    (disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note, unlike /proc/partitions, I am showing the\n\t\t * numbers in hex - the same format as the root=\n\t\t * option takes.\n\t\t */\n\t\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\n\t\twhile ((part = disk_part_iter_next(&piter))) {\n\t\t\tbool is_part0 = part == &disk->part0;\n\n\t\t\tprintk(\"%s%s %10llu %s %s\", is_part0 ? \"\" : \"  \",\n\t\t\t       bdevt_str(part_devt(part), devt_buf),\n\t\t\t       (unsigned long long)part_nr_sects_read(part) >> 1\n\t\t\t       , disk_name(disk, part->partno, name_buf),\n\t\t\t       part->info ? part->info->uuid : \"\");\n\t\t\tif (is_part0) {\n\t\t\t\tif (dev->parent && dev->parent->driver)\n\t\t\t\t\tprintk(\" driver: %s\\n\",\n\t\t\t\t\t      dev->parent->driver->name);\n\t\t\t\telse\n\t\t\t\t\tprintk(\" (driver?)\\n\");\n\t\t\t} else\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tdisk_part_iter_exit(&piter);\n\t}\n\tclass_dev_iter_exit(&iter);\n}\n\n#ifdef CONFIG_PROC_FS\n/* iterator */\nstatic void *disk_seqf_start(struct seq_file *seqf, loff_t *pos)\n{\n\tloff_t skip = *pos;\n\tstruct class_dev_iter *iter;\n\tstruct device *dev;\n\n\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tseqf->private = iter;\n\tclass_dev_iter_init(iter, &block_class, NULL, &disk_type);\n\tdo {\n\t\tdev = class_dev_iter_next(iter);\n\t\tif (!dev)\n\t\t\treturn NULL;\n\t} while (skip--);\n\n\treturn dev_to_disk(dev);\n}\n\nstatic void *disk_seqf_next(struct seq_file *seqf, void *v, loff_t *pos)\n{\n\tstruct device *dev;\n\n\t(*pos)++;\n\tdev = class_dev_iter_next(seqf->private);\n\tif (dev)\n\t\treturn dev_to_disk(dev);\n\n\treturn NULL;\n}\n\nstatic void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}\n\nstatic void *show_partition_start(struct seq_file *seqf, loff_t *pos)\n{\n\tvoid *p;\n\n\tp = disk_seqf_start(seqf, pos);\n\tif (!IS_ERR_OR_NULL(p) && !*pos)\n\t\tseq_puts(seqf, \"major minor  #blocks  name\\n\\n\");\n\treturn p;\n}\n\nstatic int show_partition(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *sgp = v;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\tchar buf[BDEVNAME_SIZE];\n\n\t/* Don't show non-partitionable removeable devices or empty devices */\n\tif (!get_capacity(sgp) || (!disk_max_parts(sgp) &&\n\t\t\t\t   (sgp->flags & GENHD_FL_REMOVABLE)))\n\t\treturn 0;\n\tif (sgp->flags & GENHD_FL_SUPPRESS_PARTITION_INFO)\n\t\treturn 0;\n\n\t/* show the full disk and all non-0 size partitions of it */\n\tdisk_part_iter_init(&piter, sgp, DISK_PITER_INCL_PART0);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tseq_printf(seqf, \"%4d  %7d %10llu %s\\n\",\n\t\t\t   MAJOR(part_devt(part)), MINOR(part_devt(part)),\n\t\t\t   (unsigned long long)part_nr_sects_read(part) >> 1,\n\t\t\t   disk_name(sgp, part->partno, buf));\n\tdisk_part_iter_exit(&piter);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations partitions_op = {\n\t.start\t= show_partition_start,\n\t.next\t= disk_seqf_next,\n\t.stop\t= disk_seqf_stop,\n\t.show\t= show_partition\n};\n\nstatic int partitions_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &partitions_op);\n}\n\nstatic const struct file_operations proc_partitions_operations = {\n\t.open\t\t= partitions_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n#endif\n\n\nstatic struct kobject *base_probe(dev_t devt, int *partno, void *data)\n{\n\tif (request_module(\"block-major-%d-%d\", MAJOR(devt), MINOR(devt)) > 0)\n\t\t/* Make old-style 2.4 aliases work */\n\t\trequest_module(\"block-major-%d\", MAJOR(devt));\n\treturn NULL;\n}\n\nstatic int __init genhd_device_init(void)\n{\n\tint error;\n\n\tblock_class.dev_kobj = sysfs_dev_block_kobj;\n\terror = class_register(&block_class);\n\tif (unlikely(error))\n\t\treturn error;\n\tbdev_map = kobj_map_init(base_probe, &block_class_lock);\n\tblk_dev_init();\n\n\tregister_blkdev(BLOCK_EXT_MAJOR, \"blkext\");\n\n\t/* create top-level block dir */\n\tif (!sysfs_deprecated)\n\t\tblock_depr = kobject_create_and_add(\"block\", NULL);\n\treturn 0;\n}\n\nsubsys_initcall(genhd_device_init);\n\nstatic ssize_t disk_range_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", disk->minors);\n}\n\nstatic ssize_t disk_ext_range_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", disk_max_parts(disk));\n}\n\nstatic ssize_t disk_removable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       (disk->flags & GENHD_FL_REMOVABLE ? 1 : 0));\n}\n\nstatic ssize_t disk_ro_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", get_disk_ro(disk) ? 1 : 0);\n}\n\nstatic ssize_t disk_capability_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%x\\n\", disk->flags);\n}\n\nstatic ssize_t disk_alignment_offset_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", queue_alignment_offset(disk->queue));\n}\n\nstatic ssize_t disk_discard_alignment_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", queue_discard_alignment(disk->queue));\n}\n\nstatic DEVICE_ATTR(range, S_IRUGO, disk_range_show, NULL);\nstatic DEVICE_ATTR(ext_range, S_IRUGO, disk_ext_range_show, NULL);\nstatic DEVICE_ATTR(removable, S_IRUGO, disk_removable_show, NULL);\nstatic DEVICE_ATTR(ro, S_IRUGO, disk_ro_show, NULL);\nstatic DEVICE_ATTR(size, S_IRUGO, part_size_show, NULL);\nstatic DEVICE_ATTR(alignment_offset, S_IRUGO, disk_alignment_offset_show, NULL);\nstatic DEVICE_ATTR(discard_alignment, S_IRUGO, disk_discard_alignment_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(capability, S_IRUGO, disk_capability_show, NULL);\nstatic DEVICE_ATTR(stat, S_IRUGO, part_stat_show, NULL);\nstatic DEVICE_ATTR(inflight, S_IRUGO, part_inflight_show, NULL);\nstatic DEVICE_ATTR(badblocks, S_IRUGO | S_IWUSR, disk_badblocks_show,\n\t\tdisk_badblocks_store);\n#ifdef CONFIG_FAIL_MAKE_REQUEST\nstatic struct device_attribute dev_attr_fail =\n\t__ATTR(make-it-fail, S_IRUGO|S_IWUSR, part_fail_show, part_fail_store);\n#endif\n#ifdef CONFIG_FAIL_IO_TIMEOUT\nstatic struct device_attribute dev_attr_fail_timeout =\n\t__ATTR(io-timeout-fail,  S_IRUGO|S_IWUSR, part_timeout_show,\n\t\tpart_timeout_store);\n#endif\n\nstatic struct attribute *disk_attrs[] = {\n\t&dev_attr_range.attr,\n\t&dev_attr_ext_range.attr,\n\t&dev_attr_removable.attr,\n\t&dev_attr_ro.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_alignment_offset.attr,\n\t&dev_attr_discard_alignment.attr,\n\t&dev_attr_capability.attr,\n\t&dev_attr_stat.attr,\n\t&dev_attr_inflight.attr,\n\t&dev_attr_badblocks.attr,\n#ifdef CONFIG_FAIL_MAKE_REQUEST\n\t&dev_attr_fail.attr,\n#endif\n#ifdef CONFIG_FAIL_IO_TIMEOUT\n\t&dev_attr_fail_timeout.attr,\n#endif\n\tNULL\n};\n\nstatic struct attribute_group disk_attr_group = {\n\t.attrs = disk_attrs,\n};\n\nstatic const struct attribute_group *disk_attr_groups[] = {\n\t&disk_attr_group,\n\tNULL\n};\n\n/**\n * disk_replace_part_tbl - replace disk->part_tbl in RCU-safe way\n * @disk: disk to replace part_tbl for\n * @new_ptbl: new part_tbl to install\n *\n * Replace disk->part_tbl with @new_ptbl in RCU-safe way.  The\n * original ptbl is freed using RCU callback.\n *\n * LOCKING:\n * Matching bd_mutx locked.\n */\nstatic void disk_replace_part_tbl(struct gendisk *disk,\n\t\t\t\t  struct disk_part_tbl *new_ptbl)\n{\n\tstruct disk_part_tbl *old_ptbl = disk->part_tbl;\n\n\trcu_assign_pointer(disk->part_tbl, new_ptbl);\n\n\tif (old_ptbl) {\n\t\trcu_assign_pointer(old_ptbl->last_lookup, NULL);\n\t\tkfree_rcu(old_ptbl, rcu_head);\n\t}\n}\n\n/**\n * disk_expand_part_tbl - expand disk->part_tbl\n * @disk: disk to expand part_tbl for\n * @partno: expand such that this partno can fit in\n *\n * Expand disk->part_tbl such that @partno can fit in.  disk->part_tbl\n * uses RCU to allow unlocked dereferencing for stats and other stuff.\n *\n * LOCKING:\n * Matching bd_mutex locked, might sleep.\n *\n * RETURNS:\n * 0 on success, -errno on failure.\n */\nint disk_expand_part_tbl(struct gendisk *disk, int partno)\n{\n\tstruct disk_part_tbl *old_ptbl = disk->part_tbl;\n\tstruct disk_part_tbl *new_ptbl;\n\tint len = old_ptbl ? old_ptbl->len : 0;\n\tint i, target;\n\tsize_t size;\n\n\t/*\n\t * check for int overflow, since we can get here from blkpg_ioctl()\n\t * with a user passed 'partno'.\n\t */\n\ttarget = partno + 1;\n\tif (target < 0)\n\t\treturn -EINVAL;\n\n\t/* disk_max_parts() is zero during initialization, ignore if so */\n\tif (disk_max_parts(disk) && target > disk_max_parts(disk))\n\t\treturn -EINVAL;\n\n\tif (target <= len)\n\t\treturn 0;\n\n\tsize = sizeof(*new_ptbl) + target * sizeof(new_ptbl->part[0]);\n\tnew_ptbl = kzalloc_node(size, GFP_KERNEL, disk->node_id);\n\tif (!new_ptbl)\n\t\treturn -ENOMEM;\n\n\tnew_ptbl->len = target;\n\n\tfor (i = 0; i < len; i++)\n\t\trcu_assign_pointer(new_ptbl->part[i], old_ptbl->part[i]);\n\n\tdisk_replace_part_tbl(disk, new_ptbl);\n\treturn 0;\n}\n\nstatic void disk_release(struct device *dev)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tblk_free_devt(dev->devt);\n\tdisk_release_events(disk);\n\tkfree(disk->random);\n\tdisk_replace_part_tbl(disk, NULL);\n\thd_free_part(&disk->part0);\n\tif (disk->queue)\n\t\tblk_put_queue(disk->queue);\n\tkfree(disk);\n}\nstruct class block_class = {\n\t.name\t\t= \"block\",\n};\n\nstatic char *block_devnode(struct device *dev, umode_t *mode,\n\t\t\t   kuid_t *uid, kgid_t *gid)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (disk->devnode)\n\t\treturn disk->devnode(disk, mode);\n\treturn NULL;\n}\n\nstatic struct device_type disk_type = {\n\t.name\t\t= \"disk\",\n\t.groups\t\t= disk_attr_groups,\n\t.release\t= disk_release,\n\t.devnode\t= block_devnode,\n};\n\n#ifdef CONFIG_PROC_FS\n/*\n * aggregate disk stat collector.  Uses the same stats that the sysfs\n * entries do, above, but makes them available through one seq_file.\n *\n * The output looks suspiciously like /proc/partitions with a bunch of\n * extra fields.\n */\nstatic int diskstats_show(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *gp = v;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *hd;\n\tchar buf[BDEVNAME_SIZE];\n\tint cpu;\n\n\t/*\n\tif (&disk_to_dev(gp)->kobj.entry == block_class.devices.next)\n\t\tseq_puts(seqf,\t\"major minor name\"\n\t\t\t\t\"     rio rmerge rsect ruse wio wmerge \"\n\t\t\t\t\"wsect wuse running use aveq\"\n\t\t\t\t\"\\n\\n\");\n\t*/\n\n\tdisk_part_iter_init(&piter, gp, DISK_PITER_INCL_EMPTY_PART0);\n\twhile ((hd = disk_part_iter_next(&piter))) {\n\t\tcpu = part_stat_lock();\n\t\tpart_round_stats(cpu, hd);\n\t\tpart_stat_unlock();\n\t\tseq_printf(seqf, \"%4d %7d %s %lu %lu %lu \"\n\t\t\t   \"%u %lu %lu %lu %u %u %u %u\\n\",\n\t\t\t   MAJOR(part_devt(hd)), MINOR(part_devt(hd)),\n\t\t\t   disk_name(gp, hd->partno, buf),\n\t\t\t   part_stat_read(hd, ios[READ]),\n\t\t\t   part_stat_read(hd, merges[READ]),\n\t\t\t   part_stat_read(hd, sectors[READ]),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, ticks[READ])),\n\t\t\t   part_stat_read(hd, ios[WRITE]),\n\t\t\t   part_stat_read(hd, merges[WRITE]),\n\t\t\t   part_stat_read(hd, sectors[WRITE]),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),\n\t\t\t   part_in_flight(hd),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, io_ticks)),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, time_in_queue))\n\t\t\t);\n\t}\n\tdisk_part_iter_exit(&piter);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations diskstats_op = {\n\t.start\t= disk_seqf_start,\n\t.next\t= disk_seqf_next,\n\t.stop\t= disk_seqf_stop,\n\t.show\t= diskstats_show\n};\n\nstatic int diskstats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &diskstats_op);\n}\n\nstatic const struct file_operations proc_diskstats_operations = {\n\t.open\t\t= diskstats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init proc_genhd_init(void)\n{\n\tproc_create(\"diskstats\", 0, NULL, &proc_diskstats_operations);\n\tproc_create(\"partitions\", 0, NULL, &proc_partitions_operations);\n\treturn 0;\n}\nmodule_init(proc_genhd_init);\n#endif /* CONFIG_PROC_FS */\n\ndev_t blk_lookup_devt(const char *name, int partno)\n{\n\tdev_t devt = MKDEV(0, 0);\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct hd_struct *part;\n\n\t\tif (strcmp(dev_name(dev), name))\n\t\t\tcontinue;\n\n\t\tif (partno < disk->minors) {\n\t\t\t/* We need to return the right devno, even\n\t\t\t * if the partition doesn't exist yet.\n\t\t\t */\n\t\t\tdevt = MKDEV(MAJOR(dev->devt),\n\t\t\t\t     MINOR(dev->devt) + partno);\n\t\t\tbreak;\n\t\t}\n\t\tpart = disk_get_part(disk, partno);\n\t\tif (part) {\n\t\t\tdevt = part_devt(part);\n\t\t\tdisk_put_part(part);\n\t\t\tbreak;\n\t\t}\n\t\tdisk_put_part(part);\n\t}\n\tclass_dev_iter_exit(&iter);\n\treturn devt;\n}\nEXPORT_SYMBOL(blk_lookup_devt);\n\nstruct gendisk *alloc_disk(int minors)\n{\n\treturn alloc_disk_node(minors, NUMA_NO_NODE);\n}\nEXPORT_SYMBOL(alloc_disk);\n\nstruct gendisk *alloc_disk_node(int minors, int node_id)\n{\n\tstruct gendisk *disk;\n\n\tdisk = kzalloc_node(sizeof(struct gendisk), GFP_KERNEL, node_id);\n\tif (disk) {\n\t\tif (!init_part_stats(&disk->part0)) {\n\t\t\tkfree(disk);\n\t\t\treturn NULL;\n\t\t}\n\t\tdisk->node_id = node_id;\n\t\tif (disk_expand_part_tbl(disk, 0)) {\n\t\t\tfree_part_stats(&disk->part0);\n\t\t\tkfree(disk);\n\t\t\treturn NULL;\n\t\t}\n\t\tdisk->part_tbl->part[0] = &disk->part0;\n\n\t\t/*\n\t\t * set_capacity() and get_capacity() currently don't use\n\t\t * seqcounter to read/update the part0->nr_sects. Still init\n\t\t * the counter as we can read the sectors in IO submission\n\t\t * patch using seqence counters.\n\t\t *\n\t\t * TODO: Ideally set_capacity() and get_capacity() should be\n\t\t * converted to make use of bd_mutex and sequence counters.\n\t\t */\n\t\tseqcount_init(&disk->part0.nr_sects_seq);\n\t\tif (hd_ref_init(&disk->part0)) {\n\t\t\thd_free_part(&disk->part0);\n\t\t\tkfree(disk);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdisk->minors = minors;\n\t\trand_initialize_disk(disk);\n\t\tdisk_to_dev(disk)->class = &block_class;\n\t\tdisk_to_dev(disk)->type = &disk_type;\n\t\tdevice_initialize(disk_to_dev(disk));\n\t}\n\treturn disk;\n}\nEXPORT_SYMBOL(alloc_disk_node);\n\nstruct kobject *get_disk(struct gendisk *disk)\n{\n\tstruct module *owner;\n\tstruct kobject *kobj;\n\n\tif (!disk->fops)\n\t\treturn NULL;\n\towner = disk->fops->owner;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&disk_to_dev(disk)->kobj);\n\tif (kobj == NULL) {\n\t\tmodule_put(owner);\n\t\treturn NULL;\n\t}\n\treturn kobj;\n\n}\n\nEXPORT_SYMBOL(get_disk);\n\nvoid put_disk(struct gendisk *disk)\n{\n\tif (disk)\n\t\tkobject_put(&disk_to_dev(disk)->kobj);\n}\n\nEXPORT_SYMBOL(put_disk);\n\nstatic void set_disk_ro_uevent(struct gendisk *gd, int ro)\n{\n\tchar event[] = \"DISK_RO=1\";\n\tchar *envp[] = { event, NULL };\n\n\tif (!ro)\n\t\tevent[8] = '0';\n\tkobject_uevent_env(&disk_to_dev(gd)->kobj, KOBJ_CHANGE, envp);\n}\n\nvoid set_device_ro(struct block_device *bdev, int flag)\n{\n\tbdev->bd_part->policy = flag;\n}\n\nEXPORT_SYMBOL(set_device_ro);\n\nvoid set_disk_ro(struct gendisk *disk, int flag)\n{\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\n\tif (disk->part0.policy != flag) {\n\t\tset_disk_ro_uevent(disk, flag);\n\t\tdisk->part0.policy = flag;\n\t}\n\n\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tpart->policy = flag;\n\tdisk_part_iter_exit(&piter);\n}\n\nEXPORT_SYMBOL(set_disk_ro);\n\nint bdev_read_only(struct block_device *bdev)\n{\n\tif (!bdev)\n\t\treturn 0;\n\treturn bdev->bd_part->policy;\n}\n\nEXPORT_SYMBOL(bdev_read_only);\n\nint invalidate_partition(struct gendisk *disk, int partno)\n{\n\tint res = 0;\n\tstruct block_device *bdev = bdget_disk(disk, partno);\n\tif (bdev) {\n\t\tfsync_bdev(bdev);\n\t\tres = __invalidate_device(bdev, true);\n\t\tbdput(bdev);\n\t}\n\treturn res;\n}\n\nEXPORT_SYMBOL(invalidate_partition);\n\n/*\n * Disk events - monitor disk events like media change and eject request.\n */\nstruct disk_events {\n\tstruct list_head\tnode;\t\t/* all disk_event's */\n\tstruct gendisk\t\t*disk;\t\t/* the associated disk */\n\tspinlock_t\t\tlock;\n\n\tstruct mutex\t\tblock_mutex;\t/* protects blocking */\n\tint\t\t\tblock;\t\t/* event blocking depth */\n\tunsigned int\t\tpending;\t/* events already sent out */\n\tunsigned int\t\tclearing;\t/* events being cleared */\n\n\tlong\t\t\tpoll_msecs;\t/* interval, -1 for default */\n\tstruct delayed_work\tdwork;\n};\n\nstatic const char *disk_events_strs[] = {\n\t[ilog2(DISK_EVENT_MEDIA_CHANGE)]\t= \"media_change\",\n\t[ilog2(DISK_EVENT_EJECT_REQUEST)]\t= \"eject_request\",\n};\n\nstatic char *disk_uevents[] = {\n\t[ilog2(DISK_EVENT_MEDIA_CHANGE)]\t= \"DISK_MEDIA_CHANGE=1\",\n\t[ilog2(DISK_EVENT_EJECT_REQUEST)]\t= \"DISK_EJECT_REQUEST=1\",\n};\n\n/* list of all disk_events */\nstatic DEFINE_MUTEX(disk_events_mutex);\nstatic LIST_HEAD(disk_events);\n\n/* disable in-kernel polling by default */\nstatic unsigned long disk_events_dfl_poll_msecs;\n\nstatic unsigned long disk_events_poll_jiffies(struct gendisk *disk)\n{\n\tstruct disk_events *ev = disk->ev;\n\tlong intv_msecs = 0;\n\n\t/*\n\t * If device-specific poll interval is set, always use it.  If\n\t * the default is being used, poll iff there are events which\n\t * can't be monitored asynchronously.\n\t */\n\tif (ev->poll_msecs >= 0)\n\t\tintv_msecs = ev->poll_msecs;\n\telse if (disk->events & ~disk->async_events)\n\t\tintv_msecs = disk_events_dfl_poll_msecs;\n\n\treturn msecs_to_jiffies(intv_msecs);\n}\n\n/**\n * disk_block_events - block and flush disk event checking\n * @disk: disk to block events for\n *\n * On return from this function, it is guaranteed that event checking\n * isn't in progress and won't happen until unblocked by\n * disk_unblock_events().  Events blocking is counted and the actual\n * unblocking happens after the matching number of unblocks are done.\n *\n * Note that this intentionally does not block event checking from\n * disk_clear_events().\n *\n * CONTEXT:\n * Might sleep.\n */\nvoid disk_block_events(struct gendisk *disk)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned long flags;\n\tbool cancel;\n\n\tif (!ev)\n\t\treturn;\n\n\t/*\n\t * Outer mutex ensures that the first blocker completes canceling\n\t * the event work before further blockers are allowed to finish.\n\t */\n\tmutex_lock(&ev->block_mutex);\n\n\tspin_lock_irqsave(&ev->lock, flags);\n\tcancel = !ev->block++;\n\tspin_unlock_irqrestore(&ev->lock, flags);\n\n\tif (cancel)\n\t\tcancel_delayed_work_sync(&disk->ev->dwork);\n\n\tmutex_unlock(&ev->block_mutex);\n}\n\nstatic void __disk_unblock_events(struct gendisk *disk, bool check_now)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned long intv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ev->lock, flags);\n\n\tif (WARN_ON_ONCE(ev->block <= 0))\n\t\tgoto out_unlock;\n\n\tif (--ev->block)\n\t\tgoto out_unlock;\n\n\tintv = disk_events_poll_jiffies(disk);\n\tif (check_now)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, 0);\n\telse if (intv)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, intv);\nout_unlock:\n\tspin_unlock_irqrestore(&ev->lock, flags);\n}\n\n/**\n * disk_unblock_events - unblock disk event checking\n * @disk: disk to unblock events for\n *\n * Undo disk_block_events().  When the block count reaches zero, it\n * starts events polling if configured.\n *\n * CONTEXT:\n * Don't care.  Safe to call from irq context.\n */\nvoid disk_unblock_events(struct gendisk *disk)\n{\n\tif (disk->ev)\n\t\t__disk_unblock_events(disk, false);\n}\n\n/**\n * disk_flush_events - schedule immediate event checking and flushing\n * @disk: disk to check and flush events for\n * @mask: events to flush\n *\n * Schedule immediate event checking on @disk if not blocked.  Events in\n * @mask are scheduled to be cleared from the driver.  Note that this\n * doesn't clear the events from @disk->ev.\n *\n * CONTEXT:\n * If @mask is non-zero must be called with bdev->bd_mutex held.\n */\nvoid disk_flush_events(struct gendisk *disk, unsigned int mask)\n{\n\tstruct disk_events *ev = disk->ev;\n\n\tif (!ev)\n\t\treturn;\n\n\tspin_lock_irq(&ev->lock);\n\tev->clearing |= mask;\n\tif (!ev->block)\n\t\tmod_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, 0);\n\tspin_unlock_irq(&ev->lock);\n}\n\n/**\n * disk_clear_events - synchronously check, clear and return pending events\n * @disk: disk to fetch and clear events from\n * @mask: mask of events to be fetched and cleared\n *\n * Disk events are synchronously checked and pending events in @mask\n * are cleared and returned.  This ignores the block count.\n *\n * CONTEXT:\n * Might sleep.\n */\nunsigned int disk_clear_events(struct gendisk *disk, unsigned int mask)\n{\n\tconst struct block_device_operations *bdops = disk->fops;\n\tstruct disk_events *ev = disk->ev;\n\tunsigned int pending;\n\tunsigned int clearing = mask;\n\n\tif (!ev) {\n\t\t/* for drivers still using the old ->media_changed method */\n\t\tif ((mask & DISK_EVENT_MEDIA_CHANGE) &&\n\t\t    bdops->media_changed && bdops->media_changed(disk))\n\t\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\t\treturn 0;\n\t}\n\n\tdisk_block_events(disk);\n\n\t/*\n\t * store the union of mask and ev->clearing on the stack so that the\n\t * race with disk_flush_events does not cause ambiguity (ev->clearing\n\t * can still be modified even if events are blocked).\n\t */\n\tspin_lock_irq(&ev->lock);\n\tclearing |= ev->clearing;\n\tev->clearing = 0;\n\tspin_unlock_irq(&ev->lock);\n\n\tdisk_check_events(ev, &clearing);\n\t/*\n\t * if ev->clearing is not 0, the disk_flush_events got called in the\n\t * middle of this function, so we want to run the workfn without delay.\n\t */\n\t__disk_unblock_events(disk, ev->clearing ? true : false);\n\n\t/* then, fetch and clear pending events */\n\tspin_lock_irq(&ev->lock);\n\tpending = ev->pending & mask;\n\tev->pending &= ~mask;\n\tspin_unlock_irq(&ev->lock);\n\tWARN_ON_ONCE(clearing & mask);\n\n\treturn pending;\n}\n\n/*\n * Separate this part out so that a different pointer for clearing_ptr can be\n * passed in for disk_clear_events.\n */\nstatic void disk_events_workfn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct disk_events *ev = container_of(dwork, struct disk_events, dwork);\n\n\tdisk_check_events(ev, &ev->clearing);\n}\n\nstatic void disk_check_events(struct disk_events *ev,\n\t\t\t      unsigned int *clearing_ptr)\n{\n\tstruct gendisk *disk = ev->disk;\n\tchar *envp[ARRAY_SIZE(disk_uevents) + 1] = { };\n\tunsigned int clearing = *clearing_ptr;\n\tunsigned int events;\n\tunsigned long intv;\n\tint nr_events = 0, i;\n\n\t/* check events */\n\tevents = disk->fops->check_events(disk, clearing);\n\n\t/* accumulate pending events and schedule next poll if necessary */\n\tspin_lock_irq(&ev->lock);\n\n\tevents &= ~ev->pending;\n\tev->pending |= events;\n\t*clearing_ptr &= ~clearing;\n\n\tintv = disk_events_poll_jiffies(disk);\n\tif (!ev->block && intv)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, intv);\n\n\tspin_unlock_irq(&ev->lock);\n\n\t/*\n\t * Tell userland about new events.  Only the events listed in\n\t * @disk->events are reported.  Unlisted events are processed the\n\t * same internally but never get reported to userland.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(disk_uevents); i++)\n\t\tif (events & disk->events & (1 << i))\n\t\t\tenvp[nr_events++] = disk_uevents[i];\n\n\tif (nr_events)\n\t\tkobject_uevent_env(&disk_to_dev(disk)->kobj, KOBJ_CHANGE, envp);\n}\n\n/*\n * A disk events enabled device has the following sysfs nodes under\n * its /sys/block/X/ directory.\n *\n * events\t\t: list of all supported events\n * events_async\t\t: list of events which can be detected w/o polling\n * events_poll_msecs\t: polling interval, 0: disable, -1: system default\n */\nstatic ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}\n\nstatic ssize_t disk_events_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn __disk_events_show(disk->events, buf);\n}\n\nstatic ssize_t disk_events_async_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn __disk_events_show(disk->async_events, buf);\n}\n\nstatic ssize_t disk_events_poll_msecs_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%ld\\n\", disk->ev->poll_msecs);\n}\n\nstatic ssize_t disk_events_poll_msecs_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tlong intv;\n\n\tif (!count || !sscanf(buf, \"%ld\", &intv))\n\t\treturn -EINVAL;\n\n\tif (intv < 0 && intv != -1)\n\t\treturn -EINVAL;\n\n\tdisk_block_events(disk);\n\tdisk->ev->poll_msecs = intv;\n\t__disk_unblock_events(disk, true);\n\n\treturn count;\n}\n\nstatic const DEVICE_ATTR(events, S_IRUGO, disk_events_show, NULL);\nstatic const DEVICE_ATTR(events_async, S_IRUGO, disk_events_async_show, NULL);\nstatic const DEVICE_ATTR(events_poll_msecs, S_IRUGO|S_IWUSR,\n\t\t\t disk_events_poll_msecs_show,\n\t\t\t disk_events_poll_msecs_store);\n\nstatic const struct attribute *disk_events_attrs[] = {\n\t&dev_attr_events.attr,\n\t&dev_attr_events_async.attr,\n\t&dev_attr_events_poll_msecs.attr,\n\tNULL,\n};\n\n/*\n * The default polling interval can be specified by the kernel\n * parameter block.events_dfl_poll_msecs which defaults to 0\n * (disable).  This can also be modified runtime by writing to\n * /sys/module/block/events_dfl_poll_msecs.\n */\nstatic int disk_events_set_dfl_poll_msecs(const char *val,\n\t\t\t\t\t  const struct kernel_param *kp)\n{\n\tstruct disk_events *ev;\n\tint ret;\n\n\tret = param_set_ulong(val, kp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&disk_events_mutex);\n\n\tlist_for_each_entry(ev, &disk_events, node)\n\t\tdisk_flush_events(ev->disk, 0);\n\n\tmutex_unlock(&disk_events_mutex);\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops disk_events_dfl_poll_msecs_param_ops = {\n\t.set\t= disk_events_set_dfl_poll_msecs,\n\t.get\t= param_get_ulong,\n};\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX\t\"block.\"\n\nmodule_param_cb(events_dfl_poll_msecs, &disk_events_dfl_poll_msecs_param_ops,\n\t\t&disk_events_dfl_poll_msecs, 0644);\n\n/*\n * disk_{alloc|add|del|release}_events - initialize and destroy disk_events.\n */\nstatic void disk_alloc_events(struct gendisk *disk)\n{\n\tstruct disk_events *ev;\n\n\tif (!disk->fops->check_events)\n\t\treturn;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tpr_warn(\"%s: failed to initialize events\\n\", disk->disk_name);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&ev->node);\n\tev->disk = disk;\n\tspin_lock_init(&ev->lock);\n\tmutex_init(&ev->block_mutex);\n\tev->block = 1;\n\tev->poll_msecs = -1;\n\tINIT_DELAYED_WORK(&ev->dwork, disk_events_workfn);\n\n\tdisk->ev = ev;\n}\n\nstatic void disk_add_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\n\t/* FIXME: error handling */\n\tif (sysfs_create_files(&disk_to_dev(disk)->kobj, disk_events_attrs) < 0)\n\t\tpr_warn(\"%s: failed to create sysfs files for events\\n\",\n\t\t\tdisk->disk_name);\n\n\tmutex_lock(&disk_events_mutex);\n\tlist_add_tail(&disk->ev->node, &disk_events);\n\tmutex_unlock(&disk_events_mutex);\n\n\t/*\n\t * Block count is initialized to 1 and the following initial\n\t * unblock kicks it into action.\n\t */\n\t__disk_unblock_events(disk, true);\n}\n\nstatic void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\n\tdisk_block_events(disk);\n\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}\n\nstatic void disk_release_events(struct gendisk *disk)\n{\n\t/* the block count should be 1 from disk_del_events() */\n\tWARN_ON_ONCE(disk->ev && disk->ev->block != 1);\n\tkfree(disk->ev);\n}\n"], "filenames": ["block/genhd.c"], "buggy_code_start_loc": [858], "buggy_code_end_loc": [858], "fixing_code_start_loc": [859], "fixing_code_end_loc": [860], "type": "CWE-416", "message": "Use-after-free vulnerability in the disk_seqf_stop function in block/genhd.c in the Linux kernel before 4.7.1 allows local users to gain privileges by leveraging the execution of a certain stop operation even if the corresponding start operation had failed.", "other": {"cve": {"id": "CVE-2016-7910", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:05.110", "lastModified": "2023-01-19T16:08:01.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in the disk_seqf_stop function in block/genhd.c in the Linux kernel before 4.7.1 allows local users to gain privileges by leveraging the execution of a certain stop operation even if the corresponding start operation had failed."}, {"lang": "es", "value": "Vulnerabilidad de uso despu\u00e9s de liberaci\u00f3n de memoria en la funci\u00f3n disk_seqf_stop en block/genhd.c en el kernel de Linux en versiones anteriores a 4.7.1 permite a usuarios locales obtener privilegios aprovechando la ejecuci\u00f3n de una cierta operaci\u00f3n de parada incluso si la operaci\u00f3n de arranque correspondiente hubiera fallado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.84", "matchCriteriaId": "937FB472-B574-474F-B177-8EE85AC205A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.10.103", "matchCriteriaId": "0DC9AE03-9DF2-4168-8542-1171CB42C604"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.63", "matchCriteriaId": "5E9AAF5C-B199-415C-9DE1-E6B6D49C496E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.14.76", "matchCriteriaId": "F973F317-7CFF-484A-9B00-6957860C64FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.15", "versionEndExcluding": "3.16.39", "matchCriteriaId": "7C441EE1-EC9F-4D9D-95A4-3FD494363278"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.40", "matchCriteriaId": "BA4EE5D3-BF05-408A-A0CD-360F799A43AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.31", "matchCriteriaId": "A9D6D603-71C1-43F3-8A78-D5942BB88069"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.18", "matchCriteriaId": "90BAD349-4A79-4C09-AF6D-326F7B5EA4CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.6.7", "matchCriteriaId": "66D035A7-20BC-4D9D-8DA6-E6E8188CC244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.7", "versionEndExcluding": "4.7.1", "matchCriteriaId": "594FA24C-DE6D-49CA-AE2F-383918AAE393"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=77da160530dd1dc94f6ae15a981f24e5f0021e84", "source": "security@android.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.7.1", "source": "security@android.com", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/94135", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:0892", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1297", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1298", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1308", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84", "source": "security@android.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84"}}