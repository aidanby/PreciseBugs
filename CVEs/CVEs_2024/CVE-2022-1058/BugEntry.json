{"buggy_code": ["// Copyright 2014 The Gogs Authors. All rights reserved.\n// Copyright 2020 The Gitea Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage context\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"html\"\n\t\"html/template\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"code.gitea.io/gitea/models/unit\"\n\tuser_model \"code.gitea.io/gitea/models/user\"\n\t\"code.gitea.io/gitea/modules/base\"\n\tmc \"code.gitea.io/gitea/modules/cache\"\n\t\"code.gitea.io/gitea/modules/json\"\n\t\"code.gitea.io/gitea/modules/log\"\n\t\"code.gitea.io/gitea/modules/setting\"\n\t\"code.gitea.io/gitea/modules/templates\"\n\t\"code.gitea.io/gitea/modules/translation\"\n\t\"code.gitea.io/gitea/modules/web/middleware\"\n\t\"code.gitea.io/gitea/services/auth\"\n\n\t\"gitea.com/go-chi/cache\"\n\t\"gitea.com/go-chi/session\"\n\tchi \"github.com/go-chi/chi/v5\"\n\t\"github.com/unknwon/com\"\n\t\"github.com/unknwon/i18n\"\n\t\"github.com/unrolled/render\"\n\t\"golang.org/x/crypto/pbkdf2\"\n)\n\n// Render represents a template render\ntype Render interface {\n\tTemplateLookup(tmpl string) *template.Template\n\tHTML(w io.Writer, status int, name string, binding interface{}, htmlOpt ...render.HTMLOptions) error\n}\n\n// Context represents context of a request.\ntype Context struct {\n\tResp     ResponseWriter\n\tReq      *http.Request\n\tData     map[string]interface{} // data used by MVC templates\n\tPageData map[string]interface{} // data used by JavaScript modules in one page, it's `window.config.pageData`\n\tRender   Render\n\ttranslation.Locale\n\tCache   cache.Cache\n\tcsrf    CSRF\n\tFlash   *middleware.Flash\n\tSession session.Store\n\n\tLink        string // current request URL\n\tEscapedLink string\n\tUser        *user_model.User\n\tIsSigned    bool\n\tIsBasicAuth bool\n\n\tRepo *Repository\n\tOrg  *Organization\n}\n\n// TrHTMLEscapeArgs runs Tr but pre-escapes all arguments with html.EscapeString.\n// This is useful if the locale message is intended to only produce HTML content.\nfunc (ctx *Context) TrHTMLEscapeArgs(msg string, args ...string) string {\n\ttrArgs := make([]interface{}, len(args))\n\tfor i, arg := range args {\n\t\ttrArgs[i] = html.EscapeString(arg)\n\t}\n\treturn ctx.Tr(msg, trArgs...)\n}\n\n// GetData returns the data\nfunc (ctx *Context) GetData() map[string]interface{} {\n\treturn ctx.Data\n}\n\n// IsUserSiteAdmin returns true if current user is a site admin\nfunc (ctx *Context) IsUserSiteAdmin() bool {\n\treturn ctx.IsSigned && ctx.User.IsAdmin\n}\n\n// IsUserRepoOwner returns true if current user owns current repo\nfunc (ctx *Context) IsUserRepoOwner() bool {\n\treturn ctx.Repo.IsOwner()\n}\n\n// IsUserRepoAdmin returns true if current user is admin in current repo\nfunc (ctx *Context) IsUserRepoAdmin() bool {\n\treturn ctx.Repo.IsAdmin()\n}\n\n// IsUserRepoWriter returns true if current user has write privilege in current repo\nfunc (ctx *Context) IsUserRepoWriter(unitTypes []unit.Type) bool {\n\tfor _, unitType := range unitTypes {\n\t\tif ctx.Repo.CanWrite(unitType) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// IsUserRepoReaderSpecific returns true if current user can read current repo's specific part\nfunc (ctx *Context) IsUserRepoReaderSpecific(unitType unit.Type) bool {\n\treturn ctx.Repo.CanRead(unitType)\n}\n\n// IsUserRepoReaderAny returns true if current user can read any part of current repo\nfunc (ctx *Context) IsUserRepoReaderAny() bool {\n\treturn ctx.Repo.HasAccess()\n}\n\n// RedirectToUser redirect to a differently-named user\nfunc RedirectToUser(ctx *Context, userName string, redirectUserID int64) {\n\tuser, err := user_model.GetUserByID(redirectUserID)\n\tif err != nil {\n\t\tctx.ServerError(\"GetUserByID\", err)\n\t\treturn\n\t}\n\n\tredirectPath := strings.Replace(\n\t\tctx.Req.URL.EscapedPath(),\n\t\turl.PathEscape(userName),\n\t\turl.PathEscape(user.Name),\n\t\t1,\n\t)\n\tif ctx.Req.URL.RawQuery != \"\" {\n\t\tredirectPath += \"?\" + ctx.Req.URL.RawQuery\n\t}\n\tctx.Redirect(path.Join(setting.AppSubURL, redirectPath))\n}\n\n// HasAPIError returns true if error occurs in form validation.\nfunc (ctx *Context) HasAPIError() bool {\n\thasErr, ok := ctx.Data[\"HasError\"]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hasErr.(bool)\n}\n\n// GetErrMsg returns error message\nfunc (ctx *Context) GetErrMsg() string {\n\treturn ctx.Data[\"ErrorMsg\"].(string)\n}\n\n// HasError returns true if error occurs in form validation.\n// Attention: this function changes ctx.Data and ctx.Flash\nfunc (ctx *Context) HasError() bool {\n\thasErr, ok := ctx.Data[\"HasError\"]\n\tif !ok {\n\t\treturn false\n\t}\n\tctx.Flash.ErrorMsg = ctx.Data[\"ErrorMsg\"].(string)\n\tctx.Data[\"Flash\"] = ctx.Flash\n\treturn hasErr.(bool)\n}\n\n// HasValue returns true if value of given name exists.\nfunc (ctx *Context) HasValue(name string) bool {\n\t_, ok := ctx.Data[name]\n\treturn ok\n}\n\n// RedirectToFirst redirects to first not empty URL\nfunc (ctx *Context) RedirectToFirst(location ...string) {\n\tfor _, loc := range location {\n\t\tif len(loc) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tu, err := url.Parse(loc)\n\t\tif err != nil || ((u.Scheme != \"\" || u.Host != \"\") && !strings.HasPrefix(strings.ToLower(loc), strings.ToLower(setting.AppURL))) {\n\t\t\tcontinue\n\t\t}\n\n\t\tctx.Redirect(loc)\n\t\treturn\n\t}\n\n\tctx.Redirect(setting.AppSubURL + \"/\")\n}\n\n// HTML calls Context.HTML and renders the template to HTTP response\nfunc (ctx *Context) HTML(status int, name base.TplName) {\n\tlog.Debug(\"Template: %s\", name)\n\ttmplStartTime := time.Now()\n\tctx.Data[\"TmplLoadTimes\"] = func() string {\n\t\treturn strconv.FormatInt(time.Since(tmplStartTime).Nanoseconds()/1e6, 10) + \"ms\"\n\t}\n\tif err := ctx.Render.HTML(ctx.Resp, status, string(name), ctx.Data); err != nil {\n\t\tif status == http.StatusInternalServerError && name == base.TplName(\"status/500\") {\n\t\t\tctx.PlainText(http.StatusInternalServerError, \"Unable to find status/500 template\")\n\t\t\treturn\n\t\t}\n\t\tctx.ServerError(\"Render failed\", err)\n\t}\n}\n\n// RenderToString renders the template content to a string\nfunc (ctx *Context) RenderToString(name base.TplName, data map[string]interface{}) (string, error) {\n\tvar buf strings.Builder\n\terr := ctx.Render.HTML(&buf, 200, string(name), data)\n\treturn buf.String(), err\n}\n\n// RenderWithErr used for page has form validation but need to prompt error to users.\nfunc (ctx *Context) RenderWithErr(msg string, tpl base.TplName, form interface{}) {\n\tif form != nil {\n\t\tmiddleware.AssignForm(form, ctx.Data)\n\t}\n\tctx.Flash.ErrorMsg = msg\n\tctx.Data[\"Flash\"] = ctx.Flash\n\tctx.HTML(http.StatusOK, tpl)\n}\n\n// NotFound displays a 404 (Not Found) page and prints the given error, if any.\nfunc (ctx *Context) NotFound(logMsg string, logErr error) {\n\tctx.notFoundInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) notFoundInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.ErrorWithSkip(2, \"%s: %v\", logMsg, logErr)\n\t\tif !setting.IsProd {\n\t\t\tctx.Data[\"ErrorMsg\"] = logErr\n\t\t}\n\t}\n\n\t// response simple message if Accept isn't text/html\n\tshowHTML := false\n\tfor _, part := range ctx.Req.Header[\"Accept\"] {\n\t\tif strings.Contains(part, \"text/html\") {\n\t\t\tshowHTML = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !showHTML {\n\t\tctx.PlainText(http.StatusNotFound, \"Not found.\\n\")\n\t\treturn\n\t}\n\n\tctx.Data[\"IsRepo\"] = ctx.Repo.Repository != nil\n\tctx.Data[\"Title\"] = \"Page Not Found\"\n\tctx.HTML(http.StatusNotFound, base.TplName(\"status/404\"))\n}\n\n// ServerError displays a 500 (Internal Server Error) page and prints the given error, if any.\nfunc (ctx *Context) ServerError(logMsg string, logErr error) {\n\tctx.serverErrorInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) serverErrorInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.ErrorWithSkip(2, \"%s: %v\", logMsg, logErr)\n\t\tif _, ok := logErr.(*net.OpError); ok || errors.Is(logErr, &net.OpError{}) {\n\t\t\t// This is an error within the underlying connection\n\t\t\t// and further rendering will not work so just return\n\t\t\treturn\n\t\t}\n\n\t\tif !setting.IsProd {\n\t\t\tctx.Data[\"ErrorMsg\"] = logErr\n\t\t}\n\t}\n\n\tctx.Data[\"Title\"] = \"Internal Server Error\"\n\tctx.HTML(http.StatusInternalServerError, base.TplName(\"status/500\"))\n}\n\n// NotFoundOrServerError use error check function to determine if the error\n// is about not found. It responds with 404 status code for not found error,\n// or error context description for logging purpose of 500 server error.\nfunc (ctx *Context) NotFoundOrServerError(logMsg string, errCheck func(error) bool, err error) {\n\tif errCheck(err) {\n\t\tctx.notFoundInternal(logMsg, err)\n\t\treturn\n\t}\n\tctx.serverErrorInternal(logMsg, err)\n}\n\n// PlainTextBytes renders bytes as plain text\nfunc (ctx *Context) PlainTextBytes(status int, bs []byte) {\n\tif (status/100 == 4) || (status/100 == 5) {\n\t\tlog.Error(\"PlainTextBytes: %s\", string(bs))\n\t}\n\tctx.Resp.WriteHeader(status)\n\tctx.Resp.Header().Set(\"Content-Type\", \"text/plain;charset=utf-8\")\n\tctx.Resp.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\tif _, err := ctx.Resp.Write(bs); err != nil {\n\t\tlog.Error(\"Write bytes failed: %v\", err)\n\t}\n}\n\n// PlainText renders content as plain text\nfunc (ctx *Context) PlainText(status int, text string) {\n\tctx.PlainTextBytes(status, []byte(text))\n}\n\n// RespHeader returns the response header\nfunc (ctx *Context) RespHeader() http.Header {\n\treturn ctx.Resp.Header()\n}\n\n// ServeContent serves content to http request\nfunc (ctx *Context) ServeContent(name string, r io.ReadSeeker, params ...interface{}) {\n\tmodTime := time.Now()\n\tfor _, p := range params {\n\t\tswitch v := p.(type) {\n\t\tcase time.Time:\n\t\t\tmodTime = v\n\t\t}\n\t}\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\tctx.Resp.Header().Set(\"Access-Control-Expose-Headers\", \"Content-Disposition\")\n\thttp.ServeContent(ctx.Resp, ctx.Req, name, modTime, r)\n}\n\n// ServeFile serves given file to response.\nfunc (ctx *Context) ServeFile(file string, names ...string) {\n\tvar name string\n\tif len(names) > 0 {\n\t\tname = names[0]\n\t} else {\n\t\tname = path.Base(file)\n\t}\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\thttp.ServeFile(ctx.Resp, ctx.Req, file)\n}\n\n// ServeStream serves file via io stream\nfunc (ctx *Context) ServeStream(rd io.Reader, name string) {\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\t_, err := io.Copy(ctx.Resp, rd)\n\tif err != nil {\n\t\tctx.ServerError(\"Download file failed\", err)\n\t}\n}\n\n// Error returned an error to web browser\nfunc (ctx *Context) Error(status int, contents ...string) {\n\tvar v = http.StatusText(status)\n\tif len(contents) > 0 {\n\t\tv = contents[0]\n\t}\n\thttp.Error(ctx.Resp, v, status)\n}\n\n// JSON render content as JSON\nfunc (ctx *Context) JSON(status int, content interface{}) {\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tctx.Resp.WriteHeader(status)\n\tif err := json.NewEncoder(ctx.Resp).Encode(content); err != nil {\n\t\tctx.ServerError(\"Render JSON failed\", err)\n\t}\n}\n\n// Redirect redirects the request\nfunc (ctx *Context) Redirect(location string, status ...int) {\n\tcode := http.StatusFound\n\tif len(status) == 1 {\n\t\tcode = status[0]\n\t}\n\n\thttp.Redirect(ctx.Resp, ctx.Req, location, code)\n}\n\n// SetCookie convenience function to set most cookies consistently\n// CSRF and a few others are the exception here\nfunc (ctx *Context) SetCookie(name, value string, expiry int) {\n\tmiddleware.SetCookie(ctx.Resp, name, value,\n\t\texpiry,\n\t\tsetting.AppSubURL,\n\t\tsetting.SessionConfig.Domain,\n\t\tsetting.SessionConfig.Secure,\n\t\ttrue,\n\t\tmiddleware.SameSite(setting.SessionConfig.SameSite))\n}\n\n// DeleteCookie convenience function to delete most cookies consistently\n// CSRF and a few others are the exception here\nfunc (ctx *Context) DeleteCookie(name string) {\n\tmiddleware.SetCookie(ctx.Resp, name, \"\",\n\t\t-1,\n\t\tsetting.AppSubURL,\n\t\tsetting.SessionConfig.Domain,\n\t\tsetting.SessionConfig.Secure,\n\t\ttrue,\n\t\tmiddleware.SameSite(setting.SessionConfig.SameSite))\n}\n\n// GetCookie returns given cookie value from request header.\nfunc (ctx *Context) GetCookie(name string) string {\n\treturn middleware.GetCookie(ctx.Req, name)\n}\n\n// GetSuperSecureCookie returns given cookie value from request header with secret string.\nfunc (ctx *Context) GetSuperSecureCookie(secret, name string) (string, bool) {\n\tval := ctx.GetCookie(name)\n\treturn ctx.CookieDecrypt(secret, val)\n}\n\n// CookieDecrypt returns given value from with secret string.\nfunc (ctx *Context) CookieDecrypt(secret, val string) (string, bool) {\n\tif val == \"\" {\n\t\treturn \"\", false\n\t}\n\n\ttext, err := hex.DecodeString(val)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\tkey := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)\n\ttext, err = com.AESGCMDecrypt(key, text)\n\treturn string(text), err == nil\n}\n\n// SetSuperSecureCookie sets given cookie value to response header with secret string.\nfunc (ctx *Context) SetSuperSecureCookie(secret, name, value string, expiry int) {\n\ttext := ctx.CookieEncrypt(secret, value)\n\n\tctx.SetCookie(name, text, expiry)\n}\n\n// CookieEncrypt encrypts a given value using the provided secret\nfunc (ctx *Context) CookieEncrypt(secret, value string) string {\n\tkey := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)\n\ttext, err := com.AESGCMEncrypt(key, []byte(value))\n\tif err != nil {\n\t\tpanic(\"error encrypting cookie: \" + err.Error())\n\t}\n\n\treturn hex.EncodeToString(text)\n}\n\n// GetCookieInt returns cookie result in int type.\nfunc (ctx *Context) GetCookieInt(name string) int {\n\tr, _ := strconv.Atoi(ctx.GetCookie(name))\n\treturn r\n}\n\n// GetCookieInt64 returns cookie result in int64 type.\nfunc (ctx *Context) GetCookieInt64(name string) int64 {\n\tr, _ := strconv.ParseInt(ctx.GetCookie(name), 10, 64)\n\treturn r\n}\n\n// GetCookieFloat64 returns cookie result in float64 type.\nfunc (ctx *Context) GetCookieFloat64(name string) float64 {\n\tv, _ := strconv.ParseFloat(ctx.GetCookie(name), 64)\n\treturn v\n}\n\n// RemoteAddr returns the client machie ip address\nfunc (ctx *Context) RemoteAddr() string {\n\treturn ctx.Req.RemoteAddr\n}\n\n// Params returns the param on route\nfunc (ctx *Context) Params(p string) string {\n\ts, _ := url.PathUnescape(chi.URLParam(ctx.Req, strings.TrimPrefix(p, \":\")))\n\treturn s\n}\n\n// ParamsInt64 returns the param on route as int64\nfunc (ctx *Context) ParamsInt64(p string) int64 {\n\tv, _ := strconv.ParseInt(ctx.Params(p), 10, 64)\n\treturn v\n}\n\n// SetParams set params into routes\nfunc (ctx *Context) SetParams(k, v string) {\n\tchiCtx := chi.RouteContext(ctx)\n\tchiCtx.URLParams.Add(strings.TrimPrefix(k, \":\"), url.PathEscape(v))\n}\n\n// Write writes data to web browser\nfunc (ctx *Context) Write(bs []byte) (int, error) {\n\treturn ctx.Resp.Write(bs)\n}\n\n// Written returns true if there are something sent to web browser\nfunc (ctx *Context) Written() bool {\n\treturn ctx.Resp.Status() > 0\n}\n\n// Status writes status code\nfunc (ctx *Context) Status(status int) {\n\tctx.Resp.WriteHeader(status)\n}\n\n// Deadline is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Deadline() (deadline time.Time, ok bool) {\n\treturn ctx.Req.Context().Deadline()\n}\n\n// Done is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Done() <-chan struct{} {\n\treturn ctx.Req.Context().Done()\n}\n\n// Err is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Err() error {\n\treturn ctx.Req.Context().Err()\n}\n\n// Value is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Value(key interface{}) interface{} {\n\treturn ctx.Req.Context().Value(key)\n}\n\n// Handler represents a custom handler\ntype Handler func(*Context)\n\ntype contextKeyType struct{}\n\nvar contextKey interface{} = contextKeyType{}\n\n// WithContext set up install context in request\nfunc WithContext(req *http.Request, ctx *Context) *http.Request {\n\treturn req.WithContext(context.WithValue(req.Context(), contextKey, ctx))\n}\n\n// GetContext retrieves install context from request\nfunc GetContext(req *http.Request) *Context {\n\treturn req.Context().Value(contextKey).(*Context)\n}\n\n// GetContextUser returns context user\nfunc GetContextUser(req *http.Request) *user_model.User {\n\tif apiContext, ok := req.Context().Value(apiContextKey).(*APIContext); ok {\n\t\treturn apiContext.User\n\t}\n\tif ctx, ok := req.Context().Value(contextKey).(*Context); ok {\n\t\treturn ctx.User\n\t}\n\treturn nil\n}\n\nfunc getCsrfOpts() CsrfOptions {\n\treturn CsrfOptions{\n\t\tSecret:         setting.SecretKey,\n\t\tCookie:         setting.CSRFCookieName,\n\t\tSetCookie:      true,\n\t\tSecure:         setting.SessionConfig.Secure,\n\t\tCookieHTTPOnly: setting.CSRFCookieHTTPOnly,\n\t\tHeader:         \"X-Csrf-Token\",\n\t\tCookieDomain:   setting.SessionConfig.Domain,\n\t\tCookiePath:     setting.SessionConfig.CookiePath,\n\t\tSameSite:       setting.SessionConfig.SameSite,\n\t}\n}\n\n// Auth converts auth.Auth as a middleware\nfunc Auth(authMethod auth.Method) func(*Context) {\n\treturn func(ctx *Context) {\n\t\tctx.User = authMethod.Verify(ctx.Req, ctx.Resp, ctx, ctx.Session)\n\t\tif ctx.User != nil {\n\t\t\tif ctx.Locale.Language() != ctx.User.Language {\n\t\t\t\tctx.Locale = middleware.Locale(ctx.Resp, ctx.Req)\n\t\t\t}\n\t\t\tctx.IsBasicAuth = ctx.Data[\"AuthedMethod\"].(string) == auth.BasicMethodName\n\t\t\tctx.IsSigned = true\n\t\t\tctx.Data[\"IsSigned\"] = ctx.IsSigned\n\t\t\tctx.Data[\"SignedUser\"] = ctx.User\n\t\t\tctx.Data[\"SignedUserID\"] = ctx.User.ID\n\t\t\tctx.Data[\"SignedUserName\"] = ctx.User.Name\n\t\t\tctx.Data[\"IsAdmin\"] = ctx.User.IsAdmin\n\t\t} else {\n\t\t\tctx.Data[\"SignedUserID\"] = int64(0)\n\t\t\tctx.Data[\"SignedUserName\"] = \"\"\n\n\t\t\t// ensure the session uid is deleted\n\t\t\t_ = ctx.Session.Delete(\"uid\")\n\t\t}\n\t}\n}\n\n// Contexter initializes a classic context for a request.\nfunc Contexter() func(next http.Handler) http.Handler {\n\tvar rnd = templates.HTMLRenderer()\n\tvar csrfOpts = getCsrfOpts()\n\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {\n\t\t\tvar locale = middleware.Locale(resp, req)\n\t\t\tvar startTime = time.Now()\n\t\t\tvar link = setting.AppSubURL + strings.TrimSuffix(req.URL.EscapedPath(), \"/\")\n\n\t\t\tvar ctx = Context{\n\t\t\t\tResp:    NewResponse(resp),\n\t\t\t\tCache:   mc.GetCache(),\n\t\t\t\tLocale:  locale,\n\t\t\t\tLink:    link,\n\t\t\t\tRender:  rnd,\n\t\t\t\tSession: session.GetSession(req),\n\t\t\t\tRepo: &Repository{\n\t\t\t\t\tPullRequest: &PullRequest{},\n\t\t\t\t},\n\t\t\t\tOrg: &Organization{},\n\t\t\t\tData: map[string]interface{}{\n\t\t\t\t\t\"CurrentURL\":    setting.AppSubURL + req.URL.RequestURI(),\n\t\t\t\t\t\"PageStartTime\": startTime,\n\t\t\t\t\t\"Link\":          link,\n\t\t\t\t\t\"RunModeIsProd\": setting.IsProd,\n\t\t\t\t},\n\t\t\t}\n\t\t\t// PageData is passed by reference, and it will be rendered to `window.config.pageData` in `head.tmpl` for JavaScript modules\n\t\t\tctx.PageData = map[string]interface{}{}\n\t\t\tctx.Data[\"PageData\"] = ctx.PageData\n\n\t\t\tctx.Req = WithContext(req, &ctx)\n\t\t\tctx.csrf = Csrfer(csrfOpts, &ctx)\n\n\t\t\t// Get flash.\n\t\t\tflashCookie := ctx.GetCookie(\"macaron_flash\")\n\t\t\tvals, _ := url.ParseQuery(flashCookie)\n\t\t\tif len(vals) > 0 {\n\t\t\t\tf := &middleware.Flash{\n\t\t\t\t\tDataStore:  &ctx,\n\t\t\t\t\tValues:     vals,\n\t\t\t\t\tErrorMsg:   vals.Get(\"error\"),\n\t\t\t\t\tSuccessMsg: vals.Get(\"success\"),\n\t\t\t\t\tInfoMsg:    vals.Get(\"info\"),\n\t\t\t\t\tWarningMsg: vals.Get(\"warning\"),\n\t\t\t\t}\n\t\t\t\tctx.Data[\"Flash\"] = f\n\t\t\t}\n\n\t\t\tf := &middleware.Flash{\n\t\t\t\tDataStore:  &ctx,\n\t\t\t\tValues:     url.Values{},\n\t\t\t\tErrorMsg:   \"\",\n\t\t\t\tWarningMsg: \"\",\n\t\t\t\tInfoMsg:    \"\",\n\t\t\t\tSuccessMsg: \"\",\n\t\t\t}\n\t\t\tctx.Resp.Before(func(resp ResponseWriter) {\n\t\t\t\tif flash := f.Encode(); len(flash) > 0 {\n\t\t\t\t\tmiddleware.SetCookie(resp, \"macaron_flash\", flash, 0,\n\t\t\t\t\t\tsetting.SessionConfig.CookiePath,\n\t\t\t\t\t\tmiddleware.Domain(setting.SessionConfig.Domain),\n\t\t\t\t\t\tmiddleware.HTTPOnly(true),\n\t\t\t\t\t\tmiddleware.Secure(setting.SessionConfig.Secure),\n\t\t\t\t\t\tmiddleware.SameSite(setting.SessionConfig.SameSite),\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tmiddleware.SetCookie(ctx.Resp, \"macaron_flash\", \"\", -1,\n\t\t\t\t\tsetting.SessionConfig.CookiePath,\n\t\t\t\t\tmiddleware.Domain(setting.SessionConfig.Domain),\n\t\t\t\t\tmiddleware.HTTPOnly(true),\n\t\t\t\t\tmiddleware.Secure(setting.SessionConfig.Secure),\n\t\t\t\t\tmiddleware.SameSite(setting.SessionConfig.SameSite),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tctx.Flash = f\n\n\t\t\t// If request sends files, parse them here otherwise the Query() can't be parsed and the CsrfToken will be invalid.\n\t\t\tif ctx.Req.Method == \"POST\" && strings.Contains(ctx.Req.Header.Get(\"Content-Type\"), \"multipart/form-data\") {\n\t\t\t\tif err := ctx.Req.ParseMultipartForm(setting.Attachment.MaxSize << 20); err != nil && !strings.Contains(err.Error(), \"EOF\") { // 32MB max size\n\t\t\t\t\tctx.ServerError(\"ParseMultipartForm\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.Resp.Header().Set(`X-Frame-Options`, setting.CORSConfig.XFrameOptions)\n\n\t\t\tctx.Data[\"CsrfToken\"] = html.EscapeString(ctx.csrf.GetToken())\n\t\t\tctx.Data[\"CsrfTokenHtml\"] = template.HTML(`<input type=\"hidden\" name=\"_csrf\" value=\"` + ctx.Data[\"CsrfToken\"].(string) + `\">`)\n\n\t\t\t// FIXME: do we really always need these setting? There should be someway to have to avoid having to always set these\n\t\t\tctx.Data[\"IsLandingPageHome\"] = setting.LandingPageURL == setting.LandingPageHome\n\t\t\tctx.Data[\"IsLandingPageExplore\"] = setting.LandingPageURL == setting.LandingPageExplore\n\t\t\tctx.Data[\"IsLandingPageOrganizations\"] = setting.LandingPageURL == setting.LandingPageOrganizations\n\n\t\t\tctx.Data[\"ShowRegistrationButton\"] = setting.Service.ShowRegistrationButton\n\t\t\tctx.Data[\"ShowMilestonesDashboardPage\"] = setting.Service.ShowMilestonesDashboardPage\n\t\t\tctx.Data[\"ShowFooterBranding\"] = setting.ShowFooterBranding\n\t\t\tctx.Data[\"ShowFooterVersion\"] = setting.ShowFooterVersion\n\n\t\t\tctx.Data[\"EnableSwagger\"] = setting.API.EnableSwagger\n\t\t\tctx.Data[\"EnableOpenIDSignIn\"] = setting.Service.EnableOpenIDSignIn\n\t\t\tctx.Data[\"DisableMigrations\"] = setting.Repository.DisableMigrations\n\t\t\tctx.Data[\"DisableStars\"] = setting.Repository.DisableStars\n\n\t\t\tctx.Data[\"ManifestData\"] = setting.ManifestData\n\n\t\t\tctx.Data[\"UnitWikiGlobalDisabled\"] = unit.TypeWiki.UnitGlobalDisabled()\n\t\t\tctx.Data[\"UnitIssuesGlobalDisabled\"] = unit.TypeIssues.UnitGlobalDisabled()\n\t\t\tctx.Data[\"UnitPullsGlobalDisabled\"] = unit.TypePullRequests.UnitGlobalDisabled()\n\t\t\tctx.Data[\"UnitProjectsGlobalDisabled\"] = unit.TypeProjects.UnitGlobalDisabled()\n\n\t\t\tctx.Data[\"i18n\"] = locale\n\t\t\tctx.Data[\"Tr\"] = i18n.Tr\n\t\t\tctx.Data[\"Lang\"] = locale.Language()\n\t\t\tctx.Data[\"AllLangs\"] = translation.AllLangs()\n\t\t\tfor _, lang := range translation.AllLangs() {\n\t\t\t\tif lang.Lang == locale.Language() {\n\t\t\t\t\tctx.Data[\"LangName\"] = lang.Name\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext.ServeHTTP(ctx.Resp, ctx.Req)\n\n\t\t\t// Handle adding signedUserName to the context for the AccessLogger\n\t\t\tusernameInterface := ctx.Data[\"SignedUserName\"]\n\t\t\tidentityPtrInterface := ctx.Req.Context().Value(signedUserNameStringPointerKey)\n\t\t\tif usernameInterface != nil && identityPtrInterface != nil {\n\t\t\t\tusername := usernameInterface.(string)\n\t\t\t\tidentityPtr := identityPtrInterface.(*string)\n\t\t\t\tif identityPtr != nil && username != \"\" {\n\t\t\t\t\t*identityPtr = username\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["// Copyright 2014 The Gogs Authors. All rights reserved.\n// Copyright 2020 The Gitea Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage context\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"html\"\n\t\"html/template\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"code.gitea.io/gitea/models/unit\"\n\tuser_model \"code.gitea.io/gitea/models/user\"\n\t\"code.gitea.io/gitea/modules/base\"\n\tmc \"code.gitea.io/gitea/modules/cache\"\n\t\"code.gitea.io/gitea/modules/json\"\n\t\"code.gitea.io/gitea/modules/log\"\n\t\"code.gitea.io/gitea/modules/setting\"\n\t\"code.gitea.io/gitea/modules/templates\"\n\t\"code.gitea.io/gitea/modules/translation\"\n\t\"code.gitea.io/gitea/modules/web/middleware\"\n\t\"code.gitea.io/gitea/services/auth\"\n\n\t\"gitea.com/go-chi/cache\"\n\t\"gitea.com/go-chi/session\"\n\tchi \"github.com/go-chi/chi/v5\"\n\t\"github.com/unknwon/com\"\n\t\"github.com/unknwon/i18n\"\n\t\"github.com/unrolled/render\"\n\t\"golang.org/x/crypto/pbkdf2\"\n)\n\n// Render represents a template render\ntype Render interface {\n\tTemplateLookup(tmpl string) *template.Template\n\tHTML(w io.Writer, status int, name string, binding interface{}, htmlOpt ...render.HTMLOptions) error\n}\n\n// Context represents context of a request.\ntype Context struct {\n\tResp     ResponseWriter\n\tReq      *http.Request\n\tData     map[string]interface{} // data used by MVC templates\n\tPageData map[string]interface{} // data used by JavaScript modules in one page, it's `window.config.pageData`\n\tRender   Render\n\ttranslation.Locale\n\tCache   cache.Cache\n\tcsrf    CSRF\n\tFlash   *middleware.Flash\n\tSession session.Store\n\n\tLink        string // current request URL\n\tEscapedLink string\n\tUser        *user_model.User\n\tIsSigned    bool\n\tIsBasicAuth bool\n\n\tRepo *Repository\n\tOrg  *Organization\n}\n\n// TrHTMLEscapeArgs runs Tr but pre-escapes all arguments with html.EscapeString.\n// This is useful if the locale message is intended to only produce HTML content.\nfunc (ctx *Context) TrHTMLEscapeArgs(msg string, args ...string) string {\n\ttrArgs := make([]interface{}, len(args))\n\tfor i, arg := range args {\n\t\ttrArgs[i] = html.EscapeString(arg)\n\t}\n\treturn ctx.Tr(msg, trArgs...)\n}\n\n// GetData returns the data\nfunc (ctx *Context) GetData() map[string]interface{} {\n\treturn ctx.Data\n}\n\n// IsUserSiteAdmin returns true if current user is a site admin\nfunc (ctx *Context) IsUserSiteAdmin() bool {\n\treturn ctx.IsSigned && ctx.User.IsAdmin\n}\n\n// IsUserRepoOwner returns true if current user owns current repo\nfunc (ctx *Context) IsUserRepoOwner() bool {\n\treturn ctx.Repo.IsOwner()\n}\n\n// IsUserRepoAdmin returns true if current user is admin in current repo\nfunc (ctx *Context) IsUserRepoAdmin() bool {\n\treturn ctx.Repo.IsAdmin()\n}\n\n// IsUserRepoWriter returns true if current user has write privilege in current repo\nfunc (ctx *Context) IsUserRepoWriter(unitTypes []unit.Type) bool {\n\tfor _, unitType := range unitTypes {\n\t\tif ctx.Repo.CanWrite(unitType) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// IsUserRepoReaderSpecific returns true if current user can read current repo's specific part\nfunc (ctx *Context) IsUserRepoReaderSpecific(unitType unit.Type) bool {\n\treturn ctx.Repo.CanRead(unitType)\n}\n\n// IsUserRepoReaderAny returns true if current user can read any part of current repo\nfunc (ctx *Context) IsUserRepoReaderAny() bool {\n\treturn ctx.Repo.HasAccess()\n}\n\n// RedirectToUser redirect to a differently-named user\nfunc RedirectToUser(ctx *Context, userName string, redirectUserID int64) {\n\tuser, err := user_model.GetUserByID(redirectUserID)\n\tif err != nil {\n\t\tctx.ServerError(\"GetUserByID\", err)\n\t\treturn\n\t}\n\n\tredirectPath := strings.Replace(\n\t\tctx.Req.URL.EscapedPath(),\n\t\turl.PathEscape(userName),\n\t\turl.PathEscape(user.Name),\n\t\t1,\n\t)\n\tif ctx.Req.URL.RawQuery != \"\" {\n\t\tredirectPath += \"?\" + ctx.Req.URL.RawQuery\n\t}\n\tctx.Redirect(path.Join(setting.AppSubURL, redirectPath))\n}\n\n// HasAPIError returns true if error occurs in form validation.\nfunc (ctx *Context) HasAPIError() bool {\n\thasErr, ok := ctx.Data[\"HasError\"]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hasErr.(bool)\n}\n\n// GetErrMsg returns error message\nfunc (ctx *Context) GetErrMsg() string {\n\treturn ctx.Data[\"ErrorMsg\"].(string)\n}\n\n// HasError returns true if error occurs in form validation.\n// Attention: this function changes ctx.Data and ctx.Flash\nfunc (ctx *Context) HasError() bool {\n\thasErr, ok := ctx.Data[\"HasError\"]\n\tif !ok {\n\t\treturn false\n\t}\n\tctx.Flash.ErrorMsg = ctx.Data[\"ErrorMsg\"].(string)\n\tctx.Data[\"Flash\"] = ctx.Flash\n\treturn hasErr.(bool)\n}\n\n// HasValue returns true if value of given name exists.\nfunc (ctx *Context) HasValue(name string) bool {\n\t_, ok := ctx.Data[name]\n\treturn ok\n}\n\n// RedirectToFirst redirects to first not empty URL\nfunc (ctx *Context) RedirectToFirst(location ...string) {\n\tfor _, loc := range location {\n\t\tif len(loc) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Unfortunately browsers consider a redirect Location with preceding \"//\" and \"/\\\" as meaning redirect to \"http(s)://REST_OF_PATH\"\n\t\t// Therefore we should ignore these redirect locations to prevent open redirects\n\t\tif len(loc) > 1 && loc[0] == '/' && (loc[1] == '/' || loc[1] == '\\\\') {\n\t\t\tcontinue\n\t\t}\n\n\t\tu, err := url.Parse(loc)\n\t\tif err != nil || ((u.Scheme != \"\" || u.Host != \"\") && !strings.HasPrefix(strings.ToLower(loc), strings.ToLower(setting.AppURL))) {\n\t\t\tcontinue\n\t\t}\n\n\t\tctx.Redirect(loc)\n\t\treturn\n\t}\n\n\tctx.Redirect(setting.AppSubURL + \"/\")\n}\n\n// HTML calls Context.HTML and renders the template to HTTP response\nfunc (ctx *Context) HTML(status int, name base.TplName) {\n\tlog.Debug(\"Template: %s\", name)\n\ttmplStartTime := time.Now()\n\tctx.Data[\"TmplLoadTimes\"] = func() string {\n\t\treturn strconv.FormatInt(time.Since(tmplStartTime).Nanoseconds()/1e6, 10) + \"ms\"\n\t}\n\tif err := ctx.Render.HTML(ctx.Resp, status, string(name), ctx.Data); err != nil {\n\t\tif status == http.StatusInternalServerError && name == base.TplName(\"status/500\") {\n\t\t\tctx.PlainText(http.StatusInternalServerError, \"Unable to find status/500 template\")\n\t\t\treturn\n\t\t}\n\t\tctx.ServerError(\"Render failed\", err)\n\t}\n}\n\n// RenderToString renders the template content to a string\nfunc (ctx *Context) RenderToString(name base.TplName, data map[string]interface{}) (string, error) {\n\tvar buf strings.Builder\n\terr := ctx.Render.HTML(&buf, 200, string(name), data)\n\treturn buf.String(), err\n}\n\n// RenderWithErr used for page has form validation but need to prompt error to users.\nfunc (ctx *Context) RenderWithErr(msg string, tpl base.TplName, form interface{}) {\n\tif form != nil {\n\t\tmiddleware.AssignForm(form, ctx.Data)\n\t}\n\tctx.Flash.ErrorMsg = msg\n\tctx.Data[\"Flash\"] = ctx.Flash\n\tctx.HTML(http.StatusOK, tpl)\n}\n\n// NotFound displays a 404 (Not Found) page and prints the given error, if any.\nfunc (ctx *Context) NotFound(logMsg string, logErr error) {\n\tctx.notFoundInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) notFoundInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.ErrorWithSkip(2, \"%s: %v\", logMsg, logErr)\n\t\tif !setting.IsProd {\n\t\t\tctx.Data[\"ErrorMsg\"] = logErr\n\t\t}\n\t}\n\n\t// response simple message if Accept isn't text/html\n\tshowHTML := false\n\tfor _, part := range ctx.Req.Header[\"Accept\"] {\n\t\tif strings.Contains(part, \"text/html\") {\n\t\t\tshowHTML = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !showHTML {\n\t\tctx.PlainText(http.StatusNotFound, \"Not found.\\n\")\n\t\treturn\n\t}\n\n\tctx.Data[\"IsRepo\"] = ctx.Repo.Repository != nil\n\tctx.Data[\"Title\"] = \"Page Not Found\"\n\tctx.HTML(http.StatusNotFound, base.TplName(\"status/404\"))\n}\n\n// ServerError displays a 500 (Internal Server Error) page and prints the given error, if any.\nfunc (ctx *Context) ServerError(logMsg string, logErr error) {\n\tctx.serverErrorInternal(logMsg, logErr)\n}\n\nfunc (ctx *Context) serverErrorInternal(logMsg string, logErr error) {\n\tif logErr != nil {\n\t\tlog.ErrorWithSkip(2, \"%s: %v\", logMsg, logErr)\n\t\tif _, ok := logErr.(*net.OpError); ok || errors.Is(logErr, &net.OpError{}) {\n\t\t\t// This is an error within the underlying connection\n\t\t\t// and further rendering will not work so just return\n\t\t\treturn\n\t\t}\n\n\t\tif !setting.IsProd {\n\t\t\tctx.Data[\"ErrorMsg\"] = logErr\n\t\t}\n\t}\n\n\tctx.Data[\"Title\"] = \"Internal Server Error\"\n\tctx.HTML(http.StatusInternalServerError, base.TplName(\"status/500\"))\n}\n\n// NotFoundOrServerError use error check function to determine if the error\n// is about not found. It responds with 404 status code for not found error,\n// or error context description for logging purpose of 500 server error.\nfunc (ctx *Context) NotFoundOrServerError(logMsg string, errCheck func(error) bool, err error) {\n\tif errCheck(err) {\n\t\tctx.notFoundInternal(logMsg, err)\n\t\treturn\n\t}\n\tctx.serverErrorInternal(logMsg, err)\n}\n\n// PlainTextBytes renders bytes as plain text\nfunc (ctx *Context) PlainTextBytes(status int, bs []byte) {\n\tif (status/100 == 4) || (status/100 == 5) {\n\t\tlog.Error(\"PlainTextBytes: %s\", string(bs))\n\t}\n\tctx.Resp.WriteHeader(status)\n\tctx.Resp.Header().Set(\"Content-Type\", \"text/plain;charset=utf-8\")\n\tctx.Resp.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\tif _, err := ctx.Resp.Write(bs); err != nil {\n\t\tlog.Error(\"Write bytes failed: %v\", err)\n\t}\n}\n\n// PlainText renders content as plain text\nfunc (ctx *Context) PlainText(status int, text string) {\n\tctx.PlainTextBytes(status, []byte(text))\n}\n\n// RespHeader returns the response header\nfunc (ctx *Context) RespHeader() http.Header {\n\treturn ctx.Resp.Header()\n}\n\n// ServeContent serves content to http request\nfunc (ctx *Context) ServeContent(name string, r io.ReadSeeker, params ...interface{}) {\n\tmodTime := time.Now()\n\tfor _, p := range params {\n\t\tswitch v := p.(type) {\n\t\tcase time.Time:\n\t\t\tmodTime = v\n\t\t}\n\t}\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\tctx.Resp.Header().Set(\"Access-Control-Expose-Headers\", \"Content-Disposition\")\n\thttp.ServeContent(ctx.Resp, ctx.Req, name, modTime, r)\n}\n\n// ServeFile serves given file to response.\nfunc (ctx *Context) ServeFile(file string, names ...string) {\n\tvar name string\n\tif len(names) > 0 {\n\t\tname = names[0]\n\t} else {\n\t\tname = path.Base(file)\n\t}\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\thttp.ServeFile(ctx.Resp, ctx.Req, file)\n}\n\n// ServeStream serves file via io stream\nfunc (ctx *Context) ServeStream(rd io.Reader, name string) {\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\t_, err := io.Copy(ctx.Resp, rd)\n\tif err != nil {\n\t\tctx.ServerError(\"Download file failed\", err)\n\t}\n}\n\n// Error returned an error to web browser\nfunc (ctx *Context) Error(status int, contents ...string) {\n\tvar v = http.StatusText(status)\n\tif len(contents) > 0 {\n\t\tv = contents[0]\n\t}\n\thttp.Error(ctx.Resp, v, status)\n}\n\n// JSON render content as JSON\nfunc (ctx *Context) JSON(status int, content interface{}) {\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tctx.Resp.WriteHeader(status)\n\tif err := json.NewEncoder(ctx.Resp).Encode(content); err != nil {\n\t\tctx.ServerError(\"Render JSON failed\", err)\n\t}\n}\n\n// Redirect redirects the request\nfunc (ctx *Context) Redirect(location string, status ...int) {\n\tcode := http.StatusFound\n\tif len(status) == 1 {\n\t\tcode = status[0]\n\t}\n\n\thttp.Redirect(ctx.Resp, ctx.Req, location, code)\n}\n\n// SetCookie convenience function to set most cookies consistently\n// CSRF and a few others are the exception here\nfunc (ctx *Context) SetCookie(name, value string, expiry int) {\n\tmiddleware.SetCookie(ctx.Resp, name, value,\n\t\texpiry,\n\t\tsetting.AppSubURL,\n\t\tsetting.SessionConfig.Domain,\n\t\tsetting.SessionConfig.Secure,\n\t\ttrue,\n\t\tmiddleware.SameSite(setting.SessionConfig.SameSite))\n}\n\n// DeleteCookie convenience function to delete most cookies consistently\n// CSRF and a few others are the exception here\nfunc (ctx *Context) DeleteCookie(name string) {\n\tmiddleware.SetCookie(ctx.Resp, name, \"\",\n\t\t-1,\n\t\tsetting.AppSubURL,\n\t\tsetting.SessionConfig.Domain,\n\t\tsetting.SessionConfig.Secure,\n\t\ttrue,\n\t\tmiddleware.SameSite(setting.SessionConfig.SameSite))\n}\n\n// GetCookie returns given cookie value from request header.\nfunc (ctx *Context) GetCookie(name string) string {\n\treturn middleware.GetCookie(ctx.Req, name)\n}\n\n// GetSuperSecureCookie returns given cookie value from request header with secret string.\nfunc (ctx *Context) GetSuperSecureCookie(secret, name string) (string, bool) {\n\tval := ctx.GetCookie(name)\n\treturn ctx.CookieDecrypt(secret, val)\n}\n\n// CookieDecrypt returns given value from with secret string.\nfunc (ctx *Context) CookieDecrypt(secret, val string) (string, bool) {\n\tif val == \"\" {\n\t\treturn \"\", false\n\t}\n\n\ttext, err := hex.DecodeString(val)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\tkey := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)\n\ttext, err = com.AESGCMDecrypt(key, text)\n\treturn string(text), err == nil\n}\n\n// SetSuperSecureCookie sets given cookie value to response header with secret string.\nfunc (ctx *Context) SetSuperSecureCookie(secret, name, value string, expiry int) {\n\ttext := ctx.CookieEncrypt(secret, value)\n\n\tctx.SetCookie(name, text, expiry)\n}\n\n// CookieEncrypt encrypts a given value using the provided secret\nfunc (ctx *Context) CookieEncrypt(secret, value string) string {\n\tkey := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)\n\ttext, err := com.AESGCMEncrypt(key, []byte(value))\n\tif err != nil {\n\t\tpanic(\"error encrypting cookie: \" + err.Error())\n\t}\n\n\treturn hex.EncodeToString(text)\n}\n\n// GetCookieInt returns cookie result in int type.\nfunc (ctx *Context) GetCookieInt(name string) int {\n\tr, _ := strconv.Atoi(ctx.GetCookie(name))\n\treturn r\n}\n\n// GetCookieInt64 returns cookie result in int64 type.\nfunc (ctx *Context) GetCookieInt64(name string) int64 {\n\tr, _ := strconv.ParseInt(ctx.GetCookie(name), 10, 64)\n\treturn r\n}\n\n// GetCookieFloat64 returns cookie result in float64 type.\nfunc (ctx *Context) GetCookieFloat64(name string) float64 {\n\tv, _ := strconv.ParseFloat(ctx.GetCookie(name), 64)\n\treturn v\n}\n\n// RemoteAddr returns the client machie ip address\nfunc (ctx *Context) RemoteAddr() string {\n\treturn ctx.Req.RemoteAddr\n}\n\n// Params returns the param on route\nfunc (ctx *Context) Params(p string) string {\n\ts, _ := url.PathUnescape(chi.URLParam(ctx.Req, strings.TrimPrefix(p, \":\")))\n\treturn s\n}\n\n// ParamsInt64 returns the param on route as int64\nfunc (ctx *Context) ParamsInt64(p string) int64 {\n\tv, _ := strconv.ParseInt(ctx.Params(p), 10, 64)\n\treturn v\n}\n\n// SetParams set params into routes\nfunc (ctx *Context) SetParams(k, v string) {\n\tchiCtx := chi.RouteContext(ctx)\n\tchiCtx.URLParams.Add(strings.TrimPrefix(k, \":\"), url.PathEscape(v))\n}\n\n// Write writes data to web browser\nfunc (ctx *Context) Write(bs []byte) (int, error) {\n\treturn ctx.Resp.Write(bs)\n}\n\n// Written returns true if there are something sent to web browser\nfunc (ctx *Context) Written() bool {\n\treturn ctx.Resp.Status() > 0\n}\n\n// Status writes status code\nfunc (ctx *Context) Status(status int) {\n\tctx.Resp.WriteHeader(status)\n}\n\n// Deadline is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Deadline() (deadline time.Time, ok bool) {\n\treturn ctx.Req.Context().Deadline()\n}\n\n// Done is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Done() <-chan struct{} {\n\treturn ctx.Req.Context().Done()\n}\n\n// Err is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Err() error {\n\treturn ctx.Req.Context().Err()\n}\n\n// Value is part of the interface for context.Context and we pass this to the request context\nfunc (ctx *Context) Value(key interface{}) interface{} {\n\treturn ctx.Req.Context().Value(key)\n}\n\n// Handler represents a custom handler\ntype Handler func(*Context)\n\ntype contextKeyType struct{}\n\nvar contextKey interface{} = contextKeyType{}\n\n// WithContext set up install context in request\nfunc WithContext(req *http.Request, ctx *Context) *http.Request {\n\treturn req.WithContext(context.WithValue(req.Context(), contextKey, ctx))\n}\n\n// GetContext retrieves install context from request\nfunc GetContext(req *http.Request) *Context {\n\treturn req.Context().Value(contextKey).(*Context)\n}\n\n// GetContextUser returns context user\nfunc GetContextUser(req *http.Request) *user_model.User {\n\tif apiContext, ok := req.Context().Value(apiContextKey).(*APIContext); ok {\n\t\treturn apiContext.User\n\t}\n\tif ctx, ok := req.Context().Value(contextKey).(*Context); ok {\n\t\treturn ctx.User\n\t}\n\treturn nil\n}\n\nfunc getCsrfOpts() CsrfOptions {\n\treturn CsrfOptions{\n\t\tSecret:         setting.SecretKey,\n\t\tCookie:         setting.CSRFCookieName,\n\t\tSetCookie:      true,\n\t\tSecure:         setting.SessionConfig.Secure,\n\t\tCookieHTTPOnly: setting.CSRFCookieHTTPOnly,\n\t\tHeader:         \"X-Csrf-Token\",\n\t\tCookieDomain:   setting.SessionConfig.Domain,\n\t\tCookiePath:     setting.SessionConfig.CookiePath,\n\t\tSameSite:       setting.SessionConfig.SameSite,\n\t}\n}\n\n// Auth converts auth.Auth as a middleware\nfunc Auth(authMethod auth.Method) func(*Context) {\n\treturn func(ctx *Context) {\n\t\tctx.User = authMethod.Verify(ctx.Req, ctx.Resp, ctx, ctx.Session)\n\t\tif ctx.User != nil {\n\t\t\tif ctx.Locale.Language() != ctx.User.Language {\n\t\t\t\tctx.Locale = middleware.Locale(ctx.Resp, ctx.Req)\n\t\t\t}\n\t\t\tctx.IsBasicAuth = ctx.Data[\"AuthedMethod\"].(string) == auth.BasicMethodName\n\t\t\tctx.IsSigned = true\n\t\t\tctx.Data[\"IsSigned\"] = ctx.IsSigned\n\t\t\tctx.Data[\"SignedUser\"] = ctx.User\n\t\t\tctx.Data[\"SignedUserID\"] = ctx.User.ID\n\t\t\tctx.Data[\"SignedUserName\"] = ctx.User.Name\n\t\t\tctx.Data[\"IsAdmin\"] = ctx.User.IsAdmin\n\t\t} else {\n\t\t\tctx.Data[\"SignedUserID\"] = int64(0)\n\t\t\tctx.Data[\"SignedUserName\"] = \"\"\n\n\t\t\t// ensure the session uid is deleted\n\t\t\t_ = ctx.Session.Delete(\"uid\")\n\t\t}\n\t}\n}\n\n// Contexter initializes a classic context for a request.\nfunc Contexter() func(next http.Handler) http.Handler {\n\tvar rnd = templates.HTMLRenderer()\n\tvar csrfOpts = getCsrfOpts()\n\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {\n\t\t\tvar locale = middleware.Locale(resp, req)\n\t\t\tvar startTime = time.Now()\n\t\t\tvar link = setting.AppSubURL + strings.TrimSuffix(req.URL.EscapedPath(), \"/\")\n\n\t\t\tvar ctx = Context{\n\t\t\t\tResp:    NewResponse(resp),\n\t\t\t\tCache:   mc.GetCache(),\n\t\t\t\tLocale:  locale,\n\t\t\t\tLink:    link,\n\t\t\t\tRender:  rnd,\n\t\t\t\tSession: session.GetSession(req),\n\t\t\t\tRepo: &Repository{\n\t\t\t\t\tPullRequest: &PullRequest{},\n\t\t\t\t},\n\t\t\t\tOrg: &Organization{},\n\t\t\t\tData: map[string]interface{}{\n\t\t\t\t\t\"CurrentURL\":    setting.AppSubURL + req.URL.RequestURI(),\n\t\t\t\t\t\"PageStartTime\": startTime,\n\t\t\t\t\t\"Link\":          link,\n\t\t\t\t\t\"RunModeIsProd\": setting.IsProd,\n\t\t\t\t},\n\t\t\t}\n\t\t\t// PageData is passed by reference, and it will be rendered to `window.config.pageData` in `head.tmpl` for JavaScript modules\n\t\t\tctx.PageData = map[string]interface{}{}\n\t\t\tctx.Data[\"PageData\"] = ctx.PageData\n\n\t\t\tctx.Req = WithContext(req, &ctx)\n\t\t\tctx.csrf = Csrfer(csrfOpts, &ctx)\n\n\t\t\t// Get flash.\n\t\t\tflashCookie := ctx.GetCookie(\"macaron_flash\")\n\t\t\tvals, _ := url.ParseQuery(flashCookie)\n\t\t\tif len(vals) > 0 {\n\t\t\t\tf := &middleware.Flash{\n\t\t\t\t\tDataStore:  &ctx,\n\t\t\t\t\tValues:     vals,\n\t\t\t\t\tErrorMsg:   vals.Get(\"error\"),\n\t\t\t\t\tSuccessMsg: vals.Get(\"success\"),\n\t\t\t\t\tInfoMsg:    vals.Get(\"info\"),\n\t\t\t\t\tWarningMsg: vals.Get(\"warning\"),\n\t\t\t\t}\n\t\t\t\tctx.Data[\"Flash\"] = f\n\t\t\t}\n\n\t\t\tf := &middleware.Flash{\n\t\t\t\tDataStore:  &ctx,\n\t\t\t\tValues:     url.Values{},\n\t\t\t\tErrorMsg:   \"\",\n\t\t\t\tWarningMsg: \"\",\n\t\t\t\tInfoMsg:    \"\",\n\t\t\t\tSuccessMsg: \"\",\n\t\t\t}\n\t\t\tctx.Resp.Before(func(resp ResponseWriter) {\n\t\t\t\tif flash := f.Encode(); len(flash) > 0 {\n\t\t\t\t\tmiddleware.SetCookie(resp, \"macaron_flash\", flash, 0,\n\t\t\t\t\t\tsetting.SessionConfig.CookiePath,\n\t\t\t\t\t\tmiddleware.Domain(setting.SessionConfig.Domain),\n\t\t\t\t\t\tmiddleware.HTTPOnly(true),\n\t\t\t\t\t\tmiddleware.Secure(setting.SessionConfig.Secure),\n\t\t\t\t\t\tmiddleware.SameSite(setting.SessionConfig.SameSite),\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tmiddleware.SetCookie(ctx.Resp, \"macaron_flash\", \"\", -1,\n\t\t\t\t\tsetting.SessionConfig.CookiePath,\n\t\t\t\t\tmiddleware.Domain(setting.SessionConfig.Domain),\n\t\t\t\t\tmiddleware.HTTPOnly(true),\n\t\t\t\t\tmiddleware.Secure(setting.SessionConfig.Secure),\n\t\t\t\t\tmiddleware.SameSite(setting.SessionConfig.SameSite),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tctx.Flash = f\n\n\t\t\t// If request sends files, parse them here otherwise the Query() can't be parsed and the CsrfToken will be invalid.\n\t\t\tif ctx.Req.Method == \"POST\" && strings.Contains(ctx.Req.Header.Get(\"Content-Type\"), \"multipart/form-data\") {\n\t\t\t\tif err := ctx.Req.ParseMultipartForm(setting.Attachment.MaxSize << 20); err != nil && !strings.Contains(err.Error(), \"EOF\") { // 32MB max size\n\t\t\t\t\tctx.ServerError(\"ParseMultipartForm\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.Resp.Header().Set(`X-Frame-Options`, setting.CORSConfig.XFrameOptions)\n\n\t\t\tctx.Data[\"CsrfToken\"] = html.EscapeString(ctx.csrf.GetToken())\n\t\t\tctx.Data[\"CsrfTokenHtml\"] = template.HTML(`<input type=\"hidden\" name=\"_csrf\" value=\"` + ctx.Data[\"CsrfToken\"].(string) + `\">`)\n\n\t\t\t// FIXME: do we really always need these setting? There should be someway to have to avoid having to always set these\n\t\t\tctx.Data[\"IsLandingPageHome\"] = setting.LandingPageURL == setting.LandingPageHome\n\t\t\tctx.Data[\"IsLandingPageExplore\"] = setting.LandingPageURL == setting.LandingPageExplore\n\t\t\tctx.Data[\"IsLandingPageOrganizations\"] = setting.LandingPageURL == setting.LandingPageOrganizations\n\n\t\t\tctx.Data[\"ShowRegistrationButton\"] = setting.Service.ShowRegistrationButton\n\t\t\tctx.Data[\"ShowMilestonesDashboardPage\"] = setting.Service.ShowMilestonesDashboardPage\n\t\t\tctx.Data[\"ShowFooterBranding\"] = setting.ShowFooterBranding\n\t\t\tctx.Data[\"ShowFooterVersion\"] = setting.ShowFooterVersion\n\n\t\t\tctx.Data[\"EnableSwagger\"] = setting.API.EnableSwagger\n\t\t\tctx.Data[\"EnableOpenIDSignIn\"] = setting.Service.EnableOpenIDSignIn\n\t\t\tctx.Data[\"DisableMigrations\"] = setting.Repository.DisableMigrations\n\t\t\tctx.Data[\"DisableStars\"] = setting.Repository.DisableStars\n\n\t\t\tctx.Data[\"ManifestData\"] = setting.ManifestData\n\n\t\t\tctx.Data[\"UnitWikiGlobalDisabled\"] = unit.TypeWiki.UnitGlobalDisabled()\n\t\t\tctx.Data[\"UnitIssuesGlobalDisabled\"] = unit.TypeIssues.UnitGlobalDisabled()\n\t\t\tctx.Data[\"UnitPullsGlobalDisabled\"] = unit.TypePullRequests.UnitGlobalDisabled()\n\t\t\tctx.Data[\"UnitProjectsGlobalDisabled\"] = unit.TypeProjects.UnitGlobalDisabled()\n\n\t\t\tctx.Data[\"i18n\"] = locale\n\t\t\tctx.Data[\"Tr\"] = i18n.Tr\n\t\t\tctx.Data[\"Lang\"] = locale.Language()\n\t\t\tctx.Data[\"AllLangs\"] = translation.AllLangs()\n\t\t\tfor _, lang := range translation.AllLangs() {\n\t\t\t\tif lang.Lang == locale.Language() {\n\t\t\t\t\tctx.Data[\"LangName\"] = lang.Name\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext.ServeHTTP(ctx.Resp, ctx.Req)\n\n\t\t\t// Handle adding signedUserName to the context for the AccessLogger\n\t\t\tusernameInterface := ctx.Data[\"SignedUserName\"]\n\t\t\tidentityPtrInterface := ctx.Req.Context().Value(signedUserNameStringPointerKey)\n\t\t\tif usernameInterface != nil && identityPtrInterface != nil {\n\t\t\t\tusername := usernameInterface.(string)\n\t\t\t\tidentityPtr := identityPtrInterface.(*string)\n\t\t\t\tif identityPtr != nil && username != \"\" {\n\t\t\t\t\t*identityPtr = username\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"], "filenames": ["modules/context/context.go"], "buggy_code_start_loc": [180], "buggy_code_end_loc": [180], "fixing_code_start_loc": [181], "fixing_code_end_loc": [187], "type": "CWE-601", "message": "Open Redirect on login in GitHub repository go-gitea/gitea prior to 1.16.5.", "other": {"cve": {"id": "CVE-2022-1058", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-24T15:15:08.023", "lastModified": "2022-03-29T15:40:49.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open Redirect on login in GitHub repository go-gitea/gitea prior to 1.16.5."}, {"lang": "es", "value": "Un Redireccionamiento Abierto en el inicio de sesi\u00f3n en el repositorio de GitHub go-gitea/gitea versiones anteriores a 1.16.5"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitea:gitea:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.5", "matchCriteriaId": "956B114D-88B9-48A3-8AFF-EB878EB15BF3"}]}]}], "references": [{"url": "https://github.com/go-gitea/gitea/commit/e3d8e92bdc67562783de9a76b5b7842b68daeb48", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4fb42144-ac70-4f76-a5e1-ef6b5e55dc0d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/go-gitea/gitea/commit/e3d8e92bdc67562783de9a76b5b7842b68daeb48"}}