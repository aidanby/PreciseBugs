{"buggy_code": ["/**\n * Copyright (c) 2014 Redpine Signals Inc.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <linux/etherdevice.h>\n#include <linux/timer.h>\n#include \"rsi_mgmt.h\"\n#include \"rsi_common.h\"\n#include \"rsi_ps.h\"\n#include \"rsi_hal.h\"\n\nstatic struct bootup_params boot_params_20 = {\n\t.magic_number = cpu_to_le16(0x5aa5),\n\t.crystal_good_time = 0x0,\n\t.valid = cpu_to_le32(VALID_20),\n\t.reserved_for_valids = 0x0,\n\t.bootup_mode_info = 0x0,\n\t.digital_loop_back_params = 0x0,\n\t.rtls_timestamp_en = 0x0,\n\t.host_spi_intr_cfg = 0x0,\n\t.device_clk_info = {{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|\n\t\t\t\t\t      (TA_PLL_M_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = cpu_to_le16(0xb),\n\t\t\t.bbp_lmac_clk_reg_val = cpu_to_le16(0x111),\n\t\t\t.umac_clock_reg_config = cpu_to_le16(0x48),\n\t\t\t.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t} },\n\t.buckboost_wakeup_cnt = 0x0,\n\t.pmu_wakeup_wait = 0x0,\n\t.shutdown_wait_time = 0x0,\n\t.pmu_slp_clkout_sel = 0x0,\n\t.wdt_prog_value = 0x0,\n\t.wdt_soc_rst_delay = 0x0,\n\t.dcdc_operation_mode = 0x0,\n\t.soc_reset_wait_cnt = 0x0,\n\t.waiting_time_at_fresh_sleep = 0x0,\n\t.max_threshold_to_avoid_sleep = 0x0,\n\t.beacon_resedue_alg_en = 0,\n};\n\nstatic struct bootup_params boot_params_40 = {\n\t.magic_number = cpu_to_le16(0x5aa5),\n\t.crystal_good_time = 0x0,\n\t.valid = cpu_to_le32(VALID_40),\n\t.reserved_for_valids = 0x0,\n\t.bootup_mode_info = 0x0,\n\t.digital_loop_back_params = 0x0,\n\t.rtls_timestamp_en = 0x0,\n\t.host_spi_intr_cfg = 0x0,\n\t.device_clk_info = {{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = cpu_to_le16(0x09),\n\t\t\t.bbp_lmac_clk_reg_val = cpu_to_le16(0x1121),\n\t\t\t.umac_clock_reg_config = cpu_to_le16(0x48),\n\t\t\t.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t} },\n\t.buckboost_wakeup_cnt = 0x0,\n\t.pmu_wakeup_wait = 0x0,\n\t.shutdown_wait_time = 0x0,\n\t.pmu_slp_clkout_sel = 0x0,\n\t.wdt_prog_value = 0x0,\n\t.wdt_soc_rst_delay = 0x0,\n\t.dcdc_operation_mode = 0x0,\n\t.soc_reset_wait_cnt = 0x0,\n\t.waiting_time_at_fresh_sleep = 0x0,\n\t.max_threshold_to_avoid_sleep = 0x0,\n\t.beacon_resedue_alg_en = 0,\n};\n\nstatic struct bootup_params_9116 boot_params_9116_20 = {\n\t.magic_number = cpu_to_le16(LOADED_TOKEN),\n\t.valid = cpu_to_le32(VALID_20),\n\t.device_clk_info_9116 = {{\n\t\t.pll_config_9116_g = {\n\t\t\t.pll_ctrl_set_reg = cpu_to_le16(0xd518),\n\t\t\t.pll_ctrl_clr_reg = cpu_to_le16(0x2ae7),\n\t\t\t.pll_modem_conig_reg = cpu_to_le16(0x2000),\n\t\t\t.soc_clk_config_reg = cpu_to_le16(0x0c18),\n\t\t\t.adc_dac_strm1_config_reg = cpu_to_le16(0x1100),\n\t\t\t.adc_dac_strm2_config_reg = cpu_to_le16(0x6600),\n\t\t},\n\t\t.switch_clk_9116_g = {\n\t\t\t.switch_clk_info =\n\t\t\t\tcpu_to_le32((RSI_SWITCH_TASS_CLK |\n\t\t\t\t\t    RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG |\n\t\t\t\t\t    RSI_SWITCH_BBP_LMAC_CLK_REG)),\n\t\t\t.tass_clock_reg = cpu_to_le32(0x083C0503),\n\t\t\t.wlan_bbp_lmac_clk_reg_val = cpu_to_le32(0x01042001),\n\t\t\t.zbbt_bbp_lmac_clk_reg_val = cpu_to_le32(0x02010001),\n\t\t\t.bbp_lmac_clk_en_val = cpu_to_le32(0x0000003b),\n\t\t}\n\t},\n\t},\n};\n\nstatic struct bootup_params_9116 boot_params_9116_40 = {\n\t.magic_number = cpu_to_le16(LOADED_TOKEN),\n\t.valid = cpu_to_le32(VALID_40),\n\t.device_clk_info_9116 = {{\n\t\t.pll_config_9116_g = {\n\t\t\t.pll_ctrl_set_reg = cpu_to_le16(0xd518),\n\t\t\t.pll_ctrl_clr_reg = cpu_to_le16(0x2ae7),\n\t\t\t.pll_modem_conig_reg = cpu_to_le16(0x3000),\n\t\t\t.soc_clk_config_reg = cpu_to_le16(0x0c18),\n\t\t\t.adc_dac_strm1_config_reg = cpu_to_le16(0x0000),\n\t\t\t.adc_dac_strm2_config_reg = cpu_to_le16(0x6600),\n\t\t},\n\t\t.switch_clk_9116_g = {\n\t\t\t.switch_clk_info =\n\t\t\t\tcpu_to_le32((RSI_SWITCH_TASS_CLK |\n\t\t\t\t\t    RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG |\n\t\t\t\t\t    RSI_SWITCH_BBP_LMAC_CLK_REG |\n\t\t\t\t\t    RSI_MODEM_CLK_160MHZ)),\n\t\t\t.tass_clock_reg = cpu_to_le32(0x083C0503),\n\t\t\t.wlan_bbp_lmac_clk_reg_val = cpu_to_le32(0x01042002),\n\t\t\t.zbbt_bbp_lmac_clk_reg_val = cpu_to_le32(0x04010002),\n\t\t\t.bbp_lmac_clk_en_val = cpu_to_le32(0x0000003b),\n\t\t}\n\t},\n\t},\n};\n\nstatic u16 mcs[] = {13, 26, 39, 52, 78, 104, 117, 130};\n\n/**\n * rsi_set_default_parameters() - This function sets default parameters.\n * @common: Pointer to the driver private structure.\n *\n * Return: none\n */\nstatic void rsi_set_default_parameters(struct rsi_common *common)\n{\n\tcommon->band = NL80211_BAND_2GHZ;\n\tcommon->channel_width = BW_20MHZ;\n\tcommon->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;\n\tcommon->channel = 1;\n\tcommon->min_rate = 0xffff;\n\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\tcommon->iface_down = true;\n\tcommon->endpoint = EP_2GHZ_20MHZ;\n\tcommon->driver_mode = 1; /* End to end mode */\n\tcommon->lp_ps_handshake_mode = 0; /* Default no handShake mode*/\n\tcommon->ulp_ps_handshake_mode = 2; /* Default PKT handShake mode*/\n\tcommon->rf_power_val = 0; /* Default 1.9V */\n\tcommon->wlan_rf_power_mode = 0;\n\tcommon->obm_ant_sel_val = 2;\n\tcommon->beacon_interval = RSI_BEACON_INTERVAL;\n\tcommon->dtim_cnt = RSI_DTIM_COUNT;\n\tcommon->w9116_features.pll_mode = 0x0;\n\tcommon->w9116_features.rf_type = 1;\n\tcommon->w9116_features.wireless_mode = 0;\n\tcommon->w9116_features.enable_ppe = 0;\n\tcommon->w9116_features.afe_type = 1;\n\tcommon->w9116_features.dpd = 0;\n\tcommon->w9116_features.sifs_tx_enable = 0;\n\tcommon->w9116_features.ps_options = 0;\n}\n\nvoid init_bgscan_params(struct rsi_common *common)\n{\n\tmemset((u8 *)&common->bgscan, 0, sizeof(struct rsi_bgscan_params));\n\tcommon->bgscan.bgscan_threshold = RSI_DEF_BGSCAN_THRLD;\n\tcommon->bgscan.roam_threshold = RSI_DEF_ROAM_THRLD;\n\tcommon->bgscan.bgscan_periodicity = RSI_BGSCAN_PERIODICITY;\n\tcommon->bgscan.num_bgscan_channels = 0;\n\tcommon->bgscan.two_probe = 1;\n\tcommon->bgscan.active_scan_duration = RSI_ACTIVE_SCAN_TIME;\n\tcommon->bgscan.passive_scan_duration = RSI_PASSIVE_SCAN_TIME;\n}\n\n/**\n * rsi_set_contention_vals() - This function sets the contention values for the\n *\t\t\t       backoff procedure.\n * @common: Pointer to the driver private structure.\n *\n * Return: None.\n */\nstatic void rsi_set_contention_vals(struct rsi_common *common)\n{\n\tu8 ii = 0;\n\n\tfor (; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tcommon->tx_qinfo[ii].wme_params =\n\t\t\t(((common->edca_params[ii].cw_min / 2) +\n\t\t\t  (common->edca_params[ii].aifs)) *\n\t\t\t  WMM_SHORT_SLOT_TIME + SIFS_DURATION);\n\t\tcommon->tx_qinfo[ii].weight = common->tx_qinfo[ii].wme_params;\n\t\tcommon->tx_qinfo[ii].pkt_contended = 0;\n\t}\n}\n\n/**\n * rsi_send_internal_mgmt_frame() - This function sends management frames to\n *\t\t\t\t    firmware.Also schedules packet to queue\n *\t\t\t\t    for transmission.\n * @common: Pointer to the driver private structure.\n * @skb: Pointer to the socket buffer structure.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_send_internal_mgmt_frame(struct rsi_common *common,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct skb_info *tx_params;\n\tstruct rsi_cmd_desc *desc;\n\n\tif (skb == NULL) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to allocate skb\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdesc = (struct rsi_cmd_desc *)skb->data;\n\tdesc->desc_dword0.len_qno |= cpu_to_le16(DESC_IMMEDIATE_WAKEUP);\n\tskb->priority = MGMT_SOFT_Q;\n\ttx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;\n\ttx_params->flags |= INTERNAL_MGMT_PKT;\n\tskb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\treturn 0;\n}\n\n/**\n * rsi_load_radio_caps() - This function is used to send radio capabilities\n *\t\t\t   values to firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nstatic int rsi_load_radio_caps(struct rsi_common *common)\n{\n\tstruct rsi_radio_caps *radio_caps;\n\tstruct rsi_hw *adapter = common->priv;\n\tu16 inx = 0;\n\tu8 ii;\n\tu8 radio_id = 0;\n\tu16 gc[20] = {0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0};\n\tstruct sk_buff *skb;\n\tu16 frame_len = sizeof(struct rsi_radio_caps);\n\n\trsi_dbg(INFO_ZONE, \"%s: Sending rate symbol req frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tradio_caps = (struct rsi_radio_caps *)skb->data;\n\n\tradio_caps->desc_dword0.frame_type = RADIO_CAPABILITIES;\n\tradio_caps->channel_num = common->channel;\n\tradio_caps->rf_model = RSI_RF_TYPE;\n\n\tradio_caps->radio_cfg_info = RSI_LMAC_CLOCK_80MHZ;\n\tif (common->channel_width == BW_40MHZ) {\n\t\tradio_caps->radio_cfg_info |= RSI_ENABLE_40MHZ;\n\n\t\tif (common->fsm_state == FSM_MAC_INIT_DONE) {\n\t\t\tstruct ieee80211_hw *hw = adapter->hw;\n\t\t\tstruct ieee80211_conf *conf = &hw->conf;\n\n\t\t\tif (conf_is_ht40_plus(conf)) {\n\t\t\t\tradio_caps->ppe_ack_rate =\n\t\t\t\t\tcpu_to_le16(LOWER_20_ENABLE |\n\t\t\t\t\t\t    (LOWER_20_ENABLE >> 12));\n\t\t\t} else if (conf_is_ht40_minus(conf)) {\n\t\t\t\tradio_caps->ppe_ack_rate =\n\t\t\t\t\tcpu_to_le16(UPPER_20_ENABLE |\n\t\t\t\t\t\t    (UPPER_20_ENABLE >> 12));\n\t\t\t} else {\n\t\t\t\tradio_caps->ppe_ack_rate =\n\t\t\t\t\tcpu_to_le16((BW_40MHZ << 12) |\n\t\t\t\t\t\t    FULL40M_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n\tradio_caps->radio_info |= radio_id;\n\n\tif (adapter->device_model == RSI_DEV_9116 &&\n\t    common->channel_width == BW_20MHZ)\n\t\tradio_caps->radio_cfg_info &= ~0x3;\n\n\tradio_caps->sifs_tx_11n = cpu_to_le16(SIFS_TX_11N_VALUE);\n\tradio_caps->sifs_tx_11b = cpu_to_le16(SIFS_TX_11B_VALUE);\n\tradio_caps->slot_rx_11n = cpu_to_le16(SHORT_SLOT_VALUE);\n\tradio_caps->ofdm_ack_tout = cpu_to_le16(OFDM_ACK_TOUT_VALUE);\n\tradio_caps->cck_ack_tout = cpu_to_le16(CCK_ACK_TOUT_VALUE);\n\tradio_caps->preamble_type = cpu_to_le16(LONG_PREAMBLE);\n\n\tfor (ii = 0; ii < MAX_HW_QUEUES; ii++) {\n\t\tradio_caps->qos_params[ii].cont_win_min_q = cpu_to_le16(3);\n\t\tradio_caps->qos_params[ii].cont_win_max_q = cpu_to_le16(0x3f);\n\t\tradio_caps->qos_params[ii].aifsn_val_q = cpu_to_le16(2);\n\t\tradio_caps->qos_params[ii].txop_q = 0;\n\t}\n\n\tfor (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tif (common->edca_params[ii].cw_max > 0) {\n\t\t\tradio_caps->qos_params[ii].cont_win_min_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].cw_min);\n\t\t\tradio_caps->qos_params[ii].cont_win_max_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].cw_max);\n\t\t\tradio_caps->qos_params[ii].aifsn_val_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].aifs << 8);\n\t\t\tradio_caps->qos_params[ii].txop_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].txop);\n\t\t}\n\t}\n\n\tradio_caps->qos_params[BROADCAST_HW_Q].txop_q = cpu_to_le16(0xffff);\n\tradio_caps->qos_params[MGMT_HW_Q].txop_q = 0;\n\tradio_caps->qos_params[BEACON_HW_Q].txop_q = cpu_to_le16(0xffff);\n\n\tmemcpy(&common->rate_pwr[0], &gc[0], 40);\n\tfor (ii = 0; ii < 20; ii++)\n\t\tradio_caps->gcpd_per_rate[inx++] =\n\t\t\tcpu_to_le16(common->rate_pwr[ii]  & 0x00FF);\n\n\trsi_set_len_qno(&radio_caps->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_mgmt_pkt_to_core() - This function is the entry point for Mgmt module.\n * @common: Pointer to the driver private structure.\n * @msg: Pointer to received packet.\n * @msg_len: Length of the received packet.\n * @type: Type of received packet.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_mgmt_pkt_to_core(struct rsi_common *common,\n\t\t\t\tu8 *msg,\n\t\t\t\ts32 msg_len)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_tx_info *info;\n\tstruct skb_info *rx_params;\n\tu8 pad_bytes = msg[4];\n\tstruct sk_buff *skb;\n\n\tif (!adapter->sc_nvifs)\n\t\treturn -ENOLINK;\n\n\tmsg_len -= pad_bytes;\n\tif (msg_len <= 0) {\n\t\trsi_dbg(MGMT_RX_ZONE,\n\t\t\t\"%s: Invalid rx msg of len = %d\\n\",\n\t\t\t__func__, msg_len);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = dev_alloc_skb(msg_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb,\n\t\t     (u8 *)(msg + FRAME_DESC_SZ + pad_bytes),\n\t\t     msg_len);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\trx_params = (struct skb_info *)info->driver_data;\n\trx_params->rssi = rsi_get_rssi(msg);\n\trx_params->channel = rsi_get_channel(msg);\n\trsi_indicate_pkt_to_os(common, skb);\n\n\treturn 0;\n}\n\n/**\n * rsi_hal_send_sta_notify_frame() - This function sends the station notify\n *\t\t\t\t     frame to firmware.\n * @common: Pointer to the driver private structure.\n * @opmode: Operating mode of device.\n * @notify_event: Notification about station connection.\n * @bssid: bssid.\n * @qos_enable: Qos is enabled.\n * @aid: Aid (unique for all STA).\n *\n * Return: status: 0 on success, corresponding negative error code on failure.\n */\nint rsi_hal_send_sta_notify_frame(struct rsi_common *common, enum opmode opmode,\n\t\t\t\t  u8 notify_event, const unsigned char *bssid,\n\t\t\t\t  u8 qos_enable, u16 aid, u16 sta_id,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_peer_notify *peer_notify;\n\tu16 vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;\n\tint status;\n\tu16 frame_len = sizeof(struct rsi_peer_notify);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending sta notify frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tpeer_notify = (struct rsi_peer_notify *)skb->data;\n\n\tif (opmode == RSI_OPMODE_STA)\n\t\tpeer_notify->command = cpu_to_le16(PEER_TYPE_AP << 1);\n\telse if (opmode == RSI_OPMODE_AP)\n\t\tpeer_notify->command = cpu_to_le16(PEER_TYPE_STA << 1);\n\n\tswitch (notify_event) {\n\tcase STA_CONNECTED:\n\t\tpeer_notify->command |= cpu_to_le16(RSI_ADD_PEER);\n\t\tbreak;\n\tcase STA_DISCONNECTED:\n\t\tpeer_notify->command |= cpu_to_le16(RSI_DELETE_PEER);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpeer_notify->command |= cpu_to_le16((aid & 0xfff) << 4);\n\tether_addr_copy(peer_notify->mac_addr, bssid);\n\tpeer_notify->mpdu_density = cpu_to_le16(RSI_MPDU_DENSITY);\n\tpeer_notify->sta_flags = cpu_to_le32((qos_enable) ? 1 : 0);\n\n\trsi_set_len_qno(&peer_notify->desc.desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ),\n\t\t\tRSI_WIFI_MGMT_Q);\n\tpeer_notify->desc.desc_dword0.frame_type = PEER_NOTIFY;\n\tpeer_notify->desc.desc_dword3.qid_tid = sta_id;\n\tpeer_notify->desc.desc_dword3.sta_id = vap_id;\n\n\tskb_put(skb, frame_len);\n\n\tstatus = rsi_send_internal_mgmt_frame(common, skb);\n\n\tif ((vif->type == NL80211_IFTYPE_STATION) &&\n\t    (!status && qos_enable)) {\n\t\trsi_set_contention_vals(common);\n\t\tstatus = rsi_load_radio_caps(common);\n\t}\n\treturn status;\n}\n\n/**\n * rsi_send_aggregation_params_frame() - This function sends the ampdu\n *\t\t\t\t\t indication frame to firmware.\n * @common: Pointer to the driver private structure.\n * @tid: traffic identifier.\n * @ssn: ssn.\n * @buf_size: buffer size.\n * @event: notification about station connection.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nint rsi_send_aggregation_params_frame(struct rsi_common *common,\n\t\t\t\t      u16 tid,\n\t\t\t\t      u16 ssn,\n\t\t\t\t      u8 buf_size,\n\t\t\t\t      u8 event,\n\t\t\t\t      u8 sta_id)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_aggr_params *aggr_params;\n\tu16 frame_len = sizeof(struct rsi_aggr_params);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\taggr_params = (struct rsi_aggr_params *)skb->data;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending AMPDU indication frame\\n\", __func__);\n\n\trsi_set_len_qno(&aggr_params->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\taggr_params->desc_dword0.frame_type = AMPDU_IND;\n\n\taggr_params->aggr_params = tid & RSI_AGGR_PARAMS_TID_MASK;\n\taggr_params->peer_id = sta_id;\n\tif (event == STA_TX_ADDBA_DONE) {\n\t\taggr_params->seq_start = cpu_to_le16(ssn);\n\t\taggr_params->baw_size = cpu_to_le16(buf_size);\n\t\taggr_params->aggr_params |= RSI_AGGR_PARAMS_START;\n\t} else if (event == STA_RX_ADDBA_DONE) {\n\t\taggr_params->seq_start = cpu_to_le16(ssn);\n\t\taggr_params->aggr_params |= (RSI_AGGR_PARAMS_START |\n\t\t\t\t\t     RSI_AGGR_PARAMS_RX_AGGR);\n\t} else if (event == STA_RX_DELBA) {\n\t\taggr_params->aggr_params |= RSI_AGGR_PARAMS_RX_AGGR;\n\t}\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_program_bb_rf() - This function starts base band and RF programming.\n *\t\t\t This is called after initial configurations are done.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nstatic int rsi_program_bb_rf(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_bb_rf_prog *bb_rf_prog;\n\tu16 frame_len = sizeof(struct rsi_bb_rf_prog);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending program BB/RF frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tbb_rf_prog = (struct rsi_bb_rf_prog *)skb->data;\n\n\trsi_set_len_qno(&bb_rf_prog->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\tbb_rf_prog->desc_dword0.frame_type = BBP_PROG_IN_TA;\n\tbb_rf_prog->endpoint = common->endpoint;\n\tbb_rf_prog->rf_power_mode = common->wlan_rf_power_mode;\n\n\tif (common->rf_reset) {\n\t\tbb_rf_prog->flags =  cpu_to_le16(RF_RESET_ENABLE);\n\t\trsi_dbg(MGMT_TX_ZONE, \"%s: ===> RF RESET REQUEST SENT <===\\n\",\n\t\t\t__func__);\n\t\tcommon->rf_reset = 0;\n\t}\n\tcommon->bb_rf_prog_count = 1;\n\tbb_rf_prog->flags |= cpu_to_le16(PUT_BBP_RESET | BBP_REG_WRITE |\n\t\t\t\t\t (RSI_RF_TYPE << 4));\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_set_vap_capabilities() - This function send vap capability to firmware.\n * @common: Pointer to the driver private structure.\n * @opmode: Operating mode of device.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nint rsi_set_vap_capabilities(struct rsi_common *common,\n\t\t\t     enum opmode mode,\n\t\t\t     u8 *mac_addr,\n\t\t\t     u8 vap_id,\n\t\t\t     u8 vap_status)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_vap_caps *vap_caps;\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tu16 frame_len = sizeof(struct rsi_vap_caps);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending VAP capabilities frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tvap_caps = (struct rsi_vap_caps *)skb->data;\n\n\trsi_set_len_qno(&vap_caps->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tvap_caps->desc_dword0.frame_type = VAP_CAPABILITIES;\n\tvap_caps->status = vap_status;\n\tvap_caps->vif_type = mode;\n\tvap_caps->channel_bw = common->channel_width;\n\tvap_caps->vap_id = vap_id;\n\tvap_caps->radioid_macid = ((common->mac_id & 0xf) << 4) |\n\t\t\t\t   (common->radio_id & 0xf);\n\n\tmemcpy(vap_caps->mac_addr, mac_addr, IEEE80211_ADDR_LEN);\n\tvap_caps->keep_alive_period = cpu_to_le16(90);\n\tvap_caps->frag_threshold = cpu_to_le16(IEEE80211_MAX_FRAG_THRESHOLD);\n\n\tvap_caps->rts_threshold = cpu_to_le16(common->rts_threshold);\n\n\tif (common->band == NL80211_BAND_5GHZ) {\n\t\tvap_caps->default_ctrl_rate = cpu_to_le16(RSI_RATE_6);\n\t\tvap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);\n\t} else {\n\t\tvap_caps->default_ctrl_rate = cpu_to_le16(RSI_RATE_1);\n\t\tvap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_1);\n\t}\n\tif (conf_is_ht40(conf)) {\n\t\tif (conf_is_ht40_minus(conf))\n\t\t\tvap_caps->ctrl_rate_flags =\n\t\t\t\tcpu_to_le16(UPPER_20_ENABLE);\n\t\telse if (conf_is_ht40_plus(conf))\n\t\t\tvap_caps->ctrl_rate_flags =\n\t\t\t\tcpu_to_le16(LOWER_20_ENABLE);\n\t\telse\n\t\t\tvap_caps->ctrl_rate_flags =\n\t\t\t\tcpu_to_le16(FULL40M_ENABLE);\n\t}\n\n\tvap_caps->default_data_rate = 0;\n\tvap_caps->beacon_interval = cpu_to_le16(common->beacon_interval);\n\tvap_caps->dtim_period = cpu_to_le16(common->dtim_cnt);\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_hal_load_key() - This function is used to load keys within the firmware.\n * @common: Pointer to the driver private structure.\n * @data: Pointer to the key data.\n * @key_len: Key length to be loaded.\n * @key_type: Type of key: GROUP/PAIRWISE.\n * @key_id: Key index.\n * @cipher: Type of cipher used.\n *\n * Return: 0 on success, -1 on failure.\n */\nint rsi_hal_load_key(struct rsi_common *common,\n\t\t     u8 *data,\n\t\t     u16 key_len,\n\t\t     u8 key_type,\n\t\t     u8 key_id,\n\t\t     u32 cipher,\n\t\t     s16 sta_id,\n\t\t     struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_set_key *set_key;\n\tu16 key_descriptor = 0;\n\tu16 frame_len = sizeof(struct rsi_set_key);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending load key frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tset_key = (struct rsi_set_key *)skb->data;\n\n\tif (key_type == RSI_GROUP_KEY) {\n\t\tkey_descriptor = RSI_KEY_TYPE_BROADCAST;\n\t\tif (vif->type == NL80211_IFTYPE_AP)\n\t\t\tkey_descriptor |= RSI_KEY_MODE_AP;\n\t}\n\tif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\n\t    (cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\tkey_id = 0;\n\t\tkey_descriptor |= RSI_WEP_KEY;\n\t\tif (key_len >= 13)\n\t\t\tkey_descriptor |= RSI_WEP_KEY_104;\n\t} else if (cipher != KEY_TYPE_CLEAR) {\n\t\tkey_descriptor |= RSI_CIPHER_WPA;\n\t\tif (cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\tkey_descriptor |= RSI_CIPHER_TKIP;\n\t}\n\tkey_descriptor |= RSI_PROTECT_DATA_FRAMES;\n\tkey_descriptor |= (key_id << RSI_KEY_ID_OFFSET);\n\n\trsi_set_len_qno(&set_key->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tset_key->desc_dword0.frame_type = SET_KEY_REQ;\n\tset_key->key_desc = cpu_to_le16(key_descriptor);\n\tset_key->sta_id = sta_id;\n\n\tif (data) {\n\t\tif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\n\t\t    (cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\t\tmemcpy(&set_key->key[key_id][1], data, key_len * 2);\n\t\t} else {\n\t\t\tmemcpy(&set_key->key[0][0], data, key_len);\n\t\t}\n\t\tmemcpy(set_key->tx_mic_key, &data[16], 8);\n\t\tmemcpy(set_key->rx_mic_key, &data[24], 8);\n\t} else {\n\t\tmemset(&set_key[FRAME_DESC_SZ], 0, frame_len - FRAME_DESC_SZ);\n\t}\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/*\n * This function sends the common device configuration parameters to device.\n * This frame includes the useful information to make device works on\n * specific operating mode.\n */\nstatic int rsi_send_common_dev_params(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tu16 frame_len;\n\tstruct rsi_config_vals *dev_cfgs;\n\n\tframe_len = sizeof(struct rsi_config_vals);\n\n\trsi_dbg(MGMT_TX_ZONE, \"Sending common device config params\\n\");\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to allocate skb\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\n\tdev_cfgs = (struct rsi_config_vals *)skb->data;\n\tmemset(dev_cfgs, 0, (sizeof(struct rsi_config_vals)));\n\n\trsi_set_len_qno(&dev_cfgs->len_qno, (frame_len - FRAME_DESC_SZ),\n\t\t\tRSI_COEX_Q);\n\tdev_cfgs->pkt_type = COMMON_DEV_CONFIG;\n\n\tdev_cfgs->lp_ps_handshake = common->lp_ps_handshake_mode;\n\tdev_cfgs->ulp_ps_handshake = common->ulp_ps_handshake_mode;\n\n\tdev_cfgs->unused_ulp_gpio = RSI_UNUSED_ULP_GPIO_BITMAP;\n\tdev_cfgs->unused_soc_gpio_bitmap =\n\t\t\t\tcpu_to_le32(RSI_UNUSED_SOC_GPIO_BITMAP);\n\n\tdev_cfgs->opermode = common->oper_mode;\n\tdev_cfgs->wlan_rf_pwr_mode = common->wlan_rf_power_mode;\n\tdev_cfgs->driver_mode = common->driver_mode;\n\tdev_cfgs->region_code = NL80211_DFS_FCC;\n\tdev_cfgs->antenna_sel_val = common->obm_ant_sel_val;\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/*\n * rsi_load_bootup_params() - This function send bootup params to the firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nstatic int rsi_load_bootup_params(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_boot_params *boot_params;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending boot params frame\\n\", __func__);\n\tskb = dev_alloc_skb(sizeof(struct rsi_boot_params));\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, sizeof(struct rsi_boot_params));\n\tboot_params = (struct rsi_boot_params *)skb->data;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s:\\n\", __func__);\n\n\tif (common->channel_width == BW_40MHZ) {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_40,\n\t\t       sizeof(struct bootup_params));\n\t\trsi_dbg(MGMT_TX_ZONE, \"%s: Packet 40MHZ <=== %d\\n\", __func__,\n\t\t\tUMAC_CLK_40BW);\n\t\tboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40BW);\n\t} else {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_20,\n\t\t       sizeof(struct bootup_params));\n\t\tif (boot_params_20.valid != cpu_to_le32(VALID_20)) {\n\t\t\tboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_20BW);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_20BW);\n\t\t} else {\n\t\t\tboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40MHZ);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_40MHZ);\n\t\t}\n\t}\n\n\t/**\n\t * Bit{0:11} indicates length of the Packet\n\t * Bit{12:15} indicates host queue number\n\t */\n\tboot_params->desc_word[0] = cpu_to_le16(sizeof(struct bootup_params) |\n\t\t\t\t    (RSI_WIFI_MGMT_Q << 12));\n\tboot_params->desc_word[1] = cpu_to_le16(BOOTUP_PARAMS_REQUEST);\n\n\tskb_put(skb, sizeof(struct rsi_boot_params));\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nstatic int rsi_load_9116_bootup_params(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_boot_params_9116 *boot_params;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending boot params frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(sizeof(struct rsi_boot_params_9116));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, sizeof(struct rsi_boot_params));\n\tboot_params = (struct rsi_boot_params_9116 *)skb->data;\n\n\tif (common->channel_width == BW_40MHZ) {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_9116_40,\n\t\t       sizeof(struct bootup_params_9116));\n\t\trsi_dbg(MGMT_TX_ZONE, \"%s: Packet 40MHZ <=== %d\\n\", __func__,\n\t\t\tUMAC_CLK_40BW);\n\t\tboot_params->umac_clk = cpu_to_le16(UMAC_CLK_40BW);\n\t} else {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_9116_20,\n\t\t       sizeof(struct bootup_params_9116));\n\t\tif (boot_params_20.valid != cpu_to_le32(VALID_20)) {\n\t\t\tboot_params->umac_clk = cpu_to_le16(UMAC_CLK_20BW);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_20BW);\n\t\t} else {\n\t\t\tboot_params->umac_clk = cpu_to_le16(UMAC_CLK_40MHZ);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_40MHZ);\n\t\t}\n\t}\n\trsi_set_len_qno(&boot_params->desc_dword0.len_qno,\n\t\t\tsizeof(struct bootup_params_9116), RSI_WIFI_MGMT_Q);\n\tboot_params->desc_dword0.frame_type = BOOTUP_PARAMS_REQUEST;\n\tskb_put(skb, sizeof(struct rsi_boot_params_9116));\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_send_reset_mac() - This function prepares reset MAC request and sends an\n *\t\t\t  internal management frame to indicate it to firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nstatic int rsi_send_reset_mac(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_mac_frame *mgmt_frame;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending reset MAC frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tmgmt_frame = (struct rsi_mac_frame *)skb->data;\n\n\tmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\n\tmgmt_frame->desc_word[1] = cpu_to_le16(RESET_MAC_REQ);\n\tmgmt_frame->desc_word[4] = cpu_to_le16(RETRY_COUNT << 8);\n\n#define RSI_9116_DEF_TA_AGGR\t3\n\tif (common->priv->device_model == RSI_DEV_9116)\n\t\tmgmt_frame->desc_word[3] |=\n\t\t\tcpu_to_le16(RSI_9116_DEF_TA_AGGR << 8);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_band_check() - This function programs the band\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nint rsi_band_check(struct rsi_common *common,\n\t\t   struct ieee80211_channel *curchan)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tu8 prev_bw = common->channel_width;\n\tu8 prev_ep = common->endpoint;\n\tint status = 0;\n\n\tif (common->band != curchan->band) {\n\t\tcommon->rf_reset = 1;\n\t\tcommon->band = curchan->band;\n\t}\n\n\tif ((hw->conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT) ||\n\t    (hw->conf.chandef.width == NL80211_CHAN_WIDTH_20))\n\t\tcommon->channel_width = BW_20MHZ;\n\telse\n\t\tcommon->channel_width = BW_40MHZ;\n\n\tif (common->band == NL80211_BAND_2GHZ) {\n\t\tif (common->channel_width)\n\t\t\tcommon->endpoint = EP_2GHZ_40MHZ;\n\t\telse\n\t\t\tcommon->endpoint = EP_2GHZ_20MHZ;\n\t} else {\n\t\tif (common->channel_width)\n\t\t\tcommon->endpoint = EP_5GHZ_40MHZ;\n\t\telse\n\t\t\tcommon->endpoint = EP_5GHZ_20MHZ;\n\t}\n\n\tif (common->endpoint != prev_ep) {\n\t\tstatus = rsi_program_bb_rf(common);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (common->channel_width != prev_bw) {\n\t\tif (adapter->device_model == RSI_DEV_9116)\n\t\t\tstatus = rsi_load_9116_bootup_params(common);\n\t\telse\n\t\t\tstatus = rsi_load_bootup_params(common);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tstatus = rsi_load_radio_caps(common);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\n/**\n * rsi_set_channel() - This function programs the channel.\n * @common: Pointer to the driver private structure.\n * @channel: Channel value to be set.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nint rsi_set_channel(struct rsi_common *common,\n\t\t    struct ieee80211_channel *channel)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_chan_config *chan_cfg;\n\tu16 frame_len = sizeof(struct rsi_chan_config);\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending scan req frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!channel) {\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\n\t}\n\tmemset(skb->data, 0, frame_len);\n\tchan_cfg = (struct rsi_chan_config *)skb->data;\n\n\trsi_set_len_qno(&chan_cfg->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\tchan_cfg->desc_dword0.frame_type = SCAN_REQUEST;\n\tchan_cfg->channel_number = channel->hw_value;\n\tchan_cfg->antenna_gain_offset_2g = channel->max_antenna_gain;\n\tchan_cfg->antenna_gain_offset_5g = channel->max_antenna_gain;\n\tchan_cfg->region_rftype = (RSI_RF_TYPE & 0xf) << 4;\n\n\tif ((channel->flags & IEEE80211_CHAN_NO_IR) ||\n\t    (channel->flags & IEEE80211_CHAN_RADAR)) {\n\t\tchan_cfg->antenna_gain_offset_2g |= RSI_CHAN_RADAR;\n\t} else {\n\t\tif (common->tx_power < channel->max_power)\n\t\t\tchan_cfg->tx_power = cpu_to_le16(common->tx_power);\n\t\telse\n\t\t\tchan_cfg->tx_power = cpu_to_le16(channel->max_power);\n\t}\n\tchan_cfg->region_rftype |= (common->priv->dfs_region & 0xf);\n\n\tif (common->channel_width == BW_40MHZ)\n\t\tchan_cfg->channel_width = 0x1;\n\n\tcommon->channel = channel->hw_value;\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_send_radio_params_update() - This function sends the radio\n *\t\t\t\tparameters update to device\n * @common: Pointer to the driver private structure.\n * @channel: Channel value to be set.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nint rsi_send_radio_params_update(struct rsi_common *common)\n{\n\tstruct rsi_mac_frame *cmd_frame;\n\tstruct sk_buff *skb = NULL;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending Radio Params update frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tcmd_frame = (struct rsi_mac_frame *)skb->data;\n\n\tcmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\n\tcmd_frame->desc_word[1] = cpu_to_le16(RADIO_PARAMS_UPDATE);\n\tcmd_frame->desc_word[3] = cpu_to_le16(BIT(0));\n\n\tcmd_frame->desc_word[3] |= cpu_to_le16(common->tx_power << 8);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/* This function programs the threshold. */\nint rsi_send_vap_dynamic_update(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_dynamic_s *dynamic_frame;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending vap update indication frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(sizeof(struct rsi_dynamic_s));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, sizeof(struct rsi_dynamic_s));\n\tdynamic_frame = (struct rsi_dynamic_s *)skb->data;\n\trsi_set_len_qno(&dynamic_frame->desc_dword0.len_qno,\n\t\t\tsizeof(dynamic_frame->frame_body), RSI_WIFI_MGMT_Q);\n\n\tdynamic_frame->desc_dword0.frame_type = VAP_DYNAMIC_UPDATE;\n\tdynamic_frame->desc_dword2.pkt_info =\n\t\t\t\t\tcpu_to_le32(common->rts_threshold);\n\n\tif (common->wow_flags & RSI_WOW_ENABLED) {\n\t\t/* Beacon miss threshold */\n\t\tdynamic_frame->desc_dword3.token =\n\t\t\t\t\tcpu_to_le16(RSI_BCN_MISS_THRESHOLD);\n\t\tdynamic_frame->frame_body.keep_alive_period =\n\t\t\t\t\tcpu_to_le16(RSI_WOW_KEEPALIVE);\n\t} else {\n\t\tdynamic_frame->frame_body.keep_alive_period =\n\t\t\t\t\tcpu_to_le16(RSI_DEF_KEEPALIVE);\n\t}\n\n\tdynamic_frame->desc_dword3.sta_id = 0; /* vap id */\n\n\tskb_put(skb, sizeof(struct rsi_dynamic_s));\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_compare() - This function is used to compare two integers\n * @a: pointer to the first integer\n * @b: pointer to the second integer\n *\n * Return: 0 if both are equal, -1 if the first is smaller, else 1\n */\nstatic int rsi_compare(const void *a, const void *b)\n{\n\tu16 _a = *(const u16 *)(a);\n\tu16 _b = *(const u16 *)(b);\n\n\tif (_a > _b)\n\t\treturn -1;\n\n\tif (_a < _b)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * rsi_map_rates() - This function is used to map selected rates to hw rates.\n * @rate: The standard rate to be mapped.\n * @offset: Offset that will be returned.\n *\n * Return: 0 if it is a mcs rate, else 1\n */\nstatic bool rsi_map_rates(u16 rate, int *offset)\n{\n\tint kk;\n\tfor (kk = 0; kk < ARRAY_SIZE(rsi_mcsrates); kk++) {\n\t\tif (rate == mcs[kk]) {\n\t\t\t*offset = kk;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (kk = 0; kk < ARRAY_SIZE(rsi_rates); kk++) {\n\t\tif (rate == rsi_rates[kk].bitrate / 5) {\n\t\t\t*offset = kk;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * rsi_send_auto_rate_request() - This function is to set rates for connection\n *\t\t\t\t  and send autorate request to firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nstatic int rsi_send_auto_rate_request(struct rsi_common *common,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      u16 sta_id,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_auto_rate *auto_rate;\n\tint ii = 0, jj = 0, kk = 0;\n\tstruct ieee80211_hw *hw = common->priv->hw;\n\tu8 band = hw->conf.chandef.chan->band;\n\tu8 num_supported_rates = 0;\n\tu8 rate_table_offset, rate_offset = 0;\n\tu32 rate_bitmap;\n\tu16 *selected_rates, min_rate;\n\tbool is_ht = false, is_sgi = false;\n\tu16 frame_len = sizeof(struct rsi_auto_rate);\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending auto rate request frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tselected_rates = kzalloc(2 * RSI_TBL_SZ, GFP_KERNEL);\n\tif (!selected_rates) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of mem\\n\",\n\t\t\t__func__);\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tauto_rate = (struct rsi_auto_rate *)skb->data;\n\n\tauto_rate->aarf_rssi = cpu_to_le16(((u16)3 << 6) | (u16)(18 & 0x3f));\n\tauto_rate->collision_tolerance = cpu_to_le16(3);\n\tauto_rate->failure_limit = cpu_to_le16(3);\n\tauto_rate->initial_boundary = cpu_to_le16(3);\n\tauto_rate->max_threshold_limt = cpu_to_le16(27);\n\n\tauto_rate->desc.desc_dword0.frame_type = AUTO_RATE_IND;\n\n\tif (common->channel_width == BW_40MHZ)\n\t\tauto_rate->desc.desc_dword3.qid_tid = BW_40MHZ;\n\tauto_rate->desc.desc_dword3.sta_id = sta_id;\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\trate_bitmap = common->bitrate_mask[band];\n\t\tis_ht = common->vif_info[0].is_ht;\n\t\tis_sgi = common->vif_info[0].sgi;\n\t} else {\n\t\trate_bitmap = sta->supp_rates[band];\n\t\tis_ht = sta->ht_cap.ht_supported;\n\t\tif ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||\n\t\t    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\tis_sgi = true;\n\t}\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tif ((rate_bitmap == 0) && (is_ht))\n\t\t\tmin_rate = RSI_RATE_MCS0;\n\t\telse\n\t\t\tmin_rate = RSI_RATE_1;\n\t\trate_table_offset = 0;\n\t} else {\n\t\tif ((rate_bitmap == 0) && (is_ht))\n\t\t\tmin_rate = RSI_RATE_MCS0;\n\t\telse\n\t\t\tmin_rate = RSI_RATE_6;\n\t\trate_table_offset = 4;\n\t}\n\n\tfor (ii = 0, jj = 0;\n\t     ii < (ARRAY_SIZE(rsi_rates) - rate_table_offset); ii++) {\n\t\tif (rate_bitmap & BIT(ii)) {\n\t\t\tselected_rates[jj++] =\n\t\t\t(rsi_rates[ii + rate_table_offset].bitrate / 5);\n\t\t\trate_offset++;\n\t\t}\n\t}\n\tnum_supported_rates = jj;\n\n\tif (is_ht) {\n\t\tfor (ii = 0; ii < ARRAY_SIZE(mcs); ii++)\n\t\t\tselected_rates[jj++] = mcs[ii];\n\t\tnum_supported_rates += ARRAY_SIZE(mcs);\n\t\trate_offset += ARRAY_SIZE(mcs);\n\t}\n\n\tsort(selected_rates, jj, sizeof(u16), &rsi_compare, NULL);\n\n\t/* mapping the rates to RSI rates */\n\tfor (ii = 0; ii < jj; ii++) {\n\t\tif (rsi_map_rates(selected_rates[ii], &kk)) {\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_rates[kk].hw_value);\n\t\t} else {\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_mcsrates[kk]);\n\t\t}\n\t}\n\n\t/* loading HT rates in the bottom half of the auto rate table */\n\tif (is_ht) {\n\t\tfor (ii = rate_offset, kk = ARRAY_SIZE(rsi_mcsrates) - 1;\n\t\t     ii < rate_offset + 2 * ARRAY_SIZE(rsi_mcsrates); ii++) {\n\t\t\tif (is_sgi || conf_is_ht40(&common->priv->hw->conf))\n\t\t\t\tauto_rate->supported_rates[ii++] =\n\t\t\t\t\tcpu_to_le16(rsi_mcsrates[kk] | BIT(9));\n\t\t\telse\n\t\t\t\tauto_rate->supported_rates[ii++] =\n\t\t\t\t\tcpu_to_le16(rsi_mcsrates[kk]);\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_mcsrates[kk--]);\n\t\t}\n\n\t\tfor (; ii < (RSI_TBL_SZ - 1); ii++) {\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_mcsrates[0]);\n\t\t}\n\t}\n\n\tfor (; ii < RSI_TBL_SZ; ii++)\n\t\tauto_rate->supported_rates[ii] = cpu_to_le16(min_rate);\n\n\tauto_rate->num_supported_rates = cpu_to_le16(num_supported_rates * 2);\n\tauto_rate->moderate_rate_inx = cpu_to_le16(num_supported_rates / 2);\n\tnum_supported_rates *= 2;\n\n\trsi_set_len_qno(&auto_rate->desc.desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\n\tskb_put(skb, frame_len);\n\tkfree(selected_rates);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_inform_bss_status() - This function informs about bss status with the\n *\t\t\t     help of sta notify params by sending an internal\n *\t\t\t     management frame to firmware.\n * @common: Pointer to the driver private structure.\n * @status: Bss status type.\n * @bssid: Bssid.\n * @qos_enable: Qos is enabled.\n * @aid: Aid (unique for all STAs).\n *\n * Return: None.\n */\nvoid rsi_inform_bss_status(struct rsi_common *common,\n\t\t\t   enum opmode opmode,\n\t\t\t   u8 status,\n\t\t\t   const u8 *addr,\n\t\t\t   u8 qos_enable,\n\t\t\t   u16 aid,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   u16 sta_id,\n\t\t\t   u16 assoc_cap,\n\t\t\t   struct ieee80211_vif *vif)\n{\n\tif (status) {\n\t\tif (opmode == RSI_OPMODE_STA)\n\t\t\tcommon->hw_data_qs_blocked = true;\n\t\trsi_hal_send_sta_notify_frame(common,\n\t\t\t\t\t      opmode,\n\t\t\t\t\t      STA_CONNECTED,\n\t\t\t\t\t      addr,\n\t\t\t\t\t      qos_enable,\n\t\t\t\t\t      aid, sta_id,\n\t\t\t\t\t      vif);\n\t\tif (common->min_rate == 0xffff)\n\t\t\trsi_send_auto_rate_request(common, sta, sta_id, vif);\n\t\tif (opmode == RSI_OPMODE_STA &&\n\t\t    !(assoc_cap & WLAN_CAPABILITY_PRIVACY) &&\n\t\t    !rsi_send_block_unblock_frame(common, false))\n\t\t\tcommon->hw_data_qs_blocked = false;\n\t} else {\n\t\tif (opmode == RSI_OPMODE_STA)\n\t\t\tcommon->hw_data_qs_blocked = true;\n\n\t\tif (!(common->wow_flags & RSI_WOW_ENABLED))\n\t\t\trsi_hal_send_sta_notify_frame(common, opmode,\n\t\t\t\t\t\t      STA_DISCONNECTED, addr,\n\t\t\t\t\t\t      qos_enable, aid, sta_id,\n\t\t\t\t\t\t      vif);\n\t\tif (opmode == RSI_OPMODE_STA)\n\t\t\trsi_send_block_unblock_frame(common, true);\n\t}\n}\n\n/**\n * rsi_eeprom_read() - This function sends a frame to read the mac address\n *\t\t       from the eeprom.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_eeprom_read(struct rsi_common *common)\n{\n\tstruct rsi_eeprom_read_frame *mgmt_frame;\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending EEPROM read req frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tmgmt_frame = (struct rsi_eeprom_read_frame *)skb->data;\n\n\t/* FrameType */\n\trsi_set_len_qno(&mgmt_frame->len_qno, 0, RSI_WIFI_MGMT_Q);\n\tmgmt_frame->pkt_type = EEPROM_READ;\n\n\t/* Number of bytes to read */\n\tmgmt_frame->pkt_info =\n\t\tcpu_to_le32((adapter->eeprom.length << RSI_EEPROM_LEN_OFFSET) &\n\t\t\t    RSI_EEPROM_LEN_MASK);\n\tmgmt_frame->pkt_info |= cpu_to_le32((3 << RSI_EEPROM_HDR_SIZE_OFFSET) &\n\t\t\t\t\t    RSI_EEPROM_HDR_SIZE_MASK);\n\n\t/* Address to read */\n\tmgmt_frame->eeprom_offset = cpu_to_le32(adapter->eeprom.offset);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * This function sends a frame to block/unblock\n * data queues in the firmware\n *\n * @param common Pointer to the driver private structure.\n * @param block event - block if true, unblock if false\n * @return 0 on success, -1 on failure.\n */\nint rsi_send_block_unblock_frame(struct rsi_common *common, bool block_event)\n{\n\tstruct rsi_block_unblock_data *mgmt_frame;\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending block/unblock frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tmgmt_frame = (struct rsi_block_unblock_data *)skb->data;\n\n\trsi_set_len_qno(&mgmt_frame->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\tmgmt_frame->desc_dword0.frame_type = BLOCK_HW_QUEUE;\n\tmgmt_frame->host_quiet_info = QUIET_INFO_VALID;\n\n\tif (block_event) {\n\t\trsi_dbg(INFO_ZONE, \"blocking the data qs\\n\");\n\t\tmgmt_frame->block_q_bitmap = cpu_to_le16(0xf);\n\t\tmgmt_frame->block_q_bitmap |= cpu_to_le16(0xf << 4);\n\t} else {\n\t\trsi_dbg(INFO_ZONE, \"unblocking the data qs\\n\");\n\t\tmgmt_frame->unblock_q_bitmap = cpu_to_le16(0xf);\n\t\tmgmt_frame->unblock_q_bitmap |= cpu_to_le16(0xf << 4);\n\t}\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_send_rx_filter_frame() - Sends a frame to filter the RX packets\n *\n * @common: Pointer to the driver private structure.\n * @rx_filter_word: Flags of filter packets\n *\n * @Return: 0 on success, -1 on failure.\n */\nint rsi_send_rx_filter_frame(struct rsi_common *common, u16 rx_filter_word)\n{\n\tstruct rsi_mac_frame *cmd_frame;\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE, \"Sending RX filter frame\\n\");\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tcmd_frame = (struct rsi_mac_frame *)skb->data;\n\n\tcmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\n\tcmd_frame->desc_word[1] = cpu_to_le16(SET_RX_FILTER);\n\tcmd_frame->desc_word[4] = cpu_to_le16(rx_filter_word);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nint rsi_send_ps_request(struct rsi_hw *adapter, bool enable,\n\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_bss_conf *bss = &vif->bss_conf;\n\tstruct rsi_request_ps *ps;\n\tstruct rsi_ps_info *ps_info;\n\tstruct sk_buff *skb;\n\tint frame_len = sizeof(*ps);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len);\n\n\tps = (struct rsi_request_ps *)skb->data;\n\tps_info = &adapter->ps_info;\n\n\trsi_set_len_qno(&ps->desc.desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tps->desc.desc_dword0.frame_type = WAKEUP_SLEEP_REQUEST;\n\tif (enable) {\n\t\tps->ps_sleep.enable = RSI_PS_ENABLE;\n\t\tps->desc.desc_dword3.token = cpu_to_le16(RSI_SLEEP_REQUEST);\n\t} else {\n\t\tps->ps_sleep.enable = RSI_PS_DISABLE;\n\t\tps->desc.desc_dword0.len_qno |= cpu_to_le16(RSI_PS_DISABLE_IND);\n\t\tps->desc.desc_dword3.token = cpu_to_le16(RSI_WAKEUP_REQUEST);\n\t}\n\n\tps->ps_uapsd_acs = common->uapsd_bitmap;\n\n\tps->ps_sleep.sleep_type = ps_info->sleep_type;\n\tps->ps_sleep.num_bcns_per_lis_int =\n\t\tcpu_to_le16(ps_info->num_bcns_per_lis_int);\n\tps->ps_sleep.sleep_duration =\n\t\tcpu_to_le32(ps_info->deep_sleep_wakeup_period);\n\n\tif (bss->assoc)\n\t\tps->ps_sleep.connected_sleep = RSI_CONNECTED_SLEEP;\n\telse\n\t\tps->ps_sleep.connected_sleep = RSI_DEEP_SLEEP;\n\n\tps->ps_listen_interval = cpu_to_le32(ps_info->listen_interval);\n\tps->ps_dtim_interval_duration =\n\t\tcpu_to_le32(ps_info->dtim_interval_duration);\n\n\tif (ps_info->listen_interval > ps_info->dtim_interval_duration)\n\t\tps->ps_listen_interval = cpu_to_le32(RSI_PS_DISABLE);\n\n\tps->ps_num_dtim_intervals = cpu_to_le16(ps_info->num_dtims_per_sleep);\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nstatic int rsi_send_w9116_features(struct rsi_common *common)\n{\n\tstruct rsi_wlan_9116_features *w9116_features;\n\tu16 frame_len = sizeof(struct rsi_wlan_9116_features);\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending wlan 9116 features\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len);\n\n\tw9116_features = (struct rsi_wlan_9116_features *)skb->data;\n\n\tw9116_features->pll_mode = common->w9116_features.pll_mode;\n\tw9116_features->rf_type = common->w9116_features.rf_type;\n\tw9116_features->wireless_mode = common->w9116_features.wireless_mode;\n\tw9116_features->enable_ppe = common->w9116_features.enable_ppe;\n\tw9116_features->afe_type = common->w9116_features.afe_type;\n\tif (common->w9116_features.dpd)\n\t\tw9116_features->feature_enable |= cpu_to_le32(RSI_DPD);\n\tif (common->w9116_features.sifs_tx_enable)\n\t\tw9116_features->feature_enable |=\n\t\t\tcpu_to_le32(RSI_SIFS_TX_ENABLE);\n\tif (common->w9116_features.ps_options & RSI_DUTY_CYCLING)\n\t\tw9116_features->feature_enable |= cpu_to_le32(RSI_DUTY_CYCLING);\n\tif (common->w9116_features.ps_options & RSI_END_OF_FRAME)\n\t\tw9116_features->feature_enable |= cpu_to_le32(RSI_END_OF_FRAME);\n\tw9116_features->feature_enable |=\n\t\tcpu_to_le32((common->w9116_features.ps_options & ~0x3) << 2);\n\n\trsi_set_len_qno(&w9116_features->desc.desc_dword0.len_qno,\n\t\t\tframe_len - FRAME_DESC_SZ, RSI_WIFI_MGMT_Q);\n\tw9116_features->desc.desc_dword0.frame_type = FEATURES_ENABLE;\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_set_antenna() - This function send antenna configuration request\n *\t\t       to device\n *\n * @common: Pointer to the driver private structure.\n * @antenna: bitmap for tx antenna selection\n *\n * Return: 0 on Success, negative error code on failure\n */\nint rsi_set_antenna(struct rsi_common *common, u8 antenna)\n{\n\tstruct rsi_ant_sel_frame *ant_sel_frame;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\n\tant_sel_frame = (struct rsi_ant_sel_frame *)skb->data;\n\tant_sel_frame->desc_dword0.frame_type = ANT_SEL_FRAME;\n\tant_sel_frame->sub_frame_type = ANTENNA_SEL_TYPE;\n\tant_sel_frame->ant_value = cpu_to_le16(antenna & ANTENNA_MASK_VALUE);\n\trsi_set_len_qno(&ant_sel_frame->desc_dword0.len_qno,\n\t\t\t0, RSI_WIFI_MGMT_Q);\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nstatic int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nint rsi_send_wowlan_request(struct rsi_common *common, u16 flags,\n\t\t\t    u16 sleep_status)\n{\n\tstruct rsi_wowlan_req *cmd_frame;\n\tstruct sk_buff *skb;\n\tu8 length;\n\n\trsi_dbg(ERR_ZONE, \"%s: Sending wowlan request frame\\n\", __func__);\n\n\tlength = sizeof(*cmd_frame);\n\tskb = dev_alloc_skb(length);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, length);\n\tcmd_frame = (struct rsi_wowlan_req *)skb->data;\n\n\trsi_set_len_qno(&cmd_frame->desc.desc_dword0.len_qno,\n\t\t\t(length - FRAME_DESC_SZ),\n\t\t\tRSI_WIFI_MGMT_Q);\n\tcmd_frame->desc.desc_dword0.frame_type = WOWLAN_CONFIG_PARAMS;\n\tcmd_frame->host_sleep_status = sleep_status;\n\tif (common->secinfo.security_enable &&\n\t    common->secinfo.gtk_cipher)\n\t\tflags |= RSI_WOW_GTK_REKEY;\n\tif (sleep_status)\n\t\tcmd_frame->wow_flags = flags;\n\trsi_dbg(INFO_ZONE, \"Host_Sleep_Status : %d Flags : %d\\n\",\n\t\tcmd_frame->host_sleep_status, cmd_frame->wow_flags);\n\n\tskb_put(skb, length);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n#endif\n\nint rsi_send_bgscan_params(struct rsi_common *common, int enable)\n{\n\tstruct rsi_bgscan_params *params = &common->bgscan;\n\tstruct cfg80211_scan_request *scan_req = common->hwscan;\n\tstruct rsi_bgscan_config *bgscan;\n\tstruct sk_buff *skb;\n\tu16 frame_len = sizeof(*bgscan);\n\tu8 i;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending bgscan params frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len);\n\n\tbgscan = (struct rsi_bgscan_config *)skb->data;\n\trsi_set_len_qno(&bgscan->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tbgscan->desc_dword0.frame_type = BG_SCAN_PARAMS;\n\tbgscan->bgscan_threshold = cpu_to_le16(params->bgscan_threshold);\n\tbgscan->roam_threshold = cpu_to_le16(params->roam_threshold);\n\tif (enable)\n\t\tbgscan->bgscan_periodicity =\n\t\t\tcpu_to_le16(params->bgscan_periodicity);\n\tbgscan->active_scan_duration =\n\t\t\tcpu_to_le16(params->active_scan_duration);\n\tbgscan->passive_scan_duration =\n\t\t\tcpu_to_le16(params->passive_scan_duration);\n\tbgscan->two_probe = params->two_probe;\n\n\tbgscan->num_bgscan_channels = scan_req->n_channels;\n\tfor (i = 0; i < bgscan->num_bgscan_channels; i++)\n\t\tbgscan->channels2scan[i] =\n\t\t\tcpu_to_le16(scan_req->channels[i]->hw_value);\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/* This function sends the probe request to be used by firmware in\n * background scan\n */\nint rsi_send_bgscan_probe_req(struct rsi_common *common,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct cfg80211_scan_request *scan_req = common->hwscan;\n\tstruct rsi_bgscan_probe *bgscan;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *probereq_skb;\n\tu16 frame_len = sizeof(*bgscan);\n\tsize_t ssid_len = 0;\n\tu8 *ssid = NULL;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending bgscan probe req frame\\n\", __func__);\n\n\tif (common->priv->sc_nvifs <= 0)\n\t\treturn -ENODEV;\n\n\tif (scan_req->n_ssids) {\n\t\tssid = scan_req->ssids[0].ssid;\n\t\tssid_len = scan_req->ssids[0].ssid_len;\n\t}\n\n\tskb = dev_alloc_skb(frame_len + MAX_BGSCAN_PROBE_REQ_LEN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len + MAX_BGSCAN_PROBE_REQ_LEN);\n\n\tbgscan = (struct rsi_bgscan_probe *)skb->data;\n\tbgscan->desc_dword0.frame_type = BG_SCAN_PROBE_REQ;\n\tbgscan->flags = cpu_to_le16(HOST_BG_SCAN_TRIG);\n\tif (common->band == NL80211_BAND_5GHZ) {\n\t\tbgscan->mgmt_rate = cpu_to_le16(RSI_RATE_6);\n\t\tbgscan->def_chan = cpu_to_le16(40);\n\t} else {\n\t\tbgscan->mgmt_rate = cpu_to_le16(RSI_RATE_1);\n\t\tbgscan->def_chan = cpu_to_le16(11);\n\t}\n\tbgscan->channel_scan_time = cpu_to_le16(RSI_CHANNEL_SCAN_TIME);\n\n\tprobereq_skb = ieee80211_probereq_get(common->priv->hw, vif->addr, ssid,\n\t\t\t\t\t      ssid_len, scan_req->ie_len);\n\tif (!probereq_skb) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&skb->data[frame_len], probereq_skb->data, probereq_skb->len);\n\n\tbgscan->probe_req_length = cpu_to_le16(probereq_skb->len);\n\n\trsi_set_len_qno(&bgscan->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ + probereq_skb->len),\n\t\t\tRSI_WIFI_MGMT_Q);\n\n\tskb_put(skb, frame_len + probereq_skb->len);\n\n\tdev_kfree_skb(probereq_skb);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_handle_ta_confirm_type() - This function handles the confirm frames.\n * @common: Pointer to the driver private structure.\n * @msg: Pointer to received packet.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_handle_ta_confirm_type(struct rsi_common *common,\n\t\t\t\t      u8 *msg)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tu8 sub_type = (msg[15] & 0xff);\n\tu16 msg_len = ((u16 *)msg)[0] & 0xfff;\n\tu8 offset;\n\n\tswitch (sub_type) {\n\tcase BOOTUP_PARAMS_REQUEST:\n\t\trsi_dbg(FSM_ZONE, \"%s: Boot up params confirm received\\n\",\n\t\t\t__func__);\n\t\tif (common->fsm_state == FSM_BOOT_PARAMS_SENT) {\n\t\t\tif (adapter->device_model == RSI_DEV_9116) {\n\t\t\t\tcommon->band = NL80211_BAND_5GHZ;\n\t\t\t\tcommon->num_supp_bands = 2;\n\n\t\t\t\tif (rsi_send_reset_mac(common))\n\t\t\t\t\tgoto out;\n\t\t\t\telse\n\t\t\t\t\tcommon->fsm_state = FSM_RESET_MAC_SENT;\n\t\t\t} else {\n\t\t\t\tadapter->eeprom.length =\n\t\t\t\t\t(IEEE80211_ADDR_LEN +\n\t\t\t\t\t WLAN_MAC_MAGIC_WORD_LEN +\n\t\t\t\t\t WLAN_HOST_MODE_LEN);\n\t\t\t\tadapter->eeprom.offset = WLAN_MAC_EEPROM_ADDR;\n\t\t\t\tif (rsi_eeprom_read(common)) {\n\t\t\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcommon->fsm_state = FSM_EEPROM_READ_MAC_ADDR;\n\t\t\t}\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Received bootup params cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase EEPROM_READ:\n\t\trsi_dbg(FSM_ZONE, \"EEPROM READ confirm received\\n\");\n\t\tif (msg_len <= 0) {\n\t\t\trsi_dbg(FSM_ZONE,\n\t\t\t\t\"%s: [EEPROM_READ] Invalid len %d\\n\",\n\t\t\t\t__func__, msg_len);\n\t\t\tgoto out;\n\t\t}\n\t\tif (msg[16] != MAGIC_WORD) {\n\t\t\trsi_dbg(FSM_ZONE,\n\t\t\t\t\"%s: [EEPROM_READ] Invalid token\\n\", __func__);\n\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (common->fsm_state == FSM_EEPROM_READ_MAC_ADDR) {\n\t\t\toffset = (FRAME_DESC_SZ + WLAN_HOST_MODE_LEN +\n\t\t\t\t  WLAN_MAC_MAGIC_WORD_LEN);\n\t\t\tmemcpy(common->mac_addr, &msg[offset], ETH_ALEN);\n\t\t\tadapter->eeprom.length =\n\t\t\t\t((WLAN_MAC_MAGIC_WORD_LEN + 3) & (~3));\n\t\t\tadapter->eeprom.offset = WLAN_EEPROM_RFTYPE_ADDR;\n\t\t\tif (rsi_eeprom_read(common)) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: Failed reading RF band\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcommon->fsm_state = FSM_EEPROM_READ_RF_TYPE;\n\t\t} else if (common->fsm_state == FSM_EEPROM_READ_RF_TYPE) {\n\t\t\tif ((msg[17] & 0x3) == 0x3) {\n\t\t\t\trsi_dbg(INIT_ZONE, \"Dual band supported\\n\");\n\t\t\t\tcommon->band = NL80211_BAND_5GHZ;\n\t\t\t\tcommon->num_supp_bands = 2;\n\t\t\t} else if ((msg[17] & 0x3) == 0x1) {\n\t\t\t\trsi_dbg(INIT_ZONE,\n\t\t\t\t\t\"Only 2.4Ghz band supported\\n\");\n\t\t\t\tcommon->band = NL80211_BAND_2GHZ;\n\t\t\t\tcommon->num_supp_bands = 1;\n\t\t\t}\n\t\t\tif (rsi_send_reset_mac(common))\n\t\t\t\tgoto out;\n\t\t\tcommon->fsm_state = FSM_RESET_MAC_SENT;\n\t\t} else {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Invalid EEPROM read type\\n\",\n\t\t\t\t__func__);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase RESET_MAC_REQ:\n\t\tif (common->fsm_state == FSM_RESET_MAC_SENT) {\n\t\t\trsi_dbg(FSM_ZONE, \"%s: Reset MAC cfm received\\n\",\n\t\t\t\t__func__);\n\n\t\t\tif (rsi_load_radio_caps(common))\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tcommon->fsm_state = FSM_RADIO_CAPS_SENT;\n\t\t} else {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Received reset mac cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase RADIO_CAPABILITIES:\n\t\tif (common->fsm_state == FSM_RADIO_CAPS_SENT) {\n\t\t\tcommon->rf_reset = 1;\n\t\t\tif (adapter->device_model == RSI_DEV_9116 &&\n\t\t\t    rsi_send_w9116_features(common)) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"Failed to send 9116 features\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (rsi_program_bb_rf(common)) {\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tcommon->fsm_state = FSM_BB_RF_PROG_SENT;\n\t\t\t\trsi_dbg(FSM_ZONE, \"%s: Radio cap cfm received\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Received radio caps cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase BB_PROG_VALUES_REQUEST:\n\tcase RF_PROG_VALUES_REQUEST:\n\tcase BBP_PROG_IN_TA:\n\t\trsi_dbg(FSM_ZONE, \"%s: BB/RF cfm received\\n\", __func__);\n\t\tif (common->fsm_state == FSM_BB_RF_PROG_SENT) {\n\t\t\tcommon->bb_rf_prog_count--;\n\t\t\tif (!common->bb_rf_prog_count) {\n\t\t\t\tcommon->fsm_state = FSM_MAC_INIT_DONE;\n\t\t\t\tif (common->reinit_hw) {\n\t\t\t\t\tcomplete(&common->wlan_init_completion);\n\t\t\t\t} else {\n\t\t\t\t\treturn rsi_mac80211_attach(common);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Received bbb_rf cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase SCAN_REQUEST:\n\t\trsi_dbg(INFO_ZONE, \"Set channel confirm\\n\");\n\t\tbreak;\n\n\tcase WAKEUP_SLEEP_REQUEST:\n\t\trsi_dbg(INFO_ZONE, \"Wakeup/Sleep confirmation.\\n\");\n\t\treturn rsi_handle_ps_confirm(adapter, msg);\n\n\tcase BG_SCAN_PROBE_REQ:\n\t\trsi_dbg(INFO_ZONE, \"BG scan complete event\\n\");\n\t\tif (common->bgscan_en) {\n\t\t\tstruct cfg80211_scan_info info;\n\n\t\t\tif (!rsi_send_bgscan_params(common, RSI_STOP_BGSCAN))\n\t\t\t\tcommon->bgscan_en = 0;\n\t\t\tinfo.aborted = false;\n\t\t\tieee80211_scan_completed(adapter->hw, &info);\n\t\t}\n\t\trsi_dbg(INFO_ZONE, \"Background scan completed\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\trsi_dbg(INFO_ZONE, \"%s: Invalid TA confirm pkt received\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\treturn 0;\nout:\n\trsi_dbg(ERR_ZONE, \"%s: Unable to send pkt/Invalid frame received\\n\",\n\t\t__func__);\n\treturn -EINVAL;\n}\n\nint rsi_handle_card_ready(struct rsi_common *common, u8 *msg)\n{\n\tint status;\n\n\tswitch (common->fsm_state) {\n\tcase FSM_CARD_NOT_READY:\n\t\trsi_dbg(INIT_ZONE, \"Card ready indication from Common HAL\\n\");\n\t\trsi_set_default_parameters(common);\n\t\tif (rsi_send_common_dev_params(common) < 0)\n\t\t\treturn -EINVAL;\n\t\tcommon->fsm_state = FSM_COMMON_DEV_PARAMS_SENT;\n\t\tbreak;\n\tcase FSM_COMMON_DEV_PARAMS_SENT:\n\t\trsi_dbg(INIT_ZONE, \"Card ready indication from WLAN HAL\\n\");\n\n\t\tif (common->priv->device_model == RSI_DEV_9116) {\n\t\t\tif (msg[16] != MAGIC_WORD) {\n\t\t\t\trsi_dbg(FSM_ZONE,\n\t\t\t\t\t\"%s: [EEPROM_READ] Invalid token\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmemcpy(common->mac_addr, &msg[20], ETH_ALEN);\n\t\t\trsi_dbg(INIT_ZONE, \"MAC Addr %pM\", common->mac_addr);\n\t\t}\n\t\t/* Get usb buffer status register address */\n\t\tcommon->priv->usb_buffer_status_reg = *(u32 *)&msg[8];\n\t\trsi_dbg(INFO_ZONE, \"USB buffer status register = %x\\n\",\n\t\t\tcommon->priv->usb_buffer_status_reg);\n\n\t\tif (common->priv->device_model == RSI_DEV_9116)\n\t\t\tstatus = rsi_load_9116_bootup_params(common);\n\t\telse\n\t\t\tstatus = rsi_load_bootup_params(common);\n\t\tif (status < 0) {\n\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\treturn status;\n\t\t}\n\t\tcommon->fsm_state = FSM_BOOT_PARAMS_SENT;\n\t\tbreak;\n\tdefault:\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: card ready indication in invalid state %d.\\n\",\n\t\t\t__func__, common->fsm_state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * rsi_mgmt_pkt_recv() - This function processes the management packets\n *\t\t\t received from the hardware.\n * @common: Pointer to the driver private structure.\n * @msg: Pointer to the received packet.\n *\n * Return: 0 on success, -1 on failure.\n */\nint rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg)\n{\n\ts32 msg_len = (le16_to_cpu(*(__le16 *)&msg[0]) & 0x0fff);\n\tu16 msg_type = (msg[2]);\n\n\trsi_dbg(FSM_ZONE, \"%s: Msg Len: %d, Msg Type: %4x\\n\",\n\t\t__func__, msg_len, msg_type);\n\n\tswitch (msg_type) {\n\tcase TA_CONFIRM_TYPE:\n\t\treturn rsi_handle_ta_confirm_type(common, msg);\n\tcase CARD_READY_IND:\n\t\tcommon->hibernate_resume = false;\n\t\trsi_dbg(FSM_ZONE, \"%s: Card ready indication received\\n\",\n\t\t\t__func__);\n\t\treturn rsi_handle_card_ready(common, msg);\n\tcase TX_STATUS_IND:\n\t\tswitch (msg[RSI_TX_STATUS_TYPE]) {\n\t\tcase PROBEREQ_CONFIRM:\n\t\t\tcommon->mgmt_q_block = false;\n\t\t\trsi_dbg(FSM_ZONE, \"%s: Probe confirm received\\n\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\tcase EAPOL4_CONFIRM:\n\t\t\tif (msg[RSI_TX_STATUS]) {\n\t\t\t\tcommon->eapol4_confirm = true;\n\t\t\t\tif (!rsi_send_block_unblock_frame(common,\n\t\t\t\t\t\t\t\t  false))\n\t\t\t\t\tcommon->hw_data_qs_blocked = false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase BEACON_EVENT_IND:\n\t\trsi_dbg(INFO_ZONE, \"Beacon event\\n\");\n\t\tif (common->fsm_state != FSM_MAC_INIT_DONE)\n\t\t\treturn -1;\n\t\tif (common->iface_down)\n\t\t\treturn -1;\n\t\tif (!common->beacon_enabled)\n\t\t\treturn -1;\n\t\trsi_send_beacon(common);\n\t\tbreak;\n\tcase WOWLAN_WAKEUP_REASON:\n\t\trsi_dbg(ERR_ZONE, \"\\n\\nWakeup Type: %x\\n\", msg[15]);\n\t\tswitch (msg[15]) {\n\t\tcase RSI_UNICAST_MAGIC_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for Unicast magic packet ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_BROADCAST_MAGICPKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for Broadcast magic packet ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_EAPOL_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for GTK renewal ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_DISCONNECT_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for Disconnect ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_HW_BMISS_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for HW Beacon miss ***\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"##### Un-intentional Wakeup #####\\n\");\n\t\t\tbreak;\n\t}\n\tbreak;\n\tcase RX_DOT11_MGMT:\n\t\treturn rsi_mgmt_pkt_to_core(common, msg, msg_len);\n\tdefault:\n\t\trsi_dbg(INFO_ZONE, \"Received packet type: 0x%x\\n\", msg_type);\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2014 Redpine Signals Inc.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <linux/etherdevice.h>\n#include <linux/timer.h>\n#include \"rsi_mgmt.h\"\n#include \"rsi_common.h\"\n#include \"rsi_ps.h\"\n#include \"rsi_hal.h\"\n\nstatic struct bootup_params boot_params_20 = {\n\t.magic_number = cpu_to_le16(0x5aa5),\n\t.crystal_good_time = 0x0,\n\t.valid = cpu_to_le32(VALID_20),\n\t.reserved_for_valids = 0x0,\n\t.bootup_mode_info = 0x0,\n\t.digital_loop_back_params = 0x0,\n\t.rtls_timestamp_en = 0x0,\n\t.host_spi_intr_cfg = 0x0,\n\t.device_clk_info = {{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|\n\t\t\t\t\t      (TA_PLL_M_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = cpu_to_le16(0xb),\n\t\t\t.bbp_lmac_clk_reg_val = cpu_to_le16(0x111),\n\t\t\t.umac_clock_reg_config = cpu_to_le16(0x48),\n\t\t\t.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_20)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t} },\n\t.buckboost_wakeup_cnt = 0x0,\n\t.pmu_wakeup_wait = 0x0,\n\t.shutdown_wait_time = 0x0,\n\t.pmu_slp_clkout_sel = 0x0,\n\t.wdt_prog_value = 0x0,\n\t.wdt_soc_rst_delay = 0x0,\n\t.dcdc_operation_mode = 0x0,\n\t.soc_reset_wait_cnt = 0x0,\n\t.waiting_time_at_fresh_sleep = 0x0,\n\t.max_threshold_to_avoid_sleep = 0x0,\n\t.beacon_resedue_alg_en = 0,\n};\n\nstatic struct bootup_params boot_params_40 = {\n\t.magic_number = cpu_to_le16(0x5aa5),\n\t.crystal_good_time = 0x0,\n\t.valid = cpu_to_le32(VALID_40),\n\t.reserved_for_valids = 0x0,\n\t.bootup_mode_info = 0x0,\n\t.digital_loop_back_params = 0x0,\n\t.rtls_timestamp_en = 0x0,\n\t.host_spi_intr_cfg = 0x0,\n\t.device_clk_info = {{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = cpu_to_le16(0x09),\n\t\t\t.bbp_lmac_clk_reg_val = cpu_to_le16(0x1121),\n\t\t\t.umac_clock_reg_config = cpu_to_le16(0x48),\n\t\t\t.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t},\n\t{\n\t\t.pll_config_g = {\n\t\t\t.tapll_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|\n\t\t\t\t\t\t\t (TA_PLL_M_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),\n\t\t\t},\n\t\t\t.pll960_info_g = {\n\t\t\t\t.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|\n\t\t\t\t\t\t\t (PLL960_N_VAL_40)),\n\t\t\t\t.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),\n\t\t\t\t.pll_reg_3 = 0x0,\n\t\t\t},\n\t\t\t.afepll_info_g = {\n\t\t\t\t.pll_reg = cpu_to_le16(0x9f0),\n\t\t\t}\n\t\t},\n\t\t.switch_clk_g = {\n\t\t\t.switch_clk_info = 0x0,\n\t\t\t.bbp_lmac_clk_reg_val = 0x0,\n\t\t\t.umac_clock_reg_config = 0x0,\n\t\t\t.qspi_uart_clock_reg_config = 0x0\n\t\t}\n\t} },\n\t.buckboost_wakeup_cnt = 0x0,\n\t.pmu_wakeup_wait = 0x0,\n\t.shutdown_wait_time = 0x0,\n\t.pmu_slp_clkout_sel = 0x0,\n\t.wdt_prog_value = 0x0,\n\t.wdt_soc_rst_delay = 0x0,\n\t.dcdc_operation_mode = 0x0,\n\t.soc_reset_wait_cnt = 0x0,\n\t.waiting_time_at_fresh_sleep = 0x0,\n\t.max_threshold_to_avoid_sleep = 0x0,\n\t.beacon_resedue_alg_en = 0,\n};\n\nstatic struct bootup_params_9116 boot_params_9116_20 = {\n\t.magic_number = cpu_to_le16(LOADED_TOKEN),\n\t.valid = cpu_to_le32(VALID_20),\n\t.device_clk_info_9116 = {{\n\t\t.pll_config_9116_g = {\n\t\t\t.pll_ctrl_set_reg = cpu_to_le16(0xd518),\n\t\t\t.pll_ctrl_clr_reg = cpu_to_le16(0x2ae7),\n\t\t\t.pll_modem_conig_reg = cpu_to_le16(0x2000),\n\t\t\t.soc_clk_config_reg = cpu_to_le16(0x0c18),\n\t\t\t.adc_dac_strm1_config_reg = cpu_to_le16(0x1100),\n\t\t\t.adc_dac_strm2_config_reg = cpu_to_le16(0x6600),\n\t\t},\n\t\t.switch_clk_9116_g = {\n\t\t\t.switch_clk_info =\n\t\t\t\tcpu_to_le32((RSI_SWITCH_TASS_CLK |\n\t\t\t\t\t    RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG |\n\t\t\t\t\t    RSI_SWITCH_BBP_LMAC_CLK_REG)),\n\t\t\t.tass_clock_reg = cpu_to_le32(0x083C0503),\n\t\t\t.wlan_bbp_lmac_clk_reg_val = cpu_to_le32(0x01042001),\n\t\t\t.zbbt_bbp_lmac_clk_reg_val = cpu_to_le32(0x02010001),\n\t\t\t.bbp_lmac_clk_en_val = cpu_to_le32(0x0000003b),\n\t\t}\n\t},\n\t},\n};\n\nstatic struct bootup_params_9116 boot_params_9116_40 = {\n\t.magic_number = cpu_to_le16(LOADED_TOKEN),\n\t.valid = cpu_to_le32(VALID_40),\n\t.device_clk_info_9116 = {{\n\t\t.pll_config_9116_g = {\n\t\t\t.pll_ctrl_set_reg = cpu_to_le16(0xd518),\n\t\t\t.pll_ctrl_clr_reg = cpu_to_le16(0x2ae7),\n\t\t\t.pll_modem_conig_reg = cpu_to_le16(0x3000),\n\t\t\t.soc_clk_config_reg = cpu_to_le16(0x0c18),\n\t\t\t.adc_dac_strm1_config_reg = cpu_to_le16(0x0000),\n\t\t\t.adc_dac_strm2_config_reg = cpu_to_le16(0x6600),\n\t\t},\n\t\t.switch_clk_9116_g = {\n\t\t\t.switch_clk_info =\n\t\t\t\tcpu_to_le32((RSI_SWITCH_TASS_CLK |\n\t\t\t\t\t    RSI_SWITCH_WLAN_BBP_LMAC_CLK_REG |\n\t\t\t\t\t    RSI_SWITCH_BBP_LMAC_CLK_REG |\n\t\t\t\t\t    RSI_MODEM_CLK_160MHZ)),\n\t\t\t.tass_clock_reg = cpu_to_le32(0x083C0503),\n\t\t\t.wlan_bbp_lmac_clk_reg_val = cpu_to_le32(0x01042002),\n\t\t\t.zbbt_bbp_lmac_clk_reg_val = cpu_to_le32(0x04010002),\n\t\t\t.bbp_lmac_clk_en_val = cpu_to_le32(0x0000003b),\n\t\t}\n\t},\n\t},\n};\n\nstatic u16 mcs[] = {13, 26, 39, 52, 78, 104, 117, 130};\n\n/**\n * rsi_set_default_parameters() - This function sets default parameters.\n * @common: Pointer to the driver private structure.\n *\n * Return: none\n */\nstatic void rsi_set_default_parameters(struct rsi_common *common)\n{\n\tcommon->band = NL80211_BAND_2GHZ;\n\tcommon->channel_width = BW_20MHZ;\n\tcommon->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;\n\tcommon->channel = 1;\n\tcommon->min_rate = 0xffff;\n\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\tcommon->iface_down = true;\n\tcommon->endpoint = EP_2GHZ_20MHZ;\n\tcommon->driver_mode = 1; /* End to end mode */\n\tcommon->lp_ps_handshake_mode = 0; /* Default no handShake mode*/\n\tcommon->ulp_ps_handshake_mode = 2; /* Default PKT handShake mode*/\n\tcommon->rf_power_val = 0; /* Default 1.9V */\n\tcommon->wlan_rf_power_mode = 0;\n\tcommon->obm_ant_sel_val = 2;\n\tcommon->beacon_interval = RSI_BEACON_INTERVAL;\n\tcommon->dtim_cnt = RSI_DTIM_COUNT;\n\tcommon->w9116_features.pll_mode = 0x0;\n\tcommon->w9116_features.rf_type = 1;\n\tcommon->w9116_features.wireless_mode = 0;\n\tcommon->w9116_features.enable_ppe = 0;\n\tcommon->w9116_features.afe_type = 1;\n\tcommon->w9116_features.dpd = 0;\n\tcommon->w9116_features.sifs_tx_enable = 0;\n\tcommon->w9116_features.ps_options = 0;\n}\n\nvoid init_bgscan_params(struct rsi_common *common)\n{\n\tmemset((u8 *)&common->bgscan, 0, sizeof(struct rsi_bgscan_params));\n\tcommon->bgscan.bgscan_threshold = RSI_DEF_BGSCAN_THRLD;\n\tcommon->bgscan.roam_threshold = RSI_DEF_ROAM_THRLD;\n\tcommon->bgscan.bgscan_periodicity = RSI_BGSCAN_PERIODICITY;\n\tcommon->bgscan.num_bgscan_channels = 0;\n\tcommon->bgscan.two_probe = 1;\n\tcommon->bgscan.active_scan_duration = RSI_ACTIVE_SCAN_TIME;\n\tcommon->bgscan.passive_scan_duration = RSI_PASSIVE_SCAN_TIME;\n}\n\n/**\n * rsi_set_contention_vals() - This function sets the contention values for the\n *\t\t\t       backoff procedure.\n * @common: Pointer to the driver private structure.\n *\n * Return: None.\n */\nstatic void rsi_set_contention_vals(struct rsi_common *common)\n{\n\tu8 ii = 0;\n\n\tfor (; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tcommon->tx_qinfo[ii].wme_params =\n\t\t\t(((common->edca_params[ii].cw_min / 2) +\n\t\t\t  (common->edca_params[ii].aifs)) *\n\t\t\t  WMM_SHORT_SLOT_TIME + SIFS_DURATION);\n\t\tcommon->tx_qinfo[ii].weight = common->tx_qinfo[ii].wme_params;\n\t\tcommon->tx_qinfo[ii].pkt_contended = 0;\n\t}\n}\n\n/**\n * rsi_send_internal_mgmt_frame() - This function sends management frames to\n *\t\t\t\t    firmware.Also schedules packet to queue\n *\t\t\t\t    for transmission.\n * @common: Pointer to the driver private structure.\n * @skb: Pointer to the socket buffer structure.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_send_internal_mgmt_frame(struct rsi_common *common,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct skb_info *tx_params;\n\tstruct rsi_cmd_desc *desc;\n\n\tif (skb == NULL) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to allocate skb\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdesc = (struct rsi_cmd_desc *)skb->data;\n\tdesc->desc_dword0.len_qno |= cpu_to_le16(DESC_IMMEDIATE_WAKEUP);\n\tskb->priority = MGMT_SOFT_Q;\n\ttx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;\n\ttx_params->flags |= INTERNAL_MGMT_PKT;\n\tskb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\treturn 0;\n}\n\n/**\n * rsi_load_radio_caps() - This function is used to send radio capabilities\n *\t\t\t   values to firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nstatic int rsi_load_radio_caps(struct rsi_common *common)\n{\n\tstruct rsi_radio_caps *radio_caps;\n\tstruct rsi_hw *adapter = common->priv;\n\tu16 inx = 0;\n\tu8 ii;\n\tu8 radio_id = 0;\n\tu16 gc[20] = {0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0,\n\t\t      0xf0, 0xf0, 0xf0, 0xf0};\n\tstruct sk_buff *skb;\n\tu16 frame_len = sizeof(struct rsi_radio_caps);\n\n\trsi_dbg(INFO_ZONE, \"%s: Sending rate symbol req frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tradio_caps = (struct rsi_radio_caps *)skb->data;\n\n\tradio_caps->desc_dword0.frame_type = RADIO_CAPABILITIES;\n\tradio_caps->channel_num = common->channel;\n\tradio_caps->rf_model = RSI_RF_TYPE;\n\n\tradio_caps->radio_cfg_info = RSI_LMAC_CLOCK_80MHZ;\n\tif (common->channel_width == BW_40MHZ) {\n\t\tradio_caps->radio_cfg_info |= RSI_ENABLE_40MHZ;\n\n\t\tif (common->fsm_state == FSM_MAC_INIT_DONE) {\n\t\t\tstruct ieee80211_hw *hw = adapter->hw;\n\t\t\tstruct ieee80211_conf *conf = &hw->conf;\n\n\t\t\tif (conf_is_ht40_plus(conf)) {\n\t\t\t\tradio_caps->ppe_ack_rate =\n\t\t\t\t\tcpu_to_le16(LOWER_20_ENABLE |\n\t\t\t\t\t\t    (LOWER_20_ENABLE >> 12));\n\t\t\t} else if (conf_is_ht40_minus(conf)) {\n\t\t\t\tradio_caps->ppe_ack_rate =\n\t\t\t\t\tcpu_to_le16(UPPER_20_ENABLE |\n\t\t\t\t\t\t    (UPPER_20_ENABLE >> 12));\n\t\t\t} else {\n\t\t\t\tradio_caps->ppe_ack_rate =\n\t\t\t\t\tcpu_to_le16((BW_40MHZ << 12) |\n\t\t\t\t\t\t    FULL40M_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n\tradio_caps->radio_info |= radio_id;\n\n\tif (adapter->device_model == RSI_DEV_9116 &&\n\t    common->channel_width == BW_20MHZ)\n\t\tradio_caps->radio_cfg_info &= ~0x3;\n\n\tradio_caps->sifs_tx_11n = cpu_to_le16(SIFS_TX_11N_VALUE);\n\tradio_caps->sifs_tx_11b = cpu_to_le16(SIFS_TX_11B_VALUE);\n\tradio_caps->slot_rx_11n = cpu_to_le16(SHORT_SLOT_VALUE);\n\tradio_caps->ofdm_ack_tout = cpu_to_le16(OFDM_ACK_TOUT_VALUE);\n\tradio_caps->cck_ack_tout = cpu_to_le16(CCK_ACK_TOUT_VALUE);\n\tradio_caps->preamble_type = cpu_to_le16(LONG_PREAMBLE);\n\n\tfor (ii = 0; ii < MAX_HW_QUEUES; ii++) {\n\t\tradio_caps->qos_params[ii].cont_win_min_q = cpu_to_le16(3);\n\t\tradio_caps->qos_params[ii].cont_win_max_q = cpu_to_le16(0x3f);\n\t\tradio_caps->qos_params[ii].aifsn_val_q = cpu_to_le16(2);\n\t\tradio_caps->qos_params[ii].txop_q = 0;\n\t}\n\n\tfor (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tif (common->edca_params[ii].cw_max > 0) {\n\t\t\tradio_caps->qos_params[ii].cont_win_min_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].cw_min);\n\t\t\tradio_caps->qos_params[ii].cont_win_max_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].cw_max);\n\t\t\tradio_caps->qos_params[ii].aifsn_val_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].aifs << 8);\n\t\t\tradio_caps->qos_params[ii].txop_q =\n\t\t\t\tcpu_to_le16(common->edca_params[ii].txop);\n\t\t}\n\t}\n\n\tradio_caps->qos_params[BROADCAST_HW_Q].txop_q = cpu_to_le16(0xffff);\n\tradio_caps->qos_params[MGMT_HW_Q].txop_q = 0;\n\tradio_caps->qos_params[BEACON_HW_Q].txop_q = cpu_to_le16(0xffff);\n\n\tmemcpy(&common->rate_pwr[0], &gc[0], 40);\n\tfor (ii = 0; ii < 20; ii++)\n\t\tradio_caps->gcpd_per_rate[inx++] =\n\t\t\tcpu_to_le16(common->rate_pwr[ii]  & 0x00FF);\n\n\trsi_set_len_qno(&radio_caps->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_mgmt_pkt_to_core() - This function is the entry point for Mgmt module.\n * @common: Pointer to the driver private structure.\n * @msg: Pointer to received packet.\n * @msg_len: Length of the received packet.\n * @type: Type of received packet.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_mgmt_pkt_to_core(struct rsi_common *common,\n\t\t\t\tu8 *msg,\n\t\t\t\ts32 msg_len)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_tx_info *info;\n\tstruct skb_info *rx_params;\n\tu8 pad_bytes = msg[4];\n\tstruct sk_buff *skb;\n\n\tif (!adapter->sc_nvifs)\n\t\treturn -ENOLINK;\n\n\tmsg_len -= pad_bytes;\n\tif (msg_len <= 0) {\n\t\trsi_dbg(MGMT_RX_ZONE,\n\t\t\t\"%s: Invalid rx msg of len = %d\\n\",\n\t\t\t__func__, msg_len);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = dev_alloc_skb(msg_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb,\n\t\t     (u8 *)(msg + FRAME_DESC_SZ + pad_bytes),\n\t\t     msg_len);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\trx_params = (struct skb_info *)info->driver_data;\n\trx_params->rssi = rsi_get_rssi(msg);\n\trx_params->channel = rsi_get_channel(msg);\n\trsi_indicate_pkt_to_os(common, skb);\n\n\treturn 0;\n}\n\n/**\n * rsi_hal_send_sta_notify_frame() - This function sends the station notify\n *\t\t\t\t     frame to firmware.\n * @common: Pointer to the driver private structure.\n * @opmode: Operating mode of device.\n * @notify_event: Notification about station connection.\n * @bssid: bssid.\n * @qos_enable: Qos is enabled.\n * @aid: Aid (unique for all STA).\n *\n * Return: status: 0 on success, corresponding negative error code on failure.\n */\nint rsi_hal_send_sta_notify_frame(struct rsi_common *common, enum opmode opmode,\n\t\t\t\t  u8 notify_event, const unsigned char *bssid,\n\t\t\t\t  u8 qos_enable, u16 aid, u16 sta_id,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_peer_notify *peer_notify;\n\tu16 vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;\n\tint status;\n\tu16 frame_len = sizeof(struct rsi_peer_notify);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending sta notify frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tpeer_notify = (struct rsi_peer_notify *)skb->data;\n\n\tif (opmode == RSI_OPMODE_STA)\n\t\tpeer_notify->command = cpu_to_le16(PEER_TYPE_AP << 1);\n\telse if (opmode == RSI_OPMODE_AP)\n\t\tpeer_notify->command = cpu_to_le16(PEER_TYPE_STA << 1);\n\n\tswitch (notify_event) {\n\tcase STA_CONNECTED:\n\t\tpeer_notify->command |= cpu_to_le16(RSI_ADD_PEER);\n\t\tbreak;\n\tcase STA_DISCONNECTED:\n\t\tpeer_notify->command |= cpu_to_le16(RSI_DELETE_PEER);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpeer_notify->command |= cpu_to_le16((aid & 0xfff) << 4);\n\tether_addr_copy(peer_notify->mac_addr, bssid);\n\tpeer_notify->mpdu_density = cpu_to_le16(RSI_MPDU_DENSITY);\n\tpeer_notify->sta_flags = cpu_to_le32((qos_enable) ? 1 : 0);\n\n\trsi_set_len_qno(&peer_notify->desc.desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ),\n\t\t\tRSI_WIFI_MGMT_Q);\n\tpeer_notify->desc.desc_dword0.frame_type = PEER_NOTIFY;\n\tpeer_notify->desc.desc_dword3.qid_tid = sta_id;\n\tpeer_notify->desc.desc_dword3.sta_id = vap_id;\n\n\tskb_put(skb, frame_len);\n\n\tstatus = rsi_send_internal_mgmt_frame(common, skb);\n\n\tif ((vif->type == NL80211_IFTYPE_STATION) &&\n\t    (!status && qos_enable)) {\n\t\trsi_set_contention_vals(common);\n\t\tstatus = rsi_load_radio_caps(common);\n\t}\n\treturn status;\n}\n\n/**\n * rsi_send_aggregation_params_frame() - This function sends the ampdu\n *\t\t\t\t\t indication frame to firmware.\n * @common: Pointer to the driver private structure.\n * @tid: traffic identifier.\n * @ssn: ssn.\n * @buf_size: buffer size.\n * @event: notification about station connection.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nint rsi_send_aggregation_params_frame(struct rsi_common *common,\n\t\t\t\t      u16 tid,\n\t\t\t\t      u16 ssn,\n\t\t\t\t      u8 buf_size,\n\t\t\t\t      u8 event,\n\t\t\t\t      u8 sta_id)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_aggr_params *aggr_params;\n\tu16 frame_len = sizeof(struct rsi_aggr_params);\n\n\tskb = dev_alloc_skb(frame_len);\n\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\taggr_params = (struct rsi_aggr_params *)skb->data;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending AMPDU indication frame\\n\", __func__);\n\n\trsi_set_len_qno(&aggr_params->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\taggr_params->desc_dword0.frame_type = AMPDU_IND;\n\n\taggr_params->aggr_params = tid & RSI_AGGR_PARAMS_TID_MASK;\n\taggr_params->peer_id = sta_id;\n\tif (event == STA_TX_ADDBA_DONE) {\n\t\taggr_params->seq_start = cpu_to_le16(ssn);\n\t\taggr_params->baw_size = cpu_to_le16(buf_size);\n\t\taggr_params->aggr_params |= RSI_AGGR_PARAMS_START;\n\t} else if (event == STA_RX_ADDBA_DONE) {\n\t\taggr_params->seq_start = cpu_to_le16(ssn);\n\t\taggr_params->aggr_params |= (RSI_AGGR_PARAMS_START |\n\t\t\t\t\t     RSI_AGGR_PARAMS_RX_AGGR);\n\t} else if (event == STA_RX_DELBA) {\n\t\taggr_params->aggr_params |= RSI_AGGR_PARAMS_RX_AGGR;\n\t}\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_program_bb_rf() - This function starts base band and RF programming.\n *\t\t\t This is called after initial configurations are done.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nstatic int rsi_program_bb_rf(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_bb_rf_prog *bb_rf_prog;\n\tu16 frame_len = sizeof(struct rsi_bb_rf_prog);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending program BB/RF frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tbb_rf_prog = (struct rsi_bb_rf_prog *)skb->data;\n\n\trsi_set_len_qno(&bb_rf_prog->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\tbb_rf_prog->desc_dword0.frame_type = BBP_PROG_IN_TA;\n\tbb_rf_prog->endpoint = common->endpoint;\n\tbb_rf_prog->rf_power_mode = common->wlan_rf_power_mode;\n\n\tif (common->rf_reset) {\n\t\tbb_rf_prog->flags =  cpu_to_le16(RF_RESET_ENABLE);\n\t\trsi_dbg(MGMT_TX_ZONE, \"%s: ===> RF RESET REQUEST SENT <===\\n\",\n\t\t\t__func__);\n\t\tcommon->rf_reset = 0;\n\t}\n\tcommon->bb_rf_prog_count = 1;\n\tbb_rf_prog->flags |= cpu_to_le16(PUT_BBP_RESET | BBP_REG_WRITE |\n\t\t\t\t\t (RSI_RF_TYPE << 4));\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_set_vap_capabilities() - This function send vap capability to firmware.\n * @common: Pointer to the driver private structure.\n * @opmode: Operating mode of device.\n *\n * Return: 0 on success, corresponding negative error code on failure.\n */\nint rsi_set_vap_capabilities(struct rsi_common *common,\n\t\t\t     enum opmode mode,\n\t\t\t     u8 *mac_addr,\n\t\t\t     u8 vap_id,\n\t\t\t     u8 vap_status)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_vap_caps *vap_caps;\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tu16 frame_len = sizeof(struct rsi_vap_caps);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending VAP capabilities frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tvap_caps = (struct rsi_vap_caps *)skb->data;\n\n\trsi_set_len_qno(&vap_caps->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tvap_caps->desc_dword0.frame_type = VAP_CAPABILITIES;\n\tvap_caps->status = vap_status;\n\tvap_caps->vif_type = mode;\n\tvap_caps->channel_bw = common->channel_width;\n\tvap_caps->vap_id = vap_id;\n\tvap_caps->radioid_macid = ((common->mac_id & 0xf) << 4) |\n\t\t\t\t   (common->radio_id & 0xf);\n\n\tmemcpy(vap_caps->mac_addr, mac_addr, IEEE80211_ADDR_LEN);\n\tvap_caps->keep_alive_period = cpu_to_le16(90);\n\tvap_caps->frag_threshold = cpu_to_le16(IEEE80211_MAX_FRAG_THRESHOLD);\n\n\tvap_caps->rts_threshold = cpu_to_le16(common->rts_threshold);\n\n\tif (common->band == NL80211_BAND_5GHZ) {\n\t\tvap_caps->default_ctrl_rate = cpu_to_le16(RSI_RATE_6);\n\t\tvap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);\n\t} else {\n\t\tvap_caps->default_ctrl_rate = cpu_to_le16(RSI_RATE_1);\n\t\tvap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_1);\n\t}\n\tif (conf_is_ht40(conf)) {\n\t\tif (conf_is_ht40_minus(conf))\n\t\t\tvap_caps->ctrl_rate_flags =\n\t\t\t\tcpu_to_le16(UPPER_20_ENABLE);\n\t\telse if (conf_is_ht40_plus(conf))\n\t\t\tvap_caps->ctrl_rate_flags =\n\t\t\t\tcpu_to_le16(LOWER_20_ENABLE);\n\t\telse\n\t\t\tvap_caps->ctrl_rate_flags =\n\t\t\t\tcpu_to_le16(FULL40M_ENABLE);\n\t}\n\n\tvap_caps->default_data_rate = 0;\n\tvap_caps->beacon_interval = cpu_to_le16(common->beacon_interval);\n\tvap_caps->dtim_period = cpu_to_le16(common->dtim_cnt);\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_hal_load_key() - This function is used to load keys within the firmware.\n * @common: Pointer to the driver private structure.\n * @data: Pointer to the key data.\n * @key_len: Key length to be loaded.\n * @key_type: Type of key: GROUP/PAIRWISE.\n * @key_id: Key index.\n * @cipher: Type of cipher used.\n *\n * Return: 0 on success, -1 on failure.\n */\nint rsi_hal_load_key(struct rsi_common *common,\n\t\t     u8 *data,\n\t\t     u16 key_len,\n\t\t     u8 key_type,\n\t\t     u8 key_id,\n\t\t     u32 cipher,\n\t\t     s16 sta_id,\n\t\t     struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_set_key *set_key;\n\tu16 key_descriptor = 0;\n\tu16 frame_len = sizeof(struct rsi_set_key);\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending load key frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tset_key = (struct rsi_set_key *)skb->data;\n\n\tif (key_type == RSI_GROUP_KEY) {\n\t\tkey_descriptor = RSI_KEY_TYPE_BROADCAST;\n\t\tif (vif->type == NL80211_IFTYPE_AP)\n\t\t\tkey_descriptor |= RSI_KEY_MODE_AP;\n\t}\n\tif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\n\t    (cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\tkey_id = 0;\n\t\tkey_descriptor |= RSI_WEP_KEY;\n\t\tif (key_len >= 13)\n\t\t\tkey_descriptor |= RSI_WEP_KEY_104;\n\t} else if (cipher != KEY_TYPE_CLEAR) {\n\t\tkey_descriptor |= RSI_CIPHER_WPA;\n\t\tif (cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\tkey_descriptor |= RSI_CIPHER_TKIP;\n\t}\n\tkey_descriptor |= RSI_PROTECT_DATA_FRAMES;\n\tkey_descriptor |= (key_id << RSI_KEY_ID_OFFSET);\n\n\trsi_set_len_qno(&set_key->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tset_key->desc_dword0.frame_type = SET_KEY_REQ;\n\tset_key->key_desc = cpu_to_le16(key_descriptor);\n\tset_key->sta_id = sta_id;\n\n\tif (data) {\n\t\tif ((cipher == WLAN_CIPHER_SUITE_WEP40) ||\n\t\t    (cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\t\tmemcpy(&set_key->key[key_id][1], data, key_len * 2);\n\t\t} else {\n\t\t\tmemcpy(&set_key->key[0][0], data, key_len);\n\t\t}\n\t\tmemcpy(set_key->tx_mic_key, &data[16], 8);\n\t\tmemcpy(set_key->rx_mic_key, &data[24], 8);\n\t} else {\n\t\tmemset(&set_key[FRAME_DESC_SZ], 0, frame_len - FRAME_DESC_SZ);\n\t}\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/*\n * This function sends the common device configuration parameters to device.\n * This frame includes the useful information to make device works on\n * specific operating mode.\n */\nstatic int rsi_send_common_dev_params(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tu16 frame_len;\n\tstruct rsi_config_vals *dev_cfgs;\n\n\tframe_len = sizeof(struct rsi_config_vals);\n\n\trsi_dbg(MGMT_TX_ZONE, \"Sending common device config params\\n\");\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to allocate skb\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\n\tdev_cfgs = (struct rsi_config_vals *)skb->data;\n\tmemset(dev_cfgs, 0, (sizeof(struct rsi_config_vals)));\n\n\trsi_set_len_qno(&dev_cfgs->len_qno, (frame_len - FRAME_DESC_SZ),\n\t\t\tRSI_COEX_Q);\n\tdev_cfgs->pkt_type = COMMON_DEV_CONFIG;\n\n\tdev_cfgs->lp_ps_handshake = common->lp_ps_handshake_mode;\n\tdev_cfgs->ulp_ps_handshake = common->ulp_ps_handshake_mode;\n\n\tdev_cfgs->unused_ulp_gpio = RSI_UNUSED_ULP_GPIO_BITMAP;\n\tdev_cfgs->unused_soc_gpio_bitmap =\n\t\t\t\tcpu_to_le32(RSI_UNUSED_SOC_GPIO_BITMAP);\n\n\tdev_cfgs->opermode = common->oper_mode;\n\tdev_cfgs->wlan_rf_pwr_mode = common->wlan_rf_power_mode;\n\tdev_cfgs->driver_mode = common->driver_mode;\n\tdev_cfgs->region_code = NL80211_DFS_FCC;\n\tdev_cfgs->antenna_sel_val = common->obm_ant_sel_val;\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/*\n * rsi_load_bootup_params() - This function send bootup params to the firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nstatic int rsi_load_bootup_params(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_boot_params *boot_params;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending boot params frame\\n\", __func__);\n\tskb = dev_alloc_skb(sizeof(struct rsi_boot_params));\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, sizeof(struct rsi_boot_params));\n\tboot_params = (struct rsi_boot_params *)skb->data;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s:\\n\", __func__);\n\n\tif (common->channel_width == BW_40MHZ) {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_40,\n\t\t       sizeof(struct bootup_params));\n\t\trsi_dbg(MGMT_TX_ZONE, \"%s: Packet 40MHZ <=== %d\\n\", __func__,\n\t\t\tUMAC_CLK_40BW);\n\t\tboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40BW);\n\t} else {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_20,\n\t\t       sizeof(struct bootup_params));\n\t\tif (boot_params_20.valid != cpu_to_le32(VALID_20)) {\n\t\t\tboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_20BW);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_20BW);\n\t\t} else {\n\t\t\tboot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40MHZ);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_40MHZ);\n\t\t}\n\t}\n\n\t/**\n\t * Bit{0:11} indicates length of the Packet\n\t * Bit{12:15} indicates host queue number\n\t */\n\tboot_params->desc_word[0] = cpu_to_le16(sizeof(struct bootup_params) |\n\t\t\t\t    (RSI_WIFI_MGMT_Q << 12));\n\tboot_params->desc_word[1] = cpu_to_le16(BOOTUP_PARAMS_REQUEST);\n\n\tskb_put(skb, sizeof(struct rsi_boot_params));\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nstatic int rsi_load_9116_bootup_params(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_boot_params_9116 *boot_params;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending boot params frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(sizeof(struct rsi_boot_params_9116));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, sizeof(struct rsi_boot_params));\n\tboot_params = (struct rsi_boot_params_9116 *)skb->data;\n\n\tif (common->channel_width == BW_40MHZ) {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_9116_40,\n\t\t       sizeof(struct bootup_params_9116));\n\t\trsi_dbg(MGMT_TX_ZONE, \"%s: Packet 40MHZ <=== %d\\n\", __func__,\n\t\t\tUMAC_CLK_40BW);\n\t\tboot_params->umac_clk = cpu_to_le16(UMAC_CLK_40BW);\n\t} else {\n\t\tmemcpy(&boot_params->bootup_params,\n\t\t       &boot_params_9116_20,\n\t\t       sizeof(struct bootup_params_9116));\n\t\tif (boot_params_20.valid != cpu_to_le32(VALID_20)) {\n\t\t\tboot_params->umac_clk = cpu_to_le16(UMAC_CLK_20BW);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_20BW);\n\t\t} else {\n\t\t\tboot_params->umac_clk = cpu_to_le16(UMAC_CLK_40MHZ);\n\t\t\trsi_dbg(MGMT_TX_ZONE,\n\t\t\t\t\"%s: Packet 20MHZ <=== %d\\n\", __func__,\n\t\t\t\tUMAC_CLK_40MHZ);\n\t\t}\n\t}\n\trsi_set_len_qno(&boot_params->desc_dword0.len_qno,\n\t\t\tsizeof(struct bootup_params_9116), RSI_WIFI_MGMT_Q);\n\tboot_params->desc_dword0.frame_type = BOOTUP_PARAMS_REQUEST;\n\tskb_put(skb, sizeof(struct rsi_boot_params_9116));\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_send_reset_mac() - This function prepares reset MAC request and sends an\n *\t\t\t  internal management frame to indicate it to firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nstatic int rsi_send_reset_mac(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_mac_frame *mgmt_frame;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending reset MAC frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tmgmt_frame = (struct rsi_mac_frame *)skb->data;\n\n\tmgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\n\tmgmt_frame->desc_word[1] = cpu_to_le16(RESET_MAC_REQ);\n\tmgmt_frame->desc_word[4] = cpu_to_le16(RETRY_COUNT << 8);\n\n#define RSI_9116_DEF_TA_AGGR\t3\n\tif (common->priv->device_model == RSI_DEV_9116)\n\t\tmgmt_frame->desc_word[3] |=\n\t\t\tcpu_to_le16(RSI_9116_DEF_TA_AGGR << 8);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_band_check() - This function programs the band\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nint rsi_band_check(struct rsi_common *common,\n\t\t   struct ieee80211_channel *curchan)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tu8 prev_bw = common->channel_width;\n\tu8 prev_ep = common->endpoint;\n\tint status = 0;\n\n\tif (common->band != curchan->band) {\n\t\tcommon->rf_reset = 1;\n\t\tcommon->band = curchan->band;\n\t}\n\n\tif ((hw->conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT) ||\n\t    (hw->conf.chandef.width == NL80211_CHAN_WIDTH_20))\n\t\tcommon->channel_width = BW_20MHZ;\n\telse\n\t\tcommon->channel_width = BW_40MHZ;\n\n\tif (common->band == NL80211_BAND_2GHZ) {\n\t\tif (common->channel_width)\n\t\t\tcommon->endpoint = EP_2GHZ_40MHZ;\n\t\telse\n\t\t\tcommon->endpoint = EP_2GHZ_20MHZ;\n\t} else {\n\t\tif (common->channel_width)\n\t\t\tcommon->endpoint = EP_5GHZ_40MHZ;\n\t\telse\n\t\t\tcommon->endpoint = EP_5GHZ_20MHZ;\n\t}\n\n\tif (common->endpoint != prev_ep) {\n\t\tstatus = rsi_program_bb_rf(common);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (common->channel_width != prev_bw) {\n\t\tif (adapter->device_model == RSI_DEV_9116)\n\t\t\tstatus = rsi_load_9116_bootup_params(common);\n\t\telse\n\t\t\tstatus = rsi_load_bootup_params(common);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tstatus = rsi_load_radio_caps(common);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\n/**\n * rsi_set_channel() - This function programs the channel.\n * @common: Pointer to the driver private structure.\n * @channel: Channel value to be set.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nint rsi_set_channel(struct rsi_common *common,\n\t\t    struct ieee80211_channel *channel)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rsi_chan_config *chan_cfg;\n\tu16 frame_len = sizeof(struct rsi_chan_config);\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending scan req frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!channel) {\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\n\t}\n\tmemset(skb->data, 0, frame_len);\n\tchan_cfg = (struct rsi_chan_config *)skb->data;\n\n\trsi_set_len_qno(&chan_cfg->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\tchan_cfg->desc_dword0.frame_type = SCAN_REQUEST;\n\tchan_cfg->channel_number = channel->hw_value;\n\tchan_cfg->antenna_gain_offset_2g = channel->max_antenna_gain;\n\tchan_cfg->antenna_gain_offset_5g = channel->max_antenna_gain;\n\tchan_cfg->region_rftype = (RSI_RF_TYPE & 0xf) << 4;\n\n\tif ((channel->flags & IEEE80211_CHAN_NO_IR) ||\n\t    (channel->flags & IEEE80211_CHAN_RADAR)) {\n\t\tchan_cfg->antenna_gain_offset_2g |= RSI_CHAN_RADAR;\n\t} else {\n\t\tif (common->tx_power < channel->max_power)\n\t\t\tchan_cfg->tx_power = cpu_to_le16(common->tx_power);\n\t\telse\n\t\t\tchan_cfg->tx_power = cpu_to_le16(channel->max_power);\n\t}\n\tchan_cfg->region_rftype |= (common->priv->dfs_region & 0xf);\n\n\tif (common->channel_width == BW_40MHZ)\n\t\tchan_cfg->channel_width = 0x1;\n\n\tcommon->channel = channel->hw_value;\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_send_radio_params_update() - This function sends the radio\n *\t\t\t\tparameters update to device\n * @common: Pointer to the driver private structure.\n * @channel: Channel value to be set.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nint rsi_send_radio_params_update(struct rsi_common *common)\n{\n\tstruct rsi_mac_frame *cmd_frame;\n\tstruct sk_buff *skb = NULL;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending Radio Params update frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tcmd_frame = (struct rsi_mac_frame *)skb->data;\n\n\tcmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\n\tcmd_frame->desc_word[1] = cpu_to_le16(RADIO_PARAMS_UPDATE);\n\tcmd_frame->desc_word[3] = cpu_to_le16(BIT(0));\n\n\tcmd_frame->desc_word[3] |= cpu_to_le16(common->tx_power << 8);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/* This function programs the threshold. */\nint rsi_send_vap_dynamic_update(struct rsi_common *common)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_dynamic_s *dynamic_frame;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending vap update indication frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(sizeof(struct rsi_dynamic_s));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, sizeof(struct rsi_dynamic_s));\n\tdynamic_frame = (struct rsi_dynamic_s *)skb->data;\n\trsi_set_len_qno(&dynamic_frame->desc_dword0.len_qno,\n\t\t\tsizeof(dynamic_frame->frame_body), RSI_WIFI_MGMT_Q);\n\n\tdynamic_frame->desc_dword0.frame_type = VAP_DYNAMIC_UPDATE;\n\tdynamic_frame->desc_dword2.pkt_info =\n\t\t\t\t\tcpu_to_le32(common->rts_threshold);\n\n\tif (common->wow_flags & RSI_WOW_ENABLED) {\n\t\t/* Beacon miss threshold */\n\t\tdynamic_frame->desc_dword3.token =\n\t\t\t\t\tcpu_to_le16(RSI_BCN_MISS_THRESHOLD);\n\t\tdynamic_frame->frame_body.keep_alive_period =\n\t\t\t\t\tcpu_to_le16(RSI_WOW_KEEPALIVE);\n\t} else {\n\t\tdynamic_frame->frame_body.keep_alive_period =\n\t\t\t\t\tcpu_to_le16(RSI_DEF_KEEPALIVE);\n\t}\n\n\tdynamic_frame->desc_dword3.sta_id = 0; /* vap id */\n\n\tskb_put(skb, sizeof(struct rsi_dynamic_s));\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_compare() - This function is used to compare two integers\n * @a: pointer to the first integer\n * @b: pointer to the second integer\n *\n * Return: 0 if both are equal, -1 if the first is smaller, else 1\n */\nstatic int rsi_compare(const void *a, const void *b)\n{\n\tu16 _a = *(const u16 *)(a);\n\tu16 _b = *(const u16 *)(b);\n\n\tif (_a > _b)\n\t\treturn -1;\n\n\tif (_a < _b)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * rsi_map_rates() - This function is used to map selected rates to hw rates.\n * @rate: The standard rate to be mapped.\n * @offset: Offset that will be returned.\n *\n * Return: 0 if it is a mcs rate, else 1\n */\nstatic bool rsi_map_rates(u16 rate, int *offset)\n{\n\tint kk;\n\tfor (kk = 0; kk < ARRAY_SIZE(rsi_mcsrates); kk++) {\n\t\tif (rate == mcs[kk]) {\n\t\t\t*offset = kk;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (kk = 0; kk < ARRAY_SIZE(rsi_rates); kk++) {\n\t\tif (rate == rsi_rates[kk].bitrate / 5) {\n\t\t\t*offset = kk;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * rsi_send_auto_rate_request() - This function is to set rates for connection\n *\t\t\t\t  and send autorate request to firmware.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, corresponding error code on failure.\n */\nstatic int rsi_send_auto_rate_request(struct rsi_common *common,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      u16 sta_id,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb;\n\tstruct rsi_auto_rate *auto_rate;\n\tint ii = 0, jj = 0, kk = 0;\n\tstruct ieee80211_hw *hw = common->priv->hw;\n\tu8 band = hw->conf.chandef.chan->band;\n\tu8 num_supported_rates = 0;\n\tu8 rate_table_offset, rate_offset = 0;\n\tu32 rate_bitmap;\n\tu16 *selected_rates, min_rate;\n\tbool is_ht = false, is_sgi = false;\n\tu16 frame_len = sizeof(struct rsi_auto_rate);\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending auto rate request frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, frame_len);\n\tselected_rates = kzalloc(2 * RSI_TBL_SZ, GFP_KERNEL);\n\tif (!selected_rates) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of mem\\n\",\n\t\t\t__func__);\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tauto_rate = (struct rsi_auto_rate *)skb->data;\n\n\tauto_rate->aarf_rssi = cpu_to_le16(((u16)3 << 6) | (u16)(18 & 0x3f));\n\tauto_rate->collision_tolerance = cpu_to_le16(3);\n\tauto_rate->failure_limit = cpu_to_le16(3);\n\tauto_rate->initial_boundary = cpu_to_le16(3);\n\tauto_rate->max_threshold_limt = cpu_to_le16(27);\n\n\tauto_rate->desc.desc_dword0.frame_type = AUTO_RATE_IND;\n\n\tif (common->channel_width == BW_40MHZ)\n\t\tauto_rate->desc.desc_dword3.qid_tid = BW_40MHZ;\n\tauto_rate->desc.desc_dword3.sta_id = sta_id;\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\trate_bitmap = common->bitrate_mask[band];\n\t\tis_ht = common->vif_info[0].is_ht;\n\t\tis_sgi = common->vif_info[0].sgi;\n\t} else {\n\t\trate_bitmap = sta->supp_rates[band];\n\t\tis_ht = sta->ht_cap.ht_supported;\n\t\tif ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||\n\t\t    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\tis_sgi = true;\n\t}\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tif ((rate_bitmap == 0) && (is_ht))\n\t\t\tmin_rate = RSI_RATE_MCS0;\n\t\telse\n\t\t\tmin_rate = RSI_RATE_1;\n\t\trate_table_offset = 0;\n\t} else {\n\t\tif ((rate_bitmap == 0) && (is_ht))\n\t\t\tmin_rate = RSI_RATE_MCS0;\n\t\telse\n\t\t\tmin_rate = RSI_RATE_6;\n\t\trate_table_offset = 4;\n\t}\n\n\tfor (ii = 0, jj = 0;\n\t     ii < (ARRAY_SIZE(rsi_rates) - rate_table_offset); ii++) {\n\t\tif (rate_bitmap & BIT(ii)) {\n\t\t\tselected_rates[jj++] =\n\t\t\t(rsi_rates[ii + rate_table_offset].bitrate / 5);\n\t\t\trate_offset++;\n\t\t}\n\t}\n\tnum_supported_rates = jj;\n\n\tif (is_ht) {\n\t\tfor (ii = 0; ii < ARRAY_SIZE(mcs); ii++)\n\t\t\tselected_rates[jj++] = mcs[ii];\n\t\tnum_supported_rates += ARRAY_SIZE(mcs);\n\t\trate_offset += ARRAY_SIZE(mcs);\n\t}\n\n\tsort(selected_rates, jj, sizeof(u16), &rsi_compare, NULL);\n\n\t/* mapping the rates to RSI rates */\n\tfor (ii = 0; ii < jj; ii++) {\n\t\tif (rsi_map_rates(selected_rates[ii], &kk)) {\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_rates[kk].hw_value);\n\t\t} else {\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_mcsrates[kk]);\n\t\t}\n\t}\n\n\t/* loading HT rates in the bottom half of the auto rate table */\n\tif (is_ht) {\n\t\tfor (ii = rate_offset, kk = ARRAY_SIZE(rsi_mcsrates) - 1;\n\t\t     ii < rate_offset + 2 * ARRAY_SIZE(rsi_mcsrates); ii++) {\n\t\t\tif (is_sgi || conf_is_ht40(&common->priv->hw->conf))\n\t\t\t\tauto_rate->supported_rates[ii++] =\n\t\t\t\t\tcpu_to_le16(rsi_mcsrates[kk] | BIT(9));\n\t\t\telse\n\t\t\t\tauto_rate->supported_rates[ii++] =\n\t\t\t\t\tcpu_to_le16(rsi_mcsrates[kk]);\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_mcsrates[kk--]);\n\t\t}\n\n\t\tfor (; ii < (RSI_TBL_SZ - 1); ii++) {\n\t\t\tauto_rate->supported_rates[ii] =\n\t\t\t\tcpu_to_le16(rsi_mcsrates[0]);\n\t\t}\n\t}\n\n\tfor (; ii < RSI_TBL_SZ; ii++)\n\t\tauto_rate->supported_rates[ii] = cpu_to_le16(min_rate);\n\n\tauto_rate->num_supported_rates = cpu_to_le16(num_supported_rates * 2);\n\tauto_rate->moderate_rate_inx = cpu_to_le16(num_supported_rates / 2);\n\tnum_supported_rates *= 2;\n\n\trsi_set_len_qno(&auto_rate->desc.desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\n\tskb_put(skb, frame_len);\n\tkfree(selected_rates);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_inform_bss_status() - This function informs about bss status with the\n *\t\t\t     help of sta notify params by sending an internal\n *\t\t\t     management frame to firmware.\n * @common: Pointer to the driver private structure.\n * @status: Bss status type.\n * @bssid: Bssid.\n * @qos_enable: Qos is enabled.\n * @aid: Aid (unique for all STAs).\n *\n * Return: None.\n */\nvoid rsi_inform_bss_status(struct rsi_common *common,\n\t\t\t   enum opmode opmode,\n\t\t\t   u8 status,\n\t\t\t   const u8 *addr,\n\t\t\t   u8 qos_enable,\n\t\t\t   u16 aid,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   u16 sta_id,\n\t\t\t   u16 assoc_cap,\n\t\t\t   struct ieee80211_vif *vif)\n{\n\tif (status) {\n\t\tif (opmode == RSI_OPMODE_STA)\n\t\t\tcommon->hw_data_qs_blocked = true;\n\t\trsi_hal_send_sta_notify_frame(common,\n\t\t\t\t\t      opmode,\n\t\t\t\t\t      STA_CONNECTED,\n\t\t\t\t\t      addr,\n\t\t\t\t\t      qos_enable,\n\t\t\t\t\t      aid, sta_id,\n\t\t\t\t\t      vif);\n\t\tif (common->min_rate == 0xffff)\n\t\t\trsi_send_auto_rate_request(common, sta, sta_id, vif);\n\t\tif (opmode == RSI_OPMODE_STA &&\n\t\t    !(assoc_cap & WLAN_CAPABILITY_PRIVACY) &&\n\t\t    !rsi_send_block_unblock_frame(common, false))\n\t\t\tcommon->hw_data_qs_blocked = false;\n\t} else {\n\t\tif (opmode == RSI_OPMODE_STA)\n\t\t\tcommon->hw_data_qs_blocked = true;\n\n\t\tif (!(common->wow_flags & RSI_WOW_ENABLED))\n\t\t\trsi_hal_send_sta_notify_frame(common, opmode,\n\t\t\t\t\t\t      STA_DISCONNECTED, addr,\n\t\t\t\t\t\t      qos_enable, aid, sta_id,\n\t\t\t\t\t\t      vif);\n\t\tif (opmode == RSI_OPMODE_STA)\n\t\t\trsi_send_block_unblock_frame(common, true);\n\t}\n}\n\n/**\n * rsi_eeprom_read() - This function sends a frame to read the mac address\n *\t\t       from the eeprom.\n * @common: Pointer to the driver private structure.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_eeprom_read(struct rsi_common *common)\n{\n\tstruct rsi_eeprom_read_frame *mgmt_frame;\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending EEPROM read req frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tmgmt_frame = (struct rsi_eeprom_read_frame *)skb->data;\n\n\t/* FrameType */\n\trsi_set_len_qno(&mgmt_frame->len_qno, 0, RSI_WIFI_MGMT_Q);\n\tmgmt_frame->pkt_type = EEPROM_READ;\n\n\t/* Number of bytes to read */\n\tmgmt_frame->pkt_info =\n\t\tcpu_to_le32((adapter->eeprom.length << RSI_EEPROM_LEN_OFFSET) &\n\t\t\t    RSI_EEPROM_LEN_MASK);\n\tmgmt_frame->pkt_info |= cpu_to_le32((3 << RSI_EEPROM_HDR_SIZE_OFFSET) &\n\t\t\t\t\t    RSI_EEPROM_HDR_SIZE_MASK);\n\n\t/* Address to read */\n\tmgmt_frame->eeprom_offset = cpu_to_le32(adapter->eeprom.offset);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * This function sends a frame to block/unblock\n * data queues in the firmware\n *\n * @param common Pointer to the driver private structure.\n * @param block event - block if true, unblock if false\n * @return 0 on success, -1 on failure.\n */\nint rsi_send_block_unblock_frame(struct rsi_common *common, bool block_event)\n{\n\tstruct rsi_block_unblock_data *mgmt_frame;\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending block/unblock frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tmgmt_frame = (struct rsi_block_unblock_data *)skb->data;\n\n\trsi_set_len_qno(&mgmt_frame->desc_dword0.len_qno, 0, RSI_WIFI_MGMT_Q);\n\tmgmt_frame->desc_dword0.frame_type = BLOCK_HW_QUEUE;\n\tmgmt_frame->host_quiet_info = QUIET_INFO_VALID;\n\n\tif (block_event) {\n\t\trsi_dbg(INFO_ZONE, \"blocking the data qs\\n\");\n\t\tmgmt_frame->block_q_bitmap = cpu_to_le16(0xf);\n\t\tmgmt_frame->block_q_bitmap |= cpu_to_le16(0xf << 4);\n\t} else {\n\t\trsi_dbg(INFO_ZONE, \"unblocking the data qs\\n\");\n\t\tmgmt_frame->unblock_q_bitmap = cpu_to_le16(0xf);\n\t\tmgmt_frame->unblock_q_bitmap |= cpu_to_le16(0xf << 4);\n\t}\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_send_rx_filter_frame() - Sends a frame to filter the RX packets\n *\n * @common: Pointer to the driver private structure.\n * @rx_filter_word: Flags of filter packets\n *\n * @Return: 0 on success, -1 on failure.\n */\nint rsi_send_rx_filter_frame(struct rsi_common *common, u16 rx_filter_word)\n{\n\tstruct rsi_mac_frame *cmd_frame;\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE, \"Sending RX filter frame\\n\");\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\tcmd_frame = (struct rsi_mac_frame *)skb->data;\n\n\tcmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);\n\tcmd_frame->desc_word[1] = cpu_to_le16(SET_RX_FILTER);\n\tcmd_frame->desc_word[4] = cpu_to_le16(rx_filter_word);\n\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nint rsi_send_ps_request(struct rsi_hw *adapter, bool enable,\n\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_bss_conf *bss = &vif->bss_conf;\n\tstruct rsi_request_ps *ps;\n\tstruct rsi_ps_info *ps_info;\n\tstruct sk_buff *skb;\n\tint frame_len = sizeof(*ps);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len);\n\n\tps = (struct rsi_request_ps *)skb->data;\n\tps_info = &adapter->ps_info;\n\n\trsi_set_len_qno(&ps->desc.desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tps->desc.desc_dword0.frame_type = WAKEUP_SLEEP_REQUEST;\n\tif (enable) {\n\t\tps->ps_sleep.enable = RSI_PS_ENABLE;\n\t\tps->desc.desc_dword3.token = cpu_to_le16(RSI_SLEEP_REQUEST);\n\t} else {\n\t\tps->ps_sleep.enable = RSI_PS_DISABLE;\n\t\tps->desc.desc_dword0.len_qno |= cpu_to_le16(RSI_PS_DISABLE_IND);\n\t\tps->desc.desc_dword3.token = cpu_to_le16(RSI_WAKEUP_REQUEST);\n\t}\n\n\tps->ps_uapsd_acs = common->uapsd_bitmap;\n\n\tps->ps_sleep.sleep_type = ps_info->sleep_type;\n\tps->ps_sleep.num_bcns_per_lis_int =\n\t\tcpu_to_le16(ps_info->num_bcns_per_lis_int);\n\tps->ps_sleep.sleep_duration =\n\t\tcpu_to_le32(ps_info->deep_sleep_wakeup_period);\n\n\tif (bss->assoc)\n\t\tps->ps_sleep.connected_sleep = RSI_CONNECTED_SLEEP;\n\telse\n\t\tps->ps_sleep.connected_sleep = RSI_DEEP_SLEEP;\n\n\tps->ps_listen_interval = cpu_to_le32(ps_info->listen_interval);\n\tps->ps_dtim_interval_duration =\n\t\tcpu_to_le32(ps_info->dtim_interval_duration);\n\n\tif (ps_info->listen_interval > ps_info->dtim_interval_duration)\n\t\tps->ps_listen_interval = cpu_to_le32(RSI_PS_DISABLE);\n\n\tps->ps_num_dtim_intervals = cpu_to_le16(ps_info->num_dtims_per_sleep);\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nstatic int rsi_send_w9116_features(struct rsi_common *common)\n{\n\tstruct rsi_wlan_9116_features *w9116_features;\n\tu16 frame_len = sizeof(struct rsi_wlan_9116_features);\n\tstruct sk_buff *skb;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending wlan 9116 features\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len);\n\n\tw9116_features = (struct rsi_wlan_9116_features *)skb->data;\n\n\tw9116_features->pll_mode = common->w9116_features.pll_mode;\n\tw9116_features->rf_type = common->w9116_features.rf_type;\n\tw9116_features->wireless_mode = common->w9116_features.wireless_mode;\n\tw9116_features->enable_ppe = common->w9116_features.enable_ppe;\n\tw9116_features->afe_type = common->w9116_features.afe_type;\n\tif (common->w9116_features.dpd)\n\t\tw9116_features->feature_enable |= cpu_to_le32(RSI_DPD);\n\tif (common->w9116_features.sifs_tx_enable)\n\t\tw9116_features->feature_enable |=\n\t\t\tcpu_to_le32(RSI_SIFS_TX_ENABLE);\n\tif (common->w9116_features.ps_options & RSI_DUTY_CYCLING)\n\t\tw9116_features->feature_enable |= cpu_to_le32(RSI_DUTY_CYCLING);\n\tif (common->w9116_features.ps_options & RSI_END_OF_FRAME)\n\t\tw9116_features->feature_enable |= cpu_to_le32(RSI_END_OF_FRAME);\n\tw9116_features->feature_enable |=\n\t\tcpu_to_le32((common->w9116_features.ps_options & ~0x3) << 2);\n\n\trsi_set_len_qno(&w9116_features->desc.desc_dword0.len_qno,\n\t\t\tframe_len - FRAME_DESC_SZ, RSI_WIFI_MGMT_Q);\n\tw9116_features->desc.desc_dword0.frame_type = FEATURES_ENABLE;\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_set_antenna() - This function send antenna configuration request\n *\t\t       to device\n *\n * @common: Pointer to the driver private structure.\n * @antenna: bitmap for tx antenna selection\n *\n * Return: 0 on Success, negative error code on failure\n */\nint rsi_set_antenna(struct rsi_common *common, u8 antenna)\n{\n\tstruct rsi_ant_sel_frame *ant_sel_frame;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(FRAME_DESC_SZ);\n\tif (!skb) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of skb\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(skb->data, 0, FRAME_DESC_SZ);\n\n\tant_sel_frame = (struct rsi_ant_sel_frame *)skb->data;\n\tant_sel_frame->desc_dword0.frame_type = ANT_SEL_FRAME;\n\tant_sel_frame->sub_frame_type = ANTENNA_SEL_TYPE;\n\tant_sel_frame->ant_value = cpu_to_le16(antenna & ANTENNA_MASK_VALUE);\n\trsi_set_len_qno(&ant_sel_frame->desc_dword0.len_qno,\n\t\t\t0, RSI_WIFI_MGMT_Q);\n\tskb_put(skb, FRAME_DESC_SZ);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\nstatic int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nint rsi_send_wowlan_request(struct rsi_common *common, u16 flags,\n\t\t\t    u16 sleep_status)\n{\n\tstruct rsi_wowlan_req *cmd_frame;\n\tstruct sk_buff *skb;\n\tu8 length;\n\n\trsi_dbg(ERR_ZONE, \"%s: Sending wowlan request frame\\n\", __func__);\n\n\tlength = sizeof(*cmd_frame);\n\tskb = dev_alloc_skb(length);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, length);\n\tcmd_frame = (struct rsi_wowlan_req *)skb->data;\n\n\trsi_set_len_qno(&cmd_frame->desc.desc_dword0.len_qno,\n\t\t\t(length - FRAME_DESC_SZ),\n\t\t\tRSI_WIFI_MGMT_Q);\n\tcmd_frame->desc.desc_dword0.frame_type = WOWLAN_CONFIG_PARAMS;\n\tcmd_frame->host_sleep_status = sleep_status;\n\tif (common->secinfo.security_enable &&\n\t    common->secinfo.gtk_cipher)\n\t\tflags |= RSI_WOW_GTK_REKEY;\n\tif (sleep_status)\n\t\tcmd_frame->wow_flags = flags;\n\trsi_dbg(INFO_ZONE, \"Host_Sleep_Status : %d Flags : %d\\n\",\n\t\tcmd_frame->host_sleep_status, cmd_frame->wow_flags);\n\n\tskb_put(skb, length);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n#endif\n\nint rsi_send_bgscan_params(struct rsi_common *common, int enable)\n{\n\tstruct rsi_bgscan_params *params = &common->bgscan;\n\tstruct cfg80211_scan_request *scan_req = common->hwscan;\n\tstruct rsi_bgscan_config *bgscan;\n\tstruct sk_buff *skb;\n\tu16 frame_len = sizeof(*bgscan);\n\tu8 i;\n\n\trsi_dbg(MGMT_TX_ZONE, \"%s: Sending bgscan params frame\\n\", __func__);\n\n\tskb = dev_alloc_skb(frame_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len);\n\n\tbgscan = (struct rsi_bgscan_config *)skb->data;\n\trsi_set_len_qno(&bgscan->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ), RSI_WIFI_MGMT_Q);\n\tbgscan->desc_dword0.frame_type = BG_SCAN_PARAMS;\n\tbgscan->bgscan_threshold = cpu_to_le16(params->bgscan_threshold);\n\tbgscan->roam_threshold = cpu_to_le16(params->roam_threshold);\n\tif (enable)\n\t\tbgscan->bgscan_periodicity =\n\t\t\tcpu_to_le16(params->bgscan_periodicity);\n\tbgscan->active_scan_duration =\n\t\t\tcpu_to_le16(params->active_scan_duration);\n\tbgscan->passive_scan_duration =\n\t\t\tcpu_to_le16(params->passive_scan_duration);\n\tbgscan->two_probe = params->two_probe;\n\n\tbgscan->num_bgscan_channels = scan_req->n_channels;\n\tfor (i = 0; i < bgscan->num_bgscan_channels; i++)\n\t\tbgscan->channels2scan[i] =\n\t\t\tcpu_to_le16(scan_req->channels[i]->hw_value);\n\n\tskb_put(skb, frame_len);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/* This function sends the probe request to be used by firmware in\n * background scan\n */\nint rsi_send_bgscan_probe_req(struct rsi_common *common,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct cfg80211_scan_request *scan_req = common->hwscan;\n\tstruct rsi_bgscan_probe *bgscan;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *probereq_skb;\n\tu16 frame_len = sizeof(*bgscan);\n\tsize_t ssid_len = 0;\n\tu8 *ssid = NULL;\n\n\trsi_dbg(MGMT_TX_ZONE,\n\t\t\"%s: Sending bgscan probe req frame\\n\", __func__);\n\n\tif (common->priv->sc_nvifs <= 0)\n\t\treturn -ENODEV;\n\n\tif (scan_req->n_ssids) {\n\t\tssid = scan_req->ssids[0].ssid;\n\t\tssid_len = scan_req->ssids[0].ssid_len;\n\t}\n\n\tskb = dev_alloc_skb(frame_len + MAX_BGSCAN_PROBE_REQ_LEN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, frame_len + MAX_BGSCAN_PROBE_REQ_LEN);\n\n\tbgscan = (struct rsi_bgscan_probe *)skb->data;\n\tbgscan->desc_dword0.frame_type = BG_SCAN_PROBE_REQ;\n\tbgscan->flags = cpu_to_le16(HOST_BG_SCAN_TRIG);\n\tif (common->band == NL80211_BAND_5GHZ) {\n\t\tbgscan->mgmt_rate = cpu_to_le16(RSI_RATE_6);\n\t\tbgscan->def_chan = cpu_to_le16(40);\n\t} else {\n\t\tbgscan->mgmt_rate = cpu_to_le16(RSI_RATE_1);\n\t\tbgscan->def_chan = cpu_to_le16(11);\n\t}\n\tbgscan->channel_scan_time = cpu_to_le16(RSI_CHANNEL_SCAN_TIME);\n\n\tprobereq_skb = ieee80211_probereq_get(common->priv->hw, vif->addr, ssid,\n\t\t\t\t\t      ssid_len, scan_req->ie_len);\n\tif (!probereq_skb) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&skb->data[frame_len], probereq_skb->data, probereq_skb->len);\n\n\tbgscan->probe_req_length = cpu_to_le16(probereq_skb->len);\n\n\trsi_set_len_qno(&bgscan->desc_dword0.len_qno,\n\t\t\t(frame_len - FRAME_DESC_SZ + probereq_skb->len),\n\t\t\tRSI_WIFI_MGMT_Q);\n\n\tskb_put(skb, frame_len + probereq_skb->len);\n\n\tdev_kfree_skb(probereq_skb);\n\n\treturn rsi_send_internal_mgmt_frame(common, skb);\n}\n\n/**\n * rsi_handle_ta_confirm_type() - This function handles the confirm frames.\n * @common: Pointer to the driver private structure.\n * @msg: Pointer to received packet.\n *\n * Return: 0 on success, -1 on failure.\n */\nstatic int rsi_handle_ta_confirm_type(struct rsi_common *common,\n\t\t\t\t      u8 *msg)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tu8 sub_type = (msg[15] & 0xff);\n\tu16 msg_len = ((u16 *)msg)[0] & 0xfff;\n\tu8 offset;\n\n\tswitch (sub_type) {\n\tcase BOOTUP_PARAMS_REQUEST:\n\t\trsi_dbg(FSM_ZONE, \"%s: Boot up params confirm received\\n\",\n\t\t\t__func__);\n\t\tif (common->fsm_state == FSM_BOOT_PARAMS_SENT) {\n\t\t\tif (adapter->device_model == RSI_DEV_9116) {\n\t\t\t\tcommon->band = NL80211_BAND_5GHZ;\n\t\t\t\tcommon->num_supp_bands = 2;\n\n\t\t\t\tif (rsi_send_reset_mac(common))\n\t\t\t\t\tgoto out;\n\t\t\t\telse\n\t\t\t\t\tcommon->fsm_state = FSM_RESET_MAC_SENT;\n\t\t\t} else {\n\t\t\t\tadapter->eeprom.length =\n\t\t\t\t\t(IEEE80211_ADDR_LEN +\n\t\t\t\t\t WLAN_MAC_MAGIC_WORD_LEN +\n\t\t\t\t\t WLAN_HOST_MODE_LEN);\n\t\t\t\tadapter->eeprom.offset = WLAN_MAC_EEPROM_ADDR;\n\t\t\t\tif (rsi_eeprom_read(common)) {\n\t\t\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcommon->fsm_state = FSM_EEPROM_READ_MAC_ADDR;\n\t\t\t}\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Received bootup params cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase EEPROM_READ:\n\t\trsi_dbg(FSM_ZONE, \"EEPROM READ confirm received\\n\");\n\t\tif (msg_len <= 0) {\n\t\t\trsi_dbg(FSM_ZONE,\n\t\t\t\t\"%s: [EEPROM_READ] Invalid len %d\\n\",\n\t\t\t\t__func__, msg_len);\n\t\t\tgoto out;\n\t\t}\n\t\tif (msg[16] != MAGIC_WORD) {\n\t\t\trsi_dbg(FSM_ZONE,\n\t\t\t\t\"%s: [EEPROM_READ] Invalid token\\n\", __func__);\n\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (common->fsm_state == FSM_EEPROM_READ_MAC_ADDR) {\n\t\t\toffset = (FRAME_DESC_SZ + WLAN_HOST_MODE_LEN +\n\t\t\t\t  WLAN_MAC_MAGIC_WORD_LEN);\n\t\t\tmemcpy(common->mac_addr, &msg[offset], ETH_ALEN);\n\t\t\tadapter->eeprom.length =\n\t\t\t\t((WLAN_MAC_MAGIC_WORD_LEN + 3) & (~3));\n\t\t\tadapter->eeprom.offset = WLAN_EEPROM_RFTYPE_ADDR;\n\t\t\tif (rsi_eeprom_read(common)) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: Failed reading RF band\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcommon->fsm_state = FSM_EEPROM_READ_RF_TYPE;\n\t\t} else if (common->fsm_state == FSM_EEPROM_READ_RF_TYPE) {\n\t\t\tif ((msg[17] & 0x3) == 0x3) {\n\t\t\t\trsi_dbg(INIT_ZONE, \"Dual band supported\\n\");\n\t\t\t\tcommon->band = NL80211_BAND_5GHZ;\n\t\t\t\tcommon->num_supp_bands = 2;\n\t\t\t} else if ((msg[17] & 0x3) == 0x1) {\n\t\t\t\trsi_dbg(INIT_ZONE,\n\t\t\t\t\t\"Only 2.4Ghz band supported\\n\");\n\t\t\t\tcommon->band = NL80211_BAND_2GHZ;\n\t\t\t\tcommon->num_supp_bands = 1;\n\t\t\t}\n\t\t\tif (rsi_send_reset_mac(common))\n\t\t\t\tgoto out;\n\t\t\tcommon->fsm_state = FSM_RESET_MAC_SENT;\n\t\t} else {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Invalid EEPROM read type\\n\",\n\t\t\t\t__func__);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase RESET_MAC_REQ:\n\t\tif (common->fsm_state == FSM_RESET_MAC_SENT) {\n\t\t\trsi_dbg(FSM_ZONE, \"%s: Reset MAC cfm received\\n\",\n\t\t\t\t__func__);\n\n\t\t\tif (rsi_load_radio_caps(common))\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tcommon->fsm_state = FSM_RADIO_CAPS_SENT;\n\t\t} else {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Received reset mac cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase RADIO_CAPABILITIES:\n\t\tif (common->fsm_state == FSM_RADIO_CAPS_SENT) {\n\t\t\tcommon->rf_reset = 1;\n\t\t\tif (adapter->device_model == RSI_DEV_9116 &&\n\t\t\t    rsi_send_w9116_features(common)) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"Failed to send 9116 features\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (rsi_program_bb_rf(common)) {\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tcommon->fsm_state = FSM_BB_RF_PROG_SENT;\n\t\t\t\trsi_dbg(FSM_ZONE, \"%s: Radio cap cfm received\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Received radio caps cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase BB_PROG_VALUES_REQUEST:\n\tcase RF_PROG_VALUES_REQUEST:\n\tcase BBP_PROG_IN_TA:\n\t\trsi_dbg(FSM_ZONE, \"%s: BB/RF cfm received\\n\", __func__);\n\t\tif (common->fsm_state == FSM_BB_RF_PROG_SENT) {\n\t\t\tcommon->bb_rf_prog_count--;\n\t\t\tif (!common->bb_rf_prog_count) {\n\t\t\t\tcommon->fsm_state = FSM_MAC_INIT_DONE;\n\t\t\t\tif (common->reinit_hw) {\n\t\t\t\t\tcomplete(&common->wlan_init_completion);\n\t\t\t\t} else {\n\t\t\t\t\treturn rsi_mac80211_attach(common);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Received bbb_rf cfm in %d state\\n\",\n\t\t\t\t __func__, common->fsm_state);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase SCAN_REQUEST:\n\t\trsi_dbg(INFO_ZONE, \"Set channel confirm\\n\");\n\t\tbreak;\n\n\tcase WAKEUP_SLEEP_REQUEST:\n\t\trsi_dbg(INFO_ZONE, \"Wakeup/Sleep confirmation.\\n\");\n\t\treturn rsi_handle_ps_confirm(adapter, msg);\n\n\tcase BG_SCAN_PROBE_REQ:\n\t\trsi_dbg(INFO_ZONE, \"BG scan complete event\\n\");\n\t\tif (common->bgscan_en) {\n\t\t\tstruct cfg80211_scan_info info;\n\n\t\t\tif (!rsi_send_bgscan_params(common, RSI_STOP_BGSCAN))\n\t\t\t\tcommon->bgscan_en = 0;\n\t\t\tinfo.aborted = false;\n\t\t\tieee80211_scan_completed(adapter->hw, &info);\n\t\t}\n\t\trsi_dbg(INFO_ZONE, \"Background scan completed\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\trsi_dbg(INFO_ZONE, \"%s: Invalid TA confirm pkt received\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\treturn 0;\nout:\n\trsi_dbg(ERR_ZONE, \"%s: Unable to send pkt/Invalid frame received\\n\",\n\t\t__func__);\n\treturn -EINVAL;\n}\n\nint rsi_handle_card_ready(struct rsi_common *common, u8 *msg)\n{\n\tint status;\n\n\tswitch (common->fsm_state) {\n\tcase FSM_CARD_NOT_READY:\n\t\trsi_dbg(INIT_ZONE, \"Card ready indication from Common HAL\\n\");\n\t\trsi_set_default_parameters(common);\n\t\tif (rsi_send_common_dev_params(common) < 0)\n\t\t\treturn -EINVAL;\n\t\tcommon->fsm_state = FSM_COMMON_DEV_PARAMS_SENT;\n\t\tbreak;\n\tcase FSM_COMMON_DEV_PARAMS_SENT:\n\t\trsi_dbg(INIT_ZONE, \"Card ready indication from WLAN HAL\\n\");\n\n\t\tif (common->priv->device_model == RSI_DEV_9116) {\n\t\t\tif (msg[16] != MAGIC_WORD) {\n\t\t\t\trsi_dbg(FSM_ZONE,\n\t\t\t\t\t\"%s: [EEPROM_READ] Invalid token\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmemcpy(common->mac_addr, &msg[20], ETH_ALEN);\n\t\t\trsi_dbg(INIT_ZONE, \"MAC Addr %pM\", common->mac_addr);\n\t\t}\n\t\t/* Get usb buffer status register address */\n\t\tcommon->priv->usb_buffer_status_reg = *(u32 *)&msg[8];\n\t\trsi_dbg(INFO_ZONE, \"USB buffer status register = %x\\n\",\n\t\t\tcommon->priv->usb_buffer_status_reg);\n\n\t\tif (common->priv->device_model == RSI_DEV_9116)\n\t\t\tstatus = rsi_load_9116_bootup_params(common);\n\t\telse\n\t\t\tstatus = rsi_load_bootup_params(common);\n\t\tif (status < 0) {\n\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\t\t\treturn status;\n\t\t}\n\t\tcommon->fsm_state = FSM_BOOT_PARAMS_SENT;\n\t\tbreak;\n\tdefault:\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: card ready indication in invalid state %d.\\n\",\n\t\t\t__func__, common->fsm_state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * rsi_mgmt_pkt_recv() - This function processes the management packets\n *\t\t\t received from the hardware.\n * @common: Pointer to the driver private structure.\n * @msg: Pointer to the received packet.\n *\n * Return: 0 on success, -1 on failure.\n */\nint rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg)\n{\n\ts32 msg_len = (le16_to_cpu(*(__le16 *)&msg[0]) & 0x0fff);\n\tu16 msg_type = (msg[2]);\n\n\trsi_dbg(FSM_ZONE, \"%s: Msg Len: %d, Msg Type: %4x\\n\",\n\t\t__func__, msg_len, msg_type);\n\n\tswitch (msg_type) {\n\tcase TA_CONFIRM_TYPE:\n\t\treturn rsi_handle_ta_confirm_type(common, msg);\n\tcase CARD_READY_IND:\n\t\tcommon->hibernate_resume = false;\n\t\trsi_dbg(FSM_ZONE, \"%s: Card ready indication received\\n\",\n\t\t\t__func__);\n\t\treturn rsi_handle_card_ready(common, msg);\n\tcase TX_STATUS_IND:\n\t\tswitch (msg[RSI_TX_STATUS_TYPE]) {\n\t\tcase PROBEREQ_CONFIRM:\n\t\t\tcommon->mgmt_q_block = false;\n\t\t\trsi_dbg(FSM_ZONE, \"%s: Probe confirm received\\n\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\tcase EAPOL4_CONFIRM:\n\t\t\tif (msg[RSI_TX_STATUS]) {\n\t\t\t\tcommon->eapol4_confirm = true;\n\t\t\t\tif (!rsi_send_block_unblock_frame(common,\n\t\t\t\t\t\t\t\t  false))\n\t\t\t\t\tcommon->hw_data_qs_blocked = false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase BEACON_EVENT_IND:\n\t\trsi_dbg(INFO_ZONE, \"Beacon event\\n\");\n\t\tif (common->fsm_state != FSM_MAC_INIT_DONE)\n\t\t\treturn -1;\n\t\tif (common->iface_down)\n\t\t\treturn -1;\n\t\tif (!common->beacon_enabled)\n\t\t\treturn -1;\n\t\trsi_send_beacon(common);\n\t\tbreak;\n\tcase WOWLAN_WAKEUP_REASON:\n\t\trsi_dbg(ERR_ZONE, \"\\n\\nWakeup Type: %x\\n\", msg[15]);\n\t\tswitch (msg[15]) {\n\t\tcase RSI_UNICAST_MAGIC_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for Unicast magic packet ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_BROADCAST_MAGICPKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for Broadcast magic packet ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_EAPOL_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for GTK renewal ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_DISCONNECT_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for Disconnect ***\\n\");\n\t\t\tbreak;\n\t\tcase RSI_HW_BMISS_PKT:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"*** Wakeup for HW Beacon miss ***\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"##### Un-intentional Wakeup #####\\n\");\n\t\t\tbreak;\n\t}\n\tbreak;\n\tcase RX_DOT11_MGMT:\n\t\treturn rsi_mgmt_pkt_to_core(common, msg, msg_len);\n\tdefault:\n\t\trsi_dbg(INFO_ZONE, \"Received packet type: 0x%x\\n\", msg_type);\n\t}\n\treturn 0;\n}\n"], "filenames": ["drivers/net/wireless/rsi/rsi_91x_mgmt.c"], "buggy_code_start_loc": [1758], "buggy_code_end_loc": [1758], "fixing_code_start_loc": [1759], "fixing_code_end_loc": [1760], "type": "CWE-401", "message": "A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c.", "other": {"cve": {"id": "CVE-2019-19071", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.047", "lastModified": "2023-01-17T21:33:48.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n rsi_send_beacon() en el archivo drivers/net/wireless/rsi/rsi_91x_mgmt.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n rsi_prepare_beacon(), tambi\u00e9n se conoce como CID -d563131ef23c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14", "versionEndExcluding": "4.14.159", "matchCriteriaId": "DC9F1CBF-0471-48C3-9A5C-FC8EE5B51384"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.89", "matchCriteriaId": "E96276FC-AC23-4EAF-83AC-BB44733064EC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.3.16", "matchCriteriaId": "22BF102C-6F4F-4F6F-BDC4-CA17FDC10DF5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndExcluding": "5.4.3", "matchCriteriaId": "B9661C2E-394B-49AA-B15D-EDA60F5E2526"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4258-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f"}}