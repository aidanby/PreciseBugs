{"buggy_code": ["## Parse Server Changelog\n\n### master\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.0...master)\n\n### 4.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.4.0...4.5.0)\n\n__BREAKING CHANGES:__\n- FIX: Consistent casing for afterLiveQueryEvent. The afterLiveQueryEvent was introduced in 4.4.0 with inconsistent casing for the event names, which was fixed in 4.5.0. [#7023](https://github.com/parse-community/parse-server/pull/7023). Thanks to [dblythy](https://github.com/dblythy).\n___\n- FIX: Properly handle serverURL and publicServerUrl in Batch requests. [#7049](https://github.com/parse-community/parse-server/pull/7049). Thanks to [Zach Goldberg](https://github.com/ZachGoldberg).\n- IMPROVE: Prevent invalid column names (className and length). [#7053](https://github.com/parse-community/parse-server/pull/7053). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: GraphQL: Remove viewer from logout mutation. [#7029](https://github.com/parse-community/parse-server/pull/7029). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- IMPROVE: GraphQL: Optimize on Relation. [#7044](https://github.com/parse-community/parse-server/pull/7044). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Include sessionToken in onLiveQueryEvent. [#7043](https://github.com/parse-community/parse-server/pull/7043). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Definitions for accountLockout and passwordPolicy. [#7040](https://github.com/parse-community/parse-server/pull/7040). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix typo in server definitions for emailVerifyTokenReuseIfValid. [#7037](https://github.com/parse-community/parse-server/pull/7037). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: LDAP auth stores password in plain text. See [GHSA-4w46-w44m-3jq3](https://github.com/parse-community/parse-server/security/advisories/GHSA-4w46-w44m-3jq3) for more details about the vulnerability and [da905a3](https://github.com/parse-community/parse-server/commit/da905a357d062ab4fea727a21eac231acc2ed92a) for the fix. Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- NEW: Reuse tokens if they haven't expired. [#7017](https://github.com/parse-community/parse-server/pull/7017). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add LDAPS-support to LDAP-Authcontroller. [#7014](https://github.com/parse-community/parse-server/pull/7014). Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- FIX: (beforeSave/afterSave): Return value instead of Parse.Op for nested fields. [#7005](https://github.com/parse-community/parse-server/pull/7005). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: (beforeSave): Skip Sanitizing Database results. [#7003](https://github.com/parse-community/parse-server/pull/7003). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix includeAll for querying a Pointer and Pointer array. [#7002](https://github.com/parse-community/parse-server/pull/7002). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Add encryptionKey to src/options/index.js. [#6999](https://github.com/parse-community/parse-server/pull/6999). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Update PostgresStorageAdapter.js. [#6989](https://github.com/parse-community/parse-server/pull/6989). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t).\n\n### 4.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.3.0...4.4.0)\n- IMPROVE: Update PostgresStorageAdapter.js. [#6981](https://github.com/parse-community/parse-server/pull/6981). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: skipWithMasterKey on Built-In Validator. [#6972](https://github.com/parse-community/parse-server/issues/6972). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add fileKey rotation to GridFSBucketAdapter. [#6768](https://github.com/parse-community/parse-server/pull/6768). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Remove unused parameter in Cloud Function. [#6969](https://github.com/parse-community/parse-server/issues/6969). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Validation Handler Update. [#6968](https://github.com/parse-community/parse-server/issues/6968). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (directAccess): Properly handle response status. [#6966](https://github.com/parse-community/parse-server/issues/6966). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Remove hostnameMaxLen for Mongo URL. [#6693](https://github.com/parse-community/parse-server/issues/6693). Thanks to [markhoward02](https://github.com/markhoward02).\n- IMPROVE: Show a message if cloud functions are duplicated. [#6963](https://github.com/parse-community/parse-server/issues/6963). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Pass request.query to afterFind. [#6960](https://github.com/parse-community/parse-server/issues/6960). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: Patch session vulnerability over Live Query. See [GHSA-2xm2-xj2q-qgpj](https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj) for more details about the vulnerability and [78b59fb](https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58) for the fix. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- IMPROVE: LiveQueryEvent Error Logging Improvements. [#6951](https://github.com/parse-community/parse-server/issues/6951). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Include stack in Cloud Code. [#6958](https://github.com/parse-community/parse-server/issues/6958). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (jobs): Add Error Message to JobStatus Failure. [#6954](https://github.com/parse-community/parse-server/issues/6954). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Create Cloud function afterLiveQueryEvent. [#6859](https://github.com/parse-community/parse-server/issues/6859). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Update vkontakte API to the latest version. [#6944](https://github.com/parse-community/parse-server/issues/6944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- FIX: Use an empty object as default value of options for Google Sign in. [#6844](https://github.com/parse-community/parse-server/issues/6844). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Postgres: prepend className to unique indexes. [#6741](https://github.com/parse-community/parse-server/pull/6741). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: GraphQL: Transform input types also on user mutations. [#6934](https://github.com/parse-community/parse-server/pull/6934). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Set objectId into query for Email Validation. [#6930](https://github.com/parse-community/parse-server/pull/6930). Thanks to [Danaru](https://github.com/Danaru87).\n- FIX: GraphQL: Optimize queries, fixes some null returns (on object), fix stitched GraphQLUpload. [#6709](https://github.com/parse-community/parse-server/pull/6709). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Do not throw error if user provide a pointer like index onMongo. [#6923](https://github.com/parse-community/parse-server/pull/6923). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Hotfix instagram api. [#6922](https://github.com/parse-community/parse-server/issues/6922). Thanks to [Tim](https://github.com/timination).\n- FIX: (directAccess/cloud-code): Pass installationId with LogIn. [#6903](https://github.com/parse-community/parse-server/issues/6903). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix bcrypt binary incompatibility. [#6891](https://github.com/parse-community/parse-server/issues/6891). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- NEW: Keycloak auth adapter. [#6376](https://github.com/parse-community/parse-server/issues/6376). Thanks to [Rhuan](https://github.com/rhuanbarreto).\n- IMPROVE: Changed incorrect key name in apple auth adapter tests. [#6861](https://github.com/parse-community/parse-server/issues/6861). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Fix mutating beforeSubscribe Query. [#6868](https://github.com/parse-community/parse-server/issues/6868). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix beforeLogin for users logging in with AuthData. [#6872](https://github.com/parse-community/parse-server/issues/6872). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Remove Facebook AccountKit auth. [#6870](https://github.com/parse-community/parse-server/issues/6870). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Updated TOKEN_ISSUER to 'accounts.google.com'. [#6836](https://github.com/parse-community/parse-server/issues/6836). Thanks to [Arjun Vedak](https://github.com/arjun3396).\n- IMPROVE: Optimized deletion of class field from schema by using an index if available to do an index scan instead of a collection scan. [#6815](https://github.com/parse-community/parse-server/issues/6815). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- IMPROVE: Enable MongoDB transaction test for MongoDB >= 4.0.4 [#6827](https://github.com/parse-community/parse-server/pull/6827). Thanks to [Manuel](https://github.com/mtrezza).\n\n### 4.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.2.0...4.3.0)\n- PERFORMANCE: Optimizing pointer CLP query decoration done by DatabaseController#addPointerPermissions [#6747](https://github.com/parse-community/parse-server/pull/6747). Thanks to [mess-lelouch](https://github.com/mess-lelouch).\n- SECURITY: Fix security breach on GraphQL viewer [78239ac](https://github.com/parse-community/parse-server/commit/78239ac9071167fdf243c55ae4bc9a2c0b0d89aa), [secuity advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-236h-rqv8-8q73). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Save context not present if direct access enabled [#6764](https://github.com/parse-community/parse-server/pull/6764). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani).\n- NEW: Before Connect + Before Subscribe [#6793](https://github.com/parse-community/parse-server/pull/6793). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Add version to playground to fix CDN [#6804](https://github.com/parse-community/parse-server/pull/6804). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW (EXPERIMENTAL): Idempotency enforcement for client requests. This deduplicates requests where the client intends to send one request to Parse Server but due to network issues the server receives the request multiple times. **Caution, this is an experimental feature that may not be appropriate for production.** [#6748](https://github.com/parse-community/parse-server/issues/6748). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Add production Google Auth Adapter instead of using the development url [#6734](https://github.com/parse-community/parse-server/pull/6734). Thanks to [SebC.](https://github.com/SebC99).\n- IMPROVE: Run Prettier JS Again Without requiring () on arrow functions [#6796](https://github.com/parse-community/parse-server/pull/6796). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Run Prettier JS [#6795](https://github.com/parse-community/parse-server/pull/6795). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Replace bcrypt with @node-rs/bcrypt [#6794](https://github.com/parse-community/parse-server/pull/6794). Thanks to [LongYinan](https://github.com/Brooooooklyn).\n- IMPROVE: Make clear description of anonymous user [#6655](https://github.com/parse-community/parse-server/pull/6655). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon).\n- IMPROVE: Simplify GraphQL merge system to avoid js ref bugs [#6791](https://github.com/parse-community/parse-server/pull/6791). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Pass context in beforeDelete, afterDelete, beforeFind and Parse.Cloud.run [#6666](https://github.com/parse-community/parse-server/pull/6666). Thanks to [yog27ray](https://github.com/yog27ray).\n- NEW: Allow passing custom gql schema function to ParseServer#start options [#6762](https://github.com/parse-community/parse-server/pull/6762). Thanks to [Luca](https://github.com/lucatk).\n- NEW: Allow custom cors origin header [#6772](https://github.com/parse-community/parse-server/pull/6772). Thanks to [Kevin Yao](https://github.com/kzmeyao).\n- FIX: Fix context for cascade-saving and saving existing object [#6735](https://github.com/parse-community/parse-server/pull/6735). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file bucket encryption using fileKey [#6765](https://github.com/parse-community/parse-server/pull/6765). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Removed gaze from dev dependencies and removed not working dev script [#6745](https://github.com/parse-community/parse-server/pull/6745). Thanks to [Vincent Semrau](https://github.com/vince1995).\n- IMPROVE: Upgrade graphql-tools to v6 [#6701](https://github.com/parse-community/parse-server/pull/6701). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- NEW: Support Metadata in GridFSAdapter [#6660](https://github.com/parse-community/parse-server/pull/6660). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Allow to unset file from graphql [#6651](https://github.com/parse-community/parse-server/pull/6651). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Handle shutdown for RedisCacheAdapter [#6658](https://github.com/parse-community/parse-server/pull/6658). Thanks to [promisenxu](https://github.com/promisenxu).\n- FIX: Fix explain on user class [#6650](https://github.com/parse-community/parse-server/pull/6650). Thanks to [Manuel](https://github.com/mtrezza).\n- FIX: Fix read preference for aggregate [#6585](https://github.com/parse-community/parse-server/pull/6585). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add context to Parse.Object.save [#6626](https://github.com/parse-community/parse-server/pull/6626). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Adding ssl config params to Postgres URI [#6580](https://github.com/parse-community/parse-server/pull/6580). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Travis postgres update: removing unnecessary start of mongo-runner [#6594](https://github.com/parse-community/parse-server/pull/6594). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: ObjectId size for Pointer in Postgres [#6619](https://github.com/parse-community/parse-server/pull/6619). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Improve a test case [#6629](https://github.com/parse-community/parse-server/pull/6629). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- NEW: Allow to resolve automatically Parse Type fields from Custom Schema [#6562](https://github.com/parse-community/parse-server/pull/6562). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Remove wrong console log in test [#6627](https://github.com/parse-community/parse-server/pull/6627). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- IMPROVE: Graphql tools v5 [#6611](https://github.com/parse-community/parse-server/pull/6611). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- FIX: Catch JSON.parse and return 403 properly [#6589](https://github.com/parse-community/parse-server/pull/6589). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- PERFORMANCE: Allow covering relation queries with minimal index [#6581](https://github.com/parse-community/parse-server/pull/6581). Thanks to [Noah Silas](https://github.com/noahsilas).\n- FIX: Fix Postgres group aggregation [#6522](https://github.com/parse-community/parse-server/pull/6522). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- NEW: Allow set user mapped from JWT directly on request [#6411](https://github.com/parse-community/parse-server/pull/6411). Thanks to [Gordon Sun](https://github.com/sunshineo).\n\n### 4.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.1.0...4.2.0)\n\n__BREAKING CHANGES:__\n- CHANGE: The Sign-In with Apple authentication adapter parameter `client_id` has been changed to `clientId`. If using the Apple authentication adapter, this change requires to update the Parse Server configuration accordingly. See [#6523](https://github.com/parse-community/parse-server/pull/6523) for details.\n___\n- UPGRADE: Parse JS SDK to 2.12.0 [#6548](https://github.com/parse-community/parse-server/pull/6548)\n- NEW: Support Group aggregation on multiple columns for Postgres [#6483](https://github.com/parse-community/parse-server/pull/6483). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- FIX: Improve test reliability by instructing Travis to only install one version of Postgres [#6490](https://github.com/parse-community/parse-server/pull/6490). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: Unknown type bug on overloaded types [#6494](https://github.com/parse-community/parse-server/pull/6494). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Improve reliability of 'SignIn with AppleID' [#6416](https://github.com/parse-community/parse-server/pull/6416). Thanks to [Andy King](https://github.com/andrewking0207).\n- FIX: Improve Travis reliability by separating Postgres & Mongo scripts [#6505](https://github.com/parse-community/parse-server/pull/6505). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Apple SignIn support for multiple IDs [#6523](https://github.com/parse-community/parse-server/pull/6523). Thanks to [UnderratedDev](https://github.com/UnderratedDev).\n- NEW: Add support for new Instagram API [#6398](https://github.com/parse-community/parse-server/pull/6398). Thanks to [Maravilho Singa](https://github.com/maravilhosinga).\n- FIX: Updating Postgres/Postgis Call and Postgis to 3.0 [#6528](https://github.com/parse-community/parse-server/pull/6528). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: enableExpressErrorHandler logic [#6423](https://github.com/parse-community/parse-server/pull/6423). Thanks to [Nikolay Andryukhin](https://github.com/hybeats).\n- FIX: Change Order Enum Strategy for GraphQL [#6515](https://github.com/parse-community/parse-server/pull/6515). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Switch ACL to Relay Global Id for GraphQL [#6495](https://github.com/parse-community/parse-server/pull/6495). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Handle keys for pointer fields properly for GraphQL [#6499](https://github.com/parse-community/parse-server/pull/6499). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: GraphQL file mutation [#6507](https://github.com/parse-community/parse-server/pull/6507). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Aggregate geoNear with date query [#6540](https://github.com/parse-community/parse-server/pull/6540). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file triggers and file meta data [#6344](https://github.com/parse-community/parse-server/pull/6344). Thanks to [stevestencil](https://github.com/stevestencil).\n- FIX: Improve local testing of postgres [#6531](https://github.com/parse-community/parse-server/pull/6531). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Case insensitive username and email indexing and query planning for Postgres [#6506](https://github.com/parse-community/parse-server/issues/6441). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n\n### 4.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.2...4.1.0)\n\n_SECURITY RELEASE_: see [advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4) for details\n- SECURITY FIX: Patch Regex vulnerabilities. See [3a3a5ee](https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269). Special thanks to [W0lfw00d](https://github.com/W0lfw00d) for identifying and [responsibly reporting](https://github.com/parse-community/parse-server/blob/master/SECURITY.md) the vulnerability. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo) for the speedy fix.\n\n### 4.0.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.1...4.0.2)\n\n__BREAKING CHANGES:__\n1. Remove Support for Mongo 3.2 & 3.4. The new minimum supported version is Mongo 3.6.\n2. Change username and email validation to be case insensitive. This change should be transparent in most use cases. The validation behavior should now behave 'as expected'. See [#5634](https://github.com/parse-community/parse-server/pull/5634) for details.\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted above, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- FIX: attempt to get travis to deploy to npmjs again. See [#6475](https://github.com/parse-community/parse-server/pull/6457). Thanks to [Arthur Cinader](https://github.com/acinader).\n\n### 4.0.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.0...4.0.1)\n- FIX: correct 'new' travis config to properly deploy.  See [#6452](https://github.com/parse-community/parse-server/pull/6452). Thanks to [Arthur Cinader](https://github.com/acinader).\n- FIX: Better message on not allowed to protect default fields. See [#6439](https://github.com/parse-community/parse-server/pull/6439).Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n\n### 4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.10.0...4.0.0)\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted below, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- NEW: add hint option to Parse.Query [#6322](https://github.com/parse-community/parse-server/pull/6322). Thanks to [Steve Stencil](https://github.com/stevestencil)\n- FIX: CLP objectId size validation fix [#6332](https://github.com/parse-community/parse-server/pull/6332). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add volumes to Docker command [#6356](https://github.com/parse-community/parse-server/pull/6356). Thanks to [Kasra Bigdeli](https://github.com/githubsaturn)\n- NEW: GraphQL 3rd Party LoginWith Support [#6371](https://github.com/parse-community/parse-server/pull/6371). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: GraphQL Geo Queries [#6363](https://github.com/parse-community/parse-server/pull/6363). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: GraphQL Nested File Upload [#6372](https://github.com/parse-community/parse-server/pull/6372). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Granular CLP pointer permissions [#6352](https://github.com/parse-community/parse-server/pull/6352). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add missing colon for customPages [#6393](https://github.com/parse-community/parse-server/pull/6393). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: `afterLogin` cloud code hook [#6387](https://github.com/parse-community/parse-server/pull/6387). Thanks to [David Corona](https://github.com/davesters)\n- FIX: __BREAKING CHANGE__ Prevent new usernames or emails that clash with existing users' email or username if it only differs by case.  For example, don't allow a new user with the name 'Jane' if we already have a user 'jane'. [#5634](https://github.com/parse-community/parse-server/pull/5634). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: Support Travis CI V2. [#6414](https://github.com/parse-community/parse-server/pull/6414). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Prevent crashing on websocket error. [#6418](https://github.com/parse-community/parse-server/pull/6418). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Allow protectedFields for Authenticated users and Public. [$6415](https://github.com/parse-community/parse-server/pull/6415). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Correct bug in determining GraphQL pointer errors when mutating. [#6413](https://github.com/parse-community/parse-server/pull/6431). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Allow true GraphQL Schema Customization. [#6360](https://github.com/parse-community/parse-server/pull/6360). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- __BREAKING CHANGE__: Remove Support for Mongo version < 3.6 [#6445](https://github.com/parse-community/parse-server/pull/6445). Thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 3.10.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.9.0...3.10.0)\n- FIX: correct and cover ordering queries in GraphQL [#6316](https://github.com/parse-community/parse-server/pull/6316).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL support for reset password email [#6301](https://github.com/parse-community/parse-server/pull/6301). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Add default limit to GraphQL fetch [#6304](https://github.com/parse-community/parse-server/pull/6304). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: use bash syntax highlighting [#6302](https://github.com/parse-community/parse-server/pull/6302). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: Add max log file option [#6296](https://github.com/parse-community/parse-server/pull/6296). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: support user supplied objectId [#6101](https://github.com/parse-community/parse-server/pull/6101). Thanks to [Ruhan](https://github.com/rhuanbarretos)\n- FIX: Add missing encodeURIComponent on username [#6278](https://github.com/parse-community/parse-server/pull/6278). Thanks to [Christopher Brookes](https://github.com/Klaitos)\n- NEW: update  PostgresStorageAdapter.js to use async/await [#6275](https://github.com/parse-community/parse-server/pull/6275). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: Support required fields on output type for GraphQL [#6279](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Support required fields for GraphQL [#6271](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: use mongodb 3.3.5 [#6263](https://github.com/parse-community/parse-server/pull/6263). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL: DX Relational Where Query [#6255](https://github.com/parse-community/parse-server/pull/6255). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL alias for mutations in classConfigs [#6258](https://github.com/parse-community/parse-server/pull/6258). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: GraphQL classConfig query alias [#6257](https://github.com/parse-community/parse-server/pull/6257). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: Allow validateFilename to return a string or Parse Error [#6246](https://github.com/parse-community/parse-server/pull/6246). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Relay Spec [#6089](https://github.com/parse-community/parse-server/pull/6089). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Set default ACL for GraphQL [#6249](https://github.com/parse-community/parse-server/pull/6249). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: LDAP auth Adapter [#6226](https://github.com/parse-community/parse-server/pull/6226). Thanks to [Julian Dax](https://github.com/brodo)\n- FIX: improve beforeFind to include Query info [#6237](https://github.com/parse-community/parse-server/pull/6237). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: improve websocket error handling [#6230](https://github.com/parse-community/parse-server/pull/6230). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: addition of an afterLogout trigger [#6217](https://github.com/parse-community/parse-server/pull/6217). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Initialize default logger [#6186](https://github.com/parse-community/parse-server/pull/6186). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add funding link [#6192](https://github.com/parse-community/parse-server/pull/6192 ). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: installationId on LiveQuery connect [#6180](https://github.com/parse-community/parse-server/pull/6180). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add exposing port in docker container [#6165](https://github.com/parse-community/parse-server/pull/6165). Thanks to [Priyash Patil](https://github.com/priyashpatil)\n- NEW: Support Google Play Games Service [#6147](https://github.com/parse-community/parse-server/pull/6147). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Throw error when setting authData to null [#6154](https://github.com/parse-community/parse-server/pull/6154). Thanks to [Manuel](https://github.com/mtrezza)\n- CHANGE: Move filename validation out of the Router and into the FilesAdaptor [#6157](https://github.com/parse-community/parse-server/pull/6157). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Added warning for special URL sensitive characters for appId [#6159](https://github.com/parse-community/parse-server/pull/6159). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- NEW: Support Apple Game Center Auth [#6143](https://github.com/parse-community/parse-server/pull/6143). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test with Node 12 [#6133](https://github.com/parse-community/parse-server/pull/6133). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: prevent after find from firing when saving objects [#6127](https://github.com/parse-community/parse-server/pull/6127). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL Mutations not returning updated information [6130](https://github.com/parse-community/parse-server/pull/6130). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Cleanup Schema cache per request [#6216](https://github.com/parse-community/parse-server/pull/6216). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Improve installation instructions [#6120](https://github.com/parse-community/parse-server/pull/6120). Thanks to [Andres Galante](https://github.com/andresgalante)\n- DOC: add code formatting to contributing guidelines [#6119](https://github.com/parse-community/parse-server/pull/6119). Thanks to [Andres Galante](https://github.com/andresgalante)\n- NEW: Add GraphQL ACL Type + Input [#5957](https://github.com/parse-community/parse-server/pull/5957). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: replace public key [#6099](https://github.com/parse-community/parse-server/pull/6099). Thanks to [Arthur Cinader](https://github.com/acinader)\n- NEW: Support microsoft authentication in GraphQL [#6051](https://github.com/parse-community/parse-server/pull/6051). Thanks to [Alann Maulana](https://github.com/alann-maulana)\n- NEW: Install parse-server 3.9.0 instead of 2.2 [#6069](https://github.com/parse-community/parse-server/pull/6069). Thanks to [Julian Dax](https://github.com/brodo)\n- NEW: Use #!/bin/bash instead of #!/bin/sh [#6062](https://github.com/parse-community/parse-server/pull/6062). Thanks to [Julian Dax](https://github.com/brodo)\n- DOC: Update GraphQL readme section [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n### 3.9.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.8.0...3.9.0)\n- NEW: Add allowHeaders to Options [#6044](https://github.com/parse-community/parse-server/pull/6044). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Introduce ReadOptionsInput to GraphQL API [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Stream video with GridFSBucketAdapter (implements byte-range requests) [#6028](https://github.com/parse-community/parse-server/pull/6028). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Aggregate not matching null values [#6043](https://github.com/parse-community/parse-server/pull/6043). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Improve callCloudCode mutation to receive a CloudCodeFunction enum instead of a String in the GraphQL API [#6029](https://github.com/parse-community/parse-server/pull/6029). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- TEST: Add more tests to transactions [#6022](https://github.com/parse-community/parse-server/pull/6022). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Pointer constraint input type as ID in the GraphQL API [#6020](https://github.com/parse-community/parse-server/pull/6020). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- CHANGE: Remove underline from operators of the GraphQL API [#6024](https://github.com/parse-community/parse-server/pull/6024). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Make method async as expected in usage [#6025](https://github.com/parse-community/parse-server/pull/6025). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- DOC: Added breaking change note to 3.8 release [#6023](https://github.com/parse-community/parse-server/pull/6023). Thanks to [Manuel](https://github.com/mtrezza)\n- NEW: Added support for line auth [#6007](https://github.com/parse-community/parse-server/pull/6007). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- FIX: Fix aggregate group id [#5994](https://github.com/parse-community/parse-server/pull/5994). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Schema operations instead of generic operations in the GraphQL API [#5993](https://github.com/parse-community/parse-server/pull/5993). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Fix changelog formatting[#6009](https://github.com/parse-community/parse-server/pull/6009). Thanks to [Tom Fox](https://github.com/TomWFox)\n- CHANGE: Rename objectId to id in the GraphQL API [#5985](https://github.com/parse-community/parse-server/pull/5985). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- FIX: Fix beforeLogin trigger when user has a file [#6001](https://github.com/parse-community/parse-server/pull/6001). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Update GraphQL Docs with the latest changes [#5980](https://github.com/parse-community/parse-server/pull/5980). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n### 3.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.2...3.8.0)\n- NEW:  Protected fields pointer-permissions support [#5951](https://github.com/parse-community/parse-server/pull/5951).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- NEW: GraphQL DX: Relation/Pointer [#5946](https://github.com/parse-community/parse-server/pull/5946).  Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Master Key Only Config Properties [#5953](https://github.com/parse-community/parse-server/pull/5954). Thanks to [Manuel](https://github.com/mtrezza)\n- FIX: Better validation when creating a Relation fields [#5922](https://github.com/parse-community/parse-server/pull/5922).  Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: enable GraphQL file upload [#5944](https://github.com/parse-community/parse-server/pull/5944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Handle shutdown on grid adapters  [#5943](https://github.com/parse-community/parse-server/pull/5943).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Fix GraphQL max upload size [#5940](https://github.com/parse-community/parse-server/pull/5940). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove Buffer() deprecation notice [#5942](https://github.com/parse-community/parse-server/pull/5942).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove MongoDB unified topology deprecation notice from the grid adapter [#5941](https://github.com/parse-community/parse-server/pull/5941).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: add callback for serverCloseComplete [#5937](https://github.com/parse-community/parse-server/pull/5937). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOCS: Add Cloud Code guide to README [#5936](https://github.com/parse-community/parse-server/pull/5936).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Remove nested operations from GraphQL API [#5931](https://github.com/parse-community/parse-server/pull/5931).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Improve Live Query Monitoring [#5927](https://github.com/parse-community/parse-server/pull/5927).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL: Fix undefined Array [#5296](https://github.com/parse-community/parse-server/pull/5926). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Added array support for pointer-permissions [#5921](https://github.com/parse-community/parse-server/pull/5921).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- GraphQL: Renaming Types/Inputs [#5921](https://github.com/parse-community/parse-server/pull/5921). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Lint no-prototype-builtins [#5920](https://github.com/parse-community/parse-server/pull/5920). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Inline Fragment on Array Fields [#5908](https://github.com/parse-community/parse-server/pull/5908). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: Add instructions to launch a compatible Docker Postgres [](). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- Fix: Undefined dot notation in matchKeyInQuery [#5917](https://github.com/parse-community/parse-server/pull/5917). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- Fix: Logger print JSON and Numbers [#5916](https://github.com/parse-community/parse-server/pull/5916). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Return specific Type on specific Mutation [#5893](https://github.com/parse-community/parse-server/pull/5893). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Apple sign-in authAdapter [#5891](https://github.com/parse-community/parse-server/pull/5891). Thanks to [SebC](https://github.com/SebC99).\n- DOCS: Add GraphQL beta notice [#5886](https://github.com/parse-community/parse-server/pull/5886). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- GraphQL: Remove \"password\" output field from _User class [#5889](https://github.com/parse-community/parse-server/pull/5889). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- GraphQL: Object constraints [#5715](https://github.com/parse-community/parse-server/pull/5715). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- DOCS: README top section overhaul + add sponsors [#5876](https://github.com/parse-community/parse-server/pull/5876). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: Return a Promise from classUpdate method [#5877](https://github.com/parse-community/parse-server/pull/5877). Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- FIX: Use UTC Month in aggregate tests [#5879](https://github.com/parse-community/parse-server/pull/5879). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Transaction was aborting before all promises have either resolved or rejected [#5878](https://github.com/parse-community/parse-server/pull/5878). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Use transactions for batch operation [#5849](https://github.com/parse-community/parse-server/pull/5849). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n#### Breaking Changes:\n- If you are running Parse Server on top of a MongoDB deployment which does not fit the [Retryable Writes Requirements](https://docs.mongodb.com/manual/core/retryable-writes/#prerequisites), you will have to add `retryWrites=false` to your connection string in order to upgrade to Parse Server 3.8.\n\n### 3.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.1...3.7.2)\n\n- FIX: Live Query was failing on release 3.7.1\n\n### 3.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.0...3.7.1)\n\n- FIX: Missing APN module\n- FIX: Set falsy values as default to schema fields [#5868](https://github.com/parse-community/parse-server/pull/5868), thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: Implement WebSocketServer Adapter [#5866](https://github.com/parse-community/parse-server/pull/5866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n### 3.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.6.0...3.7.0)\n\n- FIX: Prevent linkWith sessionToken from generating new session [#5801](https://github.com/parse-community/parse-server/pull/5801), thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Improve session token error messages [#5753](https://github.com/parse-community/parse-server/pull/5753), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: GraphQL { functions { call } } generic mutation [#5818](https://github.com/parse-community/parse-server/pull/5818), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Custom Schema [#5821](https://github.com/parse-community/parse-server/pull/5821), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL custom schema on CLI [#5828](https://github.com/parse-community/parse-server/pull/5828), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL @mock directive [#5836](https://github.com/parse-community/parse-server/pull/5836), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: GraphQL _or operator not working [#5840](https://github.com/parse-community/parse-server/pull/5840), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add \"count\" to CLP initial value [#5841](https://github.com/parse-community/parse-server/pull/5841), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: Add ability to alter the response from the after save trigger [#5814](https://github.com/parse-community/parse-server/pull/5814), thanks to [BrunoMaurice](https://github.com/brunoMaurice)\n- FIX: Cache apple public key for the case it fails to fetch again [#5848](https://github.com/parse-community/parse-server/pull/5848), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Configuration Options [#5782](https://github.com/parse-community/parse-server/pull/5782), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: Required fields and default values [#5835](https://github.com/parse-community/parse-server/pull/5835), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Postgres safely escape strings in nested objects [#5855](https://github.com/parse-community/parse-server/pull/5855), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Support PhantAuth authentication [#5850](https://github.com/parse-community/parse-server/pull/5850), thanks to [Ivan SZKIBA](https://github.com/szkiba)\n- FIX: Remove uws package [#5860](https://github.com/parse-community/parse-server/pull/5860), thanks to [Zeal Murapa](https://github.com/GoGross)\n\n### 3.6.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.5.0...3.6.0)\n\n- SECURITY FIX: Address [Security Advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-8w3j-g983-8jh5) of a potential [Enumeration Attack](https://www.owasp.org/index.php/Testing_for_User_Enumeration_and_Guessable_User_Account_(OWASP-AT-002)#Description_of_the_Issue) [73b0f9a](https://github.com/parse-community/parse-server/commit/73b0f9a339b81f5d757725dc557955a7b670a3ec), big thanks to [Fabian Strachanski](https://github.com/fastrde) for identifying the problem, creating a fix and following the [vulnerability disclosure guidelines](https://github.com/parse-community/parse-server/blob/master/SECURITY.md#parse-community-vulnerability-disclosure-program)\n- NEW: Added rest option: excludeKeys [#5737](https://github.com/parse-community/parse-server/pull/5737), thanks to [Raschid J.F. Rafeally](https://github.com/RaschidJFR)\n- FIX: LiveQuery create event with fields [#5790](https://github.com/parse-community/parse-server/pull/5790), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Generate sessionToken with linkWith [#5799](https://github.com/parse-community/parse-server/pull/5799), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n### 3.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.4...3.5.0)\n\n- NEW: GraphQL Support [#5674](https://github.com/parse-community/parse-server/pull/5674), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n[GraphQL Guide](https://github.com/parse-community/parse-server#graphql)\n\n- NEW: Sign in with Apple [#5694](https://github.com/parse-community/parse-server/pull/5694), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: AppSecret to Facebook Auth [#5695](https://github.com/parse-community/parse-server/pull/5695), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Postgres: Regex support foreign characters [#5598](https://github.com/parse-community/parse-server/pull/5598), thanks to [Jeff Gu Kang](https://github.com/JeffGuKang)\n- FIX: Winston Logger string interpolation [#5729](https://github.com/parse-community/parse-server/pull/5729), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n### 3.4.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.3...3.4.4)\n\nFix: Commit changes\n\n### 3.4.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.2...3.4.3)\n\nFix: Use changes in master to travis configuration to enable pushing to npm and gh_pages.  See diff for details.\n\n### 3.4.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.1...3.4.2)\n\nFix: In my haste to get a [Security Fix](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) out, I added [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5) to master instead of to 3.4.1.  This commit fixes that.  [Arthur Cinader](https://github.com/acinader)\n\n### 3.4.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.0...3.4.1)\n\nSecurity Fix: see Advisory: [GHSA-2479-qvv7-47q](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) for details [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5). Big thanks to: [Benjamin Simonsson](https://github.com/BenniPlejd) for identifying the issue and promptly bringing it to the Parse Community's attention and also big thanks to the indefatigable [Diamond Lewis](https://github.com/dplewis) for crafting a failing test and then a solution within an hour of the report.\n\n### 3.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.3.0...3.4.0)\n- NEW: Aggregate supports group by date fields [#5538](https://github.com/parse-community/parse-server/pull/5538) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: API for Read Preferences [#3963](https://github.com/parse-community/parse-server/pull/3963) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add Redis options for LiveQuery [#5584](https://github.com/parse-community/parse-server/pull/5584) thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add Direct Access option for Server Config [#5550](https://github.com/parse-community/parse-server/pull/5550) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: updating mixed array in Postgres [#5552](https://github.com/parse-community/parse-server/pull/5552) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: notEqualTo GeoPoint Query in Postgres [#5549](https://github.com/parse-community/parse-server/pull/5549), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: put the timestamp back in logs that was lost after Winston upgrade [#5571](https://github.com/parse-community/parse-server/pull/5571), thanks to [Steven Rowe](https://github.com/mrowe009) and [Arthur Cinader](https://github.com/acinader)\n- FIX: Validates permission before calling beforeSave [#5546](https://github.com/parse-community/parse-server/pull/5546), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove userSensitiveFields default value. [#5588](https://github.com/parse-community/parse-server/pull/5588), thanks to [William George](https://github.com/awgeorge)\n- FIX: Decode Date JSON value in LiveQuery. [#5540](https://github.com/parse-community/parse-server/pull/5540), thanks to [ananfang](https://github.com/ananfang)\n\n\n### 3.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.3...3.3.0)\n- NEW: beforeLogin trigger with support for auth providers ([#5445](https://github.com/parse-community/parse-server/pull/5445)), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: RFC 7662 compliant OAuth2 auth adapter ([#4910](https://github.com/parse-community/parse-server/pull/4910)), thanks to [M\u00fcller Zsolt](https://github.com/zsmuller)\n- FIX: cannot change password when maxPasswordHistory is 1 ([#5191](https://github.com/parse-community/parse-server/pull/5191)), thanks to [Tulsi Sapkota](https://github.com/Tolsee)\n- FIX (Postgres): count being very slow on large Parse Classes' collections ([#5330](https://github.com/parse-community/parse-server/pull/5330)), thanks to [CoderickLamar](https://github.com/CoderickLamar)\n- FIX: using per-key basis queue ([#5420](https://github.com/parse-community/parse-server/pull/5420)), thanks to [Georges Jamous](https://github.com/georgesjamous)\n- FIX: issue on count with Geo constraints and mongo ([#5286](https://github.com/parse-community/parse-server/pull/5286)), thanks to [Julien Qu\u00e9r\u00e9](https://github.com/jlnquere)\n\n### 3.2.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.2...3.2.3)\n- Correct previous release with patch that is fully merged\n\n### 3.2.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.1...3.2.2)\n- Security fix to properly process userSensitiveFields when parse-server is started with\n  ../lib/cli/parse-server [#5463](https://github.com/parse-community/parse-server/pull/5463\n  )\n\n### 3.2.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.0...3.2.1)\n- Increment package.json version to match the deployment tag\n\n### 3.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.3...3.2.0)\n- NEW: Support accessing sensitive fields with an explicit ACL.  Not documented yet, see [tests](https://github.com/parse-community/parse-server/blob/f2c332ea6a984808ad5b2e3ce34864a20724f72b/spec/UserPII.spec.js#L526) for examples\n- Upgrade Parse SDK JS to 2.3.1 [#5457](https://github.com/parse-community/parse-server/pull/5457)\n- Hides token contents in logStartupOptions if they arrive as a buffer [#6a9380](https://github.com/parse-community/parse-server/commit/6a93806c62205a56a8f4e3b8765848c552510337)\n- Support custom message for password requirements [#5399](https://github.com/parse-community/parse-server/pull/5399)\n- Support for Ajax password reset [#5332](https://github.com/parse-community/parse-server/pull/5332)\n- Postgres: Refuse to build unsafe JSON lists for contains [#5337](https://github.com/parse-community/parse-server/pull/5337)\n- Properly handle return values in beforeSave [#5228](https://github.com/parse-community/parse-server/pull/5228)\n- Fixes issue when querying user roles [#5276](https://github.com/parse-community/parse-server/pull/5276)\n- Fixes issue affecting update with CLP [#5269](https://github.com/parse-community/parse-server/pull/5269)\n\n### 3.1.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.2...3.1.3)\n\n- Postgres: Fixes support for global configuration\n- Postgres: Fixes support for numeric arrays\n- Postgres: Fixes issue affecting queries on empty arrays\n- LiveQuery: Adds support for transmitting the original object\n- Queries: Use estimated count if query is empty\n- Docker: Reduces the size of the docker image to 154Mb\n\n\n### 3.1.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.1...3.1.2)\n\n- Removes dev script, use TDD instead of server.\n- Removes nodemon and problematic dependencies.\n- Addressed event-stream security debacle.\n\n### 3.1.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.0...3.1.1)\n\n#### Improvements:\n* Fixes issue that would prevent users with large number of roles to resolve all of them [Antoine Cormouls](https://github.com/Moumouls) (#5131, #5132)\n* Fixes distinct query on special fields ([#5144](https://github.com/parse-community/parse-server/pull/5144))\n\n\n### 3.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.0.0...3.1.0)\n\n#### Breaking Changes:\n* Return success on sendPasswordResetEmail even if email not found. (#7fe4030)\n#### Security Fix:\n* Expire password reset tokens on email change (#5104)\n#### Improvements:\n* Live Query CLPs (#4387)\n* Reduces number of calls to injectDefaultSchema (#5107)\n* Remove runtime dependency on request (#5076)\n#### Bug fixes:\n* Fixes issue with vkontatke authentication (#4977)\n* Use the correct function when validating google auth tokens (#5018)\n* fix unexpected 'delete' trigger issue on LiveQuery (#5031)\n* Improves performance for roles and ACL's in live query server (#5126)\n\n\n### 3.0.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.4...3.0.0)\n\n`parse-server` 3.0.0 comes with brand new handlers for cloud code. It now fully supports promises and async / await.\nFor more informations, visit the v3.0.0 [migration guide](https://github.com/parse-community/parse-server/blob/master/3.0.0.md).\n\n#### Breaking changes:\n* Cloud Code handlers have a new interface based on promises.\n* response.success / response.error are removed in Cloud Code\n* Cloud Code runs with Parse-SDK 2.0\n* The aggregate now require aggregates to be passed in the form: `{\"pipeline\": [...]}` (REST Only)\n\n#### Improvements:\n* Adds Pipeline Operator to Aggregate Router.\n* Adds documentations for parse-server's adapters, constructors and more.\n* Adds ability to pass a context object between `beforeSave` and `afterSave` affecting the same object.\n\n#### Bug Fixes:\n* Fixes issue that would crash the server when mongo objects had undefined values [#4966](https://github.com/parse-community/parse-server/issues/4966)\n* Fixes issue that prevented ACL's from being used with `select` (see [#571](https://github.com/parse-community/Parse-SDK-JS/issues/571))\n\n#### Dependency updates:\n* [@parse/simple-mailgun-adapter@1.1.0](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [mongodb@3.1.3](https://www.npmjs.com/package/mongodb)\n* [request@2.88.0](https://www.npmjs.com/package/request)\n\n##### Devevelopment Dependencies Updates:\n* [@parse/minami@1.0.0](https://www.npmjs.com/package/@parse/minami)\n* [deep-diff@1.0.2](https://www.npmjs.com/package/deep-diff)\n* [flow-bin@0.79.0](https://www.npmjs.com/package/flow-bin)\n* [jsdoc@3.5.5](https://www.npmjs.com/package/jsdoc)\n* [jsdoc-babel@0.4.0](https://www.npmjs.com/package/jsdoc-babel)\n\n### 2.8.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.3...2.8.4)\n\n#### Improvements:\n* Adds ability to forward errors to express handler (#4697)\n* Adds ability to increment the push badge with an arbitrary value (#4889)\n* Adds ability to preserve the file names when uploading (#4915)\n* `_User` now follow regular ACL policy. Letting administrator lock user out. (#4860) and (#4898)\n* Ensure dates are properly handled in aggregates (#4743)\n* Aggregates: Improved support for stages sharing the same name\n* Add includeAll option\n* Added verify password to users router and tests. (#4747)\n* Ensure read preference is never overriden, so DB config prevails (#4833)\n* add support for geoWithin.centerSphere queries via withJSON (#4825)\n* Allow sorting an object field (#4806)\n* Postgres: Don't merge JSON fields after save() to keep same behaviour as MongoDB (#4808) (#4815)\n\n#### Dependency updates\n* [commander@2.16.0](https://www.npmjs.com/package/commander)\n* [mongodb@3.1.1](https://www.npmjs.com/package/mongodb)\n* [pg-promise@8.4.5](https://www.npmjs.com/package/pg-promise)\n* [ws@6.0.0](https://www.npmjs.com/package/ws)\n* [bcrypt@3.0.0](https://www.npmjs.com/package/bcrypt)\n* [uws@10.148.1](https://www.npmjs.com/package/uws)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.2.0](https://www.npmjs.com/package/cross-env)\n* [eslint@5.0.0](https://www.npmjs.com/package/eslint)\n* [flow-bin@0.76.0](https://www.npmjs.com/package/flow-bin)\n* [mongodb-runner@4.0.0](https://www.npmjs.com/package/mongodb-runner)\n* [nodemon@1.18.1](https://www.npmjs.com/package/nodemon)\n* [nyc@12.0.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [supports-color@5.4.0](https://www.npmjs.com/package/supports-color)\n\n### 2.8.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.2...2.8.3)\n\n#### Improvements:\n\n* Adds support for JS SDK 2.0 job status header\n* Removes npm-git scripts as npm supports using git repositories that build, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### 2.8.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.2)\n\n##### Bug Fixes:\n* Ensure legacy users without ACL's are not locked out, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Use common HTTP agent to increase webhooks performance, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds withinPolygon support for Polygon objects, thanks to [Mads Bjerre](https://github.com/madsb)\n\n#### Dependency Updates:\n* [ws@5.2.0](https://www.npmjs.com/package/ws)\n* [commander@2.15.1](https://www.npmjs.com/package/commander)\n* [nodemon@1.17.5](https://www.npmjs.com/package/nodemon)\n\n##### Devevelopment Dependencies Updates:\n* [flow-bin@0.73.0](https://www.npmjs.com/package/flow-bin)\n* [cross-env@5.1.6](https://www.npmjs.com/package/cross-env)\n* [gaze@1.1.3](https://www.npmjs.com/package/gaze)\n* [deepcopy@1.0.0](https://www.npmjs.com/package/deepcopy)\n* [deep-diff@1.0.1](https://www.npmjs.com/package/deep-diff)\n\n\n### 2.8.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.0)\n\nEnsure all the files are properly exported to the final package.\n\n### 2.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.0...2.7.4)\n\n#### New Features\n* Adding Mongodb element to add `arrayMatches` the #4762 (#4766), thanks to [J\u00e9r\u00e9my Piednoel](https://github.com/jeremypiednoel)\n* Adds ability to Lockout users (#4749), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Fixes issue when using afterFind with relations (#4752), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New query condition support to match all strings that starts with some other given strings (#3864), thanks to [Eduard Bosch Bertran](https://github.com/eduardbosch)\n* Allow creation of indices on default fields (#4738), thanks to [Claire Neveu](https://github.com/ClaireNeveu)\n* Purging empty class (#4676), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Fixes issues comparing to zero or false (#4667), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fix Aggregate Match Pointer (#4643), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Allow Parse.Error when returning from Cloud Code (#4695), thanks to [Saulo Tauil](https://github.com/saulogt)\n* Fix typo: \"requrest\" -> \"request\" (#4761), thanks to [Joseph Frazier](https://github.com/josephfrazier)\n* Send version for Vkontakte API (#4725), thanks to [oleg](https://github.com/alekoleg)\n* Ensure we respond with invalid password even if email is unverified (#4708), thanks to [dblythy](https://github.com/dblythy)\n* Add _password_history to default sensitive data (#4699), thanks to [Jong Eun Lee](https://github.com/yomybaby)\n* Check for node version in postinstall script (#4657), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Remove FB Graph API version from URL to use the oldest non deprecated version, thanks to [SebC](https://github.com/SebC99)\n\n#### Dependency Updates:\n* [@parse/push-adapter@2.0.3](https://www.npmjs.com/package/@parse/push-adapter)\n* [@parse/simple-mailgun-adapter@1.0.2](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [uws@10.148.0](https://www.npmjs.com/package/uws)\n* [body-parser@1.18.3](https://www.npmjs.com/package/body-parser)\n* [mime@2.3.1](https://www.npmjs.com/package/mime)\n* [request@2.85.0](https://www.npmjs.com/package/request)\n* [mongodb@3.0.7](https://www.npmjs.com/package/mongodb)\n* [bcrypt@2.0.1](https://www.npmjs.com/package/bcrypt)\n* [ws@5.1.1](https://www.npmjs.com/package/ws)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.1.5](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.71.0](https://www.npmjs.com/package/flow-bin)\n* [deep-diff@1.0.0](https://www.npmjs.com/package/deep-diff)\n* [nodemon@1.17.3](https://www.npmjs.com/package/nodemon)\n\n\n### 2.7.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.4...2.7.3)\n\n#### Bug Fixes:\n* Fixes an issue affecting polygon queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Dependency Updates:\n* [pg-promise@8.2.1](https://www.npmjs.com/package/pg-promise)\n\n##### Development Dependencies Updates:\n* [nodemon@1.17.1](https://www.npmjs.com/package/nodemon)\n\n### 2.7.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.3...2.7.2)\n\n#### Improvements:\n* Improve documentation for LiveQuery options, thanks to [Arthur Cinader](https://github.com/acinader)\n* Improve documentation for using cloud code with docker, thanks to [Stephen Tuso](https://github.com/stephentuso)\n* Adds support for Facebook's AccountKit, thanks to [6thfdwp](https://github.com/6thfdwp)\n* Disable afterFind routines when running aggregates, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Improve support for distinct aggregations of nulls, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Regenreate the email verification token when requesting a new email, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes:\n* Fix issue affecting readOnly masterKey and purge command, thanks to [AreyouHappy](https://github.com/AreyouHappy)\n* Fixes Issue unsetting in beforeSave doesn't allow object creation, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fixes issue crashing server on invalid live query payload, thanks to [fridays](https://github.com/fridays)\n* Fixes issue affecting postgres storage adapter \"undefined property '__op'\", thanks to [Tyson Andre](https://github,com/TysonAndre)\n\n#### Dependency Updates:\n* [winston@2.4.1](https://www.npmjs.com/package/winston)\n* [pg-promise@8.2.0](https://www.npmjs.com/package/pg-promise)\n* [commander@2.15.0](https://www.npmjs.com/package/commander)\n* [lru-cache@4.1.2](https://www.npmjs.com/package/lru-cache)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [ws@5.0.0](https://www.npmjs.com/package/ws)\n* [mongodb@3.0.4](https://www.npmjs.com/package/mongodb)\n* [lodash@4.17.5](https://www.npmjs.com/package/lodash)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.1.4](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.67.1](https://www.npmjs.com/package/flow-bin)\n* [jasmine@3.1.0](https://www.npmjs.com/package/jasmine)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [babel-eslint@8.2.2](https://www.npmjs.com/package/babel-eslint)\n* [nodemon@1.15.0](https://www.npmjs.com/package/nodemon)\n\n### 2.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.2...2.7.1)\n\n#### Improvements:\n* Improved match aggregate\n* Do not mark the empty push as failed\n* Support pointer in aggregate query\n* Introduces flow types for storage\n* Postgres: Refactoring of Postgres Storage Adapter\n* Postgres: Support for multiple projection in aggregate\n* Postgres: performance optimizations\n* Adds infos about vulnerability disclosures\n* Adds ability to login with email when provided as username\n\n#### Bug Fixes\n* Scrub Passwords with URL Encoded Characters\n* Fixes issue affecting using sorting in beforeFind\n\n#### Dependency Updates:\n* [commander@2.13.0](https://www.npmjs.com/package/commander)\n* [semver@5.5.0](https://www.npmjs.com/package/semver)\n* [pg-promise@7.4.0](https://www.npmjs.com/package/pg-promise)\n* [ws@4.0.0](https://www.npmjs.com/package/ws)\n* [mime@2.2.0](https://www.npmjs.com/package/mime)\n* [parse@1.11.0](https://www.npmjs.com/package/parse)\n\n##### Devevelopment Dependencies Updates:\n* [nodemon@1.14.11](https://www.npmjs.com/package/nodemon)\n* [flow-bin@0.64.0](https://www.npmjs.com/package/flow-bin)\n* [jasmine@2.9.0](https://www.npmjs.com/package/jasmine)\n* [cross-env@5.1.3](https://www.npmjs.com/package/cross-env)\n\n### 2.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.1...2.7.0)\n\n:warning: Fixes a security issue affecting Class Level Permissions\n\n* Adds support for dot notation when using matchesKeyInQuery, thanks to [Henrik](https://github.com/bohemima) and [Arthur Cinader](https://github.com/acinader)\n\n### 2.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.0...2.6.5)\n\n:warning: This version contains an issue affecting Class Level Permissions on mongoDB. Please upgrade to 2.7.1.\n\nStarting parse-server 2.7.0, the minimun nodejs version is 6.11.4, please update your engines before updating parse-server\n\n#### New Features:\n* Aggregation endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds indexation options onto Schema endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug fixes:\n* Fixes sessionTokens being overridden in 'find' (#4332), thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Proper `handleShutdown()` feature to close database connections (#4361), thanks to [CHANG, TZU-YEN](https://github.com/trylovetom)\n* Fixes issue affecting state of _PushStatus objects, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Fixes issue affecting calling password reset password pages with wrong appid, thanks to [Bryan de Leon](https://github.com/bryandel)\n* Fixes issue affecting duplicates _Sessions on successive logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Updates contributing guides, and improves windows support, thanks to [Addison Elliott](https://github.com/addisonelliott)\n* Uses new official scoped packaged, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves health checks responses, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add password confirmation to choose_password, thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Improve performance of relation queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [commander@2.12.1](https://www.npmjs.com/package/commander)\n* [ws@3.3.2](https://www.npmjs.com/package/ws)\n* [uws@9.14.0](https://www.npmjs.com/package/uws)\n* [pg-promise@7.3.2](https://www.npmjs.com/package/pg-promise)\n* [parse@1.10.2](https://www.npmjs.com/package/parse)\n* [pg-promise@7.3.1](https://www.npmjs.com/package/pg-promise)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.1.1](https://www.npmjs.com/package/cross-env)\n\n\n\n### 2.6.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.5...2.6.4)\n\n#### New Features:\n* Adds support for read-only masterKey, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds support for relative time queries (mongodb only), thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Improvements:\n* Handle possible afterSave exception, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add support for expiration interval in Push, thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Bug Fixes:\n* The REST API key was improperly inferred from environment when using the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.6.4\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.4...2.6.3)\n\n#### Improvements:\n* Improves management of configurations and default values, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds ability to start ParseServer with `ParseServer.start(options)`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds request original IP to cloud code hooks, thanks to [Gustav Ahlberg](https://github.com/Gyran)\n* Corrects some outdated links, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds serverURL validation on startup, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with POST requests alongside GET, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with email, instead of username, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes issue affecting beforeSaves and increments, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Dependency Updates:\n* [parse-server-push-adapter@2.0.2](https://www.npmjs.com/package/parse-server-push-adapter)\n* [semver@5.4.1](https://www.npmjs.com/package/semver)\n* [pg-promise@7.0.3](https://www.npmjs.com/package/pg-promise)\n* [mongodb@2.2.33](https://www.npmjs.com/package/mongodb)\n* [parse@1.10.1](https://www.npmjs.com/package/parse)\n* [express@4.16.0](https://www.npmjs.com/package/express)\n* [mime@1.4.1](https://www.npmjs.com/package/mime)\n* [parse-server-simple-mailgun-adapter@1.0.1](https://www.npmjs.com/package/parse-server-simple-mailgun-adapter)\n\n##### Devevelopment Dependencies Updates:\n* [babel-preset-env@1.6.1](https://www.npmjs.com/package/babel-preset-env)\n* [cross-env@5.1.0](https://www.npmjs.com/package/cross-env)\n* [mongodb-runner@3.6.1](https://www.npmjs.com/package/mongodb-runner)\n* [eslint-plugin-flowtype@2.39.1](https://www.npmjs.com/package/eslint-plugin-flowtype)\n* [eslint@4.9.0](https://www.npmjs.com/package/eslint)\n\n### 2.6.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.2...2.6.3)\n\n#### Improvements:\n* Queries on Pointer fields with `$in` and `$nin` now supports list of objectId's, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQueries on `$in` and `$nin` for pointer fields work as expected thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Also remove device token when APNS error is BadDeviceToken, thanks to [Mauricio Tollin](https://github.com/)\n* LRU cache is not available on the ParseServer object, thanks to [Tyler Brock](https://github.com/tbrock)\n* Error messages are more expressive, thanks to [Tyler Brock](https://github.com/tbrock)\n* Postgres: Properly handle undefined field values, thanks to [Diamond Lewis](https://github.com/dlewis)\n* Updating with two GeoPoints fails correctly, thanks to [Anthony Mosca](https://github.com/aontas)\n\n#### New Features:\n* Adds ability to set a maxLimit on server configuration for queries, thanks to [Chris Norris](https://github.com/)\n\n#### Bug fixes:\n* Fixes issue affecting reporting `_PushStatus` with misconfigured serverURL, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting deletion of class that doesn't exist, thanks to [Diamond Lewis](https://github.com/dlewis)\n\n#### Dependency Updates:\n* [winston@2.4.0](https://www.npmjs.com/package/winston)\n* [pg-promise@6.10.2](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.6.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [request@2.83.0](https://www.npmjs.com/package/request)\n* [body-parser@1.18.2](https://www.npmjs.com/package/body-parser)\n\n##### Devevelopment Dependencies Updates:\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [eslint@4.7.1](https://www.npmjs.com/package/eslint)\n\n### 2.6.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.1...2.6.2)\n\n#### Improvements:\n* PushWorker/PushQueue channels are properly prefixed with the Parse applicationId, thanks to [Marvel Mathew](https://github.com/marvelm)\n* You can use Parse.Cloud.afterSave hooks on _PushStatus\n* You can use Parse.Cloud.onLiveQueryEvent to track the number of clients and subscriptions\n* Adds support for more fields from the Audience class.\n\n#### New Features:\n* Push: Adds ability to track sentPerUTC offset if your push scheduler supports it.\n* Push: Adds support for cleaning up invalid deviceTokens from _Installation (PARSE_SERVER_CLEANUP_INVALID_INSTALLATIONS=1).\n\n#### Dependency Updates:\n* [ws@3.2.0](https://www.npmjs.com/package/ws)\n* [pg-promise@6.5.3](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.5.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [body-parser@1.18.1](https://www.npmjs.com/package/body-parser)\n\n##### Devevelopment Dependencies Updates:\n* [nodemon@1.12.1](https://www.npmjs.com/package/nodemon)\n* [mongodb-runner@3.6.0](https://www.npmjs.com/package/mongodb-runner)\n* [babel-eslint@8.0.0](https://www.npmjs.com/package/babel-eslint)\n\n### 2.6.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.0...2.6.1)\n\n#### Improvements:\n* Improves overall performance of the server, more particularly with large query results.\n* Improves performance of InMemoryCacheAdapter by removing serialization.\n* Improves logging performance by skipping necessary log calls.\n* Refactors object routers to simplify logic.\n* Adds automatic indexing on $text indexes, thanks to [Diamon Lewis](https://github.com/dplewis)\n\n#### New Features:\n* Push: Adds ability to send localized pushes according to the _Installation localeIdentifier\n* Push: proper support for scheduling push in user's locale time, thanks to [Marvel Mathew](https://github.com/marvelm)\n* LiveQuery: Adds ability to use LiveQuery with a masterKey, thanks to [Jeremy May](https://github.com/kenishi)\n\n#### Bug Fixes:\n* Fixes an issue that would duplicate Session objects per userId-installationId pair.\n* Fixes an issue affecting pointer permissions introduced in this release.\n* Fixes an issue that would prevent displaying audiences correctly in dashboard.\n* Fixes an issue affecting preventLoginWithUnverifiedEmail upon signups.\n\n#### Dependency Updates:\n* [pg-promise@6.3.2](https://www.npmjs.com/package/pg-promise)\n* [body-parser@1.18.0](https://www.npmjs.com/package/body-parser)\n* [nodemon@1.11.1](https://www.npmjs.com/package/nodemon)\n\n##### Devevelopment Dependencies Updates:\n* [babel-cli@6.26.0](https://www.npmjs.com/package/babel-cli)\n\n### 2.6.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.3...2.6.0)\n\n#### Breaking Changes:\n* [parse-server-s3-adapter@1.2.0](https://www.npmjs.com/package/parse-server-s3-adapter): A new deprecation notice is introduced with parse-server-s3-adapter's version 1.2.0.  An upcoming release will remove passing key and password arguments.  AWS credentials should be set using AWS best practices.  See the [Deprecation Notice for AWS credentials]( https://github.com/parse-server-modules/parse-server-s3-adapter/blob/master/README.md#deprecation-notice----aws-credentials) section of the adapter's README.\n\n#### New Features\n* Polygon is fully supported as a type, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Query supports PolygonContains, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements\n* Postgres: Adds support nested contains and containedIn, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Adds support for `null` in containsAll queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Cloud Code: Request headers are passed to the cloud functions, thanks to [miguel-s](https://github.com/miguel-s)\n* Push: All push queries now filter only where deviceToken exists\n\n#### Bug Fixes:\n* Fixes issue affecting updates of _User objects when authData was passed.\n* Push: Pushing to an empty audience should now properly report a failed _PushStatus\n* Linking Users: Fixes issue affecting linking users with sessionToken only\n\n#### Dependency Updates:\n* [ws@3.1.0](https://www.npmjs.com/package/ws)\n* [mime@1.4.0](https://www.npmjs.com/package/mime)\n* [semver@5.4.0](https://www.npmjs.com/package/semver)\n* [uws@8.14.1](https://www.npmjs.com/package/uws)\n* [bcrypt@1.0.3](https://www.npmjs.com/package/bcrypt)\n* [mongodb@2.2.31](https://www.npmjs.com/package/mongodb)\n* [redis@2.8.0](https://www.npmjs.com/package/redis)\n* [pg-promise@6.3.1](https://www.npmjs.com/package/pg-promise)\n* [commander@2.11.0](https://www.npmjs.com/package/commander)\n\n##### Devevelopment Dependencies Updates:\n* [jasmine@2.8.0](https://www.npmjs.com/package/jasmine)\n* [babel-register@6.26.0](https://www.npmjs.com/package/babel-register)\n* [babel-core@6.26.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.2](https://www.npmjs.com/package/cross-env)\n\n### 2.5.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.2...2.5.3)\n\n#### New Features:\n* badge property on android installations will now be set as on iOS (#3970), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes incorrect number parser for cache options\n\n### 2.5.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.1...2.5.2)\n\n#### Improvements:\n* Restores ability to run on node >= 4.6\n* Adds ability to configure cache from CLI\n* Removes runtime check for node >= 4.6\n\n### 2.5.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.0...2.5.1)\n\n#### New Features:\n* Adds ability to set default objectId size (#3950), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements:\n* Uses LRU cache instead of InMemoryCache by default (#3979), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* iOS pushes are now using HTTP/2.0 instead of binary API  (#3983), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [parse@1.10.0](https://www.npmjs.com/package/parse)\n* [pg-promise@6.3.0](https://www.npmjs.com/package/pg-promise)\n* [parse-server-s3-adapter@1.1.0](https://www.npmjs.com/package/parse-server-s3-adapter)\n* [parse-server-push-adapter@2.0.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.5.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.2...2.5.0)\n\n#### New Features:\n* Adds ability to run full text search (#3904), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to run `$withinPolygon` queries (#3889), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to pass read preference per query with mongodb (#3865), thanks to [davimacedo](https://github.com/davimacedo)\n* beforeFind trigger now includes `isGet` for get queries (#3862), thanks to [davimacedo](https://github.com/davimacedo)\n* Adds endpoints for dashboard's audience API (#3861), thanks to [davimacedo](https://github.com/davimacedo)\n* Restores the job scheduling endpoints (#3927), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Removes unnecessary warning when using maxTimeMs with mongodb, thanks to [Tyler Brock](https://github.com/tbrock)\n* Improves access control on system classes (#3916), thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Adds bytes support in postgres (#3894), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug Fixes:\n* Fixes issue with vkontakte adapter that would hang the request, thanks to [Denis Trofimov](https://github.com/denistrofimov)\n* Fixes issue affecting null relational data (#3924), thanks to [davimacedo](https://github.com/davimacedo)\n* Fixes issue affecting session token deletion (#3937), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting the serverInfo endpoint (#3933), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting beforeSave with dot-noted sub-documents (#3912), thanks to [IlyaDiallo](https://github.com/IlyaDiallo)\n* Fixes issue affecting emails being sent when using a 3rd party auth (#3882), thanks to [davimacedo](https://github.com/davimacedo)\n\n#### Dependency Updates:\n* [commander@2.10.0](https://www.npmjs.com/package/commander)\n* [pg-promise@5.9.7](https://www.npmjs.com/package/pg-promise)\n* [lru-cache@4.1.0](https://www.npmjs.com/package/lru-cache)\n* [mongodb@2.2.28](https://www.npmjs.com/package/mongodb)\n\n##### Devevelopment dependencies\n* [babel-core@6.25.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.1](https://www.npmjs.com/package/cross-env)\n* [nyc@11.0.2](https://www.npmjs.com/package/nyc)\n\n### 2.4.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.1...2.4.2)\n\n#### New Features:\n* ParseQuery: Support for withinPolygon [#3866](https://github.com/parse-community/parse-server/pull/3866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Postgres: Use transactions when deleting a class, [#3869](https://github.com/parse-community/parse-server/pull/3836), thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Postgres: Proper support for GeoPoint equality query, [#3874](https://github.com/parse-community/parse-server/pull/3836), thanks to [Diamond Lewis](https://github.com/dplewis)\n* beforeSave and liveQuery will be correctly triggered on email verification [#3851](https://github.com/parse-community/parse-server/pull/3851), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Skip authData validation if it hasn't changed, on PUT requests [#3872](https://github.com/parse-community/parse-server/pull/3872), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [mongodb@2.2.27](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.2](https://www.npmjs.com/package/pg-promise)\n\n\n### 2.4.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.0...2.4.1)\n\n#### Bug fixes:\n* Fixes issue affecting relation updates ([#3835](https://github.com/parse-community/parse-server/pull/3835), [#3836](https://github.com/parse-community/parse-server/pull/3836)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting sending push notifications, thanks to [Felipe Andrade](https://github.com/felipemobile)\n* Session are always cleared when updating the passwords ([#3289](https://github.com/parse-community/parse-server/pull/3289), [#3821](https://github.com/parse-community/parse-server/pull/3821), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [body-parser@1.17.2](https://www.npmjs.com/package/body-parser)\n* [pg-promise@5.7.1](https://www.npmjs.com/package/pg-promise)\n* [ws@3.0.0](https://www.npmjs.com/package/ws)\n\n\n### 2.4.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.8...2.4.0)\n\nStarting 2.4.0, parse-server is tested against node 6.10 and 7.10, mongodb 3.2 and 3.4.\nIf you experience issues with older versions, please [open a issue](https://github.com/parse-community/parse-server/issues).\n\n#### New Features:\n* Adds `count` Class Level Permission ([#3814](https://github.com/parse-community/parse-server/pull/3814)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Proper graceful shutdown support ([#3786](https://github.com/parse-community/parse-server/pull/3786)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Let parse-server store as `scheduled` Push Notifications with push_time (#3717, #3722), thanks to [Felipe Andrade](https://github.com/felipemobile)\n\n#### Improvements\n* Parse-Server images are built through docker hub, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Skip authData validation if it hasn't changed, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* [postgres] Improve performance when adding many new fields to the Schema ([#3740](https://github.com/parse-community/parse-server/pull/3740)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Test maintenance, wordsmithing and nits ([#3744](https://github.com/parse-community/parse-server/pull/3744)), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Bug Fixes:\n* [postgres] Fixes issue affecting deleting multiple fields of a Schema ([#3734](https://github.com/parse-community/parse-server/pull/3734), [#3735](https://github.com/parse-community/parse-server/pull/3735)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Fix issue affecting _PushStatus state ([#3808](https://github.com/parse-community/parse-server/pull/3808)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* requiresAuthentication Class Level Permission behaves correctly, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Email Verification related fields are not exposed ([#3681](https://github.com/parse-community/parse-server/pull/3681), [#3393](https://github.com/parse-community/parse-server/pull/3393), [#3432](https://github.com/parse-community/parse-server/pull/3432)), thanks to [Anthony Mosca](https://github.com/aontas)\n* HTTP query parameters are properly obfuscated in logs ([#3793](https://github.com/parse-community/parse-server/pull/3793), [#3789](https://github.com/parse-community/parse-server/pull/3789)), thanks to [@youngerong](https://github.com/youngerong)\n* Improve handling of `$near` operators in `$or` queries ([#3767](https://github.com/parse-community/parse-server/pull/3767), [#3798](https://github.com/parse-community/parse-server/pull/3798)), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Fix issue affecting arrays of pointers ([#3169](https://github.com/parse-community/parse-server/pull/3169)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix issue affecting overloaded query constraints ([#3723](https://github.com/parse-community/parse-server/pull/3723), [#3678](https://github.com/parse-community/parse-server/pull/3678)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Properly catch unhandled rejections in _Installation updates ([#3795](https://github.com/parse-community/parse-server/pull/3795)), thanks to [kahoona77](https://github.com/kahoona77)\n\n#### Dependency Updates:\n\n* [uws@0.14.5](https://www.npmjs.com/package/uws)\n* [mime@1.3.6](https://www.npmjs.com/package/mime)\n* [mongodb@2.2.26](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.0](https://www.npmjs.com/package/pg-promise)\n* [semver@5.3.0](https://www.npmjs.com/package/semver)\n\n##### Devevelopment dependencies\n* [babel-cli@6.24.1](https://www.npmjs.com/package/babel-cli)\n* [babel-core@6.24.1](https://www.npmjs.com/package/babel-core)\n* [babel-preset-es2015@6.24.1](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-preset-stage-0@6.24.1](https://www.npmjs.com/package/babel-preset-stage-0)\n* [babel-register@6.24.1](https://www.npmjs.com/package/babel-register)\n* [cross-env@5.0.0](https://www.npmjs.com/package/cross-env)\n* [deep-diff@0.3.8](https://www.npmjs.com/package/deep-diff)\n* [gaze@1.1.2](https://www.npmjs.com/package/gaze)\n* [jasmine@2.6.0](https://www.npmjs.com/package/jasmine)\n* [jasmine-spec-reporter@4.1.0](https://www.npmjs.com/package/jasmine-spec-reporter)\n* [mongodb-runner@3.5.0](https://www.npmjs.com/package/mongodb-runner)\n* [nyc@10.3.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.1](https://www.npmjs.com/package/request-promise)\n\n\n### 2.3.8\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.7...2.3.8)\n\n#### New Features\n* Support for PG-Promise options, thanks to [ren dong](https://github.com/rendongsc)\n\n#### Improvements\n* Improves support for graceful shutdown, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves configuration validation for Twitter Authentication, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes\n* Fixes issue affecting GeoPoint __type with Postgres, thanks to [zhoul-HS](https://github.com/zhoul-HS)\n* Prevent user creation if username or password is empty, thanks to [Wissam Abirached](https://github.com/wabirached)\n\n#### Dependency Updates:\n* [cross-env@4.0.0 ](https://www.npmjs.com/package/cross-env)\n* [ws@2.2.3](https://www.npmjs.com/package/ws)\n* [babel-core@6.24.0](https://www.npmjs.com/package/babel-core)\n* [uws@0.14.0](https://www.npmjs.com/package/uws)\n* [babel-preset-es2015@6.24.0](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-plugin-syntax-flow@6.18.0](https://www.npmjs.com/package/babel-plugin-syntax-flow)\n* [babel-cli@6.24.0](https://www.npmjs.com/package/babel-cli)\n* [babel-register@6.24.0](https://www.npmjs.com/package/babel-register)\n* [winston-daily-rotate-file@1.4.6](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [mongodb@2.2.25](https://www.npmjs.com/package/mongodb)\n* [redis@2.7.0](https://www.npmjs.com/package/redis)\n* [pg-promise@5.6.4](https://www.npmjs.com/package/pg-promise)\n* [parse-server-push-adapter@1.3.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.3.7\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.6...2.3.7)\n\n#### New Features\n* New endpoint to resend verification email, thanks to [Xy Ziemba](https://github.com/xyziemba)\n\n#### Improvements\n* Add TTL option for Redis Cache Adapter, thanks to [Ryan Foster](https://github.com/f0ster)\n* Update Postgres Storage Adapter, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n\n#### Bug Fixes\n* Add index on Role.name, fixes (#3579), thanks to [Natan Rolnik](https://github.com/natanrolnik)\n* Fix default value of userSensitiveFields, fixes (#3593), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Dependency Updates:\n* [body-parser@1.17.1](https://www.npmjs.com/package/body-parser)\n* [express@4.15.2](https://www.npmjs.com/package/express)\n* [request@2.81.0](https://www.npmjs.com/package/request)\n* [winston-daily-rotate-file@1.4.5](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [ws@2.2.0](https://www.npmjs.com/package/ws)\n\n\n### 2.3.6\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.5...2.3.6)\n\n#### Improvements\n* Adds support for injecting a middleware for instumentation in the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Alleviate mongodb bug with $or queries [SERVER-13732](https://jira.mongodb.org/browse/SERVER-13732), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n\n#### Bug Fixes\n* Fix issue affecting password policy and empty passwords, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Fix issue when logging url in non string objects, thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n\n#### Dependencies updates:\n* [ws@2.1.0](https://npmjs.com/package/ws)\n* [uws@0.13.0](https://npmjs.com/package/uws)\n* [pg-promise@5.6.2](https://npmjs.com/package/pg-promise)\n\n\n### 2.3.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.3...2.3.5)\n\n#### Bug Fixes\n* Allow empty client key\n(#3497), thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix LiveQuery unsafe user\n(#3525), thanks to [David Starke](https://github.com/dstarke)\n* Use `flushdb` instead of `flushall` in RedisCacheAdapter\n(#3523), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix saving GeoPoints and Files in `_GlobalConfig` (Make sure we don't treat\ndot notation keys as topLevel atoms)\n(#3531), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.2...2.3.3)\n\n#### Breaking Changes\n* **Minimum Node engine bumped to 4.6** (#3480), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes\n* Add logging on failure to create file (#3424), thanks to [Arthur Cinader](https://github.com/acinader)\n* Log Parse Errors so they are intelligible (#3431), thanks to [Arthur Cinader](https://github.com/acinader)\n* MongoDB $or Queries avoid SERVER-13732 bug (#3476), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Mongo object to Parse object date serialization - avoid re-serialization of iso of type Date (#3389), thanks to [nodechefMatt](https://github.com/nodechefMatt)\n\n#### Improvements\n* Ground preparations for push scalability (#3080), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Use uWS as optional dependency for ws server (#3231), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.1...2.3.2)\n\n#### New features\n* Add parseFrameURL for masking user-facing pages (#3267), thanks to  [Lenart Rudel](https://github.com/lenart)\n\n#### Bug fixes\n* Fix Parse-Server to work with winston-daily-rotate-1.4.2 (#3335), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Improvements\n* Add support for regex string for password policy validatorPattern setting (#3331), thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* LiveQuery should match subobjects with dot notation (#3322), thanks to [David Starke](https://github.com/dstarke)\n* Reduce time to process high number of installations for push (#3264), thanks to [jeacott1](https://github.com/jeacott1)\n* Fix trivial typo in error message (#3238), thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.3.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.0...2.3.1)\n\nA major issue was introduced when refactoring the authentication modules.\nThis release addresses only that issue.\n\n### 2.3.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.25...2.3.0)\n\n#### Breaking changes\n* Parse.Cloud.useMasterKey() is a no-op, please refer to (Cloud Code migration guide)[https://github.com/ParsePlatform/parse-server/wiki/Compatibility-with-Hosted-Parse#cloud-code]\n* Authentication helpers are now proper adapters, deprecates oauth option in favor of auth.\n* DEPRECATES: facebookAppIds, use `auth: { facebook: { appIds: [\"AAAAAAAAA\" ] } }`\n* `email` field is not returned anymore for `Parse.User` queries. (Provided only on the user itself if provided).\n\n#### New Features\n* Adds ability to restrict access through Class Level Permissions to only authenticated users [see docs](http://parseplatform.github.io/docs/ios/guide/#requires-authentication-permission-requires-parse-server---230)\n* Adds ability to strip sensitive data from `_User` responses, strips emails by default, thanks to [Arthur Cinader](https://github.com/acinader)\n* Adds password history support for password policies, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n\n#### Improvements\n* Bump parse-server-s3-adapter to 1.0.6, thanks to [Arthur Cinader](https://github.com/acinader)\n* Using PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS let you create user sessions when passing {installationId: \"xxx-xxx\"} on signup in cloud code, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Add CLI option to pass `host` parameter when creating parse-server from CLI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug fixes\n* Ensure batch routes are only using posix paths, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Ensure falsy options from CLI are properly taken into account, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fixes issues affecting calls to `matchesKeyInQuery` with pointers.\n* Ensure that `select` keys can be changed in triggers (beforeFind...), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Housekeeping\n* Enables and enforces linting with eslint, thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.2.25\n\nPostgres support requires v9.5\n\n#### New Features\n* Dockerizing Parse Server, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Login with qq, wechat, weibo, thanks to [haifeizhang]()\n* Password policy, validation and expiration, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Health check on /health, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Reuse SchemaCache across requests option, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements\n* Better support for CLI options, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Specity a database timeout with maxTimeMS, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds the username to reset password success pages, thanks to [Halim Qarroum](https://github.com/HQarroum)\n* Better support for Redis cache adapter, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Better coverage of Postgres, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug Fixes\n* Fixes issue when sending push to multiple installations, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issues with twitter authentication, thanks to [jonas-db](https://github.com/jonas-db)\n* Ignore createdAt fields update, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* Improve support for array equality with LiveQuery, thanks to [David Poetzsch-Heffter](https://github.com/dpoetzsch)\n* Improve support for batch endpoint when serverURL and publicServerURL have different paths, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support saving relation objects, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n\n### 2.2.24\n\n#### New Features\n* LiveQuery: Bring your own adapter (#2902), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQuery: Adds \"update\" operator to update a query subscription (#2935), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements\n* Better Postgres support, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Logs the function name when failing (#2963), thanks to [Michael Helvey](https://github.com/michaelhelvey)\n* CLI: forces closing the connections with SIGINT/SIGTERM (#2964), thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Reduce the number of calls to the `_SCHEMA` table (#2912), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* LiveQuery: Support for Role ACL's, thanks to [Aaron Blondeau](https://github.com/aaron-blondeau-dose)\n\n#### Bug Fixes\n* Better support for checking application and client keys, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Google OAuth, better support for android and web logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.23\n\n* Run liveQuery server from CLI with a different port, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support for Postgres databaseURI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Support for Postgres options, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Improved support for google login (id_token and access_token), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improvements with VKontakte login, thanks to [Eugene Antropov](https://github.com/antigp)\n* Improved support for `select` and `include`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n\n* Fix error when updating installation with useMasterKey (#2888), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix bug affecting usage of multiple `notEqualTo`, thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Improved support for null values in arrays, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.22\n\n* Minimum nodejs engine is now 4.5\n\n#### New Features\n* New: CLI for parse-live-query-server, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Start parse-live-query-server for parse-server CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n* Fix: Include with pointers are not conflicting with get CLP anymore, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes dependency on babel-polyfill, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Support nested select calls, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Use native column selection instead of runtime, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: installationId header is properly used when updating `_Installation` objects, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: don't crash parse-server on improperly formatted live-query messages, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Passwords are properly stripped out of logs, thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix: Lookup for email in username if email is not set, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.21\n\n* Fix: Reverts removal of babel-polyfill\n\n### 2.2.20\n\n* New: Adds CloudCode handler for `beforeFind`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: RedisCacheAdapter for syncing schema, role and user caches across servers, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Latest master build available at `ParsePlatform/parse-server#latest`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Better support for upgradeToRevocableSession with missing session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes babel-polyfill runtime dependency, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Cluster option now support a boolean value for automatically choosing the right number of processes, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Filenames now appear correctly, thanks to [Lama Chandrasena](https://github.com/lama-buddy)\n* Fix: `_acl` is properly updated, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\nOther fixes by [Mathias Rangel Wulff](https://github.com/mathiasrw)\n\n### 2.2.19\n\n* New: support for upgrading to revocable sessions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: NullCacheAdapter for disabling caching, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* New: Account lockout policy [#2601](https://github.com/ParsePlatform/parse-server/pull/2601), thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* New: Jobs endpoint for defining and run jobs (no scheduling), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add --cluster option to the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Support for login with vk.com, thanks to [Nurdaulet Bolatov](https://github.com/nbolatov)\n* New: experimental support for postgres databases, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: parse-server doesn't call next() after successful responses, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Nested objects are properly includeed with Pointer Permissions on, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: null values in include calls are properly handled, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Schema validations now runs after beforeSave hooks, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: usersname and passwords are properly type checked, thanks to [Bam Wang](https://github.com/bamwang)\n* Fix: logging in info log would log also in error log, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: removes extaneous logging from ParseLiveQueryServer, thanks to [Flavio Torres](https://github.com/flavionegrao)\n* Fix: support for Range requests for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n\n### 2.2.18\n\n* Fix: Improve support for objects in push alert, thanks to [Antoine Lenoir](https://github.com/alenoir)\n* Fix; Prevent pointed from getting clobbered when they are changed in a beforeSave, thanks to [sud](https://github.com/sud80)\n* Fix: Improve support for \"Bytes\" type, thanks to [CongHoang](https://github.com/conghoang)\n* Fix: Better logging compatability with Parse.com, thanks to [Arthur Cinader](https://github.com/acinader)\n* New: Add Janrain Capture and Janrain Engage auth provider, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Include content length header in files response, thanks to [Steven Van Bael](https://github.com/vbsteven)\n* Improved: Support byte range header for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n* Improved: Validations for LinkedIn access_tokens, thanks to [Felix Dumit](https://github.com/felix-dumit)\n* Improved: Experimental postgres support, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Perf: Use native bcrypt implementation if available, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### [2.2.17](https://github.com/ParsePlatform/parse-server/tree/2.2.17) (07/23/2016)\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.16...2.2.17)\n\n* Cloud code logs [\\#2370](https://github.com/ParsePlatform/parse-server/pull/2370) ([flovilmart](https://github.com/flovilmart))\n* Make sure \\_PushStatus operations are run in order [\\#2367](https://github.com/ParsePlatform/parse-server/pull/2367) ([flovilmart](https://github.com/flovilmart))\n* Typo fix for error message when can't ensure uniqueness of user email addresses [\\#2360](https://github.com/ParsePlatform/parse-server/pull/2360) ([AndrewLane](https://github.com/AndrewLane))\n* LiveQuery constrains matching fix [\\#2357](https://github.com/ParsePlatform/parse-server/pull/2357) ([simonas-notcat](https://github.com/simonas-notcat))\n* Fix typo in logging for commander parseConfigFile [\\#2352](https://github.com/ParsePlatform/parse-server/pull/2352) ([AndrewLane](https://github.com/AndrewLane))\n* Fix minor typos in test names [\\#2351](https://github.com/ParsePlatform/parse-server/pull/2351) ([acinader](https://github.com/acinader))\n* Makes sure we don't strip authData or session token from users using masterKey [\\#2348](https://github.com/ParsePlatform/parse-server/pull/2348) ([flovilmart](https://github.com/flovilmart))\n* Run coverage with istanbul [\\#2340](https://github.com/ParsePlatform/parse-server/pull/2340) ([flovilmart](https://github.com/flovilmart))\n* Run next\\(\\) after successfully sending data to the client [\\#2338](https://github.com/ParsePlatform/parse-server/pull/2338) ([blacha](https://github.com/blacha))\n* Cache all the mongodb/version folder [\\#2336](https://github.com/ParsePlatform/parse-server/pull/2336) ([flovilmart](https://github.com/flovilmart))\n* updates usage of setting: emailVerifyTokenValidityDuration [\\#2331](https://github.com/ParsePlatform/parse-server/pull/2331) ([cherukumilli](https://github.com/cherukumilli))\n* Update Mongodb client to 2.2.4 [\\#2329](https://github.com/ParsePlatform/parse-server/pull/2329) ([flovilmart](https://github.com/flovilmart))\n* Allow usage of analytics adapter [\\#2327](https://github.com/ParsePlatform/parse-server/pull/2327) ([deashay](https://github.com/deashay))\n* Fix flaky tests [\\#2324](https://github.com/ParsePlatform/parse-server/pull/2324) ([flovilmart](https://github.com/flovilmart))\n* don't serve null authData values [\\#2320](https://github.com/ParsePlatform/parse-server/pull/2320) ([yuzeh](https://github.com/yuzeh))\n* Fix null relation problem [\\#2319](https://github.com/ParsePlatform/parse-server/pull/2319) ([flovilmart](https://github.com/flovilmart))\n* Clear the connectionPromise upon close or error [\\#2314](https://github.com/ParsePlatform/parse-server/pull/2314) ([flovilmart](https://github.com/flovilmart))\n* Report validation errors with correct error code [\\#2299](https://github.com/ParsePlatform/parse-server/pull/2299) ([flovilmart](https://github.com/flovilmart))\n* Parses correctly Parse.Files and Dates when sent to Cloud Code Functions [\\#2297](https://github.com/ParsePlatform/parse-server/pull/2297) ([flovilmart](https://github.com/flovilmart))\n* Adding proper generic Not Implemented. [\\#2292](https://github.com/ParsePlatform/parse-server/pull/2292) ([vitaly-t](https://github.com/vitaly-t))\n* Adds schema caching capabilities \\(5s by default\\) [\\#2286](https://github.com/ParsePlatform/parse-server/pull/2286) ([flovilmart](https://github.com/flovilmart))\n* add digits oauth provider [\\#2284](https://github.com/ParsePlatform/parse-server/pull/2284) ([ranhsd](https://github.com/ranhsd))\n* Improve installations query [\\#2281](https://github.com/ParsePlatform/parse-server/pull/2281) ([flovilmart](https://github.com/flovilmart))\n* Adding request headers to cloud functions fixes \\#1461 [\\#2274](https://github.com/ParsePlatform/parse-server/pull/2274) ([blacha](https://github.com/blacha))\n* Creates a new sessionToken when updating password [\\#2266](https://github.com/ParsePlatform/parse-server/pull/2266) ([flovilmart](https://github.com/flovilmart))\n* Add Gitter chat link to the README. [\\#2264](https://github.com/ParsePlatform/parse-server/pull/2264) ([nlutsenko](https://github.com/nlutsenko))\n* Restores ability to include non pointer keys [\\#2263](https://github.com/ParsePlatform/parse-server/pull/2263) ([flovilmart](https://github.com/flovilmart))\n* Allow next middleware handle error in handleParseErrors [\\#2260](https://github.com/ParsePlatform/parse-server/pull/2260) ([mejcz](https://github.com/mejcz))\n* Exposes the ClientSDK infos if available [\\#2259](https://github.com/ParsePlatform/parse-server/pull/2259) ([flovilmart](https://github.com/flovilmart))\n* Adds support for multiple twitter auths options [\\#2256](https://github.com/ParsePlatform/parse-server/pull/2256) ([flovilmart](https://github.com/flovilmart))\n* validate\\_purchase fix for SANDBOX requests [\\#2253](https://github.com/ParsePlatform/parse-server/pull/2253) ([valeryvaskabovich](https://github.com/valeryvaskabovich))\n\n### 2.2.16 (7/10/2016)\n\n* New: Expose InMemoryCacheAdapter publicly, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* New: Add ability to prevent login with unverified email, thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* Improved: Better error message for incorrect type, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Better error message for permission denied, thanks to [Blayne Chard](https://github.com/blacha)\n* Improved: Update authData on login, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improved: Ability to not check for old files on Parse.com, thanks to [OzgeAkin](https://github.com/OzgeAkin)\n* Fix: Issues with email adapter validation, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Issues with nested $or queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.15 (6/30/2016)\n\n* Fix: Type in description for Parse.Error.INVALID_QUERY, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improvement: Stop requiring verifyUserEmails for password reset functionality, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Improvement: Kill without validation, thanks to [Drew Gross](https://github.com/drew-gross)\n* Fix: Deleting a file does not delete from fs.files, thanks to [David Keita](https://github.com/maninga)\n* Fix: Postgres stoage adapter fix, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Fix: Results invalid session when providing an invalid session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: issue creating an anonymous user, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: make http response serializable, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add postmark email adapter alternative [Glenn Reyes](https://github.com/glennreyes)\n\n### 2.2.14 (6/25/2016)\n\n* Hotfix: Fix Parse.Cloud.HTTPResponse serialization\n\n### 2.2.13 (6/12/2016)\n\n* Hotfix: Pin version of deepcopy\n\n### 2.2.12 (6/9/2016)\n\n* New: Custom error codes in cloud code response.error, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Crash in beforeSave when response is not an object, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Allow \"get\" on installations\n* Fix: Fix overly restrictive Class Level Permissions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Fix nested date parsing in Cloud Code, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Support very old file formats from Parse.com\n\n### 2.2.11 (5/31/2016)\n\n* Security: Censor user password in logs, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Add PARSE_SERVER_LOGS_FOLDER env var for setting log folder, thanks to [KartikeyaRokde](https://github.com/KartikeyaRokde)\n* New: Webhook key support, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Perf: Add cache adapter and default caching of certain objects, thanks to [Blayne Chard](https://github.com/blacha)\n* Improvement: Better error messages for schema type mismatches, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Improvement: Better error messages for reset password emails\n* Improvement: Webhook key support in CLI, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Remove read only fields when using beforeSave, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Use content type provided by JS SDK, thanks to [Blayne Chard](https://github.com/blacha) and [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Tell the dashboard the stored push data is available, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Add support for HTTP Basic Auth, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: Support for MongoDB version 3.2.6, (note: do not use MongoDB 3.2 with migrated apps that still have traffic on Parse.com), thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Prevent `pm2` from crashing when push notifications fail, thanks to [benishak](https://github.com/benishak)\n* Fix: Add full list of default _Installation fields, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Strip objectId out of hooks responses, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix external webhook response format, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix beforeSave when object is passed to `success`, thanks to [Madhav Bhagat](https://github.com/codebreach)\n* Fix: Remove use of deprecated APIs, thanks to [Emad Ehsan](https://github.com/emadehsan)\n* Fix: Crash when multiple Parse Servers on the same machine try to write to the same logs folder, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fix: Various issues with key names in `Parse.Object`s\n* Fix: Treat Bytes type properly\n* Fix: Caching bugs that caused writes by masterKey or other session token to not show up to users reading with a different session token\n* Fix: Pin mongo driver version, preventing a regression in version 2.1.19\n* Fix: Various issues with pointer fields not being treated properly\n* Fix: Issues with pointed getting un-fetched due to changes in beforeSave\n* Fix: Fixed crash when deleting classes that have CLPs\n\n### 2.2.10 (5/15/2016)\n\n* Fix: Write legacy ACLs to Mongo so that clients that still go through Parse.com can read them, thanks to [Tyler Brock](https://github.com/TylerBrock) and [carmenlau](https://github.com/carmenlau)\n* Fix: Querying installations with limit = 0 and count = 1 now works, thanks to [ssk7833](https://github.com/ssk7833)\n* Fix: Return correct error when violating unique index, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Allow unsetting user's email, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Support for Node 6.1\n\n### 2.2.9 (5/9/2016)\n\n* Fix: Fix a regression that caused Parse Server to crash when a null parameter is passed to a Cloud function\n\n### 2.2.8 (5/8/2016)\n\n* New: Support for Pointer Permissions\n* New: Expose logger in Cloud Code\n* New: Option to revoke sessions on password reset\n* New: Option to expire inactive sessions\n* Perf: Improvements in ACL checking query\n* Fix: Issues when sending pushes to list of devices that contains invalid values\n* Fix: Issues caused by using babel-polyfill outside of Parse Server, but in the same express app\n* Fix: Remove creation of extra session tokens\n* Fix: Return authData when querying with master key\n* Fix: Bugs when deleting webhooks\n* Fix: Ignore _RevocableSession header, which might be sent by the JS SDK\n* Fix: Issues with querying via URL params\n* Fix: Properly encode \"Date\" parameters to cloud code functions\n\n\n### 2.2.7 (4/15/2016)\n\n* Adds support for --verbose and verbose option when running ParseServer [\\#1414](https://github.com/ParsePlatform/parse-server/pull/1414) ([flovilmart](https://github.com/flovilmart))\n* Adds limit = 0 as a valid parameter for queries [\\#1493](https://github.com/ParsePlatform/parse-server/pull/1493) ([seijiakiyama](https://github.com/seijiakiyama))\n* Makes sure we preserve Installations when updating a token  \\(\\#1475\\) [\\#1486](https://github.com/ParsePlatform/parse-server/pull/1486) ([flovilmart](https://github.com/flovilmart))\n* Hotfix for tests [\\#1503](https://github.com/ParsePlatform/parse-server/pull/1503) ([flovilmart](https://github.com/flovilmart))\n* Enable logs [\\#1502](https://github.com/ParsePlatform/parse-server/pull/1502) ([drew-gross](https://github.com/drew-gross))\n* Do some triple equals for great justice [\\#1499](https://github.com/ParsePlatform/parse-server/pull/1499) ([TylerBrock](https://github.com/TylerBrock))\n* Apply credential stripping to all untransforms for \\_User [\\#1498](https://github.com/ParsePlatform/parse-server/pull/1498) ([TylerBrock](https://github.com/TylerBrock))\n* Checking if object has defined key for Pointer constraints in liveQuery [\\#1487](https://github.com/ParsePlatform/parse-server/pull/1487) ([simonas-notcat](https://github.com/simonas-notcat))\n* Remove collection prefix and default mongo URI [\\#1479](https://github.com/ParsePlatform/parse-server/pull/1479) ([drew-gross](https://github.com/drew-gross))\n* Store collection prefix in mongo adapter, and clean up adapter interface [\\#1472](https://github.com/ParsePlatform/parse-server/pull/1472) ([drew-gross](https://github.com/drew-gross))\n* Move field deletion logic into mongo adapter [\\#1471](https://github.com/ParsePlatform/parse-server/pull/1471) ([drew-gross](https://github.com/drew-gross))\n* Adds support for Long and Double mongodb types \\(fixes \\#1316\\) [\\#1470](https://github.com/ParsePlatform/parse-server/pull/1470) ([flovilmart](https://github.com/flovilmart))\n* Schema.js database agnostic [\\#1468](https://github.com/ParsePlatform/parse-server/pull/1468) ([flovilmart](https://github.com/flovilmart))\n* Remove console.log [\\#1465](https://github.com/ParsePlatform/parse-server/pull/1465) ([drew-gross](https://github.com/drew-gross))\n* Push status nits [\\#1462](https://github.com/ParsePlatform/parse-server/pull/1462) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1444 [\\#1451](https://github.com/ParsePlatform/parse-server/pull/1451) ([flovilmart](https://github.com/flovilmart))\n* Removing sessionToken and authData from \\_User objects included in a query [\\#1450](https://github.com/ParsePlatform/parse-server/pull/1450) ([simonas-notcat](https://github.com/simonas-notcat))\n* Move mongo field type logic into mongoadapter [\\#1432](https://github.com/ParsePlatform/parse-server/pull/1432) ([drew-gross](https://github.com/drew-gross))\n* Prevents \\_User lock out when setting ACL on signup or afterwards [\\#1429](https://github.com/ParsePlatform/parse-server/pull/1429) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1428](https://github.com/ParsePlatform/parse-server/pull/1428) ([flovilmart](https://github.com/flovilmart))\n* Adds relation fields to objects [\\#1424](https://github.com/ParsePlatform/parse-server/pull/1424) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1423](https://github.com/ParsePlatform/parse-server/pull/1423) ([flovilmart](https://github.com/flovilmart))\n* Sets the defaultSchemas keys in the SchemaCollection [\\#1421](https://github.com/ParsePlatform/parse-server/pull/1421) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1417 [\\#1420](https://github.com/ParsePlatform/parse-server/pull/1420) ([drew-gross](https://github.com/drew-gross))\n* Untransform should treat Array's as nested objects [\\#1416](https://github.com/ParsePlatform/parse-server/pull/1416) ([blacha](https://github.com/blacha))\n* Adds X-Parse-Push-Status-Id header [\\#1412](https://github.com/ParsePlatform/parse-server/pull/1412) ([flovilmart](https://github.com/flovilmart))\n* Schema format cleanup [\\#1407](https://github.com/ParsePlatform/parse-server/pull/1407) ([drew-gross](https://github.com/drew-gross))\n* Updates the publicServerURL option [\\#1397](https://github.com/ParsePlatform/parse-server/pull/1397) ([flovilmart](https://github.com/flovilmart))\n* Fix exception with non-expiring session tokens. [\\#1386](https://github.com/ParsePlatform/parse-server/pull/1386) ([0x18B2EE](https://github.com/0x18B2EE))\n* Move mongo schema format related logic into mongo adapter [\\#1385](https://github.com/ParsePlatform/parse-server/pull/1385) ([drew-gross](https://github.com/drew-gross))\n* WIP: Huge performance improvement on roles queries [\\#1383](https://github.com/ParsePlatform/parse-server/pull/1383) ([flovilmart](https://github.com/flovilmart))\n* Removes GCS Adapter from provided adapters [\\#1339](https://github.com/ParsePlatform/parse-server/pull/1339) ([flovilmart](https://github.com/flovilmart))\n* DBController refactoring [\\#1228](https://github.com/ParsePlatform/parse-server/pull/1228) ([flovilmart](https://github.com/flovilmart))\n* Spotify authentication [\\#1226](https://github.com/ParsePlatform/parse-server/pull/1226) ([1nput0utput](https://github.com/1nput0utput))\n* Expose DatabaseAdapter to simplify application tests [\\#1121](https://github.com/ParsePlatform/parse-server/pull/1121) ([steven-supersolid](https://github.com/steven-supersolid))\n\n### 2.2.6 (4/5/2016)\n\n* Important Fix: Disables find on installation from clients [\\#1374](https://github.com/ParsePlatform/parse-server/pull/1374) ([flovilmart](https://github.com/flovilmart))\n* Adds missing options to the CLI [\\#1368](https://github.com/ParsePlatform/parse-server/pull/1368) ([flovilmart](https://github.com/flovilmart))\n* Removes only master on travis [\\#1367](https://github.com/ParsePlatform/parse-server/pull/1367) ([flovilmart](https://github.com/flovilmart))\n* Auth.\\_loadRoles should not query the same role twice. [\\#1366](https://github.com/ParsePlatform/parse-server/pull/1366) ([blacha](https://github.com/blacha))\n\n### 2.2.5 (4/4/2016)\n\n* Improves config loading and tests [\\#1363](https://github.com/ParsePlatform/parse-server/pull/1363) ([flovilmart](https://github.com/flovilmart))\n* Adds travis configuration to deploy NPM on new version tags [\\#1361](https://github.com/ParsePlatform/parse-server/pull/1361) ([gfosco](https://github.com/gfosco))\n* Inject the default schemas properties when loading it [\\#1357](https://github.com/ParsePlatform/parse-server/pull/1357) ([flovilmart](https://github.com/flovilmart))\n* Adds console transport when testing with VERBOSE=1 [\\#1351](https://github.com/ParsePlatform/parse-server/pull/1351) ([flovilmart](https://github.com/flovilmart))\n* Make notEqual work on relations  [\\#1350](https://github.com/ParsePlatform/parse-server/pull/1350) ([flovilmart](https://github.com/flovilmart))\n* Accept only bool for $exists in LiveQuery [\\#1315](https://github.com/ParsePlatform/parse-server/pull/1315) ([drew-gross](https://github.com/drew-gross))\n* Adds more options when using CLI/config [\\#1305](https://github.com/ParsePlatform/parse-server/pull/1305) ([flovilmart](https://github.com/flovilmart))\n* Update error message [\\#1297](https://github.com/ParsePlatform/parse-server/pull/1297) ([drew-gross](https://github.com/drew-gross))\n* Properly let masterKey add fields [\\#1291](https://github.com/ParsePlatform/parse-server/pull/1291) ([flovilmart](https://github.com/flovilmart))\n* Point to \\#1271 as how to write a good issue report [\\#1290](https://github.com/ParsePlatform/parse-server/pull/1290) ([drew-gross](https://github.com/drew-gross))\n* Adds ability to override mount with publicServerURL for production uses [\\#1287](https://github.com/ParsePlatform/parse-server/pull/1287) ([flovilmart](https://github.com/flovilmart))\n* Single object queries to use include and keys [\\#1280](https://github.com/ParsePlatform/parse-server/pull/1280) ([jeremyjackson89](https://github.com/jeremyjackson89))\n* Improves report for Push error in logs and \\_PushStatus [\\#1269](https://github.com/ParsePlatform/parse-server/pull/1269) ([flovilmart](https://github.com/flovilmart))\n* Removes all stdout/err logs while testing [\\#1268](https://github.com/ParsePlatform/parse-server/pull/1268) ([flovilmart](https://github.com/flovilmart))\n* Matching queries with doesNotExist constraint [\\#1250](https://github.com/ParsePlatform/parse-server/pull/1250) ([andrecardoso](https://github.com/andrecardoso))\n* Added session length option for session tokens to server configuration [\\#997](https://github.com/ParsePlatform/parse-server/pull/997) ([Kenishi](https://github.com/Kenishi))\n* Regression test for \\#1259 [\\#1286](https://github.com/ParsePlatform/parse-server/pull/1286) ([drew-gross](https://github.com/drew-gross))\n* Regression test for \\#871 [\\#1283](https://github.com/ParsePlatform/parse-server/pull/1283) ([drew-gross](https://github.com/drew-gross))\n* Add a test to repro \\#701 [\\#1281](https://github.com/ParsePlatform/parse-server/pull/1281) ([drew-gross](https://github.com/drew-gross))\n* Fix for \\#1334: using relative cloud code files broken  [\\#1353](https://github.com/ParsePlatform/parse-server/pull/1353) ([airdrummingfool](https://github.com/airdrummingfool))\n* Fix Issue/1288 [\\#1346](https://github.com/ParsePlatform/parse-server/pull/1346) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1271 [\\#1295](https://github.com/ParsePlatform/parse-server/pull/1295) ([drew-gross](https://github.com/drew-gross))\n* Fixes issue \\#1302 [\\#1314](https://github.com/ParsePlatform/parse-server/pull/1314) ([flovilmart](https://github.com/flovilmart))\n* Fixes bug related to include in queries [\\#1312](https://github.com/ParsePlatform/parse-server/pull/1312) ([flovilmart](https://github.com/flovilmart))\n\n\n### 2.2.4 (3/29/2016)\n\n* Hotfix: fixed imports issue for S3Adapter, GCSAdapter, FileSystemAdapter [\\#1263](https://github.com/ParsePlatform/parse-server/pull/1263) ([drew-gross](https://github.com/drew-gross)\n* Fix: Clean null authData values on _User update [\\#1199](https://github.com/ParsePlatform/parse-server/pull/1199) ([yuzeh](https://github.com/yuzeh))\n\n### 2.2.3 (3/29/2016)\n\n* Fixed bug with invalid email verification link on email update. [\\#1253](https://github.com/ParsePlatform/parse-server/pull/1253) ([kzielonka](https://github.com/kzielonka))\n* Badge update supports increment as well as Increment [\\#1248](https://github.com/ParsePlatform/parse-server/pull/1248) ([flovilmart](https://github.com/flovilmart))\n* Config/Push Tested with the dashboard. [\\#1235](https://github.com/ParsePlatform/parse-server/pull/1235) ([drew-gross](https://github.com/drew-gross))\n* Better logging with winston [\\#1234](https://github.com/ParsePlatform/parse-server/pull/1234) ([flovilmart](https://github.com/flovilmart))\n* Make GlobalConfig work like parse.com [\\#1210](https://github.com/ParsePlatform/parse-server/pull/1210) ([framp](https://github.com/framp))\n* Improve flattening of results from pushAdapter [\\#1204](https://github.com/ParsePlatform/parse-server/pull/1204) ([flovilmart](https://github.com/flovilmart))\n* Push adapters are provided by external packages [\\#1195](https://github.com/ParsePlatform/parse-server/pull/1195) ([flovilmart](https://github.com/flovilmart))\n* Fix flaky test [\\#1188](https://github.com/ParsePlatform/parse-server/pull/1188) ([drew-gross](https://github.com/drew-gross))\n* Fixes problem affecting finding array pointers [\\#1185](https://github.com/ParsePlatform/parse-server/pull/1185) ([flovilmart](https://github.com/flovilmart))\n* Moves Files adapters to external packages [\\#1172](https://github.com/ParsePlatform/parse-server/pull/1172) ([flovilmart](https://github.com/flovilmart))\n* Mark push as enabled in serverInfo endpoint [\\#1164](https://github.com/ParsePlatform/parse-server/pull/1164) ([drew-gross](https://github.com/drew-gross))\n* Document email adapter [\\#1144](https://github.com/ParsePlatform/parse-server/pull/1144) ([drew-gross](https://github.com/drew-gross))\n* Reset password fix [\\#1133](https://github.com/ParsePlatform/parse-server/pull/1133) ([carmenlau](https://github.com/carmenlau))\n\n### 2.2.2 (3/23/2016)\n\n* Important Fix: Mounts createLiveQueryServer, fix babel induced problem [\\#1153](https://github.com/ParsePlatform/parse-server/pull/1153) (flovilmart)\n* Move ParseServer to it's own file [\\#1166](https://github.com/ParsePlatform/parse-server/pull/1166) (flovilmart)\n* Update README.md * remove deploy buttons * replace with community links [\\#1139](https://github.com/ParsePlatform/parse-server/pull/1139) (drew-gross)\n* Adds bootstrap.sh [\\#1138](https://github.com/ParsePlatform/parse-server/pull/1138) (flovilmart)\n* Fix: Do not override username [\\#1142](https://github.com/ParsePlatform/parse-server/pull/1142) (flovilmart)\n* Fix: Add pushId back to GCM payload [\\#1168](https://github.com/ParsePlatform/parse-server/pull/1168) (wangmengyan95)\n\n### 2.2.1 (3/22/2016)\n\n* New: Add FileSystemAdapter file adapter [\\#1098](https://github.com/ParsePlatform/parse-server/pull/1098) (dtsolis)\n* New: Enabled CLP editing [\\#1128](https://github.com/ParsePlatform/parse-server/pull/1128) (drew-gross)\n* Improvement: Reduces the number of connections to mongo created [\\#1111](https://github.com/ParsePlatform/parse-server/pull/1111) (flovilmart)\n* Improvement: Make ParseServer a class [\\#980](https://github.com/ParsePlatform/parse-server/pull/980) (flovilmart)\n* Fix: Adds support for plain object in $add, $addUnique, $remove [\\#1114](https://github.com/ParsePlatform/parse-server/pull/1114) (flovilmart)\n* Fix: Generates default CLP, freezes objects [\\#1132](https://github.com/ParsePlatform/parse-server/pull/1132) (flovilmart)\n* Fix: Properly sets installationId on creating session with 3rd party auth [\\#1110](https://github.com/ParsePlatform/parse-server/pull/1110) (flovilmart)\n\n### 2.2.0 (3/18/2016)\n\n* New Feature: Real-time functionality with Live Queries! [\\#1092](https://github.com/ParsePlatform/parse-server/pull/1092) (wangmengyan95)\n* Improvement: Push Status API [\\#1004](https://github.com/ParsePlatform/parse-server/pull/1004) (flovilmart)\n* Improvement: Allow client operations on Roles [\\#1068](https://github.com/ParsePlatform/parse-server/pull/1068) (flovilmart)\n* Improvement: Add URI encoding to mongo auth parameters [\\#986](https://github.com/ParsePlatform/parse-server/pull/986) (bgw)\n* Improvement: Adds support for apps key in config file, but only support single app for now [\\#979](https://github.com/ParsePlatform/parse-server/pull/979) (flovilmart)\n* Documentation: Getting Started and Configuring Parse Server [\\#988](https://github.com/ParsePlatform/parse-server/pull/988) (hramos)\n* Fix: Various edge cases with REST API [\\#1066](https://github.com/ParsePlatform/parse-server/pull/1066) (flovilmart)\n* Fix: Makes sure the location in results has the proper objectId [\\#1065](https://github.com/ParsePlatform/parse-server/pull/1065) (flovilmart)\n* Fix: Third-party auth is properly removed when unlinked [\\#1081](https://github.com/ParsePlatform/parse-server/pull/1081) (flovilmart)\n* Fix: Clear the session-user cache when changing \\_User objects [\\#1072](https://github.com/ParsePlatform/parse-server/pull/1072) (gfosco)\n* Fix: Bug related to subqueries on unfetched objects [\\#1046](https://github.com/ParsePlatform/parse-server/pull/1046) (flovilmart)\n* Fix: Properly urlencode parameters for email validation and password reset [\\#1001](https://github.com/ParsePlatform/parse-server/pull/1001) (flovilmart)\n* Fix: Better sanitization/decoding of object data for afterSave triggers [\\#992](https://github.com/ParsePlatform/parse-server/pull/992) (flovilmart)\n* Fix: Changes default encoding for httpRequest [\\#892](https://github.com/ParsePlatform/parse-server/pull/892) (flovilmart)\n\n### 2.1.6 (3/11/2016)\n\n* Improvement: Full query support for badge Increment \\(\\#931\\) [\\#983](https://github.com/ParsePlatform/parse-server/pull/983) (flovilmart)\n* Improvement: Shutdown standalone parse server gracefully [\\#958](https://github.com/ParsePlatform/parse-server/pull/958) (raulr)\n* Improvement: Add database options to ParseServer constructor and pass to MongoStorageAdapter [\\#956](https://github.com/ParsePlatform/parse-server/pull/956) (steven-supersolid)\n* Improvement: AuthData logic refactor [\\#952](https://github.com/ParsePlatform/parse-server/pull/952) (flovilmart)\n* Improvement: Changed FileLoggerAdapterSpec to fail gracefully on Windows [\\#946](https://github.com/ParsePlatform/parse-server/pull/946) (aneeshd16)\n* Improvement: Add new schema collection type and replace all usages of direct mongo collection for schema operations. [\\#943](https://github.com/ParsePlatform/parse-server/pull/943) (nlutsenko)\n* Improvement: Adds CLP API to Schema router [\\#898](https://github.com/ParsePlatform/parse-server/pull/898) (flovilmart)\n* Fix: Cleans up authData null keys on login for android crash [\\#978](https://github.com/ParsePlatform/parse-server/pull/978) (flovilmart)\n* Fix: Do master query for before/afterSaveHook [\\#959](https://github.com/ParsePlatform/parse-server/pull/959) (wangmengyan95)\n* Fix: re-add shebang [\\#944](https://github.com/ParsePlatform/parse-server/pull/944) (flovilmart)\n* Fix: Added test command for Windows support [\\#886](https://github.com/ParsePlatform/parse-server/pull/886) (aneeshd16)\n\n### 2.1.5 (3/9/2016)\n\n* New: FileAdapter for Google Cloud Storage [\\#708](https://github.com/ParsePlatform/parse-server/pull/708) (mcdonamp)\n* Improvement: Minimize extra schema queries in some scenarios. [\\#919](https://github.com/ParsePlatform/parse-server/pull/919) (Marco129)\n* Improvement: Move DatabaseController and Schema fully to adaptive mongo collection. [\\#909](https://github.com/ParsePlatform/parse-server/pull/909) (nlutsenko)\n* Improvement: Cleanup PushController/PushRouter, remove raw mongo collection access. [\\#903](https://github.com/ParsePlatform/parse-server/pull/903) (nlutsenko)\n* Improvement: Increment badge the right way [\\#902](https://github.com/ParsePlatform/parse-server/pull/902) (flovilmart)\n* Improvement: Migrate ParseGlobalConfig to new database storage API. [\\#901](https://github.com/ParsePlatform/parse-server/pull/901) (nlutsenko)\n* Improvement: Improve delete flow for non-existent \\_Join collection [\\#881](https://github.com/ParsePlatform/parse-server/pull/881) (Marco129)\n* Improvement: Adding a role scenario test for issue 827 [\\#878](https://github.com/ParsePlatform/parse-server/pull/878) (gfosco)\n* Improvement: Test empty authData block on login for \\#413 [\\#863](https://github.com/ParsePlatform/parse-server/pull/863) (gfosco)\n* Improvement: Modified the npm dev script to support Windows [\\#846](https://github.com/ParsePlatform/parse-server/pull/846) (aneeshd16)\n* Improvement: Move HooksController to use MongoCollection instead of direct Mongo access. [\\#844](https://github.com/ParsePlatform/parse-server/pull/844) (nlutsenko)\n* Improvement: Adds public\\_html and views for packaging [\\#839](https://github.com/ParsePlatform/parse-server/pull/839) (flovilmart)\n* Improvement: Better support for windows builds [\\#831](https://github.com/ParsePlatform/parse-server/pull/831) (flovilmart)\n* Improvement: Convert Schema.js to ES6 class. [\\#826](https://github.com/ParsePlatform/parse-server/pull/826) (nlutsenko)\n* Improvement: Remove duplicated instructions [\\#816](https://github.com/ParsePlatform/parse-server/pull/816) (hramos)\n* Improvement: Completely migrate SchemasRouter to new MongoCollection API. [\\#794](https://github.com/ParsePlatform/parse-server/pull/794) (nlutsenko)\n* Fix: Do not require where clause in $dontSelect condition on queries. [\\#925](https://github.com/ParsePlatform/parse-server/pull/925) (nlutsenko)\n* Fix: Make sure that ACLs propagate to before/after save hooks. [\\#924](https://github.com/ParsePlatform/parse-server/pull/924) (nlutsenko)\n* Fix: Support params option in Parse.Cloud.httpRequest. [\\#912](https://github.com/ParsePlatform/parse-server/pull/912) (carmenlau)\n* Fix: Fix flaky Parse.GeoPoint test. [\\#908](https://github.com/ParsePlatform/parse-server/pull/908) (nlutsenko)\n* Fix: Handle legacy \\_client\\_permissions key in \\_SCHEMA. [\\#900](https://github.com/ParsePlatform/parse-server/pull/900) (drew-gross)\n* Fix: Fixes bug when querying equalTo on objectId and relation [\\#887](https://github.com/ParsePlatform/parse-server/pull/887) (flovilmart)\n* Fix: Allow crossdomain on filesRouter [\\#876](https://github.com/ParsePlatform/parse-server/pull/876) (flovilmart)\n* Fix: Remove limit when counting results. [\\#867](https://github.com/ParsePlatform/parse-server/pull/867) (gfosco)\n* Fix: beforeSave changes should propagate to the response [\\#865](https://github.com/ParsePlatform/parse-server/pull/865) (gfosco)\n* Fix: Delete relation field when \\_Join collection not exist [\\#864](https://github.com/ParsePlatform/parse-server/pull/864) (Marco129)\n* Fix: Related query on non-existing column [\\#861](https://github.com/ParsePlatform/parse-server/pull/861) (gfosco)\n* Fix: Update markdown in .github/ISSUE\\_TEMPLATE.md [\\#859](https://github.com/ParsePlatform/parse-server/pull/859) (igorshubovych)\n* Fix: Issue with creating wrong \\_Session for Facebook login [\\#857](https://github.com/ParsePlatform/parse-server/pull/857) (tobernguyen)\n* Fix: Leak warnings in tests, use mongodb-runner from node\\_modules [\\#843](https://github.com/ParsePlatform/parse-server/pull/843) (drew-gross)\n* Fix: Reversed roles lookup [\\#841](https://github.com/ParsePlatform/parse-server/pull/841) (flovilmart)\n* Fix: Improves loading of Push Adapter, fix loading of S3Adapter [\\#833](https://github.com/ParsePlatform/parse-server/pull/833) (flovilmart)\n* Fix: Add field to system schema [\\#828](https://github.com/ParsePlatform/parse-server/pull/828) (Marco129)\n\n### 2.1.4 (3/3/2016)\n\n* New: serverInfo endpoint that returns server version and info about the server's features\n* Improvement: Add support for badges on iOS\n* Improvement: Improve failure handling in cloud code http requests\n* Improvement: Add support for queries on pointers and relations\n* Improvement: Add support for multiple $in clauses in a query\n* Improvement: Add allowClientClassCreation config option\n* Improvement: Allow atomically setting subdocument keys\n* Improvement: Allow arbitrarily deeply nested roles\n* Improvement: Set proper content-type in S3 File Adapter\n* Improvement: S3 adapter auto-creates buckets\n* Improvement: Better error messages for many errors\n* Performance: Improved algorithm for validating client keys\n* Experimental: Parse Hooks and Hooks API\n* Experimental: Email verification and password reset emails\n* Experimental: Improve compatability of logs feature with Parse.com\n* Fix: Fix for attempting to delete missing classes via schemas API\n* Fix: Allow creation of system classes via schemas API\n* Fix: Allow missing where cause in $select\n* Fix: Improve handling of invalid object ids\n* Fix: Replace query overwriting existing query\n* Fix: Propagate installationId in cloud code triggers\n* Fix: Session expiresAt is now a Date instead of a string\n* Fix: Fix count queries\n* Fix: Disallow _Role objects without names or without ACL\n* Fix: Better handling of invalid types submitted\n* Fix: beforeSave will not be triggered for attempts to save with invalid authData\n* Fix: Fix duplicate device token issues on Android\n* Fix: Allow empty authData on signup\n* Fix: Allow Master Key Headers (CORS)\n* Fix: Fix bugs if JavaScript key was not provided in server configuration\n* Fix: Parse Files on objects can now be stored without URLs\n* Fix: allow both objectId or installationId when modifying installation\n* Fix: Command line works better when not given options\n\n### 2.1.3 (2/24/2016)\n\n* Feature: Add initial support for in-app purchases\n* Feature: Better error messages when attempting to run the server on a port that is already in use or without a server URL\n* Feature: Allow customization of max file size\n* Performance: Faster saves if not using beforeSave triggers\n* Fix: Send session token in response to current user endpoint\n* Fix: Remove triggers for _Session collection\n* Fix: Improve compatability of cloud code beforeSave hook for newly created object\n* Fix: ACL creation for master key only objects\n* Fix: Allow uploading files without Content-Type\n* Fix: Add features to http request to match Parse.com\n* Fix: Bugs in development script when running from locations other than project root\n* Fix: Can pass query constraints in URL\n* Fix: Objects with legacy \"_tombstone\" key now don't cause issues.\n* Fix: Allow nested keys in objects to begin with underscores\n* Fix: Allow correct headers for CORS\n\n### 2.1.2 (2/19/2016)\n\n* Change: The S3 file adapter constructor requires a bucket name\n* Fix: Parse Query should throw if improperly encoded\n* Fix: Issue where roles were not used in some requests\n* Fix: serverURL will no longer default to api.parse.com/1\n\n### 2.1.1 (2/18/2016)\n\n* Experimental: Schemas API support for DELETE operations\n* Fix: Session token issue fetching Users\n* Fix: Facebook auth validation\n* Fix: Invalid error when deleting missing session\n\n### 2.1.0 (2/17/2016)\n\n* Feature: Support for additional OAuth providers\n* Feature: Ability to implement custom OAuth providers\n* Feature: Support for deleting Parse Files\n* Feature: Allow querying roles\n* Feature: Support for logs, extensible via Log Adapter\n* Feature: New Push Adapter for sending push notifications through OneSignal\n* Feature: Tighter default security for Users\n* Feature: Pass parameters to cloud code in query string\n* Feature: Disable anonymous users via configuration.\n* Experimental: Schemas API support for PUT operations\n* Fix: Prevent installation ID from being added to User\n* Fix: Becoming a user works properly with sessions\n* Fix: Including multiple object when some object are unavailable will get all the objects that are available\n* Fix: Invalid URL for Parse Files\n* Fix: Making a query without a limit now returns 100 results\n* Fix: Expose installation id in cloud code\n* Fix: Correct username for Anonymous users\n* Fix: Session token issue after fetching user\n* Fix: Issues during install process\n* Fix: Issue with Unity SDK sending _noBody\n\n### 2.0.8 (2/11/2016)\n\n* Add: support for Android and iOS push notifications\n* Experimental: cloud code validation hooks (can mark as non-experimental after we have docs)\n* Experimental: support for schemas API (GET and POST only)\n* Experimental: support for Parse Config (GET and POST only)\n* Fix: Querying objects with equality constraint on array column\n* Fix: User logout will remove session token\n* Fix: Various files related bugs\n* Fix: Force minimum node version 4.3 due to security issues in earlier version\n* Performance Improvement: Improved caching\n", "// This is a port of the test suite:\n// hungry/js/test/parse_user_test.js\n//\n// Things that we didn't port:\n// Tests that involve revocable sessions.\n// Tests that involve sending password reset emails.\n\n'use strict';\n\nconst MongoStorageAdapter = require('../lib/Adapters/Storage/Mongo/MongoStorageAdapter').default;\nconst request = require('../lib/request');\nconst passwordCrypto = require('../lib/password');\nconst Config = require('../lib/Config');\nconst cryptoUtils = require('../lib/cryptoUtils');\n\nfunction verifyACL(user) {\n  const ACL = user.getACL();\n  expect(ACL.getReadAccess(user)).toBe(true);\n  expect(ACL.getWriteAccess(user)).toBe(true);\n  expect(ACL.getPublicReadAccess()).toBe(true);\n  expect(ACL.getPublicWriteAccess()).toBe(false);\n  const perms = ACL.permissionsById;\n  expect(Object.keys(perms).length).toBe(2);\n  expect(perms[user.id].read).toBe(true);\n  expect(perms[user.id].write).toBe(true);\n  expect(perms['*'].read).toBe(true);\n  expect(perms['*'].write).not.toBe(true);\n}\n\ndescribe('Parse.User testing', () => {\n  it('user sign up class method', async done => {\n    const user = await Parse.User.signUp('asdf', 'zxcv');\n    ok(user.getSessionToken());\n    done();\n  });\n\n  it('user sign up instance method', async () => {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    await user.signUp();\n    ok(user.getSessionToken());\n  });\n\n  it('user login wrong username', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    try {\n      await Parse.User.logIn('non_existent_user', 'asdf3');\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });\n\n  it('user login wrong password', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    try {\n      await Parse.User.logIn('asdf', 'asdfWrong');\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });\n\n  it('user login with non-string username with REST API', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        _method: 'GET',\n        username: { $regex: '^asd' },\n        password: 'zxcv',\n      },\n    })\n      .then(res => {\n        fail(`no request should succeed: ${JSON.stringify(res)}`);\n        done();\n      })\n      .catch(err => {\n        expect(err.status).toBe(404);\n        expect(err.text).toMatch('{\"code\":101,\"error\":\"Invalid username/password.\"}');\n        done();\n      });\n  });\n\n  it('user login with non-string username with REST API (again)', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        _method: 'GET',\n        username: 'asdf',\n        password: { $regex: '^zx' },\n      },\n    })\n      .then(res => {\n        fail(`no request should succeed: ${JSON.stringify(res)}`);\n        done();\n      })\n      .catch(err => {\n        expect(err.status).toBe(404);\n        expect(err.text).toMatch('{\"code\":101,\"error\":\"Invalid username/password.\"}');\n        done();\n      });\n  });\n\n  it('user login using POST with REST API', async done => {\n    await Parse.User.signUp('some_user', 'some_password');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n      },\n      body: {\n        username: 'some_user',\n        password: 'some_password',\n      },\n    })\n      .then(res => {\n        expect(res.data.username).toBe('some_user');\n        done();\n      })\n      .catch(err => {\n        fail(`no request should fail: ${JSON.stringify(err)}`);\n        done();\n      });\n  });\n\n  it('user login', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    const user = await Parse.User.logIn('asdf', 'zxcv');\n    equal(user.get('username'), 'asdf');\n    verifyACL(user);\n    done();\n  });\n\n  it('should respect ACL without locking user out', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('asdf');\n    user.setPassword('zxcv');\n    user.setACL(ACL);\n    user\n      .signUp()\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        equal(user.get('username'), 'asdf');\n        const ACL = user.getACL();\n        expect(ACL.getReadAccess(user)).toBe(true);\n        expect(ACL.getWriteAccess(user)).toBe(true);\n        expect(ACL.getPublicReadAccess()).toBe(false);\n        expect(ACL.getPublicWriteAccess()).toBe(false);\n        const perms = ACL.permissionsById;\n        expect(Object.keys(perms).length).toBe(1);\n        expect(perms[user.id].read).toBe(true);\n        expect(perms[user.id].write).toBe(true);\n        expect(perms['*']).toBeUndefined();\n        // Try to lock out user\n        const newACL = new Parse.ACL();\n        newACL.setReadAccess(user.id, false);\n        newACL.setWriteAccess(user.id, false);\n        user.setACL(newACL);\n        return user.save();\n      })\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        equal(user.get('username'), 'asdf');\n        const ACL = user.getACL();\n        expect(ACL.getReadAccess(user)).toBe(true);\n        expect(ACL.getWriteAccess(user)).toBe(true);\n        expect(ACL.getPublicReadAccess()).toBe(false);\n        expect(ACL.getPublicWriteAccess()).toBe(false);\n        const perms = ACL.permissionsById;\n        expect(Object.keys(perms).length).toBe(1);\n        expect(perms[user.id].read).toBe(true);\n        expect(perms[user.id].write).toBe(true);\n        expect(perms['*']).toBeUndefined();\n        done();\n      })\n      .catch(() => {\n        fail('Should not fail');\n        done();\n      });\n  });\n\n  it('should let masterKey lockout user', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('asdf');\n    user.setPassword('zxcv');\n    user.setACL(ACL);\n    user\n      .signUp()\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        equal(user.get('username'), 'asdf');\n        // Lock the user down\n        const ACL = new Parse.ACL();\n        user.setACL(ACL);\n        return user.save(null, { useMasterKey: true });\n      })\n      .then(() => {\n        expect(user.getACL().getPublicReadAccess()).toBe(false);\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.message).toBe('Invalid username/password.');\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n  });\n\n  it_only_db('mongo')('should let legacy users without ACL login', async () => {\n    const databaseURI = 'mongodb://localhost:27017/parseServerMongoAdapterTestDatabase';\n    const adapter = new MongoStorageAdapter({\n      collectionPrefix: 'test_',\n      uri: databaseURI,\n    });\n    await adapter.connect();\n    await adapter.database.dropDatabase();\n    delete adapter.connectionPromise;\n\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'newUser',\n      password: 'password',\n    });\n\n    const collection = await adapter._adaptiveCollection('_User');\n    await collection.insertOne({\n      // the hashed password is 'password' hashed\n      _hashed_password: '$2b$10$mJ2ca2UbCM9hlojYHZxkQe8pyEXe5YMg0nMdvP4AJBeqlTEZJ6/Uu',\n      _session_token: 'xxx',\n      email: 'xxx@a.b',\n      username: 'oldUser',\n      emailVerified: true,\n      _email_verify_token: 'yyy',\n    });\n\n    // get the 2 users\n    const users = await collection.find();\n    expect(users.length).toBe(2);\n\n    const aUser = await Parse.User.logIn('oldUser', 'password');\n    expect(aUser).not.toBeUndefined();\n\n    const newUser = await Parse.User.logIn('newUser', 'password');\n    expect(newUser).not.toBeUndefined();\n  });\n\n  it('should be let masterKey lock user out with authData', async () => {\n    const response = await request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        key: 'value',\n        authData: { anonymous: { id: '00000000-0000-0000-0000-000000000001' } },\n      },\n    });\n    const body = response.data;\n    const objectId = body.objectId;\n    const sessionToken = body.sessionToken;\n    expect(sessionToken).toBeDefined();\n    expect(objectId).toBeDefined();\n    const user = new Parse.User();\n    user.id = objectId;\n    const ACL = new Parse.ACL();\n    user.setACL(ACL);\n    await user.save(null, { useMasterKey: true });\n    // update the user\n    const options = {\n      method: 'POST',\n      url: `http://localhost:8378/1/classes/_User/`,\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        key: 'otherValue',\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    };\n    const res = await request(options);\n    expect(res.data.objectId).not.toEqual(objectId);\n  });\n\n  it('user login with files', done => {\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file\n      .save()\n      .then(file => {\n        return Parse.User.signUp('asdf', 'zxcv', { file: file });\n      })\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        const fileAgain = user.get('file');\n        ok(fileAgain.name());\n        ok(fileAgain.url());\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('become sends token back', done => {\n    let user = null;\n    let sessionToken = null;\n\n    Parse.User.signUp('Jason', 'Parse', { code: 'red' })\n      .then(newUser => {\n        user = newUser;\n        expect(user.get('code'), 'red');\n\n        sessionToken = newUser.getSessionToken();\n        expect(sessionToken).toBeDefined();\n\n        return Parse.User.become(sessionToken);\n      })\n      .then(newUser => {\n        expect(newUser.id).toEqual(user.id);\n        expect(newUser.get('username'), 'Jason');\n        expect(newUser.get('code'), 'red');\n        expect(newUser.getSessionToken()).toEqual(sessionToken);\n      })\n      .then(\n        () => {\n          done();\n        },\n        error => {\n          jfail(error);\n          done();\n        }\n      );\n  });\n\n  it('become', done => {\n    let user = null;\n    let sessionToken = null;\n\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('Jason', 'Parse', { code: 'red' });\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n\n        user = newUser;\n        sessionToken = newUser.getSessionToken();\n        ok(sessionToken);\n\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        ok(!Parse.User.current());\n\n        return Parse.User.become(sessionToken);\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n\n        ok(newUser);\n        equal(newUser.id, user.id);\n        equal(newUser.get('username'), 'Jason');\n        equal(newUser.get('code'), 'red');\n\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        ok(!Parse.User.current());\n\n        return Parse.User.become('somegarbage');\n      })\n      .then(\n        function () {\n          // This should have failed actually.\n          ok(false, \"Shouldn't have been able to log in with garbage session token.\");\n        },\n        function (error) {\n          ok(error);\n          // Handle the error.\n          return Promise.resolve();\n        }\n      )\n      .then(\n        function () {\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('should not call beforeLogin with become', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n\n    await Parse.User._logInWith('facebook');\n    const sessionToken = Parse.User.current().getSessionToken();\n    await Parse.User.become(sessionToken);\n    expect(hit).toBe(0);\n    done();\n  });\n\n  it('cannot save non-authed user', async done => {\n    let user = new Parse.User();\n    user.set({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    let userAgain = await user.signUp();\n    equal(userAgain, user);\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    user.set({\n      username: 'hacker',\n      password: 'password',\n    });\n    userAgain = await user.signUp();\n    equal(userAgain, user);\n    userNotAuthed.set('username', 'changed');\n    userNotAuthed.save().then(fail, err => {\n      expect(err.code).toEqual(Parse.Error.SESSION_MISSING);\n      done();\n    });\n  });\n\n  it('cannot delete non-authed user', async done => {\n    let user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    const userAgain = await user.signUp({\n      username: 'hacker',\n      password: 'password',\n    });\n    equal(userAgain, user);\n    userNotAuthed.set('username', 'changed');\n    try {\n      await userNotAuthed.destroy();\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n      done();\n    }\n  });\n\n  it('cannot saveAll with non-authed user', async done => {\n    let user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    await user.signUp({\n      username: 'hacker',\n      password: 'password',\n    });\n    const userNotAuthedNotChanged = await query.get(user.id);\n    userNotAuthed.set('username', 'changed');\n    const object = new TestObject();\n    await object.save({\n      user: userNotAuthedNotChanged,\n    });\n    const item1 = new TestObject();\n    await item1.save({\n      number: 0,\n    });\n    item1.set('number', 1);\n    const item2 = new TestObject();\n    item2.set('number', 2);\n    try {\n      await Parse.Object.saveAll([item1, item2, userNotAuthed]);\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n      done();\n    }\n  });\n\n  it('never locks himself up', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'username',\n      password: 'password',\n    });\n    user.setACL(new Parse.ACL());\n    await user.save();\n    await user.fetch();\n    expect(user.getACL().getReadAccess(user)).toBe(true);\n    expect(user.getACL().getWriteAccess(user)).toBe(true);\n    const publicReadACL = new Parse.ACL();\n    publicReadACL.setPublicReadAccess(true);\n\n    // Create an administrator role with a single admin user\n    const role = new Parse.Role('admin', publicReadACL);\n    const admin = new Parse.User();\n    await admin.signUp({\n      username: 'admin',\n      password: 'admin',\n    });\n    role.getUsers().add(admin);\n    await role.save(null, { useMasterKey: true });\n\n    // Grant the admins write rights on the user\n    const acl = user.getACL();\n    acl.setRoleWriteAccess(role, true);\n    acl.setRoleReadAccess(role, true);\n\n    // Update with the masterKey just to be sure\n    await user.save({ ACL: acl }, { useMasterKey: true });\n\n    // Try to update from admin... should all work fine\n    await user.save({ key: 'fromAdmin' }, { sessionToken: admin.getSessionToken() });\n    await user.fetch();\n    expect(user.toJSON().key).toEqual('fromAdmin');\n\n    // Try to save when logged out (public)\n    let failed = false;\n    try {\n      // Ensure no session token is sent\n      await Parse.User.logOut();\n      await user.save({ key: 'fromPublic' });\n    } catch (e) {\n      failed = true;\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    expect({ failed }).toEqual({ failed: true });\n\n    // Try to save with a random user, should fail\n    failed = false;\n    const anyUser = new Parse.User();\n    await anyUser.signUp({\n      username: 'randomUser',\n      password: 'password',\n    });\n    try {\n      await user.save({ key: 'fromAnyUser' });\n    } catch (e) {\n      failed = true;\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    expect({ failed }).toEqual({ failed: true });\n  });\n\n  it('current user', done => {\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    user\n      .signUp()\n      .then(() => {\n        const currentUser = Parse.User.current();\n        equal(user.id, currentUser.id);\n        ok(user.getSessionToken());\n\n        const currentUserAgain = Parse.User.current();\n        // should be the same object\n        equal(currentUser, currentUserAgain);\n\n        // test logging out the current user\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        equal(Parse.User.current(), null);\n        done();\n      });\n  });\n\n  it('user.isCurrent', done => {\n    const user1 = new Parse.User();\n    const user2 = new Parse.User();\n    const user3 = new Parse.User();\n\n    user1.set('username', 'a');\n    user2.set('username', 'b');\n    user3.set('username', 'c');\n\n    user1.set('password', 'password');\n    user2.set('password', 'password');\n    user3.set('password', 'password');\n\n    user1\n      .signUp()\n      .then(() => {\n        equal(user1.isCurrent(), true);\n        equal(user2.isCurrent(), false);\n        equal(user3.isCurrent(), false);\n        return user2.signUp();\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), true);\n        equal(user3.isCurrent(), false);\n        return user3.signUp();\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), false);\n        equal(user3.isCurrent(), true);\n        return Parse.User.logIn('a', 'password');\n      })\n      .then(() => {\n        equal(user1.isCurrent(), true);\n        equal(user2.isCurrent(), false);\n        equal(user3.isCurrent(), false);\n        return Parse.User.logIn('b', 'password');\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), true);\n        equal(user3.isCurrent(), false);\n        return Parse.User.logIn('b', 'password');\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), true);\n        equal(user3.isCurrent(), false);\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        equal(user2.isCurrent(), false);\n        done();\n      });\n  });\n\n  it('user associations', async done => {\n    const child = new TestObject();\n    await child.save();\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    user.set('child', child);\n    await user.signUp();\n    const object = new TestObject();\n    object.set('user', user);\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    const objectAgain = await query.get(object.id);\n    const userAgain = objectAgain.get('user');\n    await userAgain.fetch();\n    equal(user.id, userAgain.id);\n    equal(userAgain.get('child').id, child.id);\n    done();\n  });\n\n  it('user queries', async done => {\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    await user.signUp();\n    const query = new Parse.Query(Parse.User);\n    const userAgain = await query.get(user.id);\n    equal(userAgain.id, user.id);\n    const users = await query.find();\n    equal(users.length, 1);\n    equal(users[0].id, user.id);\n    ok(userAgain.get('email'), 'asdf@example.com');\n    done();\n  });\n\n  function signUpAll(list, optionsOrCallback) {\n    let promise = Promise.resolve();\n    list.forEach(user => {\n      promise = promise.then(function () {\n        return user.signUp();\n      });\n    });\n    promise = promise.then(function () {\n      return list;\n    });\n    return promise.then(optionsOrCallback);\n  }\n\n  it('contained in user array queries', async done => {\n    const USERS = 4;\n    const MESSAGES = 5;\n\n    // Make a list of users.\n    const userList = range(USERS).map(function (i) {\n      const user = new Parse.User();\n      user.set('password', 'user_num_' + i);\n      user.set('email', 'user_num_' + i + '@example.com');\n      user.set('username', 'xinglblog_num_' + i);\n      return user;\n    });\n\n    signUpAll(userList, async function (users) {\n      // Make a list of messages.\n      if (!users || users.length != USERS) {\n        fail('signupAll failed');\n        done();\n        return;\n      }\n      const messageList = range(MESSAGES).map(function (i) {\n        const message = new TestObject();\n        message.set('to', users[(i + 1) % USERS]);\n        message.set('from', users[i % USERS]);\n        return message;\n      });\n\n      // Save all the messages.\n      await Parse.Object.saveAll(messageList);\n\n      // Assemble an \"in\" list.\n      const inList = [users[0], users[3], users[3]]; // Intentional dupe\n      const query = new Parse.Query(TestObject);\n      query.containedIn('from', inList);\n      const results = await query.find();\n      equal(results.length, 3);\n      done();\n    });\n  });\n\n  it(\"saving a user signs them up but doesn't log them in\", async done => {\n    const user = new Parse.User();\n    await user.save({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    equal(Parse.User.current(), null);\n    done();\n  });\n\n  it('user updates', async done => {\n    const user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n\n    user.set('username', 'test');\n    await user.save();\n    equal(Object.keys(user.attributes).length, 6);\n    ok(user.attributes['username']);\n    ok(user.attributes['email']);\n    await user.destroy();\n    const query = new Parse.Query(Parse.User);\n    try {\n      await query.get(user.id);\n      done.fail();\n    } catch (error) {\n      // The user should no longer exist.\n      equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });\n\n  it('count users', async done => {\n    const james = new Parse.User();\n    james.set('username', 'james');\n    james.set('password', 'mypass');\n    await james.signUp();\n    const kevin = new Parse.User();\n    kevin.set('username', 'kevin');\n    kevin.set('password', 'mypass');\n    await kevin.signUp();\n    const query = new Parse.Query(Parse.User);\n    const count = await query.count();\n    equal(count, 2);\n    done();\n  });\n\n  it('user sign up with container class', async done => {\n    await Parse.User.signUp('ilya', 'mypass', { array: ['hello'] });\n    done();\n  });\n\n  it('user modified while saving', done => {\n    Parse.Object.disableSingleInstance();\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'password');\n    user.signUp().then(function (userAgain) {\n      equal(userAgain.get('username'), 'bob');\n      ok(userAgain.dirty('username'));\n      const query = new Parse.Query(Parse.User);\n      query.get(user.id).then(freshUser => {\n        equal(freshUser.id, user.id);\n        equal(freshUser.get('username'), 'alice');\n        done();\n      });\n    });\n    // Jump a frame so the signup call is properly sent\n    // This is due to the fact that now, we use real promises\n    process.nextTick(() => {\n      ok(user.set('username', 'bob'));\n    });\n  });\n\n  it('user modified while saving with unsaved child', done => {\n    Parse.Object.disableSingleInstance();\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'password');\n    user.set('child', new TestObject());\n    user.signUp().then(userAgain => {\n      equal(userAgain.get('username'), 'bob');\n      // Should be dirty, but it depends on batch support.\n      // ok(userAgain.dirty(\"username\"));\n      const query = new Parse.Query(Parse.User);\n      query.get(user.id).then(freshUser => {\n        equal(freshUser.id, user.id);\n        // Should be alice, but it depends on batch support.\n        equal(freshUser.get('username'), 'bob');\n        done();\n      });\n    });\n    ok(user.set('username', 'bob'));\n  });\n\n  it('user loaded from localStorage from signup', async done => {\n    const alice = await Parse.User.signUp('alice', 'password');\n    ok(alice.id, 'Alice should have an objectId');\n    ok(alice.getSessionToken(), 'Alice should have a session token');\n    equal(alice.get('password'), undefined, 'Alice should not have a password');\n\n    // Simulate the environment getting reset.\n    Parse.User._currentUser = null;\n    Parse.User._currentUserMatchesDisk = false;\n\n    const aliceAgain = Parse.User.current();\n    equal(aliceAgain.get('username'), 'alice');\n    equal(aliceAgain.id, alice.id, 'currentUser should have objectId');\n    ok(aliceAgain.getSessionToken(), 'currentUser should have a sessionToken');\n    equal(alice.get('password'), undefined, 'currentUser should not have password');\n    done();\n  });\n\n  it('user loaded from localStorage from login', done => {\n    let id;\n    Parse.User.signUp('alice', 'password')\n      .then(alice => {\n        id = alice.id;\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.logIn('alice', 'password');\n      })\n      .then(() => {\n        // Force the current user to read from disk\n        delete Parse.User._currentUser;\n        delete Parse.User._currentUserMatchesDisk;\n\n        const userFromDisk = Parse.User.current();\n        equal(userFromDisk.get('password'), undefined, 'password should not be in attributes');\n        equal(userFromDisk.id, id, 'id should be set');\n        ok(userFromDisk.getSessionToken(), 'currentUser should have a sessionToken');\n        done();\n      });\n  });\n\n  it('saving user after browser refresh', done => {\n    let id;\n\n    Parse.User.signUp('alice', 'password', null)\n      .then(function (alice) {\n        id = alice.id;\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.logIn('alice', 'password');\n      })\n      .then(function () {\n        // Simulate browser refresh by force-reloading user from localStorage\n        Parse.User._clearCache();\n\n        // Test that this save works correctly\n        return Parse.User.current().save({ some_field: 1 });\n      })\n      .then(\n        function () {\n          // Check the user in memory just after save operation\n          const userInMemory = Parse.User.current();\n\n          equal(\n            userInMemory.getUsername(),\n            'alice',\n            'saving user should not remove existing fields'\n          );\n\n          equal(userInMemory.get('some_field'), 1, 'saving user should save specified field');\n\n          equal(\n            userInMemory.get('password'),\n            undefined,\n            'password should not be in attributes after saving user'\n          );\n\n          equal(\n            userInMemory.get('objectId'),\n            undefined,\n            'objectId should not be in attributes after saving user'\n          );\n\n          equal(\n            userInMemory.get('_id'),\n            undefined,\n            '_id should not be in attributes after saving user'\n          );\n\n          equal(userInMemory.id, id, 'id should be set');\n\n          expect(userInMemory.updatedAt instanceof Date).toBe(true);\n\n          ok(userInMemory.createdAt instanceof Date);\n\n          ok(userInMemory.getSessionToken(), 'user should have a sessionToken after saving');\n\n          // Force the current user to read from localStorage, and check again\n          delete Parse.User._currentUser;\n          delete Parse.User._currentUserMatchesDisk;\n          const userFromDisk = Parse.User.current();\n\n          equal(\n            userFromDisk.getUsername(),\n            'alice',\n            'userFromDisk should have previously existing fields'\n          );\n\n          equal(userFromDisk.get('some_field'), 1, 'userFromDisk should have saved field');\n\n          equal(\n            userFromDisk.get('password'),\n            undefined,\n            'password should not be in attributes of userFromDisk'\n          );\n\n          equal(\n            userFromDisk.get('objectId'),\n            undefined,\n            'objectId should not be in attributes of userFromDisk'\n          );\n\n          equal(\n            userFromDisk.get('_id'),\n            undefined,\n            '_id should not be in attributes of userFromDisk'\n          );\n\n          equal(userFromDisk.id, id, 'id should be set on userFromDisk');\n\n          ok(userFromDisk.updatedAt instanceof Date);\n\n          ok(userFromDisk.createdAt instanceof Date);\n\n          ok(userFromDisk.getSessionToken(), 'userFromDisk should have a sessionToken');\n\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('user with missing username', async done => {\n    const user = new Parse.User();\n    user.set('password', 'foo');\n    try {\n      await user.signUp();\n      done.fail();\n    } catch (error) {\n      equal(error.code, Parse.Error.OTHER_CAUSE);\n      done();\n    }\n  });\n\n  it('user with missing password', async done => {\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    try {\n      await user.signUp();\n      done.fail();\n    } catch (error) {\n      equal(error.code, Parse.Error.OTHER_CAUSE);\n      done();\n    }\n  });\n\n  it('user stupid subclassing', async done => {\n    const SuperUser = Parse.Object.extend('User');\n    const user = new SuperUser();\n    user.set('username', 'bob');\n    user.set('password', 'welcome');\n    ok(user instanceof Parse.User, 'Subclassing User should have worked');\n    await user.signUp();\n    done();\n  });\n\n  it('user signup class method uses subclassing', async done => {\n    const SuperUser = Parse.User.extend({\n      secret: function () {\n        return 1337;\n      },\n    });\n\n    const user = await Parse.User.signUp('bob', 'welcome');\n    ok(user instanceof SuperUser, 'Subclassing User should have worked');\n    equal(user.secret(), 1337);\n    done();\n  });\n\n  it('user on disk gets updated after save', async done => {\n    Parse.User.extend({\n      isSuper: function () {\n        return true;\n      },\n    });\n\n    const user = await Parse.User.signUp('bob', 'welcome');\n    await user.save('secret', 1337);\n    delete Parse.User._currentUser;\n    delete Parse.User._currentUserMatchesDisk;\n\n    const userFromDisk = Parse.User.current();\n    equal(userFromDisk.get('secret'), 1337);\n    ok(userFromDisk.isSuper(), 'The subclass should have been used');\n    done();\n  });\n\n  it(\"current user isn't dirty\", async done => {\n    const user = await Parse.User.signUp('andrew', 'oppa', {\n      style: 'gangnam',\n    });\n    ok(!user.dirty('style'), 'The user just signed up.');\n    Parse.User._currentUser = null;\n    Parse.User._currentUserMatchesDisk = false;\n    const userAgain = Parse.User.current();\n    ok(!userAgain.dirty('style'), 'The user was just read from disk.');\n    done();\n  });\n\n  const getMockFacebookProviderWithIdToken = function (id, token) {\n    return {\n      authData: {\n        id: id,\n        access_token: token,\n        expiration_date: new Date().toJSON(),\n      },\n      shouldError: false,\n      loggedOut: false,\n      synchronizedUserId: null,\n      synchronizedAuthToken: null,\n      synchronizedExpiration: null,\n\n      authenticate: function (options) {\n        if (this.shouldError) {\n          options.error(this, 'An error occurred');\n        } else if (this.shouldCancel) {\n          options.error(this, null);\n        } else {\n          options.success(this, this.authData);\n        }\n      },\n      restoreAuthentication: function (authData) {\n        if (!authData) {\n          this.synchronizedUserId = null;\n          this.synchronizedAuthToken = null;\n          this.synchronizedExpiration = null;\n          return true;\n        }\n        this.synchronizedUserId = authData.id;\n        this.synchronizedAuthToken = authData.access_token;\n        this.synchronizedExpiration = authData.expiration_date;\n        return true;\n      },\n      getAuthType: function () {\n        return 'facebook';\n      },\n      deauthenticate: function () {\n        this.loggedOut = true;\n        this.restoreAuthentication(null);\n      },\n    };\n  };\n\n  // Note that this mocks out client-side Facebook action rather than\n  // server-side.\n  const getMockFacebookProvider = function () {\n    return getMockFacebookProviderWithIdToken('8675309', 'jenny');\n  };\n\n  const getMockMyOauthProvider = function () {\n    return {\n      authData: {\n        id: '12345',\n        access_token: '12345',\n        expiration_date: new Date().toJSON(),\n      },\n      shouldError: false,\n      loggedOut: false,\n      synchronizedUserId: null,\n      synchronizedAuthToken: null,\n      synchronizedExpiration: null,\n\n      authenticate: function (options) {\n        if (this.shouldError) {\n          options.error(this, 'An error occurred');\n        } else if (this.shouldCancel) {\n          options.error(this, null);\n        } else {\n          options.success(this, this.authData);\n        }\n      },\n      restoreAuthentication: function (authData) {\n        if (!authData) {\n          this.synchronizedUserId = null;\n          this.synchronizedAuthToken = null;\n          this.synchronizedExpiration = null;\n          return true;\n        }\n        this.synchronizedUserId = authData.id;\n        this.synchronizedAuthToken = authData.access_token;\n        this.synchronizedExpiration = authData.expiration_date;\n        return true;\n      },\n      getAuthType: function () {\n        return 'myoauth';\n      },\n      deauthenticate: function () {\n        this.loggedOut = true;\n        this.restoreAuthentication(null);\n      },\n    };\n  };\n\n  Parse.User.extend({\n    extended: function () {\n      return true;\n    },\n  });\n\n  it('log in with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    done();\n  });\n\n  it('can not set authdata to null', async () => {\n    try {\n      const provider = getMockFacebookProvider();\n      Parse.User._registerAuthenticationProvider(provider);\n      const user = await Parse.User._logInWith('facebook');\n      user.set('authData', null);\n      await user.save();\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('This authentication method is unsupported.');\n    }\n  });\n\n  it('ignore setting authdata to undefined', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    user.set('authData', undefined);\n    await user.save();\n    let authData = user.get('authData');\n    expect(authData).toBe(undefined);\n    await user.fetch();\n    authData = user.get('authData');\n    expect(authData.facebook.id).toBeDefined();\n  });\n\n  it('user authData should be available in cloudcode (#2342)', async done => {\n    Parse.Cloud.define('checkLogin', req => {\n      expect(req.user).not.toBeUndefined();\n      expect(Parse.FacebookUtils.isLinked(req.user)).toBe(true);\n      return 'ok';\n    });\n\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n\n    Parse.Cloud.run('checkLogin').then(done, done);\n  });\n\n  it('log in with provider and update token', async done => {\n    const provider = getMockFacebookProvider();\n    const secondProvider = getMockFacebookProviderWithIdToken('8675309', 'jenny_valid_token');\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    Parse.User._registerAuthenticationProvider(secondProvider);\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    expect(secondProvider.synchronizedAuthToken).toEqual('jenny_valid_token');\n    // Make sure we can login with the new token again\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    done();\n  });\n\n  it('returns authData when authed and logged in with provider (regression test for #1498)', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    const userQuery = new Parse.Query(Parse.User);\n    userQuery.get(user.id).then(user => {\n      expect(user.get('authData')).not.toBeUndefined();\n      done();\n    });\n  });\n\n  it('only creates a single session for an installation / user pair (#2885)', async done => {\n    Parse.Object.disableSingleInstance();\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User.logInWith('facebook');\n    await Parse.User.logInWith('facebook');\n    const user = await Parse.User.logInWith('facebook');\n    const sessionToken = user.getSessionToken();\n    const query = new Parse.Query('_Session');\n    return query\n      .find({ useMasterKey: true })\n      .then(results => {\n        expect(results.length).toBe(1);\n        expect(results[0].get('sessionToken')).toBe(sessionToken);\n        expect(results[0].get('createdWith')).toEqual({\n          action: 'login',\n          authProvider: 'facebook',\n        });\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('log in with provider with files', done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file\n      .save()\n      .then(file => {\n        const user = new Parse.User();\n        user.set('file', file);\n        return user._linkWith('facebook', {});\n      })\n      .then(user => {\n        expect(user._isLinked('facebook')).toBeTruthy();\n        return Parse.User._logInWith('facebook', {});\n      })\n      .then(user => {\n        const fileAgain = user.get('file');\n        expect(fileAgain.name()).toMatch(/yolo.txt$/);\n        expect(fileAgain.url()).toMatch(/yolo.txt$/);\n      })\n      .then(() => {\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('log in with provider twice', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n\n    Parse.User.logOut().then(async () => {\n      ok(provider.loggedOut);\n      provider.loggedOut = false;\n      const innerModel = await Parse.User._logInWith('facebook');\n      ok(innerModel instanceof Parse.User, 'Model should be a Parse.User');\n      ok(innerModel === Parse.User.current(), 'Returned model should be the current user');\n      ok(provider.authData.id === provider.synchronizedUserId);\n      ok(provider.authData.access_token === provider.synchronizedAuthToken);\n      ok(innerModel._isLinked('facebook'), 'User should be linked to facebook');\n      ok(innerModel.existed(), 'User should not be newly-created');\n      done();\n    }, done.fail);\n  });\n\n  it('log in with provider failed', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldError = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    try {\n      await Parse.User._logInWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error, 'Error should be non-null');\n      done();\n    }\n  });\n\n  it('log in with provider cancelled', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldCancel = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    try {\n      await Parse.User._logInWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error === null, 'Error should be null');\n      done();\n    }\n  });\n\n  it('login with provider should not call beforeSave trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    Parse.User.logOut().then(async () => {\n      Parse.Cloud.beforeSave(Parse.User, function (req, res) {\n        res.error(\"Before save shouldn't be called on login\");\n      });\n      await Parse.User._logInWith('facebook');\n      done();\n    });\n  });\n\n  it('signup with provider should not call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n\n    await Parse.User._logInWith('facebook');\n    expect(hit).toBe(0);\n    done();\n  });\n\n  it('login with provider should call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      expect(req.object.get('authData')).toBeDefined();\n      expect(req.object.get('name')).toBe('tupac shakur');\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.current().save({ name: 'tupac shakur' });\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    expect(hit).toBe(1);\n    done();\n  });\n\n  it('incorrect login with provider should not call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    provider.shouldError = true;\n    try {\n      await Parse.User._logInWith('facebook');\n    } catch (e) {\n      expect(e).toBeDefined();\n    }\n    expect(hit).toBe(0);\n    done();\n  });\n\n  it('login with provider should be blockable by beforeLogin', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.current().save({ isBanned: true });\n    await Parse.User.logOut();\n\n    try {\n      await Parse.User._logInWith('facebook');\n      throw new Error('should not have continued login.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n\n    expect(hit).toBe(1);\n    done();\n  });\n\n  it('login with provider should be blockable by beforeLogin even when the user has a attached file', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n\n    const user = await Parse.User._logInWith('facebook');\n    const base64 = 'aHR0cHM6Ly9naXRodWIuY29tL2t2bmt1YW5n';\n    const file = new Parse.File('myfile.txt', { base64 });\n    await file.save();\n    await user.save({ isBanned: true, file });\n    await Parse.User.logOut();\n\n    try {\n      await Parse.User._logInWith('facebook');\n      throw new Error('should not have continued login.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n\n    expect(hit).toBe(1);\n    done();\n  });\n\n  it('logout with provider should call afterLogout trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let userId;\n    Parse.Cloud.afterLogout(req => {\n      expect(req.object.className).toEqual('_Session');\n      expect(req.object.id).toBeDefined();\n      const user = req.object.get('user');\n      expect(user).toBeDefined();\n      userId = user.id;\n    });\n    const user = await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    expect(user.id).toBe(userId);\n    done();\n  });\n\n  it('link with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const model = await user._linkWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked');\n    done();\n  });\n\n  // What this means is, only one Parse User can be linked to a\n  // particular Facebook account.\n  it('link with provider for already linked user', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProviderToAlreadyLinkedUser');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const model = await user._linkWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked.');\n    const user2 = new Parse.User();\n    user2.set('username', 'testLinkWithProviderToAlreadyLinkedUser2');\n    user2.set('password', 'mypass');\n    await user2.signUp();\n    try {\n      await user2._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.ACCOUNT_ALREADY_LINKED);\n      done();\n    }\n  });\n\n  it('link with provider should return sessionToken', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const query = new Parse.Query(Parse.User);\n    const u2 = await query.get(user.id);\n    const model = await u2._linkWith('facebook', {}, { useMasterKey: true });\n    expect(u2.getSessionToken()).toBeDefined();\n    expect(model.getSessionToken()).toBeDefined();\n    expect(u2.getSessionToken()).toBe(model.getSessionToken());\n  });\n\n  it('link with provider via sessionToken should not create new sessionToken (Regression #5799)', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProviderNoOverride');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const sessionToken = user.getSessionToken();\n\n    await user._linkWith('facebook', {}, { sessionToken });\n    expect(sessionToken).toBe(user.getSessionToken());\n\n    expect(user._isLinked(provider)).toBe(true);\n    await user._unlinkFrom(provider, { sessionToken });\n    expect(user._isLinked(provider)).toBe(false);\n\n    const become = await Parse.User.become(sessionToken);\n    expect(sessionToken).toBe(become.getSessionToken());\n  });\n\n  it('link with provider failed', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldError = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error, 'Linking should fail');\n      ok(!user._isLinked('facebook'), 'User should not be linked to facebook');\n      done();\n    }\n  });\n\n  it('link with provider cancelled', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldCancel = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(!error, 'Linking should be cancelled');\n      ok(!user._isLinked('facebook'), 'User should not be linked to facebook');\n      done();\n    }\n  });\n\n  it('unlink with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User.');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook.');\n    await model._unlinkFrom('facebook');\n    ok(!model._isLinked('facebook'), 'User should not be linked.');\n    ok(!provider.synchronizedUserId, 'User id should be cleared.');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared.');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared.');\n    done();\n  });\n\n  it('unlink and link', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n\n    await model._unlinkFrom('facebook');\n    ok(!model._isLinked('facebook'), 'User should not be linked to facebook');\n    ok(!provider.synchronizedUserId, 'User id should be cleared');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared');\n\n    await model._linkWith('facebook');\n    ok(provider.synchronizedUserId, 'User id should have a value');\n    ok(provider.synchronizedAuthToken, 'Auth token should have a value');\n    ok(provider.synchronizedExpiration, 'Expiration should have a value');\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    done();\n  });\n\n  it('link multiple providers', async done => {\n    const provider = getMockFacebookProvider();\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    expect(model.id).toEqual(objectId);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    done();\n  });\n\n  it('link multiple providers and updates token', async done => {\n    const provider = getMockFacebookProvider();\n    const secondProvider = getMockFacebookProviderWithIdToken('8675309', 'jenny_valid_token');\n\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    Parse.User._registerAuthenticationProvider(secondProvider);\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    const user = await Parse.User._logInWith('myoauth');\n    expect(user.id).toBe(objectId);\n    done();\n  });\n\n  it('link multiple providers and update token', async done => {\n    const provider = getMockFacebookProvider();\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    expect(model.id).toEqual(objectId);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    await model._linkWith('facebook');\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    done();\n  });\n\n  it('should fail linking with existing', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('password');\n    await user.signUp();\n    // try to link here\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (e) {\n      done();\n    }\n  });\n\n  it('should fail linking with existing through REST', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    const userId = model.id;\n    Parse.User.logOut().then(() => {\n      request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json',\n        },\n        body: { authData: { facebook: provider.authData } },\n      }).then(response => {\n        const body = response.data;\n        // make sure the location header is properly set\n        expect(userId).not.toBeUndefined();\n        expect(body.objectId).toEqual(userId);\n        expect(response.headers.location).toEqual(Parse.serverURL + '/users/' + userId);\n        done();\n      });\n    });\n  });\n\n  it('should allow login with old authData token', done => {\n    const provider = {\n      authData: {\n        id: '12345',\n        access_token: 'token',\n      },\n      restoreAuthentication: function () {\n        return true;\n      },\n      deauthenticate: function () {\n        provider.authData = {};\n      },\n      authenticate: function (options) {\n        options.success(this, provider.authData);\n      },\n      getAuthType: function () {\n        return 'shortLivedAuth';\n      },\n    };\n    defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('token');\n    Parse.User._registerAuthenticationProvider(provider);\n    Parse.User._logInWith('shortLivedAuth', {})\n      .then(() => {\n        // Simulate a remotely expired token (like a short lived one)\n        // In this case, we want success as it was valid once.\n        // If the client needs an updated one, do lock the user out\n        defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('otherToken');\n        return Parse.User._logInWith('shortLivedAuth', {});\n      })\n      .then(\n        () => {\n          done();\n        },\n        err => {\n          done.fail(err);\n        }\n      );\n  });\n\n  it('should allow PUT request with stale auth Data', done => {\n    const provider = {\n      authData: {\n        id: '12345',\n        access_token: 'token',\n      },\n      restoreAuthentication: function () {\n        return true;\n      },\n      deauthenticate: function () {\n        provider.authData = {};\n      },\n      authenticate: function (options) {\n        options.success(this, provider.authData);\n      },\n      getAuthType: function () {\n        return 'shortLivedAuth';\n      },\n    };\n    defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('token');\n    Parse.User._registerAuthenticationProvider(provider);\n    Parse.User._logInWith('shortLivedAuth', {})\n      .then(() => {\n        // Simulate a remotely expired token (like a short lived one)\n        // In this case, we want success as it was valid once.\n        // If the client needs an updated one, do lock the user out\n        defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('otherToken');\n        return request({\n          method: 'PUT',\n          url: Parse.serverURL + '/users/' + Parse.User.current().id,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'X-Parse-Session-Token': Parse.User.current().getSessionToken(),\n            'Content-Type': 'application/json',\n          },\n          body: {\n            key: 'value', // update a key\n            authData: {\n              // pass the original auth data\n              shortLivedAuth: {\n                id: '12345',\n                access_token: 'token',\n              },\n            },\n          },\n        });\n      })\n      .then(\n        () => {\n          done();\n        },\n        err => {\n          done.fail(err);\n        }\n      );\n  });\n\n  it('should properly error when password is missing', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    user.set('username', 'myUser');\n    user.set('email', 'foo@example.com');\n    user\n      .save()\n      .then(() => {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.logIn('myUser', 'password');\n      })\n      .then(\n        () => {\n          fail('should not succeed');\n          done();\n        },\n        err => {\n          expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n          expect(err.message).toEqual('Invalid username/password.');\n          done();\n        }\n      );\n  });\n\n  it('should have authData in beforeSave and afterSave', async done => {\n    Parse.Cloud.beforeSave('_User', request => {\n      const authData = request.object.get('authData');\n      expect(authData).not.toBeUndefined();\n      if (authData) {\n        expect(authData.facebook.id).toEqual('8675309');\n        expect(authData.facebook.access_token).toEqual('jenny');\n      } else {\n        fail('authData should be set');\n      }\n    });\n\n    Parse.Cloud.afterSave('_User', request => {\n      const authData = request.object.get('authData');\n      expect(authData).not.toBeUndefined();\n      if (authData) {\n        expect(authData.facebook.id).toEqual('8675309');\n        expect(authData.facebook.access_token).toEqual('jenny');\n      } else {\n        fail('authData should be set');\n      }\n    });\n\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    done();\n  });\n\n  it('set password then change password', done => {\n    Parse.User.signUp('bob', 'barker')\n      .then(bob => {\n        bob.setPassword('meower');\n        return bob.save();\n      })\n      .then(() => {\n        return Parse.User.logIn('bob', 'meower');\n      })\n      .then(\n        bob => {\n          expect(bob.getUsername()).toEqual('bob');\n          done();\n        },\n        e => {\n          console.log(e);\n          fail();\n        }\n      );\n  });\n\n  it('authenticated check', async done => {\n    const user = new Parse.User();\n    user.set('username', 'darkhelmet');\n    user.set('password', 'onetwothreefour');\n    ok(!user.authenticated());\n    await user.signUp(null);\n    ok(user.authenticated());\n    done();\n  });\n\n  it('log in with explicit facebook auth data', async done => {\n    await Parse.FacebookUtils.logIn({\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    });\n    done();\n  });\n\n  it('log in async with explicit facebook auth data', done => {\n    Parse.FacebookUtils.logIn({\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(\n      function () {\n        done();\n      },\n      function (error) {\n        ok(false, error);\n        done();\n      }\n    );\n  });\n\n  it('link with explicit facebook auth data', async done => {\n    const user = await Parse.User.signUp('mask', 'open sesame');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(done, error => {\n      jfail(error);\n      done();\n    });\n  });\n\n  it('link async with explicit facebook auth data', async done => {\n    const user = await Parse.User.signUp('mask', 'open sesame');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(\n      function () {\n        done();\n      },\n      function (error) {\n        ok(false, error);\n        done();\n      }\n    );\n  });\n\n  it('async methods', done => {\n    const data = { foo: 'bar' };\n\n    Parse.User.signUp('finn', 'human', data)\n      .then(function (user) {\n        equal(Parse.User.current(), user);\n        equal(user.get('foo'), 'bar');\n        return Parse.User.logOut();\n      })\n      .then(function () {\n        return Parse.User.logIn('finn', 'human');\n      })\n      .then(function (user) {\n        equal(user, Parse.User.current());\n        equal(user.get('foo'), 'bar');\n        return Parse.User.logOut();\n      })\n      .then(function () {\n        const user = new Parse.User();\n        user.set('username', 'jake');\n        user.set('password', 'dog');\n        user.set('foo', 'baz');\n        return user.signUp();\n      })\n      .then(function (user) {\n        equal(user, Parse.User.current());\n        equal(user.get('foo'), 'baz');\n        user = new Parse.User();\n        user.set('username', 'jake');\n        user.set('password', 'dog');\n        return user.logIn();\n      })\n      .then(function (user) {\n        equal(user, Parse.User.current());\n        equal(user.get('foo'), 'baz');\n        const userAgain = new Parse.User();\n        userAgain.id = user.id;\n        return userAgain.fetch();\n      })\n      .then(function (userAgain) {\n        equal(userAgain.get('foo'), 'baz');\n        done();\n      });\n  });\n\n  it(\"querying for users doesn't get session tokens\", done => {\n    Parse.User.signUp('finn', 'human', { foo: 'bar' })\n      .then(function () {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        const user = new Parse.User();\n        user.set('username', 'jake');\n        user.set('password', 'dog');\n        user.set('foo', 'baz');\n        return user.signUp();\n      })\n      .then(function () {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        const query = new Parse.Query(Parse.User);\n        return query.find({ sessionToken: null });\n      })\n      .then(\n        function (users) {\n          equal(users.length, 2);\n          users.forEach(user => {\n            expect(user.getSessionToken()).toBeUndefined();\n            ok(!user.getSessionToken(), 'user should not have a session token.');\n          });\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('querying for users only gets the expected fields', done => {\n    Parse.User.signUp('finn', 'human', { foo: 'bar' }).then(() => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n        },\n        url: 'http://localhost:8378/1/users',\n      }).then(response => {\n        const b = response.data;\n        expect(b.results.length).toEqual(1);\n        const user = b.results[0];\n        expect(Object.keys(user).length).toEqual(6);\n        done();\n      });\n    });\n  });\n\n  it(\"retrieve user data from fetch, make sure the session token hasn't changed\", done => {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    let currentSessionToken = '';\n    Promise.resolve()\n      .then(function () {\n        return user.signUp();\n      })\n      .then(function () {\n        currentSessionToken = user.getSessionToken();\n        return user.fetch();\n      })\n      .then(\n        function (u) {\n          expect(currentSessionToken).toEqual(u.getSessionToken());\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('user save should fail with invalid email', done => {\n    const user = new Parse.User();\n    user.set('username', 'teste');\n    user.set('password', 'test');\n    user.set('email', 'invalid');\n    user.signUp().then(\n      () => {\n        fail('Should not have been able to save.');\n        done();\n      },\n      error => {\n        expect(error.code).toEqual(125);\n        done();\n      }\n    );\n  });\n\n  it('user signup should error if email taken', done => {\n    const user = new Parse.User();\n    user.set('username', 'test1');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user\n      .signUp()\n      .then(() => {\n        const user2 = new Parse.User();\n        user2.set('username', 'test2');\n        user2.set('password', 'test');\n        user2.set('email', 'test@test.com');\n        return user2.signUp();\n      })\n      .then(\n        () => {\n          fail('Should not have been able to sign up.');\n          done();\n        },\n        () => {\n          done();\n        }\n      );\n  });\n\n  describe('case insensitive signup not allowed', () => {\n    it('signup should fail with duplicate case insensitive username with basic setter', async () => {\n      const user = new Parse.User();\n      user.set('username', 'test1');\n      user.set('password', 'test');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.set('username', 'Test1');\n      user2.set('password', 'test');\n      await expectAsync(user2.signUp()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.')\n      );\n    });\n\n    it('signup should fail with duplicate case insensitive username with field specific setter', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.setUsername('Test1');\n      user2.setPassword('test');\n      await expectAsync(user2.signUp()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.')\n      );\n    });\n\n    it('signup should fail with duplicate case insensitive email', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      user.setEmail('test@example.com');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.setUsername('test2');\n      user2.setPassword('test');\n      user2.setEmail('Test@Example.Com');\n      await expectAsync(user2.signUp()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.')\n      );\n    });\n\n    it('edit should fail with duplicate case insensitive email', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      user.setEmail('test@example.com');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.setUsername('test2');\n      user2.setPassword('test');\n      user2.setEmail('Foo@Example.Com');\n      await user2.signUp();\n\n      user2.setEmail('Test@Example.Com');\n      await expectAsync(user2.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.')\n      );\n    });\n\n    describe('anonymous users', () => {\n      beforeEach(() => {\n        const insensitiveCollisions = [\n          'abcdefghijklmnop',\n          'Abcdefghijklmnop',\n          'ABcdefghijklmnop',\n          'ABCdefghijklmnop',\n          'ABCDefghijklmnop',\n          'ABCDEfghijklmnop',\n          'ABCDEFghijklmnop',\n          'ABCDEFGhijklmnop',\n          'ABCDEFGHijklmnop',\n          'ABCDEFGHIjklmnop',\n          'ABCDEFGHIJklmnop',\n          'ABCDEFGHIJKlmnop',\n          'ABCDEFGHIJKLmnop',\n          'ABCDEFGHIJKLMnop',\n          'ABCDEFGHIJKLMnop',\n          'ABCDEFGHIJKLMNop',\n          'ABCDEFGHIJKLMNOp',\n          'ABCDEFGHIJKLMNOP',\n        ];\n\n        // need a bunch of spare random strings per api request\n        spyOn(cryptoUtils, 'randomString').and.returnValues(...insensitiveCollisions);\n      });\n\n      it('should not fail on case insensitive matches', async () => {\n        const user1 = await Parse.AnonymousUtils.logIn();\n        const username1 = user1.get('username');\n\n        const user2 = await Parse.AnonymousUtils.logIn();\n        const username2 = user2.get('username');\n\n        expect(username1).not.toBeUndefined();\n        expect(username2).not.toBeUndefined();\n        expect(username1.toLowerCase()).toBe('abcdefghijklmnop');\n        expect(username2.toLowerCase()).toBe('abcdefghijklmnop');\n        expect(username2).not.toBe(username1);\n        expect(username2.toLowerCase()).toBe(username1.toLowerCase()); // this is redundant :).\n      });\n    });\n  });\n\n  it('user cannot update email to existing user', done => {\n    const user = new Parse.User();\n    user.set('username', 'test1');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user\n      .signUp()\n      .then(() => {\n        const user2 = new Parse.User();\n        user2.set('username', 'test2');\n        user2.set('password', 'test');\n        return user2.signUp();\n      })\n      .then(user2 => {\n        user2.set('email', 'test@test.com');\n        return user2.save();\n      })\n      .then(\n        () => {\n          fail('Should not have been able to sign up.');\n          done();\n        },\n        () => {\n          done();\n        }\n      );\n  });\n\n  it('unset user email', done => {\n    const user = new Parse.User();\n    user.set('username', 'test');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user\n      .signUp()\n      .then(() => {\n        user.unset('email');\n        return user.save();\n      })\n      .then(() => {\n        return Parse.User.logIn('test', 'test');\n      })\n      .then(user => {\n        expect(user.getEmail()).toBeUndefined();\n        done();\n      });\n  });\n\n  it('create session from user', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          method: 'POST',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          expect(typeof b.sessionToken).toEqual('string');\n          expect(typeof b.createdWith).toEqual('object');\n          expect(b.createdWith.action).toEqual('create');\n          expect(typeof b.user).toEqual('object');\n          expect(b.user.objectId).toEqual(user.id);\n          done();\n        });\n      });\n  });\n\n  it('user get session from token on signup', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions/me',\n        }).then(response => {\n          const b = response.data;\n          expect(typeof b.sessionToken).toEqual('string');\n          expect(typeof b.createdWith).toEqual('object');\n          expect(b.createdWith.action).toEqual('signup');\n          expect(typeof b.user).toEqual('object');\n          expect(b.user.objectId).toEqual(user.id);\n          done();\n        });\n      });\n  });\n\n  it('user get session from token on login', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.logOut().then(() => {\n          return Parse.User.logIn('finn', 'human');\n        });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions/me',\n        }).then(response => {\n          const b = response.data;\n          expect(typeof b.sessionToken).toEqual('string');\n          expect(typeof b.createdWith).toEqual('object');\n          expect(b.createdWith.action).toEqual('login');\n          expect(typeof b.user).toEqual('object');\n          expect(b.user.objectId).toEqual(user.id);\n          done();\n        });\n      });\n  });\n\n  it('user update session with other field', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions/me',\n        }).then(response => {\n          const b = response.data;\n          request({\n            method: 'PUT',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': user.getSessionToken(),\n              'X-Parse-REST-API-Key': 'rest',\n            },\n            url: 'http://localhost:8378/1/sessions/' + b.objectId,\n            body: JSON.stringify({ foo: 'bar' }),\n          }).then(() => {\n            done();\n          });\n        });\n      });\n  });\n\n  it('cannot update session if invalid or no session token', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions/me',\n        }).then(response => {\n          const b = response.data;\n          request({\n            method: 'PUT',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': 'foo',\n              'X-Parse-REST-API-Key': 'rest',\n              'Content-Type': 'application/json',\n            },\n            url: 'http://localhost:8378/1/sessions/' + b.objectId,\n            body: JSON.stringify({ foo: 'bar' }),\n          }).then(fail, response => {\n            const b = response.data;\n            expect(b.error).toBe('Invalid session token');\n            request({\n              method: 'PUT',\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: 'http://localhost:8378/1/sessions/' + b.objectId,\n              body: JSON.stringify({ foo: 'bar' }),\n            }).then(fail, response => {\n              const b = response.data;\n              expect(b.error).toBe('Session token required.');\n              done();\n            });\n          });\n        });\n      });\n  });\n\n  it('get session only for current user', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('test1', 'test', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.signUp('test2', 'test', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          expect(b.results.length).toEqual(1);\n          expect(typeof b.results[0].user).toEqual('object');\n          expect(b.results[0].user.objectId).toEqual(user.id);\n          done();\n        });\n      });\n  });\n\n  it('delete session by object', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('test1', 'test', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.signUp('test2', 'test', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          let objId;\n          try {\n            expect(b.results.length).toEqual(1);\n            objId = b.results[0].objectId;\n          } catch (e) {\n            jfail(e);\n            done();\n            return;\n          }\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': user.getSessionToken(),\n              'X-Parse-REST-API-Key': 'rest',\n            },\n            url: 'http://localhost:8378/1/sessions/' + objId,\n          }).then(() => {\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-Session-Token': user.getSessionToken(),\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: 'http://localhost:8378/1/sessions',\n            }).then(fail, response => {\n              const b = response.data;\n              expect(b.code).toEqual(209);\n              expect(b.error).toBe('Invalid session token');\n              done();\n            });\n          });\n        });\n      });\n  });\n\n  it('cannot delete session if no sessionToken', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('test1', 'test', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.signUp('test2', 'test', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          expect(b.results.length).toEqual(1);\n          const objId = b.results[0].objectId;\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n            },\n            url: 'http://localhost:8378/1/sessions/' + objId,\n          }).then(fail, response => {\n            const b = response.data;\n            expect(b.code).toEqual(209);\n            expect(b.error).toBe('Invalid session token');\n            done();\n          });\n        });\n      });\n  });\n\n  it('password format matches hosted parse', done => {\n    const hashed = '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie';\n    passwordCrypto.compare('test', hashed).then(\n      pass => {\n        expect(pass).toBe(true);\n        done();\n      },\n      () => {\n        fail('Password format did not match.');\n        done();\n      }\n    );\n  });\n\n  it('changing password clears sessions', done => {\n    let sessionToken = null;\n\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('fosco', 'parse');\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n        sessionToken = newUser.getSessionToken();\n        ok(sessionToken);\n        newUser.set('password', 'facebook');\n        return newUser.save();\n      })\n      .then(function () {\n        return Parse.User.become(sessionToken);\n      })\n      .then(\n        function () {\n          fail('Session should have been invalidated');\n          done();\n        },\n        function (err) {\n          expect(err.code).toBe(Parse.Error.INVALID_SESSION_TOKEN);\n          expect(err.message).toBe('Invalid session token');\n          done();\n        }\n      );\n  });\n\n  it('test parse user become', done => {\n    let sessionToken = null;\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('flessard', 'folo', { foo: 1 });\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n        sessionToken = newUser.getSessionToken();\n        ok(sessionToken);\n        newUser.set('foo', 2);\n        return newUser.save();\n      })\n      .then(function () {\n        return Parse.User.become(sessionToken);\n      })\n      .then(\n        function (newUser) {\n          equal(newUser.get('foo'), 2);\n          done();\n        },\n        function () {\n          fail('The session should still be valid');\n          done();\n        }\n      );\n  });\n\n  it('ensure logout works', done => {\n    let user = null;\n    let sessionToken = null;\n\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('log', 'out');\n      })\n      .then(newUser => {\n        user = newUser;\n        sessionToken = user.getSessionToken();\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        user.set('foo', 'bar');\n        return user.save(null, { sessionToken: sessionToken });\n      })\n      .then(\n        () => {\n          fail('Save should have failed.');\n          done();\n        },\n        e => {\n          expect(e.code).toEqual(Parse.Error.INVALID_SESSION_TOKEN);\n          done();\n        }\n      );\n  });\n\n  it('support user/password signup with empty authData block', done => {\n    // The android SDK can send an empty authData object along with username and password.\n    Parse.User.signUp('artof', 'thedeal', { authData: {} }).then(\n      () => {\n        done();\n      },\n      () => {\n        fail('Signup should have succeeded.');\n        done();\n      }\n    );\n  });\n\n  it('session expiresAt correct format', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      url: 'http://localhost:8378/1/classes/_Session',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test',\n      },\n    }).then(response => {\n      const body = response.data;\n      expect(body.results[0].expiresAt.__type).toEqual('Date');\n      done();\n    });\n  });\n\n  it('Invalid session tokens are rejected', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      url: 'http://localhost:8378/1/classes/AClass',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Rest-API-Key': 'rest',\n        'X-Parse-Session-Token': 'text',\n      },\n    }).then(fail, response => {\n      const body = response.data;\n      expect(body.code).toBe(209);\n      expect(body.error).toBe('Invalid session token');\n      done();\n    });\n  });\n\n  it_exclude_dbs(['postgres'])(\n    'should cleanup null authData keys (regression test for #935)',\n    done => {\n      const database = Config.get(Parse.applicationId).database;\n      database\n        .create(\n          '_User',\n          {\n            username: 'user',\n            _hashed_password: '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie',\n            _auth_data_facebook: null,\n          },\n          {}\n        )\n        .then(() => {\n          return request({\n            url: 'http://localhost:8378/1/login?username=user&password=test',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Master-Key': 'test',\n            },\n          }).then(res => res.data);\n        })\n        .then(user => {\n          const authData = user.authData;\n          expect(user.username).toEqual('user');\n          expect(authData).toBeUndefined();\n          done();\n        })\n        .catch(() => {\n          fail('this should not fail');\n          done();\n        });\n    }\n  );\n\n  it_exclude_dbs(['postgres'])('should not serve null authData keys', done => {\n    const database = Config.get(Parse.applicationId).database;\n    database\n      .create(\n        '_User',\n        {\n          username: 'user',\n          _hashed_password: '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie',\n          _auth_data_facebook: null,\n        },\n        {}\n      )\n      .then(() => {\n        return new Parse.Query(Parse.User)\n          .equalTo('username', 'user')\n          .first({ useMasterKey: true });\n      })\n      .then(user => {\n        const authData = user.get('authData');\n        expect(user.get('username')).toEqual('user');\n        expect(authData).toBeUndefined();\n        done();\n      })\n      .catch(() => {\n        fail('this should not fail');\n        done();\n      });\n  });\n\n  it('should cleanup null authData keys ParseUser update (regression test for #1198, #2252)', done => {\n    Parse.Cloud.beforeSave('_User', req => {\n      req.object.set('foo', 'bar');\n    });\n\n    let originalSessionToken;\n    let originalUserId;\n    // Simulate anonymous user save\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    })\n      .then(response => response.data)\n      .then(user => {\n        originalSessionToken = user.sessionToken;\n        originalUserId = user.objectId;\n        // Simulate registration\n        return request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/classes/_User/' + user.objectId,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': user.sessionToken,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n          body: {\n            authData: { anonymous: null },\n            username: 'user',\n            password: 'password',\n          },\n        }).then(response => {\n          return response.data;\n        });\n      })\n      .then(user => {\n        expect(typeof user).toEqual('object');\n        expect(user.authData).toBeUndefined();\n        expect(user.sessionToken).not.toBeUndefined();\n        // Session token should have changed\n        expect(user.sessionToken).not.toEqual(originalSessionToken);\n        // test that the sessionToken is valid\n        return request({\n          url: 'http://localhost:8378/1/users/me',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': user.sessionToken,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n        }).then(response => {\n          const body = response.data;\n          expect(body.username).toEqual('user');\n          expect(body.objectId).toEqual(originalUserId);\n          done();\n        });\n      })\n      .catch(err => {\n        fail('no request should fail: ' + JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should send email when upgrading from anon', done => {\n    let emailCalled = false;\n    let emailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        emailOptions = options;\n        emailCalled = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    });\n    // Simulate anonymous user save\n    return request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    })\n      .then(response => {\n        const user = response.data;\n        return request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/classes/_User/' + user.objectId,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': user.sessionToken,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n          body: {\n            authData: { anonymous: null },\n            username: 'user',\n            email: 'user@email.com',\n            password: 'password',\n          },\n        });\n      })\n      .then(() => {\n        expect(emailCalled).toBe(true);\n        expect(emailOptions).not.toBeUndefined();\n        expect(emailOptions.user.get('email')).toEqual('user@email.com');\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        fail('no request should fail: ' + JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not send email when email is not a string', async done => {\n    let emailCalled = false;\n    let emailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        emailOptions = options;\n        emailCalled = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n    await reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    });\n    const user = new Parse.User();\n    user.set('username', 'asdf@jkl.com');\n    user.set('password', 'zxcv');\n    user.set('email', 'asdf@jkl.com');\n    await user.signUp();\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/requestPasswordReset',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Session-Token': user.sessionToken,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        email: { $regex: '^asd' },\n      },\n    })\n      .then(res => {\n        fail('no request should succeed: ' + JSON.stringify(res));\n        done();\n      })\n      .catch(err => {\n        expect(emailCalled).toBeTruthy();\n        expect(emailOptions).toBeDefined();\n        expect(err.status).toBe(400);\n        expect(err.text).toMatch('{\"code\":125,\"error\":\"you must provide a valid email string\"}');\n        done();\n      });\n  });\n\n  it('should aftersave with full object', done => {\n    let hit = 0;\n    Parse.Cloud.afterSave('_User', (req, res) => {\n      hit++;\n      expect(req.object.get('username')).toEqual('User');\n      res.success();\n    });\n    const user = new Parse.User();\n    user.setUsername('User');\n    user.setPassword('pass');\n    user\n      .signUp()\n      .then(() => {\n        user.set('hello', 'world');\n        return user.save();\n      })\n      .then(() => {\n        expect(hit).toBe(2);\n        done();\n      });\n  });\n\n  it('changes to a user should update the cache', done => {\n    Parse.Cloud.define('testUpdatedUser', req => {\n      expect(req.user.get('han')).toEqual('solo');\n      return {};\n    });\n    const user = new Parse.User();\n    user.setUsername('harrison');\n    user.setPassword('ford');\n    user\n      .signUp()\n      .then(() => {\n        user.set('han', 'solo');\n        return user.save();\n      })\n      .then(() => {\n        return Parse.Cloud.run('testUpdatedUser');\n      })\n      .then(\n        () => {\n          done();\n        },\n        () => {\n          fail('Should not have failed.');\n          done();\n        }\n      );\n  });\n\n  it('should fail to become user with expired token', done => {\n    let token;\n    Parse.User.signUp('auser', 'somepass', null)\n      .then(() =>\n        request({\n          method: 'GET',\n          url: 'http://localhost:8378/1/classes/_Session',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Master-Key': 'test',\n          },\n        })\n      )\n      .then(response => {\n        const body = response.data;\n        const id = body.results[0].objectId;\n        const expiresAt = new Date(new Date().setYear(2015));\n        token = body.results[0].sessionToken;\n        return request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/classes/_Session/' + id,\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Master-Key': 'test',\n            'Content-Type': 'application/json',\n          },\n          body: {\n            expiresAt: { __type: 'Date', iso: expiresAt.toISOString() },\n          },\n        });\n      })\n      .then(() => Parse.User.become(token))\n      .then(\n        () => {\n          fail('Should not have succeded');\n          done();\n        },\n        error => {\n          expect(error.code).toEqual(209);\n          expect(error.message).toEqual('Session token is expired.');\n          done();\n        }\n      )\n      .catch(done.fail);\n  });\n\n  it('should not create extraneous session tokens', done => {\n    const config = Config.get(Parse.applicationId);\n    config.database\n      .loadSchema()\n      .then(s => {\n        // Lock down the _User class for creation\n        return s.addClassIfNotExists('_User', {}, { create: {} });\n      })\n      .then(() => {\n        const user = new Parse.User();\n        return user.save({ username: 'user', password: 'pass' });\n      })\n      .then(\n        () => {\n          fail('should not be able to save the user');\n        },\n        () => {\n          return Promise.resolve();\n        }\n      )\n      .then(() => {\n        const q = new Parse.Query('_Session');\n        return q.find({ useMasterKey: true });\n      })\n      .then(\n        res => {\n          // We should have no session created\n          expect(res.length).toBe(0);\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('should not overwrite username when unlinking facebook user (regression test for #1532)', async done => {\n    Parse.Object.disableSingleInstance();\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    await user._linkWith('facebook');\n    expect(user.get('username')).toEqual('testLinkWithProvider');\n    expect(Parse.FacebookUtils.isLinked(user)).toBeTruthy();\n    await user._unlinkFrom('facebook');\n    user = await user.fetch();\n    expect(user.get('username')).toEqual('testLinkWithProvider');\n    expect(Parse.FacebookUtils.isLinked(user)).toBeFalsy();\n    done();\n  });\n\n  it('should revoke sessions when converting anonymous user to \"normal\" user', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    }).then(response => {\n      const body = response.data;\n      Parse.User.become(body.sessionToken).then(user => {\n        const obj = new Parse.Object('TestObject');\n        obj.setACL(new Parse.ACL(user));\n        return obj\n          .save()\n          .then(() => {\n            // Change password, revoking session\n            user.set('username', 'no longer anonymous');\n            user.set('password', 'password');\n            return user.save();\n          })\n          .then(() => {\n            // Session token should have been recycled\n            expect(body.sessionToken).not.toEqual(user.getSessionToken());\n          })\n          .then(() => obj.fetch())\n          .then(() => {\n            done();\n          })\n          .catch(() => {\n            fail('should not fail');\n            done();\n          });\n      });\n    });\n  });\n\n  it('should not revoke session tokens if the server is configures to not revoke session tokens', done => {\n    reconfigureServer({ revokeSessionOnPasswordReset: false }).then(() => {\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json',\n        },\n        body: {\n          authData: {\n            anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n          },\n        },\n      }).then(response => {\n        const body = response.data;\n        Parse.User.become(body.sessionToken).then(user => {\n          const obj = new Parse.Object('TestObject');\n          obj.setACL(new Parse.ACL(user));\n          return (\n            obj\n              .save()\n              .then(() => {\n                // Change password, revoking session\n                user.set('username', 'no longer anonymous');\n                user.set('password', 'password');\n                return user.save();\n              })\n              .then(() => obj.fetch())\n              // fetch should succeed as we still have our session token\n              .then(done, fail)\n          );\n        });\n      });\n    });\n  });\n\n  it('should not fail querying non existing relations', done => {\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n    });\n    user\n      .signUp()\n      .then(() => {\n        return Parse.User.current().relation('relation').query().find();\n      })\n      .then(res => {\n        expect(res.length).toBe(0);\n        done();\n      })\n      .catch(err => {\n        fail(JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not allow updates to emailVerified', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() => {\n        return Parse.User.current().set('emailVerified', true).save();\n      })\n      .then(() => {\n        fail('Should not be able to update emailVerified');\n        done();\n      })\n      .catch(err => {\n        expect(err.message).toBe(\"Clients aren't allowed to manually update email verification.\");\n        done();\n      });\n  });\n\n  it('should not retrieve hidden fields on GET users/me (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() =>\n        request({\n          method: 'GET',\n          url: 'http://localhost:8378/1/users/me',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': Parse.User.current().getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        })\n      )\n      .then(response => {\n        const res = response.data;\n        expect(res.emailVerified).toBe(false);\n        expect(res._email_verify_token).toBeUndefined();\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('should not retrieve hidden fields on GET users/id (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() =>\n        request({\n          method: 'GET',\n          url: 'http://localhost:8378/1/users/' + Parse.User.current().id,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        })\n      )\n      .then(response => {\n        const res = response.data;\n        expect(res.emailVerified).toBe(false);\n        expect(res._email_verify_token).toBeUndefined();\n        done();\n      })\n      .catch(err => {\n        fail(JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not retrieve hidden fields on login (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() =>\n        request({\n          url: 'http://localhost:8378/1/login?email=test@email.com&username=hello&password=world',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        })\n      )\n      .then(response => {\n        const res = response.data;\n        expect(res.emailVerified).toBe(false);\n        expect(res._email_verify_token).toBeUndefined();\n        done();\n      })\n      .catch(err => {\n        fail(JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not allow updates to hidden fields', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() => {\n        return Parse.User.current().set('_email_verify_token', 'bad').save();\n      })\n      .then(() => {\n        fail('Should not be able to update email verification token');\n        done();\n      })\n      .catch(err => {\n        expect(err).toBeDefined();\n        done();\n      });\n  });\n\n  it('should revoke sessions when setting paswword with masterKey (#3289)', done => {\n    let user;\n    Parse.User.signUp('username', 'password')\n      .then(newUser => {\n        user = newUser;\n        user.set('password', 'newPassword');\n        return user.save(null, { useMasterKey: true });\n      })\n      .then(() => {\n        const query = new Parse.Query('_Session');\n        query.equalTo('user', user);\n        return query.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(0);\n        done();\n      }, done.fail);\n  });\n\n  xit('should not send a verification email if the user signed up using oauth', done => {\n    let emailCalledCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: () => {\n        emailCalledCount++;\n        return Promise.resolve();\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    });\n    const user = new Parse.User();\n    user.set('email', 'email1@host.com');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(user => {\n      user.set('email', 'email2@host.com');\n      user.save().then(() => {\n        expect(emailCalledCount).toBe(0);\n        done();\n      });\n    });\n  }).pend('this test fails.  See: https://github.com/parse-community/parse-server/issues/5097');\n\n  it('should be able to update user with authData passed', done => {\n    let objectId;\n    let sessionToken;\n\n    function validate(block) {\n      return request({\n        url: `http://localhost:8378/1/classes/_User/${objectId}`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'X-Parse-Session-Token': sessionToken,\n        },\n      }).then(response => block(response.data));\n    }\n\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        key: 'value',\n        authData: { anonymous: { id: '00000000-0000-0000-0000-000000000001' } },\n      },\n    })\n      .then(response => {\n        const body = response.data;\n        objectId = body.objectId;\n        sessionToken = body.sessionToken;\n        expect(sessionToken).toBeDefined();\n        expect(objectId).toBeDefined();\n        return validate(user => {\n          // validate that keys are set on creation\n          expect(user.key).toBe('value');\n        });\n      })\n      .then(() => {\n        // update the user\n        const options = {\n          method: 'PUT',\n          url: `http://localhost:8378/1/classes/_User/${objectId}`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n            'X-Parse-Session-Token': sessionToken,\n            'Content-Type': 'application/json',\n          },\n          body: {\n            key: 'otherValue',\n            authData: {\n              anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n            },\n          },\n        };\n        return request(options);\n      })\n      .then(() => {\n        return validate(user => {\n          // validate that keys are set on update\n          expect(user.key).toBe('otherValue');\n        });\n      })\n      .then(() => {\n        done();\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('can login with email', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          qs: { email: 'yo@lo.com', password: 'yolopass' },\n        };\n        return request(options);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('cannot login with email and invalid password', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          method: 'POST',\n          url: `http://localhost:8378/1/login`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n          body: { email: 'yo@lo.com', password: 'yolopass2' },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(() => done());\n  });\n\n  it('can login with email through query string', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo.com&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('can login when both email and username are passed', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo.com&username=yolo&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it(\"fails to login when username doesn't match email\", done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo.com&username=yolo2&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('Invalid username/password.');\n        done();\n      });\n  });\n\n  it(\"fails to login when email doesn't match username\", done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo2.com&username=yolo&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('Invalid username/password.');\n        done();\n      });\n  });\n\n  it('fails to login when email and username are not provided', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('username/email is required.');\n        done();\n      });\n  });\n\n  it('allows login when providing email as username', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        return Parse.User.logIn('yo@lo.com', 'yolopass');\n      })\n      .then(user => {\n        expect(user.get('username')).toBe('yolo');\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('handles properly when 2 users share username / email pairs', done => {\n    const user = new Parse.User({\n      username: 'yo@loname.com',\n      password: 'yolopass',\n      email: 'yo@lo.com',\n    });\n    const user2 = new Parse.User({\n      username: 'yo@lo.com',\n      email: 'yo@loname.com',\n      password: 'yolopass2', // different passwords\n    });\n\n    Parse.Object.saveAll([user, user2])\n      .then(() => {\n        return Parse.User.logIn('yo@loname.com', 'yolopass');\n      })\n      .then(user => {\n        // the username takes precedence over the email,\n        // so we get the user with username as passed in\n        expect(user.get('username')).toBe('yo@loname.com');\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('handles properly when 2 users share username / email pairs, counterpart', done => {\n    const user = new Parse.User({\n      username: 'yo@loname.com',\n      password: 'yolopass',\n      email: 'yo@lo.com',\n    });\n    const user2 = new Parse.User({\n      username: 'yo@lo.com',\n      email: 'yo@loname.com',\n      password: 'yolopass2', // different passwords\n    });\n\n    Parse.Object.saveAll([user, user2])\n      .then(() => {\n        return Parse.User.logIn('yo@loname.com', 'yolopass2');\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.message).toEqual('Invalid username/password.');\n        done();\n      });\n  });\n\n  it('fails to login when password is not provided', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?username=yolo`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('password is required.');\n        done();\n      });\n  });\n\n  it('does not duplicate session when logging in multiple times #3451', done => {\n    const user = new Parse.User();\n    user\n      .signUp({\n        username: 'yolo',\n        password: 'yolo',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const token = user.getSessionToken();\n        let promise = Promise.resolve();\n        let count = 0;\n        while (count < 5) {\n          promise = promise.then(() => {\n            return Parse.User.logIn('yolo', 'yolo').then(res => {\n              // ensure a new session token is generated at each login\n              expect(res.getSessionToken()).not.toBe(token);\n            });\n          });\n          count++;\n        }\n        return promise;\n      })\n      .then(() => {\n        // wait because session destruction is not synchronous\n        return new Promise(resolve => {\n          setTimeout(resolve, 100);\n        });\n      })\n      .then(() => {\n        const query = new Parse.Query('_Session');\n        return query.find({ useMasterKey: true });\n      })\n      .then(results => {\n        // only one session in the end\n        expect(results.length).toBe(1);\n      })\n      .then(done, done.fail);\n  });\n\n  it('should throw OBJECT_NOT_FOUND instead of SESSION_MISSING when using masterKey', async () => {\n    // create a fake user (just so we simulate an object not found)\n    const non_existent_user = Parse.User.createWithoutData('fake_id');\n    try {\n      await non_existent_user.destroy({ useMasterKey: true });\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    try {\n      await non_existent_user.save({}, { useMasterKey: true });\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    try {\n      await non_existent_user.save();\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    try {\n      await non_existent_user.destroy();\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n  });\n\n  describe('issue #4897', () => {\n    it_only_db('mongo')('should be able to login with a legacy user (no ACL)', async () => {\n      // This issue is a side effect of the locked users and legacy users which don't have ACL's\n      // In this scenario, a legacy user wasn't be able to login as there's no ACL on it\n      const database = Config.get(Parse.applicationId).database;\n      const collection = await database.adapter._adaptiveCollection('_User');\n      await collection.insertOne({\n        _id: 'ABCDEF1234',\n        name: '<some_name>',\n        email: '<some_email>',\n        username: '<some_username>',\n        _hashed_password: '<some_password>',\n        _auth_data_facebook: {\n          id: '8675309',\n          access_token: 'jenny',\n        },\n        sessionToken: '<some_session_token>',\n      });\n      const provider = getMockFacebookProvider();\n      Parse.User._registerAuthenticationProvider(provider);\n      const model = await Parse.User._logInWith('facebook', {});\n      expect(model.id).toBe('ABCDEF1234');\n      ok(model instanceof Parse.User, 'Model should be a Parse.User');\n      strictEqual(Parse.User.current(), model);\n      ok(model.extended(), 'Should have used subclass.');\n      strictEqual(provider.authData.id, provider.synchronizedUserId);\n      strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n      strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n      ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    });\n  });\n});\n\ndescribe('Security Advisory GHSA-8w3j-g983-8jh5', function () {\n  it_only_db('mongo')(\n    'should validate credentials first and check if account already linked afterwards ()',\n    async done => {\n      // Add User to Database with authData\n      const database = Config.get(Parse.applicationId).database;\n      const collection = await database.adapter._adaptiveCollection('_User');\n      await collection.insertOne({\n        _id: 'ABCDEF1234',\n        name: '<some_name>',\n        email: '<some_email>',\n        username: '<some_username>',\n        _hashed_password: '<some_password>',\n        _auth_data_custom: {\n          id: 'linkedID', // Already linked userid\n        },\n        sessionToken: '<some_session_token>',\n      });\n      const provider = {\n        getAuthType: () => 'custom',\n        restoreAuthentication: () => true,\n      }; // AuthProvider checks if password is 'password'\n      Parse.User._registerAuthenticationProvider(provider);\n\n      // Try to link second user with wrong password\n      try {\n        const user = await Parse.AnonymousUtils.logIn();\n        await user._linkWith(provider.getAuthType(), {\n          authData: { id: 'linkedID', password: 'wrong' },\n        });\n      } catch (error) {\n        // This should throw Parse.Error.SESSION_MISSING and not Parse.Error.ACCOUNT_ALREADY_LINKED\n        expect(error.code).toEqual(Parse.Error.SESSION_MISSING);\n        done();\n        return;\n      }\n      fail();\n      done();\n    }\n  );\n  it_only_db('mongo')('should ignore authData field', async () => {\n    // Add User to Database with authData\n    const database = Config.get(Parse.applicationId).database;\n    const collection = await database.adapter._adaptiveCollection('_User');\n    await collection.insertOne({\n      _id: '1234ABCDEF',\n      name: '<some_name>',\n      email: '<some_email>',\n      username: '<some_username>',\n      _hashed_password: '<some_password>',\n      _auth_data_custom: {\n        id: 'linkedID',\n      },\n      sessionToken: '<some_session_token>',\n      authData: null, // should ignore\n    });\n    const provider = {\n      getAuthType: () => 'custom',\n      restoreAuthentication: () => true,\n    };\n    Parse.User._registerAuthenticationProvider(provider);\n    const query = new Parse.Query(Parse.User);\n    const user = await query.get('1234ABCDEF', { useMasterKey: true });\n    expect(user.get('authData')).toEqual({ custom: { id: 'linkedID' } });\n  });\n});\n", "// A RestWrite encapsulates everything we need to run an operation\n// that writes to the database.\n// This could be either a \"create\" or an \"update\".\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar deepcopy = require('deepcopy');\n\nconst Auth = require('./Auth');\nvar cryptoUtils = require('./cryptoUtils');\nvar passwordCrypto = require('./password');\nvar Parse = require('parse/node');\nvar triggers = require('./triggers');\nvar ClientSDK = require('./ClientSDK');\nimport RestQuery from './RestQuery';\nimport _ from 'lodash';\nimport logger from './logger';\n\n// query and data are both provided in REST API format. So data\n// types are encoded by plain old objects.\n// If query is null, this is a \"create\" and the data in data should be\n// created.\n// Otherwise this is an \"update\" - the object matching the query\n// should get updated with data.\n// RestWrite will handle objectId, createdAt, and updatedAt for\n// everything. It also knows to use triggers and special modifications\n// for the _User class.\nfunction RestWrite(config, auth, className, query, data, originalData, clientSDK, context, action) {\n  if (auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      'Cannot perform a write operation when using readOnlyMasterKey'\n    );\n  }\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.clientSDK = clientSDK;\n  this.storage = {};\n  this.runOptions = {};\n  this.context = context || {};\n\n  if (action) {\n    this.runOptions.action = action;\n  }\n\n  if (!query) {\n    if (this.config.allowCustomObjectId) {\n      if (Object.prototype.hasOwnProperty.call(data, 'objectId') && !data.objectId) {\n        throw new Parse.Error(\n          Parse.Error.MISSING_OBJECT_ID,\n          'objectId must not be empty, null or undefined'\n        );\n      }\n    } else {\n      if (data.objectId) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'objectId is an invalid field name.');\n      }\n      if (data.id) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'id is an invalid field name.');\n      }\n    }\n  }\n\n  // When the operation is complete, this.response may have several\n  // fields.\n  // response: the actual data to be returned\n  // status: the http status code. if not present, treated like a 200\n  // location: the location header. if not present, no location header\n  this.response = null;\n\n  // Processing this operation may mutate our data, so we operate on a\n  // copy\n  this.query = deepcopy(query);\n  this.data = deepcopy(data);\n  // We never change originalData, so we do not need a deep copy\n  this.originalData = originalData;\n\n  // The timestamp we'll use for this whole operation\n  this.updatedAt = Parse._encode(new Date()).iso;\n\n  // Shared SchemaController to be reused to reduce the number of loadSchema() calls per request\n  // Once set the schemaData should be immutable\n  this.validSchemaController = null;\n}\n\n// A convenient method to perform all the steps of processing the\n// write, in order.\n// Returns a promise for a {response, status, location} object.\n// status and location are optional.\nRestWrite.prototype.execute = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.handleInstallation();\n    })\n    .then(() => {\n      return this.handleSession();\n    })\n    .then(() => {\n      return this.validateAuthData();\n    })\n    .then(() => {\n      return this.runBeforeSaveTrigger();\n    })\n    .then(() => {\n      return this.deleteEmailResetTokenIfNeeded();\n    })\n    .then(() => {\n      return this.validateSchema();\n    })\n    .then(schemaController => {\n      this.validSchemaController = schemaController;\n      return this.setRequiredFieldsIfNeeded();\n    })\n    .then(() => {\n      return this.transformUser();\n    })\n    .then(() => {\n      return this.expandFilesForExistingObjects();\n    })\n    .then(() => {\n      return this.destroyDuplicatedSessions();\n    })\n    .then(() => {\n      return this.runDatabaseOperation();\n    })\n    .then(() => {\n      return this.createSessionTokenIfNeeded();\n    })\n    .then(() => {\n      return this.handleFollowup();\n    })\n    .then(() => {\n      return this.runAfterSaveTrigger();\n    })\n    .then(() => {\n      return this.cleanUserAuthData();\n    })\n    .then(() => {\n      return this.response;\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestWrite.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.runOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.runOptions.acl = this.runOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestWrite.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the schema.\nRestWrite.prototype.validateSchema = function () {\n  return this.config.database.validateObject(\n    this.className,\n    this.data,\n    this.query,\n    this.runOptions\n  );\n};\n\n// Runs any beforeSave triggers against this operation.\n// Any change leads to our data being mutated.\nRestWrite.prototype.runBeforeSaveTrigger = function () {\n  if (this.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'beforeSave' trigger for this class.\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeSave, this.config.applicationId)\n  ) {\n    return Promise.resolve();\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  var extraData = { className: this.className };\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  let originalObject = null;\n  const updatedObject = this.buildUpdatedObject(extraData);\n  if (this.query && this.query.objectId) {\n    // This is an update for existing object.\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  return Promise.resolve()\n    .then(() => {\n      // Before calling the trigger, validate the permissions for the save operation\n      let databasePromise = null;\n      if (this.query) {\n        // Validate for updating\n        databasePromise = this.config.database.update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          true,\n          true\n        );\n      } else {\n        // Validate for creating\n        databasePromise = this.config.database.create(\n          this.className,\n          this.data,\n          this.runOptions,\n          true\n        );\n      }\n      // In the case that there is no permission for the operation, it throws an error\n      return databasePromise.then(result => {\n        if (!result || result.length <= 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n      });\n    })\n    .then(() => {\n      return triggers.maybeRunTrigger(\n        triggers.Types.beforeSave,\n        this.auth,\n        updatedObject,\n        originalObject,\n        this.config,\n        this.context\n      );\n    })\n    .then(response => {\n      if (response && response.object) {\n        this.storage.fieldsChangedByTrigger = _.reduce(\n          response.object,\n          (result, value, key) => {\n            if (!_.isEqual(this.data[key], value)) {\n              result.push(key);\n            }\n            return result;\n          },\n          []\n        );\n        this.data = response.object;\n        // We should delete the objectId for an update write\n        if (this.query && this.query.objectId) {\n          delete this.data.objectId;\n        }\n      }\n    });\n};\n\nRestWrite.prototype.runBeforeLoginTrigger = async function (userData) {\n  // Avoid doing any setup for triggers if there is no 'beforeLogin' trigger\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeLogin, this.config.applicationId)\n  ) {\n    return;\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  const extraData = { className: this.className };\n\n  // Expand file objects\n  this.config.filesController.expandFilesInObject(this.config, userData);\n\n  const user = triggers.inflate(extraData, userData);\n\n  // no need to return a response\n  await triggers.maybeRunTrigger(\n    triggers.Types.beforeLogin,\n    this.auth,\n    user,\n    null,\n    this.config,\n    this.context\n  );\n};\n\nRestWrite.prototype.setRequiredFieldsIfNeeded = function () {\n  if (this.data) {\n    return this.validSchemaController.getAllClasses().then(allClasses => {\n      const schema = allClasses.find(oneClass => oneClass.className === this.className);\n      const setRequiredFieldIfNeeded = (fieldName, setDefault) => {\n        if (\n          this.data[fieldName] === undefined ||\n          this.data[fieldName] === null ||\n          this.data[fieldName] === '' ||\n          (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete')\n        ) {\n          if (\n            setDefault &&\n            schema.fields[fieldName] &&\n            schema.fields[fieldName].defaultValue !== null &&\n            schema.fields[fieldName].defaultValue !== undefined &&\n            (this.data[fieldName] === undefined ||\n              (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete'))\n          ) {\n            this.data[fieldName] = schema.fields[fieldName].defaultValue;\n            this.storage.fieldsChangedByTrigger = this.storage.fieldsChangedByTrigger || [];\n            if (this.storage.fieldsChangedByTrigger.indexOf(fieldName) < 0) {\n              this.storage.fieldsChangedByTrigger.push(fieldName);\n            }\n          } else if (schema.fields[fieldName] && schema.fields[fieldName].required === true) {\n            throw new Parse.Error(Parse.Error.VALIDATION_ERROR, `${fieldName} is required`);\n          }\n        }\n      };\n\n      // Add default fields\n      this.data.updatedAt = this.updatedAt;\n      if (!this.query) {\n        this.data.createdAt = this.updatedAt;\n\n        // Only assign new objectId if we are creating new object\n        if (!this.data.objectId) {\n          this.data.objectId = cryptoUtils.newObjectId(this.config.objectIdSize);\n        }\n        if (schema) {\n          Object.keys(schema.fields).forEach(fieldName => {\n            setRequiredFieldIfNeeded(fieldName, true);\n          });\n        }\n      } else if (schema) {\n        Object.keys(this.data).forEach(fieldName => {\n          setRequiredFieldIfNeeded(fieldName, false);\n        });\n      }\n    });\n  }\n  return Promise.resolve();\n};\n\n// Transforms auth data for a user object.\n// Does nothing if this isn't a user object.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.validateAuthData = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n\n  if (!this.query && !this.data.authData) {\n    if (typeof this.data.username !== 'string' || _.isEmpty(this.data.username)) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'bad or missing username');\n    }\n    if (typeof this.data.password !== 'string' || _.isEmpty(this.data.password)) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'password is required');\n    }\n  }\n\n  if (\n    (this.data.authData && !Object.keys(this.data.authData).length) ||\n    !Object.prototype.hasOwnProperty.call(this.data, 'authData')\n  ) {\n    // Handle saving authData to {} or if authData doesn't exist\n    return;\n  } else if (Object.prototype.hasOwnProperty.call(this.data, 'authData') && !this.data.authData) {\n    // Handle saving authData to null\n    throw new Parse.Error(\n      Parse.Error.UNSUPPORTED_SERVICE,\n      'This authentication method is unsupported.'\n    );\n  }\n\n  var authData = this.data.authData;\n  var providers = Object.keys(authData);\n  if (providers.length > 0) {\n    const canHandleAuthData = providers.reduce((canHandle, provider) => {\n      var providerAuthData = authData[provider];\n      var hasToken = providerAuthData && providerAuthData.id;\n      return canHandle && (hasToken || providerAuthData == null);\n    }, true);\n    if (canHandleAuthData) {\n      return this.handleAuthData(authData);\n    }\n  }\n  throw new Parse.Error(\n    Parse.Error.UNSUPPORTED_SERVICE,\n    'This authentication method is unsupported.'\n  );\n};\n\nRestWrite.prototype.handleAuthDataValidation = function (authData) {\n  const validations = Object.keys(authData).map(provider => {\n    if (authData[provider] === null) {\n      return Promise.resolve();\n    }\n    const validateAuthData = this.config.authDataManager.getValidatorForProvider(provider);\n    if (!validateAuthData) {\n      throw new Parse.Error(\n        Parse.Error.UNSUPPORTED_SERVICE,\n        'This authentication method is unsupported.'\n      );\n    }\n    return validateAuthData(authData[provider]);\n  });\n  return Promise.all(validations);\n};\n\nRestWrite.prototype.findUsersWithAuthData = function (authData) {\n  const providers = Object.keys(authData);\n  const query = providers\n    .reduce((memo, provider) => {\n      if (!authData[provider]) {\n        return memo;\n      }\n      const queryKey = `authData.${provider}.id`;\n      const query = {};\n      query[queryKey] = authData[provider].id;\n      memo.push(query);\n      return memo;\n    }, [])\n    .filter(q => {\n      return typeof q !== 'undefined';\n    });\n\n  let findPromise = Promise.resolve([]);\n  if (query.length > 0) {\n    findPromise = this.config.database.find(this.className, { $or: query }, {});\n  }\n\n  return findPromise;\n};\n\nRestWrite.prototype.filteredObjectsByACL = function (objects) {\n  if (this.auth.isMaster) {\n    return objects;\n  }\n  return objects.filter(object => {\n    if (!object.ACL) {\n      return true; // legacy users that have no ACL field on them\n    }\n    // Regular users that have been locked out.\n    return object.ACL && Object.keys(object.ACL).length > 0;\n  });\n};\n\nRestWrite.prototype.handleAuthData = function (authData) {\n  let results;\n  return this.findUsersWithAuthData(authData).then(async r => {\n    results = this.filteredObjectsByACL(r);\n\n    if (results.length == 1) {\n      this.storage['authProvider'] = Object.keys(authData).join(',');\n\n      const userResult = results[0];\n      const mutatedAuthData = {};\n      Object.keys(authData).forEach(provider => {\n        const providerData = authData[provider];\n        const userAuthData = userResult.authData[provider];\n        if (!_.isEqual(providerData, userAuthData)) {\n          mutatedAuthData[provider] = providerData;\n        }\n      });\n      const hasMutatedAuthData = Object.keys(mutatedAuthData).length !== 0;\n      let userId;\n      if (this.query && this.query.objectId) {\n        userId = this.query.objectId;\n      } else if (this.auth && this.auth.user && this.auth.user.id) {\n        userId = this.auth.user.id;\n      }\n      if (!userId || userId === userResult.objectId) {\n        // no user making the call\n        // OR the user making the call is the right one\n        // Login with auth data\n        delete results[0].password;\n\n        // need to set the objectId first otherwise location has trailing undefined\n        this.data.objectId = userResult.objectId;\n\n        if (!this.query || !this.query.objectId) {\n          // this a login call, no userId passed\n          this.response = {\n            response: userResult,\n            location: this.location(),\n          };\n          // Run beforeLogin hook before storing any updates\n          // to authData on the db; changes to userResult\n          // will be ignored.\n          await this.runBeforeLoginTrigger(deepcopy(userResult));\n        }\n\n        // If we didn't change the auth data, just keep going\n        if (!hasMutatedAuthData) {\n          return;\n        }\n        // We have authData that is updated on login\n        // that can happen when token are refreshed,\n        // We should update the token and let the user in\n        // We should only check the mutated keys\n        return this.handleAuthDataValidation(mutatedAuthData).then(async () => {\n          // IF we have a response, we'll skip the database operation / beforeSave / afterSave etc...\n          // we need to set it up there.\n          // We are supposed to have a response only on LOGIN with authData, so we skip those\n          // If we're not logging in, but just updating the current user, we can safely skip that part\n          if (this.response) {\n            // Assign the new authData in the response\n            Object.keys(mutatedAuthData).forEach(provider => {\n              this.response.response.authData[provider] = mutatedAuthData[provider];\n            });\n\n            // Run the DB update directly, as 'master'\n            // Just update the authData part\n            // Then we're good for the user, early exit of sorts\n            return this.config.database.update(\n              this.className,\n              { objectId: this.data.objectId },\n              { authData: mutatedAuthData },\n              {}\n            );\n          }\n        });\n      } else if (userId) {\n        // Trying to update auth data but users\n        // are different\n        if (userResult.objectId !== userId) {\n          throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n        }\n        // No auth data was mutated, just keep going\n        if (!hasMutatedAuthData) {\n          return;\n        }\n      }\n    }\n    return this.handleAuthDataValidation(authData).then(() => {\n      if (results.length > 1) {\n        // More than 1 user with the passed id's\n        throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n      }\n    });\n  });\n};\n\n// The non-third-party parts of User transformation\nRestWrite.prototype.transformUser = function () {\n  var promise = Promise.resolve();\n\n  if (this.className !== '_User') {\n    return promise;\n  }\n\n  if (!this.auth.isMaster && 'emailVerified' in this.data) {\n    const error = `Clients aren't allowed to manually update email verification.`;\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // Do not cleanup session if objectId is not set\n  if (this.query && this.objectId()) {\n    // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n    // session tokens, and remove them from the cache.\n    promise = new RestQuery(this.config, Auth.master(this.config), '_Session', {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    })\n      .execute()\n      .then(results => {\n        results.results.forEach(session =>\n          this.config.cacheController.user.del(session.sessionToken)\n        );\n      });\n  }\n\n  return promise\n    .then(() => {\n      // Transform the password\n      if (this.data.password === undefined) {\n        // ignore only if undefined. should proceed if empty ('')\n        return Promise.resolve();\n      }\n\n      if (this.query) {\n        this.storage['clearSessions'] = true;\n        // Generate a new session only if the user requested\n        if (!this.auth.isMaster) {\n          this.storage['generateNewSession'] = true;\n        }\n      }\n\n      return this._validatePasswordPolicy().then(() => {\n        return passwordCrypto.hash(this.data.password).then(hashedPassword => {\n          this.data._hashed_password = hashedPassword;\n          delete this.data.password;\n        });\n      });\n    })\n    .then(() => {\n      return this._validateUserName();\n    })\n    .then(() => {\n      return this._validateEmail();\n    });\n};\n\nRestWrite.prototype._validateUserName = function () {\n  // Check for username uniqueness\n  if (!this.data.username) {\n    if (!this.query) {\n      this.data.username = cryptoUtils.randomString(25);\n      this.responseShouldHaveUsername = true;\n    }\n    return Promise.resolve();\n  }\n  /*\n    Usernames should be unique when compared case insensitively\n\n    Users should be able to make case sensitive usernames and\n    login using the case they entered.  I.e. 'Snoopy' should preclude\n    'snoopy' as a valid username.\n  */\n  return this.config.database\n    .find(\n      this.className,\n      {\n        username: this.data.username,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.USERNAME_TAKEN,\n          'Account already exists for this username.'\n        );\n      }\n      return;\n    });\n};\n\n/*\n  As with usernames, Parse should not allow case insensitive collisions of email.\n  unlike with usernames (which can have case insensitive collisions in the case of\n  auth adapters), emails should never have a case insensitive collision.\n\n  This behavior can be enforced through a properly configured index see:\n  https://docs.mongodb.com/manual/core/index-case-insensitive/#create-a-case-insensitive-index\n  which could be implemented instead of this code based validation.\n\n  Given that this lookup should be a relatively low use case and that the case sensitive\n  unique index will be used by the db for the query, this is an adequate solution.\n*/\nRestWrite.prototype._validateEmail = function () {\n  if (!this.data.email || this.data.email.__op === 'Delete') {\n    return Promise.resolve();\n  }\n  // Validate basic email address format\n  if (!this.data.email.match(/^.+@.+$/)) {\n    return Promise.reject(\n      new Parse.Error(Parse.Error.INVALID_EMAIL_ADDRESS, 'Email address format is invalid.')\n    );\n  }\n  // Case insensitive match, see note above function.\n  return this.config.database\n    .find(\n      this.className,\n      {\n        email: this.data.email,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.EMAIL_TAKEN,\n          'Account already exists for this email address.'\n        );\n      }\n      if (\n        !this.data.authData ||\n        !Object.keys(this.data.authData).length ||\n        (Object.keys(this.data.authData).length === 1 &&\n          Object.keys(this.data.authData)[0] === 'anonymous')\n      ) {\n        // We updated the email, send a new validation\n        this.storage['sendVerificationEmail'] = true;\n        this.config.userController.setEmailVerifyToken(this.data);\n      }\n    });\n};\n\nRestWrite.prototype._validatePasswordPolicy = function () {\n  if (!this.config.passwordPolicy) return Promise.resolve();\n  return this._validatePasswordRequirements().then(() => {\n    return this._validatePasswordHistory();\n  });\n};\n\nRestWrite.prototype._validatePasswordRequirements = function () {\n  // check if the password conforms to the defined password policy if configured\n  // If we specified a custom error in our configuration use it.\n  // Example: \"Passwords must include a Capital Letter, Lowercase Letter, and a number.\"\n  //\n  // This is especially useful on the generic \"password reset\" page,\n  // as it allows the programmer to communicate specific requirements instead of:\n  // a. making the user guess whats wrong\n  // b. making a custom password reset page that shows the requirements\n  const policyError = this.config.passwordPolicy.validationError\n    ? this.config.passwordPolicy.validationError\n    : 'Password does not meet the Password Policy requirements.';\n  const containsUsernameError = 'Password cannot contain your username.';\n\n  // check whether the password meets the password strength requirements\n  if (\n    (this.config.passwordPolicy.patternValidator &&\n      !this.config.passwordPolicy.patternValidator(this.data.password)) ||\n    (this.config.passwordPolicy.validatorCallback &&\n      !this.config.passwordPolicy.validatorCallback(this.data.password))\n  ) {\n    return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n  }\n\n  // check whether password contain username\n  if (this.config.passwordPolicy.doNotAllowUsername === true) {\n    if (this.data.username) {\n      // username is not passed during password reset\n      if (this.data.password.indexOf(this.data.username) >= 0)\n        return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError));\n    } else {\n      // retrieve the User object using objectId during password reset\n      return this.config.database.find('_User', { objectId: this.objectId() }).then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        if (this.data.password.indexOf(results[0].username) >= 0)\n          return Promise.reject(\n            new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError)\n          );\n        return Promise.resolve();\n      });\n    }\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype._validatePasswordHistory = function () {\n  // check whether password is repeating from specified history\n  if (this.query && this.config.passwordPolicy.maxPasswordHistory) {\n    return this.config.database\n      .find(\n        '_User',\n        { objectId: this.objectId() },\n        { keys: ['_password_history', '_hashed_password'] }\n      )\n      .then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        const user = results[0];\n        let oldPasswords = [];\n        if (user._password_history)\n          oldPasswords = _.take(\n            user._password_history,\n            this.config.passwordPolicy.maxPasswordHistory - 1\n          );\n        oldPasswords.push(user.password);\n        const newPassword = this.data.password;\n        // compare the new password hash with all old password hashes\n        const promises = oldPasswords.map(function (hash) {\n          return passwordCrypto.compare(newPassword, hash).then(result => {\n            if (result)\n              // reject if there is a match\n              return Promise.reject('REPEAT_PASSWORD');\n            return Promise.resolve();\n          });\n        });\n        // wait for all comparisons to complete\n        return Promise.all(promises)\n          .then(() => {\n            return Promise.resolve();\n          })\n          .catch(err => {\n            if (err === 'REPEAT_PASSWORD')\n              // a match was found\n              return Promise.reject(\n                new Parse.Error(\n                  Parse.Error.VALIDATION_ERROR,\n                  `New password should not be the same as last ${this.config.passwordPolicy.maxPasswordHistory} passwords.`\n                )\n              );\n            throw err;\n          });\n      });\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype.createSessionTokenIfNeeded = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n  // Don't generate session for updating user (this.query is set) unless authData exists\n  if (this.query && !this.data.authData) {\n    return;\n  }\n  // Don't generate new sessionToken if linking via sessionToken\n  if (this.auth.user && this.data.authData) {\n    return;\n  }\n  if (\n    !this.storage['authProvider'] && // signup call, with\n    this.config.preventLoginWithUnverifiedEmail && // no login without verification\n    this.config.verifyUserEmails\n  ) {\n    // verification is on\n    return; // do not create the session token in that case!\n  }\n  return this.createSessionToken();\n};\n\nRestWrite.prototype.createSessionToken = async function () {\n  // cloud installationId from Cloud Code,\n  // never create session tokens from there.\n  if (this.auth.installationId && this.auth.installationId === 'cloud') {\n    return;\n  }\n\n  const { sessionData, createSession } = Auth.createSession(this.config, {\n    userId: this.objectId(),\n    createdWith: {\n      action: this.storage['authProvider'] ? 'login' : 'signup',\n      authProvider: this.storage['authProvider'] || 'password',\n    },\n    installationId: this.auth.installationId,\n  });\n\n  if (this.response && this.response.response) {\n    this.response.response.sessionToken = sessionData.sessionToken;\n  }\n\n  return createSession();\n};\n\n// Delete email reset tokens if user is changing password or email.\nRestWrite.prototype.deleteEmailResetTokenIfNeeded = function () {\n  if (this.className !== '_User' || this.query === null) {\n    // null query means create\n    return;\n  }\n\n  if ('password' in this.data || 'email' in this.data) {\n    const addOps = {\n      _perishable_token: { __op: 'Delete' },\n      _perishable_token_expires_at: { __op: 'Delete' },\n    };\n    this.data = Object.assign(this.data, addOps);\n  }\n};\n\nRestWrite.prototype.destroyDuplicatedSessions = function () {\n  // Only for _Session, and at creation time\n  if (this.className != '_Session' || this.query) {\n    return;\n  }\n  // Destroy the sessions in 'Background'\n  const { user, installationId, sessionToken } = this.data;\n  if (!user || !installationId) {\n    return;\n  }\n  if (!user.objectId) {\n    return;\n  }\n  this.config.database.destroy(\n    '_Session',\n    {\n      user,\n      installationId,\n      sessionToken: { $ne: sessionToken },\n    },\n    {},\n    this.validSchemaController\n  );\n};\n\n// Handles any followup logic\nRestWrite.prototype.handleFollowup = function () {\n  if (this.storage && this.storage['clearSessions'] && this.config.revokeSessionOnPasswordReset) {\n    var sessionQuery = {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    };\n    delete this.storage['clearSessions'];\n    return this.config.database\n      .destroy('_Session', sessionQuery)\n      .then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['generateNewSession']) {\n    delete this.storage['generateNewSession'];\n    return this.createSessionToken().then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['sendVerificationEmail']) {\n    delete this.storage['sendVerificationEmail'];\n    // Fire and forget!\n    this.config.userController.sendVerificationEmail(this.data);\n    return this.handleFollowup.bind(this);\n  }\n};\n\n// Handles the _Session class specialness.\n// Does nothing if this isn't an _Session object.\nRestWrite.prototype.handleSession = function () {\n  if (this.response || this.className !== '_Session') {\n    return;\n  }\n\n  if (!this.auth.user && !this.auth.isMaster) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token required.');\n  }\n\n  // TODO: Verify proper error to throw\n  if (this.data.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Cannot set ' + 'ACL on a Session.');\n  }\n\n  if (this.query) {\n    if (this.data.user && !this.auth.isMaster && this.data.user.objectId != this.auth.user.id) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.installationId) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.sessionToken) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    }\n  }\n\n  if (!this.query && !this.auth.isMaster) {\n    const additionalSessionData = {};\n    for (var key in this.data) {\n      if (key === 'objectId' || key === 'user') {\n        continue;\n      }\n      additionalSessionData[key] = this.data[key];\n    }\n\n    const { sessionData, createSession } = Auth.createSession(this.config, {\n      userId: this.auth.user.id,\n      createdWith: {\n        action: 'create',\n      },\n      additionalSessionData,\n    });\n\n    return createSession().then(results => {\n      if (!results.response) {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Error creating session.');\n      }\n      sessionData['objectId'] = results.response['objectId'];\n      this.response = {\n        status: 201,\n        location: results.location,\n        response: sessionData,\n      };\n    });\n  }\n};\n\n// Handles the _Installation class specialness.\n// Does nothing if this isn't an installation object.\n// If an installation is found, this can mutate this.query and turn a create\n// into an update.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.handleInstallation = function () {\n  if (this.response || this.className !== '_Installation') {\n    return;\n  }\n\n  if (\n    !this.query &&\n    !this.data.deviceToken &&\n    !this.data.installationId &&\n    !this.auth.installationId\n  ) {\n    throw new Parse.Error(\n      135,\n      'at least one ID field (deviceToken, installationId) ' + 'must be specified in this operation'\n    );\n  }\n\n  // If the device token is 64 characters long, we assume it is for iOS\n  // and lowercase it.\n  if (this.data.deviceToken && this.data.deviceToken.length == 64) {\n    this.data.deviceToken = this.data.deviceToken.toLowerCase();\n  }\n\n  // We lowercase the installationId if present\n  if (this.data.installationId) {\n    this.data.installationId = this.data.installationId.toLowerCase();\n  }\n\n  let installationId = this.data.installationId;\n\n  // If data.installationId is not set and we're not master, we can lookup in auth\n  if (!installationId && !this.auth.isMaster) {\n    installationId = this.auth.installationId;\n  }\n\n  if (installationId) {\n    installationId = installationId.toLowerCase();\n  }\n\n  // Updating _Installation but not updating anything critical\n  if (this.query && !this.data.deviceToken && !installationId && !this.data.deviceType) {\n    return;\n  }\n\n  var promise = Promise.resolve();\n\n  var idMatch; // Will be a match on either objectId or installationId\n  var objectIdMatch;\n  var installationIdMatch;\n  var deviceTokenMatches = [];\n\n  // Instead of issuing 3 reads, let's do it with one OR.\n  const orQueries = [];\n  if (this.query && this.query.objectId) {\n    orQueries.push({\n      objectId: this.query.objectId,\n    });\n  }\n  if (installationId) {\n    orQueries.push({\n      installationId: installationId,\n    });\n  }\n  if (this.data.deviceToken) {\n    orQueries.push({ deviceToken: this.data.deviceToken });\n  }\n\n  if (orQueries.length == 0) {\n    return;\n  }\n\n  promise = promise\n    .then(() => {\n      return this.config.database.find(\n        '_Installation',\n        {\n          $or: orQueries,\n        },\n        {}\n      );\n    })\n    .then(results => {\n      results.forEach(result => {\n        if (this.query && this.query.objectId && result.objectId == this.query.objectId) {\n          objectIdMatch = result;\n        }\n        if (result.installationId == installationId) {\n          installationIdMatch = result;\n        }\n        if (result.deviceToken == this.data.deviceToken) {\n          deviceTokenMatches.push(result);\n        }\n      });\n\n      // Sanity checks when running a query\n      if (this.query && this.query.objectId) {\n        if (!objectIdMatch) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for update.');\n        }\n        if (\n          this.data.installationId &&\n          objectIdMatch.installationId &&\n          this.data.installationId !== objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'installationId may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceToken &&\n          objectIdMatch.deviceToken &&\n          this.data.deviceToken !== objectIdMatch.deviceToken &&\n          !this.data.installationId &&\n          !objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'deviceToken may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceType &&\n          this.data.deviceType &&\n          this.data.deviceType !== objectIdMatch.deviceType\n        ) {\n          throw new Parse.Error(136, 'deviceType may not be changed in this ' + 'operation');\n        }\n      }\n\n      if (this.query && this.query.objectId && objectIdMatch) {\n        idMatch = objectIdMatch;\n      }\n\n      if (installationId && installationIdMatch) {\n        idMatch = installationIdMatch;\n      }\n      // need to specify deviceType only if it's new\n      if (!this.query && !this.data.deviceType && !idMatch) {\n        throw new Parse.Error(135, 'deviceType must be specified in this operation');\n      }\n    })\n    .then(() => {\n      if (!idMatch) {\n        if (!deviceTokenMatches.length) {\n          return;\n        } else if (\n          deviceTokenMatches.length == 1 &&\n          (!deviceTokenMatches[0]['installationId'] || !installationId)\n        ) {\n          // Single match on device token but none on installationId, and either\n          // the passed object or the match is missing an installationId, so we\n          // can just return the match.\n          return deviceTokenMatches[0]['objectId'];\n        } else if (!this.data.installationId) {\n          throw new Parse.Error(\n            132,\n            'Must specify installationId when deviceToken ' +\n              'matches multiple Installation objects'\n          );\n        } else {\n          // Multiple device token matches and we specified an installation ID,\n          // or a single match where both the passed and matching objects have\n          // an installation ID. Try cleaning out old installations that match\n          // the deviceToken, and return nil to signal that a new object should\n          // be created.\n          var delQuery = {\n            deviceToken: this.data.deviceToken,\n            installationId: {\n              $ne: installationId,\n            },\n          };\n          if (this.data.appIdentifier) {\n            delQuery['appIdentifier'] = this.data.appIdentifier;\n          }\n          this.config.database.destroy('_Installation', delQuery).catch(err => {\n            if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n              // no deletions were made. Can be ignored.\n              return;\n            }\n            // rethrow the error\n            throw err;\n          });\n          return;\n        }\n      } else {\n        if (deviceTokenMatches.length == 1 && !deviceTokenMatches[0]['installationId']) {\n          // Exactly one device token match and it doesn't have an installation\n          // ID. This is the one case where we want to merge with the existing\n          // object.\n          const delQuery = { objectId: idMatch.objectId };\n          return this.config.database\n            .destroy('_Installation', delQuery)\n            .then(() => {\n              return deviceTokenMatches[0]['objectId'];\n            })\n            .catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n        } else {\n          if (this.data.deviceToken && idMatch.deviceToken != this.data.deviceToken) {\n            // We're setting the device token on an existing installation, so\n            // we should try cleaning out old installations that match this\n            // device token.\n            const delQuery = {\n              deviceToken: this.data.deviceToken,\n            };\n            // We have a unique install Id, use that to preserve\n            // the interesting installation\n            if (this.data.installationId) {\n              delQuery['installationId'] = {\n                $ne: this.data.installationId,\n              };\n            } else if (\n              idMatch.objectId &&\n              this.data.objectId &&\n              idMatch.objectId == this.data.objectId\n            ) {\n              // we passed an objectId, preserve that instalation\n              delQuery['objectId'] = {\n                $ne: idMatch.objectId,\n              };\n            } else {\n              // What to do here? can't really clean up everything...\n              return idMatch.objectId;\n            }\n            if (this.data.appIdentifier) {\n              delQuery['appIdentifier'] = this.data.appIdentifier;\n            }\n            this.config.database.destroy('_Installation', delQuery).catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored.\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n          }\n          // In non-merge scenarios, just return the installation match id\n          return idMatch.objectId;\n        }\n      }\n    })\n    .then(objId => {\n      if (objId) {\n        this.query = { objectId: objId };\n        delete this.data.objectId;\n        delete this.data.createdAt;\n      }\n      // TODO: Validate ops (add/remove on channels, $inc on badge, etc.)\n    });\n  return promise;\n};\n\n// If we short-circuted the object response - then we need to make sure we expand all the files,\n// since this might not have a query, meaning it won't return the full result back.\n// TODO: (nlutsenko) This should die when we move to per-class based controllers on _Session/_User\nRestWrite.prototype.expandFilesForExistingObjects = function () {\n  // Check whether we have a short-circuited response - only then run expansion.\n  if (this.response && this.response.response) {\n    this.config.filesController.expandFilesInObject(this.config, this.response.response);\n  }\n};\n\nRestWrite.prototype.runDatabaseOperation = function () {\n  if (this.response) {\n    return;\n  }\n\n  if (this.className === '_Role') {\n    this.config.cacheController.role.clear();\n  }\n\n  if (this.className === '_User' && this.query && this.auth.isUnauthenticated()) {\n    throw new Parse.Error(\n      Parse.Error.SESSION_MISSING,\n      `Cannot modify user ${this.query.objectId}.`\n    );\n  }\n\n  if (this.className === '_Product' && this.data.download) {\n    this.data.downloadName = this.data.download.name;\n  }\n\n  // TODO: Add better detection for ACL, ensuring a user can't be locked from\n  //       their own user record.\n  if (this.data.ACL && this.data.ACL['*unresolved']) {\n    throw new Parse.Error(Parse.Error.INVALID_ACL, 'Invalid ACL.');\n  }\n\n  if (this.query) {\n    // Force the user to not lockout\n    // Matched with parse.com\n    if (this.className === '_User' && this.data.ACL && this.auth.isMaster !== true) {\n      this.data.ACL[this.query.objectId] = { read: true, write: true };\n    }\n    // update password timestamp if user password is being changed\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordAge\n    ) {\n      this.data._password_changed_at = Parse._encode(new Date());\n    }\n    // Ignore createdAt when update\n    delete this.data.createdAt;\n\n    let defer = Promise.resolve();\n    // if password history is enabled then save the current password to history\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordHistory\n    ) {\n      defer = this.config.database\n        .find(\n          '_User',\n          { objectId: this.objectId() },\n          { keys: ['_password_history', '_hashed_password'] }\n        )\n        .then(results => {\n          if (results.length != 1) {\n            throw undefined;\n          }\n          const user = results[0];\n          let oldPasswords = [];\n          if (user._password_history) {\n            oldPasswords = _.take(\n              user._password_history,\n              this.config.passwordPolicy.maxPasswordHistory\n            );\n          }\n          //n-1 passwords go into history including last password\n          while (\n            oldPasswords.length > Math.max(0, this.config.passwordPolicy.maxPasswordHistory - 2)\n          ) {\n            oldPasswords.shift();\n          }\n          oldPasswords.push(user.password);\n          this.data._password_history = oldPasswords;\n        });\n    }\n\n    return defer.then(() => {\n      // Run an update\n      return this.config.database\n        .update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          false,\n          false,\n          this.validSchemaController\n        )\n        .then(response => {\n          response.updatedAt = this.updatedAt;\n          this._updateResponseWithData(response, this.data);\n          this.response = { response };\n        });\n    });\n  } else {\n    // Set the default ACL and password timestamp for the new _User\n    if (this.className === '_User') {\n      var ACL = this.data.ACL;\n      // default public r/w ACL\n      if (!ACL) {\n        ACL = {};\n        ACL['*'] = { read: true, write: false };\n      }\n      // make sure the user is not locked down\n      ACL[this.data.objectId] = { read: true, write: true };\n      this.data.ACL = ACL;\n      // password timestamp to be used when password expiry policy is enforced\n      if (this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n        this.data._password_changed_at = Parse._encode(new Date());\n      }\n    }\n\n    // Run a create\n    return this.config.database\n      .create(this.className, this.data, this.runOptions, false, this.validSchemaController)\n      .catch(error => {\n        if (this.className !== '_User' || error.code !== Parse.Error.DUPLICATE_VALUE) {\n          throw error;\n        }\n\n        // Quick check, if we were able to infer the duplicated field name\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'username') {\n          throw new Parse.Error(\n            Parse.Error.USERNAME_TAKEN,\n            'Account already exists for this username.'\n          );\n        }\n\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'email') {\n          throw new Parse.Error(\n            Parse.Error.EMAIL_TAKEN,\n            'Account already exists for this email address.'\n          );\n        }\n\n        // If this was a failed user creation due to username or email already taken, we need to\n        // check whether it was username or email and return the appropriate error.\n        // Fallback to the original method\n        // TODO: See if we can later do this without additional queries by using named indexes.\n        return this.config.database\n          .find(\n            this.className,\n            {\n              username: this.data.username,\n              objectId: { $ne: this.objectId() },\n            },\n            { limit: 1 }\n          )\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.USERNAME_TAKEN,\n                'Account already exists for this username.'\n              );\n            }\n            return this.config.database.find(\n              this.className,\n              { email: this.data.email, objectId: { $ne: this.objectId() } },\n              { limit: 1 }\n            );\n          })\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.EMAIL_TAKEN,\n                'Account already exists for this email address.'\n              );\n            }\n            throw new Parse.Error(\n              Parse.Error.DUPLICATE_VALUE,\n              'A duplicate value for a field with unique values was provided'\n            );\n          });\n      })\n      .then(response => {\n        response.objectId = this.data.objectId;\n        response.createdAt = this.data.createdAt;\n\n        if (this.responseShouldHaveUsername) {\n          response.username = this.data.username;\n        }\n        this._updateResponseWithData(response, this.data);\n        this.response = {\n          status: 201,\n          response,\n          location: this.location(),\n        };\n      });\n  }\n};\n\n// Returns nothing - doesn't wait for the trigger.\nRestWrite.prototype.runAfterSaveTrigger = function () {\n  if (!this.response || !this.response.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'afterSave' trigger for this class.\n  const hasAfterSaveHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterSave,\n    this.config.applicationId\n  );\n  const hasLiveQuery = this.config.liveQueryController.hasLiveQuery(this.className);\n  if (!hasAfterSaveHook && !hasLiveQuery) {\n    return Promise.resolve();\n  }\n\n  var extraData = { className: this.className };\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  // Build the original object, we only do this for a update write.\n  let originalObject;\n  if (this.query && this.query.objectId) {\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  // Build the inflated object, different from beforeSave, originalData is not empty\n  // since developers can change data in the beforeSave.\n  const updatedObject = this.buildUpdatedObject(extraData);\n  updatedObject._handleSaveResponse(this.response.response, this.response.status || 200);\n\n  this.config.database.loadSchema().then(schemaController => {\n    // Notifiy LiveQueryServer if possible\n    const perms = schemaController.getClassLevelPermissions(updatedObject.className);\n    this.config.liveQueryController.onAfterSave(\n      updatedObject.className,\n      updatedObject,\n      originalObject,\n      perms\n    );\n  });\n\n  // Run afterSave trigger\n  return triggers\n    .maybeRunTrigger(\n      triggers.Types.afterSave,\n      this.auth,\n      updatedObject,\n      originalObject,\n      this.config,\n      this.context\n    )\n    .then(result => {\n      if (result && typeof result === 'object') {\n        this.response.response = result;\n      }\n    })\n    .catch(function (err) {\n      logger.warn('afterSave caught an error', err);\n    });\n};\n\n// A helper to figure out what location this operation happens at.\nRestWrite.prototype.location = function () {\n  var middle = this.className === '_User' ? '/users/' : '/classes/' + this.className + '/';\n  const mount = this.config.mount || this.config.serverURL;\n  return mount + middle + this.data.objectId;\n};\n\n// A helper to get the object id for this operation.\n// Because it could be either on the query or on the data\nRestWrite.prototype.objectId = function () {\n  return this.data.objectId || this.query.objectId;\n};\n\n// Returns a copy of the data and delete bad keys (_auth_data, _hashed_password...)\nRestWrite.prototype.sanitizedData = function () {\n  const data = Object.keys(this.data).reduce((data, key) => {\n    // Regexp comes from Parse.Object.prototype.validate\n    if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n  return Parse._decode(undefined, data);\n};\n\n// Returns an updated copy of the object\nRestWrite.prototype.buildUpdatedObject = function (extraData) {\n  const updatedObject = triggers.inflate(extraData, this.originalData);\n  Object.keys(this.data).reduce(function (data, key) {\n    if (key.indexOf('.') > 0) {\n      if (typeof data[key].__op === 'string') {\n        updatedObject.set(key, data[key]);\n      } else {\n        // subdocument key with dot notation { 'x.y': v } => { 'x': { 'y' : v } })\n        const splittedKey = key.split('.');\n        const parentProp = splittedKey[0];\n        let parentVal = updatedObject.get(parentProp);\n        if (typeof parentVal !== 'object') {\n          parentVal = {};\n        }\n        parentVal[splittedKey[1]] = data[key];\n        updatedObject.set(parentProp, parentVal);\n      }\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n\n  updatedObject.set(this.sanitizedData());\n  return updatedObject;\n};\n\nRestWrite.prototype.cleanUserAuthData = function () {\n  if (this.response && this.response.response && this.className === '_User') {\n    const user = this.response.response;\n    if (user.authData) {\n      Object.keys(user.authData).forEach(provider => {\n        if (user.authData[provider] === null) {\n          delete user.authData[provider];\n        }\n      });\n      if (Object.keys(user.authData).length == 0) {\n        delete user.authData;\n      }\n    }\n  }\n};\n\nRestWrite.prototype._updateResponseWithData = function (response, data) {\n  if (_.isEmpty(this.storage.fieldsChangedByTrigger)) {\n    return response;\n  }\n  const clientSupportsDelete = ClientSDK.supportsForwardDelete(this.clientSDK);\n  this.storage.fieldsChangedByTrigger.forEach(fieldName => {\n    const dataValue = data[fieldName];\n\n    if (!Object.prototype.hasOwnProperty.call(response, fieldName)) {\n      response[fieldName] = dataValue;\n    }\n\n    // Strips operations from responses\n    if (response[fieldName] && response[fieldName].__op) {\n      delete response[fieldName];\n      if (clientSupportsDelete && dataValue.__op == 'Delete') {\n        response[fieldName] = dataValue;\n      }\n    }\n  });\n  return response;\n};\n\nexport default RestWrite;\nmodule.exports = RestWrite;\n"], "fixing_code": ["## Parse Server Changelog\n\n### master\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.1...master)\n\n### 4.5.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.0...4.5.1)\n\n- SECURITY FIX: Fixes incorrect session property `authProvider: password` of anonymous users. When signing up an anonymous user, the session field `createdWith` indicates incorrectly that the session has been created using username and password with `authProvider: password`, instead of an anonymous sign-up with `authProvider: anonymous`. This fixes the issue by setting the correct `authProvider: anonymous` for future sign-ups of anonymous users. This fix does not fix incorrect `authProvider: password` for existing sessions of anonymous users. Consider this if your app logic depends on the `authProvider` field. (Corey Baker) [GHSA-23r4-5mxp-c7g5](https://github.com/parse-community/parse-server/security/advisories/GHSA-23r4-5mxp-c7g5)\n\n### 4.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.4.0...4.5.0)\n\n__BREAKING CHANGES:__\n- FIX: Consistent casing for afterLiveQueryEvent. The afterLiveQueryEvent was introduced in 4.4.0 with inconsistent casing for the event names, which was fixed in 4.5.0. [#7023](https://github.com/parse-community/parse-server/pull/7023). Thanks to [dblythy](https://github.com/dblythy).\n___\n- FIX: Properly handle serverURL and publicServerUrl in Batch requests. [#7049](https://github.com/parse-community/parse-server/pull/7049). Thanks to [Zach Goldberg](https://github.com/ZachGoldberg).\n- IMPROVE: Prevent invalid column names (className and length). [#7053](https://github.com/parse-community/parse-server/pull/7053). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: GraphQL: Remove viewer from logout mutation. [#7029](https://github.com/parse-community/parse-server/pull/7029). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- IMPROVE: GraphQL: Optimize on Relation. [#7044](https://github.com/parse-community/parse-server/pull/7044). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Include sessionToken in onLiveQueryEvent. [#7043](https://github.com/parse-community/parse-server/pull/7043). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Definitions for accountLockout and passwordPolicy. [#7040](https://github.com/parse-community/parse-server/pull/7040). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix typo in server definitions for emailVerifyTokenReuseIfValid. [#7037](https://github.com/parse-community/parse-server/pull/7037). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: LDAP auth stores password in plain text. See [GHSA-4w46-w44m-3jq3](https://github.com/parse-community/parse-server/security/advisories/GHSA-4w46-w44m-3jq3) for more details about the vulnerability and [da905a3](https://github.com/parse-community/parse-server/commit/da905a357d062ab4fea727a21eac231acc2ed92a) for the fix. Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- NEW: Reuse tokens if they haven't expired. [#7017](https://github.com/parse-community/parse-server/pull/7017). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add LDAPS-support to LDAP-Authcontroller. [#7014](https://github.com/parse-community/parse-server/pull/7014). Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- FIX: (beforeSave/afterSave): Return value instead of Parse.Op for nested fields. [#7005](https://github.com/parse-community/parse-server/pull/7005). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: (beforeSave): Skip Sanitizing Database results. [#7003](https://github.com/parse-community/parse-server/pull/7003). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix includeAll for querying a Pointer and Pointer array. [#7002](https://github.com/parse-community/parse-server/pull/7002). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Add encryptionKey to src/options/index.js. [#6999](https://github.com/parse-community/parse-server/pull/6999). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Update PostgresStorageAdapter.js. [#6989](https://github.com/parse-community/parse-server/pull/6989). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t).\n\n### 4.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.3.0...4.4.0)\n- IMPROVE: Update PostgresStorageAdapter.js. [#6981](https://github.com/parse-community/parse-server/pull/6981). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: skipWithMasterKey on Built-In Validator. [#6972](https://github.com/parse-community/parse-server/issues/6972). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add fileKey rotation to GridFSBucketAdapter. [#6768](https://github.com/parse-community/parse-server/pull/6768). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Remove unused parameter in Cloud Function. [#6969](https://github.com/parse-community/parse-server/issues/6969). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Validation Handler Update. [#6968](https://github.com/parse-community/parse-server/issues/6968). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (directAccess): Properly handle response status. [#6966](https://github.com/parse-community/parse-server/issues/6966). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Remove hostnameMaxLen for Mongo URL. [#6693](https://github.com/parse-community/parse-server/issues/6693). Thanks to [markhoward02](https://github.com/markhoward02).\n- IMPROVE: Show a message if cloud functions are duplicated. [#6963](https://github.com/parse-community/parse-server/issues/6963). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Pass request.query to afterFind. [#6960](https://github.com/parse-community/parse-server/issues/6960). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: Patch session vulnerability over Live Query. See [GHSA-2xm2-xj2q-qgpj](https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj) for more details about the vulnerability and [78b59fb](https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58) for the fix. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- IMPROVE: LiveQueryEvent Error Logging Improvements. [#6951](https://github.com/parse-community/parse-server/issues/6951). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Include stack in Cloud Code. [#6958](https://github.com/parse-community/parse-server/issues/6958). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (jobs): Add Error Message to JobStatus Failure. [#6954](https://github.com/parse-community/parse-server/issues/6954). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Create Cloud function afterLiveQueryEvent. [#6859](https://github.com/parse-community/parse-server/issues/6859). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Update vkontakte API to the latest version. [#6944](https://github.com/parse-community/parse-server/issues/6944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- FIX: Use an empty object as default value of options for Google Sign in. [#6844](https://github.com/parse-community/parse-server/issues/6844). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Postgres: prepend className to unique indexes. [#6741](https://github.com/parse-community/parse-server/pull/6741). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: GraphQL: Transform input types also on user mutations. [#6934](https://github.com/parse-community/parse-server/pull/6934). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Set objectId into query for Email Validation. [#6930](https://github.com/parse-community/parse-server/pull/6930). Thanks to [Danaru](https://github.com/Danaru87).\n- FIX: GraphQL: Optimize queries, fixes some null returns (on object), fix stitched GraphQLUpload. [#6709](https://github.com/parse-community/parse-server/pull/6709). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Do not throw error if user provide a pointer like index onMongo. [#6923](https://github.com/parse-community/parse-server/pull/6923). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Hotfix instagram api. [#6922](https://github.com/parse-community/parse-server/issues/6922). Thanks to [Tim](https://github.com/timination).\n- FIX: (directAccess/cloud-code): Pass installationId with LogIn. [#6903](https://github.com/parse-community/parse-server/issues/6903). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix bcrypt binary incompatibility. [#6891](https://github.com/parse-community/parse-server/issues/6891). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- NEW: Keycloak auth adapter. [#6376](https://github.com/parse-community/parse-server/issues/6376). Thanks to [Rhuan](https://github.com/rhuanbarreto).\n- IMPROVE: Changed incorrect key name in apple auth adapter tests. [#6861](https://github.com/parse-community/parse-server/issues/6861). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Fix mutating beforeSubscribe Query. [#6868](https://github.com/parse-community/parse-server/issues/6868). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix beforeLogin for users logging in with AuthData. [#6872](https://github.com/parse-community/parse-server/issues/6872). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Remove Facebook AccountKit auth. [#6870](https://github.com/parse-community/parse-server/issues/6870). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Updated TOKEN_ISSUER to 'accounts.google.com'. [#6836](https://github.com/parse-community/parse-server/issues/6836). Thanks to [Arjun Vedak](https://github.com/arjun3396).\n- IMPROVE: Optimized deletion of class field from schema by using an index if available to do an index scan instead of a collection scan. [#6815](https://github.com/parse-community/parse-server/issues/6815). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- IMPROVE: Enable MongoDB transaction test for MongoDB >= 4.0.4 [#6827](https://github.com/parse-community/parse-server/pull/6827). Thanks to [Manuel](https://github.com/mtrezza).\n\n### 4.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.2.0...4.3.0)\n- PERFORMANCE: Optimizing pointer CLP query decoration done by DatabaseController#addPointerPermissions [#6747](https://github.com/parse-community/parse-server/pull/6747). Thanks to [mess-lelouch](https://github.com/mess-lelouch).\n- SECURITY: Fix security breach on GraphQL viewer [78239ac](https://github.com/parse-community/parse-server/commit/78239ac9071167fdf243c55ae4bc9a2c0b0d89aa), [secuity advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-236h-rqv8-8q73). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Save context not present if direct access enabled [#6764](https://github.com/parse-community/parse-server/pull/6764). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani).\n- NEW: Before Connect + Before Subscribe [#6793](https://github.com/parse-community/parse-server/pull/6793). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Add version to playground to fix CDN [#6804](https://github.com/parse-community/parse-server/pull/6804). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW (EXPERIMENTAL): Idempotency enforcement for client requests. This deduplicates requests where the client intends to send one request to Parse Server but due to network issues the server receives the request multiple times. **Caution, this is an experimental feature that may not be appropriate for production.** [#6748](https://github.com/parse-community/parse-server/issues/6748). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Add production Google Auth Adapter instead of using the development url [#6734](https://github.com/parse-community/parse-server/pull/6734). Thanks to [SebC.](https://github.com/SebC99).\n- IMPROVE: Run Prettier JS Again Without requiring () on arrow functions [#6796](https://github.com/parse-community/parse-server/pull/6796). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Run Prettier JS [#6795](https://github.com/parse-community/parse-server/pull/6795). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Replace bcrypt with @node-rs/bcrypt [#6794](https://github.com/parse-community/parse-server/pull/6794). Thanks to [LongYinan](https://github.com/Brooooooklyn).\n- IMPROVE: Make clear description of anonymous user [#6655](https://github.com/parse-community/parse-server/pull/6655). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon).\n- IMPROVE: Simplify GraphQL merge system to avoid js ref bugs [#6791](https://github.com/parse-community/parse-server/pull/6791). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Pass context in beforeDelete, afterDelete, beforeFind and Parse.Cloud.run [#6666](https://github.com/parse-community/parse-server/pull/6666). Thanks to [yog27ray](https://github.com/yog27ray).\n- NEW: Allow passing custom gql schema function to ParseServer#start options [#6762](https://github.com/parse-community/parse-server/pull/6762). Thanks to [Luca](https://github.com/lucatk).\n- NEW: Allow custom cors origin header [#6772](https://github.com/parse-community/parse-server/pull/6772). Thanks to [Kevin Yao](https://github.com/kzmeyao).\n- FIX: Fix context for cascade-saving and saving existing object [#6735](https://github.com/parse-community/parse-server/pull/6735). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file bucket encryption using fileKey [#6765](https://github.com/parse-community/parse-server/pull/6765). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Removed gaze from dev dependencies and removed not working dev script [#6745](https://github.com/parse-community/parse-server/pull/6745). Thanks to [Vincent Semrau](https://github.com/vince1995).\n- IMPROVE: Upgrade graphql-tools to v6 [#6701](https://github.com/parse-community/parse-server/pull/6701). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- NEW: Support Metadata in GridFSAdapter [#6660](https://github.com/parse-community/parse-server/pull/6660). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Allow to unset file from graphql [#6651](https://github.com/parse-community/parse-server/pull/6651). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Handle shutdown for RedisCacheAdapter [#6658](https://github.com/parse-community/parse-server/pull/6658). Thanks to [promisenxu](https://github.com/promisenxu).\n- FIX: Fix explain on user class [#6650](https://github.com/parse-community/parse-server/pull/6650). Thanks to [Manuel](https://github.com/mtrezza).\n- FIX: Fix read preference for aggregate [#6585](https://github.com/parse-community/parse-server/pull/6585). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add context to Parse.Object.save [#6626](https://github.com/parse-community/parse-server/pull/6626). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Adding ssl config params to Postgres URI [#6580](https://github.com/parse-community/parse-server/pull/6580). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Travis postgres update: removing unnecessary start of mongo-runner [#6594](https://github.com/parse-community/parse-server/pull/6594). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: ObjectId size for Pointer in Postgres [#6619](https://github.com/parse-community/parse-server/pull/6619). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Improve a test case [#6629](https://github.com/parse-community/parse-server/pull/6629). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- NEW: Allow to resolve automatically Parse Type fields from Custom Schema [#6562](https://github.com/parse-community/parse-server/pull/6562). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Remove wrong console log in test [#6627](https://github.com/parse-community/parse-server/pull/6627). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- IMPROVE: Graphql tools v5 [#6611](https://github.com/parse-community/parse-server/pull/6611). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- FIX: Catch JSON.parse and return 403 properly [#6589](https://github.com/parse-community/parse-server/pull/6589). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- PERFORMANCE: Allow covering relation queries with minimal index [#6581](https://github.com/parse-community/parse-server/pull/6581). Thanks to [Noah Silas](https://github.com/noahsilas).\n- FIX: Fix Postgres group aggregation [#6522](https://github.com/parse-community/parse-server/pull/6522). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- NEW: Allow set user mapped from JWT directly on request [#6411](https://github.com/parse-community/parse-server/pull/6411). Thanks to [Gordon Sun](https://github.com/sunshineo).\n\n### 4.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.1.0...4.2.0)\n\n__BREAKING CHANGES:__\n- CHANGE: The Sign-In with Apple authentication adapter parameter `client_id` has been changed to `clientId`. If using the Apple authentication adapter, this change requires to update the Parse Server configuration accordingly. See [#6523](https://github.com/parse-community/parse-server/pull/6523) for details.\n___\n- UPGRADE: Parse JS SDK to 2.12.0 [#6548](https://github.com/parse-community/parse-server/pull/6548)\n- NEW: Support Group aggregation on multiple columns for Postgres [#6483](https://github.com/parse-community/parse-server/pull/6483). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- FIX: Improve test reliability by instructing Travis to only install one version of Postgres [#6490](https://github.com/parse-community/parse-server/pull/6490). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: Unknown type bug on overloaded types [#6494](https://github.com/parse-community/parse-server/pull/6494). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Improve reliability of 'SignIn with AppleID' [#6416](https://github.com/parse-community/parse-server/pull/6416). Thanks to [Andy King](https://github.com/andrewking0207).\n- FIX: Improve Travis reliability by separating Postgres & Mongo scripts [#6505](https://github.com/parse-community/parse-server/pull/6505). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Apple SignIn support for multiple IDs [#6523](https://github.com/parse-community/parse-server/pull/6523). Thanks to [UnderratedDev](https://github.com/UnderratedDev).\n- NEW: Add support for new Instagram API [#6398](https://github.com/parse-community/parse-server/pull/6398). Thanks to [Maravilho Singa](https://github.com/maravilhosinga).\n- FIX: Updating Postgres/Postgis Call and Postgis to 3.0 [#6528](https://github.com/parse-community/parse-server/pull/6528). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: enableExpressErrorHandler logic [#6423](https://github.com/parse-community/parse-server/pull/6423). Thanks to [Nikolay Andryukhin](https://github.com/hybeats).\n- FIX: Change Order Enum Strategy for GraphQL [#6515](https://github.com/parse-community/parse-server/pull/6515). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Switch ACL to Relay Global Id for GraphQL [#6495](https://github.com/parse-community/parse-server/pull/6495). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Handle keys for pointer fields properly for GraphQL [#6499](https://github.com/parse-community/parse-server/pull/6499). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: GraphQL file mutation [#6507](https://github.com/parse-community/parse-server/pull/6507). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Aggregate geoNear with date query [#6540](https://github.com/parse-community/parse-server/pull/6540). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file triggers and file meta data [#6344](https://github.com/parse-community/parse-server/pull/6344). Thanks to [stevestencil](https://github.com/stevestencil).\n- FIX: Improve local testing of postgres [#6531](https://github.com/parse-community/parse-server/pull/6531). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Case insensitive username and email indexing and query planning for Postgres [#6506](https://github.com/parse-community/parse-server/issues/6441). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n\n### 4.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.2...4.1.0)\n\n_SECURITY RELEASE_: see [advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4) for details\n- SECURITY FIX: Patch Regex vulnerabilities. See [3a3a5ee](https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269). Special thanks to [W0lfw00d](https://github.com/W0lfw00d) for identifying and [responsibly reporting](https://github.com/parse-community/parse-server/blob/master/SECURITY.md) the vulnerability. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo) for the speedy fix.\n\n### 4.0.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.1...4.0.2)\n\n__BREAKING CHANGES:__\n1. Remove Support for Mongo 3.2 & 3.4. The new minimum supported version is Mongo 3.6.\n2. Change username and email validation to be case insensitive. This change should be transparent in most use cases. The validation behavior should now behave 'as expected'. See [#5634](https://github.com/parse-community/parse-server/pull/5634) for details.\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted above, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- FIX: attempt to get travis to deploy to npmjs again. See [#6475](https://github.com/parse-community/parse-server/pull/6457). Thanks to [Arthur Cinader](https://github.com/acinader).\n\n### 4.0.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.0...4.0.1)\n- FIX: correct 'new' travis config to properly deploy.  See [#6452](https://github.com/parse-community/parse-server/pull/6452). Thanks to [Arthur Cinader](https://github.com/acinader).\n- FIX: Better message on not allowed to protect default fields. See [#6439](https://github.com/parse-community/parse-server/pull/6439).Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n\n### 4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.10.0...4.0.0)\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted below, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- NEW: add hint option to Parse.Query [#6322](https://github.com/parse-community/parse-server/pull/6322). Thanks to [Steve Stencil](https://github.com/stevestencil)\n- FIX: CLP objectId size validation fix [#6332](https://github.com/parse-community/parse-server/pull/6332). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add volumes to Docker command [#6356](https://github.com/parse-community/parse-server/pull/6356). Thanks to [Kasra Bigdeli](https://github.com/githubsaturn)\n- NEW: GraphQL 3rd Party LoginWith Support [#6371](https://github.com/parse-community/parse-server/pull/6371). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: GraphQL Geo Queries [#6363](https://github.com/parse-community/parse-server/pull/6363). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: GraphQL Nested File Upload [#6372](https://github.com/parse-community/parse-server/pull/6372). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Granular CLP pointer permissions [#6352](https://github.com/parse-community/parse-server/pull/6352). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add missing colon for customPages [#6393](https://github.com/parse-community/parse-server/pull/6393). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: `afterLogin` cloud code hook [#6387](https://github.com/parse-community/parse-server/pull/6387). Thanks to [David Corona](https://github.com/davesters)\n- FIX: __BREAKING CHANGE__ Prevent new usernames or emails that clash with existing users' email or username if it only differs by case.  For example, don't allow a new user with the name 'Jane' if we already have a user 'jane'. [#5634](https://github.com/parse-community/parse-server/pull/5634). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: Support Travis CI V2. [#6414](https://github.com/parse-community/parse-server/pull/6414). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Prevent crashing on websocket error. [#6418](https://github.com/parse-community/parse-server/pull/6418). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Allow protectedFields for Authenticated users and Public. [$6415](https://github.com/parse-community/parse-server/pull/6415). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Correct bug in determining GraphQL pointer errors when mutating. [#6413](https://github.com/parse-community/parse-server/pull/6431). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Allow true GraphQL Schema Customization. [#6360](https://github.com/parse-community/parse-server/pull/6360). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- __BREAKING CHANGE__: Remove Support for Mongo version < 3.6 [#6445](https://github.com/parse-community/parse-server/pull/6445). Thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 3.10.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.9.0...3.10.0)\n- FIX: correct and cover ordering queries in GraphQL [#6316](https://github.com/parse-community/parse-server/pull/6316).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL support for reset password email [#6301](https://github.com/parse-community/parse-server/pull/6301). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Add default limit to GraphQL fetch [#6304](https://github.com/parse-community/parse-server/pull/6304). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: use bash syntax highlighting [#6302](https://github.com/parse-community/parse-server/pull/6302). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: Add max log file option [#6296](https://github.com/parse-community/parse-server/pull/6296). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: support user supplied objectId [#6101](https://github.com/parse-community/parse-server/pull/6101). Thanks to [Ruhan](https://github.com/rhuanbarretos)\n- FIX: Add missing encodeURIComponent on username [#6278](https://github.com/parse-community/parse-server/pull/6278). Thanks to [Christopher Brookes](https://github.com/Klaitos)\n- NEW: update  PostgresStorageAdapter.js to use async/await [#6275](https://github.com/parse-community/parse-server/pull/6275). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: Support required fields on output type for GraphQL [#6279](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Support required fields for GraphQL [#6271](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: use mongodb 3.3.5 [#6263](https://github.com/parse-community/parse-server/pull/6263). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL: DX Relational Where Query [#6255](https://github.com/parse-community/parse-server/pull/6255). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL alias for mutations in classConfigs [#6258](https://github.com/parse-community/parse-server/pull/6258). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: GraphQL classConfig query alias [#6257](https://github.com/parse-community/parse-server/pull/6257). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: Allow validateFilename to return a string or Parse Error [#6246](https://github.com/parse-community/parse-server/pull/6246). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Relay Spec [#6089](https://github.com/parse-community/parse-server/pull/6089). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Set default ACL for GraphQL [#6249](https://github.com/parse-community/parse-server/pull/6249). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: LDAP auth Adapter [#6226](https://github.com/parse-community/parse-server/pull/6226). Thanks to [Julian Dax](https://github.com/brodo)\n- FIX: improve beforeFind to include Query info [#6237](https://github.com/parse-community/parse-server/pull/6237). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: improve websocket error handling [#6230](https://github.com/parse-community/parse-server/pull/6230). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: addition of an afterLogout trigger [#6217](https://github.com/parse-community/parse-server/pull/6217). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Initialize default logger [#6186](https://github.com/parse-community/parse-server/pull/6186). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add funding link [#6192](https://github.com/parse-community/parse-server/pull/6192 ). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: installationId on LiveQuery connect [#6180](https://github.com/parse-community/parse-server/pull/6180). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add exposing port in docker container [#6165](https://github.com/parse-community/parse-server/pull/6165). Thanks to [Priyash Patil](https://github.com/priyashpatil)\n- NEW: Support Google Play Games Service [#6147](https://github.com/parse-community/parse-server/pull/6147). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Throw error when setting authData to null [#6154](https://github.com/parse-community/parse-server/pull/6154). Thanks to [Manuel](https://github.com/mtrezza)\n- CHANGE: Move filename validation out of the Router and into the FilesAdaptor [#6157](https://github.com/parse-community/parse-server/pull/6157). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Added warning for special URL sensitive characters for appId [#6159](https://github.com/parse-community/parse-server/pull/6159). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- NEW: Support Apple Game Center Auth [#6143](https://github.com/parse-community/parse-server/pull/6143). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test with Node 12 [#6133](https://github.com/parse-community/parse-server/pull/6133). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: prevent after find from firing when saving objects [#6127](https://github.com/parse-community/parse-server/pull/6127). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL Mutations not returning updated information [6130](https://github.com/parse-community/parse-server/pull/6130). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Cleanup Schema cache per request [#6216](https://github.com/parse-community/parse-server/pull/6216). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Improve installation instructions [#6120](https://github.com/parse-community/parse-server/pull/6120). Thanks to [Andres Galante](https://github.com/andresgalante)\n- DOC: add code formatting to contributing guidelines [#6119](https://github.com/parse-community/parse-server/pull/6119). Thanks to [Andres Galante](https://github.com/andresgalante)\n- NEW: Add GraphQL ACL Type + Input [#5957](https://github.com/parse-community/parse-server/pull/5957). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: replace public key [#6099](https://github.com/parse-community/parse-server/pull/6099). Thanks to [Arthur Cinader](https://github.com/acinader)\n- NEW: Support microsoft authentication in GraphQL [#6051](https://github.com/parse-community/parse-server/pull/6051). Thanks to [Alann Maulana](https://github.com/alann-maulana)\n- NEW: Install parse-server 3.9.0 instead of 2.2 [#6069](https://github.com/parse-community/parse-server/pull/6069). Thanks to [Julian Dax](https://github.com/brodo)\n- NEW: Use #!/bin/bash instead of #!/bin/sh [#6062](https://github.com/parse-community/parse-server/pull/6062). Thanks to [Julian Dax](https://github.com/brodo)\n- DOC: Update GraphQL readme section [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n### 3.9.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.8.0...3.9.0)\n- NEW: Add allowHeaders to Options [#6044](https://github.com/parse-community/parse-server/pull/6044). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Introduce ReadOptionsInput to GraphQL API [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Stream video with GridFSBucketAdapter (implements byte-range requests) [#6028](https://github.com/parse-community/parse-server/pull/6028). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Aggregate not matching null values [#6043](https://github.com/parse-community/parse-server/pull/6043). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Improve callCloudCode mutation to receive a CloudCodeFunction enum instead of a String in the GraphQL API [#6029](https://github.com/parse-community/parse-server/pull/6029). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- TEST: Add more tests to transactions [#6022](https://github.com/parse-community/parse-server/pull/6022). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Pointer constraint input type as ID in the GraphQL API [#6020](https://github.com/parse-community/parse-server/pull/6020). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- CHANGE: Remove underline from operators of the GraphQL API [#6024](https://github.com/parse-community/parse-server/pull/6024). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Make method async as expected in usage [#6025](https://github.com/parse-community/parse-server/pull/6025). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- DOC: Added breaking change note to 3.8 release [#6023](https://github.com/parse-community/parse-server/pull/6023). Thanks to [Manuel](https://github.com/mtrezza)\n- NEW: Added support for line auth [#6007](https://github.com/parse-community/parse-server/pull/6007). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- FIX: Fix aggregate group id [#5994](https://github.com/parse-community/parse-server/pull/5994). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Schema operations instead of generic operations in the GraphQL API [#5993](https://github.com/parse-community/parse-server/pull/5993). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Fix changelog formatting[#6009](https://github.com/parse-community/parse-server/pull/6009). Thanks to [Tom Fox](https://github.com/TomWFox)\n- CHANGE: Rename objectId to id in the GraphQL API [#5985](https://github.com/parse-community/parse-server/pull/5985). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- FIX: Fix beforeLogin trigger when user has a file [#6001](https://github.com/parse-community/parse-server/pull/6001). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Update GraphQL Docs with the latest changes [#5980](https://github.com/parse-community/parse-server/pull/5980). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n### 3.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.2...3.8.0)\n- NEW:  Protected fields pointer-permissions support [#5951](https://github.com/parse-community/parse-server/pull/5951).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- NEW: GraphQL DX: Relation/Pointer [#5946](https://github.com/parse-community/parse-server/pull/5946).  Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Master Key Only Config Properties [#5953](https://github.com/parse-community/parse-server/pull/5954). Thanks to [Manuel](https://github.com/mtrezza)\n- FIX: Better validation when creating a Relation fields [#5922](https://github.com/parse-community/parse-server/pull/5922).  Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: enable GraphQL file upload [#5944](https://github.com/parse-community/parse-server/pull/5944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Handle shutdown on grid adapters  [#5943](https://github.com/parse-community/parse-server/pull/5943).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Fix GraphQL max upload size [#5940](https://github.com/parse-community/parse-server/pull/5940). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove Buffer() deprecation notice [#5942](https://github.com/parse-community/parse-server/pull/5942).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove MongoDB unified topology deprecation notice from the grid adapter [#5941](https://github.com/parse-community/parse-server/pull/5941).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: add callback for serverCloseComplete [#5937](https://github.com/parse-community/parse-server/pull/5937). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOCS: Add Cloud Code guide to README [#5936](https://github.com/parse-community/parse-server/pull/5936).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Remove nested operations from GraphQL API [#5931](https://github.com/parse-community/parse-server/pull/5931).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Improve Live Query Monitoring [#5927](https://github.com/parse-community/parse-server/pull/5927).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL: Fix undefined Array [#5296](https://github.com/parse-community/parse-server/pull/5926). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Added array support for pointer-permissions [#5921](https://github.com/parse-community/parse-server/pull/5921).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- GraphQL: Renaming Types/Inputs [#5921](https://github.com/parse-community/parse-server/pull/5921). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Lint no-prototype-builtins [#5920](https://github.com/parse-community/parse-server/pull/5920). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Inline Fragment on Array Fields [#5908](https://github.com/parse-community/parse-server/pull/5908). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: Add instructions to launch a compatible Docker Postgres [](). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- Fix: Undefined dot notation in matchKeyInQuery [#5917](https://github.com/parse-community/parse-server/pull/5917). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- Fix: Logger print JSON and Numbers [#5916](https://github.com/parse-community/parse-server/pull/5916). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Return specific Type on specific Mutation [#5893](https://github.com/parse-community/parse-server/pull/5893). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Apple sign-in authAdapter [#5891](https://github.com/parse-community/parse-server/pull/5891). Thanks to [SebC](https://github.com/SebC99).\n- DOCS: Add GraphQL beta notice [#5886](https://github.com/parse-community/parse-server/pull/5886). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- GraphQL: Remove \"password\" output field from _User class [#5889](https://github.com/parse-community/parse-server/pull/5889). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- GraphQL: Object constraints [#5715](https://github.com/parse-community/parse-server/pull/5715). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- DOCS: README top section overhaul + add sponsors [#5876](https://github.com/parse-community/parse-server/pull/5876). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: Return a Promise from classUpdate method [#5877](https://github.com/parse-community/parse-server/pull/5877). Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- FIX: Use UTC Month in aggregate tests [#5879](https://github.com/parse-community/parse-server/pull/5879). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Transaction was aborting before all promises have either resolved or rejected [#5878](https://github.com/parse-community/parse-server/pull/5878). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Use transactions for batch operation [#5849](https://github.com/parse-community/parse-server/pull/5849). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n#### Breaking Changes:\n- If you are running Parse Server on top of a MongoDB deployment which does not fit the [Retryable Writes Requirements](https://docs.mongodb.com/manual/core/retryable-writes/#prerequisites), you will have to add `retryWrites=false` to your connection string in order to upgrade to Parse Server 3.8.\n\n### 3.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.1...3.7.2)\n\n- FIX: Live Query was failing on release 3.7.1\n\n### 3.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.0...3.7.1)\n\n- FIX: Missing APN module\n- FIX: Set falsy values as default to schema fields [#5868](https://github.com/parse-community/parse-server/pull/5868), thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: Implement WebSocketServer Adapter [#5866](https://github.com/parse-community/parse-server/pull/5866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n### 3.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.6.0...3.7.0)\n\n- FIX: Prevent linkWith sessionToken from generating new session [#5801](https://github.com/parse-community/parse-server/pull/5801), thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Improve session token error messages [#5753](https://github.com/parse-community/parse-server/pull/5753), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: GraphQL { functions { call } } generic mutation [#5818](https://github.com/parse-community/parse-server/pull/5818), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Custom Schema [#5821](https://github.com/parse-community/parse-server/pull/5821), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL custom schema on CLI [#5828](https://github.com/parse-community/parse-server/pull/5828), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL @mock directive [#5836](https://github.com/parse-community/parse-server/pull/5836), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: GraphQL _or operator not working [#5840](https://github.com/parse-community/parse-server/pull/5840), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add \"count\" to CLP initial value [#5841](https://github.com/parse-community/parse-server/pull/5841), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: Add ability to alter the response from the after save trigger [#5814](https://github.com/parse-community/parse-server/pull/5814), thanks to [BrunoMaurice](https://github.com/brunoMaurice)\n- FIX: Cache apple public key for the case it fails to fetch again [#5848](https://github.com/parse-community/parse-server/pull/5848), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Configuration Options [#5782](https://github.com/parse-community/parse-server/pull/5782), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: Required fields and default values [#5835](https://github.com/parse-community/parse-server/pull/5835), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Postgres safely escape strings in nested objects [#5855](https://github.com/parse-community/parse-server/pull/5855), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Support PhantAuth authentication [#5850](https://github.com/parse-community/parse-server/pull/5850), thanks to [Ivan SZKIBA](https://github.com/szkiba)\n- FIX: Remove uws package [#5860](https://github.com/parse-community/parse-server/pull/5860), thanks to [Zeal Murapa](https://github.com/GoGross)\n\n### 3.6.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.5.0...3.6.0)\n\n- SECURITY FIX: Address [Security Advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-8w3j-g983-8jh5) of a potential [Enumeration Attack](https://www.owasp.org/index.php/Testing_for_User_Enumeration_and_Guessable_User_Account_(OWASP-AT-002)#Description_of_the_Issue) [73b0f9a](https://github.com/parse-community/parse-server/commit/73b0f9a339b81f5d757725dc557955a7b670a3ec), big thanks to [Fabian Strachanski](https://github.com/fastrde) for identifying the problem, creating a fix and following the [vulnerability disclosure guidelines](https://github.com/parse-community/parse-server/blob/master/SECURITY.md#parse-community-vulnerability-disclosure-program)\n- NEW: Added rest option: excludeKeys [#5737](https://github.com/parse-community/parse-server/pull/5737), thanks to [Raschid J.F. Rafeally](https://github.com/RaschidJFR)\n- FIX: LiveQuery create event with fields [#5790](https://github.com/parse-community/parse-server/pull/5790), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Generate sessionToken with linkWith [#5799](https://github.com/parse-community/parse-server/pull/5799), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n### 3.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.4...3.5.0)\n\n- NEW: GraphQL Support [#5674](https://github.com/parse-community/parse-server/pull/5674), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n[GraphQL Guide](https://github.com/parse-community/parse-server#graphql)\n\n- NEW: Sign in with Apple [#5694](https://github.com/parse-community/parse-server/pull/5694), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: AppSecret to Facebook Auth [#5695](https://github.com/parse-community/parse-server/pull/5695), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Postgres: Regex support foreign characters [#5598](https://github.com/parse-community/parse-server/pull/5598), thanks to [Jeff Gu Kang](https://github.com/JeffGuKang)\n- FIX: Winston Logger string interpolation [#5729](https://github.com/parse-community/parse-server/pull/5729), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n### 3.4.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.3...3.4.4)\n\nFix: Commit changes\n\n### 3.4.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.2...3.4.3)\n\nFix: Use changes in master to travis configuration to enable pushing to npm and gh_pages.  See diff for details.\n\n### 3.4.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.1...3.4.2)\n\nFix: In my haste to get a [Security Fix](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) out, I added [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5) to master instead of to 3.4.1.  This commit fixes that.  [Arthur Cinader](https://github.com/acinader)\n\n### 3.4.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.0...3.4.1)\n\nSecurity Fix: see Advisory: [GHSA-2479-qvv7-47q](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) for details [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5). Big thanks to: [Benjamin Simonsson](https://github.com/BenniPlejd) for identifying the issue and promptly bringing it to the Parse Community's attention and also big thanks to the indefatigable [Diamond Lewis](https://github.com/dplewis) for crafting a failing test and then a solution within an hour of the report.\n\n### 3.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.3.0...3.4.0)\n- NEW: Aggregate supports group by date fields [#5538](https://github.com/parse-community/parse-server/pull/5538) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: API for Read Preferences [#3963](https://github.com/parse-community/parse-server/pull/3963) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add Redis options for LiveQuery [#5584](https://github.com/parse-community/parse-server/pull/5584) thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add Direct Access option for Server Config [#5550](https://github.com/parse-community/parse-server/pull/5550) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: updating mixed array in Postgres [#5552](https://github.com/parse-community/parse-server/pull/5552) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: notEqualTo GeoPoint Query in Postgres [#5549](https://github.com/parse-community/parse-server/pull/5549), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: put the timestamp back in logs that was lost after Winston upgrade [#5571](https://github.com/parse-community/parse-server/pull/5571), thanks to [Steven Rowe](https://github.com/mrowe009) and [Arthur Cinader](https://github.com/acinader)\n- FIX: Validates permission before calling beforeSave [#5546](https://github.com/parse-community/parse-server/pull/5546), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove userSensitiveFields default value. [#5588](https://github.com/parse-community/parse-server/pull/5588), thanks to [William George](https://github.com/awgeorge)\n- FIX: Decode Date JSON value in LiveQuery. [#5540](https://github.com/parse-community/parse-server/pull/5540), thanks to [ananfang](https://github.com/ananfang)\n\n\n### 3.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.3...3.3.0)\n- NEW: beforeLogin trigger with support for auth providers ([#5445](https://github.com/parse-community/parse-server/pull/5445)), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: RFC 7662 compliant OAuth2 auth adapter ([#4910](https://github.com/parse-community/parse-server/pull/4910)), thanks to [M\u00fcller Zsolt](https://github.com/zsmuller)\n- FIX: cannot change password when maxPasswordHistory is 1 ([#5191](https://github.com/parse-community/parse-server/pull/5191)), thanks to [Tulsi Sapkota](https://github.com/Tolsee)\n- FIX (Postgres): count being very slow on large Parse Classes' collections ([#5330](https://github.com/parse-community/parse-server/pull/5330)), thanks to [CoderickLamar](https://github.com/CoderickLamar)\n- FIX: using per-key basis queue ([#5420](https://github.com/parse-community/parse-server/pull/5420)), thanks to [Georges Jamous](https://github.com/georgesjamous)\n- FIX: issue on count with Geo constraints and mongo ([#5286](https://github.com/parse-community/parse-server/pull/5286)), thanks to [Julien Qu\u00e9r\u00e9](https://github.com/jlnquere)\n\n### 3.2.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.2...3.2.3)\n- Correct previous release with patch that is fully merged\n\n### 3.2.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.1...3.2.2)\n- Security fix to properly process userSensitiveFields when parse-server is started with\n  ../lib/cli/parse-server [#5463](https://github.com/parse-community/parse-server/pull/5463\n  )\n\n### 3.2.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.0...3.2.1)\n- Increment package.json version to match the deployment tag\n\n### 3.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.3...3.2.0)\n- NEW: Support accessing sensitive fields with an explicit ACL.  Not documented yet, see [tests](https://github.com/parse-community/parse-server/blob/f2c332ea6a984808ad5b2e3ce34864a20724f72b/spec/UserPII.spec.js#L526) for examples\n- Upgrade Parse SDK JS to 2.3.1 [#5457](https://github.com/parse-community/parse-server/pull/5457)\n- Hides token contents in logStartupOptions if they arrive as a buffer [#6a9380](https://github.com/parse-community/parse-server/commit/6a93806c62205a56a8f4e3b8765848c552510337)\n- Support custom message for password requirements [#5399](https://github.com/parse-community/parse-server/pull/5399)\n- Support for Ajax password reset [#5332](https://github.com/parse-community/parse-server/pull/5332)\n- Postgres: Refuse to build unsafe JSON lists for contains [#5337](https://github.com/parse-community/parse-server/pull/5337)\n- Properly handle return values in beforeSave [#5228](https://github.com/parse-community/parse-server/pull/5228)\n- Fixes issue when querying user roles [#5276](https://github.com/parse-community/parse-server/pull/5276)\n- Fixes issue affecting update with CLP [#5269](https://github.com/parse-community/parse-server/pull/5269)\n\n### 3.1.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.2...3.1.3)\n\n- Postgres: Fixes support for global configuration\n- Postgres: Fixes support for numeric arrays\n- Postgres: Fixes issue affecting queries on empty arrays\n- LiveQuery: Adds support for transmitting the original object\n- Queries: Use estimated count if query is empty\n- Docker: Reduces the size of the docker image to 154Mb\n\n\n### 3.1.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.1...3.1.2)\n\n- Removes dev script, use TDD instead of server.\n- Removes nodemon and problematic dependencies.\n- Addressed event-stream security debacle.\n\n### 3.1.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.0...3.1.1)\n\n#### Improvements:\n* Fixes issue that would prevent users with large number of roles to resolve all of them [Antoine Cormouls](https://github.com/Moumouls) (#5131, #5132)\n* Fixes distinct query on special fields ([#5144](https://github.com/parse-community/parse-server/pull/5144))\n\n\n### 3.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.0.0...3.1.0)\n\n#### Breaking Changes:\n* Return success on sendPasswordResetEmail even if email not found. (#7fe4030)\n#### Security Fix:\n* Expire password reset tokens on email change (#5104)\n#### Improvements:\n* Live Query CLPs (#4387)\n* Reduces number of calls to injectDefaultSchema (#5107)\n* Remove runtime dependency on request (#5076)\n#### Bug fixes:\n* Fixes issue with vkontatke authentication (#4977)\n* Use the correct function when validating google auth tokens (#5018)\n* fix unexpected 'delete' trigger issue on LiveQuery (#5031)\n* Improves performance for roles and ACL's in live query server (#5126)\n\n\n### 3.0.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.4...3.0.0)\n\n`parse-server` 3.0.0 comes with brand new handlers for cloud code. It now fully supports promises and async / await.\nFor more informations, visit the v3.0.0 [migration guide](https://github.com/parse-community/parse-server/blob/master/3.0.0.md).\n\n#### Breaking changes:\n* Cloud Code handlers have a new interface based on promises.\n* response.success / response.error are removed in Cloud Code\n* Cloud Code runs with Parse-SDK 2.0\n* The aggregate now require aggregates to be passed in the form: `{\"pipeline\": [...]}` (REST Only)\n\n#### Improvements:\n* Adds Pipeline Operator to Aggregate Router.\n* Adds documentations for parse-server's adapters, constructors and more.\n* Adds ability to pass a context object between `beforeSave` and `afterSave` affecting the same object.\n\n#### Bug Fixes:\n* Fixes issue that would crash the server when mongo objects had undefined values [#4966](https://github.com/parse-community/parse-server/issues/4966)\n* Fixes issue that prevented ACL's from being used with `select` (see [#571](https://github.com/parse-community/Parse-SDK-JS/issues/571))\n\n#### Dependency updates:\n* [@parse/simple-mailgun-adapter@1.1.0](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [mongodb@3.1.3](https://www.npmjs.com/package/mongodb)\n* [request@2.88.0](https://www.npmjs.com/package/request)\n\n##### Devevelopment Dependencies Updates:\n* [@parse/minami@1.0.0](https://www.npmjs.com/package/@parse/minami)\n* [deep-diff@1.0.2](https://www.npmjs.com/package/deep-diff)\n* [flow-bin@0.79.0](https://www.npmjs.com/package/flow-bin)\n* [jsdoc@3.5.5](https://www.npmjs.com/package/jsdoc)\n* [jsdoc-babel@0.4.0](https://www.npmjs.com/package/jsdoc-babel)\n\n### 2.8.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.3...2.8.4)\n\n#### Improvements:\n* Adds ability to forward errors to express handler (#4697)\n* Adds ability to increment the push badge with an arbitrary value (#4889)\n* Adds ability to preserve the file names when uploading (#4915)\n* `_User` now follow regular ACL policy. Letting administrator lock user out. (#4860) and (#4898)\n* Ensure dates are properly handled in aggregates (#4743)\n* Aggregates: Improved support for stages sharing the same name\n* Add includeAll option\n* Added verify password to users router and tests. (#4747)\n* Ensure read preference is never overriden, so DB config prevails (#4833)\n* add support for geoWithin.centerSphere queries via withJSON (#4825)\n* Allow sorting an object field (#4806)\n* Postgres: Don't merge JSON fields after save() to keep same behaviour as MongoDB (#4808) (#4815)\n\n#### Dependency updates\n* [commander@2.16.0](https://www.npmjs.com/package/commander)\n* [mongodb@3.1.1](https://www.npmjs.com/package/mongodb)\n* [pg-promise@8.4.5](https://www.npmjs.com/package/pg-promise)\n* [ws@6.0.0](https://www.npmjs.com/package/ws)\n* [bcrypt@3.0.0](https://www.npmjs.com/package/bcrypt)\n* [uws@10.148.1](https://www.npmjs.com/package/uws)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.2.0](https://www.npmjs.com/package/cross-env)\n* [eslint@5.0.0](https://www.npmjs.com/package/eslint)\n* [flow-bin@0.76.0](https://www.npmjs.com/package/flow-bin)\n* [mongodb-runner@4.0.0](https://www.npmjs.com/package/mongodb-runner)\n* [nodemon@1.18.1](https://www.npmjs.com/package/nodemon)\n* [nyc@12.0.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [supports-color@5.4.0](https://www.npmjs.com/package/supports-color)\n\n### 2.8.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.2...2.8.3)\n\n#### Improvements:\n\n* Adds support for JS SDK 2.0 job status header\n* Removes npm-git scripts as npm supports using git repositories that build, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### 2.8.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.2)\n\n##### Bug Fixes:\n* Ensure legacy users without ACL's are not locked out, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Use common HTTP agent to increase webhooks performance, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds withinPolygon support for Polygon objects, thanks to [Mads Bjerre](https://github.com/madsb)\n\n#### Dependency Updates:\n* [ws@5.2.0](https://www.npmjs.com/package/ws)\n* [commander@2.15.1](https://www.npmjs.com/package/commander)\n* [nodemon@1.17.5](https://www.npmjs.com/package/nodemon)\n\n##### Devevelopment Dependencies Updates:\n* [flow-bin@0.73.0](https://www.npmjs.com/package/flow-bin)\n* [cross-env@5.1.6](https://www.npmjs.com/package/cross-env)\n* [gaze@1.1.3](https://www.npmjs.com/package/gaze)\n* [deepcopy@1.0.0](https://www.npmjs.com/package/deepcopy)\n* [deep-diff@1.0.1](https://www.npmjs.com/package/deep-diff)\n\n\n### 2.8.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.0)\n\nEnsure all the files are properly exported to the final package.\n\n### 2.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.0...2.7.4)\n\n#### New Features\n* Adding Mongodb element to add `arrayMatches` the #4762 (#4766), thanks to [J\u00e9r\u00e9my Piednoel](https://github.com/jeremypiednoel)\n* Adds ability to Lockout users (#4749), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Fixes issue when using afterFind with relations (#4752), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New query condition support to match all strings that starts with some other given strings (#3864), thanks to [Eduard Bosch Bertran](https://github.com/eduardbosch)\n* Allow creation of indices on default fields (#4738), thanks to [Claire Neveu](https://github.com/ClaireNeveu)\n* Purging empty class (#4676), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Fixes issues comparing to zero or false (#4667), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fix Aggregate Match Pointer (#4643), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Allow Parse.Error when returning from Cloud Code (#4695), thanks to [Saulo Tauil](https://github.com/saulogt)\n* Fix typo: \"requrest\" -> \"request\" (#4761), thanks to [Joseph Frazier](https://github.com/josephfrazier)\n* Send version for Vkontakte API (#4725), thanks to [oleg](https://github.com/alekoleg)\n* Ensure we respond with invalid password even if email is unverified (#4708), thanks to [dblythy](https://github.com/dblythy)\n* Add _password_history to default sensitive data (#4699), thanks to [Jong Eun Lee](https://github.com/yomybaby)\n* Check for node version in postinstall script (#4657), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Remove FB Graph API version from URL to use the oldest non deprecated version, thanks to [SebC](https://github.com/SebC99)\n\n#### Dependency Updates:\n* [@parse/push-adapter@2.0.3](https://www.npmjs.com/package/@parse/push-adapter)\n* [@parse/simple-mailgun-adapter@1.0.2](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [uws@10.148.0](https://www.npmjs.com/package/uws)\n* [body-parser@1.18.3](https://www.npmjs.com/package/body-parser)\n* [mime@2.3.1](https://www.npmjs.com/package/mime)\n* [request@2.85.0](https://www.npmjs.com/package/request)\n* [mongodb@3.0.7](https://www.npmjs.com/package/mongodb)\n* [bcrypt@2.0.1](https://www.npmjs.com/package/bcrypt)\n* [ws@5.1.1](https://www.npmjs.com/package/ws)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.1.5](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.71.0](https://www.npmjs.com/package/flow-bin)\n* [deep-diff@1.0.0](https://www.npmjs.com/package/deep-diff)\n* [nodemon@1.17.3](https://www.npmjs.com/package/nodemon)\n\n\n### 2.7.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.4...2.7.3)\n\n#### Bug Fixes:\n* Fixes an issue affecting polygon queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Dependency Updates:\n* [pg-promise@8.2.1](https://www.npmjs.com/package/pg-promise)\n\n##### Development Dependencies Updates:\n* [nodemon@1.17.1](https://www.npmjs.com/package/nodemon)\n\n### 2.7.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.3...2.7.2)\n\n#### Improvements:\n* Improve documentation for LiveQuery options, thanks to [Arthur Cinader](https://github.com/acinader)\n* Improve documentation for using cloud code with docker, thanks to [Stephen Tuso](https://github.com/stephentuso)\n* Adds support for Facebook's AccountKit, thanks to [6thfdwp](https://github.com/6thfdwp)\n* Disable afterFind routines when running aggregates, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Improve support for distinct aggregations of nulls, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Regenreate the email verification token when requesting a new email, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes:\n* Fix issue affecting readOnly masterKey and purge command, thanks to [AreyouHappy](https://github.com/AreyouHappy)\n* Fixes Issue unsetting in beforeSave doesn't allow object creation, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fixes issue crashing server on invalid live query payload, thanks to [fridays](https://github.com/fridays)\n* Fixes issue affecting postgres storage adapter \"undefined property '__op'\", thanks to [Tyson Andre](https://github,com/TysonAndre)\n\n#### Dependency Updates:\n* [winston@2.4.1](https://www.npmjs.com/package/winston)\n* [pg-promise@8.2.0](https://www.npmjs.com/package/pg-promise)\n* [commander@2.15.0](https://www.npmjs.com/package/commander)\n* [lru-cache@4.1.2](https://www.npmjs.com/package/lru-cache)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [ws@5.0.0](https://www.npmjs.com/package/ws)\n* [mongodb@3.0.4](https://www.npmjs.com/package/mongodb)\n* [lodash@4.17.5](https://www.npmjs.com/package/lodash)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.1.4](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.67.1](https://www.npmjs.com/package/flow-bin)\n* [jasmine@3.1.0](https://www.npmjs.com/package/jasmine)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [babel-eslint@8.2.2](https://www.npmjs.com/package/babel-eslint)\n* [nodemon@1.15.0](https://www.npmjs.com/package/nodemon)\n\n### 2.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.2...2.7.1)\n\n#### Improvements:\n* Improved match aggregate\n* Do not mark the empty push as failed\n* Support pointer in aggregate query\n* Introduces flow types for storage\n* Postgres: Refactoring of Postgres Storage Adapter\n* Postgres: Support for multiple projection in aggregate\n* Postgres: performance optimizations\n* Adds infos about vulnerability disclosures\n* Adds ability to login with email when provided as username\n\n#### Bug Fixes\n* Scrub Passwords with URL Encoded Characters\n* Fixes issue affecting using sorting in beforeFind\n\n#### Dependency Updates:\n* [commander@2.13.0](https://www.npmjs.com/package/commander)\n* [semver@5.5.0](https://www.npmjs.com/package/semver)\n* [pg-promise@7.4.0](https://www.npmjs.com/package/pg-promise)\n* [ws@4.0.0](https://www.npmjs.com/package/ws)\n* [mime@2.2.0](https://www.npmjs.com/package/mime)\n* [parse@1.11.0](https://www.npmjs.com/package/parse)\n\n##### Devevelopment Dependencies Updates:\n* [nodemon@1.14.11](https://www.npmjs.com/package/nodemon)\n* [flow-bin@0.64.0](https://www.npmjs.com/package/flow-bin)\n* [jasmine@2.9.0](https://www.npmjs.com/package/jasmine)\n* [cross-env@5.1.3](https://www.npmjs.com/package/cross-env)\n\n### 2.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.1...2.7.0)\n\n:warning: Fixes a security issue affecting Class Level Permissions\n\n* Adds support for dot notation when using matchesKeyInQuery, thanks to [Henrik](https://github.com/bohemima) and [Arthur Cinader](https://github.com/acinader)\n\n### 2.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.0...2.6.5)\n\n:warning: This version contains an issue affecting Class Level Permissions on mongoDB. Please upgrade to 2.7.1.\n\nStarting parse-server 2.7.0, the minimun nodejs version is 6.11.4, please update your engines before updating parse-server\n\n#### New Features:\n* Aggregation endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds indexation options onto Schema endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug fixes:\n* Fixes sessionTokens being overridden in 'find' (#4332), thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Proper `handleShutdown()` feature to close database connections (#4361), thanks to [CHANG, TZU-YEN](https://github.com/trylovetom)\n* Fixes issue affecting state of _PushStatus objects, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Fixes issue affecting calling password reset password pages with wrong appid, thanks to [Bryan de Leon](https://github.com/bryandel)\n* Fixes issue affecting duplicates _Sessions on successive logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Updates contributing guides, and improves windows support, thanks to [Addison Elliott](https://github.com/addisonelliott)\n* Uses new official scoped packaged, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves health checks responses, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add password confirmation to choose_password, thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Improve performance of relation queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [commander@2.12.1](https://www.npmjs.com/package/commander)\n* [ws@3.3.2](https://www.npmjs.com/package/ws)\n* [uws@9.14.0](https://www.npmjs.com/package/uws)\n* [pg-promise@7.3.2](https://www.npmjs.com/package/pg-promise)\n* [parse@1.10.2](https://www.npmjs.com/package/parse)\n* [pg-promise@7.3.1](https://www.npmjs.com/package/pg-promise)\n\n##### Devevelopment Dependencies Updates:\n* [cross-env@5.1.1](https://www.npmjs.com/package/cross-env)\n\n\n\n### 2.6.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.5...2.6.4)\n\n#### New Features:\n* Adds support for read-only masterKey, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds support for relative time queries (mongodb only), thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Improvements:\n* Handle possible afterSave exception, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add support for expiration interval in Push, thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Bug Fixes:\n* The REST API key was improperly inferred from environment when using the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.6.4\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.4...2.6.3)\n\n#### Improvements:\n* Improves management of configurations and default values, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds ability to start ParseServer with `ParseServer.start(options)`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds request original IP to cloud code hooks, thanks to [Gustav Ahlberg](https://github.com/Gyran)\n* Corrects some outdated links, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds serverURL validation on startup, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with POST requests alongside GET, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with email, instead of username, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes issue affecting beforeSaves and increments, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Dependency Updates:\n* [parse-server-push-adapter@2.0.2](https://www.npmjs.com/package/parse-server-push-adapter)\n* [semver@5.4.1](https://www.npmjs.com/package/semver)\n* [pg-promise@7.0.3](https://www.npmjs.com/package/pg-promise)\n* [mongodb@2.2.33](https://www.npmjs.com/package/mongodb)\n* [parse@1.10.1](https://www.npmjs.com/package/parse)\n* [express@4.16.0](https://www.npmjs.com/package/express)\n* [mime@1.4.1](https://www.npmjs.com/package/mime)\n* [parse-server-simple-mailgun-adapter@1.0.1](https://www.npmjs.com/package/parse-server-simple-mailgun-adapter)\n\n##### Devevelopment Dependencies Updates:\n* [babel-preset-env@1.6.1](https://www.npmjs.com/package/babel-preset-env)\n* [cross-env@5.1.0](https://www.npmjs.com/package/cross-env)\n* [mongodb-runner@3.6.1](https://www.npmjs.com/package/mongodb-runner)\n* [eslint-plugin-flowtype@2.39.1](https://www.npmjs.com/package/eslint-plugin-flowtype)\n* [eslint@4.9.0](https://www.npmjs.com/package/eslint)\n\n### 2.6.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.2...2.6.3)\n\n#### Improvements:\n* Queries on Pointer fields with `$in` and `$nin` now supports list of objectId's, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQueries on `$in` and `$nin` for pointer fields work as expected thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Also remove device token when APNS error is BadDeviceToken, thanks to [Mauricio Tollin](https://github.com/)\n* LRU cache is not available on the ParseServer object, thanks to [Tyler Brock](https://github.com/tbrock)\n* Error messages are more expressive, thanks to [Tyler Brock](https://github.com/tbrock)\n* Postgres: Properly handle undefined field values, thanks to [Diamond Lewis](https://github.com/dlewis)\n* Updating with two GeoPoints fails correctly, thanks to [Anthony Mosca](https://github.com/aontas)\n\n#### New Features:\n* Adds ability to set a maxLimit on server configuration for queries, thanks to [Chris Norris](https://github.com/)\n\n#### Bug fixes:\n* Fixes issue affecting reporting `_PushStatus` with misconfigured serverURL, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting deletion of class that doesn't exist, thanks to [Diamond Lewis](https://github.com/dlewis)\n\n#### Dependency Updates:\n* [winston@2.4.0](https://www.npmjs.com/package/winston)\n* [pg-promise@6.10.2](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.6.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [request@2.83.0](https://www.npmjs.com/package/request)\n* [body-parser@1.18.2](https://www.npmjs.com/package/body-parser)\n\n##### Devevelopment Dependencies Updates:\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [eslint@4.7.1](https://www.npmjs.com/package/eslint)\n\n### 2.6.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.1...2.6.2)\n\n#### Improvements:\n* PushWorker/PushQueue channels are properly prefixed with the Parse applicationId, thanks to [Marvel Mathew](https://github.com/marvelm)\n* You can use Parse.Cloud.afterSave hooks on _PushStatus\n* You can use Parse.Cloud.onLiveQueryEvent to track the number of clients and subscriptions\n* Adds support for more fields from the Audience class.\n\n#### New Features:\n* Push: Adds ability to track sentPerUTC offset if your push scheduler supports it.\n* Push: Adds support for cleaning up invalid deviceTokens from _Installation (PARSE_SERVER_CLEANUP_INVALID_INSTALLATIONS=1).\n\n#### Dependency Updates:\n* [ws@3.2.0](https://www.npmjs.com/package/ws)\n* [pg-promise@6.5.3](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.5.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [body-parser@1.18.1](https://www.npmjs.com/package/body-parser)\n\n##### Devevelopment Dependencies Updates:\n* [nodemon@1.12.1](https://www.npmjs.com/package/nodemon)\n* [mongodb-runner@3.6.0](https://www.npmjs.com/package/mongodb-runner)\n* [babel-eslint@8.0.0](https://www.npmjs.com/package/babel-eslint)\n\n### 2.6.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.0...2.6.1)\n\n#### Improvements:\n* Improves overall performance of the server, more particularly with large query results.\n* Improves performance of InMemoryCacheAdapter by removing serialization.\n* Improves logging performance by skipping necessary log calls.\n* Refactors object routers to simplify logic.\n* Adds automatic indexing on $text indexes, thanks to [Diamon Lewis](https://github.com/dplewis)\n\n#### New Features:\n* Push: Adds ability to send localized pushes according to the _Installation localeIdentifier\n* Push: proper support for scheduling push in user's locale time, thanks to [Marvel Mathew](https://github.com/marvelm)\n* LiveQuery: Adds ability to use LiveQuery with a masterKey, thanks to [Jeremy May](https://github.com/kenishi)\n\n#### Bug Fixes:\n* Fixes an issue that would duplicate Session objects per userId-installationId pair.\n* Fixes an issue affecting pointer permissions introduced in this release.\n* Fixes an issue that would prevent displaying audiences correctly in dashboard.\n* Fixes an issue affecting preventLoginWithUnverifiedEmail upon signups.\n\n#### Dependency Updates:\n* [pg-promise@6.3.2](https://www.npmjs.com/package/pg-promise)\n* [body-parser@1.18.0](https://www.npmjs.com/package/body-parser)\n* [nodemon@1.11.1](https://www.npmjs.com/package/nodemon)\n\n##### Devevelopment Dependencies Updates:\n* [babel-cli@6.26.0](https://www.npmjs.com/package/babel-cli)\n\n### 2.6.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.3...2.6.0)\n\n#### Breaking Changes:\n* [parse-server-s3-adapter@1.2.0](https://www.npmjs.com/package/parse-server-s3-adapter): A new deprecation notice is introduced with parse-server-s3-adapter's version 1.2.0.  An upcoming release will remove passing key and password arguments.  AWS credentials should be set using AWS best practices.  See the [Deprecation Notice for AWS credentials]( https://github.com/parse-server-modules/parse-server-s3-adapter/blob/master/README.md#deprecation-notice----aws-credentials) section of the adapter's README.\n\n#### New Features\n* Polygon is fully supported as a type, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Query supports PolygonContains, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements\n* Postgres: Adds support nested contains and containedIn, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Adds support for `null` in containsAll queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Cloud Code: Request headers are passed to the cloud functions, thanks to [miguel-s](https://github.com/miguel-s)\n* Push: All push queries now filter only where deviceToken exists\n\n#### Bug Fixes:\n* Fixes issue affecting updates of _User objects when authData was passed.\n* Push: Pushing to an empty audience should now properly report a failed _PushStatus\n* Linking Users: Fixes issue affecting linking users with sessionToken only\n\n#### Dependency Updates:\n* [ws@3.1.0](https://www.npmjs.com/package/ws)\n* [mime@1.4.0](https://www.npmjs.com/package/mime)\n* [semver@5.4.0](https://www.npmjs.com/package/semver)\n* [uws@8.14.1](https://www.npmjs.com/package/uws)\n* [bcrypt@1.0.3](https://www.npmjs.com/package/bcrypt)\n* [mongodb@2.2.31](https://www.npmjs.com/package/mongodb)\n* [redis@2.8.0](https://www.npmjs.com/package/redis)\n* [pg-promise@6.3.1](https://www.npmjs.com/package/pg-promise)\n* [commander@2.11.0](https://www.npmjs.com/package/commander)\n\n##### Devevelopment Dependencies Updates:\n* [jasmine@2.8.0](https://www.npmjs.com/package/jasmine)\n* [babel-register@6.26.0](https://www.npmjs.com/package/babel-register)\n* [babel-core@6.26.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.2](https://www.npmjs.com/package/cross-env)\n\n### 2.5.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.2...2.5.3)\n\n#### New Features:\n* badge property on android installations will now be set as on iOS (#3970), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes incorrect number parser for cache options\n\n### 2.5.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.1...2.5.2)\n\n#### Improvements:\n* Restores ability to run on node >= 4.6\n* Adds ability to configure cache from CLI\n* Removes runtime check for node >= 4.6\n\n### 2.5.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.0...2.5.1)\n\n#### New Features:\n* Adds ability to set default objectId size (#3950), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements:\n* Uses LRU cache instead of InMemoryCache by default (#3979), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* iOS pushes are now using HTTP/2.0 instead of binary API  (#3983), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [parse@1.10.0](https://www.npmjs.com/package/parse)\n* [pg-promise@6.3.0](https://www.npmjs.com/package/pg-promise)\n* [parse-server-s3-adapter@1.1.0](https://www.npmjs.com/package/parse-server-s3-adapter)\n* [parse-server-push-adapter@2.0.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.5.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.2...2.5.0)\n\n#### New Features:\n* Adds ability to run full text search (#3904), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to run `$withinPolygon` queries (#3889), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to pass read preference per query with mongodb (#3865), thanks to [davimacedo](https://github.com/davimacedo)\n* beforeFind trigger now includes `isGet` for get queries (#3862), thanks to [davimacedo](https://github.com/davimacedo)\n* Adds endpoints for dashboard's audience API (#3861), thanks to [davimacedo](https://github.com/davimacedo)\n* Restores the job scheduling endpoints (#3927), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Removes unnecessary warning when using maxTimeMs with mongodb, thanks to [Tyler Brock](https://github.com/tbrock)\n* Improves access control on system classes (#3916), thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Adds bytes support in postgres (#3894), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug Fixes:\n* Fixes issue with vkontakte adapter that would hang the request, thanks to [Denis Trofimov](https://github.com/denistrofimov)\n* Fixes issue affecting null relational data (#3924), thanks to [davimacedo](https://github.com/davimacedo)\n* Fixes issue affecting session token deletion (#3937), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting the serverInfo endpoint (#3933), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting beforeSave with dot-noted sub-documents (#3912), thanks to [IlyaDiallo](https://github.com/IlyaDiallo)\n* Fixes issue affecting emails being sent when using a 3rd party auth (#3882), thanks to [davimacedo](https://github.com/davimacedo)\n\n#### Dependency Updates:\n* [commander@2.10.0](https://www.npmjs.com/package/commander)\n* [pg-promise@5.9.7](https://www.npmjs.com/package/pg-promise)\n* [lru-cache@4.1.0](https://www.npmjs.com/package/lru-cache)\n* [mongodb@2.2.28](https://www.npmjs.com/package/mongodb)\n\n##### Devevelopment dependencies\n* [babel-core@6.25.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.1](https://www.npmjs.com/package/cross-env)\n* [nyc@11.0.2](https://www.npmjs.com/package/nyc)\n\n### 2.4.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.1...2.4.2)\n\n#### New Features:\n* ParseQuery: Support for withinPolygon [#3866](https://github.com/parse-community/parse-server/pull/3866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Postgres: Use transactions when deleting a class, [#3869](https://github.com/parse-community/parse-server/pull/3836), thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Postgres: Proper support for GeoPoint equality query, [#3874](https://github.com/parse-community/parse-server/pull/3836), thanks to [Diamond Lewis](https://github.com/dplewis)\n* beforeSave and liveQuery will be correctly triggered on email verification [#3851](https://github.com/parse-community/parse-server/pull/3851), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Skip authData validation if it hasn't changed, on PUT requests [#3872](https://github.com/parse-community/parse-server/pull/3872), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [mongodb@2.2.27](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.2](https://www.npmjs.com/package/pg-promise)\n\n\n### 2.4.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.0...2.4.1)\n\n#### Bug fixes:\n* Fixes issue affecting relation updates ([#3835](https://github.com/parse-community/parse-server/pull/3835), [#3836](https://github.com/parse-community/parse-server/pull/3836)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting sending push notifications, thanks to [Felipe Andrade](https://github.com/felipemobile)\n* Session are always cleared when updating the passwords ([#3289](https://github.com/parse-community/parse-server/pull/3289), [#3821](https://github.com/parse-community/parse-server/pull/3821), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [body-parser@1.17.2](https://www.npmjs.com/package/body-parser)\n* [pg-promise@5.7.1](https://www.npmjs.com/package/pg-promise)\n* [ws@3.0.0](https://www.npmjs.com/package/ws)\n\n\n### 2.4.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.8...2.4.0)\n\nStarting 2.4.0, parse-server is tested against node 6.10 and 7.10, mongodb 3.2 and 3.4.\nIf you experience issues with older versions, please [open a issue](https://github.com/parse-community/parse-server/issues).\n\n#### New Features:\n* Adds `count` Class Level Permission ([#3814](https://github.com/parse-community/parse-server/pull/3814)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Proper graceful shutdown support ([#3786](https://github.com/parse-community/parse-server/pull/3786)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Let parse-server store as `scheduled` Push Notifications with push_time (#3717, #3722), thanks to [Felipe Andrade](https://github.com/felipemobile)\n\n#### Improvements\n* Parse-Server images are built through docker hub, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Skip authData validation if it hasn't changed, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* [postgres] Improve performance when adding many new fields to the Schema ([#3740](https://github.com/parse-community/parse-server/pull/3740)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Test maintenance, wordsmithing and nits ([#3744](https://github.com/parse-community/parse-server/pull/3744)), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Bug Fixes:\n* [postgres] Fixes issue affecting deleting multiple fields of a Schema ([#3734](https://github.com/parse-community/parse-server/pull/3734), [#3735](https://github.com/parse-community/parse-server/pull/3735)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Fix issue affecting _PushStatus state ([#3808](https://github.com/parse-community/parse-server/pull/3808)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* requiresAuthentication Class Level Permission behaves correctly, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Email Verification related fields are not exposed ([#3681](https://github.com/parse-community/parse-server/pull/3681), [#3393](https://github.com/parse-community/parse-server/pull/3393), [#3432](https://github.com/parse-community/parse-server/pull/3432)), thanks to [Anthony Mosca](https://github.com/aontas)\n* HTTP query parameters are properly obfuscated in logs ([#3793](https://github.com/parse-community/parse-server/pull/3793), [#3789](https://github.com/parse-community/parse-server/pull/3789)), thanks to [@youngerong](https://github.com/youngerong)\n* Improve handling of `$near` operators in `$or` queries ([#3767](https://github.com/parse-community/parse-server/pull/3767), [#3798](https://github.com/parse-community/parse-server/pull/3798)), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Fix issue affecting arrays of pointers ([#3169](https://github.com/parse-community/parse-server/pull/3169)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix issue affecting overloaded query constraints ([#3723](https://github.com/parse-community/parse-server/pull/3723), [#3678](https://github.com/parse-community/parse-server/pull/3678)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Properly catch unhandled rejections in _Installation updates ([#3795](https://github.com/parse-community/parse-server/pull/3795)), thanks to [kahoona77](https://github.com/kahoona77)\n\n#### Dependency Updates:\n\n* [uws@0.14.5](https://www.npmjs.com/package/uws)\n* [mime@1.3.6](https://www.npmjs.com/package/mime)\n* [mongodb@2.2.26](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.0](https://www.npmjs.com/package/pg-promise)\n* [semver@5.3.0](https://www.npmjs.com/package/semver)\n\n##### Devevelopment dependencies\n* [babel-cli@6.24.1](https://www.npmjs.com/package/babel-cli)\n* [babel-core@6.24.1](https://www.npmjs.com/package/babel-core)\n* [babel-preset-es2015@6.24.1](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-preset-stage-0@6.24.1](https://www.npmjs.com/package/babel-preset-stage-0)\n* [babel-register@6.24.1](https://www.npmjs.com/package/babel-register)\n* [cross-env@5.0.0](https://www.npmjs.com/package/cross-env)\n* [deep-diff@0.3.8](https://www.npmjs.com/package/deep-diff)\n* [gaze@1.1.2](https://www.npmjs.com/package/gaze)\n* [jasmine@2.6.0](https://www.npmjs.com/package/jasmine)\n* [jasmine-spec-reporter@4.1.0](https://www.npmjs.com/package/jasmine-spec-reporter)\n* [mongodb-runner@3.5.0](https://www.npmjs.com/package/mongodb-runner)\n* [nyc@10.3.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.1](https://www.npmjs.com/package/request-promise)\n\n\n### 2.3.8\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.7...2.3.8)\n\n#### New Features\n* Support for PG-Promise options, thanks to [ren dong](https://github.com/rendongsc)\n\n#### Improvements\n* Improves support for graceful shutdown, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves configuration validation for Twitter Authentication, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes\n* Fixes issue affecting GeoPoint __type with Postgres, thanks to [zhoul-HS](https://github.com/zhoul-HS)\n* Prevent user creation if username or password is empty, thanks to [Wissam Abirached](https://github.com/wabirached)\n\n#### Dependency Updates:\n* [cross-env@4.0.0 ](https://www.npmjs.com/package/cross-env)\n* [ws@2.2.3](https://www.npmjs.com/package/ws)\n* [babel-core@6.24.0](https://www.npmjs.com/package/babel-core)\n* [uws@0.14.0](https://www.npmjs.com/package/uws)\n* [babel-preset-es2015@6.24.0](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-plugin-syntax-flow@6.18.0](https://www.npmjs.com/package/babel-plugin-syntax-flow)\n* [babel-cli@6.24.0](https://www.npmjs.com/package/babel-cli)\n* [babel-register@6.24.0](https://www.npmjs.com/package/babel-register)\n* [winston-daily-rotate-file@1.4.6](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [mongodb@2.2.25](https://www.npmjs.com/package/mongodb)\n* [redis@2.7.0](https://www.npmjs.com/package/redis)\n* [pg-promise@5.6.4](https://www.npmjs.com/package/pg-promise)\n* [parse-server-push-adapter@1.3.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.3.7\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.6...2.3.7)\n\n#### New Features\n* New endpoint to resend verification email, thanks to [Xy Ziemba](https://github.com/xyziemba)\n\n#### Improvements\n* Add TTL option for Redis Cache Adapter, thanks to [Ryan Foster](https://github.com/f0ster)\n* Update Postgres Storage Adapter, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n\n#### Bug Fixes\n* Add index on Role.name, fixes (#3579), thanks to [Natan Rolnik](https://github.com/natanrolnik)\n* Fix default value of userSensitiveFields, fixes (#3593), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Dependency Updates:\n* [body-parser@1.17.1](https://www.npmjs.com/package/body-parser)\n* [express@4.15.2](https://www.npmjs.com/package/express)\n* [request@2.81.0](https://www.npmjs.com/package/request)\n* [winston-daily-rotate-file@1.4.5](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [ws@2.2.0](https://www.npmjs.com/package/ws)\n\n\n### 2.3.6\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.5...2.3.6)\n\n#### Improvements\n* Adds support for injecting a middleware for instumentation in the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Alleviate mongodb bug with $or queries [SERVER-13732](https://jira.mongodb.org/browse/SERVER-13732), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n\n#### Bug Fixes\n* Fix issue affecting password policy and empty passwords, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Fix issue when logging url in non string objects, thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n\n#### Dependencies updates:\n* [ws@2.1.0](https://npmjs.com/package/ws)\n* [uws@0.13.0](https://npmjs.com/package/uws)\n* [pg-promise@5.6.2](https://npmjs.com/package/pg-promise)\n\n\n### 2.3.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.3...2.3.5)\n\n#### Bug Fixes\n* Allow empty client key\n(#3497), thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix LiveQuery unsafe user\n(#3525), thanks to [David Starke](https://github.com/dstarke)\n* Use `flushdb` instead of `flushall` in RedisCacheAdapter\n(#3523), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix saving GeoPoints and Files in `_GlobalConfig` (Make sure we don't treat\ndot notation keys as topLevel atoms)\n(#3531), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.2...2.3.3)\n\n#### Breaking Changes\n* **Minimum Node engine bumped to 4.6** (#3480), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes\n* Add logging on failure to create file (#3424), thanks to [Arthur Cinader](https://github.com/acinader)\n* Log Parse Errors so they are intelligible (#3431), thanks to [Arthur Cinader](https://github.com/acinader)\n* MongoDB $or Queries avoid SERVER-13732 bug (#3476), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Mongo object to Parse object date serialization - avoid re-serialization of iso of type Date (#3389), thanks to [nodechefMatt](https://github.com/nodechefMatt)\n\n#### Improvements\n* Ground preparations for push scalability (#3080), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Use uWS as optional dependency for ws server (#3231), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.1...2.3.2)\n\n#### New features\n* Add parseFrameURL for masking user-facing pages (#3267), thanks to  [Lenart Rudel](https://github.com/lenart)\n\n#### Bug fixes\n* Fix Parse-Server to work with winston-daily-rotate-1.4.2 (#3335), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Improvements\n* Add support for regex string for password policy validatorPattern setting (#3331), thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* LiveQuery should match subobjects with dot notation (#3322), thanks to [David Starke](https://github.com/dstarke)\n* Reduce time to process high number of installations for push (#3264), thanks to [jeacott1](https://github.com/jeacott1)\n* Fix trivial typo in error message (#3238), thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.3.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.0...2.3.1)\n\nA major issue was introduced when refactoring the authentication modules.\nThis release addresses only that issue.\n\n### 2.3.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.25...2.3.0)\n\n#### Breaking changes\n* Parse.Cloud.useMasterKey() is a no-op, please refer to (Cloud Code migration guide)[https://github.com/ParsePlatform/parse-server/wiki/Compatibility-with-Hosted-Parse#cloud-code]\n* Authentication helpers are now proper adapters, deprecates oauth option in favor of auth.\n* DEPRECATES: facebookAppIds, use `auth: { facebook: { appIds: [\"AAAAAAAAA\" ] } }`\n* `email` field is not returned anymore for `Parse.User` queries. (Provided only on the user itself if provided).\n\n#### New Features\n* Adds ability to restrict access through Class Level Permissions to only authenticated users [see docs](http://parseplatform.github.io/docs/ios/guide/#requires-authentication-permission-requires-parse-server---230)\n* Adds ability to strip sensitive data from `_User` responses, strips emails by default, thanks to [Arthur Cinader](https://github.com/acinader)\n* Adds password history support for password policies, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n\n#### Improvements\n* Bump parse-server-s3-adapter to 1.0.6, thanks to [Arthur Cinader](https://github.com/acinader)\n* Using PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS let you create user sessions when passing {installationId: \"xxx-xxx\"} on signup in cloud code, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Add CLI option to pass `host` parameter when creating parse-server from CLI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug fixes\n* Ensure batch routes are only using posix paths, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Ensure falsy options from CLI are properly taken into account, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fixes issues affecting calls to `matchesKeyInQuery` with pointers.\n* Ensure that `select` keys can be changed in triggers (beforeFind...), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Housekeeping\n* Enables and enforces linting with eslint, thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.2.25\n\nPostgres support requires v9.5\n\n#### New Features\n* Dockerizing Parse Server, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Login with qq, wechat, weibo, thanks to [haifeizhang]()\n* Password policy, validation and expiration, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Health check on /health, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Reuse SchemaCache across requests option, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements\n* Better support for CLI options, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Specity a database timeout with maxTimeMS, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds the username to reset password success pages, thanks to [Halim Qarroum](https://github.com/HQarroum)\n* Better support for Redis cache adapter, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Better coverage of Postgres, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug Fixes\n* Fixes issue when sending push to multiple installations, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issues with twitter authentication, thanks to [jonas-db](https://github.com/jonas-db)\n* Ignore createdAt fields update, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* Improve support for array equality with LiveQuery, thanks to [David Poetzsch-Heffter](https://github.com/dpoetzsch)\n* Improve support for batch endpoint when serverURL and publicServerURL have different paths, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support saving relation objects, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n\n### 2.2.24\n\n#### New Features\n* LiveQuery: Bring your own adapter (#2902), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQuery: Adds \"update\" operator to update a query subscription (#2935), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements\n* Better Postgres support, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Logs the function name when failing (#2963), thanks to [Michael Helvey](https://github.com/michaelhelvey)\n* CLI: forces closing the connections with SIGINT/SIGTERM (#2964), thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Reduce the number of calls to the `_SCHEMA` table (#2912), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* LiveQuery: Support for Role ACL's, thanks to [Aaron Blondeau](https://github.com/aaron-blondeau-dose)\n\n#### Bug Fixes\n* Better support for checking application and client keys, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Google OAuth, better support for android and web logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.23\n\n* Run liveQuery server from CLI with a different port, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support for Postgres databaseURI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Support for Postgres options, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Improved support for google login (id_token and access_token), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improvements with VKontakte login, thanks to [Eugene Antropov](https://github.com/antigp)\n* Improved support for `select` and `include`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n\n* Fix error when updating installation with useMasterKey (#2888), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix bug affecting usage of multiple `notEqualTo`, thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Improved support for null values in arrays, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.22\n\n* Minimum nodejs engine is now 4.5\n\n#### New Features\n* New: CLI for parse-live-query-server, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Start parse-live-query-server for parse-server CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n* Fix: Include with pointers are not conflicting with get CLP anymore, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes dependency on babel-polyfill, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Support nested select calls, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Use native column selection instead of runtime, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: installationId header is properly used when updating `_Installation` objects, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: don't crash parse-server on improperly formatted live-query messages, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Passwords are properly stripped out of logs, thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix: Lookup for email in username if email is not set, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.21\n\n* Fix: Reverts removal of babel-polyfill\n\n### 2.2.20\n\n* New: Adds CloudCode handler for `beforeFind`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: RedisCacheAdapter for syncing schema, role and user caches across servers, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Latest master build available at `ParsePlatform/parse-server#latest`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Better support for upgradeToRevocableSession with missing session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes babel-polyfill runtime dependency, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Cluster option now support a boolean value for automatically choosing the right number of processes, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Filenames now appear correctly, thanks to [Lama Chandrasena](https://github.com/lama-buddy)\n* Fix: `_acl` is properly updated, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\nOther fixes by [Mathias Rangel Wulff](https://github.com/mathiasrw)\n\n### 2.2.19\n\n* New: support for upgrading to revocable sessions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: NullCacheAdapter for disabling caching, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* New: Account lockout policy [#2601](https://github.com/ParsePlatform/parse-server/pull/2601), thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* New: Jobs endpoint for defining and run jobs (no scheduling), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add --cluster option to the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Support for login with vk.com, thanks to [Nurdaulet Bolatov](https://github.com/nbolatov)\n* New: experimental support for postgres databases, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: parse-server doesn't call next() after successful responses, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Nested objects are properly includeed with Pointer Permissions on, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: null values in include calls are properly handled, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Schema validations now runs after beforeSave hooks, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: usersname and passwords are properly type checked, thanks to [Bam Wang](https://github.com/bamwang)\n* Fix: logging in info log would log also in error log, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: removes extaneous logging from ParseLiveQueryServer, thanks to [Flavio Torres](https://github.com/flavionegrao)\n* Fix: support for Range requests for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n\n### 2.2.18\n\n* Fix: Improve support for objects in push alert, thanks to [Antoine Lenoir](https://github.com/alenoir)\n* Fix; Prevent pointed from getting clobbered when they are changed in a beforeSave, thanks to [sud](https://github.com/sud80)\n* Fix: Improve support for \"Bytes\" type, thanks to [CongHoang](https://github.com/conghoang)\n* Fix: Better logging compatability with Parse.com, thanks to [Arthur Cinader](https://github.com/acinader)\n* New: Add Janrain Capture and Janrain Engage auth provider, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Include content length header in files response, thanks to [Steven Van Bael](https://github.com/vbsteven)\n* Improved: Support byte range header for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n* Improved: Validations for LinkedIn access_tokens, thanks to [Felix Dumit](https://github.com/felix-dumit)\n* Improved: Experimental postgres support, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Perf: Use native bcrypt implementation if available, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### [2.2.17](https://github.com/ParsePlatform/parse-server/tree/2.2.17) (07/23/2016)\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.16...2.2.17)\n\n* Cloud code logs [\\#2370](https://github.com/ParsePlatform/parse-server/pull/2370) ([flovilmart](https://github.com/flovilmart))\n* Make sure \\_PushStatus operations are run in order [\\#2367](https://github.com/ParsePlatform/parse-server/pull/2367) ([flovilmart](https://github.com/flovilmart))\n* Typo fix for error message when can't ensure uniqueness of user email addresses [\\#2360](https://github.com/ParsePlatform/parse-server/pull/2360) ([AndrewLane](https://github.com/AndrewLane))\n* LiveQuery constrains matching fix [\\#2357](https://github.com/ParsePlatform/parse-server/pull/2357) ([simonas-notcat](https://github.com/simonas-notcat))\n* Fix typo in logging for commander parseConfigFile [\\#2352](https://github.com/ParsePlatform/parse-server/pull/2352) ([AndrewLane](https://github.com/AndrewLane))\n* Fix minor typos in test names [\\#2351](https://github.com/ParsePlatform/parse-server/pull/2351) ([acinader](https://github.com/acinader))\n* Makes sure we don't strip authData or session token from users using masterKey [\\#2348](https://github.com/ParsePlatform/parse-server/pull/2348) ([flovilmart](https://github.com/flovilmart))\n* Run coverage with istanbul [\\#2340](https://github.com/ParsePlatform/parse-server/pull/2340) ([flovilmart](https://github.com/flovilmart))\n* Run next\\(\\) after successfully sending data to the client [\\#2338](https://github.com/ParsePlatform/parse-server/pull/2338) ([blacha](https://github.com/blacha))\n* Cache all the mongodb/version folder [\\#2336](https://github.com/ParsePlatform/parse-server/pull/2336) ([flovilmart](https://github.com/flovilmart))\n* updates usage of setting: emailVerifyTokenValidityDuration [\\#2331](https://github.com/ParsePlatform/parse-server/pull/2331) ([cherukumilli](https://github.com/cherukumilli))\n* Update Mongodb client to 2.2.4 [\\#2329](https://github.com/ParsePlatform/parse-server/pull/2329) ([flovilmart](https://github.com/flovilmart))\n* Allow usage of analytics adapter [\\#2327](https://github.com/ParsePlatform/parse-server/pull/2327) ([deashay](https://github.com/deashay))\n* Fix flaky tests [\\#2324](https://github.com/ParsePlatform/parse-server/pull/2324) ([flovilmart](https://github.com/flovilmart))\n* don't serve null authData values [\\#2320](https://github.com/ParsePlatform/parse-server/pull/2320) ([yuzeh](https://github.com/yuzeh))\n* Fix null relation problem [\\#2319](https://github.com/ParsePlatform/parse-server/pull/2319) ([flovilmart](https://github.com/flovilmart))\n* Clear the connectionPromise upon close or error [\\#2314](https://github.com/ParsePlatform/parse-server/pull/2314) ([flovilmart](https://github.com/flovilmart))\n* Report validation errors with correct error code [\\#2299](https://github.com/ParsePlatform/parse-server/pull/2299) ([flovilmart](https://github.com/flovilmart))\n* Parses correctly Parse.Files and Dates when sent to Cloud Code Functions [\\#2297](https://github.com/ParsePlatform/parse-server/pull/2297) ([flovilmart](https://github.com/flovilmart))\n* Adding proper generic Not Implemented. [\\#2292](https://github.com/ParsePlatform/parse-server/pull/2292) ([vitaly-t](https://github.com/vitaly-t))\n* Adds schema caching capabilities \\(5s by default\\) [\\#2286](https://github.com/ParsePlatform/parse-server/pull/2286) ([flovilmart](https://github.com/flovilmart))\n* add digits oauth provider [\\#2284](https://github.com/ParsePlatform/parse-server/pull/2284) ([ranhsd](https://github.com/ranhsd))\n* Improve installations query [\\#2281](https://github.com/ParsePlatform/parse-server/pull/2281) ([flovilmart](https://github.com/flovilmart))\n* Adding request headers to cloud functions fixes \\#1461 [\\#2274](https://github.com/ParsePlatform/parse-server/pull/2274) ([blacha](https://github.com/blacha))\n* Creates a new sessionToken when updating password [\\#2266](https://github.com/ParsePlatform/parse-server/pull/2266) ([flovilmart](https://github.com/flovilmart))\n* Add Gitter chat link to the README. [\\#2264](https://github.com/ParsePlatform/parse-server/pull/2264) ([nlutsenko](https://github.com/nlutsenko))\n* Restores ability to include non pointer keys [\\#2263](https://github.com/ParsePlatform/parse-server/pull/2263) ([flovilmart](https://github.com/flovilmart))\n* Allow next middleware handle error in handleParseErrors [\\#2260](https://github.com/ParsePlatform/parse-server/pull/2260) ([mejcz](https://github.com/mejcz))\n* Exposes the ClientSDK infos if available [\\#2259](https://github.com/ParsePlatform/parse-server/pull/2259) ([flovilmart](https://github.com/flovilmart))\n* Adds support for multiple twitter auths options [\\#2256](https://github.com/ParsePlatform/parse-server/pull/2256) ([flovilmart](https://github.com/flovilmart))\n* validate\\_purchase fix for SANDBOX requests [\\#2253](https://github.com/ParsePlatform/parse-server/pull/2253) ([valeryvaskabovich](https://github.com/valeryvaskabovich))\n\n### 2.2.16 (7/10/2016)\n\n* New: Expose InMemoryCacheAdapter publicly, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* New: Add ability to prevent login with unverified email, thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* Improved: Better error message for incorrect type, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Better error message for permission denied, thanks to [Blayne Chard](https://github.com/blacha)\n* Improved: Update authData on login, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improved: Ability to not check for old files on Parse.com, thanks to [OzgeAkin](https://github.com/OzgeAkin)\n* Fix: Issues with email adapter validation, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Issues with nested $or queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.15 (6/30/2016)\n\n* Fix: Type in description for Parse.Error.INVALID_QUERY, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improvement: Stop requiring verifyUserEmails for password reset functionality, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Improvement: Kill without validation, thanks to [Drew Gross](https://github.com/drew-gross)\n* Fix: Deleting a file does not delete from fs.files, thanks to [David Keita](https://github.com/maninga)\n* Fix: Postgres stoage adapter fix, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Fix: Results invalid session when providing an invalid session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: issue creating an anonymous user, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: make http response serializable, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add postmark email adapter alternative [Glenn Reyes](https://github.com/glennreyes)\n\n### 2.2.14 (6/25/2016)\n\n* Hotfix: Fix Parse.Cloud.HTTPResponse serialization\n\n### 2.2.13 (6/12/2016)\n\n* Hotfix: Pin version of deepcopy\n\n### 2.2.12 (6/9/2016)\n\n* New: Custom error codes in cloud code response.error, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Crash in beforeSave when response is not an object, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Allow \"get\" on installations\n* Fix: Fix overly restrictive Class Level Permissions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Fix nested date parsing in Cloud Code, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Support very old file formats from Parse.com\n\n### 2.2.11 (5/31/2016)\n\n* Security: Censor user password in logs, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Add PARSE_SERVER_LOGS_FOLDER env var for setting log folder, thanks to [KartikeyaRokde](https://github.com/KartikeyaRokde)\n* New: Webhook key support, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Perf: Add cache adapter and default caching of certain objects, thanks to [Blayne Chard](https://github.com/blacha)\n* Improvement: Better error messages for schema type mismatches, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Improvement: Better error messages for reset password emails\n* Improvement: Webhook key support in CLI, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Remove read only fields when using beforeSave, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Use content type provided by JS SDK, thanks to [Blayne Chard](https://github.com/blacha) and [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Tell the dashboard the stored push data is available, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Add support for HTTP Basic Auth, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: Support for MongoDB version 3.2.6, (note: do not use MongoDB 3.2 with migrated apps that still have traffic on Parse.com), thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Prevent `pm2` from crashing when push notifications fail, thanks to [benishak](https://github.com/benishak)\n* Fix: Add full list of default _Installation fields, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Strip objectId out of hooks responses, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix external webhook response format, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix beforeSave when object is passed to `success`, thanks to [Madhav Bhagat](https://github.com/codebreach)\n* Fix: Remove use of deprecated APIs, thanks to [Emad Ehsan](https://github.com/emadehsan)\n* Fix: Crash when multiple Parse Servers on the same machine try to write to the same logs folder, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fix: Various issues with key names in `Parse.Object`s\n* Fix: Treat Bytes type properly\n* Fix: Caching bugs that caused writes by masterKey or other session token to not show up to users reading with a different session token\n* Fix: Pin mongo driver version, preventing a regression in version 2.1.19\n* Fix: Various issues with pointer fields not being treated properly\n* Fix: Issues with pointed getting un-fetched due to changes in beforeSave\n* Fix: Fixed crash when deleting classes that have CLPs\n\n### 2.2.10 (5/15/2016)\n\n* Fix: Write legacy ACLs to Mongo so that clients that still go through Parse.com can read them, thanks to [Tyler Brock](https://github.com/TylerBrock) and [carmenlau](https://github.com/carmenlau)\n* Fix: Querying installations with limit = 0 and count = 1 now works, thanks to [ssk7833](https://github.com/ssk7833)\n* Fix: Return correct error when violating unique index, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Allow unsetting user's email, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Support for Node 6.1\n\n### 2.2.9 (5/9/2016)\n\n* Fix: Fix a regression that caused Parse Server to crash when a null parameter is passed to a Cloud function\n\n### 2.2.8 (5/8/2016)\n\n* New: Support for Pointer Permissions\n* New: Expose logger in Cloud Code\n* New: Option to revoke sessions on password reset\n* New: Option to expire inactive sessions\n* Perf: Improvements in ACL checking query\n* Fix: Issues when sending pushes to list of devices that contains invalid values\n* Fix: Issues caused by using babel-polyfill outside of Parse Server, but in the same express app\n* Fix: Remove creation of extra session tokens\n* Fix: Return authData when querying with master key\n* Fix: Bugs when deleting webhooks\n* Fix: Ignore _RevocableSession header, which might be sent by the JS SDK\n* Fix: Issues with querying via URL params\n* Fix: Properly encode \"Date\" parameters to cloud code functions\n\n\n### 2.2.7 (4/15/2016)\n\n* Adds support for --verbose and verbose option when running ParseServer [\\#1414](https://github.com/ParsePlatform/parse-server/pull/1414) ([flovilmart](https://github.com/flovilmart))\n* Adds limit = 0 as a valid parameter for queries [\\#1493](https://github.com/ParsePlatform/parse-server/pull/1493) ([seijiakiyama](https://github.com/seijiakiyama))\n* Makes sure we preserve Installations when updating a token  \\(\\#1475\\) [\\#1486](https://github.com/ParsePlatform/parse-server/pull/1486) ([flovilmart](https://github.com/flovilmart))\n* Hotfix for tests [\\#1503](https://github.com/ParsePlatform/parse-server/pull/1503) ([flovilmart](https://github.com/flovilmart))\n* Enable logs [\\#1502](https://github.com/ParsePlatform/parse-server/pull/1502) ([drew-gross](https://github.com/drew-gross))\n* Do some triple equals for great justice [\\#1499](https://github.com/ParsePlatform/parse-server/pull/1499) ([TylerBrock](https://github.com/TylerBrock))\n* Apply credential stripping to all untransforms for \\_User [\\#1498](https://github.com/ParsePlatform/parse-server/pull/1498) ([TylerBrock](https://github.com/TylerBrock))\n* Checking if object has defined key for Pointer constraints in liveQuery [\\#1487](https://github.com/ParsePlatform/parse-server/pull/1487) ([simonas-notcat](https://github.com/simonas-notcat))\n* Remove collection prefix and default mongo URI [\\#1479](https://github.com/ParsePlatform/parse-server/pull/1479) ([drew-gross](https://github.com/drew-gross))\n* Store collection prefix in mongo adapter, and clean up adapter interface [\\#1472](https://github.com/ParsePlatform/parse-server/pull/1472) ([drew-gross](https://github.com/drew-gross))\n* Move field deletion logic into mongo adapter [\\#1471](https://github.com/ParsePlatform/parse-server/pull/1471) ([drew-gross](https://github.com/drew-gross))\n* Adds support for Long and Double mongodb types \\(fixes \\#1316\\) [\\#1470](https://github.com/ParsePlatform/parse-server/pull/1470) ([flovilmart](https://github.com/flovilmart))\n* Schema.js database agnostic [\\#1468](https://github.com/ParsePlatform/parse-server/pull/1468) ([flovilmart](https://github.com/flovilmart))\n* Remove console.log [\\#1465](https://github.com/ParsePlatform/parse-server/pull/1465) ([drew-gross](https://github.com/drew-gross))\n* Push status nits [\\#1462](https://github.com/ParsePlatform/parse-server/pull/1462) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1444 [\\#1451](https://github.com/ParsePlatform/parse-server/pull/1451) ([flovilmart](https://github.com/flovilmart))\n* Removing sessionToken and authData from \\_User objects included in a query [\\#1450](https://github.com/ParsePlatform/parse-server/pull/1450) ([simonas-notcat](https://github.com/simonas-notcat))\n* Move mongo field type logic into mongoadapter [\\#1432](https://github.com/ParsePlatform/parse-server/pull/1432) ([drew-gross](https://github.com/drew-gross))\n* Prevents \\_User lock out when setting ACL on signup or afterwards [\\#1429](https://github.com/ParsePlatform/parse-server/pull/1429) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1428](https://github.com/ParsePlatform/parse-server/pull/1428) ([flovilmart](https://github.com/flovilmart))\n* Adds relation fields to objects [\\#1424](https://github.com/ParsePlatform/parse-server/pull/1424) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1423](https://github.com/ParsePlatform/parse-server/pull/1423) ([flovilmart](https://github.com/flovilmart))\n* Sets the defaultSchemas keys in the SchemaCollection [\\#1421](https://github.com/ParsePlatform/parse-server/pull/1421) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1417 [\\#1420](https://github.com/ParsePlatform/parse-server/pull/1420) ([drew-gross](https://github.com/drew-gross))\n* Untransform should treat Array's as nested objects [\\#1416](https://github.com/ParsePlatform/parse-server/pull/1416) ([blacha](https://github.com/blacha))\n* Adds X-Parse-Push-Status-Id header [\\#1412](https://github.com/ParsePlatform/parse-server/pull/1412) ([flovilmart](https://github.com/flovilmart))\n* Schema format cleanup [\\#1407](https://github.com/ParsePlatform/parse-server/pull/1407) ([drew-gross](https://github.com/drew-gross))\n* Updates the publicServerURL option [\\#1397](https://github.com/ParsePlatform/parse-server/pull/1397) ([flovilmart](https://github.com/flovilmart))\n* Fix exception with non-expiring session tokens. [\\#1386](https://github.com/ParsePlatform/parse-server/pull/1386) ([0x18B2EE](https://github.com/0x18B2EE))\n* Move mongo schema format related logic into mongo adapter [\\#1385](https://github.com/ParsePlatform/parse-server/pull/1385) ([drew-gross](https://github.com/drew-gross))\n* WIP: Huge performance improvement on roles queries [\\#1383](https://github.com/ParsePlatform/parse-server/pull/1383) ([flovilmart](https://github.com/flovilmart))\n* Removes GCS Adapter from provided adapters [\\#1339](https://github.com/ParsePlatform/parse-server/pull/1339) ([flovilmart](https://github.com/flovilmart))\n* DBController refactoring [\\#1228](https://github.com/ParsePlatform/parse-server/pull/1228) ([flovilmart](https://github.com/flovilmart))\n* Spotify authentication [\\#1226](https://github.com/ParsePlatform/parse-server/pull/1226) ([1nput0utput](https://github.com/1nput0utput))\n* Expose DatabaseAdapter to simplify application tests [\\#1121](https://github.com/ParsePlatform/parse-server/pull/1121) ([steven-supersolid](https://github.com/steven-supersolid))\n\n### 2.2.6 (4/5/2016)\n\n* Important Fix: Disables find on installation from clients [\\#1374](https://github.com/ParsePlatform/parse-server/pull/1374) ([flovilmart](https://github.com/flovilmart))\n* Adds missing options to the CLI [\\#1368](https://github.com/ParsePlatform/parse-server/pull/1368) ([flovilmart](https://github.com/flovilmart))\n* Removes only master on travis [\\#1367](https://github.com/ParsePlatform/parse-server/pull/1367) ([flovilmart](https://github.com/flovilmart))\n* Auth.\\_loadRoles should not query the same role twice. [\\#1366](https://github.com/ParsePlatform/parse-server/pull/1366) ([blacha](https://github.com/blacha))\n\n### 2.2.5 (4/4/2016)\n\n* Improves config loading and tests [\\#1363](https://github.com/ParsePlatform/parse-server/pull/1363) ([flovilmart](https://github.com/flovilmart))\n* Adds travis configuration to deploy NPM on new version tags [\\#1361](https://github.com/ParsePlatform/parse-server/pull/1361) ([gfosco](https://github.com/gfosco))\n* Inject the default schemas properties when loading it [\\#1357](https://github.com/ParsePlatform/parse-server/pull/1357) ([flovilmart](https://github.com/flovilmart))\n* Adds console transport when testing with VERBOSE=1 [\\#1351](https://github.com/ParsePlatform/parse-server/pull/1351) ([flovilmart](https://github.com/flovilmart))\n* Make notEqual work on relations  [\\#1350](https://github.com/ParsePlatform/parse-server/pull/1350) ([flovilmart](https://github.com/flovilmart))\n* Accept only bool for $exists in LiveQuery [\\#1315](https://github.com/ParsePlatform/parse-server/pull/1315) ([drew-gross](https://github.com/drew-gross))\n* Adds more options when using CLI/config [\\#1305](https://github.com/ParsePlatform/parse-server/pull/1305) ([flovilmart](https://github.com/flovilmart))\n* Update error message [\\#1297](https://github.com/ParsePlatform/parse-server/pull/1297) ([drew-gross](https://github.com/drew-gross))\n* Properly let masterKey add fields [\\#1291](https://github.com/ParsePlatform/parse-server/pull/1291) ([flovilmart](https://github.com/flovilmart))\n* Point to \\#1271 as how to write a good issue report [\\#1290](https://github.com/ParsePlatform/parse-server/pull/1290) ([drew-gross](https://github.com/drew-gross))\n* Adds ability to override mount with publicServerURL for production uses [\\#1287](https://github.com/ParsePlatform/parse-server/pull/1287) ([flovilmart](https://github.com/flovilmart))\n* Single object queries to use include and keys [\\#1280](https://github.com/ParsePlatform/parse-server/pull/1280) ([jeremyjackson89](https://github.com/jeremyjackson89))\n* Improves report for Push error in logs and \\_PushStatus [\\#1269](https://github.com/ParsePlatform/parse-server/pull/1269) ([flovilmart](https://github.com/flovilmart))\n* Removes all stdout/err logs while testing [\\#1268](https://github.com/ParsePlatform/parse-server/pull/1268) ([flovilmart](https://github.com/flovilmart))\n* Matching queries with doesNotExist constraint [\\#1250](https://github.com/ParsePlatform/parse-server/pull/1250) ([andrecardoso](https://github.com/andrecardoso))\n* Added session length option for session tokens to server configuration [\\#997](https://github.com/ParsePlatform/parse-server/pull/997) ([Kenishi](https://github.com/Kenishi))\n* Regression test for \\#1259 [\\#1286](https://github.com/ParsePlatform/parse-server/pull/1286) ([drew-gross](https://github.com/drew-gross))\n* Regression test for \\#871 [\\#1283](https://github.com/ParsePlatform/parse-server/pull/1283) ([drew-gross](https://github.com/drew-gross))\n* Add a test to repro \\#701 [\\#1281](https://github.com/ParsePlatform/parse-server/pull/1281) ([drew-gross](https://github.com/drew-gross))\n* Fix for \\#1334: using relative cloud code files broken  [\\#1353](https://github.com/ParsePlatform/parse-server/pull/1353) ([airdrummingfool](https://github.com/airdrummingfool))\n* Fix Issue/1288 [\\#1346](https://github.com/ParsePlatform/parse-server/pull/1346) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1271 [\\#1295](https://github.com/ParsePlatform/parse-server/pull/1295) ([drew-gross](https://github.com/drew-gross))\n* Fixes issue \\#1302 [\\#1314](https://github.com/ParsePlatform/parse-server/pull/1314) ([flovilmart](https://github.com/flovilmart))\n* Fixes bug related to include in queries [\\#1312](https://github.com/ParsePlatform/parse-server/pull/1312) ([flovilmart](https://github.com/flovilmart))\n\n\n### 2.2.4 (3/29/2016)\n\n* Hotfix: fixed imports issue for S3Adapter, GCSAdapter, FileSystemAdapter [\\#1263](https://github.com/ParsePlatform/parse-server/pull/1263) ([drew-gross](https://github.com/drew-gross)\n* Fix: Clean null authData values on _User update [\\#1199](https://github.com/ParsePlatform/parse-server/pull/1199) ([yuzeh](https://github.com/yuzeh))\n\n### 2.2.3 (3/29/2016)\n\n* Fixed bug with invalid email verification link on email update. [\\#1253](https://github.com/ParsePlatform/parse-server/pull/1253) ([kzielonka](https://github.com/kzielonka))\n* Badge update supports increment as well as Increment [\\#1248](https://github.com/ParsePlatform/parse-server/pull/1248) ([flovilmart](https://github.com/flovilmart))\n* Config/Push Tested with the dashboard. [\\#1235](https://github.com/ParsePlatform/parse-server/pull/1235) ([drew-gross](https://github.com/drew-gross))\n* Better logging with winston [\\#1234](https://github.com/ParsePlatform/parse-server/pull/1234) ([flovilmart](https://github.com/flovilmart))\n* Make GlobalConfig work like parse.com [\\#1210](https://github.com/ParsePlatform/parse-server/pull/1210) ([framp](https://github.com/framp))\n* Improve flattening of results from pushAdapter [\\#1204](https://github.com/ParsePlatform/parse-server/pull/1204) ([flovilmart](https://github.com/flovilmart))\n* Push adapters are provided by external packages [\\#1195](https://github.com/ParsePlatform/parse-server/pull/1195) ([flovilmart](https://github.com/flovilmart))\n* Fix flaky test [\\#1188](https://github.com/ParsePlatform/parse-server/pull/1188) ([drew-gross](https://github.com/drew-gross))\n* Fixes problem affecting finding array pointers [\\#1185](https://github.com/ParsePlatform/parse-server/pull/1185) ([flovilmart](https://github.com/flovilmart))\n* Moves Files adapters to external packages [\\#1172](https://github.com/ParsePlatform/parse-server/pull/1172) ([flovilmart](https://github.com/flovilmart))\n* Mark push as enabled in serverInfo endpoint [\\#1164](https://github.com/ParsePlatform/parse-server/pull/1164) ([drew-gross](https://github.com/drew-gross))\n* Document email adapter [\\#1144](https://github.com/ParsePlatform/parse-server/pull/1144) ([drew-gross](https://github.com/drew-gross))\n* Reset password fix [\\#1133](https://github.com/ParsePlatform/parse-server/pull/1133) ([carmenlau](https://github.com/carmenlau))\n\n### 2.2.2 (3/23/2016)\n\n* Important Fix: Mounts createLiveQueryServer, fix babel induced problem [\\#1153](https://github.com/ParsePlatform/parse-server/pull/1153) (flovilmart)\n* Move ParseServer to it's own file [\\#1166](https://github.com/ParsePlatform/parse-server/pull/1166) (flovilmart)\n* Update README.md * remove deploy buttons * replace with community links [\\#1139](https://github.com/ParsePlatform/parse-server/pull/1139) (drew-gross)\n* Adds bootstrap.sh [\\#1138](https://github.com/ParsePlatform/parse-server/pull/1138) (flovilmart)\n* Fix: Do not override username [\\#1142](https://github.com/ParsePlatform/parse-server/pull/1142) (flovilmart)\n* Fix: Add pushId back to GCM payload [\\#1168](https://github.com/ParsePlatform/parse-server/pull/1168) (wangmengyan95)\n\n### 2.2.1 (3/22/2016)\n\n* New: Add FileSystemAdapter file adapter [\\#1098](https://github.com/ParsePlatform/parse-server/pull/1098) (dtsolis)\n* New: Enabled CLP editing [\\#1128](https://github.com/ParsePlatform/parse-server/pull/1128) (drew-gross)\n* Improvement: Reduces the number of connections to mongo created [\\#1111](https://github.com/ParsePlatform/parse-server/pull/1111) (flovilmart)\n* Improvement: Make ParseServer a class [\\#980](https://github.com/ParsePlatform/parse-server/pull/980) (flovilmart)\n* Fix: Adds support for plain object in $add, $addUnique, $remove [\\#1114](https://github.com/ParsePlatform/parse-server/pull/1114) (flovilmart)\n* Fix: Generates default CLP, freezes objects [\\#1132](https://github.com/ParsePlatform/parse-server/pull/1132) (flovilmart)\n* Fix: Properly sets installationId on creating session with 3rd party auth [\\#1110](https://github.com/ParsePlatform/parse-server/pull/1110) (flovilmart)\n\n### 2.2.0 (3/18/2016)\n\n* New Feature: Real-time functionality with Live Queries! [\\#1092](https://github.com/ParsePlatform/parse-server/pull/1092) (wangmengyan95)\n* Improvement: Push Status API [\\#1004](https://github.com/ParsePlatform/parse-server/pull/1004) (flovilmart)\n* Improvement: Allow client operations on Roles [\\#1068](https://github.com/ParsePlatform/parse-server/pull/1068) (flovilmart)\n* Improvement: Add URI encoding to mongo auth parameters [\\#986](https://github.com/ParsePlatform/parse-server/pull/986) (bgw)\n* Improvement: Adds support for apps key in config file, but only support single app for now [\\#979](https://github.com/ParsePlatform/parse-server/pull/979) (flovilmart)\n* Documentation: Getting Started and Configuring Parse Server [\\#988](https://github.com/ParsePlatform/parse-server/pull/988) (hramos)\n* Fix: Various edge cases with REST API [\\#1066](https://github.com/ParsePlatform/parse-server/pull/1066) (flovilmart)\n* Fix: Makes sure the location in results has the proper objectId [\\#1065](https://github.com/ParsePlatform/parse-server/pull/1065) (flovilmart)\n* Fix: Third-party auth is properly removed when unlinked [\\#1081](https://github.com/ParsePlatform/parse-server/pull/1081) (flovilmart)\n* Fix: Clear the session-user cache when changing \\_User objects [\\#1072](https://github.com/ParsePlatform/parse-server/pull/1072) (gfosco)\n* Fix: Bug related to subqueries on unfetched objects [\\#1046](https://github.com/ParsePlatform/parse-server/pull/1046) (flovilmart)\n* Fix: Properly urlencode parameters for email validation and password reset [\\#1001](https://github.com/ParsePlatform/parse-server/pull/1001) (flovilmart)\n* Fix: Better sanitization/decoding of object data for afterSave triggers [\\#992](https://github.com/ParsePlatform/parse-server/pull/992) (flovilmart)\n* Fix: Changes default encoding for httpRequest [\\#892](https://github.com/ParsePlatform/parse-server/pull/892) (flovilmart)\n\n### 2.1.6 (3/11/2016)\n\n* Improvement: Full query support for badge Increment \\(\\#931\\) [\\#983](https://github.com/ParsePlatform/parse-server/pull/983) (flovilmart)\n* Improvement: Shutdown standalone parse server gracefully [\\#958](https://github.com/ParsePlatform/parse-server/pull/958) (raulr)\n* Improvement: Add database options to ParseServer constructor and pass to MongoStorageAdapter [\\#956](https://github.com/ParsePlatform/parse-server/pull/956) (steven-supersolid)\n* Improvement: AuthData logic refactor [\\#952](https://github.com/ParsePlatform/parse-server/pull/952) (flovilmart)\n* Improvement: Changed FileLoggerAdapterSpec to fail gracefully on Windows [\\#946](https://github.com/ParsePlatform/parse-server/pull/946) (aneeshd16)\n* Improvement: Add new schema collection type and replace all usages of direct mongo collection for schema operations. [\\#943](https://github.com/ParsePlatform/parse-server/pull/943) (nlutsenko)\n* Improvement: Adds CLP API to Schema router [\\#898](https://github.com/ParsePlatform/parse-server/pull/898) (flovilmart)\n* Fix: Cleans up authData null keys on login for android crash [\\#978](https://github.com/ParsePlatform/parse-server/pull/978) (flovilmart)\n* Fix: Do master query for before/afterSaveHook [\\#959](https://github.com/ParsePlatform/parse-server/pull/959) (wangmengyan95)\n* Fix: re-add shebang [\\#944](https://github.com/ParsePlatform/parse-server/pull/944) (flovilmart)\n* Fix: Added test command for Windows support [\\#886](https://github.com/ParsePlatform/parse-server/pull/886) (aneeshd16)\n\n### 2.1.5 (3/9/2016)\n\n* New: FileAdapter for Google Cloud Storage [\\#708](https://github.com/ParsePlatform/parse-server/pull/708) (mcdonamp)\n* Improvement: Minimize extra schema queries in some scenarios. [\\#919](https://github.com/ParsePlatform/parse-server/pull/919) (Marco129)\n* Improvement: Move DatabaseController and Schema fully to adaptive mongo collection. [\\#909](https://github.com/ParsePlatform/parse-server/pull/909) (nlutsenko)\n* Improvement: Cleanup PushController/PushRouter, remove raw mongo collection access. [\\#903](https://github.com/ParsePlatform/parse-server/pull/903) (nlutsenko)\n* Improvement: Increment badge the right way [\\#902](https://github.com/ParsePlatform/parse-server/pull/902) (flovilmart)\n* Improvement: Migrate ParseGlobalConfig to new database storage API. [\\#901](https://github.com/ParsePlatform/parse-server/pull/901) (nlutsenko)\n* Improvement: Improve delete flow for non-existent \\_Join collection [\\#881](https://github.com/ParsePlatform/parse-server/pull/881) (Marco129)\n* Improvement: Adding a role scenario test for issue 827 [\\#878](https://github.com/ParsePlatform/parse-server/pull/878) (gfosco)\n* Improvement: Test empty authData block on login for \\#413 [\\#863](https://github.com/ParsePlatform/parse-server/pull/863) (gfosco)\n* Improvement: Modified the npm dev script to support Windows [\\#846](https://github.com/ParsePlatform/parse-server/pull/846) (aneeshd16)\n* Improvement: Move HooksController to use MongoCollection instead of direct Mongo access. [\\#844](https://github.com/ParsePlatform/parse-server/pull/844) (nlutsenko)\n* Improvement: Adds public\\_html and views for packaging [\\#839](https://github.com/ParsePlatform/parse-server/pull/839) (flovilmart)\n* Improvement: Better support for windows builds [\\#831](https://github.com/ParsePlatform/parse-server/pull/831) (flovilmart)\n* Improvement: Convert Schema.js to ES6 class. [\\#826](https://github.com/ParsePlatform/parse-server/pull/826) (nlutsenko)\n* Improvement: Remove duplicated instructions [\\#816](https://github.com/ParsePlatform/parse-server/pull/816) (hramos)\n* Improvement: Completely migrate SchemasRouter to new MongoCollection API. [\\#794](https://github.com/ParsePlatform/parse-server/pull/794) (nlutsenko)\n* Fix: Do not require where clause in $dontSelect condition on queries. [\\#925](https://github.com/ParsePlatform/parse-server/pull/925) (nlutsenko)\n* Fix: Make sure that ACLs propagate to before/after save hooks. [\\#924](https://github.com/ParsePlatform/parse-server/pull/924) (nlutsenko)\n* Fix: Support params option in Parse.Cloud.httpRequest. [\\#912](https://github.com/ParsePlatform/parse-server/pull/912) (carmenlau)\n* Fix: Fix flaky Parse.GeoPoint test. [\\#908](https://github.com/ParsePlatform/parse-server/pull/908) (nlutsenko)\n* Fix: Handle legacy \\_client\\_permissions key in \\_SCHEMA. [\\#900](https://github.com/ParsePlatform/parse-server/pull/900) (drew-gross)\n* Fix: Fixes bug when querying equalTo on objectId and relation [\\#887](https://github.com/ParsePlatform/parse-server/pull/887) (flovilmart)\n* Fix: Allow crossdomain on filesRouter [\\#876](https://github.com/ParsePlatform/parse-server/pull/876) (flovilmart)\n* Fix: Remove limit when counting results. [\\#867](https://github.com/ParsePlatform/parse-server/pull/867) (gfosco)\n* Fix: beforeSave changes should propagate to the response [\\#865](https://github.com/ParsePlatform/parse-server/pull/865) (gfosco)\n* Fix: Delete relation field when \\_Join collection not exist [\\#864](https://github.com/ParsePlatform/parse-server/pull/864) (Marco129)\n* Fix: Related query on non-existing column [\\#861](https://github.com/ParsePlatform/parse-server/pull/861) (gfosco)\n* Fix: Update markdown in .github/ISSUE\\_TEMPLATE.md [\\#859](https://github.com/ParsePlatform/parse-server/pull/859) (igorshubovych)\n* Fix: Issue with creating wrong \\_Session for Facebook login [\\#857](https://github.com/ParsePlatform/parse-server/pull/857) (tobernguyen)\n* Fix: Leak warnings in tests, use mongodb-runner from node\\_modules [\\#843](https://github.com/ParsePlatform/parse-server/pull/843) (drew-gross)\n* Fix: Reversed roles lookup [\\#841](https://github.com/ParsePlatform/parse-server/pull/841) (flovilmart)\n* Fix: Improves loading of Push Adapter, fix loading of S3Adapter [\\#833](https://github.com/ParsePlatform/parse-server/pull/833) (flovilmart)\n* Fix: Add field to system schema [\\#828](https://github.com/ParsePlatform/parse-server/pull/828) (Marco129)\n\n### 2.1.4 (3/3/2016)\n\n* New: serverInfo endpoint that returns server version and info about the server's features\n* Improvement: Add support for badges on iOS\n* Improvement: Improve failure handling in cloud code http requests\n* Improvement: Add support for queries on pointers and relations\n* Improvement: Add support for multiple $in clauses in a query\n* Improvement: Add allowClientClassCreation config option\n* Improvement: Allow atomically setting subdocument keys\n* Improvement: Allow arbitrarily deeply nested roles\n* Improvement: Set proper content-type in S3 File Adapter\n* Improvement: S3 adapter auto-creates buckets\n* Improvement: Better error messages for many errors\n* Performance: Improved algorithm for validating client keys\n* Experimental: Parse Hooks and Hooks API\n* Experimental: Email verification and password reset emails\n* Experimental: Improve compatability of logs feature with Parse.com\n* Fix: Fix for attempting to delete missing classes via schemas API\n* Fix: Allow creation of system classes via schemas API\n* Fix: Allow missing where cause in $select\n* Fix: Improve handling of invalid object ids\n* Fix: Replace query overwriting existing query\n* Fix: Propagate installationId in cloud code triggers\n* Fix: Session expiresAt is now a Date instead of a string\n* Fix: Fix count queries\n* Fix: Disallow _Role objects without names or without ACL\n* Fix: Better handling of invalid types submitted\n* Fix: beforeSave will not be triggered for attempts to save with invalid authData\n* Fix: Fix duplicate device token issues on Android\n* Fix: Allow empty authData on signup\n* Fix: Allow Master Key Headers (CORS)\n* Fix: Fix bugs if JavaScript key was not provided in server configuration\n* Fix: Parse Files on objects can now be stored without URLs\n* Fix: allow both objectId or installationId when modifying installation\n* Fix: Command line works better when not given options\n\n### 2.1.3 (2/24/2016)\n\n* Feature: Add initial support for in-app purchases\n* Feature: Better error messages when attempting to run the server on a port that is already in use or without a server URL\n* Feature: Allow customization of max file size\n* Performance: Faster saves if not using beforeSave triggers\n* Fix: Send session token in response to current user endpoint\n* Fix: Remove triggers for _Session collection\n* Fix: Improve compatability of cloud code beforeSave hook for newly created object\n* Fix: ACL creation for master key only objects\n* Fix: Allow uploading files without Content-Type\n* Fix: Add features to http request to match Parse.com\n* Fix: Bugs in development script when running from locations other than project root\n* Fix: Can pass query constraints in URL\n* Fix: Objects with legacy \"_tombstone\" key now don't cause issues.\n* Fix: Allow nested keys in objects to begin with underscores\n* Fix: Allow correct headers for CORS\n\n### 2.1.2 (2/19/2016)\n\n* Change: The S3 file adapter constructor requires a bucket name\n* Fix: Parse Query should throw if improperly encoded\n* Fix: Issue where roles were not used in some requests\n* Fix: serverURL will no longer default to api.parse.com/1\n\n### 2.1.1 (2/18/2016)\n\n* Experimental: Schemas API support for DELETE operations\n* Fix: Session token issue fetching Users\n* Fix: Facebook auth validation\n* Fix: Invalid error when deleting missing session\n\n### 2.1.0 (2/17/2016)\n\n* Feature: Support for additional OAuth providers\n* Feature: Ability to implement custom OAuth providers\n* Feature: Support for deleting Parse Files\n* Feature: Allow querying roles\n* Feature: Support for logs, extensible via Log Adapter\n* Feature: New Push Adapter for sending push notifications through OneSignal\n* Feature: Tighter default security for Users\n* Feature: Pass parameters to cloud code in query string\n* Feature: Disable anonymous users via configuration.\n* Experimental: Schemas API support for PUT operations\n* Fix: Prevent installation ID from being added to User\n* Fix: Becoming a user works properly with sessions\n* Fix: Including multiple object when some object are unavailable will get all the objects that are available\n* Fix: Invalid URL for Parse Files\n* Fix: Making a query without a limit now returns 100 results\n* Fix: Expose installation id in cloud code\n* Fix: Correct username for Anonymous users\n* Fix: Session token issue after fetching user\n* Fix: Issues during install process\n* Fix: Issue with Unity SDK sending _noBody\n\n### 2.0.8 (2/11/2016)\n\n* Add: support for Android and iOS push notifications\n* Experimental: cloud code validation hooks (can mark as non-experimental after we have docs)\n* Experimental: support for schemas API (GET and POST only)\n* Experimental: support for Parse Config (GET and POST only)\n* Fix: Querying objects with equality constraint on array column\n* Fix: User logout will remove session token\n* Fix: Various files related bugs\n* Fix: Force minimum node version 4.3 due to security issues in earlier version\n* Performance Improvement: Improved caching\n", "// This is a port of the test suite:\n// hungry/js/test/parse_user_test.js\n//\n// Things that we didn't port:\n// Tests that involve revocable sessions.\n// Tests that involve sending password reset emails.\n\n'use strict';\n\nconst MongoStorageAdapter = require('../lib/Adapters/Storage/Mongo/MongoStorageAdapter').default;\nconst request = require('../lib/request');\nconst passwordCrypto = require('../lib/password');\nconst Config = require('../lib/Config');\nconst cryptoUtils = require('../lib/cryptoUtils');\n\nfunction verifyACL(user) {\n  const ACL = user.getACL();\n  expect(ACL.getReadAccess(user)).toBe(true);\n  expect(ACL.getWriteAccess(user)).toBe(true);\n  expect(ACL.getPublicReadAccess()).toBe(true);\n  expect(ACL.getPublicWriteAccess()).toBe(false);\n  const perms = ACL.permissionsById;\n  expect(Object.keys(perms).length).toBe(2);\n  expect(perms[user.id].read).toBe(true);\n  expect(perms[user.id].write).toBe(true);\n  expect(perms['*'].read).toBe(true);\n  expect(perms['*'].write).not.toBe(true);\n}\n\ndescribe('Parse.User testing', () => {\n  it('user sign up class method', async done => {\n    const user = await Parse.User.signUp('asdf', 'zxcv');\n    ok(user.getSessionToken());\n    done();\n  });\n\n  it('user sign up instance method', async () => {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    await user.signUp();\n    ok(user.getSessionToken());\n  });\n\n  it('user login wrong username', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    try {\n      await Parse.User.logIn('non_existent_user', 'asdf3');\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });\n\n  it('user login wrong password', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    try {\n      await Parse.User.logIn('asdf', 'asdfWrong');\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });\n\n  it('user login with non-string username with REST API', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        _method: 'GET',\n        username: { $regex: '^asd' },\n        password: 'zxcv',\n      },\n    })\n      .then(res => {\n        fail(`no request should succeed: ${JSON.stringify(res)}`);\n        done();\n      })\n      .catch(err => {\n        expect(err.status).toBe(404);\n        expect(err.text).toMatch('{\"code\":101,\"error\":\"Invalid username/password.\"}');\n        done();\n      });\n  });\n\n  it('user login with non-string username with REST API (again)', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        _method: 'GET',\n        username: 'asdf',\n        password: { $regex: '^zx' },\n      },\n    })\n      .then(res => {\n        fail(`no request should succeed: ${JSON.stringify(res)}`);\n        done();\n      })\n      .catch(err => {\n        expect(err.status).toBe(404);\n        expect(err.text).toMatch('{\"code\":101,\"error\":\"Invalid username/password.\"}');\n        done();\n      });\n  });\n\n  it('user login using POST with REST API', async done => {\n    await Parse.User.signUp('some_user', 'some_password');\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/login',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n      },\n      body: {\n        username: 'some_user',\n        password: 'some_password',\n      },\n    })\n      .then(res => {\n        expect(res.data.username).toBe('some_user');\n        done();\n      })\n      .catch(err => {\n        fail(`no request should fail: ${JSON.stringify(err)}`);\n        done();\n      });\n  });\n\n  it('user login', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    const user = await Parse.User.logIn('asdf', 'zxcv');\n    equal(user.get('username'), 'asdf');\n    verifyACL(user);\n    done();\n  });\n\n  it('should respect ACL without locking user out', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('asdf');\n    user.setPassword('zxcv');\n    user.setACL(ACL);\n    user\n      .signUp()\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        equal(user.get('username'), 'asdf');\n        const ACL = user.getACL();\n        expect(ACL.getReadAccess(user)).toBe(true);\n        expect(ACL.getWriteAccess(user)).toBe(true);\n        expect(ACL.getPublicReadAccess()).toBe(false);\n        expect(ACL.getPublicWriteAccess()).toBe(false);\n        const perms = ACL.permissionsById;\n        expect(Object.keys(perms).length).toBe(1);\n        expect(perms[user.id].read).toBe(true);\n        expect(perms[user.id].write).toBe(true);\n        expect(perms['*']).toBeUndefined();\n        // Try to lock out user\n        const newACL = new Parse.ACL();\n        newACL.setReadAccess(user.id, false);\n        newACL.setWriteAccess(user.id, false);\n        user.setACL(newACL);\n        return user.save();\n      })\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        equal(user.get('username'), 'asdf');\n        const ACL = user.getACL();\n        expect(ACL.getReadAccess(user)).toBe(true);\n        expect(ACL.getWriteAccess(user)).toBe(true);\n        expect(ACL.getPublicReadAccess()).toBe(false);\n        expect(ACL.getPublicWriteAccess()).toBe(false);\n        const perms = ACL.permissionsById;\n        expect(Object.keys(perms).length).toBe(1);\n        expect(perms[user.id].read).toBe(true);\n        expect(perms[user.id].write).toBe(true);\n        expect(perms['*']).toBeUndefined();\n        done();\n      })\n      .catch(() => {\n        fail('Should not fail');\n        done();\n      });\n  });\n\n  it('should let masterKey lockout user', done => {\n    const user = new Parse.User();\n    const ACL = new Parse.ACL();\n    ACL.setPublicReadAccess(false);\n    ACL.setPublicWriteAccess(false);\n    user.setUsername('asdf');\n    user.setPassword('zxcv');\n    user.setACL(ACL);\n    user\n      .signUp()\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        equal(user.get('username'), 'asdf');\n        // Lock the user down\n        const ACL = new Parse.ACL();\n        user.setACL(ACL);\n        return user.save(null, { useMasterKey: true });\n      })\n      .then(() => {\n        expect(user.getACL().getPublicReadAccess()).toBe(false);\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.message).toBe('Invalid username/password.');\n        expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n        done();\n      });\n  });\n\n  it_only_db('mongo')('should let legacy users without ACL login', async () => {\n    const databaseURI = 'mongodb://localhost:27017/parseServerMongoAdapterTestDatabase';\n    const adapter = new MongoStorageAdapter({\n      collectionPrefix: 'test_',\n      uri: databaseURI,\n    });\n    await adapter.connect();\n    await adapter.database.dropDatabase();\n    delete adapter.connectionPromise;\n\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'newUser',\n      password: 'password',\n    });\n\n    const collection = await adapter._adaptiveCollection('_User');\n    await collection.insertOne({\n      // the hashed password is 'password' hashed\n      _hashed_password: '$2b$10$mJ2ca2UbCM9hlojYHZxkQe8pyEXe5YMg0nMdvP4AJBeqlTEZJ6/Uu',\n      _session_token: 'xxx',\n      email: 'xxx@a.b',\n      username: 'oldUser',\n      emailVerified: true,\n      _email_verify_token: 'yyy',\n    });\n\n    // get the 2 users\n    const users = await collection.find();\n    expect(users.length).toBe(2);\n\n    const aUser = await Parse.User.logIn('oldUser', 'password');\n    expect(aUser).not.toBeUndefined();\n\n    const newUser = await Parse.User.logIn('newUser', 'password');\n    expect(newUser).not.toBeUndefined();\n  });\n\n  it('should be let masterKey lock user out with authData', async () => {\n    const response = await request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        key: 'value',\n        authData: { anonymous: { id: '00000000-0000-0000-0000-000000000001' } },\n      },\n    });\n    const body = response.data;\n    const objectId = body.objectId;\n    const sessionToken = body.sessionToken;\n    expect(sessionToken).toBeDefined();\n    expect(objectId).toBeDefined();\n    const user = new Parse.User();\n    user.id = objectId;\n    const ACL = new Parse.ACL();\n    user.setACL(ACL);\n    await user.save(null, { useMasterKey: true });\n    // update the user\n    const options = {\n      method: 'POST',\n      url: `http://localhost:8378/1/classes/_User/`,\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        key: 'otherValue',\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    };\n    const res = await request(options);\n    expect(res.data.objectId).not.toEqual(objectId);\n  });\n\n  it('user login with files', done => {\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file\n      .save()\n      .then(file => {\n        return Parse.User.signUp('asdf', 'zxcv', { file: file });\n      })\n      .then(() => {\n        return Parse.User.logIn('asdf', 'zxcv');\n      })\n      .then(user => {\n        const fileAgain = user.get('file');\n        ok(fileAgain.name());\n        ok(fileAgain.url());\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('become sends token back', done => {\n    let user = null;\n    let sessionToken = null;\n\n    Parse.User.signUp('Jason', 'Parse', { code: 'red' })\n      .then(newUser => {\n        user = newUser;\n        expect(user.get('code'), 'red');\n\n        sessionToken = newUser.getSessionToken();\n        expect(sessionToken).toBeDefined();\n\n        return Parse.User.become(sessionToken);\n      })\n      .then(newUser => {\n        expect(newUser.id).toEqual(user.id);\n        expect(newUser.get('username'), 'Jason');\n        expect(newUser.get('code'), 'red');\n        expect(newUser.getSessionToken()).toEqual(sessionToken);\n      })\n      .then(\n        () => {\n          done();\n        },\n        error => {\n          jfail(error);\n          done();\n        }\n      );\n  });\n\n  it('become', done => {\n    let user = null;\n    let sessionToken = null;\n\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('Jason', 'Parse', { code: 'red' });\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n\n        user = newUser;\n        sessionToken = newUser.getSessionToken();\n        ok(sessionToken);\n\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        ok(!Parse.User.current());\n\n        return Parse.User.become(sessionToken);\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n\n        ok(newUser);\n        equal(newUser.id, user.id);\n        equal(newUser.get('username'), 'Jason');\n        equal(newUser.get('code'), 'red');\n\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        ok(!Parse.User.current());\n\n        return Parse.User.become('somegarbage');\n      })\n      .then(\n        function () {\n          // This should have failed actually.\n          ok(false, \"Shouldn't have been able to log in with garbage session token.\");\n        },\n        function (error) {\n          ok(error);\n          // Handle the error.\n          return Promise.resolve();\n        }\n      )\n      .then(\n        function () {\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('should not call beforeLogin with become', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n\n    await Parse.User._logInWith('facebook');\n    const sessionToken = Parse.User.current().getSessionToken();\n    await Parse.User.become(sessionToken);\n    expect(hit).toBe(0);\n    done();\n  });\n\n  it('cannot save non-authed user', async done => {\n    let user = new Parse.User();\n    user.set({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    let userAgain = await user.signUp();\n    equal(userAgain, user);\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    user.set({\n      username: 'hacker',\n      password: 'password',\n    });\n    userAgain = await user.signUp();\n    equal(userAgain, user);\n    userNotAuthed.set('username', 'changed');\n    userNotAuthed.save().then(fail, err => {\n      expect(err.code).toEqual(Parse.Error.SESSION_MISSING);\n      done();\n    });\n  });\n\n  it('cannot delete non-authed user', async done => {\n    let user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    const userAgain = await user.signUp({\n      username: 'hacker',\n      password: 'password',\n    });\n    equal(userAgain, user);\n    userNotAuthed.set('username', 'changed');\n    try {\n      await userNotAuthed.destroy();\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n      done();\n    }\n  });\n\n  it('cannot saveAll with non-authed user', async done => {\n    let user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    const query = new Parse.Query(Parse.User);\n    const userNotAuthed = await query.get(user.id);\n    user = new Parse.User();\n    await user.signUp({\n      username: 'hacker',\n      password: 'password',\n    });\n    const userNotAuthedNotChanged = await query.get(user.id);\n    userNotAuthed.set('username', 'changed');\n    const object = new TestObject();\n    await object.save({\n      user: userNotAuthedNotChanged,\n    });\n    const item1 = new TestObject();\n    await item1.save({\n      number: 0,\n    });\n    item1.set('number', 1);\n    const item2 = new TestObject();\n    item2.set('number', 2);\n    try {\n      await Parse.Object.saveAll([item1, item2, userNotAuthed]);\n      done.fail();\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n      done();\n    }\n  });\n\n  it('never locks himself up', async () => {\n    const user = new Parse.User();\n    await user.signUp({\n      username: 'username',\n      password: 'password',\n    });\n    user.setACL(new Parse.ACL());\n    await user.save();\n    await user.fetch();\n    expect(user.getACL().getReadAccess(user)).toBe(true);\n    expect(user.getACL().getWriteAccess(user)).toBe(true);\n    const publicReadACL = new Parse.ACL();\n    publicReadACL.setPublicReadAccess(true);\n\n    // Create an administrator role with a single admin user\n    const role = new Parse.Role('admin', publicReadACL);\n    const admin = new Parse.User();\n    await admin.signUp({\n      username: 'admin',\n      password: 'admin',\n    });\n    role.getUsers().add(admin);\n    await role.save(null, { useMasterKey: true });\n\n    // Grant the admins write rights on the user\n    const acl = user.getACL();\n    acl.setRoleWriteAccess(role, true);\n    acl.setRoleReadAccess(role, true);\n\n    // Update with the masterKey just to be sure\n    await user.save({ ACL: acl }, { useMasterKey: true });\n\n    // Try to update from admin... should all work fine\n    await user.save({ key: 'fromAdmin' }, { sessionToken: admin.getSessionToken() });\n    await user.fetch();\n    expect(user.toJSON().key).toEqual('fromAdmin');\n\n    // Try to save when logged out (public)\n    let failed = false;\n    try {\n      // Ensure no session token is sent\n      await Parse.User.logOut();\n      await user.save({ key: 'fromPublic' });\n    } catch (e) {\n      failed = true;\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    expect({ failed }).toEqual({ failed: true });\n\n    // Try to save with a random user, should fail\n    failed = false;\n    const anyUser = new Parse.User();\n    await anyUser.signUp({\n      username: 'randomUser',\n      password: 'password',\n    });\n    try {\n      await user.save({ key: 'fromAnyUser' });\n    } catch (e) {\n      failed = true;\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    expect({ failed }).toEqual({ failed: true });\n  });\n\n  it('current user', done => {\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    user\n      .signUp()\n      .then(() => {\n        const currentUser = Parse.User.current();\n        equal(user.id, currentUser.id);\n        ok(user.getSessionToken());\n\n        const currentUserAgain = Parse.User.current();\n        // should be the same object\n        equal(currentUser, currentUserAgain);\n\n        // test logging out the current user\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        equal(Parse.User.current(), null);\n        done();\n      });\n  });\n\n  it('user.isCurrent', done => {\n    const user1 = new Parse.User();\n    const user2 = new Parse.User();\n    const user3 = new Parse.User();\n\n    user1.set('username', 'a');\n    user2.set('username', 'b');\n    user3.set('username', 'c');\n\n    user1.set('password', 'password');\n    user2.set('password', 'password');\n    user3.set('password', 'password');\n\n    user1\n      .signUp()\n      .then(() => {\n        equal(user1.isCurrent(), true);\n        equal(user2.isCurrent(), false);\n        equal(user3.isCurrent(), false);\n        return user2.signUp();\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), true);\n        equal(user3.isCurrent(), false);\n        return user3.signUp();\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), false);\n        equal(user3.isCurrent(), true);\n        return Parse.User.logIn('a', 'password');\n      })\n      .then(() => {\n        equal(user1.isCurrent(), true);\n        equal(user2.isCurrent(), false);\n        equal(user3.isCurrent(), false);\n        return Parse.User.logIn('b', 'password');\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), true);\n        equal(user3.isCurrent(), false);\n        return Parse.User.logIn('b', 'password');\n      })\n      .then(() => {\n        equal(user1.isCurrent(), false);\n        equal(user2.isCurrent(), true);\n        equal(user3.isCurrent(), false);\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        equal(user2.isCurrent(), false);\n        done();\n      });\n  });\n\n  it('user associations', async done => {\n    const child = new TestObject();\n    await child.save();\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    user.set('child', child);\n    await user.signUp();\n    const object = new TestObject();\n    object.set('user', user);\n    await object.save();\n    const query = new Parse.Query(TestObject);\n    const objectAgain = await query.get(object.id);\n    const userAgain = objectAgain.get('user');\n    await userAgain.fetch();\n    equal(user.id, userAgain.id);\n    equal(userAgain.get('child').id, child.id);\n    done();\n  });\n\n  it('user queries', async done => {\n    const user = new Parse.User();\n    user.set('password', 'asdf');\n    user.set('email', 'asdf@example.com');\n    user.set('username', 'zxcv');\n    await user.signUp();\n    const query = new Parse.Query(Parse.User);\n    const userAgain = await query.get(user.id);\n    equal(userAgain.id, user.id);\n    const users = await query.find();\n    equal(users.length, 1);\n    equal(users[0].id, user.id);\n    ok(userAgain.get('email'), 'asdf@example.com');\n    done();\n  });\n\n  function signUpAll(list, optionsOrCallback) {\n    let promise = Promise.resolve();\n    list.forEach(user => {\n      promise = promise.then(function () {\n        return user.signUp();\n      });\n    });\n    promise = promise.then(function () {\n      return list;\n    });\n    return promise.then(optionsOrCallback);\n  }\n\n  it('contained in user array queries', async done => {\n    const USERS = 4;\n    const MESSAGES = 5;\n\n    // Make a list of users.\n    const userList = range(USERS).map(function (i) {\n      const user = new Parse.User();\n      user.set('password', 'user_num_' + i);\n      user.set('email', 'user_num_' + i + '@example.com');\n      user.set('username', 'xinglblog_num_' + i);\n      return user;\n    });\n\n    signUpAll(userList, async function (users) {\n      // Make a list of messages.\n      if (!users || users.length != USERS) {\n        fail('signupAll failed');\n        done();\n        return;\n      }\n      const messageList = range(MESSAGES).map(function (i) {\n        const message = new TestObject();\n        message.set('to', users[(i + 1) % USERS]);\n        message.set('from', users[i % USERS]);\n        return message;\n      });\n\n      // Save all the messages.\n      await Parse.Object.saveAll(messageList);\n\n      // Assemble an \"in\" list.\n      const inList = [users[0], users[3], users[3]]; // Intentional dupe\n      const query = new Parse.Query(TestObject);\n      query.containedIn('from', inList);\n      const results = await query.find();\n      equal(results.length, 3);\n      done();\n    });\n  });\n\n  it(\"saving a user signs them up but doesn't log them in\", async done => {\n    const user = new Parse.User();\n    await user.save({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n    equal(Parse.User.current(), null);\n    done();\n  });\n\n  it('user updates', async done => {\n    const user = new Parse.User();\n    await user.signUp({\n      password: 'asdf',\n      email: 'asdf@example.com',\n      username: 'zxcv',\n    });\n\n    user.set('username', 'test');\n    await user.save();\n    equal(Object.keys(user.attributes).length, 6);\n    ok(user.attributes['username']);\n    ok(user.attributes['email']);\n    await user.destroy();\n    const query = new Parse.Query(Parse.User);\n    try {\n      await query.get(user.id);\n      done.fail();\n    } catch (error) {\n      // The user should no longer exist.\n      equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n      done();\n    }\n  });\n\n  it('count users', async done => {\n    const james = new Parse.User();\n    james.set('username', 'james');\n    james.set('password', 'mypass');\n    await james.signUp();\n    const kevin = new Parse.User();\n    kevin.set('username', 'kevin');\n    kevin.set('password', 'mypass');\n    await kevin.signUp();\n    const query = new Parse.Query(Parse.User);\n    const count = await query.count();\n    equal(count, 2);\n    done();\n  });\n\n  it('user sign up with container class', async done => {\n    await Parse.User.signUp('ilya', 'mypass', { array: ['hello'] });\n    done();\n  });\n\n  it('user modified while saving', done => {\n    Parse.Object.disableSingleInstance();\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'password');\n    user.signUp().then(function (userAgain) {\n      equal(userAgain.get('username'), 'bob');\n      ok(userAgain.dirty('username'));\n      const query = new Parse.Query(Parse.User);\n      query.get(user.id).then(freshUser => {\n        equal(freshUser.id, user.id);\n        equal(freshUser.get('username'), 'alice');\n        done();\n      });\n    });\n    // Jump a frame so the signup call is properly sent\n    // This is due to the fact that now, we use real promises\n    process.nextTick(() => {\n      ok(user.set('username', 'bob'));\n    });\n  });\n\n  it('user modified while saving with unsaved child', done => {\n    Parse.Object.disableSingleInstance();\n    const user = new Parse.User();\n    user.set('username', 'alice');\n    user.set('password', 'password');\n    user.set('child', new TestObject());\n    user.signUp().then(userAgain => {\n      equal(userAgain.get('username'), 'bob');\n      // Should be dirty, but it depends on batch support.\n      // ok(userAgain.dirty(\"username\"));\n      const query = new Parse.Query(Parse.User);\n      query.get(user.id).then(freshUser => {\n        equal(freshUser.id, user.id);\n        // Should be alice, but it depends on batch support.\n        equal(freshUser.get('username'), 'bob');\n        done();\n      });\n    });\n    ok(user.set('username', 'bob'));\n  });\n\n  it('user loaded from localStorage from signup', async done => {\n    const alice = await Parse.User.signUp('alice', 'password');\n    ok(alice.id, 'Alice should have an objectId');\n    ok(alice.getSessionToken(), 'Alice should have a session token');\n    equal(alice.get('password'), undefined, 'Alice should not have a password');\n\n    // Simulate the environment getting reset.\n    Parse.User._currentUser = null;\n    Parse.User._currentUserMatchesDisk = false;\n\n    const aliceAgain = Parse.User.current();\n    equal(aliceAgain.get('username'), 'alice');\n    equal(aliceAgain.id, alice.id, 'currentUser should have objectId');\n    ok(aliceAgain.getSessionToken(), 'currentUser should have a sessionToken');\n    equal(alice.get('password'), undefined, 'currentUser should not have password');\n    done();\n  });\n\n  it('user loaded from localStorage from login', done => {\n    let id;\n    Parse.User.signUp('alice', 'password')\n      .then(alice => {\n        id = alice.id;\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.logIn('alice', 'password');\n      })\n      .then(() => {\n        // Force the current user to read from disk\n        delete Parse.User._currentUser;\n        delete Parse.User._currentUserMatchesDisk;\n\n        const userFromDisk = Parse.User.current();\n        equal(userFromDisk.get('password'), undefined, 'password should not be in attributes');\n        equal(userFromDisk.id, id, 'id should be set');\n        ok(userFromDisk.getSessionToken(), 'currentUser should have a sessionToken');\n        done();\n      });\n  });\n\n  it('saving user after browser refresh', done => {\n    let id;\n\n    Parse.User.signUp('alice', 'password', null)\n      .then(function (alice) {\n        id = alice.id;\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.logIn('alice', 'password');\n      })\n      .then(function () {\n        // Simulate browser refresh by force-reloading user from localStorage\n        Parse.User._clearCache();\n\n        // Test that this save works correctly\n        return Parse.User.current().save({ some_field: 1 });\n      })\n      .then(\n        function () {\n          // Check the user in memory just after save operation\n          const userInMemory = Parse.User.current();\n\n          equal(\n            userInMemory.getUsername(),\n            'alice',\n            'saving user should not remove existing fields'\n          );\n\n          equal(userInMemory.get('some_field'), 1, 'saving user should save specified field');\n\n          equal(\n            userInMemory.get('password'),\n            undefined,\n            'password should not be in attributes after saving user'\n          );\n\n          equal(\n            userInMemory.get('objectId'),\n            undefined,\n            'objectId should not be in attributes after saving user'\n          );\n\n          equal(\n            userInMemory.get('_id'),\n            undefined,\n            '_id should not be in attributes after saving user'\n          );\n\n          equal(userInMemory.id, id, 'id should be set');\n\n          expect(userInMemory.updatedAt instanceof Date).toBe(true);\n\n          ok(userInMemory.createdAt instanceof Date);\n\n          ok(userInMemory.getSessionToken(), 'user should have a sessionToken after saving');\n\n          // Force the current user to read from localStorage, and check again\n          delete Parse.User._currentUser;\n          delete Parse.User._currentUserMatchesDisk;\n          const userFromDisk = Parse.User.current();\n\n          equal(\n            userFromDisk.getUsername(),\n            'alice',\n            'userFromDisk should have previously existing fields'\n          );\n\n          equal(userFromDisk.get('some_field'), 1, 'userFromDisk should have saved field');\n\n          equal(\n            userFromDisk.get('password'),\n            undefined,\n            'password should not be in attributes of userFromDisk'\n          );\n\n          equal(\n            userFromDisk.get('objectId'),\n            undefined,\n            'objectId should not be in attributes of userFromDisk'\n          );\n\n          equal(\n            userFromDisk.get('_id'),\n            undefined,\n            '_id should not be in attributes of userFromDisk'\n          );\n\n          equal(userFromDisk.id, id, 'id should be set on userFromDisk');\n\n          ok(userFromDisk.updatedAt instanceof Date);\n\n          ok(userFromDisk.createdAt instanceof Date);\n\n          ok(userFromDisk.getSessionToken(), 'userFromDisk should have a sessionToken');\n\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('user with missing username', async done => {\n    const user = new Parse.User();\n    user.set('password', 'foo');\n    try {\n      await user.signUp();\n      done.fail();\n    } catch (error) {\n      equal(error.code, Parse.Error.OTHER_CAUSE);\n      done();\n    }\n  });\n\n  it('user with missing password', async done => {\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    try {\n      await user.signUp();\n      done.fail();\n    } catch (error) {\n      equal(error.code, Parse.Error.OTHER_CAUSE);\n      done();\n    }\n  });\n\n  it('user stupid subclassing', async done => {\n    const SuperUser = Parse.Object.extend('User');\n    const user = new SuperUser();\n    user.set('username', 'bob');\n    user.set('password', 'welcome');\n    ok(user instanceof Parse.User, 'Subclassing User should have worked');\n    await user.signUp();\n    done();\n  });\n\n  it('user signup class method uses subclassing', async done => {\n    const SuperUser = Parse.User.extend({\n      secret: function () {\n        return 1337;\n      },\n    });\n\n    const user = await Parse.User.signUp('bob', 'welcome');\n    ok(user instanceof SuperUser, 'Subclassing User should have worked');\n    equal(user.secret(), 1337);\n    done();\n  });\n\n  it('user on disk gets updated after save', async done => {\n    Parse.User.extend({\n      isSuper: function () {\n        return true;\n      },\n    });\n\n    const user = await Parse.User.signUp('bob', 'welcome');\n    await user.save('secret', 1337);\n    delete Parse.User._currentUser;\n    delete Parse.User._currentUserMatchesDisk;\n\n    const userFromDisk = Parse.User.current();\n    equal(userFromDisk.get('secret'), 1337);\n    ok(userFromDisk.isSuper(), 'The subclass should have been used');\n    done();\n  });\n\n  it(\"current user isn't dirty\", async done => {\n    const user = await Parse.User.signUp('andrew', 'oppa', {\n      style: 'gangnam',\n    });\n    ok(!user.dirty('style'), 'The user just signed up.');\n    Parse.User._currentUser = null;\n    Parse.User._currentUserMatchesDisk = false;\n    const userAgain = Parse.User.current();\n    ok(!userAgain.dirty('style'), 'The user was just read from disk.');\n    done();\n  });\n\n  const getMockFacebookProviderWithIdToken = function (id, token) {\n    return {\n      authData: {\n        id: id,\n        access_token: token,\n        expiration_date: new Date().toJSON(),\n      },\n      shouldError: false,\n      loggedOut: false,\n      synchronizedUserId: null,\n      synchronizedAuthToken: null,\n      synchronizedExpiration: null,\n\n      authenticate: function (options) {\n        if (this.shouldError) {\n          options.error(this, 'An error occurred');\n        } else if (this.shouldCancel) {\n          options.error(this, null);\n        } else {\n          options.success(this, this.authData);\n        }\n      },\n      restoreAuthentication: function (authData) {\n        if (!authData) {\n          this.synchronizedUserId = null;\n          this.synchronizedAuthToken = null;\n          this.synchronizedExpiration = null;\n          return true;\n        }\n        this.synchronizedUserId = authData.id;\n        this.synchronizedAuthToken = authData.access_token;\n        this.synchronizedExpiration = authData.expiration_date;\n        return true;\n      },\n      getAuthType: function () {\n        return 'facebook';\n      },\n      deauthenticate: function () {\n        this.loggedOut = true;\n        this.restoreAuthentication(null);\n      },\n    };\n  };\n\n  // Note that this mocks out client-side Facebook action rather than\n  // server-side.\n  const getMockFacebookProvider = function () {\n    return getMockFacebookProviderWithIdToken('8675309', 'jenny');\n  };\n\n  const getMockMyOauthProvider = function () {\n    return {\n      authData: {\n        id: '12345',\n        access_token: '12345',\n        expiration_date: new Date().toJSON(),\n      },\n      shouldError: false,\n      loggedOut: false,\n      synchronizedUserId: null,\n      synchronizedAuthToken: null,\n      synchronizedExpiration: null,\n\n      authenticate: function (options) {\n        if (this.shouldError) {\n          options.error(this, 'An error occurred');\n        } else if (this.shouldCancel) {\n          options.error(this, null);\n        } else {\n          options.success(this, this.authData);\n        }\n      },\n      restoreAuthentication: function (authData) {\n        if (!authData) {\n          this.synchronizedUserId = null;\n          this.synchronizedAuthToken = null;\n          this.synchronizedExpiration = null;\n          return true;\n        }\n        this.synchronizedUserId = authData.id;\n        this.synchronizedAuthToken = authData.access_token;\n        this.synchronizedExpiration = authData.expiration_date;\n        return true;\n      },\n      getAuthType: function () {\n        return 'myoauth';\n      },\n      deauthenticate: function () {\n        this.loggedOut = true;\n        this.restoreAuthentication(null);\n      },\n    };\n  };\n\n  Parse.User.extend({\n    extended: function () {\n      return true;\n    },\n  });\n\n  it('log in with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    done();\n  });\n\n  it('can not set authdata to null', async () => {\n    try {\n      const provider = getMockFacebookProvider();\n      Parse.User._registerAuthenticationProvider(provider);\n      const user = await Parse.User._logInWith('facebook');\n      user.set('authData', null);\n      await user.save();\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('This authentication method is unsupported.');\n    }\n  });\n\n  it('ignore setting authdata to undefined', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    user.set('authData', undefined);\n    await user.save();\n    let authData = user.get('authData');\n    expect(authData).toBe(undefined);\n    await user.fetch();\n    authData = user.get('authData');\n    expect(authData.facebook.id).toBeDefined();\n  });\n\n  it('user authData should be available in cloudcode (#2342)', async done => {\n    Parse.Cloud.define('checkLogin', req => {\n      expect(req.user).not.toBeUndefined();\n      expect(Parse.FacebookUtils.isLinked(req.user)).toBe(true);\n      return 'ok';\n    });\n\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n\n    Parse.Cloud.run('checkLogin').then(done, done);\n  });\n\n  it('log in with provider and update token', async done => {\n    const provider = getMockFacebookProvider();\n    const secondProvider = getMockFacebookProviderWithIdToken('8675309', 'jenny_valid_token');\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    Parse.User._registerAuthenticationProvider(secondProvider);\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    expect(secondProvider.synchronizedAuthToken).toEqual('jenny_valid_token');\n    // Make sure we can login with the new token again\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    done();\n  });\n\n  it('returns authData when authed and logged in with provider (regression test for #1498)', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    const userQuery = new Parse.Query(Parse.User);\n    userQuery.get(user.id).then(user => {\n      expect(user.get('authData')).not.toBeUndefined();\n      done();\n    });\n  });\n\n  it('only creates a single session for an installation / user pair (#2885)', async done => {\n    Parse.Object.disableSingleInstance();\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User.logInWith('facebook');\n    await Parse.User.logInWith('facebook');\n    const user = await Parse.User.logInWith('facebook');\n    const sessionToken = user.getSessionToken();\n    const query = new Parse.Query('_Session');\n    return query\n      .find({ useMasterKey: true })\n      .then(results => {\n        expect(results.length).toBe(1);\n        expect(results[0].get('sessionToken')).toBe(sessionToken);\n        expect(results[0].get('createdWith')).toEqual({\n          action: 'login',\n          authProvider: 'facebook',\n        });\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('log in with provider with files', done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const file = new Parse.File('yolo.txt', [1, 2, 3], 'text/plain');\n    file\n      .save()\n      .then(file => {\n        const user = new Parse.User();\n        user.set('file', file);\n        return user._linkWith('facebook', {});\n      })\n      .then(user => {\n        expect(user._isLinked('facebook')).toBeTruthy();\n        return Parse.User._logInWith('facebook', {});\n      })\n      .then(user => {\n        const fileAgain = user.get('file');\n        expect(fileAgain.name()).toMatch(/yolo.txt$/);\n        expect(fileAgain.url()).toMatch(/yolo.txt$/);\n      })\n      .then(() => {\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('log in with provider twice', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n\n    Parse.User.logOut().then(async () => {\n      ok(provider.loggedOut);\n      provider.loggedOut = false;\n      const innerModel = await Parse.User._logInWith('facebook');\n      ok(innerModel instanceof Parse.User, 'Model should be a Parse.User');\n      ok(innerModel === Parse.User.current(), 'Returned model should be the current user');\n      ok(provider.authData.id === provider.synchronizedUserId);\n      ok(provider.authData.access_token === provider.synchronizedAuthToken);\n      ok(innerModel._isLinked('facebook'), 'User should be linked to facebook');\n      ok(innerModel.existed(), 'User should not be newly-created');\n      done();\n    }, done.fail);\n  });\n\n  it('log in with provider failed', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldError = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    try {\n      await Parse.User._logInWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error, 'Error should be non-null');\n      done();\n    }\n  });\n\n  it('log in with provider cancelled', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldCancel = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    try {\n      await Parse.User._logInWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error === null, 'Error should be null');\n      done();\n    }\n  });\n\n  it('login with provider should not call beforeSave trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    Parse.User.logOut().then(async () => {\n      Parse.Cloud.beforeSave(Parse.User, function (req, res) {\n        res.error(\"Before save shouldn't be called on login\");\n      });\n      await Parse.User._logInWith('facebook');\n      done();\n    });\n  });\n\n  it('signup with provider should not call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n\n    await Parse.User._logInWith('facebook');\n    expect(hit).toBe(0);\n    done();\n  });\n\n  it('login with provider should call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      expect(req.object.get('authData')).toBeDefined();\n      expect(req.object.get('name')).toBe('tupac shakur');\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.current().save({ name: 'tupac shakur' });\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    expect(hit).toBe(1);\n    done();\n  });\n\n  it('incorrect login with provider should not call beforeLogin trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(() => {\n      hit++;\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    provider.shouldError = true;\n    try {\n      await Parse.User._logInWith('facebook');\n    } catch (e) {\n      expect(e).toBeDefined();\n    }\n    expect(hit).toBe(0);\n    done();\n  });\n\n  it('login with provider should be blockable by beforeLogin', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n    await Parse.User._logInWith('facebook');\n    await Parse.User.current().save({ isBanned: true });\n    await Parse.User.logOut();\n\n    try {\n      await Parse.User._logInWith('facebook');\n      throw new Error('should not have continued login.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n\n    expect(hit).toBe(1);\n    done();\n  });\n\n  it('login with provider should be blockable by beforeLogin even when the user has a attached file', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let hit = 0;\n    Parse.Cloud.beforeLogin(req => {\n      hit++;\n      if (req.object.get('isBanned')) {\n        throw new Error('banned account');\n      }\n    });\n\n    const user = await Parse.User._logInWith('facebook');\n    const base64 = 'aHR0cHM6Ly9naXRodWIuY29tL2t2bmt1YW5n';\n    const file = new Parse.File('myfile.txt', { base64 });\n    await file.save();\n    await user.save({ isBanned: true, file });\n    await Parse.User.logOut();\n\n    try {\n      await Parse.User._logInWith('facebook');\n      throw new Error('should not have continued login.');\n    } catch (e) {\n      expect(e.message).toBe('banned account');\n    }\n\n    expect(hit).toBe(1);\n    done();\n  });\n\n  it('logout with provider should call afterLogout trigger', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n\n    let userId;\n    Parse.Cloud.afterLogout(req => {\n      expect(req.object.className).toEqual('_Session');\n      expect(req.object.id).toBeDefined();\n      const user = req.object.get('user');\n      expect(user).toBeDefined();\n      userId = user.id;\n    });\n    const user = await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    expect(user.id).toBe(userId);\n    done();\n  });\n\n  it('link with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const model = await user._linkWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked');\n    done();\n  });\n\n  // What this means is, only one Parse User can be linked to a\n  // particular Facebook account.\n  it('link with provider for already linked user', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProviderToAlreadyLinkedUser');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const model = await user._linkWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked.');\n    const user2 = new Parse.User();\n    user2.set('username', 'testLinkWithProviderToAlreadyLinkedUser2');\n    user2.set('password', 'mypass');\n    await user2.signUp();\n    try {\n      await user2._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      expect(error.code).toEqual(Parse.Error.ACCOUNT_ALREADY_LINKED);\n      done();\n    }\n  });\n\n  it('link with provider should return sessionToken', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const query = new Parse.Query(Parse.User);\n    const u2 = await query.get(user.id);\n    const model = await u2._linkWith('facebook', {}, { useMasterKey: true });\n    expect(u2.getSessionToken()).toBeDefined();\n    expect(model.getSessionToken()).toBeDefined();\n    expect(u2.getSessionToken()).toBe(model.getSessionToken());\n  });\n\n  it('link with provider via sessionToken should not create new sessionToken (Regression #5799)', async () => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProviderNoOverride');\n    user.set('password', 'mypass');\n    await user.signUp();\n    const sessionToken = user.getSessionToken();\n\n    await user._linkWith('facebook', {}, { sessionToken });\n    expect(sessionToken).toBe(user.getSessionToken());\n\n    expect(user._isLinked(provider)).toBe(true);\n    await user._unlinkFrom(provider, { sessionToken });\n    expect(user._isLinked(provider)).toBe(false);\n\n    const become = await Parse.User.become(sessionToken);\n    expect(sessionToken).toBe(become.getSessionToken());\n  });\n\n  it('link with provider failed', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldError = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(error, 'Linking should fail');\n      ok(!user._isLinked('facebook'), 'User should not be linked to facebook');\n      done();\n    }\n  });\n\n  it('link with provider cancelled', async done => {\n    const provider = getMockFacebookProvider();\n    provider.shouldCancel = true;\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (error) {\n      ok(!error, 'Linking should be cancelled');\n      ok(!user._isLinked('facebook'), 'User should not be linked to facebook');\n      done();\n    }\n  });\n\n  it('unlink with provider', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User.');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook.');\n    await model._unlinkFrom('facebook');\n    ok(!model._isLinked('facebook'), 'User should not be linked.');\n    ok(!provider.synchronizedUserId, 'User id should be cleared.');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared.');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared.');\n    done();\n  });\n\n  it('unlink and link', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n\n    await model._unlinkFrom('facebook');\n    ok(!model._isLinked('facebook'), 'User should not be linked to facebook');\n    ok(!provider.synchronizedUserId, 'User id should be cleared');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared');\n\n    await model._linkWith('facebook');\n    ok(provider.synchronizedUserId, 'User id should have a value');\n    ok(provider.synchronizedAuthToken, 'Auth token should have a value');\n    ok(provider.synchronizedExpiration, 'Expiration should have a value');\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    done();\n  });\n\n  it('link multiple providers', async done => {\n    const provider = getMockFacebookProvider();\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    expect(model.id).toEqual(objectId);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    done();\n  });\n\n  it('link multiple providers and updates token', async done => {\n    const provider = getMockFacebookProvider();\n    const secondProvider = getMockFacebookProviderWithIdToken('8675309', 'jenny_valid_token');\n\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    Parse.User._registerAuthenticationProvider(secondProvider);\n    await Parse.User.logOut();\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    const user = await Parse.User._logInWith('myoauth');\n    expect(user.id).toBe(objectId);\n    done();\n  });\n\n  it('link multiple providers and update token', async done => {\n    const provider = getMockFacebookProvider();\n    const mockProvider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    Parse.User._registerAuthenticationProvider(mockProvider);\n    const objectId = model.id;\n    await model._linkWith('myoauth');\n    expect(model.id).toEqual(objectId);\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    await model._linkWith('facebook');\n    ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n    done();\n  });\n\n  it('should fail linking with existing', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    await Parse.User.logOut();\n    const user = new Parse.User();\n    user.setUsername('user');\n    user.setPassword('password');\n    await user.signUp();\n    // try to link here\n    try {\n      await user._linkWith('facebook');\n      done.fail();\n    } catch (e) {\n      done();\n    }\n  });\n\n  it('should fail linking with existing through REST', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('facebook');\n    const userId = model.id;\n    Parse.User.logOut().then(() => {\n      request({\n        method: 'POST',\n        url: Parse.serverURL + '/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json',\n        },\n        body: { authData: { facebook: provider.authData } },\n      }).then(response => {\n        const body = response.data;\n        // make sure the location header is properly set\n        expect(userId).not.toBeUndefined();\n        expect(body.objectId).toEqual(userId);\n        expect(response.headers.location).toEqual(Parse.serverURL + '/users/' + userId);\n        done();\n      });\n    });\n  });\n\n  it('should allow login with old authData token', done => {\n    const provider = {\n      authData: {\n        id: '12345',\n        access_token: 'token',\n      },\n      restoreAuthentication: function () {\n        return true;\n      },\n      deauthenticate: function () {\n        provider.authData = {};\n      },\n      authenticate: function (options) {\n        options.success(this, provider.authData);\n      },\n      getAuthType: function () {\n        return 'shortLivedAuth';\n      },\n    };\n    defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('token');\n    Parse.User._registerAuthenticationProvider(provider);\n    Parse.User._logInWith('shortLivedAuth', {})\n      .then(() => {\n        // Simulate a remotely expired token (like a short lived one)\n        // In this case, we want success as it was valid once.\n        // If the client needs an updated one, do lock the user out\n        defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('otherToken');\n        return Parse.User._logInWith('shortLivedAuth', {});\n      })\n      .then(\n        () => {\n          done();\n        },\n        err => {\n          done.fail(err);\n        }\n      );\n  });\n\n  it('should allow PUT request with stale auth Data', done => {\n    const provider = {\n      authData: {\n        id: '12345',\n        access_token: 'token',\n      },\n      restoreAuthentication: function () {\n        return true;\n      },\n      deauthenticate: function () {\n        provider.authData = {};\n      },\n      authenticate: function (options) {\n        options.success(this, provider.authData);\n      },\n      getAuthType: function () {\n        return 'shortLivedAuth';\n      },\n    };\n    defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('token');\n    Parse.User._registerAuthenticationProvider(provider);\n    Parse.User._logInWith('shortLivedAuth', {})\n      .then(() => {\n        // Simulate a remotely expired token (like a short lived one)\n        // In this case, we want success as it was valid once.\n        // If the client needs an updated one, do lock the user out\n        defaultConfiguration.auth.shortLivedAuth.setValidAccessToken('otherToken');\n        return request({\n          method: 'PUT',\n          url: Parse.serverURL + '/users/' + Parse.User.current().id,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'X-Parse-Session-Token': Parse.User.current().getSessionToken(),\n            'Content-Type': 'application/json',\n          },\n          body: {\n            key: 'value', // update a key\n            authData: {\n              // pass the original auth data\n              shortLivedAuth: {\n                id: '12345',\n                access_token: 'token',\n              },\n            },\n          },\n        });\n      })\n      .then(\n        () => {\n          done();\n        },\n        err => {\n          done.fail(err);\n        }\n      );\n  });\n\n  it('should properly error when password is missing', async done => {\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const user = await Parse.User._logInWith('facebook');\n    user.set('username', 'myUser');\n    user.set('email', 'foo@example.com');\n    user\n      .save()\n      .then(() => {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.logIn('myUser', 'password');\n      })\n      .then(\n        () => {\n          fail('should not succeed');\n          done();\n        },\n        err => {\n          expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n          expect(err.message).toEqual('Invalid username/password.');\n          done();\n        }\n      );\n  });\n\n  it('should have authData in beforeSave and afterSave', async done => {\n    Parse.Cloud.beforeSave('_User', request => {\n      const authData = request.object.get('authData');\n      expect(authData).not.toBeUndefined();\n      if (authData) {\n        expect(authData.facebook.id).toEqual('8675309');\n        expect(authData.facebook.access_token).toEqual('jenny');\n      } else {\n        fail('authData should be set');\n      }\n    });\n\n    Parse.Cloud.afterSave('_User', request => {\n      const authData = request.object.get('authData');\n      expect(authData).not.toBeUndefined();\n      if (authData) {\n        expect(authData.facebook.id).toEqual('8675309');\n        expect(authData.facebook.access_token).toEqual('jenny');\n      } else {\n        fail('authData should be set');\n      }\n    });\n\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    await Parse.User._logInWith('facebook');\n    done();\n  });\n\n  it('set password then change password', done => {\n    Parse.User.signUp('bob', 'barker')\n      .then(bob => {\n        bob.setPassword('meower');\n        return bob.save();\n      })\n      .then(() => {\n        return Parse.User.logIn('bob', 'meower');\n      })\n      .then(\n        bob => {\n          expect(bob.getUsername()).toEqual('bob');\n          done();\n        },\n        e => {\n          console.log(e);\n          fail();\n        }\n      );\n  });\n\n  it('authenticated check', async done => {\n    const user = new Parse.User();\n    user.set('username', 'darkhelmet');\n    user.set('password', 'onetwothreefour');\n    ok(!user.authenticated());\n    await user.signUp(null);\n    ok(user.authenticated());\n    done();\n  });\n\n  it('log in with explicit facebook auth data', async done => {\n    await Parse.FacebookUtils.logIn({\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    });\n    done();\n  });\n\n  it('log in async with explicit facebook auth data', done => {\n    Parse.FacebookUtils.logIn({\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(\n      function () {\n        done();\n      },\n      function (error) {\n        ok(false, error);\n        done();\n      }\n    );\n  });\n\n  it('link with explicit facebook auth data', async done => {\n    const user = await Parse.User.signUp('mask', 'open sesame');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(done, error => {\n      jfail(error);\n      done();\n    });\n  });\n\n  it('link async with explicit facebook auth data', async done => {\n    const user = await Parse.User.signUp('mask', 'open sesame');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(\n      function () {\n        done();\n      },\n      function (error) {\n        ok(false, error);\n        done();\n      }\n    );\n  });\n\n  it('async methods', done => {\n    const data = { foo: 'bar' };\n\n    Parse.User.signUp('finn', 'human', data)\n      .then(function (user) {\n        equal(Parse.User.current(), user);\n        equal(user.get('foo'), 'bar');\n        return Parse.User.logOut();\n      })\n      .then(function () {\n        return Parse.User.logIn('finn', 'human');\n      })\n      .then(function (user) {\n        equal(user, Parse.User.current());\n        equal(user.get('foo'), 'bar');\n        return Parse.User.logOut();\n      })\n      .then(function () {\n        const user = new Parse.User();\n        user.set('username', 'jake');\n        user.set('password', 'dog');\n        user.set('foo', 'baz');\n        return user.signUp();\n      })\n      .then(function (user) {\n        equal(user, Parse.User.current());\n        equal(user.get('foo'), 'baz');\n        user = new Parse.User();\n        user.set('username', 'jake');\n        user.set('password', 'dog');\n        return user.logIn();\n      })\n      .then(function (user) {\n        equal(user, Parse.User.current());\n        equal(user.get('foo'), 'baz');\n        const userAgain = new Parse.User();\n        userAgain.id = user.id;\n        return userAgain.fetch();\n      })\n      .then(function (userAgain) {\n        equal(userAgain.get('foo'), 'baz');\n        done();\n      });\n  });\n\n  it(\"querying for users doesn't get session tokens\", done => {\n    Parse.User.signUp('finn', 'human', { foo: 'bar' })\n      .then(function () {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        const user = new Parse.User();\n        user.set('username', 'jake');\n        user.set('password', 'dog');\n        user.set('foo', 'baz');\n        return user.signUp();\n      })\n      .then(function () {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        const query = new Parse.Query(Parse.User);\n        return query.find({ sessionToken: null });\n      })\n      .then(\n        function (users) {\n          equal(users.length, 2);\n          users.forEach(user => {\n            expect(user.getSessionToken()).toBeUndefined();\n            ok(!user.getSessionToken(), 'user should not have a session token.');\n          });\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('querying for users only gets the expected fields', done => {\n    Parse.User.signUp('finn', 'human', { foo: 'bar' }).then(() => {\n      request({\n        headers: {\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n        },\n        url: 'http://localhost:8378/1/users',\n      }).then(response => {\n        const b = response.data;\n        expect(b.results.length).toEqual(1);\n        const user = b.results[0];\n        expect(Object.keys(user).length).toEqual(6);\n        done();\n      });\n    });\n  });\n\n  it(\"retrieve user data from fetch, make sure the session token hasn't changed\", done => {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n    let currentSessionToken = '';\n    Promise.resolve()\n      .then(function () {\n        return user.signUp();\n      })\n      .then(function () {\n        currentSessionToken = user.getSessionToken();\n        return user.fetch();\n      })\n      .then(\n        function (u) {\n          expect(currentSessionToken).toEqual(u.getSessionToken());\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n  });\n\n  it('user save should fail with invalid email', done => {\n    const user = new Parse.User();\n    user.set('username', 'teste');\n    user.set('password', 'test');\n    user.set('email', 'invalid');\n    user.signUp().then(\n      () => {\n        fail('Should not have been able to save.');\n        done();\n      },\n      error => {\n        expect(error.code).toEqual(125);\n        done();\n      }\n    );\n  });\n\n  it('user signup should error if email taken', done => {\n    const user = new Parse.User();\n    user.set('username', 'test1');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user\n      .signUp()\n      .then(() => {\n        const user2 = new Parse.User();\n        user2.set('username', 'test2');\n        user2.set('password', 'test');\n        user2.set('email', 'test@test.com');\n        return user2.signUp();\n      })\n      .then(\n        () => {\n          fail('Should not have been able to sign up.');\n          done();\n        },\n        () => {\n          done();\n        }\n      );\n  });\n\n  describe('case insensitive signup not allowed', () => {\n    it('signup should fail with duplicate case insensitive username with basic setter', async () => {\n      const user = new Parse.User();\n      user.set('username', 'test1');\n      user.set('password', 'test');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.set('username', 'Test1');\n      user2.set('password', 'test');\n      await expectAsync(user2.signUp()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.')\n      );\n    });\n\n    it('signup should fail with duplicate case insensitive username with field specific setter', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.setUsername('Test1');\n      user2.setPassword('test');\n      await expectAsync(user2.signUp()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.')\n      );\n    });\n\n    it('signup should fail with duplicate case insensitive email', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      user.setEmail('test@example.com');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.setUsername('test2');\n      user2.setPassword('test');\n      user2.setEmail('Test@Example.Com');\n      await expectAsync(user2.signUp()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.')\n      );\n    });\n\n    it('edit should fail with duplicate case insensitive email', async () => {\n      const user = new Parse.User();\n      user.setUsername('test1');\n      user.setPassword('test');\n      user.setEmail('test@example.com');\n      await user.signUp();\n\n      const user2 = new Parse.User();\n      user2.setUsername('test2');\n      user2.setPassword('test');\n      user2.setEmail('Foo@Example.Com');\n      await user2.signUp();\n\n      user2.setEmail('Test@Example.Com');\n      await expectAsync(user2.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.')\n      );\n    });\n\n    describe('anonymous users', () => {\n      beforeEach(() => {\n        const insensitiveCollisions = [\n          'abcdefghijklmnop',\n          'Abcdefghijklmnop',\n          'ABcdefghijklmnop',\n          'ABCdefghijklmnop',\n          'ABCDefghijklmnop',\n          'ABCDEfghijklmnop',\n          'ABCDEFghijklmnop',\n          'ABCDEFGhijklmnop',\n          'ABCDEFGHijklmnop',\n          'ABCDEFGHIjklmnop',\n          'ABCDEFGHIJklmnop',\n          'ABCDEFGHIJKlmnop',\n          'ABCDEFGHIJKLmnop',\n          'ABCDEFGHIJKLMnop',\n          'ABCDEFGHIJKLMnop',\n          'ABCDEFGHIJKLMNop',\n          'ABCDEFGHIJKLMNOp',\n          'ABCDEFGHIJKLMNOP',\n        ];\n\n        // need a bunch of spare random strings per api request\n        spyOn(cryptoUtils, 'randomString').and.returnValues(...insensitiveCollisions);\n      });\n\n      it('should not fail on case insensitive matches', async () => {\n        const user1 = await Parse.AnonymousUtils.logIn();\n        const username1 = user1.get('username');\n\n        const user2 = await Parse.AnonymousUtils.logIn();\n        const username2 = user2.get('username');\n\n        expect(username1).not.toBeUndefined();\n        expect(username2).not.toBeUndefined();\n        expect(username1.toLowerCase()).toBe('abcdefghijklmnop');\n        expect(username2.toLowerCase()).toBe('abcdefghijklmnop');\n        expect(username2).not.toBe(username1);\n        expect(username2.toLowerCase()).toBe(username1.toLowerCase()); // this is redundant :).\n      });\n    });\n  });\n\n  it('user cannot update email to existing user', done => {\n    const user = new Parse.User();\n    user.set('username', 'test1');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user\n      .signUp()\n      .then(() => {\n        const user2 = new Parse.User();\n        user2.set('username', 'test2');\n        user2.set('password', 'test');\n        return user2.signUp();\n      })\n      .then(user2 => {\n        user2.set('email', 'test@test.com');\n        return user2.save();\n      })\n      .then(\n        () => {\n          fail('Should not have been able to sign up.');\n          done();\n        },\n        () => {\n          done();\n        }\n      );\n  });\n\n  it('unset user email', done => {\n    const user = new Parse.User();\n    user.set('username', 'test');\n    user.set('password', 'test');\n    user.set('email', 'test@test.com');\n    user\n      .signUp()\n      .then(() => {\n        user.unset('email');\n        return user.save();\n      })\n      .then(() => {\n        return Parse.User.logIn('test', 'test');\n      })\n      .then(user => {\n        expect(user.getEmail()).toBeUndefined();\n        done();\n      });\n  });\n\n  it('create session from user', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          method: 'POST',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          expect(typeof b.sessionToken).toEqual('string');\n          expect(typeof b.createdWith).toEqual('object');\n          expect(b.createdWith.action).toEqual('create');\n          expect(typeof b.user).toEqual('object');\n          expect(b.user.objectId).toEqual(user.id);\n          done();\n        });\n      });\n  });\n\n  it('user get session from token on signup', async () => {\n    const user = await Parse.User.signUp('finn', 'human', { foo: 'bar' });\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Session-Token': user.getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest',\n      },\n      url: 'http://localhost:8378/1/sessions/me',\n    });\n    const data = response.data;\n    expect(typeof data.sessionToken).toEqual('string');\n    expect(typeof data.createdWith).toEqual('object');\n    expect(data.createdWith.action).toEqual('signup');\n    expect(data.createdWith.authProvider).toEqual('password');\n    expect(typeof data.user).toEqual('object');\n    expect(data.user.objectId).toEqual(user.id);\n  });\n\n  it('user get session from token on username/password login', async () => {\n    await Parse.User.signUp('finn', 'human', { foo: 'bar' });\n    await Parse.User.logOut();\n    const user = await Parse.User.logIn('finn', 'human');\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Session-Token': user.getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest',\n      },\n      url: 'http://localhost:8378/1/sessions/me',\n    });\n    const data = response.data;\n    expect(typeof data.sessionToken).toEqual('string');\n    expect(typeof data.createdWith).toEqual('object');\n    expect(data.createdWith.action).toEqual('login');\n    expect(data.createdWith.authProvider).toEqual('password');\n    expect(typeof data.user).toEqual('object');\n    expect(data.user.objectId).toEqual(user.id);\n  });\n\n  it('user get session from token on anonymous login', async () => {\n    const user = await Parse.AnonymousUtils.logIn();\n    const response = await request({\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Session-Token': user.getSessionToken(),\n        'X-Parse-REST-API-Key': 'rest',\n      },\n      url: 'http://localhost:8378/1/sessions/me',\n    });\n    const data = response.data;\n    expect(typeof data.sessionToken).toEqual('string');\n    expect(typeof data.createdWith).toEqual('object');\n    expect(data.createdWith.action).toEqual('login');\n    expect(data.createdWith.authProvider).toEqual('anonymous');\n    expect(typeof data.user).toEqual('object');\n    expect(data.user.objectId).toEqual(user.id);\n  });\n\n  it('user update session with other field', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions/me',\n        }).then(response => {\n          const b = response.data;\n          request({\n            method: 'PUT',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': user.getSessionToken(),\n              'X-Parse-REST-API-Key': 'rest',\n            },\n            url: 'http://localhost:8378/1/sessions/' + b.objectId,\n            body: JSON.stringify({ foo: 'bar' }),\n          }).then(() => {\n            done();\n          });\n        });\n      });\n  });\n\n  it('cannot update session if invalid or no session token', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('finn', 'human', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions/me',\n        }).then(response => {\n          const b = response.data;\n          request({\n            method: 'PUT',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': 'foo',\n              'X-Parse-REST-API-Key': 'rest',\n              'Content-Type': 'application/json',\n            },\n            url: 'http://localhost:8378/1/sessions/' + b.objectId,\n            body: JSON.stringify({ foo: 'bar' }),\n          }).then(fail, response => {\n            const b = response.data;\n            expect(b.error).toBe('Invalid session token');\n            request({\n              method: 'PUT',\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: 'http://localhost:8378/1/sessions/' + b.objectId,\n              body: JSON.stringify({ foo: 'bar' }),\n            }).then(fail, response => {\n              const b = response.data;\n              expect(b.error).toBe('Session token required.');\n              done();\n            });\n          });\n        });\n      });\n  });\n\n  it('get session only for current user', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('test1', 'test', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.signUp('test2', 'test', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          expect(b.results.length).toEqual(1);\n          expect(typeof b.results[0].user).toEqual('object');\n          expect(b.results[0].user.objectId).toEqual(user.id);\n          done();\n        });\n      });\n  });\n\n  it('delete session by object', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('test1', 'test', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.signUp('test2', 'test', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          let objId;\n          try {\n            expect(b.results.length).toEqual(1);\n            objId = b.results[0].objectId;\n          } catch (e) {\n            jfail(e);\n            done();\n            return;\n          }\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Session-Token': user.getSessionToken(),\n              'X-Parse-REST-API-Key': 'rest',\n            },\n            url: 'http://localhost:8378/1/sessions/' + objId,\n          }).then(() => {\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-Session-Token': user.getSessionToken(),\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: 'http://localhost:8378/1/sessions',\n            }).then(fail, response => {\n              const b = response.data;\n              expect(b.code).toEqual(209);\n              expect(b.error).toBe('Invalid session token');\n              done();\n            });\n          });\n        });\n      });\n  });\n\n  it('cannot delete session if no sessionToken', done => {\n    Promise.resolve()\n      .then(() => {\n        return Parse.User.signUp('test1', 'test', { foo: 'bar' });\n      })\n      .then(() => {\n        return Parse.User.signUp('test2', 'test', { foo: 'bar' });\n      })\n      .then(user => {\n        request({\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Session-Token': user.getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/sessions',\n        }).then(response => {\n          const b = response.data;\n          expect(b.results.length).toEqual(1);\n          const objId = b.results[0].objectId;\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n            },\n            url: 'http://localhost:8378/1/sessions/' + objId,\n          }).then(fail, response => {\n            const b = response.data;\n            expect(b.code).toEqual(209);\n            expect(b.error).toBe('Invalid session token');\n            done();\n          });\n        });\n      });\n  });\n\n  it('password format matches hosted parse', done => {\n    const hashed = '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie';\n    passwordCrypto.compare('test', hashed).then(\n      pass => {\n        expect(pass).toBe(true);\n        done();\n      },\n      () => {\n        fail('Password format did not match.');\n        done();\n      }\n    );\n  });\n\n  it('changing password clears sessions', done => {\n    let sessionToken = null;\n\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('fosco', 'parse');\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n        sessionToken = newUser.getSessionToken();\n        ok(sessionToken);\n        newUser.set('password', 'facebook');\n        return newUser.save();\n      })\n      .then(function () {\n        return Parse.User.become(sessionToken);\n      })\n      .then(\n        function () {\n          fail('Session should have been invalidated');\n          done();\n        },\n        function (err) {\n          expect(err.code).toBe(Parse.Error.INVALID_SESSION_TOKEN);\n          expect(err.message).toBe('Invalid session token');\n          done();\n        }\n      );\n  });\n\n  it('test parse user become', done => {\n    let sessionToken = null;\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('flessard', 'folo', { foo: 1 });\n      })\n      .then(function (newUser) {\n        equal(Parse.User.current(), newUser);\n        sessionToken = newUser.getSessionToken();\n        ok(sessionToken);\n        newUser.set('foo', 2);\n        return newUser.save();\n      })\n      .then(function () {\n        return Parse.User.become(sessionToken);\n      })\n      .then(\n        function (newUser) {\n          equal(newUser.get('foo'), 2);\n          done();\n        },\n        function () {\n          fail('The session should still be valid');\n          done();\n        }\n      );\n  });\n\n  it('ensure logout works', done => {\n    let user = null;\n    let sessionToken = null;\n\n    Promise.resolve()\n      .then(function () {\n        return Parse.User.signUp('log', 'out');\n      })\n      .then(newUser => {\n        user = newUser;\n        sessionToken = user.getSessionToken();\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        user.set('foo', 'bar');\n        return user.save(null, { sessionToken: sessionToken });\n      })\n      .then(\n        () => {\n          fail('Save should have failed.');\n          done();\n        },\n        e => {\n          expect(e.code).toEqual(Parse.Error.INVALID_SESSION_TOKEN);\n          done();\n        }\n      );\n  });\n\n  it('support user/password signup with empty authData block', done => {\n    // The android SDK can send an empty authData object along with username and password.\n    Parse.User.signUp('artof', 'thedeal', { authData: {} }).then(\n      () => {\n        done();\n      },\n      () => {\n        fail('Signup should have succeeded.');\n        done();\n      }\n    );\n  });\n\n  it('session expiresAt correct format', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      url: 'http://localhost:8378/1/classes/_Session',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test',\n      },\n    }).then(response => {\n      const body = response.data;\n      expect(body.results[0].expiresAt.__type).toEqual('Date');\n      done();\n    });\n  });\n\n  it('Invalid session tokens are rejected', async done => {\n    await Parse.User.signUp('asdf', 'zxcv');\n    request({\n      url: 'http://localhost:8378/1/classes/AClass',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Rest-API-Key': 'rest',\n        'X-Parse-Session-Token': 'text',\n      },\n    }).then(fail, response => {\n      const body = response.data;\n      expect(body.code).toBe(209);\n      expect(body.error).toBe('Invalid session token');\n      done();\n    });\n  });\n\n  it_exclude_dbs(['postgres'])(\n    'should cleanup null authData keys (regression test for #935)',\n    done => {\n      const database = Config.get(Parse.applicationId).database;\n      database\n        .create(\n          '_User',\n          {\n            username: 'user',\n            _hashed_password: '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie',\n            _auth_data_facebook: null,\n          },\n          {}\n        )\n        .then(() => {\n          return request({\n            url: 'http://localhost:8378/1/login?username=user&password=test',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-Master-Key': 'test',\n            },\n          }).then(res => res.data);\n        })\n        .then(user => {\n          const authData = user.authData;\n          expect(user.username).toEqual('user');\n          expect(authData).toBeUndefined();\n          done();\n        })\n        .catch(() => {\n          fail('this should not fail');\n          done();\n        });\n    }\n  );\n\n  it_exclude_dbs(['postgres'])('should not serve null authData keys', done => {\n    const database = Config.get(Parse.applicationId).database;\n    database\n      .create(\n        '_User',\n        {\n          username: 'user',\n          _hashed_password: '$2a$10$8/wZJyEuiEaobBBqzTG.jeY.XSFJd0rzaN//ososvEI4yLqI.4aie',\n          _auth_data_facebook: null,\n        },\n        {}\n      )\n      .then(() => {\n        return new Parse.Query(Parse.User)\n          .equalTo('username', 'user')\n          .first({ useMasterKey: true });\n      })\n      .then(user => {\n        const authData = user.get('authData');\n        expect(user.get('username')).toEqual('user');\n        expect(authData).toBeUndefined();\n        done();\n      })\n      .catch(() => {\n        fail('this should not fail');\n        done();\n      });\n  });\n\n  it('should cleanup null authData keys ParseUser update (regression test for #1198, #2252)', done => {\n    Parse.Cloud.beforeSave('_User', req => {\n      req.object.set('foo', 'bar');\n    });\n\n    let originalSessionToken;\n    let originalUserId;\n    // Simulate anonymous user save\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    })\n      .then(response => response.data)\n      .then(user => {\n        originalSessionToken = user.sessionToken;\n        originalUserId = user.objectId;\n        // Simulate registration\n        return request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/classes/_User/' + user.objectId,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': user.sessionToken,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n          body: {\n            authData: { anonymous: null },\n            username: 'user',\n            password: 'password',\n          },\n        }).then(response => {\n          return response.data;\n        });\n      })\n      .then(user => {\n        expect(typeof user).toEqual('object');\n        expect(user.authData).toBeUndefined();\n        expect(user.sessionToken).not.toBeUndefined();\n        // Session token should have changed\n        expect(user.sessionToken).not.toEqual(originalSessionToken);\n        // test that the sessionToken is valid\n        return request({\n          url: 'http://localhost:8378/1/users/me',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': user.sessionToken,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n        }).then(response => {\n          const body = response.data;\n          expect(body.username).toEqual('user');\n          expect(body.objectId).toEqual(originalUserId);\n          done();\n        });\n      })\n      .catch(err => {\n        fail('no request should fail: ' + JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should send email when upgrading from anon', done => {\n    let emailCalled = false;\n    let emailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        emailOptions = options;\n        emailCalled = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    });\n    // Simulate anonymous user save\n    return request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    })\n      .then(response => {\n        const user = response.data;\n        return request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/classes/_User/' + user.objectId,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': user.sessionToken,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n          body: {\n            authData: { anonymous: null },\n            username: 'user',\n            email: 'user@email.com',\n            password: 'password',\n          },\n        });\n      })\n      .then(() => {\n        expect(emailCalled).toBe(true);\n        expect(emailOptions).not.toBeUndefined();\n        expect(emailOptions.user.get('email')).toEqual('user@email.com');\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        fail('no request should fail: ' + JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not send email when email is not a string', async done => {\n    let emailCalled = false;\n    let emailOptions;\n    const emailAdapter = {\n      sendVerificationEmail: options => {\n        emailOptions = options;\n        emailCalled = true;\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n    await reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    });\n    const user = new Parse.User();\n    user.set('username', 'asdf@jkl.com');\n    user.set('password', 'zxcv');\n    user.set('email', 'asdf@jkl.com');\n    await user.signUp();\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/requestPasswordReset',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-Session-Token': user.sessionToken,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        email: { $regex: '^asd' },\n      },\n    })\n      .then(res => {\n        fail('no request should succeed: ' + JSON.stringify(res));\n        done();\n      })\n      .catch(err => {\n        expect(emailCalled).toBeTruthy();\n        expect(emailOptions).toBeDefined();\n        expect(err.status).toBe(400);\n        expect(err.text).toMatch('{\"code\":125,\"error\":\"you must provide a valid email string\"}');\n        done();\n      });\n  });\n\n  it('should aftersave with full object', done => {\n    let hit = 0;\n    Parse.Cloud.afterSave('_User', (req, res) => {\n      hit++;\n      expect(req.object.get('username')).toEqual('User');\n      res.success();\n    });\n    const user = new Parse.User();\n    user.setUsername('User');\n    user.setPassword('pass');\n    user\n      .signUp()\n      .then(() => {\n        user.set('hello', 'world');\n        return user.save();\n      })\n      .then(() => {\n        expect(hit).toBe(2);\n        done();\n      });\n  });\n\n  it('changes to a user should update the cache', done => {\n    Parse.Cloud.define('testUpdatedUser', req => {\n      expect(req.user.get('han')).toEqual('solo');\n      return {};\n    });\n    const user = new Parse.User();\n    user.setUsername('harrison');\n    user.setPassword('ford');\n    user\n      .signUp()\n      .then(() => {\n        user.set('han', 'solo');\n        return user.save();\n      })\n      .then(() => {\n        return Parse.Cloud.run('testUpdatedUser');\n      })\n      .then(\n        () => {\n          done();\n        },\n        () => {\n          fail('Should not have failed.');\n          done();\n        }\n      );\n  });\n\n  it('should fail to become user with expired token', done => {\n    let token;\n    Parse.User.signUp('auser', 'somepass', null)\n      .then(() =>\n        request({\n          method: 'GET',\n          url: 'http://localhost:8378/1/classes/_Session',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Master-Key': 'test',\n          },\n        })\n      )\n      .then(response => {\n        const body = response.data;\n        const id = body.results[0].objectId;\n        const expiresAt = new Date(new Date().setYear(2015));\n        token = body.results[0].sessionToken;\n        return request({\n          method: 'PUT',\n          url: 'http://localhost:8378/1/classes/_Session/' + id,\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-Master-Key': 'test',\n            'Content-Type': 'application/json',\n          },\n          body: {\n            expiresAt: { __type: 'Date', iso: expiresAt.toISOString() },\n          },\n        });\n      })\n      .then(() => Parse.User.become(token))\n      .then(\n        () => {\n          fail('Should not have succeded');\n          done();\n        },\n        error => {\n          expect(error.code).toEqual(209);\n          expect(error.message).toEqual('Session token is expired.');\n          done();\n        }\n      )\n      .catch(done.fail);\n  });\n\n  it('should not create extraneous session tokens', done => {\n    const config = Config.get(Parse.applicationId);\n    config.database\n      .loadSchema()\n      .then(s => {\n        // Lock down the _User class for creation\n        return s.addClassIfNotExists('_User', {}, { create: {} });\n      })\n      .then(() => {\n        const user = new Parse.User();\n        return user.save({ username: 'user', password: 'pass' });\n      })\n      .then(\n        () => {\n          fail('should not be able to save the user');\n        },\n        () => {\n          return Promise.resolve();\n        }\n      )\n      .then(() => {\n        const q = new Parse.Query('_Session');\n        return q.find({ useMasterKey: true });\n      })\n      .then(\n        res => {\n          // We should have no session created\n          expect(res.length).toBe(0);\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('should not overwrite username when unlinking facebook user (regression test for #1532)', async done => {\n    Parse.Object.disableSingleInstance();\n    const provider = getMockFacebookProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    let user = new Parse.User();\n    user.set('username', 'testLinkWithProvider');\n    user.set('password', 'mypass');\n    await user.signUp();\n    await user._linkWith('facebook');\n    expect(user.get('username')).toEqual('testLinkWithProvider');\n    expect(Parse.FacebookUtils.isLinked(user)).toBeTruthy();\n    await user._unlinkFrom('facebook');\n    user = await user.fetch();\n    expect(user.get('username')).toEqual('testLinkWithProvider');\n    expect(Parse.FacebookUtils.isLinked(user)).toBeFalsy();\n    done();\n  });\n\n  it('should revoke sessions when converting anonymous user to \"normal\" user', done => {\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        authData: {\n          anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n        },\n      },\n    }).then(response => {\n      const body = response.data;\n      Parse.User.become(body.sessionToken).then(user => {\n        const obj = new Parse.Object('TestObject');\n        obj.setACL(new Parse.ACL(user));\n        return obj\n          .save()\n          .then(() => {\n            // Change password, revoking session\n            user.set('username', 'no longer anonymous');\n            user.set('password', 'password');\n            return user.save();\n          })\n          .then(() => {\n            // Session token should have been recycled\n            expect(body.sessionToken).not.toEqual(user.getSessionToken());\n          })\n          .then(() => obj.fetch())\n          .then(() => {\n            done();\n          })\n          .catch(() => {\n            fail('should not fail');\n            done();\n          });\n      });\n    });\n  });\n\n  it('should not revoke session tokens if the server is configures to not revoke session tokens', done => {\n    reconfigureServer({ revokeSessionOnPasswordReset: false }).then(() => {\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/_User',\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'Content-Type': 'application/json',\n        },\n        body: {\n          authData: {\n            anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n          },\n        },\n      }).then(response => {\n        const body = response.data;\n        Parse.User.become(body.sessionToken).then(user => {\n          const obj = new Parse.Object('TestObject');\n          obj.setACL(new Parse.ACL(user));\n          return (\n            obj\n              .save()\n              .then(() => {\n                // Change password, revoking session\n                user.set('username', 'no longer anonymous');\n                user.set('password', 'password');\n                return user.save();\n              })\n              .then(() => obj.fetch())\n              // fetch should succeed as we still have our session token\n              .then(done, fail)\n          );\n        });\n      });\n    });\n  });\n\n  it('should not fail querying non existing relations', done => {\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n    });\n    user\n      .signUp()\n      .then(() => {\n        return Parse.User.current().relation('relation').query().find();\n      })\n      .then(res => {\n        expect(res.length).toBe(0);\n        done();\n      })\n      .catch(err => {\n        fail(JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not allow updates to emailVerified', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() => {\n        return Parse.User.current().set('emailVerified', true).save();\n      })\n      .then(() => {\n        fail('Should not be able to update emailVerified');\n        done();\n      })\n      .catch(err => {\n        expect(err.message).toBe(\"Clients aren't allowed to manually update email verification.\");\n        done();\n      });\n  });\n\n  it('should not retrieve hidden fields on GET users/me (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() =>\n        request({\n          method: 'GET',\n          url: 'http://localhost:8378/1/users/me',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Session-Token': Parse.User.current().getSessionToken(),\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        })\n      )\n      .then(response => {\n        const res = response.data;\n        expect(res.emailVerified).toBe(false);\n        expect(res._email_verify_token).toBeUndefined();\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('should not retrieve hidden fields on GET users/id (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() =>\n        request({\n          method: 'GET',\n          url: 'http://localhost:8378/1/users/' + Parse.User.current().id,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        })\n      )\n      .then(response => {\n        const res = response.data;\n        expect(res.emailVerified).toBe(false);\n        expect(res._email_verify_token).toBeUndefined();\n        done();\n      })\n      .catch(err => {\n        fail(JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not retrieve hidden fields on login (#3432)', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() =>\n        request({\n          url: 'http://localhost:8378/1/login?email=test@email.com&username=hello&password=world',\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        })\n      )\n      .then(response => {\n        const res = response.data;\n        expect(res.emailVerified).toBe(false);\n        expect(res._email_verify_token).toBeUndefined();\n        done();\n      })\n      .catch(err => {\n        fail(JSON.stringify(err));\n        done();\n      });\n  });\n\n  it('should not allow updates to hidden fields', done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n\n    const user = new Parse.User();\n    user.set({\n      username: 'hello',\n      password: 'world',\n      email: 'test@email.com',\n    });\n\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    })\n      .then(() => {\n        return user.signUp();\n      })\n      .then(() => {\n        return Parse.User.current().set('_email_verify_token', 'bad').save();\n      })\n      .then(() => {\n        fail('Should not be able to update email verification token');\n        done();\n      })\n      .catch(err => {\n        expect(err).toBeDefined();\n        done();\n      });\n  });\n\n  it('should revoke sessions when setting paswword with masterKey (#3289)', done => {\n    let user;\n    Parse.User.signUp('username', 'password')\n      .then(newUser => {\n        user = newUser;\n        user.set('password', 'newPassword');\n        return user.save(null, { useMasterKey: true });\n      })\n      .then(() => {\n        const query = new Parse.Query('_Session');\n        query.equalTo('user', user);\n        return query.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(0);\n        done();\n      }, done.fail);\n  });\n\n  xit('should not send a verification email if the user signed up using oauth', done => {\n    let emailCalledCount = 0;\n    const emailAdapter = {\n      sendVerificationEmail: () => {\n        emailCalledCount++;\n        return Promise.resolve();\n      },\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => Promise.resolve(),\n    };\n    reconfigureServer({\n      appName: 'unused',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      publicServerURL: 'http://localhost:8378/1',\n    });\n    const user = new Parse.User();\n    user.set('email', 'email1@host.com');\n    Parse.FacebookUtils.link(user, {\n      id: '8675309',\n      access_token: 'jenny',\n      expiration_date: new Date().toJSON(),\n    }).then(user => {\n      user.set('email', 'email2@host.com');\n      user.save().then(() => {\n        expect(emailCalledCount).toBe(0);\n        done();\n      });\n    });\n  }).pend('this test fails.  See: https://github.com/parse-community/parse-server/issues/5097');\n\n  it('should be able to update user with authData passed', done => {\n    let objectId;\n    let sessionToken;\n\n    function validate(block) {\n      return request({\n        url: `http://localhost:8378/1/classes/_User/${objectId}`,\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-REST-API-Key': 'rest',\n          'X-Parse-Session-Token': sessionToken,\n        },\n      }).then(response => block(response.data));\n    }\n\n    request({\n      method: 'POST',\n      url: 'http://localhost:8378/1/classes/_User',\n      headers: {\n        'X-Parse-Application-Id': Parse.applicationId,\n        'X-Parse-REST-API-Key': 'rest',\n        'Content-Type': 'application/json',\n      },\n      body: {\n        key: 'value',\n        authData: { anonymous: { id: '00000000-0000-0000-0000-000000000001' } },\n      },\n    })\n      .then(response => {\n        const body = response.data;\n        objectId = body.objectId;\n        sessionToken = body.sessionToken;\n        expect(sessionToken).toBeDefined();\n        expect(objectId).toBeDefined();\n        return validate(user => {\n          // validate that keys are set on creation\n          expect(user.key).toBe('value');\n        });\n      })\n      .then(() => {\n        // update the user\n        const options = {\n          method: 'PUT',\n          url: `http://localhost:8378/1/classes/_User/${objectId}`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n            'X-Parse-Session-Token': sessionToken,\n            'Content-Type': 'application/json',\n          },\n          body: {\n            key: 'otherValue',\n            authData: {\n              anonymous: { id: '00000000-0000-0000-0000-000000000001' },\n            },\n          },\n        };\n        return request(options);\n      })\n      .then(() => {\n        return validate(user => {\n          // validate that keys are set on update\n          expect(user.key).toBe('otherValue');\n        });\n      })\n      .then(() => {\n        done();\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('can login with email', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          qs: { email: 'yo@lo.com', password: 'yolopass' },\n        };\n        return request(options);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('cannot login with email and invalid password', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          method: 'POST',\n          url: `http://localhost:8378/1/login`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n            'Content-Type': 'application/json',\n          },\n          body: { email: 'yo@lo.com', password: 'yolopass2' },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(() => done());\n  });\n\n  it('can login with email through query string', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo.com&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('can login when both email and username are passed', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo.com&username=yolo&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it(\"fails to login when username doesn't match email\", done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo.com&username=yolo2&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('Invalid username/password.');\n        done();\n      });\n  });\n\n  it(\"fails to login when email doesn't match username\", done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?email=yo@lo2.com&username=yolo&password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('Invalid username/password.');\n        done();\n      });\n  });\n\n  it('fails to login when email and username are not provided', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?password=yolopass`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('username/email is required.');\n        done();\n      });\n  });\n\n  it('allows login when providing email as username', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        return Parse.User.logIn('yo@lo.com', 'yolopass');\n      })\n      .then(user => {\n        expect(user.get('username')).toBe('yolo');\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('handles properly when 2 users share username / email pairs', done => {\n    const user = new Parse.User({\n      username: 'yo@loname.com',\n      password: 'yolopass',\n      email: 'yo@lo.com',\n    });\n    const user2 = new Parse.User({\n      username: 'yo@lo.com',\n      email: 'yo@loname.com',\n      password: 'yolopass2', // different passwords\n    });\n\n    Parse.Object.saveAll([user, user2])\n      .then(() => {\n        return Parse.User.logIn('yo@loname.com', 'yolopass');\n      })\n      .then(user => {\n        // the username takes precedence over the email,\n        // so we get the user with username as passed in\n        expect(user.get('username')).toBe('yo@loname.com');\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('handles properly when 2 users share username / email pairs, counterpart', done => {\n    const user = new Parse.User({\n      username: 'yo@loname.com',\n      password: 'yolopass',\n      email: 'yo@lo.com',\n    });\n    const user2 = new Parse.User({\n      username: 'yo@lo.com',\n      email: 'yo@loname.com',\n      password: 'yolopass2', // different passwords\n    });\n\n    Parse.Object.saveAll([user, user2])\n      .then(() => {\n        return Parse.User.logIn('yo@loname.com', 'yolopass2');\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.message).toEqual('Invalid username/password.');\n        done();\n      });\n  });\n\n  it('fails to login when password is not provided', done => {\n    const user = new Parse.User();\n    user\n      .save({\n        username: 'yolo',\n        password: 'yolopass',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const options = {\n          url: `http://localhost:8378/1/login?username=yolo`,\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-REST-API-Key': 'rest',\n          },\n        };\n        return request(options);\n      })\n      .then(done.fail)\n      .catch(err => {\n        expect(err.data.error).toEqual('password is required.');\n        done();\n      });\n  });\n\n  it('does not duplicate session when logging in multiple times #3451', done => {\n    const user = new Parse.User();\n    user\n      .signUp({\n        username: 'yolo',\n        password: 'yolo',\n        email: 'yo@lo.com',\n      })\n      .then(() => {\n        const token = user.getSessionToken();\n        let promise = Promise.resolve();\n        let count = 0;\n        while (count < 5) {\n          promise = promise.then(() => {\n            return Parse.User.logIn('yolo', 'yolo').then(res => {\n              // ensure a new session token is generated at each login\n              expect(res.getSessionToken()).not.toBe(token);\n            });\n          });\n          count++;\n        }\n        return promise;\n      })\n      .then(() => {\n        // wait because session destruction is not synchronous\n        return new Promise(resolve => {\n          setTimeout(resolve, 100);\n        });\n      })\n      .then(() => {\n        const query = new Parse.Query('_Session');\n        return query.find({ useMasterKey: true });\n      })\n      .then(results => {\n        // only one session in the end\n        expect(results.length).toBe(1);\n      })\n      .then(done, done.fail);\n  });\n\n  it('should throw OBJECT_NOT_FOUND instead of SESSION_MISSING when using masterKey', async () => {\n    // create a fake user (just so we simulate an object not found)\n    const non_existent_user = Parse.User.createWithoutData('fake_id');\n    try {\n      await non_existent_user.destroy({ useMasterKey: true });\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    try {\n      await non_existent_user.save({}, { useMasterKey: true });\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n    }\n    try {\n      await non_existent_user.save();\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n    try {\n      await non_existent_user.destroy();\n      throw '';\n    } catch (e) {\n      expect(e.code).toBe(Parse.Error.SESSION_MISSING);\n    }\n  });\n\n  describe('issue #4897', () => {\n    it_only_db('mongo')('should be able to login with a legacy user (no ACL)', async () => {\n      // This issue is a side effect of the locked users and legacy users which don't have ACL's\n      // In this scenario, a legacy user wasn't be able to login as there's no ACL on it\n      const database = Config.get(Parse.applicationId).database;\n      const collection = await database.adapter._adaptiveCollection('_User');\n      await collection.insertOne({\n        _id: 'ABCDEF1234',\n        name: '<some_name>',\n        email: '<some_email>',\n        username: '<some_username>',\n        _hashed_password: '<some_password>',\n        _auth_data_facebook: {\n          id: '8675309',\n          access_token: 'jenny',\n        },\n        sessionToken: '<some_session_token>',\n      });\n      const provider = getMockFacebookProvider();\n      Parse.User._registerAuthenticationProvider(provider);\n      const model = await Parse.User._logInWith('facebook', {});\n      expect(model.id).toBe('ABCDEF1234');\n      ok(model instanceof Parse.User, 'Model should be a Parse.User');\n      strictEqual(Parse.User.current(), model);\n      ok(model.extended(), 'Should have used subclass.');\n      strictEqual(provider.authData.id, provider.synchronizedUserId);\n      strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n      strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n      ok(model._isLinked('facebook'), 'User should be linked to facebook');\n    });\n  });\n});\n\ndescribe('Security Advisory GHSA-8w3j-g983-8jh5', function () {\n  it_only_db('mongo')(\n    'should validate credentials first and check if account already linked afterwards ()',\n    async done => {\n      // Add User to Database with authData\n      const database = Config.get(Parse.applicationId).database;\n      const collection = await database.adapter._adaptiveCollection('_User');\n      await collection.insertOne({\n        _id: 'ABCDEF1234',\n        name: '<some_name>',\n        email: '<some_email>',\n        username: '<some_username>',\n        _hashed_password: '<some_password>',\n        _auth_data_custom: {\n          id: 'linkedID', // Already linked userid\n        },\n        sessionToken: '<some_session_token>',\n      });\n      const provider = {\n        getAuthType: () => 'custom',\n        restoreAuthentication: () => true,\n      }; // AuthProvider checks if password is 'password'\n      Parse.User._registerAuthenticationProvider(provider);\n\n      // Try to link second user with wrong password\n      try {\n        const user = await Parse.AnonymousUtils.logIn();\n        await user._linkWith(provider.getAuthType(), {\n          authData: { id: 'linkedID', password: 'wrong' },\n        });\n      } catch (error) {\n        // This should throw Parse.Error.SESSION_MISSING and not Parse.Error.ACCOUNT_ALREADY_LINKED\n        expect(error.code).toEqual(Parse.Error.SESSION_MISSING);\n        done();\n        return;\n      }\n      fail();\n      done();\n    }\n  );\n  it_only_db('mongo')('should ignore authData field', async () => {\n    // Add User to Database with authData\n    const database = Config.get(Parse.applicationId).database;\n    const collection = await database.adapter._adaptiveCollection('_User');\n    await collection.insertOne({\n      _id: '1234ABCDEF',\n      name: '<some_name>',\n      email: '<some_email>',\n      username: '<some_username>',\n      _hashed_password: '<some_password>',\n      _auth_data_custom: {\n        id: 'linkedID',\n      },\n      sessionToken: '<some_session_token>',\n      authData: null, // should ignore\n    });\n    const provider = {\n      getAuthType: () => 'custom',\n      restoreAuthentication: () => true,\n    };\n    Parse.User._registerAuthenticationProvider(provider);\n    const query = new Parse.Query(Parse.User);\n    const user = await query.get('1234ABCDEF', { useMasterKey: true });\n    expect(user.get('authData')).toEqual({ custom: { id: 'linkedID' } });\n  });\n});\n", "// A RestWrite encapsulates everything we need to run an operation\n// that writes to the database.\n// This could be either a \"create\" or an \"update\".\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar deepcopy = require('deepcopy');\n\nconst Auth = require('./Auth');\nvar cryptoUtils = require('./cryptoUtils');\nvar passwordCrypto = require('./password');\nvar Parse = require('parse/node');\nvar triggers = require('./triggers');\nvar ClientSDK = require('./ClientSDK');\nimport RestQuery from './RestQuery';\nimport _ from 'lodash';\nimport logger from './logger';\n\n// query and data are both provided in REST API format. So data\n// types are encoded by plain old objects.\n// If query is null, this is a \"create\" and the data in data should be\n// created.\n// Otherwise this is an \"update\" - the object matching the query\n// should get updated with data.\n// RestWrite will handle objectId, createdAt, and updatedAt for\n// everything. It also knows to use triggers and special modifications\n// for the _User class.\nfunction RestWrite(config, auth, className, query, data, originalData, clientSDK, context, action) {\n  if (auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      'Cannot perform a write operation when using readOnlyMasterKey'\n    );\n  }\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.clientSDK = clientSDK;\n  this.storage = {};\n  this.runOptions = {};\n  this.context = context || {};\n\n  if (action) {\n    this.runOptions.action = action;\n  }\n\n  if (!query) {\n    if (this.config.allowCustomObjectId) {\n      if (Object.prototype.hasOwnProperty.call(data, 'objectId') && !data.objectId) {\n        throw new Parse.Error(\n          Parse.Error.MISSING_OBJECT_ID,\n          'objectId must not be empty, null or undefined'\n        );\n      }\n    } else {\n      if (data.objectId) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'objectId is an invalid field name.');\n      }\n      if (data.id) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'id is an invalid field name.');\n      }\n    }\n  }\n\n  // When the operation is complete, this.response may have several\n  // fields.\n  // response: the actual data to be returned\n  // status: the http status code. if not present, treated like a 200\n  // location: the location header. if not present, no location header\n  this.response = null;\n\n  // Processing this operation may mutate our data, so we operate on a\n  // copy\n  this.query = deepcopy(query);\n  this.data = deepcopy(data);\n  // We never change originalData, so we do not need a deep copy\n  this.originalData = originalData;\n\n  // The timestamp we'll use for this whole operation\n  this.updatedAt = Parse._encode(new Date()).iso;\n\n  // Shared SchemaController to be reused to reduce the number of loadSchema() calls per request\n  // Once set the schemaData should be immutable\n  this.validSchemaController = null;\n}\n\n// A convenient method to perform all the steps of processing the\n// write, in order.\n// Returns a promise for a {response, status, location} object.\n// status and location are optional.\nRestWrite.prototype.execute = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.handleInstallation();\n    })\n    .then(() => {\n      return this.handleSession();\n    })\n    .then(() => {\n      return this.validateAuthData();\n    })\n    .then(() => {\n      return this.runBeforeSaveTrigger();\n    })\n    .then(() => {\n      return this.deleteEmailResetTokenIfNeeded();\n    })\n    .then(() => {\n      return this.validateSchema();\n    })\n    .then(schemaController => {\n      this.validSchemaController = schemaController;\n      return this.setRequiredFieldsIfNeeded();\n    })\n    .then(() => {\n      return this.transformUser();\n    })\n    .then(() => {\n      return this.expandFilesForExistingObjects();\n    })\n    .then(() => {\n      return this.destroyDuplicatedSessions();\n    })\n    .then(() => {\n      return this.runDatabaseOperation();\n    })\n    .then(() => {\n      return this.createSessionTokenIfNeeded();\n    })\n    .then(() => {\n      return this.handleFollowup();\n    })\n    .then(() => {\n      return this.runAfterSaveTrigger();\n    })\n    .then(() => {\n      return this.cleanUserAuthData();\n    })\n    .then(() => {\n      return this.response;\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestWrite.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.runOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.runOptions.acl = this.runOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestWrite.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the schema.\nRestWrite.prototype.validateSchema = function () {\n  return this.config.database.validateObject(\n    this.className,\n    this.data,\n    this.query,\n    this.runOptions\n  );\n};\n\n// Runs any beforeSave triggers against this operation.\n// Any change leads to our data being mutated.\nRestWrite.prototype.runBeforeSaveTrigger = function () {\n  if (this.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'beforeSave' trigger for this class.\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeSave, this.config.applicationId)\n  ) {\n    return Promise.resolve();\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  var extraData = { className: this.className };\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  let originalObject = null;\n  const updatedObject = this.buildUpdatedObject(extraData);\n  if (this.query && this.query.objectId) {\n    // This is an update for existing object.\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  return Promise.resolve()\n    .then(() => {\n      // Before calling the trigger, validate the permissions for the save operation\n      let databasePromise = null;\n      if (this.query) {\n        // Validate for updating\n        databasePromise = this.config.database.update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          true,\n          true\n        );\n      } else {\n        // Validate for creating\n        databasePromise = this.config.database.create(\n          this.className,\n          this.data,\n          this.runOptions,\n          true\n        );\n      }\n      // In the case that there is no permission for the operation, it throws an error\n      return databasePromise.then(result => {\n        if (!result || result.length <= 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n      });\n    })\n    .then(() => {\n      return triggers.maybeRunTrigger(\n        triggers.Types.beforeSave,\n        this.auth,\n        updatedObject,\n        originalObject,\n        this.config,\n        this.context\n      );\n    })\n    .then(response => {\n      if (response && response.object) {\n        this.storage.fieldsChangedByTrigger = _.reduce(\n          response.object,\n          (result, value, key) => {\n            if (!_.isEqual(this.data[key], value)) {\n              result.push(key);\n            }\n            return result;\n          },\n          []\n        );\n        this.data = response.object;\n        // We should delete the objectId for an update write\n        if (this.query && this.query.objectId) {\n          delete this.data.objectId;\n        }\n      }\n    });\n};\n\nRestWrite.prototype.runBeforeLoginTrigger = async function (userData) {\n  // Avoid doing any setup for triggers if there is no 'beforeLogin' trigger\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeLogin, this.config.applicationId)\n  ) {\n    return;\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  const extraData = { className: this.className };\n\n  // Expand file objects\n  this.config.filesController.expandFilesInObject(this.config, userData);\n\n  const user = triggers.inflate(extraData, userData);\n\n  // no need to return a response\n  await triggers.maybeRunTrigger(\n    triggers.Types.beforeLogin,\n    this.auth,\n    user,\n    null,\n    this.config,\n    this.context\n  );\n};\n\nRestWrite.prototype.setRequiredFieldsIfNeeded = function () {\n  if (this.data) {\n    return this.validSchemaController.getAllClasses().then(allClasses => {\n      const schema = allClasses.find(oneClass => oneClass.className === this.className);\n      const setRequiredFieldIfNeeded = (fieldName, setDefault) => {\n        if (\n          this.data[fieldName] === undefined ||\n          this.data[fieldName] === null ||\n          this.data[fieldName] === '' ||\n          (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete')\n        ) {\n          if (\n            setDefault &&\n            schema.fields[fieldName] &&\n            schema.fields[fieldName].defaultValue !== null &&\n            schema.fields[fieldName].defaultValue !== undefined &&\n            (this.data[fieldName] === undefined ||\n              (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete'))\n          ) {\n            this.data[fieldName] = schema.fields[fieldName].defaultValue;\n            this.storage.fieldsChangedByTrigger = this.storage.fieldsChangedByTrigger || [];\n            if (this.storage.fieldsChangedByTrigger.indexOf(fieldName) < 0) {\n              this.storage.fieldsChangedByTrigger.push(fieldName);\n            }\n          } else if (schema.fields[fieldName] && schema.fields[fieldName].required === true) {\n            throw new Parse.Error(Parse.Error.VALIDATION_ERROR, `${fieldName} is required`);\n          }\n        }\n      };\n\n      // Add default fields\n      this.data.updatedAt = this.updatedAt;\n      if (!this.query) {\n        this.data.createdAt = this.updatedAt;\n\n        // Only assign new objectId if we are creating new object\n        if (!this.data.objectId) {\n          this.data.objectId = cryptoUtils.newObjectId(this.config.objectIdSize);\n        }\n        if (schema) {\n          Object.keys(schema.fields).forEach(fieldName => {\n            setRequiredFieldIfNeeded(fieldName, true);\n          });\n        }\n      } else if (schema) {\n        Object.keys(this.data).forEach(fieldName => {\n          setRequiredFieldIfNeeded(fieldName, false);\n        });\n      }\n    });\n  }\n  return Promise.resolve();\n};\n\n// Transforms auth data for a user object.\n// Does nothing if this isn't a user object.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.validateAuthData = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n\n  if (!this.query && !this.data.authData) {\n    if (typeof this.data.username !== 'string' || _.isEmpty(this.data.username)) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'bad or missing username');\n    }\n    if (typeof this.data.password !== 'string' || _.isEmpty(this.data.password)) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'password is required');\n    }\n  }\n\n  if (\n    (this.data.authData && !Object.keys(this.data.authData).length) ||\n    !Object.prototype.hasOwnProperty.call(this.data, 'authData')\n  ) {\n    // Handle saving authData to {} or if authData doesn't exist\n    return;\n  } else if (Object.prototype.hasOwnProperty.call(this.data, 'authData') && !this.data.authData) {\n    // Handle saving authData to null\n    throw new Parse.Error(\n      Parse.Error.UNSUPPORTED_SERVICE,\n      'This authentication method is unsupported.'\n    );\n  }\n\n  var authData = this.data.authData;\n  var providers = Object.keys(authData);\n  if (providers.length > 0) {\n    const canHandleAuthData = providers.reduce((canHandle, provider) => {\n      var providerAuthData = authData[provider];\n      var hasToken = providerAuthData && providerAuthData.id;\n      return canHandle && (hasToken || providerAuthData == null);\n    }, true);\n    if (canHandleAuthData) {\n      return this.handleAuthData(authData);\n    }\n  }\n  throw new Parse.Error(\n    Parse.Error.UNSUPPORTED_SERVICE,\n    'This authentication method is unsupported.'\n  );\n};\n\nRestWrite.prototype.handleAuthDataValidation = function (authData) {\n  const validations = Object.keys(authData).map(provider => {\n    if (authData[provider] === null) {\n      return Promise.resolve();\n    }\n    const validateAuthData = this.config.authDataManager.getValidatorForProvider(provider);\n    if (!validateAuthData) {\n      throw new Parse.Error(\n        Parse.Error.UNSUPPORTED_SERVICE,\n        'This authentication method is unsupported.'\n      );\n    }\n    return validateAuthData(authData[provider]);\n  });\n  return Promise.all(validations);\n};\n\nRestWrite.prototype.findUsersWithAuthData = function (authData) {\n  const providers = Object.keys(authData);\n  const query = providers\n    .reduce((memo, provider) => {\n      if (!authData[provider]) {\n        return memo;\n      }\n      const queryKey = `authData.${provider}.id`;\n      const query = {};\n      query[queryKey] = authData[provider].id;\n      memo.push(query);\n      return memo;\n    }, [])\n    .filter(q => {\n      return typeof q !== 'undefined';\n    });\n\n  let findPromise = Promise.resolve([]);\n  if (query.length > 0) {\n    findPromise = this.config.database.find(this.className, { $or: query }, {});\n  }\n\n  return findPromise;\n};\n\nRestWrite.prototype.filteredObjectsByACL = function (objects) {\n  if (this.auth.isMaster) {\n    return objects;\n  }\n  return objects.filter(object => {\n    if (!object.ACL) {\n      return true; // legacy users that have no ACL field on them\n    }\n    // Regular users that have been locked out.\n    return object.ACL && Object.keys(object.ACL).length > 0;\n  });\n};\n\nRestWrite.prototype.handleAuthData = function (authData) {\n  let results;\n  return this.findUsersWithAuthData(authData).then(async r => {\n    results = this.filteredObjectsByACL(r);\n\n    if (results.length == 1) {\n      this.storage['authProvider'] = Object.keys(authData).join(',');\n\n      const userResult = results[0];\n      const mutatedAuthData = {};\n      Object.keys(authData).forEach(provider => {\n        const providerData = authData[provider];\n        const userAuthData = userResult.authData[provider];\n        if (!_.isEqual(providerData, userAuthData)) {\n          mutatedAuthData[provider] = providerData;\n        }\n      });\n      const hasMutatedAuthData = Object.keys(mutatedAuthData).length !== 0;\n      let userId;\n      if (this.query && this.query.objectId) {\n        userId = this.query.objectId;\n      } else if (this.auth && this.auth.user && this.auth.user.id) {\n        userId = this.auth.user.id;\n      }\n      if (!userId || userId === userResult.objectId) {\n        // no user making the call\n        // OR the user making the call is the right one\n        // Login with auth data\n        delete results[0].password;\n\n        // need to set the objectId first otherwise location has trailing undefined\n        this.data.objectId = userResult.objectId;\n\n        if (!this.query || !this.query.objectId) {\n          // this a login call, no userId passed\n          this.response = {\n            response: userResult,\n            location: this.location(),\n          };\n          // Run beforeLogin hook before storing any updates\n          // to authData on the db; changes to userResult\n          // will be ignored.\n          await this.runBeforeLoginTrigger(deepcopy(userResult));\n        }\n\n        // If we didn't change the auth data, just keep going\n        if (!hasMutatedAuthData) {\n          return;\n        }\n        // We have authData that is updated on login\n        // that can happen when token are refreshed,\n        // We should update the token and let the user in\n        // We should only check the mutated keys\n        return this.handleAuthDataValidation(mutatedAuthData).then(async () => {\n          // IF we have a response, we'll skip the database operation / beforeSave / afterSave etc...\n          // we need to set it up there.\n          // We are supposed to have a response only on LOGIN with authData, so we skip those\n          // If we're not logging in, but just updating the current user, we can safely skip that part\n          if (this.response) {\n            // Assign the new authData in the response\n            Object.keys(mutatedAuthData).forEach(provider => {\n              this.response.response.authData[provider] = mutatedAuthData[provider];\n            });\n\n            // Run the DB update directly, as 'master'\n            // Just update the authData part\n            // Then we're good for the user, early exit of sorts\n            return this.config.database.update(\n              this.className,\n              { objectId: this.data.objectId },\n              { authData: mutatedAuthData },\n              {}\n            );\n          }\n        });\n      } else if (userId) {\n        // Trying to update auth data but users\n        // are different\n        if (userResult.objectId !== userId) {\n          throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n        }\n        // No auth data was mutated, just keep going\n        if (!hasMutatedAuthData) {\n          return;\n        }\n      }\n    }\n    return this.handleAuthDataValidation(authData).then(() => {\n      if (results.length > 1) {\n        // More than 1 user with the passed id's\n        throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n      }\n    });\n  });\n};\n\n// The non-third-party parts of User transformation\nRestWrite.prototype.transformUser = function () {\n  var promise = Promise.resolve();\n\n  if (this.className !== '_User') {\n    return promise;\n  }\n\n  if (!this.auth.isMaster && 'emailVerified' in this.data) {\n    const error = `Clients aren't allowed to manually update email verification.`;\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // Do not cleanup session if objectId is not set\n  if (this.query && this.objectId()) {\n    // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n    // session tokens, and remove them from the cache.\n    promise = new RestQuery(this.config, Auth.master(this.config), '_Session', {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    })\n      .execute()\n      .then(results => {\n        results.results.forEach(session =>\n          this.config.cacheController.user.del(session.sessionToken)\n        );\n      });\n  }\n\n  return promise\n    .then(() => {\n      // Transform the password\n      if (this.data.password === undefined) {\n        // ignore only if undefined. should proceed if empty ('')\n        return Promise.resolve();\n      }\n\n      if (this.query) {\n        this.storage['clearSessions'] = true;\n        // Generate a new session only if the user requested\n        if (!this.auth.isMaster) {\n          this.storage['generateNewSession'] = true;\n        }\n      }\n\n      return this._validatePasswordPolicy().then(() => {\n        return passwordCrypto.hash(this.data.password).then(hashedPassword => {\n          this.data._hashed_password = hashedPassword;\n          delete this.data.password;\n        });\n      });\n    })\n    .then(() => {\n      return this._validateUserName();\n    })\n    .then(() => {\n      return this._validateEmail();\n    });\n};\n\nRestWrite.prototype._validateUserName = function () {\n  // Check for username uniqueness\n  if (!this.data.username) {\n    if (!this.query) {\n      this.data.username = cryptoUtils.randomString(25);\n      this.responseShouldHaveUsername = true;\n    }\n    return Promise.resolve();\n  }\n  /*\n    Usernames should be unique when compared case insensitively\n\n    Users should be able to make case sensitive usernames and\n    login using the case they entered.  I.e. 'Snoopy' should preclude\n    'snoopy' as a valid username.\n  */\n  return this.config.database\n    .find(\n      this.className,\n      {\n        username: this.data.username,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.USERNAME_TAKEN,\n          'Account already exists for this username.'\n        );\n      }\n      return;\n    });\n};\n\n/*\n  As with usernames, Parse should not allow case insensitive collisions of email.\n  unlike with usernames (which can have case insensitive collisions in the case of\n  auth adapters), emails should never have a case insensitive collision.\n\n  This behavior can be enforced through a properly configured index see:\n  https://docs.mongodb.com/manual/core/index-case-insensitive/#create-a-case-insensitive-index\n  which could be implemented instead of this code based validation.\n\n  Given that this lookup should be a relatively low use case and that the case sensitive\n  unique index will be used by the db for the query, this is an adequate solution.\n*/\nRestWrite.prototype._validateEmail = function () {\n  if (!this.data.email || this.data.email.__op === 'Delete') {\n    return Promise.resolve();\n  }\n  // Validate basic email address format\n  if (!this.data.email.match(/^.+@.+$/)) {\n    return Promise.reject(\n      new Parse.Error(Parse.Error.INVALID_EMAIL_ADDRESS, 'Email address format is invalid.')\n    );\n  }\n  // Case insensitive match, see note above function.\n  return this.config.database\n    .find(\n      this.className,\n      {\n        email: this.data.email,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.EMAIL_TAKEN,\n          'Account already exists for this email address.'\n        );\n      }\n      if (\n        !this.data.authData ||\n        !Object.keys(this.data.authData).length ||\n        (Object.keys(this.data.authData).length === 1 &&\n          Object.keys(this.data.authData)[0] === 'anonymous')\n      ) {\n        // We updated the email, send a new validation\n        this.storage['sendVerificationEmail'] = true;\n        this.config.userController.setEmailVerifyToken(this.data);\n      }\n    });\n};\n\nRestWrite.prototype._validatePasswordPolicy = function () {\n  if (!this.config.passwordPolicy) return Promise.resolve();\n  return this._validatePasswordRequirements().then(() => {\n    return this._validatePasswordHistory();\n  });\n};\n\nRestWrite.prototype._validatePasswordRequirements = function () {\n  // check if the password conforms to the defined password policy if configured\n  // If we specified a custom error in our configuration use it.\n  // Example: \"Passwords must include a Capital Letter, Lowercase Letter, and a number.\"\n  //\n  // This is especially useful on the generic \"password reset\" page,\n  // as it allows the programmer to communicate specific requirements instead of:\n  // a. making the user guess whats wrong\n  // b. making a custom password reset page that shows the requirements\n  const policyError = this.config.passwordPolicy.validationError\n    ? this.config.passwordPolicy.validationError\n    : 'Password does not meet the Password Policy requirements.';\n  const containsUsernameError = 'Password cannot contain your username.';\n\n  // check whether the password meets the password strength requirements\n  if (\n    (this.config.passwordPolicy.patternValidator &&\n      !this.config.passwordPolicy.patternValidator(this.data.password)) ||\n    (this.config.passwordPolicy.validatorCallback &&\n      !this.config.passwordPolicy.validatorCallback(this.data.password))\n  ) {\n    return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n  }\n\n  // check whether password contain username\n  if (this.config.passwordPolicy.doNotAllowUsername === true) {\n    if (this.data.username) {\n      // username is not passed during password reset\n      if (this.data.password.indexOf(this.data.username) >= 0)\n        return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError));\n    } else {\n      // retrieve the User object using objectId during password reset\n      return this.config.database.find('_User', { objectId: this.objectId() }).then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        if (this.data.password.indexOf(results[0].username) >= 0)\n          return Promise.reject(\n            new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError)\n          );\n        return Promise.resolve();\n      });\n    }\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype._validatePasswordHistory = function () {\n  // check whether password is repeating from specified history\n  if (this.query && this.config.passwordPolicy.maxPasswordHistory) {\n    return this.config.database\n      .find(\n        '_User',\n        { objectId: this.objectId() },\n        { keys: ['_password_history', '_hashed_password'] }\n      )\n      .then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        const user = results[0];\n        let oldPasswords = [];\n        if (user._password_history)\n          oldPasswords = _.take(\n            user._password_history,\n            this.config.passwordPolicy.maxPasswordHistory - 1\n          );\n        oldPasswords.push(user.password);\n        const newPassword = this.data.password;\n        // compare the new password hash with all old password hashes\n        const promises = oldPasswords.map(function (hash) {\n          return passwordCrypto.compare(newPassword, hash).then(result => {\n            if (result)\n              // reject if there is a match\n              return Promise.reject('REPEAT_PASSWORD');\n            return Promise.resolve();\n          });\n        });\n        // wait for all comparisons to complete\n        return Promise.all(promises)\n          .then(() => {\n            return Promise.resolve();\n          })\n          .catch(err => {\n            if (err === 'REPEAT_PASSWORD')\n              // a match was found\n              return Promise.reject(\n                new Parse.Error(\n                  Parse.Error.VALIDATION_ERROR,\n                  `New password should not be the same as last ${this.config.passwordPolicy.maxPasswordHistory} passwords.`\n                )\n              );\n            throw err;\n          });\n      });\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype.createSessionTokenIfNeeded = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n  // Don't generate session for updating user (this.query is set) unless authData exists\n  if (this.query && !this.data.authData) {\n    return;\n  }\n  // Don't generate new sessionToken if linking via sessionToken\n  if (this.auth.user && this.data.authData) {\n    return;\n  }\n  if (\n    !this.storage['authProvider'] && // signup call, with\n    this.config.preventLoginWithUnverifiedEmail && // no login without verification\n    this.config.verifyUserEmails\n  ) {\n    // verification is on\n    return; // do not create the session token in that case!\n  }\n  return this.createSessionToken();\n};\n\nRestWrite.prototype.createSessionToken = async function () {\n  // cloud installationId from Cloud Code,\n  // never create session tokens from there.\n  if (this.auth.installationId && this.auth.installationId === 'cloud') {\n    return;\n  }\n\n  if (this.storage['authProvider'] == null && this.data.authData) {\n    this.storage['authProvider'] = Object.keys(this.data.authData).join(',');\n  }\n\n  const { sessionData, createSession } = Auth.createSession(this.config, {\n    userId: this.objectId(),\n    createdWith: {\n      action: this.storage['authProvider'] ? 'login' : 'signup',\n      authProvider: this.storage['authProvider'] || 'password',\n    },\n    installationId: this.auth.installationId,\n  });\n\n  if (this.response && this.response.response) {\n    this.response.response.sessionToken = sessionData.sessionToken;\n  }\n\n  return createSession();\n};\n\n// Delete email reset tokens if user is changing password or email.\nRestWrite.prototype.deleteEmailResetTokenIfNeeded = function () {\n  if (this.className !== '_User' || this.query === null) {\n    // null query means create\n    return;\n  }\n\n  if ('password' in this.data || 'email' in this.data) {\n    const addOps = {\n      _perishable_token: { __op: 'Delete' },\n      _perishable_token_expires_at: { __op: 'Delete' },\n    };\n    this.data = Object.assign(this.data, addOps);\n  }\n};\n\nRestWrite.prototype.destroyDuplicatedSessions = function () {\n  // Only for _Session, and at creation time\n  if (this.className != '_Session' || this.query) {\n    return;\n  }\n  // Destroy the sessions in 'Background'\n  const { user, installationId, sessionToken } = this.data;\n  if (!user || !installationId) {\n    return;\n  }\n  if (!user.objectId) {\n    return;\n  }\n  this.config.database.destroy(\n    '_Session',\n    {\n      user,\n      installationId,\n      sessionToken: { $ne: sessionToken },\n    },\n    {},\n    this.validSchemaController\n  );\n};\n\n// Handles any followup logic\nRestWrite.prototype.handleFollowup = function () {\n  if (this.storage && this.storage['clearSessions'] && this.config.revokeSessionOnPasswordReset) {\n    var sessionQuery = {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    };\n    delete this.storage['clearSessions'];\n    return this.config.database\n      .destroy('_Session', sessionQuery)\n      .then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['generateNewSession']) {\n    delete this.storage['generateNewSession'];\n    return this.createSessionToken().then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['sendVerificationEmail']) {\n    delete this.storage['sendVerificationEmail'];\n    // Fire and forget!\n    this.config.userController.sendVerificationEmail(this.data);\n    return this.handleFollowup.bind(this);\n  }\n};\n\n// Handles the _Session class specialness.\n// Does nothing if this isn't an _Session object.\nRestWrite.prototype.handleSession = function () {\n  if (this.response || this.className !== '_Session') {\n    return;\n  }\n\n  if (!this.auth.user && !this.auth.isMaster) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token required.');\n  }\n\n  // TODO: Verify proper error to throw\n  if (this.data.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Cannot set ' + 'ACL on a Session.');\n  }\n\n  if (this.query) {\n    if (this.data.user && !this.auth.isMaster && this.data.user.objectId != this.auth.user.id) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.installationId) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.sessionToken) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    }\n  }\n\n  if (!this.query && !this.auth.isMaster) {\n    const additionalSessionData = {};\n    for (var key in this.data) {\n      if (key === 'objectId' || key === 'user') {\n        continue;\n      }\n      additionalSessionData[key] = this.data[key];\n    }\n\n    const { sessionData, createSession } = Auth.createSession(this.config, {\n      userId: this.auth.user.id,\n      createdWith: {\n        action: 'create',\n      },\n      additionalSessionData,\n    });\n\n    return createSession().then(results => {\n      if (!results.response) {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Error creating session.');\n      }\n      sessionData['objectId'] = results.response['objectId'];\n      this.response = {\n        status: 201,\n        location: results.location,\n        response: sessionData,\n      };\n    });\n  }\n};\n\n// Handles the _Installation class specialness.\n// Does nothing if this isn't an installation object.\n// If an installation is found, this can mutate this.query and turn a create\n// into an update.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.handleInstallation = function () {\n  if (this.response || this.className !== '_Installation') {\n    return;\n  }\n\n  if (\n    !this.query &&\n    !this.data.deviceToken &&\n    !this.data.installationId &&\n    !this.auth.installationId\n  ) {\n    throw new Parse.Error(\n      135,\n      'at least one ID field (deviceToken, installationId) ' + 'must be specified in this operation'\n    );\n  }\n\n  // If the device token is 64 characters long, we assume it is for iOS\n  // and lowercase it.\n  if (this.data.deviceToken && this.data.deviceToken.length == 64) {\n    this.data.deviceToken = this.data.deviceToken.toLowerCase();\n  }\n\n  // We lowercase the installationId if present\n  if (this.data.installationId) {\n    this.data.installationId = this.data.installationId.toLowerCase();\n  }\n\n  let installationId = this.data.installationId;\n\n  // If data.installationId is not set and we're not master, we can lookup in auth\n  if (!installationId && !this.auth.isMaster) {\n    installationId = this.auth.installationId;\n  }\n\n  if (installationId) {\n    installationId = installationId.toLowerCase();\n  }\n\n  // Updating _Installation but not updating anything critical\n  if (this.query && !this.data.deviceToken && !installationId && !this.data.deviceType) {\n    return;\n  }\n\n  var promise = Promise.resolve();\n\n  var idMatch; // Will be a match on either objectId or installationId\n  var objectIdMatch;\n  var installationIdMatch;\n  var deviceTokenMatches = [];\n\n  // Instead of issuing 3 reads, let's do it with one OR.\n  const orQueries = [];\n  if (this.query && this.query.objectId) {\n    orQueries.push({\n      objectId: this.query.objectId,\n    });\n  }\n  if (installationId) {\n    orQueries.push({\n      installationId: installationId,\n    });\n  }\n  if (this.data.deviceToken) {\n    orQueries.push({ deviceToken: this.data.deviceToken });\n  }\n\n  if (orQueries.length == 0) {\n    return;\n  }\n\n  promise = promise\n    .then(() => {\n      return this.config.database.find(\n        '_Installation',\n        {\n          $or: orQueries,\n        },\n        {}\n      );\n    })\n    .then(results => {\n      results.forEach(result => {\n        if (this.query && this.query.objectId && result.objectId == this.query.objectId) {\n          objectIdMatch = result;\n        }\n        if (result.installationId == installationId) {\n          installationIdMatch = result;\n        }\n        if (result.deviceToken == this.data.deviceToken) {\n          deviceTokenMatches.push(result);\n        }\n      });\n\n      // Sanity checks when running a query\n      if (this.query && this.query.objectId) {\n        if (!objectIdMatch) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for update.');\n        }\n        if (\n          this.data.installationId &&\n          objectIdMatch.installationId &&\n          this.data.installationId !== objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'installationId may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceToken &&\n          objectIdMatch.deviceToken &&\n          this.data.deviceToken !== objectIdMatch.deviceToken &&\n          !this.data.installationId &&\n          !objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'deviceToken may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceType &&\n          this.data.deviceType &&\n          this.data.deviceType !== objectIdMatch.deviceType\n        ) {\n          throw new Parse.Error(136, 'deviceType may not be changed in this ' + 'operation');\n        }\n      }\n\n      if (this.query && this.query.objectId && objectIdMatch) {\n        idMatch = objectIdMatch;\n      }\n\n      if (installationId && installationIdMatch) {\n        idMatch = installationIdMatch;\n      }\n      // need to specify deviceType only if it's new\n      if (!this.query && !this.data.deviceType && !idMatch) {\n        throw new Parse.Error(135, 'deviceType must be specified in this operation');\n      }\n    })\n    .then(() => {\n      if (!idMatch) {\n        if (!deviceTokenMatches.length) {\n          return;\n        } else if (\n          deviceTokenMatches.length == 1 &&\n          (!deviceTokenMatches[0]['installationId'] || !installationId)\n        ) {\n          // Single match on device token but none on installationId, and either\n          // the passed object or the match is missing an installationId, so we\n          // can just return the match.\n          return deviceTokenMatches[0]['objectId'];\n        } else if (!this.data.installationId) {\n          throw new Parse.Error(\n            132,\n            'Must specify installationId when deviceToken ' +\n              'matches multiple Installation objects'\n          );\n        } else {\n          // Multiple device token matches and we specified an installation ID,\n          // or a single match where both the passed and matching objects have\n          // an installation ID. Try cleaning out old installations that match\n          // the deviceToken, and return nil to signal that a new object should\n          // be created.\n          var delQuery = {\n            deviceToken: this.data.deviceToken,\n            installationId: {\n              $ne: installationId,\n            },\n          };\n          if (this.data.appIdentifier) {\n            delQuery['appIdentifier'] = this.data.appIdentifier;\n          }\n          this.config.database.destroy('_Installation', delQuery).catch(err => {\n            if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n              // no deletions were made. Can be ignored.\n              return;\n            }\n            // rethrow the error\n            throw err;\n          });\n          return;\n        }\n      } else {\n        if (deviceTokenMatches.length == 1 && !deviceTokenMatches[0]['installationId']) {\n          // Exactly one device token match and it doesn't have an installation\n          // ID. This is the one case where we want to merge with the existing\n          // object.\n          const delQuery = { objectId: idMatch.objectId };\n          return this.config.database\n            .destroy('_Installation', delQuery)\n            .then(() => {\n              return deviceTokenMatches[0]['objectId'];\n            })\n            .catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n        } else {\n          if (this.data.deviceToken && idMatch.deviceToken != this.data.deviceToken) {\n            // We're setting the device token on an existing installation, so\n            // we should try cleaning out old installations that match this\n            // device token.\n            const delQuery = {\n              deviceToken: this.data.deviceToken,\n            };\n            // We have a unique install Id, use that to preserve\n            // the interesting installation\n            if (this.data.installationId) {\n              delQuery['installationId'] = {\n                $ne: this.data.installationId,\n              };\n            } else if (\n              idMatch.objectId &&\n              this.data.objectId &&\n              idMatch.objectId == this.data.objectId\n            ) {\n              // we passed an objectId, preserve that instalation\n              delQuery['objectId'] = {\n                $ne: idMatch.objectId,\n              };\n            } else {\n              // What to do here? can't really clean up everything...\n              return idMatch.objectId;\n            }\n            if (this.data.appIdentifier) {\n              delQuery['appIdentifier'] = this.data.appIdentifier;\n            }\n            this.config.database.destroy('_Installation', delQuery).catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored.\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n          }\n          // In non-merge scenarios, just return the installation match id\n          return idMatch.objectId;\n        }\n      }\n    })\n    .then(objId => {\n      if (objId) {\n        this.query = { objectId: objId };\n        delete this.data.objectId;\n        delete this.data.createdAt;\n      }\n      // TODO: Validate ops (add/remove on channels, $inc on badge, etc.)\n    });\n  return promise;\n};\n\n// If we short-circuted the object response - then we need to make sure we expand all the files,\n// since this might not have a query, meaning it won't return the full result back.\n// TODO: (nlutsenko) This should die when we move to per-class based controllers on _Session/_User\nRestWrite.prototype.expandFilesForExistingObjects = function () {\n  // Check whether we have a short-circuited response - only then run expansion.\n  if (this.response && this.response.response) {\n    this.config.filesController.expandFilesInObject(this.config, this.response.response);\n  }\n};\n\nRestWrite.prototype.runDatabaseOperation = function () {\n  if (this.response) {\n    return;\n  }\n\n  if (this.className === '_Role') {\n    this.config.cacheController.role.clear();\n  }\n\n  if (this.className === '_User' && this.query && this.auth.isUnauthenticated()) {\n    throw new Parse.Error(\n      Parse.Error.SESSION_MISSING,\n      `Cannot modify user ${this.query.objectId}.`\n    );\n  }\n\n  if (this.className === '_Product' && this.data.download) {\n    this.data.downloadName = this.data.download.name;\n  }\n\n  // TODO: Add better detection for ACL, ensuring a user can't be locked from\n  //       their own user record.\n  if (this.data.ACL && this.data.ACL['*unresolved']) {\n    throw new Parse.Error(Parse.Error.INVALID_ACL, 'Invalid ACL.');\n  }\n\n  if (this.query) {\n    // Force the user to not lockout\n    // Matched with parse.com\n    if (this.className === '_User' && this.data.ACL && this.auth.isMaster !== true) {\n      this.data.ACL[this.query.objectId] = { read: true, write: true };\n    }\n    // update password timestamp if user password is being changed\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordAge\n    ) {\n      this.data._password_changed_at = Parse._encode(new Date());\n    }\n    // Ignore createdAt when update\n    delete this.data.createdAt;\n\n    let defer = Promise.resolve();\n    // if password history is enabled then save the current password to history\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordHistory\n    ) {\n      defer = this.config.database\n        .find(\n          '_User',\n          { objectId: this.objectId() },\n          { keys: ['_password_history', '_hashed_password'] }\n        )\n        .then(results => {\n          if (results.length != 1) {\n            throw undefined;\n          }\n          const user = results[0];\n          let oldPasswords = [];\n          if (user._password_history) {\n            oldPasswords = _.take(\n              user._password_history,\n              this.config.passwordPolicy.maxPasswordHistory\n            );\n          }\n          //n-1 passwords go into history including last password\n          while (\n            oldPasswords.length > Math.max(0, this.config.passwordPolicy.maxPasswordHistory - 2)\n          ) {\n            oldPasswords.shift();\n          }\n          oldPasswords.push(user.password);\n          this.data._password_history = oldPasswords;\n        });\n    }\n\n    return defer.then(() => {\n      // Run an update\n      return this.config.database\n        .update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          false,\n          false,\n          this.validSchemaController\n        )\n        .then(response => {\n          response.updatedAt = this.updatedAt;\n          this._updateResponseWithData(response, this.data);\n          this.response = { response };\n        });\n    });\n  } else {\n    // Set the default ACL and password timestamp for the new _User\n    if (this.className === '_User') {\n      var ACL = this.data.ACL;\n      // default public r/w ACL\n      if (!ACL) {\n        ACL = {};\n        ACL['*'] = { read: true, write: false };\n      }\n      // make sure the user is not locked down\n      ACL[this.data.objectId] = { read: true, write: true };\n      this.data.ACL = ACL;\n      // password timestamp to be used when password expiry policy is enforced\n      if (this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n        this.data._password_changed_at = Parse._encode(new Date());\n      }\n    }\n\n    // Run a create\n    return this.config.database\n      .create(this.className, this.data, this.runOptions, false, this.validSchemaController)\n      .catch(error => {\n        if (this.className !== '_User' || error.code !== Parse.Error.DUPLICATE_VALUE) {\n          throw error;\n        }\n\n        // Quick check, if we were able to infer the duplicated field name\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'username') {\n          throw new Parse.Error(\n            Parse.Error.USERNAME_TAKEN,\n            'Account already exists for this username.'\n          );\n        }\n\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'email') {\n          throw new Parse.Error(\n            Parse.Error.EMAIL_TAKEN,\n            'Account already exists for this email address.'\n          );\n        }\n\n        // If this was a failed user creation due to username or email already taken, we need to\n        // check whether it was username or email and return the appropriate error.\n        // Fallback to the original method\n        // TODO: See if we can later do this without additional queries by using named indexes.\n        return this.config.database\n          .find(\n            this.className,\n            {\n              username: this.data.username,\n              objectId: { $ne: this.objectId() },\n            },\n            { limit: 1 }\n          )\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.USERNAME_TAKEN,\n                'Account already exists for this username.'\n              );\n            }\n            return this.config.database.find(\n              this.className,\n              { email: this.data.email, objectId: { $ne: this.objectId() } },\n              { limit: 1 }\n            );\n          })\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.EMAIL_TAKEN,\n                'Account already exists for this email address.'\n              );\n            }\n            throw new Parse.Error(\n              Parse.Error.DUPLICATE_VALUE,\n              'A duplicate value for a field with unique values was provided'\n            );\n          });\n      })\n      .then(response => {\n        response.objectId = this.data.objectId;\n        response.createdAt = this.data.createdAt;\n\n        if (this.responseShouldHaveUsername) {\n          response.username = this.data.username;\n        }\n        this._updateResponseWithData(response, this.data);\n        this.response = {\n          status: 201,\n          response,\n          location: this.location(),\n        };\n      });\n  }\n};\n\n// Returns nothing - doesn't wait for the trigger.\nRestWrite.prototype.runAfterSaveTrigger = function () {\n  if (!this.response || !this.response.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'afterSave' trigger for this class.\n  const hasAfterSaveHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterSave,\n    this.config.applicationId\n  );\n  const hasLiveQuery = this.config.liveQueryController.hasLiveQuery(this.className);\n  if (!hasAfterSaveHook && !hasLiveQuery) {\n    return Promise.resolve();\n  }\n\n  var extraData = { className: this.className };\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  // Build the original object, we only do this for a update write.\n  let originalObject;\n  if (this.query && this.query.objectId) {\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  // Build the inflated object, different from beforeSave, originalData is not empty\n  // since developers can change data in the beforeSave.\n  const updatedObject = this.buildUpdatedObject(extraData);\n  updatedObject._handleSaveResponse(this.response.response, this.response.status || 200);\n\n  this.config.database.loadSchema().then(schemaController => {\n    // Notifiy LiveQueryServer if possible\n    const perms = schemaController.getClassLevelPermissions(updatedObject.className);\n    this.config.liveQueryController.onAfterSave(\n      updatedObject.className,\n      updatedObject,\n      originalObject,\n      perms\n    );\n  });\n\n  // Run afterSave trigger\n  return triggers\n    .maybeRunTrigger(\n      triggers.Types.afterSave,\n      this.auth,\n      updatedObject,\n      originalObject,\n      this.config,\n      this.context\n    )\n    .then(result => {\n      if (result && typeof result === 'object') {\n        this.response.response = result;\n      }\n    })\n    .catch(function (err) {\n      logger.warn('afterSave caught an error', err);\n    });\n};\n\n// A helper to figure out what location this operation happens at.\nRestWrite.prototype.location = function () {\n  var middle = this.className === '_User' ? '/users/' : '/classes/' + this.className + '/';\n  const mount = this.config.mount || this.config.serverURL;\n  return mount + middle + this.data.objectId;\n};\n\n// A helper to get the object id for this operation.\n// Because it could be either on the query or on the data\nRestWrite.prototype.objectId = function () {\n  return this.data.objectId || this.query.objectId;\n};\n\n// Returns a copy of the data and delete bad keys (_auth_data, _hashed_password...)\nRestWrite.prototype.sanitizedData = function () {\n  const data = Object.keys(this.data).reduce((data, key) => {\n    // Regexp comes from Parse.Object.prototype.validate\n    if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n  return Parse._decode(undefined, data);\n};\n\n// Returns an updated copy of the object\nRestWrite.prototype.buildUpdatedObject = function (extraData) {\n  const updatedObject = triggers.inflate(extraData, this.originalData);\n  Object.keys(this.data).reduce(function (data, key) {\n    if (key.indexOf('.') > 0) {\n      if (typeof data[key].__op === 'string') {\n        updatedObject.set(key, data[key]);\n      } else {\n        // subdocument key with dot notation { 'x.y': v } => { 'x': { 'y' : v } })\n        const splittedKey = key.split('.');\n        const parentProp = splittedKey[0];\n        let parentVal = updatedObject.get(parentProp);\n        if (typeof parentVal !== 'object') {\n          parentVal = {};\n        }\n        parentVal[splittedKey[1]] = data[key];\n        updatedObject.set(parentProp, parentVal);\n      }\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n\n  updatedObject.set(this.sanitizedData());\n  return updatedObject;\n};\n\nRestWrite.prototype.cleanUserAuthData = function () {\n  if (this.response && this.response.response && this.className === '_User') {\n    const user = this.response.response;\n    if (user.authData) {\n      Object.keys(user.authData).forEach(provider => {\n        if (user.authData[provider] === null) {\n          delete user.authData[provider];\n        }\n      });\n      if (Object.keys(user.authData).length == 0) {\n        delete user.authData;\n      }\n    }\n  }\n};\n\nRestWrite.prototype._updateResponseWithData = function (response, data) {\n  if (_.isEmpty(this.storage.fieldsChangedByTrigger)) {\n    return response;\n  }\n  const clientSupportsDelete = ClientSDK.supportsForwardDelete(this.clientSDK);\n  this.storage.fieldsChangedByTrigger.forEach(fieldName => {\n    const dataValue = data[fieldName];\n\n    if (!Object.prototype.hasOwnProperty.call(response, fieldName)) {\n      response[fieldName] = dataValue;\n    }\n\n    // Strips operations from responses\n    if (response[fieldName] && response[fieldName].__op) {\n      delete response[fieldName];\n      if (clientSupportsDelete && dataValue.__op == 'Delete') {\n        response[fieldName] = dataValue;\n      }\n    }\n  });\n  return response;\n};\n\nexport default RestWrite;\nmodule.exports = RestWrite;\n"], "filenames": ["CHANGELOG.md", "spec/ParseUser.spec.js", "src/RestWrite.js"], "buggy_code_start_loc": [4, 2377, 857], "buggy_code_end_loc": [5, 2430, 857], "fixing_code_start_loc": [4, 2377, 858], "fixing_code_end_loc": [10, 2434, 862], "type": "CWE-863", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Developers can use the REST API to signup users and also allow users to login anonymously. Prior to version 4.5.1, when an anonymous user is first signed up using REST, the server creates session incorrectly. Particularly, the `authProvider` field in `_Session` class under `createdWith` shows the user logged in creating a password. If a developer later depends on the `createdWith` field to provide a different level of access between a password user and anonymous user, the server incorrectly classified the session type as being created with a `password`. The server does not currently use `createdWith` to make decisions about internal functions, so if a developer is not using `createdWith` directly, they are not affected. The vulnerability only affects users who depend on `createdWith` by using it directly. The issue is patched in Parse Server version 4.5.1. As a workaround, do not use the `createdWith` Session field to make decisions if one allows anonymous login.", "other": {"cve": {"id": "CVE-2021-39138", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-19T16:15:12.483", "lastModified": "2022-08-12T18:01:28.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Developers can use the REST API to signup users and also allow users to login anonymously. Prior to version 4.5.1, when an anonymous user is first signed up using REST, the server creates session incorrectly. Particularly, the `authProvider` field in `_Session` class under `createdWith` shows the user logged in creating a password. If a developer later depends on the `createdWith` field to provide a different level of access between a password user and anonymous user, the server incorrectly classified the session type as being created with a `password`. The server does not currently use `createdWith` to make decisions about internal functions, so if a developer is not using `createdWith` directly, they are not affected. The vulnerability only affects users who depend on `createdWith` by using it directly. The issue is patched in Parse Server version 4.5.1. As a workaround, do not use the `createdWith` Session field to make decisions if one allows anonymous login."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede desplegarse en cualquier infraestructura que pueda ejecutar Node.js. Los desarrolladores pueden usar la API REST para registrar usuarios y tambi\u00e9n permitir a usuarios registrarse an\u00f3nimamente. Versiones anteriores a 4.5.1, cuando un usuario an\u00f3nimo es registrado por primera vez usando REST, el servidor creaba la sesi\u00f3n incorrectamente. En particular, el campo \"authProvider\" de la clase \"_Session\" en \"createdWith\" muestra que el usuario se ha registrado creando una contrase\u00f1a. Si un desarrollador depende posteriormente del campo \"createdWith\" para proporcionar un nivel de acceso diferente entre un usuario con contrase\u00f1a y un usuario an\u00f3nimo, el servidor clasifica incorrectamente el tipo de sesi\u00f3n como creada con un \"password\". El servidor no usa actualmente \"createdWith\" para tomar decisiones sobre las funciones internas, por lo que si un desarrollador no est\u00e1 usando \"createdWith\" directamente, no est\u00e1 afectado. La vulnerabilidad s\u00f3lo afecta a usuarios que dependen de \"createdWith\" al usarlo directamente. El problema est\u00e1 parcheado en Parse Server versi\u00f3n 4.5.1. Como soluci\u00f3n, no use el campo de sesi\u00f3n \"createdWith\" para tomar decisiones si se permite el acceso an\u00f3nimo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.5.1", "matchCriteriaId": "9DE0F06D-5868-45AD-B21E-C5268BCC7F52"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/147bd9a3dc43391e92c36e05d5db860b04ca27db", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/4.5.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-23r4-5mxp-c7g5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/147bd9a3dc43391e92c36e05d5db860b04ca27db"}}