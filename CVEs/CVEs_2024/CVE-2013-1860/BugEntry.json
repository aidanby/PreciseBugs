{"buggy_code": ["/*\n * cdc-wdm.c\n *\n * This driver supports USB CDC WCM Device Management.\n *\n * Copyright (c) 2007-2009 Oliver Neukum\n *\n * Some code taken from cdc-acm.c\n *\n * Released under the GPLv2.\n *\n * Many thanks to Carl Nordbeck\n */\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/poll.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/usb/cdc-wdm.h>\n\n/*\n * Version Information\n */\n#define DRIVER_VERSION \"v0.03\"\n#define DRIVER_AUTHOR \"Oliver Neukum\"\n#define DRIVER_DESC \"USB Abstract Control Model driver for USB WCM Device Management\"\n\nstatic const struct usb_device_id wdm_ids[] = {\n\t{\n\t\t.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS |\n\t\t\t\t USB_DEVICE_ID_MATCH_INT_SUBCLASS,\n\t\t.bInterfaceClass = USB_CLASS_COMM,\n\t\t.bInterfaceSubClass = USB_CDC_SUBCLASS_DMM\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, wdm_ids);\n\n#define WDM_MINOR_BASE\t176\n\n\n#define WDM_IN_USE\t\t1\n#define WDM_DISCONNECTING\t2\n#define WDM_RESULT\t\t3\n#define WDM_READ\t\t4\n#define WDM_INT_STALL\t\t5\n#define WDM_POLL_RUNNING\t6\n#define WDM_RESPONDING\t\t7\n#define WDM_SUSPENDING\t\t8\n#define WDM_RESETTING\t\t9\n\n#define WDM_MAX\t\t\t16\n\n/* CDC-WMC r1.1 requires wMaxCommand to be \"at least 256 decimal (0x100)\" */\n#define WDM_DEFAULT_BUFSIZE\t256\n\nstatic DEFINE_MUTEX(wdm_mutex);\nstatic DEFINE_SPINLOCK(wdm_device_list_lock);\nstatic LIST_HEAD(wdm_device_list);\n\n/* --- method tables --- */\n\nstruct wdm_device {\n\tu8\t\t\t*inbuf; /* buffer for response */\n\tu8\t\t\t*outbuf; /* buffer for command */\n\tu8\t\t\t*sbuf; /* buffer for status */\n\tu8\t\t\t*ubuf; /* buffer for copy to user space */\n\n\tstruct urb\t\t*command;\n\tstruct urb\t\t*response;\n\tstruct urb\t\t*validity;\n\tstruct usb_interface\t*intf;\n\tstruct usb_ctrlrequest\t*orq;\n\tstruct usb_ctrlrequest\t*irq;\n\tspinlock_t\t\tiuspin;\n\n\tunsigned long\t\tflags;\n\tu16\t\t\tbufsize;\n\tu16\t\t\twMaxCommand;\n\tu16\t\t\twMaxPacketSize;\n\t__le16\t\t\tinum;\n\tint\t\t\treslength;\n\tint\t\t\tlength;\n\tint\t\t\tread;\n\tint\t\t\tcount;\n\tdma_addr_t\t\tshandle;\n\tdma_addr_t\t\tihandle;\n\tstruct mutex\t\twlock;\n\tstruct mutex\t\trlock;\n\twait_queue_head_t\twait;\n\tstruct work_struct\trxwork;\n\tint\t\t\twerr;\n\tint\t\t\trerr;\n\n\tstruct list_head\tdevice_list;\n\tint\t\t\t(*manage_power)(struct usb_interface *, int);\n};\n\nstatic struct usb_driver wdm_driver;\n\n/* return intfdata if we own the interface, else look up intf in the list */\nstatic struct wdm_device *wdm_find_device(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_for_each_entry(desc, &wdm_device_list, device_list)\n\t\tif (desc->intf == intf)\n\t\t\tgoto found;\n\tdesc = NULL;\nfound:\n\tspin_unlock(&wdm_device_list_lock);\n\n\treturn desc;\n}\n\nstatic struct wdm_device *wdm_find_device_by_minor(int minor)\n{\n\tstruct wdm_device *desc;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_for_each_entry(desc, &wdm_device_list, device_list)\n\t\tif (desc->intf->minor == minor)\n\t\t\tgoto found;\n\tdesc = NULL;\nfound:\n\tspin_unlock(&wdm_device_list_lock);\n\n\treturn desc;\n}\n\n/* --- callbacks --- */\nstatic void wdm_out_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc;\n\tdesc = urb->context;\n\tspin_lock(&desc->iuspin);\n\tdesc->werr = urb->status;\n\tspin_unlock(&desc->iuspin);\n\tkfree(desc->outbuf);\n\tdesc->outbuf = NULL;\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\twake_up(&desc->wait);\n}\n\nstatic void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}\n\nstatic void wdm_int_callback(struct urb *urb)\n{\n\tint rv = 0;\n\tint status = urb->status;\n\tstruct wdm_device *desc;\n\tstruct usb_cdc_notification *dr;\n\n\tdesc = urb->context;\n\tdr = (struct usb_cdc_notification *)desc->sbuf;\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOENT:\n\t\tcase -ECONNRESET:\n\t\t\treturn; /* unplug */\n\t\tcase -EPIPE:\n\t\t\tset_bit(WDM_INT_STALL, &desc->flags);\n\t\t\tdev_err(&desc->intf->dev, \"Stall on int endpoint\\n\");\n\t\t\tgoto sw; /* halt is cleared in work */\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (urb->actual_length < sizeof(struct usb_cdc_notification)) {\n\t\tdev_err(&desc->intf->dev, \"wdm_int_callback - %d bytes\\n\",\n\t\t\turb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tswitch (dr->bNotificationType) {\n\tcase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\n\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\"NOTIFY_RESPONSE_AVAILABLE received: index %d len %d\",\n\t\t\tdr->wIndex, dr->wLength);\n\t\tbreak;\n\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\n\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\"NOTIFY_NETWORK_CONNECTION %s network\",\n\t\t\tdr->wValue ? \"connected to\" : \"disconnected from\");\n\t\tgoto exit;\n\tdefault:\n\t\tclear_bit(WDM_POLL_RUNNING, &desc->flags);\n\t\tdev_err(&desc->intf->dev,\n\t\t\t\"unknown notification %d received: index %d len %d\\n\",\n\t\t\tdr->bNotificationType, dr->wIndex, dr->wLength);\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_READ, &desc->flags);\n\tset_bit(WDM_RESPONDING, &desc->flags);\n\tif (!test_bit(WDM_DISCONNECTING, &desc->flags)\n\t\t&& !test_bit(WDM_SUSPENDING, &desc->flags)) {\n\t\trv = usb_submit_urb(desc->response, GFP_ATOMIC);\n\t\tdev_dbg(&desc->intf->dev, \"%s: usb_submit_urb %d\",\n\t\t\t__func__, rv);\n\t}\n\tspin_unlock(&desc->iuspin);\n\tif (rv < 0) {\n\t\tclear_bit(WDM_RESPONDING, &desc->flags);\n\t\tif (rv == -EPERM)\n\t\t\treturn;\n\t\tif (rv == -ENOMEM) {\nsw:\n\t\t\trv = schedule_work(&desc->rxwork);\n\t\t\tif (rv)\n\t\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\t\"Cannot schedule work\\n\");\n\t\t}\n\t}\nexit:\n\trv = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rv)\n\t\tdev_err(&desc->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, rv);\n\n}\n\nstatic void kill_urbs(struct wdm_device *desc)\n{\n\t/* the order here is essential */\n\tusb_kill_urb(desc->command);\n\tusb_kill_urb(desc->validity);\n\tusb_kill_urb(desc->response);\n}\n\nstatic void free_urbs(struct wdm_device *desc)\n{\n\tusb_free_urb(desc->validity);\n\tusb_free_urb(desc->response);\n\tusb_free_urb(desc->command);\n}\n\nstatic void cleanup(struct wdm_device *desc)\n{\n\tkfree(desc->sbuf);\n\tkfree(desc->inbuf);\n\tkfree(desc->orq);\n\tkfree(desc->irq);\n\tkfree(desc->ubuf);\n\tfree_urbs(desc);\n\tkfree(desc);\n}\n\nstatic ssize_t wdm_write\n(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tu8 *buf;\n\tint rv = -EMSGSIZE, r, we;\n\tstruct wdm_device *desc = file->private_data;\n\tstruct usb_ctrlrequest *req;\n\n\tif (count > desc->wMaxCommand)\n\t\tcount = desc->wMaxCommand;\n\n\tspin_lock_irq(&desc->iuspin);\n\twe = desc->werr;\n\tdesc->werr = 0;\n\tspin_unlock_irq(&desc->iuspin);\n\tif (we < 0)\n\t\treturn -EIO;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf) {\n\t\trv = -ENOMEM;\n\t\tgoto outnl;\n\t}\n\n\tr = copy_from_user(buf, buffer, count);\n\tif (r > 0) {\n\t\tkfree(buf);\n\t\trv = -EFAULT;\n\t\tgoto outnl;\n\t}\n\n\t/* concurrent writes and disconnect */\n\tr = mutex_lock_interruptible(&desc->wlock);\n\trv = -ERESTARTSYS;\n\tif (r) {\n\t\tkfree(buf);\n\t\tgoto outnl;\n\t}\n\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tkfree(buf);\n\t\trv = -ENODEV;\n\t\tgoto outnp;\n\t}\n\n\tr = usb_autopm_get_interface(desc->intf);\n\tif (r < 0) {\n\t\tkfree(buf);\n\t\trv = usb_translate_errors(r);\n\t\tgoto outnp;\n\t}\n\n\tif (!(file->f_flags & O_NONBLOCK))\n\t\tr = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,\n\t\t\t\t\t\t\t\t&desc->flags));\n\telse\n\t\tif (test_bit(WDM_IN_USE, &desc->flags))\n\t\t\tr = -EAGAIN;\n\n\tif (test_bit(WDM_RESETTING, &desc->flags))\n\t\tr = -EIO;\n\n\tif (r < 0) {\n\t\tkfree(buf);\n\t\trv = r;\n\t\tgoto out;\n\t}\n\n\treq = desc->orq;\n\tusb_fill_control_urb(\n\t\tdesc->command,\n\t\tinterface_to_usbdev(desc->intf),\n\t\t/* using common endpoint 0 */\n\t\tusb_sndctrlpipe(interface_to_usbdev(desc->intf), 0),\n\t\t(unsigned char *)req,\n\t\tbuf,\n\t\tcount,\n\t\twdm_out_callback,\n\t\tdesc\n\t);\n\n\treq->bRequestType = (USB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\t     USB_RECIP_INTERFACE);\n\treq->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\n\treq->wValue = 0;\n\treq->wIndex = desc->inum;\n\treq->wLength = cpu_to_le16(count);\n\tset_bit(WDM_IN_USE, &desc->flags);\n\tdesc->outbuf = buf;\n\n\trv = usb_submit_urb(desc->command, GFP_KERNEL);\n\tif (rv < 0) {\n\t\tkfree(buf);\n\t\tdesc->outbuf = NULL;\n\t\tclear_bit(WDM_IN_USE, &desc->flags);\n\t\tdev_err(&desc->intf->dev, \"Tx URB error: %d\\n\", rv);\n\t\trv = usb_translate_errors(rv);\n\t} else {\n\t\tdev_dbg(&desc->intf->dev, \"Tx URB has been submitted index=%d\",\n\t\t\treq->wIndex);\n\t}\nout:\n\tusb_autopm_put_interface(desc->intf);\noutnp:\n\tmutex_unlock(&desc->wlock);\noutnl:\n\treturn rv < 0 ? rv : count;\n}\n\nstatic ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}\n\nstatic int wdm_flush(struct file *file, fl_owner_t id)\n{\n\tstruct wdm_device *desc = file->private_data;\n\n\twait_event(desc->wait, !test_bit(WDM_IN_USE, &desc->flags));\n\n\t/* cannot dereference desc->intf if WDM_DISCONNECTING */\n\tif (desc->werr < 0 && !test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\tdev_err(&desc->intf->dev, \"Error in flush path: %d\\n\",\n\t\t\tdesc->werr);\n\n\treturn usb_translate_errors(desc->werr);\n}\n\nstatic unsigned int wdm_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct wdm_device *desc = file->private_data;\n\tunsigned long flags;\n\tunsigned int mask = 0;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tmask = POLLHUP | POLLERR;\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\tgoto desc_out;\n\t}\n\tif (test_bit(WDM_READ, &desc->flags))\n\t\tmask = POLLIN | POLLRDNORM;\n\tif (desc->rerr || desc->werr)\n\t\tmask |= POLLERR;\n\tif (!test_bit(WDM_IN_USE, &desc->flags))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\n\tpoll_wait(file, &desc->wait, wait);\n\ndesc_out:\n\treturn mask;\n}\n\nstatic int wdm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tint rv = -ENODEV;\n\tstruct usb_interface *intf;\n\tstruct wdm_device *desc;\n\n\tmutex_lock(&wdm_mutex);\n\tdesc = wdm_find_device_by_minor(minor);\n\tif (!desc)\n\t\tgoto out;\n\n\tintf = desc->intf;\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\tgoto out;\n\tfile->private_data = desc;\n\n\trv = usb_autopm_get_interface(desc->intf);\n\tif (rv < 0) {\n\t\tdev_err(&desc->intf->dev, \"Error autopm - %d\\n\", rv);\n\t\tgoto out;\n\t}\n\n\t/* using write lock to protect desc->count */\n\tmutex_lock(&desc->wlock);\n\tif (!desc->count++) {\n\t\tdesc->werr = 0;\n\t\tdesc->rerr = 0;\n\t\trv = usb_submit_urb(desc->validity, GFP_KERNEL);\n\t\tif (rv < 0) {\n\t\t\tdesc->count--;\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Error submitting int urb - %d\\n\", rv);\n\t\t\trv = usb_translate_errors(rv);\n\t\t}\n\t} else {\n\t\trv = 0;\n\t}\n\tmutex_unlock(&desc->wlock);\n\tif (desc->count == 1)\n\t\tdesc->manage_power(intf, 1);\n\tusb_autopm_put_interface(desc->intf);\nout:\n\tmutex_unlock(&wdm_mutex);\n\treturn rv;\n}\n\nstatic int wdm_release(struct inode *inode, struct file *file)\n{\n\tstruct wdm_device *desc = file->private_data;\n\n\tmutex_lock(&wdm_mutex);\n\n\t/* using write lock to protect desc->count */\n\tmutex_lock(&desc->wlock);\n\tdesc->count--;\n\tmutex_unlock(&desc->wlock);\n\n\tif (!desc->count) {\n\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\tdev_dbg(&desc->intf->dev, \"wdm_release: cleanup\");\n\t\t\tkill_urbs(desc);\n\t\t\tdesc->manage_power(desc->intf, 0);\n\t\t} else {\n\t\t\t/* must avoid dev_printk here as desc->intf is invalid */\n\t\t\tpr_debug(KBUILD_MODNAME \" %s: device gone - cleaning up\\n\", __func__);\n\t\t\tcleanup(desc);\n\t\t}\n\t}\n\tmutex_unlock(&wdm_mutex);\n\treturn 0;\n}\n\nstatic const struct file_operations wdm_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\twdm_read,\n\t.write =\twdm_write,\n\t.open =\t\twdm_open,\n\t.flush =\twdm_flush,\n\t.release =\twdm_release,\n\t.poll =\t\twdm_poll,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic struct usb_class_driver wdm_class = {\n\t.name =\t\t\"cdc-wdm%d\",\n\t.fops =\t\t&wdm_fops,\n\t.minor_base =\tWDM_MINOR_BASE,\n};\n\n/* --- error handling --- */\nstatic void wdm_rxwork(struct work_struct *work)\n{\n\tstruct wdm_device *desc = container_of(work, struct wdm_device, rxwork);\n\tunsigned long flags;\n\tint rv;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\trv = usb_submit_urb(desc->response, GFP_KERNEL);\n\t\tif (rv < 0 && rv != -EPERM) {\n\t\t\tspin_lock_irqsave(&desc->iuspin, flags);\n\t\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\t\t\tschedule_work(&desc->rxwork);\n\t\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\t}\n\t}\n}\n\n/* --- hotplug --- */\n\nstatic int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor *ep,\n\t\tu16 bufsize, int (*manage_power)(struct usb_interface *, int))\n{\n\tint rv = -ENOMEM;\n\tstruct wdm_device *desc;\n\n\tdesc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);\n\tif (!desc)\n\t\tgoto out;\n\tINIT_LIST_HEAD(&desc->device_list);\n\tmutex_init(&desc->rlock);\n\tmutex_init(&desc->wlock);\n\tspin_lock_init(&desc->iuspin);\n\tinit_waitqueue_head(&desc->wait);\n\tdesc->wMaxCommand = bufsize;\n\t/* this will be expanded and needed in hardware endianness */\n\tdesc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);\n\tdesc->intf = intf;\n\tINIT_WORK(&desc->rxwork, wdm_rxwork);\n\n\trv = -EINVAL;\n\tif (!usb_endpoint_is_int_in(ep))\n\t\tgoto err;\n\n\tdesc->wMaxPacketSize = usb_endpoint_maxp(ep);\n\n\tdesc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!desc->orq)\n\t\tgoto err;\n\tdesc->irq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!desc->irq)\n\t\tgoto err;\n\n\tdesc->validity = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->validity)\n\t\tgoto err;\n\n\tdesc->response = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->response)\n\t\tgoto err;\n\n\tdesc->command = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->command)\n\t\tgoto err;\n\n\tdesc->ubuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\n\tif (!desc->ubuf)\n\t\tgoto err;\n\n\tdesc->sbuf = kmalloc(desc->wMaxPacketSize, GFP_KERNEL);\n\tif (!desc->sbuf)\n\t\tgoto err;\n\n\tdesc->inbuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\n\tif (!desc->inbuf)\n\t\tgoto err;\n\n\tusb_fill_int_urb(\n\t\tdesc->validity,\n\t\tinterface_to_usbdev(intf),\n\t\tusb_rcvintpipe(interface_to_usbdev(intf), ep->bEndpointAddress),\n\t\tdesc->sbuf,\n\t\tdesc->wMaxPacketSize,\n\t\twdm_int_callback,\n\t\tdesc,\n\t\tep->bInterval\n\t);\n\n\tdesc->irq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);\n\tdesc->irq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\n\tdesc->irq->wValue = 0;\n\tdesc->irq->wIndex = desc->inum;\n\tdesc->irq->wLength = cpu_to_le16(desc->wMaxCommand);\n\n\tusb_fill_control_urb(\n\t\tdesc->response,\n\t\tinterface_to_usbdev(intf),\n\t\t/* using common endpoint 0 */\n\t\tusb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),\n\t\t(unsigned char *)desc->irq,\n\t\tdesc->inbuf,\n\t\tdesc->wMaxCommand,\n\t\twdm_in_callback,\n\t\tdesc\n\t);\n\n\tdesc->manage_power = manage_power;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_add(&desc->device_list, &wdm_device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\n\trv = usb_register_dev(intf, &wdm_class);\n\tif (rv < 0)\n\t\tgoto err;\n\telse\n\t\tdev_info(&intf->dev, \"%s: USB WDM device\\n\", dev_name(intf->usb_dev));\nout:\n\treturn rv;\nerr:\n\tspin_lock(&wdm_device_list_lock);\n\tlist_del(&desc->device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\tcleanup(desc);\n\treturn rv;\n}\n\nstatic int wdm_manage_power(struct usb_interface *intf, int on)\n{\n\t/* need autopm_get/put here to ensure the usbcore sees the new value */\n\tint rv = usb_autopm_get_interface(intf);\n\tif (rv < 0)\n\t\tgoto err;\n\n\tintf->needs_remote_wakeup = on;\n\tusb_autopm_put_interface(intf);\nerr:\n\treturn rv;\n}\n\nstatic int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint rv = -EINVAL;\n\tstruct usb_host_interface *iface;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_cdc_dmm_desc *dmhd;\n\tu8 *buffer = intf->altsetting->extra;\n\tint buflen = intf->altsetting->extralen;\n\tu16 maxcom = WDM_DEFAULT_BUFSIZE;\n\n\tif (!buffer)\n\t\tgoto err;\n\twhile (buflen > 2) {\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tdmhd = (struct usb_cdc_dmm_desc *)buffer;\n\t\t\tmaxcom = le16_to_cpu(dmhd->wMaxCommand);\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Finding maximum buffer length: %d\", maxcom);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Ignoring extra header, type %d, length %d\\n\",\n\t\t\t\tbuffer[2], buffer[0]);\n\t\t\tbreak;\n\t\t}\nnext_desc:\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tiface = intf->cur_altsetting;\n\tif (iface->desc.bNumEndpoints != 1)\n\t\tgoto err;\n\tep = &iface->endpoint[0].desc;\n\n\trv = wdm_create(intf, ep, maxcom, &wdm_manage_power);\n\nerr:\n\treturn rv;\n}\n\n/**\n * usb_cdc_wdm_register - register a WDM subdriver\n * @intf: usb interface the subdriver will associate with\n * @ep: interrupt endpoint to monitor for notifications\n * @bufsize: maximum message size to support for read/write\n *\n * Create WDM usb class character device and associate it with intf\n * without binding, allowing another driver to manage the interface.\n *\n * The subdriver will manage the given interrupt endpoint exclusively\n * and will issue control requests referring to the given intf. It\n * will otherwise avoid interferring, and in particular not do\n * usb_set_intfdata/usb_get_intfdata on intf.\n *\n * The return value is a pointer to the subdriver's struct usb_driver.\n * The registering driver is responsible for calling this subdriver's\n * disconnect, suspend, resume, pre_reset and post_reset methods from\n * its own.\n */\nstruct usb_driver *usb_cdc_wdm_register(struct usb_interface *intf,\n\t\t\t\t\tstruct usb_endpoint_descriptor *ep,\n\t\t\t\t\tint bufsize,\n\t\t\t\t\tint (*manage_power)(struct usb_interface *, int))\n{\n\tint rv = -EINVAL;\n\n\trv = wdm_create(intf, ep, bufsize, manage_power);\n\tif (rv < 0)\n\t\tgoto err;\n\n\treturn &wdm_driver;\nerr:\n\treturn ERR_PTR(rv);\n}\nEXPORT_SYMBOL(usb_cdc_wdm_register);\n\nstatic void wdm_disconnect(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc;\n\tunsigned long flags;\n\n\tusb_deregister_dev(intf, &wdm_class);\n\tdesc = wdm_find_device(intf);\n\tmutex_lock(&wdm_mutex);\n\n\t/* the spinlock makes sure no new urbs are generated in the callbacks */\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tset_bit(WDM_DISCONNECTING, &desc->flags);\n\tset_bit(WDM_READ, &desc->flags);\n\t/* to terminate pending flushes */\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\twake_up_all(&desc->wait);\n\tmutex_lock(&desc->rlock);\n\tmutex_lock(&desc->wlock);\n\tkill_urbs(desc);\n\tcancel_work_sync(&desc->rxwork);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\n\t/* the desc->intf pointer used as list key is now invalid */\n\tspin_lock(&wdm_device_list_lock);\n\tlist_del(&desc->device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\n\tif (!desc->count)\n\t\tcleanup(desc);\n\telse\n\t\tdev_dbg(&intf->dev, \"%s: %d open files - postponing cleanup\\n\", __func__, desc->count);\n\tmutex_unlock(&wdm_mutex);\n}\n\n#ifdef CONFIG_PM\nstatic int wdm_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv = 0;\n\n\tdev_dbg(&desc->intf->dev, \"wdm%d_suspend\\n\", intf->minor);\n\n\t/* if this is an autosuspend the caller does the locking */\n\tif (!PMSG_IS_AUTO(message)) {\n\t\tmutex_lock(&desc->rlock);\n\t\tmutex_lock(&desc->wlock);\n\t}\n\tspin_lock_irq(&desc->iuspin);\n\n\tif (PMSG_IS_AUTO(message) &&\n\t\t\t(test_bit(WDM_IN_USE, &desc->flags)\n\t\t\t|| test_bit(WDM_RESPONDING, &desc->flags))) {\n\t\tspin_unlock_irq(&desc->iuspin);\n\t\trv = -EBUSY;\n\t} else {\n\n\t\tset_bit(WDM_SUSPENDING, &desc->flags);\n\t\tspin_unlock_irq(&desc->iuspin);\n\t\t/* callback submits work - order is essential */\n\t\tkill_urbs(desc);\n\t\tcancel_work_sync(&desc->rxwork);\n\t}\n\tif (!PMSG_IS_AUTO(message)) {\n\t\tmutex_unlock(&desc->wlock);\n\t\tmutex_unlock(&desc->rlock);\n\t}\n\n\treturn rv;\n}\n#endif\n\nstatic int recover_from_urb_loss(struct wdm_device *desc)\n{\n\tint rv = 0;\n\n\tif (desc->count) {\n\t\trv = usb_submit_urb(desc->validity, GFP_NOIO);\n\t\tif (rv < 0)\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Error resume submitting int urb - %d\\n\", rv);\n\t}\n\treturn rv;\n}\n\n#ifdef CONFIG_PM\nstatic int wdm_resume(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tdev_dbg(&desc->intf->dev, \"wdm%d_resume\\n\", intf->minor);\n\n\tclear_bit(WDM_SUSPENDING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\n\treturn rv;\n}\n#endif\n\nstatic int wdm_pre_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\n\t/*\n\t * we notify everybody using poll of\n\t * an exceptional situation\n\t * must be done before recovery lest a spontaneous\n\t * message from the device is lost\n\t */\n\tspin_lock_irq(&desc->iuspin);\n\tset_bit(WDM_RESETTING, &desc->flags);\t/* inform read/write */\n\tset_bit(WDM_READ, &desc->flags);\t/* unblock read */\n\tclear_bit(WDM_IN_USE, &desc->flags);\t/* unblock write */\n\tdesc->rerr = -EINTR;\n\tspin_unlock_irq(&desc->iuspin);\n\twake_up_all(&desc->wait);\n\tmutex_lock(&desc->rlock);\n\tmutex_lock(&desc->wlock);\n\tkill_urbs(desc);\n\tcancel_work_sync(&desc->rxwork);\n\treturn 0;\n}\n\nstatic int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}\n\nstatic struct usb_driver wdm_driver = {\n\t.name =\t\t\"cdc_wdm\",\n\t.probe =\twdm_probe,\n\t.disconnect =\twdm_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\twdm_suspend,\n\t.resume =\twdm_resume,\n\t.reset_resume =\twdm_resume,\n#endif\n\t.pre_reset =\twdm_pre_reset,\n\t.post_reset =\twdm_post_reset,\n\t.id_table =\twdm_ids,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(wdm_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * cdc-wdm.c\n *\n * This driver supports USB CDC WCM Device Management.\n *\n * Copyright (c) 2007-2009 Oliver Neukum\n *\n * Some code taken from cdc-acm.c\n *\n * Released under the GPLv2.\n *\n * Many thanks to Carl Nordbeck\n */\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/poll.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/usb/cdc-wdm.h>\n\n/*\n * Version Information\n */\n#define DRIVER_VERSION \"v0.03\"\n#define DRIVER_AUTHOR \"Oliver Neukum\"\n#define DRIVER_DESC \"USB Abstract Control Model driver for USB WCM Device Management\"\n\nstatic const struct usb_device_id wdm_ids[] = {\n\t{\n\t\t.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS |\n\t\t\t\t USB_DEVICE_ID_MATCH_INT_SUBCLASS,\n\t\t.bInterfaceClass = USB_CLASS_COMM,\n\t\t.bInterfaceSubClass = USB_CDC_SUBCLASS_DMM\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, wdm_ids);\n\n#define WDM_MINOR_BASE\t176\n\n\n#define WDM_IN_USE\t\t1\n#define WDM_DISCONNECTING\t2\n#define WDM_RESULT\t\t3\n#define WDM_READ\t\t4\n#define WDM_INT_STALL\t\t5\n#define WDM_POLL_RUNNING\t6\n#define WDM_RESPONDING\t\t7\n#define WDM_SUSPENDING\t\t8\n#define WDM_RESETTING\t\t9\n#define WDM_OVERFLOW\t\t10\n\n#define WDM_MAX\t\t\t16\n\n/* CDC-WMC r1.1 requires wMaxCommand to be \"at least 256 decimal (0x100)\" */\n#define WDM_DEFAULT_BUFSIZE\t256\n\nstatic DEFINE_MUTEX(wdm_mutex);\nstatic DEFINE_SPINLOCK(wdm_device_list_lock);\nstatic LIST_HEAD(wdm_device_list);\n\n/* --- method tables --- */\n\nstruct wdm_device {\n\tu8\t\t\t*inbuf; /* buffer for response */\n\tu8\t\t\t*outbuf; /* buffer for command */\n\tu8\t\t\t*sbuf; /* buffer for status */\n\tu8\t\t\t*ubuf; /* buffer for copy to user space */\n\n\tstruct urb\t\t*command;\n\tstruct urb\t\t*response;\n\tstruct urb\t\t*validity;\n\tstruct usb_interface\t*intf;\n\tstruct usb_ctrlrequest\t*orq;\n\tstruct usb_ctrlrequest\t*irq;\n\tspinlock_t\t\tiuspin;\n\n\tunsigned long\t\tflags;\n\tu16\t\t\tbufsize;\n\tu16\t\t\twMaxCommand;\n\tu16\t\t\twMaxPacketSize;\n\t__le16\t\t\tinum;\n\tint\t\t\treslength;\n\tint\t\t\tlength;\n\tint\t\t\tread;\n\tint\t\t\tcount;\n\tdma_addr_t\t\tshandle;\n\tdma_addr_t\t\tihandle;\n\tstruct mutex\t\twlock;\n\tstruct mutex\t\trlock;\n\twait_queue_head_t\twait;\n\tstruct work_struct\trxwork;\n\tint\t\t\twerr;\n\tint\t\t\trerr;\n\n\tstruct list_head\tdevice_list;\n\tint\t\t\t(*manage_power)(struct usb_interface *, int);\n};\n\nstatic struct usb_driver wdm_driver;\n\n/* return intfdata if we own the interface, else look up intf in the list */\nstatic struct wdm_device *wdm_find_device(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_for_each_entry(desc, &wdm_device_list, device_list)\n\t\tif (desc->intf == intf)\n\t\t\tgoto found;\n\tdesc = NULL;\nfound:\n\tspin_unlock(&wdm_device_list_lock);\n\n\treturn desc;\n}\n\nstatic struct wdm_device *wdm_find_device_by_minor(int minor)\n{\n\tstruct wdm_device *desc;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_for_each_entry(desc, &wdm_device_list, device_list)\n\t\tif (desc->intf->minor == minor)\n\t\t\tgoto found;\n\tdesc = NULL;\nfound:\n\tspin_unlock(&wdm_device_list_lock);\n\n\treturn desc;\n}\n\n/* --- callbacks --- */\nstatic void wdm_out_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc;\n\tdesc = urb->context;\n\tspin_lock(&desc->iuspin);\n\tdesc->werr = urb->status;\n\tspin_unlock(&desc->iuspin);\n\tkfree(desc->outbuf);\n\tdesc->outbuf = NULL;\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\twake_up(&desc->wait);\n}\n\nstatic void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}\n\nstatic void wdm_int_callback(struct urb *urb)\n{\n\tint rv = 0;\n\tint status = urb->status;\n\tstruct wdm_device *desc;\n\tstruct usb_cdc_notification *dr;\n\n\tdesc = urb->context;\n\tdr = (struct usb_cdc_notification *)desc->sbuf;\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOENT:\n\t\tcase -ECONNRESET:\n\t\t\treturn; /* unplug */\n\t\tcase -EPIPE:\n\t\t\tset_bit(WDM_INT_STALL, &desc->flags);\n\t\t\tdev_err(&desc->intf->dev, \"Stall on int endpoint\\n\");\n\t\t\tgoto sw; /* halt is cleared in work */\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (urb->actual_length < sizeof(struct usb_cdc_notification)) {\n\t\tdev_err(&desc->intf->dev, \"wdm_int_callback - %d bytes\\n\",\n\t\t\turb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tswitch (dr->bNotificationType) {\n\tcase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\n\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\"NOTIFY_RESPONSE_AVAILABLE received: index %d len %d\",\n\t\t\tdr->wIndex, dr->wLength);\n\t\tbreak;\n\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\n\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\"NOTIFY_NETWORK_CONNECTION %s network\",\n\t\t\tdr->wValue ? \"connected to\" : \"disconnected from\");\n\t\tgoto exit;\n\tdefault:\n\t\tclear_bit(WDM_POLL_RUNNING, &desc->flags);\n\t\tdev_err(&desc->intf->dev,\n\t\t\t\"unknown notification %d received: index %d len %d\\n\",\n\t\t\tdr->bNotificationType, dr->wIndex, dr->wLength);\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_READ, &desc->flags);\n\tset_bit(WDM_RESPONDING, &desc->flags);\n\tif (!test_bit(WDM_DISCONNECTING, &desc->flags)\n\t\t&& !test_bit(WDM_SUSPENDING, &desc->flags)) {\n\t\trv = usb_submit_urb(desc->response, GFP_ATOMIC);\n\t\tdev_dbg(&desc->intf->dev, \"%s: usb_submit_urb %d\",\n\t\t\t__func__, rv);\n\t}\n\tspin_unlock(&desc->iuspin);\n\tif (rv < 0) {\n\t\tclear_bit(WDM_RESPONDING, &desc->flags);\n\t\tif (rv == -EPERM)\n\t\t\treturn;\n\t\tif (rv == -ENOMEM) {\nsw:\n\t\t\trv = schedule_work(&desc->rxwork);\n\t\t\tif (rv)\n\t\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\t\"Cannot schedule work\\n\");\n\t\t}\n\t}\nexit:\n\trv = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rv)\n\t\tdev_err(&desc->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, rv);\n\n}\n\nstatic void kill_urbs(struct wdm_device *desc)\n{\n\t/* the order here is essential */\n\tusb_kill_urb(desc->command);\n\tusb_kill_urb(desc->validity);\n\tusb_kill_urb(desc->response);\n}\n\nstatic void free_urbs(struct wdm_device *desc)\n{\n\tusb_free_urb(desc->validity);\n\tusb_free_urb(desc->response);\n\tusb_free_urb(desc->command);\n}\n\nstatic void cleanup(struct wdm_device *desc)\n{\n\tkfree(desc->sbuf);\n\tkfree(desc->inbuf);\n\tkfree(desc->orq);\n\tkfree(desc->irq);\n\tkfree(desc->ubuf);\n\tfree_urbs(desc);\n\tkfree(desc);\n}\n\nstatic ssize_t wdm_write\n(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tu8 *buf;\n\tint rv = -EMSGSIZE, r, we;\n\tstruct wdm_device *desc = file->private_data;\n\tstruct usb_ctrlrequest *req;\n\n\tif (count > desc->wMaxCommand)\n\t\tcount = desc->wMaxCommand;\n\n\tspin_lock_irq(&desc->iuspin);\n\twe = desc->werr;\n\tdesc->werr = 0;\n\tspin_unlock_irq(&desc->iuspin);\n\tif (we < 0)\n\t\treturn -EIO;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf) {\n\t\trv = -ENOMEM;\n\t\tgoto outnl;\n\t}\n\n\tr = copy_from_user(buf, buffer, count);\n\tif (r > 0) {\n\t\tkfree(buf);\n\t\trv = -EFAULT;\n\t\tgoto outnl;\n\t}\n\n\t/* concurrent writes and disconnect */\n\tr = mutex_lock_interruptible(&desc->wlock);\n\trv = -ERESTARTSYS;\n\tif (r) {\n\t\tkfree(buf);\n\t\tgoto outnl;\n\t}\n\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tkfree(buf);\n\t\trv = -ENODEV;\n\t\tgoto outnp;\n\t}\n\n\tr = usb_autopm_get_interface(desc->intf);\n\tif (r < 0) {\n\t\tkfree(buf);\n\t\trv = usb_translate_errors(r);\n\t\tgoto outnp;\n\t}\n\n\tif (!(file->f_flags & O_NONBLOCK))\n\t\tr = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,\n\t\t\t\t\t\t\t\t&desc->flags));\n\telse\n\t\tif (test_bit(WDM_IN_USE, &desc->flags))\n\t\t\tr = -EAGAIN;\n\n\tif (test_bit(WDM_RESETTING, &desc->flags))\n\t\tr = -EIO;\n\n\tif (r < 0) {\n\t\tkfree(buf);\n\t\trv = r;\n\t\tgoto out;\n\t}\n\n\treq = desc->orq;\n\tusb_fill_control_urb(\n\t\tdesc->command,\n\t\tinterface_to_usbdev(desc->intf),\n\t\t/* using common endpoint 0 */\n\t\tusb_sndctrlpipe(interface_to_usbdev(desc->intf), 0),\n\t\t(unsigned char *)req,\n\t\tbuf,\n\t\tcount,\n\t\twdm_out_callback,\n\t\tdesc\n\t);\n\n\treq->bRequestType = (USB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\t     USB_RECIP_INTERFACE);\n\treq->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\n\treq->wValue = 0;\n\treq->wIndex = desc->inum;\n\treq->wLength = cpu_to_le16(count);\n\tset_bit(WDM_IN_USE, &desc->flags);\n\tdesc->outbuf = buf;\n\n\trv = usb_submit_urb(desc->command, GFP_KERNEL);\n\tif (rv < 0) {\n\t\tkfree(buf);\n\t\tdesc->outbuf = NULL;\n\t\tclear_bit(WDM_IN_USE, &desc->flags);\n\t\tdev_err(&desc->intf->dev, \"Tx URB error: %d\\n\", rv);\n\t\trv = usb_translate_errors(rv);\n\t} else {\n\t\tdev_dbg(&desc->intf->dev, \"Tx URB has been submitted index=%d\",\n\t\t\treq->wIndex);\n\t}\nout:\n\tusb_autopm_put_interface(desc->intf);\noutnp:\n\tmutex_unlock(&desc->wlock);\noutnl:\n\treturn rv < 0 ? rv : count;\n}\n\nstatic ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\t\t\trv = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}\n\nstatic int wdm_flush(struct file *file, fl_owner_t id)\n{\n\tstruct wdm_device *desc = file->private_data;\n\n\twait_event(desc->wait, !test_bit(WDM_IN_USE, &desc->flags));\n\n\t/* cannot dereference desc->intf if WDM_DISCONNECTING */\n\tif (desc->werr < 0 && !test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\tdev_err(&desc->intf->dev, \"Error in flush path: %d\\n\",\n\t\t\tdesc->werr);\n\n\treturn usb_translate_errors(desc->werr);\n}\n\nstatic unsigned int wdm_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct wdm_device *desc = file->private_data;\n\tunsigned long flags;\n\tunsigned int mask = 0;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tmask = POLLHUP | POLLERR;\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\tgoto desc_out;\n\t}\n\tif (test_bit(WDM_READ, &desc->flags))\n\t\tmask = POLLIN | POLLRDNORM;\n\tif (desc->rerr || desc->werr)\n\t\tmask |= POLLERR;\n\tif (!test_bit(WDM_IN_USE, &desc->flags))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\n\tpoll_wait(file, &desc->wait, wait);\n\ndesc_out:\n\treturn mask;\n}\n\nstatic int wdm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tint rv = -ENODEV;\n\tstruct usb_interface *intf;\n\tstruct wdm_device *desc;\n\n\tmutex_lock(&wdm_mutex);\n\tdesc = wdm_find_device_by_minor(minor);\n\tif (!desc)\n\t\tgoto out;\n\n\tintf = desc->intf;\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\tgoto out;\n\tfile->private_data = desc;\n\n\trv = usb_autopm_get_interface(desc->intf);\n\tif (rv < 0) {\n\t\tdev_err(&desc->intf->dev, \"Error autopm - %d\\n\", rv);\n\t\tgoto out;\n\t}\n\n\t/* using write lock to protect desc->count */\n\tmutex_lock(&desc->wlock);\n\tif (!desc->count++) {\n\t\tdesc->werr = 0;\n\t\tdesc->rerr = 0;\n\t\trv = usb_submit_urb(desc->validity, GFP_KERNEL);\n\t\tif (rv < 0) {\n\t\t\tdesc->count--;\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Error submitting int urb - %d\\n\", rv);\n\t\t\trv = usb_translate_errors(rv);\n\t\t}\n\t} else {\n\t\trv = 0;\n\t}\n\tmutex_unlock(&desc->wlock);\n\tif (desc->count == 1)\n\t\tdesc->manage_power(intf, 1);\n\tusb_autopm_put_interface(desc->intf);\nout:\n\tmutex_unlock(&wdm_mutex);\n\treturn rv;\n}\n\nstatic int wdm_release(struct inode *inode, struct file *file)\n{\n\tstruct wdm_device *desc = file->private_data;\n\n\tmutex_lock(&wdm_mutex);\n\n\t/* using write lock to protect desc->count */\n\tmutex_lock(&desc->wlock);\n\tdesc->count--;\n\tmutex_unlock(&desc->wlock);\n\n\tif (!desc->count) {\n\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\tdev_dbg(&desc->intf->dev, \"wdm_release: cleanup\");\n\t\t\tkill_urbs(desc);\n\t\t\tdesc->manage_power(desc->intf, 0);\n\t\t} else {\n\t\t\t/* must avoid dev_printk here as desc->intf is invalid */\n\t\t\tpr_debug(KBUILD_MODNAME \" %s: device gone - cleaning up\\n\", __func__);\n\t\t\tcleanup(desc);\n\t\t}\n\t}\n\tmutex_unlock(&wdm_mutex);\n\treturn 0;\n}\n\nstatic const struct file_operations wdm_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\twdm_read,\n\t.write =\twdm_write,\n\t.open =\t\twdm_open,\n\t.flush =\twdm_flush,\n\t.release =\twdm_release,\n\t.poll =\t\twdm_poll,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic struct usb_class_driver wdm_class = {\n\t.name =\t\t\"cdc-wdm%d\",\n\t.fops =\t\t&wdm_fops,\n\t.minor_base =\tWDM_MINOR_BASE,\n};\n\n/* --- error handling --- */\nstatic void wdm_rxwork(struct work_struct *work)\n{\n\tstruct wdm_device *desc = container_of(work, struct wdm_device, rxwork);\n\tunsigned long flags;\n\tint rv;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\trv = usb_submit_urb(desc->response, GFP_KERNEL);\n\t\tif (rv < 0 && rv != -EPERM) {\n\t\t\tspin_lock_irqsave(&desc->iuspin, flags);\n\t\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\t\t\tschedule_work(&desc->rxwork);\n\t\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\t}\n\t}\n}\n\n/* --- hotplug --- */\n\nstatic int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor *ep,\n\t\tu16 bufsize, int (*manage_power)(struct usb_interface *, int))\n{\n\tint rv = -ENOMEM;\n\tstruct wdm_device *desc;\n\n\tdesc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);\n\tif (!desc)\n\t\tgoto out;\n\tINIT_LIST_HEAD(&desc->device_list);\n\tmutex_init(&desc->rlock);\n\tmutex_init(&desc->wlock);\n\tspin_lock_init(&desc->iuspin);\n\tinit_waitqueue_head(&desc->wait);\n\tdesc->wMaxCommand = bufsize;\n\t/* this will be expanded and needed in hardware endianness */\n\tdesc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);\n\tdesc->intf = intf;\n\tINIT_WORK(&desc->rxwork, wdm_rxwork);\n\n\trv = -EINVAL;\n\tif (!usb_endpoint_is_int_in(ep))\n\t\tgoto err;\n\n\tdesc->wMaxPacketSize = usb_endpoint_maxp(ep);\n\n\tdesc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!desc->orq)\n\t\tgoto err;\n\tdesc->irq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!desc->irq)\n\t\tgoto err;\n\n\tdesc->validity = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->validity)\n\t\tgoto err;\n\n\tdesc->response = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->response)\n\t\tgoto err;\n\n\tdesc->command = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->command)\n\t\tgoto err;\n\n\tdesc->ubuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\n\tif (!desc->ubuf)\n\t\tgoto err;\n\n\tdesc->sbuf = kmalloc(desc->wMaxPacketSize, GFP_KERNEL);\n\tif (!desc->sbuf)\n\t\tgoto err;\n\n\tdesc->inbuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\n\tif (!desc->inbuf)\n\t\tgoto err;\n\n\tusb_fill_int_urb(\n\t\tdesc->validity,\n\t\tinterface_to_usbdev(intf),\n\t\tusb_rcvintpipe(interface_to_usbdev(intf), ep->bEndpointAddress),\n\t\tdesc->sbuf,\n\t\tdesc->wMaxPacketSize,\n\t\twdm_int_callback,\n\t\tdesc,\n\t\tep->bInterval\n\t);\n\n\tdesc->irq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);\n\tdesc->irq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\n\tdesc->irq->wValue = 0;\n\tdesc->irq->wIndex = desc->inum;\n\tdesc->irq->wLength = cpu_to_le16(desc->wMaxCommand);\n\n\tusb_fill_control_urb(\n\t\tdesc->response,\n\t\tinterface_to_usbdev(intf),\n\t\t/* using common endpoint 0 */\n\t\tusb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),\n\t\t(unsigned char *)desc->irq,\n\t\tdesc->inbuf,\n\t\tdesc->wMaxCommand,\n\t\twdm_in_callback,\n\t\tdesc\n\t);\n\n\tdesc->manage_power = manage_power;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_add(&desc->device_list, &wdm_device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\n\trv = usb_register_dev(intf, &wdm_class);\n\tif (rv < 0)\n\t\tgoto err;\n\telse\n\t\tdev_info(&intf->dev, \"%s: USB WDM device\\n\", dev_name(intf->usb_dev));\nout:\n\treturn rv;\nerr:\n\tspin_lock(&wdm_device_list_lock);\n\tlist_del(&desc->device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\tcleanup(desc);\n\treturn rv;\n}\n\nstatic int wdm_manage_power(struct usb_interface *intf, int on)\n{\n\t/* need autopm_get/put here to ensure the usbcore sees the new value */\n\tint rv = usb_autopm_get_interface(intf);\n\tif (rv < 0)\n\t\tgoto err;\n\n\tintf->needs_remote_wakeup = on;\n\tusb_autopm_put_interface(intf);\nerr:\n\treturn rv;\n}\n\nstatic int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint rv = -EINVAL;\n\tstruct usb_host_interface *iface;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_cdc_dmm_desc *dmhd;\n\tu8 *buffer = intf->altsetting->extra;\n\tint buflen = intf->altsetting->extralen;\n\tu16 maxcom = WDM_DEFAULT_BUFSIZE;\n\n\tif (!buffer)\n\t\tgoto err;\n\twhile (buflen > 2) {\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tdmhd = (struct usb_cdc_dmm_desc *)buffer;\n\t\t\tmaxcom = le16_to_cpu(dmhd->wMaxCommand);\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Finding maximum buffer length: %d\", maxcom);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Ignoring extra header, type %d, length %d\\n\",\n\t\t\t\tbuffer[2], buffer[0]);\n\t\t\tbreak;\n\t\t}\nnext_desc:\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tiface = intf->cur_altsetting;\n\tif (iface->desc.bNumEndpoints != 1)\n\t\tgoto err;\n\tep = &iface->endpoint[0].desc;\n\n\trv = wdm_create(intf, ep, maxcom, &wdm_manage_power);\n\nerr:\n\treturn rv;\n}\n\n/**\n * usb_cdc_wdm_register - register a WDM subdriver\n * @intf: usb interface the subdriver will associate with\n * @ep: interrupt endpoint to monitor for notifications\n * @bufsize: maximum message size to support for read/write\n *\n * Create WDM usb class character device and associate it with intf\n * without binding, allowing another driver to manage the interface.\n *\n * The subdriver will manage the given interrupt endpoint exclusively\n * and will issue control requests referring to the given intf. It\n * will otherwise avoid interferring, and in particular not do\n * usb_set_intfdata/usb_get_intfdata on intf.\n *\n * The return value is a pointer to the subdriver's struct usb_driver.\n * The registering driver is responsible for calling this subdriver's\n * disconnect, suspend, resume, pre_reset and post_reset methods from\n * its own.\n */\nstruct usb_driver *usb_cdc_wdm_register(struct usb_interface *intf,\n\t\t\t\t\tstruct usb_endpoint_descriptor *ep,\n\t\t\t\t\tint bufsize,\n\t\t\t\t\tint (*manage_power)(struct usb_interface *, int))\n{\n\tint rv = -EINVAL;\n\n\trv = wdm_create(intf, ep, bufsize, manage_power);\n\tif (rv < 0)\n\t\tgoto err;\n\n\treturn &wdm_driver;\nerr:\n\treturn ERR_PTR(rv);\n}\nEXPORT_SYMBOL(usb_cdc_wdm_register);\n\nstatic void wdm_disconnect(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc;\n\tunsigned long flags;\n\n\tusb_deregister_dev(intf, &wdm_class);\n\tdesc = wdm_find_device(intf);\n\tmutex_lock(&wdm_mutex);\n\n\t/* the spinlock makes sure no new urbs are generated in the callbacks */\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tset_bit(WDM_DISCONNECTING, &desc->flags);\n\tset_bit(WDM_READ, &desc->flags);\n\t/* to terminate pending flushes */\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\twake_up_all(&desc->wait);\n\tmutex_lock(&desc->rlock);\n\tmutex_lock(&desc->wlock);\n\tkill_urbs(desc);\n\tcancel_work_sync(&desc->rxwork);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\n\t/* the desc->intf pointer used as list key is now invalid */\n\tspin_lock(&wdm_device_list_lock);\n\tlist_del(&desc->device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\n\tif (!desc->count)\n\t\tcleanup(desc);\n\telse\n\t\tdev_dbg(&intf->dev, \"%s: %d open files - postponing cleanup\\n\", __func__, desc->count);\n\tmutex_unlock(&wdm_mutex);\n}\n\n#ifdef CONFIG_PM\nstatic int wdm_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv = 0;\n\n\tdev_dbg(&desc->intf->dev, \"wdm%d_suspend\\n\", intf->minor);\n\n\t/* if this is an autosuspend the caller does the locking */\n\tif (!PMSG_IS_AUTO(message)) {\n\t\tmutex_lock(&desc->rlock);\n\t\tmutex_lock(&desc->wlock);\n\t}\n\tspin_lock_irq(&desc->iuspin);\n\n\tif (PMSG_IS_AUTO(message) &&\n\t\t\t(test_bit(WDM_IN_USE, &desc->flags)\n\t\t\t|| test_bit(WDM_RESPONDING, &desc->flags))) {\n\t\tspin_unlock_irq(&desc->iuspin);\n\t\trv = -EBUSY;\n\t} else {\n\n\t\tset_bit(WDM_SUSPENDING, &desc->flags);\n\t\tspin_unlock_irq(&desc->iuspin);\n\t\t/* callback submits work - order is essential */\n\t\tkill_urbs(desc);\n\t\tcancel_work_sync(&desc->rxwork);\n\t}\n\tif (!PMSG_IS_AUTO(message)) {\n\t\tmutex_unlock(&desc->wlock);\n\t\tmutex_unlock(&desc->rlock);\n\t}\n\n\treturn rv;\n}\n#endif\n\nstatic int recover_from_urb_loss(struct wdm_device *desc)\n{\n\tint rv = 0;\n\n\tif (desc->count) {\n\t\trv = usb_submit_urb(desc->validity, GFP_NOIO);\n\t\tif (rv < 0)\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Error resume submitting int urb - %d\\n\", rv);\n\t}\n\treturn rv;\n}\n\n#ifdef CONFIG_PM\nstatic int wdm_resume(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tdev_dbg(&desc->intf->dev, \"wdm%d_resume\\n\", intf->minor);\n\n\tclear_bit(WDM_SUSPENDING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\n\treturn rv;\n}\n#endif\n\nstatic int wdm_pre_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\n\t/*\n\t * we notify everybody using poll of\n\t * an exceptional situation\n\t * must be done before recovery lest a spontaneous\n\t * message from the device is lost\n\t */\n\tspin_lock_irq(&desc->iuspin);\n\tset_bit(WDM_RESETTING, &desc->flags);\t/* inform read/write */\n\tset_bit(WDM_READ, &desc->flags);\t/* unblock read */\n\tclear_bit(WDM_IN_USE, &desc->flags);\t/* unblock write */\n\tdesc->rerr = -EINTR;\n\tspin_unlock_irq(&desc->iuspin);\n\twake_up_all(&desc->wait);\n\tmutex_lock(&desc->rlock);\n\tmutex_lock(&desc->wlock);\n\tkill_urbs(desc);\n\tcancel_work_sync(&desc->rxwork);\n\treturn 0;\n}\n\nstatic int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}\n\nstatic struct usb_driver wdm_driver = {\n\t.name =\t\t\"cdc_wdm\",\n\t.probe =\twdm_probe,\n\t.disconnect =\twdm_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\twdm_suspend,\n\t.resume =\twdm_resume,\n\t.reset_resume =\twdm_resume,\n#endif\n\t.pre_reset =\twdm_pre_reset,\n\t.post_reset =\twdm_post_reset,\n\t.id_table =\twdm_ids,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(wdm_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/class/cdc-wdm.c"], "buggy_code_start_loc": [58], "buggy_code_end_loc": [1006], "fixing_code_start_loc": [59], "fixing_code_end_loc": [1024], "type": "CWE-119", "message": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.", "other": {"cve": {"id": "CVE-2013-1860", "sourceIdentifier": "secalert@redhat.com", "published": "2013-03-22T11:59:11.693", "lastModified": "2023-02-13T04:41:46.713", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n drivers/usb/class/cdc-wdm.c en el kernel de Linux anterior a v3.8.4 permite a atacantes f\u00edsicamente pr\u00f3ximos causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de un dispositivo USB cdc-wdm  espcialmente dise\u00f1ado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.3", "matchCriteriaId": "7A40E2A8-BBC3-4763-B150-9193F30E9DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=c0f5ecee4e741667b2493c742b60b6218d40b3aa", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0328.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0339.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.4", "source": "secalert@redhat.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/15/3", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/58510", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1809-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1811-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1812-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1813-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1814-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1829-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=921970", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa"}}