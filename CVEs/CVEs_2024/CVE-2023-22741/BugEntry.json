{"buggy_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n#ifndef STUN_COMMON_H\n/** Defined when <sofia-sip/stun_common.h> has been included. */\n#define STUN_COMMON_H\n\n/**\n * @file sofia-sip/stun_common.h\n * @brief\n *\n * @author Tat Chan <Tat.Chan@nokia.com>\n *\n * @date Created: Fri Oct  3 13:39:55 2003 ppessi\n *\n */\n\n#include <sofia-sip/su_localinfo.h>\n\nSOFIA_BEGIN_DECLS\n\n/* Define Message Types */\n#define BINDING_REQUEST               0x0001\n#define BINDING_RESPONSE              0x0101\n#define BINDING_ERROR_RESPONSE        0x0111\n#define SHARED_SECRET_REQUEST         0x0002\n#define SHARED_SECRET_RESPONSE        0x0102\n#define SHARED_SECRET_ERROR_RESPONSE  0x0112\n\n/* Define Attribute Types */\n#define MAPPED_ADDRESS                0x0001\n#define RESPONSE_ADDRESS              0x0002\n#define CHANGE_REQUEST                0x0003\n#define SOURCE_ADDRESS                0x0004\n#define CHANGED_ADDRESS               0x0005\n#define USERNAME                      0x0006\n#define PASSWORD                      0x0007\n#define MESSAGE_INTEGRITY             0x0008\n#define ERROR_CODE                    0x0009\n#define UNKNOWN_ATTRIBUTES            0x000a\n#define REFLECTED_FROM                0x000b\n#define STUN_A_REALM                  0x0014 /* XXX: check value in 3489bis-05+ */\n#define STUN_A_NONCE                  0x0015 /* XXX: check value in 3489bis-05+ */\n#define STUN_A_XOR_MAPPED_ADDRESS     0x0020\n#define STUN_A_FINGERPRINT            0x0023\n#define STUN_A_SERVER                 0x8022\n#define STUN_A_ALTERNATE_SERVER       0x8023\n#define STUN_A_REFRESH_INTERVAL       0x8024\n\n/* Defines for mandatory and optional attributes */\n#define STUN_A_LAST_MANDATORY         0x0023 /**< largest attribute in the current\n\t\t\t\t\t\tspec (see above for exceptions\n\t\t\t\t\t\tfor buggy servers) */\n#define STUN_A_OPTIONAL               0x7fff\n\n/* Compability attribute types */\n#define STUN_A_ALTERNATE_SERVER_DEP   0x000e /**< historic from early fc3489bis drafts */\n#define STUN_A_BUGGYSERVER_XORONLY    0x0021 /**< workaround for stund-0.94 and older */\n#define STUN_A_BUGGYSERVER_SERVER     0x0022 /**< workaround for stund-0.94 and older */\n#define LARGEST_ATTRIBUTE             STUN_A_LAST_MANDATORY /**< deprecated API */\n#define OPTIONAL_ATTRIBUTE            STUN_A_OPTIONAL /**< deprecated API */\n\n/* Stun response codes */\n#define STUN_400_BAD_REQUEST             400\n#define STUN_401_UNAUTHORIZED            401\n#define STUN_420_UNKNOWN_ATTRIBUTE       420\n#define STUN_430_STALE_CREDENTIALS       430\n#define STUN_431_INTEGRITY_CHECK_FAILURE 431\n#define STUN_432_MISSING_USERNAME        432\n#define STUN_433_USE_TLS                 433\n#define STUN_500_SERVER_ERROR            500\n#define STUN_600_GLOBAL_FAILURE          600\n\n/* flags for CHANGE_REQUEST */\n#define STUN_CR_CHANGE_IP               0x0004\n#define STUN_CR_CHANGE_PORT             0x0002\n\n/* mask for ERROR_CODE */\n#define STUN_EC_CLASS                   0x0070\n#define STUN_EC_NUM                     0x000F\n\n#define RAND_MAX_16                     65535\n\n#define STUN_TID_BYTES                  16\n\n/* other protocol specific parameters */\n#define STUN_MAX_RETRX                  5 /* should be 8? */\n#define STUN_MAX_RETRX_INT              1600  /**< max retrx interval in\n\t\t\t\t\t\t   millisec */\n#define STUN_DEFAULT_PORT               3478  /**< from RFC3489 */\n\n/*\n * STUN header format\n */\n  /*\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         message type          |       message length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n   |                       Transaction ID                          |\n   |                                                               |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  */\nstruct stun_buffer_s {\n  unsigned char *data;      /**< Pointer to data */\n  unsigned size;            /**< Size of buffer */\n};\n\ntypedef struct stun_buffer_s stun_buffer_t;\n\ntypedef struct {\n  uint16_t msg_type;        /**< message type */\n  uint16_t msg_len;         /**< message length */\n  uint8_t tran_id[16];      /**< transaction id, 128 bits */\n} stun_hdr_t;\n\ntypedef struct stun_attr_s {\n  uint16_t attr_type;       /**< attribute type */\n  void *pattr;              /**< pointer to corresponding attribute */\n  stun_buffer_t enc_buf;    /**< encoded attribue */\n  struct stun_attr_s *next; /**< next attribute */\n} stun_attr_t;\n\ntypedef struct {\n  stun_hdr_t stun_hdr;\n  stun_attr_t *stun_attr;\n  stun_buffer_t enc_buf;    /**< to store already encoded stun msg */\n} stun_msg_t;\n\n/* stun attribute definition */\n/* stun_sockaddr_t is used for:\n   MAPPED_ADDRESS\n   RESPONSE_ADDRESS\n   SOURCE_ADDRESS\n   CHANGED_ADDRESS\n   REFLECTED_FROM\n*/\ntypedef struct sockaddr_in stun_attr_sockaddr_t;\n\n/* CHANGE_REQUEST attribute */\ntypedef struct stun_attr_uint32_s {\n  uint32_t value;\n} stun_attr_uint32_t;\n\ntypedef stun_attr_uint32_t stun_attr_changerequest_t;\n\n/* ERROR_CODE attribute */\ntypedef struct {\n  int code;\n  char *phrase;\n} stun_attr_errorcode_t;\n\n/* USERNAME attribute */\n/* typedef struct {\n  stun_buffer_t *uname;\n} stun_attr_username_t;\n*/\ntypedef stun_buffer_t stun_attr_username_t;\n\n/* PASSWORD attribute */\ntypedef stun_buffer_t stun_attr_password_t;\n\n/* UNKNOWN_ATTRIBUTES attribute */\ntypedef struct stun_attr_unknownattributes_s{\n  uint16_t attr_type[2];\n  struct stun_attr_unknownattributes_s *next;\n} stun_attr_unknownattributes_t;\n\n/* Common functions */\nint stun_parse_message(stun_msg_t *msg);\nint stun_parse_attribute(stun_msg_t *msg, unsigned char *p);\nint stun_parse_attr_address(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_error_code(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_unknown_attributes(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_uint32(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_buffer(stun_attr_t *attr, const unsigned char *p, unsigned len);\n\nstun_attr_t *stun_get_attr(stun_attr_t *attr, uint16_t attr_type);\n\nint stun_encode_address(stun_attr_t *attr);\nint stun_encode_uint32(stun_attr_t *attr);\nint stun_encode_buffer(stun_attr_t *attr);\nint stun_encode_error_code(stun_attr_t *attr);\nint stun_encode_message_integrity(stun_attr_t *attr, unsigned char *buf, int len, stun_buffer_t *pwd);\nint stun_encode_type_len(stun_attr_t *attr, uint16_t len);\nint stun_encode_response_address(stun_attr_t *attr);\n\nint stun_validate_message_integrity(stun_msg_t *msg, stun_buffer_t *pwd);\n\nint stun_copy_buffer(stun_buffer_t *p, stun_buffer_t *p2);\nvoid stun_init_buffer(stun_buffer_t *p);\nint stun_free_buffer(stun_buffer_t *p);\nint stun_free_message(stun_msg_t *msg);\n\nint stun_init_message(stun_msg_t *msg);\n/* int stun_send_message(int sockfd, struct sockaddr_in *to_addr, stun_msg_t *msg, stun_buffer_t *pwd); */\nint stun_encode_message(stun_msg_t *msg, stun_buffer_t *pwd);\n\nchar const *stun_response_phrase(int status);\nvoid debug_print(stun_buffer_t *buf);\nchar const *stun_attr_phrase(uint16_t type);\n\n/**Determines and returns local IP address\n *\n * Address is determined using su_getlocalinfo() function.\n *\n * @param family        network address family in use\n * @return local ip address\n */\nchar *stun_determine_ip_address(int family);\n\nSOFIA_END_DECLS\n\n#endif /* !defined STUN_COMMON_H */\n", "/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@internal\n * @file stun_common.c\n * @brief\n *\n * @author Tat Chan <Tat.Chan@nokia.com>\n * @author Kai Vehmanen <kai.vehmanen@nokia.com>\n *\n * @date Created: Fri Oct  3 13:40:41 2003 ppessi\n *\n */\n\n#include \"config.h\"\n\n#ifdef USE_TURN\n#include \"../turn/turn_common.h\"\n#undef STUN_A_LAST_MANDATORY\n#define STUN_A_LAST_MANDATORY TURN_LARGEST_ATTRIBUTE\n#endif\n\n#include \"stun_internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#if HAVE_FUNC\n#elif HAVE_FUNCTION\n#define __func__ __FUNCTION__\n#else\n#define __func__ \"stun_common\"\n#endif\n\nconst char stun_400_Bad_request[] = \"Bad Request\",\n  stun_401_Unauthorized[] = \"Unauthorized\",\n  stun_420_Unknown_attribute[] = \"Unknown Attribute\",\n  stun_430_Stale_credentials[] = \"Stale Credentials\",\n  stun_431_Integrity_check_failure[] = \"Integrity Check Failure\",\n  stun_432_Missing_username[] = \"Missing Username\",\n  stun_433_Use_tls[] = \"Use TLS\",\n#ifdef USE_TURN\n  turn_434_Missing_realm[] = \"Missing Realm\",\n  turn_435_Missing_nonce[] = \"Missing Nonce\",\n  turn_436_Unknown_username[] = \"Unknown Username\",\n  turn_437_No_binding[] = \"No Binding\",\n  turn_439_Illegal_port[] = \"Illegal Port\",\n#endif\n  stun_500_Server_error[] = \"Server Error\",\n  stun_600_Global_failure[] = \"Global Failure\";\n\n#define set16(b, offset, value)\t\t\t\\\n  (((b)[(offset) + 0] = ((value) >> 8) & 255),\t\\\n   ((b)[(offset) + 1] = (value) & 255))\n\n#define get16(b, offset)\t\\\n  (((b)[(offset) + 0] << 8) |\t\\\n   ((b)[(offset) + 1] << 0))\n\nint stun_parse_message(stun_msg_t *msg)\n{\n  unsigned len;\n  int i;\n  unsigned char *p;\n\n  /* parse header first */\n  p = msg->enc_buf.data;\n  msg->stun_hdr.msg_type = get16(p, 0);\n  msg->stun_hdr.msg_len = get16(p, 2);\n  memcpy(msg->stun_hdr.tran_id, p + 4, STUN_TID_BYTES);\n\n  SU_DEBUG_5((\"%s: Parse STUN message: Length = %d\\n\", __func__,\n\t      msg->stun_hdr.msg_len));\n\n  /* parse attributes */\n  len = msg->stun_hdr.msg_len;\n  p = msg->enc_buf.data + 20;\n  msg->stun_attr = NULL;\n  while (len > 0) {\n    i = stun_parse_attribute(msg, p);\n    if (i <= 0 || i > len) {\n      SU_DEBUG_3((\"%s: Error parsing attribute.\\n\", __func__));\n      return -1;\n    }\n    p += i;\n    len -= i;\n  }\n\n  return 0;\n}\n\nint stun_parse_attribute(stun_msg_t *msg, unsigned char *p)\n{\n  int len;\n  uint16_t attr_type;\n  stun_attr_t *attr, *next;\n\n  attr_type = get16(p, 0);\n  len = get16(p, 2);\n\n  SU_DEBUG_5((\"%s: received attribute: Type %02X, Length %d - %s\\n\",\n\t      __func__, attr_type, len, stun_attr_phrase(attr_type)));\n\n  if (attr_type > STUN_A_LAST_MANDATORY && attr_type < STUN_A_OPTIONAL) {\n    return -1;\n  }\n\n  attr = (stun_attr_t *)calloc(1, sizeof(stun_attr_t));\n  if (!attr)\n    return -1;\n  attr->next = NULL;\n  attr->attr_type = attr_type;\n  p += 4;\n\n  switch (attr->attr_type) {\n  case MAPPED_ADDRESS:\n  case RESPONSE_ADDRESS:\n  case SOURCE_ADDRESS:\n  case CHANGED_ADDRESS:\n  case REFLECTED_FROM:\n#ifdef USE_TURN\n  case TURN_ALTERNATE_SERVER:\n  case TURN_DESTINATION_ADDRESS:\n  case TURN_SOURCE_ADDRESS:\n#endif\n    if (stun_parse_attr_address(attr, p, len) < 0) {\n      free(attr);\n      return -1;\n    }\n    break;\n  case ERROR_CODE:\n    if (stun_parse_attr_error_code(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  case UNKNOWN_ATTRIBUTES:\n    if(stun_parse_attr_unknown_attributes(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  case CHANGE_REQUEST:\n#ifdef USE_TURN\n  case TURN_LIFETIME:\n  case TURN_MAGIC_COOKIE:\n  case TURN_BANDWIDTH:\n#endif\n    if (stun_parse_attr_uint32(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  case USERNAME:\n  case PASSWORD:\n  case STUN_A_REALM:\n  case STUN_A_NONCE:\n#ifdef USE_TURN\n  case TURN_DATA:\n  case TURN_NONCE:\n#endif\n    if (stun_parse_attr_buffer(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  default:\n    /* just copy as is */\n    attr->pattr = NULL;\n    attr->enc_buf.size = len;\n    attr->enc_buf.data = (unsigned char *) malloc(len);\n    memcpy(attr->enc_buf.data, p, len);\n    break;\n  }\n\n  /* skip to end of list */\n  if(msg->stun_attr==NULL) {\n    msg->stun_attr = attr;\n  }\n  else {\n    next = msg->stun_attr;\n    while(next->next!=NULL) {\n      next = next->next;\n    }\n    next->next = attr;\n  }\n  return len+4;\n}\n\nint stun_parse_attr_address(stun_attr_t *attr,\n\t\t\t    const unsigned char *p,\n\t\t\t    unsigned len)\n{\n  su_sockaddr_t *addr;\n  int addrlen;\n  char ipaddr[SU_ADDRSIZE + 2];\n\n  if (len != 8) {\n    return -1;\n  }\n\n  addrlen = sizeof(su_sockaddr_t);\n  addr = (su_sockaddr_t *) malloc(addrlen);\n\n  if (*(p+1) == 1) { /* expected value for IPv4 */\n    addr->su_sin.sin_family = AF_INET;\n  }\n  else {\n    free(addr);\n    return -1;\n  }\n  memcpy(&addr->su_sin.sin_port, p + 2, 2);\n  memcpy(&addr->su_sin.sin_addr.s_addr, p + 4, 4);\n\n  SU_DEBUG_5((\"%s: address attribute: %s:%d\\n\", __func__,\n\t      su_inet_ntop(addr->su_family, SU_ADDR(addr), ipaddr, sizeof(ipaddr)),\n\t      (unsigned) ntohs(addr->su_sin.sin_port)));\n\n  attr->pattr = addr;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_error_code(stun_attr_t *attr, const unsigned char *p, unsigned len) {\n\n  uint32_t tmp;\n  stun_attr_errorcode_t *error;\n\n  memcpy(&tmp, p, sizeof(uint32_t));\n  tmp = ntohl(tmp);\n  error = (stun_attr_errorcode_t *) malloc(sizeof(*error));\n\n  error->code = (tmp & STUN_EC_CLASS)*100 + (tmp & STUN_EC_NUM);\n\n  error->phrase = (char *) malloc(len-3);\n\n  strncpy(error->phrase, (char*)p+4, len-4);\n  error->phrase[len - 4] = '\\0';\n\n  attr->pattr = error;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_uint32(stun_attr_t *attr, const unsigned char *p, unsigned len)\n{\n  uint32_t tmp;\n  stun_attr_changerequest_t *cr;\n  cr = (stun_attr_changerequest_t *) malloc(sizeof(*cr));\n  memcpy(&tmp, p, sizeof(uint32_t));\n  cr->value = ntohl(tmp);\n  attr->pattr = cr;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_buffer(stun_attr_t *attr, const unsigned char *p, unsigned len)\n{\n  stun_buffer_t *buf;\n  buf = (stun_buffer_t *) malloc(sizeof(stun_buffer_t));\n  buf->size = len;\n  buf->data = (unsigned char *) malloc(len);\n  memcpy(buf->data, p, len);\n  attr->pattr = buf;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_unknown_attributes(stun_attr_t *attr,\n\t\t\t\t       const unsigned char *p,\n\t\t\t\t       unsigned len)\n{\n  return 0;\n}\n\n/** scan thru attribute list and return the next requested attr */\nstun_attr_t *stun_get_attr(stun_attr_t *attr, uint16_t attr_type) {\n  stun_attr_t *p;\n\n  for (p = attr; p != NULL; p = p->next) {\n    if (p->attr_type == attr_type)\n      break;\n  }\n\n  return p;\n}\n\nvoid stun_init_buffer(stun_buffer_t *p) {\n  p->data = NULL;\n  p->size = 0;\n}\n\nint stun_free_buffer(stun_buffer_t *p) {\n  if (p->data)\n    free(p->data), p->data = NULL;\n  p->size = 0;\n  return 0;\n}\n\nint stun_copy_buffer(stun_buffer_t *p, stun_buffer_t *p2) {\n  stun_free_buffer(p); /* clean up existing data */\n  p->size = p2->size;\n  p->data = (unsigned char *) malloc(p->size);\n  memcpy(p->data, p2->data, p->size);\n  return p->size;\n}\n\nconst char *stun_response_phrase(int status) {\n  if (status <100 || status >600)\n    return NULL;\n\n  switch (status) {\n  case STUN_400_BAD_REQUEST: return stun_400_Bad_request;\n  case STUN_401_UNAUTHORIZED: return stun_401_Unauthorized;\n  case STUN_420_UNKNOWN_ATTRIBUTE: return stun_420_Unknown_attribute;\n  case STUN_430_STALE_CREDENTIALS: return stun_430_Stale_credentials;\n  case STUN_431_INTEGRITY_CHECK_FAILURE: return stun_431_Integrity_check_failure;\n  case STUN_432_MISSING_USERNAME: return stun_432_Missing_username;\n  case STUN_433_USE_TLS: return stun_433_Use_tls;\n#ifdef USE_TURN\n  case TURN_MISSING_REALM: return turn_434_Missing_realm;\n  case TURN_MISSING_NONCE: return turn_435_Missing_nonce;\n  case TURN_UNKNOWN_USERNAME: return turn_436_Unknown_username;\n  case TURN_NO_BINDING: return turn_437_No_binding;\n  case TURN_ILLEGAL_PORT: return turn_439_Illegal_port;\n#endif\n  case STUN_500_SERVER_ERROR: return stun_500_Server_error;\n  case STUN_600_GLOBAL_FAILURE: return stun_600_Global_failure;\n  }\n  return \"Response\";\n}\n\n/** The set of functions encodes the corresponding attribute to\n *    network format, and save the result to the enc_buf. Return the\n *    size of the buffer.\n */\n\n\n/* This function is used to encode any attribute of the form ADDRESS\n   */\nint stun_encode_address(stun_attr_t *attr) {\n  stun_attr_sockaddr_t *a;\n  uint16_t tmp;\n\n  a = (stun_attr_sockaddr_t *)attr->pattr;\n\n  if (stun_encode_type_len(attr, 8) < 0) {\n    return -1;\n  }\n\n  tmp = htons(0x01); /* FAMILY = 0x01 */\n  memcpy(attr->enc_buf.data+4, &tmp, sizeof(tmp));\n  memcpy(attr->enc_buf.data+6, &a->sin_port, 2);\n  memcpy(attr->enc_buf.data+8, &a->sin_addr.s_addr, 4);\n\n  return attr->enc_buf.size;\n}\n\nint stun_encode_uint32(stun_attr_t *attr) {\n  uint32_t tmp;\n\n  if (stun_encode_type_len(attr, 4) < 0) {\n    return -1;\n  }\n\n  tmp = htonl(((stun_attr_changerequest_t *) attr->pattr)->value);\n  memcpy(attr->enc_buf.data+4, &tmp, 4);\n  return attr->enc_buf.size;\n}\n\nint stun_encode_error_code(stun_attr_t *attr) {\n  short int class, num;\n  size_t phrase_len, padded;\n  stun_attr_errorcode_t *error;\n\n  error = (stun_attr_errorcode_t *) attr->pattr;\n  class = error->code / 100;\n  num = error->code % 100;\n\n  phrase_len = strlen(error->phrase);\n  if (phrase_len + 8 > 65536)\n    phrase_len = 65536 - 8;\n\n  /* note: align the phrase len (see RFC3489:11.2.9) */\n  padded = phrase_len + (phrase_len % 4 == 0 ? 0 : 4 - (phrase_len % 4));\n\n  /* note: error-code has four octets of headers plus the\n   *       reason field -> len+4 octets */\n  if (stun_encode_type_len(attr, (uint16_t)(padded + 4)) < 0) {\n    return -1;\n  }\n  else {\n    assert(attr->enc_buf.size == padded + 8);\n    memset(attr->enc_buf.data+4, 0, 2);\n    attr->enc_buf.data[6] = class;\n    attr->enc_buf.data[7] = num;\n    /* note: 4 octets of TLV header and 4 octets of error-code header */\n    memcpy(attr->enc_buf.data+8, error->phrase,\n\t   phrase_len);\n    memset(attr->enc_buf.data + 8 + phrase_len, 0, padded - phrase_len);\n  }\n\n  return attr->enc_buf.size;\n}\n\nint stun_encode_buffer(stun_attr_t *attr) {\n  stun_buffer_t *a;\n\n  a = (stun_buffer_t *)attr->pattr;\n  assert(a->size < 65536);\n  if (stun_encode_type_len(attr, (uint16_t)a->size) < 0) {\n    return -1;\n  }\n\n  memcpy(attr->enc_buf.data+4, a->data, a->size);\n  return attr->enc_buf.size;\n}\n\n#if defined(HAVE_OPENSSL)\nint stun_encode_message_integrity(stun_attr_t *attr,\n\t\t\t\t  unsigned char *buf,\n\t\t\t\t  int len,\n\t\t\t\t  stun_buffer_t *pwd) {\n  int padded_len;\n  unsigned int dig_len;\n  unsigned char *padded_text = NULL;\n  void *sha1_hmac;\n\n  if (stun_encode_type_len(attr, 20) < 0) {\n    return -1;\n  }\n\n  /* zero padding */\n  if (len % 64 != 0) {\n\n    padded_len = len + (64 - (len % 64));\n    padded_text = (unsigned char *) malloc(padded_len);\n    memcpy(padded_text, buf, len);\n    memset(padded_text + len, 0, padded_len - len);\n\n    sha1_hmac = HMAC(EVP_sha1(), pwd->data, pwd->size, padded_text, padded_len, NULL, &dig_len);\n  }\n  else {\n    sha1_hmac = HMAC(EVP_sha1(), pwd->data, pwd->size, buf, len, NULL, &dig_len);\n  }\n\n  assert(dig_len == 20);\n\n  memcpy(attr->enc_buf.data + 4, sha1_hmac, 20);\n  free(padded_text);\n  return attr->enc_buf.size;\n}\n#else\nint stun_encode_message_integrity(stun_attr_t *attr,\n\t\t\t\t  unsigned char *buf,\n\t\t\t\t  int len,\n\t\t\t\t  stun_buffer_t *pwd) {\n\n  return 0;\n}\n#endif /* HAVE_OPENSSL */\n\n/** this function allocates the enc_buf, fills in type, length */\nint stun_encode_type_len(stun_attr_t *attr, uint16_t len) {\n  uint16_t tmp;\n\n  attr->enc_buf.data = (unsigned char *) malloc(len + 4);\n  memset(attr->enc_buf.data, 0, len + 4);\n\n  tmp = htons(attr->attr_type);\n  memcpy(attr->enc_buf.data, &tmp, 2);\n\n  tmp = htons(len);\n  memcpy(attr->enc_buf.data + 2, &tmp, 2);\n  attr->enc_buf.size = len + 4;\n\n  return 0;\n}\n\n/**\n * Validate the message integrity based on given\n * STUN password 'pwd'. The received content should be\n * in msg->enc_buf.\n */\nint stun_validate_message_integrity(stun_msg_t *msg, stun_buffer_t *pwd)\n{\n\n#if defined(HAVE_OPENSSL)\n  int padded_len, len;\n  unsigned int dig_len;\n  unsigned char dig[20]; /* received sha1 digest */\n  unsigned char *padded_text;\n#endif\n\n  /* password NULL so shared-secret not established and\n     messege integrity checks can be skipped */\n  if (pwd->data == NULL)\n    return 0;\n\n  /* otherwise the check must match */\n\n#if defined(HAVE_OPENSSL)\n\n  /* message integrity not received */\n  if (stun_get_attr(msg->stun_attr, MESSAGE_INTEGRITY) == NULL) {\n    SU_DEBUG_5((\"%s: error: message integrity missing.\\n\", __func__));\n    return -1;\n  }\n\n  /* zero padding */\n  len = msg->enc_buf.size - 24;\n  padded_len = len + (len % 64 == 0 ? 0 : 64 - (len % 64));\n  padded_text = (unsigned char *) malloc(padded_len);\n  memset(padded_text, 0, padded_len);\n  memcpy(padded_text, msg->enc_buf.data, len);\n\n  memcpy(dig, HMAC(EVP_sha1(), pwd->data, pwd->size, padded_text, padded_len, NULL, &dig_len), 20);\n\n  if (memcmp(dig, msg->enc_buf.data + msg->enc_buf.size - 20, 20) != 0) {\n    /* does not match, but try the test server's password */\n    if (memcmp(msg->enc_buf.data+msg->enc_buf.size-20, \"hmac-not-implemented\", 20) != 0) {\n      SU_DEBUG_5((\"%s: error: message digest problem.\\n\", __func__));\n      return -1;\n    }\n  }\n  else {\n    SU_DEBUG_5((\"%s: message integrity validated.\\n\", __func__));\n  }\n\n  free(padded_text);\n\n  return 0;\n#else /* HAVE_OPENSSL */\n  return -1;\n#endif\n}\n\nvoid debug_print(stun_buffer_t *buf) {\n  unsigned i;\n  for(i = 0; i < buf->size/4; i++) {\n    SU_DEBUG_9((\"%02x %02x %02x %02x\\n\",\n\t\t*(buf->data + i*4),\n\t\t*(buf->data + i*4 +1),\n\t\t*(buf->data + i*4 +2),\n\t\t*(buf->data + i*4 +3)));\n    if (i == 4)\n\t\tSU_DEBUG_9((\"---------------------\\n\" VA_NONE));\n  }\n  SU_DEBUG_9((\"\\n\" VA_NONE));\n}\n\nint stun_init_message(stun_msg_t *msg) {\n  msg->stun_hdr.msg_type = 0;\n  msg->stun_hdr.msg_len = 0;\n  msg->stun_attr = NULL;\n  stun_init_buffer(&msg->enc_buf);\n  return 0;\n}\n\nint stun_free_message(stun_msg_t *msg) {\n\n  stun_attr_t *p, *p2;\n\n  /* clearing header */\n  memset(&msg->stun_hdr, 0, sizeof msg->stun_hdr);\n\n  /* clearing attr */\n  p = msg->stun_attr;\n  while(p) {\n    if(p->pattr) {\n      switch(p->attr_type) {\n      case USERNAME:\n      case PASSWORD:\n#ifdef USE_TURN\n      case TURN_DATA:\n      case TURN_NONCE:\n#endif\n\tstun_free_buffer(p->pattr);\n\tbreak;\n      default:\n\tfree(p->pattr);\n      }\n    }\n    stun_free_buffer(&p->enc_buf);\n    p2 = p->next;\n    free(p);\n    p = p2;\n  }\n  msg->stun_attr = NULL;\n\n  /* clearing buffer */\n  stun_free_buffer(&msg->enc_buf);\n\n  return 0;\n}\n\n\nint stun_send_message(su_socket_t s, su_sockaddr_t *to_addr,\n\t\t      stun_msg_t *msg, stun_buffer_t *pwd)\n{\n  int err;\n  char ipaddr[SU_ADDRSIZE + 2];\n  stun_attr_t **a, *b;\n\n  stun_encode_message(msg, pwd);\n\n  err = su_sendto(s, msg->enc_buf.data, msg->enc_buf.size, 0,\n\t\t  to_addr, SU_SOCKADDR_SIZE(to_addr));\n\n  free(msg->enc_buf.data), msg->enc_buf.data = NULL;\n  msg->enc_buf.size = 0;\n\n  for (a = &msg->stun_attr; *a;) {\n\n    if ((*a)->pattr)\n      free((*a)->pattr), (*a)->pattr = NULL;\n\n    if ((*a)->enc_buf.data)\n      free((*a)->enc_buf.data), (*a)->enc_buf.data = NULL;\n\n    b = *a;\n    b = b->next;\n    free(*a);\n    *a = NULL;\n    *a = b;\n  }\n\n  if (err > 0) {\n    su_inet_ntop(to_addr->su_family, SU_ADDR(to_addr), ipaddr, sizeof(ipaddr));\n    SU_DEBUG_5((\"%s: message sent to %s:%u\\n\", __func__,\n\t\tipaddr, ntohs(to_addr->su_port)));\n\n    debug_print(&msg->enc_buf);\n  }\n  else\n    STUN_ERROR(errno, sendto);\n\n  return err;\n}\n\n\n/** Send a STUN message.\n *  This will convert the stun_msg_t to the binary format based on the\n *  spec\n */\nint stun_encode_message(stun_msg_t *msg, stun_buffer_t *pwd) {\n\n  int z = -1, len, buf_len = 0;\n  unsigned char *buf;\n  stun_attr_t *attr, *msg_int=NULL;\n\n  if (msg->enc_buf.data == NULL) {\n    /* convert msg to binary format */\n    /* convert attributes to binary format for transmission */\n    len = 0;\n    for (attr = msg->stun_attr; attr ; attr = attr->next) {\n      switch(attr->attr_type) {\n      case RESPONSE_ADDRESS:\n      case MAPPED_ADDRESS:\n      case SOURCE_ADDRESS:\n      case CHANGED_ADDRESS:\n      case REFLECTED_FROM:\n#ifdef USE_TURN\n      case TURN_ALTERNATE_SERVER:\n      case TURN_DESTINATION_ADDRESS:\n      case TURN_SOURCE_ADDRESS:\n#endif\n\tz = stun_encode_address(attr);\n\tbreak;\n      case CHANGE_REQUEST:\n#ifdef USE_TURN\n      case TURN_LIFETIME:\n      case TURN_MAGIC_COOKIE:\n      case TURN_BANDWIDTH:\n#endif\n\tz = stun_encode_uint32(attr);\n\tbreak;\n\n      case USERNAME:\n      case PASSWORD:\n#ifdef USE_TURN\n      case TURN_REALM:\n      case TURN_NONCE:\n      case TURN_DATA:\n#endif\n\tz = stun_encode_buffer(attr);\n\tbreak;\n      case MESSAGE_INTEGRITY:\n\tmsg_int = attr;\n\tz = 24;\n\tbreak;\n      case ERROR_CODE:\n\tz = stun_encode_error_code(attr);\n      default:\n\tbreak;\n      }\n\n      if(z < 0) return z;\n\n      len += z;\n    }\n\n    msg->stun_hdr.msg_len = len;\n    buf_len = 20 + msg->stun_hdr.msg_len;\n    buf = (unsigned char *) malloc(buf_len);\n\n    /* convert to binary format for transmission */\n    set16(buf, 0, msg->stun_hdr.msg_type);\n    set16(buf, 2, msg->stun_hdr.msg_len);\n    memcpy(buf + 4, msg->stun_hdr.tran_id, STUN_TID_BYTES);\n\n    len = 20;\n\n    /* attaching encoded attributes */\n    attr = msg->stun_attr;\n    while(attr) {\n      /* attach only if enc_buf is not null */\n      if(attr->enc_buf.data && attr->attr_type != MESSAGE_INTEGRITY) {\n\tmemcpy(buf+len, (void *)attr->enc_buf.data, attr->enc_buf.size);\n\tlen += attr->enc_buf.size;\n      }\n      attr = attr->next;\n    }\n\n    if (msg_int) {\n      /* compute message integrity */\n      if(stun_encode_message_integrity(msg_int, buf, len, pwd)!=24) {\n\tfree(buf);\n\treturn -1;\n      }\n      memcpy(buf+len, (void *)msg_int->enc_buf.data,\n\t     msg_int->enc_buf.size);\n    }\n\n    /* save binary buffer for future reference */\n    if (msg->enc_buf.data)\n      free(msg->enc_buf.data);\n\n    msg->enc_buf.data = buf; msg->enc_buf.size = buf_len;\n  }\n\n  return 0;\n}\n\n#include <sofia-sip/su.h>\n#include <sofia-sip/su_debug.h>\n#include <sofia-sip/su_localinfo.h>\n\nchar *stun_determine_ip_address(int family)\n{\n\n  char *local_ip_address;\n  su_localinfo_t *li = NULL, hints[1] = {{ LI_CANONNAME|LI_NUMERIC }};\n  int error;\n  size_t address_size;\n  struct sockaddr_in *sa = NULL;\n  su_sockaddr_t *temp;\n\n  hints->li_family = family;\n  hints->li_canonname = getenv(\"HOSTADDRESS\");\n  if ((error = su_getlocalinfo(hints, &li)) < 0) {\n    SU_DEBUG_5((\"%s: stun_determine_ip_address, su_getlocalinfo: %s\\n\",\n\t\t__func__, su_gli_strerror(error)));\n    return NULL;\n  }\n\n  temp = li->li_addr;\n  sa = &temp->su_sin;\n\n  address_size = strlen(inet_ntoa(sa->sin_addr));\n\n  local_ip_address = malloc(address_size + 1);\n  strcpy(local_ip_address, (char *) inet_ntoa(sa->sin_addr)); /* otherwise? */\n\n  su_freelocalinfo(li);\n\n  return local_ip_address;\n\n}\n\nconst char *stun_attr_phrase(uint16_t type)\n{\n  switch(type) {\n  case MAPPED_ADDRESS: return \"MAPPED-ADDRESS\";\n  case RESPONSE_ADDRESS: return \"RESPONSE-ADDRESS\";\n  case CHANGE_REQUEST: return \"CHANGE-REQUEST\";\n  case SOURCE_ADDRESS: return \"SOURCE-ADDRESS\";\n  case CHANGED_ADDRESS: return \"CHANGED-ADDRESS\";\n  case USERNAME: return \"USERNAME\";\n  case PASSWORD: return \"PASSWORD\";\n  case MESSAGE_INTEGRITY: return \"MESSAGE-INTEGRITY\";\n  case ERROR_CODE: return \"ERROR-CODE\";\n  case UNKNOWN_ATTRIBUTES: return \"UNKNOWN-ATTRIBUTES\";\n  case REFLECTED_FROM: return \"REFLECTED-FROM\";\n  case STUN_A_ALTERNATE_SERVER:\n  case STUN_A_ALTERNATE_SERVER_DEP:\n    return \"ALTERNATE-SERVER\";\n  case STUN_A_REALM: return \"REALM\";\n  case STUN_A_NONCE: return \"NONCE\";\n  case STUN_A_XOR_MAPPED_ADDRESS: return \"XOR-MAPPED-ADDRESS\";\n#ifdef USE_TURN\n  case TURN_REALM: return \"REALM\";\n  case TURN_LIFETIME: return \"LIFETIME\";\n  case TURN_ALTERNATE_SERVER: return \"ALTERNATE_SERVER\";\n  case TURN_MAGIC_COOKIE: return \"MAGIC_COOKIE\";\n  case TURN_BANDWIDTH: return \"BANDWIDTH\";\n  case TURN_DESTINATION_ADDRESS: return \"DESTINATION_ADDRESS\";\n  case TURN_SOURCE_ADDRESS: return \"SOURCE_ADDRESS\";\n  case TURN_DATA: return \"DATA\";\n  case TURN_NONCE: return \"NONCE\";\n#endif\n  default: return \"Attribute undefined\";\n  }\n}\n"], "fixing_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n#ifndef STUN_COMMON_H\n/** Defined when <sofia-sip/stun_common.h> has been included. */\n#define STUN_COMMON_H\n\n/**\n * @file sofia-sip/stun_common.h\n * @brief\n *\n * @author Tat Chan <Tat.Chan@nokia.com>\n *\n * @date Created: Fri Oct  3 13:39:55 2003 ppessi\n *\n */\n\n#include <sofia-sip/su_localinfo.h>\n\nSOFIA_BEGIN_DECLS\n\n/* Define Message Types */\n#define BINDING_REQUEST               0x0001\n#define BINDING_RESPONSE              0x0101\n#define BINDING_ERROR_RESPONSE        0x0111\n#define SHARED_SECRET_REQUEST         0x0002\n#define SHARED_SECRET_RESPONSE        0x0102\n#define SHARED_SECRET_ERROR_RESPONSE  0x0112\n\n/* Define Attribute Types */\n#define MAPPED_ADDRESS                0x0001\n#define RESPONSE_ADDRESS              0x0002\n#define CHANGE_REQUEST                0x0003\n#define SOURCE_ADDRESS                0x0004\n#define CHANGED_ADDRESS               0x0005\n#define USERNAME                      0x0006\n#define PASSWORD                      0x0007\n#define MESSAGE_INTEGRITY             0x0008\n#define ERROR_CODE                    0x0009\n#define UNKNOWN_ATTRIBUTES            0x000a\n#define REFLECTED_FROM                0x000b\n#define STUN_A_REALM                  0x0014 /* XXX: check value in 3489bis-05+ */\n#define STUN_A_NONCE                  0x0015 /* XXX: check value in 3489bis-05+ */\n#define STUN_A_XOR_MAPPED_ADDRESS     0x0020\n#define STUN_A_FINGERPRINT            0x0023\n#define STUN_A_SERVER                 0x8022\n#define STUN_A_ALTERNATE_SERVER       0x8023\n#define STUN_A_REFRESH_INTERVAL       0x8024\n\n/* Defines for mandatory and optional attributes */\n#define STUN_A_LAST_MANDATORY         0x0023 /**< largest attribute in the current\n\t\t\t\t\t\tspec (see above for exceptions\n\t\t\t\t\t\tfor buggy servers) */\n#define STUN_A_OPTIONAL               0x7fff\n\n/* Compability attribute types */\n#define STUN_A_ALTERNATE_SERVER_DEP   0x000e /**< historic from early fc3489bis drafts */\n#define STUN_A_BUGGYSERVER_XORONLY    0x0021 /**< workaround for stund-0.94 and older */\n#define STUN_A_BUGGYSERVER_SERVER     0x0022 /**< workaround for stund-0.94 and older */\n#define LARGEST_ATTRIBUTE             STUN_A_LAST_MANDATORY /**< deprecated API */\n#define OPTIONAL_ATTRIBUTE            STUN_A_OPTIONAL /**< deprecated API */\n\n/* Stun response codes */\n#define STUN_400_BAD_REQUEST             400\n#define STUN_401_UNAUTHORIZED            401\n#define STUN_420_UNKNOWN_ATTRIBUTE       420\n#define STUN_430_STALE_CREDENTIALS       430\n#define STUN_431_INTEGRITY_CHECK_FAILURE 431\n#define STUN_432_MISSING_USERNAME        432\n#define STUN_433_USE_TLS                 433\n#define STUN_500_SERVER_ERROR            500\n#define STUN_600_GLOBAL_FAILURE          600\n\n/* flags for CHANGE_REQUEST */\n#define STUN_CR_CHANGE_IP               0x0004\n#define STUN_CR_CHANGE_PORT             0x0002\n\n/* mask for ERROR_CODE */\n#define STUN_EC_CLASS                   0x0070\n#define STUN_EC_NUM                     0x000F\n\n#define RAND_MAX_16                     65535\n\n#define STUN_TID_BYTES                  16\n\n/* other protocol specific parameters */\n#define STUN_MAX_RETRX                  5 /* should be 8? */\n#define STUN_MAX_RETRX_INT              1600  /**< max retrx interval in\n\t\t\t\t\t\t   millisec */\n#define STUN_DEFAULT_PORT               3478  /**< from RFC3489 */\n\n/*\n * STUN header format\n */\n  /*\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         message type          |       message length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n   |                       Transaction ID                          |\n   |                                                               |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  */\nstruct stun_buffer_s {\n  unsigned char *data;      /**< Pointer to data */\n  unsigned size;            /**< Size of buffer */\n};\n\ntypedef struct stun_buffer_s stun_buffer_t;\n\ntypedef struct {\n  uint16_t msg_type;        /**< message type */\n  uint16_t msg_len;         /**< message length */\n  uint8_t tran_id[16];      /**< transaction id, 128 bits */\n} stun_hdr_t;\n\ntypedef struct stun_attr_s {\n  uint16_t attr_type;       /**< attribute type */\n  void *pattr;              /**< pointer to corresponding attribute */\n  stun_buffer_t enc_buf;    /**< encoded attribue */\n  struct stun_attr_s *next; /**< next attribute */\n} stun_attr_t;\n\ntypedef struct {\n  stun_hdr_t stun_hdr;\n  stun_attr_t *stun_attr;\n  stun_buffer_t enc_buf;    /**< to store already encoded stun msg */\n} stun_msg_t;\n\n/* stun attribute definition */\n/* stun_sockaddr_t is used for:\n   MAPPED_ADDRESS\n   RESPONSE_ADDRESS\n   SOURCE_ADDRESS\n   CHANGED_ADDRESS\n   REFLECTED_FROM\n*/\ntypedef struct sockaddr_in stun_attr_sockaddr_t;\n\n/* CHANGE_REQUEST attribute */\ntypedef struct stun_attr_uint32_s {\n  uint32_t value;\n} stun_attr_uint32_t;\n\ntypedef stun_attr_uint32_t stun_attr_changerequest_t;\n\n/* ERROR_CODE attribute */\ntypedef struct {\n  int code;\n  char *phrase;\n} stun_attr_errorcode_t;\n\n/* USERNAME attribute */\n/* typedef struct {\n  stun_buffer_t *uname;\n} stun_attr_username_t;\n*/\ntypedef stun_buffer_t stun_attr_username_t;\n\n/* PASSWORD attribute */\ntypedef stun_buffer_t stun_attr_password_t;\n\n/* UNKNOWN_ATTRIBUTES attribute */\ntypedef struct stun_attr_unknownattributes_s{\n  uint16_t attr_type[2];\n  struct stun_attr_unknownattributes_s *next;\n} stun_attr_unknownattributes_t;\n\n/* Common functions */\nint stun_parse_message(stun_msg_t *msg);\nint stun_parse_attribute(stun_msg_t *msg, unsigned char *p, size_t left_len);\nint stun_parse_attr_address(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_error_code(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_unknown_attributes(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_uint32(stun_attr_t *attr, const unsigned char *p, unsigned len);\nint stun_parse_attr_buffer(stun_attr_t *attr, const unsigned char *p, unsigned len);\n\nstun_attr_t *stun_get_attr(stun_attr_t *attr, uint16_t attr_type);\n\nint stun_encode_address(stun_attr_t *attr);\nint stun_encode_uint32(stun_attr_t *attr);\nint stun_encode_buffer(stun_attr_t *attr);\nint stun_encode_error_code(stun_attr_t *attr);\nint stun_encode_message_integrity(stun_attr_t *attr, unsigned char *buf, int len, stun_buffer_t *pwd);\nint stun_encode_type_len(stun_attr_t *attr, uint16_t len);\nint stun_encode_response_address(stun_attr_t *attr);\n\nint stun_validate_message_integrity(stun_msg_t *msg, stun_buffer_t *pwd);\n\nint stun_copy_buffer(stun_buffer_t *p, stun_buffer_t *p2);\nvoid stun_init_buffer(stun_buffer_t *p);\nint stun_free_buffer(stun_buffer_t *p);\nint stun_free_message(stun_msg_t *msg);\n\nint stun_init_message(stun_msg_t *msg);\n/* int stun_send_message(int sockfd, struct sockaddr_in *to_addr, stun_msg_t *msg, stun_buffer_t *pwd); */\nint stun_encode_message(stun_msg_t *msg, stun_buffer_t *pwd);\n\nchar const *stun_response_phrase(int status);\nvoid debug_print(stun_buffer_t *buf);\nchar const *stun_attr_phrase(uint16_t type);\n\n/**Determines and returns local IP address\n *\n * Address is determined using su_getlocalinfo() function.\n *\n * @param family        network address family in use\n * @return local ip address\n */\nchar *stun_determine_ip_address(int family);\n\nSOFIA_END_DECLS\n\n#endif /* !defined STUN_COMMON_H */\n", "/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@internal\n * @file stun_common.c\n * @brief\n *\n * @author Tat Chan <Tat.Chan@nokia.com>\n * @author Kai Vehmanen <kai.vehmanen@nokia.com>\n *\n * @date Created: Fri Oct  3 13:40:41 2003 ppessi\n *\n */\n\n#include \"config.h\"\n\n#ifdef USE_TURN\n#include \"../turn/turn_common.h\"\n#undef STUN_A_LAST_MANDATORY\n#define STUN_A_LAST_MANDATORY TURN_LARGEST_ATTRIBUTE\n#endif\n\n#include \"stun_internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#if HAVE_FUNC\n#elif HAVE_FUNCTION\n#define __func__ __FUNCTION__\n#else\n#define __func__ \"stun_common\"\n#endif\n\nconst char stun_400_Bad_request[] = \"Bad Request\",\n  stun_401_Unauthorized[] = \"Unauthorized\",\n  stun_420_Unknown_attribute[] = \"Unknown Attribute\",\n  stun_430_Stale_credentials[] = \"Stale Credentials\",\n  stun_431_Integrity_check_failure[] = \"Integrity Check Failure\",\n  stun_432_Missing_username[] = \"Missing Username\",\n  stun_433_Use_tls[] = \"Use TLS\",\n#ifdef USE_TURN\n  turn_434_Missing_realm[] = \"Missing Realm\",\n  turn_435_Missing_nonce[] = \"Missing Nonce\",\n  turn_436_Unknown_username[] = \"Unknown Username\",\n  turn_437_No_binding[] = \"No Binding\",\n  turn_439_Illegal_port[] = \"Illegal Port\",\n#endif\n  stun_500_Server_error[] = \"Server Error\",\n  stun_600_Global_failure[] = \"Global Failure\";\n\n#define set16(b, offset, value)\t\t\t\\\n  (((b)[(offset) + 0] = ((value) >> 8) & 255),\t\\\n   ((b)[(offset) + 1] = (value) & 255))\n\n#define get16(b, offset)\t\\\n  (((b)[(offset) + 0] << 8) |\t\\\n   ((b)[(offset) + 1] << 0))\n\nint stun_parse_message(stun_msg_t *msg)\n{\n  unsigned len;\n  int i;\n  unsigned char *p;\n\n  /* parse header first */\n  p = msg->enc_buf.data;\n\n  if (get16(p, 2) > (msg->enc_buf.size - 20))\n  {\n    SU_DEBUG_3((\"%s: Error STUN Message Length is too big.\\n\", __func__));\n    return -1;\n  }\n\n  msg->stun_hdr.msg_type = get16(p, 0);\n  msg->stun_hdr.msg_len = get16(p, 2);\n  memcpy(msg->stun_hdr.tran_id, p + 4, STUN_TID_BYTES);\n\n  SU_DEBUG_5((\"%s: Parse STUN message: Length = %d\\n\", __func__,\n\t      msg->stun_hdr.msg_len));\n\n  /* parse attributes */\n  len = msg->stun_hdr.msg_len;\n  p = msg->enc_buf.data + 20;\n  msg->stun_attr = NULL;\n  while (len >= 4) {  // Type (2) + Length (2) + Value (variable) min attribute size\n    i = stun_parse_attribute(msg, p, len);\n    if (i <= 0 || i > len) {\n      SU_DEBUG_3((\"%s: Error parsing attribute.\\n\", __func__));\n      return -1;\n    }\n    p += i;\n    len -= i;\n  }\n\n  return 0;\n}\n\nint stun_parse_attribute(stun_msg_t *msg, unsigned char *p, size_t left_len)\n{\n  int len;\n  uint16_t attr_type;\n  stun_attr_t *attr, *next;\n\n  attr_type = get16(p, 0);\n  len = get16(p, 2);\n\n  if ((left_len - 4) < len) // make sure we have enough space for attribute\n  {\n    SU_DEBUG_3((\"%s: Error STUN attr len is too big.\\n\", __func__));\n    return -1;\n  }\n\n  SU_DEBUG_5((\"%s: received attribute: Type %02X, Length %d - %s\\n\",\n\t      __func__, attr_type, len, stun_attr_phrase(attr_type)));\n\n  if (attr_type > STUN_A_LAST_MANDATORY && attr_type < STUN_A_OPTIONAL) {\n    return -1;\n  }\n\n  attr = (stun_attr_t *)calloc(1, sizeof(stun_attr_t));\n  if (!attr)\n    return -1;\n  attr->next = NULL;\n  attr->attr_type = attr_type;\n  p += 4;\n\n  switch (attr->attr_type) {\n  case MAPPED_ADDRESS:\n  case RESPONSE_ADDRESS:\n  case SOURCE_ADDRESS:\n  case CHANGED_ADDRESS:\n  case REFLECTED_FROM:\n#ifdef USE_TURN\n  case TURN_ALTERNATE_SERVER:\n  case TURN_DESTINATION_ADDRESS:\n  case TURN_SOURCE_ADDRESS:\n#endif\n    if (stun_parse_attr_address(attr, p, len) < 0) {\n      free(attr);\n      return -1;\n    }\n    break;\n  case ERROR_CODE:\n    if (stun_parse_attr_error_code(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  case UNKNOWN_ATTRIBUTES:\n    if(stun_parse_attr_unknown_attributes(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  case CHANGE_REQUEST:\n#ifdef USE_TURN\n  case TURN_LIFETIME:\n  case TURN_MAGIC_COOKIE:\n  case TURN_BANDWIDTH:\n#endif\n    if (stun_parse_attr_uint32(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  case USERNAME:\n  case PASSWORD:\n  case STUN_A_REALM:\n  case STUN_A_NONCE:\n#ifdef USE_TURN\n  case TURN_DATA:\n  case TURN_NONCE:\n#endif\n    if (stun_parse_attr_buffer(attr, p, len) <0) { free(attr); return -1; }\n    break;\n  default:\n    /* just copy as is */\n    attr->pattr = NULL;\n    attr->enc_buf.size = len;\n    attr->enc_buf.data = (unsigned char *) malloc(len);\n    memcpy(attr->enc_buf.data, p, len);\n    break;\n  }\n\n  /* skip to end of list */\n  if(msg->stun_attr==NULL) {\n    msg->stun_attr = attr;\n  }\n  else {\n    next = msg->stun_attr;\n    while(next->next!=NULL) {\n      next = next->next;\n    }\n    next->next = attr;\n  }\n  return len+4;\n}\n\nint stun_parse_attr_address(stun_attr_t *attr,\n\t\t\t    const unsigned char *p,\n\t\t\t    unsigned len)\n{\n  su_sockaddr_t *addr;\n  int addrlen;\n  char ipaddr[SU_ADDRSIZE + 2];\n\n  if (len != 8) {\n    return -1;\n  }\n\n  addrlen = sizeof(su_sockaddr_t);\n  addr = (su_sockaddr_t *) malloc(addrlen);\n\n  if (*(p+1) == 1) { /* expected value for IPv4 */\n    addr->su_sin.sin_family = AF_INET;\n  }\n  else {\n    free(addr);\n    return -1;\n  }\n  memcpy(&addr->su_sin.sin_port, p + 2, 2);\n  memcpy(&addr->su_sin.sin_addr.s_addr, p + 4, 4);\n\n  SU_DEBUG_5((\"%s: address attribute: %s:%d\\n\", __func__,\n\t      su_inet_ntop(addr->su_family, SU_ADDR(addr), ipaddr, sizeof(ipaddr)),\n\t      (unsigned) ntohs(addr->su_sin.sin_port)));\n\n  attr->pattr = addr;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_error_code(stun_attr_t *attr, const unsigned char *p, unsigned len) {\n\n  uint32_t tmp;\n  stun_attr_errorcode_t *error;\n\n  memcpy(&tmp, p, sizeof(uint32_t));\n  tmp = ntohl(tmp);\n  error = (stun_attr_errorcode_t *) malloc(sizeof(*error));\n\n  error->code = (tmp & STUN_EC_CLASS)*100 + (tmp & STUN_EC_NUM);\n\n  error->phrase = (char *) malloc(len-3);\n\n  strncpy(error->phrase, (char*)p+4, len-4);\n  error->phrase[len - 4] = '\\0';\n\n  attr->pattr = error;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_uint32(stun_attr_t *attr, const unsigned char *p, unsigned len)\n{\n  uint32_t tmp;\n  stun_attr_changerequest_t *cr;\n  cr = (stun_attr_changerequest_t *) malloc(sizeof(*cr));\n  memcpy(&tmp, p, sizeof(uint32_t));\n  cr->value = ntohl(tmp);\n  attr->pattr = cr;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_buffer(stun_attr_t *attr, const unsigned char *p, unsigned len)\n{\n  stun_buffer_t *buf;\n  buf = (stun_buffer_t *) malloc(sizeof(stun_buffer_t));\n  buf->size = len;\n  buf->data = (unsigned char *) malloc(len);\n  memcpy(buf->data, p, len);\n  attr->pattr = buf;\n  stun_init_buffer(&attr->enc_buf);\n\n  return 0;\n}\n\nint stun_parse_attr_unknown_attributes(stun_attr_t *attr,\n\t\t\t\t       const unsigned char *p,\n\t\t\t\t       unsigned len)\n{\n  return 0;\n}\n\n/** scan thru attribute list and return the next requested attr */\nstun_attr_t *stun_get_attr(stun_attr_t *attr, uint16_t attr_type) {\n  stun_attr_t *p;\n\n  for (p = attr; p != NULL; p = p->next) {\n    if (p->attr_type == attr_type)\n      break;\n  }\n\n  return p;\n}\n\nvoid stun_init_buffer(stun_buffer_t *p) {\n  p->data = NULL;\n  p->size = 0;\n}\n\nint stun_free_buffer(stun_buffer_t *p) {\n  if (p->data)\n    free(p->data), p->data = NULL;\n  p->size = 0;\n  return 0;\n}\n\nint stun_copy_buffer(stun_buffer_t *p, stun_buffer_t *p2) {\n  stun_free_buffer(p); /* clean up existing data */\n  p->size = p2->size;\n  p->data = (unsigned char *) malloc(p->size);\n  memcpy(p->data, p2->data, p->size);\n  return p->size;\n}\n\nconst char *stun_response_phrase(int status) {\n  if (status <100 || status >600)\n    return NULL;\n\n  switch (status) {\n  case STUN_400_BAD_REQUEST: return stun_400_Bad_request;\n  case STUN_401_UNAUTHORIZED: return stun_401_Unauthorized;\n  case STUN_420_UNKNOWN_ATTRIBUTE: return stun_420_Unknown_attribute;\n  case STUN_430_STALE_CREDENTIALS: return stun_430_Stale_credentials;\n  case STUN_431_INTEGRITY_CHECK_FAILURE: return stun_431_Integrity_check_failure;\n  case STUN_432_MISSING_USERNAME: return stun_432_Missing_username;\n  case STUN_433_USE_TLS: return stun_433_Use_tls;\n#ifdef USE_TURN\n  case TURN_MISSING_REALM: return turn_434_Missing_realm;\n  case TURN_MISSING_NONCE: return turn_435_Missing_nonce;\n  case TURN_UNKNOWN_USERNAME: return turn_436_Unknown_username;\n  case TURN_NO_BINDING: return turn_437_No_binding;\n  case TURN_ILLEGAL_PORT: return turn_439_Illegal_port;\n#endif\n  case STUN_500_SERVER_ERROR: return stun_500_Server_error;\n  case STUN_600_GLOBAL_FAILURE: return stun_600_Global_failure;\n  }\n  return \"Response\";\n}\n\n/** The set of functions encodes the corresponding attribute to\n *    network format, and save the result to the enc_buf. Return the\n *    size of the buffer.\n */\n\n\n/* This function is used to encode any attribute of the form ADDRESS\n   */\nint stun_encode_address(stun_attr_t *attr) {\n  stun_attr_sockaddr_t *a;\n  uint16_t tmp;\n\n  a = (stun_attr_sockaddr_t *)attr->pattr;\n\n  if (stun_encode_type_len(attr, 8) < 0) {\n    return -1;\n  }\n\n  tmp = htons(0x01); /* FAMILY = 0x01 */\n  memcpy(attr->enc_buf.data+4, &tmp, sizeof(tmp));\n  memcpy(attr->enc_buf.data+6, &a->sin_port, 2);\n  memcpy(attr->enc_buf.data+8, &a->sin_addr.s_addr, 4);\n\n  return attr->enc_buf.size;\n}\n\nint stun_encode_uint32(stun_attr_t *attr) {\n  uint32_t tmp;\n\n  if (stun_encode_type_len(attr, 4) < 0) {\n    return -1;\n  }\n\n  tmp = htonl(((stun_attr_changerequest_t *) attr->pattr)->value);\n  memcpy(attr->enc_buf.data+4, &tmp, 4);\n  return attr->enc_buf.size;\n}\n\nint stun_encode_error_code(stun_attr_t *attr) {\n  short int class, num;\n  size_t phrase_len, padded;\n  stun_attr_errorcode_t *error;\n\n  error = (stun_attr_errorcode_t *) attr->pattr;\n  class = error->code / 100;\n  num = error->code % 100;\n\n  phrase_len = strlen(error->phrase);\n  if (phrase_len + 8 > 65536)\n    phrase_len = 65536 - 8;\n\n  /* note: align the phrase len (see RFC3489:11.2.9) */\n  padded = phrase_len + (phrase_len % 4 == 0 ? 0 : 4 - (phrase_len % 4));\n\n  /* note: error-code has four octets of headers plus the\n   *       reason field -> len+4 octets */\n  if (stun_encode_type_len(attr, (uint16_t)(padded + 4)) < 0) {\n    return -1;\n  }\n  else {\n    assert(attr->enc_buf.size == padded + 8);\n    memset(attr->enc_buf.data+4, 0, 2);\n    attr->enc_buf.data[6] = class;\n    attr->enc_buf.data[7] = num;\n    /* note: 4 octets of TLV header and 4 octets of error-code header */\n    memcpy(attr->enc_buf.data+8, error->phrase,\n\t   phrase_len);\n    memset(attr->enc_buf.data + 8 + phrase_len, 0, padded - phrase_len);\n  }\n\n  return attr->enc_buf.size;\n}\n\nint stun_encode_buffer(stun_attr_t *attr) {\n  stun_buffer_t *a;\n\n  a = (stun_buffer_t *)attr->pattr;\n  assert(a->size < 65536);\n  if (stun_encode_type_len(attr, (uint16_t)a->size) < 0) {\n    return -1;\n  }\n\n  memcpy(attr->enc_buf.data+4, a->data, a->size);\n  return attr->enc_buf.size;\n}\n\n#if defined(HAVE_OPENSSL)\nint stun_encode_message_integrity(stun_attr_t *attr,\n\t\t\t\t  unsigned char *buf,\n\t\t\t\t  int len,\n\t\t\t\t  stun_buffer_t *pwd) {\n  int padded_len;\n  unsigned int dig_len;\n  unsigned char *padded_text = NULL;\n  void *sha1_hmac;\n\n  if (stun_encode_type_len(attr, 20) < 0) {\n    return -1;\n  }\n\n  /* zero padding */\n  if (len % 64 != 0) {\n\n    padded_len = len + (64 - (len % 64));\n    padded_text = (unsigned char *) malloc(padded_len);\n    memcpy(padded_text, buf, len);\n    memset(padded_text + len, 0, padded_len - len);\n\n    sha1_hmac = HMAC(EVP_sha1(), pwd->data, pwd->size, padded_text, padded_len, NULL, &dig_len);\n  }\n  else {\n    sha1_hmac = HMAC(EVP_sha1(), pwd->data, pwd->size, buf, len, NULL, &dig_len);\n  }\n\n  assert(dig_len == 20);\n\n  memcpy(attr->enc_buf.data + 4, sha1_hmac, 20);\n  free(padded_text);\n  return attr->enc_buf.size;\n}\n#else\nint stun_encode_message_integrity(stun_attr_t *attr,\n\t\t\t\t  unsigned char *buf,\n\t\t\t\t  int len,\n\t\t\t\t  stun_buffer_t *pwd) {\n\n  return 0;\n}\n#endif /* HAVE_OPENSSL */\n\n/** this function allocates the enc_buf, fills in type, length */\nint stun_encode_type_len(stun_attr_t *attr, uint16_t len) {\n  uint16_t tmp;\n\n  attr->enc_buf.data = (unsigned char *) malloc(len + 4);\n  memset(attr->enc_buf.data, 0, len + 4);\n\n  tmp = htons(attr->attr_type);\n  memcpy(attr->enc_buf.data, &tmp, 2);\n\n  tmp = htons(len);\n  memcpy(attr->enc_buf.data + 2, &tmp, 2);\n  attr->enc_buf.size = len + 4;\n\n  return 0;\n}\n\n/**\n * Validate the message integrity based on given\n * STUN password 'pwd'. The received content should be\n * in msg->enc_buf.\n */\nint stun_validate_message_integrity(stun_msg_t *msg, stun_buffer_t *pwd)\n{\n\n#if defined(HAVE_OPENSSL)\n  int padded_len, len;\n  unsigned int dig_len;\n  unsigned char dig[20]; /* received sha1 digest */\n  unsigned char *padded_text;\n#endif\n\n  /* password NULL so shared-secret not established and\n     messege integrity checks can be skipped */\n  if (pwd->data == NULL)\n    return 0;\n\n  /* otherwise the check must match */\n\n#if defined(HAVE_OPENSSL)\n\n  /* message integrity not received */\n  if (stun_get_attr(msg->stun_attr, MESSAGE_INTEGRITY) == NULL) {\n    SU_DEBUG_5((\"%s: error: message integrity missing.\\n\", __func__));\n    return -1;\n  }\n\n  /* zero padding */\n  len = msg->enc_buf.size - 24;\n  padded_len = len + (len % 64 == 0 ? 0 : 64 - (len % 64));\n  padded_text = (unsigned char *) malloc(padded_len);\n  memset(padded_text, 0, padded_len);\n  memcpy(padded_text, msg->enc_buf.data, len);\n\n  memcpy(dig, HMAC(EVP_sha1(), pwd->data, pwd->size, padded_text, padded_len, NULL, &dig_len), 20);\n\n  if (memcmp(dig, msg->enc_buf.data + msg->enc_buf.size - 20, 20) != 0) {\n    /* does not match, but try the test server's password */\n    if (memcmp(msg->enc_buf.data+msg->enc_buf.size-20, \"hmac-not-implemented\", 20) != 0) {\n      SU_DEBUG_5((\"%s: error: message digest problem.\\n\", __func__));\n      return -1;\n    }\n  }\n  else {\n    SU_DEBUG_5((\"%s: message integrity validated.\\n\", __func__));\n  }\n\n  free(padded_text);\n\n  return 0;\n#else /* HAVE_OPENSSL */\n  return -1;\n#endif\n}\n\nvoid debug_print(stun_buffer_t *buf) {\n  unsigned i;\n  for(i = 0; i < buf->size/4; i++) {\n    SU_DEBUG_9((\"%02x %02x %02x %02x\\n\",\n\t\t*(buf->data + i*4),\n\t\t*(buf->data + i*4 +1),\n\t\t*(buf->data + i*4 +2),\n\t\t*(buf->data + i*4 +3)));\n    if (i == 4)\n\t\tSU_DEBUG_9((\"---------------------\\n\" VA_NONE));\n  }\n  SU_DEBUG_9((\"\\n\" VA_NONE));\n}\n\nint stun_init_message(stun_msg_t *msg) {\n  msg->stun_hdr.msg_type = 0;\n  msg->stun_hdr.msg_len = 0;\n  msg->stun_attr = NULL;\n  stun_init_buffer(&msg->enc_buf);\n  return 0;\n}\n\nint stun_free_message(stun_msg_t *msg) {\n\n  stun_attr_t *p, *p2;\n\n  /* clearing header */\n  memset(&msg->stun_hdr, 0, sizeof msg->stun_hdr);\n\n  /* clearing attr */\n  p = msg->stun_attr;\n  while(p) {\n    if(p->pattr) {\n      switch(p->attr_type) {\n      case USERNAME:\n      case PASSWORD:\n#ifdef USE_TURN\n      case TURN_DATA:\n      case TURN_NONCE:\n#endif\n\tstun_free_buffer(p->pattr);\n\tbreak;\n      default:\n\tfree(p->pattr);\n      }\n    }\n    stun_free_buffer(&p->enc_buf);\n    p2 = p->next;\n    free(p);\n    p = p2;\n  }\n  msg->stun_attr = NULL;\n\n  /* clearing buffer */\n  stun_free_buffer(&msg->enc_buf);\n\n  return 0;\n}\n\n\nint stun_send_message(su_socket_t s, su_sockaddr_t *to_addr,\n\t\t      stun_msg_t *msg, stun_buffer_t *pwd)\n{\n  int err;\n  char ipaddr[SU_ADDRSIZE + 2];\n  stun_attr_t **a, *b;\n\n  stun_encode_message(msg, pwd);\n\n  err = su_sendto(s, msg->enc_buf.data, msg->enc_buf.size, 0,\n\t\t  to_addr, SU_SOCKADDR_SIZE(to_addr));\n\n  free(msg->enc_buf.data), msg->enc_buf.data = NULL;\n  msg->enc_buf.size = 0;\n\n  for (a = &msg->stun_attr; *a;) {\n\n    if ((*a)->pattr)\n      free((*a)->pattr), (*a)->pattr = NULL;\n\n    if ((*a)->enc_buf.data)\n      free((*a)->enc_buf.data), (*a)->enc_buf.data = NULL;\n\n    b = *a;\n    b = b->next;\n    free(*a);\n    *a = NULL;\n    *a = b;\n  }\n\n  if (err > 0) {\n    su_inet_ntop(to_addr->su_family, SU_ADDR(to_addr), ipaddr, sizeof(ipaddr));\n    SU_DEBUG_5((\"%s: message sent to %s:%u\\n\", __func__,\n\t\tipaddr, ntohs(to_addr->su_port)));\n\n    debug_print(&msg->enc_buf);\n  }\n  else\n    STUN_ERROR(errno, sendto);\n\n  return err;\n}\n\n\n/** Send a STUN message.\n *  This will convert the stun_msg_t to the binary format based on the\n *  spec\n */\nint stun_encode_message(stun_msg_t *msg, stun_buffer_t *pwd) {\n\n  int z = -1, len, buf_len = 0;\n  unsigned char *buf;\n  stun_attr_t *attr, *msg_int=NULL;\n\n  if (msg->enc_buf.data == NULL) {\n    /* convert msg to binary format */\n    /* convert attributes to binary format for transmission */\n    len = 0;\n    for (attr = msg->stun_attr; attr ; attr = attr->next) {\n      switch(attr->attr_type) {\n      case RESPONSE_ADDRESS:\n      case MAPPED_ADDRESS:\n      case SOURCE_ADDRESS:\n      case CHANGED_ADDRESS:\n      case REFLECTED_FROM:\n#ifdef USE_TURN\n      case TURN_ALTERNATE_SERVER:\n      case TURN_DESTINATION_ADDRESS:\n      case TURN_SOURCE_ADDRESS:\n#endif\n\tz = stun_encode_address(attr);\n\tbreak;\n      case CHANGE_REQUEST:\n#ifdef USE_TURN\n      case TURN_LIFETIME:\n      case TURN_MAGIC_COOKIE:\n      case TURN_BANDWIDTH:\n#endif\n\tz = stun_encode_uint32(attr);\n\tbreak;\n\n      case USERNAME:\n      case PASSWORD:\n#ifdef USE_TURN\n      case TURN_REALM:\n      case TURN_NONCE:\n      case TURN_DATA:\n#endif\n\tz = stun_encode_buffer(attr);\n\tbreak;\n      case MESSAGE_INTEGRITY:\n\tmsg_int = attr;\n\tz = 24;\n\tbreak;\n      case ERROR_CODE:\n\tz = stun_encode_error_code(attr);\n      default:\n\tbreak;\n      }\n\n      if(z < 0) return z;\n\n      len += z;\n    }\n\n    msg->stun_hdr.msg_len = len;\n    buf_len = 20 + msg->stun_hdr.msg_len;\n    buf = (unsigned char *) malloc(buf_len);\n\n    /* convert to binary format for transmission */\n    set16(buf, 0, msg->stun_hdr.msg_type);\n    set16(buf, 2, msg->stun_hdr.msg_len);\n    memcpy(buf + 4, msg->stun_hdr.tran_id, STUN_TID_BYTES);\n\n    len = 20;\n\n    /* attaching encoded attributes */\n    attr = msg->stun_attr;\n    while(attr) {\n      /* attach only if enc_buf is not null */\n      if(attr->enc_buf.data && attr->attr_type != MESSAGE_INTEGRITY) {\n\tmemcpy(buf+len, (void *)attr->enc_buf.data, attr->enc_buf.size);\n\tlen += attr->enc_buf.size;\n      }\n      attr = attr->next;\n    }\n\n    if (msg_int) {\n      /* compute message integrity */\n      if(stun_encode_message_integrity(msg_int, buf, len, pwd)!=24) {\n\tfree(buf);\n\treturn -1;\n      }\n      memcpy(buf+len, (void *)msg_int->enc_buf.data,\n\t     msg_int->enc_buf.size);\n    }\n\n    /* save binary buffer for future reference */\n    if (msg->enc_buf.data)\n      free(msg->enc_buf.data);\n\n    msg->enc_buf.data = buf; msg->enc_buf.size = buf_len;\n  }\n\n  return 0;\n}\n\n#include <sofia-sip/su.h>\n#include <sofia-sip/su_debug.h>\n#include <sofia-sip/su_localinfo.h>\n\nchar *stun_determine_ip_address(int family)\n{\n\n  char *local_ip_address;\n  su_localinfo_t *li = NULL, hints[1] = {{ LI_CANONNAME|LI_NUMERIC }};\n  int error;\n  size_t address_size;\n  struct sockaddr_in *sa = NULL;\n  su_sockaddr_t *temp;\n\n  hints->li_family = family;\n  hints->li_canonname = getenv(\"HOSTADDRESS\");\n  if ((error = su_getlocalinfo(hints, &li)) < 0) {\n    SU_DEBUG_5((\"%s: stun_determine_ip_address, su_getlocalinfo: %s\\n\",\n\t\t__func__, su_gli_strerror(error)));\n    return NULL;\n  }\n\n  temp = li->li_addr;\n  sa = &temp->su_sin;\n\n  address_size = strlen(inet_ntoa(sa->sin_addr));\n\n  local_ip_address = malloc(address_size + 1);\n  strcpy(local_ip_address, (char *) inet_ntoa(sa->sin_addr)); /* otherwise? */\n\n  su_freelocalinfo(li);\n\n  return local_ip_address;\n\n}\n\nconst char *stun_attr_phrase(uint16_t type)\n{\n  switch(type) {\n  case MAPPED_ADDRESS: return \"MAPPED-ADDRESS\";\n  case RESPONSE_ADDRESS: return \"RESPONSE-ADDRESS\";\n  case CHANGE_REQUEST: return \"CHANGE-REQUEST\";\n  case SOURCE_ADDRESS: return \"SOURCE-ADDRESS\";\n  case CHANGED_ADDRESS: return \"CHANGED-ADDRESS\";\n  case USERNAME: return \"USERNAME\";\n  case PASSWORD: return \"PASSWORD\";\n  case MESSAGE_INTEGRITY: return \"MESSAGE-INTEGRITY\";\n  case ERROR_CODE: return \"ERROR-CODE\";\n  case UNKNOWN_ATTRIBUTES: return \"UNKNOWN-ATTRIBUTES\";\n  case REFLECTED_FROM: return \"REFLECTED-FROM\";\n  case STUN_A_ALTERNATE_SERVER:\n  case STUN_A_ALTERNATE_SERVER_DEP:\n    return \"ALTERNATE-SERVER\";\n  case STUN_A_REALM: return \"REALM\";\n  case STUN_A_NONCE: return \"NONCE\";\n  case STUN_A_XOR_MAPPED_ADDRESS: return \"XOR-MAPPED-ADDRESS\";\n#ifdef USE_TURN\n  case TURN_REALM: return \"REALM\";\n  case TURN_LIFETIME: return \"LIFETIME\";\n  case TURN_ALTERNATE_SERVER: return \"ALTERNATE_SERVER\";\n  case TURN_MAGIC_COOKIE: return \"MAGIC_COOKIE\";\n  case TURN_BANDWIDTH: return \"BANDWIDTH\";\n  case TURN_DESTINATION_ADDRESS: return \"DESTINATION_ADDRESS\";\n  case TURN_SOURCE_ADDRESS: return \"SOURCE_ADDRESS\";\n  case TURN_DATA: return \"DATA\";\n  case TURN_NONCE: return \"NONCE\";\n#endif\n  default: return \"Attribute undefined\";\n  }\n}\n"], "filenames": ["libsofia-sip-ua/stun/sofia-sip/stun_common.h", "libsofia-sip-ua/stun/stun_common.c"], "buggy_code_start_loc": [195, 89], "buggy_code_end_loc": [196, 121], "fixing_code_start_loc": [195, 90], "fixing_code_end_loc": [196, 135], "type": "CWE-120", "message": "Sofia-SIP is an open-source SIP User-Agent library, compliant with the IETF RFC3261 specification. In affected versions Sofia-SIP **lacks both message length and attributes length checks** when it handles STUN packets, leading to controllable heap-over-flow. For example, in stun_parse_attribute(), after we get the attribute's type and length value, the length will be used directly to copy from the heap, regardless of the message's left size. Since network users control the overflowed length, and the data is written to heap chunks later, attackers may achieve remote code execution by heap grooming or other exploitation methods. The bug was introduced 16 years ago in sofia-sip 1.12.4 (plus some patches through 12/21/2006) to in tree libs with git-svn-id: http://svn.freeswitch.org/svn/freeswitch/trunk@3774 d0543943-73ff-0310-b7d9-9358b9ac24b2. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-22741", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-19T22:15:11.273", "lastModified": "2023-05-24T21:15:11.190", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sofia-SIP is an open-source SIP User-Agent library, compliant with the IETF RFC3261 specification. In affected versions Sofia-SIP **lacks both message length and attributes length checks** when it handles STUN packets, leading to controllable heap-over-flow. For example, in stun_parse_attribute(), after we get the attribute's type and length value, the length will be used directly to copy from the heap, regardless of the message's left size. Since network users control the overflowed length, and the data is written to heap chunks later, attackers may achieve remote code execution by heap grooming or other exploitation methods. The bug was introduced 16 years ago in sofia-sip 1.12.4 (plus some patches through 12/21/2006) to in tree libs with git-svn-id: http://svn.freeswitch.org/svn/freeswitch/trunk@3774 d0543943-73ff-0310-b7d9-9358b9ac24b2. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:signalwire:sofia-sip:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.11", "matchCriteriaId": "0DF9E38A-C29D-4A98-82E7-5CAF18A94054"}]}]}], "references": [{"url": "https://github.com/freeswitch/sofia-sip/commit/da53e4fbcb138b080a75576dd49c1fff2ada2764", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-8599-x7rq-fr54", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5410", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/freeswitch/sofia-sip/commit/da53e4fbcb138b080a75576dd49c1fff2ada2764"}}