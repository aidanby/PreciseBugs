{"buggy_code": ["#include \"../fbuffer/fbuffer.h\"\n#include \"generator.h\"\n\n#ifdef HAVE_RUBY_ENCODING_H\nstatic VALUE CEncoding_UTF_8;\nstatic ID i_encoding, i_encode;\n#endif\n\nstatic VALUE mJSON, mExt, mGenerator, cState, mGeneratorMethods, mObject,\n             mHash, mArray,\n#ifdef RUBY_INTEGER_UNIFICATION\n             mInteger,\n#else\n             mFixnum, mBignum,\n#endif\n             mFloat, mString, mString_Extend,\n             mTrueClass, mFalseClass, mNilClass, eGeneratorError,\n             eNestingError, CRegexp_MULTILINE, CJSON_SAFE_STATE_PROTOTYPE,\n             i_SAFE_STATE_PROTOTYPE;\n\nstatic ID i_to_s, i_to_json, i_new, i_indent, i_space, i_space_before,\n          i_object_nl, i_array_nl, i_max_nesting, i_allow_nan, i_ascii_only,\n          i_pack, i_unpack, i_create_id, i_extend, i_key_p,\n          i_aref, i_send, i_respond_to_p, i_match, i_keys, i_depth,\n          i_buffer_initial_length, i_dup;\n\n/*\n * Copyright 2001-2004 Unicode, Inc.\n *\n * Disclaimer\n *\n * This source code is provided as is by Unicode, Inc. No claims are\n * made as to fitness for any particular purpose. No warranties of any\n * kind are expressed or implied. The recipient agrees to determine\n * applicability of information provided. If this file has been\n * purchased on magnetic or optical media from Unicode, Inc., the\n * sole remedy for any claim will be exchange of defective media\n * within 90 days of receipt.\n *\n * Limitations on Rights to Redistribute This Code\n *\n * Unicode, Inc. hereby grants the right to freely use the information\n * supplied in this file in the creation of products supporting the\n * Unicode Standard, and to make copies of this file in any form\n * for internal or external distribution as long as this notice\n * remains attached.\n */\n\n/*\n * Index into the table below with the first byte of a UTF-8 sequence to\n * get the number of trailing bytes that are supposed to follow it.\n * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is\n * left as-is for anyone who may want to do such conversion, which was\n * allowed in earlier algorithms.\n */\nstatic const char trailingBytesForUTF8[256] = {\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5\n};\n\n/*\n * Magic values subtracted from a buffer value during UTF8 conversion.\n * This table contains as many values as there might be trailing bytes\n * in a UTF-8 sequence.\n */\nstatic const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,\n    0x03C82080UL, 0xFA082080UL, 0x82082080UL };\n\n/*\n * Utility routine to tell whether a sequence of bytes is legal UTF-8.\n * This must be called with the length pre-determined by the first byte.\n * If not calling this from ConvertUTF8to*, then the length can be set by:\n *  length = trailingBytesForUTF8[*source]+1;\n * and the sequence is illegal right away if there aren't that many bytes\n * available.\n * If presented with a length > 4, this returns 0.  The Unicode\n * definition of UTF-8 goes up to 4-byte sequences.\n */\nstatic unsigned char isLegalUTF8(const UTF8 *source, unsigned long length)\n{\n    UTF8 a;\n    const UTF8 *srcptr = source+length;\n    switch (length) {\n        default: return 0;\n                 /* Everything else falls through when \"1\"... */\n        case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return 0;\n        case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return 0;\n        case 2: if ((a = (*--srcptr)) > 0xBF) return 0;\n\n                    switch (*source) {\n                        /* no fall-through in this inner switch */\n                        case 0xE0: if (a < 0xA0) return 0; break;\n                        case 0xED: if (a > 0x9F) return 0; break;\n                        case 0xF0: if (a < 0x90) return 0; break;\n                        case 0xF4: if (a > 0x8F) return 0; break;\n                        default:   if (a < 0x80) return 0;\n                    }\n\n        case 1: if (*source >= 0x80 && *source < 0xC2) return 0;\n    }\n    if (*source > 0xF4) return 0;\n    return 1;\n}\n\n/* Escapes the UTF16 character and stores the result in the buffer buf. */\nstatic void unicode_escape(char *buf, UTF16 character)\n{\n    const char *digits = \"0123456789abcdef\";\n\n    buf[2] = digits[character >> 12];\n    buf[3] = digits[(character >> 8) & 0xf];\n    buf[4] = digits[(character >> 4) & 0xf];\n    buf[5] = digits[character & 0xf];\n}\n\n/* Escapes the UTF16 character and stores the result in the buffer buf, then\n * the buffer buf is appended to the FBuffer buffer. */\nstatic void unicode_escape_to_buffer(FBuffer *buffer, char buf[6], UTF16\n        character)\n{\n    unicode_escape(buf, character);\n    fbuffer_append(buffer, buf, 6);\n}\n\n/* Converts string to a JSON string in FBuffer buffer, where all but the ASCII\n * and control characters are JSON escaped. */\nstatic void convert_UTF8_to_JSON_ASCII(FBuffer *buffer, VALUE string)\n{\n    const UTF8 *source = (UTF8 *) RSTRING_PTR(string);\n    const UTF8 *sourceEnd = source + RSTRING_LEN(string);\n    char buf[6] = { '\\\\', 'u' };\n\n    while (source < sourceEnd) {\n        UTF32 ch = 0;\n        unsigned short extraBytesToRead = trailingBytesForUTF8[*source];\n        if (source + extraBytesToRead >= sourceEnd) {\n            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                    \"partial character in source, but hit end\");\n        }\n        if (!isLegalUTF8(source, extraBytesToRead+1)) {\n            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                    \"source sequence is illegal/malformed utf-8\");\n        }\n        /*\n         * The cases all fall through. See \"Note A\" below.\n         */\n        switch (extraBytesToRead) {\n            case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */\n            case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */\n            case 3: ch += *source++; ch <<= 6;\n            case 2: ch += *source++; ch <<= 6;\n            case 1: ch += *source++; ch <<= 6;\n            case 0: ch += *source++;\n        }\n        ch -= offsetsFromUTF8[extraBytesToRead];\n\n        if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */\n            /* UTF-16 surrogate values are illegal in UTF-32 */\n            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {\n#if UNI_STRICT_CONVERSION\n                source -= (extraBytesToRead+1); /* return to the illegal value itself */\n                rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                        \"source sequence is illegal/malformed utf-8\");\n#else\n                unicode_escape_to_buffer(buffer, buf, UNI_REPLACEMENT_CHAR);\n#endif\n            } else {\n                /* normal case */\n                if (ch >= 0x20 && ch <= 0x7f) {\n                    switch (ch) {\n                        case '\\\\':\n                            fbuffer_append(buffer, \"\\\\\\\\\", 2);\n                            break;\n                        case '\"':\n                            fbuffer_append(buffer, \"\\\\\\\"\", 2);\n                            break;\n                        default:\n                            fbuffer_append_char(buffer, (char)ch);\n                            break;\n                    }\n                } else {\n                    switch (ch) {\n                        case '\\n':\n                            fbuffer_append(buffer, \"\\\\n\", 2);\n                            break;\n                        case '\\r':\n                            fbuffer_append(buffer, \"\\\\r\", 2);\n                            break;\n                        case '\\t':\n                            fbuffer_append(buffer, \"\\\\t\", 2);\n                            break;\n                        case '\\f':\n                            fbuffer_append(buffer, \"\\\\f\", 2);\n                            break;\n                        case '\\b':\n                            fbuffer_append(buffer, \"\\\\b\", 2);\n                            break;\n                        default:\n                            unicode_escape_to_buffer(buffer, buf, (UTF16) ch);\n                            break;\n                    }\n                }\n            }\n        } else if (ch > UNI_MAX_UTF16) {\n#if UNI_STRICT_CONVERSION\n            source -= (extraBytesToRead+1); /* return to the start */\n            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                    \"source sequence is illegal/malformed utf8\");\n#else\n            unicode_escape_to_buffer(buffer, buf, UNI_REPLACEMENT_CHAR);\n#endif\n        } else {\n            /* target is a character in range 0xFFFF - 0x10FFFF. */\n            ch -= halfBase;\n            unicode_escape_to_buffer(buffer, buf, (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START));\n            unicode_escape_to_buffer(buffer, buf, (UTF16)((ch & halfMask) + UNI_SUR_LOW_START));\n        }\n    }\n    RB_GC_GUARD(string);\n}\n\n/* Converts string to a JSON string in FBuffer buffer, where only the\n * characters required by the JSON standard are JSON escaped. The remaining\n * characters (should be UTF8) are just passed through and appended to the\n * result. */\nstatic void convert_UTF8_to_JSON(FBuffer *buffer, VALUE string)\n{\n    const char *ptr = RSTRING_PTR(string), *p;\n    unsigned long len = RSTRING_LEN(string), start = 0, end = 0;\n    const char *escape = NULL;\n    int escape_len;\n    unsigned char c;\n    char buf[6] = { '\\\\', 'u' };\n\n    for (start = 0, end = 0; end < len;) {\n        p = ptr + end;\n        c = (unsigned char) *p;\n        if (c < 0x20) {\n            switch (c) {\n                case '\\n':\n                    escape = \"\\\\n\";\n                    escape_len = 2;\n                    break;\n                case '\\r':\n                    escape = \"\\\\r\";\n                    escape_len = 2;\n                    break;\n                case '\\t':\n                    escape = \"\\\\t\";\n                    escape_len = 2;\n                    break;\n                case '\\f':\n                    escape = \"\\\\f\";\n                    escape_len = 2;\n                    break;\n                case '\\b':\n                    escape = \"\\\\b\";\n                    escape_len = 2;\n                    break;\n                default:\n                    unicode_escape(buf, (UTF16) *p);\n                    escape = buf;\n                    escape_len = 6;\n                    break;\n            }\n        } else {\n            switch (c) {\n                case '\\\\':\n                    escape = \"\\\\\\\\\";\n                    escape_len = 2;\n                    break;\n                case '\"':\n                    escape =  \"\\\\\\\"\";\n                    escape_len = 2;\n                    break;\n                default:\n                    {\n                        unsigned short clen = trailingBytesForUTF8[c] + 1;\n                        if (end + clen > len) {\n                            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                                    \"partial character in source, but hit end\");\n                        }\n                        if (!isLegalUTF8((UTF8 *) p, clen)) {\n                            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                                    \"source sequence is illegal/malformed utf-8\");\n                        }\n                        end += clen;\n                    }\n                    continue;\n                    break;\n            }\n        }\n        fbuffer_append(buffer, ptr + start, end - start);\n        fbuffer_append(buffer, escape, escape_len);\n        start = ++end;\n        escape = NULL;\n    }\n    fbuffer_append(buffer, ptr + start, end - start);\n}\n\nstatic char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}\n\n/*\n * Document-module: JSON::Ext::Generator\n *\n * This is the JSON generator implemented as a C extension. It can be\n * configured to be used by setting\n *\n *  JSON.generator = JSON::Ext::Generator\n *\n * with the method generator= in JSON.\n *\n */\n\n/*\n * call-seq: to_json(state = nil)\n *\n * Returns a JSON string containing a JSON object, that is generated from\n * this Hash instance.\n * _state_ is a JSON::State object, that can also be used to configure the\n * produced JSON string output further.\n */\nstatic VALUE mHash_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(object);\n}\n\n/*\n * call-seq: to_json(state = nil)\n *\n * Returns a JSON string containing a JSON array, that is generated from\n * this Array instance.\n * _state_ is a JSON::State object, that can also be used to configure the\n * produced JSON string output further.\n */\nstatic VALUE mArray_to_json(int argc, VALUE *argv, VALUE self) {\n    GENERATE_JSON(array);\n}\n\n#ifdef RUBY_INTEGER_UNIFICATION\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Integer number.\n */\nstatic VALUE mInteger_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(integer);\n}\n\n#else\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Integer number.\n */\nstatic VALUE mFixnum_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(fixnum);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Integer number.\n */\nstatic VALUE mBignum_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(bignum);\n}\n#endif\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Float number.\n */\nstatic VALUE mFloat_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(float);\n}\n\n/*\n * call-seq: String.included(modul)\n *\n * Extends _modul_ with the String::Extend module.\n */\nstatic VALUE mString_included_s(VALUE self, VALUE modul) {\n    VALUE result = rb_funcall(modul, i_extend, 1, mString_Extend);\n    return result;\n}\n\n/*\n * call-seq: to_json(*)\n *\n * This string should be encoded with UTF-8 A call to this method\n * returns a JSON string encoded with UTF16 big endian characters as\n * \\u????.\n */\nstatic VALUE mString_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(string);\n}\n\n/*\n * call-seq: to_json_raw_object()\n *\n * This method creates a raw object hash, that can be nested into\n * other data structures and will be generated as a raw string. This\n * method should be used, if you want to convert raw strings to JSON\n * instead of UTF-8 strings, e. g. binary data.\n */\nstatic VALUE mString_to_json_raw_object(VALUE self)\n{\n    VALUE ary;\n    VALUE result = rb_hash_new();\n    rb_hash_aset(result, rb_funcall(mJSON, i_create_id, 0), rb_class_name(rb_obj_class(self)));\n    ary = rb_funcall(self, i_unpack, 1, rb_str_new2(\"C*\"));\n    rb_hash_aset(result, rb_str_new2(\"raw\"), ary);\n    return result;\n}\n\n/*\n * call-seq: to_json_raw(*args)\n *\n * This method creates a JSON text from the result of a call to\n * to_json_raw_object of this String.\n */\nstatic VALUE mString_to_json_raw(int argc, VALUE *argv, VALUE self)\n{\n    VALUE obj = mString_to_json_raw_object(self);\n    Check_Type(obj, T_HASH);\n    return mHash_to_json(argc, argv, obj);\n}\n\n/*\n * call-seq: json_create(o)\n *\n * Raw Strings are JSON Objects (the raw bytes are stored in an array for the\n * key \"raw\"). The Ruby String can be created by this module method.\n */\nstatic VALUE mString_Extend_json_create(VALUE self, VALUE o)\n{\n    VALUE ary;\n    Check_Type(o, T_HASH);\n    ary = rb_hash_aref(o, rb_str_new2(\"raw\"));\n    return rb_funcall(ary, i_pack, 1, rb_str_new2(\"C*\"));\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string for true: 'true'.\n */\nstatic VALUE mTrueClass_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(true);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string for false: 'false'.\n */\nstatic VALUE mFalseClass_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(false);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string for nil: 'null'.\n */\nstatic VALUE mNilClass_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(null);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Converts this object to a string (calling #to_s), converts\n * it to a JSON string, and returns the result. This is a fallback, if no\n * special method #to_json was defined for some object.\n */\nstatic VALUE mObject_to_json(int argc, VALUE *argv, VALUE self)\n{\n    VALUE state;\n    VALUE string = rb_funcall(self, i_to_s, 0);\n    rb_scan_args(argc, argv, \"01\", &state);\n    Check_Type(string, T_STRING);\n    state = cState_from_state_s(cState, state);\n    return cState_partial_generate(state, string);\n}\n\nstatic void State_free(void *ptr)\n{\n    JSON_Generator_State *state = ptr;\n    if (state->indent) ruby_xfree(state->indent);\n    if (state->space) ruby_xfree(state->space);\n    if (state->space_before) ruby_xfree(state->space_before);\n    if (state->object_nl) ruby_xfree(state->object_nl);\n    if (state->array_nl) ruby_xfree(state->array_nl);\n    if (state->array_delim) fbuffer_free(state->array_delim);\n    if (state->object_delim) fbuffer_free(state->object_delim);\n    if (state->object_delim2) fbuffer_free(state->object_delim2);\n    ruby_xfree(state);\n}\n\nstatic size_t State_memsize(const void *ptr)\n{\n    const JSON_Generator_State *state = ptr;\n    size_t size = sizeof(*state);\n    if (state->indent) size += state->indent_len + 1;\n    if (state->space) size += state->space_len + 1;\n    if (state->space_before) size += state->space_before_len + 1;\n    if (state->object_nl) size += state->object_nl_len + 1;\n    if (state->array_nl) size += state->array_nl_len + 1;\n    if (state->array_delim) size += FBUFFER_CAPA(state->array_delim);\n    if (state->object_delim) size += FBUFFER_CAPA(state->object_delim);\n    if (state->object_delim2) size += FBUFFER_CAPA(state->object_delim2);\n    return size;\n}\n\n#ifdef NEW_TYPEDDATA_WRAPPER\nstatic const rb_data_type_t JSON_Generator_State_type = {\n    \"JSON/Generator/State\",\n    {NULL, State_free, State_memsize,},\n#ifdef RUBY_TYPED_FREE_IMMEDIATELY\n    0, 0,\n    RUBY_TYPED_FREE_IMMEDIATELY,\n#endif\n};\n#endif\n\nstatic VALUE cState_s_allocate(VALUE klass)\n{\n    JSON_Generator_State *state;\n    return TypedData_Make_Struct(klass, JSON_Generator_State,\n\t\t\t\t &JSON_Generator_State_type, state);\n}\n\n/*\n * call-seq: configure(opts)\n *\n * Configure this State instance with the Hash _opts_, and return\n * itself.\n */\nstatic VALUE cState_configure(VALUE self, VALUE opts)\n{\n    VALUE tmp;\n    GET_STATE(self);\n    tmp = rb_check_convert_type(opts, T_HASH, \"Hash\", \"to_hash\");\n    if (NIL_P(tmp)) tmp = rb_convert_type(opts, T_HASH, \"Hash\", \"to_h\");\n    opts = tmp;\n    tmp = rb_hash_aref(opts, ID2SYM(i_indent));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->indent = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->indent_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_space));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->space = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->space_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_space_before));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->space_before = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->space_before_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_array_nl));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->array_nl = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->array_nl_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_object_nl));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->object_nl = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->object_nl_len = len;\n    }\n    tmp = ID2SYM(i_max_nesting);\n    state->max_nesting = 100;\n    if (option_given_p(opts, tmp)) {\n        VALUE max_nesting = rb_hash_aref(opts, tmp);\n        if (RTEST(max_nesting)) {\n            Check_Type(max_nesting, T_FIXNUM);\n            state->max_nesting = FIX2LONG(max_nesting);\n        } else {\n            state->max_nesting = 0;\n        }\n    }\n    tmp = ID2SYM(i_depth);\n    state->depth = 0;\n    if (option_given_p(opts, tmp)) {\n        VALUE depth = rb_hash_aref(opts, tmp);\n        if (RTEST(depth)) {\n            Check_Type(depth, T_FIXNUM);\n            state->depth = FIX2LONG(depth);\n        } else {\n            state->depth = 0;\n        }\n    }\n    tmp = ID2SYM(i_buffer_initial_length);\n    if (option_given_p(opts, tmp)) {\n        VALUE buffer_initial_length = rb_hash_aref(opts, tmp);\n        if (RTEST(buffer_initial_length)) {\n            long initial_length;\n            Check_Type(buffer_initial_length, T_FIXNUM);\n            initial_length = FIX2LONG(buffer_initial_length);\n            if (initial_length > 0) state->buffer_initial_length = initial_length;\n        }\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_allow_nan));\n    state->allow_nan = RTEST(tmp);\n    tmp = rb_hash_aref(opts, ID2SYM(i_ascii_only));\n    state->ascii_only = RTEST(tmp);\n    return self;\n}\n\nstatic void set_state_ivars(VALUE hash, VALUE state)\n{\n    VALUE ivars = rb_obj_instance_variables(state);\n    int i = 0;\n    for (i = 0; i < RARRAY_LEN(ivars); i++) {\n        VALUE key = rb_funcall(rb_ary_entry(ivars, i), i_to_s, 0);\n        long key_len = RSTRING_LEN(key);\n        VALUE value = rb_iv_get(state, StringValueCStr(key));\n        rb_hash_aset(hash, rb_str_intern(rb_str_substr(key, 1, key_len - 1)), value);\n    }\n}\n\n/*\n * call-seq: to_h\n *\n * Returns the configuration instance variables as a hash, that can be\n * passed to the configure method.\n */\nstatic VALUE cState_to_h(VALUE self)\n{\n    VALUE result = rb_hash_new();\n    GET_STATE(self);\n    set_state_ivars(result, self);\n    rb_hash_aset(result, ID2SYM(i_indent), rb_str_new(state->indent, state->indent_len));\n    rb_hash_aset(result, ID2SYM(i_space), rb_str_new(state->space, state->space_len));\n    rb_hash_aset(result, ID2SYM(i_space_before), rb_str_new(state->space_before, state->space_before_len));\n    rb_hash_aset(result, ID2SYM(i_object_nl), rb_str_new(state->object_nl, state->object_nl_len));\n    rb_hash_aset(result, ID2SYM(i_array_nl), rb_str_new(state->array_nl, state->array_nl_len));\n    rb_hash_aset(result, ID2SYM(i_allow_nan), state->allow_nan ? Qtrue : Qfalse);\n    rb_hash_aset(result, ID2SYM(i_ascii_only), state->ascii_only ? Qtrue : Qfalse);\n    rb_hash_aset(result, ID2SYM(i_max_nesting), LONG2FIX(state->max_nesting));\n    rb_hash_aset(result, ID2SYM(i_depth), LONG2FIX(state->depth));\n    rb_hash_aset(result, ID2SYM(i_buffer_initial_length), LONG2FIX(state->buffer_initial_length));\n    return result;\n}\n\n/*\n* call-seq: [](name)\n*\n* Returns the value returned by method +name+.\n*/\nstatic VALUE cState_aref(VALUE self, VALUE name)\n{\n    name = rb_funcall(name, i_to_s, 0);\n    if (RTEST(rb_funcall(self, i_respond_to_p, 1, name))) {\n        return rb_funcall(self, i_send, 1, name);\n    } else {\n        return rb_ivar_get(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\"), name)));\n    }\n}\n\n/*\n* call-seq: []=(name, value)\n*\n* Sets the attribute name to value.\n*/\nstatic VALUE cState_aset(VALUE self, VALUE name, VALUE value)\n{\n    VALUE name_writer;\n\n    name = rb_funcall(name, i_to_s, 0);\n    name_writer = rb_str_cat2(rb_str_dup(name), \"=\");\n    if (RTEST(rb_funcall(self, i_respond_to_p, 1, name_writer))) {\n        return rb_funcall(self, i_send, 2, name_writer, value);\n    } else {\n        rb_ivar_set(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\"), name)), value);\n    }\n    return Qnil;\n}\n\nstatic void generate_json_object(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    char *object_nl = state->object_nl;\n    long object_nl_len = state->object_nl_len;\n    char *indent = state->indent;\n    long indent_len = state->indent_len;\n    long max_nesting = state->max_nesting;\n    char *delim = FBUFFER_PTR(state->object_delim);\n    long delim_len = FBUFFER_LEN(state->object_delim);\n    char *delim2 = FBUFFER_PTR(state->object_delim2);\n    long delim2_len = FBUFFER_LEN(state->object_delim2);\n    long depth = ++state->depth;\n    int i, j;\n    VALUE key, key_to_s, keys;\n    if (max_nesting != 0 && depth > max_nesting) {\n        fbuffer_free(buffer);\n        rb_raise(eNestingError, \"nesting of %ld is too deep\", --state->depth);\n    }\n    fbuffer_append_char(buffer, '{');\n    keys = rb_funcall(obj, i_keys, 0);\n    for(i = 0; i < RARRAY_LEN(keys); i++) {\n        if (i > 0) fbuffer_append(buffer, delim, delim_len);\n        if (object_nl) {\n            fbuffer_append(buffer, object_nl, object_nl_len);\n        }\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n        key = rb_ary_entry(keys, i);\n        key_to_s = rb_funcall(key, i_to_s, 0);\n        Check_Type(key_to_s, T_STRING);\n        generate_json(buffer, Vstate, state, key_to_s);\n        fbuffer_append(buffer, delim2, delim2_len);\n        generate_json(buffer, Vstate, state, rb_hash_aref(obj, key));\n    }\n    depth = --state->depth;\n    if (object_nl) {\n        fbuffer_append(buffer, object_nl, object_nl_len);\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n    }\n    fbuffer_append_char(buffer, '}');\n}\n\nstatic void generate_json_array(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    char *array_nl = state->array_nl;\n    long array_nl_len = state->array_nl_len;\n    char *indent = state->indent;\n    long indent_len = state->indent_len;\n    long max_nesting = state->max_nesting;\n    char *delim = FBUFFER_PTR(state->array_delim);\n    long delim_len = FBUFFER_LEN(state->array_delim);\n    long depth = ++state->depth;\n    int i, j;\n    if (max_nesting != 0 && depth > max_nesting) {\n        fbuffer_free(buffer);\n        rb_raise(eNestingError, \"nesting of %ld is too deep\", --state->depth);\n    }\n    fbuffer_append_char(buffer, '[');\n    if (array_nl) fbuffer_append(buffer, array_nl, array_nl_len);\n    for(i = 0; i < RARRAY_LEN(obj); i++) {\n        if (i > 0) fbuffer_append(buffer, delim, delim_len);\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n        generate_json(buffer, Vstate, state, rb_ary_entry(obj, i));\n    }\n    state->depth = --depth;\n    if (array_nl) {\n        fbuffer_append(buffer, array_nl, array_nl_len);\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n    }\n    fbuffer_append_char(buffer, ']');\n}\n\nstatic void generate_json_string(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append_char(buffer, '\"');\n#ifdef HAVE_RUBY_ENCODING_H\n    obj = rb_funcall(obj, i_encode, 1, CEncoding_UTF_8);\n#endif\n    if (state->ascii_only) {\n        convert_UTF8_to_JSON_ASCII(buffer, obj);\n    } else {\n        convert_UTF8_to_JSON(buffer, obj);\n    }\n    fbuffer_append_char(buffer, '\"');\n}\n\nstatic void generate_json_null(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append(buffer, \"null\", 4);\n}\n\nstatic void generate_json_false(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append(buffer, \"false\", 5);\n}\n\nstatic void generate_json_true(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append(buffer, \"true\", 4);\n}\n\nstatic void generate_json_fixnum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append_long(buffer, FIX2LONG(obj));\n}\n\nstatic void generate_json_bignum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    VALUE tmp = rb_funcall(obj, i_to_s, 0);\n    fbuffer_append_str(buffer, tmp);\n}\n\n#ifdef RUBY_INTEGER_UNIFICATION\nstatic void generate_json_integer(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    if (FIXNUM_P(obj))\n        generate_json_fixnum(buffer, Vstate, state, obj);\n    else\n        generate_json_bignum(buffer, Vstate, state, obj);\n}\n#endif\nstatic void generate_json_float(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    double value = RFLOAT_VALUE(obj);\n    char allow_nan = state->allow_nan;\n    VALUE tmp = rb_funcall(obj, i_to_s, 0);\n    if (!allow_nan) {\n        if (isinf(value)) {\n            fbuffer_free(buffer);\n            rb_raise(eGeneratorError, \"%u: %\"PRIsVALUE\" not allowed in JSON\", __LINE__, RB_OBJ_STRING(tmp));\n        } else if (isnan(value)) {\n            fbuffer_free(buffer);\n            rb_raise(eGeneratorError, \"%u: %\"PRIsVALUE\" not allowed in JSON\", __LINE__, RB_OBJ_STRING(tmp));\n        }\n    }\n    fbuffer_append_str(buffer, tmp);\n}\n\nstatic void generate_json(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    VALUE tmp;\n    VALUE klass = CLASS_OF(obj);\n    if (klass == rb_cHash) {\n        generate_json_object(buffer, Vstate, state, obj);\n    } else if (klass == rb_cArray) {\n        generate_json_array(buffer, Vstate, state, obj);\n    } else if (klass == rb_cString) {\n        generate_json_string(buffer, Vstate, state, obj);\n    } else if (obj == Qnil) {\n        generate_json_null(buffer, Vstate, state, obj);\n    } else if (obj == Qfalse) {\n        generate_json_false(buffer, Vstate, state, obj);\n    } else if (obj == Qtrue) {\n        generate_json_true(buffer, Vstate, state, obj);\n    } else if (FIXNUM_P(obj)) {\n        generate_json_fixnum(buffer, Vstate, state, obj);\n    } else if (RB_TYPE_P(obj, T_BIGNUM)) {\n        generate_json_bignum(buffer, Vstate, state, obj);\n    } else if (klass == rb_cFloat) {\n        generate_json_float(buffer, Vstate, state, obj);\n    } else if (rb_respond_to(obj, i_to_json)) {\n        tmp = rb_funcall(obj, i_to_json, 1, Vstate);\n        Check_Type(tmp, T_STRING);\n        fbuffer_append_str(buffer, tmp);\n    } else {\n        tmp = rb_funcall(obj, i_to_s, 0);\n        Check_Type(tmp, T_STRING);\n        generate_json_string(buffer, Vstate, state, tmp);\n    }\n}\n\nstatic FBuffer *cState_prepare_buffer(VALUE self)\n{\n    FBuffer *buffer;\n    GET_STATE(self);\n    buffer = fbuffer_alloc(state->buffer_initial_length);\n\n    if (state->object_delim) {\n        fbuffer_clear(state->object_delim);\n    } else {\n        state->object_delim = fbuffer_alloc(16);\n    }\n    fbuffer_append_char(state->object_delim, ',');\n    if (state->object_delim2) {\n        fbuffer_clear(state->object_delim2);\n    } else {\n        state->object_delim2 = fbuffer_alloc(16);\n    }\n    if (state->space_before) fbuffer_append(state->object_delim2, state->space_before, state->space_before_len);\n    fbuffer_append_char(state->object_delim2, ':');\n    if (state->space) fbuffer_append(state->object_delim2, state->space, state->space_len);\n\n    if (state->array_delim) {\n        fbuffer_clear(state->array_delim);\n    } else {\n        state->array_delim = fbuffer_alloc(16);\n    }\n    fbuffer_append_char(state->array_delim, ',');\n    if (state->array_nl) fbuffer_append(state->array_delim, state->array_nl, state->array_nl_len);\n    return buffer;\n}\n\nstatic VALUE cState_partial_generate(VALUE self, VALUE obj)\n{\n    FBuffer *buffer = cState_prepare_buffer(self);\n    GET_STATE(self);\n    generate_json(buffer, self, state, obj);\n    return fbuffer_to_s(buffer);\n}\n\n/*\n * call-seq: generate(obj)\n *\n * Generates a valid JSON document from object +obj+ and returns the\n * result. If no valid JSON document can be created this method raises a\n * GeneratorError exception.\n */\nstatic VALUE cState_generate(VALUE self, VALUE obj)\n{\n    VALUE result = cState_partial_generate(self, obj);\n    GET_STATE(self);\n    (void)state;\n    return result;\n}\n\n/*\n * call-seq: new(opts = {})\n *\n * Instantiates a new State object, configured by _opts_.\n *\n * _opts_ can have the following keys:\n *\n * * *indent*: a string used to indent levels (default: ''),\n * * *space*: a string that is put after, a : or , delimiter (default: ''),\n * * *space_before*: a string that is put before a : pair delimiter (default: ''),\n * * *object_nl*: a string that is put at the end of a JSON object (default: ''),\n * * *array_nl*: a string that is put at the end of a JSON array (default: ''),\n * * *allow_nan*: true if NaN, Infinity, and -Infinity should be\n *   generated, otherwise an exception is thrown, if these values are\n *   encountered. This options defaults to false.\n * * *buffer_initial_length*: sets the initial length of the generator's\n *   internal buffer.\n */\nstatic VALUE cState_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE opts;\n    GET_STATE(self);\n    state->max_nesting = 100;\n    state->buffer_initial_length = FBUFFER_INITIAL_LENGTH_DEFAULT;\n    rb_scan_args(argc, argv, \"01\", &opts);\n    if (!NIL_P(opts)) cState_configure(self, opts);\n    return self;\n}\n\n/*\n * call-seq: initialize_copy(orig)\n *\n * Initializes this object from orig if it can be duplicated/cloned and returns\n * it.\n*/\nstatic VALUE cState_init_copy(VALUE obj, VALUE orig)\n{\n    JSON_Generator_State *objState, *origState;\n\n    if (obj == orig) return obj;\n    GET_STATE_TO(obj, objState);\n    GET_STATE_TO(orig, origState);\n    if (!objState) rb_raise(rb_eArgError, \"unallocated JSON::State\");\n\n    MEMCPY(objState, origState, JSON_Generator_State, 1);\n    objState->indent = fstrndup(origState->indent, origState->indent_len);\n    objState->space = fstrndup(origState->space, origState->space_len);\n    objState->space_before = fstrndup(origState->space_before, origState->space_before_len);\n    objState->object_nl = fstrndup(origState->object_nl, origState->object_nl_len);\n    objState->array_nl = fstrndup(origState->array_nl, origState->array_nl_len);\n    if (origState->array_delim) objState->array_delim = fbuffer_dup(origState->array_delim);\n    if (origState->object_delim) objState->object_delim = fbuffer_dup(origState->object_delim);\n    if (origState->object_delim2) objState->object_delim2 = fbuffer_dup(origState->object_delim2);\n    return obj;\n}\n\n/*\n * call-seq: from_state(opts)\n *\n * Creates a State object from _opts_, which ought to be Hash to create a\n * new State instance configured by _opts_, something else to create an\n * unconfigured instance. If _opts_ is a State object, it is just returned.\n */\nstatic VALUE cState_from_state_s(VALUE self, VALUE opts)\n{\n    if (rb_obj_is_kind_of(opts, self)) {\n        return opts;\n    } else if (rb_obj_is_kind_of(opts, rb_cHash)) {\n        return rb_funcall(self, i_new, 1, opts);\n    } else {\n        if (NIL_P(CJSON_SAFE_STATE_PROTOTYPE)) {\n            CJSON_SAFE_STATE_PROTOTYPE = rb_const_get(mJSON, i_SAFE_STATE_PROTOTYPE);\n        }\n        return rb_funcall(CJSON_SAFE_STATE_PROTOTYPE, i_dup, 0);\n    }\n}\n\n/*\n * call-seq: indent()\n *\n * Returns the string that is used to indent levels in the JSON text.\n */\nstatic VALUE cState_indent(VALUE self)\n{\n    GET_STATE(self);\n    return state->indent ? rb_str_new(state->indent, state->indent_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: indent=(indent)\n *\n * Sets the string that is used to indent levels in the JSON text.\n */\nstatic VALUE cState_indent_set(VALUE self, VALUE indent)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = strdup(RSTRING_PTR(indent));\n        state->indent_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: space()\n *\n * Returns the string that is used to insert a space between the tokens in a JSON\n * string.\n */\nstatic VALUE cState_space(VALUE self)\n{\n    GET_STATE(self);\n    return state->space ? rb_str_new(state->space, state->space_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: space=(space)\n *\n * Sets _space_ to the string that is used to insert a space between the tokens in a JSON\n * string.\n */\nstatic VALUE cState_space_set(VALUE self, VALUE space)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space, T_STRING);\n    len = RSTRING_LEN(space);\n    if (len == 0) {\n        if (state->space) {\n            ruby_xfree(state->space);\n            state->space = NULL;\n            state->space_len = 0;\n        }\n    } else {\n        if (state->space) ruby_xfree(state->space);\n        state->space = strdup(RSTRING_PTR(space));\n        state->space_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: space_before()\n *\n * Returns the string that is used to insert a space before the ':' in JSON objects.\n */\nstatic VALUE cState_space_before(VALUE self)\n{\n    GET_STATE(self);\n    return state->space_before ? rb_str_new(state->space_before, state->space_before_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: space_before=(space_before)\n *\n * Sets the string that is used to insert a space before the ':' in JSON objects.\n */\nstatic VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = strdup(RSTRING_PTR(space_before));\n        state->space_before_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: object_nl()\n *\n * This string is put at the end of a line that holds a JSON object (or\n * Hash).\n */\nstatic VALUE cState_object_nl(VALUE self)\n{\n    GET_STATE(self);\n    return state->object_nl ? rb_str_new(state->object_nl, state->object_nl_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: object_nl=(object_nl)\n *\n * This string is put at the end of a line that holds a JSON object (or\n * Hash).\n */\nstatic VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = strdup(RSTRING_PTR(object_nl));\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: array_nl()\n *\n * This string is put at the end of a line that holds a JSON array.\n */\nstatic VALUE cState_array_nl(VALUE self)\n{\n    GET_STATE(self);\n    return state->array_nl ? rb_str_new(state->array_nl, state->array_nl_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: array_nl=(array_nl)\n *\n * This string is put at the end of a line that holds a JSON array.\n */\nstatic VALUE cState_array_nl_set(VALUE self, VALUE array_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = strdup(RSTRING_PTR(array_nl));\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}\n\n\n/*\n* call-seq: check_circular?\n*\n* Returns true, if circular data structures should be checked,\n* otherwise returns false.\n*/\nstatic VALUE cState_check_circular_p(VALUE self)\n{\n    GET_STATE(self);\n    return state->max_nesting ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq: max_nesting\n *\n * This integer returns the maximum level of data structure nesting in\n * the generated JSON, max_nesting = 0 if no maximum is checked.\n */\nstatic VALUE cState_max_nesting(VALUE self)\n{\n    GET_STATE(self);\n    return LONG2FIX(state->max_nesting);\n}\n\n/*\n * call-seq: max_nesting=(depth)\n *\n * This sets the maximum level of data structure nesting in the generated JSON\n * to the integer depth, max_nesting = 0 if no maximum should be checked.\n */\nstatic VALUE cState_max_nesting_set(VALUE self, VALUE depth)\n{\n    GET_STATE(self);\n    Check_Type(depth, T_FIXNUM);\n    return state->max_nesting = FIX2LONG(depth);\n}\n\n/*\n * call-seq: allow_nan?\n *\n * Returns true, if NaN, Infinity, and -Infinity should be generated, otherwise\n * returns false.\n */\nstatic VALUE cState_allow_nan_p(VALUE self)\n{\n    GET_STATE(self);\n    return state->allow_nan ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq: ascii_only?\n *\n * Returns true, if NaN, Infinity, and -Infinity should be generated, otherwise\n * returns false.\n */\nstatic VALUE cState_ascii_only_p(VALUE self)\n{\n    GET_STATE(self);\n    return state->ascii_only ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq: depth\n *\n * This integer returns the current depth of data structure nesting.\n */\nstatic VALUE cState_depth(VALUE self)\n{\n    GET_STATE(self);\n    return LONG2FIX(state->depth);\n}\n\n/*\n * call-seq: depth=(depth)\n *\n * This sets the maximum level of data structure nesting in the generated JSON\n * to the integer depth, max_nesting = 0 if no maximum should be checked.\n */\nstatic VALUE cState_depth_set(VALUE self, VALUE depth)\n{\n    GET_STATE(self);\n    Check_Type(depth, T_FIXNUM);\n    state->depth = FIX2LONG(depth);\n    return Qnil;\n}\n\n/*\n * call-seq: buffer_initial_length\n *\n * This integer returns the current initial length of the buffer.\n */\nstatic VALUE cState_buffer_initial_length(VALUE self)\n{\n    GET_STATE(self);\n    return LONG2FIX(state->buffer_initial_length);\n}\n\n/*\n * call-seq: buffer_initial_length=(length)\n *\n * This sets the initial length of the buffer to +length+, if +length+ > 0,\n * otherwise its value isn't changed.\n */\nstatic VALUE cState_buffer_initial_length_set(VALUE self, VALUE buffer_initial_length)\n{\n    long initial_length;\n    GET_STATE(self);\n    Check_Type(buffer_initial_length, T_FIXNUM);\n    initial_length = FIX2LONG(buffer_initial_length);\n    if (initial_length > 0) {\n        state->buffer_initial_length = initial_length;\n    }\n    return Qnil;\n}\n\n/*\n *\n */\nvoid Init_generator(void)\n{\n    rb_require(\"json/common\");\n\n    mJSON = rb_define_module(\"JSON\");\n    mExt = rb_define_module_under(mJSON, \"Ext\");\n    mGenerator = rb_define_module_under(mExt, \"Generator\");\n\n    eGeneratorError = rb_path2class(\"JSON::GeneratorError\");\n    eNestingError = rb_path2class(\"JSON::NestingError\");\n\n    cState = rb_define_class_under(mGenerator, \"State\", rb_cObject);\n    rb_define_alloc_func(cState, cState_s_allocate);\n    rb_define_singleton_method(cState, \"from_state\", cState_from_state_s, 1);\n    rb_define_method(cState, \"initialize\", cState_initialize, -1);\n    rb_define_method(cState, \"initialize_copy\", cState_init_copy, 1);\n    rb_define_method(cState, \"indent\", cState_indent, 0);\n    rb_define_method(cState, \"indent=\", cState_indent_set, 1);\n    rb_define_method(cState, \"space\", cState_space, 0);\n    rb_define_method(cState, \"space=\", cState_space_set, 1);\n    rb_define_method(cState, \"space_before\", cState_space_before, 0);\n    rb_define_method(cState, \"space_before=\", cState_space_before_set, 1);\n    rb_define_method(cState, \"object_nl\", cState_object_nl, 0);\n    rb_define_method(cState, \"object_nl=\", cState_object_nl_set, 1);\n    rb_define_method(cState, \"array_nl\", cState_array_nl, 0);\n    rb_define_method(cState, \"array_nl=\", cState_array_nl_set, 1);\n    rb_define_method(cState, \"max_nesting\", cState_max_nesting, 0);\n    rb_define_method(cState, \"max_nesting=\", cState_max_nesting_set, 1);\n    rb_define_method(cState, \"check_circular?\", cState_check_circular_p, 0);\n    rb_define_method(cState, \"allow_nan?\", cState_allow_nan_p, 0);\n    rb_define_method(cState, \"ascii_only?\", cState_ascii_only_p, 0);\n    rb_define_method(cState, \"depth\", cState_depth, 0);\n    rb_define_method(cState, \"depth=\", cState_depth_set, 1);\n    rb_define_method(cState, \"buffer_initial_length\", cState_buffer_initial_length, 0);\n    rb_define_method(cState, \"buffer_initial_length=\", cState_buffer_initial_length_set, 1);\n    rb_define_method(cState, \"configure\", cState_configure, 1);\n    rb_define_alias(cState, \"merge\", \"configure\");\n    rb_define_method(cState, \"to_h\", cState_to_h, 0);\n    rb_define_alias(cState, \"to_hash\", \"to_h\");\n    rb_define_method(cState, \"[]\", cState_aref, 1);\n    rb_define_method(cState, \"[]=\", cState_aset, 2);\n    rb_define_method(cState, \"generate\", cState_generate, 1);\n\n    mGeneratorMethods = rb_define_module_under(mGenerator, \"GeneratorMethods\");\n    mObject = rb_define_module_under(mGeneratorMethods, \"Object\");\n    rb_define_method(mObject, \"to_json\", mObject_to_json, -1);\n    mHash = rb_define_module_under(mGeneratorMethods, \"Hash\");\n    rb_define_method(mHash, \"to_json\", mHash_to_json, -1);\n    mArray = rb_define_module_under(mGeneratorMethods, \"Array\");\n    rb_define_method(mArray, \"to_json\", mArray_to_json, -1);\n#ifdef RUBY_INTEGER_UNIFICATION\n    mInteger = rb_define_module_under(mGeneratorMethods, \"Integer\");\n    rb_define_method(mInteger, \"to_json\", mInteger_to_json, -1);\n#else\n    mFixnum = rb_define_module_under(mGeneratorMethods, \"Fixnum\");\n    rb_define_method(mFixnum, \"to_json\", mFixnum_to_json, -1);\n    mBignum = rb_define_module_under(mGeneratorMethods, \"Bignum\");\n    rb_define_method(mBignum, \"to_json\", mBignum_to_json, -1);\n#endif\n    mFloat = rb_define_module_under(mGeneratorMethods, \"Float\");\n    rb_define_method(mFloat, \"to_json\", mFloat_to_json, -1);\n    mString = rb_define_module_under(mGeneratorMethods, \"String\");\n    rb_define_singleton_method(mString, \"included\", mString_included_s, 1);\n    rb_define_method(mString, \"to_json\", mString_to_json, -1);\n    rb_define_method(mString, \"to_json_raw\", mString_to_json_raw, -1);\n    rb_define_method(mString, \"to_json_raw_object\", mString_to_json_raw_object, 0);\n    mString_Extend = rb_define_module_under(mString, \"Extend\");\n    rb_define_method(mString_Extend, \"json_create\", mString_Extend_json_create, 1);\n    mTrueClass = rb_define_module_under(mGeneratorMethods, \"TrueClass\");\n    rb_define_method(mTrueClass, \"to_json\", mTrueClass_to_json, -1);\n    mFalseClass = rb_define_module_under(mGeneratorMethods, \"FalseClass\");\n    rb_define_method(mFalseClass, \"to_json\", mFalseClass_to_json, -1);\n    mNilClass = rb_define_module_under(mGeneratorMethods, \"NilClass\");\n    rb_define_method(mNilClass, \"to_json\", mNilClass_to_json, -1);\n\n    CRegexp_MULTILINE = rb_const_get(rb_cRegexp, rb_intern(\"MULTILINE\"));\n    i_to_s = rb_intern(\"to_s\");\n    i_to_json = rb_intern(\"to_json\");\n    i_new = rb_intern(\"new\");\n    i_indent = rb_intern(\"indent\");\n    i_space = rb_intern(\"space\");\n    i_space_before = rb_intern(\"space_before\");\n    i_object_nl = rb_intern(\"object_nl\");\n    i_array_nl = rb_intern(\"array_nl\");\n    i_max_nesting = rb_intern(\"max_nesting\");\n    i_allow_nan = rb_intern(\"allow_nan\");\n    i_ascii_only = rb_intern(\"ascii_only\");\n    i_depth = rb_intern(\"depth\");\n    i_buffer_initial_length = rb_intern(\"buffer_initial_length\");\n    i_pack = rb_intern(\"pack\");\n    i_unpack = rb_intern(\"unpack\");\n    i_create_id = rb_intern(\"create_id\");\n    i_extend = rb_intern(\"extend\");\n    i_key_p = rb_intern(\"key?\");\n    i_aref = rb_intern(\"[]\");\n    i_send = rb_intern(\"__send__\");\n    i_respond_to_p = rb_intern(\"respond_to?\");\n    i_match = rb_intern(\"match\");\n    i_keys = rb_intern(\"keys\");\n    i_dup = rb_intern(\"dup\");\n#ifdef HAVE_RUBY_ENCODING_H\n    CEncoding_UTF_8 = rb_funcall(rb_path2class(\"Encoding\"), rb_intern(\"find\"), 1, rb_str_new2(\"utf-8\"));\n    i_encoding = rb_intern(\"encoding\");\n    i_encode = rb_intern(\"encode\");\n#endif\n    i_SAFE_STATE_PROTOTYPE = rb_intern(\"SAFE_STATE_PROTOTYPE\");\n    CJSON_SAFE_STATE_PROTOTYPE = Qnil;\n}\n", "#ifndef _GENERATOR_H_\n#define _GENERATOR_H_\n\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n\n#include \"ruby.h\"\n\n#ifdef HAVE_RUBY_RE_H\n#include \"ruby/re.h\"\n#else\n#include \"re.h\"\n#endif\n\n#ifndef rb_intern_str\n#define rb_intern_str(string) SYM2ID(rb_str_intern(string))\n#endif\n\n#ifndef rb_obj_instance_variables\n#define rb_obj_instance_variables(object) rb_funcall(object, rb_intern(\"instance_variables\"), 0)\n#endif\n\n#define option_given_p(opts, key) RTEST(rb_funcall(opts, i_key_p, 1, key))\n\n/* unicode definitions */\n\n#define UNI_STRICT_CONVERSION 1\n\ntypedef unsigned long  UTF32; /* at least 32 bits */\ntypedef unsigned short UTF16; /* at least 16 bits */\ntypedef unsigned char  UTF8;  /* typically 8 bits */\n\n#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD\n#define UNI_MAX_BMP (UTF32)0x0000FFFF\n#define UNI_MAX_UTF16 (UTF32)0x0010FFFF\n#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF\n#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF\n\n#define UNI_SUR_HIGH_START  (UTF32)0xD800\n#define UNI_SUR_HIGH_END    (UTF32)0xDBFF\n#define UNI_SUR_LOW_START   (UTF32)0xDC00\n#define UNI_SUR_LOW_END     (UTF32)0xDFFF\n\nstatic const int halfShift  = 10; /* used for shifting by 10 bits */\n\nstatic const UTF32 halfBase = 0x0010000UL;\nstatic const UTF32 halfMask = 0x3FFUL;\n\nstatic unsigned char isLegalUTF8(const UTF8 *source, unsigned long length);\nstatic void unicode_escape(char *buf, UTF16 character);\nstatic void unicode_escape_to_buffer(FBuffer *buffer, char buf[6], UTF16 character);\nstatic void convert_UTF8_to_JSON_ASCII(FBuffer *buffer, VALUE string);\nstatic void convert_UTF8_to_JSON(FBuffer *buffer, VALUE string);\nstatic char *fstrndup(const char *ptr, unsigned long len);\n\n/* ruby api and some helpers */\n\ntypedef struct JSON_Generator_StateStruct {\n    char *indent;\n    long indent_len;\n    char *space;\n    long space_len;\n    char *space_before;\n    long space_before_len;\n    char *object_nl;\n    long object_nl_len;\n    char *array_nl;\n    long array_nl_len;\n    FBuffer *array_delim;\n    FBuffer *object_delim;\n    FBuffer *object_delim2;\n    long max_nesting;\n    char allow_nan;\n    char ascii_only;\n    long depth;\n    long buffer_initial_length;\n} JSON_Generator_State;\n\n#define GET_STATE_TO(self, state) \\\n    TypedData_Get_Struct(self, JSON_Generator_State, &JSON_Generator_State_type, state)\n\n#define GET_STATE(self)                       \\\n    JSON_Generator_State *state;              \\\n    GET_STATE_TO(self, state)\n\n#define GENERATE_JSON(type)                                                                     \\\n    FBuffer *buffer;                                                                            \\\n    VALUE Vstate;                                                                               \\\n    JSON_Generator_State *state;                                                                \\\n                                                                                                \\\n    rb_scan_args(argc, argv, \"01\", &Vstate);                                                    \\\n    Vstate = cState_from_state_s(cState, Vstate);                                               \\\n    TypedData_Get_Struct(Vstate, JSON_Generator_State, &JSON_Generator_State_type, state);\t\\\n    buffer = cState_prepare_buffer(Vstate);                                                     \\\n    generate_json_##type(buffer, Vstate, state, self);                                          \\\n    return fbuffer_to_s(buffer)\n\nstatic VALUE mHash_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mArray_to_json(int argc, VALUE *argv, VALUE self);\n#ifdef RUBY_INTEGER_UNIFICATION\nstatic VALUE mInteger_to_json(int argc, VALUE *argv, VALUE self);\n#else\nstatic VALUE mFixnum_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mBignum_to_json(int argc, VALUE *argv, VALUE self);\n#endif\nstatic VALUE mFloat_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mString_included_s(VALUE self, VALUE modul);\nstatic VALUE mString_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mString_to_json_raw_object(VALUE self);\nstatic VALUE mString_to_json_raw(int argc, VALUE *argv, VALUE self);\nstatic VALUE mString_Extend_json_create(VALUE self, VALUE o);\nstatic VALUE mTrueClass_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mFalseClass_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mNilClass_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mObject_to_json(int argc, VALUE *argv, VALUE self);\nstatic void State_free(void *state);\nstatic VALUE cState_s_allocate(VALUE klass);\nstatic VALUE cState_configure(VALUE self, VALUE opts);\nstatic VALUE cState_to_h(VALUE self);\nstatic void generate_json(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_object(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_array(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_string(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_null(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_false(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_true(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\n#ifdef RUBY_INTEGER_UNIFICATION\nstatic void generate_json_integer(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\n#endif\nstatic void generate_json_fixnum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_bignum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_float(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic VALUE cState_partial_generate(VALUE self, VALUE obj);\nstatic VALUE cState_generate(VALUE self, VALUE obj);\nstatic VALUE cState_initialize(int argc, VALUE *argv, VALUE self);\nstatic VALUE cState_from_state_s(VALUE self, VALUE opts);\nstatic VALUE cState_indent(VALUE self);\nstatic VALUE cState_indent_set(VALUE self, VALUE indent);\nstatic VALUE cState_space(VALUE self);\nstatic VALUE cState_space_set(VALUE self, VALUE space);\nstatic VALUE cState_space_before(VALUE self);\nstatic VALUE cState_space_before_set(VALUE self, VALUE space_before);\nstatic VALUE cState_object_nl(VALUE self);\nstatic VALUE cState_object_nl_set(VALUE self, VALUE object_nl);\nstatic VALUE cState_array_nl(VALUE self);\nstatic VALUE cState_array_nl_set(VALUE self, VALUE array_nl);\nstatic VALUE cState_max_nesting(VALUE self);\nstatic VALUE cState_max_nesting_set(VALUE self, VALUE depth);\nstatic VALUE cState_allow_nan_p(VALUE self);\nstatic VALUE cState_ascii_only_p(VALUE self);\nstatic VALUE cState_depth(VALUE self);\nstatic VALUE cState_depth_set(VALUE self, VALUE depth);\nstatic FBuffer *cState_prepare_buffer(VALUE self);\n#ifndef ZALLOC\n#define ZALLOC(type) ((type *)ruby_zalloc(sizeof(type)))\nstatic inline void *ruby_zalloc(size_t n)\n{\n    void *p = ruby_xmalloc(n);\n    memset(p, 0, n);\n    return p;\n}\n#endif\n#ifdef TypedData_Make_Struct\nstatic const rb_data_type_t JSON_Generator_State_type;\n#define NEW_TYPEDDATA_WRAPPER 1\n#else\n#define TypedData_Make_Struct(klass, type, ignore, json) Data_Make_Struct(klass, type, NULL, State_free, json)\n#define TypedData_Get_Struct(self, JSON_Generator_State, ignore, json) Data_Get_Struct(self, JSON_Generator_State, json)\n#endif\n\n#endif\n"], "fixing_code": ["#include \"../fbuffer/fbuffer.h\"\n#include \"generator.h\"\n\n#ifdef HAVE_RUBY_ENCODING_H\nstatic VALUE CEncoding_UTF_8;\nstatic ID i_encoding, i_encode;\n#endif\n\nstatic VALUE mJSON, mExt, mGenerator, cState, mGeneratorMethods, mObject,\n             mHash, mArray,\n#ifdef RUBY_INTEGER_UNIFICATION\n             mInteger,\n#else\n             mFixnum, mBignum,\n#endif\n             mFloat, mString, mString_Extend,\n             mTrueClass, mFalseClass, mNilClass, eGeneratorError,\n             eNestingError, CRegexp_MULTILINE, CJSON_SAFE_STATE_PROTOTYPE,\n             i_SAFE_STATE_PROTOTYPE;\n\nstatic ID i_to_s, i_to_json, i_new, i_indent, i_space, i_space_before,\n          i_object_nl, i_array_nl, i_max_nesting, i_allow_nan, i_ascii_only,\n          i_pack, i_unpack, i_create_id, i_extend, i_key_p,\n          i_aref, i_send, i_respond_to_p, i_match, i_keys, i_depth,\n          i_buffer_initial_length, i_dup;\n\n/*\n * Copyright 2001-2004 Unicode, Inc.\n *\n * Disclaimer\n *\n * This source code is provided as is by Unicode, Inc. No claims are\n * made as to fitness for any particular purpose. No warranties of any\n * kind are expressed or implied. The recipient agrees to determine\n * applicability of information provided. If this file has been\n * purchased on magnetic or optical media from Unicode, Inc., the\n * sole remedy for any claim will be exchange of defective media\n * within 90 days of receipt.\n *\n * Limitations on Rights to Redistribute This Code\n *\n * Unicode, Inc. hereby grants the right to freely use the information\n * supplied in this file in the creation of products supporting the\n * Unicode Standard, and to make copies of this file in any form\n * for internal or external distribution as long as this notice\n * remains attached.\n */\n\n/*\n * Index into the table below with the first byte of a UTF-8 sequence to\n * get the number of trailing bytes that are supposed to follow it.\n * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is\n * left as-is for anyone who may want to do such conversion, which was\n * allowed in earlier algorithms.\n */\nstatic const char trailingBytesForUTF8[256] = {\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5\n};\n\n/*\n * Magic values subtracted from a buffer value during UTF8 conversion.\n * This table contains as many values as there might be trailing bytes\n * in a UTF-8 sequence.\n */\nstatic const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,\n    0x03C82080UL, 0xFA082080UL, 0x82082080UL };\n\n/*\n * Utility routine to tell whether a sequence of bytes is legal UTF-8.\n * This must be called with the length pre-determined by the first byte.\n * If not calling this from ConvertUTF8to*, then the length can be set by:\n *  length = trailingBytesForUTF8[*source]+1;\n * and the sequence is illegal right away if there aren't that many bytes\n * available.\n * If presented with a length > 4, this returns 0.  The Unicode\n * definition of UTF-8 goes up to 4-byte sequences.\n */\nstatic unsigned char isLegalUTF8(const UTF8 *source, unsigned long length)\n{\n    UTF8 a;\n    const UTF8 *srcptr = source+length;\n    switch (length) {\n        default: return 0;\n                 /* Everything else falls through when \"1\"... */\n        case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return 0;\n        case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return 0;\n        case 2: if ((a = (*--srcptr)) > 0xBF) return 0;\n\n                    switch (*source) {\n                        /* no fall-through in this inner switch */\n                        case 0xE0: if (a < 0xA0) return 0; break;\n                        case 0xED: if (a > 0x9F) return 0; break;\n                        case 0xF0: if (a < 0x90) return 0; break;\n                        case 0xF4: if (a > 0x8F) return 0; break;\n                        default:   if (a < 0x80) return 0;\n                    }\n\n        case 1: if (*source >= 0x80 && *source < 0xC2) return 0;\n    }\n    if (*source > 0xF4) return 0;\n    return 1;\n}\n\n/* Escapes the UTF16 character and stores the result in the buffer buf. */\nstatic void unicode_escape(char *buf, UTF16 character)\n{\n    const char *digits = \"0123456789abcdef\";\n\n    buf[2] = digits[character >> 12];\n    buf[3] = digits[(character >> 8) & 0xf];\n    buf[4] = digits[(character >> 4) & 0xf];\n    buf[5] = digits[character & 0xf];\n}\n\n/* Escapes the UTF16 character and stores the result in the buffer buf, then\n * the buffer buf is appended to the FBuffer buffer. */\nstatic void unicode_escape_to_buffer(FBuffer *buffer, char buf[6], UTF16\n        character)\n{\n    unicode_escape(buf, character);\n    fbuffer_append(buffer, buf, 6);\n}\n\n/* Converts string to a JSON string in FBuffer buffer, where all but the ASCII\n * and control characters are JSON escaped. */\nstatic void convert_UTF8_to_JSON_ASCII(FBuffer *buffer, VALUE string)\n{\n    const UTF8 *source = (UTF8 *) RSTRING_PTR(string);\n    const UTF8 *sourceEnd = source + RSTRING_LEN(string);\n    char buf[6] = { '\\\\', 'u' };\n\n    while (source < sourceEnd) {\n        UTF32 ch = 0;\n        unsigned short extraBytesToRead = trailingBytesForUTF8[*source];\n        if (source + extraBytesToRead >= sourceEnd) {\n            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                    \"partial character in source, but hit end\");\n        }\n        if (!isLegalUTF8(source, extraBytesToRead+1)) {\n            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                    \"source sequence is illegal/malformed utf-8\");\n        }\n        /*\n         * The cases all fall through. See \"Note A\" below.\n         */\n        switch (extraBytesToRead) {\n            case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */\n            case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */\n            case 3: ch += *source++; ch <<= 6;\n            case 2: ch += *source++; ch <<= 6;\n            case 1: ch += *source++; ch <<= 6;\n            case 0: ch += *source++;\n        }\n        ch -= offsetsFromUTF8[extraBytesToRead];\n\n        if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */\n            /* UTF-16 surrogate values are illegal in UTF-32 */\n            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {\n#if UNI_STRICT_CONVERSION\n                source -= (extraBytesToRead+1); /* return to the illegal value itself */\n                rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                        \"source sequence is illegal/malformed utf-8\");\n#else\n                unicode_escape_to_buffer(buffer, buf, UNI_REPLACEMENT_CHAR);\n#endif\n            } else {\n                /* normal case */\n                if (ch >= 0x20 && ch <= 0x7f) {\n                    switch (ch) {\n                        case '\\\\':\n                            fbuffer_append(buffer, \"\\\\\\\\\", 2);\n                            break;\n                        case '\"':\n                            fbuffer_append(buffer, \"\\\\\\\"\", 2);\n                            break;\n                        default:\n                            fbuffer_append_char(buffer, (char)ch);\n                            break;\n                    }\n                } else {\n                    switch (ch) {\n                        case '\\n':\n                            fbuffer_append(buffer, \"\\\\n\", 2);\n                            break;\n                        case '\\r':\n                            fbuffer_append(buffer, \"\\\\r\", 2);\n                            break;\n                        case '\\t':\n                            fbuffer_append(buffer, \"\\\\t\", 2);\n                            break;\n                        case '\\f':\n                            fbuffer_append(buffer, \"\\\\f\", 2);\n                            break;\n                        case '\\b':\n                            fbuffer_append(buffer, \"\\\\b\", 2);\n                            break;\n                        default:\n                            unicode_escape_to_buffer(buffer, buf, (UTF16) ch);\n                            break;\n                    }\n                }\n            }\n        } else if (ch > UNI_MAX_UTF16) {\n#if UNI_STRICT_CONVERSION\n            source -= (extraBytesToRead+1); /* return to the start */\n            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                    \"source sequence is illegal/malformed utf8\");\n#else\n            unicode_escape_to_buffer(buffer, buf, UNI_REPLACEMENT_CHAR);\n#endif\n        } else {\n            /* target is a character in range 0xFFFF - 0x10FFFF. */\n            ch -= halfBase;\n            unicode_escape_to_buffer(buffer, buf, (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START));\n            unicode_escape_to_buffer(buffer, buf, (UTF16)((ch & halfMask) + UNI_SUR_LOW_START));\n        }\n    }\n    RB_GC_GUARD(string);\n}\n\n/* Converts string to a JSON string in FBuffer buffer, where only the\n * characters required by the JSON standard are JSON escaped. The remaining\n * characters (should be UTF8) are just passed through and appended to the\n * result. */\nstatic void convert_UTF8_to_JSON(FBuffer *buffer, VALUE string)\n{\n    const char *ptr = RSTRING_PTR(string), *p;\n    unsigned long len = RSTRING_LEN(string), start = 0, end = 0;\n    const char *escape = NULL;\n    int escape_len;\n    unsigned char c;\n    char buf[6] = { '\\\\', 'u' };\n\n    for (start = 0, end = 0; end < len;) {\n        p = ptr + end;\n        c = (unsigned char) *p;\n        if (c < 0x20) {\n            switch (c) {\n                case '\\n':\n                    escape = \"\\\\n\";\n                    escape_len = 2;\n                    break;\n                case '\\r':\n                    escape = \"\\\\r\";\n                    escape_len = 2;\n                    break;\n                case '\\t':\n                    escape = \"\\\\t\";\n                    escape_len = 2;\n                    break;\n                case '\\f':\n                    escape = \"\\\\f\";\n                    escape_len = 2;\n                    break;\n                case '\\b':\n                    escape = \"\\\\b\";\n                    escape_len = 2;\n                    break;\n                default:\n                    unicode_escape(buf, (UTF16) *p);\n                    escape = buf;\n                    escape_len = 6;\n                    break;\n            }\n        } else {\n            switch (c) {\n                case '\\\\':\n                    escape = \"\\\\\\\\\";\n                    escape_len = 2;\n                    break;\n                case '\"':\n                    escape =  \"\\\\\\\"\";\n                    escape_len = 2;\n                    break;\n                default:\n                    {\n                        unsigned short clen = trailingBytesForUTF8[c] + 1;\n                        if (end + clen > len) {\n                            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                                    \"partial character in source, but hit end\");\n                        }\n                        if (!isLegalUTF8((UTF8 *) p, clen)) {\n                            rb_raise(rb_path2class(\"JSON::GeneratorError\"),\n                                    \"source sequence is illegal/malformed utf-8\");\n                        }\n                        end += clen;\n                    }\n                    continue;\n                    break;\n            }\n        }\n        fbuffer_append(buffer, ptr + start, end - start);\n        fbuffer_append(buffer, escape, escape_len);\n        start = ++end;\n        escape = NULL;\n    }\n    fbuffer_append(buffer, ptr + start, end - start);\n}\n\nstatic char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memcpy(result, ptr, len);\n  return result;\n}\n\n/*\n * Document-module: JSON::Ext::Generator\n *\n * This is the JSON generator implemented as a C extension. It can be\n * configured to be used by setting\n *\n *  JSON.generator = JSON::Ext::Generator\n *\n * with the method generator= in JSON.\n *\n */\n\n/*\n * call-seq: to_json(state = nil)\n *\n * Returns a JSON string containing a JSON object, that is generated from\n * this Hash instance.\n * _state_ is a JSON::State object, that can also be used to configure the\n * produced JSON string output further.\n */\nstatic VALUE mHash_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(object);\n}\n\n/*\n * call-seq: to_json(state = nil)\n *\n * Returns a JSON string containing a JSON array, that is generated from\n * this Array instance.\n * _state_ is a JSON::State object, that can also be used to configure the\n * produced JSON string output further.\n */\nstatic VALUE mArray_to_json(int argc, VALUE *argv, VALUE self) {\n    GENERATE_JSON(array);\n}\n\n#ifdef RUBY_INTEGER_UNIFICATION\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Integer number.\n */\nstatic VALUE mInteger_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(integer);\n}\n\n#else\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Integer number.\n */\nstatic VALUE mFixnum_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(fixnum);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Integer number.\n */\nstatic VALUE mBignum_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(bignum);\n}\n#endif\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string representation for this Float number.\n */\nstatic VALUE mFloat_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(float);\n}\n\n/*\n * call-seq: String.included(modul)\n *\n * Extends _modul_ with the String::Extend module.\n */\nstatic VALUE mString_included_s(VALUE self, VALUE modul) {\n    VALUE result = rb_funcall(modul, i_extend, 1, mString_Extend);\n    return result;\n}\n\n/*\n * call-seq: to_json(*)\n *\n * This string should be encoded with UTF-8 A call to this method\n * returns a JSON string encoded with UTF16 big endian characters as\n * \\u????.\n */\nstatic VALUE mString_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(string);\n}\n\n/*\n * call-seq: to_json_raw_object()\n *\n * This method creates a raw object hash, that can be nested into\n * other data structures and will be generated as a raw string. This\n * method should be used, if you want to convert raw strings to JSON\n * instead of UTF-8 strings, e. g. binary data.\n */\nstatic VALUE mString_to_json_raw_object(VALUE self)\n{\n    VALUE ary;\n    VALUE result = rb_hash_new();\n    rb_hash_aset(result, rb_funcall(mJSON, i_create_id, 0), rb_class_name(rb_obj_class(self)));\n    ary = rb_funcall(self, i_unpack, 1, rb_str_new2(\"C*\"));\n    rb_hash_aset(result, rb_str_new2(\"raw\"), ary);\n    return result;\n}\n\n/*\n * call-seq: to_json_raw(*args)\n *\n * This method creates a JSON text from the result of a call to\n * to_json_raw_object of this String.\n */\nstatic VALUE mString_to_json_raw(int argc, VALUE *argv, VALUE self)\n{\n    VALUE obj = mString_to_json_raw_object(self);\n    Check_Type(obj, T_HASH);\n    return mHash_to_json(argc, argv, obj);\n}\n\n/*\n * call-seq: json_create(o)\n *\n * Raw Strings are JSON Objects (the raw bytes are stored in an array for the\n * key \"raw\"). The Ruby String can be created by this module method.\n */\nstatic VALUE mString_Extend_json_create(VALUE self, VALUE o)\n{\n    VALUE ary;\n    Check_Type(o, T_HASH);\n    ary = rb_hash_aref(o, rb_str_new2(\"raw\"));\n    return rb_funcall(ary, i_pack, 1, rb_str_new2(\"C*\"));\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string for true: 'true'.\n */\nstatic VALUE mTrueClass_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(true);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string for false: 'false'.\n */\nstatic VALUE mFalseClass_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(false);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Returns a JSON string for nil: 'null'.\n */\nstatic VALUE mNilClass_to_json(int argc, VALUE *argv, VALUE self)\n{\n    GENERATE_JSON(null);\n}\n\n/*\n * call-seq: to_json(*)\n *\n * Converts this object to a string (calling #to_s), converts\n * it to a JSON string, and returns the result. This is a fallback, if no\n * special method #to_json was defined for some object.\n */\nstatic VALUE mObject_to_json(int argc, VALUE *argv, VALUE self)\n{\n    VALUE state;\n    VALUE string = rb_funcall(self, i_to_s, 0);\n    rb_scan_args(argc, argv, \"01\", &state);\n    Check_Type(string, T_STRING);\n    state = cState_from_state_s(cState, state);\n    return cState_partial_generate(state, string);\n}\n\nstatic void State_free(void *ptr)\n{\n    JSON_Generator_State *state = ptr;\n    if (state->indent) ruby_xfree(state->indent);\n    if (state->space) ruby_xfree(state->space);\n    if (state->space_before) ruby_xfree(state->space_before);\n    if (state->object_nl) ruby_xfree(state->object_nl);\n    if (state->array_nl) ruby_xfree(state->array_nl);\n    if (state->array_delim) fbuffer_free(state->array_delim);\n    if (state->object_delim) fbuffer_free(state->object_delim);\n    if (state->object_delim2) fbuffer_free(state->object_delim2);\n    ruby_xfree(state);\n}\n\nstatic size_t State_memsize(const void *ptr)\n{\n    const JSON_Generator_State *state = ptr;\n    size_t size = sizeof(*state);\n    if (state->indent) size += state->indent_len + 1;\n    if (state->space) size += state->space_len + 1;\n    if (state->space_before) size += state->space_before_len + 1;\n    if (state->object_nl) size += state->object_nl_len + 1;\n    if (state->array_nl) size += state->array_nl_len + 1;\n    if (state->array_delim) size += FBUFFER_CAPA(state->array_delim);\n    if (state->object_delim) size += FBUFFER_CAPA(state->object_delim);\n    if (state->object_delim2) size += FBUFFER_CAPA(state->object_delim2);\n    return size;\n}\n\n#ifdef NEW_TYPEDDATA_WRAPPER\nstatic const rb_data_type_t JSON_Generator_State_type = {\n    \"JSON/Generator/State\",\n    {NULL, State_free, State_memsize,},\n#ifdef RUBY_TYPED_FREE_IMMEDIATELY\n    0, 0,\n    RUBY_TYPED_FREE_IMMEDIATELY,\n#endif\n};\n#endif\n\nstatic VALUE cState_s_allocate(VALUE klass)\n{\n    JSON_Generator_State *state;\n    return TypedData_Make_Struct(klass, JSON_Generator_State,\n\t\t\t\t &JSON_Generator_State_type, state);\n}\n\n/*\n * call-seq: configure(opts)\n *\n * Configure this State instance with the Hash _opts_, and return\n * itself.\n */\nstatic VALUE cState_configure(VALUE self, VALUE opts)\n{\n    VALUE tmp;\n    GET_STATE(self);\n    tmp = rb_check_convert_type(opts, T_HASH, \"Hash\", \"to_hash\");\n    if (NIL_P(tmp)) tmp = rb_convert_type(opts, T_HASH, \"Hash\", \"to_h\");\n    opts = tmp;\n    tmp = rb_hash_aref(opts, ID2SYM(i_indent));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->indent = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->indent_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_space));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->space = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->space_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_space_before));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->space_before = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->space_before_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_array_nl));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->array_nl = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->array_nl_len = len;\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_object_nl));\n    if (RTEST(tmp)) {\n        unsigned long len;\n        Check_Type(tmp, T_STRING);\n        len = RSTRING_LEN(tmp);\n        state->object_nl = fstrndup(RSTRING_PTR(tmp), len + 1);\n        state->object_nl_len = len;\n    }\n    tmp = ID2SYM(i_max_nesting);\n    state->max_nesting = 100;\n    if (option_given_p(opts, tmp)) {\n        VALUE max_nesting = rb_hash_aref(opts, tmp);\n        if (RTEST(max_nesting)) {\n            Check_Type(max_nesting, T_FIXNUM);\n            state->max_nesting = FIX2LONG(max_nesting);\n        } else {\n            state->max_nesting = 0;\n        }\n    }\n    tmp = ID2SYM(i_depth);\n    state->depth = 0;\n    if (option_given_p(opts, tmp)) {\n        VALUE depth = rb_hash_aref(opts, tmp);\n        if (RTEST(depth)) {\n            Check_Type(depth, T_FIXNUM);\n            state->depth = FIX2LONG(depth);\n        } else {\n            state->depth = 0;\n        }\n    }\n    tmp = ID2SYM(i_buffer_initial_length);\n    if (option_given_p(opts, tmp)) {\n        VALUE buffer_initial_length = rb_hash_aref(opts, tmp);\n        if (RTEST(buffer_initial_length)) {\n            long initial_length;\n            Check_Type(buffer_initial_length, T_FIXNUM);\n            initial_length = FIX2LONG(buffer_initial_length);\n            if (initial_length > 0) state->buffer_initial_length = initial_length;\n        }\n    }\n    tmp = rb_hash_aref(opts, ID2SYM(i_allow_nan));\n    state->allow_nan = RTEST(tmp);\n    tmp = rb_hash_aref(opts, ID2SYM(i_ascii_only));\n    state->ascii_only = RTEST(tmp);\n    return self;\n}\n\nstatic void set_state_ivars(VALUE hash, VALUE state)\n{\n    VALUE ivars = rb_obj_instance_variables(state);\n    int i = 0;\n    for (i = 0; i < RARRAY_LEN(ivars); i++) {\n        VALUE key = rb_funcall(rb_ary_entry(ivars, i), i_to_s, 0);\n        long key_len = RSTRING_LEN(key);\n        VALUE value = rb_iv_get(state, StringValueCStr(key));\n        rb_hash_aset(hash, rb_str_intern(rb_str_substr(key, 1, key_len - 1)), value);\n    }\n}\n\n/*\n * call-seq: to_h\n *\n * Returns the configuration instance variables as a hash, that can be\n * passed to the configure method.\n */\nstatic VALUE cState_to_h(VALUE self)\n{\n    VALUE result = rb_hash_new();\n    GET_STATE(self);\n    set_state_ivars(result, self);\n    rb_hash_aset(result, ID2SYM(i_indent), rb_str_new(state->indent, state->indent_len));\n    rb_hash_aset(result, ID2SYM(i_space), rb_str_new(state->space, state->space_len));\n    rb_hash_aset(result, ID2SYM(i_space_before), rb_str_new(state->space_before, state->space_before_len));\n    rb_hash_aset(result, ID2SYM(i_object_nl), rb_str_new(state->object_nl, state->object_nl_len));\n    rb_hash_aset(result, ID2SYM(i_array_nl), rb_str_new(state->array_nl, state->array_nl_len));\n    rb_hash_aset(result, ID2SYM(i_allow_nan), state->allow_nan ? Qtrue : Qfalse);\n    rb_hash_aset(result, ID2SYM(i_ascii_only), state->ascii_only ? Qtrue : Qfalse);\n    rb_hash_aset(result, ID2SYM(i_max_nesting), LONG2FIX(state->max_nesting));\n    rb_hash_aset(result, ID2SYM(i_depth), LONG2FIX(state->depth));\n    rb_hash_aset(result, ID2SYM(i_buffer_initial_length), LONG2FIX(state->buffer_initial_length));\n    return result;\n}\n\n/*\n* call-seq: [](name)\n*\n* Returns the value returned by method +name+.\n*/\nstatic VALUE cState_aref(VALUE self, VALUE name)\n{\n    name = rb_funcall(name, i_to_s, 0);\n    if (RTEST(rb_funcall(self, i_respond_to_p, 1, name))) {\n        return rb_funcall(self, i_send, 1, name);\n    } else {\n        return rb_ivar_get(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\"), name)));\n    }\n}\n\n/*\n* call-seq: []=(name, value)\n*\n* Sets the attribute name to value.\n*/\nstatic VALUE cState_aset(VALUE self, VALUE name, VALUE value)\n{\n    VALUE name_writer;\n\n    name = rb_funcall(name, i_to_s, 0);\n    name_writer = rb_str_cat2(rb_str_dup(name), \"=\");\n    if (RTEST(rb_funcall(self, i_respond_to_p, 1, name_writer))) {\n        return rb_funcall(self, i_send, 2, name_writer, value);\n    } else {\n        rb_ivar_set(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\"), name)), value);\n    }\n    return Qnil;\n}\n\nstatic void generate_json_object(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    char *object_nl = state->object_nl;\n    long object_nl_len = state->object_nl_len;\n    char *indent = state->indent;\n    long indent_len = state->indent_len;\n    long max_nesting = state->max_nesting;\n    char *delim = FBUFFER_PTR(state->object_delim);\n    long delim_len = FBUFFER_LEN(state->object_delim);\n    char *delim2 = FBUFFER_PTR(state->object_delim2);\n    long delim2_len = FBUFFER_LEN(state->object_delim2);\n    long depth = ++state->depth;\n    int i, j;\n    VALUE key, key_to_s, keys;\n    if (max_nesting != 0 && depth > max_nesting) {\n        fbuffer_free(buffer);\n        rb_raise(eNestingError, \"nesting of %ld is too deep\", --state->depth);\n    }\n    fbuffer_append_char(buffer, '{');\n    keys = rb_funcall(obj, i_keys, 0);\n    for(i = 0; i < RARRAY_LEN(keys); i++) {\n        if (i > 0) fbuffer_append(buffer, delim, delim_len);\n        if (object_nl) {\n            fbuffer_append(buffer, object_nl, object_nl_len);\n        }\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n        key = rb_ary_entry(keys, i);\n        key_to_s = rb_funcall(key, i_to_s, 0);\n        Check_Type(key_to_s, T_STRING);\n        generate_json(buffer, Vstate, state, key_to_s);\n        fbuffer_append(buffer, delim2, delim2_len);\n        generate_json(buffer, Vstate, state, rb_hash_aref(obj, key));\n    }\n    depth = --state->depth;\n    if (object_nl) {\n        fbuffer_append(buffer, object_nl, object_nl_len);\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n    }\n    fbuffer_append_char(buffer, '}');\n}\n\nstatic void generate_json_array(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    char *array_nl = state->array_nl;\n    long array_nl_len = state->array_nl_len;\n    char *indent = state->indent;\n    long indent_len = state->indent_len;\n    long max_nesting = state->max_nesting;\n    char *delim = FBUFFER_PTR(state->array_delim);\n    long delim_len = FBUFFER_LEN(state->array_delim);\n    long depth = ++state->depth;\n    int i, j;\n    if (max_nesting != 0 && depth > max_nesting) {\n        fbuffer_free(buffer);\n        rb_raise(eNestingError, \"nesting of %ld is too deep\", --state->depth);\n    }\n    fbuffer_append_char(buffer, '[');\n    if (array_nl) fbuffer_append(buffer, array_nl, array_nl_len);\n    for(i = 0; i < RARRAY_LEN(obj); i++) {\n        if (i > 0) fbuffer_append(buffer, delim, delim_len);\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n        generate_json(buffer, Vstate, state, rb_ary_entry(obj, i));\n    }\n    state->depth = --depth;\n    if (array_nl) {\n        fbuffer_append(buffer, array_nl, array_nl_len);\n        if (indent) {\n            for (j = 0; j < depth; j++) {\n                fbuffer_append(buffer, indent, indent_len);\n            }\n        }\n    }\n    fbuffer_append_char(buffer, ']');\n}\n\nstatic void generate_json_string(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append_char(buffer, '\"');\n#ifdef HAVE_RUBY_ENCODING_H\n    obj = rb_funcall(obj, i_encode, 1, CEncoding_UTF_8);\n#endif\n    if (state->ascii_only) {\n        convert_UTF8_to_JSON_ASCII(buffer, obj);\n    } else {\n        convert_UTF8_to_JSON(buffer, obj);\n    }\n    fbuffer_append_char(buffer, '\"');\n}\n\nstatic void generate_json_null(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append(buffer, \"null\", 4);\n}\n\nstatic void generate_json_false(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append(buffer, \"false\", 5);\n}\n\nstatic void generate_json_true(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append(buffer, \"true\", 4);\n}\n\nstatic void generate_json_fixnum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    fbuffer_append_long(buffer, FIX2LONG(obj));\n}\n\nstatic void generate_json_bignum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    VALUE tmp = rb_funcall(obj, i_to_s, 0);\n    fbuffer_append_str(buffer, tmp);\n}\n\n#ifdef RUBY_INTEGER_UNIFICATION\nstatic void generate_json_integer(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    if (FIXNUM_P(obj))\n        generate_json_fixnum(buffer, Vstate, state, obj);\n    else\n        generate_json_bignum(buffer, Vstate, state, obj);\n}\n#endif\nstatic void generate_json_float(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    double value = RFLOAT_VALUE(obj);\n    char allow_nan = state->allow_nan;\n    VALUE tmp = rb_funcall(obj, i_to_s, 0);\n    if (!allow_nan) {\n        if (isinf(value)) {\n            fbuffer_free(buffer);\n            rb_raise(eGeneratorError, \"%u: %\"PRIsVALUE\" not allowed in JSON\", __LINE__, RB_OBJ_STRING(tmp));\n        } else if (isnan(value)) {\n            fbuffer_free(buffer);\n            rb_raise(eGeneratorError, \"%u: %\"PRIsVALUE\" not allowed in JSON\", __LINE__, RB_OBJ_STRING(tmp));\n        }\n    }\n    fbuffer_append_str(buffer, tmp);\n}\n\nstatic void generate_json(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj)\n{\n    VALUE tmp;\n    VALUE klass = CLASS_OF(obj);\n    if (klass == rb_cHash) {\n        generate_json_object(buffer, Vstate, state, obj);\n    } else if (klass == rb_cArray) {\n        generate_json_array(buffer, Vstate, state, obj);\n    } else if (klass == rb_cString) {\n        generate_json_string(buffer, Vstate, state, obj);\n    } else if (obj == Qnil) {\n        generate_json_null(buffer, Vstate, state, obj);\n    } else if (obj == Qfalse) {\n        generate_json_false(buffer, Vstate, state, obj);\n    } else if (obj == Qtrue) {\n        generate_json_true(buffer, Vstate, state, obj);\n    } else if (FIXNUM_P(obj)) {\n        generate_json_fixnum(buffer, Vstate, state, obj);\n    } else if (RB_TYPE_P(obj, T_BIGNUM)) {\n        generate_json_bignum(buffer, Vstate, state, obj);\n    } else if (klass == rb_cFloat) {\n        generate_json_float(buffer, Vstate, state, obj);\n    } else if (rb_respond_to(obj, i_to_json)) {\n        tmp = rb_funcall(obj, i_to_json, 1, Vstate);\n        Check_Type(tmp, T_STRING);\n        fbuffer_append_str(buffer, tmp);\n    } else {\n        tmp = rb_funcall(obj, i_to_s, 0);\n        Check_Type(tmp, T_STRING);\n        generate_json_string(buffer, Vstate, state, tmp);\n    }\n}\n\nstatic FBuffer *cState_prepare_buffer(VALUE self)\n{\n    FBuffer *buffer;\n    GET_STATE(self);\n    buffer = fbuffer_alloc(state->buffer_initial_length);\n\n    if (state->object_delim) {\n        fbuffer_clear(state->object_delim);\n    } else {\n        state->object_delim = fbuffer_alloc(16);\n    }\n    fbuffer_append_char(state->object_delim, ',');\n    if (state->object_delim2) {\n        fbuffer_clear(state->object_delim2);\n    } else {\n        state->object_delim2 = fbuffer_alloc(16);\n    }\n    if (state->space_before) fbuffer_append(state->object_delim2, state->space_before, state->space_before_len);\n    fbuffer_append_char(state->object_delim2, ':');\n    if (state->space) fbuffer_append(state->object_delim2, state->space, state->space_len);\n\n    if (state->array_delim) {\n        fbuffer_clear(state->array_delim);\n    } else {\n        state->array_delim = fbuffer_alloc(16);\n    }\n    fbuffer_append_char(state->array_delim, ',');\n    if (state->array_nl) fbuffer_append(state->array_delim, state->array_nl, state->array_nl_len);\n    return buffer;\n}\n\nstatic VALUE cState_partial_generate(VALUE self, VALUE obj)\n{\n    FBuffer *buffer = cState_prepare_buffer(self);\n    GET_STATE(self);\n    generate_json(buffer, self, state, obj);\n    return fbuffer_to_s(buffer);\n}\n\n/*\n * call-seq: generate(obj)\n *\n * Generates a valid JSON document from object +obj+ and returns the\n * result. If no valid JSON document can be created this method raises a\n * GeneratorError exception.\n */\nstatic VALUE cState_generate(VALUE self, VALUE obj)\n{\n    VALUE result = cState_partial_generate(self, obj);\n    GET_STATE(self);\n    (void)state;\n    return result;\n}\n\n/*\n * call-seq: new(opts = {})\n *\n * Instantiates a new State object, configured by _opts_.\n *\n * _opts_ can have the following keys:\n *\n * * *indent*: a string used to indent levels (default: ''),\n * * *space*: a string that is put after, a : or , delimiter (default: ''),\n * * *space_before*: a string that is put before a : pair delimiter (default: ''),\n * * *object_nl*: a string that is put at the end of a JSON object (default: ''),\n * * *array_nl*: a string that is put at the end of a JSON array (default: ''),\n * * *allow_nan*: true if NaN, Infinity, and -Infinity should be\n *   generated, otherwise an exception is thrown, if these values are\n *   encountered. This options defaults to false.\n * * *buffer_initial_length*: sets the initial length of the generator's\n *   internal buffer.\n */\nstatic VALUE cState_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE opts;\n    GET_STATE(self);\n    state->max_nesting = 100;\n    state->buffer_initial_length = FBUFFER_INITIAL_LENGTH_DEFAULT;\n    rb_scan_args(argc, argv, \"01\", &opts);\n    if (!NIL_P(opts)) cState_configure(self, opts);\n    return self;\n}\n\n/*\n * call-seq: initialize_copy(orig)\n *\n * Initializes this object from orig if it can be duplicated/cloned and returns\n * it.\n*/\nstatic VALUE cState_init_copy(VALUE obj, VALUE orig)\n{\n    JSON_Generator_State *objState, *origState;\n\n    if (obj == orig) return obj;\n    GET_STATE_TO(obj, objState);\n    GET_STATE_TO(orig, origState);\n    if (!objState) rb_raise(rb_eArgError, \"unallocated JSON::State\");\n\n    MEMCPY(objState, origState, JSON_Generator_State, 1);\n    objState->indent = fstrndup(origState->indent, origState->indent_len);\n    objState->space = fstrndup(origState->space, origState->space_len);\n    objState->space_before = fstrndup(origState->space_before, origState->space_before_len);\n    objState->object_nl = fstrndup(origState->object_nl, origState->object_nl_len);\n    objState->array_nl = fstrndup(origState->array_nl, origState->array_nl_len);\n    if (origState->array_delim) objState->array_delim = fbuffer_dup(origState->array_delim);\n    if (origState->object_delim) objState->object_delim = fbuffer_dup(origState->object_delim);\n    if (origState->object_delim2) objState->object_delim2 = fbuffer_dup(origState->object_delim2);\n    return obj;\n}\n\n/*\n * call-seq: from_state(opts)\n *\n * Creates a State object from _opts_, which ought to be Hash to create a\n * new State instance configured by _opts_, something else to create an\n * unconfigured instance. If _opts_ is a State object, it is just returned.\n */\nstatic VALUE cState_from_state_s(VALUE self, VALUE opts)\n{\n    if (rb_obj_is_kind_of(opts, self)) {\n        return opts;\n    } else if (rb_obj_is_kind_of(opts, rb_cHash)) {\n        return rb_funcall(self, i_new, 1, opts);\n    } else {\n        if (NIL_P(CJSON_SAFE_STATE_PROTOTYPE)) {\n            CJSON_SAFE_STATE_PROTOTYPE = rb_const_get(mJSON, i_SAFE_STATE_PROTOTYPE);\n        }\n        return rb_funcall(CJSON_SAFE_STATE_PROTOTYPE, i_dup, 0);\n    }\n}\n\n/*\n * call-seq: indent()\n *\n * Returns the string that is used to indent levels in the JSON text.\n */\nstatic VALUE cState_indent(VALUE self)\n{\n    GET_STATE(self);\n    return state->indent ? rb_str_new(state->indent, state->indent_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: indent=(indent)\n *\n * Sets the string that is used to indent levels in the JSON text.\n */\nstatic VALUE cState_indent_set(VALUE self, VALUE indent)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = fstrndup(RSTRING_PTR(indent), len);\n        state->indent_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: space()\n *\n * Returns the string that is used to insert a space between the tokens in a JSON\n * string.\n */\nstatic VALUE cState_space(VALUE self)\n{\n    GET_STATE(self);\n    return state->space ? rb_str_new(state->space, state->space_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: space=(space)\n *\n * Sets _space_ to the string that is used to insert a space between the tokens in a JSON\n * string.\n */\nstatic VALUE cState_space_set(VALUE self, VALUE space)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space, T_STRING);\n    len = RSTRING_LEN(space);\n    if (len == 0) {\n        if (state->space) {\n            ruby_xfree(state->space);\n            state->space = NULL;\n            state->space_len = 0;\n        }\n    } else {\n        if (state->space) ruby_xfree(state->space);\n        state->space = fstrndup(RSTRING_PTR(space), len);\n        state->space_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: space_before()\n *\n * Returns the string that is used to insert a space before the ':' in JSON objects.\n */\nstatic VALUE cState_space_before(VALUE self)\n{\n    GET_STATE(self);\n    return state->space_before ? rb_str_new(state->space_before, state->space_before_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: space_before=(space_before)\n *\n * Sets the string that is used to insert a space before the ':' in JSON objects.\n */\nstatic VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = fstrndup(RSTRING_PTR(space_before), len);\n        state->space_before_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: object_nl()\n *\n * This string is put at the end of a line that holds a JSON object (or\n * Hash).\n */\nstatic VALUE cState_object_nl(VALUE self)\n{\n    GET_STATE(self);\n    return state->object_nl ? rb_str_new(state->object_nl, state->object_nl_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: object_nl=(object_nl)\n *\n * This string is put at the end of a line that holds a JSON object (or\n * Hash).\n */\nstatic VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = fstrndup(RSTRING_PTR(object_nl), len);\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}\n\n/*\n * call-seq: array_nl()\n *\n * This string is put at the end of a line that holds a JSON array.\n */\nstatic VALUE cState_array_nl(VALUE self)\n{\n    GET_STATE(self);\n    return state->array_nl ? rb_str_new(state->array_nl, state->array_nl_len) : rb_str_new2(\"\");\n}\n\n/*\n * call-seq: array_nl=(array_nl)\n *\n * This string is put at the end of a line that holds a JSON array.\n */\nstatic VALUE cState_array_nl_set(VALUE self, VALUE array_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = fstrndup(RSTRING_PTR(array_nl), len);\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}\n\n\n/*\n* call-seq: check_circular?\n*\n* Returns true, if circular data structures should be checked,\n* otherwise returns false.\n*/\nstatic VALUE cState_check_circular_p(VALUE self)\n{\n    GET_STATE(self);\n    return state->max_nesting ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq: max_nesting\n *\n * This integer returns the maximum level of data structure nesting in\n * the generated JSON, max_nesting = 0 if no maximum is checked.\n */\nstatic VALUE cState_max_nesting(VALUE self)\n{\n    GET_STATE(self);\n    return LONG2FIX(state->max_nesting);\n}\n\n/*\n * call-seq: max_nesting=(depth)\n *\n * This sets the maximum level of data structure nesting in the generated JSON\n * to the integer depth, max_nesting = 0 if no maximum should be checked.\n */\nstatic VALUE cState_max_nesting_set(VALUE self, VALUE depth)\n{\n    GET_STATE(self);\n    Check_Type(depth, T_FIXNUM);\n    return state->max_nesting = FIX2LONG(depth);\n}\n\n/*\n * call-seq: allow_nan?\n *\n * Returns true, if NaN, Infinity, and -Infinity should be generated, otherwise\n * returns false.\n */\nstatic VALUE cState_allow_nan_p(VALUE self)\n{\n    GET_STATE(self);\n    return state->allow_nan ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq: ascii_only?\n *\n * Returns true, if NaN, Infinity, and -Infinity should be generated, otherwise\n * returns false.\n */\nstatic VALUE cState_ascii_only_p(VALUE self)\n{\n    GET_STATE(self);\n    return state->ascii_only ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq: depth\n *\n * This integer returns the current depth of data structure nesting.\n */\nstatic VALUE cState_depth(VALUE self)\n{\n    GET_STATE(self);\n    return LONG2FIX(state->depth);\n}\n\n/*\n * call-seq: depth=(depth)\n *\n * This sets the maximum level of data structure nesting in the generated JSON\n * to the integer depth, max_nesting = 0 if no maximum should be checked.\n */\nstatic VALUE cState_depth_set(VALUE self, VALUE depth)\n{\n    GET_STATE(self);\n    Check_Type(depth, T_FIXNUM);\n    state->depth = FIX2LONG(depth);\n    return Qnil;\n}\n\n/*\n * call-seq: buffer_initial_length\n *\n * This integer returns the current initial length of the buffer.\n */\nstatic VALUE cState_buffer_initial_length(VALUE self)\n{\n    GET_STATE(self);\n    return LONG2FIX(state->buffer_initial_length);\n}\n\n/*\n * call-seq: buffer_initial_length=(length)\n *\n * This sets the initial length of the buffer to +length+, if +length+ > 0,\n * otherwise its value isn't changed.\n */\nstatic VALUE cState_buffer_initial_length_set(VALUE self, VALUE buffer_initial_length)\n{\n    long initial_length;\n    GET_STATE(self);\n    Check_Type(buffer_initial_length, T_FIXNUM);\n    initial_length = FIX2LONG(buffer_initial_length);\n    if (initial_length > 0) {\n        state->buffer_initial_length = initial_length;\n    }\n    return Qnil;\n}\n\n/*\n *\n */\nvoid Init_generator(void)\n{\n    rb_require(\"json/common\");\n\n    mJSON = rb_define_module(\"JSON\");\n    mExt = rb_define_module_under(mJSON, \"Ext\");\n    mGenerator = rb_define_module_under(mExt, \"Generator\");\n\n    eGeneratorError = rb_path2class(\"JSON::GeneratorError\");\n    eNestingError = rb_path2class(\"JSON::NestingError\");\n\n    cState = rb_define_class_under(mGenerator, \"State\", rb_cObject);\n    rb_define_alloc_func(cState, cState_s_allocate);\n    rb_define_singleton_method(cState, \"from_state\", cState_from_state_s, 1);\n    rb_define_method(cState, \"initialize\", cState_initialize, -1);\n    rb_define_method(cState, \"initialize_copy\", cState_init_copy, 1);\n    rb_define_method(cState, \"indent\", cState_indent, 0);\n    rb_define_method(cState, \"indent=\", cState_indent_set, 1);\n    rb_define_method(cState, \"space\", cState_space, 0);\n    rb_define_method(cState, \"space=\", cState_space_set, 1);\n    rb_define_method(cState, \"space_before\", cState_space_before, 0);\n    rb_define_method(cState, \"space_before=\", cState_space_before_set, 1);\n    rb_define_method(cState, \"object_nl\", cState_object_nl, 0);\n    rb_define_method(cState, \"object_nl=\", cState_object_nl_set, 1);\n    rb_define_method(cState, \"array_nl\", cState_array_nl, 0);\n    rb_define_method(cState, \"array_nl=\", cState_array_nl_set, 1);\n    rb_define_method(cState, \"max_nesting\", cState_max_nesting, 0);\n    rb_define_method(cState, \"max_nesting=\", cState_max_nesting_set, 1);\n    rb_define_method(cState, \"check_circular?\", cState_check_circular_p, 0);\n    rb_define_method(cState, \"allow_nan?\", cState_allow_nan_p, 0);\n    rb_define_method(cState, \"ascii_only?\", cState_ascii_only_p, 0);\n    rb_define_method(cState, \"depth\", cState_depth, 0);\n    rb_define_method(cState, \"depth=\", cState_depth_set, 1);\n    rb_define_method(cState, \"buffer_initial_length\", cState_buffer_initial_length, 0);\n    rb_define_method(cState, \"buffer_initial_length=\", cState_buffer_initial_length_set, 1);\n    rb_define_method(cState, \"configure\", cState_configure, 1);\n    rb_define_alias(cState, \"merge\", \"configure\");\n    rb_define_method(cState, \"to_h\", cState_to_h, 0);\n    rb_define_alias(cState, \"to_hash\", \"to_h\");\n    rb_define_method(cState, \"[]\", cState_aref, 1);\n    rb_define_method(cState, \"[]=\", cState_aset, 2);\n    rb_define_method(cState, \"generate\", cState_generate, 1);\n\n    mGeneratorMethods = rb_define_module_under(mGenerator, \"GeneratorMethods\");\n    mObject = rb_define_module_under(mGeneratorMethods, \"Object\");\n    rb_define_method(mObject, \"to_json\", mObject_to_json, -1);\n    mHash = rb_define_module_under(mGeneratorMethods, \"Hash\");\n    rb_define_method(mHash, \"to_json\", mHash_to_json, -1);\n    mArray = rb_define_module_under(mGeneratorMethods, \"Array\");\n    rb_define_method(mArray, \"to_json\", mArray_to_json, -1);\n#ifdef RUBY_INTEGER_UNIFICATION\n    mInteger = rb_define_module_under(mGeneratorMethods, \"Integer\");\n    rb_define_method(mInteger, \"to_json\", mInteger_to_json, -1);\n#else\n    mFixnum = rb_define_module_under(mGeneratorMethods, \"Fixnum\");\n    rb_define_method(mFixnum, \"to_json\", mFixnum_to_json, -1);\n    mBignum = rb_define_module_under(mGeneratorMethods, \"Bignum\");\n    rb_define_method(mBignum, \"to_json\", mBignum_to_json, -1);\n#endif\n    mFloat = rb_define_module_under(mGeneratorMethods, \"Float\");\n    rb_define_method(mFloat, \"to_json\", mFloat_to_json, -1);\n    mString = rb_define_module_under(mGeneratorMethods, \"String\");\n    rb_define_singleton_method(mString, \"included\", mString_included_s, 1);\n    rb_define_method(mString, \"to_json\", mString_to_json, -1);\n    rb_define_method(mString, \"to_json_raw\", mString_to_json_raw, -1);\n    rb_define_method(mString, \"to_json_raw_object\", mString_to_json_raw_object, 0);\n    mString_Extend = rb_define_module_under(mString, \"Extend\");\n    rb_define_method(mString_Extend, \"json_create\", mString_Extend_json_create, 1);\n    mTrueClass = rb_define_module_under(mGeneratorMethods, \"TrueClass\");\n    rb_define_method(mTrueClass, \"to_json\", mTrueClass_to_json, -1);\n    mFalseClass = rb_define_module_under(mGeneratorMethods, \"FalseClass\");\n    rb_define_method(mFalseClass, \"to_json\", mFalseClass_to_json, -1);\n    mNilClass = rb_define_module_under(mGeneratorMethods, \"NilClass\");\n    rb_define_method(mNilClass, \"to_json\", mNilClass_to_json, -1);\n\n    CRegexp_MULTILINE = rb_const_get(rb_cRegexp, rb_intern(\"MULTILINE\"));\n    i_to_s = rb_intern(\"to_s\");\n    i_to_json = rb_intern(\"to_json\");\n    i_new = rb_intern(\"new\");\n    i_indent = rb_intern(\"indent\");\n    i_space = rb_intern(\"space\");\n    i_space_before = rb_intern(\"space_before\");\n    i_object_nl = rb_intern(\"object_nl\");\n    i_array_nl = rb_intern(\"array_nl\");\n    i_max_nesting = rb_intern(\"max_nesting\");\n    i_allow_nan = rb_intern(\"allow_nan\");\n    i_ascii_only = rb_intern(\"ascii_only\");\n    i_depth = rb_intern(\"depth\");\n    i_buffer_initial_length = rb_intern(\"buffer_initial_length\");\n    i_pack = rb_intern(\"pack\");\n    i_unpack = rb_intern(\"unpack\");\n    i_create_id = rb_intern(\"create_id\");\n    i_extend = rb_intern(\"extend\");\n    i_key_p = rb_intern(\"key?\");\n    i_aref = rb_intern(\"[]\");\n    i_send = rb_intern(\"__send__\");\n    i_respond_to_p = rb_intern(\"respond_to?\");\n    i_match = rb_intern(\"match\");\n    i_keys = rb_intern(\"keys\");\n    i_dup = rb_intern(\"dup\");\n#ifdef HAVE_RUBY_ENCODING_H\n    CEncoding_UTF_8 = rb_funcall(rb_path2class(\"Encoding\"), rb_intern(\"find\"), 1, rb_str_new2(\"utf-8\"));\n    i_encoding = rb_intern(\"encoding\");\n    i_encode = rb_intern(\"encode\");\n#endif\n    i_SAFE_STATE_PROTOTYPE = rb_intern(\"SAFE_STATE_PROTOTYPE\");\n    CJSON_SAFE_STATE_PROTOTYPE = Qnil;\n}\n", "#ifndef _GENERATOR_H_\n#define _GENERATOR_H_\n\n#include <math.h>\n#include <ctype.h>\n\n#include \"ruby.h\"\n\n#ifdef HAVE_RUBY_RE_H\n#include \"ruby/re.h\"\n#else\n#include \"re.h\"\n#endif\n\n#ifndef rb_intern_str\n#define rb_intern_str(string) SYM2ID(rb_str_intern(string))\n#endif\n\n#ifndef rb_obj_instance_variables\n#define rb_obj_instance_variables(object) rb_funcall(object, rb_intern(\"instance_variables\"), 0)\n#endif\n\n#define option_given_p(opts, key) RTEST(rb_funcall(opts, i_key_p, 1, key))\n\n/* unicode definitions */\n\n#define UNI_STRICT_CONVERSION 1\n\ntypedef unsigned long  UTF32; /* at least 32 bits */\ntypedef unsigned short UTF16; /* at least 16 bits */\ntypedef unsigned char  UTF8;  /* typically 8 bits */\n\n#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD\n#define UNI_MAX_BMP (UTF32)0x0000FFFF\n#define UNI_MAX_UTF16 (UTF32)0x0010FFFF\n#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF\n#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF\n\n#define UNI_SUR_HIGH_START  (UTF32)0xD800\n#define UNI_SUR_HIGH_END    (UTF32)0xDBFF\n#define UNI_SUR_LOW_START   (UTF32)0xDC00\n#define UNI_SUR_LOW_END     (UTF32)0xDFFF\n\nstatic const int halfShift  = 10; /* used for shifting by 10 bits */\n\nstatic const UTF32 halfBase = 0x0010000UL;\nstatic const UTF32 halfMask = 0x3FFUL;\n\nstatic unsigned char isLegalUTF8(const UTF8 *source, unsigned long length);\nstatic void unicode_escape(char *buf, UTF16 character);\nstatic void unicode_escape_to_buffer(FBuffer *buffer, char buf[6], UTF16 character);\nstatic void convert_UTF8_to_JSON_ASCII(FBuffer *buffer, VALUE string);\nstatic void convert_UTF8_to_JSON(FBuffer *buffer, VALUE string);\nstatic char *fstrndup(const char *ptr, unsigned long len);\n\n/* ruby api and some helpers */\n\ntypedef struct JSON_Generator_StateStruct {\n    char *indent;\n    long indent_len;\n    char *space;\n    long space_len;\n    char *space_before;\n    long space_before_len;\n    char *object_nl;\n    long object_nl_len;\n    char *array_nl;\n    long array_nl_len;\n    FBuffer *array_delim;\n    FBuffer *object_delim;\n    FBuffer *object_delim2;\n    long max_nesting;\n    char allow_nan;\n    char ascii_only;\n    long depth;\n    long buffer_initial_length;\n} JSON_Generator_State;\n\n#define GET_STATE_TO(self, state) \\\n    TypedData_Get_Struct(self, JSON_Generator_State, &JSON_Generator_State_type, state)\n\n#define GET_STATE(self)                       \\\n    JSON_Generator_State *state;              \\\n    GET_STATE_TO(self, state)\n\n#define GENERATE_JSON(type)                                                                     \\\n    FBuffer *buffer;                                                                            \\\n    VALUE Vstate;                                                                               \\\n    JSON_Generator_State *state;                                                                \\\n                                                                                                \\\n    rb_scan_args(argc, argv, \"01\", &Vstate);                                                    \\\n    Vstate = cState_from_state_s(cState, Vstate);                                               \\\n    TypedData_Get_Struct(Vstate, JSON_Generator_State, &JSON_Generator_State_type, state);\t\\\n    buffer = cState_prepare_buffer(Vstate);                                                     \\\n    generate_json_##type(buffer, Vstate, state, self);                                          \\\n    return fbuffer_to_s(buffer)\n\nstatic VALUE mHash_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mArray_to_json(int argc, VALUE *argv, VALUE self);\n#ifdef RUBY_INTEGER_UNIFICATION\nstatic VALUE mInteger_to_json(int argc, VALUE *argv, VALUE self);\n#else\nstatic VALUE mFixnum_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mBignum_to_json(int argc, VALUE *argv, VALUE self);\n#endif\nstatic VALUE mFloat_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mString_included_s(VALUE self, VALUE modul);\nstatic VALUE mString_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mString_to_json_raw_object(VALUE self);\nstatic VALUE mString_to_json_raw(int argc, VALUE *argv, VALUE self);\nstatic VALUE mString_Extend_json_create(VALUE self, VALUE o);\nstatic VALUE mTrueClass_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mFalseClass_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mNilClass_to_json(int argc, VALUE *argv, VALUE self);\nstatic VALUE mObject_to_json(int argc, VALUE *argv, VALUE self);\nstatic void State_free(void *state);\nstatic VALUE cState_s_allocate(VALUE klass);\nstatic VALUE cState_configure(VALUE self, VALUE opts);\nstatic VALUE cState_to_h(VALUE self);\nstatic void generate_json(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_object(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_array(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_string(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_null(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_false(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_true(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\n#ifdef RUBY_INTEGER_UNIFICATION\nstatic void generate_json_integer(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\n#endif\nstatic void generate_json_fixnum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_bignum(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic void generate_json_float(FBuffer *buffer, VALUE Vstate, JSON_Generator_State *state, VALUE obj);\nstatic VALUE cState_partial_generate(VALUE self, VALUE obj);\nstatic VALUE cState_generate(VALUE self, VALUE obj);\nstatic VALUE cState_initialize(int argc, VALUE *argv, VALUE self);\nstatic VALUE cState_from_state_s(VALUE self, VALUE opts);\nstatic VALUE cState_indent(VALUE self);\nstatic VALUE cState_indent_set(VALUE self, VALUE indent);\nstatic VALUE cState_space(VALUE self);\nstatic VALUE cState_space_set(VALUE self, VALUE space);\nstatic VALUE cState_space_before(VALUE self);\nstatic VALUE cState_space_before_set(VALUE self, VALUE space_before);\nstatic VALUE cState_object_nl(VALUE self);\nstatic VALUE cState_object_nl_set(VALUE self, VALUE object_nl);\nstatic VALUE cState_array_nl(VALUE self);\nstatic VALUE cState_array_nl_set(VALUE self, VALUE array_nl);\nstatic VALUE cState_max_nesting(VALUE self);\nstatic VALUE cState_max_nesting_set(VALUE self, VALUE depth);\nstatic VALUE cState_allow_nan_p(VALUE self);\nstatic VALUE cState_ascii_only_p(VALUE self);\nstatic VALUE cState_depth(VALUE self);\nstatic VALUE cState_depth_set(VALUE self, VALUE depth);\nstatic FBuffer *cState_prepare_buffer(VALUE self);\n#ifndef ZALLOC\n#define ZALLOC(type) ((type *)ruby_zalloc(sizeof(type)))\nstatic inline void *ruby_zalloc(size_t n)\n{\n    void *p = ruby_xmalloc(n);\n    memset(p, 0, n);\n    return p;\n}\n#endif\n#ifdef TypedData_Make_Struct\nstatic const rb_data_type_t JSON_Generator_State_type;\n#define NEW_TYPEDDATA_WRAPPER 1\n#else\n#define TypedData_Make_Struct(klass, type, ignore, json) Data_Make_Struct(klass, type, NULL, State_free, json)\n#define TypedData_Get_Struct(self, JSON_Generator_State, ignore, json) Data_Get_Struct(self, JSON_Generator_State, json)\n#endif\n\n#endif\n"], "filenames": ["ext/json/ext/generator/generator.c", "ext/json/ext/generator/generator.h"], "buggy_code_start_loc": [311, 4], "buggy_code_end_loc": [1212, 5], "fixing_code_start_loc": [311, 3], "fixing_code_end_loc": [1212, 3], "type": "CWE-119", "message": "Ruby through 2.2.7, 2.3.x through 2.3.4, and 2.4.x through 2.4.1 can expose arbitrary memory during a JSON.generate call. The issues lies in using strdup in ext/json/ext/generator/generator.c, which will stop after encountering a '\\0' byte, returning a pointer to a string of length zero, which is not the length stored in space_len.", "other": {"cve": {"id": "CVE-2017-14064", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-31T17:29:00.183", "lastModified": "2019-05-13T18:48:46.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ruby through 2.2.7, 2.3.x through 2.3.4, and 2.4.x through 2.4.1 can expose arbitrary memory during a JSON.generate call. The issues lies in using strdup in ext/json/ext/generator/generator.c, which will stop after encountering a '\\0' byte, returning a pointer to a string of length zero, which is not the length stored in space_len."}, {"lang": "es", "value": "Ruby hasta la versi\u00f3n 2.2.7, 2.3.x hasta la 2.3.4, y 2.4.x hasta la 2.4.1 puede exponer memoria arbitraria durante una llamada JSON.generate. Los problemas surgen al usar strdup en ext/json/ext/generator/generator.c, el cual se detendr\u00eda despu\u00e9s de encontrar un byte '\\0', devolviendo un puntero a un string de longitud cero, que no es la longitud almacenada en space_len."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.7", "matchCriteriaId": "20D4B423-C141-4B08-9FE4-2ADCB868A224"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "822307DD-7F7D-44C2-9C4B-CB8704663410"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.0:preview1:*:*:*:*:*:*", "matchCriteriaId": "A2D62AC9-83B8-4C84-A47E-2B06C2816964"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.0:preview2:*:*:*:*:*:*", "matchCriteriaId": "E583E49C-95B1-4AE4-AA7A-6D6BA7D470B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F197C5A-2588-417F-A743-E72D1E8EF4F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "FBA01BF1-91AD-4968-9AC2-A194FCD6AB76"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "B36CCD91-2A20-4C2E-96D5-73704DFC10E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "485C401C-CC3B-4A74-82D6-F4539FFE48B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "F9E99F5A-E693-43E9-8AB3-A3FCB21BCF14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.4.0:preview1:*:*:*:*:*:*", "matchCriteriaId": "9DDA92E9-C9CF-47B9-B647-0202D493D057"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.4.0:preview2:*:*:*:*:*:*", "matchCriteriaId": "A682A487-A615-404C-A7D9-A28C0C31B4E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.4.0:preview3:*:*:*:*:*:*", "matchCriteriaId": "8930BA64-E9BC-42E0-9D74-8FA2ABD1F692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.4.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "A87AE96A-F7FB-41A2-943C-DFAEA6D81446"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "946D2AB0-D334-4D94-BDA2-733BFC6C9E1E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100890", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039363", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1042004", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3485", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0378", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0583", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0585", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.ruby-lang.org/issues/13853", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/flori/json/commit/8f782fd8e181d9cfe9387ded43a5ca9692266b85", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/209949", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-18", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3685-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3966", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.ruby-lang.org/en/news/2017/09/14/ruby-2-2-8-released/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.ruby-lang.org/en/news/2017/09/14/ruby-2-3-5-released/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/flori/json/commit/8f782fd8e181d9cfe9387ded43a5ca9692266b85"}}