{"buggy_code": ["package httpauth\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/ntbosscher/gobase/auth\"\n\t\"github.com/ntbosscher/gobase/auth/httpauth/oauth\"\n\t\"github.com/ntbosscher/gobase/env\"\n\t\"github.com/ntbosscher/gobase/res\"\n\t\"github.com/ntbosscher/gobase/strs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar jwtKey []byte\nvar IsVerbose bool\n\nfunc init() {\n\tvar err error\n\tjwtKey, err = ioutil.ReadFile(\"./.jwtkey\")\n\tif err != nil {\n\t\tlog.Println(\"./.jwtkey should contain 2048 random bytes. Run `go run github.com/ntbosscher/gobase/auth/httpauth/jwtgen` to automatically generate one\")\n\t\tlog.Fatal(\"failed to read required file ./.jwtkey: \" + err.Error())\n\t}\n}\n\ntype ActiveUserValidator func(ctx context.Context, user *auth.UserInfo) error\n\ntype Config struct {\n\n\t// Optional oauth config\n\tOAuth *oauth.Config\n\n\t// Checks user credentials on login\n\tCredentialChecker CredentialChecker\n\n\t// ValidateActiveUser allows you to do extra db checks when\n\t// we do a access token refresh\n\t// e.g. check if the user has been archived.\n\t//\n\t// If ValidateActiveUser returns an error, we'll assume the user is no longer valid\n\t// and force them to re-login\n\t//\n\t// if not set, this check will be ignored\n\tValidateActiveUser ActiveUserValidator\n\n\t// POST route that will accept login requests\n\t// default: /api/auth/login\n\tLoginPath string\n\n\t// route that will accept logout requests\n\t// default: /api/auth/logout\n\tLogoutPath string\n\n\t// route/url to redirect logout requests to after they've been logged out\n\t// default: /\n\tLogoutRedirectTo string\n\n\t// POST route that will accept register requests\n\t// default: /api/auth/register\n\tRegisterPath string\n\n\t// Handler for registration requests. If a non-nil auth.UserInfo is returned\n\t// httpauth will setup the user session\n\t// if nil, register feature will be disabled\n\tRegisterHandler func(rq *res.Request) (*auth.UserInfo, res.Responder)\n\n\t// POST route that will accept jwt refresh requests\n\t// default: /api/auth/refresh\n\tRefreshPath string\n\n\t// default: 30 min\n\tAccessTokenLifeTime time.Duration\n\n\t// default: 30 days\n\tRefreshTokenLifeTime time.Duration\n\n\t// default: token\n\tAccessTokenCookieName string\n\n\t// default: refresh-token\n\tRefreshTokenCookieName string\n\n\t// route prefixes that don't require authentication\n\tPublicRoutePrefixes []string\n\n\t// exact match request paths that don't require authentication\n\tIgnoreRoutes []string\n\n\t// filters each request after authentication has been checked\n\t// default: nil\n\tPerRequestFilter PerRequestFilter\n}\n\ntype PerRequestFilter func(ctx context.Context, r *http.Request, user *auth.UserInfo) error\n\nfunc (c Config) getRefreshTokenCookieName() string {\n\treturn strs.Coalesce(c.RefreshTokenCookieName, \"refresh-token\")\n}\n\nfunc (c Config) getAccessTokenCookieName() string {\n\treturn strs.Coalesce(c.AccessTokenCookieName, \"token\")\n}\n\nfunc Setup(router *res.Router, config Config) *AuthRouter {\n\tloginPath := strs.Coalesce(config.LoginPath, defaultLoginEndpoint)\n\trouter.Post(loginPath, loginHandler(&config))\n\tlogoutPath := strs.Coalesce(config.LogoutPath, defaultLogoutEndpoint)\n\trouter.Post(logoutPath, logoutHandler(&config))\n\trouter.Get(logoutPath, logoutHandler(&config))\n\trefreshPath := strs.Coalesce(config.RefreshPath, defaultRefreshEndpoint)\n\trouter.Post(refreshPath, refreshHandler(&config))\n\n\tif config.RegisterHandler != nil {\n\t\trouter.Post(strs.Coalesce(config.RegisterPath, defaultRegisterEndpoint), registerHandler(&config))\n\t}\n\n\tconfig.IgnoreRoutes = append(config.IgnoreRoutes, loginPath, logoutPath, refreshPath)\n\n\tif config.OAuth != nil {\n\t\tconfig.IgnoreRoutes = append(config.IgnoreRoutes, config.OAuth.CallbackPath)\n\t}\n\n\tsessionSetter := func(rq *res.Request, user *auth.UserInfo) error {\n\t\t_, _, err := setupSession(rq, user, &config)\n\t\treturn err\n\t}\n\n\tif config.OAuth != nil {\n\t\toauth.Setup(router, config.OAuth, sessionSetter)\n\t}\n\n\tserver := middleware(config)\n\n\trouter.Use(func(h http.Handler) http.Handler {\n\t\tserver.next = h\n\t\treturn server\n\t})\n\n\treturn &AuthRouter{\n\t\tconfig: &config,\n\t\tauth:   server,\n\t\tnext:   router,\n\t}\n}\n\nfunc middleware(config Config) *server {\n\n\tif config.CredentialChecker == nil {\n\t\tlog.Fatal(\"github.com/ntbosscher/gobase/auth/authhttp.Middleware(config): config requires CredentialChecker\")\n\t}\n\n\treturn &server{\n\t\tperRequestFilter:         config.PerRequestFilter,\n\t\tignoreRoutesWithPrefixes: config.PublicRoutePrefixes,\n\t\tignoreRoutes:             config.IgnoreRoutes,\n\t\tauthHandler:              authHandler(&config),\n\t}\n}\n\ntype server struct {\n\tnext                     http.Handler\n\tperRequestFilter         PerRequestFilter\n\tignoreRoutesWithPrefixes []string\n\tignoreRoutes             []string\n\tauthHandler              func(request *res.Request) (res.Responder, context.Context)\n}\n\nconst defaultLoginEndpoint = \"/api/auth/login\"\nconst defaultRefreshEndpoint = \"/api/auth/refresh\"\nconst defaultLogoutEndpoint = \"/api/auth/logout\"\nconst defaultRegisterEndpoint = \"/api/auth/register\"\n\nfunc (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\n\tignoredRoute := false\n\n\tfor _, path := range s.ignoreRoutes {\n\t\tif r.URL.Path == path {\n\t\t\tignoredRoute = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !ignoredRoute {\n\t\tfor _, prefix := range s.ignoreRoutesWithPrefixes {\n\t\t\tif strings.HasPrefix(r.URL.Path, prefix) {\n\t\t\t\tignoredRoute = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\terr, ctx := s.authHandler(res.NewRequest(w, r))\n\tif err != nil {\n\n\t\t// attempt to authenticate, but ignore errors\n\t\tif ignoredRoute {\n\t\t\ts.next.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\terr.Respond(w, r)\n\t\treturn\n\t}\n\n\tr = r.WithContext(ctx)\n\n\tif !ignoredRoute && s.perRequestFilter != nil {\n\t\tif err := s.perRequestFilter(ctx, r, auth.Current(ctx)); err != nil {\n\t\t\tnotAuthenticated.Respond(w, r)\n\t\t\treturn\n\t\t}\n\t}\n\n\ts.next.ServeHTTP(w, r)\n}\n\nfunc logVerbose(err error) {\n\tif IsVerbose {\n\t\tlog.Println(err)\n\t}\n}\n\nvar notAuthenticated = res.NotAuthorized()\n\nfunc registerHandler(config *Config) func(rq *res.Request) res.Responder {\n\treturn func(rq *res.Request) res.Responder {\n\t\tinfo, response := config.RegisterHandler(rq)\n\t\tif info != nil {\n\t\t\t_, _, err := setupSession(rq, info, config)\n\t\t\tlogVerbose(err)\n\t\t}\n\n\t\treturn response\n\t}\n}\n\nfunc authHandler(config *Config) func(rq *res.Request) (res.Responder, context.Context) {\n\treturn func(rq *res.Request) (res.Responder, context.Context) {\n\t\ttokenString := cookieOrBearerToken(rq, config.getAccessTokenCookieName())\n\t\tif tokenString == \"\" {\n\t\t\treturn notAuthenticated, nil\n\t\t}\n\n\t\tuser, err := parseJwt(tokenString)\n\t\tif err != nil {\n\t\t\treturn res.NotAuthorized(err.Error()), nil\n\t\t}\n\n\t\tctx := auth.SetUser(rq.Context(), user)\n\t\treturn nil, ctx\n\t}\n}\n\nfunc parseJwt(tokenString string) (*auth.UserInfo, error) {\n\tuser := &auth.UserInfo{}\n\ttoken, err := jwt.ParseWithClaims(tokenString, user, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !token.Valid {\n\t\treturn nil, errors.New(\"invalid token\")\n\t}\n\n\treturn user, nil\n}\n\nfunc cookieOrBearerToken(rq *res.Request, name string) string {\n\tif value := rq.Cookie(name); value != \"\" {\n\t\treturn value\n\t}\n\n\tbearerToken := rq.Request().Header.Get(\"Authorization\")\n\treturn strings.TrimPrefix(bearerToken, \"Bearer \")\n}\n\nfunc refreshHandler(config *Config) res.HandlerFunc2 {\n\treturn func(rq *res.Request) res.Responder {\n\n\t\trefreshToken := cookieOrBearerToken(rq, config.getRefreshTokenCookieName())\n\t\tif refreshToken == \"\" {\n\t\t\treturn res.BadRequest(\"Invalid refresh token\")\n\t\t}\n\n\t\tclaims, err := parseJwt(refreshToken)\n\t\tif err != nil {\n\t\t\treturn res.AppError(\"Access denied: \" + err.Error())\n\t\t}\n\n\t\tif config.ValidateActiveUser != nil {\n\t\t\tif err := config.ValidateActiveUser(rq.Context(), claims); err != nil {\n\t\t\t\treturn res.Redirect(config.LogoutPath)\n\t\t\t}\n\t\t}\n\n\t\taccessToken, accessTokenExpiry, err := createAccessToken(claims, config.AccessTokenLifeTime)\n\t\tif err != nil {\n\t\t\treturn res.AppError(\"Failed to create access token: \" + err.Error())\n\t\t}\n\n\t\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\t\tSecure:  !env.IsTesting,\n\t\t\tName:    config.getAccessTokenCookieName(),\n\t\t\tValue:   accessToken,\n\t\t\tExpires: accessTokenExpiry,\n\t\t\tPath:    \"/\",\n\t\t})\n\n\t\treturn res.Ok(map[string]interface{}{\n\t\t\t\"accessToken\": accessToken,\n\t\t})\n\t}\n}\n\nfunc setupSession(rq *res.Request, user *auth.UserInfo, config *Config) (accessToken string, refreshToken string, err error) {\n\taccessToken, accessTokenExpiry, err := createAccessToken(user, config.AccessTokenLifeTime)\n\tif err != nil {\n\t\terr = errors.New(\"Failed to create access token: \" + err.Error())\n\t\treturn\n\t}\n\n\trefreshToken, refreshTokenExpiry, err := createRefreshToken(user, config.RefreshTokenLifeTime)\n\tif err != nil {\n\t\terr = errors.New(\"Failed to create refresh token: \" + err.Error())\n\t\treturn\n\t}\n\n\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\tSecure:  !env.IsTesting,\n\t\tName:    config.getAccessTokenCookieName(),\n\t\tValue:   accessToken,\n\t\tExpires: accessTokenExpiry,\n\t\tPath:    \"/\",\n\t})\n\n\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\tSecure:   !env.IsTesting,\n\t\tHttpOnly: true,\n\t\tName:     config.getRefreshTokenCookieName(),\n\t\tValue:    refreshToken,\n\t\tExpires:  refreshTokenExpiry,\n\t\tPath:     \"/\",\n\t})\n\n\treturn\n}\n\nfunc loginHandler(config *Config) res.HandlerFunc2 {\n\treturn func(rq *res.Request) res.Responder {\n\t\tcreds := &Credential{}\n\t\tif err := rq.ParseJSON(creds); err != nil {\n\t\t\treturn res.BadRequest(err.Error())\n\t\t}\n\n\t\tuser, err := config.CredentialChecker(rq.Context(), creds)\n\t\tif err != nil {\n\t\t\treturn res.AppError(err.Error())\n\t\t}\n\n\t\taccessToken, refreshToken, err := setupSession(rq, user, config)\n\t\tif err != nil {\n\t\t\treturn res.Error(err)\n\t\t}\n\n\t\treturn res.Ok(map[string]interface{}{\n\t\t\t\"accessToken\":  accessToken,\n\t\t\t\"refreshToken\": refreshToken,\n\t\t})\n\t}\n}\n\ntype Credential struct {\n\tUsername string\n\tPassword string\n}\n\ntype CredentialChecker = func(context.Context, *Credential) (*auth.UserInfo, error)\n\nfunc createRefreshToken(user *auth.UserInfo, lifetime time.Duration) (token string, expiry time.Time, err error) {\n\n\tif lifetime == 0 {\n\t\texpiry = time.Now().AddDate(0, 0, 30)\n\t} else {\n\t\texpiry = time.Now().Add(lifetime)\n\t}\n\n\tuser.StandardClaims.ExpiresAt = expiry.Unix()\n\n\ttokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, user)\n\ttoken, err = tokenObj.SignedString(jwtKey)\n\treturn\n}\n\ntype Claims struct {\n}\n\nfunc createAccessToken(user *auth.UserInfo, lifetime time.Duration) (token string, expiry time.Time, err error) {\n\n\tif lifetime == 0 {\n\t\texpiry = time.Now().Add(30 * time.Minute)\n\t} else {\n\t\texpiry = time.Now().Add(lifetime)\n\t}\n\n\tuser.StandardClaims.ExpiresAt = expiry.Unix()\n\n\ttokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, user)\n\ttoken, err = tokenObj.SignedString(jwtKey)\n\treturn\n}\n\nfunc logoutHandler(config *Config) res.HandlerFunc2 {\n\treturn func(rq *res.Request) res.Responder {\n\n\t\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\t\tSecure: !env.IsTesting,\n\t\t\tName:   config.getAccessTokenCookieName(),\n\t\t\tMaxAge: -1,\n\t\t\tPath:   \"/\",\n\t\t})\n\n\t\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\t\tSecure: !env.IsTesting,\n\t\t\tName:   config.getRefreshTokenCookieName(),\n\t\t\tMaxAge: -1,\n\t\t\tPath:   \"/\",\n\t\t})\n\n\t\tif config.LogoutRedirectTo == \"\" {\n\t\t\treturn res.Redirect(\"/\")\n\t\t}\n\n\t\treturn res.Redirect(config.LogoutRedirectTo)\n\t}\n}\n"], "fixing_code": ["package httpauth\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/ntbosscher/gobase/auth\"\n\t\"github.com/ntbosscher/gobase/auth/httpauth/oauth\"\n\t\"github.com/ntbosscher/gobase/env\"\n\t\"github.com/ntbosscher/gobase/res\"\n\t\"github.com/ntbosscher/gobase/strs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar jwtKey []byte\nvar IsVerbose bool\n\nfunc init() {\n\tvar err error\n\tjwtKey, err = ioutil.ReadFile(\"./.jwtkey\")\n\tif err != nil {\n\t\tlog.Println(\"./.jwtkey should contain 2048 random bytes. Run `go run github.com/ntbosscher/gobase/auth/httpauth/jwtgen` to automatically generate one\")\n\t\tlog.Fatal(\"failed to read required file ./.jwtkey: \" + err.Error())\n\t}\n}\n\ntype ActiveUserValidator func(ctx context.Context, user *auth.UserInfo) error\n\ntype Config struct {\n\n\t// Optional oauth config\n\tOAuth *oauth.Config\n\n\t// Checks user credentials on login\n\tCredentialChecker CredentialChecker\n\n\t// ValidateActiveUser allows you to do extra db checks when\n\t// we do a access token refresh\n\t// e.g. check if the user has been archived.\n\t//\n\t// If ValidateActiveUser returns an error, we'll assume the user is no longer valid\n\t// and force them to re-login\n\t//\n\t// if not set, this check will be ignored\n\tValidateActiveUser ActiveUserValidator\n\n\t// POST route that will accept login requests\n\t// default: /api/auth/login\n\tLoginPath string\n\n\t// route that will accept logout requests\n\t// default: /api/auth/logout\n\tLogoutPath string\n\n\t// route/url to redirect logout requests to after they've been logged out\n\t// default: /\n\tLogoutRedirectTo string\n\n\t// POST route that will accept register requests\n\t// default: /api/auth/register\n\tRegisterPath string\n\n\t// Handler for registration requests. If a non-nil auth.UserInfo is returned\n\t// httpauth will setup the user session\n\t// if nil, register feature will be disabled\n\tRegisterHandler func(rq *res.Request) (*auth.UserInfo, res.Responder)\n\n\t// POST route that will accept jwt refresh requests\n\t// default: /api/auth/refresh\n\tRefreshPath string\n\n\t// default: 30 min\n\tAccessTokenLifeTime time.Duration\n\n\t// default: 30 days\n\tRefreshTokenLifeTime time.Duration\n\n\t// default: token\n\tAccessTokenCookieName string\n\n\t// default: refresh-token\n\tRefreshTokenCookieName string\n\n\t// route prefixes that don't require authentication\n\tPublicRoutePrefixes []string\n\n\t// exact match request paths that don't require authentication\n\tIgnoreRoutes []string\n\n\t// filters each request after authentication has been checked\n\t// default: nil\n\tPerRequestFilter PerRequestFilter\n}\n\ntype PerRequestFilter func(ctx context.Context, r *http.Request, user *auth.UserInfo) error\n\nfunc (c Config) getRefreshTokenCookieName() string {\n\treturn strs.Coalesce(c.RefreshTokenCookieName, \"refresh-token\")\n}\n\nfunc (c Config) getAccessTokenCookieName() string {\n\treturn strs.Coalesce(c.AccessTokenCookieName, \"token\")\n}\n\nconst defaultLoginEndpoint = \"/api/auth/login\"\nconst defaultRefreshEndpoint = \"/api/auth/refresh\"\nconst defaultLogoutEndpoint = \"/api/auth/logout\"\nconst defaultRegisterEndpoint = \"/api/auth/register\"\n\nfunc Setup(router *res.Router, config Config) *AuthRouter {\n\tloginPath := strs.Coalesce(config.LoginPath, defaultLoginEndpoint)\n\trouter.Post(loginPath, loginHandler(&config))\n\tlogoutPath := strs.Coalesce(config.LogoutPath, defaultLogoutEndpoint)\n\trouter.Post(logoutPath, logoutHandler(&config))\n\trouter.Get(logoutPath, logoutHandler(&config))\n\trefreshPath := strs.Coalesce(config.RefreshPath, defaultRefreshEndpoint)\n\trouter.Post(refreshPath, refreshHandler(&config))\n\n\tif config.RegisterHandler != nil {\n\t\trouter.Post(strs.Coalesce(config.RegisterPath, defaultRegisterEndpoint), registerHandler(&config))\n\t}\n\n\tconfig.IgnoreRoutes = append(config.IgnoreRoutes, loginPath, logoutPath, refreshPath)\n\n\tif config.OAuth != nil {\n\t\tconfig.IgnoreRoutes = append(config.IgnoreRoutes, config.OAuth.CallbackPath)\n\t}\n\n\tsessionSetter := func(rq *res.Request, user *auth.UserInfo) error {\n\t\t_, _, err := setupSession(rq, user, &config)\n\t\treturn err\n\t}\n\n\tif config.OAuth != nil {\n\t\toauth.Setup(router, config.OAuth, sessionSetter)\n\t}\n\n\tserver := newServer(config)\n\n\trouter.Use(func(handler http.Handler) http.Handler {\n\t\treturn cloneServer(server, handler)\n\t})\n\n\treturn &AuthRouter{\n\t\tconfig: &config,\n\t\tauth:   server,\n\t\tnext:   router,\n\t}\n}\n\nfunc cloneServer(src *server, next http.Handler) *server {\n\tclone := &server{}\n\t*clone = *src\n\tclone.next = next\n\treturn clone\n}\n\nfunc newServer(config Config) *server {\n\n\tif config.CredentialChecker == nil {\n\t\tlog.Fatal(\"github.com/ntbosscher/gobase/auth/authhttp.Middleware(config): config requires CredentialChecker\")\n\t}\n\n\treturn &server{\n\t\tperRequestFilter:         config.PerRequestFilter,\n\t\tignoreRoutesWithPrefixes: config.PublicRoutePrefixes,\n\t\tignoreRoutes:             config.IgnoreRoutes,\n\t\tauthHandler:              authHandler(&config),\n\t}\n}\n\ntype server struct {\n\tnext http.Handler\n\tperRequestFilter         PerRequestFilter\n\tignoreRoutesWithPrefixes []string\n\tignoreRoutes             []string\n\tauthHandler              func(request *res.Request) (res.Responder, context.Context)\n}\n\nfunc (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\n\tignoredRoute := false\n\n\tfor _, path := range s.ignoreRoutes {\n\t\tif r.URL.Path == path {\n\t\t\tignoredRoute = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !ignoredRoute {\n\t\tfor _, prefix := range s.ignoreRoutesWithPrefixes {\n\t\t\tif strings.HasPrefix(r.URL.Path, prefix) {\n\t\t\t\tignoredRoute = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\terr, ctx := s.authHandler(res.NewRequest(w, r))\n\tif err != nil {\n\n\t\t// attempt to authenticate, but ignore errors\n\t\tif ignoredRoute {\n\t\t\ts.next.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\terr.Respond(w, r)\n\t\treturn\n\t}\n\n\tr = r.WithContext(ctx)\n\n\tif !ignoredRoute && s.perRequestFilter != nil {\n\t\tif err := s.perRequestFilter(ctx, r, auth.Current(ctx)); err != nil {\n\t\t\tnotAuthenticated.Respond(w, r)\n\t\t\treturn\n\t\t}\n\t}\n\n\ts.next.ServeHTTP(w, r)\n}\n\nfunc logVerbose(err error) {\n\tif IsVerbose {\n\t\tlog.Println(err)\n\t}\n}\n\nvar notAuthenticated = res.NotAuthorized()\n\nfunc registerHandler(config *Config) func(rq *res.Request) res.Responder {\n\treturn func(rq *res.Request) res.Responder {\n\t\tinfo, response := config.RegisterHandler(rq)\n\t\tif info != nil {\n\t\t\t_, _, err := setupSession(rq, info, config)\n\t\t\tlogVerbose(err)\n\t\t}\n\n\t\treturn response\n\t}\n}\n\nfunc authHandler(config *Config) func(rq *res.Request) (res.Responder, context.Context) {\n\treturn func(rq *res.Request) (res.Responder, context.Context) {\n\t\ttokenString := cookieOrBearerToken(rq, config.getAccessTokenCookieName())\n\t\tif tokenString == \"\" {\n\t\t\treturn notAuthenticated, nil\n\t\t}\n\n\t\tuser, err := parseJwt(tokenString)\n\t\tif err != nil {\n\t\t\treturn res.NotAuthorized(err.Error()), nil\n\t\t}\n\n\t\tctx := auth.SetUser(rq.Context(), user)\n\t\treturn nil, ctx\n\t}\n}\n\nfunc parseJwt(tokenString string) (*auth.UserInfo, error) {\n\tuser := &auth.UserInfo{}\n\ttoken, err := jwt.ParseWithClaims(tokenString, user, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !token.Valid {\n\t\treturn nil, errors.New(\"invalid token\")\n\t}\n\n\treturn user, nil\n}\n\nfunc cookieOrBearerToken(rq *res.Request, name string) string {\n\tif value := rq.Cookie(name); value != \"\" {\n\t\treturn value\n\t}\n\n\tbearerToken := rq.Request().Header.Get(\"Authorization\")\n\treturn strings.TrimPrefix(bearerToken, \"Bearer \")\n}\n\nfunc refreshHandler(config *Config) res.HandlerFunc2 {\n\treturn func(rq *res.Request) res.Responder {\n\n\t\trefreshToken := cookieOrBearerToken(rq, config.getRefreshTokenCookieName())\n\t\tif refreshToken == \"\" {\n\t\t\treturn res.BadRequest(\"Invalid refresh token\")\n\t\t}\n\n\t\tclaims, err := parseJwt(refreshToken)\n\t\tif err != nil {\n\t\t\treturn res.AppError(\"Access denied: \" + err.Error())\n\t\t}\n\n\t\tif config.ValidateActiveUser != nil {\n\t\t\tif err := config.ValidateActiveUser(rq.Context(), claims); err != nil {\n\t\t\t\treturn res.Redirect(config.LogoutPath)\n\t\t\t}\n\t\t}\n\n\t\taccessToken, accessTokenExpiry, err := createAccessToken(claims, config.AccessTokenLifeTime)\n\t\tif err != nil {\n\t\t\treturn res.AppError(\"Failed to create access token: \" + err.Error())\n\t\t}\n\n\t\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\t\tSecure:  !env.IsTesting,\n\t\t\tName:    config.getAccessTokenCookieName(),\n\t\t\tValue:   accessToken,\n\t\t\tExpires: accessTokenExpiry,\n\t\t\tPath:    \"/\",\n\t\t})\n\n\t\treturn res.Ok(map[string]interface{}{\n\t\t\t\"accessToken\": accessToken,\n\t\t})\n\t}\n}\n\nfunc setupSession(rq *res.Request, user *auth.UserInfo, config *Config) (accessToken string, refreshToken string, err error) {\n\taccessToken, accessTokenExpiry, err := createAccessToken(user, config.AccessTokenLifeTime)\n\tif err != nil {\n\t\terr = errors.New(\"Failed to create access token: \" + err.Error())\n\t\treturn\n\t}\n\n\trefreshToken, refreshTokenExpiry, err := createRefreshToken(user, config.RefreshTokenLifeTime)\n\tif err != nil {\n\t\terr = errors.New(\"Failed to create refresh token: \" + err.Error())\n\t\treturn\n\t}\n\n\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\tSecure:  !env.IsTesting,\n\t\tName:    config.getAccessTokenCookieName(),\n\t\tValue:   accessToken,\n\t\tExpires: accessTokenExpiry,\n\t\tPath:    \"/\",\n\t})\n\n\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\tSecure:   !env.IsTesting,\n\t\tHttpOnly: true,\n\t\tName:     config.getRefreshTokenCookieName(),\n\t\tValue:    refreshToken,\n\t\tExpires:  refreshTokenExpiry,\n\t\tPath:     \"/\",\n\t})\n\n\treturn\n}\n\nfunc loginHandler(config *Config) res.HandlerFunc2 {\n\treturn func(rq *res.Request) res.Responder {\n\t\tcreds := &Credential{}\n\t\tif err := rq.ParseJSON(creds); err != nil {\n\t\t\treturn res.BadRequest(err.Error())\n\t\t}\n\n\t\tuser, err := config.CredentialChecker(rq.Context(), creds)\n\t\tif err != nil {\n\t\t\treturn res.AppError(err.Error())\n\t\t}\n\n\t\taccessToken, refreshToken, err := setupSession(rq, user, config)\n\t\tif err != nil {\n\t\t\treturn res.Error(err)\n\t\t}\n\n\t\treturn res.Ok(map[string]interface{}{\n\t\t\t\"accessToken\":  accessToken,\n\t\t\t\"refreshToken\": refreshToken,\n\t\t})\n\t}\n}\n\ntype Credential struct {\n\tUsername string\n\tPassword string\n}\n\ntype CredentialChecker = func(context.Context, *Credential) (*auth.UserInfo, error)\n\nfunc createRefreshToken(user *auth.UserInfo, lifetime time.Duration) (token string, expiry time.Time, err error) {\n\n\tif lifetime == 0 {\n\t\texpiry = time.Now().AddDate(0, 0, 30)\n\t} else {\n\t\texpiry = time.Now().Add(lifetime)\n\t}\n\n\tuser.StandardClaims.ExpiresAt = expiry.Unix()\n\n\ttokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, user)\n\ttoken, err = tokenObj.SignedString(jwtKey)\n\treturn\n}\n\ntype Claims struct {\n}\n\nfunc createAccessToken(user *auth.UserInfo, lifetime time.Duration) (token string, expiry time.Time, err error) {\n\n\tif lifetime == 0 {\n\t\texpiry = time.Now().Add(30 * time.Minute)\n\t} else {\n\t\texpiry = time.Now().Add(lifetime)\n\t}\n\n\tuser.StandardClaims.ExpiresAt = expiry.Unix()\n\n\ttokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, user)\n\ttoken, err = tokenObj.SignedString(jwtKey)\n\treturn\n}\n\nfunc logoutHandler(config *Config) res.HandlerFunc2 {\n\treturn func(rq *res.Request) res.Responder {\n\n\t\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\t\tSecure: !env.IsTesting,\n\t\t\tName:   config.getAccessTokenCookieName(),\n\t\t\tMaxAge: -1,\n\t\t\tPath:   \"/\",\n\t\t})\n\n\t\thttp.SetCookie(rq.Writer(), &http.Cookie{\n\t\t\tSecure: !env.IsTesting,\n\t\t\tName:   config.getRefreshTokenCookieName(),\n\t\t\tMaxAge: -1,\n\t\t\tPath:   \"/\",\n\t\t})\n\n\t\tif config.LogoutRedirectTo == \"\" {\n\t\t\treturn res.Redirect(\"/\")\n\t\t}\n\n\t\treturn res.Redirect(config.LogoutRedirectTo)\n\t}\n}\n"], "filenames": ["auth/httpauth/main.go"], "buggy_code_start_loc": [108], "buggy_code_end_loc": [177], "fixing_code_start_loc": [109], "fixing_code_end_loc": [182], "type": "CWE-362", "message": "A race condition can cause incorrect HTTP request routing.", "other": {"cve": {"id": "CVE-2022-2583", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:12.500", "lastModified": "2023-01-05T04:43:54.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A race condition can cause incorrect HTTP request routing."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gobase_project:gobase:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.7.2", "matchCriteriaId": "0C9F80FD-B06D-43EF-BAB1-897057D4E716"}]}]}], "references": [{"url": "https://github.com/ntbosscher/gobase/commit/a8d40bce9c429d324122d18c446924dab809e812", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2022-0400", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntbosscher/gobase/commit/a8d40bce9c429d324122d18c446924dab809e812"}}