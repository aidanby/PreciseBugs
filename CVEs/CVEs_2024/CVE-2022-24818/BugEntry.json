{"buggy_code": ["``GeoTools``\n------------\n\nThe first utility class we have is helpfully called ``GeoTools``. This class is used to configure the library for your application.\n\nIt also provides the version number of the library, in case you want to check at runtime.::\n  \n  GeoTools.getVersion(); // Example 15.0\n\n``Hints``\n^^^^^^^^^\n\n``Hints`` are used to configure the GeoTools library for use in your application. The value provided by ``GeoTools.getDefaultHints()`` can be configured as part of your application startup:\n\n.. code-block:: java\n\n   Hints.putSystemDefault(Hints.ENTITY_RESOLVER, NullEntityResolver.INSTANCE);\n   Hints.removeSystemDefault(Hints.ENTITY_RESOLVER);\n\nGeoTools ``Hints`` are similar to a ``Map<GeoTools.Key,Object>``, the ``GeoTools.Key`` instances each provide javadocs, and some control over the values that may be used. For example the ``Hints.ENTITY_RESOLVER`` values must be an instance of ``EntityResolver``.\n\nBy contrast Java system properties are similar to a ``Map<String,String>`` and may be specified programmatically or on the command line. The following bindings to system properties are defined (each as static constants in the ``GeoTools`` class):\n\n===================================== ===============================================\n``CRS_AUTHORITY_EXTRA_DIRECTORY``     ``org.geotools.referencing.crs-directory``\n``EPSG_DATA_SOURCE``                  ``org.geotools.referencing.epsg-datasource``\n``FORCE_LONGITUDE_FIRST_AXIS_ORDER``  ``org.geotools.referencing.forceXY``\n``LOCAL_DATE_TIME_HANDLING``          ``org.geotools.localDateTimeHandling``\n``RESAMPLE_TOLERANCE``                ``org.geotools.referencing.resampleTolerance``\n``ENTITY_RESOLVER``                   ``org.xml.sax.EntityResolver``\n===================================== ===============================================\n\n\nThe bound system properties can also be used to configure Hints:\n\n.. code-block:: java\n   \n   // Allow access to local dtd and xsd files\n   System.getProperties.put(GeoTools.ENTITY_RESOLVER, \"org.geotools.util.NullEntityResolver\");\n   Hints.scanSystemProperties();\n\nPlug-ins\n^^^^^^^^\n\nIncreasingly GeoTools is being used in carefully managed plug-in systems such as Eclipse or Spring. In order to allow GeoTools to locate its own plug-ins you may need to configure the ``GeoTools`` class with additional class loaders provided by your environment.::\n  \n  GeoTools.addClassloader( loader );\n\nOut of the box GeoTools searches on the ``CLASSPATH`` available, in order to find plug-in and wire them into the library. It does this by looking in the jar's ``META-INF/services`` folder which lists plug-in classes.\n\nIn rare cases, such as OSGi plug-in system, adding additional jars to the ``CLASSPATH`` is not enough. OSGi blocks access to the ``META-INF/services`` folder. In these cases you will need to provide access to the classes yourself.::\n  \n  GeoTools.addFactoryIteratorProvider( provider );\n\nJNDI\n^^^^\n\nIf you are working in a Java Enterprise Edition environment, and would like to configure GeoTools to look up services in a specific context use the following::\n  \n  GeoTools.init( applicationContext ); // JNDI configuration\n\nGeoTools uses names of the format ``jdbc:EPSG`` internally these are adapted for use with your ``applicationContext`` using the ``GeoTools.fixName`` method::\n\n  String name = GeoTools.fixName(\"jdbc.EPSG\");\n\nXML\n^^^\n\nWhen embedding GeoTools in your own application you may wish to configure the library to use a specific ``EntityResolver`` (to access any XML Schema files included in your application, or to restrict access based on security policies).\n\nGeoTools uses a range of XML technologies when implementing both format and protocol support - where possible these are configured based on the ``Hints.ENTITY_RESOLVER`` described above.\n\nTo access the configured ``ENTITY_RESOLVER``:\n\n.. code-block:: java\n   \n   parser.setEntityResolver( GeoTools.getEntityResolver(hints) );\n\nGeoTools also includes two ``EntityResolver`` implementations:\n\n* ``PreventLocalEntityResolver``: For use when working with external XML documents, only allows DTD and XML Schema references to remote resources\n* ``NullEntityResolver``: Placeholder allowing the default ``SAXParser`` access-anything behavior.\n\nThe library uses ``PreventLocalEntityResolver`` by default, if you wish to work with a local XML file (referencing local DTD and XMLSchema) please use the following during application setup:\n\n.. code-block:: java\n\n   Hints.putSystemDefault(Hints.ENTITY_RESOLVER, NullEntityResolver.INSTANCE);\n\nLogging\n^^^^^^^\n\nIf you are working in your own application, you can teach GeoTools to use your application logging facilities (rather than Java logging which it uses by internal default).::\n  \n  GeoTools.setLoggerFactory( loggerFactory );\n\nGeoTools provides out of the box implementations for:\n\n* ``CommonsLoggerFactory`` - Apache's Common Logging framework\n* ``Log4jLoggerFactory`` - Log4J\n\nHere are a couple of examples of setting things up:\n\n* Do nothing\n  \n  Out of the box GeoTools will use Java logging\n\n* Setup for the Paranoid\n  \n  The example below tries to setup Commons-Logging first, and\n  fallback on Log4J if the former is not present on the\n  CLASSPATH.::\n    \n    try {\n        GeoTools.setLoggerFactory(\"org.geotools.util.logging.CommonsLoggerFactory\");\n    } catch (ClassNotFoundException commonsException) {\n        try {\n                GeoTools.setLoggerFactory(\"org.geotools.util.logging.Log4JLoggerFactory\");\n        } catch (ClassNotFoundException log4jException) {\n            // Nothing to do, we already tried our best.\n        }\n    }\n\n  In the above code ``ClassNotFoundException`` is a checked\n  exception thrown if Commons-Logging or Log4J is not available\n  on the CLASSPATH, so GeoTools continue to rely on the Java\n  logging system instead.\n\n* Log4J\n  \n  The following is a good approach only if the Log4J framework\n  is certain to be present on the CLASSPATH.::\n    \n    GeoTools.setLoggerFactory(Log4JLoggerFactory.getInstance());\n \n  Be warned that if Log4J is not available this method call has\n  unpredictable behavior.\n  \n  It will typically throws a ``NoClassDefFoundError`` (the unchecked\n  error, not the checked exception) at some future point. The\n  error may not be thrown at the moment ``setLoggerFactory`` is\n  invoked, but rather be delayed until a message is first logged,\n  which may surprise the user.\n\n* Custom\n  \n  You can create your own ``LoggerFactory`` if you need to track\n  messages using your own facilities.\n  \n  This is a good approach if you are making use of Eclipse\n  and would like to check bundle \"trace\" settings.\n  \nJAI\n^^^\n\nGeoTools Logging will listen to ``JAI`` errors and log them appropriately. It does this by first checking if your application has registered an ``ImagingListener``, and if not it will register a ``LoggingImagingListener`` to redirect JAI warnings. Common ``JAI`` errors (such as \"Continuing in pure Java mode\") are logged as ``Level.TRACE`` messages, all other errors are logged as ``Level.INFO``.\n\nIf you would like to check this bootstrapping process use the system property `-DLOGGING_TRACE=true`.\n\nTo completely filter JAI messages from your application set `javax.media.jai` group to ``Level.WARNING``::\n   \n   Logging.getLogger(\"javax.media.jai\").setLevel(Level.WARNING);\n\n", "Upgrade\n=======\n\nWith a library as old as GeoTools you will occasionally run into a project from ten years ago that\nneeds to be upgraded. This page collects the upgrade notes for each release change; highlighting any\nfundamental changes with code examples showing how to upgrade your code.\n\nBut first to upgrade - change your dependency geotools.version to |release| (or an appropriate stable version):\n\n.. code-block:: xml\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <geotools.version>|release|</geotools.version>\n    </properties>\n    ....\n    <dependencies>\n        <dependency>\n            <groupId>org.geotools</groupId>\n            <artifactId>gt-shapefile</artifactId>\n            <version>${geotools.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.geotools</groupId>\n            <artifactId>gt-swing</artifactId>\n            <version>${geotools.version}</version>\n        </dependency>\n        ....\n    </dependencies>\n\nGeoTools 26.x\n-------------\n\nShapefile\n^^^^^^^^^\n\n``ShapefileDataStore`` will autodetect DBF charset from CPG sidecar file, the feature now enabled by default. When this feature is enabled, the following rules apply:\n\n* if no explicit charset parameter passed to ``ShapefileDataStoreFactory``, it will instruct created ``ShapefileDataStore``\n  to try and figure out DBF file charset from CPG file. In this case, CPG files must contain correct charset name, otherwise, \n  these files should be removed, or updated properly. \n* if the store fails to read CPG, it uses the default charset specified by ``ShapefileDataStoreFactory.DBFCHARSET`` constant, \n  which is usual behavior.\n\nIn case of trouble there is an ability to bring old behavior back by setting ``org.geotools.shapefile.enableCPG`` system property\nto \"false\". This turns autodetection off. The name of the property stored in ``ShapefileDataStoreFactory.ENABLE_CPG_SWITCH`` constant.\n\nUnit of Measurement Formatting\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs more third-party libraries adopt the Java module system, stricter rules regarding access to\nnon-public parts of other modules apply.\n\nOne such case was the way GeoTools' unit formatters were previously initialized, which caused\nGeoTools to fail immediately when run from the module path.\n\nFixing this required changes to multiple classes:\n\n* ``GeoToolsUnitFormat`` which was previously used to access innards of a third-party library and\n  provide access to GeoTools-specific unit formatting instance has been split up and moved:\n  * Building and initializing individual unit formatting instances can now be done using the\n  ``org.geotools.measure.BaseUnitFormatter`` constructor (instead of extending\n  ``org.geotools.util.GeoToolsUnitFormat`` and its inner class ``BaseGT2Format``).\n  * The GeoTools-specific formatting instance can now be accessed with\n  ``org.geotools.measure.UnitFormat.getInstance()`` (instead of\n  ``org.geotools.util.GeoToolsUnitFormat.getInstance()``).\n* ``org.geotools.referencing.wkt.DefaultUnitParser`` has been moved and renamed to\n  ``org.geotools.measure.WktUnitFormat``.\n\nGeoTools 25.x\n-------------\n\nMore variable arguments support in core classes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSeveral code classes have been switched to use ``varargs`` instead of explicit arrays. \nWhile the old clients are compatible with these changes, there's now an opportunity\nto simplify code.\n\nBEFORE\n\n.. code-block:: java\n\n   // style creation\n   FeatureTypeStyle fts = styleFactory.createFeatureTypeStyle(new Rule[] {rule});\n   // query handling\n   Query q = new Query(tname(\"ft1\"));\n   q.setSortBy(new SortBy[] {new SortByImpl(\"prop\", ASCENDING)});\n   q.setPropertyNames(new String[] {\"geom\"});\n   // feature building\n   SimpleFeatureBuilder fb = new SimpleFeatureBuilder(targetType);\n   SimpleFeature = fb.buildFeature(\"f1\", new Object[] {null, 1}));\n   // test collection creation\n   SimpleFeatureCollection collection = DataUtilities.collection(new SimpleFeature[] {feature1, feature2});\n\n\nAFTER\n\n.. code-block:: java\n\n   // style creation\n   FeatureTypeStyle fts = styleFactory.createFeatureTypeStyle(rule);\n   // query handling\n   Query q = new Query(tname(\"ft1\"));\n   q.setSortBy(new SortByImpl(\"prop\", ASCENDING));\n   q.setPropertyNames(\"geom\");\n   // feature building\n   SimpleFeatureBuilder fb = new SimpleFeatureBuilder(targetType);\n   SimpleFeature = fb.buildFeature(\"f1\", null, 1));\n   // test collection creation\n   SimpleFeatureCollection collection = DataUtilities.collection(feature1, feature2);\n\nDataStore creation parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe DataAccess and DataStore creation parameters have been switched from ``Map<String, Serializable>``\nto ``Map<String, ?>``, to match actual usage (some stores require non serializable parameters).\nThis should not affect end users of the API, but ``DataAccessFactory`` and ``DataStoreFactory``\nimplementations will have to be updated to match.\n\nFor those feeding ``Properties`` object to ``DataAccess.getDataStore()`` a new utility method,\n``DataUtilities.toConnectionParameters`` has been made available, which converts a ``Properties``\nto a ``Map<String, ?>``.\n\n.. code-block:: java\n\n   Map<String,?> connectionParameters = DataUtilities.toConnectionParameters(properties);\n   DataStore dataStore = DataStoreFinder.getDataStore(connectionParameters);\n\nHTTPClient moved to its own module\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA new module ``gt-http`` has been established for the HTTPClient API.\n\nThe original interfaces ``HTTPClient`` and ``HTTPResponse`` and their implementations:\n(``SimpleHttpClient``, ``DelegateHTTPClient``, ``LoggingHTTPClient`` and DelegateHTTPResponse) have moved from \n``org.geotools.data.ows`` to the ``org.geotools.http`` package.\n\n\nPlaceholders for the previous implementations remain in place, with a deprecation reminding you to switch to\nthe new import as out outlined in the table below.\n\n===============================================  =========================  ===============================================================\nDeprecated class                                 Module                       Replacement (other module)\n===============================================  =========================  ===============================================================\norg.geotools.data.ows.AbstractHttpClient         gt-main                     org.geotools.http.AbstractHttpClient\norg.geotools.data.ows.MockHttpClient             gt-main                     org.geotools.http.MockHttpClient\norg.geotools.data.ows.MockHttpResponse           gt-main                     org.geotools.http.MockHttpResponse\norg.geotools.data.ows.DelegateHTTPClient         gt-main                     org.geotools.http.DelegateHTTPClient\norg.geotools.data.ows.DelegateHTTPResponse       gt-main                     org.geotools.http.DelegateHTTPResponse\norg.geotools.data.ows.HTTPClient                 gt-main                     org.geotools.http.HTTPClient\norg.geotools.data.ows.HTTPResponse               gt-main                     org.geotools.http.HTTPResponse\norg.geotools.data.ows.LoggingHTTPClient          gt-main                     org.geotools.http.LoggingHTTPClient\norg.geotools.data.ows.SimpleHttpClient           gt-main                     org.geotools.http.SimpleHttpClient\norg.geotools.ows.wms.MultithreadedHttpClient     gt-wms                      org.geotools.http.MultithreadedHttpClient (gt-http-commons)\norg.geotools.ows.MockHttpClient                  gt-wms                      org.geotools.http.MockHttpClient\norg.geotools.ows.MockHttpResponse                gt-wms                      org.geotools.http.MockHttpResponse\norg.geotools.ows.wmts.MockHttpClient             gt-wmts                     org.geotools.http.AbstractHttpClient\norg.geotools.data.mongodb.MockHTTPClient         gt-mongodb                  org.geotools.http.MockHttpClient\norg.geotools.data.mongodb.MockHttpResponse       gt-mongodb                  org.geotools.http.MockHttpResponse\norg.geotools.ows.wfs.MultithreadedHttpClient     gt-wfs-ng                   org.geotools.http.MultithreadedHttpClient (gt-http-commons)\norg.geotools.ows.wfs.AbstractTestHTTPClient      gt-wfs-ng                   org.geotools.http.AbstractHttpClient\norg.geotools.data.Base64                         gt-main                     org.geotools.util.Base64 (gt-metadata)\n===============================================  =========================  ===============================================================\n\nThis will result in a compile error in cases where GeoTools returns `org.geotools.http.HTTPClient`.\n\nBEFORE (compile error):\n\n.. code-block:: java\n   \n   import org.geotools.ows.HTTPClient;\n   \n   WebMapServer wms = new WebMapServer(\"http://atlas.gc.ca/cgi-bin/atlaswms_en?VERSION=1.1.1&Request=GetCapabilities&Service=WMS\");\n   HTTPClient client = wms.getHTTPClient();\n\nAFTER change imports (recommended):\n\n.. code-block:: java\n\n   import org.geotools.http.HTTPClient;\n   \n   WebMapServer wms = new WebMapServer(\"http://atlas.gc.ca/cgi-bin/atlaswms_en?VERSION=1.1.1&Request=GetCapabilities&Service=WMS\");\n   HTTPClient client = (HTTPClient) wms.getHTTPClient();\n\nALTERNATIVE add cast (continue to use deprecated api):\n\n.. code-block:: java\n\n   import org.geotools.data.ows.HTTPClient;\n   \n   WebMapServer wms = new WebMapServer(\"http://atlas.gc.ca/cgi-bin/atlaswms_en?VERSION=1.1.1&Request=GetCapabilities&Service=WMS\");\n   HTTPClient client = (HTTPClient) wms.getHTTPClient();\n\n\nHTTPClientFinder\n^^^^^^^^^^^^^^^^^\n\nTo allow the library to be configured with different ``HTTPClient`` implementations ``HTTPClientFinder`` is recommend:\n\nBEFORE:\n\n.. code-block:: java\n   \n   import org.geotools.data.ows.HTTPClient;\n   import org.geotools.data.ows.HTTPResponse;\n   import org.geotools.ows.SimpleHttpClient;\n   \n   \n   HTTPClient http = new SimpleHttpClient();\n   HTTPResponse response = http.get();   \n\nAFTER:\n\n.. code-block:: xml\n\n   <dependency>\n      <groupId>org.geotools</groupId>\n      <artifactId>gt-http</artifactId>\n      <version>${gt.version}</version>\n   </dependency>\n\n.. code-block:: java\n\n   import org.geotools.http.HTTPClient;\n   import org.geotools.http.HTTPResponse;\n   import org.geotools.http.HTTPClientFinder;\n      \n   HTTPClient http = HTTPClientFinder.createClient();\n   HTTPResponse response = http.get();\n   \nIn addition a new plugin ``gt-http-commons`` has been added for MultithreadedHttpClient.\n\n.. code-block:: xml\n\n     <dependency>\n        <groupId>org.geotools</groupId>\n        <artifactId>gt-http-commons</artifactId>\n        <version>${gt.version}</version>\n     </dependency>\n\n.. code-block:: java\n\n   import org.geotools.http.HTTPClient;\n   import org.geotools.http.HTTPResponse;\n   import org.geotools.http.HTTPClientFinder;\n   import org.geotools.http.commons.MultihreadedHttpClient;\n      \n   Hints hints = new Hints(Hints.HTTP_CLIENT, MultihreadedHttpClient.class);\n   HTTPClient http = HTTPClientFinder.createClient(hints);\n   HTTPResponse response = http.get();\n\nWMTS - WebMapTileServer initialisation\n--------------------------------------\n\nWe have introduced a new contructor for the WebMapTileServer.\nThe reason is that any HTTP headers must be specified prior to initialisation.\n\nThis might introduce a problem where a constuctor taking three arguments are used.\n\nSee list of available constructors:\n\n.. code-block:: java\n\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient)\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient, Map<String, String> headers) // <- NEW CONSTRUCTOR\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient, WMTSCapabilities capabilities)\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient, WMTSCapabilities capabilities, Map<String, Object> hints)\n\nFor the same reason we will not allow changes to the headers after initialisation,\nand have deprecated ``public Map<String, String> getHeaders()``.\n\n\nGeoTools 24.x\n-------------\n\nThe Oracle extension was upgraded to use the current JDBC driver release. If you are using ``oracle.jdbc.driver.OracleDriver`` in your code to load the JDBC driver you should change this to ``oracle.jdbc.OracleDriver``.\n\n``DbaseFileHeader.readHeader(ReadableByteChannel, Charset)`` method was removed. Instead ``DbaseFileHeader`` constructor must be used to pass a charset and ``DbaseFileHeader.readHeader(ReadableByteChannel)`` to read the header.\n\nThe Units library (JSR 385) was updated to Units 2.0. This is mostly a change from package ``tec.uom.se.*`` to ``tech.units.indriya.*``. If you make any use of the Units library in your own code you will need to update the imports. There are also changes to the arithmetic operations' names. See this `blog post <https://schneide.blog/tag/unit-api-2-0/>`_ for more details.\n\nGeoTools 22.x\n-------------\n\nChange to repo.osgeo.org for GeoTools releases\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUse *osgeo* repository ``https://repo.osgeo.org/repository/release/``:\n\n* Replaces *osgeo* release repository ``http://download.osgeo.org/webdav/geotools/`` for GeoTools releases.\n* This is a group repository used by several OSGeo projects.\n* This group repository also provides third-party dependencies used by GeoTools (such as JTS and JAI-EXT).\n\nBEFORE :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repository>\n       <id>osgeo</id>\n       <name>Open Source Geospatial Foundation Repository</name>\n       <url>http://download.osgeo.org/webdav/geotools/</url>\n   </repository>\n   \nAFTER :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repositories>\n     <repository>\n       <id>osgeo</id>\n       <name>OSGeo Release Repository</name>\n       <url>https://repo.osgeo.org/repository/release/</url>\n       <snapshots><enabled>false</enabled></snapshots>\n       <releases><enabled>true</enabled></releases>\n     </repository>\n   </repositories>\n\nAlternative: Mirror retired repo.boundlessgeo.com\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo build existing projects referencing ``http://repo.boundlessgeo.com/``, with no modifications to :file:`pom.xml`, configure mirrors using :file:`~/.m2/settings.xml`.\n\nChange to :file:`settings.xml`:\n\n.. code-block:: xml\n\n   <mirrors>\n     <mirror>\n       <id>osgeo-release</id>\n       <name>OSGeo Repository</name>\n       <url>https://repo.osgeo.org/repository/release/</url>\n       <mirrorOf>osgeo</mirrorOf>     <!-- previously http://download.osgeo.org/webdav/geotools/ -->\n     </mirror>\n     <mirror>\n       <id>geoserver-releases</id>\n       <name>Boundless Repository</name>\n       <url>https://repo.osgeo.org/repository/Geoserver-releases/</url>\n       <mirrorOf>boundless</mirrorOf> <!-- previously http://repo.boundlessgeo.com/main/ -->\n     </mirror>\n   </mirrors>\n\nBoth of the above repositories above are included in ``https://repo.osgeo.org/repository/release/`` group repository. The mirror settings are intended as a temporary measure to allow your projects to build while you update your :file:`pom.xml` to use the osgeo release repository.\n\nChange to repo.osgeo.org for GeoTools snapshots\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUse *osgeo-snapshots* repository ``https://repo.osgeo.org/repository/snapshot/``:\n\n* Replaces *boundless* snapshot repository ``http://repo.boundlessgeo.com/main`` for the GeoTools SNAPSHOTS.\n* This is a group snapshot repository used by several OSGeo projects\n\nThe contents of the *boundless* repository ``https://repo.boundlessgeo.com/main/`` previously included snapshots of active GeoTools builds. The repository ``https://repo.osgeo.org/repository/geotools-snapshots/`` has taking over this role for the GeoTools project ( and is included in the group repository ``https://repo.osgeo.org/repository/snapshot/``).\n\nTo update existing projects making use of an active branch replace *boundless* snapshot repository with *osgeo-snapshot* repository.\n\nBEFORE :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repository>\n       <snapshots>\n           <enabled>true</enabled>\n       </snapshots>\n       <id>boundless</id>\n       <name>Boundless Maven Repository</name>\n       <url>http://repo.boundlessgeo.com/main</url>\n   </repository>\n\nAFTER :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repository>\n     <id>osgeo-snapshot</id>\n     <name>OSGeo Snapshot Repository</name>\n     <url>https://repo.osgeo.org/repository/snapshot/</url>\n     <snapshots><enabled>true</enabled></snapshots>\n     <releases><enabled>false</enabled></releases>\n   </repository>\n\nGeoTools 21.x\n-------------\n\nGeoTools 21 is the first is compatible with Java 8 and Java 11.\n\nRestructured Library\n^^^^^^^^^^^^^^^^^^^^\n\nThe library has been restructured with automatic module names for Java 11 use.\n\nThe following table shows how maven dependencies have changed, and the resulting automatic module name for Java 11 use.\n\n.. list-table:: Restructure Library\n   :widths: 30, 30, 40\n   :header-rows: 1\n   \n   * - Dependency\n     - Upgrade\n     - Automatic Module Name\n   * - ``gt-opengis``\n     - ``gt-opengis``\n     - ``org.geotools.opengis``\n   * - ``gt-metadata``\n     - ``gt-metadata``\n     - ``org.geotools.metadata``\n   * - ``gt-api``\n     - (removed)\n     - \n   * - ``gt-referencing``\n     - ``gt-referencing``\n     - ``org.geotools.referencing``\n   * - ``gt-main``\n     - ``gt-main``\n     - ``org.geotools.main``\n   * - ``gt-xml``\n     - ``gt-xml``\n     - ``org.geotools.xml``\n   * - ``gt-xml``\n     - ``gt-xml``\n     - ``org.geotools.xml``\n   * - ``gt-main``\n     - ``gt-main``\n     - ``org.geotools.data``\n   * - ``gt-jdbc``\n     - ``gt-jdbc``\n     - ``org.geotools.jdbc``\n\nRepackage Library\n^^^^^^^^^^^^^^^^^\n\nPreviously GeoTools reused packages across modules by design, this approach is no longer supported by JDK resulting in the following classes changing package.\n\n.. list-table:: Restructure Library\n   :widths: 30, 70\n   :header-rows: 3\n   \n   * - Module\n     - Package\n   * - Upgrade\n     - Package\n   * - \n     - Classes Affected\n   * - ``gt-api``\n     - ``org.geotools.decorate``\n   * - ``gt-metadata``\n     - ``org.geotools.util.decorate``\n   * - \n     - Abstract Store, Wrapper\n   * - ``gt-api``\n     - ``org.geotools.data``\n   * - ``gt-main``\n     - ``org.geotools.data``\n   * - ``gt-api``\n     - ``org.geotools.data.simple``\n   * - ``gt-main``\n     - ``org.geotools.data.simple``\n   * - ``gt-api``\n     - ``org.geotools.decorate``\n   * - ``gt-main``\n     - ``org.geotools.util.decorate``\n   * - \n     - AbstractDecorator, Wrapper\n   * - ``gt-api``\n     - ``org.geotools.factory``\n   * - ``gt-main``\n     - ``org.geotools.factory``\n   * - ``gt-api``\n     - ``org.geotools.feature``\n   * - ``gt-main``\n     - ``org.geotools.feature``\n   * - ``gt-api``\n     - ``org.geotools.filter``\n   * - ``gt-main``\n     - ``org.geotools.filter``\n   * - ``gt-api``\n     - ``org.geotools.filter.expression``\n   * - ``gt-main``\n     - ``org.geotools.filter.expression``\n\nUpgrading projects using historical GeoTools snapshots\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe contents of the *boundless* repository ``https://repo.boundlessgeo.com/main/`` previously included snapshots of active GeoTools builds. The repository ``https://repo.osgeo.org/repository/geotools-snapshots/`` has taking over this role for the GeoTools project ( and is included in the group repository ``https://repo.osgeo.org/repository/snapshot/``).\n\nThe geotools-snapshots is populated from active branches only and does not contain \"historical\" snapshots from prior releases.  Due to this limitation we recommend upgrading historical projects to the appropriate GeoTools release.\n\nAs an example to fix an existing project build using GeoTools 21-SNAPSHOT which is no longer available upgrade to the most recent 21.x series release.\n\nBEFORE :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <properties>\n       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n       <geotools.version>21-SNAPSHOT</geotools.version>\n   </properties>\n   \nAFTER :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <properties>\n       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n       <geotools.version>21.5</geotools.version>\n   </properties>\n\nGeoTools 20.x\n-------------\n\nGeoTools 20 requires Java 8.\n\nUpgrade to JTS-1.16\n^^^^^^^^^^^^^^^^^^^\n\nThe transitive dependency will correctly bring in the required jars::\n\n     <dependency>\n        <groupId>org.locationtech.jts</groupId>\n        <artifactId>jts-core</artifactId>\n        <version>${jts.version}</version>\n     </dependency>\n\n**Package change to org.locationtech.jts**\n\nThis release changes the package names from ``com.vividsolutions.jts`` to ``org.locationtech.jts``. To update your own code follow the `JTS Upgrade Guide <https://github.com/locationtech/jts/blob/master/MIGRATION.md>`__ instructions.\n\nUsing the command line to update your own ``pom.xml`` files::\n\n   git grep -l com.vividsolutions | grep pom.xml | xargs sed -i \"s/com.vividsolutions/org.locationtech.jts/g\"\n   \nAnd codebase::\n\n   git grep -l com.vividsolutions | xargs sed -i \"s/com.vividsolutions/org.locationtech/\"\n\n**Use of copy rather than clone**\n\nIf you are in the habit of using ``clone`` to duplicate JTS objects (such as Geometry and Coordinate) you will find the ``clone`` method has been deprecated, and a ``copy`` method introduced to explicitly perform a deep copy::\n    \n    Geometry duplicate = geom.copy();\n\nMigrate to JSR-363 Units\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis releases upgrades from the unofficial JSR-275 units library to the official JSR-363 units API.\n\nMaven transitive dependency will correctly bring in the required jars::\n   \n    <dependency>\n       <groupId>systems.uom</groupId>\n       <artifactId>systems-common-java8</artifactId>\n       <version>0.7.2</version>\n    </dependency>\n\nPackage names have changed, resulting in some common search and replaces when upgrading:\n  \n* Search ``javax.measure.unit.Unit`` replace ``javax.measure.Unit``\n* Search ``ConversionException`` replace  ``IncommensurableException``\n  \n  This is a checked exception, in areas of the GeoTools library where this was found we now return an ``IllegalArgument`` exception.\n  \n* Search ``converter == UnitConverter.IDENTITY`` replace ``converter.isIdentity()``\n* Search ``javax.measure.unit.NonSI`` replace ``import si.uom.NonSI``\n* Search ``javax.measure.unit.SI`` replace ``import si.uom.SI``\n* Search ``SI.METER`` replace ``SI.METRE``\n* Search ``javax.measure.converter.UnitConverter`` replace ``javax.measure.UnitConverter``\n* Search ``javax.measure.unit.UnitFormat`` replace ``import javax.measure.format.UnitFormat``\n* Search ``Unit.ONE`` replace ``AbstractUnit.ONE``\n* Search ``Dimensionless.UNIT`` replace ``AbstractUnit.ONE``\n* Search ``Unit.valueOf(unitString)`` replace ``Units.parseUnit(unitString)``\n  \n**Getting Unit instances**\n\nIf you know the unit to use at compile time, use one of the Unit instances defined as static variables in ``org.geotools.measure.Units``, ``si.uom.SI``, ``si.uom.NonSI`` or ``systems.uom.common.USCustomary``.\n\nIf you need to define new Units at runtime, it is important to immediately try to convert the new unit to one of the existing instances using ``Units.autocorrect`` method. Autocorrect applies some tolerance to locate an equivalent Unit. Skipping autocorrect will produce unexpected results and errors due to small differences in units definition.\n\n.. code-block:: java\n\n   // the result should be NonSI.DEGREE_ANGLE:\n   Unit<?> deg = Units.autoCorrect(SI.RADIAN.multiply(0.0174532925199433));\n   Unit<?> halfMetre = SI.METRE.divide(2);\n\n.. code-block:: java\n\n   // the result should be SI.METRE\n   Unit<?> unit = Units.autocorrect(halfMetre.multiply(4).divide(2));\n   \n.. code-block:: java\n   \n   public <T extends Quantity<T>> Unit<T> deriveUnit(Unit<T>  baseUnit, double factor) {\n      return Units.autocorrect(baseUnit.multiply(factor);)\n   }\n\n**Use a specific Quantity whenever possible**\n\nThis allows for type-safety checks at compile time:\n\n.. code-block:: java\n\n   Unit<Length> halfMetre = SI.METRE.divide(2);\n   Unit<Length> stupidUnit = Units.autocorrect(halfMetre.multiply(4).divide(2));\n     \n**Formatting units**\n\nUse ``org.geotools.measure.Units.toName(unit)`` to get the unit name (or unit label if name is not defined).\n\n.. code-block:: java\n\n   Unit<?> unit = ...\n   System.out.println(Units.toName(unit)):\n\nUse ``org.geotools.measure.Units.getDefaultFormat().format()`` to get the unit label (ignoring the name).\n\n.. code-block:: java\n\n   // prints \"Litre\"\n   System.out.println(Units.toName(SI.LITRE))\n   // prints \"l\"\n   System.out.println(Units.getDefaultFormat().format(SI.LITRE))\n\n.. code-block:: java\n\n   // Most units don't define a name, so it does not make a difference\n   // prints \"m\"\n   System.out.println(Units.toName(SI.METRE))\n   // prints \"m\"\n   System.out.println(Units.getDefaultFormat().format(SI.METRE))\n  \n**Converting units**\n\nIf the unit ``Quantity`` type is known, use the type-safe ``getConverterTo()`` method:\n\n.. code-block:: java\n\n   Unit<Angle> unit = ...\n   UnitConverter converter = unit.getConverterTo(SI.RADIAN);\n   double convertedQuantity = converter.convert(3.1415);\n\nIf the ``Quantity`` type is undefined, use the convenience method ``org.geotools.measure.Units.getConverterToAny()``. Note that this method throws an ``IllegalArgumentException`` if units can't be converted:\n\n.. code-block:: java\n\n   Unit<?> unit = ...\n   UnitConverter converter = Units.getConverterToAny(unit, SI.RADIAN);\n   double convertedQuantity = converter.convert(3.1415);\n\n**Using units**\n\nIf previously you made use of the Units in your code, to help with unit\nconversion or simply to keep the units straight. You might have code like:\n\n.. code-block:: java \n\n  Measure<Double, Length> dist = Measure.valueOf(distance, SI.METER);\n  System.out.println(dist.doubleValue(SI.KILOMETER) + \" Km\");\n  System.out.println(dist.doubleValue(NonSI.MILE) + \" miles\");\n\nYou will find it no longer compiles. It should be converted to use the ``Quantity`` classes.\n\n.. code-block:: java\n\n    import javax.measure.Quantity;\n    import javax.measure.quantity.Length;\n    import si.uom.SI;\n    import systems.uom.common.USCustomary;\n\n    import tec.uom.se.quantity.Quantities;\n    import tec.uom.se.unit.MetricPrefix;\n\n    Quantity<Length> dist = Quantities.getQuantity(distance, SI.METRE);\n    System.out.println(dist.to(MetricPrefix.KILO(SI.METRE)).getValue() + \" Km\");\n    System.out.println(dist.to(USCustomary.MILE) + \" miles\");\n\nGeoTools 19.x\n-------------\n\nGeoTools is built and tested with Java 8 at this time, to use this library in a Java 9 or Java 10 environment additional JVM runtime arguments are required::\n\n    --add-modules=java.xml.bind --add-modules=java.activation -XX:+IgnoreUnrecognizedVMOptions\n\nThese settings turn on several JRE modules that have been disabled by default in Java 9 onward.\n\nGeoTools 15.x\n-------------\n\nGeoTools 15.x requires Java 8::\n\n    <build>\n        <plugins>\n            <plugin>\n                <inherited>true</inherited>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\nGeoTools 14.x\n-------------\nFrom 14.x version, the `JAI-EXT Project <https://github.com/geosolutions-it/jai-ext>`_ has been integrated in GeoTools. This project provides a high scalable Java API for image processing with support for ``NoData`` and ``ROI``. \nThis integration provides also the removal of the following classes, since they are now inside JAI-EXT:\n\n* ``ColorIndexer`` from *gt-coverage* module;\n* ``GTCrop`` from *gt-coverage* module;\n* ``GenericPiecewise`` from *gt-render* module;\n* ``RasterClassifier`` from *gt-render* module;\n* ``ArtifactsFilter`` from *gt-imagemosaic* module.\n\nUsers may now decide to choose between JAI and JAI-EXT operations by simply using the ``JAIExt`` class containing utility methods for handling JAI/JAI-EXT registration.\n\nA more detailed tutorial on how to use JAI-EXT may be found at the following :ref:`JAI-EXT Tutorial Page<jaiext>`.\n\n``TextSymbolizer`` provides direct access to the device independent Font list, removing deprecated array access methods. This change restores SLD 1.0 multi-lingual behavior allowing several face/size combinations to be used during labeling.\n\nBEFORE::\n\n  textSymbolizer.addFont(font);\n  Font[] array = textSymbolizer.getFonts();\n  for(int i=0; i<array.length; i++){\n      Font f = textSymbolizer.getFonts()[i];\n      ...\n   }\n  \nAFTER::\n \n  textSymbolizer.fonts().add(font);\n  for(Font f : textSymbolizer.fonts()){\n     ...\n  }\n\n``Transaction`` is now ``Closable`` for use with try-with-resource syntax::\n\n   try (Transaction t = new DefaultTransaction()){\n        store.setTransaction( t );\n        store.addFeatures( newFeatures );\n        t.commit();\n   }\n\n``ShapefileDataStore`` representing shapefiles without any data, now return empty bounds on ``getBounds()`` instead of the bounds inside the shapefile header (mostly [0:0,0:0]). So ``bounds.isEmpty()`` and ``bounds.isNull()`` will return true for empty shapefiles.\n\nGeoTools 13.0\n-------------\nAs of GeoTools 13.0, the ``CoverageViewType`` classes have been removed. The ``AbstractDataStore`` class is also now deprecated. Extensive work has been done to bring in ``ContentDataStore`` as its replacement.\n\nThere is a `ContentDataStore Tutorial <http://docs.geotools.org/latest/userguide/tutorial/datastore/index.html>`_ to help with migration from ``AbstractDataStore``.\n\nMany readers and iterators are now ``Closable`` for use with try-with-resource syntax::\n\n   try( SimpleFeatureIterator features = source.getFeatures( filter ) ){\n       while( features.hasNext() ){\n          SimpleFeature feature = features.next();\n          ...\n       }\n   }\n\nGeoTools 12.0\n-------------\nGeoTools now requires `Java 7 <http://docs.geotools.org/latest/userguide/build/install/jdk.html>`_ and this is the first release tested with OpenJDK! Please ensure you are using JDK 1.7 or newer for GeoTools 12. Both Oracle Java 7 and OpenJDK 7 are supported, tested, release targets.\n\nFilter interfaces have been simplified. The GeoTools interfaces have been deprecated since GeoTools 2.3, and finally they have been removed. All filter interfaces now use the GeoAPI Filter.\n\nGeoTools 11.0\n-------------\nOnly new features were added in GeoTools 11.0.\n\nGeoTools 10.0\n-------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`10.x`\n\n   For background details on any API changes review the change proposals above.\n\nGeoTools 10 add significant improvements in the coverage reading API.\nFor those migrating the first visible benefit is that referring to a generic grid coverage reader does not require anymore to use ``AbstractGridCoverage2DReader`` (an abstract class) but to the new ``GridCoverage2DReader`` interface. The old usage is still supported though, as most readers are still extending the same base class, but the usage of the interface allows for reader wrappers.\n\nBEFORE::\n\n  AbstractGridCoverage2DReader reader = format.getReader(source);\n  \nAFTER::\n \n  GridCoverage2DReader reader = format.getReader(source);\n\nGeoTools 9.0\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`9.x`\n\n   For background details on any API changes review the change proposals above.\n\nGeoTools 9 has resolved a long standing conflict between ``FeatureCollection`` acting as a \"result\" set capable of\nstreaming large data sets vs. acting as a familiar Java Collection. The Java 5 \"for each\" syntax prevents\nthe safe use of Iterator (as we cannot ensure it will be closed). As a result ``FeatureCollection`` no longer\ncan extend java Collection and is acting as a pure \"result set\" with streaming access provided by ``FeatureIterator``.\n\nReferencedEnvelope and CRS\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``ReferencedEnvelope`` has in the past only supported 2D extents, we have introduced the subclass ``ReferencedEnvelope3D``\nto support ``CoordinateReferenceSystems`` with three dimensions.\n\nThere is now a new factory method to safely construct the appropriate implementation for a provided ``CoordinateReferenceSystem``\nas shown below.\n\nBEFORE::\n\n  ReferencedEnvelope bbox = new ReferencedEnvelope( crs );\n  ReferencedEnvelope copy = new ReferencedEnvelope( bbox );\n  \nAFTER::\n  \n  ReferencedEnvelope bbox = ReferencedEnvelope.create( crs );\n  ReferencedEnvelope copy = ReferencedEnvelope.create( bbox );\n\nThis represents an *incompatible API change*, existing code using ``new ReferencedEnvelope`` may now throw\na ``RuntimeException`` when supplied with an incompatible ``CoordinateReferenceSystem``.\n\nFeatureCollection Add\n^^^^^^^^^^^^^^^^^^^^^\n\nWith the ``FeatureCollection.add`` method being removed, you will need to use an explicit instance that supports\nadding content.\n\nBEFORE::\n\n    SimpleFeatureCollection features = FeatureCollections.newCollection();\n\n    for( SimpleFeature feature : list ){\n       features.add( feature );\n    }\n\nAFTER::\n\n    DefaultFeatureCollection features = new DefaultFeatureCollection();\n    for( SimpleFeature feature : list ){\n    \u00a0\u00a0\u00a0features.add( feature );\n    }\n\nALTERNATE (will throw exception if ``FeatureCollection`` does not implement\n``java.util.Collection``)::\n\n    Collection<SimpleFeature> collection = DataUtilities.collectionCast( featureCollection );\n    collection.addAll( list );\n\nALTERNATE DETAIL::\n\n    SimpleFeatureCollection features = FeatureCollections.newCollection();\n    if( features instanceof Collection ){\n        Collection<SimpleFeature> collection = (Collection) features;\n        collection.addAll( list );\n    }\n    else {\n        throw new IllegalStateException(\"FeatureCollections configured with immutbale implementation\");\n    }\n    \nSPECIFIC::\n\n    ListFeatureCollection features = new ListFeatureCollection( schema, list );\n\nFeatureCollection Iterator\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe deprecated ``FeatureCollection.iterator()`` method is no longer available, please use ``FeatureCollection.features()``\nas shown below.\n\nBEFORE::\n\n  Iterator i=featureCollection.iterator();\n  try {\n      while( i.hasNext(); ){\n         SimpleFeature feature = i.next();\n         ...\n      }\n  }\n  finally {\n      featureCollection.close( i );\n  }\n\n\nAFTER::\n\n    FeatureIterator i=featureCollection.features();\n    try {\n         while( i.hasNext(); ){\n             SimpleFeature feature = i.next();\n             ...\n         }\n    }\n    finally {\n         i.close();\n    }\n\nJAVA7::\n\n    try ( FeatureIterator i=featureCollection.features()){\n        while( i.hasNext() ){\n             SimpleFeature feature = i.next();\n             ...\n        }\n    }\n\nHow to Close an Iterator\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe have made ``FeatureIterator`` implement ``Closable`` (for Java 7 try-with-resource compatibility). This\nalso provides an excellent replacement for\n``FeatureCollection.close(Iterator)``.\n\nIf you are using any wrapping ``Iterators`` that still require the ability to ``close()``\nplease consider the following approach.\n\nBEFORE::\n\n    Iterator iterator = collection.iterator();\n    try {\n       ...\n    } finally {\n        if (collection instanceof SimpleFeatureCollection) {\n            ((SimpleFeatureCollection) collection).close(iterator);\n        }\n    }\n\nQUICK::\n\n    Iterator iterator = collection.iterator();\n    try {\n       ...\n    } finally {\n        DataUtilities.close( iterator );\n    }\n\nDETAIL::\n\n    Iterator iterator = collection.iterator();\n    try {\n       ...\n    } finally {\n        if (iterator instanceof Closeable) {\n            try {\n               ((Closeable)iterator).close();\n            }\n            catch( IOException e){\n                Logger log = Logger.getLogger( collection.getClass().getPackage().toString() );\n                log.log(Level.FINE, e.getMessage(), e );\n            }\n        }\n    }\n\nJAVA7 using try-with-resource syntax for ``Iterator`` that implements ``Closeable``::\n\n    try ( Iterator i=collection.features()){\n        while( i.hasNext() ){\n             Object object = i.next();\n             ...\n        }\n    }\n    \n\nGeoTools 8.0\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`8.x`\n\n   You are encouraged to review the change proposals for GeoTools 8.0 for background information\n   on the following changes.\n\nThe changes moving from GeoTools 2.7 to GeoTools 8.0 have a great emphasis on usability and\ndocumentation. Because of the focus on ease of use; many of the changes here are marked \"Optional\"\nthis indicates that your code will not break; but you have a chance to clean it up and make\nyour code more readable.\n\nStyle\n^^^^^\n\nSome of the ``gt-opengis`` style methods that have been deprecated for a while are now removed.\n\n* ``Mark.getRotation()`` / ``Mark.setRotation( Expression )``\n* ``Mark.getSize()`` / ``Mark.setSize( Expression )``\n\nThese are handled in a similar manner:\n\n* BEFORE::\n\n      for( GraphicalSymbol symbol : graphic.graphicalSymbols() ){\n          if( symbol instanceof Mark ){\n               Mark mark = (Mark) symbol;\n               mark.setSize( ff.literal( 8 ) );\n          }\n      }\n\n* AFTER::\n\n      graphic.setSize( ff.literal( 8 ) );\n\nFilter\n^^^^^^\n\nThe filter system was upgrade to match Filter 2.0 resulting in a few additions. This mostly\neffects people writing their own functions (as now we need to know about parameter types).\n\nFeatureId\n''''''''''\n\n* BEFORE::\n\n    FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(null);\n    Filter filter;\n\n    Set<FeatureId> selected = new HashSet<FeatureId>();\n    selected.add(ff.featureId(\"CITY.98734597823459687235\"));\n    selected.add(ff.featureId(\"CITY.98734592345235823474\"));\n\n    filter = ff.id(selected);\n\n* AFTER\n\n  .. literalinclude:: /../src/main/java/org/geotools/opengis/FilterExamples.java\n     :language: java\n     :start-after: // id start\n     :end-before: // id end\n\nFunction\n''''''''\n\nWe have extended ``gt-opengis`` ``Function`` to make the ``FunctionName`` description (especially\nargument names) more available.\n\n* To update your code::\n\n    class SplitFunction implements Function {\n        public static FunctionName NAME = new FunctionNameImpl( \"split\", \"geometry\", \"line\" );\n        ...\n        FunctionName getFunctionName(){\n            return NAME;\n        }\n        ...\n    }\n\nIf you are extending abstract function expression base class; it provides a default implementation\nof ``getFunctionName()`` allowing your code to compile.\n\nFunctionExpression\n''''''''''''''''''\n\nIn a related matter ``gt-main`` no longer provides access to the deprecated ``FunctionExpression``\ninterface (it has returned an empty set for several releases now):\n\n* BEFORE::\n\n        Set<String> proposals = new TreeSet<String>();\n        Set<Function> oldFunctions = FunctionFinder. CommonFactoryFinder.getFunctionExpressions(null);\n        for( Function function : oldFunctions ) {\n            proposals.add(function.getName().toLowerCase());\n        }\n\n* AFTER::\n\n        Set<String> proposals = new TreeSet<String>();\n\n        FunctionFinder functionFinder = new FunctionFinder(null);\n        for( FunctionName function : functionFinder.getAllFunctionDescriptions() ){\n            proposals.add(function.getName().toLowerCase());\n        }\n\nDirect Position and Envelope\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated methods in ``gt-opengis`` and ``gt-referencing`` have now been removed.\n\n=========================================== ==================================== ===================================\nDeprecated method in 2.7                    Replacement in 8.0                   Notes\n=========================================== ==================================== ===================================\n``DirectPosition.getCoordinates()``         ``DirectPosition.getCoordinate()``   For consistency with ISO 19107\n``Envelope.getCenter()``                    ``Envelope.getMedian()``             For consistency with ISO 19107\n``Envelope.getLength()``                    ``Envelope.getSpan()``               For consistency with ISO 19107\n``Precision.getMaximumSignificantDigits()`` ``Precision.getScale()}}``           Remove duplication\n``PointArray.length()``                     ``List.size()``                      ``PointArray`` instance can be used\n``PointArray.position()``                   ``this``                             ``PointArray`` instance can be used\n``Position.getPosition()``                  ``Position.getDirectPosition()``     For consistency with ISO 19107\n``Point.setPosition()``                     ``Point.setDirectPosition()``        For consistency with ISO 19107\n=========================================== ==================================== ===================================\n\nNumberRange\n^^^^^^^^^^^\n\nThe ``gt-metadata`` ``NumberRange`` class is finally shedding some of its deprecated methods.\n\nBEFORE::\n\n      NumberRange before = new NumberRange( 0.0, 5.0 );\n\nAFTER::\n\n      NumberRange<Double> after1 = new NumberRange( Double.class, 0.0, 5.0 );\n      NumberRange<Double> after2 = NumberRage.create( 0.0, 5.0 );\n\nGeoTools 2.7\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.7.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.7.0 for background information\n   on the following changes.\n\nThe changes from GeoTools 2.6 to GeoTools 2.7 focus on making your code more readable; you will\nfind a number of optional changes (such as using Query rather than ``DefaultQuery``) which will\nsimplify make your code easier to follow.\n\n\nQuery\n^^^^^\n\nThe ``gt-api`` module has been updated to make ``Query`` a concrete class rather than an interface.\n\nBEFORE::\n\n        Query query = new DefaultQuery( typeName, filter );\n\nAFTER::\n\n        Query query = new Query( typeName, filter );\n\nTips:\n\n* You can perform a search and replace to change ``DefaultQuery`` to ``Query`` on your code base\n* If you have your own implementation of ``Query`` your code is now broken; after many years we have\n  never seen an implementation of ``Query`` in the wild. You should be able to fix by extending rather\n  then implementing ``Query``.\n* ``DefaultQuery`` still exists but all of the implementation code has now been \"pulled up\" into\n  ``Query`` and ``DefaultQuery`` marked as deprecated.\n* In a similar fashion ``FeatureLock`` can now be directly constructed rather than use a ``Factory``.\n\nSimpleFeatureCollection\n^^^^^^^^^^^^^^^^^^^^^^^\n\nWe have vastly cut down the use of Java generics for casual users of the GeoTools library. The\nprimary example of this is the introduction of ``SimpleFeatureCollection`` (which saves you\ntyping in ``FeatureCollection<SimpleFeatureType,SimpleFeature>`` each time).\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n            (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n    Query query = new DefaultQuery( typeName, filter );\n    FeatureCollection<SimpleFeatureType,SimpleFeature> featureCollection = source.getFeatures( query );\n\n* AFTER::\n\n    SimpleFeatureSource source = dataStore.getFeatureSource( typeName );\n    Query query = new Query( typeName, filter );\n    SimpleFeatureCollection featureCollection = source.getFeatures( query );\n\nTips:\n\n* You can do a search and replace on this one; but you need to be very careful with any\n  implementations you have that accept a ``FeatureCollection<SimpleFeatureType,SimpleFeature>``\n  as a method parameter!\n\n* Be careful if you have your own ``FeatureStore`` implementation; a search and replace will change\n  several of your methods so they no longer \"override\" the default implementation provided by\n  ``AbstractFeatureStore``.::\n\n       @Override // this would fail; you do use Override right?\n       public Set addFeatures( SimpleFeatureCollection features ){\n          ... your implementation goes here ...\n\n  To fix this code you will need to \"undo\" your search and replace for this method parameter::\n\n       @Override\n       public Set addFeatures( FeatureCollection<SimpleFeatureType,SimpleFeature> features ){\n          ... your implementation goes here ...\n\n  Note: If you use the ``@Override`` annotation in your code you will get a proper error; since your\n  new method would no longer override anything.\n\nSimpleFeatureSource\n^^^^^^^^^^^^^^^^^^^\n\nThe ``gt-api`` module now defines ``SimpleFeatuyreSource`` (to save you a bit of typing). In addition\nthe ``DataStore`` interface now returns a ``SimpleFeatureSource``; so if you want you optionally\ncan update your code for readability.\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n           (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n\n* AFTER::\n\n    SimpleFeatureSource source =  dataStore.getFeatureSource( typeName );\n\nTips:\n* you can do this with a search and replace\n* Be a bit careful when you have one of your own methods that is expecting a ``FeatureSource``\n\nSimpleFeatureStore\n^^^^^^^^^^^^^^^^^^\nIn a similar fashion returns a ``SimpleFeatureCollection``; it also has a couple of its own tricks:\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n        (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n    if( source instanceof FeatureStore){\n       // read write access\n       FeatureStore<SimpleFeatureType,SimpleFeature> store =\n            (FeatureStore<SimpleFeatureType,SimpleFeature>) source;\n       store.addFeatures( newFeatures );\n       ...\n\n* AFTER::\n\n    SimpleFeatureSource source =  dataStore.getFeatureSource( typeName );\n    if( source instanceof SimpleFeatureStore){\n       // read write access\n       SimpleFeatureStore store = (SimpleFeatureStore) source;\n       store.addFeatures( newFeatures );\n       ...\n\nSimpleFeatureLocking\n^^^^^^^^^^^^^^^^^^^^\n\nYou can also explicitly use ``SimpleFeatureLocking`` if you want read/write/lock access to simple\nfeature content. Much like ``Query`` it has been made a concrete class.\n\n``FeatureStore`` ``modifyFeatures`` by ``Name``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``FeatureStore`` method ``modifyFeatures`` now allows you to modify features by name.\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n        (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n    if( source instanceof FeatureStore){\n       // read write access\n       FeatureStore<SimpleFeatureType,SimpleFeature> store =\n            (FeatureStore<SimpleFeatureType,SimpleFeature>) source;\n\n       SimpleFeatureType schema = store.getSchema();\n       AttributeDescriptor attribute = schema.getDescriptor( attributeName );\n       store.modifyFeatures( attribute, attributeValue, filter );\n\n* AFTER::\n\n    SimpleFeatureSource source =  dataStore.getFeatureSource( typeName );\n    if( source instanceof SimpleFeatureStore){\n       // read write access\n       SimpleFeatureStore store = (SimpleFeatureStore) source;\n       store.modifyFeatures( attributeName, attributeValue, filter );\n       ...\n\nTips:\n\n* Generic ``FeatureSource`` allows ``modifyFeatures(Name, Value, filter)``\n\nCoverageProcessor\n^^^^^^^^^^^^^^^^^\n\nThe ``DefaultProcessor`` and ``AbstractProcessor`` classes have been merged into a single class called\n``CoverageProcessor``.\n\n* BEFORE::\n\n    final DefaultProcessor processor= new DefaultProcessor(hints)\n\n* AFTER::\n\n    final CoverageProcessor processor= new CoverageProcessor(hints)\n\n  Or better::\n\n      final CoverageProcessor processor= CoverageProcessor.getInstace(hints);\n\nTips:\n\n* Try to always use the static ``getDefaultInstance`` method in order to leverage on ``SoftReference`` caching\n\nGeneralEnvelope\n^^^^^^^^^^^^^^^\n\nWe have been removing old deprecated code from the ``GeneralEnvelope`` class.\n\n=================================== ===================================================\nOld Method                          New Method     \n=================================== ===================================================\n``double getCenter(dimension)``     ``DirectPosition getMedian()``\n``double getCenter()``              ``double getMedian(dimension)``\n``double getLength(dimension)``     ``double getSpan(dimension)``\n``getLength(dimension, unit)``      ``double getSpan(dimension, unit)``\n=================================== ===================================================\n\nGeoTools 2.6\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.6.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.6.0 for background information\n   on the following changes.\n\nThe GeoTools 2.6.0 release is incremental in nature with the main change being the introduction\nof the ``JDBC-NG`` DataStores the idea of ``Query`` capabilities (so you can check what hints are\nsupported).\n\nGridRange Removed\n^^^^^^^^^^^^^^^^^\n\n``GridRange`` implementations have been removed as the result of a change we are inheriting from GeoAPI\nwhere a switch from ``GridRange`` to ``GridEnvelope`` has been made. ``GridRange`` comes from\nGrid Coverages Implementation specification 1.0 (which is basically dead) while\n``GridEnvelope`` comes from ISO 19123 which looks like the replacement.\n\nThere is a big difference between interfaces though:\n\n* ``GridRange`` treats its own maximum grid coordinates as EXCLUSIVE (like Java2D classes\n  ``Rectangle2D``, ``RenderedImage`` and ``Raster`` do); while\n* ``GridEnvelope`` uses a different convention where maximum grid coordinates are INCLUSIVE.\n\nThis is shown in the code example below with the ``maxx`` variable.\n\nAs far as switching over to the new classes, the equivalence are as follows:\n\n1. Replace ``GridRange2D`` with ``GridEnvelope2D``\n\n   Notice that now ``GridEnvelope2D`` is a Java2D ``Rectangle`` and that it is also mutable!\n2. Replace ``GeneralGridRange`` with ``GeneralGridEnvelope``\n\nThere are a few more caveats, which we are showing here below.\n\nBEFORE:\n\n1. Use ``getSpan`` where ``getLength`` was used\n2. Be EXTREMELY careful with the conventions for the inclusion/exclusion of the maximum coordinates.\n3. ``GridRange2D`` IS a ``Rectangle`` and is mutable now!\n\n   BEFORE::\n\n        import org.geotools.coverage.grid.GeneralGridRange;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GeneralGridRange originalGridRange = new GeneralGridRange(actualDim);\n        final int w = originalGridRange.getLength(0);\n        final int maxx = originalGridRange.getUpper(0);\n\n        ...\n        import org.geotools.coverage.grid.GridRange2D;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GridRange2D originalGridRange2D = new GridRange2D(actualDim);\n        final int w = originalGridRange2D.getLength(0);\n        final int maxx = originalGridRange2D.getUpper(0);\n        final Rectangle rect = (Rectangle)originalGridRange2D.clone();\n    {code}\n\n   AFTER::\n\n        import org.geotools.coverage.grid.GeneralGridEnvelope;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GeneralGridEnvelope originalGridRange=new GeneralGridEnvelope (actualDim,2);\n        final int w = originalGridRange.getSpan(0);\n        final int maxx = originalGridRange.getHigh(0)+1;\n\n        import org.geotools.coverage.grid.GridEnvelope2D;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GridEnvelope2D originalGridRange2D = new GridEnvelope2D(actualDim);\n        final int w = originalGridRange2D.getSpan(0);\n        final int maxx = originalGridRange2D.getHigh(0)+1;\n        final Rectangle rect = (Rectangle)originalGridRange2D.clone();\n\n``OverviewPolicy`` ``Enum`` replace ``Hint`` use\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe hints to control overviews were deprecated and have now been removed.\n\nThe current deprecated values have been remove from the Hints class inside the Metadata module:\n\n* ``VALUE_OVERVIEW_POLICY_QUALITY``\n* ``IGNORE_COVERAGE_OVERVIEW``\n* ``VALUE_OVERVIEW_POLICY_IGNORE``\n* ``VALUE_OVERVIEW_POLICY_NEAREST``\n* ``VALUE_OVERVIEW_POLICY_SPEED``\n\nYou should use the ``Enum`` that comes with the ``OverviewPolicy`` ``Enum``. Here below you will find a few examples:\n\n* BEFORE::\n\n        Hints hints = new Hints();\n        hints.put(Hints.OVERVIEW_POLICY, Hints.VALUE_OVERVIEW_POLICY_SPEED);\n        WorldImageReader wiReader = new WorldImageReader(file, hints);\n\n* AFTER::\n\n        Hints hints = new Hints();\n        hints.put(Hints.OVERVIEW_POLICY, OverviewPolicy.SPEED);\n        WorldImageReader wiReader = new WorldImageReader(file, hints);\n\nHints:\n\n* Please, notice that the ``OverviewPolicy`` ``Enum`` provides a method to get the default policy for\n  overviews. The method is ``getDefaultPolicy()``.\n\nCoverageUtilities and FeatureUtilities\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated methods have been remove from coverage utilities classes;\n\nWe have removed deprecated methods from classes:\n\n* ``CoverageUtilities.java``\n* ``FeatureUtilities.java``\n\nExisting code should change as follows:\n\n* BEFORE::\n\n    final FeatureCollection<SimpleFeatureType, SimpleFeature> fc=FeatureUtilities.wrapGridCoverageReader(reader)\n\n* AFTER::\n\n    final GeneralParameterValue[] params=...\n\n    final FeatureCollection<SimpleFeatureType, SimpleFeature> fc=FeatureUtilities.wrapGridCoverageReader(reader,params)\n\nHints:\n\n* This change allows us to store basic parameters to control how we will perform subsequent\n  reads from this reader. The ``AbstractGridFormat`` ``READ_GRIDGEOMETRY2D`` parameter will be\n  always overridden during a subsequent read.\n\nCoverage Processing Classes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated methods have been remove from coverage processing classes:\n\n* ``filteredSubsample(GridCoverage, int, int, float[], Interpolation, BorderExtender)`` has been removed\n\nHere is what that looks like in code:\n\n* BEFORE::\n\n    public GridCoverage filteredSubsample(final GridCoverage   source,\n                                          final int            scaleX,\n                                          final int            scaleY,\n                                          final float\\[\\]      qsFilter,\n                                          final Interpolation  interpolation,\n                                          final BorderExtender be) throws CoverageProcessingException {\n         return filteredSubsample(source, scaleX, scaleY, qsFilter, interpolation);\n    }\n\n* AFTER::\n\n    public GridCoverage filteredSubsample(final GridCoverage source,\n                                          final int scaleX, final int scaleY,\n                                          final float\\[\\] qsFilter,\n                                          final Interpolation interpolation){\n           // recolor(GridCoverage, Map\\[\\]) has been removed\n           ...\n    }\n\n* BEFORE::\n\n        recolor(final GridCoverage source, final Map[] colorMaps)\n\n* AFTER::\n\n        recolor(final GridCoverage source, final ColorMap[] colorMaps);\n        // scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender) has been removed\n\n* BEFORE::\n\n        scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender)\n\n* AFTER::\n\n        scale(GridCoverage,double,double,double,double,Interpolation)\n        // scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender) has been removedBEFORE:\n\n* BEFORE::\n\n        scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender)\n\n* AFTER::\n\n        scale(GridCoverage,double,double,double,double,Interpolation)\n\nDefaultParameterDescriptor and Parameter\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRemoved deprecated constructors from ``DefaultParameterDescriptor`` and ``Parameter`` classes.\n\n* BEFORE::\n\n    DefaultParameterDescriptor(Map<String,?>,defaultValue,minimum, maximum, unit, required)\n    DefaultParameterDescriptor(Map<String,?>, defaultValue, minimum, maximum, required)\n    DefaultParameterDescriptor(name, defaultValue, minimum, maximum)\n    DefaultParameterDescriptor(name, defaultValue, minimum, maximum, unit)\n    DefaultParameterDescriptor(name, remarks, defaultValue, required)\n    DefaultParameterDescriptor(name, defaultValue)\n    DefaultParameterDescriptor( name, valueClass, defaultValue)\n    Parameter(name, value)\n    Parameter(name, value, unit)\n    Parameter(name, value)\n\n* AFTER::\n\n    DefaultParameterDescriptor.create(...)\n    Parameter.create(...)\n\nGeoTools 2.5\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.5.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.5.0 for background information\n   on the following changes.\n\nThe GeoTools 2.5.0 release is a major change to the GeoTools library due to the adoption of both\nJava 5 and a new feature model.\n\nFeatureCollction\n^^^^^^^^^^^^^^^^\n\nIn transitioning your code to Java 5 please be careful not use use the *for each* loop construct.\nWe still need to call ``FeatureCollection.close( iterator)``.\n\nDue to this restriction (of not using *for each* loop construct we have had to make ``FeatureCollection``\nno longer ``Collection``.\n\n* Example (GeoTools 2.5 code)::\n\n    FeatureCollection<SimpleFeatureType,SimpleFeature> featureCollection = feaureSource.getFeatures();\n    Iterator<SimpleFeature> iterator = featureCollection.iterator();\n    try {\n        while( iterator.hasNext() ){\n           SimpleFeature feature = iterator.next();\n           ...\n        }\n    }\n    finally {\n       featureCollection.close( iterator );\n    }\n\n* Example (GeoTools 2.7 code)\n\n  We have removed the need for the use of generics to minimize typing::\n\n    SimpleFeatureCollection featureCollection = feaureSource.getFeatures();\n    SimpleFeatureIterator iterator = featureCollection.features();\n    try {\n        while( iterator.hasNext() ){\n           SimpleFeature feature = iterator.next();\n           ...\n        }\n    }\n    finally {\n       iterator.close();\n    }\n\nJTSFactory\n^^^^^^^^^^\n\nWe are cutting down on \"anonymous\" ``FactoryFinder`` use; creating ``JTSFactory`` to allow the\nentire GeoTools library to share a JTS ``GeometryFactory``.\n\n* BEFORE (GeoTools 2.4 code)::\n\n     GeometryFactory factory = new FactoryFinder().getGeometryFactory( null );\n\n* AFTER (GeoTools 2.5 code)::\n\n    GeometryFactory factory = JTSFactoryFinder.getGeometryFactory( null );\n\nProgressListener\n^^^^^^^^^^^^^^^^\n\nTransition to ``gt-opengis`` ``ProgressListener``.\n\n* Before (GeoTools 2.2 Code)::\n\n    progress.setDescription( message );\n\n* After (GeoTools 2.4 Code)::\n\n    progress.setTask( new SimpleInternationalString( message ) );\n\nTo upgrade:\n\n1. Search: ``import org.geotools.util.ProgressListener``\n\n   Replace: ``import org.opengis.util.ProgressListener``\n\n2. Update::\n\n     setTask( new SimpleInternationalString( message ) ); // was setDescription( message );\n\nSimpleFeature\n^^^^^^^^^^^^^\n\nWe have (finally) made the move to an improved feature model. Please take the opportunity\nto change your existing code to use ``org.opengis.feature.simple.SimpleFeature``. The existing\nGeoTools Feature interface is still in use; but it has been updated in\nplace to extend ``SimpleFeature``.\n\n* Before (GeoTools 2.4 Code)::\n\n        import org.geotools.feature.FeatureType;\n        ...\n        CoordinateReferenceSystem crs = CRS.decode(\"EPSG:4326\");\n        final AttributeType GEOM =\n            AttributeTypeFactory.newAttributeType(\"Location\",Point.class,true, null,null,crs );\n        final AttributeType NAME =\n            AttributeTypeFactory.newAttributeType(\"Name\",String.class, true );\n\n        final FeatureType FLAG =\n            FeatureTypeFactory.newFeatureType(new AttributeType[] { GEOM, NAME },\"Flag\");\n\n        Feature flag1 = FLAG.create( \"flag.1\", new Object[]{ point, \"Here\" } );\n\n        AttributeType attributes[] = FLAG.getAttributeTypes();\n        AttributeType location = FLAG.getAttribute(\"Location\");\n        String label = location.getName();\n        Class binding = location.getType();\n        Geometry geom = flag1.getDefaultGeometry();\n\n* After (GeoTools 2.5 Code)::\n\n        import org.opengis.feature.simple.SimpleFeatureType;\n        ...\n        SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();\n        builder.setName( \"Flag\" );\n        builder.setNamespaceURI( \"http://localhost/\" );\n        builder.setCRS( \"EPSG:4326\" );\n        builder.add( \"Location\", Point.class );\n        builder.add( \"Name\", String.class );\n\n        SimpleFeatureType FLAG = builder.buildFeatureType();\n\n        SimpleFeature flag1 = SimpleFeatureBuilder.build( FLAG, new Object[]{ point, \"Here\"}, \"flag.1\" );\n\n        List<AttributeDescriptor> attributes = FLAG.getAttributes();\n        AttributeDescriptor location = FLAG.getAttribute(\"Location\");\n        String label = location.getLocationName();\n        Class binding = location.getType().getBinding();\n        Geometry geom = (Geometry) flag1.getDefaultGeometry();\n\nHere are some steps to start you off updating your code:\n\n1. Search Replace\n\n   * Search: ``Feature`` replace with ``SimpleFeature``\n   * Search: ``FeatureType`` replace with ``SimpleFeatureType``\n\n2. Fix the imports\n\n   * Control-Shift-O in Eclipse IDE\n   * Add casts as required for ``getDefaultGeometry()``\n\n3. ``FeatureType.create`` has been replaced with ``SimpleFeatureBuilder``\n\n   There is a static method to make the transition easier::\n\n      SimpleFeatureFeatureBuilder.build( schema, attributes, fid );\n\n4. For more code examples please see:\n\n   * :doc:`/library/main/feature`\n\nAttributeDescriptor and AttributeType\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe concept of an ``AttributeType`` has been split into two now (allowing you to reuse common types).\n\n* BEFORE (GeoTools 2.4 Code)::\n\n    import org.geotools.feature.AttributeType;\n    ...\n    GeometryAttributeType att =\n              (GeometryAttributeType) AttributeTypeBuilder.newAttributeDescriptor(geomTypeName,\n                                                                                  targetGeomType,\n                                                                                  isNillable,\n                                                                                  Integer.MAX_VALUE,\n                                                                                  Collections.EMPTY_LIST,\n                                                                                  crs );\n\n* AFTER (GeoTools 2.5 Code)::\n\n    import org.geotools.feature.AttributeTypeBuilder;\n    import org.opengis.feature.type.AttributeDescriptor\n    ...\n    AttributeTypeBuilder build = new AttributeTypeBuilder();\n    build.setName( geomTypeName );\n    build.setBinding( targetGeomType );\n    build.setNillable(true);\n    build.setCRS(crs);\n    GeometryType type = build.buildGeometryType();\n    GeometryDescriptor attribute = build.buildDescriptor( geomTypeName, type );\n\nName\n^^^^\n\nIn order to better support app-schema work we can no longer assume names are a simple String. The\n``Name`` class has been introduced to make this easier and is available\nthroughout the library: example ``FeatureSource.getName()``.\n\n* BEFORE  (GeoTools 2.4 Code)::\n\n    DataStore ds = ...\n    String []typeNames = ds.getTypeNames();\n    SimpleFeatureType type = ds.getSchema(typeNames[0]);\n    assert type.getTypeName() == typeNames[0];\n    FeatureSource source = ds.getFeatureSource(type.getTypeName());\n\n* AFTER  (GeoTools 2.5 Code)::\n\n    import org.opengis.feature.type.Name;\n    ...\n\n    DataStore ds = ...\n    List<Name> featureNames = ds.getNames();\n    SimpleFeatureType type = ds.getSchema(featureNames.get(0));\n    // type.getName() may or may not be equal to featureNames.get(0), assume not. If they're its just an implementation detail.\n    FeatureSource source = ds.getFeatureSource(featureNames.get(0));\n\nDataStore\n^^^^^^^^^\n\nTransition to use of Java 5 Generics with DataStore API.\n\n.. tip\n\n   We have removed the need to use Generics in GeoTools 2.7 allowing the use of\n   ``SimpleFeatureSource``, ``SimpleFeatureCollection``, ``SimpleFeatureStore`` etc.\n\n* BEFORE  (GeoTools 2.4 Code)::\n\n    DataStore ds = ...\n    FeatureSource source = ds.getSource(typeName);\n    FeatureStore store = (FeatureStore)source;\n    FeatureLocking locking = (FeatureLocking)source;\n\n    FeatureCollection collection = source.getFeatures();\n    FeatureIterator features = collection.features();\n    while(features.hasNext){\n      SimpleFeature feature = features.next();\n    }\n\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter writer = ds.getFeatureWriter(typeName, transaction);\n\n* AFTER  (GeoTools 2.5 Code)::\n\n    DataStore ds = ...\n    FeatureSource<SimpleFeatureType,SimpleFeature> source = ds.getSource(typeName);\n    FeatureStore<SimpleFeatureType,SimpleFeature> store = (FeatureStore<SimpleFeatureType,SimpleFeature>)source;\n    FeatureLocking<SimpleFeatureType,SimpleFeature> locking = (FeatureLocking<SimpleFeatureType,SimpleFeature>)source;\n\n    FeatureCollection<SimpleFeatureType,SimpleFeature> collection = source.getFeatures();\n    FeatureIterator<SimpleFeatureType,SimpleFeature> features = collection.features();\n    while(features.hasNext){\n       SimpleFeature feature = features.next();\n    }\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader<SimpleFeatureType,SimpleFeature> reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter<SimpleFeatureType,SimpleFeature> writer = ds.getFeatureWriter(typeName, transaction);\n\n* AFTER (GeoTools 2.7 Code)::\n\n    DataStore ds = ...\n    SimpleFeatureSource<SimpleFeatureType,SimpleFeature> source = ds.getSource(typeName);\n    SimpleFeatureStore store = (SimpleFeatureStore) source;\n    SimpleFeatureLocking locking = (SimpleFeatureLocking) source;\n\n    SimpleFeatureCollection collection = source.getFeatures();\n    SimpleFeatureIterator features = collection.features();\n    while(features.hasNext){\n       SimpleFeature feature = features.next();\n    }\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader<SimpleFeatureType,SimpleFeature> reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter<SimpleFeatureType,SimpleFeature> writer = ds.getFeatureWriter(typeName, transaction);\n\nDataAccess and DataStore\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n* The ``DataAccess`` super class has been introduced, leaving DataStore to *only* work with ``SimpleFeature``\n  capable implementations.::\n\n    import org.opengis.feature.type.Name;\n    ...\n\n    java.util.Map paramsMap = ...\n    DataStore ds = DataStoreFinder.getDataStore(paramsMap);\n    Name featureName = new org.geotools.feature.Name(namespace, localName);\n    FeatureSource<SimpleFeatureType, SimpleFeature> source = ds.getSource(featureName);\n    FeatureStore<SimpleFeatureType, SimpleFeature> store = (FeatureStore)source;\n    FeatureLocking<SimpleFeatureType, SimpleFeature> locking = (FeatureLocking)source;\n\n    FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures();\n    FeatureIterator<SimpleFeature> features = collection.features();\n    while(features.hasNext){\n     SimpleFeature feature = features.next();\n    }\n\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader<SimpleFeatureType, SimpleFeature> reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter<SimpleFeatureType, SimpleFeature> writer = ds.getFeatureWriter(typeName, transaction);\n\n* ``DataAccess``: works both with ``SimpleFeature`` and normal ``Feature`` capable implementations::\n\n    import org.opengis.feature.FeatureType;\n    import org.opengis.feature.Feature;\n    import org.opengis.feature.type.Name;\n    ...\n\n    java.util.Map paramsMap = ...\n    DataAccess<FeatureType, Feature> ds = DataAccessFinder.getDataAccess(paramsMap);\n    Name featureName = new org.geotools.feature.Name(namespace, localName);\n    FeatureSource<FeatureType, Feature> source = ds.getSource(featureName);\n    FeatureStore<FeatureType, Feature> store = (FeatureStore)source;\n    FeatureLocking<FeatureType, Feature> locking = (FeatureLocking)source;\n\n    FeatureCollection<FeatureType, Feature> collection = source.getFeatures();\n    FeatureIterator<Feature> features = collection.features();\n    while(features.hasNext){\n     Feature feature = features.next();\n    }\n    //No DataAccess.getFeatureReader/Writer\n\nGeoTools 2.4\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.4.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.4.0 for background information\n   on the following changes.\n\nThe GeoTools 2.4.0 release is a major change to the GeoTools library due to the adoption of GeoAPI\n``Filter`` model. This new filter model is immutable making it impossible to modify filters that\nhave already been constructed; in trade it is thread safe.\n\nThe following is needed when upgrading to 2.4.\n\nReferencingFactoryFinder\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nRename ``FactoryFinder`` to ``ReferencingFactoryFinder``\n\n* BEFORE (GeoTools 2.2 Code)::\n\n    CRSFactory factory = FactoryFinder.getCSFactory( null );\n\n* AFTER (GeoTools 2.4 Code)::\n\n    CRSFactory factory = ReferencingFactoryFinder.getCSFactory( null );\n\n``FeatureStore`` ``addFeatures``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe use of ``FeatureReader`` has been removed from the ``FeatureStore`` API.\n\n* Before (GeoTools 2.2 Code)::\n\n    featureStore.addFeatures( DataUtilities.reader( collection )); // add FeatureCollection\n    featureStore.addFeatures( DataUtilities.reader(array)); // add Feature[]\n    featureStore.addFeatures( DataUtilities.reader(feature )); // add Feature\n    featureStore.addFeatures( reader );\n\n* After (GeoTools 2.4 Code)::\n\n    featureStore.addFeatures( collection ); // add FeatureCollection\n    featureStore.addFeatures( DataUtilities.collection( array ) ); // add Feature[]\n    featureStore.addFeatures( DataUtilities.collection( feature )); // add Feature\n    featureStore.addFeatures( DataUtilities.collection( reader )); // add FeatureReader\n\nNote:\n\n* ``DataUtilities.collection(reader)`` will currently load the contents into memory, if you have\n  any volunteer time a \"lazy\" implementation would be helpful.\n\n``FeatureSource`` ``getSupportedHints``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe added a ``getSupportedHints()`` method that can be used to check which ``Query`` hints are supported\nby a certain ``FeatureSource``. If your ``FeatureSource`` does not intend to leverage query hints, just\nreturn an empty set.\n\n* After (GeoTools 2.4 Code)::\n\n    /**\n     * By default, no Hints are supported\n     */\n    public Set getSupportedHints() {\n        return Collections.EMPTY_SET;\n    }\n\n``Query`` ``getHints``\n^^^^^^^^^^^^^^^^^^^^^^\n\nWe have added the method ``Query.getHints()`` allow users to pass in hints to control the query\nprocess.\n\nIf you have a ``Query`` implementation other than ``DefaultQuery`` you'll need to add the ``getHints()`` method.\nThe default implementation, if you don't plan to leverage hints, can just return an\nempty Hints object.\n\n* After (GeoTools 2.4 Code)::\n\n    /**\n     * Returns an empty Hints set\n     */\n    public Hints getHints() {\n        return new Hints(Collections.emptyMap());\n    }\n\nFilter\n^^^^^^\n\nWe have completed the transition to GeoAPI Filter.\n\n* Before (GeoTools 2.2 Code)::\n\n    package org.geotools.filter;\n\n    import junit.framework.TestCase;\n\n    import org.geotools.filter.LogicFilter;\n    import org.geotools.filter.FilterFactory;\n    import org.geotools.filter.Filter;\n\n    public class FilterFactoryBeforeTest extends TestCase {\n\n        public void testBefore() throws Exception {\n            FilterFactory ff = FilterFactoryFinder.createFilterFactory();\n\n            CompareFilter filter = ff.createCompareFilter(Filter.COMPARE_GREATER_THAN);\n            filter.addLeftValue( ff.createLiteralExpression(2));\n            filter.addRightValue( ff.createLiteralExpression(1));\n\n            assertTrue( filter.contrains( null ) );\n            assertTrue( filter.getFilterType() == FilterType.COMPARE_GREATER_THAN );\n            assertTrue( Filter.NONE != filter );\n        }\n    }\n\n* AFTER (Quick GeoTools 2.3 Code)::\n\n    public void testQuick() throws Exception {\n        FilterFactory ff = FilterFactoryFinder.createFilterFactory();\n\n        CompareFilter filter = ff.createCompareFilter(FilterType.COMPARE_GREATER_THAN);\n        filter.addLeftValue( ff.createLiteralExpression(2));\n        filter.addRightValue( ff.createLiteralExpression(1));\n\n        assertTrue( filter.evaluate( null ) );\n        assertTrue( Filters.getFilterType( filter ) == FilterType.COMPARE_GREATER_THAN);\n        assertTrue( Filter.INCLUDE != filter );\n    }\n\nHere are the steps to follow to update your own code:\n\n1. Substitute.\n\n   ======================================= =================================================\n   Search                                  Replace\n   ======================================= =================================================\n   ``import org.geotools.filter.Filter;``  ``import org.opengis.filter.Filter;``\n   ``import org.geotools.filter.SortBy;``  ``import org.opengis.filter.sort.SortBy;``\n   ``Filter.NONE``                         ``Filter.INCLUDE``\n   ``Filter.ALL``                          ``Filter.EXCLUDE``\n   ``AbstractFilter.COMPARE``              ``FilterType.COMPARE``\n   ``Filter.COMPARE``                      ``FilterType.COMPARE``\n   ``Filter.GEOMETRY``                     ``FilterType.GEOMETRY``\n   ``Filter.LOGIC``                        ``FilterType.LOGIC``\n   ======================================= =================================================\n\n2. ``Filterype`` is no longer supported directly.\n\n   BEFORE::\n\n      int type = filter.getFilterType();\n\n   AFTER::\n\n      int type = Filters.getFilterType( filter );\n\n3. You can no longer chain filters together.\n\n   BEFORE::\n\n     filter = filter.and( other )\n\n   AFTER::\n\n     filter = filterFactory.and( filter, other );\n\n4. We have provided an adapter for your old filter visitors.\n\n   BEFORE::\n\n     filter.accept( visitor )\n\n   AFTER::\n\n     Filters.accept( filter, visitor );\n\n3. Update your code to use the new factory methods.\n\n   BEFORE::\n\n     filter = filterFactory.createCompareFilter(FilterType.COMPARE_EQUALS)\n     filter.setLeftGeoemtry( expr1 );\n     filter.setRightGeometry( expr3 );\n\n   AFTER::\n\n     filter = FilterFactory.equals(expr1,expr);\n\n4. Literals cannot be modified once created.\n\n   BEFORE::\n\n     Literal literal = filterFactory.createLiteral();\n     literal.setLiteral( obj );\n\n   AFTER::\n\n     Filter filter = filterFactory.literal( obj );\n\n5. Property name support.\n\n   BEFORE::\n\n     filter = = filterFac.createAttributeExpression(schema, \"name\");\n\n   AFTER::\n\n     Filter filter = filterFactory.property(name);\n\nAfter (GeoTools 2.4 Code)::\n\n        public void testAfter() throws Exception {\n            FilterFactory ff = CommonFactoryFinder.getFilterFactory(null);\n\n            Expression left = ff.literal(2);\n            Expression right = ff.literal(2);\n            PropertyIsGreaterThan filter = ff.greater( left, right );\n\n            assertTrue( filter.evaluate( null ) );\n            assertTrue( Filter.INCLUDE != filter );\n        }\n\n1. Substitute\n\n\n   =================================================== =======================================================\n   Search                                              Replace\n   =================================================== =======================================================\n   ``import org.geotools.filter.FilterFactory;``       ``import org.opengis.filter.FilterFactory;``\n   ``FilterFactoryFinder.createFilterFactory()``       ``CommonFactoryFinder.getFilterFactory(null);``\n   ``import org.geotools.filter.FilterFactoryFinder;`` ``import org.geotools.factory.CommonFactoryFinder``\n   ``import org.geotools.filter.CompareFilter;``       ``import org.geoapi.spatial.BinaryComparisonOperator``\n   ``CompareFilter``                                   ``BinaryComparisonOperator``\n   =================================================== =======================================================\n\n2. Update code to use evaluate.\n\n   BEFORE::\n\n      if( filter.contains( feature ){\n\n   AFTER::\n\n      if( filter.evaluate( feature ){\n\n3. Update code to use ``instanceof`` checks.\n\n   BEFORE::\n\n       if( filter.getFilterType() == FilterType.GEOMETRY_CONTAIN ) {\n\n   AFTER::\n\n       if( filter instanceof Contains ){\n\n\nNote regarding different Geometries\n\n* GeoTools was formally limited to only JTS Geometry\n* GeoTools filter now can take either JTS Geometry or ISO Geometry\n\n* If you need to convert from one to the other::\n\n     JTSUtils.jtsToGo1(p, CRS.decode(\"EPSG:4326\"));\n\n``Feature.getParent`` removed\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``feature.getParent()`` method have been deprecated as a mistake and has now been removed.\n\n* BEFORE (GeoTools 2.0 Code)::\n\n    public void example( FeatureSource source ){\n        FeatureCollection features = source.getFeatures();\n        Iterator i = features.iterator();\n        try {\n            while( i.hasNext() ){\n                  Feature feature = (Feature) i.next();\n                  System.out.println( precentBoxed( feature ));\n            }\n        }\n        finally {\n            features.close( i );\n        }\n    }\n    private double precentBoxed( Feature feature ){\n         Envelope context = feature.getParent().getBounds();\n         Envelope bbox = feature.getBounds();\n         double boxedContext = context.width * context.height;\n         double boxed = bbox.width * bbox.height;\n         return (boxed / boxedContext) * 100.0\n    }\n\n* AFTER (GeoTools 2.2 Code)::\n\n    public void example( FeatureSource source ){\n        FeatureCollection features = source.getFeatures();\n        Iterator i = features.iterator();\n        try {\n            while( i.hasNext() ){\n                  Feature feature = (Feature) i.next();\n                  System.out.println( precentBoxed( feature, features ));\n            }\n        }\n        finally {\n            features.close( i );\n        }\n    }\n    private double precentBoxed( Feature feature, FeatureCollection parent ){\n         Envelope context = parent.getBounds();\n         Envelope bbox = feature.getBounds();\n         double boxedContext = context.width * context.height;\n         double boxed = bbox.width * bbox.height;\n         return (boxed / boxedContext) * 100.0\n    }\n\nNotes:\n\n* you will have to make API changes to pass the intended parent collection in\n\nThis is a mistake with the previous feature model (for a feature can exist in more then one\ncollection) and we apologize for the inconvenience.\n\nSplit Classification Expressions\n\nThe biggest user of the ``feature.getParent()`` mistake was the implementation of classification\nfunctions. You will now need to split up these expressions into two parts.\n\n* BEFORE (GeoTools 2.3):\n\n  1. ``equal_interval( SPEED, 12 )``\n  2. uses ``getParent()`` internally to produce classification on feature collection;\n  3. then checks which category each feature falls into\n\n  Notes:\n\n  * please note the above code depends on ``getParent()`` so it is not safe even for GeoTools 2.3 (as some features have a null parent).\n\n* AFTER (GeoTools 2.4):\n\n  Apply the aggregation function to the feature collection:\n\n  1. ``equalInterval( SPEED, 12 )``\n  2. produce classification on provided feature collection\n  3. Construct a slot expression using the resulting literal::\n\n        classify( SPEED, {0} )\n\n  4. use literal classification from step one\n\nGTRenderer\n^^^^^^^^^^\n\nThe ``GTRender`` interface was produced as a neutral ground for client code; traditional users of\n``LiteRenderer`` and ``LiteRenderer2`` are asked to move to the implementation of ``GTRenderer`` called\n``StreamingRenderer``.\n\n* BEFORE (GeoTools 2.1):\n\n  How to paint to an *outputArea* Rectangle::\n\n    LiteRenderer2 draw = new LiteRenderer2(map);\n\n    Envelope dataArea = map.getLayerBounds();\n    AffineTransform transform = renderer.worldToScreenTransform(dataArea, outputArea);\n\n    draw.paint(g2d, outputArea, transform);\n\n* QUICK (GeoTools 2.2)\n\n  How to paint to an *outputArea* Rectangle::\n\n    StreamingRenderer draw = new StreamingRenderer();\n    draw.setContext(map);\n\n    draw.paint(g2d, outputArea, map.getLayerBounds() );\n\n* BEST PRACTICE (GeoTools 2.2)::\n\n    GTRenderer draw = new StreamingRenderer();\n    draw.setContext(map);\n\n    draw.paint(g2d, outputArea, map.getLayerBounds() );\n\n  By letting your code depend only on the ``GTRenderer`` interface you can experiment with\n  alternative implementations to find the best fit.\n\nJTS\n^^^\n\nSwap moved to JTS utility class.\n\n* BEFORE (GeoTools 2.1)::\n\n    import org.geotools.geometry.JTS;\n    import org.geotools.geometry.JTS.ReferencedEnvelope\n\n* AFTER (GeoTools 2.2)::\n\n    import org.geotools.geometry.jts.JTS;\n    import org.geotools.geometry.jts.ReferencedEnvelope\n\nJTS to Shape converters\n^^^^^^^^^^^^^^^^^^^^^^^\n\nSwap to moved Renderer JTS-to-Shape converters.\n\n* BEFORE (GeoTools 2.3)::\n\n    import org.geotools.renderer.lite.LiteShape;\n    import org.geotools.renderer.lite.LiteShape2;\n    import org.geotools.renderer.lite.PackedLineIterator;\n    import org.geotools.renderer.lite.PointIterator;\n    import org.geotools.renderer.lite.PolygonIterator;\n    import org.geotools.renderer.lite.LineIterator;\n    import org.geotools.renderer.lite.LineIterator2;\n    import org.geotools.renderer.lite.Decimator;\n    import org.geotools.renderer.lite.AbstractLiteIterator;\n    import org.geotools.renderer.lite.TransformedShape;\n    import org.geotools.renderer.lite.LiteCoordinateSequence;\n    import org.geotools.renderer.lite.LiteCoordinateSequenceFactory;\n    import org.geotools.renderer.lite.LiteCoordinateSequence;\n\n* AFTER (GeoTools 2.4)::\n\n    import org.geotools.geometry.jts.LiteShape;\n    import org.geotools.geometry.jts.LiteShape2;\n    import org.geotools.geometry.jts.PackedLineIterator;\n    import org.geotools.geometry.jts.PointIterator;\n    import org.geotools.geometry.jts.PolygonIterator;\n    import org.geotools.geometry.jts.LineIterator;\n    import org.geotools.geometry.jts.LineIterator2;\n    import org.geotools.geometry.jts.Decimator;\n    import org.geotools.geometry.jts.AbstractLiteIterator;\n    import org.geotools.geometry.jts.TransformedShape;\n    import org.geotools.geometry.jts.LiteCoordinateSequence;\n    import org.geotools.geometry.jts.LiteCoordinateSequenceFactory;\n    import org.geotools.geometry.jts.LiteCoordinateSequence;\n\nCoverage utility classes\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nSwap to moved Coverage utility classes.\n\n* BEFORE (GeoTools 2.3)::\n\n    import org.geotools.data.coverage.grid.*\n    import org.geotools.image.imageio.*\n\n  Wrapping a ``GridCoverage`` into a feature in 2.3::\n\n    org.geotools.data.DataUtilities#wrapGc(GridCoverage gridCoverage)\n    org.geotools.data.DataUtilities#wrapGcReader(\n                AbstractGridCoverage2DReader gridCoverageReader,\n                GeneralParameterValue[] params)\n\n  ``GridCoverageExchange`` Utility classes in 2.3::\n\n    org.geotools.data.coverage.grid.file.*\n    org.geotools.data.coverage.grid.stream .*\n\n  ``org.geotools.coverage.io`` classes in 2.3::\n\n    org.geotools.coverage.io.AbstractGridCoverageReader.java,\n    org.geotools.coverage.io.AmbiguousMetadataException.java,\n    org.geotools.coverage.io.ExoreferencedGridCoverageReader.java,\n    org.geotools.coverage.io.MetadataBuilder.java,\n    org.geotools.coverage.io.MetadataException.java,\n    org.geotools.coverage.io.MissingMetadataException.java\n\n* AFTER (GeoTools 2.4)::\n\n    import org.geotools.coverage.grid.io.*\n    import  org.geotools.coverage.grid.io.imageio.*\n\n  Wrapping a ``GridCoverage`` into a feature in 2.4::\n\n    org.geotools.referencing.util.coverage.CoverageUtilities #wrapGc(GridCoverage gridCoverage)\n    org.geotools.referencing.util.coverage.CoverageUtilities #wrapGcReader(\n                AbstractGridCoverage2DReader gridCoverageReader,\n                GeneralParameterValue[] params)\n\n  ``GridCoverageExchange`` Utility classes in 2.4.\n\n  The classes have been dismissed since apparently nobody was using. If needed\n  we can reintroduce them as deprecated.\n\n  ``org.geotools.coverage.io`` classes in 2.4.\n\n  These classes have been moved to ``spike/exoreferenced`` waiting for Martin to review and merge into\n  ``org.geotools.coverage.grid.io`` package\n\n``spatialschema``\n^^^^^^^^^^^^^^^^^\n\nRenamed ``spatialschema`` to ``geometry``.\n\n* Do you know what ``spatialschema`` was? We did not find it clear either.\n\n  Renamed to ``geometry``?\n\n* BEFORE::\n\n    import org.opengis.spatialschema.geometry;\n    import org.opengis.spatialschema.geometry.aggregate;\n    import org.opengis.spatialschema.geometry.complex;\n    import org.opengis.spatialschema.geometry.geometry;\n    import org.opengis.spatialschema.geometry.primitive;\n\n* AFTER::\n\n    import org.opengis.geometry;\n    import org.opengis.geometry.aggregate;\n    import org.opengis.geometry.complex;\n    import org.opengis.geometry.coordinate;\n    import org.opengis.geometry.primitive;\n\nWorld Image\n^^^^^^^^^^^\n\nSets of World Image extensions. Changed from a single String to a\n``Set<String>`` .. because\none ``wld`` is not enough?\n\n* BEFORE::\n\n    private File toWorldFile(String fileRoot, String fileExt){\n        File worldFile = new File( fileRoot + \".wld\" );\n        if( worldFile.exists() ){\n            return worldFile;\n        }\n        String ext = WorldImageFormat.getWorldExtension( fileExt );\n        File otherWorldFile = new File( fileRoot + ext );\n        if( otherWorldFile.exists() ){\n            return otherWorldFile;\n        }\n        return null;\n    }\n\n* AFTER::\n\n     private File toWorldFile(String fileRoot, String fileExt){\n        Set<String> other = WorldImageFormat.getWorldExtension( fileExt );\n        File worldFile = new File( fileRoot + \".wld\" );\n        if( worldFile.exists() ){\n            return worldFile;\n        }\n        for( String ext : other ){\n            File otherWorldFile = new File( fileRoot + ext );\n            if( otherWorldFile.exists() ){\n                return otherWorldFile;\n            }\n        }\n        return null;\n    }\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.data.jdbc.datasource;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Map;\nimport javax.sql.DataSource;\nimport org.geotools.data.DataAccessFactory.Param;\nimport org.geotools.data.DataSourceException;\nimport org.geotools.data.Parameter;\nimport org.geotools.util.factory.GeoTools;\n\n/**\n * A datasource factory SPI doing JDNI lookups\n *\n * @author Administrator\n */\npublic class JNDIDataSourceFactory extends AbstractDataSourceFactorySpi {\n\n    public static final Param DSTYPE =\n            new Param(\n                    \"dstype\",\n                    String.class,\n                    \"Must be JNDI\",\n                    false,\n                    null,\n                    Collections.singletonMap(Parameter.LEVEL, \"program\"));\n\n    public static final Param JNDI_REFNAME =\n            new Param(\n                    \"jdniReferenceName\",\n                    String.class,\n                    \"The path where the connection pool must be located\",\n                    true);\n\n    private static final Param[] PARAMS = {DSTYPE, JNDI_REFNAME};\n\n    @Override\n    public DataSource createDataSource(Map<String, ?> params) throws IOException {\n        return createNewDataSource(params);\n    }\n\n    @Override\n    public boolean canProcess(Map<String, ?> params) {\n        return super.canProcess(params) && \"JNDI\".equals(params.get(\"dstype\"));\n    }\n\n    @Override\n    public DataSource createNewDataSource(Map<String, ?> params) throws IOException {\n        String refName = (String) JNDI_REFNAME.lookUp(params);\n        try {\n            return (DataSource) GeoTools.getInitialContext().lookup(refName);\n        } catch (Exception e) {\n            throw new DataSourceException(\"Could not find the specified data source in JNDI\", e);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return \"A JNDI based DataSource locator. Provide the JDNI location of a DataSource object in order to make it work\";\n    }\n\n    @Override\n    public Param[] getParametersInfo() {\n        return PARAMS;\n    }\n\n    /** Make sure a JNDI context is available */\n    @Override\n    public boolean isAvailable() {\n        try {\n            GeoTools.getInitialContext();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2015, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\n\npackage org.geotools.jdbc;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.naming.Context;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport org.geotools.data.DataStore;\nimport org.geotools.util.factory.GeoTools;\n\n/**\n * Abstract implementation of DataStoreFactory for jdbc datastores which obtain a JNDI connection.\n *\n * <p>Subclasses should not need to override any methods, only just call the parent constructor\n * passing in the non JNDI datastore factory to delegate to.\n *\n * @author Christian Mueller\n */\n// temporary work around, the factory parameters map will be fixed separately\n@SuppressWarnings(\"unchecked\")\npublic abstract class JDBCJNDIDataStoreFactory extends JDBCDataStoreFactory {\n\n    public static final String J2EERootContext = \"java:comp/env/\";\n    /** JNDI data source name */\n    public static final Param JNDI_REFNAME =\n            new Param(\n                    \"jndiReferenceName\",\n                    String.class,\n                    \"JNDI data source\",\n                    true,\n                    J2EERootContext + \"jdbc/mydatabase\");\n\n    /** regular datastore factory to delegate to. */\n    protected JDBCDataStoreFactory delegate;\n\n    protected JDBCJNDIDataStoreFactory(JDBCDataStoreFactory delegate) {\n        this.delegate = delegate;\n    }\n\n    /**\n     * Override which explicitly returns null because with a JNDI connection the driver is not known\n     * ahead of time.\n     */\n    @Override\n    protected String getDriverClassName() {\n        return null;\n    }\n\n    /**\n     * Override which explicitly returns null, validation queries are not supported, my be part of\n     * the external data source configuration\n     */\n    @Override\n    protected String getValidationQuery() {\n        return null;\n    }\n\n    /**\n     * Override which explicitly returns null since there is no jdbc url, the connection is\n     * identified by the JNDI name.\n     */\n    @Override\n    protected String getJDBCUrl(Map<String, ?> params) throws IOException {\n        return null;\n    }\n\n    /** Override to create the datasource from the external JNDI conection. */\n    @Override\n    protected DataSource createDataSource(Map<String, ?> params, SQLDialect dialect)\n            throws IOException {\n        String jndiName = (String) JNDI_REFNAME.lookUp(params);\n        if (jndiName == null) throw new IOException(\"Missing \" + JNDI_REFNAME.description);\n\n        Context ctx = null;\n        DataSource ds = null;\n\n        try {\n            ctx = GeoTools.getInitialContext();\n        } catch (NamingException e) {\n            throw new RuntimeException(e);\n        }\n\n        try {\n            ds = (DataSource) ctx.lookup(jndiName);\n        } catch (NamingException e1) {\n            // check if the user did not specify \"java:comp/env\"\n            // and this code is running in a J2EE environment\n            try {\n                if (jndiName.startsWith(J2EERootContext) == false) {\n                    ds = (DataSource) ctx.lookup(J2EERootContext + jndiName);\n                    // success --> issue a waring\n                    Logger.getLogger(this.getClass().getName())\n                            .log(\n                                    Level.WARNING,\n                                    \"Using \"\n                                            + J2EERootContext\n                                            + jndiName\n                                            + \" instead of \"\n                                            + jndiName\n                                            + \" would avoid an unnecessary JNDI lookup\");\n                }\n            } catch (NamingException e2) {\n                // do nothing, was only a try\n            }\n        }\n\n        if (ds == null) throw new IOException(\"Cannot find JNDI data source: \" + jndiName);\n        else return ds;\n    }\n\n    /**\n     * Determines if the datastore is available.\n     *\n     * <p>Check in an Initial Context is available, that is all what can be done Checking for the\n     * right jdbc jars in the classpath is not possible here\n     */\n    @Override\n    public boolean isAvailable() {\n        try {\n            GeoTools.getInitialContext();\n            return true;\n        } catch (NamingException e) {\n            return false;\n        }\n    }\n\n    /** Override to omit all those parameters which define the creation of the connection. */\n    @Override\n    protected void setupParameters(Map<String, Object> parameters) {\n        parameters.put(\n                DBTYPE.key,\n                new Param(\n                        DBTYPE.key,\n                        DBTYPE.type,\n                        DBTYPE.description,\n                        DBTYPE.required,\n                        getDatabaseID()));\n        parameters.put(JNDI_REFNAME.key, JNDI_REFNAME);\n        parameters.put(SCHEMA.key, SCHEMA);\n        parameters.put(NAMESPACE.key, NAMESPACE);\n        parameters.put(FETCHSIZE.key, FETCHSIZE);\n        parameters.put(BATCH_INSERT_SIZE.key, BATCH_INSERT_SIZE);\n        parameters.put(EXPOSE_PK.key, EXPOSE_PK);\n        parameters.put(PK_METADATA_TABLE.key, PK_METADATA_TABLE);\n        parameters.put(SQL_ON_BORROW.key, SQL_ON_BORROW);\n        parameters.put(SQL_ON_RELEASE.key, SQL_ON_RELEASE);\n        parameters.put(CALLBACK_FACTORY.key, CALLBACK_FACTORY);\n    }\n\n    @Override\n    protected String getDatabaseID() {\n        return delegate.getDatabaseID();\n    }\n\n    @Override\n    public String getDisplayName() {\n        return delegate.getDisplayName() + \" (JNDI)\";\n    }\n\n    @Override\n    public String getDescription() {\n        return delegate.getDescription() + \" (JNDI)\";\n    }\n\n    @Override\n    protected JDBCDataStore createDataStoreInternal(JDBCDataStore dataStore, Map<String, ?> params)\n            throws IOException {\n        return delegate.createDataStoreInternal(dataStore, params);\n    }\n\n    @Override\n    public DataStore createNewDataStore(Map<String, ?> params) throws IOException {\n        return delegate.createNewDataStore(params);\n    }\n\n    @Override\n    public Map<java.awt.RenderingHints.Key, ?> getImplementationHints() {\n        return delegate.getImplementationHints();\n    }\n\n    @Override\n    protected SQLDialect createSQLDialect(JDBCDataStore dataStore) {\n        return delegate.createSQLDialect(dataStore);\n    }\n\n    @Override\n    protected boolean checkDBType(Map<String, ?> params) {\n        return delegate.checkDBType(params);\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- =======================================================================\n        Maven Project Configuration File\n\n        The Geotools Project\n            http://www.geotools.org/\n\n        Version: $Id$\n     ======================================================================= -->\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0                                http://maven.apache.org/maven-v4_0_0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <parent>\n    <groupId>org.geotools</groupId>\n    <artifactId>library</artifactId>\n    <version>26-SNAPSHOT</version>\n  </parent>\n\n  <!-- =========================================================== -->\n  <!--     Module Description                                      -->\n  <!-- =========================================================== -->\n  <groupId>org.geotools</groupId>\n  <artifactId>gt-metadata</artifactId>\n  <packaging>jar</packaging>\n\n  <name>Metadata</name>\n  <description>Contains implementations of metadata and some core utilities classes.</description>\n\n  <licenses>\n    <license>\n      <name>Lesser General Public License (LGPL)</name>\n      <url>http://www.gnu.org/copyleft/lesser.txt</url>\n      <distribution>repo</distribution>\n    </license>\n  </licenses>\n\n  <!-- =========================================================== -->\n  <!--     Developers and Contributors                             -->\n  <!-- =========================================================== -->\n  <developers>\n    <developer>\n      <id>jive</id>\n      <name>Jody Garnett</name>\n      <email>jive@users.sourceforge.net</email>\n      <organization>Refractions Research</organization>\n      <roles>\n        <role>Module Maintainer</role>\n        <role>Java Developer</role>\n      </roles>\n    </developer>\n  </developers>\n\n  <contributors>\n    <contributor>\n      <name>Toura\u00efvane</name>\n      <organization>Institut de Recherche pour le D\u00e9veloppement (IRD)</organization>\n      <roles>\n        <role>Java developper</role>\n      </roles>\n    </contributor>\n    <contributor>\n      <name>Martin Desruisseaux</name>\n      <email>desruisseaux@users.sourceforge.net</email>\n      <organization>Geomatys</organization>\n      <organizationUrl>http://www.geomatys.fr/</organizationUrl>\n      <roles>\n        <role>Retired Module Maintainer</role>\n        <role>Retired Java Developer</role>\n      </roles>\n      <timezone>+1</timezone>\n    </contributor>\n    <contributor>\n      <name>C\u00e9dric Brian\u00e7on</name>\n      <email>cedric.briancon@geomatys.fr</email>\n      <organization>Geomatys</organization>\n      <roles>\n        <role>Java developper</role>\n      </roles>\n      <timezone>+1</timezone>\n    </contributor>\n  </contributors>\n  <properties>\n    <moduleIdentifier>org.geotools.metadata</moduleIdentifier>\n  </properties>\n\n  <!-- =========================================================== -->\n  <!--     Dependency Management                                   -->\n  <!-- =========================================================== -->\n  <dependencies>\n    <!-- NOTE: The metadata module does not depend on JTS. -->\n    <dependency>\n      <groupId>org.geotools</groupId>\n      <artifactId>gt-opengis</artifactId>\n      <version>${project.version}</version>\n    </dependency>\n    <!--\n      The following is required only for compilation.  It should not be included\n      in distribution, unless the user really want to use Apache commons logging\n      (in which case he should put this dependency explicitly on the classpath).\n    -->\n    <dependency>\n      <groupId>javax.media</groupId>\n      <artifactId>jai_core</artifactId>\n      <!-- The version number is specified in the parent POM. -->\n    </dependency>\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <!-- The version number is specified in the parent POM. -->\n      <scope>provided</scope>\n      <!-- Not required for default execution. -->\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>org.locationtech.jts</groupId>\n      <artifactId>jts-core</artifactId>\n      <!-- The version number is specified in the parent POM. -->\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <scope>provided</scope>\n      <!-- Not required for default execution. -->\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-lang3</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.geotools.ogc</groupId>\n      <artifactId>net.opengis.ows</artifactId>\n      <version>${project.version}</version>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <resources>\n      <resource>\n        <directory>${basedir}/src/main/resources</directory>\n      </resource>\n      <resource>\n        <filtering>true</filtering>\n        <directory>${basedir}/src/main/properties</directory>\n      </resource>\n    </resources>\n  </build>\n\n</project>\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2007-2016, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.util.factory;\n\nimport java.awt.RenderingHints;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.jar.Manifest;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.xml.parsers.SAXParser;\nimport org.geotools.metadata.i18n.ErrorKeys;\nimport org.geotools.metadata.i18n.Errors;\nimport org.geotools.util.Arguments;\nimport org.geotools.util.Classes;\nimport org.geotools.util.NullEntityResolver;\nimport org.geotools.util.PreventLocalEntityResolver;\nimport org.geotools.util.Utilities;\nimport org.geotools.util.Version;\nimport org.geotools.util.logging.LoggerFactory;\nimport org.geotools.util.logging.Logging;\nimport org.xml.sax.EntityResolver;\n\n/**\n * Static methods relative to the global GeoTools configuration. GeoTools can be configured in a\n * system-wide basis through {@linkplain System#getProperties system properties}, some of them are\n * declared as {@link String} constants in this class.\n *\n * <p>There are many aspects to the configuration of GeoTools:\n *\n * <ul>\n *   <li>Default Settings: Are handled as the Hints returned by {@link #getDefaultHints()}, the\n *       default values can be provided in application code, or specified using system properties.\n *   <li>Integration JNDI: Telling the GeoTools library about the facilities of an application, or\n *       application container takes several forms. This class provides the {@link\n *       #init(InitialContext)} method allowing to tell GeoTools about the JNDI context to use.\n *   <li>Integration Plugins: If hosting GeoTools in a alternate plugin system such as Spring or\n *       OSGi, application may needs to hunt down the {@code FactoryFinder}s and register additional\n *       \"Factory Iterators\" for GeoTools to search using the {@link #addFactoryIteratorProvider}\n *       method.\n * </ul>\n *\n * @since 2.4\n * @version $Id$\n * @author Jody Garnett\n * @author Martin Desruisseaux\n */\npublic final class GeoTools {\n    /** Properties about this geotools build */\n    private static final Properties PROPS;\n\n    static {\n        PROPS = loadProperites(\"GeoTools.properties\");\n    }\n\n    @SuppressWarnings(\"PMD.UseTryWithResources\") // stream may be null\n    private static Properties loadProperites(String resource) {\n        Properties props = new Properties();\n        InputStream stream = GeoTools.class.getResourceAsStream(resource);\n        if (stream != null) {\n            try {\n                props.load(stream);\n            } catch (IOException ignore) {\n            } finally {\n                try {\n                    stream.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n\n        return props;\n    }\n\n    /** The current GeoTools version. The separator character must be the dot. */\n    private static final Version VERSION = new Version(PROPS.getProperty(\"version\", \"20-SNAPSHOT\"));\n\n    /** The version control (svn) revision at which this version of geotools was built. */\n    private static final String BUILD_REVISION;\n\n    static {\n        BUILD_REVISION = PROPS.getProperty(\"build.revision\", \"-1\");\n    }\n\n    /** The timestamp at which this version of geotools was built. */\n    private static final String BUILD_TIMESTAMP = PROPS.getProperty(\"build.timestamp\", \"\");\n\n    /**\n     * Object to inform about system-wide configuration changes. We use the Swing utility listener\n     * list since it is lightweight and thread-safe. Note that it doesn't involve any dependency to\n     * the remaining of Swing library.\n     */\n    private static final EventListenerList LISTENERS = new EventListenerList();\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#CRS_AUTHORITY_EXTRA_DIRECTORY CRS_AUTHORITY_EXTRA_DIRECTORY}\n     * hint.\n     *\n     * @see Hints#CRS_AUTHORITY_EXTRA_DIRECTORY\n     * @see #getDefaultHints\n     */\n    public static final String CRS_AUTHORITY_EXTRA_DIRECTORY =\n            \"org.geotools.referencing.crs-directory\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#EPSG_DATA_SOURCE EPSG_DATA_SOURCE} hint.\n     *\n     * @see Hints#EPSG_DATA_SOURCE\n     * @see #getDefaultHints\n     */\n    public static final String EPSG_DATA_SOURCE = \"org.geotools.referencing.epsg-datasource\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER\n     * FORCE_LONGITUDE_FIRST_AXIS_ORDER} hint.\n     *\n     * <p>This setting can provide a transition path for projects expecting a (<var>longitude</var>,\n     * <var>latitude</var>) axis order on a system-wide level. Application developpers can set the\n     * default value as below:\n     *\n     * <blockquote>\n     *\n     * <pre>\n     * System.setProperty(FORCE_LONGITUDE_FIRST_AXIS_ORDER, \"true\");\n     * </pre>\n     *\n     * </blockquote>\n     *\n     * Note that this system property applies mostly to the default EPSG factory. Most other\n     * factories ({@code \"CRS\"}, {@code \"AUTO\"}, <cite>etc.</cite>) don't need this property since\n     * they use (<var>longitude</var>, <var>latitude</var>) axis order by design.\n     *\n     * @see Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER\n     * @see #getDefaultHints\n     */\n    public static final String FORCE_LONGITUDE_FIRST_AXIS_ORDER =\n            \"org.geotools.referencing.forceXY\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints# ENTITY_RESOLVER} hint.\n     *\n     * <p>This setting specifies the XML Entity resolver to be used when configuring a SAXParser\n     *\n     * @see Hints#ENTITY_RESOLVER\n     * @see #getDefaultHints\n     */\n    public static final String ENTITY_RESOLVER = \"org.xml.sax.EntityResolver\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints# RESAMPLE_TOLERANCE} hint.\n     *\n     * <p>This setting specifies the tolerance used when linearizing warp transformation into\n     * piecewise linear ones, by default it is 0.333 pixels\n     *\n     * @see Hints#RESAMPLE_TOLERANCE\n     * @see #getDefaultHints\n     */\n    public static final String RESAMPLE_TOLERANCE = \"org.geotools.referencing.resampleTolerance\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#LOCAL_DATE_TIME_HANDLING} hint.\n     *\n     * <p>This setting specifies if dates shall be treated as local dates ignoring time zones.\n     *\n     * @see Hints#LOCAL_DATE_TIME_HANDLING\n     * @see #getDefaultHints\n     * @since 15.0\n     */\n    public static final String LOCAL_DATE_TIME_HANDLING = \"org.geotools.localDateTimeHandling\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#DATE_TIME_FORMAT_HANDLING} hint.\n     *\n     * <p>This setting specifies if GML 2 temporal data shall be formatted using same approach as\n     * GML 3+.\n     *\n     * @see Hints#DATE_TIME_FORMAT_HANDLING\n     * @see #getDefaultHints\n     * @since 21.0\n     */\n    public static final String DATE_TIME_FORMAT_HANDLING = \"org.geotools.dateTimeFormatHandling\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#ENCODE_EWKT} hint.\n     *\n     * <p>This setting specifies if geometries with {@link\n     * org.opengis.referencing.crs.CoordinateReferenceSystem} in the user data shall be encoded as\n     * EWKT or not.\n     *\n     * @see Hints#ENCODE_EWKT\n     * @see #getDefaultHints\n     * @since 19.0\n     */\n    public static final String ENCODE_WKT = \"org.geotools.ecql.ewkt\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#HTTP_CLIENT} hint.\n     *\n     * <p>This setting specifies whether we wan't to use a special http client\n     *\n     * @see Hints#HTTP_CLIENT\n     * @see #getDefaultHints\n     * @since 25.0\n     */\n    public static final String HTTP_CLIENT = \"org.geotools.http.client\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#HTTP_LOGGING} hint.\n     *\n     * <p>This setting specifies whether we want to log all http requests.\n     *\n     * @see Hints#HTTP_LOGGING\n     * @see #getDefaultHints\n     * @since 25.0\n     */\n    public static final String HTTP_LOGGING = \"org.geotools.http.logging\";\n\n    /** The initial context. Will be created only when first needed. */\n    private static InitialContext context;\n\n    /**\n     * Class loaders to be added to the list in ${link {@link FactoryRegistry#getClassLoaders()}}\n     * which are used to look-up plug-ins. Class loaders are added via {@link\n     * #addClassLoader(ClassLoader)}\n     */\n    private static final Set<ClassLoader> addedClassLoaders =\n            Collections.synchronizedSet(new HashSet<>());\n\n    /**\n     * The bindings between {@linkplain System#getProperties system properties} and a hint key.\n     *\n     * <p>This registry is used by {@link #scanForSystemHints} to evaluate which System properties\n     * are present using this map's keys as System property names and its mapped value to resolve\n     * the System property value the correct value type/\n     */\n    private static final Map<String, RenderingHints.Key> BINDINGS;\n\n    static {\n        Map<String, RenderingHints.Key> bindings = new HashMap<>();\n        bind(ENCODE_WKT, Hints.ENCODE_EWKT, bindings);\n        bind(CRS_AUTHORITY_EXTRA_DIRECTORY, Hints.CRS_AUTHORITY_EXTRA_DIRECTORY, bindings);\n        bind(EPSG_DATA_SOURCE, Hints.EPSG_DATA_SOURCE, bindings);\n        bind(FORCE_LONGITUDE_FIRST_AXIS_ORDER, Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, bindings);\n        bind(ENTITY_RESOLVER, Hints.ENTITY_RESOLVER, bindings);\n        bind(RESAMPLE_TOLERANCE, Hints.RESAMPLE_TOLERANCE, bindings);\n        bind(LOCAL_DATE_TIME_HANDLING, Hints.LOCAL_DATE_TIME_HANDLING, bindings);\n        bind(DATE_TIME_FORMAT_HANDLING, Hints.DATE_TIME_FORMAT_HANDLING, bindings);\n        bind(HTTP_CLIENT, Hints.HTTP_CLIENT, bindings);\n        bind(HTTP_LOGGING, Hints.HTTP_LOGGING, bindings);\n        BINDINGS = Collections.unmodifiableMap(bindings);\n    }\n\n    /**\n     * Binds the specified {@linkplain System#getProperty(String) system property} to the specified\n     * key. Only one key can be bound to a given system property. However the same key can be binded\n     * to more than one system property names, in which case the extra system property names are\n     * aliases.\n     *\n     * @param property The system property.\n     * @param key The key to bind to the system property.\n     * @param bindings The target registry mapping System properties to RenderingHints\n     * @throws IllegalArgumentException if an other key is already bounds to the given system\n     *     property.\n     */\n    private static void bind(\n            final String property,\n            final RenderingHints.Key key,\n            Map<String, RenderingHints.Key> bindings) {\n        final RenderingHints.Key old = bindings.putIfAbsent(property, key);\n        if (old != null) {\n            throw new IllegalArgumentException(\n                    Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, \"property\", property));\n        }\n    }\n\n    /** Do not allow instantiation of this class. */\n    private GeoTools() {}\n\n    /**\n     * Returns summary information about GeoTools and the current environment. Calls {@linkplain\n     * #getEnvironmentInfo()} followed by {@linkplain #getGeoToolsJarInfo()} and concatenates their\n     * results.\n     *\n     * @return requested information as a string\n     */\n    public static String getAboutInfo() {\n        final StringBuilder sb = new StringBuilder();\n\n        sb.append(getEnvironmentInfo());\n        sb.append(String.format(\"%n\"));\n        sb.append(getGeoToolsJarInfo());\n\n        return sb.toString();\n    }\n\n    /**\n     * Returns summary information about the GeoTools version and the host environment.\n     *\n     * @return information as a String\n     */\n    public static String getEnvironmentInfo() {\n        final String newline = String.format(\"%n\");\n\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"GeoTools version \").append(getVersion().toString());\n        if (sb.toString().endsWith(\"SNAPSHOT\")) {\n            sb.append(\" (built from r\").append(getBuildRevision().toString()).append(\")\");\n        }\n\n        sb.append(newline).append(\"Java version: \");\n        sb.append(System.getProperty(\"java.version\"));\n\n        sb.append(newline).append(\"Operating system: \");\n        sb.append(System.getProperty(\"os.name\"))\n                .append(' ')\n                .append(System.getProperty(\"os.version\"));\n\n        return sb.toString();\n    }\n\n    /**\n     * Returns the names of the GeoTools jars on the classpath.\n     *\n     * @return list of jars as a formatted string\n     */\n    public static String getGeoToolsJarInfo() {\n        final StringBuilder sb = new StringBuilder();\n        final String newline = String.format(\"%n\");\n        final String indent = \"    \";\n\n        sb.append(\"GeoTools jars on classpath:\");\n        for (String jarName : getGeoToolsJars()) {\n            sb.append(newline).append(indent).append(jarName);\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * A helper method for {@linkplain #getGeoToolsJarInfo} which scans the classpath looking for\n     * GeoTools jars matching the current version.\n     *\n     * @return a list of jar names\n     */\n    private static List<String> getGeoToolsJars() {\n        final Pattern pattern = Pattern.compile(\".*\\\\/\" + getVersion() + \"\\\\/(gt-.*jar$)\");\n        final List<String> jarNames = new ArrayList<>();\n\n        String pathSep = System.getProperty(\"path.separator\");\n        String classpath = System.getProperty(\"java.class.path\");\n        StringTokenizer st = new StringTokenizer(classpath, pathSep);\n        while (st.hasMoreTokens()) {\n            String path = st.nextToken();\n            Matcher matcher = pattern.matcher(path);\n            if (matcher.find()) {\n                jarNames.add(matcher.group(1));\n            }\n        }\n\n        Collections.sort(jarNames);\n        return jarNames;\n    }\n\n    /**\n     * Reports back the vcs revision at which the version of GeoTools was built.\n     *\n     * @return The svn revision.\n     */\n    public static String getBuildRevision() {\n        return BUILD_REVISION;\n    }\n\n    /**\n     * Reports back the timestamp at which the version of GeoTools of built.\n     *\n     * @return The build timestamp.\n     */\n    public static String getBuildTimestamp() {\n        return BUILD_TIMESTAMP;\n    }\n\n    /**\n     * Returns the raw properties object containing all properties about this GeoTools build.\n     *\n     * <p>Example from the 14.3 release:\n     *\n     * <ul>\n     *   <li>version=14.3\n     *   <li>build.revision=2298d56000bef6f526b521a480316ea544c74571\n     *   <li>build.branch=rel_14.3\n     *   <li>build.timestamp=21-Mar-2016 21:30\n     * </ul>\n     */\n    public static Properties getBuildProperties() {\n        Properties props = new Properties();\n        props.putAll(PROPS);\n        return props;\n    }\n\n    /**\n     * Reports back the version of GeoTools being used.\n     *\n     * @return The current GeoTools version.\n     */\n    public static Version getVersion() {\n        return VERSION;\n    }\n\n    /**\n     * Lookup version for provided class.\n     *\n     * <p>Version number is determined by either:\n     *\n     * <ul>\n     *   <li>Use of jar naming convention, matching jars such as jts-1.13.jar\n     *   <li>Use of MANIFEST.MF (to check Implementation-Version, Project-Version)\n     *   <li>\n     *   <li>To assist\n     *\n     * @return Version (or null if unavailable)\n     */\n    public static Version getVersion(Class<?> type) {\n        final URL classLocation = classLocation(type);\n        String path = classLocation.toString();\n\n        // try and extract from maven jar naming convention\n        if (classLocation.getProtocol().equalsIgnoreCase(\"jar\")) {\n            String jarVersion = jarVersion(path);\n            if (jarVersion != null) {\n                return new Version(jarVersion);\n            }\n            // try manifest\n            try {\n                URL manifestLocation = manifestLocation(path);\n                Manifest manifest = new Manifest();\n                try (InputStream content = manifestLocation.openStream()) {\n                    manifest.read(content);\n                }\n                for (String attribute :\n                        new String[] {\n                            \"Implementation-Version\", \"Project-Version\", \"Specification-Version\"\n                        }) {\n                    String value = manifest.getMainAttributes().getValue(attribute);\n                    if (value != null) {\n                        return new Version(value);\n                    }\n                }\n            } catch (IOException e) {\n                // unavailable\n            }\n        }\n        String name = type.getName();\n        if (name.startsWith(\"org.geotools\") || name.startsWith(\"org.opengis\")) {\n            return GeoTools.getVersion();\n        }\n        return null;\n    }\n\n    /**\n     * Class location.\n     *\n     * @return class location\n     */\n    static URL classLocation(Class<?> type) {\n        return type.getResource(type.getSimpleName() + \".class\");\n    }\n\n    /**\n     * Determine jar version from static analysis of classLocation path.\n     *\n     * @return jar version, or null if unknown\n     */\n    static String jarVersion(String classLocation) {\n        if (classLocation.startsWith(\"jar:\") || classLocation.contains(\".jar!\")) {\n            String location = classLocation.substring(0, classLocation.lastIndexOf(\"!\") + 1);\n            String file = location.substring(location.lastIndexOf(File.pathSeparator) + 1);\n            int dash = file.lastIndexOf(\"-\");\n            int dot = file.lastIndexOf(\".jar\");\n            if (dash != -1 && dot != -1) {\n                String version = file.substring(dash + 1, dot);\n                if (version.startsWith(\"RC\") || version.equals(\"SNAPSHOT\")) {\n                    dash = file.lastIndexOf(\"-\", dash - 1);\n                    version = file.substring(dash + 1, dot);\n                }\n                return version;\n            }\n        }\n        // handle custom protocols such as jboss \"vfs:\" or OSGi \"resource\"\n        if (classLocation.contains(\".jar/\")) {\n            String location = classLocation.substring(0, classLocation.indexOf(\".jar/\") + 4);\n            int dash = location.lastIndexOf(\"-\");\n            int dot = location.lastIndexOf(\".jar\");\n\n            if (dash != -1 && dot != -1) {\n                return location.substring(dash + 1, dot);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Generate URL of MANIFEST.MF file for provided class location.\n     *\n     * @return MANIFEST.MF location, or null if unknown\n     */\n    static URL manifestLocation(String classLocation) {\n        URL url;\n        if (classLocation.startsWith(\"jar:\")) {\n            try {\n                url =\n                        new URL(\n                                classLocation.substring(0, classLocation.lastIndexOf(\"!\") + 1)\n                                        + \"/META-INF/MANIFEST.MF\");\n                return url;\n            } catch (MalformedURLException e) {\n                return null;\n            }\n        }\n        // handle custom protocols such as jboss \"vfs:\" or OSGi \"resource\"\n        if (classLocation.contains(\".jar/\")) {\n            String location = classLocation.substring(0, classLocation.indexOf(\".jar/\") + 4);\n            try {\n                url = new URL(location + \"/META-INF/MANIFEST.MF\");\n                return url;\n            } catch (MalformedURLException e) {\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Lookup the MANIFEST.MF for the provided class.\n     *\n     * <p>This can be used to quickly verify packaging information.\n     *\n     * @return MANIFEST.MF contents, please note contents may be empty when running from IDE\n     */\n    public static Manifest getManifest(Class<?> type) {\n        final URL classLocation = classLocation(type);\n        Manifest manifest = new Manifest();\n\n        URL manifestLocation = manifestLocation(classLocation.toString());\n        if (manifestLocation != null) {\n            try {\n                try (InputStream content = manifestLocation.openStream()) {\n                    manifest.read(content);\n                }\n            } catch (IOException ignore) {\n            }\n        }\n        if (manifest.getMainAttributes().isEmpty()) {\n            // must be running in IDE\n            String name = type.getName();\n            if (name.startsWith(\"org.geotools\")\n                    || name.startsWith(\"org.opengis\")\n                    || name.startsWith(\"net.opengis\")) {\n                String generated =\n                        \"Manifest-Version: 1.0\\n\" + \"Project-Version: \" + getVersion() + \"\\n\";\n\n                try {\n                    manifest.read(new ByteArrayInputStream(generated.getBytes()));\n                } catch (IOException e) {\n                }\n            }\n        }\n        return manifest;\n    }\n    /**\n     * Sets the global {@linkplain LoggerFactory logger factory}.\n     *\n     * <p>This method is the same as {@code Logging.GEOTOOLS.setLoggerFactory(factory)}. GeoTools\n     * ships with support for <A\n     * HREF=\"http://jakarta.apache.org/commons/logging/\">Commons-logging</A> and <A\n     * HREF=\"http://logging.apache.org/log4j/\">log4j</A>. This method exists to allow you supply\n     * your own implementation (this is sometimes required when using a GeoTools application in an\n     * exotic environment like Eclipse, OC4J or your application).\n     *\n     * @param factory The logger factory to use.\n     * @see Logging#setLoggerFactory(LoggerFactory)\n     * @since 2.4\n     */\n    public void setLoggerFactory(final LoggerFactory<?> factory) {\n        Logging.GEOTOOLS.setLoggerFactory(factory);\n    }\n\n    /**\n     * Initializes GeoTools for use. This convenience method performs various tasks (more may be\n     * added in the future), including setting up the {@linkplain java.util.logging Java logging\n     * framework} in one of the following states:\n     *\n     * <p>\n     *\n     * <ul>\n     *   <li>If the <A HREF=\"http://jakarta.apache.org/commons/logging/\">Commons-logging</A>\n     *       framework is available, then every logging message in the {@code org.geotools}\n     *       namespace sent to the Java {@linkplain java.util.logging.Logger logger} are redirected\n     *       to Commons-logging.\n     *   <li>Otherwise if the <A HREF=\"http://logging.apache.org/log4j\">Log4J</A> framework is\n     *       available, then every logging message in the {@code org.geotools} namespace sent to the\n     *       Java {@linkplain java.util.logging.Logger logger} are redirected to Log4J.\n     *   <li>Otherwise, the Java logging {@linkplain java.util.logging.Formatter formatter} for\n     *       console output is replaced by a {@linkplain org.geotools.util.logging.MonolineFormatter\n     *       monoline formatter}.\n     * </ul>\n     *\n     * <p>In addition, the {@linkplain #getDefaultHints default hints} are initialized to the\n     * specified {@code hints}.\n     *\n     * <p>Invoking this method is <strong>not</strong> required fpr the GeoTools library to\n     * function. It is just a convenience method for overwriting select Java and GeoTools default\n     * settings. Supplying these defaults is not desirable in all settings, such as writing test\n     * cases.\n     *\n     * <p>Example of typical invocation in a GeoServer environment:\n     *\n     * <pre><code>\n     * Hints hints = new Hints();\n     * hints.put({@linkplain Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER}, Boolean.TRUE);\n     * hints.put({@linkplain Hints#FORCE_AXIS_ORDER_HONORING}, \"http\");\n     * GeoTools.init(hints);\n     * </code></pre>\n     *\n     * @param hints The hints to use.\n     * @see Logging#setLoggerFactory(String)\n     * @see Logging#forceMonolineConsoleOutput\n     * @see Hints#putSystemDefault\n     * @see #getDefaultHints\n     */\n    public static void init(final Hints hints) {\n        init();\n        if (hints != null) {\n            // This will trigger fireConfigurationChanged()\n            Hints.putSystemDefault(hints);\n        }\n    }\n    /**\n     * Initializes GeoTools for use. This convenience method performs various tasks (more may be\n     * added in the future), including setting up the {@linkplain java.util.logging Java logging\n     * framework} in one of the following states:\n     *\n     * <p>\n     *\n     * <ul>\n     *   <li>If the <A HREF=\"http://jakarta.apache.org/commons/logging/\">Commons-logging</A>\n     *       framework is available, then every logging message in the {@code org.geotools}\n     *       namespace sent to the Java {@linkplain java.util.logging.Logger logger} are redirected\n     *       to Commons-logging.\n     *   <li>Otherwise if the <A HREF=\"http://logging.apache.org/log4j\">Log4J</A> framework is\n     *       available, then every logging message in the {@code org.geotools} namespace sent to the\n     *       Java {@linkplain java.util.logging.Logger logger} are redirected to Log4J.\n     *   <li>Otherwise, the Java logging {@linkplain java.util.logging.Formatter formatter} for\n     *       console output is replaced by a {@linkplain org.geotools.util.logging.MonolineFormatter\n     *       monoline formatter}.\n     * </ul>\n     *\n     * <p>Invoking this method is <strong>not</strong> required fpr the GeoTools library to\n     * function. It is just a convenience method for overwriting select Java and GeoTools default\n     * settings. Supplying these defaults is not desirable in all settings, such as writing test\n     * cases.\n     *\n     * <p>\n     *\n     * @see Logging#setLoggerFactory(String)\n     * @see Logging#forceMonolineConsoleOutput\n     * @see Hints#putSystemDefault\n     * @see #getDefaultHints\n     */\n    public static void init() {\n        final Logging log = Logging.GEOTOOLS;\n        try {\n            log.setLoggerFactory(\"org.geotools.util.logging.CommonsLoggerFactory\");\n        } catch (ClassNotFoundException commonsException) {\n            try {\n                log.setLoggerFactory(\"org.geotools.util.logging.Log4JLoggerFactory\");\n            } catch (ClassNotFoundException log4jException) {\n                // Nothing to do, we already tried our best.\n            }\n        }\n        // If java logging is used, force monoline console output.\n        if (log.getLoggerFactory() == null) {\n            log.forceMonolineConsoleOutput();\n        }\n    }\n    /**\n     * Provides GeoTools with the JNDI context for resource lookup.\n     *\n     * @param applicationContext The initial context to use.\n     * @see #getInitialContext\n     * @since 2.4\n     */\n    public static void init(final InitialContext applicationContext) {\n        synchronized (GeoTools.class) {\n            context = applicationContext;\n        }\n        fireConfigurationChanged();\n    }\n\n    /**\n     * Scans {@linkplain System#getProperties system properties} for any property keys defined in\n     * this class, and add their values to the specified map of hints. For example if the {@value\n     * #FORCE_LONGITUDE_FIRST_AXIS_ORDER} system property is defined, then the {@link\n     * Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER FORCE_LONGITUDE_FIRST_AXIS_ORDER} hint will be added\n     * to the set of hints.\n     *\n     * @return {@code true} if at least one hint changed as a result of this scan, or {@code false}\n     *     otherwise.\n     */\n    static boolean scanForSystemHints(final Map<RenderingHints.Key, Object> hints) {\n        boolean changed = false;\n\n        for (final Map.Entry<String, RenderingHints.Key> entry : BINDINGS.entrySet()) {\n            final String propertyKey = entry.getKey();\n            final String property;\n            try {\n                property = System.getProperty(propertyKey);\n                if (property == null) {\n                    continue;\n                }\n            } catch (SecurityException e) {\n                unexpectedException(e);\n                continue;\n            }\n            /*\n             * Converts the system property value from String to Object (java.lang.Boolean\n             * or java.lang.Number). We perform this conversion only if the key is exactly\n             * of kind Hints.Key,  not a subclass like ClassKey, in order to avoid useless\n             * class loading on  'getValueClass()'  method invocation (ClassKey don't make\n             * sense for Boolean and Number, which are the only types that we convert here).\n             */\n            Object value = property;\n            final RenderingHints.Key hintKey = entry.getValue();\n            if (hintKey.getClass().equals(Hints.Key.class)) {\n                final Class<?> type = ((Hints.Key) hintKey).getValueClass();\n                if (type.equals(Boolean.class)) {\n                    value = Boolean.valueOf(property);\n                } else if (Number.class.isAssignableFrom(type))\n                    try {\n                        value = Classes.valueOf(type, property);\n                    } catch (NumberFormatException e) {\n                        unexpectedException(e);\n                        continue;\n                    }\n            }\n            final Object old;\n            try {\n                old = hints.put(hintKey, value);\n            } catch (IllegalArgumentException e) {\n                // The property value is illegal for this hint.\n                unexpectedException(e);\n                continue;\n            }\n            changed = changed || !Utilities.equals(old, value);\n        }\n        return changed;\n    }\n\n    /**\n     * Logs an exception as if it originated from {@link Hints#scanSystemProperties}, since it is\n     * the public API that may invokes this method.\n     */\n    private static void unexpectedException(final Exception exception) {\n        Logging.unexpectedException(Hints.class, \"scanSystemProperties\", exception);\n    }\n\n    /**\n     * Returns the default set of hints used for the various utility classes. This default set is\n     * determined by:\n     *\n     * <p>\n     *\n     * <ul>\n     *   <li>The {@linplain System#getProperties system properties} available. Some property keys\n     *       are enumerated in the {@link GeoTools} class.\n     *   <li>Any hints added by call to the {@link Hints#putSystemDefault} or {@link #init} method.\n     * </ul>\n     *\n     * <p><b>Long term plan:</b> We would like to transition the utility classes to being injected\n     * with their required factories, either by taking Hints as part of their constructor, or\n     * otherwise. Making this change would be a three step process 1) create instance methods for\n     * each static final class method 2) create an singleton instance of the class 3) change each\n     * static final class method into a call to the singleton. With this in place we could then\n     * encourage client code to make use of utility class instances before eventually retiring the\n     * static final methods.\n     *\n     * @return A copy of the default hints. It is safe to add to it.\n     */\n    public static Hints getDefaultHints() {\n        return Hints.getDefaults(false);\n    }\n    /** Used to combine provided hints with global GeoTools defaults. */\n    public static Hints addDefaultHints(final Hints hints) {\n        final Hints completed = getDefaultHints();\n        if (hints != null) {\n            completed.add(hints);\n        }\n        return completed;\n    }\n\n    /**\n     * Returns the default entity resolver, used to configure {@link SAXParser}.\n     *\n     * @param hints An optional set of hints, or {@code null} if none, see {@link\n     *     Hints#ENTITY_RESOLVER}.\n     * @return An entity resolver (never {@code null})\n     */\n    public static EntityResolver getEntityResolver(Hints hints) {\n        if (hints == null) {\n            hints = getDefaultHints();\n        }\n        if (hints.containsKey(Hints.ENTITY_RESOLVER)) {\n            Object hint = hints.get(Hints.ENTITY_RESOLVER);\n            if (hint == null) {\n                return NullEntityResolver.INSTANCE;\n            } else if (hint instanceof EntityResolver) {\n                return (EntityResolver) hint;\n            } else if (hint instanceof String) {\n                String className = (String) hint;\n                return instantiate(\n                        className, EntityResolver.class, PreventLocalEntityResolver.INSTANCE);\n            }\n        }\n        return PreventLocalEntityResolver.INSTANCE;\n    }\n\n    /**\n     * Create instance of className (or access singleton INSTANCE field).\n     *\n     * @param className Class name to instantiate\n     * @param type Class of object created\n     * @param defaultValue Default to be provided, may be null\n     * @return EntityResolver, defaults to {@link PreventLocalEntityResolver#INSTANCE} if\n     *     unavailable.\n     */\n    static <T, D extends T> T instantiate(String className, Class<T> type, D defaultValue) {\n        if (className == null) {\n            return defaultValue;\n        }\n        final Logger LOGGER = Logging.getLogger(GeoTools.class);\n        try {\n            Class<?> kind = Class.forName(className);\n            // step 1 look for instance field\n            for (Field field : kind.getDeclaredFields()) {\n                int modifier = field.getModifiers();\n                if (\"INSTANCE\".equals(field.getName())\n                        && Modifier.isStatic(modifier)\n                        && Modifier.isPublic(modifier)) {\n                    try {\n                        Object value = field.get(null);\n                        if (value != null && value instanceof EntityResolver) {\n                            return type.cast(value);\n                        } else {\n                            LOGGER.log(\n                                    Level.FINER,\n                                    \"Unable to use ENTITY_RESOLVER: \" + className + \".INSTANCE\");\n                        }\n                    } catch (Throwable t) {\n                        LOGGER.log(\n                                Level.FINER,\n                                \"Unable to instantiate ENTITY_RESOLVER: \" + className + \".INSTANCE\",\n                                t);\n                    }\n                    return defaultValue;\n                }\n            }\n            // step 2 no argument constructor\n            try {\n                Object value = kind.getDeclaredConstructor().newInstance();\n                if (type.isInstance(value)) {\n                    return type.cast(value);\n                }\n            } catch (InstantiationException\n                    | IllegalAccessException\n                    | NoSuchMethodException\n                    | InvocationTargetException e) {\n                LOGGER.log(\n                        Level.FINER, \"Unable to instantiate ENTITY_RESOLVER: \" + e.getMessage(), e);\n            }\n        } catch (ClassNotFoundException notFound) {\n            LOGGER.log(\n                    Level.FINER,\n                    \"Unable to instantiate ENTITY_RESOLVER: \" + notFound.getMessage(),\n                    notFound);\n        }\n        return defaultValue;\n    }\n    /**\n     * Returns the default initial context.\n     *\n     * @param hints An optional set of hints, or {@code null} if none.\n     * @return The initial context (never {@code null}).\n     * @throws NamingException if the initial context can't be created.\n     * @see #init(InitialContext)\n     * @since 2.4\n     * @deprecated hints isn't really used. Use the function without hints\n     */\n    @Deprecated\n    public static synchronized InitialContext getInitialContext(final Hints hints)\n            throws NamingException {\n\n        return getInitialContext();\n    }\n\n    /**\n     * Returns the default initial context.\n     *\n     * @return The initial context (never {@code null}).\n     * @throws NamingException if the initial context can't be created.\n     */\n    public static synchronized InitialContext getInitialContext() throws NamingException {\n        if (context == null) {\n            try {\n                context = new InitialContext();\n            } catch (Exception e) {\n                throw handleException(e);\n            }\n        }\n        return context;\n    }\n\n    private static NamingException handleException(Exception e) {\n        final Logger LOGGER = Logging.getLogger(GeoTools.class);\n        final String propFileName = \"jndi.properties\";\n\n        if (LOGGER.isLoggable(Level.WARNING)) {\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"Error while retriving Initial Context.\\n\\n\")\n                    .append(\"Exception: \")\n                    .append(e.getMessage())\n                    .append(\"\\n\");\n\n            Object contextFactory = System.getProperty(Context.INITIAL_CONTEXT_FACTORY);\n            sb.append(\"Factory could be taken from System property: \")\n                    .append(Context.INITIAL_CONTEXT_FACTORY)\n                    .append(\"=\")\n                    .append(contextFactory == null ? \"\" : (String) contextFactory)\n                    .append(\"\\n\");\n\n            Enumeration<URL> urls =\n                    AccessController.doPrivileged(\n                            new PrivilegedAction<Enumeration<URL>>() {\n                                @Override\n                                public Enumeration<URL> run() {\n                                    try {\n                                        return ClassLoader.getSystemResources(propFileName);\n                                    } catch (IOException e) {\n                                        return null;\n                                    }\n                                }\n                            });\n            if (urls != null) {\n                sb.append(\"Or from these property files:\\n\");\n                while (urls.hasMoreElements()) {\n                    sb.append(urls.nextElement().getPath()).append(\"\\n\");\n                }\n                sb.append(\"\\n\");\n            }\n\n            String javaHome =\n                    AccessController.doPrivileged(\n                            new PrivilegedAction<String>() {\n                                @Override\n                                public String run() {\n                                    try {\n                                        String javahome = System.getProperty(\"java.home\");\n                                        if (javahome == null) {\n                                            return null;\n                                        }\n                                        String pathname =\n                                                javahome\n                                                        + java.io.File.separator\n                                                        + \"lib\"\n                                                        + java.io.File.separator\n                                                        + propFileName;\n                                        return pathname;\n                                    } catch (Exception e) {\n                                        return null;\n                                    }\n                                }\n                            });\n            if (javaHome != null) {\n                sb.append(\"Or from a file specified by system property java.home:\\n\")\n                        .append(javaHome)\n                        .append(\"\\n\");\n            }\n            LOGGER.log(Level.WARNING, sb.toString());\n        }\n        NamingException throwing = new NamingException(\"Couldn't get Initial context.\");\n        throwing.setRootCause(e);\n        return throwing;\n    }\n\n    /**\n     * Clears the initial context (closes it if not null)\n     *\n     * @since 15.0\n     */\n    public static synchronized void clearInitialContext() throws NamingException {\n        if (context != null) {\n            context.close();\n        }\n        context = null;\n    }\n\n    /**\n     * Converts a GeoTools name to the syntax used by the {@linkplain #getInitialContext GeoTools\n     * JNDI context}. Names may be constructed in a variety of ways depending on the implementation\n     * of {@link InitialContext}. GeoTools uses {@code \"jdbc:EPSG\"} internally, but many\n     * implementaitons use the form {@code \"jdbc/EPSG\"}. Calling this method before use will set the\n     * name right.\n     *\n     * @param name Name of the form {@code \"jdbc:EPSG\"}, or {@code null}.\n     * @return Name fixed up with {@link Context#composeName(String,String)}, or {@code null} if the\n     *     given name was null.\n     * @since 2.4\n     */\n    public static String fixName(final String name) {\n        return fixName(null, name, null);\n    }\n\n    /**\n     * Converts a GeoTools name to the syntax used by the specified JNDI context. This method is\n     * similar to {@link #fixName(String)}, but uses the specified context instead of the GeoTools\n     * one.\n     *\n     * @param context The context to use, or {@code null} if none.\n     * @param name Name of the form {@code \"jdbc:EPSG\"}, or {@code null}.\n     * @return Name fixed up with {@link Context#composeName(String,String)}, or {@code null} if the\n     *     given name was null.\n     * @since 2.4\n     */\n    public static String fixName(final Context context, final String name) {\n        return (context != null) ? fixName(context, name, null) : name;\n    }\n\n    /**\n     * Implementation of {@code fixName} method. If the context is {@code null}, then the\n     * {@linkplain #getInitialContext GeoTools initial context} will be fetch only when first\n     * needed.\n     */\n    private static String fixName(Context context, final String name, final Hints hints) {\n        String fixed = null;\n        if (name != null) {\n            final StringTokenizer tokens = new StringTokenizer(name, \":/\");\n            while (tokens.hasMoreTokens()) {\n                final String part = tokens.nextToken();\n                if (fixed == null) {\n                    fixed = part;\n                } else\n                    try {\n                        if (context == null) {\n                            context = getInitialContext();\n                        }\n                        fixed = context.composeName(fixed, part);\n                    } catch (NamingException e) {\n                        Logging.unexpectedException(GeoTools.class, \"fixName\", e);\n                        return name;\n                    }\n            }\n        }\n        return fixed;\n    }\n\n    /**\n     * Adds an alternative way to search for factory implementations. {@link FactoryRegistry} has a\n     * default mechanism bundled in it, which uses the content of all {@code META-INF/services}\n     * directories found on the classpath. This {@code addFactoryIteratorProvider} method allows to\n     * specify additional discovery algorithms. It may be useful in the context of some frameworks\n     * that use the <cite>constructor injection</cite> pattern, like the <a\n     * href=\"http://www.springframework.org/\">Spring framework</a>.\n     *\n     * @param provider A new provider for factory iterators.\n     */\n    public static void addFactoryIteratorProvider(final FactoryIteratorProvider provider) {\n        FactoryIteratorProviders.addFactoryIteratorProvider(provider);\n    }\n\n    /**\n     * Removes a provider that was previously {@linkplain #addFactoryIteratorProvider added}. Note\n     * that factories already obtained from the specified provider will not be {@linkplain\n     * FactoryRegistry#deregisterFactory deregistered} by this method.\n     *\n     * @param provider The provider to remove.\n     */\n    public static void removeFactoryIteratorProvider(final FactoryIteratorProvider provider) {\n        FactoryIteratorProviders.removeFactoryIteratorProvider(provider);\n    }\n\n    /**\n     * Adds the specified listener to the list of objects to inform when system-wide configuration\n     * changed.\n     *\n     * @param listener The listener to add.\n     */\n    public static void addChangeListener(final ChangeListener listener) {\n        removeChangeListener(listener); // Ensure singleton.\n        LISTENERS.add(ChangeListener.class, listener);\n    }\n\n    /**\n     * Removes the specified listener from the list of objects to inform when system-wide\n     * configuration changed.\n     *\n     * @param listener The listener to remove.\n     */\n    public static void removeChangeListener(final ChangeListener listener) {\n        LISTENERS.remove(ChangeListener.class, listener);\n    }\n\n    /** Informs every listeners that system-wide configuration changed. */\n    public static void fireConfigurationChanged() {\n        final ChangeEvent event = new ChangeEvent(GeoTools.class);\n        final Object[] listeners = LISTENERS.getListenerList();\n        for (int i = 0; i < listeners.length; i += 2) {\n            if (listeners[i] == ChangeListener.class) {\n                ((ChangeListener) listeners[i + 1]).stateChanged(event);\n            }\n        }\n    }\n\n    /**\n     * Adds a class loader to be included in the list of class loaders that are used to locate\n     * GeoTools plug-ins.\n     *\n     * <p>Client code that calls this method may also need to call {@link\n     * FactoryRegistry#scanForPlugins()} on any existing registry to force it to clear its cache and\n     * use the added class loader to locate plugins.\n     *\n     * @param classLoader The class loader.\n     */\n    public static void addClassLoader(ClassLoader classLoader) {\n        addedClassLoaders.add(classLoader);\n        fireConfigurationChanged();\n    }\n\n    /** Returns the class loaders added via {@link #addClassLoader(ClassLoader)}. */\n    static Set<ClassLoader> getClassLoaders() {\n        return addedClassLoaders;\n    }\n\n    /**\n     * Reports the GeoTools {@linkplain #getVersion version} number to the {@linkplain System#out\n     * standard output stream}.\n     *\n     * @param args Command line arguments.\n     */\n    public static void main(String... args) {\n        final Arguments arguments = new Arguments(args);\n        arguments.getRemainingArguments(0);\n        arguments.out.print(\"GeoTools version \");\n        arguments.out.println(getVersion());\n        final Hints hints = getDefaultHints();\n        if (hints != null && !hints.isEmpty()) {\n            arguments.out.println(hints);\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2005-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.util.factory;\n\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Stream;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\n/**\n * Tests {@link org.geotools.util.factory.FactoryRegistry} implementation.\n *\n * @version $Id$\n * @author Martin Desruisseaux\n */\npublic final class FactoryRegistryTest {\n    /**\n     * Ensures that class {@link org.geotools.util.factory.Hints} is loaded before {@link\n     * DummyFactory}. It is not needed for normal execution, but Maven seems to mess with class\n     * loaders.\n     */\n    @Before\n    public void ensureHintsLoaded() {\n        assertNotNull(Hints.DATUM_FACTORY.toString());\n    }\n\n    /**\n     * Creates the factory registry to test. The tests performed in this method are more J2SE tests\n     * than Geotools implementation tests. We basically just ensure that we have setup the service\n     * registry properly.\n     *\n     * <p>Factories are specified in arguments as {@link org.geotools.util.factory.Factory} objects\n     * in order to avoid the {@link DummyClass} to be initialized before {@link\n     * org.geotools.util.factory.Hints}. This is not a problem for normal execution, but Maven seems\n     * to mess with class loaders.\n     *\n     * @param creator {@code true} if the registry should be an instance of {@link\n     *     org.geotools.util.factory.FactoryCreator}.\n     */\n    private FactoryRegistry getRegistry(\n            final boolean creator,\n            final Factory factory1,\n            final Factory factory2,\n            final Factory factory3) {\n        @SuppressWarnings(\"unchecked\")\n        final Set<Class<?>> categories = Collections.singleton(DummyFactory.class);\n        // The above line fails without the cast, I don't know why...\n        final FactoryRegistry registry;\n        if (creator) {\n            registry = new FactoryCreator(categories);\n        } else {\n            registry = new FactoryRegistry(categories);\n        }\n        registry.registerFactory(factory1);\n        registry.registerFactory(factory2);\n        registry.registerFactory(factory3);\n        assertTrue(\n                registry.setOrdering(\n                        DummyFactory.class, (DummyFactory) factory1, (DummyFactory) factory2));\n        assertTrue(\n                registry.setOrdering(\n                        DummyFactory.class, (DummyFactory) factory2, (DummyFactory) factory3));\n        assertTrue(\n                registry.setOrdering(\n                        DummyFactory.class, (DummyFactory) factory1, (DummyFactory) factory3));\n\n        final List<?> factories =\n                registry.getFactories(DummyFactory.class, null, null).collect(toList());\n        assertTrue(factories.contains(factory1));\n        assertTrue(factories.contains(factory2));\n        assertTrue(factories.contains(factory3));\n        assertTrue(factories.indexOf(factory1) < factories.indexOf(factory2));\n        assertTrue(factories.indexOf(factory2) < factories.indexOf(factory3));\n        return registry;\n    }\n\n    /**\n     * Tests the {@link org.geotools.util.factory.FactoryRegistry#getProvider} method. Note that the\n     * tested method do not create any new factory. If no registered factory matching the hints is\n     * found, an exception is expected. <br>\n     * <br>\n     * Three factories are initially registered: factory #1, #2 and #3.\n     *\n     * <p>Factory #1 has no dependency. Factory #2 uses factory #1. Factory #3 uses factory #2,\n     * which implies an indirect dependency to factory #1.\n     *\n     * <p>Additionnaly, factory #1 uses a KEY_INTERPOLATION hint.\n     */\n    @Test\n    public void testGetProvider() {\n        final Hints.Key key = DummyFactory.DUMMY_FACTORY;\n        final DummyFactory factory1 = new DummyFactory.Example1();\n        final DummyFactory factory2 = new DummyFactory.Example2();\n        final DummyFactory factory3 = new DummyFactory.Example3();\n        final FactoryRegistry registry = getRegistry(false, factory1, factory2, factory3);\n        // ------------------------------------------------\n        //     PART 1: SIMPLE HINT (not a Factory hint)\n        // ------------------------------------------------\n        /*\n         * No hints. The fist factory should be selected.\n         */\n        Hints hints = null;\n        DummyFactory factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"No preferences; should select the first factory. \", factory1, factory);\n        /*\n         * A hint compatible with one of our factories. Factory #1 declares explicitly that it uses\n         * a bilinear interpolation, which is compatible with user's hints. All other factories are\n         * indifferent. Since factory #1 is the first one in the list, it should be selected.\n         */\n        hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BILINEAR);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"First factory matches; it should be selected. \", factory1, factory);\n        /*\n         * A hint incompatible with all our factories. Factory #1 is the only one to defines\n         * explicitly a KEY_INTERPOLATION hint, but all other factories depend on factory #1\n         * either directly (factory #2) or indirectly (factory #3, which depends on #2).\n         */\n        hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BICUBIC);\n        try {\n            factory = registry.getFactory(DummyFactory.class, null, hints, key);\n            fail(\"Found factory \" + factory + \", while the hint should have been rejected.\");\n        } catch (FactoryNotFoundException exception) {\n            // This is the expected exception. Continue...\n        }\n        /*\n         * Add a new factory implementation, and try again with exactly the same hints\n         * than the previous test. This time, the new factory should be selected since\n         * this one doesn't have any dependency toward factory #1.\n         */\n        final DummyFactory factory4 = new DummyFactory.Example4();\n        registry.registerFactory(factory4);\n        assertTrue(registry.setOrdering(DummyFactory.class, factory1, factory4));\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"The new factory should be selected. \", factory4, factory);\n\n        // ----------------------------\n        //     PART 2: FACTORY HINT\n        // ----------------------------\n        /*\n         * Trivial case: user gives explicitly a factory instance.\n         */\n        DummyFactory explicit = new DummyFactory.Example3();\n        hints = new Hints(DummyFactory.DUMMY_FACTORY, explicit);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"The user-specified factory should have been selected. \", explicit, factory);\n        /*\n         * User specifies the expected implementation class rather than an instance.\n         */\n        hints = new Hints(DummyFactory.DUMMY_FACTORY, DummyFactory.Example2.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Factory of class #2 were requested. \", factory2, factory);\n        /*\n         * Same as above, but with classes specified in an array.\n         */\n        hints =\n                new Hints(\n                        DummyFactory.DUMMY_FACTORY,\n                        new Class<?>[] {DummyFactory.Example3.class, DummyFactory.Example2.class});\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Factory of class #3 were requested. \", factory3, factory);\n        /*\n         * The following hint should be ignored by factory #1, since this factory doesn't have\n         * any dependency to the INTERNAL_FACTORY hint. Since factory #1 is first in the ordering,\n         * it should be selected.\n         */\n        hints = new Hints(DummyFactory.INTERNAL_FACTORY, DummyFactory.Example2.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Expected factory #1. \", factory1, factory);\n        /*\n         * If the user really wants some factory that do have a dependency to factory #2, he should\n         * specifies in a DUMMY_FACTORY hint the implementation classes (or a common super-class or\n         * interface) that do care about the INTERNAL_FACTORY hint. Note that this extra step should\n         * not be a big deal in most real application, because:\n         *\n         *  1) Either all implementations have this dependency (for example it would be\n         *     unusual to see a DatumAuthorityFactory without a DatumFactory dependency);\n         *\n         *  2) or the user really know the implementation he wants (for example if he specifies a\n         *     JTS CoordinateSequenceFactory, he probably wants to use the JTS GeometryFactory).\n         *\n         * In the particular case of this test suite, this extra step would not be needed\n         * neither if factory #1 was last in the ordering rather than first.\n         */\n        final Hints implementations =\n                new Hints(\n                        DummyFactory.DUMMY_FACTORY,\n                        new Class[] {DummyFactory.Example2.class, DummyFactory.Example3.class});\n        /*\n         * Now search NOT for factory #1, but rather for a factory using #1 internally.\n         * This is the case of factory #2.\n         */\n        hints = new Hints(DummyFactory.INTERNAL_FACTORY, DummyFactory.Example1.class);\n        hints.add(implementations);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Expected a factory using #1 internally. \", factory2, factory);\n    }\n\n    /**\n     * Tests the {@link org.geotools.util.factory.FactoryCreator#getProvider} method. This test\n     * tries again the cases that was expected to throws an exception in {@link #testGetProvider}.\n     * But now, those cases are expected to creates automatically new factory instances instead of\n     * throwing an exception.\n     */\n    @Test\n    public void testCreateProvider() {\n        final Hints.Key key = DummyFactory.DUMMY_FACTORY;\n        final DummyFactory factory1 = new DummyFactory.Example1();\n        final DummyFactory factory2 = new DummyFactory.Example2();\n        final DummyFactory factory3 = new DummyFactory.Example3();\n        final FactoryRegistry registry = getRegistry(true, factory1, factory2, factory3);\n        /*\n         * Same tests than above (at least some of them).\n         * See comments in 'testGetProvider()' for explanation.\n         */\n        Hints hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BILINEAR);\n        DummyFactory factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"First factory matches; it should be selected. \", factory1, factory);\n\n        hints = new Hints(DummyFactory.DUMMY_FACTORY, DummyFactory.Example2.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Factory of class #2 were requested. \", factory2, factory);\n        /*\n         * The following case was throwing an exception in testGetProvider(). It should fails again\n         * here, but for a different reason. FactoryCreator is unable to creates automatically a new\n         * factory instance, since we gave no implementation hint and no registered factory have a\n         * constructor expecting a Hints argument.\n         */\n        hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BICUBIC);\n        try {\n            factory = registry.getFactory(DummyFactory.class, null, hints, key);\n            fail(\n                    \"Found or created factory \"\n                            + factory\n                            + \", while it should not have been allowed.\");\n        } catch (FactoryNotFoundException exception) {\n            // This is the expected exception. Continue...\n        }\n        /*\n         * Register a DummyFactory with a constructor expecting a Hints argument, and try again\n         * with the same hints. Now it should creates a new factory instance, because we are using\n         * FactoryCreator instead of FactoryRegistry and an appropriate constructor is found.\n         * Note that an AssertionFailedError should be thrown if the no-argument constructor of\n         * Example5 is invoked, since the constructor with a Hints argument should have priority.\n         */\n        final DummyFactory factory5 = new DummyFactory.Example5(null);\n        registry.registerFactory(factory5);\n        assertTrue(registry.setOrdering(DummyFactory.class, factory1, factory5));\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\n                \"An instance of Factory #5 should have been created.\",\n                factory5.getClass(),\n                factory.getClass());\n        assertNotSame(\"A NEW instance of Factory #5 should have been created\", factory5, factory);\n        /*\n         * Tries again with a class explicitly specified as an implementation hint.\n         * It doesn't matter if this class is registered or not.\n         */\n        hints.put(DummyFactory.DUMMY_FACTORY, DummyFactory.Example4.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertEquals(\n                \"An instance of Factory #4 should have been created.\",\n                DummyFactory.Example4.class,\n                factory.getClass());\n    }\n\n    @Ignore\n    @Test\n    public void testLookupWithExtendedClasspath() throws IOException {\n        URL url = getClass().getResource(\"foo.jar\");\n        assertNotNull(url);\n\n        FactoryRegistry reg = new FactoryCreator(DummyInterface.class);\n        Stream<DummyInterface> factories = reg.getFactories(DummyInterface.class, false);\n        assertFalse(factories.findAny().isPresent());\n\n        try (URLClassLoader cl = new URLClassLoader(new URL[] {url})) {\n            GeoTools.addClassLoader(cl);\n            reg.scanForPlugins();\n\n            Set<String> classes =\n                    reg.getFactories(DummyInterface.class, false)\n                            .map(factory -> factory.getClass().getName())\n                            .collect(toSet());\n\n            assertEquals(2, classes.size());\n            assertTrue(classes.contains(\"pkg.Foo\"));\n            assertTrue(classes.contains(\"org.geotools.util.factory.DummyInterfaceImpl\"));\n        }\n    }\n\n    /** Tests for GEOT-2817 */\n    @Test\n    public void testLookupWithSameFactoryInTwoClassLoaders()\n            throws IOException, ClassNotFoundException {\n        // create url to this project's classes\n        URL projectClasses = getClass().getResource(\"/\");\n        // create 2 classloaders with parent null to avoid delegation to the system class loader !\n        // this occurs in reality with split class loader hierarchies (e.g. GWT plugin and\n        // some application servers)\n        try (URLClassLoader cl1 = new URLClassLoader(new URL[] {projectClasses}, null);\n                URLClassLoader cl2 = new URLClassLoader(new URL[] {projectClasses}, null)) {\n            // extend with both class loaders\n            GeoTools.addClassLoader(cl1);\n            GeoTools.addClassLoader(cl2);\n            // code below was throwing ClassCastException (before java 7) prior to adding\n            // isAssignableFrom() check (line 862)\n            for (int i = 0; i < 2; i++) {\n                ClassLoader loader = (i == 0 ? cl1 : cl2);\n                Class dummy = loader.loadClass(\"org.geotools.util.factory.DummyInterface\");\n                FactoryRegistry reg = new FactoryCreator(dummy);\n                reg.scanForPlugins();\n                // we are mocking with two class loaders, trying to make it type safe will make\n                // the factory fail to load the factory\n                @SuppressWarnings(\"unchecked\")\n                Optional factory = reg.getFactories(dummy, false).findFirst();\n                assertTrue(factory.isPresent());\n                // factory class should have same class loader as interface\n                assertSame(loader, factory.get().getClass().getClassLoader());\n            }\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2007-2016, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.util.factory;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\nimport java.awt.RenderingHints;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.jar.Manifest;\nimport javax.media.jai.JAI;\nimport org.apache.commons.logging.LogFactory;\nimport org.geotools.util.NullEntityResolver;\nimport org.geotools.util.PreventLocalEntityResolver;\nimport org.geotools.util.Version;\nimport org.junit.Test;\nimport org.opengis.filter.Filter;\nimport org.xml.sax.EntityResolver;\n\n/**\n * Tests {@link org.geotools.util.factory.GeoTools}.\n *\n * @since 2.4\n * @version $Id$\n * @author Jody Garnett\n * @author Martin Desruisseaux\n */\npublic final class GeoToolsTest {\n    /** Makes sures that J2SE 1.4 assertions are enabled. */\n    @Test\n    public void testAssertionEnabled() {\n        assertTrue(\"Assertions not enabled.\", GeoToolsTest.class.desiredAssertionStatus());\n    }\n\n    /**\n     * Tests the removal of keys from a hashmap. Required for {@link\n     * org.geotools.util.factory.FactoryRegistry} working.\n     */\n    @Test\n    public void testHintsKey() {\n        final Hints hints = new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE);\n        assertFalse(hints.isEmpty());\n\n        Map<RenderingHints.Key, Object> map = new HashMap<>();\n        assertNull(map.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE));\n        map = Collections.unmodifiableMap(map);\n        assertFalse(map.isEmpty());\n\n        final Hints remaining = new Hints(hints);\n        assertTrue(remaining.keySet().removeAll(map.keySet()));\n        assertTrue(remaining.isEmpty());\n    }\n\n    /** Tests addition of custom hints. */\n    @Test\n    public void testMyHints() {\n        Hints hints = GeoTools.getDefaultHints();\n        assertTrue(hints.isEmpty());\n        assertNull(Hints.putSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE));\n        try {\n            hints = GeoTools.getDefaultHints();\n            assertNotNull(hints);\n            assertFalse(hints.isEmpty());\n            assertEquals(1, hints.size());\n            final Object value = hints.get(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER);\n            assertTrue(value instanceof Boolean);\n            assertFalse(((Boolean) value).booleanValue());\n            /*\n             * Tests the toString() method.\n             */\n            String text = hints.toString().trim();\n            assertTrue(text.matches(\"Hints:\\\\s+FORCE_LONGITUDE_FIRST_AXIS_ORDER = false\"));\n\n            assertEquals(\n                    hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE), Boolean.FALSE);\n            text = hints.toString().trim();\n            assertTrue(text.matches(\"Hints:\\\\s+FORCE_LONGITUDE_FIRST_AXIS_ORDER = true\"));\n\n            assertEquals(hints.remove(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER), Boolean.TRUE);\n            text = hints.toString().trim();\n            assertTrue(\n                    text.matches(\n                            \"Hints:\\\\s+System defaults:\\\\s+FORCE_LONGITUDE_FIRST_AXIS_ORDER = false\"));\n        } finally {\n            assertNotNull(Hints.removeSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER));\n        }\n        assertTrue(GeoTools.getDefaultHints().isEmpty());\n    }\n\n    /** Test Manifest version lookup */\n    @Test\n    public void testManifest() {\n        // jar manifest lookup\n        Manifest jai = GeoTools.getManifest(JAI.class);\n        assertFalse(\"manifest metadata\", jai.getMainAttributes().isEmpty());\n\n        // this should always be generated during a maven or ide build\n        Manifest metadata = GeoTools.getManifest(GeoTools.class);\n        assertFalse(\"manifest metadata\", metadata.getMainAttributes().isEmpty());\n        assertEquals(\n                GeoTools.getVersion().toString(),\n                metadata.getMainAttributes().getValue(\"Project-Version\"));\n\n        // should be a jar durning maven build, generated during IDE build\n        Manifest opengis = GeoTools.getManifest(Filter.class);\n        assertFalse(\"manifest metadata\", opengis.getMainAttributes().isEmpty());\n\n        Manifest commons_logging = GeoTools.getManifest(LogFactory.class);\n        assertNotNull(commons_logging);\n        assertFalse(\"manifest metadata\", commons_logging.getMainAttributes().isEmpty());\n        assertEquals(\n                \"1.1.1\", commons_logging.getMainAttributes().getValue(\"Implementation-Version\"));\n    }\n\n    /** Test version lookup */\n    @Test\n    public void testVersion() {\n\n        String location =\n                \"jar:file:/Users/jody/.m2/repository/org.locationtech/jts/1.14/jts-1.14\"\n                        + \".jar!/org.locationtech/jts/geom/Geometry.class\";\n        assertEquals(\"1.14\", GeoTools.jarVersion(location));\n\n        location =\n                \"jar:file:/Users/jody/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar!/org/apache/commons/logging/LogFactory.class\";\n        assertEquals(\"1.1.1\", GeoTools.jarVersion(location));\n\n        location =\n                \"jar:file:/Users/jody/Library/Java/Extensions/jai_core.jar!/javax/media/jai/JAI.class\";\n        assertNull(GeoTools.jarVersion(location));\n\n        location =\n                \"vfs:/var/jboss/workspace/BuildSvr_FNMOC/jboss/geoserver/deployments/geoserver.war/WEB-INF/lib/gt-xsd-wcs-13.2.jar/org/geotools/wcs/WCS.class\";\n        assertEquals(\"13.2\", GeoTools.jarVersion(location));\n\n        Version version = GeoTools.getVersion(Filter.class);\n        assertNotNull(version);\n\n        version = GeoTools.getVersion(JAI.class);\n        assertNotNull(version);\n        assertEquals(\"1.1.3\", version.toString());\n\n        version = GeoTools.getVersion(LogFactory.class);\n        assertNotNull(version);\n        assertEquals(\"1.1.1\", version.toString());\n    }\n    /** Tests the use of system properties. */\n    @Test\n    public void testSystemHints() {\n        Hints hints = GeoTools.getDefaultHints();\n        assertNotNull(hints);\n        assertTrue(hints.isEmpty());\n        System.setProperty(GeoTools.FORCE_LONGITUDE_FIRST_AXIS_ORDER, \"true\");\n        Hints.scanSystemProperties();\n        try {\n            hints = GeoTools.getDefaultHints();\n            assertNotNull(hints);\n            assertFalse(hints.isEmpty());\n            assertEquals(1, hints.size());\n            final Object value = hints.get(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER);\n            assertTrue(value instanceof Boolean);\n            assertTrue(((Boolean) value).booleanValue());\n        } finally {\n            System.clearProperty(GeoTools.FORCE_LONGITUDE_FIRST_AXIS_ORDER);\n            assertNotNull(Hints.removeSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER));\n        }\n        hints = GeoTools.getDefaultHints();\n        assertNotNull(hints);\n        assertTrue(hints.isEmpty());\n    }\n\n    /**\n     * Tests {@link org.geotools.util.factory.GeoTools#fixName} using simpliest name or no context.\n     * We avoid the tests that would require a real initial context.\n     */\n    @Test\n    public void testFixName() {\n        assertNull(GeoTools.fixName(null));\n        assertEquals(\"simpleName\", GeoTools.fixName(\"simpleName\"));\n        assertEquals(\"jdbc:EPSG\", GeoTools.fixName(null, \"jdbc:EPSG\"));\n        assertEquals(\"jdbc/EPSG\", GeoTools.fixName(null, \"jdbc/EPSG\"));\n    }\n\n    @Test\n    public void testEntityResolver() {\n\n        // confirm instantiate works\n\n        EntityResolver resolver =\n                GeoTools.instantiate(\n                        \"org.geotools.util.factory.PlaceholderEntityResolver\",\n                        EntityResolver.class,\n                        PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof PlaceholderEntityResolver);\n\n        resolver =\n                GeoTools.instantiate(\n                        \"org.geotools.util.NullEntityResolver\",\n                        EntityResolver.class,\n                        PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof NullEntityResolver);\n\n        resolver =\n                GeoTools.instantiate(\n                        \"invalid.class.reference\",\n                        EntityResolver.class,\n                        PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof PreventLocalEntityResolver);\n\n        resolver =\n                GeoTools.instantiate(\n                        null, EntityResolver.class, PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof PreventLocalEntityResolver);\n\n        // confirm system hints work\n        try {\n            Hints.putSystemDefault(Hints.ENTITY_RESOLVER, NullEntityResolver.INSTANCE);\n            assertSame(NullEntityResolver.INSTANCE, GeoTools.getEntityResolver(null));\n\n            // test default behavor\n            Hints.removeSystemDefault(Hints.ENTITY_RESOLVER);\n            assertSame(PreventLocalEntityResolver.INSTANCE, GeoTools.getEntityResolver(null));\n\n            // test system property functions with default constructor\n            System.getProperties()\n                    .put(\n                            GeoTools.ENTITY_RESOLVER,\n                            \"org.geotools.util.factory.PlaceholderEntityResolver\");\n            Hints.scanSystemProperties();\n            EntityResolver entityResolver = GeoTools.getEntityResolver(null);\n            assertTrue(entityResolver instanceof PlaceholderEntityResolver);\n\n            // test system property functions with INSTANCE field constructor\n            System.getProperties()\n                    .put(GeoTools.ENTITY_RESOLVER, \"org.geotools.util.NullEntityResolver\");\n            Hints.scanSystemProperties();\n            entityResolver = GeoTools.getEntityResolver(null);\n            assertTrue(entityResolver instanceof NullEntityResolver);\n        } finally {\n            System.clearProperty(GeoTools.ENTITY_RESOLVER);\n            Hints.removeSystemDefault(Hints.ENTITY_RESOLVER);\n            Hints.scanSystemProperties();\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2005-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.referencing.factory;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.naming.InitialContext;\nimport javax.sql.DataSource;\nimport org.geotools.metadata.iso.citation.Citations;\nimport org.geotools.util.SimpleInternationalString;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.factory.Hints;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.metadata.Identifier;\nimport org.opengis.metadata.citation.Citation;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.IdentifiedObject;\nimport org.opengis.referencing.NoSuchAuthorityCodeException;\nimport org.opengis.util.GenericName;\nimport org.opengis.util.InternationalString;\n\n/**\n * Abstract implementation for EPSG (has a DataSource reference inside).\n *\n * <p>DataSource docs needed:\n *\n * @author Cory Horner (Refractions Research)\n */\npublic abstract class AbstractEpsgMediator extends AbstractAuthorityMediator {\n\n    /** The default priority level for this factory. */\n    public static final int PRIORITY = NORMAL_PRIORITY - 10;\n\n    private static final Logger LOGGER = Logging.getLogger(AbstractEpsgMediator.class);\n\n    protected DataSource datasource;\n\n    /** No argument constructor - must not fail for factory finder registration. */\n    public AbstractEpsgMediator() {}\n\n    public AbstractEpsgMediator(Hints hints) throws FactoryException {\n        this(hints, lookupDataSource(hints));\n    }\n    /**\n     * We expect the EPSG_DATASOURCE to provide a DataSource. Either:\n     *\n     * <ul>\n     *   <li>A name we can use to look up the DataSource in the initial context\n     *   <li>An actual DataSource instance\n     * </ul>\n     *\n     * @return DataSource\n     */\n    static DataSource lookupDataSource(Hints hints) throws FactoryException {\n        Object hint = hints.get(Hints.EPSG_DATA_SOURCE);\n        if (hint instanceof DataSource) {\n            return (DataSource) hint;\n        } else if (hint instanceof String) {\n            String name = (String) hint;\n            InitialContext context;\n            try {\n                context = GeoTools.getInitialContext();\n                // name = GeoTools.fixName( context, name );\n                return (DataSource) context.lookup(name);\n            } catch (Exception e) {\n                throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n            }\n        }\n        throw new FactoryException(\"EPSG_DATA_SOURCE must be provided\");\n    }\n\n    public AbstractEpsgMediator(Hints hints, DataSource datasource) {\n        super(PRIORITY, hints);\n\n        if (datasource != null) {\n            this.datasource = datasource;\n        } else {\n            try {\n                this.datasource = lookupDataSource(hints);\n            } catch (FactoryException lookupFailed) {\n                throw (NullPointerException)\n                        new NullPointerException(\"DataSource not provided:\" + lookupFailed)\n                                .initCause(lookupFailed);\n            }\n        }\n        hints.put(Hints.EPSG_DATA_SOURCE, this.datasource);\n    }\n\n    protected Connection getConnection() throws SQLException {\n        try {\n            return datasource.getConnection();\n        } catch (SQLException e) {\n            LOGGER.log(Level.SEVERE, \"Connection failed\", e);\n            throw e;\n        }\n    }\n\n    @Override\n    public Citation getAuthority() {\n        return Citations.EPSG;\n    }\n\n    @Override\n    public void dispose() throws FactoryException {\n        super.dispose();\n        datasource = null;\n    }\n\n    @Override\n    public boolean isConnected() {\n        return datasource != null && super.isConnected();\n    }\n\n    /**\n     * Gets a description of the object corresponding to a code.\n     *\n     * @param code Value allocated by authority.\n     * @return A description of the object, or {@code null} if the object corresponding to the\n     *     specified {@code code} has no description.\n     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.\n     * @throws FactoryException if the query failed for some other reason.\n     */\n    @Override\n    public InternationalString getDescriptionText(final String code) throws FactoryException {\n        IdentifiedObject identifiedObject = createObject(code);\n        final Identifier identifier = identifiedObject.getName();\n        if (identifier instanceof GenericName) {\n            return ((GenericName) identifier).toInternationalString();\n        }\n        return new SimpleInternationalString(identifier.getCode());\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2005-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.referencing.factory.epsg;\n\nimport static org.geotools.measure.Units.DEGREE_ANGLE;\nimport static org.geotools.measure.Units.DEGREE_MINUTE_SECOND;\nimport static org.geotools.measure.Units.FOOT;\nimport static org.geotools.measure.Units.GRADE;\nimport static org.geotools.measure.Units.KILOMETER;\nimport static org.geotools.measure.Units.METRE;\nimport static org.geotools.measure.Units.MICRORADIAN;\nimport static org.geotools.measure.Units.MINUTE_ANGLE;\nimport static org.geotools.measure.Units.NAUTICAL_MILE;\nimport static org.geotools.measure.Units.ONE;\nimport static org.geotools.measure.Units.PPM;\nimport static org.geotools.measure.Units.RADIAN;\nimport static org.geotools.measure.Units.SECOND_ANGLE;\nimport static org.geotools.measure.Units.SEXAGESIMAL_DMS;\n\nimport java.awt.RenderingHints;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Date;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport javax.measure.Unit;\nimport javax.measure.quantity.Angle;\nimport javax.measure.quantity.Length;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport org.geotools.measure.Units;\nimport org.geotools.metadata.i18n.ErrorKeys;\nimport org.geotools.metadata.i18n.Errors;\nimport org.geotools.metadata.i18n.LoggingKeys;\nimport org.geotools.metadata.i18n.Loggings;\nimport org.geotools.metadata.i18n.Vocabulary;\nimport org.geotools.metadata.i18n.VocabularyKeys;\nimport org.geotools.metadata.iso.citation.CitationImpl;\nimport org.geotools.metadata.iso.citation.Citations;\nimport org.geotools.metadata.iso.extent.ExtentImpl;\nimport org.geotools.metadata.iso.extent.GeographicBoundingBoxImpl;\nimport org.geotools.metadata.iso.quality.AbsoluteExternalPositionalAccuracyImpl;\nimport org.geotools.metadata.iso.quality.QuantitativeResultImpl;\nimport org.geotools.parameter.DefaultParameterDescriptor;\nimport org.geotools.parameter.DefaultParameterDescriptorGroup;\nimport org.geotools.referencing.AbstractIdentifiedObject;\nimport org.geotools.referencing.NamedIdentifier;\nimport org.geotools.referencing.cs.DefaultCoordinateSystemAxis;\nimport org.geotools.referencing.datum.BursaWolfParameters;\nimport org.geotools.referencing.datum.DefaultGeodeticDatum;\nimport org.geotools.referencing.factory.AbstractCachedAuthorityFactory;\nimport org.geotools.referencing.factory.BufferedAuthorityFactory;\nimport org.geotools.referencing.factory.DirectAuthorityFactory;\nimport org.geotools.referencing.factory.IdentifiedObjectFinder;\nimport org.geotools.referencing.operation.DefaultConcatenatedOperation;\nimport org.geotools.referencing.operation.DefaultOperation;\nimport org.geotools.referencing.operation.DefaultOperationMethod;\nimport org.geotools.referencing.operation.DefiningConversion;\nimport org.geotools.referencing.util.CRSUtilities;\nimport org.geotools.util.LocalName;\nimport org.geotools.util.ObjectCache;\nimport org.geotools.util.ScopedName;\nimport org.geotools.util.SimpleInternationalString;\nimport org.geotools.util.TableWriter;\nimport org.geotools.util.Version;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.factory.Hints;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.metadata.Identifier;\nimport org.opengis.metadata.citation.Citation;\nimport org.opengis.metadata.extent.Extent;\nimport org.opengis.metadata.quality.EvaluationMethodType;\nimport org.opengis.metadata.quality.PositionalAccuracy;\nimport org.opengis.parameter.InvalidParameterValueException;\nimport org.opengis.parameter.ParameterDescriptor;\nimport org.opengis.parameter.ParameterNotFoundException;\nimport org.opengis.parameter.ParameterValue;\nimport org.opengis.parameter.ParameterValueGroup;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.IdentifiedObject;\nimport org.opengis.referencing.NoSuchAuthorityCodeException;\nimport org.opengis.referencing.NoSuchIdentifierException;\nimport org.opengis.referencing.crs.CRSFactory;\nimport org.opengis.referencing.crs.CompoundCRS;\nimport org.opengis.referencing.crs.CoordinateReferenceSystem;\nimport org.opengis.referencing.crs.GeneralDerivedCRS;\nimport org.opengis.referencing.crs.GeocentricCRS;\nimport org.opengis.referencing.crs.GeographicCRS;\nimport org.opengis.referencing.crs.ProjectedCRS;\nimport org.opengis.referencing.crs.SingleCRS;\nimport org.opengis.referencing.cs.AxisDirection;\nimport org.opengis.referencing.cs.CSFactory;\nimport org.opengis.referencing.cs.CartesianCS;\nimport org.opengis.referencing.cs.CoordinateSystem;\nimport org.opengis.referencing.cs.CoordinateSystemAxis;\nimport org.opengis.referencing.cs.EllipsoidalCS;\nimport org.opengis.referencing.cs.SphericalCS;\nimport org.opengis.referencing.cs.VerticalCS;\nimport org.opengis.referencing.datum.Datum;\nimport org.opengis.referencing.datum.DatumFactory;\nimport org.opengis.referencing.datum.Ellipsoid;\nimport org.opengis.referencing.datum.EngineeringDatum;\nimport org.opengis.referencing.datum.GeodeticDatum;\nimport org.opengis.referencing.datum.PrimeMeridian;\nimport org.opengis.referencing.datum.VerticalDatum;\nimport org.opengis.referencing.datum.VerticalDatumType;\nimport org.opengis.referencing.operation.ConcatenatedOperation;\nimport org.opengis.referencing.operation.Conversion;\nimport org.opengis.referencing.operation.CoordinateOperation;\nimport org.opengis.referencing.operation.MathTransform;\nimport org.opengis.referencing.operation.OperationMethod;\nimport org.opengis.referencing.operation.Projection;\nimport org.opengis.referencing.operation.Transformation;\nimport org.opengis.util.GenericName;\nimport org.opengis.util.InternationalString;\nimport si.uom.NonSI;\nimport si.uom.SI;\n\n/**\n * A coordinate reference system factory backed by the EPSG database tables.\n *\n * <p>The EPSG database is freely available at <A\n * HREF=\"http://www.epsg.org\">http://www.epsg.org</a>. Current version of this class requires EPSG\n * database version 6.6 or above.\n *\n * <p>This factory makes use of a provided {@link ObjectCache}, and may be deployed in stand aline\n * fashion; or as a worker for a {@link MultiEpsgFactory}.\n *\n * <p>This class is abstract - please see the subclasses for dialect specific implementations:\n *\n * <ul>\n *   <li>{@link AccessDialectEpsgFactory}\n *   <li>{@link AnsiDialectEpsgFactory}\n *   <li>{@link OracleDialectEpsgFactory}\n * </ul>\n *\n * These factories accepts names as well as numerical identifiers. For example \"<cite>NTF (Paris) /\n * France I</cite>\" and {@code \"27581\"} both fetchs the same object. However, names may be ambiguous\n * since the same name may be used for more than one object. This is the case of \"WGS 84\" for\n * example. If such an ambiguity is found, an exception will be thrown. If names are not wanted as a\n * legal EPSG code, subclasses can override the {@link #isPrimaryKey} method.\n *\n * @since 2.4\n * @version $Id$\n * @author Yann C\u00e9zard\n * @author Martin Desruisseaux (IRD)\n * @author Rueben Schulz\n * @author Matthias Basler\n * @author Andrea Aime\n */\n@SuppressWarnings(\"PMD.CloseResource\") // class implements its own PreparedStatement pooling\npublic abstract class AbstractEpsgFactory extends AbstractCachedAuthorityFactory {\n    /// Datum shift operation methods\n    /** First Bursa-Wolf method. */\n    private static final int BURSA_WOLF_MIN_CODE = 9603;\n\n    /** Last Bursa-Wolf method. */\n    private static final int BURSA_WOLF_MAX_CODE = 9607;\n\n    /** Rotation frame method. */\n    private static final int ROTATION_FRAME_CODE = 9607;\n\n    /** Dummy operation to ignore. */\n    private static final int DUMMY_OPERATION = 1;\n\n    /** The name for the transformation accuracy metadata. */\n    private static final InternationalString TRANSFORMATION_ACCURACY =\n            Vocabulary.formatInternational(VocabularyKeys.TRANSFORMATION_ACCURACY);\n\n    /**\n     * The authority for this database. Will be created only when first needed. This authority will\n     * contains the database version in the {@linkplain Citation#getEdition edition} attribute,\n     * together with the {@linkplain Citation#getEditionDate edition date}.\n     */\n    private transient Citation authority; // FIXME: always EPSG\n\n    /** A DataSource to the EPSG database being used. */\n    protected javax.sql.DataSource dataSource;\n\n    /**\n     * The connection to the EPSG database - this is create in a lazy manner from the DataSource.\n     *\n     * <p>This field is managed as part of our connection lifecycle.\n     */\n    private Connection connection;\n\n    /**\n     * A pool of prepared statements. Key are {@link String} object related to their originating\n     * method name (for example \"Ellipsoid\" for {@link #createEllipsoid}, while values are {@link\n     * PreparedStatement} objects.\n     *\n     * <p><strong>Note:</strong> It is okay to use {@link IdentityHashMap} instead of {@link\n     * HashMap} because the keys will always be the exact same object, namely the hard-coded\n     * argument given to calls to {@link #prepareStatement} in this class.\n     *\n     * <p>This field is managed as part of our connection lifecycle.\n     */\n    private final Map<String, PreparedStatement> statements = new IdentityHashMap<>();\n\n    /**\n     * Last object type returned by {@link #createObject}, or -1 if none. This type is an index in\n     * the {@link #TABLES_INFO} array and is strictly for {@link #createObject} internal use.\n     */\n    private int lastObjectType = -1;\n\n    /**\n     * The last table in which object name were looked for. This is for internal use by {@link\n     * #toPrimaryKey} only.\n     */\n    private transient String lastTableForName;\n\n    /**\n     * Cache for axis names. This service is not provided by {@link BufferedAuthorityFactory} since\n     * {@link AxisName} object are particular to the EPSG database.\n     *\n     * @see #getAxisName\n     */\n    private final Map<String, AxisName> axisNames = new HashMap<>();\n\n    /**\n     * Cache for axis numbers. This service is not provided by {@link BufferedAuthorityFactory}\n     * since the number of axis is used internally in this class.\n     *\n     * @see #getDimensionForCRS\n     */\n    private final Map<String, Short> axisCounts = new HashMap<>();\n\n    /**\n     * Cache for projection checks. This service is not provided by {@link BufferedAuthorityFactory}\n     * since the check that a transformation is a projection is used internally in this class.\n     *\n     * @see #isProjection\n     */\n    private final Map<String, Boolean> codeProjection = new HashMap<>();\n\n    /** Pool of naming systems, used for caching. There is usually few of them (about 15). */\n    private final Map<String, LocalName> scopes = new HashMap<>();\n\n    /**\n     * The properties to be given the objects to construct. Reused every time {@link\n     * #createProperties} is invoked.\n     */\n    private final Map<String, Object> properties = new HashMap<>();\n\n    /**\n     * A safety guard for preventing never-ending loops in recursive calls to {@link #createDatum}.\n     * This is used by {@link #createBursaWolfParameters}, which need to create a target datum. The\n     * target datum could have its own Bursa-Wolf parameters, with one of them pointing again to the\n     * source datum.\n     */\n    private final Set<String> safetyGuard = new HashSet<>();\n\n    public AbstractEpsgFactory(final Hints userHints) throws FactoryException {\n        super(MAXIMUM_PRIORITY - 20);\n        // The following hints have no effect on this class behaviour,\n        // but tell to the user what this factory do about axis order.\n        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);\n\n        //\n        // We need to obtain our DataSource\n        if (userHints != null) {\n            Object hint = userHints.get(Hints.EPSG_DATA_SOURCE);\n            if (hint instanceof String) {\n                String name = (String) hint;\n                try {\n                    dataSource = (DataSource) GeoTools.getInitialContext().lookup(name);\n                } catch (NamingException e) {\n                    throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required:\" + e);\n                }\n                hints.put(Hints.EPSG_DATA_SOURCE, dataSource);\n            } else if (hint instanceof DataSource) {\n                dataSource = (DataSource) hint;\n                hints.put(Hints.EPSG_DATA_SOURCE, dataSource);\n            } else {\n                throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required.\");\n            }\n        } else {\n            throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required.\");\n        }\n    }\n\n    public AbstractEpsgFactory(final Hints userHints, final javax.sql.DataSource dataSource) {\n        super(MAXIMUM_PRIORITY - 20);\n\n        this.dataSource = dataSource;\n        // The following hints have no effect on this class behaviour,\n        // but tell to the user what this factory do about axis order.\n        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);\n        hints.put(Hints.EPSG_DATA_SOURCE, dataSource);\n    }\n    /**\n     * Constructs an authority factory using the specified connection.\n     *\n     * @param userHints The underlying factories used for objects creation.\n     * @param connection The connection to the underlying EPSG database.\n     */\n    public AbstractEpsgFactory(final Hints userHints, final Connection connection) {\n        super(MAXIMUM_PRIORITY - 20, userHints);\n        // The following hints have no effect on this class behaviour,\n        // but tell to the user what this factory do about axis order.\n        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);\n        this.connection = connection;\n        ensureNonNull(\"connection\", connection);\n    }\n\n    /**\n     * Returns the authority for this EPSG database. This authority will contains the database\n     * version in the {@linkplain Citation#getEdition edition} attribute, together with the\n     * {@linkplain Citation#getEditionDate edition date}.\n     */\n    @Override\n    public synchronized Citation getAuthority() {\n        if (authority == null)\n            try {\n                final String query =\n                        adaptSQL(\n                                \"SELECT VERSION_NUMBER, VERSION_DATE FROM [Version History]\"\n                                        + \" ORDER BY VERSION_DATE DESC\");\n                final DatabaseMetaData metadata = getConnection().getMetaData();\n                try (Statement statement = getConnection().createStatement();\n                        ResultSet result = statement.executeQuery(query)) {\n                    if (result.next()) {\n                        final String version = result.getString(1);\n                        final Date date = result.getDate(2);\n                        final String engine = metadata.getDatabaseProductName();\n                        final CitationImpl c = new CitationImpl(Citations.EPSG);\n                        c.getAlternateTitles()\n                                .add(\n                                        Vocabulary.formatInternational(\n                                                VocabularyKeys.DATA_BASE_$3,\n                                                \"EPSG\",\n                                                version,\n                                                engine));\n                        c.setEdition(new SimpleInternationalString(version));\n                        c.setEditionDate(date);\n                        authority = (Citation) c.unmodifiable();\n                        hints.put(\n                                Hints.VERSION,\n                                new Version(version)); // For getImplementationHints()\n                    } else {\n                        authority = Citations.EPSG;\n                    }\n                }\n            } catch (SQLException exception) {\n                Logging.unexpectedException(\n                        LOGGER, AbstractEpsgFactory.class, \"getAuthority\", exception);\n                return Citations.EPSG;\n            }\n        return authority;\n    }\n\n    /**\n     * Returns a description of the database engine.\n     *\n     * @throws FactoryException if the database's metadata can't be fetched.\n     */\n    @Override\n    public synchronized String getBackingStoreDescription() throws FactoryException {\n        final Citation authority = getAuthority();\n        try (TableWriter table = new TableWriter(null, \" \")) {\n            final Vocabulary resources = Vocabulary.getResources(null);\n            CharSequence cs;\n            if ((cs = authority.getEdition()) != null) {\n                table.write(resources.getString(VocabularyKeys.VERSION_OF_$1, \"EPSG\"));\n                table.write(':');\n                table.nextColumn();\n                table.write(cs.toString());\n                table.nextLine();\n            }\n            try {\n                String s;\n                final DatabaseMetaData metadata = getConnection().getMetaData();\n                if ((s = metadata.getDatabaseProductName()) != null) {\n                    table.write(resources.getLabel(VocabularyKeys.DATABASE_ENGINE));\n                    table.nextColumn();\n                    table.write(s);\n                    if ((s = metadata.getDatabaseProductVersion()) != null) {\n                        table.write(' ');\n                        table.write(resources.getString(VocabularyKeys.VERSION_$1, s));\n                    }\n                    table.nextLine();\n                }\n                if ((s = metadata.getURL()) != null) {\n                    table.write(resources.getLabel(VocabularyKeys.DATABASE_URL));\n                    table.nextColumn();\n                    table.write(s);\n                    table.nextLine();\n                }\n            } catch (SQLException exception) {\n                throw new FactoryException(exception);\n            }\n            return table.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Returns the implementation hints for this factory. The returned map contains all the values\n     * specified in {@linkplain DirectAuthorityFactory#getImplementationHints subclass}, with the\n     * addition of {@link Hints#VERSION VERSION}.\n     */\n    @Override\n    public Map<RenderingHints.Key, ?> getImplementationHints() {\n        if (authority == null) {\n            // For the computation of Hints.VERSION.\n            getAuthority();\n        }\n        return super.getImplementationHints();\n    }\n\n    /**\n     * Returns the set of authority codes of the given type.\n     *\n     * @param type The spatial reference objects type (may be {@code Object.class}).\n     * @return The set of authority codes for spatial reference objects of the given type. If this\n     *     factory doesn't contains any object of the given type, then this method returns an empty\n     *     set.\n     * @throws FactoryException if access to the underlying database failed.\n     */\n    @Override\n    protected synchronized Set<String> generateAuthorityCodes(final Class type)\n            throws FactoryException {\n        Set<String> result = new HashSet<>();\n        for (final TableInfo table : TABLES_INFO) {\n            if (table.isTypeOf(type)) {\n                final AuthorityCodeSet codes = new AuthorityCodeSet(table, type);\n                result.addAll(codes);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets a description of the object corresponding to a code.\n     *\n     * @param code Value allocated by authority.\n     * @return A description of the object, or {@code null} if the object corresponding to the\n     *     specified {@code code} has no description.\n     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.\n     * @throws FactoryException if the query failed for some other reason.\n     */\n    @Override\n    public InternationalString getDescriptionText(final String code) throws FactoryException {\n        IdentifiedObject identifiedObject = createObject(code);\n        final Identifier identifier = identifiedObject.getName();\n        if (identifier instanceof GenericName) {\n            return ((GenericName) identifier).toInternationalString();\n        }\n        return new SimpleInternationalString(identifier.getCode());\n    }\n\n    /**\n     * Returns a prepared statement for the specified name. Most {@link PreparedStatement} creations\n     * are performed through this method, except {@link #getNumericalIdentifier} and {@link\n     * #createObject}.\n     *\n     * @param key A key uniquely identifying the caller (e.g. {@code \"Ellipsoid\"} for {@link\n     *     #createEllipsoid}).\n     * @param sql The SQL statement to use if for creating the {@link PreparedStatement} object.\n     *     Will be used only if no prepared statement was already created for the specified key.\n     * @return The prepared statement.\n     * @throws SQLException if the prepared statement can't be created.\n     */\n    private PreparedStatement prepareStatement(final String key, final String sql)\n            throws SQLException {\n        assert Thread.holdsLock(this);\n        PreparedStatement stmt = statements.get(key);\n        if (stmt == null) {\n            stmt = getConnection().prepareStatement(adaptSQL(sql));\n            statements.put(key, stmt);\n        }\n        return stmt;\n    }\n\n    /**\n     * Gets the string from the specified {@link ResultSet}. The string is required to be non-null.\n     * A null string will throw an exception.\n     *\n     * @param result The result set to fetch value from.\n     * @param columnIndex The column index (1-based).\n     * @param code The identifier of the record where the string was found.\n     * @return The string at the specified column.\n     * @throws SQLException if a SQL error occured.\n     * @throws FactoryException If a null value was found.\n     */\n    private static String getString(\n            final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        final String value = result.getString(columnIndex);\n        ensureNonNull(result, columnIndex, code);\n        return value.trim();\n    }\n\n    /**\n     * Same as {@link #getString(ResultSet,int,String)}, but report the fault on an alternative\n     * column if the value is null.\n     */\n    private static String getString(\n            final ResultSet result, final int columnIndex, final String code, final int columnFault)\n            throws SQLException, FactoryException {\n        final String str = result.getString(columnIndex);\n        if (result.wasNull()) {\n            final ResultSetMetaData metadata = result.getMetaData();\n            final String column = metadata.getColumnName(columnFault);\n            final String table = metadata.getTableName(columnFault);\n            result.close();\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.NULL_VALUE_IN_TABLE_$3, code, column, table));\n        }\n        return str.trim();\n    }\n\n    /**\n     * Gets the value from the specified {@link ResultSet}. The value is required to be non-null. A\n     * null value (i.e. blank) will throw an exception.\n     *\n     * @param result The result set to fetch value from.\n     * @param columnIndex The column index (1-based).\n     * @param code The identifier of the record where the string was found.\n     * @return The double at the specified column.\n     * @throws SQLException if a SQL error occured.\n     * @throws FactoryException If a null value was found.\n     */\n    private static double getDouble(\n            final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        final double value = result.getDouble(columnIndex);\n        ensureNonNull(result, columnIndex, code);\n        return value;\n    }\n\n    /**\n     * Gets the value from the specified {@link ResultSet}. The value is required to be non-null. A\n     * null value (i.e. blank) will throw an exception.\n     *\n     * @param result The result set to fetch value from.\n     * @param columnIndex The column index (1-based).\n     * @param code The identifier of the record where the string was found.\n     * @return The integer at the specified column.\n     * @throws SQLException if a SQL error occured.\n     * @throws FactoryException If a null value was found.\n     */\n    private static int getInt(final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        final int value = result.getInt(columnIndex);\n        ensureNonNull(result, columnIndex, code);\n        return value;\n    }\n\n    /**\n     * Make sure that the last result was non-null. Used for {@code getString}, {@code getDouble}\n     * and {@code getInt} methods only.\n     */\n    private static void ensureNonNull(\n            final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        if (result.wasNull()) {\n            final ResultSetMetaData metadata = result.getMetaData();\n            final String column = metadata.getColumnName(columnIndex);\n            final String table = metadata.getTableName(columnIndex);\n            result.close();\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.NULL_VALUE_IN_TABLE_$3, code, column, table));\n        }\n    }\n\n    /**\n     * Converts a code from an arbitrary name to the numerical identifier (the primary key). If the\n     * supplied code is already a numerical value, then it is returned unchanged. If the code is not\n     * found in the name column, it is returned unchanged as well so that the caller will produces\n     * an appropriate \"Code not found\" error message. If the code is found more than once, then an\n     * exception is thrown.\n     *\n     * <p>Note that this method includes a call to {@link #trimAuthority}, so there is no need to\n     * call it before or after this method.\n     *\n     * @param type The type of object to create.\n     * @param code The code to check.\n     * @param table The table where the code should appears.\n     * @param codeColumn The column name for the code.\n     * @param nameColumn The column name for the name.\n     * @return The numerical identifier (i.e. the table primary key value).\n     * @throws SQLException if an error occured while reading the database.\n     */\n    private String toPrimaryKey(\n            final Class type,\n            final String code,\n            final String table,\n            final String codeColumn,\n            final String nameColumn)\n            throws SQLException, FactoryException {\n        assert Thread.holdsLock(this);\n        String identifier = trimAuthority(code);\n        if (!isPrimaryKey(identifier)) {\n            /*\n             * The character is not the numerical code. Search the value in the database.\n             * If a prepared statement is already available, reuse it providing that it was\n             * created for the current table. Otherwise, we will create a new statement.\n             */\n            final String KEY = \"NumericalIdentifier\";\n            PreparedStatement statement = statements.get(KEY);\n            if (statement != null) {\n                if (!table.equals(lastTableForName)) {\n                    statements.remove(KEY);\n                    statement.close();\n                    statement = null;\n                    lastTableForName = null;\n                }\n            }\n            if (statement == null) {\n                final String query =\n                        \"SELECT \" + codeColumn + \" FROM \" + table + \" WHERE \" + nameColumn + \" = ?\";\n                statement = getConnection().prepareStatement(adaptSQL(query));\n                statements.put(KEY, statement);\n            }\n            statement.setString(1, identifier);\n            identifier = null;\n            try (ResultSet result = statement.executeQuery()) {\n                while (result.next()) {\n                    identifier = ensureSingleton(result.getString(1), identifier, code);\n                }\n            }\n            if (identifier == null) {\n                throw noSuchAuthorityCode(type, code);\n            }\n        }\n        return identifier;\n    }\n\n    /**\n     * Make sure that an object constructed from the database is not incoherent. If the code\n     * supplied to a {@code createFoo} method exists in the database, then we should find only one\n     * record. However, we will do a paranoiac check and verify if there is more records, using a\n     * {@code while (results.next())} loop instead of {@code if (results.next())}. This method is\n     * invoked in the loop for making sure that, if there is more than one record (which should\n     * never happen), at least they have identical contents.\n     *\n     * @param newValue The newly constructed object.\n     * @param oldValue The object previously constructed, or {@code null} if none.\n     * @param code The EPSG code (for formatting error message).\n     * @throws FactoryException if a duplication has been detected.\n     * @todo Use generic type when we will be allowed to compile for J2SE 1.5.\n     */\n    private static <T> T ensureSingleton(final T newValue, final T oldValue, final String code)\n            throws FactoryException {\n        if (oldValue == null) {\n            return newValue;\n        }\n        if (oldValue.equals(newValue)) {\n            return oldValue;\n        }\n        throw new FactoryException(Errors.format(ErrorKeys.DUPLICATED_VALUES_$1, code));\n    }\n\n    /**\n     * Returns the name for the {@link IdentifiedObject} to construct. This method also search for\n     * alias.\n     *\n     * @param name The name for the {@link IndentifiedObject} to construct.\n     * @param code The EPSG code of the object to construct.\n     * @param remarks Remarks, or {@code null} if none.\n     * @return The name together with a set of properties.\n     */\n    private Map<String, Object> generateProperties(\n            final String name, final String code, String remarks)\n            throws SQLException, FactoryException {\n        properties.clear();\n        final Citation authority = getAuthority();\n        if (name != null) {\n            properties.put(IdentifiedObject.NAME_KEY, new NamedIdentifier(authority, name.trim()));\n        }\n        if (code != null) {\n            final InternationalString edition = authority.getEdition();\n            final String version = (edition != null) ? edition.toString() : null;\n            properties.put(\n                    IdentifiedObject.IDENTIFIERS_KEY,\n                    new NamedIdentifier(authority, code.trim(), version));\n        }\n        if (remarks != null && (remarks = remarks.trim()).length() != 0) {\n            properties.put(IdentifiedObject.REMARKS_KEY, remarks);\n        }\n        /*\n         * Search for alias.\n         */\n        List<GenericName> alias = null;\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"Alias\",\n                        \"SELECT NAMING_SYSTEM_NAME, ALIAS\"\n                                + \" FROM [Alias] INNER JOIN [Naming System]\"\n                                + \" ON [Alias].NAMING_SYSTEM_CODE =\"\n                                + \" [Naming System].NAMING_SYSTEM_CODE\"\n                                + \" WHERE OBJECT_CODE = ?\");\n        stmt.setString(1, code);\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String scope = result.getString(1);\n                final String local = getString(result, 2, code);\n                final GenericName generic;\n                if (scope == null) {\n                    generic = new LocalName(local);\n                } else {\n                    LocalName cached = scopes.get(scope);\n                    if (cached == null) {\n                        cached = new LocalName(scope);\n                        scopes.put(scope, cached);\n                    }\n                    generic = new ScopedName(cached, local);\n                }\n                if (alias == null) {\n                    alias = new ArrayList<>();\n                }\n                alias.add(generic);\n            }\n        }\n        if (alias != null) {\n            properties.put(\n                    IdentifiedObject.ALIAS_KEY, alias.toArray(new GenericName[alias.size()]));\n        }\n        return properties;\n    }\n\n    /**\n     * Returns the name for the {@link IdentifiedObject} to construct. This method also search for\n     * alias.\n     *\n     * @param name The name for the {@link IndentifiedObject} to construct.\n     * @param code The EPSG code of the object to construct.\n     * @param area The area of use, or {@code null} if none.\n     * @param scope The scope, or {@code null} if none.\n     * @param remarks Remarks, or {@code null} if none.\n     * @return The name together with a set of properties.\n     */\n    private Map<String, Object> generateProperties(\n            final String name, final String code, String area, String scope, String remarks)\n            throws SQLException, FactoryException {\n        final Map<String, Object> properties = generateProperties(name, code, remarks);\n        if (area != null && (area = area.trim()).length() != 0) {\n            final Extent extent = generateExtent(area);\n            properties.put(Datum.DOMAIN_OF_VALIDITY_KEY, extent);\n        }\n        if (scope != null && (scope = scope.trim()).length() != 0) {\n            properties.put(Datum.SCOPE_KEY, scope);\n        }\n        return properties;\n    }\n\n    /**\n     * Returns an arbitrary object from a code. The default implementation invokes one of {@link\n     * #createCoordinateReferenceSystem}, {@link #createCoordinateSystem}, {@link #createDatum},\n     * {@link #createEllipsoid}, or {@link #createUnit} methods according the object type.\n     *\n     * @param code The EPSG value.\n     * @return The object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    @SuppressWarnings(\"PMD.OverrideBothEqualsAndHashcode\")\n    public synchronized IdentifiedObject generateObject(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        final String KEY = \"IdentifiedObject\";\n        PreparedStatement stmt = statements.get(KEY); // Null allowed.\n        StringBuilder query = null; // Will be created only if the last statement doesn't suit.\n        /*\n         * Iterates through all tables listed in TABLES_INFO, starting with the table used during\n         * the last call to 'createObject(code)'.  This approach assumes that two consecutive calls\n         * will often return the same type of object.  If the object type changed, then this method\n         * will have to discard the old prepared statement and prepare a new one, which may be a\n         * costly operation. Only the last successful prepared statement is cached, in order to keep\n         * the amount of statements low. Unsuccessful statements are immediately disposed.\n         */\n        final String epsg = trimAuthority(code);\n        final boolean isPrimaryKey = isPrimaryKey(epsg);\n        final int tupleToSkip = isPrimaryKey ? lastObjectType : -1;\n        int index = -1;\n        for (int i = -1; i < TABLES_INFO.length; i++) {\n            if (i == tupleToSkip) {\n                // Avoid to test the same table twice.  Note that this test also avoid a\n                // NullPointerException if 'stmt' is null, since 'lastObjectType' should\n                // be -1 in this case.\n                continue;\n            }\n            try {\n                if (i >= 0) {\n                    final TableInfo table = TABLES_INFO[i];\n                    final String column = isPrimaryKey ? table.codeColumn : table.nameColumn;\n                    if (column == null) {\n                        continue;\n                    }\n                    if (query == null) {\n                        query = new StringBuilder(\"SELECT \");\n                    }\n                    query.setLength(7); // 7 is the length of \"SELECT \" in the line above.\n                    query.append(table.codeColumn);\n                    query.append(\" FROM \");\n                    query.append(table.table);\n                    query.append(\" WHERE \");\n                    query.append(column);\n                    query.append(\" = ?\");\n                    if (isPrimaryKey) {\n                        assert !statements.containsKey(KEY) : table;\n                        stmt = prepareStatement(KEY, query.toString());\n                    } else {\n                        // Do not cache the statement for names.\n                        stmt = getConnection().prepareStatement(adaptSQL(query.toString()));\n                    }\n                }\n                /*\n                 * Checks if at least one record is found for the code. If the code is the primary\n                 * key, then we will stop at the first table found since a well-formed EPSG database\n                 * should not contains any duplicate identifiers. In the code is a name, then search\n                 * in all tables since duplicate names exist.\n                 */\n                stmt.setString(1, epsg);\n                try (final ResultSet result = stmt.executeQuery()) {\n                    final boolean present = result.next();\n                    if (present) {\n                        if (index >= 0) {\n                            throw new FactoryException(\n                                    Errors.format(ErrorKeys.DUPLICATED_VALUES_$1, code));\n                        }\n                        index = (i < 0) ? lastObjectType : i;\n                        if (isPrimaryKey) {\n                            // Don't scan other tables, since primary keys should be unique.\n                            // Note that names may be duplicated, so we don't stop for names.\n                            break;\n                        }\n                    }\n                }\n                if (isPrimaryKey) {\n                    if (statements.remove(KEY) == null) {\n                        throw new AssertionError(code); // Should never happen.\n                    }\n                }\n                stmt.close();\n            } catch (SQLException exception) {\n                throw databaseFailure(IdentifiedObject.class, code, exception);\n            }\n        }\n        /*\n         * If a record has been found in one table, then delegates to the appropriate method.\n         */\n        if (isPrimaryKey) {\n            lastObjectType = index;\n        }\n        if (index >= 0) {\n            switch (index) {\n                case 0:\n                    return createCoordinateReferenceSystem(code);\n                case 1:\n                    return createCoordinateSystem(code);\n                case 2:\n                    return createCoordinateSystemAxis(code);\n                case 3:\n                    return createDatum(code);\n                case 4:\n                    return createEllipsoid(code);\n                case 5:\n                    return createPrimeMeridian(code);\n                case 6:\n                    return createCoordinateOperation(code);\n                case 7:\n                    return generateOperationMethod(code);\n                case 8:\n                    return generateParameterDescriptor(code);\n                case 9:\n                    break; // Can't cast Unit to IdentifiedObject\n                default:\n                    throw new AssertionError(index); // Should not happen\n            }\n        }\n        return super.createObject(code);\n    }\n\n    /**\n     * Returns an unit from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The unit object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized Unit<?> generateUnit(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Unit<?> returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            Unit.class, code, \"[Unit of Measure]\", \"UOM_CODE\", \"UNIT_OF_MEAS_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Unit\",\n                            \"SELECT UOM_CODE,\"\n                                    + \" FACTOR_B,\"\n                                    + \" FACTOR_C,\"\n                                    + \" TARGET_UOM_CODE\"\n                                    + \" FROM [Unit of Measure]\"\n                                    + \" WHERE UOM_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final int source = getInt(result, 1, code);\n                    final double b = result.getDouble(2);\n                    final double c = result.getDouble(3);\n                    final int target = getInt(result, 4, code);\n                    final Unit<?> base = getUnit(target);\n                    if (base == null) {\n                        throw noSuchAuthorityCode(Unit.class, String.valueOf(target));\n                    }\n                    Unit unit = getUnit(source);\n                    if (unit == null) {\n                        // TODO: check unit consistency here.\n                        if (b != 0 && c != 0) {\n                            unit = (b == c) ? base : base.multiply(b / c);\n                        } else {\n                            // TODO: provide a localized message.\n                            throw new FactoryException(\"Unsupported unit: \" + code);\n                        }\n                    }\n                    returnValue = ensureSingleton(unit, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Unit.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Unit.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns an ellipsoid from a code.\n     *\n     * @param code The EPSG value.\n     * @return The ellipsoid object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized Ellipsoid generateEllipsoid(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Ellipsoid returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            Ellipsoid.class,\n                            code,\n                            \"[Ellipsoid]\",\n                            \"ELLIPSOID_CODE\",\n                            \"ELLIPSOID_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Ellipsoid\",\n                            \"SELECT ELLIPSOID_CODE,\"\n                                    + \" ELLIPSOID_NAME,\"\n                                    + \" SEMI_MAJOR_AXIS,\"\n                                    + \" INV_FLATTENING,\"\n                                    + \" SEMI_MINOR_AXIS,\"\n                                    + \" UOM_CODE,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Ellipsoid]\"\n                                    + \" WHERE ELLIPSOID_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    /*\n                     * One of 'semiMinorAxis' and 'inverseFlattening' values can be NULL in\n                     * the database. Consequently, we don't use 'getString(ResultSet, int)'\n                     * because we don't want to thrown an exception if a NULL value is found.\n                     */\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final double semiMajorAxis = getDouble(result, 3, code);\n                    final double inverseFlattening = result.getDouble(4);\n                    final double semiMinorAxis = result.getDouble(5);\n                    final String unitCode = getString(result, 6, code);\n                    final String remarks = result.getString(7);\n                    @SuppressWarnings(\"unchecked\")\n                    final Unit<Length> unit = (Unit<Length>) createUnit(unitCode);\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    final Ellipsoid ellipsoid;\n                    if (inverseFlattening == 0) {\n                        if (semiMinorAxis == 0) {\n                            // Both are null, which is not allowed.\n                            final String column = result.getMetaData().getColumnName(3);\n                            result.close();\n                            throw new FactoryException(\n                                    Errors.format(ErrorKeys.NULL_VALUE_IN_TABLE_$3, code, column));\n                        } else {\n                            // We only have semiMinorAxis defined -> it's OK\n                            ellipsoid =\n                                    factories\n                                            .getDatumFactory()\n                                            .createEllipsoid(\n                                                    properties, semiMajorAxis, semiMinorAxis, unit);\n                        }\n                    } else {\n                        if (semiMinorAxis != 0) {\n                            // Both 'inverseFlattening' and 'semiMinorAxis' are defined.\n                            // Log a warning and create the ellipsoid using the inverse flattening.\n                            final LogRecord record =\n                                    Loggings.format(\n                                            Level.WARNING, LoggingKeys.AMBIGUOUS_ELLIPSOID, code);\n                            record.setLoggerName(LOGGER.getName());\n                            LOGGER.log(record);\n                        }\n                        ellipsoid =\n                                factories\n                                        .getDatumFactory()\n                                        .createFlattenedSphere(\n                                                properties, semiMajorAxis, inverseFlattening, unit);\n                    }\n                    /*\n                     * Now that we have built an ellipsoid, compare\n                     * it with the previous one (if any).\n                     */\n                    returnValue = ensureSingleton(ellipsoid, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Ellipsoid.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Ellipsoid.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns a prime meridian, relative to Greenwich.\n     *\n     * @param code Value allocated by authority.\n     * @return The prime meridian object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized PrimeMeridian generatePrimeMeridian(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        PrimeMeridian returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            PrimeMeridian.class,\n                            code,\n                            \"[Prime Meridian]\",\n                            \"PRIME_MERIDIAN_CODE\",\n                            \"PRIME_MERIDIAN_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"PrimeMeridian\",\n                            \"SELECT PRIME_MERIDIAN_CODE,\"\n                                    + \" PRIME_MERIDIAN_NAME,\"\n                                    + \" GREENWICH_LONGITUDE,\"\n                                    + \" UOM_CODE,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Prime Meridian]\"\n                                    + \" WHERE PRIME_MERIDIAN_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final double longitude = getDouble(result, 3, code);\n                    final String unit_code = getString(result, 4, code);\n                    final String remarks = result.getString(5);\n                    @SuppressWarnings(\"unchecked\")\n                    final Unit<javax.measure.quantity.Angle> unit =\n                            (Unit<Angle>) createUnit(unit_code);\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    PrimeMeridian primeMeridian =\n                            factories\n                                    .getDatumFactory()\n                                    .createPrimeMeridian(properties, longitude, unit);\n                    returnValue = ensureSingleton(primeMeridian, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(PrimeMeridian.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(PrimeMeridian.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns an area of use.\n     *\n     * @param code Value allocated by authority.\n     * @return The area of use.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    public synchronized Extent generateExtent(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Extent returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(Extent.class, code, \"[Area]\", \"AREA_CODE\", \"AREA_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Area\",\n                            \"SELECT AREA_OF_USE,\"\n                                    + \" AREA_SOUTH_BOUND_LAT,\"\n                                    + \" AREA_NORTH_BOUND_LAT,\"\n                                    + \" AREA_WEST_BOUND_LON,\"\n                                    + \" AREA_EAST_BOUND_LON\"\n                                    + \" FROM [Area]\"\n                                    + \" WHERE AREA_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    ExtentImpl extent = null;\n                    final String description = result.getString(1);\n                    if (description != null) {\n                        extent = new ExtentImpl();\n                        extent.setDescription(new SimpleInternationalString(description));\n                    }\n                    final double ymin = result.getDouble(2);\n                    if (!result.wasNull()) {\n                        final double ymax = result.getDouble(3);\n                        if (!result.wasNull()) {\n                            final double xmin = result.getDouble(4);\n                            if (!result.wasNull()) {\n                                final double xmax = result.getDouble(5);\n                                if (!result.wasNull()) {\n                                    if (extent == null) {\n                                        extent = new ExtentImpl();\n                                    }\n                                    extent.setGeographicElements(\n                                            Collections.singleton(\n                                                    new GeographicBoundingBoxImpl(\n                                                            xmin, xmax, ymin, ymax)));\n                                }\n                            }\n                        }\n                    }\n                    if (extent != null) {\n                        returnValue =\n                                (Extent) ensureSingleton(extent.unmodifiable(), returnValue, code);\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Extent.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Extent.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns Bursa-Wolf parameters for a geodetic datum. If the specified datum has no conversion\n     * informations, then this method will returns {@code null}.\n     *\n     * @param code The EPSG code of the {@link GeodeticDatum}.\n     * @param toClose The result set to close if this method is going to invokes {@link\n     *     #createDatum} recursively. This hack is necessary because many JDBC drivers do not\n     *     support multiple result sets for the same statement. The result set is closed if an only\n     *     if this method returns a non-null value.\n     * @return an array of Bursa-Wolf parameters (in which case {@code toClose} has been closed), or\n     *     {@code null} (in which case {@code toClose} has <strong>not</strong> been closed).\n     */\n    private BursaWolfParameters[] generateBursaWolfParameters(\n            final String code, final ResultSet toClose) throws SQLException, FactoryException {\n        if (safetyGuard.contains(code)) {\n            /*\n             * Do not try to create Bursa-Wolf parameters if the datum is already\n             * in process of being created. This check avoid never-ending loops in\n             * recursive call to 'createDatum'.\n             */\n            return null;\n        }\n        PreparedStatement stmt =\n                prepareStatement(\n                        \"BursaWolfParametersSet\",\n                        \"SELECT CO.COORD_OP_CODE,\"\n                                + \" CO.COORD_OP_METHOD_CODE,\"\n                                + \" CRS2.DATUM_CODE\"\n                                + \" FROM [Coordinate_Operation] AS CO\"\n                                + \" INNER JOIN [Coordinate Reference System] AS CRS2\"\n                                + \" ON CO.TARGET_CRS_CODE = CRS2.COORD_REF_SYS_CODE\"\n                                + \" WHERE CO.COORD_OP_METHOD_CODE >= \"\n                                + BURSA_WOLF_MIN_CODE\n                                + \" AND CO.COORD_OP_METHOD_CODE <= \"\n                                + BURSA_WOLF_MAX_CODE\n                                + \" AND CO.COORD_OP_CODE <> \"\n                                + DUMMY_OPERATION // GEOT-1008\n                                + \" AND CO.SOURCE_CRS_CODE IN (\"\n                                + \" SELECT CRS1.COORD_REF_SYS_CODE \" // GEOT-1129\n                                + \" FROM [Coordinate Reference System] AS CRS1 \"\n                                + \" WHERE CRS1.DATUM_CODE = ?)\"\n                                + \" ORDER BY CRS2.DATUM_CODE,\"\n                                + \" ABS(CO.DEPRECATED), CO.COORD_OP_ACCURACY,\"\n                                + \" CO.COORD_OP_CODE DESC\"); // GEOT-846 fix\n        stmt.setString(1, code);\n        List<Object> bwInfos = null;\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String operation = getString(result, 1, code);\n                final int method = getInt(result, 2, code);\n                final String datum = getString(result, 3, code);\n                if (bwInfos == null) {\n                    bwInfos = new ArrayList<>();\n                }\n                bwInfos.add(new BursaWolfInfo(operation, method, datum));\n            }\n        }\n        if (bwInfos == null) {\n            // Don't close the connection here.\n            return null;\n        }\n        toClose.close();\n        /*\n         * Sorts the infos in preference order. The \"ORDER BY\" clause above was not enough;\n         * we also need to take the \"supersession\" table in account. Once the sorting is done,\n         * keep only one Bursa-Wolf parameters for each datum.\n         */\n        int size = bwInfos.size();\n        if (size > 1) {\n            final BursaWolfInfo[] codes = bwInfos.toArray(new BursaWolfInfo[size]);\n            sort(codes);\n            bwInfos.clear();\n            final Set<String> added = new HashSet<>();\n            for (final BursaWolfInfo candidate : codes) {\n                if (added.add(candidate.target)) {\n                    bwInfos.add(candidate);\n                }\n            }\n            size = bwInfos.size();\n        }\n        /*\n         * We got all the needed informations before to built Bursa-Wolf parameters because the\n         * 'createDatum(...)' call below may invokes 'createBursaWolfParameters(...)' recursively,\n         * and not all JDBC drivers supported multi-result set for the same statement. Now, iterate\n         * throw the results and fetch the parameter values for each BursaWolfParameters object.\n         */\n        stmt =\n                prepareStatement(\n                        \"BursaWolfParameters\",\n                        \"SELECT PARAMETER_CODE,\"\n                                + \" PARAMETER_VALUE,\"\n                                + \" UOM_CODE\"\n                                + \" FROM [Coordinate_Operation Parameter Value]\"\n                                + \" WHERE COORD_OP_CODE = ?\"\n                                + \" AND COORD_OP_METHOD_CODE = ?\");\n        for (int i = 0; i < size; i++) {\n            final BursaWolfInfo info = (BursaWolfInfo) bwInfos.get(i);\n            final GeodeticDatum datum;\n            try {\n                safetyGuard.add(code);\n                datum = createGeodeticDatum(info.target);\n            } finally {\n                safetyGuard.remove(code);\n            }\n            final BursaWolfParameters parameters = new BursaWolfParameters(datum);\n            stmt.setString(1, info.operation);\n            stmt.setInt(2, info.method);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    setBursaWolfParameter(\n                            parameters,\n                            getInt(result, 1, info.operation),\n                            getDouble(result, 2, info.operation),\n                            createUnit(getString(result, 3, info.operation)));\n                }\n            }\n            if (info.method == ROTATION_FRAME_CODE) {\n                // Coordinate frame rotation (9607): same as 9606,\n                // except for the sign of rotation parameters.\n                parameters.ex = -parameters.ex;\n                parameters.ey = -parameters.ey;\n                parameters.ey = -parameters.ey;\n            }\n            bwInfos.set(i, parameters);\n        }\n        return bwInfos.toArray(new BursaWolfParameters[size]);\n    }\n\n    /**\n     * Returns a datum from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The datum object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     * @todo Current implementation maps all \"vertical\" datum to {@link VerticalDatumType#GEOIDAL}.\n     *     We don't know yet how to maps the exact vertical datum type from the EPSG database.\n     */\n    @Override\n    public synchronized Datum generateDatum(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Datum returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(Datum.class, code, \"[Datum]\", \"DATUM_CODE\", \"DATUM_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Datum\",\n                            \"SELECT DATUM_CODE,\"\n                                    + \" DATUM_NAME,\"\n                                    + \" DATUM_TYPE,\"\n                                    + \" ORIGIN_DESCRIPTION,\"\n                                    + \" REALIZATION_EPOCH,\"\n                                    + \" AREA_OF_USE_CODE,\"\n                                    + \" DATUM_SCOPE,\"\n                                    + \" REMARKS,\"\n                                    + \" ELLIPSOID_CODE,\" // Only for geodetic type\n                                    + \" PRIME_MERIDIAN_CODE\" // Only for geodetic type\n                                    + \" FROM [Datum]\"\n                                    + \" WHERE DATUM_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                boolean exit = false;\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String type = getString(result, 3, code).trim().toLowerCase();\n                    final String anchor = result.getString(4);\n                    final Date epoch = result.getDate(5);\n                    final String area = result.getString(6);\n                    final String scope = result.getString(7);\n                    final String remarks = result.getString(8);\n                    Map<String, Object> properties =\n                            generateProperties(name, epsg, area, scope, remarks);\n                    if (anchor != null) {\n                        properties.put(Datum.ANCHOR_POINT_KEY, anchor);\n                    }\n                    if (epoch != null)\n                        try {\n                            properties.put(Datum.REALIZATION_EPOCH_KEY, epoch);\n                        } catch (NumberFormatException exception) {\n                            // Not a fatal error...\n                            Logging.unexpectedException(\n                                    LOGGER, AbstractEpsgFactory.class, \"createDatum\", exception);\n                        }\n                    final DatumFactory factory = factories.getDatumFactory();\n                    final Datum datum;\n                    /*\n                     * Now build datum according their datum type. Constructions are straightforward,\n                     * except for the \"geodetic\" datum type which need some special processing:\n                     *\n                     *   - Because it invokes again 'generateProperties' indirectly (through calls to\n                     *     'createEllipsoid' and 'createPrimeMeridian'), it must protect 'properties'\n                     *     from changes.\n                     *\n                     *   - Because 'createBursaWolfParameters' may invokes 'createDatum' recursively,\n                     *     we must close the result set if Bursa-Wolf parameters are found. In this\n                     *     case, we lost our paranoiac check for duplication.\n                     */\n                    if (type.equals(\"geodetic\")) {\n                        properties = new HashMap<>(properties); // Protect from changes\n                        final Ellipsoid ellipsoid = createEllipsoid(getString(result, 9, code));\n                        final PrimeMeridian meridian =\n                                createPrimeMeridian(getString(result, 10, code));\n                        final BursaWolfParameters[] param =\n                                generateBursaWolfParameters(primaryKey, result);\n\n                        if (param != null) {\n                            exit = true;\n                            properties.put(DefaultGeodeticDatum.BURSA_WOLF_KEY, param);\n                        }\n                        datum = factory.createGeodeticDatum(properties, ellipsoid, meridian);\n                    } else if (type.equals(\"vertical\")) {\n                        // TODO: Find the right datum type.\n                        datum = factory.createVerticalDatum(properties, VerticalDatumType.GEOIDAL);\n                    } else if (type.equals(\"engineering\")) {\n                        datum = factory.createEngineeringDatum(properties);\n                    } else {\n                        result.close();\n                        throw new FactoryException(Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                    }\n                    returnValue = ensureSingleton(datum, returnValue, code);\n                    if (exit) {\n                        // Bypass the 'result.close()' line below:\n                        // the ResultSet has already been closed.\n                        return returnValue;\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Datum.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Datum.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the name and description for the specified {@linkplain CoordinateSystemAxis\n     * coordinate system axis} code. Many axis share the same name and description, so it is worth\n     * to cache them.\n     */\n    private AxisName getAxisName(final String code) throws FactoryException {\n        assert Thread.holdsLock(this);\n        AxisName returnValue = axisNames.get(code);\n        if (returnValue == null)\n            try {\n                final PreparedStatement stmt =\n                        prepareStatement(\n                                \"AxisName\",\n                                \"SELECT COORD_AXIS_NAME, DESCRIPTION, REMARKS\"\n                                        + \" FROM [Coordinate Axis Name]\"\n                                        + \" WHERE COORD_AXIS_NAME_CODE = ?\");\n                stmt.setString(1, code);\n                try (ResultSet result = stmt.executeQuery()) {\n                    while (result.next()) {\n                        final String name = getString(result, 1, code);\n                        String description = result.getString(2);\n                        String remarks = result.getString(3);\n                        if (description == null) {\n                            description = remarks;\n                        } else if (remarks != null) {\n                            description += System.getProperty(\"line.separator\", \"\\n\") + remarks;\n                        }\n                        final AxisName axis = new AxisName(name, description);\n                        returnValue = ensureSingleton(axis, returnValue, code);\n                    }\n                }\n                if (returnValue == null) {\n                    throw noSuchAuthorityCode(AxisName.class, code);\n                }\n                axisNames.put(code, returnValue);\n            } catch (SQLException exception) {\n                throw databaseFailure(AxisName.class, code, exception);\n            }\n        return returnValue;\n    }\n\n    /**\n     * Returns a {@linkplain CoordinateSystemAxis coordinate system axis} from a code.\n     *\n     * @param code Value allocated by authority.\n     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.\n     * @throws FactoryException if the object creation failed for some other reason.\n     */\n    @Override\n    public synchronized CoordinateSystemAxis generateCoordinateSystemAxis(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateSystemAxis returnValue = null;\n        try {\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Axis\",\n                            \"SELECT COORD_AXIS_CODE,\"\n                                    + \" COORD_AXIS_NAME_CODE,\"\n                                    + \" COORD_AXIS_ORIENTATION,\"\n                                    + \" COORD_AXIS_ABBREVIATION,\"\n                                    + \" UOM_CODE\"\n                                    + \" FROM [Coordinate Axis]\"\n                                    + \" WHERE COORD_AXIS_CODE = ?\");\n            stmt.setString(1, code);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String nameCode = getString(result, 2, code);\n                    final String orientation = getString(result, 3, code);\n                    final String abbreviation = getString(result, 4, code);\n                    final String unit = getString(result, 5, code);\n                    AxisDirection direction;\n                    try {\n                        direction = DefaultCoordinateSystemAxis.getDirection(orientation);\n                    } catch (NoSuchElementException exception) {\n                        if (orientation.equalsIgnoreCase(\"Geocentre > equator/PM\")) {\n                            direction = AxisDirection.OTHER; // TODO: can we choose a more accurate\n                            // direction?\n                        } else if (orientation.equalsIgnoreCase(\"Geocentre > equator/90dE\")) {\n                            direction = AxisDirection.EAST;\n                        } else if (orientation.equalsIgnoreCase(\"Geocentre > north pole\")) {\n                            direction = AxisDirection.NORTH;\n                        } else {\n                            throw new FactoryException(exception);\n                        }\n                    }\n                    final AxisName an = getAxisName(nameCode);\n                    final Map<String, Object> properties =\n                            generateProperties(an.name, epsg, an.description);\n                    final CSFactory factory = factories.getCSFactory();\n                    final CoordinateSystemAxis axis =\n                            factory.createCoordinateSystemAxis(\n                                    properties, abbreviation, direction, createUnit(unit));\n                    returnValue = ensureSingleton(axis, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateSystemAxis.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateSystemAxis.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the coordinate system axis from an EPSG code for a {@link CoordinateSystem}.\n     *\n     * <p><strong>WARNING:</strong> The EPSG database uses \"{@code ORDER}\" as a column name. This is\n     * tolerated by Access, but MySQL doesn't accept this name.\n     *\n     * @param code the EPSG code for coordinate system owner.\n     * @param dimension of the coordinate system, which is also the size of the returned array.\n     * @return An array of coordinate system axis.\n     * @throws SQLException if an error occured during database access.\n     * @throws FactoryException if the code has not been found.\n     */\n    private CoordinateSystemAxis[] generateAxisForCoordinateSystem(\n            final String code, final int dimension) throws SQLException, FactoryException {\n        assert Thread.holdsLock(this);\n        final CoordinateSystemAxis[] axis = new CoordinateSystemAxis[dimension];\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"AxisOrder\",\n                        \"SELECT COORD_AXIS_CODE\"\n                                + \" FROM [Coordinate Axis]\"\n                                + \" WHERE COORD_SYS_CODE = ?\"\n                                + \" ORDER BY [ORDER]\");\n        // WARNING: Be careful about the column name :\n        //          MySQL rejects ORDER as a column name !!!\n        stmt.setString(1, code);\n        int i = 0;\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String axisCode = getString(result, 1, code);\n                if (i < axis.length) {\n                    // If 'i' is out of bounds, an exception will be thrown after the loop.\n                    // We don't want to thrown an ArrayIndexOutOfBoundsException here.\n                    axis[i] = createCoordinateSystemAxis(axisCode);\n                }\n                ++i;\n            }\n        }\n        if (i != axis.length) {\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.MISMATCHED_DIMENSION_$2, axis.length, i));\n        }\n        return axis;\n    }\n\n    /**\n     * Returns a coordinate system from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The coordinate system object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized CoordinateSystem generateCoordinateSystem(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateSystem returnValue = null;\n        final PreparedStatement stmt;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            CoordinateSystem.class,\n                            code,\n                            \"[Coordinate System]\",\n                            \"COORD_SYS_CODE\",\n                            \"COORD_SYS_NAME\");\n            stmt =\n                    prepareStatement(\n                            \"CoordinateSystem\",\n                            \"SELECT COORD_SYS_CODE,\"\n                                    + \" COORD_SYS_NAME,\"\n                                    + \" COORD_SYS_TYPE,\"\n                                    + \" DIMENSION,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Coordinate System]\"\n                                    + \" WHERE COORD_SYS_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String type = getString(result, 3, code).trim().toLowerCase();\n                    final int dimension = getInt(result, 4, code);\n                    final String remarks = result.getString(5);\n                    final CoordinateSystemAxis[] axis =\n                            generateAxisForCoordinateSystem(primaryKey, dimension);\n                    final Map<String, Object> properties =\n                            generateProperties(name, epsg, remarks); // Must be after axis\n                    final CSFactory factory = factories.getCSFactory();\n                    CoordinateSystem cs = null;\n                    if (type.equals(\"ellipsoidal\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createEllipsoidalCS(properties, axis[0], axis[1]);\n                                break;\n                            case 3:\n                                cs =\n                                        factory.createEllipsoidalCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"cartesian\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createCartesianCS(properties, axis[0], axis[1]);\n                                break;\n                            case 3:\n                                cs =\n                                        factory.createCartesianCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"spherical\")) {\n                        switch (dimension) {\n                            case 3:\n                                cs =\n                                        factory.createSphericalCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"vertical\") || type.equals(\"gravity-related\")) {\n                        switch (dimension) {\n                            case 1:\n                                cs = factory.createVerticalCS(properties, axis[0]);\n                                break;\n                        }\n                    } else if (type.equals(\"linear\")) {\n                        switch (dimension) {\n                            case 1:\n                                cs = factory.createLinearCS(properties, axis[0]);\n                                break;\n                        }\n                    } else if (type.equals(\"polar\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createPolarCS(properties, axis[0], axis[1]);\n                                break;\n                        }\n                    } else if (type.equals(\"cylindrical\")) {\n                        switch (dimension) {\n                            case 3:\n                                cs =\n                                        factory.createCylindricalCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"affine\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createAffineCS(properties, axis[0], axis[1]);\n                                break;\n                            case 3:\n                                cs = factory.createAffineCS(properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else {\n                        result.close();\n                        throw new FactoryException(Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                    }\n                    if (cs == null) {\n                        result.close();\n                        throw new FactoryException(\n                                Errors.format(ErrorKeys.UNEXPECTED_DIMENSION_FOR_CS_$1, type));\n                    }\n                    returnValue = ensureSingleton(cs, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateSystem.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateSystem.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the primary key for a coordinate reference system name. This method is used both by\n     * {@link #createCoordinateReferenceSystem} and {@link\n     * #createFromCoordinateReferenceSystemCodes}\n     */\n    private String toPrimaryKeyCRS(final String code) throws SQLException, FactoryException {\n        return toPrimaryKey(\n                CoordinateReferenceSystem.class,\n                code,\n                \"[Coordinate Reference System]\",\n                \"COORD_REF_SYS_CODE\",\n                \"COORD_REF_SYS_NAME\");\n    }\n\n    /**\n     * Returns a coordinate reference system from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The coordinate reference system object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized CoordinateReferenceSystem generateCoordinateReferenceSystem(\n            final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateReferenceSystem returnValue = null;\n        try {\n            final String primaryKey = toPrimaryKeyCRS(code);\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"CoordinateReferenceSystem\",\n                            \"SELECT COORD_REF_SYS_CODE,\"\n                                    + \" COORD_REF_SYS_NAME,\"\n                                    + \" AREA_OF_USE_CODE,\"\n                                    + \" CRS_SCOPE,\"\n                                    + \" REMARKS,\"\n                                    + \" COORD_REF_SYS_KIND,\"\n                                    + \" COORD_SYS_CODE,\" // Null for CompoundCRS\n                                    + \" DATUM_CODE,\" // Null for ProjectedCRS\n                                    + \" SOURCE_GEOGCRS_CODE,\" // For ProjectedCRS\n                                    + \" PROJECTION_CONV_CODE,\" // For ProjectedCRS\n                                    + \" CMPD_HORIZCRS_CODE,\" // For CompoundCRS only\n                                    + \" CMPD_VERTCRS_CODE\" // For CompoundCRS only\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE COORD_REF_SYS_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            boolean exit = false;\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String area = result.getString(3);\n                    final String scope = result.getString(4);\n                    final String remarks = result.getString(5);\n                    final String type = getString(result, 6, code);\n                    // Note: Do not invoke 'generateProperties' now, even if we have all required\n                    //       informations, because the 'properties' map is going to overwritten\n                    //       by calls to 'createDatum', 'createCoordinateSystem', etc.\n                    final CRSFactory factory = factories.getCRSFactory();\n                    final CoordinateReferenceSystem crs;\n                    /* ----------------------------------------------------------------------\n                     *   GEOGRAPHIC CRS\n                     *\n                     *   NOTE: 'generateProperties' MUST be invoked after any call to an other\n                     *         'createFoo' method. Consequently, do not factor out.\n                     * ---------------------------------------------------------------------- */\n                    if (type.equalsIgnoreCase(\"geographic 2D\")\n                            || type.equalsIgnoreCase(\"geographic 3D\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = result.getString(8);\n                        final EllipsoidalCS cs = createEllipsoidalCS(csCode);\n                        final GeodeticDatum datum;\n                        if (dmCode != null) {\n                            datum = createGeodeticDatum(dmCode);\n                        } else {\n                            final String geoCode = getString(result, 9, code, 8);\n                            result.close(); // Must be close before createGeographicCRS\n                            exit = true;\n                            final GeographicCRS baseCRS = createGeographicCRS(geoCode);\n                            datum = baseCRS.getDatum();\n                        }\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createGeographicCRS(properties, datum, cs);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   PROJECTED CRS\n                     *\n                     *   NOTE: This method invokes itself indirectly, through createGeographicCRS.\n                     *         Consequently, we can't use 'result' anymore. We must close it here.\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"projected\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String geoCode = getString(result, 9, code);\n                        final String opCode = getString(result, 10, code);\n                        result.close(); // Must be close before createGeographicCRS\n                        exit = true;\n                        final CartesianCS cs = createCartesianCS(csCode);\n                        final GeographicCRS baseCRS = createGeographicCRS(geoCode);\n                        final CoordinateOperation op = createCoordinateOperation(opCode);\n                        if (op instanceof Conversion) {\n                            final Map<String, Object> properties =\n                                    generateProperties(name, epsg, area, scope, remarks);\n                            crs =\n                                    factory.createProjectedCRS(\n                                            properties, baseCRS, (Conversion) op, cs);\n                        } else {\n                            throw noSuchAuthorityCode(Projection.class, opCode);\n                        }\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   VERTICAL CRS\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"vertical\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = getString(result, 8, code);\n                        final VerticalCS cs = createVerticalCS(csCode);\n                        final VerticalDatum datum = createVerticalDatum(dmCode);\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createVerticalCRS(properties, datum, cs);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   COMPOUND CRS\n                     *\n                     *   NOTE: This method invokes itself recursively.\n                     *         Consequently, we can't use 'result' anymore.\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"compound\")) {\n                        final String code1 = getString(result, 11, code);\n                        final String code2 = getString(result, 12, code);\n                        result.close();\n                        exit = true;\n                        final CoordinateReferenceSystem crs1, crs2;\n                        if (!safetyGuard.add(epsg)) {\n                            throw recursiveCall(CompoundCRS.class, epsg);\n                        }\n                        try {\n                            crs1 = createCoordinateReferenceSystem(code1);\n                            crs2 = createCoordinateReferenceSystem(code2);\n                        } finally {\n                            safetyGuard.remove(epsg);\n                        }\n                        // Note: Don't invoke 'generateProperties' sooner.\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createCompoundCRS(properties, crs1, crs2);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   GEOCENTRIC CRS\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"geocentric\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = getString(result, 8, code);\n                        final CoordinateSystem cs = createCoordinateSystem(csCode);\n                        final GeodeticDatum datum = createGeodeticDatum(dmCode);\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        if (cs instanceof CartesianCS) {\n                            crs = factory.createGeocentricCRS(properties, datum, (CartesianCS) cs);\n                        } else if (cs instanceof SphericalCS) {\n                            crs = factory.createGeocentricCRS(properties, datum, (SphericalCS) cs);\n                        } else {\n                            result.close();\n                            throw new FactoryException(\n                                    Errors.format(\n                                            ErrorKeys.ILLEGAL_COORDINATE_SYSTEM_FOR_CRS_$2,\n                                            cs.getClass(),\n                                            GeocentricCRS.class));\n                        }\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   ENGINEERING CRS\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"engineering\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = getString(result, 8, code);\n                        final CoordinateSystem cs = createCoordinateSystem(csCode);\n                        final EngineeringDatum datum = createEngineeringDatum(dmCode);\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createEngineeringCRS(properties, datum, cs);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   UNKNOW CRS\n                     * ---------------------------------------------------------------------- */\n                    else {\n                        result.close();\n                        throw new FactoryException(Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                    }\n                    returnValue = ensureSingleton(crs, returnValue, code);\n                    if (exit) {\n                        // Bypass the 'result.close()' line below:\n                        // the ResultSet has already been closed.\n                        return returnValue;\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateReferenceSystem.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateReferenceSystem.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns a parameter descriptor from a code.\n     *\n     * @param code The parameter descriptor code allocated by EPSG authority.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    public synchronized ParameterDescriptor<?> generateParameterDescriptor(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        ParameterDescriptor<?> returnValue = null;\n        final PreparedStatement stmt;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            ParameterDescriptor.class,\n                            code,\n                            \"[Coordinate_Operation Parameter]\",\n                            \"PARAMETER_CODE\",\n                            \"PARAMETER_NAME\");\n            stmt =\n                    prepareStatement(\n                            \"ParameterDescriptor\", // Must be singular form.\n                            \"SELECT PARAMETER_CODE,\"\n                                    + \" PARAMETER_NAME,\"\n                                    + \" DESCRIPTION\"\n                                    + \" FROM [Coordinate_Operation Parameter]\"\n                                    + \" WHERE PARAMETER_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String remarks = result.getString(3);\n                    final Unit<?> unit;\n                    final Class<?> type;\n                    /*\n                     * Search for units. We will choose the most commonly used one in parameter values.\n                     * If the parameter appears to have at least one non-null value in the \"Parameter\n                     * File Name\" column, then the type is assumed to be URI. Otherwise, the type is a\n                     * floating point number.\n                     */\n                    final PreparedStatement units =\n                            prepareStatement(\n                                    \"ParameterUnit\",\n                                    \"SELECT MIN(UOM_CODE) AS UOM,\"\n                                            + \" MIN(PARAM_VALUE_FILE_REF) AS FILEREF\"\n                                            + \" FROM [Coordinate_Operation Parameter Value]\"\n                                            + \" WHERE (PARAMETER_CODE = ?)\"\n                                            + \" GROUP BY UOM_CODE\"\n                                            + \" ORDER BY COUNT(UOM_CODE) DESC\");\n                    units.setString(1, epsg);\n                    try (final ResultSet resultUnits = units.executeQuery()) {\n                        if (resultUnits.next()) {\n                            String element = resultUnits.getString(1);\n                            unit = (element != null) ? createUnit(element) : null;\n                            element = resultUnits.getString(2);\n                            type =\n                                    (element != null && element.trim().length() != 0)\n                                            ? URI.class\n                                            : double.class;\n                        } else {\n                            unit = null;\n                            type = double.class;\n                        }\n                    }\n                    /*\n                     * Now creates the parameter descriptor.\n                     */\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    @SuppressWarnings(\"unchecked\")\n                    final ParameterDescriptor<?> descriptor =\n                            new DefaultParameterDescriptor(\n                                    properties, type, null, null, null, null, unit, true);\n                    returnValue = ensureSingleton(descriptor, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(OperationMethod.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(OperationMethod.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns all parameter descriptors for the specified method.\n     *\n     * @param method The operation method code.\n     * @return The parameter descriptors.\n     * @throws SQLException if a SQL statement failed.\n     */\n    private ParameterDescriptor[] generateParameterDescriptors(final String method)\n            throws FactoryException, SQLException {\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"ParameterDescriptors\", // Must be plural form.\n                        \"SELECT PARAMETER_CODE\"\n                                + \" FROM [Coordinate_Operation Parameter Usage]\"\n                                + \" WHERE COORD_OP_METHOD_CODE = ?\"\n                                + \" ORDER BY SORT_ORDER\");\n        stmt.setString(1, method);\n        try (ResultSet results = stmt.executeQuery()) {\n            final List<ParameterDescriptor<? extends Object>> descriptors = new ArrayList<>();\n            while (results.next()) {\n                final String param = getString(results, 1, method);\n                descriptors.add(generateParameterDescriptor(param));\n            }\n            return descriptors.toArray(new ParameterDescriptor[descriptors.size()]);\n        }\n    }\n\n    /**\n     * Fill parameter values in the specified group.\n     *\n     * @param method The EPSG code for the operation method.\n     * @param operation The EPSG code for the operation (conversion or transformation).\n     * @param parameters The parameter values to fill.\n     * @throws SQLException if a SQL statement failed.\n     */\n    private void fillParameterValues(\n            final String method, final String operation, final ParameterValueGroup parameters)\n            throws FactoryException, SQLException {\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"ParameterValues\",\n                        \"SELECT CP.PARAMETER_NAME,\"\n                                + \" CV.PARAMETER_VALUE,\"\n                                + \" CV.PARAM_VALUE_FILE_REF,\"\n                                + \" CV.UOM_CODE\"\n                                + \" FROM ([Coordinate_Operation Parameter Value] AS CV\"\n                                + \" INNER JOIN [Coordinate_Operation Parameter] AS CP\"\n                                + \" ON CV.PARAMETER_CODE = CP.PARAMETER_CODE)\"\n                                + \" INNER JOIN [Coordinate_Operation Parameter Usage] AS CU\"\n                                + \" ON (CP.PARAMETER_CODE = CU.PARAMETER_CODE)\"\n                                + \" AND (CV.COORD_OP_METHOD_CODE = CU.COORD_OP_METHOD_CODE)\"\n                                + \" WHERE CV.COORD_OP_METHOD_CODE = ?\"\n                                + \" AND CV.COORD_OP_CODE = ?\"\n                                + \" ORDER BY CU.SORT_ORDER\");\n        stmt.setString(1, method);\n        stmt.setString(2, operation);\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String name = getString(result, 1, operation);\n                final double value = result.getDouble(2);\n                final Unit<?> unit;\n                Object reference;\n                if (result.wasNull()) {\n                    /*\n                     * If no numeric values were provided in the database, then the values must\n                     * appears in some external file. It may be a file to download from FTP.\n                     */\n                    reference = getString(result, 3, operation);\n                    try {\n                        reference = new URI((String) reference);\n                    } catch (URISyntaxException exception) {\n                        // Ignore: we will stores the reference as a file.\n                        reference = new File((String) reference);\n                    }\n                    unit = null;\n                } else {\n                    reference = null;\n                    final String unitCode = result.getString(4);\n                    unit = (unitCode != null) ? createUnit(unitCode) : null;\n                }\n                final ParameterValue<?> param;\n                try {\n                    param = parameters.parameter(name);\n                } catch (ParameterNotFoundException exception) {\n                    /*\n                     * Wraps the unchecked ParameterNotFoundException into the checked\n                     * NoSuchIdentifierException, which is a FactoryException subclass.\n                     * Note that in theory, NoSuchIdentifierException is for MathTransforms rather\n                     * than parameters.  However, we are close in spirit here since we are setting\n                     * up MathTransform's parameters. Using NoSuchIdentifierException allows users\n                     * (including CoordinateOperationSet) to know that the failure is probably\n                     * caused by a MathTransform not yet supported in Geotools (or only partially\n                     * supported) rather than some more serious failure in the database side.\n                     * CoordinateOperationSet uses this information in order to determine if it\n                     * should try the next coordinate operation or propagate the exception.\n                     */\n                    final NoSuchIdentifierException e =\n                            new NoSuchIdentifierException(\n                                    Errors.format(ErrorKeys.CANT_SET_PARAMETER_VALUE_$1, name),\n                                    name);\n                    e.initCause(exception);\n                    throw e;\n                }\n                try {\n                    if (reference != null) {\n                        param.setValue(reference);\n                    } else if (unit != null) {\n                        param.setValue(value, unit);\n                    } else {\n                        param.setValue(value);\n                    }\n                } catch (InvalidParameterValueException exception) {\n                    throw new FactoryException(\n                            Errors.format(ErrorKeys.CANT_SET_PARAMETER_VALUE_$1, name), exception);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an operation method from a code.\n     *\n     * @param code The operation method code allocated by EPSG authority.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    public synchronized OperationMethod generateOperationMethod(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        OperationMethod returnValue = null;\n        final PreparedStatement stmt;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            OperationMethod.class,\n                            code,\n                            \"[Coordinate_Operation Method]\",\n                            \"COORD_OP_METHOD_CODE\",\n                            \"COORD_OP_METHOD_NAME\");\n            stmt =\n                    prepareStatement(\n                            \"OperationMethod\",\n                            \"SELECT COORD_OP_METHOD_CODE,\"\n                                    + \" COORD_OP_METHOD_NAME,\"\n                                    + \" FORMULA,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Coordinate_Operation Method]\"\n                                    + \" WHERE COORD_OP_METHOD_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                OperationMethod method = null;\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String formula = result.getString(3);\n                    final String remarks = result.getString(4);\n                    final int encoded = getDimensionsForMethod(epsg);\n                    final int sourceDimensions = encoded >>> 16;\n                    final int targetDimensions = encoded & 0xFFFF;\n                    final ParameterDescriptor[] descriptors = generateParameterDescriptors(epsg);\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    if (formula != null) {\n                        properties.put(OperationMethod.FORMULA_KEY, formula);\n                    }\n                    method =\n                            new DefaultOperationMethod(\n                                    properties,\n                                    sourceDimensions,\n                                    targetDimensions,\n                                    new DefaultParameterDescriptorGroup(properties, descriptors));\n                    returnValue = ensureSingleton(method, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(OperationMethod.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(OperationMethod.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the must common source and target dimensions for the specified method. Source\n     * dimension is encoded in the 16 highest bits and target dimension is encoded in the 16 lowest\n     * bits. If this method can't infers the dimensions from the \"Coordinate Operation\" table, then\n     * the operation method is probably a projection, which always have (2,2) dimensions in the EPSG\n     * database.\n     */\n    private int getDimensionsForMethod(final String code) throws SQLException {\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"MethodDimensions\",\n                        \"SELECT SOURCE_CRS_CODE,\"\n                                + \" TARGET_CRS_CODE\"\n                                + \" FROM [Coordinate_Operation]\"\n                                + \" WHERE COORD_OP_METHOD_CODE = ?\"\n                                + \" AND SOURCE_CRS_CODE IS NOT NULL\"\n                                + \" AND TARGET_CRS_CODE IS NOT NULL\");\n        stmt.setString(1, code);\n        final Map<Dimensions, Dimensions> dimensions = new HashMap<>();\n        final Dimensions temp = new Dimensions((2 << 16) | 2); // Default to (2,2) dimensions.\n        Dimensions max = temp;\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final short sourceDimensions = getDimensionForCRS(result.getString(1));\n                final short targetDimensions = getDimensionForCRS(result.getString(2));\n                temp.encoded = (sourceDimensions << 16) | (targetDimensions);\n                Dimensions candidate = dimensions.get(temp);\n                if (candidate == null) {\n                    candidate = new Dimensions(temp.encoded);\n                    dimensions.put(candidate, candidate);\n                }\n                if (++candidate.occurences > max.occurences) {\n                    max = candidate;\n                }\n            }\n        }\n        return max.encoded;\n    }\n\n    /** A counter for source and target dimensions (to be kept together). */\n    private static final class Dimensions {\n        /** The dimensions as an encoded value. */\n        int encoded;\n        /** The occurences of this dimensions. */\n        int occurences;\n\n        Dimensions(final int e) {\n            encoded = e;\n        }\n\n        @Override\n        public int hashCode() {\n            return encoded;\n        }\n\n        @Override\n        public boolean equals(final Object object) { // MUST ignore 'occurences'.\n            return (object instanceof Dimensions) && ((Dimensions) object).encoded == encoded;\n        }\n\n        @Override\n        public String toString() {\n            return \"[(\"\n                    + (encoded >>> 16)\n                    + ','\n                    + (encoded & 0xFFFF)\n                    + \")\\u00D7\"\n                    + occurences\n                    + ']';\n        }\n    }\n\n    /**\n     * Returns the dimension of the specified CRS. If the CRS is not found (which should not happen,\n     * but we don't need to be strict here), then this method assumes a two-dimensional CRS.\n     */\n    private short getDimensionForCRS(final String code) throws SQLException {\n        final PreparedStatement stmt;\n        final Short cached = axisCounts.get(code);\n        final short dimension;\n        if (cached == null) {\n            stmt =\n                    prepareStatement(\n                            \"Dimension\",\n                            \"  SELECT COUNT(COORD_AXIS_CODE)\"\n                                    + \" FROM [Coordinate Axis]\"\n                                    + \" WHERE COORD_SYS_CODE = (SELECT COORD_SYS_CODE \"\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE COORD_REF_SYS_CODE = ?)\");\n            stmt.setString(1, code);\n            try (ResultSet result = stmt.executeQuery()) {\n                dimension = result.next() ? result.getShort(1) : 2;\n                axisCounts.put(code, dimension);\n            }\n        } else {\n            dimension = cached.shortValue();\n        }\n        return dimension;\n    }\n\n    /**\n     * Returns {@code true} if the {@linkplain CoordinateOperation coordinate operation} for the\n     * specified code is a {@linkplain Projection projection}. The caller must have ensured that the\n     * designed operation is a {@linkplain Conversion conversion} before to invoke this method.\n     */\n    final synchronized boolean isProjection(final String code) throws SQLException {\n        final PreparedStatement stmt;\n        Boolean projection = codeProjection.get(code);\n        if (projection == null) {\n            stmt =\n                    prepareStatement(\n                            \"isProjection\",\n                            \"SELECT COORD_REF_SYS_CODE\"\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE PROJECTION_CONV_CODE = ?\"\n                                    + \" AND COORD_REF_SYS_KIND LIKE 'projected%'\");\n            stmt.setString(1, code);\n            try (ResultSet result = stmt.executeQuery()) {\n                final boolean found = result.next();\n                projection = Boolean.valueOf(found);\n                codeProjection.put(code, projection);\n            }\n        }\n        return projection.booleanValue();\n    }\n\n    /**\n     * Returns a coordinate operation from a code. The returned object will either be a {@linkplain\n     * Conversion conversion} or a {@linkplain Transformation transformation}, depending on the\n     * code.\n     *\n     * @param code Value allocated by authority.\n     * @return The coordinate operation object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized CoordinateOperation generateCoordinateOperation(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateOperation returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            CoordinateOperation.class,\n                            code,\n                            \"[Coordinate_Operation]\",\n                            \"COORD_OP_CODE\",\n                            \"COORD_OP_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"CoordinateOperation\",\n                            \"SELECT COORD_OP_CODE,\"\n                                    + \" COORD_OP_NAME,\"\n                                    + \" COORD_OP_TYPE,\"\n                                    + \" SOURCE_CRS_CODE,\"\n                                    + \" TARGET_CRS_CODE,\"\n                                    + \" COORD_OP_METHOD_CODE,\"\n                                    + \" COORD_TFM_VERSION,\"\n                                    + \" COORD_OP_ACCURACY,\"\n                                    + \" AREA_OF_USE_CODE,\"\n                                    + \" COORD_OP_SCOPE,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Coordinate_Operation]\"\n                                    + \" WHERE COORD_OP_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            boolean exit = false;\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String type = getString(result, 3, code).trim().toLowerCase();\n                    final boolean isTransformation = type.equals(\"transformation\");\n                    final boolean isConversion = type.equals(\"conversion\");\n                    final boolean isConcatenated = type.equals(\"concatenated operation\");\n                    final String sourceCode, targetCode, methodCode;\n                    if (isConversion) {\n                        // Optional for conversions, mandatory for all others.\n                        sourceCode = result.getString(4);\n                        targetCode = result.getString(5);\n                    } else {\n                        sourceCode = getString(result, 4, code);\n                        targetCode = getString(result, 5, code);\n                    }\n                    if (isConcatenated) {\n                        // Not applicable to concatenated operation, mandatory for all others.\n                        methodCode = result.getString(6);\n                    } else {\n                        methodCode = getString(result, 6, code);\n                    }\n                    String version = result.getString(7);\n                    double accuracy = result.getDouble(8);\n                    if (result.wasNull()) accuracy = Double.NaN;\n                    String area = result.getString(9);\n                    String scope = result.getString(10);\n                    String remarks = result.getString(11);\n                    /*\n                     * Gets the source and target CRS. They are mandatory for transformations (it\n                     * was checked above in this method) and optional for conversions. Conversions\n                     * are usually \"defining conversions\" and don't define source and target CRS.\n                     * In EPSG database 6.7, all defining conversions are projections and their\n                     * dimensions are always 2. However, this is not generalizable to other kind\n                     * of operation methods. For example the \"Geocentric translation\" operation\n                     * method has 3-dimensional source and target.\n                     */\n                    final int sourceDimensions, targetDimensions;\n                    final CoordinateReferenceSystem sourceCRS, targetCRS;\n                    if (sourceCode != null) {\n                        sourceCRS = createCoordinateReferenceSystem(sourceCode);\n                        sourceDimensions = sourceCRS.getCoordinateSystem().getDimension();\n                    } else {\n                        sourceCRS = null;\n                        sourceDimensions = 2; // Acceptable default for projections only.\n                    }\n                    if (targetCode != null) {\n                        targetCRS = createCoordinateReferenceSystem(targetCode);\n                        targetDimensions = targetCRS.getCoordinateSystem().getDimension();\n                    } else {\n                        targetCRS = null;\n                        targetDimensions = 2; // Acceptable default for projections only.\n                    }\n                    /*\n                     * Gets the operation method. This is mandatory for conversions and transformations\n                     * (it was checked above in this method) but optional for concatenated operations.\n                     * Fetching parameter values is part of this block.\n                     */\n                    final boolean isBursaWolf;\n                    OperationMethod method;\n                    final ParameterValueGroup parameters;\n                    if (methodCode == null) {\n                        isBursaWolf = false;\n                        method = null;\n                        parameters = null;\n                    } else {\n                        final int num;\n                        try {\n                            num = Integer.parseInt(methodCode);\n                        } catch (NumberFormatException exception) {\n                            result.close();\n                            throw new FactoryException(exception);\n                        }\n                        isBursaWolf = (num >= BURSA_WOLF_MIN_CODE && num <= BURSA_WOLF_MAX_CODE);\n                        // Reminder: The source and target dimensions MUST be computed when\n                        //           the information is available. Dimension is not always 2!!\n                        method = generateOperationMethod(methodCode);\n                        if (method.getSourceDimensions() != sourceDimensions\n                                || method.getTargetDimensions() != targetDimensions) {\n                            method =\n                                    new DefaultOperationMethod(\n                                            method, sourceDimensions, targetDimensions);\n                        }\n                        /*\n                         * Note that some parameters required for MathTransform creation are implicit in\n                         * the EPSG database (e.g. semi-major and semi-minor axis length in the case of\n                         * map projections). We ask the parameter value group straight from the math\n                         * transform factory instead of from the operation method in order to get all\n                         * required parameter descriptors, including implicit ones.\n                         */\n                        final String classe = method.getName().getCode();\n                        parameters =\n                                factories.getMathTransformFactory().getDefaultParameters(classe);\n                        fillParameterValues(methodCode, epsg, parameters);\n                    }\n                    /*\n                     * Creates common properties. The 'version' and 'accuracy' are usually defined\n                     * for transformations only. However, we check them for all kind of operations\n                     * (including conversions) and copy the information inconditionnaly if present.\n                     *\n                     * NOTE: This block must be executed last before object creations below, because\n                     *       methods like createCoordinateReferenceSystem and createOperationMethod\n                     *       overwrite the properties map.\n                     */\n                    final Map<String, Object> properties =\n                            generateProperties(name, epsg, area, scope, remarks);\n                    if (version != null && (version = version.trim()).length() != 0) {\n                        properties.put(CoordinateOperation.OPERATION_VERSION_KEY, version);\n                    }\n                    if (!Double.isNaN(accuracy)) {\n                        final QuantitativeResultImpl accuracyResult =\n                                new QuantitativeResultImpl(new double[] {accuracy});\n                        // TODO: Need to invoke something equivalent to:\n                        // accuracyResult.setValueType(Float.class);\n                        // This is the type declared in the MS-Access database.\n                        accuracyResult.setValueUnit(\n                                SI.METRE); // In meters by definition in the EPSG database.\n                        final AbsoluteExternalPositionalAccuracyImpl accuracyElement =\n                                new AbsoluteExternalPositionalAccuracyImpl(accuracyResult);\n                        accuracyElement.setMeasureDescription(TRANSFORMATION_ACCURACY);\n                        accuracyElement.setEvaluationMethodType(\n                                EvaluationMethodType.DIRECT_EXTERNAL);\n                        properties.put(\n                                CoordinateOperation.COORDINATE_OPERATION_ACCURACY_KEY,\n                                new PositionalAccuracy[] {\n                                    (PositionalAccuracy) accuracyElement.unmodifiable()\n                                });\n                    }\n                    /*\n                     * Creates the operation. Conversions should be the only operations allowed to\n                     * have null source and target CRS. In such case, the operation is a defining\n                     * conversion (usually to be used later as part of a ProjectedCRS creation),\n                     * and always a projection in the specific case of the EPSG database (which\n                     * allowed us to assume 2-dimensional operation method in the code above for\n                     * this specific case - not to be generalized to the whole EPSG database).\n                     */\n                    final CoordinateOperation operation;\n                    if (isConversion && (sourceCRS == null || targetCRS == null)) {\n                        // Note: we usually can't resolve sourceCRS and targetCRS because there\n                        // is many of them for the same coordinate operation (projection) code.\n                        operation = new DefiningConversion(properties, method, parameters);\n                    } else if (isConcatenated) {\n                        /*\n                         * Concatenated operation: we need to close the current result set, because\n                         * we are going to invoke this method recursively in the following lines.\n                         *\n                         * Note: we instantiate directly the Geotools's implementation of\n                         * ConcatenatedOperation instead of using CoordinateOperationFactory in order\n                         * to avoid loading the quite large Geotools's implementation of this factory,\n                         * and also because it is not part of FactoryGroup anyway.\n                         */\n                        result.close();\n                        exit = true;\n                        final PreparedStatement cstmt =\n                                prepareStatement(\n                                        \"ConcatenatedOperation\",\n                                        \"SELECT SINGLE_OPERATION_CODE\"\n                                                + \" FROM [Coordinate_Operation Path]\"\n                                                + \" WHERE (CONCAT_OPERATION_CODE = ?)\"\n                                                + \" ORDER BY OP_PATH_STEP\");\n                        cstmt.setString(1, epsg);\n                        final List<String> codes = new ArrayList<>();\n                        try (ResultSet cr = cstmt.executeQuery()) {\n                            while (cr.next()) {\n                                codes.add(cr.getString(1));\n                            }\n                        }\n                        final CoordinateOperation[] operations =\n                                new CoordinateOperation[codes.size()];\n                        if (!safetyGuard.add(epsg)) {\n                            throw recursiveCall(ConcatenatedOperation.class, epsg);\n                        }\n                        try {\n                            for (int i = 0; i < operations.length; i++) {\n                                operations[i] = createCoordinateOperation(codes.get(i));\n                            }\n                        } finally {\n                            safetyGuard.remove(epsg);\n                        }\n                        try {\n                            return new DefaultConcatenatedOperation(properties, operations);\n                        } catch (IllegalArgumentException exception) {\n                            // May happen if there is less than 2 operations to concatenate.\n                            // It happen for some deprecated CRS like 8658 for example.\n                            throw new FactoryException(exception);\n                        }\n                    } else {\n                        /*\n                         * Needs to create a math transform. A special processing is performed for\n                         * datum shift methods, since the conversion from ellipsoid to geocentric\n                         * for \"geocentric translations\" is implicit in the EPSG database. Even in\n                         * the case of Molodenski transforms, the axis length to set are the same.\n                         */\n                        if (isBursaWolf)\n                            try {\n                                Ellipsoid ellipsoid = CRSUtilities.getHeadGeoEllipsoid(sourceCRS);\n                                if (ellipsoid != null) {\n                                    final Unit<Length> axisUnit = ellipsoid.getAxisUnit();\n                                    parameters\n                                            .parameter(\"src_semi_major\")\n                                            .setValue(ellipsoid.getSemiMajorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"src_semi_minor\")\n                                            .setValue(ellipsoid.getSemiMinorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"src_dim\")\n                                            .setValue(\n                                                    sourceCRS.getCoordinateSystem().getDimension());\n                                }\n                                ellipsoid = CRSUtilities.getHeadGeoEllipsoid(targetCRS);\n                                if (ellipsoid != null) {\n                                    final Unit axisUnit = ellipsoid.getAxisUnit();\n                                    parameters\n                                            .parameter(\"tgt_semi_major\")\n                                            .setValue(ellipsoid.getSemiMajorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"tgt_semi_minor\")\n                                            .setValue(ellipsoid.getSemiMinorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"tgt_dim\")\n                                            .setValue(\n                                                    targetCRS.getCoordinateSystem().getDimension());\n                                }\n                            } catch (ParameterNotFoundException exception) {\n                                result.close();\n                                throw new FactoryException(\n                                        Errors.format(\n                                                ErrorKeys.GEOTOOLS_EXTENSION_REQUIRED_$1,\n                                                method.getName().getCode(),\n                                                exception));\n                            }\n                        /*\n                         * At this stage, the parameters are ready for use. Creates the math transform\n                         * and wraps it in the final operation (a Conversion or a Transformation).\n                         */\n                        final Class<? extends CoordinateOperation> expected;\n                        if (isTransformation) {\n                            expected = Transformation.class;\n                        } else if (isConversion) {\n                            expected = Conversion.class;\n                        } else {\n                            result.close();\n                            throw new FactoryException(\n                                    Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                        }\n                        final MathTransform mt =\n                                factories\n                                        .getMathTransformFactory()\n                                        .createBaseToDerived(\n                                                sourceCRS,\n                                                parameters,\n                                                targetCRS.getCoordinateSystem());\n                        // TODO: uses GeoAPI factory method once available.\n                        operation =\n                                DefaultOperation.create(\n                                        properties, sourceCRS, targetCRS, mt, method, expected);\n                    }\n                    returnValue = ensureSingleton(operation, returnValue, code);\n                    if (exit) {\n                        // Bypass the 'result.close()' line below:\n                        // the ResultSet has already been closed.\n                        return returnValue;\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateOperation.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateOperation.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Creates operations from coordinate reference system codes. The returned set is ordered with\n     * the most accurate operations first.\n     *\n     * @param sourceCode Coded value of source coordinate reference system.\n     * @param targetCode Coded value of target coordinate reference system.\n     * @throws FactoryException if the object creation failed.\n     * @todo The ordering is not consistent among all database software, because the \"accuracy\"\n     *     column may contains null values. When used in an \"ORDER BY\" clause, PostgreSQL put null\n     *     values last, while Access and HSQL put them first. The PostgreSQL's behavior is better\n     *     for what we want (put operations with unknow accuracy last). Unfortunatly, I don't know\n     *     yet how to instruct Access to put null values last using standard SQL (\"IIF\" is not\n     *     standard, and Access doesn't seem to understand \"CASE ... THEN\" clauses).\n     */\n    @Override\n    public synchronized Set generateFromCoordinateReferenceSystemCodes(\n            final String sourceCode, final String targetCode) throws FactoryException {\n        ensureNonNull(\"sourceCode\", sourceCode);\n        ensureNonNull(\"targetCode\", targetCode);\n        final String pair = sourceCode + \" \\u21E8 \" + targetCode;\n        final CoordinateOperationSet set = new CoordinateOperationSet(this);\n        try {\n            final String sourceKey = toPrimaryKeyCRS(sourceCode);\n            final String targetKey = toPrimaryKeyCRS(targetCode);\n            boolean searchTransformations = false;\n            do {\n                /*\n                 * This 'do' loop is executed twice: the first time for searching defining\n                 * conversions, and the second time for searching all other kind of operations.\n                 * Defining conversions are searched first because they are, by definition, the\n                 * most accurate operations.\n                 */\n                final String key, sql;\n                if (searchTransformations) {\n                    key = \"TransformationFromCRS\";\n                    sql =\n                            \"SELECT COORD_OP_CODE\"\n                                    + \" FROM [Coordinate_Operation]\"\n                                    + \" WHERE SOURCE_CRS_CODE = ?\"\n                                    + \" AND TARGET_CRS_CODE = ?\"\n                                    + \" ORDER BY ABS(DEPRECATED), COORD_OP_ACCURACY\";\n                } else {\n                    key = \"ConversionFromCRS\";\n                    sql =\n                            \"SELECT PROJECTION_CONV_CODE\"\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE SOURCE_GEOGCRS_CODE = ?\"\n                                    + \" AND COORD_REF_SYS_CODE = ?\";\n                }\n                final PreparedStatement stmt = prepareStatement(key, sql);\n                stmt.setString(1, sourceKey);\n                stmt.setString(2, targetKey);\n                try (ResultSet result = stmt.executeQuery()) {\n                    while (result.next()) {\n                        final String code = getString(result, 1, pair);\n                        set.addAuthorityCode(code, searchTransformations ? null : targetKey);\n                    }\n                }\n            } while ((searchTransformations = !searchTransformations) == true);\n            /*\n             * Search finished. We may have a lot of coordinate operations\n             * (e.g. about 40 for \"ED50\" (EPSG:4230) to \"WGS 84\" (EPSG:4326)).\n             * Alter the ordering using the information supplied in the supersession table.\n             */\n            final String[] codes = set.getAuthorityCodes();\n            sort(codes);\n            set.setAuthorityCodes(codes);\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateOperation.class, pair, exception);\n        }\n        /*\n         * Before to return the set, tests the creation of 1 object in order to report early\n         * (i.e. now) any problems with SQL statements. Remaining operations will be created\n         * only when first needed.\n         */\n        set.resolve(1);\n        return set;\n    }\n\n    /**\n     * Sorts an array of codes in preference order. This method orders pairwise the codes according\n     * the information provided in the supersession table. If the same object is superseded by more\n     * than one object, then the most recent one is inserted first. Except for the codes moved as a\n     * result of pairwise ordering, this method try to preserve the old ordering of the supplied\n     * codes (since deprecated operations should already be last). The ordering is performed in\n     * place.\n     *\n     * @param codes The codes, usually as an array of {@link String}. If the array do not contains\n     *     string objects, then the {@link Object#toString} method must returns the code for each\n     *     element.\n     */\n    // TODO: Use generic type for \"Object[] codes\" with J2SE 1.5.\n    private void sort(final Object... codes) throws SQLException, FactoryException {\n        if (codes.length <= 1) {\n            return; // Nothing to sort.\n        }\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"Supersession\",\n                        \"SELECT SUPERSEDED_BY\"\n                                + \" FROM [Supersession]\"\n                                + \" WHERE OBJECT_CODE = ?\"\n                                + \" ORDER BY SUPERSESSION_YEAR DESC\");\n        int maxIterations = 15; // For avoiding never-ending loop.\n        do {\n            boolean changed = false;\n            for (int i = 0; i < codes.length; i++) {\n                final String code = codes[i].toString();\n                stmt.setString(1, code);\n                try (ResultSet result = stmt.executeQuery()) {\n                    while (result.next()) {\n                        final String replacement = getString(result, 1, code);\n                        for (int j = i + 1; j < codes.length; j++) {\n                            final Object candidate = codes[j];\n                            if (replacement.equals(candidate.toString())) {\n                                /*\n                                 * Found a code to move in front of the superceded one.\n                                 */\n                                System.arraycopy(codes, i, codes, i + 1, j - i);\n                                codes[i++] = candidate;\n                                changed = true;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!changed) {\n                return;\n            }\n        } while (--maxIterations != 0);\n        LOGGER.finer(\"Possible recursivity in supersessions.\");\n    }\n\n    /**\n     * An implementation of {@link IdentifiedObjectFinder} which scans over a smaller set of\n     * authority codes.\n     *\n     * <p><b>Implementation note:</b> Since this method may be invoked indirectly by {@link\n     * LongitudeFirstFactory}, it must be insensitive to axis order.\n     */\n    private final class Finder extends IdentifiedObjectFinder {\n        /** Creates a new finder backed by the specified <em>buffered</em> authority factory. */\n        Finder(final Class<? extends IdentifiedObject> type) {\n            super(AbstractEpsgFactory.this, type);\n        }\n\n        /**\n         * Returns a set of authority codes that <strong>may</strong> identify the same object than\n         * the specified one. This implementation tries to get a smaller set than what {@link\n         * AbstractEpsgFactory#getAuthorityCodes} would produce.\n         */\n        @Override\n        protected Set<String> getCodeCandidates(final IdentifiedObject object)\n                throws FactoryException {\n            String select = \"COORD_REF_SYS_CODE\";\n            String from = \"[Coordinate Reference System]\";\n            String where, code;\n            if (object instanceof Ellipsoid) {\n                select = \"ELLIPSOID_CODE\";\n                from = \"[Ellipsoid]\";\n                where = \"SEMI_MAJOR_AXIS\";\n                code = Double.toString(((Ellipsoid) object).getSemiMajorAxis());\n            } else {\n                IdentifiedObject dependency;\n                if (object instanceof GeneralDerivedCRS) {\n                    dependency = ((GeneralDerivedCRS) object).getBaseCRS();\n                    where = \"SOURCE_GEOGCRS_CODE\";\n                } else if (object instanceof SingleCRS) {\n                    dependency = ((SingleCRS) object).getDatum();\n                    where = \"DATUM_CODE\";\n                } else if (object instanceof GeodeticDatum) {\n                    dependency = ((GeodeticDatum) object).getEllipsoid();\n                    select = \"DATUM_CODE\";\n                    from = \"[Datum]\";\n                    where = \"ELLIPSOID_CODE\";\n                } else {\n                    return super.getCodeCandidates(object);\n                }\n                dependency = getIdentifiedObjectFinder(dependency.getClass()).find(dependency);\n                Identifier id = AbstractIdentifiedObject.getIdentifier(dependency, getAuthority());\n                if (id == null || (code = id.getCode()) == null) {\n                    return super.getCodeCandidates(object);\n                }\n            }\n            String sql =\n                    \"SELECT \" + select + \" FROM \" + from + \" WHERE \" + where + \"='\" + code + '\\'';\n            sql = adaptSQL(sql);\n            final Set<String> result = new LinkedHashSet<>();\n            try (Statement s = getConnection().createStatement();\n                    ResultSet r = s.executeQuery(sql)) {\n                while (r.next()) {\n                    result.add(r.getString(1));\n                }\n            } catch (SQLException exception) {\n                throw databaseFailure(Identifier.class, code, exception);\n            }\n            return result;\n        }\n    }\n\n    /** Constructs an exception for recursive calls. */\n    private static FactoryException recursiveCall(\n            final Class<? extends IdentifiedObject> type, final String code) {\n        return new FactoryException(Errors.format(ErrorKeys.RECURSIVE_CALL_$2, type, code));\n    }\n\n    /** Constructs an exception for a database failure. */\n    private static FactoryException databaseFailure(\n            final Class<? extends Object> type, final String code, final SQLException cause) {\n        return new FactoryException(\n                Errors.format(ErrorKeys.DATABASE_FAILURE_$2, type, code), cause);\n    }\n\n    /**\n     * Invoked when a new {@link PreparedStatement} is about to be created from a SQL string. Since\n     * the <A HREF=\"http://www.epsg.org\">EPSG database</A> is available mainly in MS-Access format,\n     * SQL statements are formatted using some syntax specific to this particular database software\n     * (for example \"<code>SELECT * FROM [Coordinate Reference System]</code>\"). When prociding\n     * subclass targeting another database vendor, then this method should be overridden in order to\n     * adapt the local SQL syntax.\n     *\n     * <p>For example a subclass connecting to a <cite>PostgreSQL</cite> database could replace all\n     * spaces (\"&nbsp;\") between watching braces (\"[\" and \"]\") by underscore (\"_\").\n     *\n     * @param statement The statement in MS-Access syntax.\n     * @return The SQL statement to use. The default implementation returns the string unchanged.\n     */\n    protected abstract String adaptSQL(final String statement);\n\n    /**\n     * Returns {@code true} if the specified code may be a primary key in some table. This method do\n     * not needs to checks any entry in the database. It should just checks from the syntax if the\n     * code looks like a valid EPSG identifier. The default implementation returns {@code true} if\n     * all non-space characters are {@linkplain Character#isDigit(char) digits}.\n     *\n     * <p>When this method returns {@code false}, some {@code createFoo(...)} methods look for the\n     * code in the name column instead of the primary key column. This allows to accept the\n     * \"<cite>NTF (Paris) / France I</cite>\" string (for example) in addition to the {@code \"27581\"}\n     * primary key. Both should fetch the same object.\n     *\n     * <p>If this method returns {@code true} in all cases, then this factory never search for\n     * matching names. In such case, an appropriate exception will be thrown in {@code\n     * createFoo(...)} methods if the code is not found in the primary key column. Subclasses can\n     * overrides this method that way if this is the intended behavior.\n     *\n     * @param code The code the inspect.\n     * @return {@code true} if the code is probably a primary key.\n     * @throws FactoryException if an unexpected error occured while inspecting the code.\n     */\n    protected boolean isPrimaryKey(final String code) throws FactoryException {\n        final int length = code.length();\n        for (int i = 0; i < length; i++) {\n            final char c = code.charAt(i);\n            if (!Character.isDigit(c) && !Character.isSpaceChar(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} if it is safe to dispose this factory. This method is invoked indirectly\n     * by {@link ThreadedEpsgFactory} after some timeout in order to release resources. This method\n     * will block the disposal if some {@linkplain #getAuthorityCodes set of authority codes} are\n     * still in use.\n     */\n    final synchronized boolean canDispose() {\n        return true;\n    }\n\n    /**\n     * Disposes any resources hold by this object.\n     *\n     * @throws FactoryException if an error occurred while closing the connection.\n     */\n    @Override\n    public synchronized void dispose() throws FactoryException {\n        disconnect();\n        super.dispose();\n    }\n\n    /** Connect to the database in anticipation of of use. */\n    public void connect() throws FactoryException {\n        try {\n            getConnection();\n        } catch (SQLException e) {\n            throw new FactoryException(e);\n        }\n    }\n    /**\n     * Disconnect from the database, and remain idle. We will still keep our internal data\n     * structures, we are not going to hold onto a database connection unless we are going to be\n     * used.\n     */\n    public void disconnect() throws FactoryException {\n        if (connection != null) {\n            final boolean isClosed;\n            try {\n                isClosed = connection.isClosed();\n                for (final Iterator<PreparedStatement> it = statements.values().iterator();\n                        it.hasNext(); ) {\n                    (it.next()).close();\n                    it.remove();\n                }\n                connection.close();\n            } catch (SQLException exception) {\n                throw new FactoryException(exception);\n            }\n            if (!isClosed) {\n                /*\n                 * The above code was run unconditionally as a safety, even if the connection\n                 * was already closed. However we will log a message only if we actually closed\n                 * the connection, otherwise the log records are a little bit misleading.\n                 */\n                final LogRecord record =\n                        Loggings.format(Level.FINE, LoggingKeys.CLOSED_EPSG_DATABASE);\n                record.setLoggerName(LOGGER.getName());\n                LOGGER.log(record);\n            }\n            connection = null;\n        }\n    }\n\n    /**\n     * Access to the connection used by this EpsgFactory. The connection will be created as needed.\n     *\n     * @return the connection\n     */\n    protected synchronized Connection getConnection() throws SQLException {\n        if (connection == null) {\n            connection = dataSource.getConnection();\n        }\n        return connection;\n    }\n    /**\n     * Shutdown the database engine. This method is invoked twice by {@link ThreadedEpsgFactory} at\n     * JVM shutdown: one time before the {@linkplain #connection} is closed, and a second time\n     * after. This shutdown hook is useful for <cite>embedded</cite> database engine starting a\n     * server process in addition to the client process. Just closing the connection is not enough\n     * for them. Example:\n     *\n     * <p>\n     *\n     * <UL>\n     *   <LI>HSQL database engine needs to execute a {@code \"SHUTDOWN\"} statement using the\n     *       {@linkplain #connection} before it is closed.\n     *   <LI>Derby database engine needs to instruct the {@linkplain java.sql.DriverManager driver\n     *       manager} after all connections have been closed.\n     * </UL>\n     *\n     * <p>The default implementation does nothing, which is sufficient for implementations\n     * connecting to a distant server (i.e. non-embedded database engine), for example {@linkplain\n     * AccessDataSource MS-Access} or {@linkplain PostgreDataSource PostgreSQL}.\n     *\n     * @param active {@code true} if the {@linkplain #connection} is alive, or {@code false}\n     *     otherwise. This method is invoked first with {@code active} set to {@code true}, then a\n     *     second time with {@code active} set to {@code false}.\n     * @throws SQLException if this method failed to shutdown the database engine.\n     */\n    protected void shutdown(final boolean active) throws SQLException {}\n\n    /**\n     * Invokes {@link #dispose} when this factory is garbage collected.\n     *\n     * @throws Throwable if an error occurred while closing the connection.\n     */\n    @Override\n    @SuppressWarnings(\"deprecation\") // finalize is deprecated in Java 9\n    protected final void finalize() throws Throwable {\n        dispose();\n        super.finalize();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    //////                                                                                 ///////\n    //////   HARD CODED VALUES (other than SQL statements) RELATIVE TO THE EPSG DATABASE   ///////\n    //////                                                                                 ///////\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /**\n     * Returns a hard-coded unit from an EPSG code. We do not need to provide all units here, but we\n     * must at least provide all base units declared in the [TARGET_UOM_CODE] column of table [Unit\n     * of Measure]. Other units will be derived automatically if they are not listed here.\n     *\n     * @param code The code.\n     * @return The unit, or {@code null} if the code is unrecognized.\n     */\n    private static Unit<?> getUnit(final int code) {\n        switch (code) {\n            case 9001:\n                return METRE;\n            case 9002:\n                return FOOT;\n            case 9030:\n                return NAUTICAL_MILE;\n            case 9036:\n                return KILOMETER;\n            case 9101:\n                return RADIAN;\n            case 9122: // Fall through\n            case 9102:\n                return DEGREE_ANGLE;\n            case 9103:\n                return MINUTE_ANGLE;\n            case 9104:\n                return SECOND_ANGLE;\n            case 9105:\n                return GRADE;\n            case 9107:\n                return DEGREE_MINUTE_SECOND;\n            case 9108:\n                return DEGREE_MINUTE_SECOND;\n            case 9109:\n                return MICRORADIAN;\n            case 9110:\n                return SEXAGESIMAL_DMS;\n                // TODO case 9111: return NonSI.SEXAGESIMAL_DM;\n            case 9203: // Fall through\n            case 9201:\n                return ONE;\n            case 9202:\n                return PPM;\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Set a Bursa-Wolf parameter from an EPSG parameter.\n     *\n     * @param parameters The Bursa-Wolf parameters to modify.\n     * @param code The EPSG code for a parameter from [PARAMETER_CODE] column.\n     * @param value The value of the parameter from [PARAMETER_VALUE] column.\n     * @param unit The unit of the parameter value from [UOM_CODE] column.\n     * @throws FactoryException if the code is unrecognized.\n     * @throws IllegalArgumentException if the value could not be converted to the provided Unit\n     */\n    private static void setBursaWolfParameter(\n            final BursaWolfParameters parameters, final int code, double value, final Unit<?> unit)\n            throws FactoryException {\n        Unit<?> target = unit;\n        if (code >= 8605) {\n            if (code <= 8607) target = SI.METRE;\n            else if (code == 8611) target = Units.PPM;\n            else if (code <= 8710) target = NonSI.SECOND_ANGLE;\n        }\n        if (target != unit) {\n            value = Units.getConverterToAny(unit, target).convert(value);\n        }\n        switch (code) {\n            case 8605:\n                parameters.dx = value;\n                break;\n            case 8606:\n                parameters.dy = value;\n                break;\n            case 8607:\n                parameters.dz = value;\n                break;\n            case 8608:\n                parameters.ex = value;\n                break;\n            case 8609:\n                parameters.ey = value;\n                break;\n            case 8610:\n                parameters.ez = value;\n                break;\n            case 8611:\n                parameters.ppm = value;\n                break;\n            default:\n                throw new FactoryException(Errors.format(ErrorKeys.UNEXPECTED_PARAMETER_$1, code));\n        }\n    }\n\n    /**\n     * List of tables and columns to test for codes values. This table is used by the {@link\n     * #createObject} method in order to detect which of the following methods should be invoked for\n     * a given code:\n     *\n     * <p>{@link #createCoordinateReferenceSystem} {@link #createCoordinateSystem} {@link\n     * #createDatum} {@link #createEllipsoid} {@link #createUnit}\n     *\n     * <p>The order is significant: it is the key for a {@code switch} statement.\n     *\n     * @see #createObject\n     * @see #lastObjectType\n     */\n    private static final TableInfo[] TABLES_INFO = {\n        new TableInfo(\n                CoordinateReferenceSystem.class,\n                \"[Coordinate Reference System]\",\n                \"COORD_REF_SYS_CODE\",\n                \"COORD_REF_SYS_NAME\",\n                \"COORD_REF_SYS_KIND\",\n                new Class[] {ProjectedCRS.class, GeographicCRS.class, GeocentricCRS.class},\n                new String[] {\"projected\", \"geographic\", \"geocentric\"}),\n        new TableInfo(\n                CoordinateSystem.class,\n                \"[Coordinate System]\",\n                \"COORD_SYS_CODE\",\n                \"COORD_SYS_NAME\",\n                \"COORD_SYS_TYPE\",\n                new Class[] {\n                    CartesianCS.class, EllipsoidalCS.class, SphericalCS.class, VerticalCS.class\n                },\n                new String[] {\"Cartesian\", \"ellipsoidal\", \"spherical\", \"vertical\"}),\n        new TableInfo(\n                CoordinateSystemAxis.class,\n                \"[Coordinate Axis] AS CA INNER JOIN [Coordinate Axis Name] AS CAN\"\n                        + \" ON CA.COORD_AXIS_NAME_CODE=CAN.COORD_AXIS_NAME_CODE\",\n                \"COORD_AXIS_CODE\",\n                \"COORD_AXIS_NAME\"),\n        new TableInfo(\n                Datum.class,\n                \"[Datum]\",\n                \"DATUM_CODE\",\n                \"DATUM_NAME\",\n                \"DATUM_TYPE\",\n                new Class[] {GeodeticDatum.class, VerticalDatum.class, EngineeringDatum.class},\n                new String[] {\"geodetic\", \"vertical\", \"engineering\"}),\n        new TableInfo(Ellipsoid.class, \"[Ellipsoid]\", \"ELLIPSOID_CODE\", \"ELLIPSOID_NAME\"),\n        new TableInfo(\n                PrimeMeridian.class,\n                \"[Prime Meridian]\",\n                \"PRIME_MERIDIAN_CODE\",\n                \"PRIME_MERIDIAN_NAME\"),\n        new TableInfo(\n                CoordinateOperation.class,\n                \"[Coordinate_Operation]\",\n                \"COORD_OP_CODE\",\n                \"COORD_OP_NAME\",\n                \"COORD_OP_TYPE\",\n                new Class[] {Projection.class, Conversion.class, Transformation.class},\n                new String[] {\"conversion\", \"conversion\", \"transformation\"}),\n        // Note: Projection is handle in a special way.\n\n        new TableInfo(\n                OperationMethod.class,\n                \"[Coordinate_Operation Method]\",\n                \"COORD_OP_METHOD_CODE\",\n                \"COORD_OP_METHOD_NAME\"),\n        new TableInfo(\n                ParameterDescriptor.class,\n                \"[Coordinate_Operation Parameter]\",\n                \"PARAMETER_CODE\",\n                \"PARAMETER_NAME\"),\n        new TableInfo(Unit.class, \"[Unit of Measure]\", \"UOM_CODE\", \"UNIT_OF_MEAS_NAME\")\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ////////                                                               ////////\n    ////////        E N D   O F   H A R D   C O D E D   V A L U E S        ////////\n    ////////                                                               ////////\n    ////////    NOTE: 'createFoo(...)' methods may still have hard-coded   ////////\n    ////////    values (others than SQL statements) in 'equalsIgnoreCase'  ////////\n    ////////    expressions.                                               ////////\n    ///////////////////////////////////////////////////////////////////////////////\n    /**\n     * A set of EPSG authority codes. This set makes use of our connection to the EPSG database. All\n     * {@link #iterator} method call creates a new {@link ResultSet} holding the codes. However,\n     * call to {@link #contains} map directly to a SQL call.\n     *\n     * <p>Serialization of this class store a copy of all authority codes. The serialization do not\n     * preserve any connection to the database.\n     *\n     * @since 2.2\n     * @version $Id$\n     * @author Martin Desruisseaux (IRD)\n     */\n    final class AuthorityCodeSet extends AbstractSet<String> implements Serializable {\n        /** For compatibility with different versions. */\n        private static final long serialVersionUID = 7105664579449680562L;\n\n        /**\n         * The type for this code set. This is translated to the most appropriate interface type\n         * even if the user supplied an implementation type.\n         */\n        public final Class<?> type;\n\n        /** {@code true} if {@link #type} is assignable to {@link Projection}. */\n        private final boolean isProjection;\n\n        /**\n         * A view of this set as a map with object's name as values, or {@code null} if none. Will\n         * be created only when first needed.\n         */\n        private transient java.util.Map<String, String> asMap;\n\n        /**\n         * The SQL command to use for creating the {@code queryAll} statement. Used for iteration\n         * over all codes.\n         */\n        final String sqlAll;\n\n        /**\n         * The SQL command to use for creating the {@code querySingle} statement. Used for fetching\n         * the description from a code.\n         */\n        private final String sqlSingle;\n\n        /** The statement to use for querying all codes. Will be created only when first needed. */\n        private transient PreparedStatement queryAll;\n\n        /**\n         * The statement to use for querying a single code. Will be created only when first needed.\n         */\n        private transient PreparedStatement querySingle;\n\n        /**\n         * The collection's size, or a negative value if not yet computed. The records will be\n         * counted only when first needed. The special value -2 if set by {@link #isEmpty} if the\n         * size has not yet been computed, but we know that the set is not empty.\n         */\n        private int size = -1;\n\n        /**\n         * Creates a new set of authority codes for the specified type.\n         *\n         * @param table The table to query.\n         * @param type The type to query.\n         */\n        public AuthorityCodeSet(final TableInfo table, final Class type) {\n            final StringBuilder buffer = new StringBuilder(\"SELECT \");\n            buffer.append(table.codeColumn);\n            if (table.nameColumn != null) {\n                buffer.append(\", \").append(table.nameColumn);\n            }\n            buffer.append(\" FROM \").append(table.table);\n            boolean hasWhere = false;\n            Class tableType = table.type;\n            if (table.typeColumn != null) {\n                for (int i = 0; i < table.subTypes.length; i++) {\n                    final Class<?> candidate = table.subTypes[i];\n                    if (candidate.isAssignableFrom(type)) {\n                        buffer.append(\" WHERE (\")\n                                .append(table.typeColumn)\n                                .append(\" LIKE '\")\n                                .append(table.typeNames[i])\n                                .append(\"%'\");\n                        hasWhere = true;\n                        tableType = candidate;\n                        break;\n                    }\n                }\n                if (hasWhere) {\n                    buffer.append(')');\n                }\n            }\n            this.type = tableType;\n            isProjection = Projection.class.isAssignableFrom(tableType);\n            final int length = buffer.length();\n            buffer.append(\" ORDER BY \").append(table.codeColumn);\n            sqlAll = adaptSQL(buffer.toString());\n            buffer.setLength(length);\n            buffer.append(hasWhere ? \" AND \" : \" WHERE \").append(table.codeColumn).append(\" = ?\");\n            sqlSingle = adaptSQL(buffer.toString());\n        }\n\n        /** Returns all codes. */\n        private ResultSet getAll() throws SQLException {\n            assert Thread.holdsLock(this);\n            if (queryAll != null) {\n                try {\n                    return queryAll.executeQuery();\n                } catch (SQLException ignore) {\n                    /*\n                     * Failed to reuse an existing statement. This problem occurs in some occasions\n                     * with the JDBC-ODBC bridge in Java 6 (the error message is \"Invalid handle\").\n                     * I'm not sure where the bug come from (didn't noticed it when using HSQL). We\n                     * will try again with a new statement created in the code after this 'catch'\n                     * clause. Note that we set 'queryAll' to null first in case of failure during\n                     * the 'prepareStatement(...)' execution.\n                     */\n                    queryAll.close();\n                    queryAll = null;\n                    recoverableException(\"getAll\", ignore);\n                }\n            }\n            queryAll = getConnection().prepareStatement(sqlAll);\n            return queryAll.executeQuery();\n        }\n\n        /** Returns a single code. */\n        private ResultSet getSingle(final Object code) throws SQLException {\n            assert Thread.holdsLock(this);\n            if (querySingle == null) {\n                querySingle = getConnection().prepareStatement(sqlSingle);\n            }\n            querySingle.setString(1, code.toString());\n            return querySingle.executeQuery();\n        }\n\n        /**\n         * Returns {@code true} if the code in the specified result set is acceptable. This method\n         * handle projections in a special way.\n         */\n        private boolean isAcceptable(final ResultSet results) throws SQLException {\n            if (!isProjection) {\n                return true;\n            }\n            final String code = results.getString(1);\n            return isProjection(code);\n        }\n\n        /**\n         * Returns {@code true} if the code in the specified code is acceptable. This method handle\n         * projections in a special way.\n         */\n        private boolean isAcceptable(final String code) throws SQLException {\n            if (!isProjection) {\n                return true;\n            }\n            return isProjection(code);\n        }\n\n        /**\n         * Returns {@code true} if this collection contains no elements. This method fetch at most\n         * one row instead of counting all rows.\n         */\n        @Override\n        public synchronized boolean isEmpty() {\n            if (size != -1) {\n                return size == 0;\n            }\n            boolean empty = true;\n            try {\n                try (ResultSet results = getAll()) {\n                    while (results.next()) {\n                        if (isAcceptable(results)) {\n                            empty = false;\n                            break;\n                        }\n                    }\n                }\n            } catch (SQLException exception) {\n                unexpectedException(\"isEmpty\", exception);\n            }\n            size = empty ? 0 : -2;\n            return empty;\n        }\n\n        /** Count the number of elements in the underlying result set. */\n        @Override\n        public synchronized int size() {\n            if (size >= 0) {\n                return size;\n            }\n            int count = 0;\n            try {\n                try (ResultSet results = getAll()) {\n                    while (results.next()) {\n                        if (isAcceptable(results)) {\n                            count++;\n                        }\n                    }\n                }\n            } catch (SQLException exception) {\n                unexpectedException(\"size\", exception);\n            }\n            size = count; // Stores only on success.\n            return count;\n        }\n\n        /** Returns {@code true} if this collection contains the specified element. */\n        @Override\n        public synchronized boolean contains(final Object code) {\n            boolean exists = false;\n            if (code != null)\n                try {\n                    try (ResultSet results = getSingle(code)) {\n                        while (results.next()) {\n                            if (isAcceptable(results)) {\n                                exists = true;\n                                break;\n                            }\n                        }\n                    }\n                } catch (SQLException exception) {\n                    unexpectedException(\"contains\", exception);\n                }\n            return exists;\n        }\n\n        /**\n         * Returns an iterator over the codes. The iterator is backed by a living {@link ResultSet},\n         * which will be closed as soon as the iterator reach the last element.\n         */\n        @Override\n        public synchronized java.util.Iterator<String> iterator() {\n            try {\n                final Iterator iterator = new Iterator(getAll());\n                /*\n                 * Set the statement to null without closing it, in order to force a new statement\n                 * creation if getAll() is invoked before the iterator finish its iteration.  This\n                 * is needed because only one ResultSet is allowed for each Statement.\n                 */\n                queryAll = null;\n                return iterator;\n            } catch (SQLException exception) {\n                unexpectedException(\"iterator\", exception);\n                final Set<String> empty = Collections.emptySet();\n                return empty.iterator();\n            }\n        }\n\n        /**\n         * Returns a serializable copy of this set. This method is invoked automatically during\n         * serialization. The serialised set of authority code is disconnected from the underlying\n         * database.\n         */\n        protected LinkedHashSet<String> writeReplace() throws ObjectStreamException {\n            return new LinkedHashSet<>(this);\n        }\n\n        /**\n         * Closes the underlying statements. Note: this method is also invoked directly by {@link\n         * DirectEpsgFactory#dispose}, which is okay in this particular case since the\n         * implementation of this method can be executed an arbitrary amount of times.\n         */\n        @Override\n        @SuppressWarnings(\"deprecation\") // finalize is deprecated in Java 9\n        protected synchronized void finalize() throws SQLException {\n            if (querySingle != null) {\n                querySingle.close();\n                querySingle = null;\n            }\n            if (queryAll != null) {\n                queryAll.close();\n                queryAll = null;\n            }\n        }\n\n        /** Invoked when an exception occured. This method just log a warning. */\n        private void unexpectedException(final String method, final SQLException exception) {\n            unexpectedException(AuthorityCodes.class, method, exception);\n        }\n\n        /** Invoked when an exception occured. This method just log a warning. */\n        void unexpectedException(\n                final Class classe, final String method, final SQLException exception) {\n            Logging.unexpectedException(LOGGER, classe, method, exception);\n        }\n\n        /** Invoked when a recoverable exception occured. */\n        private void recoverableException(final String method, final SQLException exception) {\n            // Uses the FINE level instead of WARNING because it may be a recoverable error.\n            LogRecord record = Loggings.format(Level.FINE, LoggingKeys.UNEXPECTED_EXCEPTION);\n            record.setSourceClassName(AuthorityCodes.class.getName());\n            record.setSourceMethodName(method);\n            record.setThrown(exception);\n            record.setLoggerName(LOGGER.getName());\n            LOGGER.log(record);\n        }\n\n        /**\n         * The iterator over the codes. This inner class must kept a reference toward the enclosing\n         * {@link AuthorityCodes} in order to prevent a call to {@link AuthorityCodes#finalize}\n         * before the iteration is finished.\n         */\n        private final class Iterator implements java.util.Iterator<String> {\n            /** The result set, or {@code null} if there is no more elements. */\n            private ResultSet results;\n\n            /** The next code. */\n            private transient String next;\n\n            /** Creates a new iterator for the specified result set. */\n            Iterator(final ResultSet results) throws SQLException {\n                assert Thread.holdsLock(AuthorityCodeSet.this);\n                this.results = results;\n                toNext();\n            }\n\n            /** Moves to the next element. */\n            private void toNext() throws SQLException {\n                while (results.next()) {\n                    next = results.getString(1);\n                    if (isAcceptable(next)) {\n                        return;\n                    }\n                }\n                finalize();\n            }\n\n            /** Returns {@code true} if there is more elements. */\n            @Override\n            public boolean hasNext() {\n                return results != null;\n            }\n\n            /** Returns the next element. */\n            @Override\n            public String next() {\n                if (results == null) {\n                    throw new NoSuchElementException();\n                }\n                final String current = next;\n                try {\n                    toNext();\n                } catch (SQLException exception) {\n                    results = null;\n                    unexpectedException(Iterator.class, \"next\", exception);\n                }\n                return current;\n            }\n\n            /** Always throws an exception, since this iterator is read-only. */\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n\n            /** Closes the underlying result set. */\n            @Override\n            @SuppressWarnings(\"deprecation\") // finalize is deprecated in Java 9\n            protected void finalize() throws SQLException {\n                next = null;\n                if (results != null) {\n                    final PreparedStatement owner = (PreparedStatement) results.getStatement();\n                    results.close();\n                    results = null;\n                    synchronized (AuthorityCodeSet.this) {\n                        /*\n                         * We don't need the statement anymore. Gives it back to the enclosing class\n                         * in order to avoid creating a new one when AuthorityCodes.getAll() will be\n                         * invoked again,  or closes the statement if getAll() already created a new\n                         * statement anyway.\n                         */\n                        assert owner != queryAll;\n                        if (queryAll == null) {\n                            queryAll = owner;\n                        } else {\n                            owner.close();\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Returns a view of this set as a map with object's name as value, or {@code null} if none.\n         */\n        final java.util.Map<String, String> asMap() {\n            if (asMap == null) {\n                asMap = new Map();\n            }\n            return asMap;\n        }\n\n        /**\n         * A view of {@link AuthorityCodes} as a map, with authority codes as key and object names\n         * as values.\n         */\n        private final class Map extends AbstractMap<String, String> {\n            /** Returns the number of key-value mappings in this map. */\n            @Override\n            public int size() {\n                return AuthorityCodeSet.this.size();\n            }\n\n            /** Returns {@code true} if this map contains no key-value mappings. */\n            @Override\n            public boolean isEmpty() {\n                return AuthorityCodeSet.this.isEmpty();\n            }\n\n            /** Returns the description to which this map maps the specified EPSG code. */\n            @Override\n            public String get(final Object code) {\n                String value = null;\n                if (code != null)\n                    try {\n                        synchronized (AuthorityCodeSet.this) {\n                            try (ResultSet results = getSingle(code)) {\n                                while (results.next()) {\n                                    if (isAcceptable(results)) {\n                                        value = results.getString(2);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    } catch (SQLException exception) {\n                        unexpectedException(\"get\", exception);\n                    }\n                return value;\n            }\n\n            /** Returns {@code true} if this map contains a mapping for the specified EPSG code. */\n            @Override\n            public boolean containsKey(final Object key) {\n                return contains(key);\n            }\n\n            /** Returns a set view of the keys contained in this map. */\n            @Override\n            public Set<String> keySet() {\n                return AuthorityCodeSet.this;\n            }\n\n            /**\n             * Returns a set view of the mappings contained in this map.\n             *\n             * @todo Not yet implemented.\n             */\n            @Override\n            public Set<Map.Entry<String, String>> entrySet() {\n                throw new UnsupportedOperationException();\n            }\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2001-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.referencing.factory.epsg;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.util.jar.Attributes.Name;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.naming.NoInitialContextException;\nimport javax.sql.DataSource;\nimport org.geotools.metadata.i18n.ErrorKeys;\nimport org.geotools.metadata.i18n.Errors;\nimport org.geotools.metadata.i18n.LoggingKeys;\nimport org.geotools.metadata.i18n.Loggings;\nimport org.geotools.metadata.i18n.Vocabulary;\nimport org.geotools.metadata.i18n.VocabularyKeys;\nimport org.geotools.metadata.iso.citation.Citations;\nimport org.geotools.referencing.ReferencingFactoryFinder;\nimport org.geotools.referencing.factory.AbstractAuthorityFactory;\nimport org.geotools.referencing.factory.DeferredAuthorityFactory;\nimport org.geotools.referencing.factory.FactoryNotFoundException;\nimport org.geotools.referencing.factory.ReferencingFactoryContainer;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.factory.Hints;\nimport org.opengis.metadata.citation.Citation;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.crs.CRSAuthorityFactory;\nimport org.opengis.referencing.cs.CSAuthorityFactory;\nimport org.opengis.referencing.datum.DatumAuthorityFactory;\nimport org.opengis.referencing.operation.CoordinateOperationAuthorityFactory;\n\n/**\n * Base class for EPSG factories to be registered in {@link ReferencingFactoryFinder}. Various\n * subclasses are defined for different database backends: Access, PostgreSQL, HSQL,\n * <cite>etc.</cite>.\n *\n * <p>This class has the following responsibilities:\n *\n * <ul>\n *   <li>aquire a DataSource (using JNDI or otherwise)\n *   <li>specify a worker class that will talk to the database in the event of a cache miss. The\n *       class will be specific to the delect of SQL used by the database hosting the EPSG tables.\n * </ul>\n *\n * Please note we are working with <b>the same</b> tables as defined by EPSG. The only thing that\n * changes is the database used to host these tables.\n *\n * <p>Subclasses should override the following methods:\n *\n * <ul>\n *   <li>{@linkplain #createDataSource} used to aquire a DataSource\n *   <li>{@link #createBackingStore} instance capable to speak that database syntax\n * </ul>\n *\n * <p>Users should not creates instance of this class directly. They should invoke one of <code>\n * {@linkplain ReferencingFactoryFinder}.getFooAuthorityFactory(\"EPSG\")</code> methods instead.\n *\n * @since 2.4\n * @version $Id$\n * @author Martin Desruisseaux (IRD)\n */\npublic class ThreadedEpsgFactory extends DeferredAuthorityFactory\n        implements CRSAuthorityFactory,\n                CSAuthorityFactory,\n                DatumAuthorityFactory,\n                CoordinateOperationAuthorityFactory {\n    /**\n     * The default JDBC {@linkplain DataSource data source} name in JNDI. This is the name used if\n     * no other name were specified through the {@link Hints#EPSG_DATA_SOURCE EPSG_DATA_SOURCE}\n     * hint.\n     *\n     * @see #createDataSource\n     */\n    public static final String DATASOURCE_NAME = \"java:comp/env/jdbc/EPSG\";\n\n    /**\n     * {@code true} if automatic registration of {@link #datasourceName} is allowed. Set to {@code\n     * false} for now because the registration has not been correctly tested in JEE environment.\n     *\n     * @todo Consider removing completly the code related to JNDI binding. In such case, this field\n     *     and the {@link #registerInto} field would be removed.\n     */\n    private static final boolean ALLOW_REGISTRATION = false;\n\n    /** The default priority level for this factory. */\n    protected static final int PRIORITY = MAXIMUM_PRIORITY - 10;\n\n    /** The factories to be given to the backing store. */\n    private final ReferencingFactoryContainer factories;\n\n    /**\n     * The context where to register {@link #datasource}, or {@code null} if it should not be\n     * registered. This is used only as a way to pass \"hiden\" return value between {@link\n     * #createDataSource()} and {@link #createBackingStore()}.\n     */\n    private transient InitialContext registerInto;\n\n    /**\n     * The data source name. If it was not specified by the {@link Hints#EPSG_DATA_SOURCE\n     * EPSG_DATA_SOURCE} hint, then this is the {@value #DATASOURCE_NAME} value.\n     */\n    private String datasourceName;\n\n    /** The data source, or {@code null} if the connection has not yet been etablished. */\n    protected DataSource datasource;\n\n    /**\n     * Whether the DataSource is created along with the backing store, or it's a stable, long lived\n     * one\n     */\n    protected boolean dynamicDataSource = true;\n\n    /** Constructs an authority factory using the default set of factories. */\n    public ThreadedEpsgFactory() {\n        this(null);\n    }\n\n    /** Constructs an authority factory with the default priority. */\n    public ThreadedEpsgFactory(final Hints userHints) {\n        this(userHints, PRIORITY);\n    }\n\n    /**\n     * Constructs an authority factory using a set of factories created from the specified hints.\n     * This constructor recognizes the {@link Hints#CRS_FACTORY CRS}, {@link Hints#CS_FACTORY CS},\n     * {@link Hints#DATUM_FACTORY DATUM} and {@link Hints#MATH_TRANSFORM_FACTORY MATH_TRANSFORM}\n     * {@code FACTORY} hints, in addition of {@link Hints#EPSG_DATA_SOURCE EPSG_DATA_SOURCE}.\n     *\n     * @param userHints An optional set of hints, or {@code null} if none.\n     * @param priority The priority for this factory, as a number between {@link #MINIMUM_PRIORITY\n     *     MINIMUM_PRIORITY} and {@link #MAXIMUM_PRIORITY MAXIMUM_PRIORITY} inclusive.\n     */\n    public ThreadedEpsgFactory(final Hints userHints, final int priority) {\n        super(userHints, priority);\n\n        Object hint = (userHints == null) ? null : userHints.get(Hints.EPSG_DATA_SOURCE);\n\n        if (hint == null) {\n            datasourceName = DATASOURCE_NAME;\n            // datasourceName = GeoTools.fixName(DATASOURCE_NAME);\n            hints.put(Hints.EPSG_DATA_SOURCE, datasourceName);\n        } else if (hint instanceof String) {\n            datasourceName = (String) hint;\n            // datasourceName = GeoTools.fixName(datasourceName);\n            hints.put(Hints.EPSG_DATA_SOURCE, datasourceName);\n        } else if (hint instanceof Name) {\n            Name name = (Name) hint;\n            hints.put(Hints.EPSG_DATA_SOURCE, name);\n            datasourceName = name.toString();\n            // datasourceName = GeoTools.fixName(name.toString());\n        } else if (hint instanceof DataSource) {\n            datasource = (DataSource) hint;\n            hints.put(Hints.EPSG_DATA_SOURCE, datasource);\n            datasourceName = DATASOURCE_NAME;\n            dynamicDataSource = false;\n        }\n        factories = ReferencingFactoryContainer.instance(userHints);\n        long timeout = 30 * 60 * 1000;\n        String defaultTimeout =\n                System.getProperty(\n                        \"org.geotools.epsg.factory.timeout\", String.valueOf(30 * 60 * 1000));\n        try {\n            timeout = Long.valueOf(defaultTimeout);\n        } catch (NumberFormatException e) {\n            LOGGER.log(\n                    Level.WARNING,\n                    \"Invalid value for org.geotools.epsg.factory.timeout, \"\n                            + \"using the default (30 minutes) instead\");\n        }\n        // in case of negative timeout, we don't release the data source and backing store\n        if (timeout > 0) {\n            LOGGER.log(\n                    Level.FINE,\n                    \"Setting the EPSG factory \"\n                            + getClass().getName()\n                            + \" to a \"\n                            + timeout\n                            + \"ms timeout\");\n            setTimeout(timeout); // Close the connection after 1 second of inactivity.\n        } else {\n            LOGGER.log(\n                    Level.FINE, \"The EPSG factory \" + getClass().getName() + \" will not timeout\");\n        }\n    }\n\n    /**\n     * Returns the authority for this EPSG database. This authority will contains the database\n     * version in the {@linkplain Citation#getEdition edition} attribute, together with the\n     * {@linkplain Citation#getEditionDate edition date}.\n     */\n    @Override\n    public Citation getAuthority() {\n        final Citation authority = super.getAuthority();\n        return (authority != null) ? authority : Citations.EPSG;\n    }\n\n    /**\n     * Returns the data source for the EPSG database. If no data source has been previously\n     * {@linkplain #setDataSource set}, then this method invokes {@link #createDataSource}.\n     * <strong>Note:</strong> invoking this method may force immediate connection to the EPSG\n     * database.\n     *\n     * @return The data source.\n     * @throws SQLException if the connection to the EPSG database failed.\n     * @see #setDataSource\n     * @see #createDataSource\n     */\n    public final synchronized DataSource getDataSource() throws SQLException {\n        if (datasource == null) {\n            // Force the creation of the underlying backing store. It will invokes\n            // (indirectly) createBackingStore, which will fetch the DataSource.\n            if (!super.isAvailable()) {\n                // Connection failed, but the exception is not available.\n                datasource = null;\n                throw new SQLException(Errors.format(ErrorKeys.NO_DATA_SOURCE));\n            }\n        }\n        return datasource;\n    }\n\n    /**\n     * Set the data source for the EPSG database. If an other EPSG database was already in use, it\n     * will be disconnected. Users should not invoke this method on the factory returned by {@link\n     * ReferencingFactoryFinder}, since it could have a system-wide effect.\n     *\n     * @param datasource The new datasource.\n     * @throws SQLException if an error occured.\n     */\n    public synchronized void setDataSource(final DataSource datasource) throws SQLException {\n        if (datasource != this.datasource) {\n            try {\n                dispose();\n            } catch (FactoryException exception) {\n                final Throwable cause = exception.getCause();\n                if (cause instanceof SQLException) {\n                    throw (SQLException) cause;\n                }\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                }\n                // Not really an SQL exception, but we should not reach this point anyway.\n                final SQLException e = new SQLException(exception.getLocalizedMessage());\n                e.initCause(exception); // TODO: inline when we will be allowed to target Java 6.\n                throw e;\n            }\n            this.datasource = datasource;\n        }\n    }\n\n    /**\n     * Setup a data source for a connection to the EPSG database. This method is invoked by {@link\n     * #getDataSource()} when no data source has been {@linkplain #setDataSource explicitly set}.\n     * The default implementation searchs for a {@link DataSource} instance binded to the {@link\n     * Hints#EPSG_DATA_SOURCE} name (<code>{@value #DATASOURCE_NAME}</code> by default) using\n     * <cite>Java Naming and Directory Interfaces</cite> (JNDI). If no data source were found, then\n     * this method returns {@code null}.\n     *\n     * <p>Subclasses override this method in order to initialize a default data source when none\n     * were found with JNDI. For example {@code plugin/epsg-access} defines a default data source\n     * using the JDBC-ODBC bridge, which expects an \"{@code EPSG}\" database registered as an ODBC\n     * data source (see the {@linkplain org.geotools.referencing.factory.epsg package javadoc} for\n     * installation instructions). Example for a PostgreSQL data source:\n     *\n     * <blockquote>\n     *\n     * <pre>\n     * protected DataSource createDataSource() throws SQLException {\n     *     DataSource candidate = super.createDataSource();\n     *     if (candidate instanceof Jdbc3SimpleDataSource) {\n     *         return candidate;\n     *     }\n     *     Jdbc3SimpleDataSource ds = new Jdbc3SimpleDataSource();\n     *     ds.setServerName(\"localhost\");\n     *     ds.setDatabaseName(\"EPSG\");\n     *     ds.setUser(\"postgre\");\n     *     return ds;\n     * }\n     * </pre>\n     *\n     * </blockquote>\n     *\n     * @return The EPSG data source, or {@code null} if none where found.\n     * @throws SQLException if an error occured while creating the data source.\n     */\n    protected DataSource createDataSource() throws SQLException {\n        InitialContext context = null;\n        DataSource source = null;\n        try {\n            context = GeoTools.getInitialContext();\n            source = (DataSource) context.lookup(datasourceName);\n        } catch (IllegalArgumentException | NoInitialContextException exception) {\n            // Fall back on 'return null' below.\n        } catch (NamingException exception) {\n            registerInto = context;\n            // Fall back on 'return null' below.\n        }\n        return source;\n    }\n\n    /**\n     * Creates the backing store for the specified data source. This method usually returns a new\n     * instance of {@link AccessDialectEpsgFactory} or {@link AnsiDialectEpsgFactory}. Subclasses\n     * may override this method in order to returns an instance tuned for the SQL syntax of the\n     * underlying database. Example for a PostgreSQL data source:\n     *\n     * <blockquote>\n     *\n     * <pre>\n     * protected AbstractAuthorityFactory createBackingStore(Hints hints) throws SQLException {\n     *     return new AnsiDialectEpsgFactory(hints, getDataSource().getConnection());\n     * }\n     * </pre>\n     *\n     * </blockquote>\n     *\n     * @param hints A map of hints, including the low-level factories to use for CRS creation. This\n     *     argument should be given unchanged to {@code DirectEpsgFactory} constructor.\n     * @return The {@linkplain DirectEpsgFactory EPSG factory} using SQL queries appropriate for\n     *     this data source.\n     * @throws SQLException if connection to the database failed.\n     */\n    protected AbstractAuthorityFactory createBackingStore(final Hints hints) throws SQLException {\n        final DataSource source = getDataSource();\n        try (Connection connection = source.getConnection()) {\n\n            final String quote = connection.getMetaData().getIdentifierQuoteString();\n            if (quote.equals(\"\\\"\")) {\n                /*\n                 * PostgreSQL quotes the indentifiers with \"...\" while MS-Access quotes the\n                 * identifiers with [...], so we use the identifier quote string metadata as\n                 * a way to distinguish the two cases. However I'm not sure that it is a robust\n                 * criterion. Subclasses should always override as a safety.\n                 */\n                return new FactoryUsingAnsiSQL(hints, connection);\n            }\n            return new FactoryUsingSQL(hints, connection);\n        }\n    }\n\n    /**\n     * Gets the EPSG factory implementation connected to the database. This method is invoked\n     * automatically by {@link #createBackingStore()}.\n     *\n     * @return The connection to the EPSG database.\n     * @throws FactoryException if no data source were found.\n     * @throws SQLException if this method failed to etablish a connection.\n     * @todo Inline this method into {@link #createBackingStore()} after we removed the deprecated\n     *     code.\n     */\n    private AbstractAuthorityFactory createBackingStore0() throws FactoryException, SQLException {\n        /*\n         * We are locking on ReferencingFactoryFinder to avoid deadlocks.\n         * @see DeferredAuthorityFactory#getBackingStore()\n         */\n        assert Thread.holdsLock(ReferencingFactoryFinder.class);\n        final Hints sourceHints = new Hints(hints);\n        sourceHints.putAll(factories.getImplementationHints());\n        if (datasource != null) {\n            return createBackingStore(sourceHints);\n        }\n        /*\n         * Try to gets the DataSource from JNDI. In case of success, it will be tried\n         * for a connection before any DataSource declared in META-INF/services/.\n         */\n        DataSource source;\n        final InitialContext context;\n        try {\n            source = createDataSource();\n            context = registerInto;\n        } finally {\n            registerInto = null;\n        }\n        if (source == null) {\n            throw new FactoryNotFoundException(Errors.format(ErrorKeys.NO_DATA_SOURCE));\n        }\n        final AbstractAuthorityFactory factory;\n        try {\n            datasource = source;\n            factory = createBackingStore(sourceHints);\n        } finally {\n            datasource = null;\n        }\n        /*\n         * We now have a working connection. If a naming directory is running but didn't contains\n         * the \"jdbc/EPSG\" entry, add it now. In such case, a message is prepared and logged.\n         */\n        LogRecord record;\n        if (ALLOW_REGISTRATION && context != null) {\n            try {\n                context.bind(datasourceName, source);\n                record =\n                        Loggings.format(\n                                Level.FINE,\n                                LoggingKeys.CREATED_DATASOURCE_ENTRY_$1,\n                                datasourceName);\n            } catch (NamingException exception) {\n                record =\n                        Loggings.format(\n                                Level.WARNING, LoggingKeys.CANT_BIND_DATASOURCE_$1, datasourceName);\n                record.setThrown(exception);\n            }\n            log(record);\n        }\n        this.datasource = source; // Stores the data source only after success.\n        return factory;\n    }\n\n    /**\n     * Creates the backing store authority factory.\n     *\n     * @return The backing store to uses in {@code createXXX(...)} methods.\n     * @throws FactoryException if the constructor failed to connect to the EPSG database. This\n     *     exception usually has a {@link SQLException} as its cause.\n     */\n    @Override\n    protected AbstractAuthorityFactory createBackingStore() throws FactoryException {\n        final AbstractAuthorityFactory factory;\n        String product = '<' + Vocabulary.format(VocabularyKeys.UNKNOWN) + '>';\n        String url = product;\n        try {\n            factory = createBackingStore0();\n            if (factory instanceof DirectEpsgFactory) {\n                final DatabaseMetaData info =\n                        ((DirectEpsgFactory) factory).getConnection().getMetaData();\n                product = info.getDatabaseProductName();\n                url = info.getURL();\n            }\n        } catch (SQLException exception) {\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.CANT_CONNECT_DATABASE_$1, \"EPSG\"), exception);\n        }\n        log(Loggings.format(Level.CONFIG, LoggingKeys.CONNECTED_EPSG_DATABASE_$2, url, product));\n        if (factory instanceof DirectEpsgFactory) {\n            ((DirectEpsgFactory) factory).buffered = this;\n        }\n        return factory;\n    }\n\n    /** For internal use by {@link #createFactory()} and {@link #createBackingStore()} only. */\n    private static void log(final LogRecord record) {\n        record.setSourceClassName(ThreadedEpsgFactory.class.getName());\n        record.setSourceMethodName(\"createBackingStore\"); // The public caller.\n        record.setLoggerName(LOGGER.getName());\n        LOGGER.log(record);\n    }\n\n    /**\n     * Returns {@code true} if the backing store can be disposed now. This method is invoked\n     * automatically after the amount of time specified by {@link #setTimeout} if the factory were\n     * not used during that time.\n     *\n     * @param backingStore The backing store in process of being disposed.\n     */\n    @Override\n    protected boolean canDisposeBackingStore(final AbstractAuthorityFactory backingStore) {\n        if (backingStore instanceof DirectEpsgFactory) {\n            return ((DirectEpsgFactory) backingStore).canDispose();\n        }\n        return super.canDisposeBackingStore(backingStore);\n    }\n\n    @Override\n    protected void disposeBackingStore() {\n        super.disposeBackingStore();\n        if (dynamicDataSource) {\n            datasource = null;\n        }\n    }\n\n    @Override\n    public synchronized void dispose() throws FactoryException {\n        super.dispose();\n        datasource = null;\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2019, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.gce.pgraster;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.geotools.data.jdbc.datasource.DBCPDataSource;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.logging.Logging;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Configuration for a {@link PGRasterReader}.\n *\n * <p>Configuration is stored as XML with the following basic format:\n *\n * <pre>\n *     &lt;pgraster>\n *       &lt;name//>        // coverage name\n *       &lt;database>     // database connection\n *         &lt;host//>      // database host\n *         &lt;port//>      // database port\n *         &lt;name//>      // database name\n *         &lt;user//>      // database username\n *         &lt;pass//>      // database user password\n *       &lt;/database>\n *       &lt;raster>       // raster column config\n *         &lt;column//>      // column name\n *         &lt;table//>     // table name\n *         &lt;schema//>    // table schema\n *       &lt;/raster>\n *       &lt;time>        // time column config\n *         &lt;enabled//>  // enable / disable time\n *         &lt;column//>     // column name\n *       &lt;/time>\n *     &lt;/pgraster>\n *   </pre>\n */\nclass PGRasterConfig implements Closeable {\n\n    static final Logger LOG = Logging.getLogger(PGRasterConfig.class);\n\n    String name;\n    DataSource dataSource;\n    String schema;\n    String table;\n    String column;\n    String enableDrivers;\n\n    TimeConfig time = new TimeConfig();\n\n    static Document parse(File cfgfile) {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db;\n        try {\n            db = dbf.newDocumentBuilder();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error creating XML parser\");\n        }\n\n        try {\n            return db.parse(cfgfile);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error parsing pgraster config\", e);\n        }\n    }\n\n    PGRasterConfig(File configFile) {\n        this(parse(configFile));\n    }\n\n    PGRasterConfig(Document config) {\n        Element root = config.getDocumentElement();\n        if (!\"pgraster\".equalsIgnoreCase(root.getNodeName())) {\n            throw new IllegalArgumentException(\n                    \"Not a postgis raster configuration, root element must be 'pgraster'\");\n        }\n\n        this.name = first(root, \"name\").map(this::nodeValue).orElse(null);\n        this.enableDrivers = first(root, \"enableDrivers\").map(this::nodeValue).orElse(null);\n\n        Element db =\n                first(config.getDocumentElement(), \"database\")\n                        .orElseThrow(\n                                () ->\n                                        new IllegalArgumentException(\n                                                \"Config has no database element\"));\n\n        DataSource dataSource = null;\n\n        String jndi = first(db, \"jndi\").map(this::nodeValue).orElse(null);\n        if (jndi != null) {\n            try {\n                dataSource = (DataSource) GeoTools.getInitialContext().lookup(jndi);\n            } catch (NamingException e) {\n                throw new IllegalArgumentException(\"Error performing JNDI lookup for: \" + jndi, e);\n            }\n        }\n\n        if (dataSource == null) {\n            BasicDataSource source = new BasicDataSource();\n            source.setDriverClassName(\"org.postgresql.Driver\");\n\n            String host = first(db, \"host\").map(this::nodeValue).orElse(\"localhost\");\n\n            Integer port =\n                    first(db, \"port\").map(this::nodeValue).map(Integer::parseInt).orElse(5432);\n\n            String name =\n                    first(db, \"name\")\n                            .map(this::nodeValue)\n                            .orElseThrow(\n                                    () ->\n                                            new IllegalArgumentException(\n                                                    \"database 'name' not specified\"));\n\n            source.setUrl(\"jdbc:postgresql://\" + host + \":\" + port + \"/\" + name);\n\n            first(db, \"user\").map(this::nodeValue).ifPresent(source::setUsername);\n\n            first(db, \"passwd\").map(this::nodeValue).ifPresent(source::setPassword);\n\n            first(db, \"pool\")\n                    .ifPresent(\n                            p -> {\n                                first(p, \"min\")\n                                        .map(this::nodeValue)\n                                        .map(Integer::parseInt)\n                                        .ifPresent(source::setMinIdle);\n                                first(p, \"max\")\n                                        .map(this::nodeValue)\n                                        .map(Integer::parseInt)\n                                        .ifPresent(source::setMaxActive);\n                            });\n\n            dataSource = new PGRasterDataSource(source);\n        }\n\n        this.dataSource = dataSource;\n\n        Element ras =\n                first(config.getDocumentElement(), \"raster\")\n                        .orElseThrow(\n                                () ->\n                                        new IllegalArgumentException(\n                                                \"Config has no 'raster' element\"));\n\n        this.schema = first(ras, \"schema\").map(this::nodeValue).orElse(\"public\");\n        this.table =\n                first(ras, \"table\")\n                        .map(this::nodeValue)\n                        .orElseThrow(\n                                () ->\n                                        new IllegalArgumentException(\n                                                \"column must specify a 'table' element\"));\n        this.column = first(ras, \"column\").map(this::nodeValue).orElse(null);\n\n        // time\n        first(config.getDocumentElement(), \"time\")\n                .ifPresent(\n                        el -> {\n                            first(el, \"enabled\")\n                                    .map(this::nodeValue)\n                                    .map(Boolean::parseBoolean)\n                                    .ifPresent(it -> time.enabled = it);\n                            first(el, \"column\")\n                                    .map(this::nodeValue)\n                                    .ifPresent(it -> time.column = it);\n                        });\n    }\n\n    @VisibleForTesting\n    PGRasterConfig() {}\n\n    Optional<Element> first(Element el, String name) {\n        NodeList matches = el.getElementsByTagName(name);\n        if (matches.getLength() > 0) {\n            return Optional.of((Element) matches.item(0));\n        }\n        return Optional.empty();\n    }\n\n    String nodeValue(Element el) {\n        return el.getFirstChild().getNodeValue();\n    }\n\n    @Override\n    public void close() {\n        if (dataSource instanceof PGRasterDataSource) {\n            try {\n                ((PGRasterDataSource) dataSource).close();\n            } catch (SQLException e) {\n                LOG.log(Level.WARNING, \"Error closing data source\", e);\n            }\n        }\n    }\n\n    static class TimeConfig {\n        boolean enabled = true;\n        String column;\n    }\n\n    static class PGRasterDataSource extends DBCPDataSource {\n\n        PGRasterDataSource(BasicDataSource wrapped) {\n            super(wrapped);\n        }\n    }\n}\n"], "fixing_code": ["``GeoTools``\n------------\n\nThe first utility class we have is helpfully called ``GeoTools``. This class is used to configure the library for your application.\n\nIt also provides the version number of the library, in case you want to check at runtime.::\n  \n  GeoTools.getVersion(); // Example 15.0\n\n``Hints``\n^^^^^^^^^\n\n``Hints`` are used to configure the GeoTools library for use in your application. The value provided by ``GeoTools.getDefaultHints()`` can be configured as part of your application startup:\n\n.. code-block:: java\n\n   Hints.putSystemDefault(Hints.ENTITY_RESOLVER, NullEntityResolver.INSTANCE);\n   Hints.removeSystemDefault(Hints.ENTITY_RESOLVER);\n\nGeoTools ``Hints`` are similar to a ``Map<GeoTools.Key,Object>``, the ``GeoTools.Key`` instances each provide javadocs, and some control over the values that may be used. For example the ``Hints.ENTITY_RESOLVER`` values must be an instance of ``EntityResolver``.\n\nBy contrast Java system properties are similar to a ``Map<String,String>`` and may be specified programmatically or on the command line. The following bindings to system properties are defined (each as static constants in the ``GeoTools`` class):\n\n===================================== ===============================================\n``CRS_AUTHORITY_EXTRA_DIRECTORY``     ``org.geotools.referencing.crs-directory``\n``EPSG_DATA_SOURCE``                  ``org.geotools.referencing.epsg-datasource``\n``FORCE_LONGITUDE_FIRST_AXIS_ORDER``  ``org.geotools.referencing.forceXY``\n``LOCAL_DATE_TIME_HANDLING``          ``org.geotools.localDateTimeHandling``\n``RESAMPLE_TOLERANCE``                ``org.geotools.referencing.resampleTolerance``\n``ENTITY_RESOLVER``                   ``org.xml.sax.EntityResolver``\n===================================== ===============================================\n\n\nThe bound system properties can also be used to configure Hints:\n\n.. code-block:: java\n   \n   // Allow access to local dtd and xsd files\n   System.getProperties.put(GeoTools.ENTITY_RESOLVER, \"org.geotools.util.NullEntityResolver\");\n   Hints.scanSystemProperties();\n\nPlug-ins\n^^^^^^^^\n\nIncreasingly GeoTools is being used in carefully managed plug-in systems such as Eclipse or Spring. In order to allow GeoTools to locate its own plug-ins you may need to configure the ``GeoTools`` class with additional class loaders provided by your environment.::\n  \n  GeoTools.addClassloader( loader );\n\nOut of the box GeoTools searches on the ``CLASSPATH`` available, in order to find plug-in and wire them into the library. It does this by looking in the jar's ``META-INF/services`` folder which lists plug-in classes.\n\nIn rare cases, such as OSGi plug-in system, adding additional jars to the ``CLASSPATH`` is not enough. OSGi blocks access to the ``META-INF/services`` folder. In these cases you will need to provide access to the classes yourself.::\n  \n  GeoTools.addFactoryIteratorProvider( provider );\n\nJNDI\n^^^^\n\nTo configure GeoTools to look up services in a specific context use the following:\n\n.. code-block:: java\n  \n   GeoTools.init( context ); // JNDI configuration\n\nFor JNDI lookup GeooTools uses:\n\n.. code-block:: java\n\n   DataSource dataSource = (DataSource) GeoTools.jndiLookup(name);\n   \nThe ``jndiLookup(String)`` is to safe lookups by default. The default use of ``GeoTools.DEFAULT_JNDI_VALIDATOR`` ensures only no-schema and java schema lookups are allowed. To relax this policy you may supply your own approach using ``GeoTools.setJNDINameValidator(Predicate<String>)``.\n\nXML\n^^^\n\nWhen embedding GeoTools in your own application you may wish to configure the library to use a specific ``EntityResolver`` (to access any XML Schema files included in your application, or to restrict access based on security policies).\n\nGeoTools uses a range of XML technologies when implementing both format and protocol support - where possible these are configured based on the ``Hints.ENTITY_RESOLVER`` described above.\n\nTo access the configured ``ENTITY_RESOLVER``:\n\n.. code-block:: java\n   \n   parser.setEntityResolver( GeoTools.getEntityResolver(hints) );\n\nGeoTools also includes two ``EntityResolver`` implementations:\n\n* ``PreventLocalEntityResolver``: For use when working with external XML documents, only allows DTD and XML Schema references to remote resources\n* ``NullEntityResolver``: Placeholder allowing the default ``SAXParser`` access-anything behavior.\n\nThe library uses ``PreventLocalEntityResolver`` by default, if you wish to work with a local XML file (referencing local DTD and XMLSchema) please use the following during application setup:\n\n.. code-block:: java\n\n   Hints.putSystemDefault(Hints.ENTITY_RESOLVER, NullEntityResolver.INSTANCE);\n\nLogging\n^^^^^^^\n\nIf you are working in your own application, you can teach GeoTools to use your application logging facilities (rather than Java logging which it uses by internal default).::\n  \n  GeoTools.setLoggerFactory( loggerFactory );\n\nGeoTools provides out of the box implementations for:\n\n* ``CommonsLoggerFactory`` - Apache's Common Logging framework\n* ``Log4jLoggerFactory`` - Log4J\n\nHere are a couple of examples of setting things up:\n\n* Do nothing\n  \n  Out of the box GeoTools will use Java logging\n\n* Setup for the Paranoid\n  \n  The example below tries to setup Commons-Logging first, and\n  fallback on Log4J if the former is not present on the\n  CLASSPATH.::\n    \n    try {\n        GeoTools.setLoggerFactory(\"org.geotools.util.logging.CommonsLoggerFactory\");\n    } catch (ClassNotFoundException commonsException) {\n        try {\n                GeoTools.setLoggerFactory(\"org.geotools.util.logging.Log4JLoggerFactory\");\n        } catch (ClassNotFoundException log4jException) {\n            // Nothing to do, we already tried our best.\n        }\n    }\n\n  In the above code ``ClassNotFoundException`` is a checked\n  exception thrown if Commons-Logging or Log4J is not available\n  on the CLASSPATH, so GeoTools continue to rely on the Java\n  logging system instead.\n\n* Log4J\n  \n  The following is a good approach only if the Log4J framework\n  is certain to be present on the CLASSPATH.::\n    \n    GeoTools.setLoggerFactory(Log4JLoggerFactory.getInstance());\n \n  Be warned that if Log4J is not available this method call has\n  unpredictable behavior.\n  \n  It will typically throws a ``NoClassDefFoundError`` (the unchecked\n  error, not the checked exception) at some future point. The\n  error may not be thrown at the moment ``setLoggerFactory`` is\n  invoked, but rather be delayed until a message is first logged,\n  which may surprise the user.\n\n* Custom\n  \n  You can create your own ``LoggerFactory`` if you need to track\n  messages using your own facilities.\n  \n  This is a good approach if you are making use of Eclipse\n  and would like to check bundle \"trace\" settings.\n  \nJAI\n^^^\n\nGeoTools Logging will listen to ``JAI`` errors and log them appropriately. It does this by first checking if your application has registered an ``ImagingListener``, and if not it will register a ``LoggingImagingListener`` to redirect JAI warnings. Common ``JAI`` errors (such as \"Continuing in pure Java mode\") are logged as ``Level.TRACE`` messages, all other errors are logged as ``Level.INFO``.\n\nIf you would like to check this bootstrapping process use the system property `-DLOGGING_TRACE=true`.\n\nTo completely filter JAI messages from your application set `javax.media.jai` group to ``Level.WARNING``::\n   \n   Logging.getLogger(\"javax.media.jai\").setLevel(Level.WARNING);\n\n", "Upgrade\n=======\n\nWith a library as old as GeoTools you will occasionally run into a project from ten years ago that\nneeds to be upgraded. This page collects the upgrade notes for each release change; highlighting any\nfundamental changes with code examples showing how to upgrade your code.\n\nBut first to upgrade - change your dependency geotools.version to |release| (or an appropriate stable version):\n\n.. code-block:: xml\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <geotools.version>|release|</geotools.version>\n    </properties>\n    ....\n    <dependencies>\n        <dependency>\n            <groupId>org.geotools</groupId>\n            <artifactId>gt-shapefile</artifactId>\n            <version>${geotools.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.geotools</groupId>\n            <artifactId>gt-swing</artifactId>\n            <version>${geotools.version}</version>\n        </dependency>\n        ....\n    </dependencies>\n\nGeoTools 26.x\n-------------\n\nShapefile\n^^^^^^^^^\n\n``ShapefileDataStore`` will autodetect DBF charset from CPG sidecar file, the feature now enabled by default. When this feature is enabled, the following rules apply:\n\n* if no explicit charset parameter passed to ``ShapefileDataStoreFactory``, it will instruct created ``ShapefileDataStore``\n  to try and figure out DBF file charset from CPG file. In this case, CPG files must contain correct charset name, otherwise, \n  these files should be removed, or updated properly. \n* if the store fails to read CPG, it uses the default charset specified by ``ShapefileDataStoreFactory.DBFCHARSET`` constant, \n  which is usual behavior.\n\nIn case of trouble there is an ability to bring old behavior back by setting ``org.geotools.shapefile.enableCPG`` system property\nto \"false\". This turns autodetection off. The name of the property stored in ``ShapefileDataStoreFactory.ENABLE_CPG_SWITCH`` constant.\n\nUnit of Measurement Formatting\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs more third-party libraries adopt the Java module system, stricter rules regarding access to\nnon-public parts of other modules apply.\n\nOne such case was the way GeoTools' unit formatters were previously initialized, which caused\nGeoTools to fail immediately when run from the module path.\n\nFixing this required changes to multiple classes:\n\n* ``GeoToolsUnitFormat`` which was previously used to access innards of a third-party library and\n  provide access to GeoTools-specific unit formatting instance has been split up and moved:\n  * Building and initializing individual unit formatting instances can now be done using the\n  ``org.geotools.measure.BaseUnitFormatter`` constructor (instead of extending\n  ``org.geotools.util.GeoToolsUnitFormat`` and its inner class ``BaseGT2Format``).\n  * The GeoTools-specific formatting instance can now be accessed with\n  ``org.geotools.measure.UnitFormat.getInstance()`` (instead of\n  ``org.geotools.util.GeoToolsUnitFormat.getInstance()``).\n* ``org.geotools.referencing.wkt.DefaultUnitParser`` has been moved and renamed to\n  ``org.geotools.measure.WktUnitFormat``.\n\nGeoTools 25.x\n-------------\n\nGeoTools\n^^^^^^^^\n\nIn GeoTools 25.7 ``GeoTools.getInitialContext().look(name)`` and related methods have been deprecated, with ``GeoTools.jndiLookup(name)``. We have also taken an opportunity to remove ``GeoTools.fixName( context, name )`` \n\nThe use of ``GeoTools.jndiLookup(name)`` is subject to validation with the default ``GeoTools.DEFAULT_JNDI_VALIDATOR`` validator used limit name lookup.\n\nBEFORE\n\n.. code-block:: java\n\n   context = GeoTools.getInitialContext();\n   String fixedName = GeoTools.fixName( context, name );\n   return (DataSource) context.lookup(fixedName);\n\nAFTER\n\n.. code-block:: java\n\n   return (DataSource) GeoTools.jndiLookup(name);\n\n\nMore variable arguments support in core classes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSeveral code classes have been switched to use ``varargs`` instead of explicit arrays. \nWhile the old clients are compatible with these changes, there's now an opportunity\nto simplify code.\n\nBEFORE\n\n.. code-block:: java\n\n   // style creation\n   FeatureTypeStyle fts = styleFactory.createFeatureTypeStyle(new Rule[] {rule});\n   // query handling\n   Query q = new Query(tname(\"ft1\"));\n   q.setSortBy(new SortBy[] {new SortByImpl(\"prop\", ASCENDING)});\n   q.setPropertyNames(new String[] {\"geom\"});\n   // feature building\n   SimpleFeatureBuilder fb = new SimpleFeatureBuilder(targetType);\n   SimpleFeature = fb.buildFeature(\"f1\", new Object[] {null, 1}));\n   // test collection creation\n   SimpleFeatureCollection collection = DataUtilities.collection(new SimpleFeature[] {feature1, feature2});\n\n\nAFTER\n\n.. code-block:: java\n\n   // style creation\n   FeatureTypeStyle fts = styleFactory.createFeatureTypeStyle(rule);\n   // query handling\n   Query q = new Query(tname(\"ft1\"));\n   q.setSortBy(new SortByImpl(\"prop\", ASCENDING));\n   q.setPropertyNames(\"geom\");\n   // feature building\n   SimpleFeatureBuilder fb = new SimpleFeatureBuilder(targetType);\n   SimpleFeature = fb.buildFeature(\"f1\", null, 1));\n   // test collection creation\n   SimpleFeatureCollection collection = DataUtilities.collection(feature1, feature2);\n\nDataStore creation parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe DataAccess and DataStore creation parameters have been switched from ``Map<String, Serializable>``\nto ``Map<String, ?>``, to match actual usage (some stores require non serializable parameters).\nThis should not affect end users of the API, but ``DataAccessFactory`` and ``DataStoreFactory``\nimplementations will have to be updated to match.\n\nFor those feeding ``Properties`` object to ``DataAccess.getDataStore()`` a new utility method,\n``DataUtilities.toConnectionParameters`` has been made available, which converts a ``Properties``\nto a ``Map<String, ?>``.\n\n.. code-block:: java\n\n   Map<String,?> connectionParameters = DataUtilities.toConnectionParameters(properties);\n   DataStore dataStore = DataStoreFinder.getDataStore(connectionParameters);\n\nHTTPClient moved to its own module\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA new module ``gt-http`` has been established for the HTTPClient API.\n\nThe original interfaces ``HTTPClient`` and ``HTTPResponse`` and their implementations:\n(``SimpleHttpClient``, ``DelegateHTTPClient``, ``LoggingHTTPClient`` and DelegateHTTPResponse) have moved from \n``org.geotools.data.ows`` to the ``org.geotools.http`` package.\n\n\nPlaceholders for the previous implementations remain in place, with a deprecation reminding you to switch to\nthe new import as out outlined in the table below.\n\n===============================================  =========================  ===============================================================\nDeprecated class                                 Module                       Replacement (other module)\n===============================================  =========================  ===============================================================\norg.geotools.data.ows.AbstractHttpClient         gt-main                     org.geotools.http.AbstractHttpClient\norg.geotools.data.ows.MockHttpClient             gt-main                     org.geotools.http.MockHttpClient\norg.geotools.data.ows.MockHttpResponse           gt-main                     org.geotools.http.MockHttpResponse\norg.geotools.data.ows.DelegateHTTPClient         gt-main                     org.geotools.http.DelegateHTTPClient\norg.geotools.data.ows.DelegateHTTPResponse       gt-main                     org.geotools.http.DelegateHTTPResponse\norg.geotools.data.ows.HTTPClient                 gt-main                     org.geotools.http.HTTPClient\norg.geotools.data.ows.HTTPResponse               gt-main                     org.geotools.http.HTTPResponse\norg.geotools.data.ows.LoggingHTTPClient          gt-main                     org.geotools.http.LoggingHTTPClient\norg.geotools.data.ows.SimpleHttpClient           gt-main                     org.geotools.http.SimpleHttpClient\norg.geotools.ows.wms.MultithreadedHttpClient     gt-wms                      org.geotools.http.MultithreadedHttpClient (gt-http-commons)\norg.geotools.ows.MockHttpClient                  gt-wms                      org.geotools.http.MockHttpClient\norg.geotools.ows.MockHttpResponse                gt-wms                      org.geotools.http.MockHttpResponse\norg.geotools.ows.wmts.MockHttpClient             gt-wmts                     org.geotools.http.AbstractHttpClient\norg.geotools.data.mongodb.MockHTTPClient         gt-mongodb                  org.geotools.http.MockHttpClient\norg.geotools.data.mongodb.MockHttpResponse       gt-mongodb                  org.geotools.http.MockHttpResponse\norg.geotools.ows.wfs.MultithreadedHttpClient     gt-wfs-ng                   org.geotools.http.MultithreadedHttpClient (gt-http-commons)\norg.geotools.ows.wfs.AbstractTestHTTPClient      gt-wfs-ng                   org.geotools.http.AbstractHttpClient\norg.geotools.data.Base64                         gt-main                     org.geotools.util.Base64 (gt-metadata)\n===============================================  =========================  ===============================================================\n\nThis will result in a compile error in cases where GeoTools returns `org.geotools.http.HTTPClient`.\n\nBEFORE (compile error):\n\n.. code-block:: java\n   \n   import org.geotools.ows.HTTPClient;\n   \n   WebMapServer wms = new WebMapServer(\"http://atlas.gc.ca/cgi-bin/atlaswms_en?VERSION=1.1.1&Request=GetCapabilities&Service=WMS\");\n   HTTPClient client = wms.getHTTPClient();\n\nAFTER change imports (recommended):\n\n.. code-block:: java\n\n   import org.geotools.http.HTTPClient;\n   \n   WebMapServer wms = new WebMapServer(\"http://atlas.gc.ca/cgi-bin/atlaswms_en?VERSION=1.1.1&Request=GetCapabilities&Service=WMS\");\n   HTTPClient client = (HTTPClient) wms.getHTTPClient();\n\nALTERNATIVE add cast (continue to use deprecated api):\n\n.. code-block:: java\n\n   import org.geotools.data.ows.HTTPClient;\n   \n   WebMapServer wms = new WebMapServer(\"http://atlas.gc.ca/cgi-bin/atlaswms_en?VERSION=1.1.1&Request=GetCapabilities&Service=WMS\");\n   HTTPClient client = (HTTPClient) wms.getHTTPClient();\n\n\nHTTPClientFinder\n^^^^^^^^^^^^^^^^^\n\nTo allow the library to be configured with different ``HTTPClient`` implementations ``HTTPClientFinder`` is recommend:\n\nBEFORE:\n\n.. code-block:: java\n   \n   import org.geotools.data.ows.HTTPClient;\n   import org.geotools.data.ows.HTTPResponse;\n   import org.geotools.ows.SimpleHttpClient;\n   \n   \n   HTTPClient http = new SimpleHttpClient();\n   HTTPResponse response = http.get();   \n\nAFTER:\n\n.. code-block:: xml\n\n   <dependency>\n      <groupId>org.geotools</groupId>\n      <artifactId>gt-http</artifactId>\n      <version>${gt.version}</version>\n   </dependency>\n\n.. code-block:: java\n\n   import org.geotools.http.HTTPClient;\n   import org.geotools.http.HTTPResponse;\n   import org.geotools.http.HTTPClientFinder;\n      \n   HTTPClient http = HTTPClientFinder.createClient();\n   HTTPResponse response = http.get();\n   \nIn addition a new plugin ``gt-http-commons`` has been added for MultithreadedHttpClient.\n\n.. code-block:: xml\n\n     <dependency>\n        <groupId>org.geotools</groupId>\n        <artifactId>gt-http-commons</artifactId>\n        <version>${gt.version}</version>\n     </dependency>\n\n.. code-block:: java\n\n   import org.geotools.http.HTTPClient;\n   import org.geotools.http.HTTPResponse;\n   import org.geotools.http.HTTPClientFinder;\n   import org.geotools.http.commons.MultihreadedHttpClient;\n      \n   Hints hints = new Hints(Hints.HTTP_CLIENT, MultihreadedHttpClient.class);\n   HTTPClient http = HTTPClientFinder.createClient(hints);\n   HTTPResponse response = http.get();\n\nWMTS - WebMapTileServer initialisation\n--------------------------------------\n\nWe have introduced a new contructor for the WebMapTileServer.\nThe reason is that any HTTP headers must be specified prior to initialisation.\n\nThis might introduce a problem where a constuctor taking three arguments are used.\n\nSee list of available constructors:\n\n.. code-block:: java\n\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient)\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient, Map<String, String> headers) // <- NEW CONSTRUCTOR\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient, WMTSCapabilities capabilities)\n  public WebMapTileServer(URL serverURL, HTTPClient httpClient, WMTSCapabilities capabilities, Map<String, Object> hints)\n\nFor the same reason we will not allow changes to the headers after initialisation,\nand have deprecated ``public Map<String, String> getHeaders()``.\n\n\nGeoTools 24.x\n-------------\n\nThe Oracle extension was upgraded to use the current JDBC driver release. If you are using ``oracle.jdbc.driver.OracleDriver`` in your code to load the JDBC driver you should change this to ``oracle.jdbc.OracleDriver``.\n\n``DbaseFileHeader.readHeader(ReadableByteChannel, Charset)`` method was removed. Instead ``DbaseFileHeader`` constructor must be used to pass a charset and ``DbaseFileHeader.readHeader(ReadableByteChannel)`` to read the header.\n\nThe Units library (JSR 385) was updated to Units 2.0. This is mostly a change from package ``tec.uom.se.*`` to ``tech.units.indriya.*``. If you make any use of the Units library in your own code you will need to update the imports. There are also changes to the arithmetic operations' names. See this `blog post <https://schneide.blog/tag/unit-api-2-0/>`_ for more details.\n\nGeoTools 22.x\n-------------\n\nChange to repo.osgeo.org for GeoTools releases\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUse *osgeo* repository ``https://repo.osgeo.org/repository/release/``:\n\n* Replaces *osgeo* release repository ``http://download.osgeo.org/webdav/geotools/`` for GeoTools releases.\n* This is a group repository used by several OSGeo projects.\n* This group repository also provides third-party dependencies used by GeoTools (such as JTS and JAI-EXT).\n\nBEFORE :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repository>\n       <id>osgeo</id>\n       <name>Open Source Geospatial Foundation Repository</name>\n       <url>http://download.osgeo.org/webdav/geotools/</url>\n   </repository>\n   \nAFTER :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repositories>\n     <repository>\n       <id>osgeo</id>\n       <name>OSGeo Release Repository</name>\n       <url>https://repo.osgeo.org/repository/release/</url>\n       <snapshots><enabled>false</enabled></snapshots>\n       <releases><enabled>true</enabled></releases>\n     </repository>\n   </repositories>\n\nAlternative: Mirror retired repo.boundlessgeo.com\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo build existing projects referencing ``http://repo.boundlessgeo.com/``, with no modifications to :file:`pom.xml`, configure mirrors using :file:`~/.m2/settings.xml`.\n\nChange to :file:`settings.xml`:\n\n.. code-block:: xml\n\n   <mirrors>\n     <mirror>\n       <id>osgeo-release</id>\n       <name>OSGeo Repository</name>\n       <url>https://repo.osgeo.org/repository/release/</url>\n       <mirrorOf>osgeo</mirrorOf>     <!-- previously http://download.osgeo.org/webdav/geotools/ -->\n     </mirror>\n     <mirror>\n       <id>geoserver-releases</id>\n       <name>Boundless Repository</name>\n       <url>https://repo.osgeo.org/repository/Geoserver-releases/</url>\n       <mirrorOf>boundless</mirrorOf> <!-- previously http://repo.boundlessgeo.com/main/ -->\n     </mirror>\n   </mirrors>\n\nBoth of the above repositories above are included in ``https://repo.osgeo.org/repository/release/`` group repository. The mirror settings are intended as a temporary measure to allow your projects to build while you update your :file:`pom.xml` to use the osgeo release repository.\n\nChange to repo.osgeo.org for GeoTools snapshots\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUse *osgeo-snapshots* repository ``https://repo.osgeo.org/repository/snapshot/``:\n\n* Replaces *boundless* snapshot repository ``http://repo.boundlessgeo.com/main`` for the GeoTools SNAPSHOTS.\n* This is a group snapshot repository used by several OSGeo projects\n\nThe contents of the *boundless* repository ``https://repo.boundlessgeo.com/main/`` previously included snapshots of active GeoTools builds. The repository ``https://repo.osgeo.org/repository/geotools-snapshots/`` has taking over this role for the GeoTools project ( and is included in the group repository ``https://repo.osgeo.org/repository/snapshot/``).\n\nTo update existing projects making use of an active branch replace *boundless* snapshot repository with *osgeo-snapshot* repository.\n\nBEFORE :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repository>\n       <snapshots>\n           <enabled>true</enabled>\n       </snapshots>\n       <id>boundless</id>\n       <name>Boundless Maven Repository</name>\n       <url>http://repo.boundlessgeo.com/main</url>\n   </repository>\n\nAFTER :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <repository>\n     <id>osgeo-snapshot</id>\n     <name>OSGeo Snapshot Repository</name>\n     <url>https://repo.osgeo.org/repository/snapshot/</url>\n     <snapshots><enabled>true</enabled></snapshots>\n     <releases><enabled>false</enabled></releases>\n   </repository>\n\nGeoTools 21.x\n-------------\n\nGeoTools 21 is the first is compatible with Java 8 and Java 11.\n\nRestructured Library\n^^^^^^^^^^^^^^^^^^^^\n\nThe library has been restructured with automatic module names for Java 11 use.\n\nThe following table shows how maven dependencies have changed, and the resulting automatic module name for Java 11 use.\n\n.. list-table:: Restructure Library\n   :widths: 30, 30, 40\n   :header-rows: 1\n   \n   * - Dependency\n     - Upgrade\n     - Automatic Module Name\n   * - ``gt-opengis``\n     - ``gt-opengis``\n     - ``org.geotools.opengis``\n   * - ``gt-metadata``\n     - ``gt-metadata``\n     - ``org.geotools.metadata``\n   * - ``gt-api``\n     - (removed)\n     - \n   * - ``gt-referencing``\n     - ``gt-referencing``\n     - ``org.geotools.referencing``\n   * - ``gt-main``\n     - ``gt-main``\n     - ``org.geotools.main``\n   * - ``gt-xml``\n     - ``gt-xml``\n     - ``org.geotools.xml``\n   * - ``gt-xml``\n     - ``gt-xml``\n     - ``org.geotools.xml``\n   * - ``gt-main``\n     - ``gt-main``\n     - ``org.geotools.data``\n   * - ``gt-jdbc``\n     - ``gt-jdbc``\n     - ``org.geotools.jdbc``\n\nRepackage Library\n^^^^^^^^^^^^^^^^^\n\nPreviously GeoTools reused packages across modules by design, this approach is no longer supported by JDK resulting in the following classes changing package.\n\n.. list-table:: Restructure Library\n   :widths: 30, 70\n   :header-rows: 3\n   \n   * - Module\n     - Package\n   * - Upgrade\n     - Package\n   * - \n     - Classes Affected\n   * - ``gt-api``\n     - ``org.geotools.decorate``\n   * - ``gt-metadata``\n     - ``org.geotools.util.decorate``\n   * - \n     - Abstract Store, Wrapper\n   * - ``gt-api``\n     - ``org.geotools.data``\n   * - ``gt-main``\n     - ``org.geotools.data``\n   * - ``gt-api``\n     - ``org.geotools.data.simple``\n   * - ``gt-main``\n     - ``org.geotools.data.simple``\n   * - ``gt-api``\n     - ``org.geotools.decorate``\n   * - ``gt-main``\n     - ``org.geotools.util.decorate``\n   * - \n     - AbstractDecorator, Wrapper\n   * - ``gt-api``\n     - ``org.geotools.factory``\n   * - ``gt-main``\n     - ``org.geotools.factory``\n   * - ``gt-api``\n     - ``org.geotools.feature``\n   * - ``gt-main``\n     - ``org.geotools.feature``\n   * - ``gt-api``\n     - ``org.geotools.filter``\n   * - ``gt-main``\n     - ``org.geotools.filter``\n   * - ``gt-api``\n     - ``org.geotools.filter.expression``\n   * - ``gt-main``\n     - ``org.geotools.filter.expression``\n\nUpgrading projects using historical GeoTools snapshots\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe contents of the *boundless* repository ``https://repo.boundlessgeo.com/main/`` previously included snapshots of active GeoTools builds. The repository ``https://repo.osgeo.org/repository/geotools-snapshots/`` has taking over this role for the GeoTools project ( and is included in the group repository ``https://repo.osgeo.org/repository/snapshot/``).\n\nThe geotools-snapshots is populated from active branches only and does not contain \"historical\" snapshots from prior releases.  Due to this limitation we recommend upgrading historical projects to the appropriate GeoTools release.\n\nAs an example to fix an existing project build using GeoTools 21-SNAPSHOT which is no longer available upgrade to the most recent 21.x series release.\n\nBEFORE :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <properties>\n       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n       <geotools.version>21-SNAPSHOT</geotools.version>\n   </properties>\n   \nAFTER :file:`pom.xml`:\n\n.. code-block:: xml\n\n   <properties>\n       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n       <geotools.version>21.5</geotools.version>\n   </properties>\n\nGeoTools 20.x\n-------------\n\nGeoTools 20 requires Java 8.\n\nUpgrade to JTS-1.16\n^^^^^^^^^^^^^^^^^^^\n\nThe transitive dependency will correctly bring in the required jars::\n\n     <dependency>\n        <groupId>org.locationtech.jts</groupId>\n        <artifactId>jts-core</artifactId>\n        <version>${jts.version}</version>\n     </dependency>\n\n**Package change to org.locationtech.jts**\n\nThis release changes the package names from ``com.vividsolutions.jts`` to ``org.locationtech.jts``. To update your own code follow the `JTS Upgrade Guide <https://github.com/locationtech/jts/blob/master/MIGRATION.md>`__ instructions.\n\nUsing the command line to update your own ``pom.xml`` files::\n\n   git grep -l com.vividsolutions | grep pom.xml | xargs sed -i \"s/com.vividsolutions/org.locationtech.jts/g\"\n   \nAnd codebase::\n\n   git grep -l com.vividsolutions | xargs sed -i \"s/com.vividsolutions/org.locationtech/\"\n\n**Use of copy rather than clone**\n\nIf you are in the habit of using ``clone`` to duplicate JTS objects (such as Geometry and Coordinate) you will find the ``clone`` method has been deprecated, and a ``copy`` method introduced to explicitly perform a deep copy::\n    \n    Geometry duplicate = geom.copy();\n\nMigrate to JSR-363 Units\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis releases upgrades from the unofficial JSR-275 units library to the official JSR-363 units API.\n\nMaven transitive dependency will correctly bring in the required jars::\n   \n    <dependency>\n       <groupId>systems.uom</groupId>\n       <artifactId>systems-common-java8</artifactId>\n       <version>0.7.2</version>\n    </dependency>\n\nPackage names have changed, resulting in some common search and replaces when upgrading:\n  \n* Search ``javax.measure.unit.Unit`` replace ``javax.measure.Unit``\n* Search ``ConversionException`` replace  ``IncommensurableException``\n  \n  This is a checked exception, in areas of the GeoTools library where this was found we now return an ``IllegalArgument`` exception.\n  \n* Search ``converter == UnitConverter.IDENTITY`` replace ``converter.isIdentity()``\n* Search ``javax.measure.unit.NonSI`` replace ``import si.uom.NonSI``\n* Search ``javax.measure.unit.SI`` replace ``import si.uom.SI``\n* Search ``SI.METER`` replace ``SI.METRE``\n* Search ``javax.measure.converter.UnitConverter`` replace ``javax.measure.UnitConverter``\n* Search ``javax.measure.unit.UnitFormat`` replace ``import javax.measure.format.UnitFormat``\n* Search ``Unit.ONE`` replace ``AbstractUnit.ONE``\n* Search ``Dimensionless.UNIT`` replace ``AbstractUnit.ONE``\n* Search ``Unit.valueOf(unitString)`` replace ``Units.parseUnit(unitString)``\n  \n**Getting Unit instances**\n\nIf you know the unit to use at compile time, use one of the Unit instances defined as static variables in ``org.geotools.measure.Units``, ``si.uom.SI``, ``si.uom.NonSI`` or ``systems.uom.common.USCustomary``.\n\nIf you need to define new Units at runtime, it is important to immediately try to convert the new unit to one of the existing instances using ``Units.autocorrect`` method. Autocorrect applies some tolerance to locate an equivalent Unit. Skipping autocorrect will produce unexpected results and errors due to small differences in units definition.\n\n.. code-block:: java\n\n   // the result should be NonSI.DEGREE_ANGLE:\n   Unit<?> deg = Units.autoCorrect(SI.RADIAN.multiply(0.0174532925199433));\n   Unit<?> halfMetre = SI.METRE.divide(2);\n\n.. code-block:: java\n\n   // the result should be SI.METRE\n   Unit<?> unit = Units.autocorrect(halfMetre.multiply(4).divide(2));\n   \n.. code-block:: java\n   \n   public <T extends Quantity<T>> Unit<T> deriveUnit(Unit<T>  baseUnit, double factor) {\n      return Units.autocorrect(baseUnit.multiply(factor);)\n   }\n\n**Use a specific Quantity whenever possible**\n\nThis allows for type-safety checks at compile time:\n\n.. code-block:: java\n\n   Unit<Length> halfMetre = SI.METRE.divide(2);\n   Unit<Length> stupidUnit = Units.autocorrect(halfMetre.multiply(4).divide(2));\n     \n**Formatting units**\n\nUse ``org.geotools.measure.Units.toName(unit)`` to get the unit name (or unit label if name is not defined).\n\n.. code-block:: java\n\n   Unit<?> unit = ...\n   System.out.println(Units.toName(unit)):\n\nUse ``org.geotools.measure.Units.getDefaultFormat().format()`` to get the unit label (ignoring the name).\n\n.. code-block:: java\n\n   // prints \"Litre\"\n   System.out.println(Units.toName(SI.LITRE))\n   // prints \"l\"\n   System.out.println(Units.getDefaultFormat().format(SI.LITRE))\n\n.. code-block:: java\n\n   // Most units don't define a name, so it does not make a difference\n   // prints \"m\"\n   System.out.println(Units.toName(SI.METRE))\n   // prints \"m\"\n   System.out.println(Units.getDefaultFormat().format(SI.METRE))\n  \n**Converting units**\n\nIf the unit ``Quantity`` type is known, use the type-safe ``getConverterTo()`` method:\n\n.. code-block:: java\n\n   Unit<Angle> unit = ...\n   UnitConverter converter = unit.getConverterTo(SI.RADIAN);\n   double convertedQuantity = converter.convert(3.1415);\n\nIf the ``Quantity`` type is undefined, use the convenience method ``org.geotools.measure.Units.getConverterToAny()``. Note that this method throws an ``IllegalArgumentException`` if units can't be converted:\n\n.. code-block:: java\n\n   Unit<?> unit = ...\n   UnitConverter converter = Units.getConverterToAny(unit, SI.RADIAN);\n   double convertedQuantity = converter.convert(3.1415);\n\n**Using units**\n\nIf previously you made use of the Units in your code, to help with unit\nconversion or simply to keep the units straight. You might have code like:\n\n.. code-block:: java \n\n  Measure<Double, Length> dist = Measure.valueOf(distance, SI.METER);\n  System.out.println(dist.doubleValue(SI.KILOMETER) + \" Km\");\n  System.out.println(dist.doubleValue(NonSI.MILE) + \" miles\");\n\nYou will find it no longer compiles. It should be converted to use the ``Quantity`` classes.\n\n.. code-block:: java\n\n    import javax.measure.Quantity;\n    import javax.measure.quantity.Length;\n    import si.uom.SI;\n    import systems.uom.common.USCustomary;\n\n    import tec.uom.se.quantity.Quantities;\n    import tec.uom.se.unit.MetricPrefix;\n\n    Quantity<Length> dist = Quantities.getQuantity(distance, SI.METRE);\n    System.out.println(dist.to(MetricPrefix.KILO(SI.METRE)).getValue() + \" Km\");\n    System.out.println(dist.to(USCustomary.MILE) + \" miles\");\n\nGeoTools 19.x\n-------------\n\nGeoTools is built and tested with Java 8 at this time, to use this library in a Java 9 or Java 10 environment additional JVM runtime arguments are required::\n\n    --add-modules=java.xml.bind --add-modules=java.activation -XX:+IgnoreUnrecognizedVMOptions\n\nThese settings turn on several JRE modules that have been disabled by default in Java 9 onward.\n\nGeoTools 15.x\n-------------\n\nGeoTools 15.x requires Java 8::\n\n    <build>\n        <plugins>\n            <plugin>\n                <inherited>true</inherited>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\nGeoTools 14.x\n-------------\nFrom 14.x version, the `JAI-EXT Project <https://github.com/geosolutions-it/jai-ext>`_ has been integrated in GeoTools. This project provides a high scalable Java API for image processing with support for ``NoData`` and ``ROI``. \nThis integration provides also the removal of the following classes, since they are now inside JAI-EXT:\n\n* ``ColorIndexer`` from *gt-coverage* module;\n* ``GTCrop`` from *gt-coverage* module;\n* ``GenericPiecewise`` from *gt-render* module;\n* ``RasterClassifier`` from *gt-render* module;\n* ``ArtifactsFilter`` from *gt-imagemosaic* module.\n\nUsers may now decide to choose between JAI and JAI-EXT operations by simply using the ``JAIExt`` class containing utility methods for handling JAI/JAI-EXT registration.\n\nA more detailed tutorial on how to use JAI-EXT may be found at the following :ref:`JAI-EXT Tutorial Page<jaiext>`.\n\n``TextSymbolizer`` provides direct access to the device independent Font list, removing deprecated array access methods. This change restores SLD 1.0 multi-lingual behavior allowing several face/size combinations to be used during labeling.\n\nBEFORE::\n\n  textSymbolizer.addFont(font);\n  Font[] array = textSymbolizer.getFonts();\n  for(int i=0; i<array.length; i++){\n      Font f = textSymbolizer.getFonts()[i];\n      ...\n   }\n  \nAFTER::\n \n  textSymbolizer.fonts().add(font);\n  for(Font f : textSymbolizer.fonts()){\n     ...\n  }\n\n``Transaction`` is now ``Closable`` for use with try-with-resource syntax::\n\n   try (Transaction t = new DefaultTransaction()){\n        store.setTransaction( t );\n        store.addFeatures( newFeatures );\n        t.commit();\n   }\n\n``ShapefileDataStore`` representing shapefiles without any data, now return empty bounds on ``getBounds()`` instead of the bounds inside the shapefile header (mostly [0:0,0:0]). So ``bounds.isEmpty()`` and ``bounds.isNull()`` will return true for empty shapefiles.\n\nGeoTools 13.0\n-------------\nAs of GeoTools 13.0, the ``CoverageViewType`` classes have been removed. The ``AbstractDataStore`` class is also now deprecated. Extensive work has been done to bring in ``ContentDataStore`` as its replacement.\n\nThere is a `ContentDataStore Tutorial <http://docs.geotools.org/latest/userguide/tutorial/datastore/index.html>`_ to help with migration from ``AbstractDataStore``.\n\nMany readers and iterators are now ``Closable`` for use with try-with-resource syntax::\n\n   try( SimpleFeatureIterator features = source.getFeatures( filter ) ){\n       while( features.hasNext() ){\n          SimpleFeature feature = features.next();\n          ...\n       }\n   }\n\nGeoTools 12.0\n-------------\nGeoTools now requires `Java 7 <http://docs.geotools.org/latest/userguide/build/install/jdk.html>`_ and this is the first release tested with OpenJDK! Please ensure you are using JDK 1.7 or newer for GeoTools 12. Both Oracle Java 7 and OpenJDK 7 are supported, tested, release targets.\n\nFilter interfaces have been simplified. The GeoTools interfaces have been deprecated since GeoTools 2.3, and finally they have been removed. All filter interfaces now use the GeoAPI Filter.\n\nGeoTools 11.0\n-------------\nOnly new features were added in GeoTools 11.0.\n\nGeoTools 10.0\n-------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`10.x`\n\n   For background details on any API changes review the change proposals above.\n\nGeoTools 10 add significant improvements in the coverage reading API.\nFor those migrating the first visible benefit is that referring to a generic grid coverage reader does not require anymore to use ``AbstractGridCoverage2DReader`` (an abstract class) but to the new ``GridCoverage2DReader`` interface. The old usage is still supported though, as most readers are still extending the same base class, but the usage of the interface allows for reader wrappers.\n\nBEFORE::\n\n  AbstractGridCoverage2DReader reader = format.getReader(source);\n  \nAFTER::\n \n  GridCoverage2DReader reader = format.getReader(source);\n\nGeoTools 9.0\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`9.x`\n\n   For background details on any API changes review the change proposals above.\n\nGeoTools 9 has resolved a long standing conflict between ``FeatureCollection`` acting as a \"result\" set capable of\nstreaming large data sets vs. acting as a familiar Java Collection. The Java 5 \"for each\" syntax prevents\nthe safe use of Iterator (as we cannot ensure it will be closed). As a result ``FeatureCollection`` no longer\ncan extend java Collection and is acting as a pure \"result set\" with streaming access provided by ``FeatureIterator``.\n\nReferencedEnvelope and CRS\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``ReferencedEnvelope`` has in the past only supported 2D extents, we have introduced the subclass ``ReferencedEnvelope3D``\nto support ``CoordinateReferenceSystems`` with three dimensions.\n\nThere is now a new factory method to safely construct the appropriate implementation for a provided ``CoordinateReferenceSystem``\nas shown below.\n\nBEFORE::\n\n  ReferencedEnvelope bbox = new ReferencedEnvelope( crs );\n  ReferencedEnvelope copy = new ReferencedEnvelope( bbox );\n  \nAFTER::\n  \n  ReferencedEnvelope bbox = ReferencedEnvelope.create( crs );\n  ReferencedEnvelope copy = ReferencedEnvelope.create( bbox );\n\nThis represents an *incompatible API change*, existing code using ``new ReferencedEnvelope`` may now throw\na ``RuntimeException`` when supplied with an incompatible ``CoordinateReferenceSystem``.\n\nFeatureCollection Add\n^^^^^^^^^^^^^^^^^^^^^\n\nWith the ``FeatureCollection.add`` method being removed, you will need to use an explicit instance that supports\nadding content.\n\nBEFORE::\n\n    SimpleFeatureCollection features = FeatureCollections.newCollection();\n\n    for( SimpleFeature feature : list ){\n       features.add( feature );\n    }\n\nAFTER::\n\n    DefaultFeatureCollection features = new DefaultFeatureCollection();\n    for( SimpleFeature feature : list ){\n    \u00a0\u00a0\u00a0features.add( feature );\n    }\n\nALTERNATE (will throw exception if ``FeatureCollection`` does not implement\n``java.util.Collection``)::\n\n    Collection<SimpleFeature> collection = DataUtilities.collectionCast( featureCollection );\n    collection.addAll( list );\n\nALTERNATE DETAIL::\n\n    SimpleFeatureCollection features = FeatureCollections.newCollection();\n    if( features instanceof Collection ){\n        Collection<SimpleFeature> collection = (Collection) features;\n        collection.addAll( list );\n    }\n    else {\n        throw new IllegalStateException(\"FeatureCollections configured with immutbale implementation\");\n    }\n    \nSPECIFIC::\n\n    ListFeatureCollection features = new ListFeatureCollection( schema, list );\n\nFeatureCollection Iterator\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe deprecated ``FeatureCollection.iterator()`` method is no longer available, please use ``FeatureCollection.features()``\nas shown below.\n\nBEFORE::\n\n  Iterator i=featureCollection.iterator();\n  try {\n      while( i.hasNext(); ){\n         SimpleFeature feature = i.next();\n         ...\n      }\n  }\n  finally {\n      featureCollection.close( i );\n  }\n\n\nAFTER::\n\n    FeatureIterator i=featureCollection.features();\n    try {\n         while( i.hasNext(); ){\n             SimpleFeature feature = i.next();\n             ...\n         }\n    }\n    finally {\n         i.close();\n    }\n\nJAVA7::\n\n    try ( FeatureIterator i=featureCollection.features()){\n        while( i.hasNext() ){\n             SimpleFeature feature = i.next();\n             ...\n        }\n    }\n\nHow to Close an Iterator\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe have made ``FeatureIterator`` implement ``Closable`` (for Java 7 try-with-resource compatibility). This\nalso provides an excellent replacement for\n``FeatureCollection.close(Iterator)``.\n\nIf you are using any wrapping ``Iterators`` that still require the ability to ``close()``\nplease consider the following approach.\n\nBEFORE::\n\n    Iterator iterator = collection.iterator();\n    try {\n       ...\n    } finally {\n        if (collection instanceof SimpleFeatureCollection) {\n            ((SimpleFeatureCollection) collection).close(iterator);\n        }\n    }\n\nQUICK::\n\n    Iterator iterator = collection.iterator();\n    try {\n       ...\n    } finally {\n        DataUtilities.close( iterator );\n    }\n\nDETAIL::\n\n    Iterator iterator = collection.iterator();\n    try {\n       ...\n    } finally {\n        if (iterator instanceof Closeable) {\n            try {\n               ((Closeable)iterator).close();\n            }\n            catch( IOException e){\n                Logger log = Logger.getLogger( collection.getClass().getPackage().toString() );\n                log.log(Level.FINE, e.getMessage(), e );\n            }\n        }\n    }\n\nJAVA7 using try-with-resource syntax for ``Iterator`` that implements ``Closeable``::\n\n    try ( Iterator i=collection.features()){\n        while( i.hasNext() ){\n             Object object = i.next();\n             ...\n        }\n    }\n    \n\nGeoTools 8.0\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`8.x`\n\n   You are encouraged to review the change proposals for GeoTools 8.0 for background information\n   on the following changes.\n\nThe changes moving from GeoTools 2.7 to GeoTools 8.0 have a great emphasis on usability and\ndocumentation. Because of the focus on ease of use; many of the changes here are marked \"Optional\"\nthis indicates that your code will not break; but you have a chance to clean it up and make\nyour code more readable.\n\nStyle\n^^^^^\n\nSome of the ``gt-opengis`` style methods that have been deprecated for a while are now removed.\n\n* ``Mark.getRotation()`` / ``Mark.setRotation( Expression )``\n* ``Mark.getSize()`` / ``Mark.setSize( Expression )``\n\nThese are handled in a similar manner:\n\n* BEFORE::\n\n      for( GraphicalSymbol symbol : graphic.graphicalSymbols() ){\n          if( symbol instanceof Mark ){\n               Mark mark = (Mark) symbol;\n               mark.setSize( ff.literal( 8 ) );\n          }\n      }\n\n* AFTER::\n\n      graphic.setSize( ff.literal( 8 ) );\n\nFilter\n^^^^^^\n\nThe filter system was upgrade to match Filter 2.0 resulting in a few additions. This mostly\neffects people writing their own functions (as now we need to know about parameter types).\n\nFeatureId\n''''''''''\n\n* BEFORE::\n\n    FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(null);\n    Filter filter;\n\n    Set<FeatureId> selected = new HashSet<FeatureId>();\n    selected.add(ff.featureId(\"CITY.98734597823459687235\"));\n    selected.add(ff.featureId(\"CITY.98734592345235823474\"));\n\n    filter = ff.id(selected);\n\n* AFTER\n\n  .. literalinclude:: /../src/main/java/org/geotools/opengis/FilterExamples.java\n     :language: java\n     :start-after: // id start\n     :end-before: // id end\n\nFunction\n''''''''\n\nWe have extended ``gt-opengis`` ``Function`` to make the ``FunctionName`` description (especially\nargument names) more available.\n\n* To update your code::\n\n    class SplitFunction implements Function {\n        public static FunctionName NAME = new FunctionNameImpl( \"split\", \"geometry\", \"line\" );\n        ...\n        FunctionName getFunctionName(){\n            return NAME;\n        }\n        ...\n    }\n\nIf you are extending abstract function expression base class; it provides a default implementation\nof ``getFunctionName()`` allowing your code to compile.\n\nFunctionExpression\n''''''''''''''''''\n\nIn a related matter ``gt-main`` no longer provides access to the deprecated ``FunctionExpression``\ninterface (it has returned an empty set for several releases now):\n\n* BEFORE::\n\n        Set<String> proposals = new TreeSet<String>();\n        Set<Function> oldFunctions = FunctionFinder. CommonFactoryFinder.getFunctionExpressions(null);\n        for( Function function : oldFunctions ) {\n            proposals.add(function.getName().toLowerCase());\n        }\n\n* AFTER::\n\n        Set<String> proposals = new TreeSet<String>();\n\n        FunctionFinder functionFinder = new FunctionFinder(null);\n        for( FunctionName function : functionFinder.getAllFunctionDescriptions() ){\n            proposals.add(function.getName().toLowerCase());\n        }\n\nDirect Position and Envelope\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated methods in ``gt-opengis`` and ``gt-referencing`` have now been removed.\n\n=========================================== ==================================== ===================================\nDeprecated method in 2.7                    Replacement in 8.0                   Notes\n=========================================== ==================================== ===================================\n``DirectPosition.getCoordinates()``         ``DirectPosition.getCoordinate()``   For consistency with ISO 19107\n``Envelope.getCenter()``                    ``Envelope.getMedian()``             For consistency with ISO 19107\n``Envelope.getLength()``                    ``Envelope.getSpan()``               For consistency with ISO 19107\n``Precision.getMaximumSignificantDigits()`` ``Precision.getScale()}}``           Remove duplication\n``PointArray.length()``                     ``List.size()``                      ``PointArray`` instance can be used\n``PointArray.position()``                   ``this``                             ``PointArray`` instance can be used\n``Position.getPosition()``                  ``Position.getDirectPosition()``     For consistency with ISO 19107\n``Point.setPosition()``                     ``Point.setDirectPosition()``        For consistency with ISO 19107\n=========================================== ==================================== ===================================\n\nNumberRange\n^^^^^^^^^^^\n\nThe ``gt-metadata`` ``NumberRange`` class is finally shedding some of its deprecated methods.\n\nBEFORE::\n\n      NumberRange before = new NumberRange( 0.0, 5.0 );\n\nAFTER::\n\n      NumberRange<Double> after1 = new NumberRange( Double.class, 0.0, 5.0 );\n      NumberRange<Double> after2 = NumberRage.create( 0.0, 5.0 );\n\nGeoTools 2.7\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.7.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.7.0 for background information\n   on the following changes.\n\nThe changes from GeoTools 2.6 to GeoTools 2.7 focus on making your code more readable; you will\nfind a number of optional changes (such as using Query rather than ``DefaultQuery``) which will\nsimplify make your code easier to follow.\n\n\nQuery\n^^^^^\n\nThe ``gt-api`` module has been updated to make ``Query`` a concrete class rather than an interface.\n\nBEFORE::\n\n        Query query = new DefaultQuery( typeName, filter );\n\nAFTER::\n\n        Query query = new Query( typeName, filter );\n\nTips:\n\n* You can perform a search and replace to change ``DefaultQuery`` to ``Query`` on your code base\n* If you have your own implementation of ``Query`` your code is now broken; after many years we have\n  never seen an implementation of ``Query`` in the wild. You should be able to fix by extending rather\n  then implementing ``Query``.\n* ``DefaultQuery`` still exists but all of the implementation code has now been \"pulled up\" into\n  ``Query`` and ``DefaultQuery`` marked as deprecated.\n* In a similar fashion ``FeatureLock`` can now be directly constructed rather than use a ``Factory``.\n\nSimpleFeatureCollection\n^^^^^^^^^^^^^^^^^^^^^^^\n\nWe have vastly cut down the use of Java generics for casual users of the GeoTools library. The\nprimary example of this is the introduction of ``SimpleFeatureCollection`` (which saves you\ntyping in ``FeatureCollection<SimpleFeatureType,SimpleFeature>`` each time).\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n            (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n    Query query = new DefaultQuery( typeName, filter );\n    FeatureCollection<SimpleFeatureType,SimpleFeature> featureCollection = source.getFeatures( query );\n\n* AFTER::\n\n    SimpleFeatureSource source = dataStore.getFeatureSource( typeName );\n    Query query = new Query( typeName, filter );\n    SimpleFeatureCollection featureCollection = source.getFeatures( query );\n\nTips:\n\n* You can do a search and replace on this one; but you need to be very careful with any\n  implementations you have that accept a ``FeatureCollection<SimpleFeatureType,SimpleFeature>``\n  as a method parameter!\n\n* Be careful if you have your own ``FeatureStore`` implementation; a search and replace will change\n  several of your methods so they no longer \"override\" the default implementation provided by\n  ``AbstractFeatureStore``.::\n\n       @Override // this would fail; you do use Override right?\n       public Set addFeatures( SimpleFeatureCollection features ){\n          ... your implementation goes here ...\n\n  To fix this code you will need to \"undo\" your search and replace for this method parameter::\n\n       @Override\n       public Set addFeatures( FeatureCollection<SimpleFeatureType,SimpleFeature> features ){\n          ... your implementation goes here ...\n\n  Note: If you use the ``@Override`` annotation in your code you will get a proper error; since your\n  new method would no longer override anything.\n\nSimpleFeatureSource\n^^^^^^^^^^^^^^^^^^^\n\nThe ``gt-api`` module now defines ``SimpleFeatuyreSource`` (to save you a bit of typing). In addition\nthe ``DataStore`` interface now returns a ``SimpleFeatureSource``; so if you want you optionally\ncan update your code for readability.\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n           (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n\n* AFTER::\n\n    SimpleFeatureSource source =  dataStore.getFeatureSource( typeName );\n\nTips:\n* you can do this with a search and replace\n* Be a bit careful when you have one of your own methods that is expecting a ``FeatureSource``\n\nSimpleFeatureStore\n^^^^^^^^^^^^^^^^^^\nIn a similar fashion returns a ``SimpleFeatureCollection``; it also has a couple of its own tricks:\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n        (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n    if( source instanceof FeatureStore){\n       // read write access\n       FeatureStore<SimpleFeatureType,SimpleFeature> store =\n            (FeatureStore<SimpleFeatureType,SimpleFeature>) source;\n       store.addFeatures( newFeatures );\n       ...\n\n* AFTER::\n\n    SimpleFeatureSource source =  dataStore.getFeatureSource( typeName );\n    if( source instanceof SimpleFeatureStore){\n       // read write access\n       SimpleFeatureStore store = (SimpleFeatureStore) source;\n       store.addFeatures( newFeatures );\n       ...\n\nSimpleFeatureLocking\n^^^^^^^^^^^^^^^^^^^^\n\nYou can also explicitly use ``SimpleFeatureLocking`` if you want read/write/lock access to simple\nfeature content. Much like ``Query`` it has been made a concrete class.\n\n``FeatureStore`` ``modifyFeatures`` by ``Name``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``FeatureStore`` method ``modifyFeatures`` now allows you to modify features by name.\n\n* BEFORE::\n\n    FeatureSource<SimpleFeatureType,SimpleFeature> source =\n        (FeatureSource<SimpleFeatureType,SimpleFeature>) dataStore.getFeatureSource( typeName );\n    if( source instanceof FeatureStore){\n       // read write access\n       FeatureStore<SimpleFeatureType,SimpleFeature> store =\n            (FeatureStore<SimpleFeatureType,SimpleFeature>) source;\n\n       SimpleFeatureType schema = store.getSchema();\n       AttributeDescriptor attribute = schema.getDescriptor( attributeName );\n       store.modifyFeatures( attribute, attributeValue, filter );\n\n* AFTER::\n\n    SimpleFeatureSource source =  dataStore.getFeatureSource( typeName );\n    if( source instanceof SimpleFeatureStore){\n       // read write access\n       SimpleFeatureStore store = (SimpleFeatureStore) source;\n       store.modifyFeatures( attributeName, attributeValue, filter );\n       ...\n\nTips:\n\n* Generic ``FeatureSource`` allows ``modifyFeatures(Name, Value, filter)``\n\nCoverageProcessor\n^^^^^^^^^^^^^^^^^\n\nThe ``DefaultProcessor`` and ``AbstractProcessor`` classes have been merged into a single class called\n``CoverageProcessor``.\n\n* BEFORE::\n\n    final DefaultProcessor processor= new DefaultProcessor(hints)\n\n* AFTER::\n\n    final CoverageProcessor processor= new CoverageProcessor(hints)\n\n  Or better::\n\n      final CoverageProcessor processor= CoverageProcessor.getInstace(hints);\n\nTips:\n\n* Try to always use the static ``getDefaultInstance`` method in order to leverage on ``SoftReference`` caching\n\nGeneralEnvelope\n^^^^^^^^^^^^^^^\n\nWe have been removing old deprecated code from the ``GeneralEnvelope`` class.\n\n=================================== ===================================================\nOld Method                          New Method     \n=================================== ===================================================\n``double getCenter(dimension)``     ``DirectPosition getMedian()``\n``double getCenter()``              ``double getMedian(dimension)``\n``double getLength(dimension)``     ``double getSpan(dimension)``\n``getLength(dimension, unit)``      ``double getSpan(dimension, unit)``\n=================================== ===================================================\n\nGeoTools 2.6\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.6.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.6.0 for background information\n   on the following changes.\n\nThe GeoTools 2.6.0 release is incremental in nature with the main change being the introduction\nof the ``JDBC-NG`` DataStores the idea of ``Query`` capabilities (so you can check what hints are\nsupported).\n\nGridRange Removed\n^^^^^^^^^^^^^^^^^\n\n``GridRange`` implementations have been removed as the result of a change we are inheriting from GeoAPI\nwhere a switch from ``GridRange`` to ``GridEnvelope`` has been made. ``GridRange`` comes from\nGrid Coverages Implementation specification 1.0 (which is basically dead) while\n``GridEnvelope`` comes from ISO 19123 which looks like the replacement.\n\nThere is a big difference between interfaces though:\n\n* ``GridRange`` treats its own maximum grid coordinates as EXCLUSIVE (like Java2D classes\n  ``Rectangle2D``, ``RenderedImage`` and ``Raster`` do); while\n* ``GridEnvelope`` uses a different convention where maximum grid coordinates are INCLUSIVE.\n\nThis is shown in the code example below with the ``maxx`` variable.\n\nAs far as switching over to the new classes, the equivalence are as follows:\n\n1. Replace ``GridRange2D`` with ``GridEnvelope2D``\n\n   Notice that now ``GridEnvelope2D`` is a Java2D ``Rectangle`` and that it is also mutable!\n2. Replace ``GeneralGridRange`` with ``GeneralGridEnvelope``\n\nThere are a few more caveats, which we are showing here below.\n\nBEFORE:\n\n1. Use ``getSpan`` where ``getLength`` was used\n2. Be EXTREMELY careful with the conventions for the inclusion/exclusion of the maximum coordinates.\n3. ``GridRange2D`` IS a ``Rectangle`` and is mutable now!\n\n   BEFORE::\n\n        import org.geotools.coverage.grid.GeneralGridRange;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GeneralGridRange originalGridRange = new GeneralGridRange(actualDim);\n        final int w = originalGridRange.getLength(0);\n        final int maxx = originalGridRange.getUpper(0);\n\n        ...\n        import org.geotools.coverage.grid.GridRange2D;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GridRange2D originalGridRange2D = new GridRange2D(actualDim);\n        final int w = originalGridRange2D.getLength(0);\n        final int maxx = originalGridRange2D.getUpper(0);\n        final Rectangle rect = (Rectangle)originalGridRange2D.clone();\n    {code}\n\n   AFTER::\n\n        import org.geotools.coverage.grid.GeneralGridEnvelope;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GeneralGridEnvelope originalGridRange=new GeneralGridEnvelope (actualDim,2);\n        final int w = originalGridRange.getSpan(0);\n        final int maxx = originalGridRange.getHigh(0)+1;\n\n        import org.geotools.coverage.grid.GridEnvelope2D;\n        final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);\n        final GridEnvelope2D originalGridRange2D = new GridEnvelope2D(actualDim);\n        final int w = originalGridRange2D.getSpan(0);\n        final int maxx = originalGridRange2D.getHigh(0)+1;\n        final Rectangle rect = (Rectangle)originalGridRange2D.clone();\n\n``OverviewPolicy`` ``Enum`` replace ``Hint`` use\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe hints to control overviews were deprecated and have now been removed.\n\nThe current deprecated values have been remove from the Hints class inside the Metadata module:\n\n* ``VALUE_OVERVIEW_POLICY_QUALITY``\n* ``IGNORE_COVERAGE_OVERVIEW``\n* ``VALUE_OVERVIEW_POLICY_IGNORE``\n* ``VALUE_OVERVIEW_POLICY_NEAREST``\n* ``VALUE_OVERVIEW_POLICY_SPEED``\n\nYou should use the ``Enum`` that comes with the ``OverviewPolicy`` ``Enum``. Here below you will find a few examples:\n\n* BEFORE::\n\n        Hints hints = new Hints();\n        hints.put(Hints.OVERVIEW_POLICY, Hints.VALUE_OVERVIEW_POLICY_SPEED);\n        WorldImageReader wiReader = new WorldImageReader(file, hints);\n\n* AFTER::\n\n        Hints hints = new Hints();\n        hints.put(Hints.OVERVIEW_POLICY, OverviewPolicy.SPEED);\n        WorldImageReader wiReader = new WorldImageReader(file, hints);\n\nHints:\n\n* Please, notice that the ``OverviewPolicy`` ``Enum`` provides a method to get the default policy for\n  overviews. The method is ``getDefaultPolicy()``.\n\nCoverageUtilities and FeatureUtilities\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated methods have been remove from coverage utilities classes;\n\nWe have removed deprecated methods from classes:\n\n* ``CoverageUtilities.java``\n* ``FeatureUtilities.java``\n\nExisting code should change as follows:\n\n* BEFORE::\n\n    final FeatureCollection<SimpleFeatureType, SimpleFeature> fc=FeatureUtilities.wrapGridCoverageReader(reader)\n\n* AFTER::\n\n    final GeneralParameterValue[] params=...\n\n    final FeatureCollection<SimpleFeatureType, SimpleFeature> fc=FeatureUtilities.wrapGridCoverageReader(reader,params)\n\nHints:\n\n* This change allows us to store basic parameters to control how we will perform subsequent\n  reads from this reader. The ``AbstractGridFormat`` ``READ_GRIDGEOMETRY2D`` parameter will be\n  always overridden during a subsequent read.\n\nCoverage Processing Classes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated methods have been remove from coverage processing classes:\n\n* ``filteredSubsample(GridCoverage, int, int, float[], Interpolation, BorderExtender)`` has been removed\n\nHere is what that looks like in code:\n\n* BEFORE::\n\n    public GridCoverage filteredSubsample(final GridCoverage   source,\n                                          final int            scaleX,\n                                          final int            scaleY,\n                                          final float\\[\\]      qsFilter,\n                                          final Interpolation  interpolation,\n                                          final BorderExtender be) throws CoverageProcessingException {\n         return filteredSubsample(source, scaleX, scaleY, qsFilter, interpolation);\n    }\n\n* AFTER::\n\n    public GridCoverage filteredSubsample(final GridCoverage source,\n                                          final int scaleX, final int scaleY,\n                                          final float\\[\\] qsFilter,\n                                          final Interpolation interpolation){\n           // recolor(GridCoverage, Map\\[\\]) has been removed\n           ...\n    }\n\n* BEFORE::\n\n        recolor(final GridCoverage source, final Map[] colorMaps)\n\n* AFTER::\n\n        recolor(final GridCoverage source, final ColorMap[] colorMaps);\n        // scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender) has been removed\n\n* BEFORE::\n\n        scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender)\n\n* AFTER::\n\n        scale(GridCoverage,double,double,double,double,Interpolation)\n        // scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender) has been removedBEFORE:\n\n* BEFORE::\n\n        scale(GridCoverage, double, double, double, double, Interpolation, BorderExtender)\n\n* AFTER::\n\n        scale(GridCoverage,double,double,double,double,Interpolation)\n\nDefaultParameterDescriptor and Parameter\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRemoved deprecated constructors from ``DefaultParameterDescriptor`` and ``Parameter`` classes.\n\n* BEFORE::\n\n    DefaultParameterDescriptor(Map<String,?>,defaultValue,minimum, maximum, unit, required)\n    DefaultParameterDescriptor(Map<String,?>, defaultValue, minimum, maximum, required)\n    DefaultParameterDescriptor(name, defaultValue, minimum, maximum)\n    DefaultParameterDescriptor(name, defaultValue, minimum, maximum, unit)\n    DefaultParameterDescriptor(name, remarks, defaultValue, required)\n    DefaultParameterDescriptor(name, defaultValue)\n    DefaultParameterDescriptor( name, valueClass, defaultValue)\n    Parameter(name, value)\n    Parameter(name, value, unit)\n    Parameter(name, value)\n\n* AFTER::\n\n    DefaultParameterDescriptor.create(...)\n    Parameter.create(...)\n\nGeoTools 2.5\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.5.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.5.0 for background information\n   on the following changes.\n\nThe GeoTools 2.5.0 release is a major change to the GeoTools library due to the adoption of both\nJava 5 and a new feature model.\n\nFeatureCollction\n^^^^^^^^^^^^^^^^\n\nIn transitioning your code to Java 5 please be careful not use use the *for each* loop construct.\nWe still need to call ``FeatureCollection.close( iterator)``.\n\nDue to this restriction (of not using *for each* loop construct we have had to make ``FeatureCollection``\nno longer ``Collection``.\n\n* Example (GeoTools 2.5 code)::\n\n    FeatureCollection<SimpleFeatureType,SimpleFeature> featureCollection = feaureSource.getFeatures();\n    Iterator<SimpleFeature> iterator = featureCollection.iterator();\n    try {\n        while( iterator.hasNext() ){\n           SimpleFeature feature = iterator.next();\n           ...\n        }\n    }\n    finally {\n       featureCollection.close( iterator );\n    }\n\n* Example (GeoTools 2.7 code)\n\n  We have removed the need for the use of generics to minimize typing::\n\n    SimpleFeatureCollection featureCollection = feaureSource.getFeatures();\n    SimpleFeatureIterator iterator = featureCollection.features();\n    try {\n        while( iterator.hasNext() ){\n           SimpleFeature feature = iterator.next();\n           ...\n        }\n    }\n    finally {\n       iterator.close();\n    }\n\nJTSFactory\n^^^^^^^^^^\n\nWe are cutting down on \"anonymous\" ``FactoryFinder`` use; creating ``JTSFactory`` to allow the\nentire GeoTools library to share a JTS ``GeometryFactory``.\n\n* BEFORE (GeoTools 2.4 code)::\n\n     GeometryFactory factory = new FactoryFinder().getGeometryFactory( null );\n\n* AFTER (GeoTools 2.5 code)::\n\n    GeometryFactory factory = JTSFactoryFinder.getGeometryFactory( null );\n\nProgressListener\n^^^^^^^^^^^^^^^^\n\nTransition to ``gt-opengis`` ``ProgressListener``.\n\n* Before (GeoTools 2.2 Code)::\n\n    progress.setDescription( message );\n\n* After (GeoTools 2.4 Code)::\n\n    progress.setTask( new SimpleInternationalString( message ) );\n\nTo upgrade:\n\n1. Search: ``import org.geotools.util.ProgressListener``\n\n   Replace: ``import org.opengis.util.ProgressListener``\n\n2. Update::\n\n     setTask( new SimpleInternationalString( message ) ); // was setDescription( message );\n\nSimpleFeature\n^^^^^^^^^^^^^\n\nWe have (finally) made the move to an improved feature model. Please take the opportunity\nto change your existing code to use ``org.opengis.feature.simple.SimpleFeature``. The existing\nGeoTools Feature interface is still in use; but it has been updated in\nplace to extend ``SimpleFeature``.\n\n* Before (GeoTools 2.4 Code)::\n\n        import org.geotools.feature.FeatureType;\n        ...\n        CoordinateReferenceSystem crs = CRS.decode(\"EPSG:4326\");\n        final AttributeType GEOM =\n            AttributeTypeFactory.newAttributeType(\"Location\",Point.class,true, null,null,crs );\n        final AttributeType NAME =\n            AttributeTypeFactory.newAttributeType(\"Name\",String.class, true );\n\n        final FeatureType FLAG =\n            FeatureTypeFactory.newFeatureType(new AttributeType[] { GEOM, NAME },\"Flag\");\n\n        Feature flag1 = FLAG.create( \"flag.1\", new Object[]{ point, \"Here\" } );\n\n        AttributeType attributes[] = FLAG.getAttributeTypes();\n        AttributeType location = FLAG.getAttribute(\"Location\");\n        String label = location.getName();\n        Class binding = location.getType();\n        Geometry geom = flag1.getDefaultGeometry();\n\n* After (GeoTools 2.5 Code)::\n\n        import org.opengis.feature.simple.SimpleFeatureType;\n        ...\n        SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();\n        builder.setName( \"Flag\" );\n        builder.setNamespaceURI( \"http://localhost/\" );\n        builder.setCRS( \"EPSG:4326\" );\n        builder.add( \"Location\", Point.class );\n        builder.add( \"Name\", String.class );\n\n        SimpleFeatureType FLAG = builder.buildFeatureType();\n\n        SimpleFeature flag1 = SimpleFeatureBuilder.build( FLAG, new Object[]{ point, \"Here\"}, \"flag.1\" );\n\n        List<AttributeDescriptor> attributes = FLAG.getAttributes();\n        AttributeDescriptor location = FLAG.getAttribute(\"Location\");\n        String label = location.getLocationName();\n        Class binding = location.getType().getBinding();\n        Geometry geom = (Geometry) flag1.getDefaultGeometry();\n\nHere are some steps to start you off updating your code:\n\n1. Search Replace\n\n   * Search: ``Feature`` replace with ``SimpleFeature``\n   * Search: ``FeatureType`` replace with ``SimpleFeatureType``\n\n2. Fix the imports\n\n   * Control-Shift-O in Eclipse IDE\n   * Add casts as required for ``getDefaultGeometry()``\n\n3. ``FeatureType.create`` has been replaced with ``SimpleFeatureBuilder``\n\n   There is a static method to make the transition easier::\n\n      SimpleFeatureFeatureBuilder.build( schema, attributes, fid );\n\n4. For more code examples please see:\n\n   * :doc:`/library/main/feature`\n\nAttributeDescriptor and AttributeType\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe concept of an ``AttributeType`` has been split into two now (allowing you to reuse common types).\n\n* BEFORE (GeoTools 2.4 Code)::\n\n    import org.geotools.feature.AttributeType;\n    ...\n    GeometryAttributeType att =\n              (GeometryAttributeType) AttributeTypeBuilder.newAttributeDescriptor(geomTypeName,\n                                                                                  targetGeomType,\n                                                                                  isNillable,\n                                                                                  Integer.MAX_VALUE,\n                                                                                  Collections.EMPTY_LIST,\n                                                                                  crs );\n\n* AFTER (GeoTools 2.5 Code)::\n\n    import org.geotools.feature.AttributeTypeBuilder;\n    import org.opengis.feature.type.AttributeDescriptor\n    ...\n    AttributeTypeBuilder build = new AttributeTypeBuilder();\n    build.setName( geomTypeName );\n    build.setBinding( targetGeomType );\n    build.setNillable(true);\n    build.setCRS(crs);\n    GeometryType type = build.buildGeometryType();\n    GeometryDescriptor attribute = build.buildDescriptor( geomTypeName, type );\n\nName\n^^^^\n\nIn order to better support app-schema work we can no longer assume names are a simple String. The\n``Name`` class has been introduced to make this easier and is available\nthroughout the library: example ``FeatureSource.getName()``.\n\n* BEFORE  (GeoTools 2.4 Code)::\n\n    DataStore ds = ...\n    String []typeNames = ds.getTypeNames();\n    SimpleFeatureType type = ds.getSchema(typeNames[0]);\n    assert type.getTypeName() == typeNames[0];\n    FeatureSource source = ds.getFeatureSource(type.getTypeName());\n\n* AFTER  (GeoTools 2.5 Code)::\n\n    import org.opengis.feature.type.Name;\n    ...\n\n    DataStore ds = ...\n    List<Name> featureNames = ds.getNames();\n    SimpleFeatureType type = ds.getSchema(featureNames.get(0));\n    // type.getName() may or may not be equal to featureNames.get(0), assume not. If they're its just an implementation detail.\n    FeatureSource source = ds.getFeatureSource(featureNames.get(0));\n\nDataStore\n^^^^^^^^^\n\nTransition to use of Java 5 Generics with DataStore API.\n\n.. tip\n\n   We have removed the need to use Generics in GeoTools 2.7 allowing the use of\n   ``SimpleFeatureSource``, ``SimpleFeatureCollection``, ``SimpleFeatureStore`` etc.\n\n* BEFORE  (GeoTools 2.4 Code)::\n\n    DataStore ds = ...\n    FeatureSource source = ds.getSource(typeName);\n    FeatureStore store = (FeatureStore)source;\n    FeatureLocking locking = (FeatureLocking)source;\n\n    FeatureCollection collection = source.getFeatures();\n    FeatureIterator features = collection.features();\n    while(features.hasNext){\n      SimpleFeature feature = features.next();\n    }\n\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter writer = ds.getFeatureWriter(typeName, transaction);\n\n* AFTER  (GeoTools 2.5 Code)::\n\n    DataStore ds = ...\n    FeatureSource<SimpleFeatureType,SimpleFeature> source = ds.getSource(typeName);\n    FeatureStore<SimpleFeatureType,SimpleFeature> store = (FeatureStore<SimpleFeatureType,SimpleFeature>)source;\n    FeatureLocking<SimpleFeatureType,SimpleFeature> locking = (FeatureLocking<SimpleFeatureType,SimpleFeature>)source;\n\n    FeatureCollection<SimpleFeatureType,SimpleFeature> collection = source.getFeatures();\n    FeatureIterator<SimpleFeatureType,SimpleFeature> features = collection.features();\n    while(features.hasNext){\n       SimpleFeature feature = features.next();\n    }\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader<SimpleFeatureType,SimpleFeature> reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter<SimpleFeatureType,SimpleFeature> writer = ds.getFeatureWriter(typeName, transaction);\n\n* AFTER (GeoTools 2.7 Code)::\n\n    DataStore ds = ...\n    SimpleFeatureSource<SimpleFeatureType,SimpleFeature> source = ds.getSource(typeName);\n    SimpleFeatureStore store = (SimpleFeatureStore) source;\n    SimpleFeatureLocking locking = (SimpleFeatureLocking) source;\n\n    SimpleFeatureCollection collection = source.getFeatures();\n    SimpleFeatureIterator features = collection.features();\n    while(features.hasNext){\n       SimpleFeature feature = features.next();\n    }\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader<SimpleFeatureType,SimpleFeature> reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter<SimpleFeatureType,SimpleFeature> writer = ds.getFeatureWriter(typeName, transaction);\n\nDataAccess and DataStore\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n* The ``DataAccess`` super class has been introduced, leaving DataStore to *only* work with ``SimpleFeature``\n  capable implementations.::\n\n    import org.opengis.feature.type.Name;\n    ...\n\n    java.util.Map paramsMap = ...\n    DataStore ds = DataStoreFinder.getDataStore(paramsMap);\n    Name featureName = new org.geotools.feature.Name(namespace, localName);\n    FeatureSource<SimpleFeatureType, SimpleFeature> source = ds.getSource(featureName);\n    FeatureStore<SimpleFeatureType, SimpleFeature> store = (FeatureStore)source;\n    FeatureLocking<SimpleFeatureType, SimpleFeature> locking = (FeatureLocking)source;\n\n    FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures();\n    FeatureIterator<SimpleFeature> features = collection.features();\n    while(features.hasNext){\n     SimpleFeature feature = features.next();\n    }\n\n    Transaction transaction = Transaction.AUTO_COMMIT;\n    FeatureReader<SimpleFeatureType, SimpleFeature> reader = ds.getFeatureReader(new DefaultQuery(typeName), transaction);\n    FeatureWriter<SimpleFeatureType, SimpleFeature> writer = ds.getFeatureWriter(typeName, transaction);\n\n* ``DataAccess``: works both with ``SimpleFeature`` and normal ``Feature`` capable implementations::\n\n    import org.opengis.feature.FeatureType;\n    import org.opengis.feature.Feature;\n    import org.opengis.feature.type.Name;\n    ...\n\n    java.util.Map paramsMap = ...\n    DataAccess<FeatureType, Feature> ds = DataAccessFinder.getDataAccess(paramsMap);\n    Name featureName = new org.geotools.feature.Name(namespace, localName);\n    FeatureSource<FeatureType, Feature> source = ds.getSource(featureName);\n    FeatureStore<FeatureType, Feature> store = (FeatureStore)source;\n    FeatureLocking<FeatureType, Feature> locking = (FeatureLocking)source;\n\n    FeatureCollection<FeatureType, Feature> collection = source.getFeatures();\n    FeatureIterator<Feature> features = collection.features();\n    while(features.hasNext){\n     Feature feature = features.next();\n    }\n    //No DataAccess.getFeatureReader/Writer\n\nGeoTools 2.4\n------------\n\n.. sidebar:: Wiki\n\n   * :wiki:`2.4.x`\n\n   You are encouraged to review the change proposals for GeoTools 2.4.0 for background information\n   on the following changes.\n\nThe GeoTools 2.4.0 release is a major change to the GeoTools library due to the adoption of GeoAPI\n``Filter`` model. This new filter model is immutable making it impossible to modify filters that\nhave already been constructed; in trade it is thread safe.\n\nThe following is needed when upgrading to 2.4.\n\nReferencingFactoryFinder\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nRename ``FactoryFinder`` to ``ReferencingFactoryFinder``\n\n* BEFORE (GeoTools 2.2 Code)::\n\n    CRSFactory factory = FactoryFinder.getCSFactory( null );\n\n* AFTER (GeoTools 2.4 Code)::\n\n    CRSFactory factory = ReferencingFactoryFinder.getCSFactory( null );\n\n``FeatureStore`` ``addFeatures``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe use of ``FeatureReader`` has been removed from the ``FeatureStore`` API.\n\n* Before (GeoTools 2.2 Code)::\n\n    featureStore.addFeatures( DataUtilities.reader( collection )); // add FeatureCollection\n    featureStore.addFeatures( DataUtilities.reader(array)); // add Feature[]\n    featureStore.addFeatures( DataUtilities.reader(feature )); // add Feature\n    featureStore.addFeatures( reader );\n\n* After (GeoTools 2.4 Code)::\n\n    featureStore.addFeatures( collection ); // add FeatureCollection\n    featureStore.addFeatures( DataUtilities.collection( array ) ); // add Feature[]\n    featureStore.addFeatures( DataUtilities.collection( feature )); // add Feature\n    featureStore.addFeatures( DataUtilities.collection( reader )); // add FeatureReader\n\nNote:\n\n* ``DataUtilities.collection(reader)`` will currently load the contents into memory, if you have\n  any volunteer time a \"lazy\" implementation would be helpful.\n\n``FeatureSource`` ``getSupportedHints``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe added a ``getSupportedHints()`` method that can be used to check which ``Query`` hints are supported\nby a certain ``FeatureSource``. If your ``FeatureSource`` does not intend to leverage query hints, just\nreturn an empty set.\n\n* After (GeoTools 2.4 Code)::\n\n    /**\n     * By default, no Hints are supported\n     */\n    public Set getSupportedHints() {\n        return Collections.EMPTY_SET;\n    }\n\n``Query`` ``getHints``\n^^^^^^^^^^^^^^^^^^^^^^\n\nWe have added the method ``Query.getHints()`` allow users to pass in hints to control the query\nprocess.\n\nIf you have a ``Query`` implementation other than ``DefaultQuery`` you'll need to add the ``getHints()`` method.\nThe default implementation, if you don't plan to leverage hints, can just return an\nempty Hints object.\n\n* After (GeoTools 2.4 Code)::\n\n    /**\n     * Returns an empty Hints set\n     */\n    public Hints getHints() {\n        return new Hints(Collections.emptyMap());\n    }\n\nFilter\n^^^^^^\n\nWe have completed the transition to GeoAPI Filter.\n\n* Before (GeoTools 2.2 Code)::\n\n    package org.geotools.filter;\n\n    import junit.framework.TestCase;\n\n    import org.geotools.filter.LogicFilter;\n    import org.geotools.filter.FilterFactory;\n    import org.geotools.filter.Filter;\n\n    public class FilterFactoryBeforeTest extends TestCase {\n\n        public void testBefore() throws Exception {\n            FilterFactory ff = FilterFactoryFinder.createFilterFactory();\n\n            CompareFilter filter = ff.createCompareFilter(Filter.COMPARE_GREATER_THAN);\n            filter.addLeftValue( ff.createLiteralExpression(2));\n            filter.addRightValue( ff.createLiteralExpression(1));\n\n            assertTrue( filter.contrains( null ) );\n            assertTrue( filter.getFilterType() == FilterType.COMPARE_GREATER_THAN );\n            assertTrue( Filter.NONE != filter );\n        }\n    }\n\n* AFTER (Quick GeoTools 2.3 Code)::\n\n    public void testQuick() throws Exception {\n        FilterFactory ff = FilterFactoryFinder.createFilterFactory();\n\n        CompareFilter filter = ff.createCompareFilter(FilterType.COMPARE_GREATER_THAN);\n        filter.addLeftValue( ff.createLiteralExpression(2));\n        filter.addRightValue( ff.createLiteralExpression(1));\n\n        assertTrue( filter.evaluate( null ) );\n        assertTrue( Filters.getFilterType( filter ) == FilterType.COMPARE_GREATER_THAN);\n        assertTrue( Filter.INCLUDE != filter );\n    }\n\nHere are the steps to follow to update your own code:\n\n1. Substitute.\n\n   ======================================= =================================================\n   Search                                  Replace\n   ======================================= =================================================\n   ``import org.geotools.filter.Filter;``  ``import org.opengis.filter.Filter;``\n   ``import org.geotools.filter.SortBy;``  ``import org.opengis.filter.sort.SortBy;``\n   ``Filter.NONE``                         ``Filter.INCLUDE``\n   ``Filter.ALL``                          ``Filter.EXCLUDE``\n   ``AbstractFilter.COMPARE``              ``FilterType.COMPARE``\n   ``Filter.COMPARE``                      ``FilterType.COMPARE``\n   ``Filter.GEOMETRY``                     ``FilterType.GEOMETRY``\n   ``Filter.LOGIC``                        ``FilterType.LOGIC``\n   ======================================= =================================================\n\n2. ``Filterype`` is no longer supported directly.\n\n   BEFORE::\n\n      int type = filter.getFilterType();\n\n   AFTER::\n\n      int type = Filters.getFilterType( filter );\n\n3. You can no longer chain filters together.\n\n   BEFORE::\n\n     filter = filter.and( other )\n\n   AFTER::\n\n     filter = filterFactory.and( filter, other );\n\n4. We have provided an adapter for your old filter visitors.\n\n   BEFORE::\n\n     filter.accept( visitor )\n\n   AFTER::\n\n     Filters.accept( filter, visitor );\n\n3. Update your code to use the new factory methods.\n\n   BEFORE::\n\n     filter = filterFactory.createCompareFilter(FilterType.COMPARE_EQUALS)\n     filter.setLeftGeoemtry( expr1 );\n     filter.setRightGeometry( expr3 );\n\n   AFTER::\n\n     filter = FilterFactory.equals(expr1,expr);\n\n4. Literals cannot be modified once created.\n\n   BEFORE::\n\n     Literal literal = filterFactory.createLiteral();\n     literal.setLiteral( obj );\n\n   AFTER::\n\n     Filter filter = filterFactory.literal( obj );\n\n5. Property name support.\n\n   BEFORE::\n\n     filter = = filterFac.createAttributeExpression(schema, \"name\");\n\n   AFTER::\n\n     Filter filter = filterFactory.property(name);\n\nAfter (GeoTools 2.4 Code)::\n\n        public void testAfter() throws Exception {\n            FilterFactory ff = CommonFactoryFinder.getFilterFactory(null);\n\n            Expression left = ff.literal(2);\n            Expression right = ff.literal(2);\n            PropertyIsGreaterThan filter = ff.greater( left, right );\n\n            assertTrue( filter.evaluate( null ) );\n            assertTrue( Filter.INCLUDE != filter );\n        }\n\n1. Substitute\n\n\n   =================================================== =======================================================\n   Search                                              Replace\n   =================================================== =======================================================\n   ``import org.geotools.filter.FilterFactory;``       ``import org.opengis.filter.FilterFactory;``\n   ``FilterFactoryFinder.createFilterFactory()``       ``CommonFactoryFinder.getFilterFactory(null);``\n   ``import org.geotools.filter.FilterFactoryFinder;`` ``import org.geotools.factory.CommonFactoryFinder``\n   ``import org.geotools.filter.CompareFilter;``       ``import org.geoapi.spatial.BinaryComparisonOperator``\n   ``CompareFilter``                                   ``BinaryComparisonOperator``\n   =================================================== =======================================================\n\n2. Update code to use evaluate.\n\n   BEFORE::\n\n      if( filter.contains( feature ){\n\n   AFTER::\n\n      if( filter.evaluate( feature ){\n\n3. Update code to use ``instanceof`` checks.\n\n   BEFORE::\n\n       if( filter.getFilterType() == FilterType.GEOMETRY_CONTAIN ) {\n\n   AFTER::\n\n       if( filter instanceof Contains ){\n\n\nNote regarding different Geometries\n\n* GeoTools was formally limited to only JTS Geometry\n* GeoTools filter now can take either JTS Geometry or ISO Geometry\n\n* If you need to convert from one to the other::\n\n     JTSUtils.jtsToGo1(p, CRS.decode(\"EPSG:4326\"));\n\n``Feature.getParent`` removed\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``feature.getParent()`` method have been deprecated as a mistake and has now been removed.\n\n* BEFORE (GeoTools 2.0 Code)::\n\n    public void example( FeatureSource source ){\n        FeatureCollection features = source.getFeatures();\n        Iterator i = features.iterator();\n        try {\n            while( i.hasNext() ){\n                  Feature feature = (Feature) i.next();\n                  System.out.println( precentBoxed( feature ));\n            }\n        }\n        finally {\n            features.close( i );\n        }\n    }\n    private double precentBoxed( Feature feature ){\n         Envelope context = feature.getParent().getBounds();\n         Envelope bbox = feature.getBounds();\n         double boxedContext = context.width * context.height;\n         double boxed = bbox.width * bbox.height;\n         return (boxed / boxedContext) * 100.0\n    }\n\n* AFTER (GeoTools 2.2 Code)::\n\n    public void example( FeatureSource source ){\n        FeatureCollection features = source.getFeatures();\n        Iterator i = features.iterator();\n        try {\n            while( i.hasNext() ){\n                  Feature feature = (Feature) i.next();\n                  System.out.println( precentBoxed( feature, features ));\n            }\n        }\n        finally {\n            features.close( i );\n        }\n    }\n    private double precentBoxed( Feature feature, FeatureCollection parent ){\n         Envelope context = parent.getBounds();\n         Envelope bbox = feature.getBounds();\n         double boxedContext = context.width * context.height;\n         double boxed = bbox.width * bbox.height;\n         return (boxed / boxedContext) * 100.0\n    }\n\nNotes:\n\n* you will have to make API changes to pass the intended parent collection in\n\nThis is a mistake with the previous feature model (for a feature can exist in more then one\ncollection) and we apologize for the inconvenience.\n\nSplit Classification Expressions\n\nThe biggest user of the ``feature.getParent()`` mistake was the implementation of classification\nfunctions. You will now need to split up these expressions into two parts.\n\n* BEFORE (GeoTools 2.3):\n\n  1. ``equal_interval( SPEED, 12 )``\n  2. uses ``getParent()`` internally to produce classification on feature collection;\n  3. then checks which category each feature falls into\n\n  Notes:\n\n  * please note the above code depends on ``getParent()`` so it is not safe even for GeoTools 2.3 (as some features have a null parent).\n\n* AFTER (GeoTools 2.4):\n\n  Apply the aggregation function to the feature collection:\n\n  1. ``equalInterval( SPEED, 12 )``\n  2. produce classification on provided feature collection\n  3. Construct a slot expression using the resulting literal::\n\n        classify( SPEED, {0} )\n\n  4. use literal classification from step one\n\nGTRenderer\n^^^^^^^^^^\n\nThe ``GTRender`` interface was produced as a neutral ground for client code; traditional users of\n``LiteRenderer`` and ``LiteRenderer2`` are asked to move to the implementation of ``GTRenderer`` called\n``StreamingRenderer``.\n\n* BEFORE (GeoTools 2.1):\n\n  How to paint to an *outputArea* Rectangle::\n\n    LiteRenderer2 draw = new LiteRenderer2(map);\n\n    Envelope dataArea = map.getLayerBounds();\n    AffineTransform transform = renderer.worldToScreenTransform(dataArea, outputArea);\n\n    draw.paint(g2d, outputArea, transform);\n\n* QUICK (GeoTools 2.2)\n\n  How to paint to an *outputArea* Rectangle::\n\n    StreamingRenderer draw = new StreamingRenderer();\n    draw.setContext(map);\n\n    draw.paint(g2d, outputArea, map.getLayerBounds() );\n\n* BEST PRACTICE (GeoTools 2.2)::\n\n    GTRenderer draw = new StreamingRenderer();\n    draw.setContext(map);\n\n    draw.paint(g2d, outputArea, map.getLayerBounds() );\n\n  By letting your code depend only on the ``GTRenderer`` interface you can experiment with\n  alternative implementations to find the best fit.\n\nJTS\n^^^\n\nSwap moved to JTS utility class.\n\n* BEFORE (GeoTools 2.1)::\n\n    import org.geotools.geometry.JTS;\n    import org.geotools.geometry.JTS.ReferencedEnvelope\n\n* AFTER (GeoTools 2.2)::\n\n    import org.geotools.geometry.jts.JTS;\n    import org.geotools.geometry.jts.ReferencedEnvelope\n\nJTS to Shape converters\n^^^^^^^^^^^^^^^^^^^^^^^\n\nSwap to moved Renderer JTS-to-Shape converters.\n\n* BEFORE (GeoTools 2.3)::\n\n    import org.geotools.renderer.lite.LiteShape;\n    import org.geotools.renderer.lite.LiteShape2;\n    import org.geotools.renderer.lite.PackedLineIterator;\n    import org.geotools.renderer.lite.PointIterator;\n    import org.geotools.renderer.lite.PolygonIterator;\n    import org.geotools.renderer.lite.LineIterator;\n    import org.geotools.renderer.lite.LineIterator2;\n    import org.geotools.renderer.lite.Decimator;\n    import org.geotools.renderer.lite.AbstractLiteIterator;\n    import org.geotools.renderer.lite.TransformedShape;\n    import org.geotools.renderer.lite.LiteCoordinateSequence;\n    import org.geotools.renderer.lite.LiteCoordinateSequenceFactory;\n    import org.geotools.renderer.lite.LiteCoordinateSequence;\n\n* AFTER (GeoTools 2.4)::\n\n    import org.geotools.geometry.jts.LiteShape;\n    import org.geotools.geometry.jts.LiteShape2;\n    import org.geotools.geometry.jts.PackedLineIterator;\n    import org.geotools.geometry.jts.PointIterator;\n    import org.geotools.geometry.jts.PolygonIterator;\n    import org.geotools.geometry.jts.LineIterator;\n    import org.geotools.geometry.jts.LineIterator2;\n    import org.geotools.geometry.jts.Decimator;\n    import org.geotools.geometry.jts.AbstractLiteIterator;\n    import org.geotools.geometry.jts.TransformedShape;\n    import org.geotools.geometry.jts.LiteCoordinateSequence;\n    import org.geotools.geometry.jts.LiteCoordinateSequenceFactory;\n    import org.geotools.geometry.jts.LiteCoordinateSequence;\n\nCoverage utility classes\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nSwap to moved Coverage utility classes.\n\n* BEFORE (GeoTools 2.3)::\n\n    import org.geotools.data.coverage.grid.*\n    import org.geotools.image.imageio.*\n\n  Wrapping a ``GridCoverage`` into a feature in 2.3::\n\n    org.geotools.data.DataUtilities#wrapGc(GridCoverage gridCoverage)\n    org.geotools.data.DataUtilities#wrapGcReader(\n                AbstractGridCoverage2DReader gridCoverageReader,\n                GeneralParameterValue[] params)\n\n  ``GridCoverageExchange`` Utility classes in 2.3::\n\n    org.geotools.data.coverage.grid.file.*\n    org.geotools.data.coverage.grid.stream .*\n\n  ``org.geotools.coverage.io`` classes in 2.3::\n\n    org.geotools.coverage.io.AbstractGridCoverageReader.java,\n    org.geotools.coverage.io.AmbiguousMetadataException.java,\n    org.geotools.coverage.io.ExoreferencedGridCoverageReader.java,\n    org.geotools.coverage.io.MetadataBuilder.java,\n    org.geotools.coverage.io.MetadataException.java,\n    org.geotools.coverage.io.MissingMetadataException.java\n\n* AFTER (GeoTools 2.4)::\n\n    import org.geotools.coverage.grid.io.*\n    import  org.geotools.coverage.grid.io.imageio.*\n\n  Wrapping a ``GridCoverage`` into a feature in 2.4::\n\n    org.geotools.referencing.util.coverage.CoverageUtilities #wrapGc(GridCoverage gridCoverage)\n    org.geotools.referencing.util.coverage.CoverageUtilities #wrapGcReader(\n                AbstractGridCoverage2DReader gridCoverageReader,\n                GeneralParameterValue[] params)\n\n  ``GridCoverageExchange`` Utility classes in 2.4.\n\n  The classes have been dismissed since apparently nobody was using. If needed\n  we can reintroduce them as deprecated.\n\n  ``org.geotools.coverage.io`` classes in 2.4.\n\n  These classes have been moved to ``spike/exoreferenced`` waiting for Martin to review and merge into\n  ``org.geotools.coverage.grid.io`` package\n\n``spatialschema``\n^^^^^^^^^^^^^^^^^\n\nRenamed ``spatialschema`` to ``geometry``.\n\n* Do you know what ``spatialschema`` was? We did not find it clear either.\n\n  Renamed to ``geometry``?\n\n* BEFORE::\n\n    import org.opengis.spatialschema.geometry;\n    import org.opengis.spatialschema.geometry.aggregate;\n    import org.opengis.spatialschema.geometry.complex;\n    import org.opengis.spatialschema.geometry.geometry;\n    import org.opengis.spatialschema.geometry.primitive;\n\n* AFTER::\n\n    import org.opengis.geometry;\n    import org.opengis.geometry.aggregate;\n    import org.opengis.geometry.complex;\n    import org.opengis.geometry.coordinate;\n    import org.opengis.geometry.primitive;\n\nWorld Image\n^^^^^^^^^^^\n\nSets of World Image extensions. Changed from a single String to a\n``Set<String>`` .. because\none ``wld`` is not enough?\n\n* BEFORE::\n\n    private File toWorldFile(String fileRoot, String fileExt){\n        File worldFile = new File( fileRoot + \".wld\" );\n        if( worldFile.exists() ){\n            return worldFile;\n        }\n        String ext = WorldImageFormat.getWorldExtension( fileExt );\n        File otherWorldFile = new File( fileRoot + ext );\n        if( otherWorldFile.exists() ){\n            return otherWorldFile;\n        }\n        return null;\n    }\n\n* AFTER::\n\n     private File toWorldFile(String fileRoot, String fileExt){\n        Set<String> other = WorldImageFormat.getWorldExtension( fileExt );\n        File worldFile = new File( fileRoot + \".wld\" );\n        if( worldFile.exists() ){\n            return worldFile;\n        }\n        for( String ext : other ){\n            File otherWorldFile = new File( fileRoot + ext );\n            if( otherWorldFile.exists() ){\n                return otherWorldFile;\n            }\n        }\n        return null;\n    }\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.data.jdbc.datasource;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Map;\nimport javax.sql.DataSource;\nimport org.geotools.data.DataAccessFactory.Param;\nimport org.geotools.data.DataSourceException;\nimport org.geotools.data.Parameter;\nimport org.geotools.util.factory.GeoTools;\n\n/**\n * A datasource factory SPI doing JDNI lookups\n *\n * @author Administrator\n */\npublic class JNDIDataSourceFactory extends AbstractDataSourceFactorySpi {\n\n    public static final Param DSTYPE =\n            new Param(\n                    \"dstype\",\n                    String.class,\n                    \"Must be JNDI\",\n                    false,\n                    null,\n                    Collections.singletonMap(Parameter.LEVEL, \"program\"));\n\n    public static final Param JNDI_REFNAME =\n            new Param(\n                    \"jdniReferenceName\",\n                    String.class,\n                    \"The path where the connection pool must be located\",\n                    true);\n\n    private static final Param[] PARAMS = {DSTYPE, JNDI_REFNAME};\n\n    @Override\n    public DataSource createDataSource(Map<String, ?> params) throws IOException {\n        return createNewDataSource(params);\n    }\n\n    @Override\n    public boolean canProcess(Map<String, ?> params) {\n        return super.canProcess(params) && \"JNDI\".equals(params.get(\"dstype\"));\n    }\n\n    @Override\n    public DataSource createNewDataSource(Map<String, ?> params) throws IOException {\n        String refName = (String) JNDI_REFNAME.lookUp(params);\n        try {\n            return (DataSource) GeoTools.jndiLookup(refName);\n        } catch (Exception e) {\n            throw new DataSourceException(\"Could not find the specified data source in JNDI\", e);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return \"A JNDI based DataSource locator. Provide the JDNI location of a DataSource object in order to make it work\";\n    }\n\n    @Override\n    public Param[] getParametersInfo() {\n        return PARAMS;\n    }\n\n    /** Make sure a JNDI context is available */\n    @Override\n    public boolean isAvailable() {\n        return GeoTools.isJNDIAvailable();\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2015, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\n\npackage org.geotools.jdbc;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport org.geotools.data.DataStore;\nimport org.geotools.util.factory.GeoTools;\n\n/**\n * Abstract implementation of DataStoreFactory for jdbc datastores which obtain a JNDI connection.\n *\n * <p>Subclasses should not need to override any methods, only just call the parent constructor\n * passing in the non JNDI datastore factory to delegate to.\n *\n * @author Christian Mueller\n */\n// temporary work around, the factory parameters map will be fixed separately\n@SuppressWarnings(\"unchecked\")\npublic abstract class JDBCJNDIDataStoreFactory extends JDBCDataStoreFactory {\n\n    public static final String J2EERootContext = \"java:comp/env/\";\n    /** JNDI data source name */\n    public static final Param JNDI_REFNAME =\n            new Param(\n                    \"jndiReferenceName\",\n                    String.class,\n                    \"JNDI data source\",\n                    true,\n                    J2EERootContext + \"jdbc/mydatabase\");\n\n    /** regular datastore factory to delegate to. */\n    protected JDBCDataStoreFactory delegate;\n\n    protected JDBCJNDIDataStoreFactory(JDBCDataStoreFactory delegate) {\n        this.delegate = delegate;\n    }\n\n    /**\n     * Override which explicitly returns null because with a JNDI connection the driver is not known\n     * ahead of time.\n     */\n    @Override\n    protected String getDriverClassName() {\n        return null;\n    }\n\n    /**\n     * Override which explicitly returns null, validation queries are not supported, my be part of\n     * the external data source configuration\n     */\n    @Override\n    protected String getValidationQuery() {\n        return null;\n    }\n\n    /**\n     * Override which explicitly returns null since there is no jdbc url, the connection is\n     * identified by the JNDI name.\n     */\n    @Override\n    protected String getJDBCUrl(Map<String, ?> params) throws IOException {\n        return null;\n    }\n\n    /** Override to create the datasource from the external JNDI conection. */\n    @Override\n    protected DataSource createDataSource(Map<String, ?> params, SQLDialect dialect)\n            throws IOException {\n        String jndiName = (String) JNDI_REFNAME.lookUp(params);\n        if (jndiName == null) throw new IOException(\"Missing \" + JNDI_REFNAME.description);\n\n        DataSource ds = null;\n\n        try {\n            ds = (DataSource) GeoTools.jndiLookup(jndiName);\n        } catch (NamingException e1) {\n            // check if the user did not specify \"java:comp/env\"\n            // and this code is running in a J2EE environment\n            try {\n                if (jndiName.startsWith(J2EERootContext) == false) {\n                    ds = (DataSource) GeoTools.jndiLookup(J2EERootContext + jndiName);\n                    // success --> issue a waring\n                    Logger.getLogger(this.getClass().getName())\n                            .log(\n                                    Level.WARNING,\n                                    \"Using \"\n                                            + J2EERootContext\n                                            + jndiName\n                                            + \" instead of \"\n                                            + jndiName\n                                            + \" would avoid an unnecessary JNDI lookup\");\n                }\n            } catch (NamingException e2) {\n                // do nothing, was only a try\n            }\n        }\n\n        if (ds == null) throw new IOException(\"Cannot find JNDI data source: \" + jndiName);\n        else return ds;\n    }\n\n    /**\n     * Determines if the datastore is available.\n     *\n     * <p>Check in an Initial Context is available, that is all what can be done Checking for the\n     * right jdbc jars in the classpath is not possible here\n     */\n    @Override\n    public boolean isAvailable() {\n        return GeoTools.isJNDIAvailable();\n    }\n\n    /** Override to omit all those parameters which define the creation of the connection. */\n    @Override\n    protected void setupParameters(Map<String, Object> parameters) {\n        parameters.put(\n                DBTYPE.key,\n                new Param(\n                        DBTYPE.key,\n                        DBTYPE.type,\n                        DBTYPE.description,\n                        DBTYPE.required,\n                        getDatabaseID()));\n        parameters.put(JNDI_REFNAME.key, JNDI_REFNAME);\n        parameters.put(SCHEMA.key, SCHEMA);\n        parameters.put(NAMESPACE.key, NAMESPACE);\n        parameters.put(FETCHSIZE.key, FETCHSIZE);\n        parameters.put(BATCH_INSERT_SIZE.key, BATCH_INSERT_SIZE);\n        parameters.put(EXPOSE_PK.key, EXPOSE_PK);\n        parameters.put(PK_METADATA_TABLE.key, PK_METADATA_TABLE);\n        parameters.put(SQL_ON_BORROW.key, SQL_ON_BORROW);\n        parameters.put(SQL_ON_RELEASE.key, SQL_ON_RELEASE);\n        parameters.put(CALLBACK_FACTORY.key, CALLBACK_FACTORY);\n    }\n\n    @Override\n    protected String getDatabaseID() {\n        return delegate.getDatabaseID();\n    }\n\n    @Override\n    public String getDisplayName() {\n        return delegate.getDisplayName() + \" (JNDI)\";\n    }\n\n    @Override\n    public String getDescription() {\n        return delegate.getDescription() + \" (JNDI)\";\n    }\n\n    @Override\n    protected JDBCDataStore createDataStoreInternal(JDBCDataStore dataStore, Map<String, ?> params)\n            throws IOException {\n        return delegate.createDataStoreInternal(dataStore, params);\n    }\n\n    @Override\n    public DataStore createNewDataStore(Map<String, ?> params) throws IOException {\n        return delegate.createNewDataStore(params);\n    }\n\n    @Override\n    public Map<java.awt.RenderingHints.Key, ?> getImplementationHints() {\n        return delegate.getImplementationHints();\n    }\n\n    @Override\n    protected SQLDialect createSQLDialect(JDBCDataStore dataStore) {\n        return delegate.createSQLDialect(dataStore);\n    }\n\n    @Override\n    protected boolean checkDBType(Map<String, ?> params) {\n        return delegate.checkDBType(params);\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- =======================================================================\n        Maven Project Configuration File\n\n        The Geotools Project\n            http://www.geotools.org/\n\n        Version: $Id$\n     ======================================================================= -->\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0                                http://maven.apache.org/maven-v4_0_0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <parent>\n    <groupId>org.geotools</groupId>\n    <artifactId>library</artifactId>\n    <version>26-SNAPSHOT</version>\n  </parent>\n\n  <!-- =========================================================== -->\n  <!--     Module Description                                      -->\n  <!-- =========================================================== -->\n  <groupId>org.geotools</groupId>\n  <artifactId>gt-metadata</artifactId>\n  <packaging>jar</packaging>\n\n  <name>Metadata</name>\n  <description>Contains implementations of metadata and some core utilities classes.</description>\n\n  <licenses>\n    <license>\n      <name>Lesser General Public License (LGPL)</name>\n      <url>http://www.gnu.org/copyleft/lesser.txt</url>\n      <distribution>repo</distribution>\n    </license>\n  </licenses>\n\n  <!-- =========================================================== -->\n  <!--     Developers and Contributors                             -->\n  <!-- =========================================================== -->\n  <developers>\n    <developer>\n      <id>jive</id>\n      <name>Jody Garnett</name>\n      <email>jive@users.sourceforge.net</email>\n      <organization>Refractions Research</organization>\n      <roles>\n        <role>Module Maintainer</role>\n        <role>Java Developer</role>\n      </roles>\n    </developer>\n  </developers>\n\n  <contributors>\n    <contributor>\n      <name>Toura\u00efvane</name>\n      <organization>Institut de Recherche pour le D\u00e9veloppement (IRD)</organization>\n      <roles>\n        <role>Java developper</role>\n      </roles>\n    </contributor>\n    <contributor>\n      <name>Martin Desruisseaux</name>\n      <email>desruisseaux@users.sourceforge.net</email>\n      <organization>Geomatys</organization>\n      <organizationUrl>http://www.geomatys.fr/</organizationUrl>\n      <roles>\n        <role>Retired Module Maintainer</role>\n        <role>Retired Java Developer</role>\n      </roles>\n      <timezone>+1</timezone>\n    </contributor>\n    <contributor>\n      <name>C\u00e9dric Brian\u00e7on</name>\n      <email>cedric.briancon@geomatys.fr</email>\n      <organization>Geomatys</organization>\n      <roles>\n        <role>Java developper</role>\n      </roles>\n      <timezone>+1</timezone>\n    </contributor>\n  </contributors>\n  <properties>\n    <moduleIdentifier>org.geotools.metadata</moduleIdentifier>\n  </properties>\n\n  <!-- =========================================================== -->\n  <!--     Dependency Management                                   -->\n  <!-- =========================================================== -->\n  <dependencies>\n    <!-- NOTE: The metadata module does not depend on JTS. -->\n    <dependency>\n      <groupId>org.geotools</groupId>\n      <artifactId>gt-opengis</artifactId>\n      <version>${project.version}</version>\n    </dependency>\n    <!--\n      The following is required only for compilation.  It should not be included\n      in distribution, unless the user really want to use Apache commons logging\n      (in which case he should put this dependency explicitly on the classpath).\n    -->\n    <dependency>\n      <groupId>javax.media</groupId>\n      <artifactId>jai_core</artifactId>\n      <!-- The version number is specified in the parent POM. -->\n    </dependency>\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <!-- The version number is specified in the parent POM. -->\n      <scope>provided</scope>\n      <!-- Not required for default execution. -->\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>org.locationtech.jts</groupId>\n      <artifactId>jts-core</artifactId>\n      <!-- The version number is specified in the parent POM. -->\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <scope>provided</scope>\n      <!-- Not required for default execution. -->\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-lang3</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.geotools.ogc</groupId>\n      <artifactId>net.opengis.ows</artifactId>\n      <version>${project.version}</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.mockito</groupId>\n      <artifactId>mockito-core</artifactId>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <resources>\n      <resource>\n        <directory>${basedir}/src/main/resources</directory>\n      </resource>\n      <resource>\n        <filtering>true</filtering>\n        <directory>${basedir}/src/main/properties</directory>\n      </resource>\n    </resources>\n  </build>\n\n</project>\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2007-2016, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.util.factory;\n\nimport java.awt.RenderingHints;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.function.Predicate;\nimport java.util.jar.Manifest;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.xml.parsers.SAXParser;\nimport org.geotools.metadata.i18n.ErrorKeys;\nimport org.geotools.metadata.i18n.Errors;\nimport org.geotools.util.Arguments;\nimport org.geotools.util.Classes;\nimport org.geotools.util.NullEntityResolver;\nimport org.geotools.util.PreventLocalEntityResolver;\nimport org.geotools.util.Utilities;\nimport org.geotools.util.Version;\nimport org.geotools.util.logging.LoggerFactory;\nimport org.geotools.util.logging.Logging;\nimport org.xml.sax.EntityResolver;\n\n/**\n * Static methods relative to the global GeoTools configuration. GeoTools can be configured in a\n * system-wide basis through {@linkplain System#getProperties system properties}, some of them are\n * declared as {@link String} constants in this class.\n *\n * <p>There are many aspects to the configuration of GeoTools:\n *\n * <ul>\n *   <li>Default Settings: Are handled as the Hints returned by {@link #getDefaultHints()}, the\n *       default values can be provided in application code, or specified using system properties.\n *   <li>Integration JNDI: Telling the GeoTools library about the facilities of an application, or\n *       application container takes several forms. This class provides the {@link\n *       #init(InitialContext)} method allowing to tell GeoTools about the JNDI context to use.\n *   <li>Integration Plugins: If hosting GeoTools in a alternate plugin system such as Spring or\n *       OSGi, application may needs to hunt down the {@code FactoryFinder}s and register additional\n *       \"Factory Iterators\" for GeoTools to search using the {@link #addFactoryIteratorProvider}\n *       method.\n * </ul>\n *\n * @since 2.4\n * @version $Id$\n * @author Jody Garnett\n * @author Martin Desruisseaux\n */\npublic final class GeoTools {\n\n    /** Properties about this geotools build */\n    private static final Properties PROPS;\n\n    static {\n        PROPS = loadProperites(\"GeoTools.properties\");\n    }\n\n    @SuppressWarnings(\"PMD.UseTryWithResources\") // stream may be null\n    private static Properties loadProperites(String resource) {\n        Properties props = new Properties();\n        InputStream stream = GeoTools.class.getResourceAsStream(resource);\n        if (stream != null) {\n            try {\n                props.load(stream);\n            } catch (IOException ignore) {\n            } finally {\n                try {\n                    stream.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n\n        return props;\n    }\n\n    /** The current GeoTools version. The separator character must be the dot. */\n    private static final Version VERSION = new Version(PROPS.getProperty(\"version\", \"20-SNAPSHOT\"));\n\n    /** The version control (svn) revision at which this version of geotools was built. */\n    private static final String BUILD_REVISION;\n\n    static {\n        BUILD_REVISION = PROPS.getProperty(\"build.revision\", \"-1\");\n    }\n\n    /** The timestamp at which this version of geotools was built. */\n    private static final String BUILD_TIMESTAMP = PROPS.getProperty(\"build.timestamp\", \"\");\n\n    /**\n     * Object to inform about system-wide configuration changes. We use the Swing utility listener\n     * list since it is lightweight and thread-safe. Note that it doesn't involve any dependency to\n     * the remaining of Swing library.\n     */\n    private static final EventListenerList LISTENERS = new EventListenerList();\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#CRS_AUTHORITY_EXTRA_DIRECTORY CRS_AUTHORITY_EXTRA_DIRECTORY}\n     * hint.\n     *\n     * @see Hints#CRS_AUTHORITY_EXTRA_DIRECTORY\n     * @see #getDefaultHints\n     */\n    public static final String CRS_AUTHORITY_EXTRA_DIRECTORY =\n            \"org.geotools.referencing.crs-directory\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#EPSG_DATA_SOURCE EPSG_DATA_SOURCE} hint.\n     *\n     * @see Hints#EPSG_DATA_SOURCE\n     * @see #getDefaultHints\n     */\n    public static final String EPSG_DATA_SOURCE = \"org.geotools.referencing.epsg-datasource\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER\n     * FORCE_LONGITUDE_FIRST_AXIS_ORDER} hint.\n     *\n     * <p>This setting can provide a transition path for projects expecting a (<var>longitude</var>,\n     * <var>latitude</var>) axis order on a system-wide level. Application developpers can set the\n     * default value as below:\n     *\n     * <blockquote>\n     *\n     * <pre>\n     * System.setProperty(FORCE_LONGITUDE_FIRST_AXIS_ORDER, \"true\");\n     * </pre>\n     *\n     * </blockquote>\n     *\n     * Note that this system property applies mostly to the default EPSG factory. Most other\n     * factories ({@code \"CRS\"}, {@code \"AUTO\"}, <cite>etc.</cite>) don't need this property since\n     * they use (<var>longitude</var>, <var>latitude</var>) axis order by design.\n     *\n     * @see Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER\n     * @see #getDefaultHints\n     */\n    public static final String FORCE_LONGITUDE_FIRST_AXIS_ORDER =\n            \"org.geotools.referencing.forceXY\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints# ENTITY_RESOLVER} hint.\n     *\n     * <p>This setting specifies the XML Entity resolver to be used when configuring a SAXParser\n     *\n     * @see Hints#ENTITY_RESOLVER\n     * @see #getDefaultHints\n     */\n    public static final String ENTITY_RESOLVER = \"org.xml.sax.EntityResolver\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints# RESAMPLE_TOLERANCE} hint.\n     *\n     * <p>This setting specifies the tolerance used when linearizing warp transformation into\n     * piecewise linear ones, by default it is 0.333 pixels\n     *\n     * @see Hints#RESAMPLE_TOLERANCE\n     * @see #getDefaultHints\n     */\n    public static final String RESAMPLE_TOLERANCE = \"org.geotools.referencing.resampleTolerance\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#LOCAL_DATE_TIME_HANDLING} hint.\n     *\n     * <p>This setting specifies if dates shall be treated as local dates ignoring time zones.\n     *\n     * @see Hints#LOCAL_DATE_TIME_HANDLING\n     * @see #getDefaultHints\n     * @since 15.0\n     */\n    public static final String LOCAL_DATE_TIME_HANDLING = \"org.geotools.localDateTimeHandling\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#DATE_TIME_FORMAT_HANDLING} hint.\n     *\n     * <p>This setting specifies if GML 2 temporal data shall be formatted using same approach as\n     * GML 3+.\n     *\n     * @see Hints#DATE_TIME_FORMAT_HANDLING\n     * @see #getDefaultHints\n     * @since 21.0\n     */\n    public static final String DATE_TIME_FORMAT_HANDLING = \"org.geotools.dateTimeFormatHandling\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#ENCODE_EWKT} hint.\n     *\n     * <p>This setting specifies if geometries with {@link\n     * org.opengis.referencing.crs.CoordinateReferenceSystem} in the user data shall be encoded as\n     * EWKT or not.\n     *\n     * @see Hints#ENCODE_EWKT\n     * @see #getDefaultHints\n     * @since 19.0\n     */\n    public static final String ENCODE_WKT = \"org.geotools.ecql.ewkt\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#HTTP_CLIENT} hint.\n     *\n     * <p>This setting specifies whether we wan't to use a special http client\n     *\n     * @see Hints#HTTP_CLIENT\n     * @see #getDefaultHints\n     * @since 25.0\n     */\n    public static final String HTTP_CLIENT = \"org.geotools.http.client\";\n\n    /**\n     * The {@linkplain System#getProperty(String) system property} key for the default value to be\n     * assigned to the {@link Hints#HTTP_LOGGING} hint.\n     *\n     * <p>This setting specifies whether we want to log all http requests.\n     *\n     * @see Hints#HTTP_LOGGING\n     * @see #getDefaultHints\n     * @since 25.0\n     */\n    public static final String HTTP_LOGGING = \"org.geotools.http.logging\";\n\n    /** The initial context. Will be created only when first needed. */\n    private static InitialContext context;\n\n    /**\n     * Class loaders to be added to the list in ${link {@link FactoryRegistry#getClassLoaders()}}\n     * which are used to look-up plug-ins. Class loaders are added via {@link\n     * #addClassLoader(ClassLoader)}\n     */\n    private static final Set<ClassLoader> addedClassLoaders =\n            Collections.synchronizedSet(new HashSet<>());\n\n    /**\n     * The bindings between {@linkplain System#getProperties system properties} and a hint key.\n     *\n     * <p>This registry is used by {@link #scanForSystemHints} to evaluate which System properties\n     * are present using this map's keys as System property names and its mapped value to resolve\n     * the System property value the correct value type/\n     */\n    private static final Map<String, RenderingHints.Key> BINDINGS;\n\n    static {\n        Map<String, RenderingHints.Key> bindings = new HashMap<>();\n        bind(ENCODE_WKT, Hints.ENCODE_EWKT, bindings);\n        bind(CRS_AUTHORITY_EXTRA_DIRECTORY, Hints.CRS_AUTHORITY_EXTRA_DIRECTORY, bindings);\n        bind(EPSG_DATA_SOURCE, Hints.EPSG_DATA_SOURCE, bindings);\n        bind(FORCE_LONGITUDE_FIRST_AXIS_ORDER, Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, bindings);\n        bind(ENTITY_RESOLVER, Hints.ENTITY_RESOLVER, bindings);\n        bind(RESAMPLE_TOLERANCE, Hints.RESAMPLE_TOLERANCE, bindings);\n        bind(LOCAL_DATE_TIME_HANDLING, Hints.LOCAL_DATE_TIME_HANDLING, bindings);\n        bind(DATE_TIME_FORMAT_HANDLING, Hints.DATE_TIME_FORMAT_HANDLING, bindings);\n        bind(HTTP_CLIENT, Hints.HTTP_CLIENT, bindings);\n        bind(HTTP_LOGGING, Hints.HTTP_LOGGING, bindings);\n        BINDINGS = Collections.unmodifiableMap(bindings);\n    }\n\n    /**\n     * Default JNDI name validator, allows lookups only on names without a scheme, or using the\n     * <code>java</code> scheme.\n     */\n    public static final Predicate<String> DEFAULT_JNDI_VALIDATOR =\n            name -> {\n                Logger LOGGER = Logging.getLogger(GeoTools.class);\n                try {\n                    URI uri = new URI(name);\n                    boolean result = uri.getScheme() == null || uri.getScheme().equals(\"java\");\n                    if (!result)\n                        LOGGER.warning(\n                                \"JNDI lookup allowed only on java scheme, or no scheme. Found instead: \"\n                                        + name);\n                    return result;\n                } catch (URISyntaxException e) {\n                    LOGGER.log(Level.WARNING, \"Invalid JNDI name provided\", e);\n                    return false;\n                }\n            };\n\n    private static Predicate<String> jndiValidator = DEFAULT_JNDI_VALIDATOR;\n\n    /**\n     * Binds the specified {@linkplain System#getProperty(String) system property} to the specified\n     * key. Only one key can be bound to a given system property. However the same key can be binded\n     * to more than one system property names, in which case the extra system property names are\n     * aliases.\n     *\n     * @param property The system property.\n     * @param key The key to bind to the system property.\n     * @param bindings The target registry mapping System properties to RenderingHints\n     * @throws IllegalArgumentException if an other key is already bounds to the given system\n     *     property.\n     */\n    private static void bind(\n            final String property,\n            final RenderingHints.Key key,\n            Map<String, RenderingHints.Key> bindings) {\n        final RenderingHints.Key old = bindings.putIfAbsent(property, key);\n        if (old != null) {\n            throw new IllegalArgumentException(\n                    Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, \"property\", property));\n        }\n    }\n\n    /** Do not allow instantiation of this class. */\n    private GeoTools() {}\n\n    /**\n     * Returns summary information about GeoTools and the current environment. Calls {@linkplain\n     * #getEnvironmentInfo()} followed by {@linkplain #getGeoToolsJarInfo()} and concatenates their\n     * results.\n     *\n     * @return requested information as a string\n     */\n    public static String getAboutInfo() {\n        final StringBuilder sb = new StringBuilder();\n\n        sb.append(getEnvironmentInfo());\n        sb.append(String.format(\"%n\"));\n        sb.append(getGeoToolsJarInfo());\n\n        return sb.toString();\n    }\n\n    /**\n     * Returns summary information about the GeoTools version and the host environment.\n     *\n     * @return information as a String\n     */\n    public static String getEnvironmentInfo() {\n        final String newline = String.format(\"%n\");\n\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"GeoTools version \").append(getVersion().toString());\n        if (sb.toString().endsWith(\"SNAPSHOT\")) {\n            sb.append(\" (built from r\").append(getBuildRevision().toString()).append(\")\");\n        }\n\n        sb.append(newline).append(\"Java version: \");\n        sb.append(System.getProperty(\"java.version\"));\n\n        sb.append(newline).append(\"Operating system: \");\n        sb.append(System.getProperty(\"os.name\"))\n                .append(' ')\n                .append(System.getProperty(\"os.version\"));\n\n        return sb.toString();\n    }\n\n    /**\n     * Returns the names of the GeoTools jars on the classpath.\n     *\n     * @return list of jars as a formatted string\n     */\n    public static String getGeoToolsJarInfo() {\n        final StringBuilder sb = new StringBuilder();\n        final String newline = String.format(\"%n\");\n        final String indent = \"    \";\n\n        sb.append(\"GeoTools jars on classpath:\");\n        for (String jarName : getGeoToolsJars()) {\n            sb.append(newline).append(indent).append(jarName);\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * A helper method for {@linkplain #getGeoToolsJarInfo} which scans the classpath looking for\n     * GeoTools jars matching the current version.\n     *\n     * @return a list of jar names\n     */\n    private static List<String> getGeoToolsJars() {\n        final Pattern pattern = Pattern.compile(\".*\\\\/\" + getVersion() + \"\\\\/(gt-.*jar$)\");\n        final List<String> jarNames = new ArrayList<>();\n\n        String pathSep = System.getProperty(\"path.separator\");\n        String classpath = System.getProperty(\"java.class.path\");\n        StringTokenizer st = new StringTokenizer(classpath, pathSep);\n        while (st.hasMoreTokens()) {\n            String path = st.nextToken();\n            Matcher matcher = pattern.matcher(path);\n            if (matcher.find()) {\n                jarNames.add(matcher.group(1));\n            }\n        }\n\n        Collections.sort(jarNames);\n        return jarNames;\n    }\n\n    /**\n     * Reports back the vcs revision at which the version of GeoTools was built.\n     *\n     * @return The svn revision.\n     */\n    public static String getBuildRevision() {\n        return BUILD_REVISION;\n    }\n\n    /**\n     * Reports back the timestamp at which the version of GeoTools of built.\n     *\n     * @return The build timestamp.\n     */\n    public static String getBuildTimestamp() {\n        return BUILD_TIMESTAMP;\n    }\n\n    /**\n     * Returns the raw properties object containing all properties about this GeoTools build.\n     *\n     * <p>Example from the 14.3 release:\n     *\n     * <ul>\n     *   <li>version=14.3\n     *   <li>build.revision=2298d56000bef6f526b521a480316ea544c74571\n     *   <li>build.branch=rel_14.3\n     *   <li>build.timestamp=21-Mar-2016 21:30\n     * </ul>\n     */\n    public static Properties getBuildProperties() {\n        Properties props = new Properties();\n        props.putAll(PROPS);\n        return props;\n    }\n\n    /**\n     * Reports back the version of GeoTools being used.\n     *\n     * @return The current GeoTools version.\n     */\n    public static Version getVersion() {\n        return VERSION;\n    }\n\n    /**\n     * Lookup version for provided class.\n     *\n     * <p>Version number is determined by either:\n     *\n     * <ul>\n     *   <li>Use of jar naming convention, matching jars such as jts-1.13.jar\n     *   <li>Use of MANIFEST.MF (to check Implementation-Version, Project-Version)\n     *   <li>\n     *   <li>To assist\n     *\n     * @return Version (or null if unavailable)\n     */\n    public static Version getVersion(Class<?> type) {\n        final URL classLocation = classLocation(type);\n        String path = classLocation.toString();\n\n        // try and extract from maven jar naming convention\n        if (classLocation.getProtocol().equalsIgnoreCase(\"jar\")) {\n            String jarVersion = jarVersion(path);\n            if (jarVersion != null) {\n                return new Version(jarVersion);\n            }\n            // try manifest\n            try {\n                URL manifestLocation = manifestLocation(path);\n                Manifest manifest = new Manifest();\n                try (InputStream content = manifestLocation.openStream()) {\n                    manifest.read(content);\n                }\n                for (String attribute :\n                        new String[] {\n                            \"Implementation-Version\", \"Project-Version\", \"Specification-Version\"\n                        }) {\n                    String value = manifest.getMainAttributes().getValue(attribute);\n                    if (value != null) {\n                        return new Version(value);\n                    }\n                }\n            } catch (IOException e) {\n                // unavailable\n            }\n        }\n        String name = type.getName();\n        if (name.startsWith(\"org.geotools\") || name.startsWith(\"org.opengis\")) {\n            return GeoTools.getVersion();\n        }\n        return null;\n    }\n\n    /**\n     * Class location.\n     *\n     * @return class location\n     */\n    static URL classLocation(Class<?> type) {\n        return type.getResource(type.getSimpleName() + \".class\");\n    }\n\n    /**\n     * Determine jar version from static analysis of classLocation path.\n     *\n     * @return jar version, or null if unknown\n     */\n    static String jarVersion(String classLocation) {\n        if (classLocation.startsWith(\"jar:\") || classLocation.contains(\".jar!\")) {\n            String location = classLocation.substring(0, classLocation.lastIndexOf(\"!\") + 1);\n            String file = location.substring(location.lastIndexOf(File.pathSeparator) + 1);\n            int dash = file.lastIndexOf(\"-\");\n            int dot = file.lastIndexOf(\".jar\");\n            if (dash != -1 && dot != -1) {\n                String version = file.substring(dash + 1, dot);\n                if (version.startsWith(\"RC\") || version.equals(\"SNAPSHOT\")) {\n                    dash = file.lastIndexOf(\"-\", dash - 1);\n                    version = file.substring(dash + 1, dot);\n                }\n                return version;\n            }\n        }\n        // handle custom protocols such as jboss \"vfs:\" or OSGi \"resource\"\n        if (classLocation.contains(\".jar/\")) {\n            String location = classLocation.substring(0, classLocation.indexOf(\".jar/\") + 4);\n            int dash = location.lastIndexOf(\"-\");\n            int dot = location.lastIndexOf(\".jar\");\n\n            if (dash != -1 && dot != -1) {\n                return location.substring(dash + 1, dot);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Generate URL of MANIFEST.MF file for provided class location.\n     *\n     * @return MANIFEST.MF location, or null if unknown\n     */\n    static URL manifestLocation(String classLocation) {\n        URL url;\n        if (classLocation.startsWith(\"jar:\")) {\n            try {\n                url =\n                        new URL(\n                                classLocation.substring(0, classLocation.lastIndexOf(\"!\") + 1)\n                                        + \"/META-INF/MANIFEST.MF\");\n                return url;\n            } catch (MalformedURLException e) {\n                return null;\n            }\n        }\n        // handle custom protocols such as jboss \"vfs:\" or OSGi \"resource\"\n        if (classLocation.contains(\".jar/\")) {\n            String location = classLocation.substring(0, classLocation.indexOf(\".jar/\") + 4);\n            try {\n                url = new URL(location + \"/META-INF/MANIFEST.MF\");\n                return url;\n            } catch (MalformedURLException e) {\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Lookup the MANIFEST.MF for the provided class.\n     *\n     * <p>This can be used to quickly verify packaging information.\n     *\n     * @return MANIFEST.MF contents, please note contents may be empty when running from IDE\n     */\n    public static Manifest getManifest(Class<?> type) {\n        final URL classLocation = classLocation(type);\n        Manifest manifest = new Manifest();\n\n        URL manifestLocation = manifestLocation(classLocation.toString());\n        if (manifestLocation != null) {\n            try {\n                try (InputStream content = manifestLocation.openStream()) {\n                    manifest.read(content);\n                }\n            } catch (IOException ignore) {\n            }\n        }\n        if (manifest.getMainAttributes().isEmpty()) {\n            // must be running in IDE\n            String name = type.getName();\n            if (name.startsWith(\"org.geotools\")\n                    || name.startsWith(\"org.opengis\")\n                    || name.startsWith(\"net.opengis\")) {\n                String generated =\n                        \"Manifest-Version: 1.0\\n\" + \"Project-Version: \" + getVersion() + \"\\n\";\n\n                try {\n                    manifest.read(new ByteArrayInputStream(generated.getBytes()));\n                } catch (IOException e) {\n                }\n            }\n        }\n        return manifest;\n    }\n    /**\n     * Sets the global {@linkplain LoggerFactory logger factory}.\n     *\n     * <p>This method is the same as {@code Logging.GEOTOOLS.setLoggerFactory(factory)}. GeoTools\n     * ships with support for <A\n     * HREF=\"http://jakarta.apache.org/commons/logging/\">Commons-logging</A> and <A\n     * HREF=\"http://logging.apache.org/log4j/\">log4j</A>. This method exists to allow you supply\n     * your own implementation (this is sometimes required when using a GeoTools application in an\n     * exotic environment like Eclipse, OC4J or your application).\n     *\n     * @param factory The logger factory to use.\n     * @see Logging#setLoggerFactory(LoggerFactory)\n     * @since 2.4\n     */\n    public void setLoggerFactory(final LoggerFactory<?> factory) {\n        Logging.GEOTOOLS.setLoggerFactory(factory);\n    }\n\n    /**\n     * Initializes GeoTools for use. This convenience method performs various tasks (more may be\n     * added in the future), including setting up the {@linkplain java.util.logging Java logging\n     * framework} in one of the following states:\n     *\n     * <p>\n     *\n     * <ul>\n     *   <li>If the <A HREF=\"http://jakarta.apache.org/commons/logging/\">Commons-logging</A>\n     *       framework is available, then every logging message in the {@code org.geotools}\n     *       namespace sent to the Java {@linkplain java.util.logging.Logger logger} are redirected\n     *       to Commons-logging.\n     *   <li>Otherwise if the <A HREF=\"http://logging.apache.org/log4j\">Log4J</A> framework is\n     *       available, then every logging message in the {@code org.geotools} namespace sent to the\n     *       Java {@linkplain java.util.logging.Logger logger} are redirected to Log4J.\n     *   <li>Otherwise, the Java logging {@linkplain java.util.logging.Formatter formatter} for\n     *       console output is replaced by a {@linkplain org.geotools.util.logging.MonolineFormatter\n     *       monoline formatter}.\n     * </ul>\n     *\n     * <p>In addition, the {@linkplain #getDefaultHints default hints} are initialized to the\n     * specified {@code hints}.\n     *\n     * <p>Invoking this method is <strong>not</strong> required fpr the GeoTools library to\n     * function. It is just a convenience method for overwriting select Java and GeoTools default\n     * settings. Supplying these defaults is not desirable in all settings, such as writing test\n     * cases.\n     *\n     * <p>Example of typical invocation in a GeoServer environment:\n     *\n     * <pre><code>\n     * Hints hints = new Hints();\n     * hints.put({@linkplain Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER}, Boolean.TRUE);\n     * hints.put({@linkplain Hints#FORCE_AXIS_ORDER_HONORING}, \"http\");\n     * GeoTools.init(hints);\n     * </code></pre>\n     *\n     * @param hints The hints to use.\n     * @see Logging#setLoggerFactory(String)\n     * @see Logging#forceMonolineConsoleOutput\n     * @see Hints#putSystemDefault\n     * @see #getDefaultHints\n     */\n    public static void init(final Hints hints) {\n        init();\n        if (hints != null) {\n            // This will trigger fireConfigurationChanged()\n            Hints.putSystemDefault(hints);\n        }\n    }\n    /**\n     * Initializes GeoTools for use. This convenience method performs various tasks (more may be\n     * added in the future), including setting up the {@linkplain java.util.logging Java logging\n     * framework} in one of the following states:\n     *\n     * <p>\n     *\n     * <ul>\n     *   <li>If the <A HREF=\"http://jakarta.apache.org/commons/logging/\">Commons-logging</A>\n     *       framework is available, then every logging message in the {@code org.geotools}\n     *       namespace sent to the Java {@linkplain java.util.logging.Logger logger} are redirected\n     *       to Commons-logging.\n     *   <li>Otherwise if the <A HREF=\"http://logging.apache.org/log4j\">Log4J</A> framework is\n     *       available, then every logging message in the {@code org.geotools} namespace sent to the\n     *       Java {@linkplain java.util.logging.Logger logger} are redirected to Log4J.\n     *   <li>Otherwise, the Java logging {@linkplain java.util.logging.Formatter formatter} for\n     *       console output is replaced by a {@linkplain org.geotools.util.logging.MonolineFormatter\n     *       monoline formatter}.\n     * </ul>\n     *\n     * <p>Invoking this method is <strong>not</strong> required fpr the GeoTools library to\n     * function. It is just a convenience method for overwriting select Java and GeoTools default\n     * settings. Supplying these defaults is not desirable in all settings, such as writing test\n     * cases.\n     *\n     * <p>\n     *\n     * @see Logging#setLoggerFactory(String)\n     * @see Logging#forceMonolineConsoleOutput\n     * @see Hints#putSystemDefault\n     * @see #getDefaultHints\n     */\n    public static void init() {\n        final Logging log = Logging.GEOTOOLS;\n        try {\n            log.setLoggerFactory(\"org.geotools.util.logging.CommonsLoggerFactory\");\n        } catch (ClassNotFoundException commonsException) {\n            try {\n                log.setLoggerFactory(\"org.geotools.util.logging.Log4JLoggerFactory\");\n            } catch (ClassNotFoundException log4jException) {\n                // Nothing to do, we already tried our best.\n            }\n        }\n        // If java logging is used, force monoline console output.\n        if (log.getLoggerFactory() == null) {\n            log.forceMonolineConsoleOutput();\n        }\n    }\n    /**\n     * Provides GeoTools with the JNDI context for resource lookup.\n     *\n     * @param initialContext The initial context to use for JNDI lookup\n     * @see #jndiLookup(String)\n     * @since 2.4\n     */\n    public static void init(final InitialContext initialContext) {\n        synchronized (GeoTools.class) {\n            context = initialContext;\n        }\n        fireConfigurationChanged();\n    }\n\n    /**\n     * Scans {@linkplain System#getProperties system properties} for any property keys defined in\n     * this class, and add their values to the specified map of hints. For example if the {@value\n     * #FORCE_LONGITUDE_FIRST_AXIS_ORDER} system property is defined, then the {@link\n     * Hints#FORCE_LONGITUDE_FIRST_AXIS_ORDER FORCE_LONGITUDE_FIRST_AXIS_ORDER} hint will be added\n     * to the set of hints.\n     *\n     * @return {@code true} if at least one hint changed as a result of this scan, or {@code false}\n     *     otherwise.\n     */\n    static boolean scanForSystemHints(final Map<RenderingHints.Key, Object> hints) {\n        boolean changed = false;\n\n        for (final Map.Entry<String, RenderingHints.Key> entry : BINDINGS.entrySet()) {\n            final String propertyKey = entry.getKey();\n            final String property;\n            try {\n                property = System.getProperty(propertyKey);\n                if (property == null) {\n                    continue;\n                }\n            } catch (SecurityException e) {\n                unexpectedException(e);\n                continue;\n            }\n            /*\n             * Converts the system property value from String to Object (java.lang.Boolean\n             * or java.lang.Number). We perform this conversion only if the key is exactly\n             * of kind Hints.Key,  not a subclass like ClassKey, in order to avoid useless\n             * class loading on  'getValueClass()'  method invocation (ClassKey don't make\n             * sense for Boolean and Number, which are the only types that we convert here).\n             */\n            Object value = property;\n            final RenderingHints.Key hintKey = entry.getValue();\n            if (hintKey.getClass().equals(Hints.Key.class)) {\n                final Class<?> type = ((Hints.Key) hintKey).getValueClass();\n                if (type.equals(Boolean.class)) {\n                    value = Boolean.valueOf(property);\n                } else if (Number.class.isAssignableFrom(type))\n                    try {\n                        value = Classes.valueOf(type, property);\n                    } catch (NumberFormatException e) {\n                        unexpectedException(e);\n                        continue;\n                    }\n            }\n            final Object old;\n            try {\n                old = hints.put(hintKey, value);\n            } catch (IllegalArgumentException e) {\n                // The property value is illegal for this hint.\n                unexpectedException(e);\n                continue;\n            }\n            changed = changed || !Utilities.equals(old, value);\n        }\n        return changed;\n    }\n\n    /**\n     * Logs an exception as if it originated from {@link Hints#scanSystemProperties}, since it is\n     * the public API that may invokes this method.\n     */\n    private static void unexpectedException(final Exception exception) {\n        Logging.unexpectedException(Hints.class, \"scanSystemProperties\", exception);\n    }\n\n    /**\n     * Returns the default set of hints used for the various utility classes. This default set is\n     * determined by:\n     *\n     * <p>\n     *\n     * <ul>\n     *   <li>The {@linplain System#getProperties system properties} available. Some property keys\n     *       are enumerated in the {@link GeoTools} class.\n     *   <li>Any hints added by call to the {@link Hints#putSystemDefault} or {@link #init} method.\n     * </ul>\n     *\n     * <p><b>Long term plan:</b> We would like to transition the utility classes to being injected\n     * with their required factories, either by taking Hints as part of their constructor, or\n     * otherwise. Making this change would be a three step process 1) create instance methods for\n     * each static final class method 2) create an singleton instance of the class 3) change each\n     * static final class method into a call to the singleton. With this in place we could then\n     * encourage client code to make use of utility class instances before eventually retiring the\n     * static final methods.\n     *\n     * @return A copy of the default hints. It is safe to add to it.\n     */\n    public static Hints getDefaultHints() {\n        return Hints.getDefaults(false);\n    }\n    /** Used to combine provided hints with global GeoTools defaults. */\n    public static Hints addDefaultHints(final Hints hints) {\n        final Hints completed = getDefaultHints();\n        if (hints != null) {\n            completed.add(hints);\n        }\n        return completed;\n    }\n\n    /**\n     * Returns the default entity resolver, used to configure {@link SAXParser}.\n     *\n     * @param hints An optional set of hints, or {@code null} if none, see {@link\n     *     Hints#ENTITY_RESOLVER}.\n     * @return An entity resolver (never {@code null})\n     */\n    public static EntityResolver getEntityResolver(Hints hints) {\n        if (hints == null) {\n            hints = getDefaultHints();\n        }\n        if (hints.containsKey(Hints.ENTITY_RESOLVER)) {\n            Object hint = hints.get(Hints.ENTITY_RESOLVER);\n            if (hint == null) {\n                return NullEntityResolver.INSTANCE;\n            } else if (hint instanceof EntityResolver) {\n                return (EntityResolver) hint;\n            } else if (hint instanceof String) {\n                String className = (String) hint;\n                return instantiate(\n                        className, EntityResolver.class, PreventLocalEntityResolver.INSTANCE);\n            }\n        }\n        return PreventLocalEntityResolver.INSTANCE;\n    }\n\n    /**\n     * Create instance of className (or access singleton INSTANCE field).\n     *\n     * @param className Class name to instantiate\n     * @param type Class of object created\n     * @param defaultValue Default to be provided, may be null\n     * @return EntityResolver, defaults to {@link PreventLocalEntityResolver#INSTANCE} if\n     *     unavailable.\n     */\n    static <T, D extends T> T instantiate(String className, Class<T> type, D defaultValue) {\n        if (className == null) {\n            return defaultValue;\n        }\n        final Logger LOGGER = Logging.getLogger(GeoTools.class);\n        try {\n            Class<?> kind = Class.forName(className);\n            // step 1 look for instance field\n            for (Field field : kind.getDeclaredFields()) {\n                int modifier = field.getModifiers();\n                if (\"INSTANCE\".equals(field.getName())\n                        && Modifier.isStatic(modifier)\n                        && Modifier.isPublic(modifier)) {\n                    try {\n                        Object value = field.get(null);\n                        if (value != null && value instanceof EntityResolver) {\n                            return type.cast(value);\n                        } else {\n                            LOGGER.log(\n                                    Level.FINER,\n                                    \"Unable to use ENTITY_RESOLVER: \" + className + \".INSTANCE\");\n                        }\n                    } catch (Throwable t) {\n                        LOGGER.log(\n                                Level.FINER,\n                                \"Unable to instantiate ENTITY_RESOLVER: \" + className + \".INSTANCE\",\n                                t);\n                    }\n                    return defaultValue;\n                }\n            }\n            // step 2 no argument constructor\n            try {\n                Object value = kind.getDeclaredConstructor().newInstance();\n                if (type.isInstance(value)) {\n                    return type.cast(value);\n                }\n            } catch (InstantiationException\n                    | IllegalAccessException\n                    | NoSuchMethodException\n                    | InvocationTargetException e) {\n                LOGGER.log(\n                        Level.FINER, \"Unable to instantiate ENTITY_RESOLVER: \" + e.getMessage(), e);\n            }\n        } catch (ClassNotFoundException notFound) {\n            LOGGER.log(\n                    Level.FINER,\n                    \"Unable to instantiate ENTITY_RESOLVER: \" + notFound.getMessage(),\n                    notFound);\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Returns the default initial context.\n     *\n     * @return The initial context (never {@code null}).\n     * @throws NamingException if the initial context can't be created.\n     * @deprecated Please use {@link #jndiLookup(String)} instead, or provide an {@link\n     *     InitialContext} to the {@link #init(InitialContext)} method and use it directly.\n     */\n    @Deprecated\n    public static synchronized InitialContext getInitialContext() throws NamingException {\n        Logging.getLogger(GeoTools.class)\n                .severe(\n                        \"Please don't use GeoTools.getInitialContext(), perform lookups using GeoTools.jndiLookup(s) instead.\");\n        return getJNDIContext();\n    }\n\n    private static synchronized InitialContext getJNDIContext() throws NamingException {\n        if (context == null) {\n            try {\n                context = new InitialContext();\n            } catch (Exception e) {\n                throw handleException(e);\n            }\n        }\n        return context;\n    }\n\n    /**\n     * Checks if JNDI is available, either because it was initialized, or because it was possible to\n     * create one.\n     */\n    public static boolean isJNDIAvailable() {\n        try {\n            // see if we have a context, or can create one\n            return getJNDIContext() != null;\n        } catch (NamingException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Sets up a function that will be called to validate the JNDI lookups. If not set, the\n     * DEFAULT_JNDI_VALIDATOR is used. The function may want to log the reason why a given name was\n     * denied lookup.\n     *\n     * @param validator A function returning true if the lookups are meant to be performed, false\n     *     otherwise.\n     */\n    public static void setJNDINameValidator(Predicate<String> validator) {\n        jndiValidator = validator;\n    }\n\n    /**\n     * Looks up an object from the JNDI {@link InitialContext}. By default, it only allows lookups\n     * with no scheme, or inside the <code>java</code> scheme. One can set up a custom name\n     * validation routine using\n     *\n     * @param name\n     * @return\n     * @throws NamingException\n     */\n    public static Object jndiLookup(String name) throws NamingException {\n        if (!jndiValidator.test(name)) return null;\n        return getJNDIContext().lookup(name);\n    }\n\n    private static NamingException handleException(Exception e) {\n        final Logger LOGGER = Logging.getLogger(GeoTools.class);\n        final String propFileName = \"jndi.properties\";\n\n        if (LOGGER.isLoggable(Level.WARNING)) {\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"Error while retriving Initial Context.\\n\\n\")\n                    .append(\"Exception: \")\n                    .append(e.getMessage())\n                    .append(\"\\n\");\n\n            Object contextFactory = System.getProperty(Context.INITIAL_CONTEXT_FACTORY);\n            sb.append(\"Factory could be taken from System property: \")\n                    .append(Context.INITIAL_CONTEXT_FACTORY)\n                    .append(\"=\")\n                    .append(contextFactory == null ? \"\" : (String) contextFactory)\n                    .append(\"\\n\");\n\n            Enumeration<URL> urls =\n                    AccessController.doPrivileged(\n                            new PrivilegedAction<Enumeration<URL>>() {\n                                @Override\n                                public Enumeration<URL> run() {\n                                    try {\n                                        return ClassLoader.getSystemResources(propFileName);\n                                    } catch (IOException e) {\n                                        return null;\n                                    }\n                                }\n                            });\n            if (urls != null) {\n                sb.append(\"Or from these property files:\\n\");\n                while (urls.hasMoreElements()) {\n                    sb.append(urls.nextElement().getPath()).append(\"\\n\");\n                }\n                sb.append(\"\\n\");\n            }\n\n            String javaHome =\n                    AccessController.doPrivileged(\n                            new PrivilegedAction<String>() {\n                                @Override\n                                public String run() {\n                                    try {\n                                        String javahome = System.getProperty(\"java.home\");\n                                        if (javahome == null) {\n                                            return null;\n                                        }\n                                        String pathname =\n                                                javahome\n                                                        + java.io.File.separator\n                                                        + \"lib\"\n                                                        + java.io.File.separator\n                                                        + propFileName;\n                                        return pathname;\n                                    } catch (Exception e) {\n                                        return null;\n                                    }\n                                }\n                            });\n            if (javaHome != null) {\n                sb.append(\"Or from a file specified by system property java.home:\\n\")\n                        .append(javaHome)\n                        .append(\"\\n\");\n            }\n            LOGGER.log(Level.WARNING, sb.toString());\n        }\n        NamingException throwing = new NamingException(\"Couldn't get Initial context.\");\n        throwing.setRootCause(e);\n        return throwing;\n    }\n\n    /**\n     * Clears the initial context (closes it if not null)\n     *\n     * @since 15.0\n     */\n    public static synchronized void clearInitialContext() throws NamingException {\n        if (context != null) {\n            context.close();\n        }\n        context = null;\n    }\n\n    /**\n     * Converts a GeoTools name to the syntax used by the {@linkplain #getInitialContext GeoTools\n     * JNDI context}. Names may be constructed in a variety of ways depending on the implementation\n     * of {@link InitialContext}. GeoTools uses {@code \"jdbc:EPSG\"} internally, but many\n     * implementaitons use the form {@code \"jdbc/EPSG\"}. Calling this method before use will set the\n     * name right.\n     *\n     * @param name Name of the form {@code \"jdbc:EPSG\"}, or {@code null}.\n     * @return Name fixed up with {@link Context#composeName(String,String)}, or {@code null} if the\n     *     given name was null.\n     * @since 2.4\n     * @deprecated With no replacement, GeoTools now uses JNDI lookups as instructed in {@link\n     *     #jndiLookup(String)}, but does not put any object in the contex, the downstream\n     *     application should do it if necessary instead.\n     */\n    @Deprecated\n    public static String fixName(final String name) {\n        return fixName(null, name, null);\n    }\n\n    /**\n     * Converts a GeoTools name to the syntax used by the specified JNDI context. This method is\n     * similar to {@link #fixName(String)}, but uses the specified context instead of the GeoTools\n     * one.\n     *\n     * @param context The context to use, or {@code null} if none.\n     * @param name Name of the form {@code \"jdbc:EPSG\"}, or {@code null}.\n     * @return Name fixed up with {@link Context#composeName(String,String)}, or {@code null} if the\n     *     given name was null.\n     * @since 2.4\n     * @deprecated With no replacement, GeoTools now uses JNDI lookups as instructed in {@link *\n     *     #jndiLookup(String)}, but does not put any object in the contex, the downstream *\n     *     application should do it if necessary instead.\n     */\n    @Deprecated\n    public static String fixName(final Context context, final String name) {\n        return (context != null) ? fixName(context, name, null) : name;\n    }\n\n    /**\n     * Implementation of {@code fixName} method. If the context is {@code null}, then the\n     * {@linkplain #getInitialContext GeoTools initial context} will be fetch only when first\n     * needed.\n     *\n     * @deprecated With no replacement, GeoTools now uses JNDI lookups as instructed in {@link *\n     *     #jndiLookup(String)}, but does not put any object in the contex, the downstream *\n     *     application should do it if necessary instead.\n     */\n    @Deprecated\n    private static String fixName(Context context, final String name, final Hints hints) {\n        String fixed = null;\n        if (name != null) {\n            final StringTokenizer tokens = new StringTokenizer(name, \":/\");\n            while (tokens.hasMoreTokens()) {\n                final String part = tokens.nextToken();\n                if (fixed == null) {\n                    fixed = part;\n                } else\n                    try {\n                        if (context == null) {\n                            context = getInitialContext();\n                        }\n                        fixed = context.composeName(fixed, part);\n                    } catch (NamingException e) {\n                        Logging.unexpectedException(GeoTools.class, \"fixName\", e);\n                        return name;\n                    }\n            }\n        }\n        return fixed;\n    }\n\n    /**\n     * Adds an alternative way to search for factory implementations. {@link FactoryRegistry} has a\n     * default mechanism bundled in it, which uses the content of all {@code META-INF/services}\n     * directories found on the classpath. This {@code addFactoryIteratorProvider} method allows to\n     * specify additional discovery algorithms. It may be useful in the context of some frameworks\n     * that use the <cite>constructor injection</cite> pattern, like the <a\n     * href=\"http://www.springframework.org/\">Spring framework</a>.\n     *\n     * @param provider A new provider for factory iterators.\n     */\n    public static void addFactoryIteratorProvider(final FactoryIteratorProvider provider) {\n        FactoryIteratorProviders.addFactoryIteratorProvider(provider);\n    }\n\n    /**\n     * Removes a provider that was previously {@linkplain #addFactoryIteratorProvider added}. Note\n     * that factories already obtained from the specified provider will not be {@linkplain\n     * FactoryRegistry#deregisterFactory deregistered} by this method.\n     *\n     * @param provider The provider to remove.\n     */\n    public static void removeFactoryIteratorProvider(final FactoryIteratorProvider provider) {\n        FactoryIteratorProviders.removeFactoryIteratorProvider(provider);\n    }\n\n    /**\n     * Adds the specified listener to the list of objects to inform when system-wide configuration\n     * changed.\n     *\n     * @param listener The listener to add.\n     */\n    public static void addChangeListener(final ChangeListener listener) {\n        removeChangeListener(listener); // Ensure singleton.\n        LISTENERS.add(ChangeListener.class, listener);\n    }\n\n    /**\n     * Removes the specified listener from the list of objects to inform when system-wide\n     * configuration changed.\n     *\n     * @param listener The listener to remove.\n     */\n    public static void removeChangeListener(final ChangeListener listener) {\n        LISTENERS.remove(ChangeListener.class, listener);\n    }\n\n    /** Informs every listeners that system-wide configuration changed. */\n    public static void fireConfigurationChanged() {\n        final ChangeEvent event = new ChangeEvent(GeoTools.class);\n        final Object[] listeners = LISTENERS.getListenerList();\n        for (int i = 0; i < listeners.length; i += 2) {\n            if (listeners[i] == ChangeListener.class) {\n                ((ChangeListener) listeners[i + 1]).stateChanged(event);\n            }\n        }\n    }\n\n    /**\n     * Adds a class loader to be included in the list of class loaders that are used to locate\n     * GeoTools plug-ins.\n     *\n     * <p>Client code that calls this method may also need to call {@link\n     * FactoryRegistry#scanForPlugins()} on any existing registry to force it to clear its cache and\n     * use the added class loader to locate plugins.\n     *\n     * @param classLoader The class loader.\n     */\n    public static void addClassLoader(ClassLoader classLoader) {\n        addedClassLoaders.add(classLoader);\n        fireConfigurationChanged();\n    }\n\n    /** Returns the class loaders added via {@link #addClassLoader(ClassLoader)}. */\n    static Set<ClassLoader> getClassLoaders() {\n        return addedClassLoaders;\n    }\n\n    /**\n     * Reports the GeoTools {@linkplain #getVersion version} number to the {@linkplain System#out\n     * standard output stream}.\n     *\n     * @param args Command line arguments.\n     */\n    public static void main(String... args) {\n        final Arguments arguments = new Arguments(args);\n        arguments.getRemainingArguments(0);\n        arguments.out.print(\"GeoTools version \");\n        arguments.out.println(getVersion());\n        final Hints hints = getDefaultHints();\n        if (hints != null && !hints.isEmpty()) {\n            arguments.out.println(hints);\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2005-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.util.factory;\n\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Stream;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\n/**\n * Tests {@link org.geotools.util.factory.FactoryRegistry} implementation.\n *\n * @version $Id$\n * @author Martin Desruisseaux\n */\npublic final class FactoryRegistryTest {\n    /**\n     * Ensures that class {@link org.geotools.util.factory.Hints} is loaded before {@link\n     * DummyFactory}. It is not needed for normal execution, but Maven seems to mess with class\n     * loaders.\n     */\n    @Before\n    public void ensureHintsLoaded() {\n        assertNotNull(Hints.DATUM_FACTORY.toString());\n    }\n\n    /**\n     * Creates the factory registry to test. The tests performed in this method are more J2SE tests\n     * than Geotools implementation tests. We basically just ensure that we have setup the service\n     * registry properly.\n     *\n     * <p>Factories are specified in arguments as {@link org.geotools.util.factory.Factory} objects\n     * in order to avoid the {@link DummyClass} to be initialized before {@link\n     * org.geotools.util.factory.Hints}. This is not a problem for normal execution, but Maven seems\n     * to mess with class loaders.\n     *\n     * @param creator {@code true} if the registry should be an instance of {@link\n     *     org.geotools.util.factory.FactoryCreator}.\n     */\n    @SuppressWarnings(\"PMD.UnusedPrivateMethod\") // PMD getting confused here?\n    private FactoryRegistry getRegistry(\n            final boolean creator,\n            final Factory factory1,\n            final Factory factory2,\n            final Factory factory3) {\n        @SuppressWarnings(\"unchecked\")\n        final Set<Class<?>> categories = Collections.singleton(DummyFactory.class);\n        // The above line fails without the cast, I don't know why...\n        final FactoryRegistry registry;\n        if (creator) {\n            registry = new FactoryCreator(categories);\n        } else {\n            registry = new FactoryRegistry(categories);\n        }\n        registry.registerFactory(factory1);\n        registry.registerFactory(factory2);\n        registry.registerFactory(factory3);\n        assertTrue(\n                registry.setOrdering(\n                        DummyFactory.class, (DummyFactory) factory1, (DummyFactory) factory2));\n        assertTrue(\n                registry.setOrdering(\n                        DummyFactory.class, (DummyFactory) factory2, (DummyFactory) factory3));\n        assertTrue(\n                registry.setOrdering(\n                        DummyFactory.class, (DummyFactory) factory1, (DummyFactory) factory3));\n\n        final List<?> factories =\n                registry.getFactories(DummyFactory.class, null, null).collect(toList());\n        assertTrue(factories.contains(factory1));\n        assertTrue(factories.contains(factory2));\n        assertTrue(factories.contains(factory3));\n        assertTrue(factories.indexOf(factory1) < factories.indexOf(factory2));\n        assertTrue(factories.indexOf(factory2) < factories.indexOf(factory3));\n        return registry;\n    }\n\n    /**\n     * Tests the {@link org.geotools.util.factory.FactoryRegistry#getProvider} method. Note that the\n     * tested method do not create any new factory. If no registered factory matching the hints is\n     * found, an exception is expected. <br>\n     * <br>\n     * Three factories are initially registered: factory #1, #2 and #3.\n     *\n     * <p>Factory #1 has no dependency. Factory #2 uses factory #1. Factory #3 uses factory #2,\n     * which implies an indirect dependency to factory #1.\n     *\n     * <p>Additionnaly, factory #1 uses a KEY_INTERPOLATION hint.\n     */\n    @Test\n    public void testGetProvider() {\n        final Hints.Key key = DummyFactory.DUMMY_FACTORY;\n        final DummyFactory factory1 = new DummyFactory.Example1();\n        final DummyFactory factory2 = new DummyFactory.Example2();\n        final DummyFactory factory3 = new DummyFactory.Example3();\n        final FactoryRegistry registry = getRegistry(false, factory1, factory2, factory3);\n        // ------------------------------------------------\n        //     PART 1: SIMPLE HINT (not a Factory hint)\n        // ------------------------------------------------\n        /*\n         * No hints. The fist factory should be selected.\n         */\n        Hints hints = null;\n        DummyFactory factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"No preferences; should select the first factory. \", factory1, factory);\n        /*\n         * A hint compatible with one of our factories. Factory #1 declares explicitly that it uses\n         * a bilinear interpolation, which is compatible with user's hints. All other factories are\n         * indifferent. Since factory #1 is the first one in the list, it should be selected.\n         */\n        hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BILINEAR);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"First factory matches; it should be selected. \", factory1, factory);\n        /*\n         * A hint incompatible with all our factories. Factory #1 is the only one to defines\n         * explicitly a KEY_INTERPOLATION hint, but all other factories depend on factory #1\n         * either directly (factory #2) or indirectly (factory #3, which depends on #2).\n         */\n        hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BICUBIC);\n        try {\n            factory = registry.getFactory(DummyFactory.class, null, hints, key);\n            fail(\"Found factory \" + factory + \", while the hint should have been rejected.\");\n        } catch (FactoryNotFoundException exception) {\n            // This is the expected exception. Continue...\n        }\n        /*\n         * Add a new factory implementation, and try again with exactly the same hints\n         * than the previous test. This time, the new factory should be selected since\n         * this one doesn't have any dependency toward factory #1.\n         */\n        final DummyFactory factory4 = new DummyFactory.Example4();\n        registry.registerFactory(factory4);\n        assertTrue(registry.setOrdering(DummyFactory.class, factory1, factory4));\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"The new factory should be selected. \", factory4, factory);\n\n        // ----------------------------\n        //     PART 2: FACTORY HINT\n        // ----------------------------\n        /*\n         * Trivial case: user gives explicitly a factory instance.\n         */\n        DummyFactory explicit = new DummyFactory.Example3();\n        hints = new Hints(DummyFactory.DUMMY_FACTORY, explicit);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"The user-specified factory should have been selected. \", explicit, factory);\n        /*\n         * User specifies the expected implementation class rather than an instance.\n         */\n        hints = new Hints(DummyFactory.DUMMY_FACTORY, DummyFactory.Example2.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Factory of class #2 were requested. \", factory2, factory);\n        /*\n         * Same as above, but with classes specified in an array.\n         */\n        hints =\n                new Hints(\n                        DummyFactory.DUMMY_FACTORY,\n                        new Class<?>[] {DummyFactory.Example3.class, DummyFactory.Example2.class});\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Factory of class #3 were requested. \", factory3, factory);\n        /*\n         * The following hint should be ignored by factory #1, since this factory doesn't have\n         * any dependency to the INTERNAL_FACTORY hint. Since factory #1 is first in the ordering,\n         * it should be selected.\n         */\n        hints = new Hints(DummyFactory.INTERNAL_FACTORY, DummyFactory.Example2.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Expected factory #1. \", factory1, factory);\n        /*\n         * If the user really wants some factory that do have a dependency to factory #2, he should\n         * specifies in a DUMMY_FACTORY hint the implementation classes (or a common super-class or\n         * interface) that do care about the INTERNAL_FACTORY hint. Note that this extra step should\n         * not be a big deal in most real application, because:\n         *\n         *  1) Either all implementations have this dependency (for example it would be\n         *     unusual to see a DatumAuthorityFactory without a DatumFactory dependency);\n         *\n         *  2) or the user really know the implementation he wants (for example if he specifies a\n         *     JTS CoordinateSequenceFactory, he probably wants to use the JTS GeometryFactory).\n         *\n         * In the particular case of this test suite, this extra step would not be needed\n         * neither if factory #1 was last in the ordering rather than first.\n         */\n        final Hints implementations =\n                new Hints(\n                        DummyFactory.DUMMY_FACTORY,\n                        new Class[] {DummyFactory.Example2.class, DummyFactory.Example3.class});\n        /*\n         * Now search NOT for factory #1, but rather for a factory using #1 internally.\n         * This is the case of factory #2.\n         */\n        hints = new Hints(DummyFactory.INTERNAL_FACTORY, DummyFactory.Example1.class);\n        hints.add(implementations);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Expected a factory using #1 internally. \", factory2, factory);\n    }\n\n    /**\n     * Tests the {@link org.geotools.util.factory.FactoryCreator#getProvider} method. This test\n     * tries again the cases that was expected to throws an exception in {@link #testGetProvider}.\n     * But now, those cases are expected to creates automatically new factory instances instead of\n     * throwing an exception.\n     */\n    @Test\n    public void testCreateProvider() {\n        final Hints.Key key = DummyFactory.DUMMY_FACTORY;\n        final DummyFactory factory1 = new DummyFactory.Example1();\n        final DummyFactory factory2 = new DummyFactory.Example2();\n        final DummyFactory factory3 = new DummyFactory.Example3();\n        final FactoryRegistry registry = getRegistry(true, factory1, factory2, factory3);\n        /*\n         * Same tests than above (at least some of them).\n         * See comments in 'testGetProvider()' for explanation.\n         */\n        Hints hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BILINEAR);\n        DummyFactory factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"First factory matches; it should be selected. \", factory1, factory);\n\n        hints = new Hints(DummyFactory.DUMMY_FACTORY, DummyFactory.Example2.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\"Factory of class #2 were requested. \", factory2, factory);\n        /*\n         * The following case was throwing an exception in testGetProvider(). It should fails again\n         * here, but for a different reason. FactoryCreator is unable to creates automatically a new\n         * factory instance, since we gave no implementation hint and no registered factory have a\n         * constructor expecting a Hints argument.\n         */\n        hints = new Hints(Hints.KEY_INTERPOLATION, Hints.VALUE_INTERPOLATION_BICUBIC);\n        try {\n            factory = registry.getFactory(DummyFactory.class, null, hints, key);\n            fail(\n                    \"Found or created factory \"\n                            + factory\n                            + \", while it should not have been allowed.\");\n        } catch (FactoryNotFoundException exception) {\n            // This is the expected exception. Continue...\n        }\n        /*\n         * Register a DummyFactory with a constructor expecting a Hints argument, and try again\n         * with the same hints. Now it should creates a new factory instance, because we are using\n         * FactoryCreator instead of FactoryRegistry and an appropriate constructor is found.\n         * Note that an AssertionFailedError should be thrown if the no-argument constructor of\n         * Example5 is invoked, since the constructor with a Hints argument should have priority.\n         */\n        final DummyFactory factory5 = new DummyFactory.Example5(null);\n        registry.registerFactory(factory5);\n        assertTrue(registry.setOrdering(DummyFactory.class, factory1, factory5));\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertSame(\n                \"An instance of Factory #5 should have been created.\",\n                factory5.getClass(),\n                factory.getClass());\n        assertNotSame(\"A NEW instance of Factory #5 should have been created\", factory5, factory);\n        /*\n         * Tries again with a class explicitly specified as an implementation hint.\n         * It doesn't matter if this class is registered or not.\n         */\n        hints.put(DummyFactory.DUMMY_FACTORY, DummyFactory.Example4.class);\n        factory = registry.getFactory(DummyFactory.class, null, hints, key);\n        assertEquals(\n                \"An instance of Factory #4 should have been created.\",\n                DummyFactory.Example4.class,\n                factory.getClass());\n    }\n\n    @Ignore\n    @Test\n    public void testLookupWithExtendedClasspath() throws IOException {\n        URL url = getClass().getResource(\"foo.jar\");\n        assertNotNull(url);\n\n        FactoryRegistry reg = new FactoryCreator(DummyInterface.class);\n        Stream<DummyInterface> factories = reg.getFactories(DummyInterface.class, false);\n        assertFalse(factories.findAny().isPresent());\n\n        try (URLClassLoader cl = new URLClassLoader(new URL[] {url})) {\n            GeoTools.addClassLoader(cl);\n            reg.scanForPlugins();\n\n            Set<String> classes =\n                    reg.getFactories(DummyInterface.class, false)\n                            .map(factory -> factory.getClass().getName())\n                            .collect(toSet());\n\n            assertEquals(2, classes.size());\n            assertTrue(classes.contains(\"pkg.Foo\"));\n            assertTrue(classes.contains(\"org.geotools.util.factory.DummyInterfaceImpl\"));\n        }\n    }\n\n    /** Tests for GEOT-2817 */\n    @Test\n    public void testLookupWithSameFactoryInTwoClassLoaders()\n            throws IOException, ClassNotFoundException {\n        // create url to this project's classes\n        URL projectClasses = getClass().getResource(\"/\");\n        // create 2 classloaders with parent null to avoid delegation to the system class loader !\n        // this occurs in reality with split class loader hierarchies (e.g. GWT plugin and\n        // some application servers)\n        try (URLClassLoader cl1 = new URLClassLoader(new URL[] {projectClasses}, null);\n                URLClassLoader cl2 = new URLClassLoader(new URL[] {projectClasses}, null)) {\n            // extend with both class loaders\n            GeoTools.addClassLoader(cl1);\n            GeoTools.addClassLoader(cl2);\n            // code below was throwing ClassCastException (before java 7) prior to adding\n            // isAssignableFrom() check (line 862)\n            for (int i = 0; i < 2; i++) {\n                ClassLoader loader = (i == 0 ? cl1 : cl2);\n                Class dummy = loader.loadClass(\"org.geotools.util.factory.DummyInterface\");\n                FactoryRegistry reg = new FactoryCreator(dummy);\n                reg.scanForPlugins();\n                // we are mocking with two class loaders, trying to make it type safe will make\n                // the factory fail to load the factory\n                @SuppressWarnings(\"unchecked\")\n                Optional factory = reg.getFactories(dummy, false).findFirst();\n                assertTrue(factory.isPresent());\n                // factory class should have same class loader as interface\n                assertSame(loader, factory.get().getClass().getClassLoader());\n            }\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2007-2016, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.util.factory;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\nimport java.awt.RenderingHints;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.jar.Manifest;\nimport javax.media.jai.JAI;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport org.apache.commons.logging.LogFactory;\nimport org.geotools.util.NullEntityResolver;\nimport org.geotools.util.PreventLocalEntityResolver;\nimport org.geotools.util.Version;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mockito;\nimport org.opengis.filter.Filter;\nimport org.xml.sax.EntityResolver;\n\n/**\n * Tests {@link org.geotools.util.factory.GeoTools}.\n *\n * @since 2.4\n * @version $Id$\n * @author Jody Garnett\n * @author Martin Desruisseaux\n */\npublic final class GeoToolsTest {\n\n    @Before\n    public void clearJNDI() throws NamingException {\n        GeoTools.clearInitialContext();\n        GeoTools.setJNDINameValidator(GeoTools.DEFAULT_JNDI_VALIDATOR);\n    }\n\n    /** Makes sures that J2SE 1.4 assertions are enabled. */\n    @Test\n    public void testAssertionEnabled() {\n        assertTrue(\"Assertions not enabled.\", GeoToolsTest.class.desiredAssertionStatus());\n    }\n\n    /**\n     * Tests the removal of keys from a hashmap. Required for {@link\n     * org.geotools.util.factory.FactoryRegistry} working.\n     */\n    @Test\n    public void testHintsKey() {\n        final Hints hints = new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE);\n        assertFalse(hints.isEmpty());\n\n        Map<RenderingHints.Key, Object> map = new HashMap<>();\n        assertNull(map.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE));\n        map = Collections.unmodifiableMap(map);\n        assertFalse(map.isEmpty());\n\n        final Hints remaining = new Hints(hints);\n        assertTrue(remaining.keySet().removeAll(map.keySet()));\n        assertTrue(remaining.isEmpty());\n    }\n\n    /** Tests addition of custom hints. */\n    @Test\n    public void testMyHints() {\n        Hints hints = GeoTools.getDefaultHints();\n        assertTrue(hints.isEmpty());\n        assertNull(Hints.putSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE));\n        try {\n            hints = GeoTools.getDefaultHints();\n            assertNotNull(hints);\n            assertFalse(hints.isEmpty());\n            assertEquals(1, hints.size());\n            final Object value = hints.get(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER);\n            assertTrue(value instanceof Boolean);\n            assertFalse(((Boolean) value).booleanValue());\n            /*\n             * Tests the toString() method.\n             */\n            String text = hints.toString().trim();\n            assertTrue(text.matches(\"Hints:\\\\s+FORCE_LONGITUDE_FIRST_AXIS_ORDER = false\"));\n\n            assertEquals(\n                    hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.TRUE), Boolean.FALSE);\n            text = hints.toString().trim();\n            assertTrue(text.matches(\"Hints:\\\\s+FORCE_LONGITUDE_FIRST_AXIS_ORDER = true\"));\n\n            assertEquals(hints.remove(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER), Boolean.TRUE);\n            text = hints.toString().trim();\n            assertTrue(\n                    text.matches(\n                            \"Hints:\\\\s+System defaults:\\\\s+FORCE_LONGITUDE_FIRST_AXIS_ORDER = false\"));\n        } finally {\n            assertNotNull(Hints.removeSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER));\n        }\n        assertTrue(GeoTools.getDefaultHints().isEmpty());\n    }\n\n    /** Test Manifest version lookup */\n    @Test\n    public void testManifest() {\n        // jar manifest lookup\n        Manifest jai = GeoTools.getManifest(JAI.class);\n        assertFalse(\"manifest metadata\", jai.getMainAttributes().isEmpty());\n\n        // this should always be generated during a maven or ide build\n        Manifest metadata = GeoTools.getManifest(GeoTools.class);\n        assertFalse(\"manifest metadata\", metadata.getMainAttributes().isEmpty());\n        assertEquals(\n                GeoTools.getVersion().toString(),\n                metadata.getMainAttributes().getValue(\"Project-Version\"));\n\n        // should be a jar durning maven build, generated during IDE build\n        Manifest opengis = GeoTools.getManifest(Filter.class);\n        assertFalse(\"manifest metadata\", opengis.getMainAttributes().isEmpty());\n\n        Manifest commons_logging = GeoTools.getManifest(LogFactory.class);\n        assertNotNull(commons_logging);\n        assertFalse(\"manifest metadata\", commons_logging.getMainAttributes().isEmpty());\n        assertEquals(\n                \"1.1.1\", commons_logging.getMainAttributes().getValue(\"Implementation-Version\"));\n    }\n\n    /** Test version lookup */\n    @Test\n    public void testVersion() {\n\n        String location =\n                \"jar:file:/Users/jody/.m2/repository/org.locationtech/jts/1.14/jts-1.14\"\n                        + \".jar!/org.locationtech/jts/geom/Geometry.class\";\n        assertEquals(\"1.14\", GeoTools.jarVersion(location));\n\n        location =\n                \"jar:file:/Users/jody/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar!/org/apache/commons/logging/LogFactory.class\";\n        assertEquals(\"1.1.1\", GeoTools.jarVersion(location));\n\n        location =\n                \"jar:file:/Users/jody/Library/Java/Extensions/jai_core.jar!/javax/media/jai/JAI.class\";\n        assertNull(GeoTools.jarVersion(location));\n\n        location =\n                \"vfs:/var/jboss/workspace/BuildSvr_FNMOC/jboss/geoserver/deployments/geoserver.war/WEB-INF/lib/gt-xsd-wcs-13.2.jar/org/geotools/wcs/WCS.class\";\n        assertEquals(\"13.2\", GeoTools.jarVersion(location));\n\n        Version version = GeoTools.getVersion(Filter.class);\n        assertNotNull(version);\n\n        version = GeoTools.getVersion(JAI.class);\n        assertNotNull(version);\n        assertEquals(\"1.1.3\", version.toString());\n\n        version = GeoTools.getVersion(LogFactory.class);\n        assertNotNull(version);\n        assertEquals(\"1.1.1\", version.toString());\n    }\n    /** Tests the use of system properties. */\n    @Test\n    public void testSystemHints() {\n        Hints hints = GeoTools.getDefaultHints();\n        assertNotNull(hints);\n        assertTrue(hints.isEmpty());\n        System.setProperty(GeoTools.FORCE_LONGITUDE_FIRST_AXIS_ORDER, \"true\");\n        Hints.scanSystemProperties();\n        try {\n            hints = GeoTools.getDefaultHints();\n            assertNotNull(hints);\n            assertFalse(hints.isEmpty());\n            assertEquals(1, hints.size());\n            final Object value = hints.get(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER);\n            assertTrue(value instanceof Boolean);\n            assertTrue(((Boolean) value).booleanValue());\n        } finally {\n            System.clearProperty(GeoTools.FORCE_LONGITUDE_FIRST_AXIS_ORDER);\n            assertNotNull(Hints.removeSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER));\n        }\n        hints = GeoTools.getDefaultHints();\n        assertNotNull(hints);\n        assertTrue(hints.isEmpty());\n    }\n\n    /**\n     * Tests {@link org.geotools.util.factory.GeoTools#fixName} using simpliest name or no context.\n     * We avoid the tests that would require a real initial context.\n     */\n    @Test\n    @SuppressWarnings(\"deprecation\")\n    public void testFixName() {\n        assertNull(GeoTools.fixName(null));\n        assertEquals(\"simpleName\", GeoTools.fixName(\"simpleName\"));\n        assertEquals(\"jdbc:EPSG\", GeoTools.fixName(null, \"jdbc:EPSG\"));\n        assertEquals(\"jdbc/EPSG\", GeoTools.fixName(null, \"jdbc/EPSG\"));\n    }\n\n    @Test\n    public void testEntityResolver() {\n\n        // confirm instantiate works\n\n        EntityResolver resolver =\n                GeoTools.instantiate(\n                        \"org.geotools.util.factory.PlaceholderEntityResolver\",\n                        EntityResolver.class,\n                        PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof PlaceholderEntityResolver);\n\n        resolver =\n                GeoTools.instantiate(\n                        \"org.geotools.util.NullEntityResolver\",\n                        EntityResolver.class,\n                        PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof NullEntityResolver);\n\n        resolver =\n                GeoTools.instantiate(\n                        \"invalid.class.reference\",\n                        EntityResolver.class,\n                        PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof PreventLocalEntityResolver);\n\n        resolver =\n                GeoTools.instantiate(\n                        null, EntityResolver.class, PreventLocalEntityResolver.INSTANCE);\n        assertTrue(resolver instanceof PreventLocalEntityResolver);\n\n        // confirm system hints work\n        try {\n            Hints.putSystemDefault(Hints.ENTITY_RESOLVER, NullEntityResolver.INSTANCE);\n            assertSame(NullEntityResolver.INSTANCE, GeoTools.getEntityResolver(null));\n\n            // test default behavor\n            Hints.removeSystemDefault(Hints.ENTITY_RESOLVER);\n            assertSame(PreventLocalEntityResolver.INSTANCE, GeoTools.getEntityResolver(null));\n\n            // test system property functions with default constructor\n            System.getProperties()\n                    .put(\n                            GeoTools.ENTITY_RESOLVER,\n                            \"org.geotools.util.factory.PlaceholderEntityResolver\");\n            Hints.scanSystemProperties();\n            EntityResolver entityResolver = GeoTools.getEntityResolver(null);\n            assertTrue(entityResolver instanceof PlaceholderEntityResolver);\n\n            // test system property functions with INSTANCE field constructor\n            System.getProperties()\n                    .put(GeoTools.ENTITY_RESOLVER, \"org.geotools.util.NullEntityResolver\");\n            Hints.scanSystemProperties();\n            entityResolver = GeoTools.getEntityResolver(null);\n            assertTrue(entityResolver instanceof NullEntityResolver);\n        } finally {\n            System.clearProperty(GeoTools.ENTITY_RESOLVER);\n            Hints.removeSystemDefault(Hints.ENTITY_RESOLVER);\n            Hints.scanSystemProperties();\n        }\n    }\n\n    @Test\n    public void testLookupValidation() throws Exception {\n        // setup mock initial context (need a JNDI provider otherwise, like simple-jndi)\n        InitialContext ctx = Mockito.mock(InitialContext.class);\n        Object test1 = new Object();\n        String name1 = \"java://test1\";\n        Mockito.when(ctx.lookup(name1)).thenReturn(test1);\n        Object test2 = new Object();\n        String name2 = \"ftp://test2\";\n        Mockito.when(ctx.lookup(name2)).thenReturn(test2);\n        Object test3 = new Object();\n        String name3 = \"http://test3\";\n        Mockito.when(ctx.lookup(name3)).thenReturn(test3);\n        Object test4 = new Object();\n        String name4 = \"java://test4{}\"; // invalid URI\n        Mockito.when(ctx.lookup(name4)).thenReturn(test4);\n\n        // using default validator\n        GeoTools.init(ctx);\n        assertSame(test1, GeoTools.jndiLookup(name1));\n        assertNull(GeoTools.jndiLookup(name2));\n        assertNull(GeoTools.jndiLookup(name3));\n        assertNull(GeoTools.jndiLookup(name4));\n\n        // setup an \"accept all\" filter\n        GeoTools.setJNDINameValidator(name -> true);\n        assertSame(test1, GeoTools.jndiLookup(name1));\n        assertSame(test2, GeoTools.jndiLookup(name2));\n        assertSame(test3, GeoTools.jndiLookup(name3));\n        assertSame(test4, GeoTools.jndiLookup(name4));\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2005-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.referencing.factory;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.sql.DataSource;\nimport org.geotools.metadata.iso.citation.Citations;\nimport org.geotools.util.SimpleInternationalString;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.factory.Hints;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.metadata.Identifier;\nimport org.opengis.metadata.citation.Citation;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.IdentifiedObject;\nimport org.opengis.referencing.NoSuchAuthorityCodeException;\nimport org.opengis.util.GenericName;\nimport org.opengis.util.InternationalString;\n\n/**\n * Abstract implementation for EPSG (has a DataSource reference inside).\n *\n * <p>DataSource docs needed:\n *\n * @author Cory Horner (Refractions Research)\n */\npublic abstract class AbstractEpsgMediator extends AbstractAuthorityMediator {\n\n    /** The default priority level for this factory. */\n    public static final int PRIORITY = NORMAL_PRIORITY - 10;\n\n    private static final Logger LOGGER = Logging.getLogger(AbstractEpsgMediator.class);\n\n    protected DataSource datasource;\n\n    /** No argument constructor - must not fail for factory finder registration. */\n    public AbstractEpsgMediator() {}\n\n    public AbstractEpsgMediator(Hints hints) throws FactoryException {\n        this(hints, lookupDataSource(hints));\n    }\n    /**\n     * We expect the EPSG_DATASOURCE to provide a DataSource. Either:\n     *\n     * <ul>\n     *   <li>A name we can use to look up the DataSource in the initial context\n     *   <li>An actual DataSource instance\n     * </ul>\n     *\n     * @return DataSource\n     */\n    static DataSource lookupDataSource(Hints hints) throws FactoryException {\n        Object hint = hints.get(Hints.EPSG_DATA_SOURCE);\n        if (hint instanceof DataSource) {\n            return (DataSource) hint;\n        } else if (hint instanceof String) {\n            String name = (String) hint;\n            try {\n                return (DataSource) GeoTools.jndiLookup(name);\n            } catch (Exception e) {\n                throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n            }\n        }\n        throw new FactoryException(\"EPSG_DATA_SOURCE must be provided\");\n    }\n\n    public AbstractEpsgMediator(Hints hints, DataSource datasource) {\n        super(PRIORITY, hints);\n\n        if (datasource != null) {\n            this.datasource = datasource;\n        } else {\n            try {\n                this.datasource = lookupDataSource(hints);\n            } catch (FactoryException lookupFailed) {\n                throw (NullPointerException)\n                        new NullPointerException(\"DataSource not provided:\" + lookupFailed)\n                                .initCause(lookupFailed);\n            }\n        }\n        hints.put(Hints.EPSG_DATA_SOURCE, this.datasource);\n    }\n\n    protected Connection getConnection() throws SQLException {\n        try {\n            return datasource.getConnection();\n        } catch (SQLException e) {\n            LOGGER.log(Level.SEVERE, \"Connection failed\", e);\n            throw e;\n        }\n    }\n\n    @Override\n    public Citation getAuthority() {\n        return Citations.EPSG;\n    }\n\n    @Override\n    public void dispose() throws FactoryException {\n        super.dispose();\n        datasource = null;\n    }\n\n    @Override\n    public boolean isConnected() {\n        return datasource != null && super.isConnected();\n    }\n\n    /**\n     * Gets a description of the object corresponding to a code.\n     *\n     * @param code Value allocated by authority.\n     * @return A description of the object, or {@code null} if the object corresponding to the\n     *     specified {@code code} has no description.\n     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.\n     * @throws FactoryException if the query failed for some other reason.\n     */\n    @Override\n    public InternationalString getDescriptionText(final String code) throws FactoryException {\n        IdentifiedObject identifiedObject = createObject(code);\n        final Identifier identifier = identifiedObject.getName();\n        if (identifier instanceof GenericName) {\n            return ((GenericName) identifier).toInternationalString();\n        }\n        return new SimpleInternationalString(identifier.getCode());\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2005-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.referencing.factory.epsg;\n\nimport static org.geotools.measure.Units.DEGREE_ANGLE;\nimport static org.geotools.measure.Units.DEGREE_MINUTE_SECOND;\nimport static org.geotools.measure.Units.FOOT;\nimport static org.geotools.measure.Units.GRADE;\nimport static org.geotools.measure.Units.KILOMETER;\nimport static org.geotools.measure.Units.METRE;\nimport static org.geotools.measure.Units.MICRORADIAN;\nimport static org.geotools.measure.Units.MINUTE_ANGLE;\nimport static org.geotools.measure.Units.NAUTICAL_MILE;\nimport static org.geotools.measure.Units.ONE;\nimport static org.geotools.measure.Units.PPM;\nimport static org.geotools.measure.Units.RADIAN;\nimport static org.geotools.measure.Units.SECOND_ANGLE;\nimport static org.geotools.measure.Units.SEXAGESIMAL_DMS;\n\nimport java.awt.RenderingHints;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Date;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport javax.measure.Unit;\nimport javax.measure.quantity.Angle;\nimport javax.measure.quantity.Length;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport org.geotools.measure.Units;\nimport org.geotools.metadata.i18n.ErrorKeys;\nimport org.geotools.metadata.i18n.Errors;\nimport org.geotools.metadata.i18n.LoggingKeys;\nimport org.geotools.metadata.i18n.Loggings;\nimport org.geotools.metadata.i18n.Vocabulary;\nimport org.geotools.metadata.i18n.VocabularyKeys;\nimport org.geotools.metadata.iso.citation.CitationImpl;\nimport org.geotools.metadata.iso.citation.Citations;\nimport org.geotools.metadata.iso.extent.ExtentImpl;\nimport org.geotools.metadata.iso.extent.GeographicBoundingBoxImpl;\nimport org.geotools.metadata.iso.quality.AbsoluteExternalPositionalAccuracyImpl;\nimport org.geotools.metadata.iso.quality.QuantitativeResultImpl;\nimport org.geotools.parameter.DefaultParameterDescriptor;\nimport org.geotools.parameter.DefaultParameterDescriptorGroup;\nimport org.geotools.referencing.AbstractIdentifiedObject;\nimport org.geotools.referencing.NamedIdentifier;\nimport org.geotools.referencing.cs.DefaultCoordinateSystemAxis;\nimport org.geotools.referencing.datum.BursaWolfParameters;\nimport org.geotools.referencing.datum.DefaultGeodeticDatum;\nimport org.geotools.referencing.factory.AbstractCachedAuthorityFactory;\nimport org.geotools.referencing.factory.BufferedAuthorityFactory;\nimport org.geotools.referencing.factory.DirectAuthorityFactory;\nimport org.geotools.referencing.factory.IdentifiedObjectFinder;\nimport org.geotools.referencing.operation.DefaultConcatenatedOperation;\nimport org.geotools.referencing.operation.DefaultOperation;\nimport org.geotools.referencing.operation.DefaultOperationMethod;\nimport org.geotools.referencing.operation.DefiningConversion;\nimport org.geotools.referencing.util.CRSUtilities;\nimport org.geotools.util.LocalName;\nimport org.geotools.util.ObjectCache;\nimport org.geotools.util.ScopedName;\nimport org.geotools.util.SimpleInternationalString;\nimport org.geotools.util.TableWriter;\nimport org.geotools.util.Version;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.factory.Hints;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.metadata.Identifier;\nimport org.opengis.metadata.citation.Citation;\nimport org.opengis.metadata.extent.Extent;\nimport org.opengis.metadata.quality.EvaluationMethodType;\nimport org.opengis.metadata.quality.PositionalAccuracy;\nimport org.opengis.parameter.InvalidParameterValueException;\nimport org.opengis.parameter.ParameterDescriptor;\nimport org.opengis.parameter.ParameterNotFoundException;\nimport org.opengis.parameter.ParameterValue;\nimport org.opengis.parameter.ParameterValueGroup;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.IdentifiedObject;\nimport org.opengis.referencing.NoSuchAuthorityCodeException;\nimport org.opengis.referencing.NoSuchIdentifierException;\nimport org.opengis.referencing.crs.CRSFactory;\nimport org.opengis.referencing.crs.CompoundCRS;\nimport org.opengis.referencing.crs.CoordinateReferenceSystem;\nimport org.opengis.referencing.crs.GeneralDerivedCRS;\nimport org.opengis.referencing.crs.GeocentricCRS;\nimport org.opengis.referencing.crs.GeographicCRS;\nimport org.opengis.referencing.crs.ProjectedCRS;\nimport org.opengis.referencing.crs.SingleCRS;\nimport org.opengis.referencing.cs.AxisDirection;\nimport org.opengis.referencing.cs.CSFactory;\nimport org.opengis.referencing.cs.CartesianCS;\nimport org.opengis.referencing.cs.CoordinateSystem;\nimport org.opengis.referencing.cs.CoordinateSystemAxis;\nimport org.opengis.referencing.cs.EllipsoidalCS;\nimport org.opengis.referencing.cs.SphericalCS;\nimport org.opengis.referencing.cs.VerticalCS;\nimport org.opengis.referencing.datum.Datum;\nimport org.opengis.referencing.datum.DatumFactory;\nimport org.opengis.referencing.datum.Ellipsoid;\nimport org.opengis.referencing.datum.EngineeringDatum;\nimport org.opengis.referencing.datum.GeodeticDatum;\nimport org.opengis.referencing.datum.PrimeMeridian;\nimport org.opengis.referencing.datum.VerticalDatum;\nimport org.opengis.referencing.datum.VerticalDatumType;\nimport org.opengis.referencing.operation.ConcatenatedOperation;\nimport org.opengis.referencing.operation.Conversion;\nimport org.opengis.referencing.operation.CoordinateOperation;\nimport org.opengis.referencing.operation.MathTransform;\nimport org.opengis.referencing.operation.OperationMethod;\nimport org.opengis.referencing.operation.Projection;\nimport org.opengis.referencing.operation.Transformation;\nimport org.opengis.util.GenericName;\nimport org.opengis.util.InternationalString;\nimport si.uom.NonSI;\nimport si.uom.SI;\n\n/**\n * A coordinate reference system factory backed by the EPSG database tables.\n *\n * <p>The EPSG database is freely available at <A\n * HREF=\"http://www.epsg.org\">http://www.epsg.org</a>. Current version of this class requires EPSG\n * database version 6.6 or above.\n *\n * <p>This factory makes use of a provided {@link ObjectCache}, and may be deployed in stand aline\n * fashion; or as a worker for a {@link MultiEpsgFactory}.\n *\n * <p>This class is abstract - please see the subclasses for dialect specific implementations:\n *\n * <ul>\n *   <li>{@link AccessDialectEpsgFactory}\n *   <li>{@link AnsiDialectEpsgFactory}\n *   <li>{@link OracleDialectEpsgFactory}\n * </ul>\n *\n * These factories accepts names as well as numerical identifiers. For example \"<cite>NTF (Paris) /\n * France I</cite>\" and {@code \"27581\"} both fetchs the same object. However, names may be ambiguous\n * since the same name may be used for more than one object. This is the case of \"WGS 84\" for\n * example. If such an ambiguity is found, an exception will be thrown. If names are not wanted as a\n * legal EPSG code, subclasses can override the {@link #isPrimaryKey} method.\n *\n * @since 2.4\n * @version $Id$\n * @author Yann C\u00e9zard\n * @author Martin Desruisseaux (IRD)\n * @author Rueben Schulz\n * @author Matthias Basler\n * @author Andrea Aime\n */\n@SuppressWarnings(\"PMD.CloseResource\") // class implements its own PreparedStatement pooling\npublic abstract class AbstractEpsgFactory extends AbstractCachedAuthorityFactory {\n    /// Datum shift operation methods\n    /** First Bursa-Wolf method. */\n    private static final int BURSA_WOLF_MIN_CODE = 9603;\n\n    /** Last Bursa-Wolf method. */\n    private static final int BURSA_WOLF_MAX_CODE = 9607;\n\n    /** Rotation frame method. */\n    private static final int ROTATION_FRAME_CODE = 9607;\n\n    /** Dummy operation to ignore. */\n    private static final int DUMMY_OPERATION = 1;\n\n    /** The name for the transformation accuracy metadata. */\n    private static final InternationalString TRANSFORMATION_ACCURACY =\n            Vocabulary.formatInternational(VocabularyKeys.TRANSFORMATION_ACCURACY);\n\n    /**\n     * The authority for this database. Will be created only when first needed. This authority will\n     * contains the database version in the {@linkplain Citation#getEdition edition} attribute,\n     * together with the {@linkplain Citation#getEditionDate edition date}.\n     */\n    private transient Citation authority; // FIXME: always EPSG\n\n    /** A DataSource to the EPSG database being used. */\n    protected javax.sql.DataSource dataSource;\n\n    /**\n     * The connection to the EPSG database - this is create in a lazy manner from the DataSource.\n     *\n     * <p>This field is managed as part of our connection lifecycle.\n     */\n    private Connection connection;\n\n    /**\n     * A pool of prepared statements. Key are {@link String} object related to their originating\n     * method name (for example \"Ellipsoid\" for {@link #createEllipsoid}, while values are {@link\n     * PreparedStatement} objects.\n     *\n     * <p><strong>Note:</strong> It is okay to use {@link IdentityHashMap} instead of {@link\n     * HashMap} because the keys will always be the exact same object, namely the hard-coded\n     * argument given to calls to {@link #prepareStatement} in this class.\n     *\n     * <p>This field is managed as part of our connection lifecycle.\n     */\n    private final Map<String, PreparedStatement> statements = new IdentityHashMap<>();\n\n    /**\n     * Last object type returned by {@link #createObject}, or -1 if none. This type is an index in\n     * the {@link #TABLES_INFO} array and is strictly for {@link #createObject} internal use.\n     */\n    private int lastObjectType = -1;\n\n    /**\n     * The last table in which object name were looked for. This is for internal use by {@link\n     * #toPrimaryKey} only.\n     */\n    private transient String lastTableForName;\n\n    /**\n     * Cache for axis names. This service is not provided by {@link BufferedAuthorityFactory} since\n     * {@link AxisName} object are particular to the EPSG database.\n     *\n     * @see #getAxisName\n     */\n    private final Map<String, AxisName> axisNames = new HashMap<>();\n\n    /**\n     * Cache for axis numbers. This service is not provided by {@link BufferedAuthorityFactory}\n     * since the number of axis is used internally in this class.\n     *\n     * @see #getDimensionForCRS\n     */\n    private final Map<String, Short> axisCounts = new HashMap<>();\n\n    /**\n     * Cache for projection checks. This service is not provided by {@link BufferedAuthorityFactory}\n     * since the check that a transformation is a projection is used internally in this class.\n     *\n     * @see #isProjection\n     */\n    private final Map<String, Boolean> codeProjection = new HashMap<>();\n\n    /** Pool of naming systems, used for caching. There is usually few of them (about 15). */\n    private final Map<String, LocalName> scopes = new HashMap<>();\n\n    /**\n     * The properties to be given the objects to construct. Reused every time {@link\n     * #createProperties} is invoked.\n     */\n    private final Map<String, Object> properties = new HashMap<>();\n\n    /**\n     * A safety guard for preventing never-ending loops in recursive calls to {@link #createDatum}.\n     * This is used by {@link #createBursaWolfParameters}, which need to create a target datum. The\n     * target datum could have its own Bursa-Wolf parameters, with one of them pointing again to the\n     * source datum.\n     */\n    private final Set<String> safetyGuard = new HashSet<>();\n\n    public AbstractEpsgFactory(final Hints userHints) throws FactoryException {\n        super(MAXIMUM_PRIORITY - 20);\n        // The following hints have no effect on this class behaviour,\n        // but tell to the user what this factory do about axis order.\n        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);\n\n        //\n        // We need to obtain our DataSource\n        if (userHints != null) {\n            Object hint = userHints.get(Hints.EPSG_DATA_SOURCE);\n            if (hint instanceof String) {\n                String name = (String) hint;\n                try {\n                    dataSource = (DataSource) GeoTools.jndiLookup(name);\n                } catch (NamingException e) {\n                    throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required:\" + e);\n                }\n                hints.put(Hints.EPSG_DATA_SOURCE, dataSource);\n            } else if (hint instanceof DataSource) {\n                dataSource = (DataSource) hint;\n                hints.put(Hints.EPSG_DATA_SOURCE, dataSource);\n            } else {\n                throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required.\");\n            }\n        } else {\n            throw new FactoryException(\"A EPSG_DATA_SOURCE hint is required.\");\n        }\n    }\n\n    public AbstractEpsgFactory(final Hints userHints, final javax.sql.DataSource dataSource) {\n        super(MAXIMUM_PRIORITY - 20);\n\n        this.dataSource = dataSource;\n        // The following hints have no effect on this class behaviour,\n        // but tell to the user what this factory do about axis order.\n        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);\n        hints.put(Hints.EPSG_DATA_SOURCE, dataSource);\n    }\n    /**\n     * Constructs an authority factory using the specified connection.\n     *\n     * @param userHints The underlying factories used for objects creation.\n     * @param connection The connection to the underlying EPSG database.\n     */\n    public AbstractEpsgFactory(final Hints userHints, final Connection connection) {\n        super(MAXIMUM_PRIORITY - 20, userHints);\n        // The following hints have no effect on this class behaviour,\n        // but tell to the user what this factory do about axis order.\n        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);\n        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);\n        this.connection = connection;\n        ensureNonNull(\"connection\", connection);\n    }\n\n    /**\n     * Returns the authority for this EPSG database. This authority will contains the database\n     * version in the {@linkplain Citation#getEdition edition} attribute, together with the\n     * {@linkplain Citation#getEditionDate edition date}.\n     */\n    @Override\n    public synchronized Citation getAuthority() {\n        if (authority == null)\n            try {\n                final String query =\n                        adaptSQL(\n                                \"SELECT VERSION_NUMBER, VERSION_DATE FROM [Version History]\"\n                                        + \" ORDER BY VERSION_DATE DESC\");\n                final DatabaseMetaData metadata = getConnection().getMetaData();\n                try (Statement statement = getConnection().createStatement();\n                        ResultSet result = statement.executeQuery(query)) {\n                    if (result.next()) {\n                        final String version = result.getString(1);\n                        final Date date = result.getDate(2);\n                        final String engine = metadata.getDatabaseProductName();\n                        final CitationImpl c = new CitationImpl(Citations.EPSG);\n                        c.getAlternateTitles()\n                                .add(\n                                        Vocabulary.formatInternational(\n                                                VocabularyKeys.DATA_BASE_$3,\n                                                \"EPSG\",\n                                                version,\n                                                engine));\n                        c.setEdition(new SimpleInternationalString(version));\n                        c.setEditionDate(date);\n                        authority = (Citation) c.unmodifiable();\n                        hints.put(\n                                Hints.VERSION,\n                                new Version(version)); // For getImplementationHints()\n                    } else {\n                        authority = Citations.EPSG;\n                    }\n                }\n            } catch (SQLException exception) {\n                Logging.unexpectedException(\n                        LOGGER, AbstractEpsgFactory.class, \"getAuthority\", exception);\n                return Citations.EPSG;\n            }\n        return authority;\n    }\n\n    /**\n     * Returns a description of the database engine.\n     *\n     * @throws FactoryException if the database's metadata can't be fetched.\n     */\n    @Override\n    public synchronized String getBackingStoreDescription() throws FactoryException {\n        final Citation authority = getAuthority();\n        try (TableWriter table = new TableWriter(null, \" \")) {\n            final Vocabulary resources = Vocabulary.getResources(null);\n            CharSequence cs;\n            if ((cs = authority.getEdition()) != null) {\n                table.write(resources.getString(VocabularyKeys.VERSION_OF_$1, \"EPSG\"));\n                table.write(':');\n                table.nextColumn();\n                table.write(cs.toString());\n                table.nextLine();\n            }\n            try {\n                String s;\n                final DatabaseMetaData metadata = getConnection().getMetaData();\n                if ((s = metadata.getDatabaseProductName()) != null) {\n                    table.write(resources.getLabel(VocabularyKeys.DATABASE_ENGINE));\n                    table.nextColumn();\n                    table.write(s);\n                    if ((s = metadata.getDatabaseProductVersion()) != null) {\n                        table.write(' ');\n                        table.write(resources.getString(VocabularyKeys.VERSION_$1, s));\n                    }\n                    table.nextLine();\n                }\n                if ((s = metadata.getURL()) != null) {\n                    table.write(resources.getLabel(VocabularyKeys.DATABASE_URL));\n                    table.nextColumn();\n                    table.write(s);\n                    table.nextLine();\n                }\n            } catch (SQLException exception) {\n                throw new FactoryException(exception);\n            }\n            return table.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Returns the implementation hints for this factory. The returned map contains all the values\n     * specified in {@linkplain DirectAuthorityFactory#getImplementationHints subclass}, with the\n     * addition of {@link Hints#VERSION VERSION}.\n     */\n    @Override\n    public Map<RenderingHints.Key, ?> getImplementationHints() {\n        if (authority == null) {\n            // For the computation of Hints.VERSION.\n            getAuthority();\n        }\n        return super.getImplementationHints();\n    }\n\n    /**\n     * Returns the set of authority codes of the given type.\n     *\n     * @param type The spatial reference objects type (may be {@code Object.class}).\n     * @return The set of authority codes for spatial reference objects of the given type. If this\n     *     factory doesn't contains any object of the given type, then this method returns an empty\n     *     set.\n     * @throws FactoryException if access to the underlying database failed.\n     */\n    @Override\n    protected synchronized Set<String> generateAuthorityCodes(final Class type)\n            throws FactoryException {\n        Set<String> result = new HashSet<>();\n        for (final TableInfo table : TABLES_INFO) {\n            if (table.isTypeOf(type)) {\n                final AuthorityCodeSet codes = new AuthorityCodeSet(table, type);\n                result.addAll(codes);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets a description of the object corresponding to a code.\n     *\n     * @param code Value allocated by authority.\n     * @return A description of the object, or {@code null} if the object corresponding to the\n     *     specified {@code code} has no description.\n     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.\n     * @throws FactoryException if the query failed for some other reason.\n     */\n    @Override\n    public InternationalString getDescriptionText(final String code) throws FactoryException {\n        IdentifiedObject identifiedObject = createObject(code);\n        final Identifier identifier = identifiedObject.getName();\n        if (identifier instanceof GenericName) {\n            return ((GenericName) identifier).toInternationalString();\n        }\n        return new SimpleInternationalString(identifier.getCode());\n    }\n\n    /**\n     * Returns a prepared statement for the specified name. Most {@link PreparedStatement} creations\n     * are performed through this method, except {@link #getNumericalIdentifier} and {@link\n     * #createObject}.\n     *\n     * @param key A key uniquely identifying the caller (e.g. {@code \"Ellipsoid\"} for {@link\n     *     #createEllipsoid}).\n     * @param sql The SQL statement to use if for creating the {@link PreparedStatement} object.\n     *     Will be used only if no prepared statement was already created for the specified key.\n     * @return The prepared statement.\n     * @throws SQLException if the prepared statement can't be created.\n     */\n    private PreparedStatement prepareStatement(final String key, final String sql)\n            throws SQLException {\n        assert Thread.holdsLock(this);\n        PreparedStatement stmt = statements.get(key);\n        if (stmt == null) {\n            stmt = getConnection().prepareStatement(adaptSQL(sql));\n            statements.put(key, stmt);\n        }\n        return stmt;\n    }\n\n    /**\n     * Gets the string from the specified {@link ResultSet}. The string is required to be non-null.\n     * A null string will throw an exception.\n     *\n     * @param result The result set to fetch value from.\n     * @param columnIndex The column index (1-based).\n     * @param code The identifier of the record where the string was found.\n     * @return The string at the specified column.\n     * @throws SQLException if a SQL error occured.\n     * @throws FactoryException If a null value was found.\n     */\n    private static String getString(\n            final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        final String value = result.getString(columnIndex);\n        ensureNonNull(result, columnIndex, code);\n        return value.trim();\n    }\n\n    /**\n     * Same as {@link #getString(ResultSet,int,String)}, but report the fault on an alternative\n     * column if the value is null.\n     */\n    private static String getString(\n            final ResultSet result, final int columnIndex, final String code, final int columnFault)\n            throws SQLException, FactoryException {\n        final String str = result.getString(columnIndex);\n        if (result.wasNull()) {\n            final ResultSetMetaData metadata = result.getMetaData();\n            final String column = metadata.getColumnName(columnFault);\n            final String table = metadata.getTableName(columnFault);\n            result.close();\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.NULL_VALUE_IN_TABLE_$3, code, column, table));\n        }\n        return str.trim();\n    }\n\n    /**\n     * Gets the value from the specified {@link ResultSet}. The value is required to be non-null. A\n     * null value (i.e. blank) will throw an exception.\n     *\n     * @param result The result set to fetch value from.\n     * @param columnIndex The column index (1-based).\n     * @param code The identifier of the record where the string was found.\n     * @return The double at the specified column.\n     * @throws SQLException if a SQL error occured.\n     * @throws FactoryException If a null value was found.\n     */\n    private static double getDouble(\n            final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        final double value = result.getDouble(columnIndex);\n        ensureNonNull(result, columnIndex, code);\n        return value;\n    }\n\n    /**\n     * Gets the value from the specified {@link ResultSet}. The value is required to be non-null. A\n     * null value (i.e. blank) will throw an exception.\n     *\n     * @param result The result set to fetch value from.\n     * @param columnIndex The column index (1-based).\n     * @param code The identifier of the record where the string was found.\n     * @return The integer at the specified column.\n     * @throws SQLException if a SQL error occured.\n     * @throws FactoryException If a null value was found.\n     */\n    private static int getInt(final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        final int value = result.getInt(columnIndex);\n        ensureNonNull(result, columnIndex, code);\n        return value;\n    }\n\n    /**\n     * Make sure that the last result was non-null. Used for {@code getString}, {@code getDouble}\n     * and {@code getInt} methods only.\n     */\n    private static void ensureNonNull(\n            final ResultSet result, final int columnIndex, final String code)\n            throws SQLException, FactoryException {\n        if (result.wasNull()) {\n            final ResultSetMetaData metadata = result.getMetaData();\n            final String column = metadata.getColumnName(columnIndex);\n            final String table = metadata.getTableName(columnIndex);\n            result.close();\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.NULL_VALUE_IN_TABLE_$3, code, column, table));\n        }\n    }\n\n    /**\n     * Converts a code from an arbitrary name to the numerical identifier (the primary key). If the\n     * supplied code is already a numerical value, then it is returned unchanged. If the code is not\n     * found in the name column, it is returned unchanged as well so that the caller will produces\n     * an appropriate \"Code not found\" error message. If the code is found more than once, then an\n     * exception is thrown.\n     *\n     * <p>Note that this method includes a call to {@link #trimAuthority}, so there is no need to\n     * call it before or after this method.\n     *\n     * @param type The type of object to create.\n     * @param code The code to check.\n     * @param table The table where the code should appears.\n     * @param codeColumn The column name for the code.\n     * @param nameColumn The column name for the name.\n     * @return The numerical identifier (i.e. the table primary key value).\n     * @throws SQLException if an error occured while reading the database.\n     */\n    private String toPrimaryKey(\n            final Class type,\n            final String code,\n            final String table,\n            final String codeColumn,\n            final String nameColumn)\n            throws SQLException, FactoryException {\n        assert Thread.holdsLock(this);\n        String identifier = trimAuthority(code);\n        if (!isPrimaryKey(identifier)) {\n            /*\n             * The character is not the numerical code. Search the value in the database.\n             * If a prepared statement is already available, reuse it providing that it was\n             * created for the current table. Otherwise, we will create a new statement.\n             */\n            final String KEY = \"NumericalIdentifier\";\n            PreparedStatement statement = statements.get(KEY);\n            if (statement != null) {\n                if (!table.equals(lastTableForName)) {\n                    statements.remove(KEY);\n                    statement.close();\n                    statement = null;\n                    lastTableForName = null;\n                }\n            }\n            if (statement == null) {\n                final String query =\n                        \"SELECT \" + codeColumn + \" FROM \" + table + \" WHERE \" + nameColumn + \" = ?\";\n                statement = getConnection().prepareStatement(adaptSQL(query));\n                statements.put(KEY, statement);\n            }\n            statement.setString(1, identifier);\n            identifier = null;\n            try (ResultSet result = statement.executeQuery()) {\n                while (result.next()) {\n                    identifier = ensureSingleton(result.getString(1), identifier, code);\n                }\n            }\n            if (identifier == null) {\n                throw noSuchAuthorityCode(type, code);\n            }\n        }\n        return identifier;\n    }\n\n    /**\n     * Make sure that an object constructed from the database is not incoherent. If the code\n     * supplied to a {@code createFoo} method exists in the database, then we should find only one\n     * record. However, we will do a paranoiac check and verify if there is more records, using a\n     * {@code while (results.next())} loop instead of {@code if (results.next())}. This method is\n     * invoked in the loop for making sure that, if there is more than one record (which should\n     * never happen), at least they have identical contents.\n     *\n     * @param newValue The newly constructed object.\n     * @param oldValue The object previously constructed, or {@code null} if none.\n     * @param code The EPSG code (for formatting error message).\n     * @throws FactoryException if a duplication has been detected.\n     * @todo Use generic type when we will be allowed to compile for J2SE 1.5.\n     */\n    private static <T> T ensureSingleton(final T newValue, final T oldValue, final String code)\n            throws FactoryException {\n        if (oldValue == null) {\n            return newValue;\n        }\n        if (oldValue.equals(newValue)) {\n            return oldValue;\n        }\n        throw new FactoryException(Errors.format(ErrorKeys.DUPLICATED_VALUES_$1, code));\n    }\n\n    /**\n     * Returns the name for the {@link IdentifiedObject} to construct. This method also search for\n     * alias.\n     *\n     * @param name The name for the {@link IndentifiedObject} to construct.\n     * @param code The EPSG code of the object to construct.\n     * @param remarks Remarks, or {@code null} if none.\n     * @return The name together with a set of properties.\n     */\n    private Map<String, Object> generateProperties(\n            final String name, final String code, String remarks)\n            throws SQLException, FactoryException {\n        properties.clear();\n        final Citation authority = getAuthority();\n        if (name != null) {\n            properties.put(IdentifiedObject.NAME_KEY, new NamedIdentifier(authority, name.trim()));\n        }\n        if (code != null) {\n            final InternationalString edition = authority.getEdition();\n            final String version = (edition != null) ? edition.toString() : null;\n            properties.put(\n                    IdentifiedObject.IDENTIFIERS_KEY,\n                    new NamedIdentifier(authority, code.trim(), version));\n        }\n        if (remarks != null && (remarks = remarks.trim()).length() != 0) {\n            properties.put(IdentifiedObject.REMARKS_KEY, remarks);\n        }\n        /*\n         * Search for alias.\n         */\n        List<GenericName> alias = null;\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"Alias\",\n                        \"SELECT NAMING_SYSTEM_NAME, ALIAS\"\n                                + \" FROM [Alias] INNER JOIN [Naming System]\"\n                                + \" ON [Alias].NAMING_SYSTEM_CODE =\"\n                                + \" [Naming System].NAMING_SYSTEM_CODE\"\n                                + \" WHERE OBJECT_CODE = ?\");\n        stmt.setString(1, code);\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String scope = result.getString(1);\n                final String local = getString(result, 2, code);\n                final GenericName generic;\n                if (scope == null) {\n                    generic = new LocalName(local);\n                } else {\n                    LocalName cached = scopes.get(scope);\n                    if (cached == null) {\n                        cached = new LocalName(scope);\n                        scopes.put(scope, cached);\n                    }\n                    generic = new ScopedName(cached, local);\n                }\n                if (alias == null) {\n                    alias = new ArrayList<>();\n                }\n                alias.add(generic);\n            }\n        }\n        if (alias != null) {\n            properties.put(\n                    IdentifiedObject.ALIAS_KEY, alias.toArray(new GenericName[alias.size()]));\n        }\n        return properties;\n    }\n\n    /**\n     * Returns the name for the {@link IdentifiedObject} to construct. This method also search for\n     * alias.\n     *\n     * @param name The name for the {@link IndentifiedObject} to construct.\n     * @param code The EPSG code of the object to construct.\n     * @param area The area of use, or {@code null} if none.\n     * @param scope The scope, or {@code null} if none.\n     * @param remarks Remarks, or {@code null} if none.\n     * @return The name together with a set of properties.\n     */\n    private Map<String, Object> generateProperties(\n            final String name, final String code, String area, String scope, String remarks)\n            throws SQLException, FactoryException {\n        final Map<String, Object> properties = generateProperties(name, code, remarks);\n        if (area != null && (area = area.trim()).length() != 0) {\n            final Extent extent = generateExtent(area);\n            properties.put(Datum.DOMAIN_OF_VALIDITY_KEY, extent);\n        }\n        if (scope != null && (scope = scope.trim()).length() != 0) {\n            properties.put(Datum.SCOPE_KEY, scope);\n        }\n        return properties;\n    }\n\n    /**\n     * Returns an arbitrary object from a code. The default implementation invokes one of {@link\n     * #createCoordinateReferenceSystem}, {@link #createCoordinateSystem}, {@link #createDatum},\n     * {@link #createEllipsoid}, or {@link #createUnit} methods according the object type.\n     *\n     * @param code The EPSG value.\n     * @return The object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    @SuppressWarnings(\"PMD.OverrideBothEqualsAndHashcode\")\n    public synchronized IdentifiedObject generateObject(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        final String KEY = \"IdentifiedObject\";\n        PreparedStatement stmt = statements.get(KEY); // Null allowed.\n        StringBuilder query = null; // Will be created only if the last statement doesn't suit.\n        /*\n         * Iterates through all tables listed in TABLES_INFO, starting with the table used during\n         * the last call to 'createObject(code)'.  This approach assumes that two consecutive calls\n         * will often return the same type of object.  If the object type changed, then this method\n         * will have to discard the old prepared statement and prepare a new one, which may be a\n         * costly operation. Only the last successful prepared statement is cached, in order to keep\n         * the amount of statements low. Unsuccessful statements are immediately disposed.\n         */\n        final String epsg = trimAuthority(code);\n        final boolean isPrimaryKey = isPrimaryKey(epsg);\n        final int tupleToSkip = isPrimaryKey ? lastObjectType : -1;\n        int index = -1;\n        for (int i = -1; i < TABLES_INFO.length; i++) {\n            if (i == tupleToSkip) {\n                // Avoid to test the same table twice.  Note that this test also avoid a\n                // NullPointerException if 'stmt' is null, since 'lastObjectType' should\n                // be -1 in this case.\n                continue;\n            }\n            try {\n                if (i >= 0) {\n                    final TableInfo table = TABLES_INFO[i];\n                    final String column = isPrimaryKey ? table.codeColumn : table.nameColumn;\n                    if (column == null) {\n                        continue;\n                    }\n                    if (query == null) {\n                        query = new StringBuilder(\"SELECT \");\n                    }\n                    query.setLength(7); // 7 is the length of \"SELECT \" in the line above.\n                    query.append(table.codeColumn);\n                    query.append(\" FROM \");\n                    query.append(table.table);\n                    query.append(\" WHERE \");\n                    query.append(column);\n                    query.append(\" = ?\");\n                    if (isPrimaryKey) {\n                        assert !statements.containsKey(KEY) : table;\n                        stmt = prepareStatement(KEY, query.toString());\n                    } else {\n                        // Do not cache the statement for names.\n                        stmt = getConnection().prepareStatement(adaptSQL(query.toString()));\n                    }\n                }\n                /*\n                 * Checks if at least one record is found for the code. If the code is the primary\n                 * key, then we will stop at the first table found since a well-formed EPSG database\n                 * should not contains any duplicate identifiers. In the code is a name, then search\n                 * in all tables since duplicate names exist.\n                 */\n                stmt.setString(1, epsg);\n                try (final ResultSet result = stmt.executeQuery()) {\n                    final boolean present = result.next();\n                    if (present) {\n                        if (index >= 0) {\n                            throw new FactoryException(\n                                    Errors.format(ErrorKeys.DUPLICATED_VALUES_$1, code));\n                        }\n                        index = (i < 0) ? lastObjectType : i;\n                        if (isPrimaryKey) {\n                            // Don't scan other tables, since primary keys should be unique.\n                            // Note that names may be duplicated, so we don't stop for names.\n                            break;\n                        }\n                    }\n                }\n                if (isPrimaryKey) {\n                    if (statements.remove(KEY) == null) {\n                        throw new AssertionError(code); // Should never happen.\n                    }\n                }\n                stmt.close();\n            } catch (SQLException exception) {\n                throw databaseFailure(IdentifiedObject.class, code, exception);\n            }\n        }\n        /*\n         * If a record has been found in one table, then delegates to the appropriate method.\n         */\n        if (isPrimaryKey) {\n            lastObjectType = index;\n        }\n        if (index >= 0) {\n            switch (index) {\n                case 0:\n                    return createCoordinateReferenceSystem(code);\n                case 1:\n                    return createCoordinateSystem(code);\n                case 2:\n                    return createCoordinateSystemAxis(code);\n                case 3:\n                    return createDatum(code);\n                case 4:\n                    return createEllipsoid(code);\n                case 5:\n                    return createPrimeMeridian(code);\n                case 6:\n                    return createCoordinateOperation(code);\n                case 7:\n                    return generateOperationMethod(code);\n                case 8:\n                    return generateParameterDescriptor(code);\n                case 9:\n                    break; // Can't cast Unit to IdentifiedObject\n                default:\n                    throw new AssertionError(index); // Should not happen\n            }\n        }\n        return super.createObject(code);\n    }\n\n    /**\n     * Returns an unit from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The unit object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized Unit<?> generateUnit(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Unit<?> returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            Unit.class, code, \"[Unit of Measure]\", \"UOM_CODE\", \"UNIT_OF_MEAS_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Unit\",\n                            \"SELECT UOM_CODE,\"\n                                    + \" FACTOR_B,\"\n                                    + \" FACTOR_C,\"\n                                    + \" TARGET_UOM_CODE\"\n                                    + \" FROM [Unit of Measure]\"\n                                    + \" WHERE UOM_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final int source = getInt(result, 1, code);\n                    final double b = result.getDouble(2);\n                    final double c = result.getDouble(3);\n                    final int target = getInt(result, 4, code);\n                    final Unit<?> base = getUnit(target);\n                    if (base == null) {\n                        throw noSuchAuthorityCode(Unit.class, String.valueOf(target));\n                    }\n                    Unit unit = getUnit(source);\n                    if (unit == null) {\n                        // TODO: check unit consistency here.\n                        if (b != 0 && c != 0) {\n                            unit = (b == c) ? base : base.multiply(b / c);\n                        } else {\n                            // TODO: provide a localized message.\n                            throw new FactoryException(\"Unsupported unit: \" + code);\n                        }\n                    }\n                    returnValue = ensureSingleton(unit, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Unit.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Unit.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns an ellipsoid from a code.\n     *\n     * @param code The EPSG value.\n     * @return The ellipsoid object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized Ellipsoid generateEllipsoid(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Ellipsoid returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            Ellipsoid.class,\n                            code,\n                            \"[Ellipsoid]\",\n                            \"ELLIPSOID_CODE\",\n                            \"ELLIPSOID_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Ellipsoid\",\n                            \"SELECT ELLIPSOID_CODE,\"\n                                    + \" ELLIPSOID_NAME,\"\n                                    + \" SEMI_MAJOR_AXIS,\"\n                                    + \" INV_FLATTENING,\"\n                                    + \" SEMI_MINOR_AXIS,\"\n                                    + \" UOM_CODE,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Ellipsoid]\"\n                                    + \" WHERE ELLIPSOID_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    /*\n                     * One of 'semiMinorAxis' and 'inverseFlattening' values can be NULL in\n                     * the database. Consequently, we don't use 'getString(ResultSet, int)'\n                     * because we don't want to thrown an exception if a NULL value is found.\n                     */\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final double semiMajorAxis = getDouble(result, 3, code);\n                    final double inverseFlattening = result.getDouble(4);\n                    final double semiMinorAxis = result.getDouble(5);\n                    final String unitCode = getString(result, 6, code);\n                    final String remarks = result.getString(7);\n                    @SuppressWarnings(\"unchecked\")\n                    final Unit<Length> unit = (Unit<Length>) createUnit(unitCode);\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    final Ellipsoid ellipsoid;\n                    if (inverseFlattening == 0) {\n                        if (semiMinorAxis == 0) {\n                            // Both are null, which is not allowed.\n                            final String column = result.getMetaData().getColumnName(3);\n                            result.close();\n                            throw new FactoryException(\n                                    Errors.format(ErrorKeys.NULL_VALUE_IN_TABLE_$3, code, column));\n                        } else {\n                            // We only have semiMinorAxis defined -> it's OK\n                            ellipsoid =\n                                    factories\n                                            .getDatumFactory()\n                                            .createEllipsoid(\n                                                    properties, semiMajorAxis, semiMinorAxis, unit);\n                        }\n                    } else {\n                        if (semiMinorAxis != 0) {\n                            // Both 'inverseFlattening' and 'semiMinorAxis' are defined.\n                            // Log a warning and create the ellipsoid using the inverse flattening.\n                            final LogRecord record =\n                                    Loggings.format(\n                                            Level.WARNING, LoggingKeys.AMBIGUOUS_ELLIPSOID, code);\n                            record.setLoggerName(LOGGER.getName());\n                            LOGGER.log(record);\n                        }\n                        ellipsoid =\n                                factories\n                                        .getDatumFactory()\n                                        .createFlattenedSphere(\n                                                properties, semiMajorAxis, inverseFlattening, unit);\n                    }\n                    /*\n                     * Now that we have built an ellipsoid, compare\n                     * it with the previous one (if any).\n                     */\n                    returnValue = ensureSingleton(ellipsoid, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Ellipsoid.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Ellipsoid.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns a prime meridian, relative to Greenwich.\n     *\n     * @param code Value allocated by authority.\n     * @return The prime meridian object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized PrimeMeridian generatePrimeMeridian(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        PrimeMeridian returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            PrimeMeridian.class,\n                            code,\n                            \"[Prime Meridian]\",\n                            \"PRIME_MERIDIAN_CODE\",\n                            \"PRIME_MERIDIAN_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"PrimeMeridian\",\n                            \"SELECT PRIME_MERIDIAN_CODE,\"\n                                    + \" PRIME_MERIDIAN_NAME,\"\n                                    + \" GREENWICH_LONGITUDE,\"\n                                    + \" UOM_CODE,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Prime Meridian]\"\n                                    + \" WHERE PRIME_MERIDIAN_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final double longitude = getDouble(result, 3, code);\n                    final String unit_code = getString(result, 4, code);\n                    final String remarks = result.getString(5);\n                    @SuppressWarnings(\"unchecked\")\n                    final Unit<javax.measure.quantity.Angle> unit =\n                            (Unit<Angle>) createUnit(unit_code);\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    PrimeMeridian primeMeridian =\n                            factories\n                                    .getDatumFactory()\n                                    .createPrimeMeridian(properties, longitude, unit);\n                    returnValue = ensureSingleton(primeMeridian, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(PrimeMeridian.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(PrimeMeridian.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns an area of use.\n     *\n     * @param code Value allocated by authority.\n     * @return The area of use.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    public synchronized Extent generateExtent(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Extent returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(Extent.class, code, \"[Area]\", \"AREA_CODE\", \"AREA_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Area\",\n                            \"SELECT AREA_OF_USE,\"\n                                    + \" AREA_SOUTH_BOUND_LAT,\"\n                                    + \" AREA_NORTH_BOUND_LAT,\"\n                                    + \" AREA_WEST_BOUND_LON,\"\n                                    + \" AREA_EAST_BOUND_LON\"\n                                    + \" FROM [Area]\"\n                                    + \" WHERE AREA_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    ExtentImpl extent = null;\n                    final String description = result.getString(1);\n                    if (description != null) {\n                        extent = new ExtentImpl();\n                        extent.setDescription(new SimpleInternationalString(description));\n                    }\n                    final double ymin = result.getDouble(2);\n                    if (!result.wasNull()) {\n                        final double ymax = result.getDouble(3);\n                        if (!result.wasNull()) {\n                            final double xmin = result.getDouble(4);\n                            if (!result.wasNull()) {\n                                final double xmax = result.getDouble(5);\n                                if (!result.wasNull()) {\n                                    if (extent == null) {\n                                        extent = new ExtentImpl();\n                                    }\n                                    extent.setGeographicElements(\n                                            Collections.singleton(\n                                                    new GeographicBoundingBoxImpl(\n                                                            xmin, xmax, ymin, ymax)));\n                                }\n                            }\n                        }\n                    }\n                    if (extent != null) {\n                        returnValue =\n                                (Extent) ensureSingleton(extent.unmodifiable(), returnValue, code);\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Extent.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Extent.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns Bursa-Wolf parameters for a geodetic datum. If the specified datum has no conversion\n     * informations, then this method will returns {@code null}.\n     *\n     * @param code The EPSG code of the {@link GeodeticDatum}.\n     * @param toClose The result set to close if this method is going to invokes {@link\n     *     #createDatum} recursively. This hack is necessary because many JDBC drivers do not\n     *     support multiple result sets for the same statement. The result set is closed if an only\n     *     if this method returns a non-null value.\n     * @return an array of Bursa-Wolf parameters (in which case {@code toClose} has been closed), or\n     *     {@code null} (in which case {@code toClose} has <strong>not</strong> been closed).\n     */\n    private BursaWolfParameters[] generateBursaWolfParameters(\n            final String code, final ResultSet toClose) throws SQLException, FactoryException {\n        if (safetyGuard.contains(code)) {\n            /*\n             * Do not try to create Bursa-Wolf parameters if the datum is already\n             * in process of being created. This check avoid never-ending loops in\n             * recursive call to 'createDatum'.\n             */\n            return null;\n        }\n        PreparedStatement stmt =\n                prepareStatement(\n                        \"BursaWolfParametersSet\",\n                        \"SELECT CO.COORD_OP_CODE,\"\n                                + \" CO.COORD_OP_METHOD_CODE,\"\n                                + \" CRS2.DATUM_CODE\"\n                                + \" FROM [Coordinate_Operation] AS CO\"\n                                + \" INNER JOIN [Coordinate Reference System] AS CRS2\"\n                                + \" ON CO.TARGET_CRS_CODE = CRS2.COORD_REF_SYS_CODE\"\n                                + \" WHERE CO.COORD_OP_METHOD_CODE >= \"\n                                + BURSA_WOLF_MIN_CODE\n                                + \" AND CO.COORD_OP_METHOD_CODE <= \"\n                                + BURSA_WOLF_MAX_CODE\n                                + \" AND CO.COORD_OP_CODE <> \"\n                                + DUMMY_OPERATION // GEOT-1008\n                                + \" AND CO.SOURCE_CRS_CODE IN (\"\n                                + \" SELECT CRS1.COORD_REF_SYS_CODE \" // GEOT-1129\n                                + \" FROM [Coordinate Reference System] AS CRS1 \"\n                                + \" WHERE CRS1.DATUM_CODE = ?)\"\n                                + \" ORDER BY CRS2.DATUM_CODE,\"\n                                + \" ABS(CO.DEPRECATED), CO.COORD_OP_ACCURACY,\"\n                                + \" CO.COORD_OP_CODE DESC\"); // GEOT-846 fix\n        stmt.setString(1, code);\n        List<Object> bwInfos = null;\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String operation = getString(result, 1, code);\n                final int method = getInt(result, 2, code);\n                final String datum = getString(result, 3, code);\n                if (bwInfos == null) {\n                    bwInfos = new ArrayList<>();\n                }\n                bwInfos.add(new BursaWolfInfo(operation, method, datum));\n            }\n        }\n        if (bwInfos == null) {\n            // Don't close the connection here.\n            return null;\n        }\n        toClose.close();\n        /*\n         * Sorts the infos in preference order. The \"ORDER BY\" clause above was not enough;\n         * we also need to take the \"supersession\" table in account. Once the sorting is done,\n         * keep only one Bursa-Wolf parameters for each datum.\n         */\n        int size = bwInfos.size();\n        if (size > 1) {\n            final BursaWolfInfo[] codes = bwInfos.toArray(new BursaWolfInfo[size]);\n            sort(codes);\n            bwInfos.clear();\n            final Set<String> added = new HashSet<>();\n            for (final BursaWolfInfo candidate : codes) {\n                if (added.add(candidate.target)) {\n                    bwInfos.add(candidate);\n                }\n            }\n            size = bwInfos.size();\n        }\n        /*\n         * We got all the needed informations before to built Bursa-Wolf parameters because the\n         * 'createDatum(...)' call below may invokes 'createBursaWolfParameters(...)' recursively,\n         * and not all JDBC drivers supported multi-result set for the same statement. Now, iterate\n         * throw the results and fetch the parameter values for each BursaWolfParameters object.\n         */\n        stmt =\n                prepareStatement(\n                        \"BursaWolfParameters\",\n                        \"SELECT PARAMETER_CODE,\"\n                                + \" PARAMETER_VALUE,\"\n                                + \" UOM_CODE\"\n                                + \" FROM [Coordinate_Operation Parameter Value]\"\n                                + \" WHERE COORD_OP_CODE = ?\"\n                                + \" AND COORD_OP_METHOD_CODE = ?\");\n        for (int i = 0; i < size; i++) {\n            final BursaWolfInfo info = (BursaWolfInfo) bwInfos.get(i);\n            final GeodeticDatum datum;\n            try {\n                safetyGuard.add(code);\n                datum = createGeodeticDatum(info.target);\n            } finally {\n                safetyGuard.remove(code);\n            }\n            final BursaWolfParameters parameters = new BursaWolfParameters(datum);\n            stmt.setString(1, info.operation);\n            stmt.setInt(2, info.method);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    setBursaWolfParameter(\n                            parameters,\n                            getInt(result, 1, info.operation),\n                            getDouble(result, 2, info.operation),\n                            createUnit(getString(result, 3, info.operation)));\n                }\n            }\n            if (info.method == ROTATION_FRAME_CODE) {\n                // Coordinate frame rotation (9607): same as 9606,\n                // except for the sign of rotation parameters.\n                parameters.ex = -parameters.ex;\n                parameters.ey = -parameters.ey;\n                parameters.ey = -parameters.ey;\n            }\n            bwInfos.set(i, parameters);\n        }\n        return bwInfos.toArray(new BursaWolfParameters[size]);\n    }\n\n    /**\n     * Returns a datum from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The datum object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     * @todo Current implementation maps all \"vertical\" datum to {@link VerticalDatumType#GEOIDAL}.\n     *     We don't know yet how to maps the exact vertical datum type from the EPSG database.\n     */\n    @Override\n    public synchronized Datum generateDatum(final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        Datum returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(Datum.class, code, \"[Datum]\", \"DATUM_CODE\", \"DATUM_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Datum\",\n                            \"SELECT DATUM_CODE,\"\n                                    + \" DATUM_NAME,\"\n                                    + \" DATUM_TYPE,\"\n                                    + \" ORIGIN_DESCRIPTION,\"\n                                    + \" REALIZATION_EPOCH,\"\n                                    + \" AREA_OF_USE_CODE,\"\n                                    + \" DATUM_SCOPE,\"\n                                    + \" REMARKS,\"\n                                    + \" ELLIPSOID_CODE,\" // Only for geodetic type\n                                    + \" PRIME_MERIDIAN_CODE\" // Only for geodetic type\n                                    + \" FROM [Datum]\"\n                                    + \" WHERE DATUM_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                boolean exit = false;\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String type = getString(result, 3, code).trim().toLowerCase();\n                    final String anchor = result.getString(4);\n                    final Date epoch = result.getDate(5);\n                    final String area = result.getString(6);\n                    final String scope = result.getString(7);\n                    final String remarks = result.getString(8);\n                    Map<String, Object> properties =\n                            generateProperties(name, epsg, area, scope, remarks);\n                    if (anchor != null) {\n                        properties.put(Datum.ANCHOR_POINT_KEY, anchor);\n                    }\n                    if (epoch != null)\n                        try {\n                            properties.put(Datum.REALIZATION_EPOCH_KEY, epoch);\n                        } catch (NumberFormatException exception) {\n                            // Not a fatal error...\n                            Logging.unexpectedException(\n                                    LOGGER, AbstractEpsgFactory.class, \"createDatum\", exception);\n                        }\n                    final DatumFactory factory = factories.getDatumFactory();\n                    final Datum datum;\n                    /*\n                     * Now build datum according their datum type. Constructions are straightforward,\n                     * except for the \"geodetic\" datum type which need some special processing:\n                     *\n                     *   - Because it invokes again 'generateProperties' indirectly (through calls to\n                     *     'createEllipsoid' and 'createPrimeMeridian'), it must protect 'properties'\n                     *     from changes.\n                     *\n                     *   - Because 'createBursaWolfParameters' may invokes 'createDatum' recursively,\n                     *     we must close the result set if Bursa-Wolf parameters are found. In this\n                     *     case, we lost our paranoiac check for duplication.\n                     */\n                    if (type.equals(\"geodetic\")) {\n                        properties = new HashMap<>(properties); // Protect from changes\n                        final Ellipsoid ellipsoid = createEllipsoid(getString(result, 9, code));\n                        final PrimeMeridian meridian =\n                                createPrimeMeridian(getString(result, 10, code));\n                        final BursaWolfParameters[] param =\n                                generateBursaWolfParameters(primaryKey, result);\n\n                        if (param != null) {\n                            exit = true;\n                            properties.put(DefaultGeodeticDatum.BURSA_WOLF_KEY, param);\n                        }\n                        datum = factory.createGeodeticDatum(properties, ellipsoid, meridian);\n                    } else if (type.equals(\"vertical\")) {\n                        // TODO: Find the right datum type.\n                        datum = factory.createVerticalDatum(properties, VerticalDatumType.GEOIDAL);\n                    } else if (type.equals(\"engineering\")) {\n                        datum = factory.createEngineeringDatum(properties);\n                    } else {\n                        result.close();\n                        throw new FactoryException(Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                    }\n                    returnValue = ensureSingleton(datum, returnValue, code);\n                    if (exit) {\n                        // Bypass the 'result.close()' line below:\n                        // the ResultSet has already been closed.\n                        return returnValue;\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(Datum.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(Datum.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the name and description for the specified {@linkplain CoordinateSystemAxis\n     * coordinate system axis} code. Many axis share the same name and description, so it is worth\n     * to cache them.\n     */\n    private AxisName getAxisName(final String code) throws FactoryException {\n        assert Thread.holdsLock(this);\n        AxisName returnValue = axisNames.get(code);\n        if (returnValue == null)\n            try {\n                final PreparedStatement stmt =\n                        prepareStatement(\n                                \"AxisName\",\n                                \"SELECT COORD_AXIS_NAME, DESCRIPTION, REMARKS\"\n                                        + \" FROM [Coordinate Axis Name]\"\n                                        + \" WHERE COORD_AXIS_NAME_CODE = ?\");\n                stmt.setString(1, code);\n                try (ResultSet result = stmt.executeQuery()) {\n                    while (result.next()) {\n                        final String name = getString(result, 1, code);\n                        String description = result.getString(2);\n                        String remarks = result.getString(3);\n                        if (description == null) {\n                            description = remarks;\n                        } else if (remarks != null) {\n                            description += System.getProperty(\"line.separator\", \"\\n\") + remarks;\n                        }\n                        final AxisName axis = new AxisName(name, description);\n                        returnValue = ensureSingleton(axis, returnValue, code);\n                    }\n                }\n                if (returnValue == null) {\n                    throw noSuchAuthorityCode(AxisName.class, code);\n                }\n                axisNames.put(code, returnValue);\n            } catch (SQLException exception) {\n                throw databaseFailure(AxisName.class, code, exception);\n            }\n        return returnValue;\n    }\n\n    /**\n     * Returns a {@linkplain CoordinateSystemAxis coordinate system axis} from a code.\n     *\n     * @param code Value allocated by authority.\n     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.\n     * @throws FactoryException if the object creation failed for some other reason.\n     */\n    @Override\n    public synchronized CoordinateSystemAxis generateCoordinateSystemAxis(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateSystemAxis returnValue = null;\n        try {\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"Axis\",\n                            \"SELECT COORD_AXIS_CODE,\"\n                                    + \" COORD_AXIS_NAME_CODE,\"\n                                    + \" COORD_AXIS_ORIENTATION,\"\n                                    + \" COORD_AXIS_ABBREVIATION,\"\n                                    + \" UOM_CODE\"\n                                    + \" FROM [Coordinate Axis]\"\n                                    + \" WHERE COORD_AXIS_CODE = ?\");\n            stmt.setString(1, code);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String nameCode = getString(result, 2, code);\n                    final String orientation = getString(result, 3, code);\n                    final String abbreviation = getString(result, 4, code);\n                    final String unit = getString(result, 5, code);\n                    AxisDirection direction;\n                    try {\n                        direction = DefaultCoordinateSystemAxis.getDirection(orientation);\n                    } catch (NoSuchElementException exception) {\n                        if (orientation.equalsIgnoreCase(\"Geocentre > equator/PM\")) {\n                            direction = AxisDirection.OTHER; // TODO: can we choose a more accurate\n                            // direction?\n                        } else if (orientation.equalsIgnoreCase(\"Geocentre > equator/90dE\")) {\n                            direction = AxisDirection.EAST;\n                        } else if (orientation.equalsIgnoreCase(\"Geocentre > north pole\")) {\n                            direction = AxisDirection.NORTH;\n                        } else {\n                            throw new FactoryException(exception);\n                        }\n                    }\n                    final AxisName an = getAxisName(nameCode);\n                    final Map<String, Object> properties =\n                            generateProperties(an.name, epsg, an.description);\n                    final CSFactory factory = factories.getCSFactory();\n                    final CoordinateSystemAxis axis =\n                            factory.createCoordinateSystemAxis(\n                                    properties, abbreviation, direction, createUnit(unit));\n                    returnValue = ensureSingleton(axis, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateSystemAxis.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateSystemAxis.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the coordinate system axis from an EPSG code for a {@link CoordinateSystem}.\n     *\n     * <p><strong>WARNING:</strong> The EPSG database uses \"{@code ORDER}\" as a column name. This is\n     * tolerated by Access, but MySQL doesn't accept this name.\n     *\n     * @param code the EPSG code for coordinate system owner.\n     * @param dimension of the coordinate system, which is also the size of the returned array.\n     * @return An array of coordinate system axis.\n     * @throws SQLException if an error occured during database access.\n     * @throws FactoryException if the code has not been found.\n     */\n    private CoordinateSystemAxis[] generateAxisForCoordinateSystem(\n            final String code, final int dimension) throws SQLException, FactoryException {\n        assert Thread.holdsLock(this);\n        final CoordinateSystemAxis[] axis = new CoordinateSystemAxis[dimension];\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"AxisOrder\",\n                        \"SELECT COORD_AXIS_CODE\"\n                                + \" FROM [Coordinate Axis]\"\n                                + \" WHERE COORD_SYS_CODE = ?\"\n                                + \" ORDER BY [ORDER]\");\n        // WARNING: Be careful about the column name :\n        //          MySQL rejects ORDER as a column name !!!\n        stmt.setString(1, code);\n        int i = 0;\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String axisCode = getString(result, 1, code);\n                if (i < axis.length) {\n                    // If 'i' is out of bounds, an exception will be thrown after the loop.\n                    // We don't want to thrown an ArrayIndexOutOfBoundsException here.\n                    axis[i] = createCoordinateSystemAxis(axisCode);\n                }\n                ++i;\n            }\n        }\n        if (i != axis.length) {\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.MISMATCHED_DIMENSION_$2, axis.length, i));\n        }\n        return axis;\n    }\n\n    /**\n     * Returns a coordinate system from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The coordinate system object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized CoordinateSystem generateCoordinateSystem(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateSystem returnValue = null;\n        final PreparedStatement stmt;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            CoordinateSystem.class,\n                            code,\n                            \"[Coordinate System]\",\n                            \"COORD_SYS_CODE\",\n                            \"COORD_SYS_NAME\");\n            stmt =\n                    prepareStatement(\n                            \"CoordinateSystem\",\n                            \"SELECT COORD_SYS_CODE,\"\n                                    + \" COORD_SYS_NAME,\"\n                                    + \" COORD_SYS_TYPE,\"\n                                    + \" DIMENSION,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Coordinate System]\"\n                                    + \" WHERE COORD_SYS_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String type = getString(result, 3, code).trim().toLowerCase();\n                    final int dimension = getInt(result, 4, code);\n                    final String remarks = result.getString(5);\n                    final CoordinateSystemAxis[] axis =\n                            generateAxisForCoordinateSystem(primaryKey, dimension);\n                    final Map<String, Object> properties =\n                            generateProperties(name, epsg, remarks); // Must be after axis\n                    final CSFactory factory = factories.getCSFactory();\n                    CoordinateSystem cs = null;\n                    if (type.equals(\"ellipsoidal\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createEllipsoidalCS(properties, axis[0], axis[1]);\n                                break;\n                            case 3:\n                                cs =\n                                        factory.createEllipsoidalCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"cartesian\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createCartesianCS(properties, axis[0], axis[1]);\n                                break;\n                            case 3:\n                                cs =\n                                        factory.createCartesianCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"spherical\")) {\n                        switch (dimension) {\n                            case 3:\n                                cs =\n                                        factory.createSphericalCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"vertical\") || type.equals(\"gravity-related\")) {\n                        switch (dimension) {\n                            case 1:\n                                cs = factory.createVerticalCS(properties, axis[0]);\n                                break;\n                        }\n                    } else if (type.equals(\"linear\")) {\n                        switch (dimension) {\n                            case 1:\n                                cs = factory.createLinearCS(properties, axis[0]);\n                                break;\n                        }\n                    } else if (type.equals(\"polar\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createPolarCS(properties, axis[0], axis[1]);\n                                break;\n                        }\n                    } else if (type.equals(\"cylindrical\")) {\n                        switch (dimension) {\n                            case 3:\n                                cs =\n                                        factory.createCylindricalCS(\n                                                properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else if (type.equals(\"affine\")) {\n                        switch (dimension) {\n                            case 2:\n                                cs = factory.createAffineCS(properties, axis[0], axis[1]);\n                                break;\n                            case 3:\n                                cs = factory.createAffineCS(properties, axis[0], axis[1], axis[2]);\n                                break;\n                        }\n                    } else {\n                        result.close();\n                        throw new FactoryException(Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                    }\n                    if (cs == null) {\n                        result.close();\n                        throw new FactoryException(\n                                Errors.format(ErrorKeys.UNEXPECTED_DIMENSION_FOR_CS_$1, type));\n                    }\n                    returnValue = ensureSingleton(cs, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateSystem.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateSystem.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the primary key for a coordinate reference system name. This method is used both by\n     * {@link #createCoordinateReferenceSystem} and {@link\n     * #createFromCoordinateReferenceSystemCodes}\n     */\n    private String toPrimaryKeyCRS(final String code) throws SQLException, FactoryException {\n        return toPrimaryKey(\n                CoordinateReferenceSystem.class,\n                code,\n                \"[Coordinate Reference System]\",\n                \"COORD_REF_SYS_CODE\",\n                \"COORD_REF_SYS_NAME\");\n    }\n\n    /**\n     * Returns a coordinate reference system from a code.\n     *\n     * @param code Value allocated by authority.\n     * @return The coordinate reference system object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized CoordinateReferenceSystem generateCoordinateReferenceSystem(\n            final String code) throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateReferenceSystem returnValue = null;\n        try {\n            final String primaryKey = toPrimaryKeyCRS(code);\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"CoordinateReferenceSystem\",\n                            \"SELECT COORD_REF_SYS_CODE,\"\n                                    + \" COORD_REF_SYS_NAME,\"\n                                    + \" AREA_OF_USE_CODE,\"\n                                    + \" CRS_SCOPE,\"\n                                    + \" REMARKS,\"\n                                    + \" COORD_REF_SYS_KIND,\"\n                                    + \" COORD_SYS_CODE,\" // Null for CompoundCRS\n                                    + \" DATUM_CODE,\" // Null for ProjectedCRS\n                                    + \" SOURCE_GEOGCRS_CODE,\" // For ProjectedCRS\n                                    + \" PROJECTION_CONV_CODE,\" // For ProjectedCRS\n                                    + \" CMPD_HORIZCRS_CODE,\" // For CompoundCRS only\n                                    + \" CMPD_VERTCRS_CODE\" // For CompoundCRS only\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE COORD_REF_SYS_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            boolean exit = false;\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String area = result.getString(3);\n                    final String scope = result.getString(4);\n                    final String remarks = result.getString(5);\n                    final String type = getString(result, 6, code);\n                    // Note: Do not invoke 'generateProperties' now, even if we have all required\n                    //       informations, because the 'properties' map is going to overwritten\n                    //       by calls to 'createDatum', 'createCoordinateSystem', etc.\n                    final CRSFactory factory = factories.getCRSFactory();\n                    final CoordinateReferenceSystem crs;\n                    /* ----------------------------------------------------------------------\n                     *   GEOGRAPHIC CRS\n                     *\n                     *   NOTE: 'generateProperties' MUST be invoked after any call to an other\n                     *         'createFoo' method. Consequently, do not factor out.\n                     * ---------------------------------------------------------------------- */\n                    if (type.equalsIgnoreCase(\"geographic 2D\")\n                            || type.equalsIgnoreCase(\"geographic 3D\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = result.getString(8);\n                        final EllipsoidalCS cs = createEllipsoidalCS(csCode);\n                        final GeodeticDatum datum;\n                        if (dmCode != null) {\n                            datum = createGeodeticDatum(dmCode);\n                        } else {\n                            final String geoCode = getString(result, 9, code, 8);\n                            result.close(); // Must be close before createGeographicCRS\n                            exit = true;\n                            final GeographicCRS baseCRS = createGeographicCRS(geoCode);\n                            datum = baseCRS.getDatum();\n                        }\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createGeographicCRS(properties, datum, cs);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   PROJECTED CRS\n                     *\n                     *   NOTE: This method invokes itself indirectly, through createGeographicCRS.\n                     *         Consequently, we can't use 'result' anymore. We must close it here.\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"projected\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String geoCode = getString(result, 9, code);\n                        final String opCode = getString(result, 10, code);\n                        result.close(); // Must be close before createGeographicCRS\n                        exit = true;\n                        final CartesianCS cs = createCartesianCS(csCode);\n                        final GeographicCRS baseCRS = createGeographicCRS(geoCode);\n                        final CoordinateOperation op = createCoordinateOperation(opCode);\n                        if (op instanceof Conversion) {\n                            final Map<String, Object> properties =\n                                    generateProperties(name, epsg, area, scope, remarks);\n                            crs =\n                                    factory.createProjectedCRS(\n                                            properties, baseCRS, (Conversion) op, cs);\n                        } else {\n                            throw noSuchAuthorityCode(Projection.class, opCode);\n                        }\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   VERTICAL CRS\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"vertical\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = getString(result, 8, code);\n                        final VerticalCS cs = createVerticalCS(csCode);\n                        final VerticalDatum datum = createVerticalDatum(dmCode);\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createVerticalCRS(properties, datum, cs);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   COMPOUND CRS\n                     *\n                     *   NOTE: This method invokes itself recursively.\n                     *         Consequently, we can't use 'result' anymore.\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"compound\")) {\n                        final String code1 = getString(result, 11, code);\n                        final String code2 = getString(result, 12, code);\n                        result.close();\n                        exit = true;\n                        final CoordinateReferenceSystem crs1, crs2;\n                        if (!safetyGuard.add(epsg)) {\n                            throw recursiveCall(CompoundCRS.class, epsg);\n                        }\n                        try {\n                            crs1 = createCoordinateReferenceSystem(code1);\n                            crs2 = createCoordinateReferenceSystem(code2);\n                        } finally {\n                            safetyGuard.remove(epsg);\n                        }\n                        // Note: Don't invoke 'generateProperties' sooner.\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createCompoundCRS(properties, crs1, crs2);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   GEOCENTRIC CRS\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"geocentric\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = getString(result, 8, code);\n                        final CoordinateSystem cs = createCoordinateSystem(csCode);\n                        final GeodeticDatum datum = createGeodeticDatum(dmCode);\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        if (cs instanceof CartesianCS) {\n                            crs = factory.createGeocentricCRS(properties, datum, (CartesianCS) cs);\n                        } else if (cs instanceof SphericalCS) {\n                            crs = factory.createGeocentricCRS(properties, datum, (SphericalCS) cs);\n                        } else {\n                            result.close();\n                            throw new FactoryException(\n                                    Errors.format(\n                                            ErrorKeys.ILLEGAL_COORDINATE_SYSTEM_FOR_CRS_$2,\n                                            cs.getClass(),\n                                            GeocentricCRS.class));\n                        }\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   ENGINEERING CRS\n                     * ---------------------------------------------------------------------- */\n                    else if (type.equalsIgnoreCase(\"engineering\")) {\n                        final String csCode = getString(result, 7, code);\n                        final String dmCode = getString(result, 8, code);\n                        final CoordinateSystem cs = createCoordinateSystem(csCode);\n                        final EngineeringDatum datum = createEngineeringDatum(dmCode);\n                        final Map<String, Object> properties =\n                                generateProperties(name, epsg, area, scope, remarks);\n                        crs = factory.createEngineeringCRS(properties, datum, cs);\n                    }\n                    /* ----------------------------------------------------------------------\n                     *   UNKNOW CRS\n                     * ---------------------------------------------------------------------- */\n                    else {\n                        result.close();\n                        throw new FactoryException(Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                    }\n                    returnValue = ensureSingleton(crs, returnValue, code);\n                    if (exit) {\n                        // Bypass the 'result.close()' line below:\n                        // the ResultSet has already been closed.\n                        return returnValue;\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateReferenceSystem.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateReferenceSystem.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns a parameter descriptor from a code.\n     *\n     * @param code The parameter descriptor code allocated by EPSG authority.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    public synchronized ParameterDescriptor<?> generateParameterDescriptor(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        ParameterDescriptor<?> returnValue = null;\n        final PreparedStatement stmt;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            ParameterDescriptor.class,\n                            code,\n                            \"[Coordinate_Operation Parameter]\",\n                            \"PARAMETER_CODE\",\n                            \"PARAMETER_NAME\");\n            stmt =\n                    prepareStatement(\n                            \"ParameterDescriptor\", // Must be singular form.\n                            \"SELECT PARAMETER_CODE,\"\n                                    + \" PARAMETER_NAME,\"\n                                    + \" DESCRIPTION\"\n                                    + \" FROM [Coordinate_Operation Parameter]\"\n                                    + \" WHERE PARAMETER_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String remarks = result.getString(3);\n                    final Unit<?> unit;\n                    final Class<?> type;\n                    /*\n                     * Search for units. We will choose the most commonly used one in parameter values.\n                     * If the parameter appears to have at least one non-null value in the \"Parameter\n                     * File Name\" column, then the type is assumed to be URI. Otherwise, the type is a\n                     * floating point number.\n                     */\n                    final PreparedStatement units =\n                            prepareStatement(\n                                    \"ParameterUnit\",\n                                    \"SELECT MIN(UOM_CODE) AS UOM,\"\n                                            + \" MIN(PARAM_VALUE_FILE_REF) AS FILEREF\"\n                                            + \" FROM [Coordinate_Operation Parameter Value]\"\n                                            + \" WHERE (PARAMETER_CODE = ?)\"\n                                            + \" GROUP BY UOM_CODE\"\n                                            + \" ORDER BY COUNT(UOM_CODE) DESC\");\n                    units.setString(1, epsg);\n                    try (final ResultSet resultUnits = units.executeQuery()) {\n                        if (resultUnits.next()) {\n                            String element = resultUnits.getString(1);\n                            unit = (element != null) ? createUnit(element) : null;\n                            element = resultUnits.getString(2);\n                            type =\n                                    (element != null && element.trim().length() != 0)\n                                            ? URI.class\n                                            : double.class;\n                        } else {\n                            unit = null;\n                            type = double.class;\n                        }\n                    }\n                    /*\n                     * Now creates the parameter descriptor.\n                     */\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    @SuppressWarnings(\"unchecked\")\n                    final ParameterDescriptor<?> descriptor =\n                            new DefaultParameterDescriptor(\n                                    properties, type, null, null, null, null, unit, true);\n                    returnValue = ensureSingleton(descriptor, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(OperationMethod.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(OperationMethod.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns all parameter descriptors for the specified method.\n     *\n     * @param method The operation method code.\n     * @return The parameter descriptors.\n     * @throws SQLException if a SQL statement failed.\n     */\n    private ParameterDescriptor[] generateParameterDescriptors(final String method)\n            throws FactoryException, SQLException {\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"ParameterDescriptors\", // Must be plural form.\n                        \"SELECT PARAMETER_CODE\"\n                                + \" FROM [Coordinate_Operation Parameter Usage]\"\n                                + \" WHERE COORD_OP_METHOD_CODE = ?\"\n                                + \" ORDER BY SORT_ORDER\");\n        stmt.setString(1, method);\n        try (ResultSet results = stmt.executeQuery()) {\n            final List<ParameterDescriptor<? extends Object>> descriptors = new ArrayList<>();\n            while (results.next()) {\n                final String param = getString(results, 1, method);\n                descriptors.add(generateParameterDescriptor(param));\n            }\n            return descriptors.toArray(new ParameterDescriptor[descriptors.size()]);\n        }\n    }\n\n    /**\n     * Fill parameter values in the specified group.\n     *\n     * @param method The EPSG code for the operation method.\n     * @param operation The EPSG code for the operation (conversion or transformation).\n     * @param parameters The parameter values to fill.\n     * @throws SQLException if a SQL statement failed.\n     */\n    private void fillParameterValues(\n            final String method, final String operation, final ParameterValueGroup parameters)\n            throws FactoryException, SQLException {\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"ParameterValues\",\n                        \"SELECT CP.PARAMETER_NAME,\"\n                                + \" CV.PARAMETER_VALUE,\"\n                                + \" CV.PARAM_VALUE_FILE_REF,\"\n                                + \" CV.UOM_CODE\"\n                                + \" FROM ([Coordinate_Operation Parameter Value] AS CV\"\n                                + \" INNER JOIN [Coordinate_Operation Parameter] AS CP\"\n                                + \" ON CV.PARAMETER_CODE = CP.PARAMETER_CODE)\"\n                                + \" INNER JOIN [Coordinate_Operation Parameter Usage] AS CU\"\n                                + \" ON (CP.PARAMETER_CODE = CU.PARAMETER_CODE)\"\n                                + \" AND (CV.COORD_OP_METHOD_CODE = CU.COORD_OP_METHOD_CODE)\"\n                                + \" WHERE CV.COORD_OP_METHOD_CODE = ?\"\n                                + \" AND CV.COORD_OP_CODE = ?\"\n                                + \" ORDER BY CU.SORT_ORDER\");\n        stmt.setString(1, method);\n        stmt.setString(2, operation);\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final String name = getString(result, 1, operation);\n                final double value = result.getDouble(2);\n                final Unit<?> unit;\n                Object reference;\n                if (result.wasNull()) {\n                    /*\n                     * If no numeric values were provided in the database, then the values must\n                     * appears in some external file. It may be a file to download from FTP.\n                     */\n                    reference = getString(result, 3, operation);\n                    try {\n                        reference = new URI((String) reference);\n                    } catch (URISyntaxException exception) {\n                        // Ignore: we will stores the reference as a file.\n                        reference = new File((String) reference);\n                    }\n                    unit = null;\n                } else {\n                    reference = null;\n                    final String unitCode = result.getString(4);\n                    unit = (unitCode != null) ? createUnit(unitCode) : null;\n                }\n                final ParameterValue<?> param;\n                try {\n                    param = parameters.parameter(name);\n                } catch (ParameterNotFoundException exception) {\n                    /*\n                     * Wraps the unchecked ParameterNotFoundException into the checked\n                     * NoSuchIdentifierException, which is a FactoryException subclass.\n                     * Note that in theory, NoSuchIdentifierException is for MathTransforms rather\n                     * than parameters.  However, we are close in spirit here since we are setting\n                     * up MathTransform's parameters. Using NoSuchIdentifierException allows users\n                     * (including CoordinateOperationSet) to know that the failure is probably\n                     * caused by a MathTransform not yet supported in Geotools (or only partially\n                     * supported) rather than some more serious failure in the database side.\n                     * CoordinateOperationSet uses this information in order to determine if it\n                     * should try the next coordinate operation or propagate the exception.\n                     */\n                    final NoSuchIdentifierException e =\n                            new NoSuchIdentifierException(\n                                    Errors.format(ErrorKeys.CANT_SET_PARAMETER_VALUE_$1, name),\n                                    name);\n                    e.initCause(exception);\n                    throw e;\n                }\n                try {\n                    if (reference != null) {\n                        param.setValue(reference);\n                    } else if (unit != null) {\n                        param.setValue(value, unit);\n                    } else {\n                        param.setValue(value);\n                    }\n                } catch (InvalidParameterValueException exception) {\n                    throw new FactoryException(\n                            Errors.format(ErrorKeys.CANT_SET_PARAMETER_VALUE_$1, name), exception);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an operation method from a code.\n     *\n     * @param code The operation method code allocated by EPSG authority.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    public synchronized OperationMethod generateOperationMethod(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        OperationMethod returnValue = null;\n        final PreparedStatement stmt;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            OperationMethod.class,\n                            code,\n                            \"[Coordinate_Operation Method]\",\n                            \"COORD_OP_METHOD_CODE\",\n                            \"COORD_OP_METHOD_NAME\");\n            stmt =\n                    prepareStatement(\n                            \"OperationMethod\",\n                            \"SELECT COORD_OP_METHOD_CODE,\"\n                                    + \" COORD_OP_METHOD_NAME,\"\n                                    + \" FORMULA,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Coordinate_Operation Method]\"\n                                    + \" WHERE COORD_OP_METHOD_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            try (ResultSet result = stmt.executeQuery()) {\n                OperationMethod method = null;\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String formula = result.getString(3);\n                    final String remarks = result.getString(4);\n                    final int encoded = getDimensionsForMethod(epsg);\n                    final int sourceDimensions = encoded >>> 16;\n                    final int targetDimensions = encoded & 0xFFFF;\n                    final ParameterDescriptor[] descriptors = generateParameterDescriptors(epsg);\n                    final Map<String, Object> properties = generateProperties(name, epsg, remarks);\n                    if (formula != null) {\n                        properties.put(OperationMethod.FORMULA_KEY, formula);\n                    }\n                    method =\n                            new DefaultOperationMethod(\n                                    properties,\n                                    sourceDimensions,\n                                    targetDimensions,\n                                    new DefaultParameterDescriptorGroup(properties, descriptors));\n                    returnValue = ensureSingleton(method, returnValue, code);\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(OperationMethod.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(OperationMethod.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the must common source and target dimensions for the specified method. Source\n     * dimension is encoded in the 16 highest bits and target dimension is encoded in the 16 lowest\n     * bits. If this method can't infers the dimensions from the \"Coordinate Operation\" table, then\n     * the operation method is probably a projection, which always have (2,2) dimensions in the EPSG\n     * database.\n     */\n    private int getDimensionsForMethod(final String code) throws SQLException {\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"MethodDimensions\",\n                        \"SELECT SOURCE_CRS_CODE,\"\n                                + \" TARGET_CRS_CODE\"\n                                + \" FROM [Coordinate_Operation]\"\n                                + \" WHERE COORD_OP_METHOD_CODE = ?\"\n                                + \" AND SOURCE_CRS_CODE IS NOT NULL\"\n                                + \" AND TARGET_CRS_CODE IS NOT NULL\");\n        stmt.setString(1, code);\n        final Map<Dimensions, Dimensions> dimensions = new HashMap<>();\n        final Dimensions temp = new Dimensions((2 << 16) | 2); // Default to (2,2) dimensions.\n        Dimensions max = temp;\n        try (ResultSet result = stmt.executeQuery()) {\n            while (result.next()) {\n                final short sourceDimensions = getDimensionForCRS(result.getString(1));\n                final short targetDimensions = getDimensionForCRS(result.getString(2));\n                temp.encoded = (sourceDimensions << 16) | (targetDimensions);\n                Dimensions candidate = dimensions.get(temp);\n                if (candidate == null) {\n                    candidate = new Dimensions(temp.encoded);\n                    dimensions.put(candidate, candidate);\n                }\n                if (++candidate.occurences > max.occurences) {\n                    max = candidate;\n                }\n            }\n        }\n        return max.encoded;\n    }\n\n    /** A counter for source and target dimensions (to be kept together). */\n    private static final class Dimensions {\n        /** The dimensions as an encoded value. */\n        int encoded;\n        /** The occurences of this dimensions. */\n        int occurences;\n\n        Dimensions(final int e) {\n            encoded = e;\n        }\n\n        @Override\n        public int hashCode() {\n            return encoded;\n        }\n\n        @Override\n        public boolean equals(final Object object) { // MUST ignore 'occurences'.\n            return (object instanceof Dimensions) && ((Dimensions) object).encoded == encoded;\n        }\n\n        @Override\n        public String toString() {\n            return \"[(\"\n                    + (encoded >>> 16)\n                    + ','\n                    + (encoded & 0xFFFF)\n                    + \")\\u00D7\"\n                    + occurences\n                    + ']';\n        }\n    }\n\n    /**\n     * Returns the dimension of the specified CRS. If the CRS is not found (which should not happen,\n     * but we don't need to be strict here), then this method assumes a two-dimensional CRS.\n     */\n    private short getDimensionForCRS(final String code) throws SQLException {\n        final PreparedStatement stmt;\n        final Short cached = axisCounts.get(code);\n        final short dimension;\n        if (cached == null) {\n            stmt =\n                    prepareStatement(\n                            \"Dimension\",\n                            \"  SELECT COUNT(COORD_AXIS_CODE)\"\n                                    + \" FROM [Coordinate Axis]\"\n                                    + \" WHERE COORD_SYS_CODE = (SELECT COORD_SYS_CODE \"\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE COORD_REF_SYS_CODE = ?)\");\n            stmt.setString(1, code);\n            try (ResultSet result = stmt.executeQuery()) {\n                dimension = result.next() ? result.getShort(1) : 2;\n                axisCounts.put(code, dimension);\n            }\n        } else {\n            dimension = cached.shortValue();\n        }\n        return dimension;\n    }\n\n    /**\n     * Returns {@code true} if the {@linkplain CoordinateOperation coordinate operation} for the\n     * specified code is a {@linkplain Projection projection}. The caller must have ensured that the\n     * designed operation is a {@linkplain Conversion conversion} before to invoke this method.\n     */\n    final synchronized boolean isProjection(final String code) throws SQLException {\n        final PreparedStatement stmt;\n        Boolean projection = codeProjection.get(code);\n        if (projection == null) {\n            stmt =\n                    prepareStatement(\n                            \"isProjection\",\n                            \"SELECT COORD_REF_SYS_CODE\"\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE PROJECTION_CONV_CODE = ?\"\n                                    + \" AND COORD_REF_SYS_KIND LIKE 'projected%'\");\n            stmt.setString(1, code);\n            try (ResultSet result = stmt.executeQuery()) {\n                final boolean found = result.next();\n                projection = Boolean.valueOf(found);\n                codeProjection.put(code, projection);\n            }\n        }\n        return projection.booleanValue();\n    }\n\n    /**\n     * Returns a coordinate operation from a code. The returned object will either be a {@linkplain\n     * Conversion conversion} or a {@linkplain Transformation transformation}, depending on the\n     * code.\n     *\n     * @param code Value allocated by authority.\n     * @return The coordinate operation object.\n     * @throws NoSuchAuthorityCodeException if this method can't find the requested code.\n     * @throws FactoryException if some other kind of failure occured in the backing store. This\n     *     exception usually have {@link SQLException} as its cause.\n     */\n    @Override\n    public synchronized CoordinateOperation generateCoordinateOperation(final String code)\n            throws FactoryException {\n        ensureNonNull(\"code\", code);\n        CoordinateOperation returnValue = null;\n        try {\n            final String primaryKey =\n                    toPrimaryKey(\n                            CoordinateOperation.class,\n                            code,\n                            \"[Coordinate_Operation]\",\n                            \"COORD_OP_CODE\",\n                            \"COORD_OP_NAME\");\n            final PreparedStatement stmt =\n                    prepareStatement(\n                            \"CoordinateOperation\",\n                            \"SELECT COORD_OP_CODE,\"\n                                    + \" COORD_OP_NAME,\"\n                                    + \" COORD_OP_TYPE,\"\n                                    + \" SOURCE_CRS_CODE,\"\n                                    + \" TARGET_CRS_CODE,\"\n                                    + \" COORD_OP_METHOD_CODE,\"\n                                    + \" COORD_TFM_VERSION,\"\n                                    + \" COORD_OP_ACCURACY,\"\n                                    + \" AREA_OF_USE_CODE,\"\n                                    + \" COORD_OP_SCOPE,\"\n                                    + \" REMARKS\"\n                                    + \" FROM [Coordinate_Operation]\"\n                                    + \" WHERE COORD_OP_CODE = ?\");\n            stmt.setString(1, primaryKey);\n            boolean exit = false;\n            try (ResultSet result = stmt.executeQuery()) {\n                while (result.next()) {\n                    final String epsg = getString(result, 1, code);\n                    final String name = getString(result, 2, code);\n                    final String type = getString(result, 3, code).trim().toLowerCase();\n                    final boolean isTransformation = type.equals(\"transformation\");\n                    final boolean isConversion = type.equals(\"conversion\");\n                    final boolean isConcatenated = type.equals(\"concatenated operation\");\n                    final String sourceCode, targetCode, methodCode;\n                    if (isConversion) {\n                        // Optional for conversions, mandatory for all others.\n                        sourceCode = result.getString(4);\n                        targetCode = result.getString(5);\n                    } else {\n                        sourceCode = getString(result, 4, code);\n                        targetCode = getString(result, 5, code);\n                    }\n                    if (isConcatenated) {\n                        // Not applicable to concatenated operation, mandatory for all others.\n                        methodCode = result.getString(6);\n                    } else {\n                        methodCode = getString(result, 6, code);\n                    }\n                    String version = result.getString(7);\n                    double accuracy = result.getDouble(8);\n                    if (result.wasNull()) accuracy = Double.NaN;\n                    String area = result.getString(9);\n                    String scope = result.getString(10);\n                    String remarks = result.getString(11);\n                    /*\n                     * Gets the source and target CRS. They are mandatory for transformations (it\n                     * was checked above in this method) and optional for conversions. Conversions\n                     * are usually \"defining conversions\" and don't define source and target CRS.\n                     * In EPSG database 6.7, all defining conversions are projections and their\n                     * dimensions are always 2. However, this is not generalizable to other kind\n                     * of operation methods. For example the \"Geocentric translation\" operation\n                     * method has 3-dimensional source and target.\n                     */\n                    final int sourceDimensions, targetDimensions;\n                    final CoordinateReferenceSystem sourceCRS, targetCRS;\n                    if (sourceCode != null) {\n                        sourceCRS = createCoordinateReferenceSystem(sourceCode);\n                        sourceDimensions = sourceCRS.getCoordinateSystem().getDimension();\n                    } else {\n                        sourceCRS = null;\n                        sourceDimensions = 2; // Acceptable default for projections only.\n                    }\n                    if (targetCode != null) {\n                        targetCRS = createCoordinateReferenceSystem(targetCode);\n                        targetDimensions = targetCRS.getCoordinateSystem().getDimension();\n                    } else {\n                        targetCRS = null;\n                        targetDimensions = 2; // Acceptable default for projections only.\n                    }\n                    /*\n                     * Gets the operation method. This is mandatory for conversions and transformations\n                     * (it was checked above in this method) but optional for concatenated operations.\n                     * Fetching parameter values is part of this block.\n                     */\n                    final boolean isBursaWolf;\n                    OperationMethod method;\n                    final ParameterValueGroup parameters;\n                    if (methodCode == null) {\n                        isBursaWolf = false;\n                        method = null;\n                        parameters = null;\n                    } else {\n                        final int num;\n                        try {\n                            num = Integer.parseInt(methodCode);\n                        } catch (NumberFormatException exception) {\n                            result.close();\n                            throw new FactoryException(exception);\n                        }\n                        isBursaWolf = (num >= BURSA_WOLF_MIN_CODE && num <= BURSA_WOLF_MAX_CODE);\n                        // Reminder: The source and target dimensions MUST be computed when\n                        //           the information is available. Dimension is not always 2!!\n                        method = generateOperationMethod(methodCode);\n                        if (method.getSourceDimensions() != sourceDimensions\n                                || method.getTargetDimensions() != targetDimensions) {\n                            method =\n                                    new DefaultOperationMethod(\n                                            method, sourceDimensions, targetDimensions);\n                        }\n                        /*\n                         * Note that some parameters required for MathTransform creation are implicit in\n                         * the EPSG database (e.g. semi-major and semi-minor axis length in the case of\n                         * map projections). We ask the parameter value group straight from the math\n                         * transform factory instead of from the operation method in order to get all\n                         * required parameter descriptors, including implicit ones.\n                         */\n                        final String classe = method.getName().getCode();\n                        parameters =\n                                factories.getMathTransformFactory().getDefaultParameters(classe);\n                        fillParameterValues(methodCode, epsg, parameters);\n                    }\n                    /*\n                     * Creates common properties. The 'version' and 'accuracy' are usually defined\n                     * for transformations only. However, we check them for all kind of operations\n                     * (including conversions) and copy the information inconditionnaly if present.\n                     *\n                     * NOTE: This block must be executed last before object creations below, because\n                     *       methods like createCoordinateReferenceSystem and createOperationMethod\n                     *       overwrite the properties map.\n                     */\n                    final Map<String, Object> properties =\n                            generateProperties(name, epsg, area, scope, remarks);\n                    if (version != null && (version = version.trim()).length() != 0) {\n                        properties.put(CoordinateOperation.OPERATION_VERSION_KEY, version);\n                    }\n                    if (!Double.isNaN(accuracy)) {\n                        final QuantitativeResultImpl accuracyResult =\n                                new QuantitativeResultImpl(new double[] {accuracy});\n                        // TODO: Need to invoke something equivalent to:\n                        // accuracyResult.setValueType(Float.class);\n                        // This is the type declared in the MS-Access database.\n                        accuracyResult.setValueUnit(\n                                SI.METRE); // In meters by definition in the EPSG database.\n                        final AbsoluteExternalPositionalAccuracyImpl accuracyElement =\n                                new AbsoluteExternalPositionalAccuracyImpl(accuracyResult);\n                        accuracyElement.setMeasureDescription(TRANSFORMATION_ACCURACY);\n                        accuracyElement.setEvaluationMethodType(\n                                EvaluationMethodType.DIRECT_EXTERNAL);\n                        properties.put(\n                                CoordinateOperation.COORDINATE_OPERATION_ACCURACY_KEY,\n                                new PositionalAccuracy[] {\n                                    (PositionalAccuracy) accuracyElement.unmodifiable()\n                                });\n                    }\n                    /*\n                     * Creates the operation. Conversions should be the only operations allowed to\n                     * have null source and target CRS. In such case, the operation is a defining\n                     * conversion (usually to be used later as part of a ProjectedCRS creation),\n                     * and always a projection in the specific case of the EPSG database (which\n                     * allowed us to assume 2-dimensional operation method in the code above for\n                     * this specific case - not to be generalized to the whole EPSG database).\n                     */\n                    final CoordinateOperation operation;\n                    if (isConversion && (sourceCRS == null || targetCRS == null)) {\n                        // Note: we usually can't resolve sourceCRS and targetCRS because there\n                        // is many of them for the same coordinate operation (projection) code.\n                        operation = new DefiningConversion(properties, method, parameters);\n                    } else if (isConcatenated) {\n                        /*\n                         * Concatenated operation: we need to close the current result set, because\n                         * we are going to invoke this method recursively in the following lines.\n                         *\n                         * Note: we instantiate directly the Geotools's implementation of\n                         * ConcatenatedOperation instead of using CoordinateOperationFactory in order\n                         * to avoid loading the quite large Geotools's implementation of this factory,\n                         * and also because it is not part of FactoryGroup anyway.\n                         */\n                        result.close();\n                        exit = true;\n                        final PreparedStatement cstmt =\n                                prepareStatement(\n                                        \"ConcatenatedOperation\",\n                                        \"SELECT SINGLE_OPERATION_CODE\"\n                                                + \" FROM [Coordinate_Operation Path]\"\n                                                + \" WHERE (CONCAT_OPERATION_CODE = ?)\"\n                                                + \" ORDER BY OP_PATH_STEP\");\n                        cstmt.setString(1, epsg);\n                        final List<String> codes = new ArrayList<>();\n                        try (ResultSet cr = cstmt.executeQuery()) {\n                            while (cr.next()) {\n                                codes.add(cr.getString(1));\n                            }\n                        }\n                        final CoordinateOperation[] operations =\n                                new CoordinateOperation[codes.size()];\n                        if (!safetyGuard.add(epsg)) {\n                            throw recursiveCall(ConcatenatedOperation.class, epsg);\n                        }\n                        try {\n                            for (int i = 0; i < operations.length; i++) {\n                                operations[i] = createCoordinateOperation(codes.get(i));\n                            }\n                        } finally {\n                            safetyGuard.remove(epsg);\n                        }\n                        try {\n                            return new DefaultConcatenatedOperation(properties, operations);\n                        } catch (IllegalArgumentException exception) {\n                            // May happen if there is less than 2 operations to concatenate.\n                            // It happen for some deprecated CRS like 8658 for example.\n                            throw new FactoryException(exception);\n                        }\n                    } else {\n                        /*\n                         * Needs to create a math transform. A special processing is performed for\n                         * datum shift methods, since the conversion from ellipsoid to geocentric\n                         * for \"geocentric translations\" is implicit in the EPSG database. Even in\n                         * the case of Molodenski transforms, the axis length to set are the same.\n                         */\n                        if (isBursaWolf)\n                            try {\n                                Ellipsoid ellipsoid = CRSUtilities.getHeadGeoEllipsoid(sourceCRS);\n                                if (ellipsoid != null) {\n                                    final Unit<Length> axisUnit = ellipsoid.getAxisUnit();\n                                    parameters\n                                            .parameter(\"src_semi_major\")\n                                            .setValue(ellipsoid.getSemiMajorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"src_semi_minor\")\n                                            .setValue(ellipsoid.getSemiMinorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"src_dim\")\n                                            .setValue(\n                                                    sourceCRS.getCoordinateSystem().getDimension());\n                                }\n                                ellipsoid = CRSUtilities.getHeadGeoEllipsoid(targetCRS);\n                                if (ellipsoid != null) {\n                                    final Unit axisUnit = ellipsoid.getAxisUnit();\n                                    parameters\n                                            .parameter(\"tgt_semi_major\")\n                                            .setValue(ellipsoid.getSemiMajorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"tgt_semi_minor\")\n                                            .setValue(ellipsoid.getSemiMinorAxis(), axisUnit);\n                                    parameters\n                                            .parameter(\"tgt_dim\")\n                                            .setValue(\n                                                    targetCRS.getCoordinateSystem().getDimension());\n                                }\n                            } catch (ParameterNotFoundException exception) {\n                                result.close();\n                                throw new FactoryException(\n                                        Errors.format(\n                                                ErrorKeys.GEOTOOLS_EXTENSION_REQUIRED_$1,\n                                                method.getName().getCode(),\n                                                exception));\n                            }\n                        /*\n                         * At this stage, the parameters are ready for use. Creates the math transform\n                         * and wraps it in the final operation (a Conversion or a Transformation).\n                         */\n                        final Class<? extends CoordinateOperation> expected;\n                        if (isTransformation) {\n                            expected = Transformation.class;\n                        } else if (isConversion) {\n                            expected = Conversion.class;\n                        } else {\n                            result.close();\n                            throw new FactoryException(\n                                    Errors.format(ErrorKeys.UNKNOW_TYPE_$1, type));\n                        }\n                        final MathTransform mt =\n                                factories\n                                        .getMathTransformFactory()\n                                        .createBaseToDerived(\n                                                sourceCRS,\n                                                parameters,\n                                                targetCRS.getCoordinateSystem());\n                        // TODO: uses GeoAPI factory method once available.\n                        operation =\n                                DefaultOperation.create(\n                                        properties, sourceCRS, targetCRS, mt, method, expected);\n                    }\n                    returnValue = ensureSingleton(operation, returnValue, code);\n                    if (exit) {\n                        // Bypass the 'result.close()' line below:\n                        // the ResultSet has already been closed.\n                        return returnValue;\n                    }\n                }\n            }\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateOperation.class, code, exception);\n        }\n        if (returnValue == null) {\n            throw noSuchAuthorityCode(CoordinateOperation.class, code);\n        }\n        return returnValue;\n    }\n\n    /**\n     * Creates operations from coordinate reference system codes. The returned set is ordered with\n     * the most accurate operations first.\n     *\n     * @param sourceCode Coded value of source coordinate reference system.\n     * @param targetCode Coded value of target coordinate reference system.\n     * @throws FactoryException if the object creation failed.\n     * @todo The ordering is not consistent among all database software, because the \"accuracy\"\n     *     column may contains null values. When used in an \"ORDER BY\" clause, PostgreSQL put null\n     *     values last, while Access and HSQL put them first. The PostgreSQL's behavior is better\n     *     for what we want (put operations with unknow accuracy last). Unfortunatly, I don't know\n     *     yet how to instruct Access to put null values last using standard SQL (\"IIF\" is not\n     *     standard, and Access doesn't seem to understand \"CASE ... THEN\" clauses).\n     */\n    @Override\n    public synchronized Set generateFromCoordinateReferenceSystemCodes(\n            final String sourceCode, final String targetCode) throws FactoryException {\n        ensureNonNull(\"sourceCode\", sourceCode);\n        ensureNonNull(\"targetCode\", targetCode);\n        final String pair = sourceCode + \" \\u21E8 \" + targetCode;\n        final CoordinateOperationSet set = new CoordinateOperationSet(this);\n        try {\n            final String sourceKey = toPrimaryKeyCRS(sourceCode);\n            final String targetKey = toPrimaryKeyCRS(targetCode);\n            boolean searchTransformations = false;\n            do {\n                /*\n                 * This 'do' loop is executed twice: the first time for searching defining\n                 * conversions, and the second time for searching all other kind of operations.\n                 * Defining conversions are searched first because they are, by definition, the\n                 * most accurate operations.\n                 */\n                final String key, sql;\n                if (searchTransformations) {\n                    key = \"TransformationFromCRS\";\n                    sql =\n                            \"SELECT COORD_OP_CODE\"\n                                    + \" FROM [Coordinate_Operation]\"\n                                    + \" WHERE SOURCE_CRS_CODE = ?\"\n                                    + \" AND TARGET_CRS_CODE = ?\"\n                                    + \" ORDER BY ABS(DEPRECATED), COORD_OP_ACCURACY\";\n                } else {\n                    key = \"ConversionFromCRS\";\n                    sql =\n                            \"SELECT PROJECTION_CONV_CODE\"\n                                    + \" FROM [Coordinate Reference System]\"\n                                    + \" WHERE SOURCE_GEOGCRS_CODE = ?\"\n                                    + \" AND COORD_REF_SYS_CODE = ?\";\n                }\n                final PreparedStatement stmt = prepareStatement(key, sql);\n                stmt.setString(1, sourceKey);\n                stmt.setString(2, targetKey);\n                try (ResultSet result = stmt.executeQuery()) {\n                    while (result.next()) {\n                        final String code = getString(result, 1, pair);\n                        set.addAuthorityCode(code, searchTransformations ? null : targetKey);\n                    }\n                }\n            } while ((searchTransformations = !searchTransformations) == true);\n            /*\n             * Search finished. We may have a lot of coordinate operations\n             * (e.g. about 40 for \"ED50\" (EPSG:4230) to \"WGS 84\" (EPSG:4326)).\n             * Alter the ordering using the information supplied in the supersession table.\n             */\n            final String[] codes = set.getAuthorityCodes();\n            sort(codes);\n            set.setAuthorityCodes(codes);\n        } catch (SQLException exception) {\n            throw databaseFailure(CoordinateOperation.class, pair, exception);\n        }\n        /*\n         * Before to return the set, tests the creation of 1 object in order to report early\n         * (i.e. now) any problems with SQL statements. Remaining operations will be created\n         * only when first needed.\n         */\n        set.resolve(1);\n        return set;\n    }\n\n    /**\n     * Sorts an array of codes in preference order. This method orders pairwise the codes according\n     * the information provided in the supersession table. If the same object is superseded by more\n     * than one object, then the most recent one is inserted first. Except for the codes moved as a\n     * result of pairwise ordering, this method try to preserve the old ordering of the supplied\n     * codes (since deprecated operations should already be last). The ordering is performed in\n     * place.\n     *\n     * @param codes The codes, usually as an array of {@link String}. If the array do not contains\n     *     string objects, then the {@link Object#toString} method must returns the code for each\n     *     element.\n     */\n    // TODO: Use generic type for \"Object[] codes\" with J2SE 1.5.\n    private void sort(final Object... codes) throws SQLException, FactoryException {\n        if (codes.length <= 1) {\n            return; // Nothing to sort.\n        }\n        final PreparedStatement stmt =\n                prepareStatement(\n                        \"Supersession\",\n                        \"SELECT SUPERSEDED_BY\"\n                                + \" FROM [Supersession]\"\n                                + \" WHERE OBJECT_CODE = ?\"\n                                + \" ORDER BY SUPERSESSION_YEAR DESC\");\n        int maxIterations = 15; // For avoiding never-ending loop.\n        do {\n            boolean changed = false;\n            for (int i = 0; i < codes.length; i++) {\n                final String code = codes[i].toString();\n                stmt.setString(1, code);\n                try (ResultSet result = stmt.executeQuery()) {\n                    while (result.next()) {\n                        final String replacement = getString(result, 1, code);\n                        for (int j = i + 1; j < codes.length; j++) {\n                            final Object candidate = codes[j];\n                            if (replacement.equals(candidate.toString())) {\n                                /*\n                                 * Found a code to move in front of the superceded one.\n                                 */\n                                System.arraycopy(codes, i, codes, i + 1, j - i);\n                                codes[i++] = candidate;\n                                changed = true;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!changed) {\n                return;\n            }\n        } while (--maxIterations != 0);\n        LOGGER.finer(\"Possible recursivity in supersessions.\");\n    }\n\n    /**\n     * An implementation of {@link IdentifiedObjectFinder} which scans over a smaller set of\n     * authority codes.\n     *\n     * <p><b>Implementation note:</b> Since this method may be invoked indirectly by {@link\n     * LongitudeFirstFactory}, it must be insensitive to axis order.\n     */\n    private final class Finder extends IdentifiedObjectFinder {\n        /** Creates a new finder backed by the specified <em>buffered</em> authority factory. */\n        Finder(final Class<? extends IdentifiedObject> type) {\n            super(AbstractEpsgFactory.this, type);\n        }\n\n        /**\n         * Returns a set of authority codes that <strong>may</strong> identify the same object than\n         * the specified one. This implementation tries to get a smaller set than what {@link\n         * AbstractEpsgFactory#getAuthorityCodes} would produce.\n         */\n        @Override\n        protected Set<String> getCodeCandidates(final IdentifiedObject object)\n                throws FactoryException {\n            String select = \"COORD_REF_SYS_CODE\";\n            String from = \"[Coordinate Reference System]\";\n            String where, code;\n            if (object instanceof Ellipsoid) {\n                select = \"ELLIPSOID_CODE\";\n                from = \"[Ellipsoid]\";\n                where = \"SEMI_MAJOR_AXIS\";\n                code = Double.toString(((Ellipsoid) object).getSemiMajorAxis());\n            } else {\n                IdentifiedObject dependency;\n                if (object instanceof GeneralDerivedCRS) {\n                    dependency = ((GeneralDerivedCRS) object).getBaseCRS();\n                    where = \"SOURCE_GEOGCRS_CODE\";\n                } else if (object instanceof SingleCRS) {\n                    dependency = ((SingleCRS) object).getDatum();\n                    where = \"DATUM_CODE\";\n                } else if (object instanceof GeodeticDatum) {\n                    dependency = ((GeodeticDatum) object).getEllipsoid();\n                    select = \"DATUM_CODE\";\n                    from = \"[Datum]\";\n                    where = \"ELLIPSOID_CODE\";\n                } else {\n                    return super.getCodeCandidates(object);\n                }\n                dependency = getIdentifiedObjectFinder(dependency.getClass()).find(dependency);\n                Identifier id = AbstractIdentifiedObject.getIdentifier(dependency, getAuthority());\n                if (id == null || (code = id.getCode()) == null) {\n                    return super.getCodeCandidates(object);\n                }\n            }\n            String sql =\n                    \"SELECT \" + select + \" FROM \" + from + \" WHERE \" + where + \"='\" + code + '\\'';\n            sql = adaptSQL(sql);\n            final Set<String> result = new LinkedHashSet<>();\n            try (Statement s = getConnection().createStatement();\n                    ResultSet r = s.executeQuery(sql)) {\n                while (r.next()) {\n                    result.add(r.getString(1));\n                }\n            } catch (SQLException exception) {\n                throw databaseFailure(Identifier.class, code, exception);\n            }\n            return result;\n        }\n    }\n\n    /** Constructs an exception for recursive calls. */\n    private static FactoryException recursiveCall(\n            final Class<? extends IdentifiedObject> type, final String code) {\n        return new FactoryException(Errors.format(ErrorKeys.RECURSIVE_CALL_$2, type, code));\n    }\n\n    /** Constructs an exception for a database failure. */\n    private static FactoryException databaseFailure(\n            final Class<? extends Object> type, final String code, final SQLException cause) {\n        return new FactoryException(\n                Errors.format(ErrorKeys.DATABASE_FAILURE_$2, type, code), cause);\n    }\n\n    /**\n     * Invoked when a new {@link PreparedStatement} is about to be created from a SQL string. Since\n     * the <A HREF=\"http://www.epsg.org\">EPSG database</A> is available mainly in MS-Access format,\n     * SQL statements are formatted using some syntax specific to this particular database software\n     * (for example \"<code>SELECT * FROM [Coordinate Reference System]</code>\"). When prociding\n     * subclass targeting another database vendor, then this method should be overridden in order to\n     * adapt the local SQL syntax.\n     *\n     * <p>For example a subclass connecting to a <cite>PostgreSQL</cite> database could replace all\n     * spaces (\"&nbsp;\") between watching braces (\"[\" and \"]\") by underscore (\"_\").\n     *\n     * @param statement The statement in MS-Access syntax.\n     * @return The SQL statement to use. The default implementation returns the string unchanged.\n     */\n    protected abstract String adaptSQL(final String statement);\n\n    /**\n     * Returns {@code true} if the specified code may be a primary key in some table. This method do\n     * not needs to checks any entry in the database. It should just checks from the syntax if the\n     * code looks like a valid EPSG identifier. The default implementation returns {@code true} if\n     * all non-space characters are {@linkplain Character#isDigit(char) digits}.\n     *\n     * <p>When this method returns {@code false}, some {@code createFoo(...)} methods look for the\n     * code in the name column instead of the primary key column. This allows to accept the\n     * \"<cite>NTF (Paris) / France I</cite>\" string (for example) in addition to the {@code \"27581\"}\n     * primary key. Both should fetch the same object.\n     *\n     * <p>If this method returns {@code true} in all cases, then this factory never search for\n     * matching names. In such case, an appropriate exception will be thrown in {@code\n     * createFoo(...)} methods if the code is not found in the primary key column. Subclasses can\n     * overrides this method that way if this is the intended behavior.\n     *\n     * @param code The code the inspect.\n     * @return {@code true} if the code is probably a primary key.\n     * @throws FactoryException if an unexpected error occured while inspecting the code.\n     */\n    protected boolean isPrimaryKey(final String code) throws FactoryException {\n        final int length = code.length();\n        for (int i = 0; i < length; i++) {\n            final char c = code.charAt(i);\n            if (!Character.isDigit(c) && !Character.isSpaceChar(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} if it is safe to dispose this factory. This method is invoked indirectly\n     * by {@link ThreadedEpsgFactory} after some timeout in order to release resources. This method\n     * will block the disposal if some {@linkplain #getAuthorityCodes set of authority codes} are\n     * still in use.\n     */\n    final synchronized boolean canDispose() {\n        return true;\n    }\n\n    /**\n     * Disposes any resources hold by this object.\n     *\n     * @throws FactoryException if an error occurred while closing the connection.\n     */\n    @Override\n    public synchronized void dispose() throws FactoryException {\n        disconnect();\n        super.dispose();\n    }\n\n    /** Connect to the database in anticipation of of use. */\n    public void connect() throws FactoryException {\n        try {\n            getConnection();\n        } catch (SQLException e) {\n            throw new FactoryException(e);\n        }\n    }\n    /**\n     * Disconnect from the database, and remain idle. We will still keep our internal data\n     * structures, we are not going to hold onto a database connection unless we are going to be\n     * used.\n     */\n    public void disconnect() throws FactoryException {\n        if (connection != null) {\n            final boolean isClosed;\n            try {\n                isClosed = connection.isClosed();\n                for (final Iterator<PreparedStatement> it = statements.values().iterator();\n                        it.hasNext(); ) {\n                    (it.next()).close();\n                    it.remove();\n                }\n                connection.close();\n            } catch (SQLException exception) {\n                throw new FactoryException(exception);\n            }\n            if (!isClosed) {\n                /*\n                 * The above code was run unconditionally as a safety, even if the connection\n                 * was already closed. However we will log a message only if we actually closed\n                 * the connection, otherwise the log records are a little bit misleading.\n                 */\n                final LogRecord record =\n                        Loggings.format(Level.FINE, LoggingKeys.CLOSED_EPSG_DATABASE);\n                record.setLoggerName(LOGGER.getName());\n                LOGGER.log(record);\n            }\n            connection = null;\n        }\n    }\n\n    /**\n     * Access to the connection used by this EpsgFactory. The connection will be created as needed.\n     *\n     * @return the connection\n     */\n    protected synchronized Connection getConnection() throws SQLException {\n        if (connection == null) {\n            connection = dataSource.getConnection();\n        }\n        return connection;\n    }\n    /**\n     * Shutdown the database engine. This method is invoked twice by {@link ThreadedEpsgFactory} at\n     * JVM shutdown: one time before the {@linkplain #connection} is closed, and a second time\n     * after. This shutdown hook is useful for <cite>embedded</cite> database engine starting a\n     * server process in addition to the client process. Just closing the connection is not enough\n     * for them. Example:\n     *\n     * <p>\n     *\n     * <UL>\n     *   <LI>HSQL database engine needs to execute a {@code \"SHUTDOWN\"} statement using the\n     *       {@linkplain #connection} before it is closed.\n     *   <LI>Derby database engine needs to instruct the {@linkplain java.sql.DriverManager driver\n     *       manager} after all connections have been closed.\n     * </UL>\n     *\n     * <p>The default implementation does nothing, which is sufficient for implementations\n     * connecting to a distant server (i.e. non-embedded database engine), for example {@linkplain\n     * AccessDataSource MS-Access} or {@linkplain PostgreDataSource PostgreSQL}.\n     *\n     * @param active {@code true} if the {@linkplain #connection} is alive, or {@code false}\n     *     otherwise. This method is invoked first with {@code active} set to {@code true}, then a\n     *     second time with {@code active} set to {@code false}.\n     * @throws SQLException if this method failed to shutdown the database engine.\n     */\n    protected void shutdown(final boolean active) throws SQLException {}\n\n    /**\n     * Invokes {@link #dispose} when this factory is garbage collected.\n     *\n     * @throws Throwable if an error occurred while closing the connection.\n     */\n    @Override\n    @SuppressWarnings(\"deprecation\") // finalize is deprecated in Java 9\n    protected final void finalize() throws Throwable {\n        dispose();\n        super.finalize();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    //////                                                                                 ///////\n    //////   HARD CODED VALUES (other than SQL statements) RELATIVE TO THE EPSG DATABASE   ///////\n    //////                                                                                 ///////\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /**\n     * Returns a hard-coded unit from an EPSG code. We do not need to provide all units here, but we\n     * must at least provide all base units declared in the [TARGET_UOM_CODE] column of table [Unit\n     * of Measure]. Other units will be derived automatically if they are not listed here.\n     *\n     * @param code The code.\n     * @return The unit, or {@code null} if the code is unrecognized.\n     */\n    private static Unit<?> getUnit(final int code) {\n        switch (code) {\n            case 9001:\n                return METRE;\n            case 9002:\n                return FOOT;\n            case 9030:\n                return NAUTICAL_MILE;\n            case 9036:\n                return KILOMETER;\n            case 9101:\n                return RADIAN;\n            case 9122: // Fall through\n            case 9102:\n                return DEGREE_ANGLE;\n            case 9103:\n                return MINUTE_ANGLE;\n            case 9104:\n                return SECOND_ANGLE;\n            case 9105:\n                return GRADE;\n            case 9107:\n                return DEGREE_MINUTE_SECOND;\n            case 9108:\n                return DEGREE_MINUTE_SECOND;\n            case 9109:\n                return MICRORADIAN;\n            case 9110:\n                return SEXAGESIMAL_DMS;\n                // TODO case 9111: return NonSI.SEXAGESIMAL_DM;\n            case 9203: // Fall through\n            case 9201:\n                return ONE;\n            case 9202:\n                return PPM;\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Set a Bursa-Wolf parameter from an EPSG parameter.\n     *\n     * @param parameters The Bursa-Wolf parameters to modify.\n     * @param code The EPSG code for a parameter from [PARAMETER_CODE] column.\n     * @param value The value of the parameter from [PARAMETER_VALUE] column.\n     * @param unit The unit of the parameter value from [UOM_CODE] column.\n     * @throws FactoryException if the code is unrecognized.\n     * @throws IllegalArgumentException if the value could not be converted to the provided Unit\n     */\n    private static void setBursaWolfParameter(\n            final BursaWolfParameters parameters, final int code, double value, final Unit<?> unit)\n            throws FactoryException {\n        Unit<?> target = unit;\n        if (code >= 8605) {\n            if (code <= 8607) target = SI.METRE;\n            else if (code == 8611) target = Units.PPM;\n            else if (code <= 8710) target = NonSI.SECOND_ANGLE;\n        }\n        if (target != unit) {\n            value = Units.getConverterToAny(unit, target).convert(value);\n        }\n        switch (code) {\n            case 8605:\n                parameters.dx = value;\n                break;\n            case 8606:\n                parameters.dy = value;\n                break;\n            case 8607:\n                parameters.dz = value;\n                break;\n            case 8608:\n                parameters.ex = value;\n                break;\n            case 8609:\n                parameters.ey = value;\n                break;\n            case 8610:\n                parameters.ez = value;\n                break;\n            case 8611:\n                parameters.ppm = value;\n                break;\n            default:\n                throw new FactoryException(Errors.format(ErrorKeys.UNEXPECTED_PARAMETER_$1, code));\n        }\n    }\n\n    /**\n     * List of tables and columns to test for codes values. This table is used by the {@link\n     * #createObject} method in order to detect which of the following methods should be invoked for\n     * a given code:\n     *\n     * <p>{@link #createCoordinateReferenceSystem} {@link #createCoordinateSystem} {@link\n     * #createDatum} {@link #createEllipsoid} {@link #createUnit}\n     *\n     * <p>The order is significant: it is the key for a {@code switch} statement.\n     *\n     * @see #createObject\n     * @see #lastObjectType\n     */\n    private static final TableInfo[] TABLES_INFO = {\n        new TableInfo(\n                CoordinateReferenceSystem.class,\n                \"[Coordinate Reference System]\",\n                \"COORD_REF_SYS_CODE\",\n                \"COORD_REF_SYS_NAME\",\n                \"COORD_REF_SYS_KIND\",\n                new Class[] {ProjectedCRS.class, GeographicCRS.class, GeocentricCRS.class},\n                new String[] {\"projected\", \"geographic\", \"geocentric\"}),\n        new TableInfo(\n                CoordinateSystem.class,\n                \"[Coordinate System]\",\n                \"COORD_SYS_CODE\",\n                \"COORD_SYS_NAME\",\n                \"COORD_SYS_TYPE\",\n                new Class[] {\n                    CartesianCS.class, EllipsoidalCS.class, SphericalCS.class, VerticalCS.class\n                },\n                new String[] {\"Cartesian\", \"ellipsoidal\", \"spherical\", \"vertical\"}),\n        new TableInfo(\n                CoordinateSystemAxis.class,\n                \"[Coordinate Axis] AS CA INNER JOIN [Coordinate Axis Name] AS CAN\"\n                        + \" ON CA.COORD_AXIS_NAME_CODE=CAN.COORD_AXIS_NAME_CODE\",\n                \"COORD_AXIS_CODE\",\n                \"COORD_AXIS_NAME\"),\n        new TableInfo(\n                Datum.class,\n                \"[Datum]\",\n                \"DATUM_CODE\",\n                \"DATUM_NAME\",\n                \"DATUM_TYPE\",\n                new Class[] {GeodeticDatum.class, VerticalDatum.class, EngineeringDatum.class},\n                new String[] {\"geodetic\", \"vertical\", \"engineering\"}),\n        new TableInfo(Ellipsoid.class, \"[Ellipsoid]\", \"ELLIPSOID_CODE\", \"ELLIPSOID_NAME\"),\n        new TableInfo(\n                PrimeMeridian.class,\n                \"[Prime Meridian]\",\n                \"PRIME_MERIDIAN_CODE\",\n                \"PRIME_MERIDIAN_NAME\"),\n        new TableInfo(\n                CoordinateOperation.class,\n                \"[Coordinate_Operation]\",\n                \"COORD_OP_CODE\",\n                \"COORD_OP_NAME\",\n                \"COORD_OP_TYPE\",\n                new Class[] {Projection.class, Conversion.class, Transformation.class},\n                new String[] {\"conversion\", \"conversion\", \"transformation\"}),\n        // Note: Projection is handle in a special way.\n\n        new TableInfo(\n                OperationMethod.class,\n                \"[Coordinate_Operation Method]\",\n                \"COORD_OP_METHOD_CODE\",\n                \"COORD_OP_METHOD_NAME\"),\n        new TableInfo(\n                ParameterDescriptor.class,\n                \"[Coordinate_Operation Parameter]\",\n                \"PARAMETER_CODE\",\n                \"PARAMETER_NAME\"),\n        new TableInfo(Unit.class, \"[Unit of Measure]\", \"UOM_CODE\", \"UNIT_OF_MEAS_NAME\")\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    ////////                                                               ////////\n    ////////        E N D   O F   H A R D   C O D E D   V A L U E S        ////////\n    ////////                                                               ////////\n    ////////    NOTE: 'createFoo(...)' methods may still have hard-coded   ////////\n    ////////    values (others than SQL statements) in 'equalsIgnoreCase'  ////////\n    ////////    expressions.                                               ////////\n    ///////////////////////////////////////////////////////////////////////////////\n    /**\n     * A set of EPSG authority codes. This set makes use of our connection to the EPSG database. All\n     * {@link #iterator} method call creates a new {@link ResultSet} holding the codes. However,\n     * call to {@link #contains} map directly to a SQL call.\n     *\n     * <p>Serialization of this class store a copy of all authority codes. The serialization do not\n     * preserve any connection to the database.\n     *\n     * @since 2.2\n     * @version $Id$\n     * @author Martin Desruisseaux (IRD)\n     */\n    final class AuthorityCodeSet extends AbstractSet<String> implements Serializable {\n        /** For compatibility with different versions. */\n        private static final long serialVersionUID = 7105664579449680562L;\n\n        /**\n         * The type for this code set. This is translated to the most appropriate interface type\n         * even if the user supplied an implementation type.\n         */\n        public final Class<?> type;\n\n        /** {@code true} if {@link #type} is assignable to {@link Projection}. */\n        private final boolean isProjection;\n\n        /**\n         * A view of this set as a map with object's name as values, or {@code null} if none. Will\n         * be created only when first needed.\n         */\n        private transient java.util.Map<String, String> asMap;\n\n        /**\n         * The SQL command to use for creating the {@code queryAll} statement. Used for iteration\n         * over all codes.\n         */\n        final String sqlAll;\n\n        /**\n         * The SQL command to use for creating the {@code querySingle} statement. Used for fetching\n         * the description from a code.\n         */\n        private final String sqlSingle;\n\n        /** The statement to use for querying all codes. Will be created only when first needed. */\n        private transient PreparedStatement queryAll;\n\n        /**\n         * The statement to use for querying a single code. Will be created only when first needed.\n         */\n        private transient PreparedStatement querySingle;\n\n        /**\n         * The collection's size, or a negative value if not yet computed. The records will be\n         * counted only when first needed. The special value -2 if set by {@link #isEmpty} if the\n         * size has not yet been computed, but we know that the set is not empty.\n         */\n        private int size = -1;\n\n        /**\n         * Creates a new set of authority codes for the specified type.\n         *\n         * @param table The table to query.\n         * @param type The type to query.\n         */\n        public AuthorityCodeSet(final TableInfo table, final Class type) {\n            final StringBuilder buffer = new StringBuilder(\"SELECT \");\n            buffer.append(table.codeColumn);\n            if (table.nameColumn != null) {\n                buffer.append(\", \").append(table.nameColumn);\n            }\n            buffer.append(\" FROM \").append(table.table);\n            boolean hasWhere = false;\n            Class tableType = table.type;\n            if (table.typeColumn != null) {\n                for (int i = 0; i < table.subTypes.length; i++) {\n                    final Class<?> candidate = table.subTypes[i];\n                    if (candidate.isAssignableFrom(type)) {\n                        buffer.append(\" WHERE (\")\n                                .append(table.typeColumn)\n                                .append(\" LIKE '\")\n                                .append(table.typeNames[i])\n                                .append(\"%'\");\n                        hasWhere = true;\n                        tableType = candidate;\n                        break;\n                    }\n                }\n                if (hasWhere) {\n                    buffer.append(')');\n                }\n            }\n            this.type = tableType;\n            isProjection = Projection.class.isAssignableFrom(tableType);\n            final int length = buffer.length();\n            buffer.append(\" ORDER BY \").append(table.codeColumn);\n            sqlAll = adaptSQL(buffer.toString());\n            buffer.setLength(length);\n            buffer.append(hasWhere ? \" AND \" : \" WHERE \").append(table.codeColumn).append(\" = ?\");\n            sqlSingle = adaptSQL(buffer.toString());\n        }\n\n        /** Returns all codes. */\n        private ResultSet getAll() throws SQLException {\n            assert Thread.holdsLock(this);\n            if (queryAll != null) {\n                try {\n                    return queryAll.executeQuery();\n                } catch (SQLException ignore) {\n                    /*\n                     * Failed to reuse an existing statement. This problem occurs in some occasions\n                     * with the JDBC-ODBC bridge in Java 6 (the error message is \"Invalid handle\").\n                     * I'm not sure where the bug come from (didn't noticed it when using HSQL). We\n                     * will try again with a new statement created in the code after this 'catch'\n                     * clause. Note that we set 'queryAll' to null first in case of failure during\n                     * the 'prepareStatement(...)' execution.\n                     */\n                    queryAll.close();\n                    queryAll = null;\n                    recoverableException(\"getAll\", ignore);\n                }\n            }\n            queryAll = getConnection().prepareStatement(sqlAll);\n            return queryAll.executeQuery();\n        }\n\n        /** Returns a single code. */\n        private ResultSet getSingle(final Object code) throws SQLException {\n            assert Thread.holdsLock(this);\n            if (querySingle == null) {\n                querySingle = getConnection().prepareStatement(sqlSingle);\n            }\n            querySingle.setString(1, code.toString());\n            return querySingle.executeQuery();\n        }\n\n        /**\n         * Returns {@code true} if the code in the specified result set is acceptable. This method\n         * handle projections in a special way.\n         */\n        private boolean isAcceptable(final ResultSet results) throws SQLException {\n            if (!isProjection) {\n                return true;\n            }\n            final String code = results.getString(1);\n            return isProjection(code);\n        }\n\n        /**\n         * Returns {@code true} if the code in the specified code is acceptable. This method handle\n         * projections in a special way.\n         */\n        private boolean isAcceptable(final String code) throws SQLException {\n            if (!isProjection) {\n                return true;\n            }\n            return isProjection(code);\n        }\n\n        /**\n         * Returns {@code true} if this collection contains no elements. This method fetch at most\n         * one row instead of counting all rows.\n         */\n        @Override\n        public synchronized boolean isEmpty() {\n            if (size != -1) {\n                return size == 0;\n            }\n            boolean empty = true;\n            try {\n                try (ResultSet results = getAll()) {\n                    while (results.next()) {\n                        if (isAcceptable(results)) {\n                            empty = false;\n                            break;\n                        }\n                    }\n                }\n            } catch (SQLException exception) {\n                unexpectedException(\"isEmpty\", exception);\n            }\n            size = empty ? 0 : -2;\n            return empty;\n        }\n\n        /** Count the number of elements in the underlying result set. */\n        @Override\n        public synchronized int size() {\n            if (size >= 0) {\n                return size;\n            }\n            int count = 0;\n            try {\n                try (ResultSet results = getAll()) {\n                    while (results.next()) {\n                        if (isAcceptable(results)) {\n                            count++;\n                        }\n                    }\n                }\n            } catch (SQLException exception) {\n                unexpectedException(\"size\", exception);\n            }\n            size = count; // Stores only on success.\n            return count;\n        }\n\n        /** Returns {@code true} if this collection contains the specified element. */\n        @Override\n        public synchronized boolean contains(final Object code) {\n            boolean exists = false;\n            if (code != null)\n                try {\n                    try (ResultSet results = getSingle(code)) {\n                        while (results.next()) {\n                            if (isAcceptable(results)) {\n                                exists = true;\n                                break;\n                            }\n                        }\n                    }\n                } catch (SQLException exception) {\n                    unexpectedException(\"contains\", exception);\n                }\n            return exists;\n        }\n\n        /**\n         * Returns an iterator over the codes. The iterator is backed by a living {@link ResultSet},\n         * which will be closed as soon as the iterator reach the last element.\n         */\n        @Override\n        public synchronized java.util.Iterator<String> iterator() {\n            try {\n                final Iterator iterator = new Iterator(getAll());\n                /*\n                 * Set the statement to null without closing it, in order to force a new statement\n                 * creation if getAll() is invoked before the iterator finish its iteration.  This\n                 * is needed because only one ResultSet is allowed for each Statement.\n                 */\n                queryAll = null;\n                return iterator;\n            } catch (SQLException exception) {\n                unexpectedException(\"iterator\", exception);\n                final Set<String> empty = Collections.emptySet();\n                return empty.iterator();\n            }\n        }\n\n        /**\n         * Returns a serializable copy of this set. This method is invoked automatically during\n         * serialization. The serialised set of authority code is disconnected from the underlying\n         * database.\n         */\n        protected LinkedHashSet<String> writeReplace() throws ObjectStreamException {\n            return new LinkedHashSet<>(this);\n        }\n\n        /**\n         * Closes the underlying statements. Note: this method is also invoked directly by {@link\n         * DirectEpsgFactory#dispose}, which is okay in this particular case since the\n         * implementation of this method can be executed an arbitrary amount of times.\n         */\n        @Override\n        @SuppressWarnings(\"deprecation\") // finalize is deprecated in Java 9\n        protected synchronized void finalize() throws SQLException {\n            if (querySingle != null) {\n                querySingle.close();\n                querySingle = null;\n            }\n            if (queryAll != null) {\n                queryAll.close();\n                queryAll = null;\n            }\n        }\n\n        /** Invoked when an exception occured. This method just log a warning. */\n        private void unexpectedException(final String method, final SQLException exception) {\n            unexpectedException(AuthorityCodes.class, method, exception);\n        }\n\n        /** Invoked when an exception occured. This method just log a warning. */\n        void unexpectedException(\n                final Class classe, final String method, final SQLException exception) {\n            Logging.unexpectedException(LOGGER, classe, method, exception);\n        }\n\n        /** Invoked when a recoverable exception occured. */\n        private void recoverableException(final String method, final SQLException exception) {\n            // Uses the FINE level instead of WARNING because it may be a recoverable error.\n            LogRecord record = Loggings.format(Level.FINE, LoggingKeys.UNEXPECTED_EXCEPTION);\n            record.setSourceClassName(AuthorityCodes.class.getName());\n            record.setSourceMethodName(method);\n            record.setThrown(exception);\n            record.setLoggerName(LOGGER.getName());\n            LOGGER.log(record);\n        }\n\n        /**\n         * The iterator over the codes. This inner class must kept a reference toward the enclosing\n         * {@link AuthorityCodes} in order to prevent a call to {@link AuthorityCodes#finalize}\n         * before the iteration is finished.\n         */\n        private final class Iterator implements java.util.Iterator<String> {\n            /** The result set, or {@code null} if there is no more elements. */\n            private ResultSet results;\n\n            /** The next code. */\n            private transient String next;\n\n            /** Creates a new iterator for the specified result set. */\n            Iterator(final ResultSet results) throws SQLException {\n                assert Thread.holdsLock(AuthorityCodeSet.this);\n                this.results = results;\n                toNext();\n            }\n\n            /** Moves to the next element. */\n            private void toNext() throws SQLException {\n                while (results.next()) {\n                    next = results.getString(1);\n                    if (isAcceptable(next)) {\n                        return;\n                    }\n                }\n                finalize();\n            }\n\n            /** Returns {@code true} if there is more elements. */\n            @Override\n            public boolean hasNext() {\n                return results != null;\n            }\n\n            /** Returns the next element. */\n            @Override\n            public String next() {\n                if (results == null) {\n                    throw new NoSuchElementException();\n                }\n                final String current = next;\n                try {\n                    toNext();\n                } catch (SQLException exception) {\n                    results = null;\n                    unexpectedException(Iterator.class, \"next\", exception);\n                }\n                return current;\n            }\n\n            /** Always throws an exception, since this iterator is read-only. */\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n\n            /** Closes the underlying result set. */\n            @Override\n            @SuppressWarnings(\"deprecation\") // finalize is deprecated in Java 9\n            protected void finalize() throws SQLException {\n                next = null;\n                if (results != null) {\n                    final PreparedStatement owner = (PreparedStatement) results.getStatement();\n                    results.close();\n                    results = null;\n                    synchronized (AuthorityCodeSet.this) {\n                        /*\n                         * We don't need the statement anymore. Gives it back to the enclosing class\n                         * in order to avoid creating a new one when AuthorityCodes.getAll() will be\n                         * invoked again,  or closes the statement if getAll() already created a new\n                         * statement anyway.\n                         */\n                        assert owner != queryAll;\n                        if (queryAll == null) {\n                            queryAll = owner;\n                        } else {\n                            owner.close();\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Returns a view of this set as a map with object's name as value, or {@code null} if none.\n         */\n        final java.util.Map<String, String> asMap() {\n            if (asMap == null) {\n                asMap = new Map();\n            }\n            return asMap;\n        }\n\n        /**\n         * A view of {@link AuthorityCodes} as a map, with authority codes as key and object names\n         * as values.\n         */\n        private final class Map extends AbstractMap<String, String> {\n            /** Returns the number of key-value mappings in this map. */\n            @Override\n            public int size() {\n                return AuthorityCodeSet.this.size();\n            }\n\n            /** Returns {@code true} if this map contains no key-value mappings. */\n            @Override\n            public boolean isEmpty() {\n                return AuthorityCodeSet.this.isEmpty();\n            }\n\n            /** Returns the description to which this map maps the specified EPSG code. */\n            @Override\n            public String get(final Object code) {\n                String value = null;\n                if (code != null)\n                    try {\n                        synchronized (AuthorityCodeSet.this) {\n                            try (ResultSet results = getSingle(code)) {\n                                while (results.next()) {\n                                    if (isAcceptable(results)) {\n                                        value = results.getString(2);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    } catch (SQLException exception) {\n                        unexpectedException(\"get\", exception);\n                    }\n                return value;\n            }\n\n            /** Returns {@code true} if this map contains a mapping for the specified EPSG code. */\n            @Override\n            public boolean containsKey(final Object key) {\n                return contains(key);\n            }\n\n            /** Returns a set view of the keys contained in this map. */\n            @Override\n            public Set<String> keySet() {\n                return AuthorityCodeSet.this;\n            }\n\n            /**\n             * Returns a set view of the mappings contained in this map.\n             *\n             * @todo Not yet implemented.\n             */\n            @Override\n            public Set<Map.Entry<String, String>> entrySet() {\n                throw new UnsupportedOperationException();\n            }\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2001-2008, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.referencing.factory.epsg;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.util.jar.Attributes.Name;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport org.geotools.metadata.i18n.ErrorKeys;\nimport org.geotools.metadata.i18n.Errors;\nimport org.geotools.metadata.i18n.LoggingKeys;\nimport org.geotools.metadata.i18n.Loggings;\nimport org.geotools.metadata.i18n.Vocabulary;\nimport org.geotools.metadata.i18n.VocabularyKeys;\nimport org.geotools.metadata.iso.citation.Citations;\nimport org.geotools.referencing.ReferencingFactoryFinder;\nimport org.geotools.referencing.factory.AbstractAuthorityFactory;\nimport org.geotools.referencing.factory.DeferredAuthorityFactory;\nimport org.geotools.referencing.factory.FactoryNotFoundException;\nimport org.geotools.referencing.factory.ReferencingFactoryContainer;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.factory.Hints;\nimport org.opengis.metadata.citation.Citation;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.crs.CRSAuthorityFactory;\nimport org.opengis.referencing.cs.CSAuthorityFactory;\nimport org.opengis.referencing.datum.DatumAuthorityFactory;\nimport org.opengis.referencing.operation.CoordinateOperationAuthorityFactory;\n\n/**\n * Base class for EPSG factories to be registered in {@link ReferencingFactoryFinder}. Various\n * subclasses are defined for different database backends: Access, PostgreSQL, HSQL,\n * <cite>etc.</cite>.\n *\n * <p>This class has the following responsibilities:\n *\n * <ul>\n *   <li>aquire a DataSource (using JNDI or otherwise)\n *   <li>specify a worker class that will talk to the database in the event of a cache miss. The\n *       class will be specific to the delect of SQL used by the database hosting the EPSG tables.\n * </ul>\n *\n * Please note we are working with <b>the same</b> tables as defined by EPSG. The only thing that\n * changes is the database used to host these tables.\n *\n * <p>Subclasses should override the following methods:\n *\n * <ul>\n *   <li>{@linkplain #createDataSource} used to aquire a DataSource\n *   <li>{@link #createBackingStore} instance capable to speak that database syntax\n * </ul>\n *\n * <p>Users should not creates instance of this class directly. They should invoke one of <code>\n * {@linkplain ReferencingFactoryFinder}.getFooAuthorityFactory(\"EPSG\")</code> methods instead.\n *\n * @since 2.4\n * @version $Id$\n * @author Martin Desruisseaux (IRD)\n */\npublic class ThreadedEpsgFactory extends DeferredAuthorityFactory\n        implements CRSAuthorityFactory,\n                CSAuthorityFactory,\n                DatumAuthorityFactory,\n                CoordinateOperationAuthorityFactory {\n    /**\n     * The default JDBC {@linkplain DataSource data source} name in JNDI. This is the name used if\n     * no other name were specified through the {@link Hints#EPSG_DATA_SOURCE EPSG_DATA_SOURCE}\n     * hint.\n     *\n     * @see #createDataSource\n     */\n    public static final String DATASOURCE_NAME = \"java:comp/env/jdbc/EPSG\";\n\n    /** The default priority level for this factory. */\n    protected static final int PRIORITY = MAXIMUM_PRIORITY - 10;\n\n    /** The factories to be given to the backing store. */\n    private final ReferencingFactoryContainer factories;\n\n    /**\n     * The data source name. If it was not specified by the {@link Hints#EPSG_DATA_SOURCE\n     * EPSG_DATA_SOURCE} hint, then this is the {@value #DATASOURCE_NAME} value.\n     */\n    private String datasourceName;\n\n    /** The data source, or {@code null} if the connection has not yet been etablished. */\n    protected DataSource datasource;\n\n    /**\n     * Whether the DataSource is created along with the backing store, or it's a stable, long lived\n     * one\n     */\n    protected boolean dynamicDataSource = true;\n\n    /** Constructs an authority factory using the default set of factories. */\n    public ThreadedEpsgFactory() {\n        this(null);\n    }\n\n    /** Constructs an authority factory with the default priority. */\n    public ThreadedEpsgFactory(final Hints userHints) {\n        this(userHints, PRIORITY);\n    }\n\n    /**\n     * Constructs an authority factory using a set of factories created from the specified hints.\n     * This constructor recognizes the {@link Hints#CRS_FACTORY CRS}, {@link Hints#CS_FACTORY CS},\n     * {@link Hints#DATUM_FACTORY DATUM} and {@link Hints#MATH_TRANSFORM_FACTORY MATH_TRANSFORM}\n     * {@code FACTORY} hints, in addition of {@link Hints#EPSG_DATA_SOURCE EPSG_DATA_SOURCE}.\n     *\n     * @param userHints An optional set of hints, or {@code null} if none.\n     * @param priority The priority for this factory, as a number between {@link #MINIMUM_PRIORITY\n     *     MINIMUM_PRIORITY} and {@link #MAXIMUM_PRIORITY MAXIMUM_PRIORITY} inclusive.\n     */\n    public ThreadedEpsgFactory(final Hints userHints, final int priority) {\n        super(userHints, priority);\n\n        Object hint = (userHints == null) ? null : userHints.get(Hints.EPSG_DATA_SOURCE);\n\n        if (hint == null) {\n            datasourceName = DATASOURCE_NAME;\n            // datasourceName = GeoTools.fixName(DATASOURCE_NAME);\n            hints.put(Hints.EPSG_DATA_SOURCE, datasourceName);\n        } else if (hint instanceof String) {\n            datasourceName = (String) hint;\n            // datasourceName = GeoTools.fixName(datasourceName);\n            hints.put(Hints.EPSG_DATA_SOURCE, datasourceName);\n        } else if (hint instanceof Name) {\n            Name name = (Name) hint;\n            hints.put(Hints.EPSG_DATA_SOURCE, name);\n            datasourceName = name.toString();\n            // datasourceName = GeoTools.fixName(name.toString());\n        } else if (hint instanceof DataSource) {\n            datasource = (DataSource) hint;\n            hints.put(Hints.EPSG_DATA_SOURCE, datasource);\n            datasourceName = DATASOURCE_NAME;\n            dynamicDataSource = false;\n        }\n        factories = ReferencingFactoryContainer.instance(userHints);\n        long timeout = 30 * 60 * 1000;\n        String defaultTimeout =\n                System.getProperty(\n                        \"org.geotools.epsg.factory.timeout\", String.valueOf(30 * 60 * 1000));\n        try {\n            timeout = Long.valueOf(defaultTimeout);\n        } catch (NumberFormatException e) {\n            LOGGER.log(\n                    Level.WARNING,\n                    \"Invalid value for org.geotools.epsg.factory.timeout, \"\n                            + \"using the default (30 minutes) instead\");\n        }\n        // in case of negative timeout, we don't release the data source and backing store\n        if (timeout > 0) {\n            LOGGER.log(\n                    Level.FINE,\n                    \"Setting the EPSG factory \"\n                            + getClass().getName()\n                            + \" to a \"\n                            + timeout\n                            + \"ms timeout\");\n            setTimeout(timeout); // Close the connection after 1 second of inactivity.\n        } else {\n            LOGGER.log(\n                    Level.FINE, \"The EPSG factory \" + getClass().getName() + \" will not timeout\");\n        }\n    }\n\n    /**\n     * Returns the authority for this EPSG database. This authority will contains the database\n     * version in the {@linkplain Citation#getEdition edition} attribute, together with the\n     * {@linkplain Citation#getEditionDate edition date}.\n     */\n    @Override\n    public Citation getAuthority() {\n        final Citation authority = super.getAuthority();\n        return (authority != null) ? authority : Citations.EPSG;\n    }\n\n    /**\n     * Returns the data source for the EPSG database. If no data source has been previously\n     * {@linkplain #setDataSource set}, then this method invokes {@link #createDataSource}.\n     * <strong>Note:</strong> invoking this method may force immediate connection to the EPSG\n     * database.\n     *\n     * @return The data source.\n     * @throws SQLException if the connection to the EPSG database failed.\n     * @see #setDataSource\n     * @see #createDataSource\n     */\n    public final synchronized DataSource getDataSource() throws SQLException {\n        if (datasource == null) {\n            // Force the creation of the underlying backing store. It will invokes\n            // (indirectly) createBackingStore, which will fetch the DataSource.\n            if (!super.isAvailable()) {\n                // Connection failed, but the exception is not available.\n                datasource = null;\n                throw new SQLException(Errors.format(ErrorKeys.NO_DATA_SOURCE));\n            }\n        }\n        return datasource;\n    }\n\n    /**\n     * Set the data source for the EPSG database. If an other EPSG database was already in use, it\n     * will be disconnected. Users should not invoke this method on the factory returned by {@link\n     * ReferencingFactoryFinder}, since it could have a system-wide effect.\n     *\n     * @param datasource The new datasource.\n     * @throws SQLException if an error occured.\n     */\n    public synchronized void setDataSource(final DataSource datasource) throws SQLException {\n        if (datasource != this.datasource) {\n            try {\n                dispose();\n            } catch (FactoryException exception) {\n                final Throwable cause = exception.getCause();\n                if (cause instanceof SQLException) {\n                    throw (SQLException) cause;\n                }\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                }\n                // Not really an SQL exception, but we should not reach this point anyway.\n                final SQLException e = new SQLException(exception.getLocalizedMessage());\n                e.initCause(exception); // TODO: inline when we will be allowed to target Java 6.\n                throw e;\n            }\n            this.datasource = datasource;\n        }\n    }\n\n    /**\n     * Setup a data source for a connection to the EPSG database. This method is invoked by {@link\n     * #getDataSource()} when no data source has been {@linkplain #setDataSource explicitly set}.\n     * The default implementation searchs for a {@link DataSource} instance binded to the {@link\n     * Hints#EPSG_DATA_SOURCE} name (<code>{@value #DATASOURCE_NAME}</code> by default) using\n     * <cite>Java Naming and Directory Interfaces</cite> (JNDI). If no data source were found, then\n     * this method returns {@code null}.\n     *\n     * <p>Subclasses override this method in order to initialize a default data source when none\n     * were found with JNDI. For example {@code plugin/epsg-access} defines a default data source\n     * using the JDBC-ODBC bridge, which expects an \"{@code EPSG}\" database registered as an ODBC\n     * data source (see the {@linkplain org.geotools.referencing.factory.epsg package javadoc} for\n     * installation instructions). Example for a PostgreSQL data source:\n     *\n     * <blockquote>\n     *\n     * <pre>\n     * protected DataSource createDataSource() throws SQLException {\n     *     DataSource candidate = super.createDataSource();\n     *     if (candidate instanceof Jdbc3SimpleDataSource) {\n     *         return candidate;\n     *     }\n     *     Jdbc3SimpleDataSource ds = new Jdbc3SimpleDataSource();\n     *     ds.setServerName(\"localhost\");\n     *     ds.setDatabaseName(\"EPSG\");\n     *     ds.setUser(\"postgre\");\n     *     return ds;\n     * }\n     * </pre>\n     *\n     * </blockquote>\n     *\n     * @return The EPSG data source, or {@code null} if none where found.\n     * @throws SQLException if an error occured while creating the data source.\n     */\n    protected DataSource createDataSource() throws SQLException {\n        DataSource source = null;\n        try {\n            source = (DataSource) GeoTools.jndiLookup(datasourceName);\n        } catch (IllegalArgumentException | NamingException exception) {\n            // Fall back on 'return null' below.\n        }\n        return source;\n    }\n\n    /**\n     * Creates the backing store for the specified data source. This method usually returns a new\n     * instance of {@link AccessDialectEpsgFactory} or {@link AnsiDialectEpsgFactory}. Subclasses\n     * may override this method in order to returns an instance tuned for the SQL syntax of the\n     * underlying database. Example for a PostgreSQL data source:\n     *\n     * <blockquote>\n     *\n     * <pre>\n     * protected AbstractAuthorityFactory createBackingStore(Hints hints) throws SQLException {\n     *     return new AnsiDialectEpsgFactory(hints, getDataSource().getConnection());\n     * }\n     * </pre>\n     *\n     * </blockquote>\n     *\n     * @param hints A map of hints, including the low-level factories to use for CRS creation. This\n     *     argument should be given unchanged to {@code DirectEpsgFactory} constructor.\n     * @return The {@linkplain DirectEpsgFactory EPSG factory} using SQL queries appropriate for\n     *     this data source.\n     * @throws SQLException if connection to the database failed.\n     */\n    protected AbstractAuthorityFactory createBackingStore(final Hints hints) throws SQLException {\n        final DataSource source = getDataSource();\n        try (Connection connection = source.getConnection()) {\n\n            final String quote = connection.getMetaData().getIdentifierQuoteString();\n            if (quote.equals(\"\\\"\")) {\n                /*\n                 * PostgreSQL quotes the indentifiers with \"...\" while MS-Access quotes the\n                 * identifiers with [...], so we use the identifier quote string metadata as\n                 * a way to distinguish the two cases. However I'm not sure that it is a robust\n                 * criterion. Subclasses should always override as a safety.\n                 */\n                return new FactoryUsingAnsiSQL(hints, connection);\n            }\n            return new FactoryUsingSQL(hints, connection);\n        }\n    }\n\n    /**\n     * Gets the EPSG factory implementation connected to the database. This method is invoked\n     * automatically by {@link #createBackingStore()}.\n     *\n     * @return The connection to the EPSG database.\n     * @throws FactoryException if no data source were found.\n     * @throws SQLException if this method failed to etablish a connection.\n     * @todo Inline this method into {@link #createBackingStore()} after we removed the deprecated\n     *     code.\n     */\n    private AbstractAuthorityFactory createBackingStore0() throws FactoryException, SQLException {\n        /*\n         * We are locking on ReferencingFactoryFinder to avoid deadlocks.\n         * @see DeferredAuthorityFactory#getBackingStore()\n         */\n        assert Thread.holdsLock(ReferencingFactoryFinder.class);\n        final Hints sourceHints = new Hints(hints);\n        sourceHints.putAll(factories.getImplementationHints());\n        if (datasource != null) {\n            return createBackingStore(sourceHints);\n        }\n        /*\n         * Try to gets the DataSource from JNDI. In case of success, it will be tried\n         * for a connection before any DataSource declared in META-INF/services/.\n         */\n        DataSource source = createDataSource();\n        if (source == null) {\n            throw new FactoryNotFoundException(Errors.format(ErrorKeys.NO_DATA_SOURCE));\n        }\n        final AbstractAuthorityFactory factory;\n        try {\n            datasource = source;\n            factory = createBackingStore(sourceHints);\n        } finally {\n            datasource = null;\n        }\n        this.datasource = source; // Stores the data source only after success.\n        return factory;\n    }\n\n    /**\n     * Creates the backing store authority factory.\n     *\n     * @return The backing store to uses in {@code createXXX(...)} methods.\n     * @throws FactoryException if the constructor failed to connect to the EPSG database. This\n     *     exception usually has a {@link SQLException} as its cause.\n     */\n    @Override\n    protected AbstractAuthorityFactory createBackingStore() throws FactoryException {\n        final AbstractAuthorityFactory factory;\n        String product = '<' + Vocabulary.format(VocabularyKeys.UNKNOWN) + '>';\n        String url = product;\n        try {\n            factory = createBackingStore0();\n            if (factory instanceof DirectEpsgFactory) {\n                final DatabaseMetaData info =\n                        ((DirectEpsgFactory) factory).getConnection().getMetaData();\n                product = info.getDatabaseProductName();\n                url = info.getURL();\n            }\n        } catch (SQLException exception) {\n            throw new FactoryException(\n                    Errors.format(ErrorKeys.CANT_CONNECT_DATABASE_$1, \"EPSG\"), exception);\n        }\n        log(Loggings.format(Level.CONFIG, LoggingKeys.CONNECTED_EPSG_DATABASE_$2, url, product));\n        if (factory instanceof DirectEpsgFactory) {\n            ((DirectEpsgFactory) factory).buffered = this;\n        }\n        return factory;\n    }\n\n    /** For internal use by {@link #createFactory()} and {@link #createBackingStore()} only. */\n    private static void log(final LogRecord record) {\n        record.setSourceClassName(ThreadedEpsgFactory.class.getName());\n        record.setSourceMethodName(\"createBackingStore\"); // The public caller.\n        record.setLoggerName(LOGGER.getName());\n        LOGGER.log(record);\n    }\n\n    /**\n     * Returns {@code true} if the backing store can be disposed now. This method is invoked\n     * automatically after the amount of time specified by {@link #setTimeout} if the factory were\n     * not used during that time.\n     *\n     * @param backingStore The backing store in process of being disposed.\n     */\n    @Override\n    protected boolean canDisposeBackingStore(final AbstractAuthorityFactory backingStore) {\n        if (backingStore instanceof DirectEpsgFactory) {\n            return ((DirectEpsgFactory) backingStore).canDispose();\n        }\n        return super.canDisposeBackingStore(backingStore);\n    }\n\n    @Override\n    protected void disposeBackingStore() {\n        super.disposeBackingStore();\n        if (dynamicDataSource) {\n            datasource = null;\n        }\n    }\n\n    @Override\n    public synchronized void dispose() throws FactoryException {\n        super.dispose();\n        datasource = null;\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2019, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geotools.gce.pgraster;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.geotools.data.jdbc.datasource.DBCPDataSource;\nimport org.geotools.util.factory.GeoTools;\nimport org.geotools.util.logging.Logging;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\n/**\n * Configuration for a {@link PGRasterReader}.\n *\n * <p>Configuration is stored as XML with the following basic format:\n *\n * <pre>\n *     &lt;pgraster>\n *       &lt;name//>        // coverage name\n *       &lt;database>     // database connection\n *         &lt;host//>      // database host\n *         &lt;port//>      // database port\n *         &lt;name//>      // database name\n *         &lt;user//>      // database username\n *         &lt;pass//>      // database user password\n *       &lt;/database>\n *       &lt;raster>       // raster column config\n *         &lt;column//>      // column name\n *         &lt;table//>     // table name\n *         &lt;schema//>    // table schema\n *       &lt;/raster>\n *       &lt;time>        // time column config\n *         &lt;enabled//>  // enable / disable time\n *         &lt;column//>     // column name\n *       &lt;/time>\n *     &lt;/pgraster>\n *   </pre>\n */\nclass PGRasterConfig implements Closeable {\n\n    static final Logger LOG = Logging.getLogger(PGRasterConfig.class);\n\n    String name;\n    DataSource dataSource;\n    String schema;\n    String table;\n    String column;\n    String enableDrivers;\n\n    TimeConfig time = new TimeConfig();\n\n    static Document parse(File cfgfile) {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db;\n        try {\n            db = dbf.newDocumentBuilder();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error creating XML parser\");\n        }\n\n        try {\n            return db.parse(cfgfile);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error parsing pgraster config\", e);\n        }\n    }\n\n    PGRasterConfig(File configFile) {\n        this(parse(configFile));\n    }\n\n    PGRasterConfig(Document config) {\n        Element root = config.getDocumentElement();\n        if (!\"pgraster\".equalsIgnoreCase(root.getNodeName())) {\n            throw new IllegalArgumentException(\n                    \"Not a postgis raster configuration, root element must be 'pgraster'\");\n        }\n\n        this.name = first(root, \"name\").map(this::nodeValue).orElse(null);\n        this.enableDrivers = first(root, \"enableDrivers\").map(this::nodeValue).orElse(null);\n\n        Element db =\n                first(config.getDocumentElement(), \"database\")\n                        .orElseThrow(\n                                () ->\n                                        new IllegalArgumentException(\n                                                \"Config has no database element\"));\n\n        DataSource dataSource = null;\n\n        String jndi = first(db, \"jndi\").map(this::nodeValue).orElse(null);\n        if (jndi != null) {\n            try {\n                dataSource = (DataSource) GeoTools.jndiLookup(jndi);\n            } catch (NamingException e) {\n                throw new IllegalArgumentException(\"Error performing JNDI lookup for: \" + jndi, e);\n            }\n        }\n\n        if (dataSource == null) {\n            BasicDataSource source = new BasicDataSource();\n            source.setDriverClassName(\"org.postgresql.Driver\");\n\n            String host = first(db, \"host\").map(this::nodeValue).orElse(\"localhost\");\n\n            Integer port =\n                    first(db, \"port\").map(this::nodeValue).map(Integer::parseInt).orElse(5432);\n\n            String name =\n                    first(db, \"name\")\n                            .map(this::nodeValue)\n                            .orElseThrow(\n                                    () ->\n                                            new IllegalArgumentException(\n                                                    \"database 'name' not specified\"));\n\n            source.setUrl(\"jdbc:postgresql://\" + host + \":\" + port + \"/\" + name);\n\n            first(db, \"user\").map(this::nodeValue).ifPresent(source::setUsername);\n\n            first(db, \"passwd\").map(this::nodeValue).ifPresent(source::setPassword);\n\n            first(db, \"pool\")\n                    .ifPresent(\n                            p -> {\n                                first(p, \"min\")\n                                        .map(this::nodeValue)\n                                        .map(Integer::parseInt)\n                                        .ifPresent(source::setMinIdle);\n                                first(p, \"max\")\n                                        .map(this::nodeValue)\n                                        .map(Integer::parseInt)\n                                        .ifPresent(source::setMaxActive);\n                            });\n\n            dataSource = new PGRasterDataSource(source);\n        }\n\n        this.dataSource = dataSource;\n\n        Element ras =\n                first(config.getDocumentElement(), \"raster\")\n                        .orElseThrow(\n                                () ->\n                                        new IllegalArgumentException(\n                                                \"Config has no 'raster' element\"));\n\n        this.schema = first(ras, \"schema\").map(this::nodeValue).orElse(\"public\");\n        this.table =\n                first(ras, \"table\")\n                        .map(this::nodeValue)\n                        .orElseThrow(\n                                () ->\n                                        new IllegalArgumentException(\n                                                \"column must specify a 'table' element\"));\n        this.column = first(ras, \"column\").map(this::nodeValue).orElse(null);\n\n        // time\n        first(config.getDocumentElement(), \"time\")\n                .ifPresent(\n                        el -> {\n                            first(el, \"enabled\")\n                                    .map(this::nodeValue)\n                                    .map(Boolean::parseBoolean)\n                                    .ifPresent(it -> time.enabled = it);\n                            first(el, \"column\")\n                                    .map(this::nodeValue)\n                                    .ifPresent(it -> time.column = it);\n                        });\n    }\n\n    @VisibleForTesting\n    PGRasterConfig() {}\n\n    Optional<Element> first(Element el, String name) {\n        NodeList matches = el.getElementsByTagName(name);\n        if (matches.getLength() > 0) {\n            return Optional.of((Element) matches.item(0));\n        }\n        return Optional.empty();\n    }\n\n    String nodeValue(Element el) {\n        return el.getFirstChild().getNodeValue();\n    }\n\n    @Override\n    public void close() {\n        if (dataSource instanceof PGRasterDataSource) {\n            try {\n                ((PGRasterDataSource) dataSource).close();\n            } catch (SQLException e) {\n                LOG.log(Level.WARNING, \"Error closing data source\", e);\n            }\n        }\n    }\n\n    static class TimeConfig {\n        boolean enabled = true;\n        String column;\n    }\n\n    static class PGRasterDataSource extends DBCPDataSource {\n\n        PGRasterDataSource(BasicDataSource wrapped) {\n            super(wrapped);\n        }\n    }\n}\n"], "filenames": ["docs/user/library/metadata/geotools.rst", "docs/user/welcome/upgrade.rst", "modules/library/jdbc/src/main/java/org/geotools/data/jdbc/datasource/JNDIDataSourceFactory.java", "modules/library/jdbc/src/main/java/org/geotools/jdbc/JDBCJNDIDataStoreFactory.java", "modules/library/metadata/pom.xml", "modules/library/metadata/src/main/java/org/geotools/util/factory/GeoTools.java", "modules/library/metadata/src/test/java/org/geotools/util/factory/FactoryRegistryTest.java", "modules/library/metadata/src/test/java/org/geotools/util/factory/GeoToolsTest.java", "modules/library/referencing/src/main/java/org/geotools/referencing/factory/AbstractEpsgMediator.java", "modules/library/referencing/src/main/java/org/geotools/referencing/factory/epsg/AbstractEpsgFactory.java", "modules/library/referencing/src/main/java/org/geotools/referencing/factory/epsg/ThreadedEpsgFactory.java", "modules/unsupported/postgis-raster/src/main/java/org/geotools/gce/pgraster/PGRasterConfig.java"], "buggy_code_start_loc": [58, 71, 67, 24, 136, 27, 70, 31, 23, 306, 25, 120], "buggy_code_end_loc": [65, 71, 92, 144, 136, 1092, 70, 264, 81, 307, 421, 121], "fixing_code_start_loc": [58, 72, 67, 23, 137, 28, 71, 32, 22, 306, 24, 120], "fixing_code_end_loc": [71, 94, 87, 131, 142, 1165, 72, 309, 77, 307, 369, 121], "type": "CWE-20", "message": "GeoTools is an open source Java library that provides tools for geospatial data. The GeoTools library has a number of data sources that can perform unchecked JNDI lookups, which in turn can be used to perform class deserialization and result in arbitrary code execution. Similar to the Log4J case, the vulnerability can be triggered if the JNDI names are user-provided, but requires admin-level login to be triggered. The lookups are now restricted in GeoTools 26.4, GeoTools 25.6, and GeoTools 24.6. Users unable to upgrade should ensure that any downstream application should not allow usage of remotely provided JNDI strings.", "other": {"cve": {"id": "CVE-2022-24818", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-13T21:15:07.753", "lastModified": "2022-04-21T18:00:50.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GeoTools is an open source Java library that provides tools for geospatial data. The GeoTools library has a number of data sources that can perform unchecked JNDI lookups, which in turn can be used to perform class deserialization and result in arbitrary code execution. Similar to the Log4J case, the vulnerability can be triggered if the JNDI names are user-provided, but requires admin-level login to be triggered. The lookups are now restricted in GeoTools 26.4, GeoTools 25.6, and GeoTools 24.6. Users unable to upgrade should ensure that any downstream application should not allow usage of remotely provided JNDI strings."}, {"lang": "es", "value": "GeoTools es una biblioteca Java de c\u00f3digo abierto que proporciona herramientas para datos geoespaciales. La biblioteca GeoTools presenta una serie de fuentes de datos que pueden llevar a cabo b\u00fasquedas JNDI no verificadas, que a su vez pueden ser usadas para llevar a cabo una deserializaci\u00f3n de clases y resultar en una ejecuci\u00f3n de c\u00f3digo arbitrario. Al igual que en el caso de Log4J, la vulnerabilidad puede desencadenarse si los nombres JNDI son proporcionados por el usuario, pero requiere un inicio de sesi\u00f3n a nivel de administrador para activarse. Las b\u00fasquedas est\u00e1n ahora restringidas en GeoTools versi\u00f3n 26.4, GeoTools versi\u00f3n 25.6 y GeoTools versi\u00f3n 24.6. Los usuarios que no puedan actualizar deben asegurarse de que cualquier aplicaci\u00f3n posterior no permita el uso de cadenas JNDI proporcionadas de forma remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:geotools:geotools:*:*:*:*:*:*:*:*", "versionEndExcluding": "24.6", "matchCriteriaId": "F68492E7-1B2A-4854-B4EE-921899EC15D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:geotools:geotools:*:*:*:*:*:*:*:*", "versionStartIncluding": "25.0", "versionEndExcluding": "25.6", "matchCriteriaId": "CEC38324-CCBF-46BE-9D58-1D821EAB22D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:geotools:geotools:*:*:*:*:*:*:*:*", "versionStartIncluding": "26.0", "versionEndExcluding": "26.4", "matchCriteriaId": "A3235DAF-46D9-4ACD-8D36-467B26513BA7"}]}]}], "references": [{"url": "https://github.com/geotools/geotools/commit/4f70fa3234391dd0cda883a20ab0ec75688cba49", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/geotools/geotools/security/advisories/GHSA-jvh2-668r-g75x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/geotools/geotools/commit/4f70fa3234391dd0cda883a20ab0ec75688cba49"}}