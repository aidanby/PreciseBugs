{"buggy_code": ["<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2018 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Controls read and write access to datbase tables\n *\n * This class should help you to read and write records of database tables.\n * You create an object for a special table and than you are able to read\n * a special record, manipulate him and write him back. Also new records can\n * be created with this class. The advantage of this class is that you are\n * independent from SQL. You can use @c getValue, @c setValue, @c readData\n * and @c save to handle the record.\n *\n * **Code example:**\n * ```\n * // create an object for table adm_roles of role 4711\n * $roleId = 4177;\n * $role = new TableAccess($gDb, TBL_ROLES, 'rol', $roleId);\n *\n * // read max. Members and add 1 to the count\n * $maxMembers = $role->getValue('rol_max_members');\n * $maxMembers = $maxMembers + 1;\n * $role->setValue('rol_max_members', $maxMembers);\n * $role->save();\n * ```\n */\nclass TableAccess\n{\n    /**\n     * @var array<string,string> Array with sub array that contains additional tables and their connected fields that should be selected when data is read\n     */\n    protected $additionalTables = array();\n    /**\n     * @var string Name of the database table of this object. This must be the table name with the installation specific praefix e.g. **demo_users**\n     */\n    protected $tableName;\n    /**\n     * @var string The praefix of each column that this table has. E.g. the table adm_users has the column praefix **usr**\n     */\n    protected $columnPrefix;\n    /**\n     * @var string Name of the unique autoincrement index column of the database table\n     */\n    protected $keyColumnName;\n    /**\n     * @var Database An object of the class Database for communication with the database\n     */\n    protected $db;\n\n    /**\n     * @var bool Merker, ob ein neuer Datensatz oder vorhandener Datensatz bearbeitet wird\n     */\n    protected $newRecord;\n    /**\n     * @var bool Flag will be set to true if data in array dbColumns was changed\n     */\n    protected $columnsValueChanged;\n    /**\n     * @var array<string,mixed> Array ueber alle Felder der entsprechenden Tabelle zu dem gewaehlten Datensatz\n     */\n    protected $dbColumns = array();\n    /**\n     * @var array<string,array<string,mixed>> Array, welches weitere Informationen (geaendert ja/nein, Feldtyp) speichert\n     */\n    protected $columnsInfos = array();\n\n    /**\n     * Constructor that will create an object of a recordset of the specified table.\n     * If the id is set than this recordset will be loaded.\n     * @param Database   $database     Object of the class Database. This should be the default global object **$gDb**.\n     * @param string     $tableName    The name of the database table. Because of specific praefixes this should be the define value e.g. **TBL_USERS**\n     * @param string     $columnPrefix The prefix of each column of that table. E.g. for table **adm_roles** this is **rol**\n     * @param string|int $id           The id of the recordset that should be loaded. If id isn't set than an empty object of the table is created.\n     */\n    public function __construct(Database $database, $tableName, $columnPrefix, $id = '')\n    {\n        $this->db          =& $database;\n        $this->tableName    = $tableName;\n        $this->columnPrefix = $columnPrefix;\n\n        // only initialize if not set before through child constructor\n        if(!is_array($this->additionalTables))\n        {\n            $this->additionalTables = array();\n        }\n\n        // if a id is commited, then read data out of database\n        if ($id > 0)\n        {\n            $this->readDataById($id);\n        }\n        else\n        {\n            $this->clear();\n        }\n    }\n\n    /**\n     * An wakeup add the current database object to this class\n     */\n    public function __wakeup()\n    {\n        global $gDb;\n\n        if ($gDb instanceof Database)\n        {\n            $this->db = $gDb;\n        }\n    }\n\n    /**\n     * Initializes all class parameters and deletes all read data.\n     * Also the database structure of the associated table will be\n     * read and stored in the arrays **dbColumns** and **columnsInfos**\n     */\n    public function clear()\n    {\n        $this->newRecord = true;\n        $this->columnsValueChanged = false;\n\n        if (count($this->columnsInfos) > 0)\n        {\n            // die Spalteninfos wurden bereits eingelesen\n            // und werden nun nur noch neu initialisiert\n            foreach ($this->dbColumns as $fieldName => &$fieldValue)\n            {\n                $fieldValue = ''; // $this->dbColumns[$fieldName] = '';\n                $this->columnsInfos[$fieldName]['changed'] = false;\n            }\n            unset($fieldValue);\n        }\n        else\n        {\n            // alle Spalten der Tabelle ins Array einlesen und auf leer setzen\n            $tableColumnsProperties = $this->db->getTableColumnsProperties($this->tableName);\n\n            foreach ($tableColumnsProperties as $columnName => $property)\n            {\n                $this->dbColumns[$columnName] = '';\n                $this->columnsInfos[$columnName]['changed'] = false;\n                $this->columnsInfos[$columnName]['type']    = $property['type'];\n                $this->columnsInfos[$columnName]['null']    = $property['null'];\n                $this->columnsInfos[$columnName]['key']     = $property['key'];\n                $this->columnsInfos[$columnName]['serial']  = $property['serial'];\n\n                if ($property['serial'])\n                {\n                    $this->keyColumnName = $columnName;\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds a table with the connected fields to a member array. This table will be add to the\n     * select statement if data is read and the connected record is available in this class.\n     * The connected table must have a foreign key in the class table.\n     * @param string $table                     Database table name that should be connected. This can be the define of the table.\n     * @param string $columnNameAdditionalTable Name of the column in the connected table that has the foreign key to the class table\n     * @param string $columnNameClassTable      Name of the column in the class table that has the foreign key to the connected table\n     *\n     * **Code example:**\n     * ```\n     * // Constructor of adm_dates object where the category (calendar) is connected\n     * public function __construct($database, $datId = 0)\n     * {\n     *     $this->connectAdditionalTable(TBL_CATEGORIES, 'cat_id', 'dat_cat_id');\n     *     parent::__construct($db, TBL_DATES, 'dat', $datId);\n     * }\n     * ```\n     */\n    protected function connectAdditionalTable($table, $columnNameAdditionalTable, $columnNameClassTable)\n    {\n        $this->additionalTables[] = array(\n            'table'                     => $table,\n            'columnNameAdditionalTable' => $columnNameAdditionalTable,\n            'columnNameClassTable'      => $columnNameClassTable\n        );\n    }\n\n    /**\n     * Reads the number of all records of this table\n     * @return int Number of records of this table\n     */\n    public function countAllRecords()\n    {\n        $sql = 'SELECT COUNT(*) AS count FROM '.$this->tableName;\n        $countStatement = $this->db->queryPrepared($sql);\n\n        return (int) $countStatement->fetchColumn();\n    }\n\n    /**\n     * Deletes the selected record of the table and initializes the class\n     * @return true Returns **true** if no error occurred\n     */\n    public function delete()\n    {\n        if (array_key_exists($this->keyColumnName, $this->dbColumns) && $this->dbColumns[$this->keyColumnName] !== '')\n        {\n            $sql = 'DELETE FROM '.$this->tableName.'\n                     WHERE '.$this->keyColumnName.' = ? -- $this->dbColumns[$this->keyColumnName]';\n            $this->db->queryPrepared($sql, array($this->dbColumns[$this->keyColumnName]));\n        }\n\n        $this->clear();\n        return true;\n    }\n\n    /**\n     * Get the value of a column of the database table.\n     * If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @param string $columnName The name of the database column whose value should be read\n     * @param string $format     For date or timestamp columns the format should be the date/time format e.g. **d.m.Y = '02.04.2011'**.\n     *                           For text columns the format can be **database** that would return the original database value without any transformations\n     * @return mixed Returns the value of the database column.\n     *               If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @see TableAccess#setValue\n     */\n    public function getValue($columnName, $format = '')\n    {\n        global $gSettingsManager;\n\n        $columnValue = '';\n\n        if (array_key_exists($columnName, $this->dbColumns))\n        {\n            // wenn Schluesselfeld leer ist, dann 0 zurueckgeben\n            if ($this->keyColumnName === $columnName && empty($this->dbColumns[$columnName]))\n            {\n                $columnValue = 0;\n            }\n            else\n            {\n                $columnValue = $this->dbColumns[$columnName];\n            }\n        }\n\n        if (array_key_exists((string) $columnName, $this->columnsInfos) && array_key_exists('type', $this->columnsInfos[$columnName]))\n        {\n            switch ($this->columnsInfos[$columnName]['type'])\n            {\n                // String\n                case 'char':\n                case 'varchar':\n                case 'text':\n                    if ($format !== 'database')\n                    {\n                        // if text field and format not 'database' then convert all quotes to html syntax\n                        $columnValue = htmlspecialchars($columnValue, ENT_QUOTES);\n                    }\n                    break;\n\n                // Byte\n                case 'bytea':\n                    // in PostgreSQL we must encode the stored hex value back to binary\n                    $columnValue = pack('H*', pack('H*', substr($columnValue, 2)));\n                    break;\n\n                case 'timestamp':\n                case 'date':\n                case 'time':\n                    if ($columnValue !== '' && $columnValue !== null)\n                    {\n                        if ($format === '' && isset($gSettingsManager))\n                        {\n                            if (admStrContains($this->columnsInfos[$columnName]['type'], 'timestamp'))\n                            {\n                                $format = $gSettingsManager->getString('system_date') . ' ' . $gSettingsManager->getString('system_time');\n                            }\n                            elseif (admStrContains($this->columnsInfos[$columnName]['type'], 'date'))\n                            {\n                                $format = $gSettingsManager->getString('system_date');\n                            }\n                            else\n                            {\n                                $format = $gSettingsManager->getString('system_time');\n                            }\n                        }\n\n                        // try to format the date, else output the available data\n                        try\n                        {\n                            $datetime = new \\DateTime($columnValue);\n                            $columnValue = $datetime->format($format);\n                        }\n                        catch (Exception $e)\n                        {\n                            $columnValue = $this->dbColumns[$columnName];\n                        }\n                    }\n                    break;\n            }\n        }\n\n        return $columnValue;\n    }\n\n    /**\n     * If a column of the row in this object has changed throw setValue then this method\n     * will return **true** otherwise @false\n     * @return bool Returns **true** if at least one value of one column has changed\n     *              after the recordset was loaded otherwise **false**\n     */\n    public function hasColumnsValueChanged()\n    {\n        return $this->columnsValueChanged;\n    }\n\n    /**\n     * If the recordset is new and wasn't read from database or was not stored in database\n     * then this method will return true otherwise false\n     * @return bool Returns **true** if record is not stored in database\n     */\n    public function isNewRecord()\n    {\n        return $this->newRecord;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by the conditions of the param **$sqlWhereCondition** out of the table.\n     * If the sql will find more than one record the method returns **false**.\n     * Per default all columns of the default table will be read and stored in the object.\n     * @param string           $sqlWhereCondition Conditions for the table to select one record\n     * @param array<int,mixed> $queryParams       The query params for the prepared statement\n     * @return bool Returns **true** if one record is found\n     * @see TableAccess#readDataById\n     * @see TableAccess#readDataByColumns\n     */\n    protected function readData($sqlWhereCondition, array $queryParams = array())\n    {\n        $sqlAdditionalTables = '';\n\n        // create sql to connect additional tables to the select statement\n        if (count($this->additionalTables) > 0)\n        {\n            foreach ($this->additionalTables as $arrAdditionalTable)\n            {\n                $sqlAdditionalTables .= ', '.$arrAdditionalTable['table'];\n                $sqlWhereCondition   .= ' AND '.$arrAdditionalTable['columnNameAdditionalTable'].' = '.$arrAdditionalTable['columnNameClassTable'].' ';\n            }\n        }\n\n        // if condition starts with AND then remove this\n        if (admStrStartsWith(strtoupper(ltrim($sqlWhereCondition)), 'AND'))\n        {\n            $sqlWhereCondition = substr($sqlWhereCondition, 4);\n        }\n\n        if ($sqlWhereCondition !== '')\n        {\n            $sql = 'SELECT *\n                      FROM '.$this->tableName.'\n                           '.$sqlAdditionalTables.'\n                     WHERE '.$sqlWhereCondition;\n            $readDataStatement = $this->db->queryPrepared($sql, $queryParams); // TODO add more params\n\n            if ($readDataStatement->rowCount() === 1)\n            {\n                $row = $readDataStatement->fetch();\n                $this->newRecord = false;\n\n                // Daten in das Klassenarray schieben\n                foreach ($row as $key => $value)\n                {\n                    if ($value === null)\n                    {\n                        $this->dbColumns[$key] = ''; // TODO: remove\n                    }\n                    else\n                    {\n                        $this->dbColumns[$key] = $value;\n                    }\n                }\n\n                return true;\n            }\n\n            $this->clear();\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by the unique id column in the table.\n     * Per default all columns of the default table will be read and stored in the object.\n     * @param int $id Unique id of id column of the table.\n     * @return bool Returns **true** if one record is found\n     * @see TableAccess#readData\n     * @see TableAccess#readDataByColumns\n     */\n    public function readDataById($id)\n    {\n        // initialize the object, so that all fields are empty\n        $this->clear();\n\n        // add id to sql condition\n        if ($id > 0)\n        {\n            // call method to read data out of database\n            return $this->readData(' AND ' . $this->keyColumnName . ' = ? ', array($id));\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by different columns in the table.\n     * The columns are commited with an array where every element index is the column name and the value is the column value.\n     * The columns and values must be selected so that they identify only one record.\n     * If the sql will find more than one record the method returns **false**.\n     * Per default all columns of the default table will be read and stored in the object.\n     * @param array<string,mixed> $columnArray An array where every element index is the column name and the value is the column value\n     * @return bool Returns **true** if one record is found\n     *\n     * **Code example:**\n     * ```\n     * // reads data not be mem_id but with combination of role and user id\n     * $member = new TableAccess($gDb, TBL_MEMBERS, 'rol');\n     * $member->readDataByColumn(array('mem_rol_id' => $roleId, 'mem_usr_id' => $userId));\n     * ```\n     * @see TableAccess#readData\n     * @see TableAccess#readDataById\n     */\n    public function readDataByColumns(array $columnArray)\n    {\n        // initialize the object, so that all fields are empty\n        $this->clear();\n\n        if (count($columnArray) === 0)\n        {\n            return false;\n        }\n\n        $sqlWhereCondition = '';\n\n        // add every array element as a sql condition to the condition string\n        foreach ($columnArray as $columnName => $columnValue)\n        {\n            $sqlWhereCondition .= ' AND ' . $columnName . ' = \\'' . $columnValue . '\\' ';\n        }\n\n        // call method to read data out of database\n        $returnCode = $this->readData($sqlWhereCondition);\n\n        // save the array fields in the object\n        if (!$returnCode)\n        {\n            foreach ($columnArray as $columnName => $columnValue)\n            {\n                $this->setValue($columnName, $columnValue);\n            }\n        }\n\n        return $returnCode;\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update the changed columns.\n     * If the table has columns for creator or editor than these column with their timestamp will be updated.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset\n     *                                if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true)\n    {\n        global $gCurrentUser;\n\n        if (!$this->columnsValueChanged && $this->dbColumns[$this->keyColumnName] !== '')\n        {\n            return false;\n        }\n\n        if ($updateFingerPrint && is_object($gCurrentUser) && $gCurrentUser->getValue('usr_id') > 0)\n        {\n            // besitzt die Tabelle Felder zum Speichern des Erstellers und der letzten Aenderung,\n            // dann diese hier automatisiert fuellen\n            if ($this->newRecord && array_key_exists($this->columnPrefix . '_usr_id_create', $this->dbColumns))\n            {\n                $this->setValue($this->columnPrefix . '_timestamp_create', DATETIME_NOW);\n                $this->setValue($this->columnPrefix . '_usr_id_create', $gCurrentUser->getValue('usr_id'));\n            }\n            elseif (array_key_exists($this->columnPrefix . '_usr_id_change', $this->dbColumns))\n            {\n                // Daten nicht aktualisieren, wenn derselbe User dies innerhalb von 15 Minuten gemacht hat\n                if ((int) $gCurrentUser->getValue('usr_id') !== (int) $this->getValue($this->columnPrefix . '_usr_id_create')\n                || time() > (strtotime($this->getValue($this->columnPrefix . '_timestamp_create')) + 900))\n                {\n                    $this->setValue($this->columnPrefix . '_timestamp_change', DATETIME_NOW);\n                    $this->setValue($this->columnPrefix . '_usr_id_change', $gCurrentUser->getValue('usr_id'));\n                }\n            }\n        }\n\n        // SQL-Update-Statement fuer User-Tabelle zusammenbasteln\n        $sqlFieldArray = array();\n        $sqlSetArray = array();\n        $queryParams = array();\n\n        // Schleife ueber alle DB-Felder und diese dem Update hinzufuegen\n        foreach ($this->dbColumns as $key => $value)\n        {\n            // Auto-Increment-Felder duerfen nicht im Insert/Update erscheinen\n            // Felder anderer Tabellen auch nicht\n            if (admStrStartsWith($key, $this->columnPrefix . '_')\n            && !$this->columnsInfos[$key]['serial'] && $this->columnsInfos[$key]['changed'])\n            {\n                if ($this->newRecord)\n                {\n                    if ($value !== '')\n                    {\n                        // Daten fuer ein Insert aufbereiten\n                        $sqlFieldArray[] = $key;\n                        $queryParams[] = $value;\n                    }\n                }\n                else\n                {\n                    $sqlSetArray[] = $key . ' = ?';\n\n                    // Daten fuer ein Update aufbereiten\n                    if ($value === '' || $value === null)\n                    {\n                        $queryParams[] = null;\n                    }\n                    else\n                    {\n                        $queryParams[] = $value;\n                    }\n                }\n\n                $this->columnsInfos[$key]['changed'] = false;\n            }\n        }\n\n        if ($this->newRecord)\n        {\n            // insert record and mark this object as not new and remember the new id\n            $sql = 'INSERT INTO '.$this->tableName.'\n                           ('.implode(',', $sqlFieldArray).')\n                    VALUES ('.replaceValuesArrWithQM($sqlFieldArray).')';\n            $this->db->queryPrepared($sql, $queryParams);\n\n            $this->newRecord = false;\n            if ($this->keyColumnName !== '')\n            {\n                $this->dbColumns[$this->keyColumnName] = $this->db->lastInsertId();\n            }\n        }\n        else\n        {\n            $sql = 'UPDATE '.$this->tableName.'\n                       SET '.implode(', ', $sqlSetArray).'\n                     WHERE '.$this->keyColumnName.' = ? -- $this->dbColumns[$this->keyColumnName]';\n            $queryParams[] = $this->dbColumns[$this->keyColumnName];\n            $this->db->queryPrepared($sql, $queryParams);\n        }\n\n        $this->columnsValueChanged = false;\n\n        return true;\n    }\n\n    /**\n     * The method requires an array with all fields of one recordset of the table object.\n     * These fields will be add to the object as if you read one record with **readDataById**\n     * but without a separate SQL. This method is useful if you have several recordsets of the\n     * table and want to use an table object for each recordset. So you don't have to do an\n     * separate sql read for each record. This is a performant way to fill the object with\n     * the necessary data.\n     * @param array $fieldArray An array with all fields and their values of the table. If the object has\n     *                          more connected tables than you should add the fields of these tables, too.\n     *\n     * **Code example:**\n     * ```\n     * // read all announcements with their categories\n     * $sql = 'SELECT * FROM ' . TBL_ANNOUNCEMENTS . ' INNER JOIN ' . TBL_CATEGORIES . ' ON ann_cat_id = cat_id';\n     * $announcementsStatement = $gDb->queryPrepared($sql);\n     * $announcement = new TableAnnouncements($gDb);\n     *\n     * while ($row = $announcementsStatement->fetch())\n     * {\n     *     // add each recordset to an object without a separate sql within the object\n     *     $announcement->clear();\n     *     $announcement->setArray($row);\n     *     ...\n     * }\n     * ```\n     */\n    public function setArray(array $fieldArray)\n    {\n        foreach ($fieldArray as $field => $value)\n        {\n            $this->dbColumns[$field] = $value;\n            $this->columnsInfos[$field]['changed'] = false;\n        }\n\n        $this->newRecord = empty($this->dbColumns[$this->keyColumnName]);\n    }\n\n    /**\n     * Set a new value for a column of the database table. The value is only saved in the object.\n     * You must call the method **save** to store the new value to the database. If the unique key\n     * column is set to 0 than this record will be a new record and all other columns are marked as changed.\n     * @param string $columnName The name of the database column whose value should get a new value\n     * @param mixed  $newValue   The new value that should be stored in the database field\n     * @param bool   $checkValue The value will be checked if it's valid. If set to **false** than the value will not be checked.\n     * @return bool Returns **true** if the value is stored in the current object and **false** if a check failed\n     * @see TableAccess#getValue\n     */\n    public function setValue($columnName, $newValue, $checkValue = true)\n    {\n        if (!array_key_exists($columnName, $this->dbColumns))\n        {\n            return false;\n        }\n\n        // Allgemeine Plausibilitaets-Checks anhand des Feldtyps\n        if ($checkValue && $newValue !== '')\n        {\n            switch ($this->columnsInfos[$columnName]['type'])\n            {\n                // Numeric\n                case 'integer':\n                case 'smallint':\n                    if (!is_numeric($newValue))\n                    {\n                        $newValue = '';\n                    }\n\n                    // Schluesselfelder duerfen keine 0 enthalten\n                    if ((int) $newValue === 0 &&\n                        ($this->columnsInfos[$columnName]['key'] || $this->columnsInfos[$columnName]['null']))\n                    {\n                        $newValue = '';\n                    }\n                    break;\n\n                // String\n                case 'char':\n                case 'varchar':\n                case 'text':\n                    $newValue = strStripTags($newValue);\n                    break;\n\n                // Byte/Blob\n                case 'bytea':\n                    // PostgreSQL can only store hex values in bytea, so we must decode binary in hex\n                    $newValue = bin2hex($newValue);\n                    break;\n            }\n        }\n\n        // wurde das Schluesselfeld auf 0 gesetzt, dann soll ein neuer Datensatz angelegt werden\n        if ($this->keyColumnName === $columnName && (int) $newValue === 0)\n        {\n            $this->newRecord = true;\n\n            // now mark all other columns with values of this object as changed\n            foreach ($this->dbColumns as $column => $value)\n            {\n                if (strlen((string) $value) > 0)\n                {\n                    $this->columnsInfos[$column]['changed'] = true;\n                }\n            }\n        }\n\n        if (array_key_exists($columnName, $this->dbColumns))\n        {\n            // only mark as \"changed\" if the value is different (DON'T use binary safe function!)\n            if ($this->dbColumns[$columnName] != $newValue)\n            {\n                $this->dbColumns[$columnName] = $newValue;\n                $this->columnsValueChanged = true;\n                $this->columnsInfos[$columnName]['changed'] = true;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2018 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Controls read and write access to datbase tables\n *\n * This class should help you to read and write records of database tables.\n * You create an object for a special table and than you are able to read\n * a special record, manipulate him and write him back. Also new records can\n * be created with this class. The advantage of this class is that you are\n * independent from SQL. You can use @c getValue, @c setValue, @c readData\n * and @c save to handle the record.\n *\n * **Code example:**\n * ```\n * // create an object for table adm_roles of role 4711\n * $roleId = 4177;\n * $role = new TableAccess($gDb, TBL_ROLES, 'rol', $roleId);\n *\n * // read max. Members and add 1 to the count\n * $maxMembers = $role->getValue('rol_max_members');\n * $maxMembers = $maxMembers + 1;\n * $role->setValue('rol_max_members', $maxMembers);\n * $role->save();\n * ```\n */\nclass TableAccess\n{\n    /**\n     * @var array<string,string> Array with sub array that contains additional tables and their connected fields that should be selected when data is read\n     */\n    protected $additionalTables = array();\n    /**\n     * @var string Name of the database table of this object. This must be the table name with the installation specific praefix e.g. **demo_users**\n     */\n    protected $tableName;\n    /**\n     * @var string The praefix of each column that this table has. E.g. the table adm_users has the column praefix **usr**\n     */\n    protected $columnPrefix;\n    /**\n     * @var string Name of the unique autoincrement index column of the database table\n     */\n    protected $keyColumnName;\n    /**\n     * @var Database An object of the class Database for communication with the database\n     */\n    protected $db;\n\n    /**\n     * @var bool Merker, ob ein neuer Datensatz oder vorhandener Datensatz bearbeitet wird\n     */\n    protected $newRecord;\n    /**\n     * @var bool Flag will be set to true if data in array dbColumns was changed\n     */\n    protected $columnsValueChanged;\n    /**\n     * @var array<string,mixed> Array ueber alle Felder der entsprechenden Tabelle zu dem gewaehlten Datensatz\n     */\n    protected $dbColumns = array();\n    /**\n     * @var array<string,array<string,mixed>> Array, welches weitere Informationen (geaendert ja/nein, Feldtyp) speichert\n     */\n    protected $columnsInfos = array();\n\n    /**\n     * Constructor that will create an object of a recordset of the specified table.\n     * If the id is set than this recordset will be loaded.\n     * @param Database   $database     Object of the class Database. This should be the default global object **$gDb**.\n     * @param string     $tableName    The name of the database table. Because of specific praefixes this should be the define value e.g. **TBL_USERS**\n     * @param string     $columnPrefix The prefix of each column of that table. E.g. for table **adm_roles** this is **rol**\n     * @param string|int $id           The id of the recordset that should be loaded. If id isn't set than an empty object of the table is created.\n     */\n    public function __construct(Database $database, $tableName, $columnPrefix, $id = '')\n    {\n        $this->db          =& $database;\n        $this->tableName    = $tableName;\n        $this->columnPrefix = $columnPrefix;\n\n        // only initialize if not set before through child constructor\n        if(!is_array($this->additionalTables))\n        {\n            $this->additionalTables = array();\n        }\n\n        // if a id is commited, then read data out of database\n        if ($id > 0)\n        {\n            $this->readDataById($id);\n        }\n        else\n        {\n            $this->clear();\n        }\n    }\n\n    /**\n     * An wakeup add the current database object to this class\n     */\n    public function __wakeup()\n    {\n        global $gDb;\n\n        if ($gDb instanceof Database)\n        {\n            $this->db = $gDb;\n        }\n    }\n\n    /**\n     * Initializes all class parameters and deletes all read data.\n     * Also the database structure of the associated table will be\n     * read and stored in the arrays **dbColumns** and **columnsInfos**\n     */\n    public function clear()\n    {\n        $this->newRecord = true;\n        $this->columnsValueChanged = false;\n\n        if (count($this->columnsInfos) > 0)\n        {\n            // die Spalteninfos wurden bereits eingelesen\n            // und werden nun nur noch neu initialisiert\n            foreach ($this->dbColumns as $fieldName => &$fieldValue)\n            {\n                $fieldValue = ''; // $this->dbColumns[$fieldName] = '';\n                $this->columnsInfos[$fieldName]['changed'] = false;\n            }\n            unset($fieldValue);\n        }\n        else\n        {\n            // alle Spalten der Tabelle ins Array einlesen und auf leer setzen\n            $tableColumnsProperties = $this->db->getTableColumnsProperties($this->tableName);\n\n            foreach ($tableColumnsProperties as $columnName => $property)\n            {\n                $this->dbColumns[$columnName] = '';\n                $this->columnsInfos[$columnName]['changed'] = false;\n                $this->columnsInfos[$columnName]['type']    = $property['type'];\n                $this->columnsInfos[$columnName]['null']    = $property['null'];\n                $this->columnsInfos[$columnName]['key']     = $property['key'];\n                $this->columnsInfos[$columnName]['serial']  = $property['serial'];\n\n                if ($property['serial'])\n                {\n                    $this->keyColumnName = $columnName;\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds a table with the connected fields to a member array. This table will be add to the\n     * select statement if data is read and the connected record is available in this class.\n     * The connected table must have a foreign key in the class table.\n     * @param string $table                     Database table name that should be connected. This can be the define of the table.\n     * @param string $columnNameAdditionalTable Name of the column in the connected table that has the foreign key to the class table\n     * @param string $columnNameClassTable      Name of the column in the class table that has the foreign key to the connected table\n     *\n     * **Code example:**\n     * ```\n     * // Constructor of adm_dates object where the category (calendar) is connected\n     * public function __construct($database, $datId = 0)\n     * {\n     *     $this->connectAdditionalTable(TBL_CATEGORIES, 'cat_id', 'dat_cat_id');\n     *     parent::__construct($db, TBL_DATES, 'dat', $datId);\n     * }\n     * ```\n     */\n    protected function connectAdditionalTable($table, $columnNameAdditionalTable, $columnNameClassTable)\n    {\n        $this->additionalTables[] = array(\n            'table'                     => $table,\n            'columnNameAdditionalTable' => $columnNameAdditionalTable,\n            'columnNameClassTable'      => $columnNameClassTable\n        );\n    }\n\n    /**\n     * Reads the number of all records of this table\n     * @return int Number of records of this table\n     */\n    public function countAllRecords()\n    {\n        $sql = 'SELECT COUNT(*) AS count FROM '.$this->tableName;\n        $countStatement = $this->db->queryPrepared($sql);\n\n        return (int) $countStatement->fetchColumn();\n    }\n\n    /**\n     * Deletes the selected record of the table and initializes the class\n     * @return true Returns **true** if no error occurred\n     */\n    public function delete()\n    {\n        if (array_key_exists($this->keyColumnName, $this->dbColumns) && $this->dbColumns[$this->keyColumnName] !== '')\n        {\n            $sql = 'DELETE FROM '.$this->tableName.'\n                     WHERE '.$this->keyColumnName.' = ? -- $this->dbColumns[$this->keyColumnName]';\n            $this->db->queryPrepared($sql, array($this->dbColumns[$this->keyColumnName]));\n        }\n\n        $this->clear();\n        return true;\n    }\n\n    /**\n     * Get the value of a column of the database table.\n     * If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @param string $columnName The name of the database column whose value should be read\n     * @param string $format     For date or timestamp columns the format should be the date/time format e.g. **d.m.Y = '02.04.2011'**.\n     *                           For text columns the format can be **database** that would return the original database value without any transformations\n     * @return mixed Returns the value of the database column.\n     *               If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @see TableAccess#setValue\n     */\n    public function getValue($columnName, $format = '')\n    {\n        global $gSettingsManager;\n\n        $columnValue = '';\n\n        if (array_key_exists($columnName, $this->dbColumns))\n        {\n            // wenn Schluesselfeld leer ist, dann 0 zurueckgeben\n            if ($this->keyColumnName === $columnName && empty($this->dbColumns[$columnName]))\n            {\n                $columnValue = 0;\n            }\n            else\n            {\n                $columnValue = $this->dbColumns[$columnName];\n            }\n        }\n\n        if (array_key_exists((string) $columnName, $this->columnsInfos) && array_key_exists('type', $this->columnsInfos[$columnName]))\n        {\n            switch ($this->columnsInfos[$columnName]['type'])\n            {\n                // String\n                case 'char':\n                case 'varchar':\n                case 'text':\n                    if ($format !== 'database')\n                    {\n                        // if text field and format not 'database' then convert all quotes to html syntax\n                        $columnValue = htmlspecialchars($columnValue, ENT_QUOTES);\n                    }\n                    break;\n\n                // Byte\n                case 'bytea':\n                    // in PostgreSQL we must encode the stored hex value back to binary\n                    $columnValue = pack('H*', pack('H*', substr($columnValue, 2)));\n                    break;\n\n                case 'timestamp':\n                case 'date':\n                case 'time':\n                    if ($columnValue !== '' && $columnValue !== null)\n                    {\n                        if ($format === '' && isset($gSettingsManager))\n                        {\n                            if (admStrContains($this->columnsInfos[$columnName]['type'], 'timestamp'))\n                            {\n                                $format = $gSettingsManager->getString('system_date') . ' ' . $gSettingsManager->getString('system_time');\n                            }\n                            elseif (admStrContains($this->columnsInfos[$columnName]['type'], 'date'))\n                            {\n                                $format = $gSettingsManager->getString('system_date');\n                            }\n                            else\n                            {\n                                $format = $gSettingsManager->getString('system_time');\n                            }\n                        }\n\n                        // try to format the date, else output the available data\n                        try\n                        {\n                            $datetime = new \\DateTime($columnValue);\n                            $columnValue = $datetime->format($format);\n                        }\n                        catch (Exception $e)\n                        {\n                            $columnValue = $this->dbColumns[$columnName];\n                        }\n                    }\n                    break;\n            }\n        }\n\n        return $columnValue;\n    }\n\n    /**\n     * If a column of the row in this object has changed throw setValue then this method\n     * will return **true** otherwise @false\n     * @return bool Returns **true** if at least one value of one column has changed\n     *              after the recordset was loaded otherwise **false**\n     */\n    public function hasColumnsValueChanged()\n    {\n        return $this->columnsValueChanged;\n    }\n\n    /**\n     * If the recordset is new and wasn't read from database or was not stored in database\n     * then this method will return true otherwise false\n     * @return bool Returns **true** if record is not stored in database\n     */\n    public function isNewRecord()\n    {\n        return $this->newRecord;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by the conditions of the param **$sqlWhereCondition** out of the table.\n     * If the sql will find more than one record the method returns **false**.\n     * Per default all columns of the default table will be read and stored in the object.\n     * @param string           $sqlWhereCondition Conditions for the table to select one record\n     * @param array<int,mixed> $queryParams       The query params for the prepared statement\n     * @return bool Returns **true** if one record is found\n     * @see TableAccess#readDataById\n     * @see TableAccess#readDataByColumns\n     */\n    protected function readData($sqlWhereCondition, array $queryParams = array())\n    {\n        $sqlAdditionalTables = '';\n\n        // create sql to connect additional tables to the select statement\n        if (count($this->additionalTables) > 0)\n        {\n            foreach ($this->additionalTables as $arrAdditionalTable)\n            {\n                $sqlAdditionalTables .= ', '.$arrAdditionalTable['table'];\n                $sqlWhereCondition   .= ' AND '.$arrAdditionalTable['columnNameAdditionalTable'].' = '.$arrAdditionalTable['columnNameClassTable'].' ';\n            }\n        }\n\n        // if condition starts with AND then remove this\n        if (admStrStartsWith(strtoupper(ltrim($sqlWhereCondition)), 'AND'))\n        {\n            $sqlWhereCondition = substr($sqlWhereCondition, 4);\n        }\n\n        if ($sqlWhereCondition !== '')\n        {\n            $sql = 'SELECT *\n                      FROM '.$this->tableName.'\n                           '.$sqlAdditionalTables.'\n                     WHERE '.$sqlWhereCondition;\n            $readDataStatement = $this->db->queryPrepared($sql, $queryParams); // TODO add more params\n\n            if ($readDataStatement->rowCount() === 1)\n            {\n                $row = $readDataStatement->fetch();\n                $this->newRecord = false;\n\n                // Daten in das Klassenarray schieben\n                foreach ($row as $key => $value)\n                {\n                    if ($value === null)\n                    {\n                        $this->dbColumns[$key] = ''; // TODO: remove\n                    }\n                    else\n                    {\n                        $this->dbColumns[$key] = $value;\n                    }\n                }\n\n                return true;\n            }\n\n            $this->clear();\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by the unique id column in the table.\n     * Per default all columns of the default table will be read and stored in the object.\n     * @param int $id Unique id of id column of the table.\n     * @return bool Returns **true** if one record is found\n     * @see TableAccess#readData\n     * @see TableAccess#readDataByColumns\n     */\n    public function readDataById($id)\n    {\n        // initialize the object, so that all fields are empty\n        $this->clear();\n\n        // add id to sql condition\n        if ($id > 0)\n        {\n            // call method to read data out of database\n            return $this->readData(' AND ' . $this->keyColumnName . ' = ? ', array($id));\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by different columns in the table.\n     * The columns are commited with an array where every element index is the column name and the value is the column value.\n     * The columns and values must be selected so that they identify only one record.\n     * If the sql will find more than one record the method returns **false**.\n     * Per default all columns of the default table will be read and stored in the object.\n     * @param array<string,mixed> $columnArray An array where every element index is the column name and the value is the column value\n     * @return bool Returns **true** if one record is found\n     *\n     * **Code example:**\n     * ```\n     * // reads data not be mem_id but with combination of role and user id\n     * $member = new TableAccess($gDb, TBL_MEMBERS, 'rol');\n     * $member->readDataByColumn(array('mem_rol_id' => $roleId, 'mem_usr_id' => $userId));\n     * ```\n     * @see TableAccess#readData\n     * @see TableAccess#readDataById\n     */\n    public function readDataByColumns(array $columnArray)\n    {\n        // initialize the object, so that all fields are empty\n        $this->clear();\n\n        if (count($columnArray) === 0)\n        {\n            return false;\n        }\n\n        $sqlWhereCondition = '';\n\n        // add every array element as a sql condition to the condition string\n        foreach ($columnArray as $columnName => $columnValue)\n        {\n            $sqlWhereCondition .= ' AND ' . $columnName . ' = ? ';\n        }\n\n        // call method to read data out of database\n        $returnCode = $this->readData($sqlWhereCondition, array_values($columnArray));\n\n        // save the array fields in the object\n        if (!$returnCode)\n        {\n            foreach ($columnArray as $columnName => $columnValue)\n            {\n                $this->setValue($columnName, $columnValue);\n            }\n        }\n\n        return $returnCode;\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update the changed columns.\n     * If the table has columns for creator or editor than these column with their timestamp will be updated.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset\n     *                                if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true)\n    {\n        global $gCurrentUser;\n\n        if (!$this->columnsValueChanged && $this->dbColumns[$this->keyColumnName] !== '')\n        {\n            return false;\n        }\n\n        if ($updateFingerPrint && is_object($gCurrentUser) && $gCurrentUser->getValue('usr_id') > 0)\n        {\n            // besitzt die Tabelle Felder zum Speichern des Erstellers und der letzten Aenderung,\n            // dann diese hier automatisiert fuellen\n            if ($this->newRecord && array_key_exists($this->columnPrefix . '_usr_id_create', $this->dbColumns))\n            {\n                $this->setValue($this->columnPrefix . '_timestamp_create', DATETIME_NOW);\n                $this->setValue($this->columnPrefix . '_usr_id_create', $gCurrentUser->getValue('usr_id'));\n            }\n            elseif (array_key_exists($this->columnPrefix . '_usr_id_change', $this->dbColumns))\n            {\n                // Daten nicht aktualisieren, wenn derselbe User dies innerhalb von 15 Minuten gemacht hat\n                if ((int) $gCurrentUser->getValue('usr_id') !== (int) $this->getValue($this->columnPrefix . '_usr_id_create')\n                || time() > (strtotime($this->getValue($this->columnPrefix . '_timestamp_create')) + 900))\n                {\n                    $this->setValue($this->columnPrefix . '_timestamp_change', DATETIME_NOW);\n                    $this->setValue($this->columnPrefix . '_usr_id_change', $gCurrentUser->getValue('usr_id'));\n                }\n            }\n        }\n\n        // SQL-Update-Statement fuer User-Tabelle zusammenbasteln\n        $sqlFieldArray = array();\n        $sqlSetArray = array();\n        $queryParams = array();\n\n        // Schleife ueber alle DB-Felder und diese dem Update hinzufuegen\n        foreach ($this->dbColumns as $key => $value)\n        {\n            // Auto-Increment-Felder duerfen nicht im Insert/Update erscheinen\n            // Felder anderer Tabellen auch nicht\n            if (admStrStartsWith($key, $this->columnPrefix . '_')\n            && !$this->columnsInfos[$key]['serial'] && $this->columnsInfos[$key]['changed'])\n            {\n                if ($this->newRecord)\n                {\n                    if ($value !== '')\n                    {\n                        // Daten fuer ein Insert aufbereiten\n                        $sqlFieldArray[] = $key;\n                        $queryParams[] = $value;\n                    }\n                }\n                else\n                {\n                    $sqlSetArray[] = $key . ' = ?';\n\n                    // Daten fuer ein Update aufbereiten\n                    if ($value === '' || $value === null)\n                    {\n                        $queryParams[] = null;\n                    }\n                    else\n                    {\n                        $queryParams[] = $value;\n                    }\n                }\n\n                $this->columnsInfos[$key]['changed'] = false;\n            }\n        }\n\n        if ($this->newRecord)\n        {\n            // insert record and mark this object as not new and remember the new id\n            $sql = 'INSERT INTO '.$this->tableName.'\n                           ('.implode(',', $sqlFieldArray).')\n                    VALUES ('.replaceValuesArrWithQM($sqlFieldArray).')';\n            $this->db->queryPrepared($sql, $queryParams);\n\n            $this->newRecord = false;\n            if ($this->keyColumnName !== '')\n            {\n                $this->dbColumns[$this->keyColumnName] = $this->db->lastInsertId();\n            }\n        }\n        else\n        {\n            $sql = 'UPDATE '.$this->tableName.'\n                       SET '.implode(', ', $sqlSetArray).'\n                     WHERE '.$this->keyColumnName.' = ? -- $this->dbColumns[$this->keyColumnName]';\n            $queryParams[] = $this->dbColumns[$this->keyColumnName];\n            $this->db->queryPrepared($sql, $queryParams);\n        }\n\n        $this->columnsValueChanged = false;\n\n        return true;\n    }\n\n    /**\n     * The method requires an array with all fields of one recordset of the table object.\n     * These fields will be add to the object as if you read one record with **readDataById**\n     * but without a separate SQL. This method is useful if you have several recordsets of the\n     * table and want to use an table object for each recordset. So you don't have to do an\n     * separate sql read for each record. This is a performant way to fill the object with\n     * the necessary data.\n     * @param array $fieldArray An array with all fields and their values of the table. If the object has\n     *                          more connected tables than you should add the fields of these tables, too.\n     *\n     * **Code example:**\n     * ```\n     * // read all announcements with their categories\n     * $sql = 'SELECT * FROM ' . TBL_ANNOUNCEMENTS . ' INNER JOIN ' . TBL_CATEGORIES . ' ON ann_cat_id = cat_id';\n     * $announcementsStatement = $gDb->queryPrepared($sql);\n     * $announcement = new TableAnnouncements($gDb);\n     *\n     * while ($row = $announcementsStatement->fetch())\n     * {\n     *     // add each recordset to an object without a separate sql within the object\n     *     $announcement->clear();\n     *     $announcement->setArray($row);\n     *     ...\n     * }\n     * ```\n     */\n    public function setArray(array $fieldArray)\n    {\n        foreach ($fieldArray as $field => $value)\n        {\n            $this->dbColumns[$field] = $value;\n            $this->columnsInfos[$field]['changed'] = false;\n        }\n\n        $this->newRecord = empty($this->dbColumns[$this->keyColumnName]);\n    }\n\n    /**\n     * Set a new value for a column of the database table. The value is only saved in the object.\n     * You must call the method **save** to store the new value to the database. If the unique key\n     * column is set to 0 than this record will be a new record and all other columns are marked as changed.\n     * @param string $columnName The name of the database column whose value should get a new value\n     * @param mixed  $newValue   The new value that should be stored in the database field\n     * @param bool   $checkValue The value will be checked if it's valid. If set to **false** than the value will not be checked.\n     * @return bool Returns **true** if the value is stored in the current object and **false** if a check failed\n     * @see TableAccess#getValue\n     */\n    public function setValue($columnName, $newValue, $checkValue = true)\n    {\n        if (!array_key_exists($columnName, $this->dbColumns))\n        {\n            return false;\n        }\n\n        // Allgemeine Plausibilitaets-Checks anhand des Feldtyps\n        if ($checkValue && $newValue !== '')\n        {\n            switch ($this->columnsInfos[$columnName]['type'])\n            {\n                // Numeric\n                case 'integer':\n                case 'smallint':\n                    if (!is_numeric($newValue))\n                    {\n                        $newValue = '';\n                    }\n\n                    // Schluesselfelder duerfen keine 0 enthalten\n                    if ((int) $newValue === 0 &&\n                        ($this->columnsInfos[$columnName]['key'] || $this->columnsInfos[$columnName]['null']))\n                    {\n                        $newValue = '';\n                    }\n                    break;\n\n                // String\n                case 'char':\n                case 'varchar':\n                case 'text':\n                    $newValue = strStripTags($newValue);\n                    break;\n\n                // Byte/Blob\n                case 'bytea':\n                    // PostgreSQL can only store hex values in bytea, so we must decode binary in hex\n                    $newValue = bin2hex($newValue);\n                    break;\n            }\n        }\n\n        // wurde das Schluesselfeld auf 0 gesetzt, dann soll ein neuer Datensatz angelegt werden\n        if ($this->keyColumnName === $columnName && (int) $newValue === 0)\n        {\n            $this->newRecord = true;\n\n            // now mark all other columns with values of this object as changed\n            foreach ($this->dbColumns as $column => $value)\n            {\n                if (strlen((string) $value) > 0)\n                {\n                    $this->columnsInfos[$column]['changed'] = true;\n                }\n            }\n        }\n\n        if (array_key_exists($columnName, $this->dbColumns))\n        {\n            // only mark as \"changed\" if the value is different (DON'T use binary safe function!)\n            if ($this->dbColumns[$columnName] != $newValue)\n            {\n                $this->dbColumns[$columnName] = $newValue;\n                $this->columnsValueChanged = true;\n                $this->columnsInfos[$columnName]['changed'] = true;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n}\n"], "filenames": ["adm_program/system/classes/TableAccess.php"], "buggy_code_start_loc": [447], "buggy_code_end_loc": [452], "fixing_code_start_loc": [447], "fixing_code_end_loc": [452], "type": "CWE-89", "message": "SQL Injection was discovered in Admidio before version 3.3.13. The main cookie parameter is concatenated into a SQL query without any input validation/sanitization, thus an attacker without logging in, can send a GET request with arbitrary SQL queries appended to the cookie parameter and execute SQL queries. The vulnerability impacts the confidentiality of the system. This has been patched in version 3.3.13.", "other": {"cve": {"id": "CVE-2020-11004", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-24T21:15:13.747", "lastModified": "2020-05-01T19:25:26.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL Injection was discovered in Admidio before version 3.3.13. The main cookie parameter is concatenated into a SQL query without any input validation/sanitization, thus an attacker without logging in, can send a GET request with arbitrary SQL queries appended to the cookie parameter and execute SQL queries. The vulnerability impacts the confidentiality of the system. This has been patched in version 3.3.13."}, {"lang": "es", "value": "Se descubri\u00f3 una Inyecci\u00f3n SQL en Admidio versiones anteriores a la versi\u00f3n  3.3.13. El par\u00e1metro cookie principal se concatena en una consulta SQL sin ninguna comprobaci\u00f3n y saneamiento de entrada, por lo que un atacante sin inicio de sesi\u00f3n puede enviar una petici\u00f3n GET con consultas SQL arbitrarias agregadas al par\u00e1metro cookie y ejecutar consultas SQL. La vulnerabilidad impacta la confidencialidad del sistema. Esto ha sido corregido  en la versi\u00f3n 3.3.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:admidio:admidio:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.13", "matchCriteriaId": "DE46F157-622B-4017-8FC7-EB25A24FC4FA"}]}]}], "references": [{"url": "https://github.com/Admidio/admidio/commit/ea5d6f114b151ed11ec0ad7cb47bd729e77a874a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Admidio/admidio/issues/908", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Admidio/admidio/security/advisories/GHSA-qh57-rcff-gx54", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Admidio/admidio/commit/ea5d6f114b151ed11ec0ad7cb47bd729e77a874a"}}