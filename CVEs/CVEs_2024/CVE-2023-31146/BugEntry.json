{"buggy_code": ["import itertools\n\nimport pytest\n\nfrom vyper.exceptions import (\n    ArgumentException,\n    ArrayIndexException,\n    ImmutableViolation,\n    InvalidType,\n    OverflowException,\n    StateAccessViolation,\n    TypeMismatch,\n)\n\n\ndef test_list_tester_code(get_contract_with_gas_estimation):\n    list_tester_code = \"\"\"\nz: DynArray[int128, 3]\nz2: DynArray[DynArray[int128, 2], 2]\nz3: DynArray[int128, 2]\n\n@external\ndef foo(x: DynArray[int128, 3]) -> int128:\n    return x[0] + x[1] + x[2]\n\n@external\ndef goo(x: DynArray[DynArray[int128, 2], 2]) -> int128:\n    return x[0][0] + x[0][1] + x[1][0] * 10 + x[1][1] * 10\n\n@external\ndef hoo(x: DynArray[int128, 3]) -> int128:\n    y: DynArray[int128, 3] = x\n    return y[0] + x[1] + y[2]\n\n@external\ndef joo(x: DynArray[DynArray[int128, 2], 2]) -> int128:\n    y: DynArray[DynArray[int128, 2], 2] = x\n    y2: DynArray[int128, 2] = x[1]\n    return y[0][0] + y[0][1] + y2[0] * 10 + y2[1] * 10\n\n@external\ndef koo(x: DynArray[int128, 3]) -> int128:\n    self.z = x\n    return self.z[0] + x[1] + self.z[2]\n\n@external\ndef loo(x: DynArray[DynArray[int128, 2], 2]) -> int128:\n    self.z2 = x\n    self.z3 = x[1]\n    return self.z2[0][0] + self.z2[0][1] + self.z3[0] * 10 + self.z3[1] * 10\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(list_tester_code)\n    assert c.foo([3, 4, 5]) == 12\n    assert c.goo([[1, 2], [3, 4]]) == 73\n    assert c.hoo([3, 4, 5]) == 12\n    assert c.joo([[1, 2], [3, 4]]) == 73\n    assert c.koo([3, 4, 5]) == 12\n    assert c.loo([[1, 2], [3, 4]]) == 73\n    print(\"Passed list tests\")\n\n\ndef test_string_list(get_contract):\n    code = \"\"\"\n@external\ndef foo1(x: DynArray[String[32], 2]) -> DynArray[String[32], 2]:\n    return x\n\n@external\ndef foo2(x: DynArray[DynArray[String[32], 2], 2]) -> DynArray[DynArray[String[32], 2], 2]:\n    return x\n\n@external\ndef foo3(x: DynArray[DynArray[String[32], 2], 2]) -> DynArray[String[32], 2]:\n    return x[0]\n\n@external\ndef foo4(x: DynArray[DynArray[String[32], 2], 2]) -> String[32]:\n    return x[0][0]\n\n@external\ndef foo5() -> DynArray[String[32], 2]:\n    ret: DynArray[String[32], 2] = [\"hello\"]\n    ret.append(\"world\")\n    return ret\n\n@external\ndef foo6() -> DynArray[DynArray[String[32], 2], 2]:\n    ret: DynArray[DynArray[String[32], 2], 2] = []\n    ret.append([\"hello\", \"world\"])\n    return ret\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.foo1([\"hello\", \"world\"]) == [\"hello\", \"world\"]\n    assert c.foo2([[\"hello\", \"world\"]]) == [[\"hello\", \"world\"]]\n    assert c.foo3([[\"hello\", \"world\"]]) == [\"hello\", \"world\"]\n    assert c.foo4([[\"hello\", \"world\"]]) == \"hello\"\n    assert c.foo5() == [\"hello\", \"world\"]\n    assert c.foo6() == [[\"hello\", \"world\"]]\n\n\ndef test_list_output_tester_code(get_contract_with_gas_estimation):\n    list_output_tester_code = \"\"\"\nenum Foobar:\n    FOO\n    BAR\n\ny: DynArray[Foobar, 2]\nz: DynArray[int128, 2]\n\n@external\ndef foo() -> DynArray[int128, 2]:\n    return [3, 5]\n\n@external\ndef goo() -> DynArray[int128, 2]:\n    x: DynArray[int128, 2] = [3, 5]\n    return x\n\n@external\ndef hoo() -> DynArray[int128, 2]:\n    self.z = [3, 5]\n    return self.z\n\n@external\ndef hoo1() -> DynArray[int128, 2]:\n    self.z = empty(DynArray[int128, 2])\n    return self.z\n\n@external\ndef hoo2() -> DynArray[int128, 2]:\n    return empty(DynArray[int128, 2])\n\n@external\ndef hoo3() -> DynArray[int128, 2]:\n    return []\n\n@external\ndef hoo4() -> DynArray[int128, 2]:\n    self.z = []\n    return self.z\n\n@external\ndef hoo5() -> DynArray[DynArray[int128, 2], 2]:\n    return []\n\n@external\ndef joo() -> DynArray[int128, 2]:\n    self.z = [3, 5]\n    x: DynArray[int128, 2] = self.z\n    return x\n\n@external\ndef koo() -> DynArray[DynArray[int128, 2], 2]:\n    return [[1, 2], [3, 4]]\n\n@external\ndef loo() -> DynArray[DynArray[int128, 2], 2]:\n    x: DynArray[DynArray[int128, 2], 2] = [[1, 2], [3, 4]]\n    return x\n\n@external\ndef moo() -> DynArray[DynArray[int128, 2], 2]:\n    x: DynArray[int128, 2] = [1,2]\n    return [x, [3,4]]\n\n@external\ndef noo(inp: DynArray[int128, 2]) -> DynArray[int128, 2]:\n    return inp\n\n@external\ndef ooo(inp: DynArray[int128, 2]) -> DynArray[int128, 2]:\n    self.z = inp\n    return self.z\n\n@external\ndef poo(inp: DynArray[DynArray[int128, 2], 2]) -> DynArray[DynArray[int128, 2], 2]:\n    return inp\n\n@external\ndef qoo(inp: DynArray[int128, 2]) -> DynArray[DynArray[int128, 2], 2]:\n    return [inp, [3,4]]\n\n@external\ndef roo(inp: DynArray[decimal, 2]) -> DynArray[DynArray[decimal, 2], 2]:\n    return [inp, [3.0, 4.0]]\n\n@external\ndef soo() -> DynArray[Foobar, 2]:\n    x: DynArray[Foobar, 2] = [Foobar.FOO, Foobar.BAR]\n    return x\n\n@external\ndef too() -> DynArray[Foobar, 2]:\n    self.y = [Foobar.BAR, Foobar.FOO]\n    return self.y\n\n@external\ndef uoo(inp: DynArray[Foobar, 2]) -> DynArray[DynArray[Foobar, 2], 2]:\n    return [inp, [Foobar.BAR, Foobar.FOO]]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(list_output_tester_code)\n    assert c.foo() == [3, 5]\n    assert c.goo() == [3, 5]\n    assert c.hoo() == [3, 5]\n    assert c.hoo1() == c.hoo2() == c.hoo3() == c.hoo4() == []\n    assert c.hoo5() == []\n    assert c.joo() == [3, 5]\n    assert c.koo() == [[1, 2], [3, 4]]\n    assert c.loo() == [[1, 2], [3, 4]]\n    assert c.moo() == [[1, 2], [3, 4]]\n    assert c.noo([]) == []\n    assert c.noo([3, 5]) == [3, 5]\n    assert c.ooo([]) == []\n    assert c.ooo([3, 5]) == [3, 5]\n    assert c.poo([]) == []\n    assert c.poo([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]\n    assert c.qoo([1, 2]) == [[1, 2], [3, 4]]\n    assert c.roo([1, 2]) == [[1.0, 2.0], [3.0, 4.0]]\n    assert c.soo() == [1, 2]\n    assert c.too() == [2, 1]\n    assert c.uoo([1, 2]) == [[1, 2], [2, 1]]\n\n    print(\"Passed list output tests\")\n\n\ndef test_array_accessor(get_contract_with_gas_estimation):\n    array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[int128, 4] = [0, 0, 0, 0]\n    a[0] = x\n    a[1] = y\n    a[2] = z\n    a[3] = w\n    return a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(array_accessor)\n    assert c.test_array(2, 7, 1, 8) == 2718\n    print(\"Passed basic array accessor test\")\n\n\ndef test_two_d_array_accessor(get_contract_with_gas_estimation):\n    two_d_array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[int128, 2], 2] = [[0, 0], [0, 0]]\n    a[0][0] = x\n    a[0][1] = y\n    a[1][0] = z\n    a[1][1] = w\n    return a[0][0] * 1000 + a[0][1] * 100 + a[1][0] * 10 + a[1][1]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(two_d_array_accessor)\n    assert c.test_array(2, 7, 1, 8) == 2718\n    print(\"Passed complex array accessor test\")\n\n\ndef test_three_d_array_accessor(get_contract_with_gas_estimation):\n    three_d_array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[int128, 2], 2], 2] = [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    a[0][0][0] = x\n    a[0][0][1] = y\n    a[0][1][0] = z\n    a[0][1][1] = w\n    a[1][0][0] = -x\n    a[1][0][1] = -y\n    a[1][1][0] = -z\n    a[1][1][1] = -w\n    return a[0][0][0] * 1000 + a[0][0][1] * 100 + a[0][1][0] * 10 + a[0][1][1] + \\\\\n        a[1][1][1] * 1000 + a[1][1][0] * 100 + a[1][0][1] * 10 + a[1][0][0]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(three_d_array_accessor)\n    assert c.test_array(2, 7, 1, 8) == -5454\n\n\ndef test_four_d_array_accessor(get_contract_with_gas_estimation):\n    four_d_array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[DynArray[int128, 2], 2], 2], 2] = \\\\\n        [[[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]\n    a[0][0][0][0] = x\n    a[0][0][0][1] = y\n    a[0][0][1][0] = z\n    a[0][0][1][1] = w\n    a[0][1][0][0] = -x\n    a[0][1][0][1] = -y\n    a[0][1][1][0] = -z\n    a[0][1][1][1] = -w\n\n    a[1][0][0][0] = x + 1\n    a[1][0][0][1] = y + 1\n    a[1][0][1][0] = z + 1\n    a[1][0][1][1] = w + 1\n    a[1][1][0][0] = - (x + 1)\n    a[1][1][0][1] = - (y + 1)\n    a[1][1][1][0] = - (z + 1)\n    a[1][1][1][1] = - (w + 1)\n    return a[0][0][0][0] * 1000 + a[0][0][0][1] * 100 + a[0][0][1][0] * 10 + a[0][0][1][1] + \\\\\n        a[0][1][1][1] * 1000 + a[0][1][1][0] * 100 + a[0][1][0][1] * 10 + a[0][1][0][0] + \\\\\n        a[1][0][0][0] * 1000 + a[1][0][0][1] * 100 + a[1][0][1][0] * 10 + a[1][0][1][1] + \\\\\n        a[1][1][1][1] * 1000 + a[1][1][1][0] * 100 + a[1][1][0][1] * 10 + a[1][1][0][0]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(four_d_array_accessor)\n    assert c.test_array(2, 7, 1, 8) == -10908\n\n\ndef test_array_negative_accessor(get_contract_with_gas_estimation, assert_compile_failed):\n    array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[int128, 4] = [0, 0, 0, 0]\n    a[0] = x\n    a[1] = y\n    a[2] = z\n    a[3] = w\n    return a[-4] * 1000 + a[-3] * 100 + a[-2] * 10 + a[-1]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(array_negative_accessor), ArrayIndexException\n    )\n\n    two_d_array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[int128, 2], 2] = [[0, 0], [0, 0]]\n    a[0][0] = x\n    a[0][1] = y\n    a[1][0] = z\n    a[1][1] = w\n    return a[-2][-2] * 1000 + a[-2][-1] * 100 + a[-1][-2] * 10 + a[-1][-1]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(two_d_array_negative_accessor), ArrayIndexException\n    )\n\n    three_d_array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[int128, 2], 2], 2] = [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    a[0][0][0] = x\n    a[0][0][1] = y\n    a[0][1][0] = z\n    a[0][1][1] = w\n    a[1][0][0] = -x\n    a[1][0][1] = -y\n    a[1][1][0] = -z\n    a[1][1][1] = -w\n    return a[-2][-2][-2] * 1000 + a[-2][-2][-1] * 100 + a[-2][-1][-2] * 10 + a[-2][-1][-1] + \\\\\n        a[-1][-1][-1] * 1000 + a[-1][-1][-2] * 100 + a[-1][-2][-1] * 10 + a[-1][-2][-2]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(three_d_array_negative_accessor),\n        ArrayIndexException,\n    )\n\n    four_d_array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[DynArray[int128, 2], 2], 2], 2] = \\\\\n        [[[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]\n    a[0][0][0][0] = x\n    a[0][0][0][1] = y\n    a[0][0][1][0] = z\n    a[0][0][1][1] = w\n    a[0][1][0][0] = -x\n    a[0][1][0][1] = -y\n    a[0][1][1][0] = -z\n    a[0][1][1][1] = -w\n\n    a[1][0][0][0] = x + 1\n    a[1][0][0][1] = y + 1\n    a[1][0][1][0] = z + 1\n    a[1][0][1][1] = w + 1\n    a[1][1][0][0] = - (x + 1)\n    a[1][1][0][1] = - (y + 1)\n    a[1][1][1][0] = - (z + 1)\n    a[1][1][1][1] = - (w + 1)\n    return a[-2][-2][-2][-2] * 1000 + a[-2][-2][-2][-1] * 100 + \\\\\n        a[-2][-2][-1][-2] * 10 + a[-2][-2][-1][-1] + \\\\\n        a[-2][-1][-1][-1] * 1000 + a[-2][-1][-1][-2] * \\\\\n        100 + a[-2][-1][-2][-1] * 10 + a[-2][-1][-2][-2] + \\\\\n        a[-1][-2][-2][-2] * 1000 + a[-1][-2][-2][-1] * \\\\\n        100 + a[-1][-2][-1][-2] * 10 + a[-1][-2][-1][-1] + \\\\\n        a[-1][-1][-1][-1] * 1000 + a[-1][-1][-1][-2] * \\\\\n        100 + a[-1][-1][-2][-1] * 10 + a[-1][-1][-2][-2]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(four_d_array_negative_accessor),\n        ArrayIndexException,\n    )\n\n\n@pytest.mark.parametrize(\n    \"type,values,false_value\",\n    [\n        (\"uint256\", [3, 7], 4),\n        (\n            \"address\",\n            [\n                \"0x0000000000000000000000000000000000000012\",\n                \"0x0000000000000000000000000000000000000024\",\n            ],\n            \"0x0000000000000000000000000000000000000013\",\n        ),\n        (\"bool\", [True, True], False),\n        (\n            \"bytes32\",\n            [\n                \"0x0000000000000000000000000000000000000000000000000000000080ac58cd\",\n                \"0x0000000000000000000000000000000000000000000000000000000080ac58ce\",\n            ],\n            \"0x0000000000000000000000000000000000000000000000000000000080ac58cf\",\n        ),\n    ],\n)\ndef test_member_in_list(get_contract_with_gas_estimation, type, values, false_value):\n    code = f\"\"\"\n@external\ndef check(a: {type}) -> bool:\n    x: DynArray[{type}, 2] = [{values[0]}, {values[1]}]\n    return a in x\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check(values[0]) is True\n    assert c.check(values[1]) is True\n    assert c.check(false_value) is False\n\n\n@pytest.mark.parametrize(\"type_\", (\"uint256\", \"bytes32\", \"address\"))\ndef test_member_in_empty_list(get_contract_with_gas_estimation, type_):\n    code = f\"\"\"\n@external\ndef check_in(s: uint128) -> bool:\n    a: {type_} = convert(s, {type_})\n    x: DynArray[{type_}, 2] = []\n    return a in x\n\n@external\ndef check_not_in(s: uint128) -> bool:\n    a: {type_} = convert(s, {type_})\n    x: DynArray[{type_}, 2] = []\n    return a not in x\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    for s in (0, 1, 2, 3):\n        assert c.check_in(s) is False\n        assert c.check_not_in(s) is True\n\n\n@pytest.mark.parametrize(\n    \"type,values,false_values\",\n    [\n        (\"uint256\", [[3, 7], [9, 11]], [4, 10]),\n        (\"bool\", [[True, True], [False, False]], [False, True]),\n    ],\n)\ndef test_member_in_nested_list(get_contract_with_gas_estimation, type, values, false_values):\n    code = f\"\"\"\n@external\ndef check1(a: {type}) -> bool:\n    x: DynArray[DynArray[{type}, 2], 2] = {values}\n    return a in x[0]\n\n@external\ndef check2(a: {type}) -> bool:\n    x: DynArray[DynArray[{type}, 2], 2] = {values}\n    return a in x[1]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check1(values[0][0]) is True\n    assert c.check1(values[0][1]) is True\n    assert c.check1(false_values[0]) is False\n\n    assert c.check2(values[1][0]) is True\n    assert c.check2(values[1][1]) is True\n    assert c.check2(false_values[1]) is False\n\n\ndef test_member_in_nested_address_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef check1(a: address) -> bool:\n    x: DynArray[DynArray[address, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000012,\n            0x0000000000000000000000000000000000000024,\n        ],\n        [\n            0x0000000000000000000000000000000000000036,\n            0x0000000000000000000000000000000000000048,\n        ],\n    ]\n    return a in x[0]\n\n@external\ndef check2(a: address) -> bool:\n    x: DynArray[DynArray[address, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000012,\n            0x0000000000000000000000000000000000000024,\n        ],\n        [\n            0x0000000000000000000000000000000000000036,\n            0x0000000000000000000000000000000000000048,\n        ],\n    ]\n    return a in x[1]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check1(\"0x0000000000000000000000000000000000000012\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000024\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000036\") is False\n\n    assert c.check2(\"0x0000000000000000000000000000000000000036\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000048\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000024\") is False\n\n\ndef test_member_in_nested_bytes32_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef check1(a: bytes32) -> bool:\n    x: DynArray[DynArray[bytes32, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58ca,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cb,\n        ],\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58cc,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cd,\n        ],\n    ]\n    return a in x[0]\n\n@external\ndef check2(a: bytes32) -> bool:\n    x: DynArray[DynArray[bytes32, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58ca,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cb,\n        ],\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58cc,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cd,\n        ],\n    ]\n    return a in x[1]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check1(\"0x0000000000000000000000000000000000000000000000000000000080ac58ca\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000000000000000000000080ac58cb\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000000000000000000000080ac58cc\") is False\n\n    assert c.check2(\"0x0000000000000000000000000000000000000000000000000000000080ac58cc\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000000000000000000000080ac58cd\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000000000000000000000080ac58ca\") is False\n\n\ndef test_member_in_updated_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef foo() -> bool:\n    xs: DynArray[uint256, 3] = [2, 2, 2]\n    xs = [1, 1]\n    y: uint256 = 2\n    return y in xs\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.foo() is False\n\n\ndef test_member_in_updated_nested_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef foo() -> bool:\n    xs: DynArray[DynArray[DynArray[uint256, 3], 3], 3] = [\n        [[2, 2, 2], [2, 2, 2], [2, 2, 2]],\n        [[2, 2, 2], [2, 2, 2], [2, 2, 2]],\n        [[2, 2, 2], [2, 2, 2], [2, 2, 2]],\n    ]\n    xs = [\n        [[1, 1], [1, 1], [1, 1]],\n        [[1, 1], [1, 1], [1, 1]],\n        [[1, 1], [1, 1], [1, 1]],\n    ]\n    y: uint256 = 2\n    return y in xs[0][0] or y in xs[0][1] or y in xs[0][2] or \\\\\n        y in xs[1][0] or y in xs[1][1] or y in xs[1][2] or \\\\\n        y in xs[2][0] or y in xs[2][1] or y in xs[2][2]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.foo() is False\n\n\ndef test_member_in_list_lhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\n_counter: uint256\n\n@internal\ndef counter() -> uint256:\n    self._counter = 1\n    return self._counter\n\n@external\ndef bar() -> bool:\n    x: DynArray[uint256, 4] = [2, 2, 2, 2]\n    return self.counter() in x\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() is False\n\n\ndef test_member_in_nested_list_lhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\n_counter: uint256\n\n@internal\ndef counter() -> uint256:\n    self._counter = 1\n    return self._counter\n\n@external\ndef bar() -> bool:\n    x: DynArray[DynArray[DynArray[uint256, 4], 4], 4] = [\n        [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]],\n        [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]],\n        [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]],\n    ]\n    return self.counter() in x[0][0]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() is False\n\n\ndef test_member_in_list_rhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\ncounter: uint256\n\n@internal\ndef foo() -> DynArray[uint256, 3]:\n    self.counter += 1\n    return [0,0,0]\n\n@external\ndef bar() -> uint256:\n    self.counter = 0\n    t: bool = self.counter in self.foo()\n    return self.counter\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 1\n\n\ndef test_member_in_nested_list_rhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\ncounter: uint256\n\n@internal\ndef foo() -> DynArray[DynArray[DynArray[uint256, 3], 3], 3]:\n    self.counter += 1\n    return [\n        [[0,0,0], [0,0,0], [0,0,0]],\n        [[0,0,0], [0,0,0], [0,0,0]],\n        [[0,0,0], [0,0,0], [0,0,0]]\n    ]\n\n@external\ndef bar() -> uint256:\n    self.counter = 0\n    t: bool = self.counter in self.foo()[0][0]\n    return self.counter\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 1\n\n\ndef test_returns_lists(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef test_array_num_return() -> DynArray[DynArray[int128, 2], 2]:\n    a: DynArray[DynArray[int128, 2], 2] = [empty(DynArray[int128, 2]), [3, 4]]\n    return a\n\n@external\ndef test_array_decimal_return1() -> DynArray[DynArray[decimal, 2], 2]:\n    a: DynArray[DynArray[decimal, 2], 2] = [[1.0], [3.0, 4.0]]\n    return a\n\n@external\ndef test_array_decimal_return2() -> DynArray[DynArray[decimal, 2], 2]:\n    return [[1.0, 2.0]]\n\n@external\ndef test_array_decimal_return3() -> DynArray[DynArray[decimal, 2], 2]:\n    a: DynArray[DynArray[decimal, 2], 2] = [[1.0, 2.0], [3.0]]\n    return a\n\"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.test_array_num_return() == [[], [3, 4]]\n    assert c.test_array_decimal_return1() == [[1.0], [3.0, 4.0]]\n    assert c.test_array_decimal_return2() == [[1.0, 2.0]]\n    assert c.test_array_decimal_return3() == [[1.0, 2.0], [3.0]]\n\n\ndef test_mult_list(get_contract_with_gas_estimation):\n    code = \"\"\"\nnest3: DynArray[DynArray[DynArray[uint256, 2], 2], 2]\nnest4: DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2]\n\n@external\ndef test_multi3_1() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[uint256, 2], 2], 2] = [[[0, 0], [0, 4]], [[0, 7], [0, 123]]]\n    self.nest3 = l\n    return self.nest3\n\n@external\ndef test_multi3_2() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[uint256, 2], 2], 2] = [[[0, 0], [0, 4]], [[0, 7], [0, 123]]]\n    self.nest3 = l\n    l = self.nest3\n    return l\n\n@external\ndef test_multi4_1() -> DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2] = [[[[1, 0], [0, 4]], [[0, 0], [0, 0]]], [[[444, 0], [0, 0]],[[1, 0], [0, 222]]]]  # noqa: E501\n    self.nest4 = l\n    l = self.nest4\n    return l\n\n@external\ndef test_multi4_2() -> DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2] = [[[[1, 0], [0, 4]], [[0, 0], [0, 0]]], [[[444, 0], [0, 0]],[[1, 0], [0, 222]]]]  # noqa: E501\n    self.nest4 = l\n    return self.nest4\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    nest3 = [[[0, 0], [0, 4]], [[0, 7], [0, 123]]]\n    assert c.test_multi3_1() == nest3\n    assert c.test_multi3_2() == nest3\n    nest4 = [[[[1, 0], [0, 4]], [[0, 0], [0, 0]]], [[[444, 0], [0, 0]], [[1, 0], [0, 222]]]]\n    assert c.test_multi4_1() == nest4\n    assert c.test_multi4_2() == nest4\n\n\ndef test_uint256_accessor(get_contract_with_gas_estimation, assert_tx_failed):\n    code = \"\"\"\n@external\ndef bounds_check_uint256(xs: DynArray[uint256, 3], ix: uint256) -> uint256:\n    return xs[ix]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert_tx_failed(lambda: c.bounds_check_uint256([], 0))\n\n    assert c.bounds_check_uint256([1], 0) == 1\n    assert_tx_failed(lambda: c.bounds_check_uint256([1], 1))\n\n    assert c.bounds_check_uint256([1, 2, 3], 0) == 1\n    assert c.bounds_check_uint256([1, 2, 3], 2) == 3\n    assert_tx_failed(lambda: c.bounds_check_uint256([1, 2, 3], 3))\n\n    # TODO do bounds checks for nested darrays\n\n\n@pytest.mark.parametrize(\"list_\", ([], [11], [11, 12], [11, 12, 13]))\ndef test_dynarray_len(get_contract_with_gas_estimation, assert_tx_failed, list_):\n    code = \"\"\"\n@external\ndef darray_len(xs: DynArray[uint256, 3]) -> uint256:\n    return len(xs)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.darray_len(list_) == len(list_)\n\n\ndef test_dynarray_too_large(get_contract_with_gas_estimation, assert_tx_failed):\n    code = \"\"\"\n@external\ndef darray_len(xs: DynArray[uint256, 3]) -> uint256:\n    return len(xs)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert_tx_failed(lambda: c.darray_len([1, 2, 3, 4]))\n\n\ndef test_int128_accessor(get_contract_with_gas_estimation, assert_tx_failed):\n    code = \"\"\"\n@external\ndef bounds_check_int128(ix: int128) -> uint256:\n    xs: DynArray[uint256, 3] = [1,2,3]\n    return xs[ix]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bounds_check_int128(0) == 1\n    assert c.bounds_check_int128(2) == 3\n    assert_tx_failed(lambda: c.bounds_check_int128(3))\n    assert_tx_failed(lambda: c.bounds_check_int128(-1))\n\n\ndef test_index_exception(get_contract_with_gas_estimation, assert_compile_failed):\n    code = \"\"\"\n@external\ndef fail() -> uint256:\n    xs: DynArray[uint256, 3] = [1,2,3]\n    return xs[3]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), ArrayIndexException)\n\n    code = \"\"\"\n@external\ndef fail() -> uint256:\n    xs: DynArray[uint256, 3] = [1,2,3]\n    return xs[-1]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), ArrayIndexException)\n\n\ndef test_compile_time_bounds_check(get_contract_with_gas_estimation, assert_compile_failed):\n    code = \"\"\"\n@external\ndef parse_list_fail():\n    xs: DynArray[uint256, 3] = [2**256, 1, 3]\n    pass\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), OverflowException)\n\n\ndef test_2d_array_input_1(get_contract):\n    code = \"\"\"\n@internal\ndef test_input(\n    arr: DynArray[DynArray[int128, 2], 1], i: int128\n) -> (DynArray[DynArray[int128, 2], 1], int128):\n    return arr, i\n\n@external\ndef test_values(\n    arr: DynArray[DynArray[int128, 2], 1], i: int128\n) -> (DynArray[DynArray[int128, 2], 1], int128):\n    return self.test_input(arr, i)\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.test_values([[1, 2]], 3) == [[[1, 2]], 3]\n\n\ndef test_2d_array_input_2(get_contract):\n    code = \"\"\"\n@internal\ndef test_input(\n    arr: DynArray[DynArray[int128, 2], 3],\n    s: String[10]\n) -> (DynArray[DynArray[int128, 2], 3], String[10]):\n    return arr, s\n\n@external\ndef test_values(\n    arr: DynArray[DynArray[int128, 2], 3],\n    s: String[10]\n) -> (DynArray[DynArray[int128, 2], 3], String[10]):\n    return self.test_input(arr, s)\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.test_values([[1, 2], [3, 4], [5, 6]], \"abcdef\") == [[[1, 2], [3, 4], [5, 6]], \"abcdef\"]\n\n\ndef test_nested_index_of_returned_array(get_contract):\n    code = \"\"\"\n@internal\ndef inner() -> (int128, int128):\n    return 1,2\n\n@external\ndef outer() -> DynArray[int128, 2]:\n    return [333, self.inner()[0]]\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.outer() == [333, 1]\n\n\ndef test_nested_calls_inside_arrays(get_contract):\n    code = \"\"\"\n@internal\ndef _foo(a: uint256, b: DynArray[uint256, 2]) -> (uint256, uint256, uint256, uint256, uint256):\n    return 1, a, b[0], b[1], 5\n\n@internal\ndef _foo2() -> uint256:\n    a: DynArray[uint256, 10] = [6,7,8,9,10,11,12,13,15,16]\n    return 4\n\n@external\ndef foo() -> (uint256, uint256, uint256, uint256, uint256):\n    return self._foo(2, [3, self._foo2()])\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.foo() == [1, 2, 3, 4, 5]\n\n\ndef test_nested_calls_inside_arrays_with_index_access(get_contract):\n    code = \"\"\"\n@internal\ndef _foo(\n    a: DynArray[uint256, 2],\n    b: DynArray[uint256, 2]\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return a[1]-b[0], 2, a[0]-b[1], 8-b[1], 5\n\n@internal\ndef _foo2() -> (uint256, uint256):\n    a: DynArray[uint256, 10] = [6,7,8,9,10,11,12,13,15,16]\n    return a[6], 4\n\n@external\ndef foo() -> (uint256, uint256, uint256, uint256, uint256):\n    return self._foo([7, self._foo2()[0]], [11, self._foo2()[1]])\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.foo() == [1, 2, 3, 4, 5]\n\n\nappend_pop_tests = [\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array\n    \"\"\",\n        lambda xs: xs,\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\nsome_var: uint256\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.some_var = x\n        # test that typechecker for append args works\n        self.my_array.append(self.some_var)\n    return self.my_array\n    \"\"\",\n        lambda xs: xs,\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.my_array.append(x)\n    for x in xs:\n        self.my_array.pop()\n    return self.my_array\n    \"\"\",\n        lambda xs: [],\n    ),\n    # check order of evaluation.\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> (DynArray[uint256, 5], uint256):\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array, self.my_array.pop()\n    \"\"\",\n        lambda xs: None if len(xs) == 0 else [xs, xs[-1]],\n    ),\n    # check order of evaluation.\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> (uint256, DynArray[uint256, 5]):\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array.pop(), self.my_array\n    \"\"\",\n        lambda xs: None if len(xs) == 0 else [xs[-1], xs[:-1]],\n    ),\n    # test memory arrays\n    (\n        \"\"\"\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    ys: DynArray[uint256, 5] = []\n    i: uint256 = 0\n    for x in xs:\n        if i >= len(xs) - 1:\n            break\n        ys.append(x)\n        i += 1\n\n    return ys\n    \"\"\",\n        lambda xs: xs[:-1],\n    ),\n    # check overflow\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 6]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array\n    \"\"\",\n        lambda xs: None if len(xs) > 5 else xs,\n    ),\n    # pop to 0 elems\n    (\n        \"\"\"\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    ys: DynArray[uint256, 5] = []\n    for x in xs:\n        ys.append(x)\n    for x in xs:\n        ys.pop()\n    return ys\n    \"\"\",\n        lambda xs: [],\n    ),\n    # check underflow\n    (\n        \"\"\"\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    ys: DynArray[uint256, 5] = []\n    for x in xs:\n        ys.append(x)\n    for x in xs:\n        ys.pop()\n    ys.pop()  # fail\n    return ys\n    \"\"\",\n        lambda xs: None,\n    ),\n    # check underflow\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> uint256:\n    return self.my_array.pop()\n    \"\"\",\n        lambda xs: None,\n    ),\n]\n\n\n@pytest.mark.parametrize(\"subtyp\", [\"uint8\", \"int128\", \"uint256\"])\ndef test_append_literal(get_contract, subtyp):\n    data = [1, 2, 3]\n    if subtyp == \"int128\":\n        data = [-1, 2, 3]\n    code = f\"\"\"\n@external\ndef foo() -> DynArray[{subtyp}, 3]:\n    x: DynArray[{subtyp}, 3] = []\n    x.append({data[0]})\n    x.append({data[1]})\n    x.append({data[2]})\n    return x\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == data\n\n\n@pytest.mark.parametrize(\"subtyp,lit\", [(\"uint8\", 256), (\"uint256\", -1), (\"int128\", 2**127)])\ndef test_append_invalid_literal(get_contract, assert_compile_failed, subtyp, lit):\n    code = f\"\"\"\n@external\ndef foo() -> DynArray[{subtyp}, 3]:\n    x: DynArray[{subtyp}, 3] = []\n    x.append({lit})\n    return x\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), InvalidType)\n\n\ninvalid_appends_pops = [\n    (\n        \"\"\"\n@external\ndef foo() -> DynArray[uint256, 3]:\n    x: DynArray[uint256, 3] = []\n    x.append()\n    \"\"\",\n        ArgumentException,\n    ),\n    (\n        \"\"\"\n@external\ndef foo() -> DynArray[uint256, 3]:\n    x: DynArray[uint256, 3] = []\n    x.append(1,2)\n    \"\"\",\n        ArgumentException,\n    ),\n    (\n        \"\"\"\n@external\ndef foo() -> DynArray[uint256, 3]:\n    x: DynArray[uint256, 3] = []\n    x.pop(1)\n    \"\"\",\n        ArgumentException,\n    ),\n    (\n        \"\"\"\n@external\ndef foo(x: DynArray[uint256, 3]) -> DynArray[uint256, 3]:\n    x.append(1)\n    return x\n    \"\"\",\n        ImmutableViolation,\n    ),\n    (\n        \"\"\"\nfoo: DynArray[uint256, 3]\n@external\n@view\ndef bar() -> DynArray[uint256, 3]:\n    self.foo.append(1)\n    return self.foo\n    \"\"\",\n        StateAccessViolation,\n    ),\n]\n\n\n@pytest.mark.parametrize(\"code,exception_type\", invalid_appends_pops)\ndef test_invalid_append_pop(get_contract, assert_compile_failed, code, exception_type):\n    assert_compile_failed(lambda: get_contract(code), exception_type)\n\n\n@pytest.mark.parametrize(\"code,check_result\", append_pop_tests)\n# TODO change this to fuzz random data\n@pytest.mark.parametrize(\"test_data\", [[1, 2, 3, 4, 5][:i] for i in range(6)])\ndef test_append_pop(get_contract, assert_tx_failed, code, check_result, test_data):\n    c = get_contract(code)\n    expected_result = check_result(test_data)\n    if expected_result is None:\n        # None is sentinel to indicate txn should revert\n        assert_tx_failed(lambda: c.foo(test_data))\n    else:\n        assert c.foo(test_data) == expected_result\n\n\nappend_pop_complex_tests = [\n    (\n        \"\"\"\n@external\ndef foo(x: {typ}) -> DynArray[{typ}, 2]:\n    ys: DynArray[{typ}, 1] = []\n    ys.append(x)\n    return ys\n    \"\"\",\n        lambda x: [x],\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 1]\n@external\ndef foo(x: {typ}) -> DynArray[{typ}, 2]:\n    self.my_array.append(x)\n    self.my_array.append(x)  # fail\n    return self.my_array\n    \"\"\",\n        lambda x: None,\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 5]\n@external\ndef foo(x: {typ}) -> (DynArray[{typ}, 5], {typ}):\n    self.my_array.append(x)\n    return self.my_array, self.my_array.pop()\n    \"\"\",\n        lambda x: [[x], x],\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 5]\n@external\ndef foo(x: {typ}) -> ({typ}, DynArray[{typ}, 5]):\n    self.my_array.append(x)\n    return self.my_array.pop(), self.my_array\n    \"\"\",\n        lambda x: [x, []],\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 5]\n@external\ndef foo(x: {typ}) -> {typ}:\n    return self.my_array.pop()\n    \"\"\",\n        lambda x: None,\n    ),\n]\n\n\n@pytest.mark.parametrize(\"code_template,check_result\", append_pop_complex_tests)\n@pytest.mark.parametrize(\n    \"subtype\",\n    [\"uint256[3]\", \"DynArray[uint256,3]\", \"DynArray[uint8, 4]\", \"Foo\", \"DynArray[Foobar, 3]\"],\n)\n# TODO change this to fuzz random data\ndef test_append_pop_complex(get_contract, assert_tx_failed, code_template, check_result, subtype):\n    code = code_template.format(typ=subtype)\n    test_data = [1, 2, 3]\n    if subtype == \"Foo\":\n        test_data = tuple(test_data)\n        struct_def = \"\"\"\nstruct Foo:\n    x: uint256\n    y: uint256\n    z: uint256\n        \"\"\"\n        code = struct_def + \"\\n\" + code\n    elif subtype == \"DynArray[Foobar, 3]\":\n        enum_def = \"\"\"\nenum Foobar:\n    FOO\n    BAR\n    BAZ\n        \"\"\"\n        code = enum_def + \"\\n\" + code\n        test_data = [2 ** (i - 1) for i in test_data]\n\n    c = get_contract(code)\n    expected_result = check_result(test_data)\n    if expected_result is None:\n        # None is sentinel to indicate txn should revert\n        assert_tx_failed(lambda: c.foo(test_data))\n    else:\n        assert c.foo(test_data) == expected_result\n\n\ndef test_so_many_things_you_should_never_do(get_contract):\n    code = \"\"\"\n@internal\ndef _foo(a: DynArray[uint256, 2], b: DynArray[uint256, 2]) -> DynArray[uint256, 5]:\n    return [a[1]-b[0], 2, a[0]-b[1], 8-b[1], 5]\n\n@internal\ndef _foo2() -> (uint256, uint256):\n    b: DynArray[uint256, 2] = [5, 8]\n    a: DynArray[uint256, 10] = [6,7,8,9,10,11,12,13,self._foo([44,b[0]],b)[4],16]\n    return a[6], 4\n\n@external\ndef foo() -> (uint256, DynArray[uint256, 3], DynArray[uint256, 2]):\n    x: DynArray[uint256, 3] = [\n        1,\n        14-self._foo2()[0],\n        self._foo([7,self._foo2()[0]], [11,self._foo2()[1]])[2]\n    ]\n    return 666, x, [88, self._foo2()[0]]\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == [666, [1, 2, 3], [88, 12]]\n\n\ndef test_list_of_structs_arg(get_contract):\n    code = \"\"\"\nenum Foobar:\n    FOO\n    BAR\n\nstruct Foo:\n    x: uint256\n    y: uint256\n    z: Foobar\n\n@external\ndef bar(_baz: DynArray[Foo, 3]) -> uint256:\n    sum: uint256 = 0\n    for i in range(3):\n        e: Foobar = _baz[i].z\n        f: uint256 = convert(e, uint256)\n        sum += _baz[i].x * _baz[i].y + f\n    return sum\n    \"\"\"\n    c = get_contract(code)\n    c_input = [[x, y, 1] for x, y in zip(range(3), range(3))]\n    assert c.bar(c_input) == 8  # (0 * 0 + 1) + (1 * 1 + 1) + (2 * 2 + 1)\n\n\ndef test_list_of_structs_arg_with_dynamic_type(get_contract):\n    code = \"\"\"\nstruct Foo:\n    x: uint256\n    _msg: String[32]\n\n@external\ndef bar(_baz: DynArray[Foo, 3]) -> String[96]:\n    return concat(_baz[0]._msg, _baz[1]._msg, _baz[2]._msg)\n    \"\"\"\n    c = get_contract(code)\n    c_input = [[i, msg] for i, msg in enumerate((\"Hello \", \"world\", \"!!!!\"))]\n    assert c.bar(c_input) == \"Hello world!!!!\"\n\n\ndef test_list_of_structs_lists_with_nested_lists(get_contract, assert_tx_failed):\n    code = \"\"\"\nstruct Bar:\n    a: DynArray[uint8[2], 2]\n\n@external\ndef foo(x: uint8) -> uint8:\n    b: DynArray[Bar[2], 2] = [\n        [\n            Bar({a: [[x, x + 1], [x + 2, x + 3]]}),\n            Bar({a: [[x + 4, x +5], [x + 6, x + 7]]})\n        ],\n        [\n            Bar({a: [[x + 8, x + 9], [x + 10, x + 11]]}),\n            Bar({a: [[x + 12, x + 13], [x + 14, x + 15]]})\n        ],\n    ]\n    return b[0][0].a[0][0] + b[0][1].a[1][1] + b[1][0].a[0][1] + b[1][1].a[1][0]\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo(17) == 98\n    assert_tx_failed(lambda: c.foo(241))\n\n\ndef test_list_of_nested_struct_arrays(get_contract):\n    code = \"\"\"\nstruct Ded:\n    a: uint256[3]\n    b: bool\n\nstruct Foo:\n    c: uint256\n    d: uint256\n    e: Ded\n\nstruct Bar:\n    f: DynArray[Foo, 3]\n    g: DynArray[uint256, 3]\n\n@external\ndef bar(_bar: DynArray[Bar, 3]) -> uint256:\n    sum: uint256 = 0\n    for i in range(3):\n        sum += _bar[i].f[0].e.a[0] * _bar[i].f[1].e.a[1]\n    return sum\n    \"\"\"\n    c = get_contract(code)\n    c_input = [\n        ((tuple([(123, 456, ([i, i + 1, i + 2], False))] * 3)), [9, 8, 7]) for i in range(1, 4)\n    ]\n\n    assert c.bar(c_input) == 20\n\n\ndef test_2d_list_of_struct(get_contract):\n    code = \"\"\"\nstruct Bar:\n    a: uint256\n    b: uint256\n\n@external\ndef foo(x: DynArray[DynArray[Bar, 2], 2]) -> uint256:\n    return x[0][0].a + x[1][1].b\n    \"\"\"\n    c = get_contract(code)\n    c_input = [([i, i * 2], [i * 3, i * 4]) for i in range(1, 3)]\n    assert c.foo(c_input) == 9\n\n\ndef test_3d_list_of_struct(get_contract):\n    code = \"\"\"\nstruct Bar:\n    a: uint256\n    b: uint256\n\n@external\ndef foo(x: DynArray[DynArray[DynArray[Bar, 2], 2], 2]) -> uint256:\n    return x[0][0][0].a + x[1][1][1].b\n    \"\"\"\n    c = get_contract(code)\n    c_input = [([([i, i * 2], [i * 3, i * 4]) for i in range(1, 3)])] * 2\n    assert c.foo(c_input) == 9\n\n\ndef test_list_of_static_list(get_contract):\n    code = \"\"\"\n@external\ndef bar(x: int128) -> DynArray[int128[2], 2]:\n    a: DynArray[int128[2], 2] = [[x, x * 2], [x * 3, x * 4]]\n    return a\n\n@external\ndef foo(x: int128) -> int128:\n    a: DynArray[int128[2], 2] = [[x, x * 2], [x * 3, x * 4]]\n    return a[0][0] * a[1][1]\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [[7, 14], [21, 28]]\n    assert c.foo(7) == 196\n\n\ndef test_list_of_static_nested_list(get_contract):\n    code = \"\"\"\n@external\ndef bar(x: int128) -> DynArray[int128[2][2], 2]:\n    a: DynArray[int128[2][2], 2] = [\n        [[x, x * 2], [x * 3, x * 4]],\n        [[x * 5, x * 6], [x * 7, x * 8]],\n    ]\n    return a\n\n@external\ndef foo(x: int128) -> int128:\n    a: DynArray[int128[2][2], 2] = [\n        [[x, x * 2], [x * 3, x * 4]],\n        [[x * 5, x * 6], [x * 7, x * 8]],\n    ]\n    return a[0][0][0] * a[1][1][1]\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [[[7, 14], [21, 28]], [[35, 42], [49, 56]]]\n    assert c.foo(7) == 392\n\n\ndef test_struct_of_lists(get_contract):\n    code = \"\"\"\nstruct Foo:\n    a1: DynArray[uint256, 2]\n    a2: DynArray[DynArray[uint256, 2], 2]\n    a3: DynArray[DynArray[DynArray[uint256, 2], 2], 2]\n\n@internal\ndef _foo() -> DynArray[uint256, 2]:\n    return [3, 7]\n\n@internal\ndef _foo2() -> DynArray[DynArray[uint256, 2], 2]:\n    y: DynArray[uint256, 2] = self._foo()\n    z: DynArray[uint256, 2] = [y[1], y[0]]\n    return [y, z]\n\n@internal\ndef _foo3() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    y: DynArray[DynArray[uint256, 2], 2] = self._foo2()\n    z: DynArray[DynArray[uint256, 2], 2] = [y[1], y[0]]\n    return [y, z]\n\n@external\ndef bar() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    foo: Foo = Foo({\n        a1: self._foo(),\n        a2: self._foo2(),\n        a3: self._foo3(),\n    })\n    return foo.a3\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar() == [[[3, 7], [7, 3]], [[7, 3], [3, 7]]]\n\n\ndef test_struct_of_lists_2(get_contract):\n    code = \"\"\"\nstruct Foo:\n    b: Bytes[32]\n    da: DynArray[int128, 5]\n    sa: int128[5]\n    some_int: int128\n\n@internal\ndef _foo(x: int128) -> Foo:\n    f: Foo = Foo({\n        b: b\"hello\",\n        da: [x, x * 2],\n        sa: [x + 1, x + 2, x + 3, x + 4, x + 5],\n        some_int: x - 1\n    })\n    return f\n\n@external\ndef bar(x: int128) -> DynArray[int128, 5]:\n    f: Foo = self._foo(x)\n    return f.da\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [7, 14]\n\n\ndef test_struct_of_lists_3(get_contract):\n    code = \"\"\"\nstruct Foo:\n    a: DynArray[int128, 3]\n    b: DynArray[address, 3]\n    c: DynArray[bool, 3]\n\n@internal\ndef _foo(x: int128) -> Foo:\n    f: Foo = Foo({\n        a: [x, x * 2],\n        b: [0x0000000000000000000000000000000000000012],\n        c: [False, True, False]\n\n    })\n    return f\n\n@external\ndef bar(x: int128) -> DynArray[int128, 3]:\n    f: Foo = self._foo(x)\n    return f.a\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [7, 14]\n\n\ndef test_nested_struct_of_lists(get_contract, assert_compile_failed, no_optimize):\n    code = \"\"\"\nstruct nestedFoo:\n    a1: DynArray[DynArray[DynArray[uint256, 2], 2], 2]\n\nstruct Foo:\n    b1: DynArray[DynArray[DynArray[nestedFoo, 2], 2], 2]\n\n@internal\ndef _foo() -> nestedFoo:\n    return nestedFoo({a1: [\n        [[3, 7], [7, 3]],\n        [[7, 3], [3, 7]],\n    ]})\n\n@internal\ndef _foo2() -> Foo:\n    _nF1: nestedFoo = self._foo()\n    return Foo({b1: [[[_nF1, _nF1], [_nF1, _nF1]], [[_nF1, _nF1], [_nF1, _nF1]]]})\n\n@internal\ndef _foo3(f: Foo) -> Foo:\n    new_f: Foo = f\n    new_f.b1[0][1][0].a1[0][0] = [0, 0]\n    new_f.b1[1][0][0].a1[0][1] = [0, 0]\n    new_f.b1[1][1][0].a1[1][1] = [0, 0]\n    return new_f\n\n@external\ndef bar() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    foo: Foo = self._foo2()\n    return self._foo3(foo).b1[1][1][0].a1\n\n@external\ndef bar2() -> uint256:\n    foo: Foo = self._foo2()\n    newFoo: Foo = self._foo3(foo)\n    return newFoo.b1[1][1][0].a1[1][1][0] + \\\\\n        newFoo.b1[1][0][0].a1[0][1][1] + \\\\\n        newFoo.b1[0][1][0].a1[0][0][0]\n    \"\"\"\n\n    if no_optimize:\n        # fails at assembly stage with too many stack variables\n        assert_compile_failed(lambda: get_contract(code), Exception)\n    else:\n        c = get_contract(code)\n        assert c.bar() == [[[3, 7], [7, 3]], [[7, 3], [0, 0]]]\n        assert c.bar2() == 0\n\n\ndef test_tuple_of_lists(get_contract):\n    code = \"\"\"\n@internal\ndef _foo() -> DynArray[uint256, 2]:\n    return [3, 7]\n\n@internal\ndef _foo2() -> DynArray[DynArray[uint256, 2], 2]:\n    y: DynArray[uint256, 2] = self._foo()\n    z: DynArray[uint256, 2] = [y[1], y[0]]\n    return [y, z]\n\n@internal\ndef _foo3() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    y: DynArray[DynArray[uint256, 2], 2] = self._foo2()\n    z: DynArray[DynArray[uint256, 2], 2] = [y[1], y[0]]\n    return [y, z]\n\n@internal\ndef _foo4() -> (DynArray[DynArray[uint256, 2], 2], DynArray[DynArray[DynArray[uint256, 2], 2], 2]):\n    return (self._foo2(), self._foo3())\n\n@external\ndef bar() -> uint256:\n    a: DynArray[DynArray[uint256, 2], 2] = [[0, 0], [0, 0]]\n    b: DynArray[DynArray[DynArray[uint256, 2], 2], 2] = [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    a, b = self._foo4()\n    return a[0][0] * b[1][0][1] + a[1][0] * b[0][1][0]\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar() == 58\n\n\ndef test_constant_list(get_contract, assert_tx_failed):\n    some_good_primes = [5.0, 11.0, 17.0, 29.0, 37.0, 41.0]\n    code = f\"\"\"\nMY_LIST: constant(DynArray[decimal, 6]) = {some_good_primes}\n@external\ndef ix(i: uint256) -> decimal:\n    return MY_LIST[i]\n    \"\"\"\n    c = get_contract(code)\n    for i, p in enumerate(some_good_primes):\n        assert c.ix(i) == p\n    # assert oob\n    assert_tx_failed(lambda: c.ix(len(some_good_primes) + 1))\n\n\ndef test_public_dynarray(get_contract):\n    code = \"\"\"\nmy_list: public(DynArray[uint256, 5])\n@external\ndef __init__():\n    self.my_list = [1,2,3]\n    \"\"\"\n    c = get_contract(code)\n\n    for i, t in enumerate([1, 2, 3]):\n        assert c.my_list(i) == t\n\n\ndef test_nested_public_dynarray(get_contract):\n    code = \"\"\"\nmy_list: public(DynArray[DynArray[uint256, 5], 5])\n@external\ndef __init__():\n    self.my_list = [[1,2,3]]\n    \"\"\"\n    c = get_contract(code)\n\n    for i, l in enumerate([[1, 2, 3]]):\n        for j, t in enumerate(l):\n            assert c.my_list(i, j) == t\n\n\n@pytest.mark.parametrize(\n    \"typ,val\",\n    [\n        (\"DynArray[DynArray[uint256, 5], 5]\", [[], []]),\n        (\"DynArray[DynArray[DynArray[uint256, 5], 5], 5]\", [[[], []], []]),\n    ],\n)\ndef test_empty_nested_dynarray(get_contract, typ, val):\n    code = f\"\"\"\n@external\ndef foo() -> {typ}:\n    a: {typ} = {val}\n    return a\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == val\n\n\n# TODO test negative public(DynArray) cases?\n\n\n# CMC 2022-08-04 these are blocked due to typechecker bug; leaving as\n# negative tests so we know if/when the typechecker is fixed.\n# (don't consider it a high priority to fix since membership in\n# in empty list literal seems like something we should plausibly\n# reject at compile-time anyway)\ndef test_empty_list_membership_fail(get_contract, assert_compile_failed):\n    code = \"\"\"\n@external\ndef foo(x: uint256) -> bool:\n    return x in []\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code))\n    code = \"\"\"\n@external\ndef foo(x: uint256) -> bool:\n    return x not in []\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code))\n\n\n# Would be nice to put this somewhere accessible, like in vyper.types or something\ninteger_types = [\"uint8\", \"int128\", \"int256\", \"uint256\"]\n\n\n@pytest.mark.parametrize(\"storage_type,return_type\", itertools.permutations(integer_types, 2))\ndef test_constant_list_fail(get_contract, assert_compile_failed, storage_type, return_type):\n    code = f\"\"\"\nMY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]\n\n@external\ndef foo() -> DynArray[{return_type}, 3]:\n    return MY_CONSTANT\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), InvalidType)\n\n\n@pytest.mark.parametrize(\"storage_type,return_type\", itertools.permutations(integer_types, 2))\ndef test_constant_list_fail_2(get_contract, assert_compile_failed, storage_type, return_type):\n    code = f\"\"\"\nMY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]\n\n@external\ndef foo() -> {return_type}:\n    return MY_CONSTANT[0]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), InvalidType)\n\n\n@pytest.mark.parametrize(\"storage_type,return_type\", itertools.permutations(integer_types, 2))\ndef test_constant_list_fail_3(get_contract, assert_compile_failed, storage_type, return_type):\n    code = f\"\"\"\nMY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]\n\n@external\ndef foo(i: uint256) -> {return_type}:\n    return MY_CONSTANT[i]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), TypeMismatch)\n", "from vyper import ast as vy_ast\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.evm.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE\nfrom vyper.evm.opcodes import version_check\nfrom vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure, TypeMismatch\nfrom vyper.semantics.types import (\n    AddressT,\n    BoolT,\n    BytesM_T,\n    BytesT,\n    DArrayT,\n    DecimalT,\n    HashMapT,\n    IntegerT,\n    InterfaceT,\n    StructT,\n    TupleT,\n    _BytestringT,\n)\nfrom vyper.semantics.types.shortcuts import BYTES32_T, INT256_T, UINT256_T\nfrom vyper.semantics.types.subscriptable import SArrayT\nfrom vyper.semantics.types.user import EnumT\nfrom vyper.utils import (\n    GAS_CALLDATACOPY_WORD,\n    GAS_CODECOPY_WORD,\n    GAS_IDENTITY,\n    GAS_IDENTITYWORD,\n    ceil32,\n)\n\nDYNAMIC_ARRAY_OVERHEAD = 1\n\n\ndef is_bytes_m_type(typ):\n    return isinstance(typ, BytesM_T)\n\n\ndef is_numeric_type(typ):\n    return isinstance(typ, (IntegerT, DecimalT))\n\n\ndef is_integer_type(typ):\n    return isinstance(typ, IntegerT)\n\n\ndef is_decimal_type(typ):\n    return isinstance(typ, DecimalT)\n\n\ndef is_enum_type(typ):\n    return isinstance(typ, EnumT)\n\n\ndef is_tuple_like(typ):\n    # A lot of code paths treat tuples and structs similarly\n    # so we have a convenience function to detect it\n    ret = isinstance(typ, (TupleT, StructT))\n    assert ret == hasattr(typ, \"tuple_items\")\n    return ret\n\n\ndef is_array_like(typ):\n    # For convenience static and dynamic arrays share some code paths\n    ret = isinstance(typ, (DArrayT, SArrayT))\n    assert ret == typ._is_array_type\n    return ret\n\n\ndef get_type_for_exact_size(n_bytes):\n    \"\"\"Create a type which will take up exactly n_bytes. Used for allocating internal buffers.\n\n    Parameters:\n      n_bytes: the number of bytes to allocate\n    Returns:\n      type: A type which can be passed to context.new_variable\n    \"\"\"\n    return BytesT(n_bytes - 32 * DYNAMIC_ARRAY_OVERHEAD)\n\n\n# propagate revert message when calls to external contracts fail\ndef check_external_call(call_ir):\n    copy_revertdata = [\"returndatacopy\", 0, 0, \"returndatasize\"]\n    revert = IRnode.from_list([\"revert\", 0, \"returndatasize\"], error_msg=\"external call failed\")\n\n    propagate_revert_ir = [\"seq\", copy_revertdata, revert]\n    return [\"if\", [\"iszero\", call_ir], propagate_revert_ir]\n\n\n# cost per byte of the identity precompile\ndef _identity_gas_bound(num_bytes):\n    return GAS_IDENTITY + GAS_IDENTITYWORD * (ceil32(num_bytes) // 32)\n\n\ndef _calldatacopy_gas_bound(num_bytes):\n    return GAS_CALLDATACOPY_WORD * ceil32(num_bytes) // 32\n\n\ndef _codecopy_gas_bound(num_bytes):\n    return GAS_CODECOPY_WORD * ceil32(num_bytes) // 32\n\n\n# Copy byte array word-for-word (including layout)\n# TODO make this a private function\ndef make_byte_array_copier(dst, src):\n    assert isinstance(src.typ, _BytestringT)\n    assert isinstance(dst.typ, _BytestringT)\n\n    _check_assign_bytes(dst, src)\n\n    # TODO: remove this branch, copy_bytes and get_bytearray_length should handle\n    if src.value == \"~empty\":\n        # set length word to 0.\n        return STORE(dst, 0)\n\n    with src.cache_when_complex(\"src\") as (b1, src):\n        with get_bytearray_length(src).cache_when_complex(\"len\") as (b2, len_):\n            max_bytes = src.typ.maxlen\n\n            ret = [\"seq\"]\n            # store length\n            ret.append(STORE(dst, len_))\n\n            dst = bytes_data_ptr(dst)\n            src = bytes_data_ptr(src)\n\n            ret.append(copy_bytes(dst, src, len_, max_bytes))\n            return b1.resolve(b2.resolve(ret))\n\n\ndef bytes_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, _BytestringT)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef dynarray_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, DArrayT)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef _dynarray_make_setter(dst, src):\n    assert isinstance(src.typ, DArrayT)\n    assert isinstance(dst.typ, DArrayT)\n\n    if src.value == \"~empty\":\n        return IRnode.from_list(STORE(dst, 0))\n\n    if src.value == \"multi\":\n        ret = [\"seq\"]\n        # handle literals\n\n        # write the length word\n        store_length = STORE(dst, len(src.args))\n        ann = None\n        if src.annotation is not None:\n            ann = f\"len({src.annotation})\"\n        store_length = IRnode.from_list(store_length, annotation=ann)\n        ret.append(store_length)\n\n        n_items = len(src.args)\n        for i in range(n_items):\n            k = IRnode.from_list(i, typ=UINT256_T)\n            dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n            src_i = get_element_ptr(src, k, array_bounds_check=False)\n            ret.append(make_setter(dst_i, src_i))\n\n        return ret\n\n    with src.cache_when_complex(\"darray_src\") as (b1, src):\n        # for ABI-encoded dynamic data, we must loop to unpack, since\n        # the layout does not match our memory layout\n        should_loop = src.encoding == Encoding.ABI and src.typ.value_type.abi_type.is_dynamic()\n\n        # if the data is not validated, we must loop to unpack\n        should_loop |= needs_clamp(src.typ.value_type, src.encoding)\n\n        # performance: if the subtype is dynamic, there might be a lot\n        # of unused space inside of each element. for instance\n        # DynArray[DynArray[uint256, 100], 5] where all the child\n        # arrays are empty - for this case, we recursively call\n        # into make_setter instead of straight bytes copy\n        # TODO we can make this heuristic more precise, e.g.\n        # loop when subtype.is_dynamic AND location == storage\n        # OR array_size <= /bound where loop is cheaper than memcpy/\n        should_loop |= src.typ.value_type.abi_type.is_dynamic()\n\n        with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n            ret = [\"seq\"]\n\n            ret.append(STORE(dst, count))\n\n            if should_loop:\n                i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=UINT256_T)\n\n                loop_body = make_setter(\n                    get_element_ptr(dst, i, array_bounds_check=False),\n                    get_element_ptr(src, i, array_bounds_check=False),\n                )\n                loop_body.annotation = f\"{dst}[i] = {src}[i]\"\n\n                ret.append([\"repeat\", i, 0, count, src.typ.count, loop_body])\n\n            else:\n                element_size = src.typ.value_type.memory_bytes_required\n                # number of elements * size of element in bytes\n                n_bytes = _mul(count, element_size)\n                max_bytes = src.typ.count * element_size\n\n                src_ = dynarray_data_ptr(src)\n                dst_ = dynarray_data_ptr(dst)\n                ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n\n            return b1.resolve(b2.resolve(ret))\n\n\n# Copy bytes\n# Accepts 4 arguments:\n# (i) an IR node for the start position of the source\n# (ii) an IR node for the start position of the destination\n# (iii) an IR node for the length (in bytes)\n# (iv) a constant for the max length (in bytes)\n# NOTE: may pad to ceil32 of `length`! If you ask to copy 1 byte, it may\n# copy an entire (32-byte) word, depending on the copy routine chosen.\n# TODO maybe always pad to ceil32, to reduce dirty bytes bugs\ndef copy_bytes(dst, src, length, length_bound):\n    annotation = f\"copy up to {length_bound} bytes from {src} to {dst}\"\n\n    src = IRnode.from_list(src)\n    dst = IRnode.from_list(dst)\n    length = IRnode.from_list(length)\n\n    with src.cache_when_complex(\"src\") as (b1, src), length.cache_when_complex(\n        \"copy_bytes_count\"\n    ) as (b2, length), dst.cache_when_complex(\"dst\") as (b3, dst):\n        assert isinstance(length_bound, int) and length_bound >= 0\n\n        # correctness: do not clobber dst\n        if length_bound == 0:\n            return IRnode.from_list([\"seq\"], annotation=annotation)\n        # performance: if we know that length is 0, do not copy anything\n        if length.value == 0:\n            return IRnode.from_list([\"seq\"], annotation=annotation)\n\n        assert src.is_pointer and dst.is_pointer\n\n        # fast code for common case where num bytes is small\n        # TODO expand this for more cases where num words is less than ~8\n        if length_bound <= 32:\n            copy_op = STORE(dst, LOAD(src))\n            ret = IRnode.from_list(copy_op, annotation=annotation)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == MEMORY and src.location in (MEMORY, CALLDATA, DATA):\n            # special cases: batch copy to memory\n            # TODO: iloadbytes\n            if src.location == MEMORY:\n                copy_op = [\"staticcall\", \"gas\", 4, src, length, dst, length]\n                gas_bound = _identity_gas_bound(length_bound)\n            elif src.location == CALLDATA:\n                copy_op = [\"calldatacopy\", dst, src, length]\n                gas_bound = _calldatacopy_gas_bound(length_bound)\n            elif src.location == DATA:\n                copy_op = [\"dloadbytes\", dst, src, length]\n                # note: dloadbytes compiles to CODECOPY\n                gas_bound = _codecopy_gas_bound(length_bound)\n\n            ret = IRnode.from_list(copy_op, annotation=annotation, add_gas_estimate=gas_bound)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == IMMUTABLES and src.location in (MEMORY, DATA):\n            # TODO istorebytes-from-mem, istorebytes-from-calldata(?)\n            # compile to identity, CODECOPY respectively.\n            pass\n\n        # general case, copy word-for-word\n        # pseudocode for our approach (memory-storage as example):\n        # for i in range(len, bound=MAX_LEN):\n        #   sstore(_dst + i, mload(src + i * 32))\n        i = IRnode.from_list(_freshname(\"copy_bytes_ix\"), typ=UINT256_T)\n\n        # optimized form of (div (ceil32 len) 32)\n        n = [\"div\", [\"add\", 31, length], 32]\n        n_bound = ceil32(length_bound) // 32\n\n        dst_i = add_ofst(dst, _mul(i, dst.location.word_scale))\n        src_i = add_ofst(src, _mul(i, src.location.word_scale))\n\n        copy_one_word = STORE(dst_i, LOAD(src_i))\n\n        main_loop = [\"repeat\", i, 0, n, n_bound, copy_one_word]\n\n        return b1.resolve(\n            b2.resolve(b3.resolve(IRnode.from_list(main_loop, annotation=annotation)))\n        )\n\n\n# get the number of bytes at runtime\ndef get_bytearray_length(arg):\n    typ = UINT256_T\n\n    # TODO: it would be nice to merge the implementations of get_bytearray_length and\n    # get_dynarray_count\n    if arg.value == \"~empty\":\n        return IRnode.from_list(0, typ=typ)\n\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\n# get the number of elements at runtime\ndef get_dyn_array_count(arg):\n    assert isinstance(arg.typ, DArrayT)\n\n    typ = UINT256_T\n\n    if arg.value == \"multi\":\n        return IRnode.from_list(len(arg.args), typ=typ)\n\n    if arg.value == \"~empty\":\n        # empty(DynArray[...])\n        return IRnode.from_list(0, typ=typ)\n\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\ndef append_dyn_array(darray_node, elem_node):\n    assert isinstance(darray_node.typ, DArrayT)\n\n    assert darray_node.typ.count > 0, \"jerk boy u r out\"\n\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        len_ = get_dyn_array_count(darray_node)\n        with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n            assertion = [\"assert\", [\"lt\", len_, darray_node.typ.count]]\n            ret.append(IRnode.from_list(assertion, error_msg=f\"{darray_node.typ} bounds check\"))\n            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n            # NOTE: typechecks elem_node\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            ret.append(\n                make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n            )\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)))\n\n\ndef pop_dyn_array(darray_node, return_popped_item):\n    assert isinstance(darray_node.typ, DArrayT)\n    assert darray_node.encoding == Encoding.VYPER\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        old_len = clamp(\"gt\", get_dyn_array_count(darray_node), 0)\n        new_len = IRnode.from_list([\"sub\", old_len, 1], typ=UINT256_T)\n\n        with new_len.cache_when_complex(\"new_len\") as (b2, new_len):\n            ret.append(STORE(darray_node, new_len))\n\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            if return_popped_item:\n                popped_item = get_element_ptr(darray_node, new_len, array_bounds_check=False)\n                ret.append(popped_item)\n                typ = popped_item.typ\n                location = popped_item.location\n            else:\n                typ, location = None, None\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=typ, location=location)\n\n\ndef getpos(node):\n    return (\n        node.lineno,\n        node.col_offset,\n        getattr(node, \"end_lineno\", None),\n        getattr(node, \"end_col_offset\", None),\n    )\n\n\n# add an offset to a pointer, keeping location and encoding info\ndef add_ofst(ptr, ofst):\n    ret = [\"add\", ptr, ofst]\n    return IRnode.from_list(ret, location=ptr.location, encoding=ptr.encoding)\n\n\n# shorthand util\ndef _mul(x, y):\n    ret = [\"mul\", x, y]\n    return IRnode.from_list(ret)\n\n\n# Resolve pointer locations for ABI-encoded data\ndef _getelemptr_abi_helper(parent, member_t, ofst, clamp=True):\n    member_abi_t = member_t.abi_type\n\n    # ABI encoding has length word and then pretends length is not there\n    # e.g. [[1,2]] is encoded as 0x01 <len> 0x20 <inner array ofst> <encode(inner array)>\n    # note that inner array ofst is 0x20, not 0x40.\n    if has_length_word(parent.typ):\n        parent = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n\n    ofst_ir = add_ofst(parent, ofst)\n\n    if member_abi_t.is_dynamic():\n        # double dereference, according to ABI spec\n        # TODO optimize special case: first dynamic item\n        # offset is statically known.\n        ofst_ir = add_ofst(parent, unwrap_location(ofst_ir))\n\n    return IRnode.from_list(\n        ofst_ir,\n        typ=member_t,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=f\"{parent}{ofst}\",\n    )\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_tuplelike(parent, key):\n    typ = parent.typ\n    assert is_tuple_like(typ)\n\n    if isinstance(typ, StructT):\n        assert isinstance(key, str)\n        subtype = typ.member_types[key]\n        attrs = list(typ.tuple_keys())\n        index = attrs.index(key)\n        annotation = key\n    else:\n        # TupleT\n        assert isinstance(key, int)\n        subtype = typ.member_types[key]\n        attrs = list(typ.tuple_keys())\n        index = key\n        annotation = None\n\n    # generated by empty() + make_setter\n    if parent.value == \"~empty\":\n        return IRnode.from_list(\"~empty\", typ=subtype)\n\n    if parent.value == \"multi\":\n        assert parent.encoding != Encoding.ABI, \"no abi-encoded literals\"\n        return parent.args[index]\n\n    ofst = 0  # offset from parent start\n\n    if parent.encoding == Encoding.ABI:\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_t = typ.member_types[attrs[index]]\n\n        for i in range(index):\n            member_abi_t = typ.member_types[attrs[i]].abi_type\n            ofst += member_abi_t.embedded_static_size()\n\n        return _getelemptr_abi_helper(parent, member_t, ofst)\n\n    if parent.location.word_addressable:\n        for i in range(index):\n            ofst += typ.member_types[attrs[i]].storage_size_in_words\n    elif parent.location.byte_addressable:\n        for i in range(index):\n            ofst += typ.member_types[attrs[i]].memory_bytes_required\n    else:\n        raise CompilerPanic(f\"bad location {parent.location}\")  # pragma: notest\n\n    return IRnode.from_list(\n        add_ofst(parent, ofst),\n        typ=subtype,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=annotation,\n    )\n\n\ndef has_length_word(typ):\n    # Consider moving this to an attribute on typ\n    return isinstance(typ, (DArrayT, _BytestringT))\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_array(parent, key, array_bounds_check):\n    assert is_array_like(parent.typ)\n\n    if not is_integer_type(key.typ):\n        raise TypeCheckFailure(f\"{key.typ} used as array index\")\n\n    subtype = parent.typ.value_type\n\n    if parent.value == \"~empty\":\n        if array_bounds_check:\n            # this case was previously missing a bounds check. codegen\n            # is a bit complicated when bounds check is required, so\n            # block it. there is no reason to index into a literal empty\n            # array anyways!\n            raise TypeCheckFailure(\"indexing into zero array not allowed\")\n        return IRnode.from_list(\"~empty\", subtype)\n\n    if parent.value == \"multi\":\n        assert isinstance(key.value, int)\n        return parent.args[key.value]\n\n    ix = unwrap_location(key)\n\n    if array_bounds_check:\n        is_darray = isinstance(parent.typ, DArrayT)\n        bound = get_dyn_array_count(parent) if is_darray else parent.typ.count\n        # uclamplt works, even for signed ints. since two's-complement\n        # is used, if the index is negative, (unsigned) LT will interpret\n        # it as a very large number, larger than any practical value for\n        # an array index, and the clamp will throw an error.\n        # NOTE: there are optimization rules for this when ix or bound is literal\n        ix = clamp(\"lt\", ix, bound)\n\n    if parent.encoding == Encoding.ABI:\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_abi_t = subtype.abi_type\n\n        ofst = _mul(ix, member_abi_t.embedded_static_size())\n\n        return _getelemptr_abi_helper(parent, subtype, ofst)\n\n    if parent.location.word_addressable:\n        element_size = subtype.storage_size_in_words\n    elif parent.location.byte_addressable:\n        element_size = subtype.memory_bytes_required\n    else:\n        raise CompilerPanic(\"unreachable\")  # pragma: notest\n\n    ofst = _mul(ix, element_size)\n\n    if has_length_word(parent.typ):\n        data_ptr = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n    else:\n        data_ptr = parent\n\n    return IRnode.from_list(add_ofst(data_ptr, ofst), typ=subtype, location=parent.location)\n\n\ndef _get_element_ptr_mapping(parent, key):\n    assert isinstance(parent.typ, HashMapT)\n    subtype = parent.typ.value_type\n    key = unwrap_location(key)\n\n    # TODO when is key None?\n    if key is None or parent.location != STORAGE:\n        raise TypeCheckFailure(f\"bad dereference on mapping {parent}[{key}]\")\n\n    return IRnode.from_list([\"sha3_64\", parent, key], typ=subtype, location=STORAGE)\n\n\n# Take a value representing a memory or storage location, and descend down to\n# an element or member variable\n# This is analogous (but not necessarily equivalent to) getelementptr in LLVM.\ndef get_element_ptr(parent, key, array_bounds_check=True):\n    with parent.cache_when_complex(\"val\") as (b, parent):\n        typ = parent.typ\n\n        if is_tuple_like(typ):\n            ret = _get_element_ptr_tuplelike(parent, key)\n\n        elif isinstance(typ, HashMapT):\n            ret = _get_element_ptr_mapping(parent, key)\n\n        elif is_array_like(typ):\n            ret = _get_element_ptr_array(parent, key, array_bounds_check)\n\n        else:\n            raise CompilerPanic(f\"get_element_ptr cannot be called on {typ}\")  # pragma: notest\n\n        return b.resolve(ret)\n\n\ndef LOAD(ptr: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.load_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n    return IRnode.from_list([op, ptr])\n\n\ndef eval_once_check(name):\n    # an IRnode which enforces uniqueness. include with a side-effecting\n    # operation to sanity check that the codegen pipeline only generates\n    # the side-effecting operation once (otherwise, IR-to-assembly will\n    # throw a duplicate label exception). there is no runtime overhead\n    # since the jumpdest gets optimized out in the final stage of assembly.\n    return IRnode.from_list([\"unique_symbol\", name])\n\n\ndef STORE(ptr: IRnode, val: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.store_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n\n    _check = _freshname(f\"{op}_\")\n\n    store = [op, ptr, val]\n    # don't use eval_once_check for memory, immutables because it interferes\n    # with optimizer\n    if ptr.location in (MEMORY, IMMUTABLES):\n        return IRnode.from_list(store)\n\n    return IRnode.from_list([\"seq\", eval_once_check(_check), store])\n\n\n# Unwrap location\ndef unwrap_location(orig):\n    if orig.location is not None:\n        return IRnode.from_list(LOAD(orig), typ=orig.typ)\n    else:\n        # CMC 2022-03-24 TODO refactor so this branch can be removed\n        if orig.value == \"~empty\":\n            # must be word type\n            return IRnode.from_list(0, typ=orig.typ)\n        return orig\n\n\n# utility function, constructs an IR tuple out of a list of IR nodes\ndef ir_tuple_from_args(args):\n    typ = TupleT([x.typ for x in args])\n    return IRnode.from_list([\"multi\"] + [x for x in args], typ=typ)\n\n\ndef needs_external_call_wrap(typ):\n    # for calls to ABI conforming contracts.\n    # according to the ABI spec, return types are ALWAYS tuples even\n    # if only one element is being returned.\n    # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding\n    # \"and the return values v_1, ..., v_k of f are encoded as\n    #\n    #    enc((v_1, ..., v_k))\n    #    i.e. the values are combined into a tuple and encoded.\n    # \"\n    # therefore, wrap it in a tuple if it's not already a tuple.\n    # for example, `bytes` is returned as abi-encoded (bytes,)\n    # and `(bytes,)` is returned as abi-encoded ((bytes,),)\n    # In general `-> X` gets returned as (X,)\n    # including structs. MyStruct is returned as abi-encoded (MyStruct,).\n    # (Sorry this is so confusing. I didn't make these rules.)\n\n    return not (isinstance(typ, TupleT) and typ.length > 1)\n\n\ndef calculate_type_for_external_return(typ):\n    if needs_external_call_wrap(typ):\n        return TupleT([typ])\n    return typ\n\n\ndef wrap_value_for_external_return(ir_val):\n    # used for LHS promotion\n    if needs_external_call_wrap(ir_val.typ):\n        return ir_tuple_from_args([ir_val])\n    else:\n        return ir_val\n\n\ndef set_type_for_external_return(ir_val):\n    # used for RHS promotion\n    ir_val.typ = calculate_type_for_external_return(ir_val.typ)\n\n\n# return a dummy IRnode with the given type\ndef dummy_node_for_type(typ):\n    return IRnode(\"fake_node\", typ=typ)\n\n\ndef _check_assign_bytes(left, right):\n    if right.typ.maxlen > left.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from {right.typ} to {left.typ}\")  # pragma: notest\n\n    # stricter check for zeroing a byte array.\n    if right.value == \"~empty\" and right.typ.maxlen != left.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from empty({right.typ}) to {left.typ}\")  # pragma: notest\n\n\ndef _check_assign_list(left, right):\n    def FAIL():  # pragma: no cover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if left.value == \"multi\":\n        # Cannot do something like [a, b, c] = [1, 2, 3]\n        FAIL()  # pragma: notest\n\n    if isinstance(left.typ, SArrayT):\n        if not is_array_like(right.typ):\n            FAIL()  # pragma: notest\n        if left.typ.count != right.typ.count:\n            FAIL()  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(\n            dummy_node_for_type(left.typ.value_type), dummy_node_for_type(right.typ.value_type)\n        )\n\n    if isinstance(left.typ, DArrayT):\n        if not isinstance(right.typ, DArrayT):\n            FAIL()  # pragma: notest\n\n        if left.typ.count < right.typ.count:\n            FAIL()  # pragma: notest\n\n        # stricter check for zeroing\n        if right.value == \"~empty\" and right.typ.count != left.typ.count:\n            raise TypeCheckFailure(\n                f\"Bad type for clearing bytes: expected {left.typ} but got {right.typ}\"\n            )  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(\n            dummy_node_for_type(left.typ.value_type), dummy_node_for_type(right.typ.value_type)\n        )\n\n\ndef _check_assign_tuple(left, right):\n    def FAIL():  # pragma: no cover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if not isinstance(right.typ, left.typ.__class__):\n        FAIL()  # pragma: notest\n\n    if isinstance(left.typ, StructT):\n        for k in left.typ.member_types:\n            if k not in right.typ.member_types:\n                FAIL()  # pragma: notest\n            # TODO recurse into left, right if literals?\n            check_assign(\n                dummy_node_for_type(left.typ.member_types[k]),\n                dummy_node_for_type(right.typ.member_types[k]),\n            )\n\n        for k in right.typ.member_types:\n            if k not in left.typ.member_types:\n                FAIL()  # pragma: notest\n\n        if left.typ.name != right.typ.name:\n            FAIL()  # pragma: notest\n\n    else:\n        if len(left.typ.member_types) != len(right.typ.member_types):\n            FAIL()  # pragma: notest\n        for left_, right_ in zip(left.typ.member_types, right.typ.member_types):\n            # TODO recurse into left, right if literals?\n            check_assign(dummy_node_for_type(left_), dummy_node_for_type(right_))\n\n\n# sanity check an assignment\n# typechecking source code is done at an earlier phase\n# this function is more of a sanity check for typechecking internally\n# generated assignments\n# TODO: do we still need this?\ndef check_assign(left, right):\n    def FAIL():  # pragma: no cover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ} {left} {right}\")\n\n    if isinstance(left.typ, _BytestringT):\n        _check_assign_bytes(left, right)\n    elif is_array_like(left.typ):\n        _check_assign_list(left, right)\n    elif is_tuple_like(left.typ):\n        _check_assign_tuple(left, right)\n\n    elif left.typ._is_prim_word:\n        # TODO once we propagate types from typechecker, introduce this check:\n        # if left.typ != right.typ:\n        #    FAIL()  # pragma: notest\n        pass\n\n    else:  # pragma: no cover\n        FAIL()\n\n\n_label = 0\n\n\n# TODO might want to coalesce with Context.fresh_varname and compile_ir.mksymbol\ndef _freshname(name):\n    global _label\n    _label += 1\n    return f\"{name}{_label}\"\n\n\ndef reset_names():\n    global _label\n    _label = 0\n\n\n# returns True if t is ABI encoded and is a type that needs any kind of\n# validation\ndef needs_clamp(t, encoding):\n    if encoding == Encoding.VYPER:\n        return False\n    if encoding != Encoding.ABI:\n        raise CompilerPanic(\"unreachable\")  # pragma: notest\n    if isinstance(t, (_BytestringT, DArrayT)):\n        return True\n    if isinstance(t, EnumT):\n        return len(t._enum_members) < 256\n    if isinstance(t, SArrayT):\n        return needs_clamp(t.value_type, encoding)\n    if is_tuple_like(t):\n        return any(needs_clamp(m, encoding) for m in t.tuple_members())\n    if t._is_prim_word:\n        return t not in (INT256_T, UINT256_T, BYTES32_T)\n\n    raise CompilerPanic(\"unreachable\")  # pragma: notest\n\n\n# Create an x=y statement, where the types may be compound\ndef make_setter(left, right):\n    check_assign(left, right)\n\n    # For types which occupy just one word we can use single load/store\n    if left.typ._is_prim_word:\n        enc = right.encoding  # unwrap_location butchers encoding\n        right = unwrap_location(right)\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, enc):\n            right = clamp_basetype(right)\n\n        return STORE(left, right)\n\n    # Byte arrays\n    elif isinstance(left.typ, _BytestringT):\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"bs_ptr\") as (b, right):\n                copier = make_byte_array_copier(left, right)\n                ret = b.resolve([\"seq\", clamp_bytestring(right), copier])\n        else:\n            ret = make_byte_array_copier(left, right)\n\n        return IRnode.from_list(ret)\n\n    elif isinstance(left.typ, DArrayT):\n        # TODO should we enable this?\n        # implicit conversion from sarray to darray\n        # if isinstance(right.typ, SArrayType):\n        #    return _complex_make_setter(left, right)\n\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"arr_ptr\") as (b, right):\n                copier = _dynarray_make_setter(left, right)\n                ret = b.resolve([\"seq\", clamp_dyn_array(right), copier])\n        else:\n            ret = _dynarray_make_setter(left, right)\n\n        return IRnode.from_list(ret)\n\n    # Complex Types\n    assert isinstance(left.typ, (SArrayT, TupleT, StructT))\n\n    return _complex_make_setter(left, right)\n\n\ndef _complex_make_setter(left, right):\n    if right.value == \"~empty\" and left.location == MEMORY:\n        # optimized memzero\n        return mzero(left, left.typ.memory_bytes_required)\n\n    ret = [\"seq\"]\n\n    if isinstance(left.typ, SArrayT):\n        n_items = right.typ.count\n        keys = [IRnode.from_list(i, typ=UINT256_T) for i in range(n_items)]\n\n    else:\n        assert is_tuple_like(left.typ)\n        keys = left.typ.tuple_keys()\n\n    # if len(keyz) == 0:\n    #    return IRnode.from_list([\"pass\"])\n\n    # general case\n    # TODO use copy_bytes when the generated code is above a certain size\n    with left.cache_when_complex(\"_L\") as (b1, left), right.cache_when_complex(\"_R\") as (b2, right):\n        for k in keys:\n            l_i = get_element_ptr(left, k, array_bounds_check=False)\n            r_i = get_element_ptr(right, k, array_bounds_check=False)\n            ret.append(make_setter(l_i, r_i))\n\n        return b1.resolve(b2.resolve(IRnode.from_list(ret)))\n\n\ndef ensure_in_memory(ir_var, context):\n    \"\"\"Ensure a variable is in memory. This is useful for functions\n    which expect to operate on memory variables.\n    \"\"\"\n    if ir_var.location == MEMORY:\n        return ir_var\n\n    typ = ir_var.typ\n    buf = IRnode.from_list(context.new_internal_variable(typ), typ=typ, location=MEMORY)\n    do_copy = make_setter(buf, ir_var)\n\n    return IRnode.from_list([\"seq\", do_copy, buf], typ=typ, location=MEMORY)\n\n\ndef eval_seq(ir_node):\n    \"\"\"Tries to find the \"return\" value of a `seq` statement, in order so\n    that the value can be known without possibly evaluating side effects\n    \"\"\"\n    if ir_node.value in (\"seq\", \"with\") and len(ir_node.args) > 0:\n        return eval_seq(ir_node.args[-1])\n    if isinstance(ir_node.value, int):\n        return IRnode.from_list(ir_node)\n    return None\n\n\n# TODO move return checks to vyper/semantics/validation\ndef is_return_from_function(node):\n    if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") in (\n        \"raw_revert\",\n        \"selfdestruct\",\n    ):\n        return True\n    if isinstance(node, (vy_ast.Return, vy_ast.Raise)):\n        return True\n    return False\n\n\ndef check_single_exit(fn_node):\n    _check_return_body(fn_node, fn_node.body)\n    for node in fn_node.get_descendants(vy_ast.If):\n        _check_return_body(node, node.body)\n        if node.orelse:\n            _check_return_body(node, node.orelse)\n\n\ndef _check_return_body(node, node_list):\n    return_count = len([n for n in node_list if is_return_from_function(n)])\n    if return_count > 1:\n        raise StructureException(\n            \"Too too many exit statements (return, raise or selfdestruct).\", node\n        )\n    # Check for invalid code after returns.\n    last_node_pos = len(node_list) - 1\n    for idx, n in enumerate(node_list):\n        if is_return_from_function(n) and idx < last_node_pos:\n            # is not last statement in body.\n            raise StructureException(\n                \"Exit statement with succeeding code (that will not execute).\", node_list[idx + 1]\n            )\n\n\ndef mzero(dst, nbytes):\n    # calldatacopy from past-the-end gives zero bytes.\n    # cf. YP H.2 (ops section) with CALLDATACOPY spec.\n    return IRnode.from_list(\n        # calldatacopy mempos calldatapos len\n        [\"calldatacopy\", dst, \"calldatasize\", nbytes],\n        annotation=\"mzero\",\n    )\n\n\n# zero pad a bytearray according to the ABI spec. The last word\n# of the byte array needs to be right-padded with zeroes.\ndef zero_pad(bytez_placeholder):\n    len_ = [\"mload\", bytez_placeholder]\n    dst = [\"add\", [\"add\", bytez_placeholder, 32], \"len\"]\n    # the runtime length of the data rounded up to nearest 32\n    # from spec:\n    #   the actual value of X as a byte sequence,\n    #   followed by the *minimum* number of zero-bytes\n    #   such that len(enc(X)) is a multiple of 32.\n    # optimized form of ceil32(len) - len:\n    num_zero_bytes = [\"mod\", [\"sub\", 0, \"len\"], 32]\n    return IRnode.from_list(\n        [\"with\", \"len\", len_, [\"with\", \"dst\", dst, mzero(\"dst\", num_zero_bytes)]],\n        annotation=\"Zero pad\",\n    )\n\n\n# convenience rewrites for shr/sar/shl\ndef shr(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shr\", bits, x]\n    return [\"div\", x, [\"exp\", 2, bits]]\n\n\n# convenience rewrites for shr/sar/shl\ndef shl(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shl\", bits, x]\n    return [\"mul\", x, [\"exp\", 2, bits]]\n\n\ndef sar(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"sar\", bits, x]\n\n    raise NotImplementedError(\"no SAR emulation for pre-constantinople EVM\")\n\n\ndef clamp_bytestring(ir_node):\n    t = ir_node.typ\n    if not isinstance(t, _BytestringT):\n        raise CompilerPanic(f\"{t} passed to clamp_bytestring\")  # pragma: notest\n    ret = [\"assert\", [\"le\", get_bytearray_length(ir_node), t.maxlen]]\n    return IRnode.from_list(ret, error_msg=f\"{ir_node.typ} bounds check\")\n\n\ndef clamp_dyn_array(ir_node):\n    t = ir_node.typ\n    assert isinstance(t, DArrayT)\n    ret = [\"assert\", [\"le\", get_dyn_array_count(ir_node), t.count]]\n    return IRnode.from_list(ret, error_msg=f\"{ir_node.typ} bounds check\")\n\n\n# clampers for basetype\ndef clamp_basetype(ir_node):\n    t = ir_node.typ\n    if not t._is_prim_word:\n        raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest\n\n    # copy of the input\n    ir_node = unwrap_location(ir_node)\n\n    if isinstance(t, EnumT):\n        bits = len(t._enum_members)\n        # assert x >> bits == 0\n        ret = int_clamp(ir_node, bits, signed=False)\n\n    elif isinstance(t, (IntegerT, DecimalT)):\n        if t.bits == 256:\n            ret = ir_node\n        else:\n            ret = int_clamp(ir_node, t.bits, signed=t.is_signed)\n\n    elif isinstance(t, BytesM_T):\n        if t.m == 32:\n            ret = ir_node  # special case, no clamp.\n        else:\n            ret = bytes_clamp(ir_node, t.m)\n\n    elif isinstance(t, (AddressT, InterfaceT)):\n        ret = int_clamp(ir_node, 160)\n    elif t in (BoolT(),):\n        ret = int_clamp(ir_node, 1)\n    else:  # pragma: no cover\n        raise CompilerPanic(f\"{t} passed to clamp_basetype\")\n\n    return IRnode.from_list(ret, typ=ir_node.typ, error_msg=f\"validate {t}\")\n\n\ndef int_clamp(ir_node, bits, signed=False):\n    \"\"\"Generalized clamper for integer types. Takes the number of bits,\n    whether it's signed, and returns an IR node which checks it is\n    in bounds. (Consumers should use clamp_basetype instead which uses\n    type-based dispatch and is a little safer.)\n    \"\"\"\n    if bits >= 256:\n        raise CompilerPanic(f\"invalid clamp: {bits}>=256 ({ir_node})\")  # pragma: notest\n\n    u = \"u\" if not signed else \"\"\n    msg = f\"{u}int{bits} bounds check\"\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        if signed:\n            # example for bits==128:\n            # promote_signed_int(val, bits) is the \"canonical\" version of val\n            # if val is in bounds, the bits above bit 128 should be equal.\n            # (this works for both val >= 0 and val < 0. in the first case,\n            # all upper bits should be 0 if val is a valid int128,\n            # in the latter case, all upper bits should be 1.)\n            assertion = [\"assert\", [\"eq\", val, promote_signed_int(val, bits)]]\n        else:\n            assertion = [\"assert\", [\"iszero\", shr(bits, val)]]\n\n        assertion = IRnode.from_list(assertion, error_msg=msg)\n\n        ret = b.resolve([\"seq\", assertion, val])\n\n    return IRnode.from_list(ret, annotation=msg)\n\n\ndef bytes_clamp(ir_node: IRnode, n_bytes: int) -> IRnode:\n    if not (0 < n_bytes <= 32):\n        raise CompilerPanic(f\"bad type: bytes{n_bytes}\")\n    msg = f\"bytes{n_bytes} bounds check\"\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        assertion = IRnode.from_list([\"assert\", [\"iszero\", shl(n_bytes * 8, val)]], error_msg=msg)\n        ret = b.resolve([\"seq\", assertion, val])\n\n    return IRnode.from_list(ret, annotation=msg)\n\n\n# e.g. for int8, promote 255 to -1\ndef promote_signed_int(x, bits):\n    assert bits % 8 == 0\n    ret = [\"signextend\", bits // 8 - 1, x]\n    return IRnode.from_list(ret, annotation=f\"promote int{bits}\")\n\n\n# general clamp function for all ops and numbers\ndef clamp(op, arg, bound):\n    with IRnode.from_list(arg).cache_when_complex(\"clamp_arg\") as (b1, arg):\n        check = IRnode.from_list([\"assert\", [op, arg, bound]], error_msg=f\"clamp {op} {bound}\")\n        ret = [\"seq\", check, arg]\n        return IRnode.from_list(b1.resolve(ret), typ=arg.typ)\n\n\ndef clamp_nonzero(arg):\n    # TODO: use clamp(\"ne\", arg, 0) once optimizer rules can handle it\n    with IRnode.from_list(arg).cache_when_complex(\"should_nonzero\") as (b1, arg):\n        check = IRnode.from_list([\"assert\", arg], error_msg=\"check nonzero\")\n        ret = [\"seq\", check, arg]\n        return IRnode.from_list(b1.resolve(ret), typ=arg.typ)\n\n\ndef clamp2(lo, arg, hi, signed):\n    with IRnode.from_list(arg).cache_when_complex(\"clamp2_arg\") as (b1, arg):\n        GE = \"sge\" if signed else \"ge\"\n        LE = \"sle\" if signed else \"le\"\n        ret = [\"seq\", [\"assert\", [\"and\", [GE, arg, lo], [LE, arg, hi]]], arg]\n        return IRnode.from_list(b1.resolve(ret), typ=arg.typ)\n"], "fixing_code": ["import itertools\n\nimport pytest\n\nfrom vyper.exceptions import (\n    ArgumentException,\n    ArrayIndexException,\n    ImmutableViolation,\n    InvalidType,\n    OverflowException,\n    StateAccessViolation,\n    TypeMismatch,\n)\n\n\ndef test_list_tester_code(get_contract_with_gas_estimation):\n    list_tester_code = \"\"\"\nz: DynArray[int128, 3]\nz2: DynArray[DynArray[int128, 2], 2]\nz3: DynArray[int128, 2]\n\n@external\ndef foo(x: DynArray[int128, 3]) -> int128:\n    return x[0] + x[1] + x[2]\n\n@external\ndef goo(x: DynArray[DynArray[int128, 2], 2]) -> int128:\n    return x[0][0] + x[0][1] + x[1][0] * 10 + x[1][1] * 10\n\n@external\ndef hoo(x: DynArray[int128, 3]) -> int128:\n    y: DynArray[int128, 3] = x\n    return y[0] + x[1] + y[2]\n\n@external\ndef joo(x: DynArray[DynArray[int128, 2], 2]) -> int128:\n    y: DynArray[DynArray[int128, 2], 2] = x\n    y2: DynArray[int128, 2] = x[1]\n    return y[0][0] + y[0][1] + y2[0] * 10 + y2[1] * 10\n\n@external\ndef koo(x: DynArray[int128, 3]) -> int128:\n    self.z = x\n    return self.z[0] + x[1] + self.z[2]\n\n@external\ndef loo(x: DynArray[DynArray[int128, 2], 2]) -> int128:\n    self.z2 = x\n    self.z3 = x[1]\n    return self.z2[0][0] + self.z2[0][1] + self.z3[0] * 10 + self.z3[1] * 10\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(list_tester_code)\n    assert c.foo([3, 4, 5]) == 12\n    assert c.goo([[1, 2], [3, 4]]) == 73\n    assert c.hoo([3, 4, 5]) == 12\n    assert c.joo([[1, 2], [3, 4]]) == 73\n    assert c.koo([3, 4, 5]) == 12\n    assert c.loo([[1, 2], [3, 4]]) == 73\n    print(\"Passed list tests\")\n\n\ndef test_string_list(get_contract):\n    code = \"\"\"\n@external\ndef foo1(x: DynArray[String[32], 2]) -> DynArray[String[32], 2]:\n    return x\n\n@external\ndef foo2(x: DynArray[DynArray[String[32], 2], 2]) -> DynArray[DynArray[String[32], 2], 2]:\n    return x\n\n@external\ndef foo3(x: DynArray[DynArray[String[32], 2], 2]) -> DynArray[String[32], 2]:\n    return x[0]\n\n@external\ndef foo4(x: DynArray[DynArray[String[32], 2], 2]) -> String[32]:\n    return x[0][0]\n\n@external\ndef foo5() -> DynArray[String[32], 2]:\n    ret: DynArray[String[32], 2] = [\"hello\"]\n    ret.append(\"world\")\n    return ret\n\n@external\ndef foo6() -> DynArray[DynArray[String[32], 2], 2]:\n    ret: DynArray[DynArray[String[32], 2], 2] = []\n    ret.append([\"hello\", \"world\"])\n    return ret\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.foo1([\"hello\", \"world\"]) == [\"hello\", \"world\"]\n    assert c.foo2([[\"hello\", \"world\"]]) == [[\"hello\", \"world\"]]\n    assert c.foo3([[\"hello\", \"world\"]]) == [\"hello\", \"world\"]\n    assert c.foo4([[\"hello\", \"world\"]]) == \"hello\"\n    assert c.foo5() == [\"hello\", \"world\"]\n    assert c.foo6() == [[\"hello\", \"world\"]]\n\n\ndef test_list_output_tester_code(get_contract_with_gas_estimation):\n    list_output_tester_code = \"\"\"\nenum Foobar:\n    FOO\n    BAR\n\ny: DynArray[Foobar, 2]\nz: DynArray[int128, 2]\n\n@external\ndef foo() -> DynArray[int128, 2]:\n    return [3, 5]\n\n@external\ndef goo() -> DynArray[int128, 2]:\n    x: DynArray[int128, 2] = [3, 5]\n    return x\n\n@external\ndef hoo() -> DynArray[int128, 2]:\n    self.z = [3, 5]\n    return self.z\n\n@external\ndef hoo1() -> DynArray[int128, 2]:\n    self.z = empty(DynArray[int128, 2])\n    return self.z\n\n@external\ndef hoo2() -> DynArray[int128, 2]:\n    return empty(DynArray[int128, 2])\n\n@external\ndef hoo3() -> DynArray[int128, 2]:\n    return []\n\n@external\ndef hoo4() -> DynArray[int128, 2]:\n    self.z = []\n    return self.z\n\n@external\ndef hoo5() -> DynArray[DynArray[int128, 2], 2]:\n    return []\n\n@external\ndef joo() -> DynArray[int128, 2]:\n    self.z = [3, 5]\n    x: DynArray[int128, 2] = self.z\n    return x\n\n@external\ndef koo() -> DynArray[DynArray[int128, 2], 2]:\n    return [[1, 2], [3, 4]]\n\n@external\ndef loo() -> DynArray[DynArray[int128, 2], 2]:\n    x: DynArray[DynArray[int128, 2], 2] = [[1, 2], [3, 4]]\n    return x\n\n@external\ndef moo() -> DynArray[DynArray[int128, 2], 2]:\n    x: DynArray[int128, 2] = [1,2]\n    return [x, [3,4]]\n\n@external\ndef noo(inp: DynArray[int128, 2]) -> DynArray[int128, 2]:\n    return inp\n\n@external\ndef ooo(inp: DynArray[int128, 2]) -> DynArray[int128, 2]:\n    self.z = inp\n    return self.z\n\n@external\ndef poo(inp: DynArray[DynArray[int128, 2], 2]) -> DynArray[DynArray[int128, 2], 2]:\n    return inp\n\n@external\ndef qoo(inp: DynArray[int128, 2]) -> DynArray[DynArray[int128, 2], 2]:\n    return [inp, [3,4]]\n\n@external\ndef roo(inp: DynArray[decimal, 2]) -> DynArray[DynArray[decimal, 2], 2]:\n    return [inp, [3.0, 4.0]]\n\n@external\ndef soo() -> DynArray[Foobar, 2]:\n    x: DynArray[Foobar, 2] = [Foobar.FOO, Foobar.BAR]\n    return x\n\n@external\ndef too() -> DynArray[Foobar, 2]:\n    self.y = [Foobar.BAR, Foobar.FOO]\n    return self.y\n\n@external\ndef uoo(inp: DynArray[Foobar, 2]) -> DynArray[DynArray[Foobar, 2], 2]:\n    return [inp, [Foobar.BAR, Foobar.FOO]]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(list_output_tester_code)\n    assert c.foo() == [3, 5]\n    assert c.goo() == [3, 5]\n    assert c.hoo() == [3, 5]\n    assert c.hoo1() == c.hoo2() == c.hoo3() == c.hoo4() == []\n    assert c.hoo5() == []\n    assert c.joo() == [3, 5]\n    assert c.koo() == [[1, 2], [3, 4]]\n    assert c.loo() == [[1, 2], [3, 4]]\n    assert c.moo() == [[1, 2], [3, 4]]\n    assert c.noo([]) == []\n    assert c.noo([3, 5]) == [3, 5]\n    assert c.ooo([]) == []\n    assert c.ooo([3, 5]) == [3, 5]\n    assert c.poo([]) == []\n    assert c.poo([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]\n    assert c.qoo([1, 2]) == [[1, 2], [3, 4]]\n    assert c.roo([1, 2]) == [[1.0, 2.0], [3.0, 4.0]]\n    assert c.soo() == [1, 2]\n    assert c.too() == [2, 1]\n    assert c.uoo([1, 2]) == [[1, 2], [2, 1]]\n\n    print(\"Passed list output tests\")\n\n\ndef test_array_accessor(get_contract_with_gas_estimation):\n    array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[int128, 4] = [0, 0, 0, 0]\n    a[0] = x\n    a[1] = y\n    a[2] = z\n    a[3] = w\n    return a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(array_accessor)\n    assert c.test_array(2, 7, 1, 8) == 2718\n    print(\"Passed basic array accessor test\")\n\n\ndef test_two_d_array_accessor(get_contract_with_gas_estimation):\n    two_d_array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[int128, 2], 2] = [[0, 0], [0, 0]]\n    a[0][0] = x\n    a[0][1] = y\n    a[1][0] = z\n    a[1][1] = w\n    return a[0][0] * 1000 + a[0][1] * 100 + a[1][0] * 10 + a[1][1]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(two_d_array_accessor)\n    assert c.test_array(2, 7, 1, 8) == 2718\n    print(\"Passed complex array accessor test\")\n\n\ndef test_three_d_array_accessor(get_contract_with_gas_estimation):\n    three_d_array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[int128, 2], 2], 2] = [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    a[0][0][0] = x\n    a[0][0][1] = y\n    a[0][1][0] = z\n    a[0][1][1] = w\n    a[1][0][0] = -x\n    a[1][0][1] = -y\n    a[1][1][0] = -z\n    a[1][1][1] = -w\n    return a[0][0][0] * 1000 + a[0][0][1] * 100 + a[0][1][0] * 10 + a[0][1][1] + \\\\\n        a[1][1][1] * 1000 + a[1][1][0] * 100 + a[1][0][1] * 10 + a[1][0][0]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(three_d_array_accessor)\n    assert c.test_array(2, 7, 1, 8) == -5454\n\n\ndef test_four_d_array_accessor(get_contract_with_gas_estimation):\n    four_d_array_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[DynArray[int128, 2], 2], 2], 2] = \\\\\n        [[[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]\n    a[0][0][0][0] = x\n    a[0][0][0][1] = y\n    a[0][0][1][0] = z\n    a[0][0][1][1] = w\n    a[0][1][0][0] = -x\n    a[0][1][0][1] = -y\n    a[0][1][1][0] = -z\n    a[0][1][1][1] = -w\n\n    a[1][0][0][0] = x + 1\n    a[1][0][0][1] = y + 1\n    a[1][0][1][0] = z + 1\n    a[1][0][1][1] = w + 1\n    a[1][1][0][0] = - (x + 1)\n    a[1][1][0][1] = - (y + 1)\n    a[1][1][1][0] = - (z + 1)\n    a[1][1][1][1] = - (w + 1)\n    return a[0][0][0][0] * 1000 + a[0][0][0][1] * 100 + a[0][0][1][0] * 10 + a[0][0][1][1] + \\\\\n        a[0][1][1][1] * 1000 + a[0][1][1][0] * 100 + a[0][1][0][1] * 10 + a[0][1][0][0] + \\\\\n        a[1][0][0][0] * 1000 + a[1][0][0][1] * 100 + a[1][0][1][0] * 10 + a[1][0][1][1] + \\\\\n        a[1][1][1][1] * 1000 + a[1][1][1][0] * 100 + a[1][1][0][1] * 10 + a[1][1][0][0]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(four_d_array_accessor)\n    assert c.test_array(2, 7, 1, 8) == -10908\n\n\ndef test_array_negative_accessor(get_contract_with_gas_estimation, assert_compile_failed):\n    array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[int128, 4] = [0, 0, 0, 0]\n    a[0] = x\n    a[1] = y\n    a[2] = z\n    a[3] = w\n    return a[-4] * 1000 + a[-3] * 100 + a[-2] * 10 + a[-1]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(array_negative_accessor), ArrayIndexException\n    )\n\n    two_d_array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[int128, 2], 2] = [[0, 0], [0, 0]]\n    a[0][0] = x\n    a[0][1] = y\n    a[1][0] = z\n    a[1][1] = w\n    return a[-2][-2] * 1000 + a[-2][-1] * 100 + a[-1][-2] * 10 + a[-1][-1]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(two_d_array_negative_accessor), ArrayIndexException\n    )\n\n    three_d_array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[int128, 2], 2], 2] = [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    a[0][0][0] = x\n    a[0][0][1] = y\n    a[0][1][0] = z\n    a[0][1][1] = w\n    a[1][0][0] = -x\n    a[1][0][1] = -y\n    a[1][1][0] = -z\n    a[1][1][1] = -w\n    return a[-2][-2][-2] * 1000 + a[-2][-2][-1] * 100 + a[-2][-1][-2] * 10 + a[-2][-1][-1] + \\\\\n        a[-1][-1][-1] * 1000 + a[-1][-1][-2] * 100 + a[-1][-2][-1] * 10 + a[-1][-2][-2]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(three_d_array_negative_accessor),\n        ArrayIndexException,\n    )\n\n    four_d_array_negative_accessor = \"\"\"\n@external\ndef test_array(x: int128, y: int128, z: int128, w: int128) -> int128:\n    a: DynArray[DynArray[DynArray[DynArray[int128, 2], 2], 2], 2] = \\\\\n        [[[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]\n    a[0][0][0][0] = x\n    a[0][0][0][1] = y\n    a[0][0][1][0] = z\n    a[0][0][1][1] = w\n    a[0][1][0][0] = -x\n    a[0][1][0][1] = -y\n    a[0][1][1][0] = -z\n    a[0][1][1][1] = -w\n\n    a[1][0][0][0] = x + 1\n    a[1][0][0][1] = y + 1\n    a[1][0][1][0] = z + 1\n    a[1][0][1][1] = w + 1\n    a[1][1][0][0] = - (x + 1)\n    a[1][1][0][1] = - (y + 1)\n    a[1][1][1][0] = - (z + 1)\n    a[1][1][1][1] = - (w + 1)\n    return a[-2][-2][-2][-2] * 1000 + a[-2][-2][-2][-1] * 100 + \\\\\n        a[-2][-2][-1][-2] * 10 + a[-2][-2][-1][-1] + \\\\\n        a[-2][-1][-1][-1] * 1000 + a[-2][-1][-1][-2] * \\\\\n        100 + a[-2][-1][-2][-1] * 10 + a[-2][-1][-2][-2] + \\\\\n        a[-1][-2][-2][-2] * 1000 + a[-1][-2][-2][-1] * \\\\\n        100 + a[-1][-2][-1][-2] * 10 + a[-1][-2][-1][-1] + \\\\\n        a[-1][-1][-1][-1] * 1000 + a[-1][-1][-1][-2] * \\\\\n        100 + a[-1][-1][-2][-1] * 10 + a[-1][-1][-2][-2]\n    \"\"\"\n\n    assert_compile_failed(\n        lambda: get_contract_with_gas_estimation(four_d_array_negative_accessor),\n        ArrayIndexException,\n    )\n\n\n@pytest.mark.parametrize(\n    \"type,values,false_value\",\n    [\n        (\"uint256\", [3, 7], 4),\n        (\n            \"address\",\n            [\n                \"0x0000000000000000000000000000000000000012\",\n                \"0x0000000000000000000000000000000000000024\",\n            ],\n            \"0x0000000000000000000000000000000000000013\",\n        ),\n        (\"bool\", [True, True], False),\n        (\n            \"bytes32\",\n            [\n                \"0x0000000000000000000000000000000000000000000000000000000080ac58cd\",\n                \"0x0000000000000000000000000000000000000000000000000000000080ac58ce\",\n            ],\n            \"0x0000000000000000000000000000000000000000000000000000000080ac58cf\",\n        ),\n    ],\n)\ndef test_member_in_list(get_contract_with_gas_estimation, type, values, false_value):\n    code = f\"\"\"\n@external\ndef check(a: {type}) -> bool:\n    x: DynArray[{type}, 2] = [{values[0]}, {values[1]}]\n    return a in x\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check(values[0]) is True\n    assert c.check(values[1]) is True\n    assert c.check(false_value) is False\n\n\n@pytest.mark.parametrize(\"type_\", (\"uint256\", \"bytes32\", \"address\"))\ndef test_member_in_empty_list(get_contract_with_gas_estimation, type_):\n    code = f\"\"\"\n@external\ndef check_in(s: uint128) -> bool:\n    a: {type_} = convert(s, {type_})\n    x: DynArray[{type_}, 2] = []\n    return a in x\n\n@external\ndef check_not_in(s: uint128) -> bool:\n    a: {type_} = convert(s, {type_})\n    x: DynArray[{type_}, 2] = []\n    return a not in x\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    for s in (0, 1, 2, 3):\n        assert c.check_in(s) is False\n        assert c.check_not_in(s) is True\n\n\n@pytest.mark.parametrize(\n    \"type,values,false_values\",\n    [\n        (\"uint256\", [[3, 7], [9, 11]], [4, 10]),\n        (\"bool\", [[True, True], [False, False]], [False, True]),\n    ],\n)\ndef test_member_in_nested_list(get_contract_with_gas_estimation, type, values, false_values):\n    code = f\"\"\"\n@external\ndef check1(a: {type}) -> bool:\n    x: DynArray[DynArray[{type}, 2], 2] = {values}\n    return a in x[0]\n\n@external\ndef check2(a: {type}) -> bool:\n    x: DynArray[DynArray[{type}, 2], 2] = {values}\n    return a in x[1]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check1(values[0][0]) is True\n    assert c.check1(values[0][1]) is True\n    assert c.check1(false_values[0]) is False\n\n    assert c.check2(values[1][0]) is True\n    assert c.check2(values[1][1]) is True\n    assert c.check2(false_values[1]) is False\n\n\ndef test_member_in_nested_address_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef check1(a: address) -> bool:\n    x: DynArray[DynArray[address, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000012,\n            0x0000000000000000000000000000000000000024,\n        ],\n        [\n            0x0000000000000000000000000000000000000036,\n            0x0000000000000000000000000000000000000048,\n        ],\n    ]\n    return a in x[0]\n\n@external\ndef check2(a: address) -> bool:\n    x: DynArray[DynArray[address, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000012,\n            0x0000000000000000000000000000000000000024,\n        ],\n        [\n            0x0000000000000000000000000000000000000036,\n            0x0000000000000000000000000000000000000048,\n        ],\n    ]\n    return a in x[1]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check1(\"0x0000000000000000000000000000000000000012\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000024\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000036\") is False\n\n    assert c.check2(\"0x0000000000000000000000000000000000000036\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000048\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000024\") is False\n\n\ndef test_member_in_nested_bytes32_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef check1(a: bytes32) -> bool:\n    x: DynArray[DynArray[bytes32, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58ca,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cb,\n        ],\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58cc,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cd,\n        ],\n    ]\n    return a in x[0]\n\n@external\ndef check2(a: bytes32) -> bool:\n    x: DynArray[DynArray[bytes32, 2], 2] = [\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58ca,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cb,\n        ],\n        [\n            0x0000000000000000000000000000000000000000000000000000000080ac58cc,\n            0x0000000000000000000000000000000000000000000000000000000080ac58cd,\n        ],\n    ]\n    return a in x[1]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.check1(\"0x0000000000000000000000000000000000000000000000000000000080ac58ca\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000000000000000000000080ac58cb\") is True\n    assert c.check1(\"0x0000000000000000000000000000000000000000000000000000000080ac58cc\") is False\n\n    assert c.check2(\"0x0000000000000000000000000000000000000000000000000000000080ac58cc\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000000000000000000000080ac58cd\") is True\n    assert c.check2(\"0x0000000000000000000000000000000000000000000000000000000080ac58ca\") is False\n\n\ndef test_member_in_updated_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef foo() -> bool:\n    xs: DynArray[uint256, 3] = [2, 2, 2]\n    xs = [1, 1]\n    y: uint256 = 2\n    return y in xs\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.foo() is False\n\n\ndef test_member_in_updated_nested_list(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef foo() -> bool:\n    xs: DynArray[DynArray[DynArray[uint256, 3], 3], 3] = [\n        [[2, 2, 2], [2, 2, 2], [2, 2, 2]],\n        [[2, 2, 2], [2, 2, 2], [2, 2, 2]],\n        [[2, 2, 2], [2, 2, 2], [2, 2, 2]],\n    ]\n    xs = [\n        [[1, 1], [1, 1], [1, 1]],\n        [[1, 1], [1, 1], [1, 1]],\n        [[1, 1], [1, 1], [1, 1]],\n    ]\n    y: uint256 = 2\n    return y in xs[0][0] or y in xs[0][1] or y in xs[0][2] or \\\\\n        y in xs[1][0] or y in xs[1][1] or y in xs[1][2] or \\\\\n        y in xs[2][0] or y in xs[2][1] or y in xs[2][2]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.foo() is False\n\n\ndef test_member_in_list_lhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\n_counter: uint256\n\n@internal\ndef counter() -> uint256:\n    self._counter = 1\n    return self._counter\n\n@external\ndef bar() -> bool:\n    x: DynArray[uint256, 4] = [2, 2, 2, 2]\n    return self.counter() in x\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() is False\n\n\ndef test_member_in_nested_list_lhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\n_counter: uint256\n\n@internal\ndef counter() -> uint256:\n    self._counter = 1\n    return self._counter\n\n@external\ndef bar() -> bool:\n    x: DynArray[DynArray[DynArray[uint256, 4], 4], 4] = [\n        [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]],\n        [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]],\n        [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]],\n    ]\n    return self.counter() in x[0][0]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() is False\n\n\ndef test_member_in_list_rhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\ncounter: uint256\n\n@internal\ndef foo() -> DynArray[uint256, 3]:\n    self.counter += 1\n    return [0,0,0]\n\n@external\ndef bar() -> uint256:\n    self.counter = 0\n    t: bool = self.counter in self.foo()\n    return self.counter\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 1\n\n\ndef test_member_in_nested_list_rhs_side_effects(get_contract_with_gas_estimation):\n    code = \"\"\"\ncounter: uint256\n\n@internal\ndef foo() -> DynArray[DynArray[DynArray[uint256, 3], 3], 3]:\n    self.counter += 1\n    return [\n        [[0,0,0], [0,0,0], [0,0,0]],\n        [[0,0,0], [0,0,0], [0,0,0]],\n        [[0,0,0], [0,0,0], [0,0,0]]\n    ]\n\n@external\ndef bar() -> uint256:\n    self.counter = 0\n    t: bool = self.counter in self.foo()[0][0]\n    return self.counter\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bar() == 1\n\n\ndef test_returns_lists(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef test_array_num_return() -> DynArray[DynArray[int128, 2], 2]:\n    a: DynArray[DynArray[int128, 2], 2] = [empty(DynArray[int128, 2]), [3, 4]]\n    return a\n\n@external\ndef test_array_decimal_return1() -> DynArray[DynArray[decimal, 2], 2]:\n    a: DynArray[DynArray[decimal, 2], 2] = [[1.0], [3.0, 4.0]]\n    return a\n\n@external\ndef test_array_decimal_return2() -> DynArray[DynArray[decimal, 2], 2]:\n    return [[1.0, 2.0]]\n\n@external\ndef test_array_decimal_return3() -> DynArray[DynArray[decimal, 2], 2]:\n    a: DynArray[DynArray[decimal, 2], 2] = [[1.0, 2.0], [3.0]]\n    return a\n\"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.test_array_num_return() == [[], [3, 4]]\n    assert c.test_array_decimal_return1() == [[1.0], [3.0, 4.0]]\n    assert c.test_array_decimal_return2() == [[1.0, 2.0]]\n    assert c.test_array_decimal_return3() == [[1.0, 2.0], [3.0]]\n\n\ndef test_mult_list(get_contract_with_gas_estimation):\n    code = \"\"\"\nnest3: DynArray[DynArray[DynArray[uint256, 2], 2], 2]\nnest4: DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2]\n\n@external\ndef test_multi3_1() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[uint256, 2], 2], 2] = [[[0, 0], [0, 4]], [[0, 7], [0, 123]]]\n    self.nest3 = l\n    return self.nest3\n\n@external\ndef test_multi3_2() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[uint256, 2], 2], 2] = [[[0, 0], [0, 4]], [[0, 7], [0, 123]]]\n    self.nest3 = l\n    l = self.nest3\n    return l\n\n@external\ndef test_multi4_1() -> DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2] = [[[[1, 0], [0, 4]], [[0, 0], [0, 0]]], [[[444, 0], [0, 0]],[[1, 0], [0, 222]]]]  # noqa: E501\n    self.nest4 = l\n    l = self.nest4\n    return l\n\n@external\ndef test_multi4_2() -> DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2]:\n    l: DynArray[DynArray[DynArray[DynArray[uint256, 2], 2], 2], 2] = [[[[1, 0], [0, 4]], [[0, 0], [0, 0]]], [[[444, 0], [0, 0]],[[1, 0], [0, 222]]]]  # noqa: E501\n    self.nest4 = l\n    return self.nest4\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    nest3 = [[[0, 0], [0, 4]], [[0, 7], [0, 123]]]\n    assert c.test_multi3_1() == nest3\n    assert c.test_multi3_2() == nest3\n    nest4 = [[[[1, 0], [0, 4]], [[0, 0], [0, 0]]], [[[444, 0], [0, 0]], [[1, 0], [0, 222]]]]\n    assert c.test_multi4_1() == nest4\n    assert c.test_multi4_2() == nest4\n\n\ndef test_uint256_accessor(get_contract_with_gas_estimation, assert_tx_failed):\n    code = \"\"\"\n@external\ndef bounds_check_uint256(xs: DynArray[uint256, 3], ix: uint256) -> uint256:\n    return xs[ix]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert_tx_failed(lambda: c.bounds_check_uint256([], 0))\n\n    assert c.bounds_check_uint256([1], 0) == 1\n    assert_tx_failed(lambda: c.bounds_check_uint256([1], 1))\n\n    assert c.bounds_check_uint256([1, 2, 3], 0) == 1\n    assert c.bounds_check_uint256([1, 2, 3], 2) == 3\n    assert_tx_failed(lambda: c.bounds_check_uint256([1, 2, 3], 3))\n\n    # TODO do bounds checks for nested darrays\n\n\n@pytest.mark.parametrize(\"list_\", ([], [11], [11, 12], [11, 12, 13]))\ndef test_dynarray_len(get_contract_with_gas_estimation, assert_tx_failed, list_):\n    code = \"\"\"\n@external\ndef darray_len(xs: DynArray[uint256, 3]) -> uint256:\n    return len(xs)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.darray_len(list_) == len(list_)\n\n\ndef test_dynarray_too_large(get_contract_with_gas_estimation, assert_tx_failed):\n    code = \"\"\"\n@external\ndef darray_len(xs: DynArray[uint256, 3]) -> uint256:\n    return len(xs)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert_tx_failed(lambda: c.darray_len([1, 2, 3, 4]))\n\n\ndef test_int128_accessor(get_contract_with_gas_estimation, assert_tx_failed):\n    code = \"\"\"\n@external\ndef bounds_check_int128(ix: int128) -> uint256:\n    xs: DynArray[uint256, 3] = [1,2,3]\n    return xs[ix]\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    assert c.bounds_check_int128(0) == 1\n    assert c.bounds_check_int128(2) == 3\n    assert_tx_failed(lambda: c.bounds_check_int128(3))\n    assert_tx_failed(lambda: c.bounds_check_int128(-1))\n\n\ndef test_index_exception(get_contract_with_gas_estimation, assert_compile_failed):\n    code = \"\"\"\n@external\ndef fail() -> uint256:\n    xs: DynArray[uint256, 3] = [1,2,3]\n    return xs[3]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), ArrayIndexException)\n\n    code = \"\"\"\n@external\ndef fail() -> uint256:\n    xs: DynArray[uint256, 3] = [1,2,3]\n    return xs[-1]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), ArrayIndexException)\n\n\ndef test_compile_time_bounds_check(get_contract_with_gas_estimation, assert_compile_failed):\n    code = \"\"\"\n@external\ndef parse_list_fail():\n    xs: DynArray[uint256, 3] = [2**256, 1, 3]\n    pass\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), OverflowException)\n\n\ndef test_2d_array_input_1(get_contract):\n    code = \"\"\"\n@internal\ndef test_input(\n    arr: DynArray[DynArray[int128, 2], 1], i: int128\n) -> (DynArray[DynArray[int128, 2], 1], int128):\n    return arr, i\n\n@external\ndef test_values(\n    arr: DynArray[DynArray[int128, 2], 1], i: int128\n) -> (DynArray[DynArray[int128, 2], 1], int128):\n    return self.test_input(arr, i)\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.test_values([[1, 2]], 3) == [[[1, 2]], 3]\n\n\ndef test_2d_array_input_2(get_contract):\n    code = \"\"\"\n@internal\ndef test_input(\n    arr: DynArray[DynArray[int128, 2], 3],\n    s: String[10]\n) -> (DynArray[DynArray[int128, 2], 3], String[10]):\n    return arr, s\n\n@external\ndef test_values(\n    arr: DynArray[DynArray[int128, 2], 3],\n    s: String[10]\n) -> (DynArray[DynArray[int128, 2], 3], String[10]):\n    return self.test_input(arr, s)\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.test_values([[1, 2], [3, 4], [5, 6]], \"abcdef\") == [[[1, 2], [3, 4], [5, 6]], \"abcdef\"]\n\n\ndef test_nested_index_of_returned_array(get_contract):\n    code = \"\"\"\n@internal\ndef inner() -> (int128, int128):\n    return 1,2\n\n@external\ndef outer() -> DynArray[int128, 2]:\n    return [333, self.inner()[0]]\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.outer() == [333, 1]\n\n\ndef test_nested_calls_inside_arrays(get_contract):\n    code = \"\"\"\n@internal\ndef _foo(a: uint256, b: DynArray[uint256, 2]) -> (uint256, uint256, uint256, uint256, uint256):\n    return 1, a, b[0], b[1], 5\n\n@internal\ndef _foo2() -> uint256:\n    a: DynArray[uint256, 10] = [6,7,8,9,10,11,12,13,15,16]\n    return 4\n\n@external\ndef foo() -> (uint256, uint256, uint256, uint256, uint256):\n    return self._foo(2, [3, self._foo2()])\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.foo() == [1, 2, 3, 4, 5]\n\n\ndef test_nested_calls_inside_arrays_with_index_access(get_contract):\n    code = \"\"\"\n@internal\ndef _foo(\n    a: DynArray[uint256, 2],\n    b: DynArray[uint256, 2]\n) -> (uint256, uint256, uint256, uint256, uint256):\n    return a[1]-b[0], 2, a[0]-b[1], 8-b[1], 5\n\n@internal\ndef _foo2() -> (uint256, uint256):\n    a: DynArray[uint256, 10] = [6,7,8,9,10,11,12,13,15,16]\n    return a[6], 4\n\n@external\ndef foo() -> (uint256, uint256, uint256, uint256, uint256):\n    return self._foo([7, self._foo2()[0]], [11, self._foo2()[1]])\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.foo() == [1, 2, 3, 4, 5]\n\n\nappend_pop_tests = [\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array\n    \"\"\",\n        lambda xs: xs,\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\nsome_var: uint256\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.some_var = x\n        # test that typechecker for append args works\n        self.my_array.append(self.some_var)\n    return self.my_array\n    \"\"\",\n        lambda xs: xs,\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.my_array.append(x)\n    for x in xs:\n        self.my_array.pop()\n    return self.my_array\n    \"\"\",\n        lambda xs: [],\n    ),\n    # check order of evaluation.\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> (DynArray[uint256, 5], uint256):\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array, self.my_array.pop()\n    \"\"\",\n        lambda xs: None if len(xs) == 0 else [xs, xs[-1]],\n    ),\n    # check order of evaluation.\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> (uint256, DynArray[uint256, 5]):\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array.pop(), self.my_array\n    \"\"\",\n        lambda xs: None if len(xs) == 0 else [xs[-1], xs[:-1]],\n    ),\n    # test memory arrays\n    (\n        \"\"\"\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    ys: DynArray[uint256, 5] = []\n    i: uint256 = 0\n    for x in xs:\n        if i >= len(xs) - 1:\n            break\n        ys.append(x)\n        i += 1\n\n    return ys\n    \"\"\",\n        lambda xs: xs[:-1],\n    ),\n    # check overflow\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 6]) -> DynArray[uint256, 5]:\n    for x in xs:\n        self.my_array.append(x)\n    return self.my_array\n    \"\"\",\n        lambda xs: None if len(xs) > 5 else xs,\n    ),\n    # pop to 0 elems\n    (\n        \"\"\"\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    ys: DynArray[uint256, 5] = []\n    for x in xs:\n        ys.append(x)\n    for x in xs:\n        ys.pop()\n    return ys\n    \"\"\",\n        lambda xs: [],\n    ),\n    # check underflow\n    (\n        \"\"\"\n@external\ndef foo(xs: DynArray[uint256, 5]) -> DynArray[uint256, 5]:\n    ys: DynArray[uint256, 5] = []\n    for x in xs:\n        ys.append(x)\n    for x in xs:\n        ys.pop()\n    ys.pop()  # fail\n    return ys\n    \"\"\",\n        lambda xs: None,\n    ),\n    # check underflow\n    (\n        \"\"\"\nmy_array: DynArray[uint256, 5]\n@external\ndef foo(xs: DynArray[uint256, 5]) -> uint256:\n    return self.my_array.pop()\n    \"\"\",\n        lambda xs: None,\n    ),\n]\n\n\n@pytest.mark.parametrize(\"subtyp\", [\"uint8\", \"int128\", \"uint256\"])\ndef test_append_literal(get_contract, subtyp):\n    data = [1, 2, 3]\n    if subtyp == \"int128\":\n        data = [-1, 2, 3]\n    code = f\"\"\"\n@external\ndef foo() -> DynArray[{subtyp}, 3]:\n    x: DynArray[{subtyp}, 3] = []\n    x.append({data[0]})\n    x.append({data[1]})\n    x.append({data[2]})\n    return x\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == data\n\n\n@pytest.mark.parametrize(\"subtyp,lit\", [(\"uint8\", 256), (\"uint256\", -1), (\"int128\", 2**127)])\ndef test_append_invalid_literal(get_contract, assert_compile_failed, subtyp, lit):\n    code = f\"\"\"\n@external\ndef foo() -> DynArray[{subtyp}, 3]:\n    x: DynArray[{subtyp}, 3] = []\n    x.append({lit})\n    return x\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), InvalidType)\n\n\ninvalid_appends_pops = [\n    (\n        \"\"\"\n@external\ndef foo() -> DynArray[uint256, 3]:\n    x: DynArray[uint256, 3] = []\n    x.append()\n    \"\"\",\n        ArgumentException,\n    ),\n    (\n        \"\"\"\n@external\ndef foo() -> DynArray[uint256, 3]:\n    x: DynArray[uint256, 3] = []\n    x.append(1,2)\n    \"\"\",\n        ArgumentException,\n    ),\n    (\n        \"\"\"\n@external\ndef foo() -> DynArray[uint256, 3]:\n    x: DynArray[uint256, 3] = []\n    x.pop(1)\n    \"\"\",\n        ArgumentException,\n    ),\n    (\n        \"\"\"\n@external\ndef foo(x: DynArray[uint256, 3]) -> DynArray[uint256, 3]:\n    x.append(1)\n    return x\n    \"\"\",\n        ImmutableViolation,\n    ),\n    (\n        \"\"\"\nfoo: DynArray[uint256, 3]\n@external\n@view\ndef bar() -> DynArray[uint256, 3]:\n    self.foo.append(1)\n    return self.foo\n    \"\"\",\n        StateAccessViolation,\n    ),\n]\n\n\n@pytest.mark.parametrize(\"code,exception_type\", invalid_appends_pops)\ndef test_invalid_append_pop(get_contract, assert_compile_failed, code, exception_type):\n    assert_compile_failed(lambda: get_contract(code), exception_type)\n\n\n@pytest.mark.parametrize(\"code,check_result\", append_pop_tests)\n# TODO change this to fuzz random data\n@pytest.mark.parametrize(\"test_data\", [[1, 2, 3, 4, 5][:i] for i in range(6)])\ndef test_append_pop(get_contract, assert_tx_failed, code, check_result, test_data):\n    c = get_contract(code)\n    expected_result = check_result(test_data)\n    if expected_result is None:\n        # None is sentinel to indicate txn should revert\n        assert_tx_failed(lambda: c.foo(test_data))\n    else:\n        assert c.foo(test_data) == expected_result\n\n\nappend_pop_complex_tests = [\n    (\n        \"\"\"\n@external\ndef foo(x: {typ}) -> DynArray[{typ}, 2]:\n    ys: DynArray[{typ}, 1] = []\n    ys.append(x)\n    return ys\n    \"\"\",\n        lambda x: [x],\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 1]\n@external\ndef foo(x: {typ}) -> DynArray[{typ}, 2]:\n    self.my_array.append(x)\n    self.my_array.append(x)  # fail\n    return self.my_array\n    \"\"\",\n        lambda x: None,\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 5]\n@external\ndef foo(x: {typ}) -> (DynArray[{typ}, 5], {typ}):\n    self.my_array.append(x)\n    return self.my_array, self.my_array.pop()\n    \"\"\",\n        lambda x: [[x], x],\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 5]\n@external\ndef foo(x: {typ}) -> ({typ}, DynArray[{typ}, 5]):\n    self.my_array.append(x)\n    return self.my_array.pop(), self.my_array\n    \"\"\",\n        lambda x: [x, []],\n    ),\n    (\n        \"\"\"\nmy_array: DynArray[{typ}, 5]\n@external\ndef foo(x: {typ}) -> {typ}:\n    return self.my_array.pop()\n    \"\"\",\n        lambda x: None,\n    ),\n]\n\n\n@pytest.mark.parametrize(\"code_template,check_result\", append_pop_complex_tests)\n@pytest.mark.parametrize(\n    \"subtype\",\n    [\"uint256[3]\", \"DynArray[uint256,3]\", \"DynArray[uint8, 4]\", \"Foo\", \"DynArray[Foobar, 3]\"],\n)\n# TODO change this to fuzz random data\ndef test_append_pop_complex(get_contract, assert_tx_failed, code_template, check_result, subtype):\n    code = code_template.format(typ=subtype)\n    test_data = [1, 2, 3]\n    if subtype == \"Foo\":\n        test_data = tuple(test_data)\n        struct_def = \"\"\"\nstruct Foo:\n    x: uint256\n    y: uint256\n    z: uint256\n        \"\"\"\n        code = struct_def + \"\\n\" + code\n    elif subtype == \"DynArray[Foobar, 3]\":\n        enum_def = \"\"\"\nenum Foobar:\n    FOO\n    BAR\n    BAZ\n        \"\"\"\n        code = enum_def + \"\\n\" + code\n        test_data = [2 ** (i - 1) for i in test_data]\n\n    c = get_contract(code)\n    expected_result = check_result(test_data)\n    if expected_result is None:\n        # None is sentinel to indicate txn should revert\n        assert_tx_failed(lambda: c.foo(test_data))\n    else:\n        assert c.foo(test_data) == expected_result\n\n\ndef test_so_many_things_you_should_never_do(get_contract):\n    code = \"\"\"\n@internal\ndef _foo(a: DynArray[uint256, 2], b: DynArray[uint256, 2]) -> DynArray[uint256, 5]:\n    return [a[1]-b[0], 2, a[0]-b[1], 8-b[1], 5]\n\n@internal\ndef _foo2() -> (uint256, uint256):\n    b: DynArray[uint256, 2] = [5, 8]\n    a: DynArray[uint256, 10] = [6,7,8,9,10,11,12,13,self._foo([44,b[0]],b)[4],16]\n    return a[6], 4\n\n@external\ndef foo() -> (uint256, DynArray[uint256, 3], DynArray[uint256, 2]):\n    x: DynArray[uint256, 3] = [\n        1,\n        14-self._foo2()[0],\n        self._foo([7,self._foo2()[0]], [11,self._foo2()[1]])[2]\n    ]\n    return 666, x, [88, self._foo2()[0]]\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == [666, [1, 2, 3], [88, 12]]\n\n\ndef test_list_of_structs_arg(get_contract):\n    code = \"\"\"\nenum Foobar:\n    FOO\n    BAR\n\nstruct Foo:\n    x: uint256\n    y: uint256\n    z: Foobar\n\n@external\ndef bar(_baz: DynArray[Foo, 3]) -> uint256:\n    sum: uint256 = 0\n    for i in range(3):\n        e: Foobar = _baz[i].z\n        f: uint256 = convert(e, uint256)\n        sum += _baz[i].x * _baz[i].y + f\n    return sum\n    \"\"\"\n    c = get_contract(code)\n    c_input = [[x, y, 1] for x, y in zip(range(3), range(3))]\n    assert c.bar(c_input) == 8  # (0 * 0 + 1) + (1 * 1 + 1) + (2 * 2 + 1)\n\n\ndef test_list_of_structs_arg_with_dynamic_type(get_contract):\n    code = \"\"\"\nstruct Foo:\n    x: uint256\n    _msg: String[32]\n\n@external\ndef bar(_baz: DynArray[Foo, 3]) -> String[96]:\n    return concat(_baz[0]._msg, _baz[1]._msg, _baz[2]._msg)\n    \"\"\"\n    c = get_contract(code)\n    c_input = [[i, msg] for i, msg in enumerate((\"Hello \", \"world\", \"!!!!\"))]\n    assert c.bar(c_input) == \"Hello world!!!!\"\n\n\ndef test_list_of_structs_lists_with_nested_lists(get_contract, assert_tx_failed):\n    code = \"\"\"\nstruct Bar:\n    a: DynArray[uint8[2], 2]\n\n@external\ndef foo(x: uint8) -> uint8:\n    b: DynArray[Bar[2], 2] = [\n        [\n            Bar({a: [[x, x + 1], [x + 2, x + 3]]}),\n            Bar({a: [[x + 4, x +5], [x + 6, x + 7]]})\n        ],\n        [\n            Bar({a: [[x + 8, x + 9], [x + 10, x + 11]]}),\n            Bar({a: [[x + 12, x + 13], [x + 14, x + 15]]})\n        ],\n    ]\n    return b[0][0].a[0][0] + b[0][1].a[1][1] + b[1][0].a[0][1] + b[1][1].a[1][0]\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo(17) == 98\n    assert_tx_failed(lambda: c.foo(241))\n\n\ndef test_list_of_nested_struct_arrays(get_contract):\n    code = \"\"\"\nstruct Ded:\n    a: uint256[3]\n    b: bool\n\nstruct Foo:\n    c: uint256\n    d: uint256\n    e: Ded\n\nstruct Bar:\n    f: DynArray[Foo, 3]\n    g: DynArray[uint256, 3]\n\n@external\ndef bar(_bar: DynArray[Bar, 3]) -> uint256:\n    sum: uint256 = 0\n    for i in range(3):\n        sum += _bar[i].f[0].e.a[0] * _bar[i].f[1].e.a[1]\n    return sum\n    \"\"\"\n    c = get_contract(code)\n    c_input = [\n        ((tuple([(123, 456, ([i, i + 1, i + 2], False))] * 3)), [9, 8, 7]) for i in range(1, 4)\n    ]\n\n    assert c.bar(c_input) == 20\n\n\ndef test_2d_list_of_struct(get_contract):\n    code = \"\"\"\nstruct Bar:\n    a: uint256\n    b: uint256\n\n@external\ndef foo(x: DynArray[DynArray[Bar, 2], 2]) -> uint256:\n    return x[0][0].a + x[1][1].b\n    \"\"\"\n    c = get_contract(code)\n    c_input = [([i, i * 2], [i * 3, i * 4]) for i in range(1, 3)]\n    assert c.foo(c_input) == 9\n\n\ndef test_3d_list_of_struct(get_contract):\n    code = \"\"\"\nstruct Bar:\n    a: uint256\n    b: uint256\n\n@external\ndef foo(x: DynArray[DynArray[DynArray[Bar, 2], 2], 2]) -> uint256:\n    return x[0][0][0].a + x[1][1][1].b\n    \"\"\"\n    c = get_contract(code)\n    c_input = [([([i, i * 2], [i * 3, i * 4]) for i in range(1, 3)])] * 2\n    assert c.foo(c_input) == 9\n\n\ndef test_list_of_static_list(get_contract):\n    code = \"\"\"\n@external\ndef bar(x: int128) -> DynArray[int128[2], 2]:\n    a: DynArray[int128[2], 2] = [[x, x * 2], [x * 3, x * 4]]\n    return a\n\n@external\ndef foo(x: int128) -> int128:\n    a: DynArray[int128[2], 2] = [[x, x * 2], [x * 3, x * 4]]\n    return a[0][0] * a[1][1]\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [[7, 14], [21, 28]]\n    assert c.foo(7) == 196\n\n\ndef test_list_of_static_nested_list(get_contract):\n    code = \"\"\"\n@external\ndef bar(x: int128) -> DynArray[int128[2][2], 2]:\n    a: DynArray[int128[2][2], 2] = [\n        [[x, x * 2], [x * 3, x * 4]],\n        [[x * 5, x * 6], [x * 7, x * 8]],\n    ]\n    return a\n\n@external\ndef foo(x: int128) -> int128:\n    a: DynArray[int128[2][2], 2] = [\n        [[x, x * 2], [x * 3, x * 4]],\n        [[x * 5, x * 6], [x * 7, x * 8]],\n    ]\n    return a[0][0][0] * a[1][1][1]\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [[[7, 14], [21, 28]], [[35, 42], [49, 56]]]\n    assert c.foo(7) == 392\n\n\ndef test_struct_of_lists(get_contract):\n    code = \"\"\"\nstruct Foo:\n    a1: DynArray[uint256, 2]\n    a2: DynArray[DynArray[uint256, 2], 2]\n    a3: DynArray[DynArray[DynArray[uint256, 2], 2], 2]\n\n@internal\ndef _foo() -> DynArray[uint256, 2]:\n    return [3, 7]\n\n@internal\ndef _foo2() -> DynArray[DynArray[uint256, 2], 2]:\n    y: DynArray[uint256, 2] = self._foo()\n    z: DynArray[uint256, 2] = [y[1], y[0]]\n    return [y, z]\n\n@internal\ndef _foo3() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    y: DynArray[DynArray[uint256, 2], 2] = self._foo2()\n    z: DynArray[DynArray[uint256, 2], 2] = [y[1], y[0]]\n    return [y, z]\n\n@external\ndef bar() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    foo: Foo = Foo({\n        a1: self._foo(),\n        a2: self._foo2(),\n        a3: self._foo3(),\n    })\n    return foo.a3\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar() == [[[3, 7], [7, 3]], [[7, 3], [3, 7]]]\n\n\ndef test_struct_of_lists_2(get_contract):\n    code = \"\"\"\nstruct Foo:\n    b: Bytes[32]\n    da: DynArray[int128, 5]\n    sa: int128[5]\n    some_int: int128\n\n@internal\ndef _foo(x: int128) -> Foo:\n    f: Foo = Foo({\n        b: b\"hello\",\n        da: [x, x * 2],\n        sa: [x + 1, x + 2, x + 3, x + 4, x + 5],\n        some_int: x - 1\n    })\n    return f\n\n@external\ndef bar(x: int128) -> DynArray[int128, 5]:\n    f: Foo = self._foo(x)\n    return f.da\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [7, 14]\n\n\ndef test_struct_of_lists_3(get_contract):\n    code = \"\"\"\nstruct Foo:\n    a: DynArray[int128, 3]\n    b: DynArray[address, 3]\n    c: DynArray[bool, 3]\n\n@internal\ndef _foo(x: int128) -> Foo:\n    f: Foo = Foo({\n        a: [x, x * 2],\n        b: [0x0000000000000000000000000000000000000012],\n        c: [False, True, False]\n\n    })\n    return f\n\n@external\ndef bar(x: int128) -> DynArray[int128, 3]:\n    f: Foo = self._foo(x)\n    return f.a\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar(7) == [7, 14]\n\n\ndef test_nested_struct_of_lists(get_contract, assert_compile_failed, no_optimize):\n    code = \"\"\"\nstruct nestedFoo:\n    a1: DynArray[DynArray[DynArray[uint256, 2], 2], 2]\n\nstruct Foo:\n    b1: DynArray[DynArray[DynArray[nestedFoo, 2], 2], 2]\n\n@internal\ndef _foo() -> nestedFoo:\n    return nestedFoo({a1: [\n        [[3, 7], [7, 3]],\n        [[7, 3], [3, 7]],\n    ]})\n\n@internal\ndef _foo2() -> Foo:\n    _nF1: nestedFoo = self._foo()\n    return Foo({b1: [[[_nF1, _nF1], [_nF1, _nF1]], [[_nF1, _nF1], [_nF1, _nF1]]]})\n\n@internal\ndef _foo3(f: Foo) -> Foo:\n    new_f: Foo = f\n    new_f.b1[0][1][0].a1[0][0] = [0, 0]\n    new_f.b1[1][0][0].a1[0][1] = [0, 0]\n    new_f.b1[1][1][0].a1[1][1] = [0, 0]\n    return new_f\n\n@external\ndef bar() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    foo: Foo = self._foo2()\n    return self._foo3(foo).b1[1][1][0].a1\n\n@external\ndef bar2() -> uint256:\n    foo: Foo = self._foo2()\n    newFoo: Foo = self._foo3(foo)\n    return newFoo.b1[1][1][0].a1[1][1][0] + \\\\\n        newFoo.b1[1][0][0].a1[0][1][1] + \\\\\n        newFoo.b1[0][1][0].a1[0][0][0]\n    \"\"\"\n\n    if no_optimize:\n        # fails at assembly stage with too many stack variables\n        assert_compile_failed(lambda: get_contract(code), Exception)\n    else:\n        c = get_contract(code)\n        assert c.bar() == [[[3, 7], [7, 3]], [[7, 3], [0, 0]]]\n        assert c.bar2() == 0\n\n\ndef test_tuple_of_lists(get_contract):\n    code = \"\"\"\n@internal\ndef _foo() -> DynArray[uint256, 2]:\n    return [3, 7]\n\n@internal\ndef _foo2() -> DynArray[DynArray[uint256, 2], 2]:\n    y: DynArray[uint256, 2] = self._foo()\n    z: DynArray[uint256, 2] = [y[1], y[0]]\n    return [y, z]\n\n@internal\ndef _foo3() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:\n    y: DynArray[DynArray[uint256, 2], 2] = self._foo2()\n    z: DynArray[DynArray[uint256, 2], 2] = [y[1], y[0]]\n    return [y, z]\n\n@internal\ndef _foo4() -> (DynArray[DynArray[uint256, 2], 2], DynArray[DynArray[DynArray[uint256, 2], 2], 2]):\n    return (self._foo2(), self._foo3())\n\n@external\ndef bar() -> uint256:\n    a: DynArray[DynArray[uint256, 2], 2] = [[0, 0], [0, 0]]\n    b: DynArray[DynArray[DynArray[uint256, 2], 2], 2] = [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    a, b = self._foo4()\n    return a[0][0] * b[1][0][1] + a[1][0] * b[0][1][0]\n    \"\"\"\n    c = get_contract(code)\n    assert c.bar() == 58\n\n\ndef test_constant_list(get_contract, assert_tx_failed):\n    some_good_primes = [5.0, 11.0, 17.0, 29.0, 37.0, 41.0]\n    code = f\"\"\"\nMY_LIST: constant(DynArray[decimal, 6]) = {some_good_primes}\n@external\ndef ix(i: uint256) -> decimal:\n    return MY_LIST[i]\n    \"\"\"\n    c = get_contract(code)\n    for i, p in enumerate(some_good_primes):\n        assert c.ix(i) == p\n    # assert oob\n    assert_tx_failed(lambda: c.ix(len(some_good_primes) + 1))\n\n\ndef test_public_dynarray(get_contract):\n    code = \"\"\"\nmy_list: public(DynArray[uint256, 5])\n@external\ndef __init__():\n    self.my_list = [1,2,3]\n    \"\"\"\n    c = get_contract(code)\n\n    for i, t in enumerate([1, 2, 3]):\n        assert c.my_list(i) == t\n\n\ndef test_nested_public_dynarray(get_contract):\n    code = \"\"\"\nmy_list: public(DynArray[DynArray[uint256, 5], 5])\n@external\ndef __init__():\n    self.my_list = [[1,2,3]]\n    \"\"\"\n    c = get_contract(code)\n\n    for i, l in enumerate([[1, 2, 3]]):\n        for j, t in enumerate(l):\n            assert c.my_list(i, j) == t\n\n\n@pytest.mark.parametrize(\n    \"typ,val\",\n    [\n        (\"DynArray[DynArray[uint256, 5], 5]\", [[], []]),\n        (\"DynArray[DynArray[DynArray[uint256, 5], 5], 5]\", [[[], []], []]),\n    ],\n)\ndef test_empty_nested_dynarray(get_contract, typ, val):\n    code = f\"\"\"\n@external\ndef foo() -> {typ}:\n    a: {typ} = {val}\n    return a\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo() == val\n\n\n# TODO test negative public(DynArray) cases?\n\n\n# CMC 2022-08-04 these are blocked due to typechecker bug; leaving as\n# negative tests so we know if/when the typechecker is fixed.\n# (don't consider it a high priority to fix since membership in\n# in empty list literal seems like something we should plausibly\n# reject at compile-time anyway)\ndef test_empty_list_membership_fail(get_contract, assert_compile_failed):\n    code = \"\"\"\n@external\ndef foo(x: uint256) -> bool:\n    return x in []\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code))\n    code = \"\"\"\n@external\ndef foo(x: uint256) -> bool:\n    return x not in []\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code))\n\n\n# Would be nice to put this somewhere accessible, like in vyper.types or something\ninteger_types = [\"uint8\", \"int128\", \"int256\", \"uint256\"]\n\n\n@pytest.mark.parametrize(\"storage_type,return_type\", itertools.permutations(integer_types, 2))\ndef test_constant_list_fail(get_contract, assert_compile_failed, storage_type, return_type):\n    code = f\"\"\"\nMY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]\n\n@external\ndef foo() -> DynArray[{return_type}, 3]:\n    return MY_CONSTANT\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), InvalidType)\n\n\n@pytest.mark.parametrize(\"storage_type,return_type\", itertools.permutations(integer_types, 2))\ndef test_constant_list_fail_2(get_contract, assert_compile_failed, storage_type, return_type):\n    code = f\"\"\"\nMY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]\n\n@external\ndef foo() -> {return_type}:\n    return MY_CONSTANT[0]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), InvalidType)\n\n\n@pytest.mark.parametrize(\"storage_type,return_type\", itertools.permutations(integer_types, 2))\ndef test_constant_list_fail_3(get_contract, assert_compile_failed, storage_type, return_type):\n    code = f\"\"\"\nMY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]\n\n@external\ndef foo(i: uint256) -> {return_type}:\n    return MY_CONSTANT[i]\n    \"\"\"\n    assert_compile_failed(lambda: get_contract(code), TypeMismatch)\n\n\ndynarray_length_no_clobber_cases = [\n    # GHSA-3p37-3636-q8wv cases\n    \"\"\"\na: DynArray[uint256,3]\n\n@external\ndef should_revert() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0], self.a[1], self.a[2]]\n\n    return self.a  # if bug: returns [1,2,3]\n    \"\"\",\n    \"\"\"\n@external\ndef should_revert() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # if bug: returns [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0\n    b: uint256 = 1\n    c: uint256 = 2\n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n    \"\"\",\n    \"\"\"\na: DynArray[uint256,4]\n\n@external\ndef should_revert() -> DynArray[uint256,4]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,4])\n    self.a = [4, self.a[0]]\n\n    return self.a  # if bug: return [4, 4]\n    \"\"\",\n    \"\"\"\n@external\ndef should_revert() -> DynArray[uint256,4]:\n    a: DynArray[uint256, 4] = [1,2,3]\n    a = []\n\n    a = [a.pop()]  # if bug: return [1]\n\n    return a\n    \"\"\",\n    \"\"\"\n@external\ndef should_revert():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n    \"\"\",\n    \"\"\"\n@external\ndef should_revert():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n    \"\"\",\n    \"\"\"\n@external\ndef should_revert():\n    c: DynArray[DynArray[uint256, 1], 2] = [[]]\n    c[0] = c.pop()\n    \"\"\",\n    \"\"\"\na: DynArray[String[65],2]\n\n@external\ndef should_revert() -> DynArray[String[65], 2]:\n    self.a = [\"hello\", \"world\"]\n    self.a = []\n    self.a = [self.a[0], self.a[1]]\n\n    return self.a  # if bug: return [\"hello\", \"world\"]\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"code\", dynarray_length_no_clobber_cases)\ndef test_dynarray_length_no_clobber(get_contract, assert_tx_failed, code):\n    # check that length is not clobbered before dynarray data copy happens\n    c = get_contract(code)\n    assert_tx_failed(lambda: c.should_revert())\n", "from vyper import ast as vy_ast\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.evm.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE\nfrom vyper.evm.opcodes import version_check\nfrom vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure, TypeMismatch\nfrom vyper.semantics.types import (\n    AddressT,\n    BoolT,\n    BytesM_T,\n    BytesT,\n    DArrayT,\n    DecimalT,\n    HashMapT,\n    IntegerT,\n    InterfaceT,\n    StructT,\n    TupleT,\n    _BytestringT,\n)\nfrom vyper.semantics.types.shortcuts import BYTES32_T, INT256_T, UINT256_T\nfrom vyper.semantics.types.subscriptable import SArrayT\nfrom vyper.semantics.types.user import EnumT\nfrom vyper.utils import (\n    GAS_CALLDATACOPY_WORD,\n    GAS_CODECOPY_WORD,\n    GAS_IDENTITY,\n    GAS_IDENTITYWORD,\n    ceil32,\n)\n\nDYNAMIC_ARRAY_OVERHEAD = 1\n\n\ndef is_bytes_m_type(typ):\n    return isinstance(typ, BytesM_T)\n\n\ndef is_numeric_type(typ):\n    return isinstance(typ, (IntegerT, DecimalT))\n\n\ndef is_integer_type(typ):\n    return isinstance(typ, IntegerT)\n\n\ndef is_decimal_type(typ):\n    return isinstance(typ, DecimalT)\n\n\ndef is_enum_type(typ):\n    return isinstance(typ, EnumT)\n\n\ndef is_tuple_like(typ):\n    # A lot of code paths treat tuples and structs similarly\n    # so we have a convenience function to detect it\n    ret = isinstance(typ, (TupleT, StructT))\n    assert ret == hasattr(typ, \"tuple_items\")\n    return ret\n\n\ndef is_array_like(typ):\n    # For convenience static and dynamic arrays share some code paths\n    ret = isinstance(typ, (DArrayT, SArrayT))\n    assert ret == typ._is_array_type\n    return ret\n\n\ndef get_type_for_exact_size(n_bytes):\n    \"\"\"Create a type which will take up exactly n_bytes. Used for allocating internal buffers.\n\n    Parameters:\n      n_bytes: the number of bytes to allocate\n    Returns:\n      type: A type which can be passed to context.new_variable\n    \"\"\"\n    return BytesT(n_bytes - 32 * DYNAMIC_ARRAY_OVERHEAD)\n\n\n# propagate revert message when calls to external contracts fail\ndef check_external_call(call_ir):\n    copy_revertdata = [\"returndatacopy\", 0, 0, \"returndatasize\"]\n    revert = IRnode.from_list([\"revert\", 0, \"returndatasize\"], error_msg=\"external call failed\")\n\n    propagate_revert_ir = [\"seq\", copy_revertdata, revert]\n    return [\"if\", [\"iszero\", call_ir], propagate_revert_ir]\n\n\n# cost per byte of the identity precompile\ndef _identity_gas_bound(num_bytes):\n    return GAS_IDENTITY + GAS_IDENTITYWORD * (ceil32(num_bytes) // 32)\n\n\ndef _calldatacopy_gas_bound(num_bytes):\n    return GAS_CALLDATACOPY_WORD * ceil32(num_bytes) // 32\n\n\ndef _codecopy_gas_bound(num_bytes):\n    return GAS_CODECOPY_WORD * ceil32(num_bytes) // 32\n\n\n# Copy byte array word-for-word (including layout)\n# TODO make this a private function\ndef make_byte_array_copier(dst, src):\n    assert isinstance(src.typ, _BytestringT)\n    assert isinstance(dst.typ, _BytestringT)\n\n    _check_assign_bytes(dst, src)\n\n    # TODO: remove this branch, copy_bytes and get_bytearray_length should handle\n    if src.value == \"~empty\":\n        # set length word to 0.\n        return STORE(dst, 0)\n\n    with src.cache_when_complex(\"src\") as (b1, src):\n        with get_bytearray_length(src).cache_when_complex(\"len\") as (b2, len_):\n            max_bytes = src.typ.maxlen\n\n            ret = [\"seq\"]\n\n            dst_ = bytes_data_ptr(dst)\n            src_ = bytes_data_ptr(src)\n\n            ret.append(copy_bytes(dst_, src_, len_, max_bytes))\n\n            # store length\n            ret.append(STORE(dst, len_))\n\n            return b1.resolve(b2.resolve(ret))\n\n\ndef bytes_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, _BytestringT)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef dynarray_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, DArrayT)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef _dynarray_make_setter(dst, src):\n    assert isinstance(src.typ, DArrayT)\n    assert isinstance(dst.typ, DArrayT)\n\n    if src.value == \"~empty\":\n        return IRnode.from_list(STORE(dst, 0))\n\n    # copy contents of src dynarray to dst.\n    # note that in case src and dst refer to the same dynarray,\n    # in order for get_element_ptr oob checks on the src dynarray\n    # to work, we need to wait until after the data is copied\n    # before we clobber the length word.\n\n    if src.value == \"multi\":\n        ret = [\"seq\"]\n        # handle literals\n\n        # copy each item\n        n_items = len(src.args)\n\n        for i in range(n_items):\n            k = IRnode.from_list(i, typ=UINT256_T)\n            dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n            src_i = get_element_ptr(src, k, array_bounds_check=False)\n            ret.append(make_setter(dst_i, src_i))\n\n        # write the length word after data is copied\n        store_length = STORE(dst, n_items)\n        ann = None\n        if src.annotation is not None:\n            ann = f\"len({src.annotation})\"\n        store_length = IRnode.from_list(store_length, annotation=ann)\n\n        ret.append(store_length)\n\n        return ret\n\n    with src.cache_when_complex(\"darray_src\") as (b1, src):\n        # for ABI-encoded dynamic data, we must loop to unpack, since\n        # the layout does not match our memory layout\n        should_loop = src.encoding == Encoding.ABI and src.typ.value_type.abi_type.is_dynamic()\n\n        # if the data is not validated, we must loop to unpack\n        should_loop |= needs_clamp(src.typ.value_type, src.encoding)\n\n        # performance: if the subtype is dynamic, there might be a lot\n        # of unused space inside of each element. for instance\n        # DynArray[DynArray[uint256, 100], 5] where all the child\n        # arrays are empty - for this case, we recursively call\n        # into make_setter instead of straight bytes copy\n        # TODO we can make this heuristic more precise, e.g.\n        # loop when subtype.is_dynamic AND location == storage\n        # OR array_size <= /bound where loop is cheaper than memcpy/\n        should_loop |= src.typ.value_type.abi_type.is_dynamic()\n\n        with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n            ret = [\"seq\"]\n\n            if should_loop:\n                i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=UINT256_T)\n\n                loop_body = make_setter(\n                    get_element_ptr(dst, i, array_bounds_check=False),\n                    get_element_ptr(src, i, array_bounds_check=False),\n                )\n                loop_body.annotation = f\"{dst}[i] = {src}[i]\"\n\n                ret.append([\"repeat\", i, 0, count, src.typ.count, loop_body])\n\n            else:\n                element_size = src.typ.value_type.memory_bytes_required\n                # number of elements * size of element in bytes\n                n_bytes = _mul(count, element_size)\n                max_bytes = src.typ.count * element_size\n\n                src_ = dynarray_data_ptr(src)\n                dst_ = dynarray_data_ptr(dst)\n                ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n\n            # write the length word after data is copied\n            ret.append(STORE(dst, count))\n\n            return b1.resolve(b2.resolve(ret))\n\n\n# Copy bytes\n# Accepts 4 arguments:\n# (i) an IR node for the start position of the source\n# (ii) an IR node for the start position of the destination\n# (iii) an IR node for the length (in bytes)\n# (iv) a constant for the max length (in bytes)\n# NOTE: may pad to ceil32 of `length`! If you ask to copy 1 byte, it may\n# copy an entire (32-byte) word, depending on the copy routine chosen.\n# TODO maybe always pad to ceil32, to reduce dirty bytes bugs\ndef copy_bytes(dst, src, length, length_bound):\n    annotation = f\"copy up to {length_bound} bytes from {src} to {dst}\"\n\n    src = IRnode.from_list(src)\n    dst = IRnode.from_list(dst)\n    length = IRnode.from_list(length)\n\n    with src.cache_when_complex(\"src\") as (b1, src), length.cache_when_complex(\n        \"copy_bytes_count\"\n    ) as (b2, length), dst.cache_when_complex(\"dst\") as (b3, dst):\n        assert isinstance(length_bound, int) and length_bound >= 0\n\n        # correctness: do not clobber dst\n        if length_bound == 0:\n            return IRnode.from_list([\"seq\"], annotation=annotation)\n        # performance: if we know that length is 0, do not copy anything\n        if length.value == 0:\n            return IRnode.from_list([\"seq\"], annotation=annotation)\n\n        assert src.is_pointer and dst.is_pointer\n\n        # fast code for common case where num bytes is small\n        # TODO expand this for more cases where num words is less than ~8\n        if length_bound <= 32:\n            copy_op = STORE(dst, LOAD(src))\n            ret = IRnode.from_list(copy_op, annotation=annotation)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == MEMORY and src.location in (MEMORY, CALLDATA, DATA):\n            # special cases: batch copy to memory\n            # TODO: iloadbytes\n            if src.location == MEMORY:\n                copy_op = [\"staticcall\", \"gas\", 4, src, length, dst, length]\n                gas_bound = _identity_gas_bound(length_bound)\n            elif src.location == CALLDATA:\n                copy_op = [\"calldatacopy\", dst, src, length]\n                gas_bound = _calldatacopy_gas_bound(length_bound)\n            elif src.location == DATA:\n                copy_op = [\"dloadbytes\", dst, src, length]\n                # note: dloadbytes compiles to CODECOPY\n                gas_bound = _codecopy_gas_bound(length_bound)\n\n            ret = IRnode.from_list(copy_op, annotation=annotation, add_gas_estimate=gas_bound)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == IMMUTABLES and src.location in (MEMORY, DATA):\n            # TODO istorebytes-from-mem, istorebytes-from-calldata(?)\n            # compile to identity, CODECOPY respectively.\n            pass\n\n        # general case, copy word-for-word\n        # pseudocode for our approach (memory-storage as example):\n        # for i in range(len, bound=MAX_LEN):\n        #   sstore(_dst + i, mload(src + i * 32))\n        i = IRnode.from_list(_freshname(\"copy_bytes_ix\"), typ=UINT256_T)\n\n        # optimized form of (div (ceil32 len) 32)\n        n = [\"div\", [\"add\", 31, length], 32]\n        n_bound = ceil32(length_bound) // 32\n\n        dst_i = add_ofst(dst, _mul(i, dst.location.word_scale))\n        src_i = add_ofst(src, _mul(i, src.location.word_scale))\n\n        copy_one_word = STORE(dst_i, LOAD(src_i))\n\n        main_loop = [\"repeat\", i, 0, n, n_bound, copy_one_word]\n\n        return b1.resolve(\n            b2.resolve(b3.resolve(IRnode.from_list(main_loop, annotation=annotation)))\n        )\n\n\n# get the number of bytes at runtime\ndef get_bytearray_length(arg):\n    typ = UINT256_T\n\n    # TODO: it would be nice to merge the implementations of get_bytearray_length and\n    # get_dynarray_count\n    if arg.value == \"~empty\":\n        return IRnode.from_list(0, typ=typ)\n\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\n# get the number of elements at runtime\ndef get_dyn_array_count(arg):\n    assert isinstance(arg.typ, DArrayT)\n\n    typ = UINT256_T\n\n    if arg.value == \"multi\":\n        return IRnode.from_list(len(arg.args), typ=typ)\n\n    if arg.value == \"~empty\":\n        # empty(DynArray[...])\n        return IRnode.from_list(0, typ=typ)\n\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\ndef append_dyn_array(darray_node, elem_node):\n    assert isinstance(darray_node.typ, DArrayT)\n\n    assert darray_node.typ.count > 0, \"jerk boy u r out\"\n\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        len_ = get_dyn_array_count(darray_node)\n        with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n            assertion = [\"assert\", [\"lt\", len_, darray_node.typ.count]]\n            ret.append(IRnode.from_list(assertion, error_msg=f\"{darray_node.typ} bounds check\"))\n            # NOTE: typechecks elem_node\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            ret.append(\n                make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n            )\n\n            # store new length\n            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)))\n\n\ndef pop_dyn_array(darray_node, return_popped_item):\n    assert isinstance(darray_node.typ, DArrayT)\n    assert darray_node.encoding == Encoding.VYPER\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        old_len = clamp(\"gt\", get_dyn_array_count(darray_node), 0)\n        new_len = IRnode.from_list([\"sub\", old_len, 1], typ=UINT256_T)\n\n        with new_len.cache_when_complex(\"new_len\") as (b2, new_len):\n            # store new length\n            ret.append(STORE(darray_node, new_len))\n\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            if return_popped_item:\n                popped_item = get_element_ptr(darray_node, new_len, array_bounds_check=False)\n                ret.append(popped_item)\n                typ = popped_item.typ\n                location = popped_item.location\n            else:\n                typ, location = None, None\n\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=typ, location=location)\n\n\ndef getpos(node):\n    return (\n        node.lineno,\n        node.col_offset,\n        getattr(node, \"end_lineno\", None),\n        getattr(node, \"end_col_offset\", None),\n    )\n\n\n# add an offset to a pointer, keeping location and encoding info\ndef add_ofst(ptr, ofst):\n    ret = [\"add\", ptr, ofst]\n    return IRnode.from_list(ret, location=ptr.location, encoding=ptr.encoding)\n\n\n# shorthand util\ndef _mul(x, y):\n    ret = [\"mul\", x, y]\n    return IRnode.from_list(ret)\n\n\n# Resolve pointer locations for ABI-encoded data\ndef _getelemptr_abi_helper(parent, member_t, ofst, clamp=True):\n    member_abi_t = member_t.abi_type\n\n    # ABI encoding has length word and then pretends length is not there\n    # e.g. [[1,2]] is encoded as 0x01 <len> 0x20 <inner array ofst> <encode(inner array)>\n    # note that inner array ofst is 0x20, not 0x40.\n    if has_length_word(parent.typ):\n        parent = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n\n    ofst_ir = add_ofst(parent, ofst)\n\n    if member_abi_t.is_dynamic():\n        # double dereference, according to ABI spec\n        # TODO optimize special case: first dynamic item\n        # offset is statically known.\n        ofst_ir = add_ofst(parent, unwrap_location(ofst_ir))\n\n    return IRnode.from_list(\n        ofst_ir,\n        typ=member_t,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=f\"{parent}{ofst}\",\n    )\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_tuplelike(parent, key):\n    typ = parent.typ\n    assert is_tuple_like(typ)\n\n    if isinstance(typ, StructT):\n        assert isinstance(key, str)\n        subtype = typ.member_types[key]\n        attrs = list(typ.tuple_keys())\n        index = attrs.index(key)\n        annotation = key\n    else:\n        # TupleT\n        assert isinstance(key, int)\n        subtype = typ.member_types[key]\n        attrs = list(typ.tuple_keys())\n        index = key\n        annotation = None\n\n    # generated by empty() + make_setter\n    if parent.value == \"~empty\":\n        return IRnode.from_list(\"~empty\", typ=subtype)\n\n    if parent.value == \"multi\":\n        assert parent.encoding != Encoding.ABI, \"no abi-encoded literals\"\n        return parent.args[index]\n\n    ofst = 0  # offset from parent start\n\n    if parent.encoding == Encoding.ABI:\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_t = typ.member_types[attrs[index]]\n\n        for i in range(index):\n            member_abi_t = typ.member_types[attrs[i]].abi_type\n            ofst += member_abi_t.embedded_static_size()\n\n        return _getelemptr_abi_helper(parent, member_t, ofst)\n\n    if parent.location.word_addressable:\n        for i in range(index):\n            ofst += typ.member_types[attrs[i]].storage_size_in_words\n    elif parent.location.byte_addressable:\n        for i in range(index):\n            ofst += typ.member_types[attrs[i]].memory_bytes_required\n    else:\n        raise CompilerPanic(f\"bad location {parent.location}\")  # pragma: notest\n\n    return IRnode.from_list(\n        add_ofst(parent, ofst),\n        typ=subtype,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=annotation,\n    )\n\n\ndef has_length_word(typ):\n    # Consider moving this to an attribute on typ\n    return isinstance(typ, (DArrayT, _BytestringT))\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_array(parent, key, array_bounds_check):\n    assert is_array_like(parent.typ)\n\n    if not is_integer_type(key.typ):\n        raise TypeCheckFailure(f\"{key.typ} used as array index\")\n\n    subtype = parent.typ.value_type\n\n    if parent.value == \"~empty\":\n        if array_bounds_check:\n            # this case was previously missing a bounds check. codegen\n            # is a bit complicated when bounds check is required, so\n            # block it. there is no reason to index into a literal empty\n            # array anyways!\n            raise TypeCheckFailure(\"indexing into zero array not allowed\")\n        return IRnode.from_list(\"~empty\", subtype)\n\n    if parent.value == \"multi\":\n        assert isinstance(key.value, int)\n        return parent.args[key.value]\n\n    ix = unwrap_location(key)\n\n    if array_bounds_check:\n        is_darray = isinstance(parent.typ, DArrayT)\n        bound = get_dyn_array_count(parent) if is_darray else parent.typ.count\n        # uclamplt works, even for signed ints. since two's-complement\n        # is used, if the index is negative, (unsigned) LT will interpret\n        # it as a very large number, larger than any practical value for\n        # an array index, and the clamp will throw an error.\n        # NOTE: there are optimization rules for this when ix or bound is literal\n        ix = clamp(\"lt\", ix, bound)\n\n    if parent.encoding == Encoding.ABI:\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_abi_t = subtype.abi_type\n\n        ofst = _mul(ix, member_abi_t.embedded_static_size())\n\n        return _getelemptr_abi_helper(parent, subtype, ofst)\n\n    if parent.location.word_addressable:\n        element_size = subtype.storage_size_in_words\n    elif parent.location.byte_addressable:\n        element_size = subtype.memory_bytes_required\n    else:\n        raise CompilerPanic(\"unreachable\")  # pragma: notest\n\n    ofst = _mul(ix, element_size)\n\n    if has_length_word(parent.typ):\n        data_ptr = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n    else:\n        data_ptr = parent\n\n    return IRnode.from_list(add_ofst(data_ptr, ofst), typ=subtype, location=parent.location)\n\n\ndef _get_element_ptr_mapping(parent, key):\n    assert isinstance(parent.typ, HashMapT)\n    subtype = parent.typ.value_type\n    key = unwrap_location(key)\n\n    # TODO when is key None?\n    if key is None or parent.location != STORAGE:\n        raise TypeCheckFailure(f\"bad dereference on mapping {parent}[{key}]\")\n\n    return IRnode.from_list([\"sha3_64\", parent, key], typ=subtype, location=STORAGE)\n\n\n# Take a value representing a memory or storage location, and descend down to\n# an element or member variable\n# This is analogous (but not necessarily equivalent to) getelementptr in LLVM.\ndef get_element_ptr(parent, key, array_bounds_check=True):\n    with parent.cache_when_complex(\"val\") as (b, parent):\n        typ = parent.typ\n\n        if is_tuple_like(typ):\n            ret = _get_element_ptr_tuplelike(parent, key)\n\n        elif isinstance(typ, HashMapT):\n            ret = _get_element_ptr_mapping(parent, key)\n\n        elif is_array_like(typ):\n            ret = _get_element_ptr_array(parent, key, array_bounds_check)\n\n        else:\n            raise CompilerPanic(f\"get_element_ptr cannot be called on {typ}\")  # pragma: notest\n\n        return b.resolve(ret)\n\n\ndef LOAD(ptr: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.load_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n    return IRnode.from_list([op, ptr])\n\n\ndef eval_once_check(name):\n    # an IRnode which enforces uniqueness. include with a side-effecting\n    # operation to sanity check that the codegen pipeline only generates\n    # the side-effecting operation once (otherwise, IR-to-assembly will\n    # throw a duplicate label exception). there is no runtime overhead\n    # since the jumpdest gets optimized out in the final stage of assembly.\n    return IRnode.from_list([\"unique_symbol\", name])\n\n\ndef STORE(ptr: IRnode, val: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.store_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n\n    _check = _freshname(f\"{op}_\")\n\n    store = [op, ptr, val]\n    # don't use eval_once_check for memory, immutables because it interferes\n    # with optimizer\n    if ptr.location in (MEMORY, IMMUTABLES):\n        return IRnode.from_list(store)\n\n    return IRnode.from_list([\"seq\", eval_once_check(_check), store])\n\n\n# Unwrap location\ndef unwrap_location(orig):\n    if orig.location is not None:\n        return IRnode.from_list(LOAD(orig), typ=orig.typ)\n    else:\n        # CMC 2022-03-24 TODO refactor so this branch can be removed\n        if orig.value == \"~empty\":\n            # must be word type\n            return IRnode.from_list(0, typ=orig.typ)\n        return orig\n\n\n# utility function, constructs an IR tuple out of a list of IR nodes\ndef ir_tuple_from_args(args):\n    typ = TupleT([x.typ for x in args])\n    return IRnode.from_list([\"multi\"] + [x for x in args], typ=typ)\n\n\ndef needs_external_call_wrap(typ):\n    # for calls to ABI conforming contracts.\n    # according to the ABI spec, return types are ALWAYS tuples even\n    # if only one element is being returned.\n    # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding\n    # \"and the return values v_1, ..., v_k of f are encoded as\n    #\n    #    enc((v_1, ..., v_k))\n    #    i.e. the values are combined into a tuple and encoded.\n    # \"\n    # therefore, wrap it in a tuple if it's not already a tuple.\n    # for example, `bytes` is returned as abi-encoded (bytes,)\n    # and `(bytes,)` is returned as abi-encoded ((bytes,),)\n    # In general `-> X` gets returned as (X,)\n    # including structs. MyStruct is returned as abi-encoded (MyStruct,).\n    # (Sorry this is so confusing. I didn't make these rules.)\n\n    return not (isinstance(typ, TupleT) and typ.length > 1)\n\n\ndef calculate_type_for_external_return(typ):\n    if needs_external_call_wrap(typ):\n        return TupleT([typ])\n    return typ\n\n\ndef wrap_value_for_external_return(ir_val):\n    # used for LHS promotion\n    if needs_external_call_wrap(ir_val.typ):\n        return ir_tuple_from_args([ir_val])\n    else:\n        return ir_val\n\n\ndef set_type_for_external_return(ir_val):\n    # used for RHS promotion\n    ir_val.typ = calculate_type_for_external_return(ir_val.typ)\n\n\n# return a dummy IRnode with the given type\ndef dummy_node_for_type(typ):\n    return IRnode(\"fake_node\", typ=typ)\n\n\ndef _check_assign_bytes(left, right):\n    if right.typ.maxlen > left.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from {right.typ} to {left.typ}\")  # pragma: notest\n\n    # stricter check for zeroing a byte array.\n    if right.value == \"~empty\" and right.typ.maxlen != left.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from empty({right.typ}) to {left.typ}\")  # pragma: notest\n\n\ndef _check_assign_list(left, right):\n    def FAIL():  # pragma: no cover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if left.value == \"multi\":\n        # Cannot do something like [a, b, c] = [1, 2, 3]\n        FAIL()  # pragma: notest\n\n    if isinstance(left.typ, SArrayT):\n        if not is_array_like(right.typ):\n            FAIL()  # pragma: notest\n        if left.typ.count != right.typ.count:\n            FAIL()  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(\n            dummy_node_for_type(left.typ.value_type), dummy_node_for_type(right.typ.value_type)\n        )\n\n    if isinstance(left.typ, DArrayT):\n        if not isinstance(right.typ, DArrayT):\n            FAIL()  # pragma: notest\n\n        if left.typ.count < right.typ.count:\n            FAIL()  # pragma: notest\n\n        # stricter check for zeroing\n        if right.value == \"~empty\" and right.typ.count != left.typ.count:\n            raise TypeCheckFailure(\n                f\"Bad type for clearing bytes: expected {left.typ} but got {right.typ}\"\n            )  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(\n            dummy_node_for_type(left.typ.value_type), dummy_node_for_type(right.typ.value_type)\n        )\n\n\ndef _check_assign_tuple(left, right):\n    def FAIL():  # pragma: no cover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if not isinstance(right.typ, left.typ.__class__):\n        FAIL()  # pragma: notest\n\n    if isinstance(left.typ, StructT):\n        for k in left.typ.member_types:\n            if k not in right.typ.member_types:\n                FAIL()  # pragma: notest\n            # TODO recurse into left, right if literals?\n            check_assign(\n                dummy_node_for_type(left.typ.member_types[k]),\n                dummy_node_for_type(right.typ.member_types[k]),\n            )\n\n        for k in right.typ.member_types:\n            if k not in left.typ.member_types:\n                FAIL()  # pragma: notest\n\n        if left.typ.name != right.typ.name:\n            FAIL()  # pragma: notest\n\n    else:\n        if len(left.typ.member_types) != len(right.typ.member_types):\n            FAIL()  # pragma: notest\n        for left_, right_ in zip(left.typ.member_types, right.typ.member_types):\n            # TODO recurse into left, right if literals?\n            check_assign(dummy_node_for_type(left_), dummy_node_for_type(right_))\n\n\n# sanity check an assignment\n# typechecking source code is done at an earlier phase\n# this function is more of a sanity check for typechecking internally\n# generated assignments\n# TODO: do we still need this?\ndef check_assign(left, right):\n    def FAIL():  # pragma: no cover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ} {left} {right}\")\n\n    if isinstance(left.typ, _BytestringT):\n        _check_assign_bytes(left, right)\n    elif is_array_like(left.typ):\n        _check_assign_list(left, right)\n    elif is_tuple_like(left.typ):\n        _check_assign_tuple(left, right)\n\n    elif left.typ._is_prim_word:\n        # TODO once we propagate types from typechecker, introduce this check:\n        # if left.typ != right.typ:\n        #    FAIL()  # pragma: notest\n        pass\n\n    else:  # pragma: no cover\n        FAIL()\n\n\n_label = 0\n\n\n# TODO might want to coalesce with Context.fresh_varname and compile_ir.mksymbol\ndef _freshname(name):\n    global _label\n    _label += 1\n    return f\"{name}{_label}\"\n\n\ndef reset_names():\n    global _label\n    _label = 0\n\n\n# returns True if t is ABI encoded and is a type that needs any kind of\n# validation\ndef needs_clamp(t, encoding):\n    if encoding == Encoding.VYPER:\n        return False\n    if encoding != Encoding.ABI:\n        raise CompilerPanic(\"unreachable\")  # pragma: notest\n    if isinstance(t, (_BytestringT, DArrayT)):\n        return True\n    if isinstance(t, EnumT):\n        return len(t._enum_members) < 256\n    if isinstance(t, SArrayT):\n        return needs_clamp(t.value_type, encoding)\n    if is_tuple_like(t):\n        return any(needs_clamp(m, encoding) for m in t.tuple_members())\n    if t._is_prim_word:\n        return t not in (INT256_T, UINT256_T, BYTES32_T)\n\n    raise CompilerPanic(\"unreachable\")  # pragma: notest\n\n\n# Create an x=y statement, where the types may be compound\ndef make_setter(left, right):\n    check_assign(left, right)\n\n    # For types which occupy just one word we can use single load/store\n    if left.typ._is_prim_word:\n        enc = right.encoding  # unwrap_location butchers encoding\n        right = unwrap_location(right)\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, enc):\n            right = clamp_basetype(right)\n\n        return STORE(left, right)\n\n    # Byte arrays\n    elif isinstance(left.typ, _BytestringT):\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"bs_ptr\") as (b, right):\n                copier = make_byte_array_copier(left, right)\n                ret = b.resolve([\"seq\", clamp_bytestring(right), copier])\n        else:\n            ret = make_byte_array_copier(left, right)\n\n        return IRnode.from_list(ret)\n\n    elif isinstance(left.typ, DArrayT):\n        # TODO should we enable this?\n        # implicit conversion from sarray to darray\n        # if isinstance(right.typ, SArrayType):\n        #    return _complex_make_setter(left, right)\n\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"arr_ptr\") as (b, right):\n                copier = _dynarray_make_setter(left, right)\n                ret = b.resolve([\"seq\", clamp_dyn_array(right), copier])\n        else:\n            ret = _dynarray_make_setter(left, right)\n\n        return IRnode.from_list(ret)\n\n    # Complex Types\n    assert isinstance(left.typ, (SArrayT, TupleT, StructT))\n\n    return _complex_make_setter(left, right)\n\n\ndef _complex_make_setter(left, right):\n    if right.value == \"~empty\" and left.location == MEMORY:\n        # optimized memzero\n        return mzero(left, left.typ.memory_bytes_required)\n\n    ret = [\"seq\"]\n\n    if isinstance(left.typ, SArrayT):\n        n_items = right.typ.count\n        keys = [IRnode.from_list(i, typ=UINT256_T) for i in range(n_items)]\n\n    else:\n        assert is_tuple_like(left.typ)\n        keys = left.typ.tuple_keys()\n\n    # if len(keyz) == 0:\n    #    return IRnode.from_list([\"pass\"])\n\n    # general case\n    # TODO use copy_bytes when the generated code is above a certain size\n    with left.cache_when_complex(\"_L\") as (b1, left), right.cache_when_complex(\"_R\") as (b2, right):\n        for k in keys:\n            l_i = get_element_ptr(left, k, array_bounds_check=False)\n            r_i = get_element_ptr(right, k, array_bounds_check=False)\n            ret.append(make_setter(l_i, r_i))\n\n        return b1.resolve(b2.resolve(IRnode.from_list(ret)))\n\n\ndef ensure_in_memory(ir_var, context):\n    \"\"\"Ensure a variable is in memory. This is useful for functions\n    which expect to operate on memory variables.\n    \"\"\"\n    if ir_var.location == MEMORY:\n        return ir_var\n\n    typ = ir_var.typ\n    buf = IRnode.from_list(context.new_internal_variable(typ), typ=typ, location=MEMORY)\n    do_copy = make_setter(buf, ir_var)\n\n    return IRnode.from_list([\"seq\", do_copy, buf], typ=typ, location=MEMORY)\n\n\ndef eval_seq(ir_node):\n    \"\"\"Tries to find the \"return\" value of a `seq` statement, in order so\n    that the value can be known without possibly evaluating side effects\n    \"\"\"\n    if ir_node.value in (\"seq\", \"with\") and len(ir_node.args) > 0:\n        return eval_seq(ir_node.args[-1])\n    if isinstance(ir_node.value, int):\n        return IRnode.from_list(ir_node)\n    return None\n\n\n# TODO move return checks to vyper/semantics/validation\ndef is_return_from_function(node):\n    if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") in (\n        \"raw_revert\",\n        \"selfdestruct\",\n    ):\n        return True\n    if isinstance(node, (vy_ast.Return, vy_ast.Raise)):\n        return True\n    return False\n\n\ndef check_single_exit(fn_node):\n    _check_return_body(fn_node, fn_node.body)\n    for node in fn_node.get_descendants(vy_ast.If):\n        _check_return_body(node, node.body)\n        if node.orelse:\n            _check_return_body(node, node.orelse)\n\n\ndef _check_return_body(node, node_list):\n    return_count = len([n for n in node_list if is_return_from_function(n)])\n    if return_count > 1:\n        raise StructureException(\n            \"Too too many exit statements (return, raise or selfdestruct).\", node\n        )\n    # Check for invalid code after returns.\n    last_node_pos = len(node_list) - 1\n    for idx, n in enumerate(node_list):\n        if is_return_from_function(n) and idx < last_node_pos:\n            # is not last statement in body.\n            raise StructureException(\n                \"Exit statement with succeeding code (that will not execute).\", node_list[idx + 1]\n            )\n\n\ndef mzero(dst, nbytes):\n    # calldatacopy from past-the-end gives zero bytes.\n    # cf. YP H.2 (ops section) with CALLDATACOPY spec.\n    return IRnode.from_list(\n        # calldatacopy mempos calldatapos len\n        [\"calldatacopy\", dst, \"calldatasize\", nbytes],\n        annotation=\"mzero\",\n    )\n\n\n# zero pad a bytearray according to the ABI spec. The last word\n# of the byte array needs to be right-padded with zeroes.\ndef zero_pad(bytez_placeholder):\n    len_ = [\"mload\", bytez_placeholder]\n    dst = [\"add\", [\"add\", bytez_placeholder, 32], \"len\"]\n    # the runtime length of the data rounded up to nearest 32\n    # from spec:\n    #   the actual value of X as a byte sequence,\n    #   followed by the *minimum* number of zero-bytes\n    #   such that len(enc(X)) is a multiple of 32.\n    # optimized form of ceil32(len) - len:\n    num_zero_bytes = [\"mod\", [\"sub\", 0, \"len\"], 32]\n    return IRnode.from_list(\n        [\"with\", \"len\", len_, [\"with\", \"dst\", dst, mzero(\"dst\", num_zero_bytes)]],\n        annotation=\"Zero pad\",\n    )\n\n\n# convenience rewrites for shr/sar/shl\ndef shr(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shr\", bits, x]\n    return [\"div\", x, [\"exp\", 2, bits]]\n\n\n# convenience rewrites for shr/sar/shl\ndef shl(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shl\", bits, x]\n    return [\"mul\", x, [\"exp\", 2, bits]]\n\n\ndef sar(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"sar\", bits, x]\n\n    raise NotImplementedError(\"no SAR emulation for pre-constantinople EVM\")\n\n\ndef clamp_bytestring(ir_node):\n    t = ir_node.typ\n    if not isinstance(t, _BytestringT):\n        raise CompilerPanic(f\"{t} passed to clamp_bytestring\")  # pragma: notest\n    ret = [\"assert\", [\"le\", get_bytearray_length(ir_node), t.maxlen]]\n    return IRnode.from_list(ret, error_msg=f\"{ir_node.typ} bounds check\")\n\n\ndef clamp_dyn_array(ir_node):\n    t = ir_node.typ\n    assert isinstance(t, DArrayT)\n    ret = [\"assert\", [\"le\", get_dyn_array_count(ir_node), t.count]]\n    return IRnode.from_list(ret, error_msg=f\"{ir_node.typ} bounds check\")\n\n\n# clampers for basetype\ndef clamp_basetype(ir_node):\n    t = ir_node.typ\n    if not t._is_prim_word:\n        raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest\n\n    # copy of the input\n    ir_node = unwrap_location(ir_node)\n\n    if isinstance(t, EnumT):\n        bits = len(t._enum_members)\n        # assert x >> bits == 0\n        ret = int_clamp(ir_node, bits, signed=False)\n\n    elif isinstance(t, (IntegerT, DecimalT)):\n        if t.bits == 256:\n            ret = ir_node\n        else:\n            ret = int_clamp(ir_node, t.bits, signed=t.is_signed)\n\n    elif isinstance(t, BytesM_T):\n        if t.m == 32:\n            ret = ir_node  # special case, no clamp.\n        else:\n            ret = bytes_clamp(ir_node, t.m)\n\n    elif isinstance(t, (AddressT, InterfaceT)):\n        ret = int_clamp(ir_node, 160)\n    elif t in (BoolT(),):\n        ret = int_clamp(ir_node, 1)\n    else:  # pragma: no cover\n        raise CompilerPanic(f\"{t} passed to clamp_basetype\")\n\n    return IRnode.from_list(ret, typ=ir_node.typ, error_msg=f\"validate {t}\")\n\n\ndef int_clamp(ir_node, bits, signed=False):\n    \"\"\"Generalized clamper for integer types. Takes the number of bits,\n    whether it's signed, and returns an IR node which checks it is\n    in bounds. (Consumers should use clamp_basetype instead which uses\n    type-based dispatch and is a little safer.)\n    \"\"\"\n    if bits >= 256:\n        raise CompilerPanic(f\"invalid clamp: {bits}>=256 ({ir_node})\")  # pragma: notest\n\n    u = \"u\" if not signed else \"\"\n    msg = f\"{u}int{bits} bounds check\"\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        if signed:\n            # example for bits==128:\n            # promote_signed_int(val, bits) is the \"canonical\" version of val\n            # if val is in bounds, the bits above bit 128 should be equal.\n            # (this works for both val >= 0 and val < 0. in the first case,\n            # all upper bits should be 0 if val is a valid int128,\n            # in the latter case, all upper bits should be 1.)\n            assertion = [\"assert\", [\"eq\", val, promote_signed_int(val, bits)]]\n        else:\n            assertion = [\"assert\", [\"iszero\", shr(bits, val)]]\n\n        assertion = IRnode.from_list(assertion, error_msg=msg)\n\n        ret = b.resolve([\"seq\", assertion, val])\n\n    return IRnode.from_list(ret, annotation=msg)\n\n\ndef bytes_clamp(ir_node: IRnode, n_bytes: int) -> IRnode:\n    if not (0 < n_bytes <= 32):\n        raise CompilerPanic(f\"bad type: bytes{n_bytes}\")\n    msg = f\"bytes{n_bytes} bounds check\"\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        assertion = IRnode.from_list([\"assert\", [\"iszero\", shl(n_bytes * 8, val)]], error_msg=msg)\n        ret = b.resolve([\"seq\", assertion, val])\n\n    return IRnode.from_list(ret, annotation=msg)\n\n\n# e.g. for int8, promote 255 to -1\ndef promote_signed_int(x, bits):\n    assert bits % 8 == 0\n    ret = [\"signextend\", bits // 8 - 1, x]\n    return IRnode.from_list(ret, annotation=f\"promote int{bits}\")\n\n\n# general clamp function for all ops and numbers\ndef clamp(op, arg, bound):\n    with IRnode.from_list(arg).cache_when_complex(\"clamp_arg\") as (b1, arg):\n        check = IRnode.from_list([\"assert\", [op, arg, bound]], error_msg=f\"clamp {op} {bound}\")\n        ret = [\"seq\", check, arg]\n        return IRnode.from_list(b1.resolve(ret), typ=arg.typ)\n\n\ndef clamp_nonzero(arg):\n    # TODO: use clamp(\"ne\", arg, 0) once optimizer rules can handle it\n    with IRnode.from_list(arg).cache_when_complex(\"should_nonzero\") as (b1, arg):\n        check = IRnode.from_list([\"assert\", arg], error_msg=\"check nonzero\")\n        ret = [\"seq\", check, arg]\n        return IRnode.from_list(b1.resolve(ret), typ=arg.typ)\n\n\ndef clamp2(lo, arg, hi, signed):\n    with IRnode.from_list(arg).cache_when_complex(\"clamp2_arg\") as (b1, arg):\n        GE = \"sge\" if signed else \"ge\"\n        LE = \"sle\" if signed else \"le\"\n        ret = [\"seq\", [\"assert\", [\"and\", [GE, arg, lo], [LE, arg, hi]]], arg]\n        return IRnode.from_list(b1.resolve(ret), typ=arg.typ)\n"], "filenames": ["tests/parser/types/test_dynamic_array.py", "vyper/codegen/core.py"], "buggy_code_start_loc": [1750, 119], "buggy_code_end_loc": [1750, 366], "fixing_code_start_loc": [1751, 120], "fixing_code_end_loc": [1843, 383], "type": "CWE-787", "message": "Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-31146", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-11T21:15:10.240", "lastModified": "2023-05-22T18:12:02.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vyper_project:vyper:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.8", "matchCriteriaId": "BD6E3906-C87B-4245-9871-27CD85C32EEF"}]}]}], "references": [{"url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-3p37-3636-q8wv", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb"}}