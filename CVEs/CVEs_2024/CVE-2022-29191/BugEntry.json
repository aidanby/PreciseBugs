{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include <limits.h>\n\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass GetSessionHandleOp : public OpKernel {\n public:\n  explicit GetSessionHandleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64_t id = session_state->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionHandleOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\n\n#define REGISTER_DEFAULT_KERNEL(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\")        \\\n                              .Device(DEVICE_DEFAULT)     \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\")      \\\n                              .Device(DEVICE_DEFAULT)     \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_DEFAULT_KERNEL);\nREGISTER_DEFAULT_KERNEL(bool);\n#undef REGISTER_DEFAULT_KERNEL\n\nclass GetSessionTensorOp : public OpKernel {\n public:\n  explicit GetSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\").Device(DEVICE_CPU),\n                        GetSessionTensorOp);\n\n#define REGISTER_DEFAULT_KERNEL(type)                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\")            \\\n                              .Device(DEVICE_DEFAULT)         \\\n                              .HostMemory(\"handle\")           \\\n                              .TypeConstraint<type>(\"dtype\"), \\\n                          GetSessionTensorOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_DEFAULT_KERNEL);\nREGISTER_DEFAULT_KERNEL(bool);\n#undef REGISTER_DEFAULT_KERNEL\n\nclass DeleteSessionTensorOp : public OpKernel {\n public:\n  explicit DeleteSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(DeleteSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DeleteSessionTensor\").Device(DEVICE_CPU),\n                        DeleteSessionTensorOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"DeleteSessionTensor\").Device(DEVICE_DEFAULT).HostMemory(\"handle\"),\n    DeleteSessionTensorOp);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include <limits.h>\n\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass GetSessionHandleOp : public OpKernel {\n public:\n  explicit GetSessionHandleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64_t id = session_state->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionHandleOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\n\n#define REGISTER_DEFAULT_KERNEL(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\")        \\\n                              .Device(DEVICE_DEFAULT)     \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\")      \\\n                              .Device(DEVICE_DEFAULT)     \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_DEFAULT_KERNEL);\nREGISTER_DEFAULT_KERNEL(bool);\n#undef REGISTER_DEFAULT_KERNEL\n\nclass GetSessionTensorOp : public OpKernel {\n public:\n  explicit GetSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"handle must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\").Device(DEVICE_CPU),\n                        GetSessionTensorOp);\n\n#define REGISTER_DEFAULT_KERNEL(type)                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\")            \\\n                              .Device(DEVICE_DEFAULT)         \\\n                              .HostMemory(\"handle\")           \\\n                              .TypeConstraint<type>(\"dtype\"), \\\n                          GetSessionTensorOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_DEFAULT_KERNEL);\nREGISTER_DEFAULT_KERNEL(bool);\n#undef REGISTER_DEFAULT_KERNEL\n\nclass DeleteSessionTensorOp : public OpKernel {\n public:\n  explicit DeleteSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(DeleteSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DeleteSessionTensor\").Device(DEVICE_CPU),\n                        DeleteSessionTensorOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"DeleteSessionTensor\").Device(DEVICE_DEFAULT).HostMemory(\"handle\"),\n    DeleteSessionTensorOp);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/session_ops.cc"], "buggy_code_start_loc": [100], "buggy_code_end_loc": [100], "fixing_code_start_loc": [101], "fixing_code_end_loc": [103], "type": "CWE-20", "message": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.GetSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2022-29191", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-20T21:15:10.247", "lastModified": "2022-06-02T12:57:40.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.GetSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En versiones anteriores a 2.9.0, 2.8.1, 2.7.2 y 2.6.4, la implementaci\u00f3n de \"tf.raw_ops.GetSessionTensor\" no comprueba completamente los argumentos de entrada. Esto resulta en un fallo de \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Las versiones 2.9.0, 2.8.1, 2.7.2 y 2.6.4 contienen un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.4", "matchCriteriaId": "D9359D32-D090-44CF-AC43-2046084A28BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C4DFBF2D-5283-42F6-8800-D653BFA5CE82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "9CFB1CFC-579D-4647-A472-6DE8BE1951DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F3F3F37E-D27F-4060-830C-0AFF16150777"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "113B5FC0-ED39-4134-9722-A163B673E3EF"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/core/kernels/session_ops.cc#L94-L112", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/48305e8ffe5246d67570b64096a96f8e315a7281", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.6.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.8.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-fv25-wrff-wf86", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/48305e8ffe5246d67570b64096a96f8e315a7281"}}