{"buggy_code": ["CHANGELOG\n=========\n\n2.8.0\n-----\n\n * Finding deep items in `ParameterBag::get()` is deprecated since version 2.8 and\n   will be removed in 3.0.\n\n2.6.0\n-----\n\n * PdoSessionHandler changes\n   - implemented different session locking strategies to prevent loss of data by concurrent access to the same session\n   - [BC BREAK] save session data in a binary column without base64_encode\n   - [BC BREAK] added lifetime column to the session table which allows to have different lifetimes for each session\n   - implemented lazy connections that are only opened when a session is used by either passing a dsn string\n     explicitly or falling back to session.save_path ini setting\n   - added a createTable method that initializes a correctly defined table depending on the database vendor\n\n2.5.0\n-----\n\n * added `JsonResponse::setEncodingOptions()` & `JsonResponse::getEncodingOptions()` for easier manipulation\n   of the options used while encoding data to JSON format.\n\n2.4.0\n-----\n\n * added RequestStack\n * added Request::getEncodings()\n * added accessors methods to session handlers\n\n2.3.0\n-----\n\n * added support for ranges of IPs in trusted proxies\n * `UploadedFile::isValid` now returns false if the file was not uploaded via HTTP (in a non-test mode)\n * Improved error-handling of `\\Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler`\n   to ensure the supplied PDO handler throws Exceptions on error (as the class expects). Added related test cases\n   to verify that Exceptions are properly thrown when the PDO queries fail.\n\n2.2.0\n-----\n\n * fixed the Request::create() precedence (URI information always take precedence now)\n * added Request::getTrustedProxies()\n * deprecated Request::isProxyTrusted()\n * [BC BREAK] JsonResponse does not turn a top level empty array to an object anymore, use an ArrayObject to enforce objects\n * added a IpUtils class to check if an IP belongs to a CIDR\n * added Request::getRealMethod() to get the \"real\" HTTP method (getMethod() returns the \"intended\" HTTP method)\n * disabled _method request parameter support by default (call Request::enableHttpMethodParameterOverride() to\n   enable it, and Request::getHttpMethodParameterOverride() to check if it is supported)\n * Request::splitHttpAcceptHeader() method is deprecated and will be removed in 2.3\n * Deprecated Flashbag::count() and \\Countable interface, will be removed in 2.3\n\n2.1.0\n-----\n\n * added Request::getSchemeAndHttpHost() and Request::getUserInfo()\n * added a fluent interface to the Response class\n * added Request::isProxyTrusted()\n * added JsonResponse\n * added a getTargetUrl method to RedirectResponse\n * added support for streamed responses\n * made Response::prepare() method the place to enforce HTTP specification\n * [BC BREAK] moved management of the locale from the Session class to the Request class\n * added a generic access to the PHP built-in filter mechanism: ParameterBag::filter()\n * made FileBinaryMimeTypeGuesser command configurable\n * added Request::getUser() and Request::getPassword()\n * added support for the PATCH method in Request\n * removed the ContentTypeMimeTypeGuesser class as it is deprecated and never used on PHP 5.3\n * added ResponseHeaderBag::makeDisposition() (implements RFC 6266)\n * made mimetype to extension conversion configurable\n * [BC BREAK] Moved all session related classes and interfaces into own namespace, as\n   `Symfony\\Component\\HttpFoundation\\Session` and renamed classes accordingly.\n   Session handlers are located in the subnamespace `Symfony\\Component\\HttpFoundation\\Session\\Handler`.\n * SessionHandlers must implement `\\SessionHandlerInterface` or extend from the\n   `Symfony\\Component\\HttpFoundation\\Storage\\Handler\\NativeSessionHandler` base class.\n * Added internal storage driver proxy mechanism for forward compatibility with\n   PHP 5.4 `\\SessionHandler` class.\n * Added session handlers for custom Memcache, Memcached and Null session save handlers.\n * [BC BREAK] Removed `NativeSessionStorage` and replaced with `NativeFileSessionHandler`.\n * [BC BREAK] `SessionStorageInterface` methods removed: `write()`, `read()` and\n   `remove()`.  Added `getBag()`, `registerBag()`.  The `NativeSessionStorage` class\n   is a mediator for the session storage internals including the session handlers\n   which do the real work of participating in the internal PHP session workflow.\n * [BC BREAK] Introduced mock implementations of `SessionStorage` to enable unit\n   and functional testing without starting real PHP sessions.  Removed\n   `ArraySessionStorage`, and replaced with `MockArraySessionStorage` for unit\n   tests; removed `FilesystemSessionStorage`, and replaced with`MockFileSessionStorage`\n   for functional tests.  These do not interact with global session ini\n   configuration values, session functions or `$_SESSION` superglobal. This means\n   they can be configured directly allowing multiple instances to work without\n   conflicting in the same PHP process.\n * [BC BREAK] Removed the `close()` method from the `Session` class, as this is\n   now redundant.\n * Deprecated the following methods from the Session class: `setFlash()`, `setFlashes()`\n   `getFlash()`, `hasFlash()`, and `removeFlash()`. Use `getFlashBag()` instead\n   which returns a `FlashBagInterface`.\n * `Session->clear()` now only clears session attributes as before it cleared\n   flash messages and attributes. `Session->getFlashBag()->all()` clears flashes now.\n * Session data is now managed by `SessionBagInterface` to better encapsulate\n   session data.\n * Refactored session attribute and flash messages system to their own\n  `SessionBagInterface` implementations.\n * Added `FlashBag`. Flashes expire when retrieved by `get()` or `all()`. This\n   implementation is ESI compatible.\n * Added `AutoExpireFlashBag` (default) to replicate Symfony 2.0.x auto expire\n   behaviour of messages auto expiring after one page page load.  Messages must\n   be retrieved by `get()` or `all()`.\n * Added `Symfony\\Component\\HttpFoundation\\Attribute\\AttributeBag` to replicate\n   attributes storage behaviour from 2.0.x (default).\n * Added `Symfony\\Component\\HttpFoundation\\Attribute\\NamespacedAttributeBag` for\n   namespace session attributes.\n * Flash API can stores messages in an array so there may be multiple messages\n   per flash type.  The old `Session` class API remains without BC break as it\n   will allow single messages as before.\n * Added basic session meta-data to the session to record session create time,\n   last updated time, and the lifetime of the session cookie that was provided\n   to the client.\n * Request::getClientIp() method doesn't take a parameter anymore but bases\n   itself on the trustProxy parameter.\n * Added isMethod() to Request object.\n * [BC BREAK] The methods `getPathInfo()`, `getBaseUrl()` and `getBasePath()` of\n   a `Request` now all return a raw value (vs a urldecoded value before). Any call\n   to one of these methods must be checked and wrapped in a `rawurldecode()` if\n   needed.\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 'forwarded';\n    const HEADER_CLIENT_IP = 'client_ip';\n    const HEADER_CLIENT_HOST = 'client_host';\n    const HEADER_CLIENT_PROTO = 'client_proto';\n    const HEADER_CLIENT_PORT = 'client_port';\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = array();\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = array();\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = array();\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     */\n    protected static $trustedHeaders = array(\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',\n        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',\n    );\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    private $isForwardedValid = true;\n\n    private static $forwardedParams = array(\n        self::HEADER_CLIENT_IP => 'for',\n        self::HEADER_CLIENT_HOST => 'host',\n        self::HEADER_CLIENT_PROTO => 'proto',\n        self::HEADER_CLIENT_PORT => 'host',\n    );\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new ParameterBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new ParameterBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        // With the php's bug #66606, the php's built-in web server\n        // stores the Content-Type and Content-Length header values in\n        // HTTP_CONTENT_TYPE and HTTP_CONTENT_LENGTH fields.\n        $server = $_SERVER;\n        if ('cli-server' === PHP_SAPI) {\n            if (array_key_exists('HTTP_CONTENT_LENGTH', $_SERVER)) {\n                $server['CONTENT_LENGTH'] = $_SERVER['HTTP_CONTENT_LENGTH'];\n            }\n            if (array_key_exists('HTTP_CONTENT_TYPE', $_SERVER)) {\n                $server['CONTENT_TYPE'] = $_SERVER['HTTP_CONTENT_TYPE'];\n            }\n        }\n\n        $request = self::createRequestFromFactory($_GET, $_POST, array(), $_COOKIE, $_FILES, $server);\n\n        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), array('PUT', 'DELETE', 'PATCH'))\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new ParameterBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null)\n    {\n        $server = array_replace(array(\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony/2.X',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ), $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] = $server['HTTP_HOST'].':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = array();\n                break;\n            default:\n                $request = array();\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, array(), $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     *\n     * @param callable|null $callable A PHP callable\n     */\n    public static function setFactory($callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new ParameterBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new ParameterBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = array();\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (in_array($key, array('CONTENT_TYPE', 'CONTENT_LENGTH'))) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = array('g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE);\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = array();\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST = array_merge($_REQUEST, $request[$order]);\n        }\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies A list of trusted proxies\n     */\n    public static function setTrustedProxies(array $proxies)\n    {\n        self::$trustedProxies = $proxies;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = array();\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Sets the name for trusted headers.\n     *\n     * The following header keys are supported:\n     *\n     *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())\n     *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())\n     *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())\n     *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())\n     *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)\n     *\n     * Setting an empty value allows to disable the trusted header for the given key.\n     *\n     * @param string $key   The header key\n     * @param string $value The header name\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public static function setTrustedHeaderName($key, $value)\n    {\n        if (!array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to set the trusted header name for key \"%s\".', $key));\n        }\n\n        self::$trustedHeaders[$key] = $value;\n    }\n\n    /**\n     * Gets the trusted proxy header name.\n     *\n     * @param string $key The header key\n     *\n     * @return string The header name\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public static function getTrustedHeaderName($key)\n    {\n        if (!array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to get the trusted header name for key \"%s\".', $key));\n        }\n\n        return self::$trustedHeaders[$key];\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @param string $qs Query string\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString($qs)\n    {\n        if ('' == $qs) {\n            return '';\n        }\n\n        $parts = array();\n        $order = array();\n\n        foreach (explode('&', $qs) as $param) {\n            if ('' === $param || '=' === $param[0]) {\n                // Ignore useless delimiters, e.g. \"x=y&\".\n                // Also ignore pairs with empty key, even if there was a value, e.g. \"=value\", as such nameless values cannot be retrieved anyway.\n                // PHP also does not include them when building _GET.\n                continue;\n            }\n\n            $keyValuePair = explode('=', $param, 2);\n\n            // GET parameters, that are submitted from a HTML form, encode spaces as \"+\" by default (as defined in enctype application/x-www-form-urlencoded).\n            // PHP also converts \"+\" to spaces when filling the global _GET or when using the function parse_str. This is why we use urldecode and then normalize to\n            // RFC 3986 with rawurlencode.\n            $parts[] = isset($keyValuePair[1]) ?\n                rawurlencode(urldecode($keyValuePair[0])).'='.rawurlencode(urldecode($keyValuePair[1])) :\n                rawurlencode(urldecode($keyValuePair[0]));\n            $order[] = urldecode($keyValuePair[0]);\n        }\n\n        array_multisort($order, SORT_ASC, $parts);\n\n        return implode('&', $parts);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility.\n     *\n     * Order of precedence: GET, PATH, POST\n     *\n     * Avoid using this method in controllers:\n     *\n     *  * slow\n     *  * prefer to get from a \"named\" source\n     *\n     * It is better to explicitly get request parameters from the appropriate\n     * public property instead (query, attributes, request).\n     *\n     * Note: Finding deep items is deprecated since version 2.8, to be removed in 3.0.\n     *\n     * @param string $key     The key\n     * @param mixed  $default The default value if the parameter key does not exist\n     * @param bool   $deep    Is parameter deep in multidimensional array\n     *\n     * @return mixed\n     */\n    public function get($key, $default = null, $deep = false)\n    {\n        if ($deep) {\n            @trigger_error('Using paths to find deeper items in '.__METHOD__.' is deprecated since Symfony 2.8 and will be removed in 3.0. Filter the returned value in your own code instead.', E_USER_DEPRECATED);\n        }\n\n        if ($this !== $result = $this->query->get($key, $this, $deep)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->attributes->get($key, $this, $deep)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->request->get($key, $this, $deep)) {\n            return $result;\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface|null The session\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->session->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    /**\n     * Sets the Session.\n     *\n     * @param SessionInterface $session The Session\n     */\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return array($ip);\n        }\n\n        return $this->getTrustedValues(self::HEADER_CLIENT_IP, $ip) ?: array($ip);\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via \"setTrustedHeaderName()\" with\n     * the \"client-ip\" key.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see http://en.wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Port\",\n     * configure it via \"setTrustedHeaderName()\" with the \"client-port\" key.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos) {\n            return (int) substr($host, $pos + 1);\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath($path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @param string $path The target path\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath($path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', isset($path[0]) && '/' === $path[0] ? substr($path, 1) : $path);\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see http://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Proto\"\n     * (\"SSL_HTTPS\" for instance), configure it via \"setTrustedHeaderName()\" with\n     * the \"client-proto\" key.\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_CLIENT_PROTO)) {\n            return in_array(strtolower($proto[0]), array('https', 'on', 'ssl', '1'), true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Host\",\n     * configure it via \"setTrustedHeaderName()\" with the \"client-host\" key.\n     *\n     * @return string\n     *\n     * @throws \\UnexpectedValueException when the host name is invalid\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            throw new \\UnexpectedValueException(sprintf('Invalid Host \"%s\"', $host));\n        }\n\n        if (count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            throw new \\UnexpectedValueException(sprintf('Untrusted Host \"%s\"', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     *\n     * @param string $method\n     */\n    public function setMethod($method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null === $this->method) {\n            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n            if ('POST' === $this->method) {\n                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {\n                    $this->method = strtoupper($method);\n                } elseif (self::$httpMethodParameterOverride) {\n                    $this->method = strtoupper($this->request->get('_method', $this->query->get('_method', 'POST')));\n                }\n            }\n        }\n\n        return $this->method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @param string $mimeType The associated mime type\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat($mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = substr($mimeType, 0, $pos);\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string       $format    The format\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat($format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes);\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request parameter\n     *  * $default\n     *\n     * @param string $default The default format\n     *\n     * @return string The request format\n     */\n    public function getRequestFormat($default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     *\n     * @param string $format The request format\n     */\n    public function setRequestFormat($format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     *\n     * @param string $locale\n     */\n    public function setDefaultLocale($locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     *\n     * @param string $locale\n     */\n    public function setLocale($locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod($method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether the method is safe or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.\n     *\n     * @return bool\n     */\n    public function isMethodSafe(/* $andCacheable = true */)\n    {\n        return in_array($this->getMethod(), 0 < func_num_args() && !func_get_arg(0) ? array('GET', 'HEAD', 'OPTIONS', 'TRACE') : array('GET', 'HEAD'));\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool\n     */\n    public function isMethodCacheable()\n    {\n        return in_array($this->getMethod(), array('GET', 'HEAD'));\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent($asResource = false)\n    {\n        $currentContentIsResource = is_resource($this->content);\n        if (\\PHP_VERSION_ID < 50600 && false === $this->content) {\n            throw new \\LogicException('getContent() can only be called once when using the resource return type and PHP below 5.6.');\n        }\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param array $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = array();\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = array();\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (http://framework.zend.com/license/new-bsd).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (http://www.zend.com)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ($this->headers->has('X_ORIGINAL_URL')) {\n            // IIS with Microsoft Rewrite Module\n            $requestUri = $this->headers->get('X_ORIGINAL_URL');\n            $this->headers->remove('X_ORIGINAL_URL');\n            $this->server->remove('HTTP_X_ORIGINAL_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->headers->has('X_REWRITE_URL')) {\n            // IIS with ISAPI_Rewrite\n            $requestUri = $this->headers->get('X_REWRITE_URL');\n            $this->headers->remove('X_REWRITE_URL');\n        } elseif ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n            // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path, only use URL path\n            $schemeAndHttpHost = $this->getSchemeAndHttpHost();\n            if (0 === strpos($requestUri, $schemeAndHttpHost)) {\n                $requestUri = substr($requestUri, strlen($schemeAndHttpHost));\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(dirname($baseUrl), '/'.DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (strlen($requestUri) >= strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        if (basename($baseUrl) === $filename) {\n            $basePath = dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        $baseUrl = $this->getBaseUrl();\n\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        $pathInfo = substr($requestUri, strlen($baseUrl));\n        if (null !== $baseUrl && (false === $pathInfo || '' === $pathInfo)) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        } elseif (null === $baseUrl) {\n            return $requestUri;\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = array(\n            'html' => array('text/html', 'application/xhtml+xml'),\n            'txt' => array('text/plain'),\n            'js' => array('application/javascript', 'application/x-javascript', 'text/javascript'),\n            'css' => array('text/css'),\n            'json' => array('application/json', 'application/x-json'),\n            'jsonld' => array('application/ld+json'),\n            'xml' => array('text/xml', 'application/xml', 'application/x-xml'),\n            'rdf' => array('application/rdf+xml'),\n            'atom' => array('application/atom+xml'),\n            'rss' => array('application/rss+xml'),\n            'form' => array('application/x-www-form-urlencoded'),\n        );\n    }\n\n    /**\n     * Sets the default PHP locale.\n     *\n     * @param string $locale\n     */\n    private function setPhpDefaultLocale($locale)\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /*\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, false otherwise.\n     *\n     * @param string $string The urlencoded string\n     * @param string $prefix The prefix not encoded\n     *\n     * @return string|false The prefix as it is encoded in $string, or false\n     */\n    private function getUrlencodedPrefix($string, $prefix)\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return false;\n        }\n\n        $len = strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return false;\n    }\n\n    private static function createRequestFromFactory(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)\n    {\n        if (self::$requestFactory) {\n            $request = call_user_func(self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    private function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues($type, $ip = null)\n    {\n        $clientValues = array();\n        $forwardedValues = array();\n\n        if (self::$trustedHeaders[$type] && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_CLIENT_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if (self::$trustedHeaders[self::HEADER_FORWARDED] && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwardedValues = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $forwardedValues = preg_match_all(sprintf('{(?:%s)=(?:\"?\\[?)([a-zA-Z0-9\\.:_\\-/]*+)}', self::$forwardedParams[$type]), $forwardedValues, $matches) ? $matches[1] : array();\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? array('0.0.0.0', $ip) : array();\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, $ip)\n    {\n        if (!$clientIps) {\n            return array();\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            // Remove port (unfortunately, it does happen)\n            if (preg_match('{((?:\\d+\\.){3}\\d+)\\:\\d+}', $clientIp, $match)) {\n                $clientIps[$key] = $clientIp = $match[1];\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : array($firstTrustedIp);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation\\Tests;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass RequestTest extends TestCase\n{\n    protected function tearDown()\n    {\n        Request::setTrustedProxies(array());\n        Request::setTrustedHosts(array());\n    }\n\n    public function testInitialize()\n    {\n        $request = new Request();\n\n        $request->initialize(array('foo' => 'bar'));\n        $this->assertEquals('bar', $request->query->get('foo'), '->initialize() takes an array of query parameters as its first argument');\n\n        $request->initialize(array(), array('foo' => 'bar'));\n        $this->assertEquals('bar', $request->request->get('foo'), '->initialize() takes an array of request parameters as its second argument');\n\n        $request->initialize(array(), array(), array('foo' => 'bar'));\n        $this->assertEquals('bar', $request->attributes->get('foo'), '->initialize() takes an array of attributes as its third argument');\n\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_FOO' => 'bar'));\n        $this->assertEquals('bar', $request->headers->get('FOO'), '->initialize() takes an array of HTTP headers as its sixth argument');\n    }\n\n    public function testGetLocale()\n    {\n        $request = new Request();\n        $request->setLocale('pl');\n        $locale = $request->getLocale();\n        $this->assertEquals('pl', $locale);\n    }\n\n    public function testGetUser()\n    {\n        $request = Request::create('http://user:password@test.com');\n        $user = $request->getUser();\n\n        $this->assertEquals('user', $user);\n    }\n\n    public function testGetPassword()\n    {\n        $request = Request::create('http://user:password@test.com');\n        $password = $request->getPassword();\n\n        $this->assertEquals('password', $password);\n    }\n\n    public function testIsNoCache()\n    {\n        $request = new Request();\n        $isNoCache = $request->isNoCache();\n\n        $this->assertFalse($isNoCache);\n    }\n\n    public function testGetContentType()\n    {\n        $request = new Request();\n        $contentType = $request->getContentType();\n\n        $this->assertNull($contentType);\n    }\n\n    public function testSetDefaultLocale()\n    {\n        $request = new Request();\n        $request->setDefaultLocale('pl');\n        $locale = $request->getLocale();\n\n        $this->assertEquals('pl', $locale);\n    }\n\n    public function testCreate()\n    {\n        $request = Request::create('http://test.com/foo?bar=baz');\n        $this->assertEquals('http://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com/foo', 'GET', array('bar' => 'baz'));\n        $this->assertEquals('http://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com/foo?bar=foo', 'GET', array('bar' => 'baz'));\n        $this->assertEquals('http://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('https://test.com/foo?bar=baz');\n        $this->assertEquals('https://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('test.com:90/foo');\n        $this->assertEquals('http://test.com:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('test.com', $request->getHost());\n        $this->assertEquals('test.com:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('https://test.com:90/foo');\n        $this->assertEquals('https://test.com:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('test.com', $request->getHost());\n        $this->assertEquals('test.com:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('https://127.0.0.1:90/foo');\n        $this->assertEquals('https://127.0.0.1:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('127.0.0.1', $request->getHost());\n        $this->assertEquals('127.0.0.1:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('https://[::1]:90/foo');\n        $this->assertEquals('https://[::1]:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('[::1]', $request->getHost());\n        $this->assertEquals('[::1]:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('https://[::1]/foo');\n        $this->assertEquals('https://[::1]/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('[::1]', $request->getHost());\n        $this->assertEquals('[::1]', $request->getHttpHost());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $json = '{\"jsonrpc\":\"2.0\",\"method\":\"echo\",\"id\":7,\"params\":[\"Hello World\"]}';\n        $request = Request::create('http://example.com/jsonrpc', 'POST', array(), array(), array(), array(), $json);\n        $this->assertEquals($json, $request->getContent());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com');\n        $this->assertEquals('http://test.com/', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com?test=1');\n        $this->assertEquals('http://test.com/?test=1', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('test=1', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com:90/?test=1');\n        $this->assertEquals('http://test.com:90/?test=1', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('test=1', $request->getQueryString());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertEquals('test.com:90', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://username:password@test.com');\n        $this->assertEquals('http://test.com/', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertEquals('username', $request->getUser());\n        $this->assertEquals('password', $request->getPassword());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://username@test.com');\n        $this->assertEquals('http://test.com/', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertEquals('username', $request->getUser());\n        $this->assertSame('', $request->getPassword());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com/?foo');\n        $this->assertEquals('/?foo', $request->getRequestUri());\n        $this->assertEquals(array('foo' => ''), $request->query->all());\n\n        // assume rewrite rule: (.*) --> app/app.php; app/ is a symlink to a symfony web/ directory\n        $request = Request::create('http://test.com/apparthotel-1234', 'GET', array(), array(), array(),\n            array(\n                'DOCUMENT_ROOT' => '/var/www/www.test.com',\n                'SCRIPT_FILENAME' => '/var/www/www.test.com/app/app.php',\n                'SCRIPT_NAME' => '/app/app.php',\n                'PHP_SELF' => '/app/app.php/apparthotel-1234',\n            ));\n        $this->assertEquals('http://test.com/apparthotel-1234', $request->getUri());\n        $this->assertEquals('/apparthotel-1234', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n    }\n\n    public function testCreateCheckPrecedence()\n    {\n        // server is used by default\n        $request = Request::create('/', 'DELETE', array(), array(), array(), array(\n            'HTTP_HOST' => 'example.com',\n            'HTTPS' => 'on',\n            'SERVER_PORT' => 443,\n            'PHP_AUTH_USER' => 'fabien',\n            'PHP_AUTH_PW' => 'pa$$',\n            'QUERY_STRING' => 'foo=bar',\n            'CONTENT_TYPE' => 'application/json',\n        ));\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertTrue($request->isSecure());\n        $this->assertEquals('fabien', $request->getUser());\n        $this->assertEquals('pa$$', $request->getPassword());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals('application/json', $request->headers->get('CONTENT_TYPE'));\n\n        // URI has precedence over server\n        $request = Request::create('http://thomas:pokemon@example.net:8080/?foo=bar', 'GET', array(), array(), array(), array(\n            'HTTP_HOST' => 'example.com',\n            'HTTPS' => 'on',\n            'SERVER_PORT' => 443,\n        ));\n        $this->assertEquals('example.net', $request->getHost());\n        $this->assertEquals(8080, $request->getPort());\n        $this->assertFalse($request->isSecure());\n        $this->assertEquals('thomas', $request->getUser());\n        $this->assertEquals('pokemon', $request->getPassword());\n        $this->assertEquals('foo=bar', $request->getQueryString());\n    }\n\n    public function testDuplicate()\n    {\n        $request = new Request(array('foo' => 'bar'), array('foo' => 'bar'), array('foo' => 'bar'), array(), array(), array('HTTP_FOO' => 'bar'));\n        $dup = $request->duplicate();\n\n        $this->assertEquals($request->query->all(), $dup->query->all(), '->duplicate() duplicates a request an copy the current query parameters');\n        $this->assertEquals($request->request->all(), $dup->request->all(), '->duplicate() duplicates a request an copy the current request parameters');\n        $this->assertEquals($request->attributes->all(), $dup->attributes->all(), '->duplicate() duplicates a request an copy the current attributes');\n        $this->assertEquals($request->headers->all(), $dup->headers->all(), '->duplicate() duplicates a request an copy the current HTTP headers');\n\n        $dup = $request->duplicate(array('foo' => 'foobar'), array('foo' => 'foobar'), array('foo' => 'foobar'), array(), array(), array('HTTP_FOO' => 'foobar'));\n\n        $this->assertEquals(array('foo' => 'foobar'), $dup->query->all(), '->duplicate() overrides the query parameters if provided');\n        $this->assertEquals(array('foo' => 'foobar'), $dup->request->all(), '->duplicate() overrides the request parameters if provided');\n        $this->assertEquals(array('foo' => 'foobar'), $dup->attributes->all(), '->duplicate() overrides the attributes if provided');\n        $this->assertEquals(array('foo' => array('foobar')), $dup->headers->all(), '->duplicate() overrides the HTTP header if provided');\n    }\n\n    public function testDuplicateWithFormat()\n    {\n        $request = new Request(array(), array(), array('_format' => 'json'));\n        $dup = $request->duplicate();\n\n        $this->assertEquals('json', $dup->getRequestFormat());\n        $this->assertEquals('json', $dup->attributes->get('_format'));\n\n        $request = new Request();\n        $request->setRequestFormat('xml');\n        $dup = $request->duplicate();\n\n        $this->assertEquals('xml', $dup->getRequestFormat());\n    }\n\n    /**\n     * @dataProvider getFormatToMimeTypeMapProvider\n     */\n    public function testGetFormatFromMimeType($format, $mimeTypes)\n    {\n        $request = new Request();\n        foreach ($mimeTypes as $mime) {\n            $this->assertEquals($format, $request->getFormat($mime));\n        }\n        $request->setFormat($format, $mimeTypes);\n        foreach ($mimeTypes as $mime) {\n            $this->assertEquals($format, $request->getFormat($mime));\n\n            if (null !== $format) {\n                $this->assertEquals($mimeTypes[0], $request->getMimeType($format));\n            }\n        }\n    }\n\n    public function testGetFormatFromMimeTypeWithParameters()\n    {\n        $request = new Request();\n        $this->assertEquals('json', $request->getFormat('application/json; charset=utf-8'));\n    }\n\n    public function testGetFormatWithCustomMimeType()\n    {\n        $request = new Request();\n        $request->setFormat('custom', 'application/vnd.foo.api;myversion=2.3');\n        $this->assertEquals('custom', $request->getFormat('application/vnd.foo.api;myversion=2.3'));\n    }\n\n    public function getFormatToMimeTypeMapProvider()\n    {\n        return array(\n            array(null, array(null, 'unexistent-mime-type')),\n            array('txt', array('text/plain')),\n            array('js', array('application/javascript', 'application/x-javascript', 'text/javascript')),\n            array('css', array('text/css')),\n            array('json', array('application/json', 'application/x-json')),\n            array('jsonld', array('application/ld+json')),\n            array('xml', array('text/xml', 'application/xml', 'application/x-xml')),\n            array('rdf', array('application/rdf+xml')),\n            array('atom', array('application/atom+xml')),\n        );\n    }\n\n    public function testGetUri()\n    {\n        $server = array();\n\n        // Standard Request on non default PORT\n        // http://host:8080/index.php/path/info?query=string\n\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/index.php/path/info?query=string';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PATH_INFO'] = '/path/info';\n        $server['PATH_TRANSLATED'] = 'redirect:/index.php/path/info';\n        $server['PHP_SELF'] = '/index_dev.php/path/info';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request = new Request();\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host:8080/index.php/path/info?query=string', $request->getUri(), '->getUri() with non default port');\n\n        // Use std port number\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/index.php/path/info?query=string', $request->getUri(), '->getUri() with default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/index.php/path/info?query=string', $request->getUri(), '->getUri() with default port without HOST_HEADER');\n\n        // Request with URL REWRITING (hide index.php)\n        //   RewriteCond %{REQUEST_FILENAME} !-f\n        //   RewriteRule ^(.*)$ index.php [QSA,L]\n        // http://host:8080/path/info?query=string\n        $server = array();\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['REDIRECT_QUERY_STRING'] = 'query=string';\n        $server['REDIRECT_URL'] = '/path/info';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/path/info?toto=test&1=1';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PHP_SELF'] = '/index.php';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/path/info?query=string', $request->getUri(), '->getUri() with rewrite');\n\n        // Use std port number\n        //  http://host/path/info?query=string\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/path/info?query=string', $request->getUri(), '->getUri() with rewrite and default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/path/info?query=string', $request->getUri(), '->getUri() with rewrite, default port without HOST_HEADER');\n\n        // With encoded characters\n\n        $server = array(\n            'HTTP_HOST' => 'host:8080',\n            'SERVER_NAME' => 'servername',\n            'SERVER_PORT' => '8080',\n            'QUERY_STRING' => 'query=string',\n            'REQUEST_URI' => '/ba%20se/index_dev.php/foo%20bar/in+fo?query=string',\n            'SCRIPT_NAME' => '/ba se/index_dev.php',\n            'PATH_TRANSLATED' => 'redirect:/index.php/foo bar/in+fo',\n            'PHP_SELF' => '/ba se/index_dev.php/path/info',\n            'SCRIPT_FILENAME' => '/some/where/ba se/index_dev.php',\n        );\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals(\n            'http://host:8080/ba%20se/index_dev.php/foo%20bar/in+fo?query=string',\n            $request->getUri()\n        );\n\n        // with user info\n\n        $server['PHP_AUTH_USER'] = 'fabien';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/ba%20se/index_dev.php/foo%20bar/in+fo?query=string', $request->getUri());\n\n        $server['PHP_AUTH_PW'] = 'symfony';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/ba%20se/index_dev.php/foo%20bar/in+fo?query=string', $request->getUri());\n    }\n\n    public function testGetUriForPath()\n    {\n        $request = Request::create('http://test.com/foo?bar=baz');\n        $this->assertEquals('http://test.com/some/path', $request->getUriForPath('/some/path'));\n\n        $request = Request::create('http://test.com:90/foo?bar=baz');\n        $this->assertEquals('http://test.com:90/some/path', $request->getUriForPath('/some/path'));\n\n        $request = Request::create('https://test.com/foo?bar=baz');\n        $this->assertEquals('https://test.com/some/path', $request->getUriForPath('/some/path'));\n\n        $request = Request::create('https://test.com:90/foo?bar=baz');\n        $this->assertEquals('https://test.com:90/some/path', $request->getUriForPath('/some/path'));\n\n        $server = array();\n\n        // Standard Request on non default PORT\n        // http://host:8080/index.php/path/info?query=string\n\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/index.php/path/info?query=string';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PATH_INFO'] = '/path/info';\n        $server['PATH_TRANSLATED'] = 'redirect:/index.php/path/info';\n        $server['PHP_SELF'] = '/index_dev.php/path/info';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request = new Request();\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host:8080/index.php/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with non default port');\n\n        // Use std port number\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/index.php/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/index.php/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with default port without HOST_HEADER');\n\n        // Request with URL REWRITING (hide index.php)\n        //   RewriteCond %{REQUEST_FILENAME} !-f\n        //   RewriteRule ^(.*)$ index.php [QSA,L]\n        // http://host:8080/path/info?query=string\n        $server = array();\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['REDIRECT_QUERY_STRING'] = 'query=string';\n        $server['REDIRECT_URL'] = '/path/info';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/path/info?toto=test&1=1';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PHP_SELF'] = '/index.php';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/some/path', $request->getUriForPath('/some/path'), '->getUri() with rewrite');\n\n        // Use std port number\n        //  http://host/path/info?query=string\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with rewrite and default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with rewrite, default port without HOST_HEADER');\n        $this->assertEquals('servername', $request->getHttpHost());\n\n        // with user info\n\n        $server['PHP_AUTH_USER'] = 'fabien';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername/some/path', $request->getUriForPath('/some/path'));\n\n        $server['PHP_AUTH_PW'] = 'symfony';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername/some/path', $request->getUriForPath('/some/path'));\n    }\n\n    /**\n     * @dataProvider getRelativeUriForPathData()\n     */\n    public function testGetRelativeUriForPath($expected, $pathinfo, $path)\n    {\n        $this->assertEquals($expected, Request::create($pathinfo)->getRelativeUriForPath($path));\n    }\n\n    public function getRelativeUriForPathData()\n    {\n        return array(\n            array('me.png', '/foo', '/me.png'),\n            array('../me.png', '/foo/bar', '/me.png'),\n            array('me.png', '/foo/bar', '/foo/me.png'),\n            array('../baz/me.png', '/foo/bar/b', '/foo/baz/me.png'),\n            array('../../fooz/baz/me.png', '/foo/bar/b', '/fooz/baz/me.png'),\n            array('baz/me.png', '/foo/bar/b', 'baz/me.png'),\n        );\n    }\n\n    public function testGetUserInfo()\n    {\n        $request = new Request();\n\n        $server = array('PHP_AUTH_USER' => 'fabien');\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('fabien', $request->getUserInfo());\n\n        $server['PHP_AUTH_USER'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('0', $request->getUserInfo());\n\n        $server['PHP_AUTH_PW'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('0:0', $request->getUserInfo());\n    }\n\n    public function testGetSchemeAndHttpHost()\n    {\n        $request = new Request();\n\n        $server = array();\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '90';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n\n        $server['PHP_AUTH_USER'] = 'fabien';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n\n        $server['PHP_AUTH_USER'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n\n        $server['PHP_AUTH_PW'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n    }\n\n    /**\n     * @dataProvider getQueryStringNormalizationData\n     */\n    public function testGetQueryString($query, $expectedQuery, $msg)\n    {\n        $request = new Request();\n\n        $request->server->set('QUERY_STRING', $query);\n        $this->assertSame($expectedQuery, $request->getQueryString(), $msg);\n    }\n\n    public function getQueryStringNormalizationData()\n    {\n        return array(\n            array('foo', 'foo', 'works with valueless parameters'),\n            array('foo=', 'foo=', 'includes a dangling equal sign'),\n            array('bar=&foo=bar', 'bar=&foo=bar', '->works with empty parameters'),\n            array('foo=bar&bar=', 'bar=&foo=bar', 'sorts keys alphabetically'),\n\n            // GET parameters, that are submitted from a HTML form, encode spaces as \"+\" by default (as defined in enctype application/x-www-form-urlencoded).\n            // PHP also converts \"+\" to spaces when filling the global _GET or when using the function parse_str.\n            array('him=John%20Doe&her=Jane+Doe', 'her=Jane%20Doe&him=John%20Doe', 'normalizes spaces in both encodings \"%20\" and \"+\"'),\n\n            array('foo[]=1&foo[]=2', 'foo%5B%5D=1&foo%5B%5D=2', 'allows array notation'),\n            array('foo=1&foo=2', 'foo=1&foo=2', 'allows repeated parameters'),\n            array('pa%3Dram=foo%26bar%3Dbaz&test=test', 'pa%3Dram=foo%26bar%3Dbaz&test=test', 'works with encoded delimiters'),\n            array('0', '0', 'allows \"0\"'),\n            array('Jane Doe&John%20Doe', 'Jane%20Doe&John%20Doe', 'normalizes encoding in keys'),\n            array('her=Jane Doe&him=John%20Doe', 'her=Jane%20Doe&him=John%20Doe', 'normalizes encoding in values'),\n            array('foo=bar&&&test&&', 'foo=bar&test', 'removes unneeded delimiters'),\n            array('formula=e=m*c^2', 'formula=e%3Dm%2Ac%5E2', 'correctly treats only the first \"=\" as delimiter and the next as value'),\n\n            // Ignore pairs with empty key, even if there was a value, e.g. \"=value\", as such nameless values cannot be retrieved anyway.\n            // PHP also does not include them when building _GET.\n            array('foo=bar&=a=b&=x=y', 'foo=bar', 'removes params with empty key'),\n        );\n    }\n\n    public function testGetQueryStringReturnsNull()\n    {\n        $request = new Request();\n\n        $this->assertNull($request->getQueryString(), '->getQueryString() returns null for non-existent query string');\n\n        $request->server->set('QUERY_STRING', '');\n        $this->assertNull($request->getQueryString(), '->getQueryString() returns null for empty query string');\n    }\n\n    public function testGetHost()\n    {\n        $request = new Request();\n\n        $request->initialize(array('foo' => 'bar'));\n        $this->assertEquals('', $request->getHost(), '->getHost() return empty string if not initialized');\n\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_HOST' => 'www.example.com'));\n        $this->assertEquals('www.example.com', $request->getHost(), '->getHost() from Host Header');\n\n        // Host header with port number\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_HOST' => 'www.example.com:8080'));\n        $this->assertEquals('www.example.com', $request->getHost(), '->getHost() from Host Header with port number');\n\n        // Server values\n        $request->initialize(array(), array(), array(), array(), array(), array('SERVER_NAME' => 'www.example.com'));\n        $this->assertEquals('www.example.com', $request->getHost(), '->getHost() from server name');\n\n        $request->initialize(array(), array(), array(), array(), array(), array('SERVER_NAME' => 'www.example.com', 'HTTP_HOST' => 'www.host.com'));\n        $this->assertEquals('www.host.com', $request->getHost(), '->getHost() value from Host header has priority over SERVER_NAME ');\n    }\n\n    public function testGetPort()\n    {\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'https',\n            'HTTP_X_FORWARDED_PORT' => '443',\n        ));\n        $port = $request->getPort();\n\n        $this->assertEquals(80, $port, 'Without trusted proxies FORWARDED_PROTO and FORWARDED_PORT are ignored.');\n\n        Request::setTrustedProxies(array('1.1.1.1'));\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'https',\n            'HTTP_X_FORWARDED_PORT' => '8443',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With PROTO and PORT on untrusted connection server value takes precedence.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(8443, $request->getPort(), 'With PROTO and PORT set PORT takes precedence.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'https',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With only PROTO set getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(443, $request->getPort(), 'With only PROTO set getPort() defaults to 443.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'http',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'If X_FORWARDED_PROTO is set to HTTP getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(80, $request->getPort(), 'If X_FORWARDED_PROTO is set to HTTP getPort() returns port of the original request.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'On',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With only PROTO set and value is On, getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(443, $request->getPort(), 'With only PROTO set and value is On, getPort() defaults to 443.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => '1',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With only PROTO set and value is 1, getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(443, $request->getPort(), 'With only PROTO set and value is 1, getPort() defaults to 443.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'something-else',\n        ));\n        $port = $request->getPort();\n        $this->assertEquals(80, $port, 'With only PROTO set and value is not recognized, getPort() defaults to 80.');\n    }\n\n    /**\n     * @expectedException \\RuntimeException\n     */\n    public function testGetHostWithFakeHttpHostValue()\n    {\n        $request = new Request();\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_HOST' => 'www.host.com?query=string'));\n        $request->getHost();\n    }\n\n    public function testGetSetMethod()\n    {\n        $request = new Request();\n\n        $this->assertEquals('GET', $request->getMethod(), '->getMethod() returns GET if no method is defined');\n\n        $request->setMethod('get');\n        $this->assertEquals('GET', $request->getMethod(), '->getMethod() returns an uppercased string');\n\n        $request->setMethod('PURGE');\n        $this->assertEquals('PURGE', $request->getMethod(), '->getMethod() returns the method even if it is not a standard one');\n\n        $request->setMethod('POST');\n        $this->assertEquals('POST', $request->getMethod(), '->getMethod() returns the method POST if no _method is defined');\n\n        $request->setMethod('POST');\n        $request->request->set('_method', 'purge');\n        $this->assertEquals('POST', $request->getMethod(), '->getMethod() does not return the method from _method if defined and POST but support not enabled');\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->request->set('_method', 'purge');\n\n        $this->assertFalse(Request::getHttpMethodParameterOverride(), 'httpMethodParameterOverride should be disabled by default');\n\n        Request::enableHttpMethodParameterOverride();\n\n        $this->assertTrue(Request::getHttpMethodParameterOverride(), 'httpMethodParameterOverride should be enabled now but it is not');\n\n        $this->assertEquals('PURGE', $request->getMethod(), '->getMethod() returns the method from _method if defined and POST');\n        $this->disableHttpMethodParameterOverride();\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->query->set('_method', 'purge');\n        $this->assertEquals('POST', $request->getMethod(), '->getMethod() does not return the method from _method if defined and POST but support not enabled');\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->query->set('_method', 'purge');\n        Request::enableHttpMethodParameterOverride();\n        $this->assertEquals('PURGE', $request->getMethod(), '->getMethod() returns the method from _method if defined and POST');\n        $this->disableHttpMethodParameterOverride();\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->headers->set('X-HTTP-METHOD-OVERRIDE', 'delete');\n        $this->assertEquals('DELETE', $request->getMethod(), '->getMethod() returns the method from X-HTTP-Method-Override even though _method is set if defined and POST');\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->headers->set('X-HTTP-METHOD-OVERRIDE', 'delete');\n        $this->assertEquals('DELETE', $request->getMethod(), '->getMethod() returns the method from X-HTTP-Method-Override if defined and POST');\n    }\n\n    /**\n     * @dataProvider getClientIpsProvider\n     */\n    public function testGetClientIp($expected, $remoteAddr, $httpForwardedFor, $trustedProxies)\n    {\n        $request = $this->getRequestInstanceForClientIpTests($remoteAddr, $httpForwardedFor, $trustedProxies);\n\n        $this->assertEquals($expected[0], $request->getClientIp());\n    }\n\n    /**\n     * @dataProvider getClientIpsProvider\n     */\n    public function testGetClientIps($expected, $remoteAddr, $httpForwardedFor, $trustedProxies)\n    {\n        $request = $this->getRequestInstanceForClientIpTests($remoteAddr, $httpForwardedFor, $trustedProxies);\n\n        $this->assertEquals($expected, $request->getClientIps());\n    }\n\n    /**\n     * @dataProvider getClientIpsForwardedProvider\n     */\n    public function testGetClientIpsForwarded($expected, $remoteAddr, $httpForwarded, $trustedProxies)\n    {\n        $request = $this->getRequestInstanceForClientIpsForwardedTests($remoteAddr, $httpForwarded, $trustedProxies);\n\n        $this->assertEquals($expected, $request->getClientIps());\n    }\n\n    public function getClientIpsForwardedProvider()\n    {\n        //              $expected                                  $remoteAddr  $httpForwarded                                       $trustedProxies\n        return array(\n            array(array('127.0.0.1'),                              '127.0.0.1', 'for=\"_gazonk\"',                                      null),\n            array(array('127.0.0.1'),                              '127.0.0.1', 'for=\"_gazonk\"',                                      array('127.0.0.1')),\n            array(array('88.88.88.88'),                            '127.0.0.1', 'for=\"88.88.88.88:80\"',                               array('127.0.0.1')),\n            array(array('192.0.2.60'),                             '::1',       'for=192.0.2.60;proto=http;by=203.0.113.43',          array('::1')),\n            array(array('2620:0:1cfe:face:b00c::3', '192.0.2.43'), '::1',       'for=192.0.2.43, for=2620:0:1cfe:face:b00c::3',       array('::1')),\n            array(array('2001:db8:cafe::17'),                      '::1',       'for=\"[2001:db8:cafe::17]:4711',                      array('::1')),\n        );\n    }\n\n    public function getClientIpsProvider()\n    {\n        //        $expected                   $remoteAddr                $httpForwardedFor            $trustedProxies\n        return array(\n            // simple IPv4\n            array(array('88.88.88.88'),              '88.88.88.88',              null,                        null),\n            // trust the IPv4 remote addr\n            array(array('88.88.88.88'),              '88.88.88.88',              null,                        array('88.88.88.88')),\n\n            // simple IPv6\n            array(array('::1'),                      '::1',                      null,                        null),\n            // trust the IPv6 remote addr\n            array(array('::1'),                      '::1',                      null,                        array('::1')),\n\n            // forwarded for with remote IPv4 addr not trusted\n            array(array('127.0.0.1'),                '127.0.0.1',                '88.88.88.88',               null),\n            // forwarded for with remote IPv4 addr trusted\n            array(array('88.88.88.88'),              '127.0.0.1',                '88.88.88.88',               array('127.0.0.1')),\n            // forwarded for with remote IPv4 and all FF addrs trusted\n            array(array('88.88.88.88'),              '127.0.0.1',                '88.88.88.88',               array('127.0.0.1', '88.88.88.88')),\n            // forwarded for with remote IPv4 range trusted\n            array(array('88.88.88.88'),              '123.45.67.89',             '88.88.88.88',               array('123.45.67.0/24')),\n\n            // forwarded for with remote IPv6 addr not trusted\n            array(array('1620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '2620:0:1cfe:face:b00c::3',  null),\n            // forwarded for with remote IPv6 addr trusted\n            array(array('2620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '2620:0:1cfe:face:b00c::3',  array('1620:0:1cfe:face:b00c::3')),\n            // forwarded for with remote IPv6 range trusted\n            array(array('88.88.88.88'),              '2a01:198:603:0:396e:4789:8e99:890f', '88.88.88.88',     array('2a01:198:603:0::/65')),\n\n            // multiple forwarded for with remote IPv4 addr trusted\n            array(array('88.88.88.88', '87.65.43.21', '127.0.0.1'), '123.45.67.89', '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89')),\n            // multiple forwarded for with remote IPv4 addr and some reverse proxies trusted\n            array(array('87.65.43.21', '127.0.0.1'), '123.45.67.89',             '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89', '88.88.88.88')),\n            // multiple forwarded for with remote IPv4 addr and some reverse proxies trusted but in the middle\n            array(array('88.88.88.88', '127.0.0.1'), '123.45.67.89',             '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89', '87.65.43.21')),\n            // multiple forwarded for with remote IPv4 addr and all reverse proxies trusted\n            array(array('127.0.0.1'),                '123.45.67.89',             '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89', '87.65.43.21', '88.88.88.88', '127.0.0.1')),\n\n            // multiple forwarded for with remote IPv6 addr trusted\n            array(array('2620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3,2620:0:1cfe:face:b00c::3', array('1620:0:1cfe:face:b00c::3')),\n            // multiple forwarded for with remote IPv6 addr and some reverse proxies trusted\n            array(array('3620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3,2620:0:1cfe:face:b00c::3', array('1620:0:1cfe:face:b00c::3', '2620:0:1cfe:face:b00c::3')),\n            // multiple forwarded for with remote IPv4 addr and some reverse proxies trusted but in the middle\n            array(array('2620:0:1cfe:face:b00c::3', '4620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '4620:0:1cfe:face:b00c::3,3620:0:1cfe:face:b00c::3,2620:0:1cfe:face:b00c::3', array('1620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3')),\n\n            // client IP with port\n            array(array('88.88.88.88'), '127.0.0.1', '88.88.88.88:12345, 127.0.0.1', array('127.0.0.1')),\n\n            // invalid forwarded IP is ignored\n            array(array('88.88.88.88'), '127.0.0.1', 'unknown,88.88.88.88', array('127.0.0.1')),\n            array(array('88.88.88.88'), '127.0.0.1', '}__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:{s:2,88.88.88.88', array('127.0.0.1')),\n        );\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException\n     * @dataProvider getClientIpsWithConflictingHeadersProvider\n     */\n    public function testGetClientIpsWithConflictingHeaders($httpForwarded, $httpXForwardedFor)\n    {\n        $request = new Request();\n\n        $server = array(\n            'REMOTE_ADDR' => '88.88.88.88',\n            'HTTP_FORWARDED' => $httpForwarded,\n            'HTTP_X_FORWARDED_FOR' => $httpXForwardedFor,\n        );\n\n        Request::setTrustedProxies(array('88.88.88.88'));\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $request->getClientIps();\n    }\n\n    public function getClientIpsWithConflictingHeadersProvider()\n    {\n        //        $httpForwarded                   $httpXForwardedFor\n        return array(\n            array('for=87.65.43.21',                 '192.0.2.60'),\n            array('for=87.65.43.21, for=192.0.2.60', '192.0.2.60'),\n            array('for=192.0.2.60',                  '192.0.2.60,87.65.43.21'),\n            array('for=\"::face\", for=192.0.2.60',    '192.0.2.60,192.0.2.43'),\n            array('for=87.65.43.21, for=192.0.2.60', '192.0.2.60,87.65.43.21'),\n        );\n    }\n\n    /**\n     * @dataProvider getClientIpsWithAgreeingHeadersProvider\n     */\n    public function testGetClientIpsWithAgreeingHeaders($httpForwarded, $httpXForwardedFor, $expectedIps)\n    {\n        $request = new Request();\n\n        $server = array(\n            'REMOTE_ADDR' => '88.88.88.88',\n            'HTTP_FORWARDED' => $httpForwarded,\n            'HTTP_X_FORWARDED_FOR' => $httpXForwardedFor,\n        );\n\n        Request::setTrustedProxies(array('88.88.88.88'));\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $clientIps = $request->getClientIps();\n\n        $this->assertSame($expectedIps, $clientIps);\n    }\n\n    public function getClientIpsWithAgreeingHeadersProvider()\n    {\n        //        $httpForwarded                               $httpXForwardedFor\n        return array(\n            array('for=\"192.0.2.60\"',                          '192.0.2.60',             array('192.0.2.60')),\n            array('for=192.0.2.60, for=87.65.43.21',           '192.0.2.60,87.65.43.21', array('87.65.43.21', '192.0.2.60')),\n            array('for=\"[::face]\", for=192.0.2.60',            '::face,192.0.2.60',      array('192.0.2.60', '::face')),\n            array('for=\"192.0.2.60:80\"',                       '192.0.2.60',             array('192.0.2.60')),\n            array('for=192.0.2.60;proto=http;by=203.0.113.43', '192.0.2.60',             array('192.0.2.60')),\n            array('for=\"[2001:db8:cafe::17]:4711\"',            '2001:db8:cafe::17',      array('2001:db8:cafe::17')),\n        );\n    }\n\n    public function testGetContentWorksTwiceInDefaultMode()\n    {\n        $req = new Request();\n        $this->assertEquals('', $req->getContent());\n        $this->assertEquals('', $req->getContent());\n    }\n\n    public function testGetContentReturnsResource()\n    {\n        $req = new Request();\n        $retval = $req->getContent(true);\n        $this->assertInternalType('resource', $retval);\n        $this->assertEquals('', fread($retval, 1));\n        $this->assertTrue(feof($retval));\n    }\n\n    public function testGetContentReturnsResourceWhenContentSetInConstructor()\n    {\n        $req = new Request(array(), array(), array(), array(), array(), array(), 'MyContent');\n        $resource = $req->getContent(true);\n\n        $this->assertInternalType('resource', $resource);\n        $this->assertEquals('MyContent', stream_get_contents($resource));\n    }\n\n    public function testContentAsResource()\n    {\n        $resource = fopen('php://memory', 'r+');\n        fwrite($resource, 'My other content');\n        rewind($resource);\n\n        $req = new Request(array(), array(), array(), array(), array(), array(), $resource);\n        $this->assertEquals('My other content', stream_get_contents($req->getContent(true)));\n        $this->assertEquals('My other content', $req->getContent());\n    }\n\n    /**\n     * @expectedException \\LogicException\n     * @dataProvider getContentCantBeCalledTwiceWithResourcesProvider\n     */\n    public function testGetContentCantBeCalledTwiceWithResources($first, $second)\n    {\n        if (\\PHP_VERSION_ID >= 50600) {\n            $this->markTestSkipped('PHP >= 5.6 allows to open php://input several times.');\n        }\n\n        $req = new Request();\n        $req->getContent($first);\n        $req->getContent($second);\n    }\n\n    public function getContentCantBeCalledTwiceWithResourcesProvider()\n    {\n        return array(\n            'Resource then fetch' => array(true, false),\n            'Resource then resource' => array(true, true),\n        );\n    }\n\n    /**\n     * @dataProvider getContentCanBeCalledTwiceWithResourcesProvider\n     * @requires PHP 5.6\n     */\n    public function testGetContentCanBeCalledTwiceWithResources($first, $second)\n    {\n        $req = new Request();\n        $a = $req->getContent($first);\n        $b = $req->getContent($second);\n\n        if ($first) {\n            $a = stream_get_contents($a);\n        }\n\n        if ($second) {\n            $b = stream_get_contents($b);\n        }\n\n        $this->assertSame($a, $b);\n    }\n\n    public function getContentCanBeCalledTwiceWithResourcesProvider()\n    {\n        return array(\n            'Fetch then fetch' => array(false, false),\n            'Fetch then resource' => array(false, true),\n            'Resource then fetch' => array(true, false),\n            'Resource then resource' => array(true, true),\n        );\n    }\n\n    public function provideOverloadedMethods()\n    {\n        return array(\n            array('PUT'),\n            array('DELETE'),\n            array('PATCH'),\n            array('put'),\n            array('delete'),\n            array('patch'),\n        );\n    }\n\n    /**\n     * @dataProvider provideOverloadedMethods\n     */\n    public function testCreateFromGlobals($method)\n    {\n        $normalizedMethod = strtoupper($method);\n\n        $_GET['foo1'] = 'bar1';\n        $_POST['foo2'] = 'bar2';\n        $_COOKIE['foo3'] = 'bar3';\n        $_FILES['foo4'] = array('bar4');\n        $_SERVER['foo5'] = 'bar5';\n\n        $request = Request::createFromGlobals();\n        $this->assertEquals('bar1', $request->query->get('foo1'), '::fromGlobals() uses values from $_GET');\n        $this->assertEquals('bar2', $request->request->get('foo2'), '::fromGlobals() uses values from $_POST');\n        $this->assertEquals('bar3', $request->cookies->get('foo3'), '::fromGlobals() uses values from $_COOKIE');\n        $this->assertEquals(array('bar4'), $request->files->get('foo4'), '::fromGlobals() uses values from $_FILES');\n        $this->assertEquals('bar5', $request->server->get('foo5'), '::fromGlobals() uses values from $_SERVER');\n\n        unset($_GET['foo1'], $_POST['foo2'], $_COOKIE['foo3'], $_FILES['foo4'], $_SERVER['foo5']);\n\n        $_SERVER['REQUEST_METHOD'] = $method;\n        $_SERVER['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n        $request = RequestContentProxy::createFromGlobals();\n        $this->assertEquals($normalizedMethod, $request->getMethod());\n        $this->assertEquals('mycontent', $request->request->get('content'));\n\n        unset($_SERVER['REQUEST_METHOD'], $_SERVER['CONTENT_TYPE']);\n\n        Request::createFromGlobals();\n        Request::enableHttpMethodParameterOverride();\n        $_POST['_method'] = $method;\n        $_POST['foo6'] = 'bar6';\n        $_SERVER['REQUEST_METHOD'] = 'PoSt';\n        $request = Request::createFromGlobals();\n        $this->assertEquals($normalizedMethod, $request->getMethod());\n        $this->assertEquals('POST', $request->getRealMethod());\n        $this->assertEquals('bar6', $request->request->get('foo6'));\n\n        unset($_POST['_method'], $_POST['foo6'], $_SERVER['REQUEST_METHOD']);\n        $this->disableHttpMethodParameterOverride();\n    }\n\n    public function testOverrideGlobals()\n    {\n        $request = new Request();\n        $request->initialize(array('foo' => 'bar'));\n\n        // as the Request::overrideGlobals really work, it erase $_SERVER, so we must backup it\n        $server = $_SERVER;\n\n        $request->overrideGlobals();\n\n        $this->assertEquals(array('foo' => 'bar'), $_GET);\n\n        $request->initialize(array(), array('foo' => 'bar'));\n        $request->overrideGlobals();\n\n        $this->assertEquals(array('foo' => 'bar'), $_POST);\n\n        $this->assertArrayNotHasKey('HTTP_X_FORWARDED_PROTO', $_SERVER);\n\n        $request->headers->set('X_FORWARDED_PROTO', 'https');\n\n        Request::setTrustedProxies(array('1.1.1.1'));\n        $this->assertFalse($request->isSecure());\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertTrue($request->isSecure());\n        Request::setTrustedProxies(array());\n\n        $request->overrideGlobals();\n\n        $this->assertArrayHasKey('HTTP_X_FORWARDED_PROTO', $_SERVER);\n\n        $request->headers->set('CONTENT_TYPE', 'multipart/form-data');\n        $request->headers->set('CONTENT_LENGTH', 12345);\n\n        $request->overrideGlobals();\n\n        $this->assertArrayHasKey('CONTENT_TYPE', $_SERVER);\n        $this->assertArrayHasKey('CONTENT_LENGTH', $_SERVER);\n\n        $request->initialize(array('foo' => 'bar', 'baz' => 'foo'));\n        $request->query->remove('baz');\n\n        $request->overrideGlobals();\n\n        $this->assertEquals(array('foo' => 'bar'), $_GET);\n        $this->assertEquals('foo=bar', $_SERVER['QUERY_STRING']);\n        $this->assertEquals('foo=bar', $request->server->get('QUERY_STRING'));\n\n        // restore initial $_SERVER array\n        $_SERVER = $server;\n    }\n\n    public function testGetScriptName()\n    {\n        $request = new Request();\n        $this->assertEquals('', $request->getScriptName());\n\n        $server = array();\n        $server['SCRIPT_NAME'] = '/index.php';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/index.php', $request->getScriptName());\n\n        $server = array();\n        $server['ORIG_SCRIPT_NAME'] = '/frontend.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/frontend.php', $request->getScriptName());\n\n        $server = array();\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['ORIG_SCRIPT_NAME'] = '/frontend.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/index.php', $request->getScriptName());\n    }\n\n    public function testGetBasePath()\n    {\n        $request = new Request();\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $server['PHP_SELF'] = '/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $server['ORIG_SCRIPT_NAME'] = '/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('', $request->getBasePath());\n    }\n\n    public function testGetPathInfo()\n    {\n        $request = new Request();\n        $this->assertEquals('/', $request->getPathInfo());\n\n        $server = array();\n        $server['REQUEST_URI'] = '/path/info';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/path/info', $request->getPathInfo());\n\n        $server = array();\n        $server['REQUEST_URI'] = '/path%20test/info';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/path%20test/info', $request->getPathInfo());\n\n        $server = array();\n        $server['REQUEST_URI'] = '?a=b';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/', $request->getPathInfo());\n    }\n\n    public function testGetPreferredLanguage()\n    {\n        $request = new Request();\n        $this->assertNull($request->getPreferredLanguage());\n        $this->assertNull($request->getPreferredLanguage(array()));\n        $this->assertEquals('fr', $request->getPreferredLanguage(array('fr')));\n        $this->assertEquals('fr', $request->getPreferredLanguage(array('fr', 'en')));\n        $this->assertEquals('en', $request->getPreferredLanguage(array('en', 'fr')));\n        $this->assertEquals('fr-ch', $request->getPreferredLanguage(array('fr-ch', 'fr-fr')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('en', 'en-us')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('fr', 'en')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('fr', 'en')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, fr-fr; q=0.6, fr; q=0.5');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('fr', 'en')));\n    }\n\n    public function testIsXmlHttpRequest()\n    {\n        $request = new Request();\n        $this->assertFalse($request->isXmlHttpRequest());\n\n        $request->headers->set('X-Requested-With', 'XMLHttpRequest');\n        $this->assertTrue($request->isXmlHttpRequest());\n\n        $request->headers->remove('X-Requested-With');\n        $this->assertFalse($request->isXmlHttpRequest());\n    }\n\n    /**\n     * @requires extension intl\n     */\n    public function testIntlLocale()\n    {\n        $request = new Request();\n\n        $request->setDefaultLocale('fr');\n        $this->assertEquals('fr', $request->getLocale());\n        $this->assertEquals('fr', \\Locale::getDefault());\n\n        $request->setLocale('en');\n        $this->assertEquals('en', $request->getLocale());\n        $this->assertEquals('en', \\Locale::getDefault());\n\n        $request->setDefaultLocale('de');\n        $this->assertEquals('en', $request->getLocale());\n        $this->assertEquals('en', \\Locale::getDefault());\n    }\n\n    public function testGetCharsets()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getCharsets());\n        $request->headers->set('Accept-Charset', 'ISO-8859-1, US-ASCII, UTF-8; q=0.8, ISO-10646-UCS-2; q=0.6');\n        $this->assertEquals(array(), $request->getCharsets()); // testing caching\n\n        $request = new Request();\n        $request->headers->set('Accept-Charset', 'ISO-8859-1, US-ASCII, UTF-8; q=0.8, ISO-10646-UCS-2; q=0.6');\n        $this->assertEquals(array('ISO-8859-1', 'US-ASCII', 'UTF-8', 'ISO-10646-UCS-2'), $request->getCharsets());\n\n        $request = new Request();\n        $request->headers->set('Accept-Charset', 'ISO-8859-1,utf-8;q=0.7,*;q=0.7');\n        $this->assertEquals(array('ISO-8859-1', 'utf-8', '*'), $request->getCharsets());\n    }\n\n    public function testGetEncodings()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getEncodings());\n        $request->headers->set('Accept-Encoding', 'gzip,deflate,sdch');\n        $this->assertEquals(array(), $request->getEncodings()); // testing caching\n\n        $request = new Request();\n        $request->headers->set('Accept-Encoding', 'gzip,deflate,sdch');\n        $this->assertEquals(array('gzip', 'deflate', 'sdch'), $request->getEncodings());\n\n        $request = new Request();\n        $request->headers->set('Accept-Encoding', 'gzip;q=0.4,deflate;q=0.9,compress;q=0.7');\n        $this->assertEquals(array('deflate', 'compress', 'gzip'), $request->getEncodings());\n    }\n\n    public function testGetAcceptableContentTypes()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getAcceptableContentTypes());\n        $request->headers->set('Accept', 'application/vnd.wap.wmlscriptc, text/vnd.wap.wml, application/vnd.wap.xhtml+xml, application/xhtml+xml, text/html, multipart/mixed, */*');\n        $this->assertEquals(array(), $request->getAcceptableContentTypes()); // testing caching\n\n        $request = new Request();\n        $request->headers->set('Accept', 'application/vnd.wap.wmlscriptc, text/vnd.wap.wml, application/vnd.wap.xhtml+xml, application/xhtml+xml, text/html, multipart/mixed, */*');\n        $this->assertEquals(array('application/vnd.wap.wmlscriptc', 'text/vnd.wap.wml', 'application/vnd.wap.xhtml+xml', 'application/xhtml+xml', 'text/html', 'multipart/mixed', '*/*'), $request->getAcceptableContentTypes());\n    }\n\n    public function testGetLanguages()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getLanguages());\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $this->assertEquals(array('zh', 'en_US', 'en'), $request->getLanguages());\n        $this->assertEquals(array('zh', 'en_US', 'en'), $request->getLanguages());\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.6, en; q=0.8');\n        $this->assertEquals(array('zh', 'en', 'en_US'), $request->getLanguages()); // Test out of order qvalues\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en, en-us');\n        $this->assertEquals(array('zh', 'en', 'en_US'), $request->getLanguages()); // Test equal weighting without qvalues\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh; q=0.6, en, en-us; q=0.6');\n        $this->assertEquals(array('en', 'zh', 'en_US'), $request->getLanguages()); // Test equal weighting with qvalues\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, i-cherokee; q=0.6');\n        $this->assertEquals(array('zh', 'cherokee'), $request->getLanguages());\n    }\n\n    public function testGetRequestFormat()\n    {\n        $request = new Request();\n        $this->assertEquals('html', $request->getRequestFormat());\n\n        // Ensure that setting different default values over time is possible,\n        // aka. setRequestFormat determines the state.\n        $this->assertEquals('json', $request->getRequestFormat('json'));\n        $this->assertEquals('html', $request->getRequestFormat('html'));\n\n        $request = new Request();\n        $this->assertNull($request->getRequestFormat(null));\n\n        $request = new Request();\n        $this->assertNull($request->setRequestFormat('foo'));\n        $this->assertEquals('foo', $request->getRequestFormat(null));\n    }\n\n    public function testHasSession()\n    {\n        $request = new Request();\n\n        $this->assertFalse($request->hasSession());\n        $request->setSession(new Session(new MockArraySessionStorage()));\n        $this->assertTrue($request->hasSession());\n    }\n\n    public function testGetSession()\n    {\n        $request = new Request();\n\n        $request->setSession(new Session(new MockArraySessionStorage()));\n        $this->assertTrue($request->hasSession());\n\n        $session = $request->getSession();\n        $this->assertObjectHasAttribute('storage', $session);\n        $this->assertObjectHasAttribute('flashName', $session);\n        $this->assertObjectHasAttribute('attributeName', $session);\n    }\n\n    public function testHasPreviousSession()\n    {\n        $request = new Request();\n\n        $this->assertFalse($request->hasPreviousSession());\n        $request->cookies->set('MOCKSESSID', 'foo');\n        $this->assertFalse($request->hasPreviousSession());\n        $request->setSession(new Session(new MockArraySessionStorage()));\n        $this->assertTrue($request->hasPreviousSession());\n    }\n\n    public function testToString()\n    {\n        $request = new Request();\n\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $request->cookies->set('Foo', 'Bar');\n\n        $asString = (string) $request;\n\n        $this->assertContains('Accept-Language: zh, en-us; q=0.8, en; q=0.6', $asString);\n        $this->assertContains('Cookie: Foo=Bar', $asString);\n\n        $request->cookies->set('Another', 'Cookie');\n\n        $asString = (string) $request;\n\n        $this->assertContains('Cookie: Foo=Bar; Another=Cookie', $asString);\n    }\n\n    public function testIsMethod()\n    {\n        $request = new Request();\n        $request->setMethod('POST');\n        $this->assertTrue($request->isMethod('POST'));\n        $this->assertTrue($request->isMethod('post'));\n        $this->assertFalse($request->isMethod('GET'));\n        $this->assertFalse($request->isMethod('get'));\n\n        $request->setMethod('GET');\n        $this->assertTrue($request->isMethod('GET'));\n        $this->assertTrue($request->isMethod('get'));\n        $this->assertFalse($request->isMethod('POST'));\n        $this->assertFalse($request->isMethod('post'));\n    }\n\n    /**\n     * @dataProvider getBaseUrlData\n     */\n    public function testGetBaseUrl($uri, $server, $expectedBaseUrl, $expectedPathInfo)\n    {\n        $request = Request::create($uri, 'GET', array(), array(), array(), $server);\n\n        $this->assertSame($expectedBaseUrl, $request->getBaseUrl(), 'baseUrl');\n        $this->assertSame($expectedPathInfo, $request->getPathInfo(), 'pathInfo');\n    }\n\n    public function getBaseUrlData()\n    {\n        return array(\n            array(\n                '/fruit/strawberry/1234index.php/blah',\n                array(\n                    'SCRIPT_FILENAME' => 'E:/Sites/cc-new/public_html/fruit/index.php',\n                    'SCRIPT_NAME' => '/fruit/index.php',\n                    'PHP_SELF' => '/fruit/index.php',\n                ),\n                '/fruit',\n                '/strawberry/1234index.php/blah',\n            ),\n            array(\n                '/fruit/strawberry/1234index.php/blah',\n                array(\n                    'SCRIPT_FILENAME' => 'E:/Sites/cc-new/public_html/index.php',\n                    'SCRIPT_NAME' => '/index.php',\n                    'PHP_SELF' => '/index.php',\n                ),\n                '',\n                '/fruit/strawberry/1234index.php/blah',\n            ),\n            array(\n                '/foo%20bar/',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar',\n                '/',\n            ),\n            array(\n                '/foo%20bar/home',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar',\n                '/home',\n            ),\n            array(\n                '/foo%20bar/app.php/home',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar/app.php',\n                '/home',\n            ),\n            array(\n                '/foo%20bar/app.php/home%3Dbaz',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar/app.php',\n                '/home%3Dbaz',\n            ),\n            array(\n                '/foo/bar+baz',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo/app.php',\n                    'SCRIPT_NAME' => '/foo/app.php',\n                    'PHP_SELF' => '/foo/app.php',\n                ),\n                '/foo',\n                '/bar+baz',\n            ),\n        );\n    }\n\n    /**\n     * @dataProvider urlencodedStringPrefixData\n     */\n    public function testUrlencodedStringPrefix($string, $prefix, $expect)\n    {\n        $request = new Request();\n\n        $me = new \\ReflectionMethod($request, 'getUrlencodedPrefix');\n        $me->setAccessible(true);\n\n        $this->assertSame($expect, $me->invoke($request, $string, $prefix));\n    }\n\n    public function urlencodedStringPrefixData()\n    {\n        return array(\n            array('foo', 'foo', 'foo'),\n            array('fo%6f', 'foo', 'fo%6f'),\n            array('foo/bar', 'foo', 'foo'),\n            array('fo%6f/bar', 'foo', 'fo%6f'),\n            array('f%6f%6f/bar', 'foo', 'f%6f%6f'),\n            array('%66%6F%6F/bar', 'foo', '%66%6F%6F'),\n            array('fo+o/bar', 'fo+o', 'fo+o'),\n            array('fo%2Bo/bar', 'fo+o', 'fo%2Bo'),\n        );\n    }\n\n    private function disableHttpMethodParameterOverride()\n    {\n        $class = new \\ReflectionClass('Symfony\\\\Component\\\\HttpFoundation\\\\Request');\n        $property = $class->getProperty('httpMethodParameterOverride');\n        $property->setAccessible(true);\n        $property->setValue(false);\n    }\n\n    private function getRequestInstanceForClientIpTests($remoteAddr, $httpForwardedFor, $trustedProxies)\n    {\n        $request = new Request();\n\n        $server = array('REMOTE_ADDR' => $remoteAddr);\n        if (null !== $httpForwardedFor) {\n            $server['HTTP_X_FORWARDED_FOR'] = $httpForwardedFor;\n        }\n\n        if ($trustedProxies) {\n            Request::setTrustedProxies($trustedProxies);\n        }\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        return $request;\n    }\n\n    private function getRequestInstanceForClientIpsForwardedTests($remoteAddr, $httpForwarded, $trustedProxies)\n    {\n        $request = new Request();\n\n        $server = array('REMOTE_ADDR' => $remoteAddr);\n\n        if (null !== $httpForwarded) {\n            $server['HTTP_FORWARDED'] = $httpForwarded;\n        }\n\n        if ($trustedProxies) {\n            Request::setTrustedProxies($trustedProxies);\n        }\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        return $request;\n    }\n\n    public function testTrustedProxiesXForwardedFor()\n    {\n        $request = Request::create('http://example.com/');\n        $request->server->set('REMOTE_ADDR', '3.3.3.3');\n        $request->headers->set('X_FORWARDED_FOR', '1.1.1.1, 2.2.2.2');\n        $request->headers->set('X_FORWARDED_HOST', 'foo.example.com:1234, real.example.com:8080');\n        $request->headers->set('X_FORWARDED_PROTO', 'https');\n        $request->headers->set('X_FORWARDED_PORT', 443);\n        $request->headers->set('X_MY_FOR', '3.3.3.3, 4.4.4.4');\n        $request->headers->set('X_MY_HOST', 'my.example.com');\n        $request->headers->set('X_MY_PROTO', 'http');\n        $request->headers->set('X_MY_PORT', 81);\n\n        // no trusted proxies\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // disabling proxy trusting\n        Request::setTrustedProxies(array());\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // request is forwarded by a non-trusted proxy\n        Request::setTrustedProxies(array('2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $this->assertEquals('1.1.1.1', $request->getClientIp());\n        $this->assertEquals('foo.example.com', $request->getHost());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.4', '2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // check various X_FORWARDED_PROTO header values\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $request->headers->set('X_FORWARDED_PROTO', 'ssl');\n        $this->assertTrue($request->isSecure());\n\n        $request->headers->set('X_FORWARDED_PROTO', 'https, http');\n        $this->assertTrue($request->isSecure());\n\n        // custom header names\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, 'X_MY_FOR');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_HOST, 'X_MY_HOST');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PORT, 'X_MY_PORT');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PROTO, 'X_MY_PROTO');\n        $this->assertEquals('4.4.4.4', $request->getClientIp());\n        $this->assertEquals('my.example.com', $request->getHost());\n        $this->assertEquals(81, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // disabling via empty header names\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, null);\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_HOST, null);\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PORT, null);\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PROTO, null);\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // reset\n        Request::setTrustedProxies(array());\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, 'X_FORWARDED_FOR');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_HOST, 'X_FORWARDED_HOST');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PORT, 'X_FORWARDED_PORT');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PROTO, 'X_FORWARDED_PROTO');\n    }\n\n    public function testTrustedProxiesForwarded()\n    {\n        $request = Request::create('http://example.com/');\n        $request->server->set('REMOTE_ADDR', '3.3.3.3');\n        $request->headers->set('FORWARDED', 'for=1.1.1.1, host=foo.example.com:8080, proto=https, for=2.2.2.2, host=real.example.com:8080');\n\n        // no trusted proxies\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // disabling proxy trusting\n        Request::setTrustedProxies(array());\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // request is forwarded by a non-trusted proxy\n        Request::setTrustedProxies(array('2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $this->assertEquals('1.1.1.1', $request->getClientIp());\n        $this->assertEquals('foo.example.com', $request->getHost());\n        $this->assertEquals(8080, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.4', '2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // check various X_FORWARDED_PROTO header values\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $request->headers->set('FORWARDED', 'proto=ssl');\n        $this->assertTrue($request->isSecure());\n\n        $request->headers->set('FORWARDED', 'proto=https, proto=http');\n        $this->assertTrue($request->isSecure());\n    }\n\n    /**\n     * @expectedException \\InvalidArgumentException\n     */\n    public function testSetTrustedProxiesInvalidHeaderName()\n    {\n        Request::create('http://example.com/');\n        Request::setTrustedHeaderName('bogus name', 'X_MY_FOR');\n    }\n\n    /**\n     * @expectedException \\InvalidArgumentException\n     */\n    public function testGetTrustedProxiesInvalidHeaderName()\n    {\n        Request::create('http://example.com/');\n        Request::getTrustedHeaderName('bogus name');\n    }\n\n    /**\n     * @dataProvider iisRequestUriProvider\n     */\n    public function testIISRequestUri($headers, $server, $expectedRequestUri)\n    {\n        $request = new Request();\n        $request->headers->replace($headers);\n        $request->server->replace($server);\n\n        $this->assertEquals($expectedRequestUri, $request->getRequestUri(), '->getRequestUri() is correct');\n\n        $subRequestUri = '/bar/foo';\n        $subRequest = Request::create($subRequestUri, 'get', array(), array(), array(), $request->server->all());\n        $this->assertEquals($subRequestUri, $subRequest->getRequestUri(), '->getRequestUri() is correct in sub request');\n    }\n\n    public function iisRequestUriProvider()\n    {\n        return array(\n            array(\n                array(\n                    'X_ORIGINAL_URL' => '/foo/bar',\n                ),\n                array(),\n                '/foo/bar',\n            ),\n            array(\n                array(\n                    'X_REWRITE_URL' => '/foo/bar',\n                ),\n                array(),\n                '/foo/bar',\n            ),\n            array(\n                array(),\n                array(\n                    'IIS_WasUrlRewritten' => '1',\n                    'UNENCODED_URL' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(\n                    'X_ORIGINAL_URL' => '/foo/bar',\n                ),\n                array(\n                    'HTTP_X_ORIGINAL_URL' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(\n                    'X_ORIGINAL_URL' => '/foo/bar',\n                ),\n                array(\n                    'IIS_WasUrlRewritten' => '1',\n                    'UNENCODED_URL' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(\n                    'X_ORIGINAL_URL' => '/foo/bar',\n                ),\n                array(\n                    'HTTP_X_ORIGINAL_URL' => '/foo/bar',\n                    'IIS_WasUrlRewritten' => '1',\n                    'UNENCODED_URL' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(),\n                array(\n                    'ORIG_PATH_INFO' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(),\n                array(\n                    'ORIG_PATH_INFO' => '/foo/bar',\n                    'QUERY_STRING' => 'foo=bar',\n                ),\n                '/foo/bar?foo=bar',\n            ),\n        );\n    }\n\n    public function testTrustedHosts()\n    {\n        // create a request\n        $request = Request::create('/');\n\n        // no trusted host set -> no host check\n        $request->headers->set('host', 'evil.com');\n        $this->assertEquals('evil.com', $request->getHost());\n\n        // add a trusted domain and all its subdomains\n        Request::setTrustedHosts(array('^([a-z]{9}\\.)?trusted\\.com$'));\n\n        // untrusted host\n        $request->headers->set('host', 'evil.com');\n        try {\n            $request->getHost();\n            $this->fail('Request::getHost() should throw an exception when host is not trusted.');\n        } catch (\\UnexpectedValueException $e) {\n            $this->assertEquals('Untrusted Host \"evil.com\"', $e->getMessage());\n        }\n\n        // trusted hosts\n        $request->headers->set('host', 'trusted.com');\n        $this->assertEquals('trusted.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n\n        $request->server->set('HTTPS', true);\n        $request->headers->set('host', 'trusted.com');\n        $this->assertEquals('trusted.com', $request->getHost());\n        $this->assertEquals(443, $request->getPort());\n        $request->server->set('HTTPS', false);\n\n        $request->headers->set('host', 'trusted.com:8000');\n        $this->assertEquals('trusted.com', $request->getHost());\n        $this->assertEquals(8000, $request->getPort());\n\n        $request->headers->set('host', 'subdomain.trusted.com');\n        $this->assertEquals('subdomain.trusted.com', $request->getHost());\n    }\n\n    public function testSetTrustedHostsDoesNotBreakOnSpecialCharacters()\n    {\n        Request::setTrustedHosts(array('localhost(\\.local){0,1}#,example.com', 'localhost'));\n\n        $request = Request::create('/');\n        $request->headers->set('host', 'localhost');\n        $this->assertSame('localhost', $request->getHost());\n    }\n\n    public function testFactory()\n    {\n        Request::setFactory(function (array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) {\n            return new NewRequest();\n        });\n\n        $this->assertEquals('foo', Request::create('/')->getFoo());\n\n        Request::setFactory(null);\n    }\n\n    /**\n     * @dataProvider getLongHostNames\n     */\n    public function testVeryLongHosts($host)\n    {\n        $start = microtime(true);\n\n        $request = Request::create('/');\n        $request->headers->set('host', $host);\n        $this->assertEquals($host, $request->getHost());\n        $this->assertLessThan(5, microtime(true) - $start);\n    }\n\n    /**\n     * @dataProvider getHostValidities\n     */\n    public function testHostValidity($host, $isValid, $expectedHost = null, $expectedPort = null)\n    {\n        $request = Request::create('/');\n        $request->headers->set('host', $host);\n\n        if ($isValid) {\n            $this->assertSame($expectedHost ?: $host, $request->getHost());\n            if ($expectedPort) {\n                $this->assertSame($expectedPort, $request->getPort());\n            }\n        } else {\n            if (method_exists($this, 'expectException')) {\n                $this->expectException('UnexpectedValueException');\n                $this->expectExceptionMessage('Invalid Host');\n            } else {\n                $this->setExpectedException('UnexpectedValueException', 'Invalid Host');\n            }\n\n            $request->getHost();\n        }\n    }\n\n    public function getHostValidities()\n    {\n        return array(\n            array('.a', false),\n            array('a..', false),\n            array('a.', true),\n            array(\"\\xE9\", false),\n            array('[::1]', true),\n            array('[::1]:80', true, '[::1]', 80),\n            array(str_repeat('.', 101), false),\n        );\n    }\n\n    public function getLongHostNames()\n    {\n        return array(\n            array('a'.str_repeat('.a', 40000)),\n            array(str_repeat(':', 101)),\n        );\n    }\n\n    /**\n     * @dataProvider methodSafeProvider\n     */\n    public function testMethodSafe($method, $safe)\n    {\n        $request = new Request();\n        $request->setMethod($method);\n        $this->assertEquals($safe, $request->isMethodSafe(false));\n    }\n\n    public function methodSafeProvider()\n    {\n        return array(\n            array('HEAD', true),\n            array('GET', true),\n            array('POST', false),\n            array('PUT', false),\n            array('PATCH', false),\n            array('DELETE', false),\n            array('PURGE', false),\n            array('OPTIONS', true),\n            array('TRACE', true),\n            array('CONNECT', false),\n        );\n    }\n\n    public function testMethodSafeChecksCacheable()\n    {\n        $request = new Request();\n        $request->setMethod('OPTIONS');\n        $this->assertFalse($request->isMethodSafe());\n    }\n\n    /**\n     * @dataProvider methodCacheableProvider\n     */\n    public function testMethodCacheable($method, $cacheable)\n    {\n        $request = new Request();\n        $request->setMethod($method);\n        $this->assertEquals($cacheable, $request->isMethodCacheable());\n    }\n\n    public function methodCacheableProvider()\n    {\n        return array(\n            array('HEAD', true),\n            array('GET', true),\n            array('POST', false),\n            array('PUT', false),\n            array('PATCH', false),\n            array('DELETE', false),\n            array('PURGE', false),\n            array('OPTIONS', false),\n            array('TRACE', false),\n            array('CONNECT', false),\n        );\n    }\n\n    public function nonstandardRequestsData()\n    {\n        return array(\n            array('',  '', '/', 'http://host:8080/', ''),\n            array('/', '', '/', 'http://host:8080/', ''),\n\n            array('hello/app.php/x',  '', '/x', 'http://host:8080/hello/app.php/x', '/hello', '/hello/app.php'),\n            array('/hello/app.php/x', '', '/x', 'http://host:8080/hello/app.php/x', '/hello', '/hello/app.php'),\n\n            array('',      'a=b', '/', 'http://host:8080/?a=b'),\n            array('?a=b',  'a=b', '/', 'http://host:8080/?a=b'),\n            array('/?a=b', 'a=b', '/', 'http://host:8080/?a=b'),\n\n            array('x',      'a=b', '/x', 'http://host:8080/x?a=b'),\n            array('x?a=b',  'a=b', '/x', 'http://host:8080/x?a=b'),\n            array('/x?a=b', 'a=b', '/x', 'http://host:8080/x?a=b'),\n\n            array('hello/x',  '', '/x', 'http://host:8080/hello/x', '/hello'),\n            array('/hello/x', '', '/x', 'http://host:8080/hello/x', '/hello'),\n\n            array('hello/app.php/x',      'a=b', '/x', 'http://host:8080/hello/app.php/x?a=b', '/hello', '/hello/app.php'),\n            array('hello/app.php/x?a=b',  'a=b', '/x', 'http://host:8080/hello/app.php/x?a=b', '/hello', '/hello/app.php'),\n            array('/hello/app.php/x?a=b', 'a=b', '/x', 'http://host:8080/hello/app.php/x?a=b', '/hello', '/hello/app.php'),\n        );\n    }\n\n    /**\n     * @dataProvider nonstandardRequestsData\n     */\n    public function testNonstandardRequests($requestUri, $queryString, $expectedPathInfo, $expectedUri, $expectedBasePath = '', $expectedBaseUrl = null)\n    {\n        if (null === $expectedBaseUrl) {\n            $expectedBaseUrl = $expectedBasePath;\n        }\n\n        $server = array(\n            'HTTP_HOST' => 'host:8080',\n            'SERVER_PORT' => '8080',\n            'QUERY_STRING' => $queryString,\n            'PHP_SELF' => '/hello/app.php',\n            'SCRIPT_FILENAME' => '/some/path/app.php',\n            'REQUEST_URI' => $requestUri,\n        );\n\n        $request = new Request(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals($expectedPathInfo, $request->getPathInfo());\n        $this->assertEquals($expectedUri, $request->getUri());\n        $this->assertEquals($queryString, $request->getQueryString());\n        $this->assertEquals(8080, $request->getPort());\n        $this->assertEquals('host:8080', $request->getHttpHost());\n        $this->assertEquals($expectedBaseUrl, $request->getBaseUrl());\n        $this->assertEquals($expectedBasePath, $request->getBasePath());\n    }\n}\n\nclass RequestContentProxy extends Request\n{\n    public function getContent($asResource = false)\n    {\n        return http_build_query(array('_method' => 'PUT', 'content' => 'mycontent'), '', '&');\n    }\n}\n\nclass NewRequest extends Request\n{\n    public function getFoo()\n    {\n        return 'foo';\n    }\n}\n"], "fixing_code": ["CHANGELOG\n=========\n\n2.8.44\n------\n\n * [BC BREAK] Support for the IIS-only `X_ORIGINAL_URL` and `X_REWRITE_URL`\n   HTTP headers has been dropped for security reasons.\n\n2.8.0\n-----\n\n * Finding deep items in `ParameterBag::get()` is deprecated since version 2.8 and\n   will be removed in 3.0.\n\n2.6.0\n-----\n\n * PdoSessionHandler changes\n   - implemented different session locking strategies to prevent loss of data by concurrent access to the same session\n   - [BC BREAK] save session data in a binary column without base64_encode\n   - [BC BREAK] added lifetime column to the session table which allows to have different lifetimes for each session\n   - implemented lazy connections that are only opened when a session is used by either passing a dsn string\n     explicitly or falling back to session.save_path ini setting\n   - added a createTable method that initializes a correctly defined table depending on the database vendor\n\n2.5.0\n-----\n\n * added `JsonResponse::setEncodingOptions()` & `JsonResponse::getEncodingOptions()` for easier manipulation\n   of the options used while encoding data to JSON format.\n\n2.4.0\n-----\n\n * added RequestStack\n * added Request::getEncodings()\n * added accessors methods to session handlers\n\n2.3.0\n-----\n\n * added support for ranges of IPs in trusted proxies\n * `UploadedFile::isValid` now returns false if the file was not uploaded via HTTP (in a non-test mode)\n * Improved error-handling of `\\Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler`\n   to ensure the supplied PDO handler throws Exceptions on error (as the class expects). Added related test cases\n   to verify that Exceptions are properly thrown when the PDO queries fail.\n\n2.2.0\n-----\n\n * fixed the Request::create() precedence (URI information always take precedence now)\n * added Request::getTrustedProxies()\n * deprecated Request::isProxyTrusted()\n * [BC BREAK] JsonResponse does not turn a top level empty array to an object anymore, use an ArrayObject to enforce objects\n * added a IpUtils class to check if an IP belongs to a CIDR\n * added Request::getRealMethod() to get the \"real\" HTTP method (getMethod() returns the \"intended\" HTTP method)\n * disabled _method request parameter support by default (call Request::enableHttpMethodParameterOverride() to\n   enable it, and Request::getHttpMethodParameterOverride() to check if it is supported)\n * Request::splitHttpAcceptHeader() method is deprecated and will be removed in 2.3\n * Deprecated Flashbag::count() and \\Countable interface, will be removed in 2.3\n\n2.1.0\n-----\n\n * added Request::getSchemeAndHttpHost() and Request::getUserInfo()\n * added a fluent interface to the Response class\n * added Request::isProxyTrusted()\n * added JsonResponse\n * added a getTargetUrl method to RedirectResponse\n * added support for streamed responses\n * made Response::prepare() method the place to enforce HTTP specification\n * [BC BREAK] moved management of the locale from the Session class to the Request class\n * added a generic access to the PHP built-in filter mechanism: ParameterBag::filter()\n * made FileBinaryMimeTypeGuesser command configurable\n * added Request::getUser() and Request::getPassword()\n * added support for the PATCH method in Request\n * removed the ContentTypeMimeTypeGuesser class as it is deprecated and never used on PHP 5.3\n * added ResponseHeaderBag::makeDisposition() (implements RFC 6266)\n * made mimetype to extension conversion configurable\n * [BC BREAK] Moved all session related classes and interfaces into own namespace, as\n   `Symfony\\Component\\HttpFoundation\\Session` and renamed classes accordingly.\n   Session handlers are located in the subnamespace `Symfony\\Component\\HttpFoundation\\Session\\Handler`.\n * SessionHandlers must implement `\\SessionHandlerInterface` or extend from the\n   `Symfony\\Component\\HttpFoundation\\Storage\\Handler\\NativeSessionHandler` base class.\n * Added internal storage driver proxy mechanism for forward compatibility with\n   PHP 5.4 `\\SessionHandler` class.\n * Added session handlers for custom Memcache, Memcached and Null session save handlers.\n * [BC BREAK] Removed `NativeSessionStorage` and replaced with `NativeFileSessionHandler`.\n * [BC BREAK] `SessionStorageInterface` methods removed: `write()`, `read()` and\n   `remove()`.  Added `getBag()`, `registerBag()`.  The `NativeSessionStorage` class\n   is a mediator for the session storage internals including the session handlers\n   which do the real work of participating in the internal PHP session workflow.\n * [BC BREAK] Introduced mock implementations of `SessionStorage` to enable unit\n   and functional testing without starting real PHP sessions.  Removed\n   `ArraySessionStorage`, and replaced with `MockArraySessionStorage` for unit\n   tests; removed `FilesystemSessionStorage`, and replaced with`MockFileSessionStorage`\n   for functional tests.  These do not interact with global session ini\n   configuration values, session functions or `$_SESSION` superglobal. This means\n   they can be configured directly allowing multiple instances to work without\n   conflicting in the same PHP process.\n * [BC BREAK] Removed the `close()` method from the `Session` class, as this is\n   now redundant.\n * Deprecated the following methods from the Session class: `setFlash()`, `setFlashes()`\n   `getFlash()`, `hasFlash()`, and `removeFlash()`. Use `getFlashBag()` instead\n   which returns a `FlashBagInterface`.\n * `Session->clear()` now only clears session attributes as before it cleared\n   flash messages and attributes. `Session->getFlashBag()->all()` clears flashes now.\n * Session data is now managed by `SessionBagInterface` to better encapsulate\n   session data.\n * Refactored session attribute and flash messages system to their own\n  `SessionBagInterface` implementations.\n * Added `FlashBag`. Flashes expire when retrieved by `get()` or `all()`. This\n   implementation is ESI compatible.\n * Added `AutoExpireFlashBag` (default) to replicate Symfony 2.0.x auto expire\n   behaviour of messages auto expiring after one page page load.  Messages must\n   be retrieved by `get()` or `all()`.\n * Added `Symfony\\Component\\HttpFoundation\\Attribute\\AttributeBag` to replicate\n   attributes storage behaviour from 2.0.x (default).\n * Added `Symfony\\Component\\HttpFoundation\\Attribute\\NamespacedAttributeBag` for\n   namespace session attributes.\n * Flash API can stores messages in an array so there may be multiple messages\n   per flash type.  The old `Session` class API remains without BC break as it\n   will allow single messages as before.\n * Added basic session meta-data to the session to record session create time,\n   last updated time, and the lifetime of the session cookie that was provided\n   to the client.\n * Request::getClientIp() method doesn't take a parameter anymore but bases\n   itself on the trustProxy parameter.\n * Added isMethod() to Request object.\n * [BC BREAK] The methods `getPathInfo()`, `getBaseUrl()` and `getBasePath()` of\n   a `Request` now all return a raw value (vs a urldecoded value before). Any call\n   to one of these methods must be checked and wrapped in a `rawurldecode()` if\n   needed.\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 'forwarded';\n    const HEADER_CLIENT_IP = 'client_ip';\n    const HEADER_CLIENT_HOST = 'client_host';\n    const HEADER_CLIENT_PROTO = 'client_proto';\n    const HEADER_CLIENT_PORT = 'client_port';\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = array();\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = array();\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = array();\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     */\n    protected static $trustedHeaders = array(\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',\n        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',\n    );\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    private $isForwardedValid = true;\n\n    private static $forwardedParams = array(\n        self::HEADER_CLIENT_IP => 'for',\n        self::HEADER_CLIENT_HOST => 'host',\n        self::HEADER_CLIENT_PROTO => 'proto',\n        self::HEADER_CLIENT_PORT => 'host',\n    );\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new ParameterBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new ParameterBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        // With the php's bug #66606, the php's built-in web server\n        // stores the Content-Type and Content-Length header values in\n        // HTTP_CONTENT_TYPE and HTTP_CONTENT_LENGTH fields.\n        $server = $_SERVER;\n        if ('cli-server' === PHP_SAPI) {\n            if (array_key_exists('HTTP_CONTENT_LENGTH', $_SERVER)) {\n                $server['CONTENT_LENGTH'] = $_SERVER['HTTP_CONTENT_LENGTH'];\n            }\n            if (array_key_exists('HTTP_CONTENT_TYPE', $_SERVER)) {\n                $server['CONTENT_TYPE'] = $_SERVER['HTTP_CONTENT_TYPE'];\n            }\n        }\n\n        $request = self::createRequestFromFactory($_GET, $_POST, array(), $_COOKIE, $_FILES, $server);\n\n        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), array('PUT', 'DELETE', 'PATCH'))\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new ParameterBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null)\n    {\n        $server = array_replace(array(\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony/2.X',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ), $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] = $server['HTTP_HOST'].':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = array();\n                break;\n            default:\n                $request = array();\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, array(), $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     *\n     * @param callable|null $callable A PHP callable\n     */\n    public static function setFactory($callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new ParameterBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new ParameterBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = array();\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (in_array($key, array('CONTENT_TYPE', 'CONTENT_LENGTH'))) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = array('g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE);\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = array();\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST = array_merge($_REQUEST, $request[$order]);\n        }\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies A list of trusted proxies\n     */\n    public static function setTrustedProxies(array $proxies)\n    {\n        self::$trustedProxies = $proxies;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = array();\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Sets the name for trusted headers.\n     *\n     * The following header keys are supported:\n     *\n     *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())\n     *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())\n     *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())\n     *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())\n     *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)\n     *\n     * Setting an empty value allows to disable the trusted header for the given key.\n     *\n     * @param string $key   The header key\n     * @param string $value The header name\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public static function setTrustedHeaderName($key, $value)\n    {\n        if (!array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to set the trusted header name for key \"%s\".', $key));\n        }\n\n        self::$trustedHeaders[$key] = $value;\n    }\n\n    /**\n     * Gets the trusted proxy header name.\n     *\n     * @param string $key The header key\n     *\n     * @return string The header name\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public static function getTrustedHeaderName($key)\n    {\n        if (!array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to get the trusted header name for key \"%s\".', $key));\n        }\n\n        return self::$trustedHeaders[$key];\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @param string $qs Query string\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString($qs)\n    {\n        if ('' == $qs) {\n            return '';\n        }\n\n        $parts = array();\n        $order = array();\n\n        foreach (explode('&', $qs) as $param) {\n            if ('' === $param || '=' === $param[0]) {\n                // Ignore useless delimiters, e.g. \"x=y&\".\n                // Also ignore pairs with empty key, even if there was a value, e.g. \"=value\", as such nameless values cannot be retrieved anyway.\n                // PHP also does not include them when building _GET.\n                continue;\n            }\n\n            $keyValuePair = explode('=', $param, 2);\n\n            // GET parameters, that are submitted from a HTML form, encode spaces as \"+\" by default (as defined in enctype application/x-www-form-urlencoded).\n            // PHP also converts \"+\" to spaces when filling the global _GET or when using the function parse_str. This is why we use urldecode and then normalize to\n            // RFC 3986 with rawurlencode.\n            $parts[] = isset($keyValuePair[1]) ?\n                rawurlencode(urldecode($keyValuePair[0])).'='.rawurlencode(urldecode($keyValuePair[1])) :\n                rawurlencode(urldecode($keyValuePair[0]));\n            $order[] = urldecode($keyValuePair[0]);\n        }\n\n        array_multisort($order, SORT_ASC, $parts);\n\n        return implode('&', $parts);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility.\n     *\n     * Order of precedence: GET, PATH, POST\n     *\n     * Avoid using this method in controllers:\n     *\n     *  * slow\n     *  * prefer to get from a \"named\" source\n     *\n     * It is better to explicitly get request parameters from the appropriate\n     * public property instead (query, attributes, request).\n     *\n     * Note: Finding deep items is deprecated since version 2.8, to be removed in 3.0.\n     *\n     * @param string $key     The key\n     * @param mixed  $default The default value if the parameter key does not exist\n     * @param bool   $deep    Is parameter deep in multidimensional array\n     *\n     * @return mixed\n     */\n    public function get($key, $default = null, $deep = false)\n    {\n        if ($deep) {\n            @trigger_error('Using paths to find deeper items in '.__METHOD__.' is deprecated since Symfony 2.8 and will be removed in 3.0. Filter the returned value in your own code instead.', E_USER_DEPRECATED);\n        }\n\n        if ($this !== $result = $this->query->get($key, $this, $deep)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->attributes->get($key, $this, $deep)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->request->get($key, $this, $deep)) {\n            return $result;\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface|null The session\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->session->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    /**\n     * Sets the Session.\n     *\n     * @param SessionInterface $session The Session\n     */\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return array($ip);\n        }\n\n        return $this->getTrustedValues(self::HEADER_CLIENT_IP, $ip) ?: array($ip);\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via \"setTrustedHeaderName()\" with\n     * the \"client-ip\" key.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see http://en.wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Port\",\n     * configure it via \"setTrustedHeaderName()\" with the \"client-port\" key.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos) {\n            return (int) substr($host, $pos + 1);\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath($path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @param string $path The target path\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath($path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', isset($path[0]) && '/' === $path[0] ? substr($path, 1) : $path);\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see http://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Proto\"\n     * (\"SSL_HTTPS\" for instance), configure it via \"setTrustedHeaderName()\" with\n     * the \"client-proto\" key.\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_CLIENT_PROTO)) {\n            return in_array(strtolower($proto[0]), array('https', 'on', 'ssl', '1'), true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Host\",\n     * configure it via \"setTrustedHeaderName()\" with the \"client-host\" key.\n     *\n     * @return string\n     *\n     * @throws \\UnexpectedValueException when the host name is invalid\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            throw new \\UnexpectedValueException(sprintf('Invalid Host \"%s\"', $host));\n        }\n\n        if (count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            throw new \\UnexpectedValueException(sprintf('Untrusted Host \"%s\"', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     *\n     * @param string $method\n     */\n    public function setMethod($method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null === $this->method) {\n            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n            if ('POST' === $this->method) {\n                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {\n                    $this->method = strtoupper($method);\n                } elseif (self::$httpMethodParameterOverride) {\n                    $this->method = strtoupper($this->request->get('_method', $this->query->get('_method', 'POST')));\n                }\n            }\n        }\n\n        return $this->method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @param string $mimeType The associated mime type\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat($mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = substr($mimeType, 0, $pos);\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string       $format    The format\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat($format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes);\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request parameter\n     *  * $default\n     *\n     * @param string $default The default format\n     *\n     * @return string The request format\n     */\n    public function getRequestFormat($default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     *\n     * @param string $format The request format\n     */\n    public function setRequestFormat($format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     *\n     * @param string $locale\n     */\n    public function setDefaultLocale($locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     *\n     * @param string $locale\n     */\n    public function setLocale($locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod($method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether the method is safe or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.\n     *\n     * @return bool\n     */\n    public function isMethodSafe(/* $andCacheable = true */)\n    {\n        return in_array($this->getMethod(), 0 < func_num_args() && !func_get_arg(0) ? array('GET', 'HEAD', 'OPTIONS', 'TRACE') : array('GET', 'HEAD'));\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool\n     */\n    public function isMethodCacheable()\n    {\n        return in_array($this->getMethod(), array('GET', 'HEAD'));\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent($asResource = false)\n    {\n        $currentContentIsResource = is_resource($this->content);\n        if (\\PHP_VERSION_ID < 50600 && false === $this->content) {\n            throw new \\LogicException('getContent() can only be called once when using the resource return type and PHP below 5.6.');\n        }\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param array $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = array();\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = array();\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (http://framework.zend.com/license/new-bsd).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (http://www.zend.com)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n            // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path, only use URL path\n            $schemeAndHttpHost = $this->getSchemeAndHttpHost();\n            if (0 === strpos($requestUri, $schemeAndHttpHost)) {\n                $requestUri = substr($requestUri, strlen($schemeAndHttpHost));\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(dirname($baseUrl), '/'.DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (strlen($requestUri) >= strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        if (basename($baseUrl) === $filename) {\n            $basePath = dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        $baseUrl = $this->getBaseUrl();\n\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        $pathInfo = substr($requestUri, strlen($baseUrl));\n        if (null !== $baseUrl && (false === $pathInfo || '' === $pathInfo)) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        } elseif (null === $baseUrl) {\n            return $requestUri;\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = array(\n            'html' => array('text/html', 'application/xhtml+xml'),\n            'txt' => array('text/plain'),\n            'js' => array('application/javascript', 'application/x-javascript', 'text/javascript'),\n            'css' => array('text/css'),\n            'json' => array('application/json', 'application/x-json'),\n            'jsonld' => array('application/ld+json'),\n            'xml' => array('text/xml', 'application/xml', 'application/x-xml'),\n            'rdf' => array('application/rdf+xml'),\n            'atom' => array('application/atom+xml'),\n            'rss' => array('application/rss+xml'),\n            'form' => array('application/x-www-form-urlencoded'),\n        );\n    }\n\n    /**\n     * Sets the default PHP locale.\n     *\n     * @param string $locale\n     */\n    private function setPhpDefaultLocale($locale)\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /*\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, false otherwise.\n     *\n     * @param string $string The urlencoded string\n     * @param string $prefix The prefix not encoded\n     *\n     * @return string|false The prefix as it is encoded in $string, or false\n     */\n    private function getUrlencodedPrefix($string, $prefix)\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return false;\n        }\n\n        $len = strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return false;\n    }\n\n    private static function createRequestFromFactory(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)\n    {\n        if (self::$requestFactory) {\n            $request = call_user_func(self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    private function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues($type, $ip = null)\n    {\n        $clientValues = array();\n        $forwardedValues = array();\n\n        if (self::$trustedHeaders[$type] && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_CLIENT_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if (self::$trustedHeaders[self::HEADER_FORWARDED] && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwardedValues = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $forwardedValues = preg_match_all(sprintf('{(?:%s)=(?:\"?\\[?)([a-zA-Z0-9\\.:_\\-/]*+)}', self::$forwardedParams[$type]), $forwardedValues, $matches) ? $matches[1] : array();\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? array('0.0.0.0', $ip) : array();\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, $ip)\n    {\n        if (!$clientIps) {\n            return array();\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            // Remove port (unfortunately, it does happen)\n            if (preg_match('{((?:\\d+\\.){3}\\d+)\\:\\d+}', $clientIp, $match)) {\n                $clientIps[$key] = $clientIp = $match[1];\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : array($firstTrustedIp);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation\\Tests;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass RequestTest extends TestCase\n{\n    protected function tearDown()\n    {\n        Request::setTrustedProxies(array());\n        Request::setTrustedHosts(array());\n    }\n\n    public function testInitialize()\n    {\n        $request = new Request();\n\n        $request->initialize(array('foo' => 'bar'));\n        $this->assertEquals('bar', $request->query->get('foo'), '->initialize() takes an array of query parameters as its first argument');\n\n        $request->initialize(array(), array('foo' => 'bar'));\n        $this->assertEquals('bar', $request->request->get('foo'), '->initialize() takes an array of request parameters as its second argument');\n\n        $request->initialize(array(), array(), array('foo' => 'bar'));\n        $this->assertEquals('bar', $request->attributes->get('foo'), '->initialize() takes an array of attributes as its third argument');\n\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_FOO' => 'bar'));\n        $this->assertEquals('bar', $request->headers->get('FOO'), '->initialize() takes an array of HTTP headers as its sixth argument');\n    }\n\n    public function testGetLocale()\n    {\n        $request = new Request();\n        $request->setLocale('pl');\n        $locale = $request->getLocale();\n        $this->assertEquals('pl', $locale);\n    }\n\n    public function testGetUser()\n    {\n        $request = Request::create('http://user:password@test.com');\n        $user = $request->getUser();\n\n        $this->assertEquals('user', $user);\n    }\n\n    public function testGetPassword()\n    {\n        $request = Request::create('http://user:password@test.com');\n        $password = $request->getPassword();\n\n        $this->assertEquals('password', $password);\n    }\n\n    public function testIsNoCache()\n    {\n        $request = new Request();\n        $isNoCache = $request->isNoCache();\n\n        $this->assertFalse($isNoCache);\n    }\n\n    public function testGetContentType()\n    {\n        $request = new Request();\n        $contentType = $request->getContentType();\n\n        $this->assertNull($contentType);\n    }\n\n    public function testSetDefaultLocale()\n    {\n        $request = new Request();\n        $request->setDefaultLocale('pl');\n        $locale = $request->getLocale();\n\n        $this->assertEquals('pl', $locale);\n    }\n\n    public function testCreate()\n    {\n        $request = Request::create('http://test.com/foo?bar=baz');\n        $this->assertEquals('http://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com/foo', 'GET', array('bar' => 'baz'));\n        $this->assertEquals('http://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com/foo?bar=foo', 'GET', array('bar' => 'baz'));\n        $this->assertEquals('http://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('https://test.com/foo?bar=baz');\n        $this->assertEquals('https://test.com/foo?bar=baz', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('bar=baz', $request->getQueryString());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('test.com:90/foo');\n        $this->assertEquals('http://test.com:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('test.com', $request->getHost());\n        $this->assertEquals('test.com:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('https://test.com:90/foo');\n        $this->assertEquals('https://test.com:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('test.com', $request->getHost());\n        $this->assertEquals('test.com:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('https://127.0.0.1:90/foo');\n        $this->assertEquals('https://127.0.0.1:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('127.0.0.1', $request->getHost());\n        $this->assertEquals('127.0.0.1:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('https://[::1]:90/foo');\n        $this->assertEquals('https://[::1]:90/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('[::1]', $request->getHost());\n        $this->assertEquals('[::1]:90', $request->getHttpHost());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $request = Request::create('https://[::1]/foo');\n        $this->assertEquals('https://[::1]/foo', $request->getUri());\n        $this->assertEquals('/foo', $request->getPathInfo());\n        $this->assertEquals('[::1]', $request->getHost());\n        $this->assertEquals('[::1]', $request->getHttpHost());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        $json = '{\"jsonrpc\":\"2.0\",\"method\":\"echo\",\"id\":7,\"params\":[\"Hello World\"]}';\n        $request = Request::create('http://example.com/jsonrpc', 'POST', array(), array(), array(), array(), $json);\n        $this->assertEquals($json, $request->getContent());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com');\n        $this->assertEquals('http://test.com/', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com?test=1');\n        $this->assertEquals('http://test.com/?test=1', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('test=1', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com:90/?test=1');\n        $this->assertEquals('http://test.com:90/?test=1', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('test=1', $request->getQueryString());\n        $this->assertEquals(90, $request->getPort());\n        $this->assertEquals('test.com:90', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://username:password@test.com');\n        $this->assertEquals('http://test.com/', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertEquals('username', $request->getUser());\n        $this->assertEquals('password', $request->getPassword());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://username@test.com');\n        $this->assertEquals('http://test.com/', $request->getUri());\n        $this->assertEquals('/', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertEquals('username', $request->getUser());\n        $this->assertSame('', $request->getPassword());\n        $this->assertFalse($request->isSecure());\n\n        $request = Request::create('http://test.com/?foo');\n        $this->assertEquals('/?foo', $request->getRequestUri());\n        $this->assertEquals(array('foo' => ''), $request->query->all());\n\n        // assume rewrite rule: (.*) --> app/app.php; app/ is a symlink to a symfony web/ directory\n        $request = Request::create('http://test.com/apparthotel-1234', 'GET', array(), array(), array(),\n            array(\n                'DOCUMENT_ROOT' => '/var/www/www.test.com',\n                'SCRIPT_FILENAME' => '/var/www/www.test.com/app/app.php',\n                'SCRIPT_NAME' => '/app/app.php',\n                'PHP_SELF' => '/app/app.php/apparthotel-1234',\n            ));\n        $this->assertEquals('http://test.com/apparthotel-1234', $request->getUri());\n        $this->assertEquals('/apparthotel-1234', $request->getPathInfo());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertEquals('test.com', $request->getHttpHost());\n        $this->assertFalse($request->isSecure());\n    }\n\n    public function testCreateCheckPrecedence()\n    {\n        // server is used by default\n        $request = Request::create('/', 'DELETE', array(), array(), array(), array(\n            'HTTP_HOST' => 'example.com',\n            'HTTPS' => 'on',\n            'SERVER_PORT' => 443,\n            'PHP_AUTH_USER' => 'fabien',\n            'PHP_AUTH_PW' => 'pa$$',\n            'QUERY_STRING' => 'foo=bar',\n            'CONTENT_TYPE' => 'application/json',\n        ));\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertTrue($request->isSecure());\n        $this->assertEquals('fabien', $request->getUser());\n        $this->assertEquals('pa$$', $request->getPassword());\n        $this->assertEquals('', $request->getQueryString());\n        $this->assertEquals('application/json', $request->headers->get('CONTENT_TYPE'));\n\n        // URI has precedence over server\n        $request = Request::create('http://thomas:pokemon@example.net:8080/?foo=bar', 'GET', array(), array(), array(), array(\n            'HTTP_HOST' => 'example.com',\n            'HTTPS' => 'on',\n            'SERVER_PORT' => 443,\n        ));\n        $this->assertEquals('example.net', $request->getHost());\n        $this->assertEquals(8080, $request->getPort());\n        $this->assertFalse($request->isSecure());\n        $this->assertEquals('thomas', $request->getUser());\n        $this->assertEquals('pokemon', $request->getPassword());\n        $this->assertEquals('foo=bar', $request->getQueryString());\n    }\n\n    public function testDuplicate()\n    {\n        $request = new Request(array('foo' => 'bar'), array('foo' => 'bar'), array('foo' => 'bar'), array(), array(), array('HTTP_FOO' => 'bar'));\n        $dup = $request->duplicate();\n\n        $this->assertEquals($request->query->all(), $dup->query->all(), '->duplicate() duplicates a request an copy the current query parameters');\n        $this->assertEquals($request->request->all(), $dup->request->all(), '->duplicate() duplicates a request an copy the current request parameters');\n        $this->assertEquals($request->attributes->all(), $dup->attributes->all(), '->duplicate() duplicates a request an copy the current attributes');\n        $this->assertEquals($request->headers->all(), $dup->headers->all(), '->duplicate() duplicates a request an copy the current HTTP headers');\n\n        $dup = $request->duplicate(array('foo' => 'foobar'), array('foo' => 'foobar'), array('foo' => 'foobar'), array(), array(), array('HTTP_FOO' => 'foobar'));\n\n        $this->assertEquals(array('foo' => 'foobar'), $dup->query->all(), '->duplicate() overrides the query parameters if provided');\n        $this->assertEquals(array('foo' => 'foobar'), $dup->request->all(), '->duplicate() overrides the request parameters if provided');\n        $this->assertEquals(array('foo' => 'foobar'), $dup->attributes->all(), '->duplicate() overrides the attributes if provided');\n        $this->assertEquals(array('foo' => array('foobar')), $dup->headers->all(), '->duplicate() overrides the HTTP header if provided');\n    }\n\n    public function testDuplicateWithFormat()\n    {\n        $request = new Request(array(), array(), array('_format' => 'json'));\n        $dup = $request->duplicate();\n\n        $this->assertEquals('json', $dup->getRequestFormat());\n        $this->assertEquals('json', $dup->attributes->get('_format'));\n\n        $request = new Request();\n        $request->setRequestFormat('xml');\n        $dup = $request->duplicate();\n\n        $this->assertEquals('xml', $dup->getRequestFormat());\n    }\n\n    /**\n     * @dataProvider getFormatToMimeTypeMapProvider\n     */\n    public function testGetFormatFromMimeType($format, $mimeTypes)\n    {\n        $request = new Request();\n        foreach ($mimeTypes as $mime) {\n            $this->assertEquals($format, $request->getFormat($mime));\n        }\n        $request->setFormat($format, $mimeTypes);\n        foreach ($mimeTypes as $mime) {\n            $this->assertEquals($format, $request->getFormat($mime));\n\n            if (null !== $format) {\n                $this->assertEquals($mimeTypes[0], $request->getMimeType($format));\n            }\n        }\n    }\n\n    public function testGetFormatFromMimeTypeWithParameters()\n    {\n        $request = new Request();\n        $this->assertEquals('json', $request->getFormat('application/json; charset=utf-8'));\n    }\n\n    public function testGetFormatWithCustomMimeType()\n    {\n        $request = new Request();\n        $request->setFormat('custom', 'application/vnd.foo.api;myversion=2.3');\n        $this->assertEquals('custom', $request->getFormat('application/vnd.foo.api;myversion=2.3'));\n    }\n\n    public function getFormatToMimeTypeMapProvider()\n    {\n        return array(\n            array(null, array(null, 'unexistent-mime-type')),\n            array('txt', array('text/plain')),\n            array('js', array('application/javascript', 'application/x-javascript', 'text/javascript')),\n            array('css', array('text/css')),\n            array('json', array('application/json', 'application/x-json')),\n            array('jsonld', array('application/ld+json')),\n            array('xml', array('text/xml', 'application/xml', 'application/x-xml')),\n            array('rdf', array('application/rdf+xml')),\n            array('atom', array('application/atom+xml')),\n        );\n    }\n\n    public function testGetUri()\n    {\n        $server = array();\n\n        // Standard Request on non default PORT\n        // http://host:8080/index.php/path/info?query=string\n\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/index.php/path/info?query=string';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PATH_INFO'] = '/path/info';\n        $server['PATH_TRANSLATED'] = 'redirect:/index.php/path/info';\n        $server['PHP_SELF'] = '/index_dev.php/path/info';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request = new Request();\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host:8080/index.php/path/info?query=string', $request->getUri(), '->getUri() with non default port');\n\n        // Use std port number\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/index.php/path/info?query=string', $request->getUri(), '->getUri() with default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/index.php/path/info?query=string', $request->getUri(), '->getUri() with default port without HOST_HEADER');\n\n        // Request with URL REWRITING (hide index.php)\n        //   RewriteCond %{REQUEST_FILENAME} !-f\n        //   RewriteRule ^(.*)$ index.php [QSA,L]\n        // http://host:8080/path/info?query=string\n        $server = array();\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['REDIRECT_QUERY_STRING'] = 'query=string';\n        $server['REDIRECT_URL'] = '/path/info';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/path/info?toto=test&1=1';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PHP_SELF'] = '/index.php';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/path/info?query=string', $request->getUri(), '->getUri() with rewrite');\n\n        // Use std port number\n        //  http://host/path/info?query=string\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/path/info?query=string', $request->getUri(), '->getUri() with rewrite and default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/path/info?query=string', $request->getUri(), '->getUri() with rewrite, default port without HOST_HEADER');\n\n        // With encoded characters\n\n        $server = array(\n            'HTTP_HOST' => 'host:8080',\n            'SERVER_NAME' => 'servername',\n            'SERVER_PORT' => '8080',\n            'QUERY_STRING' => 'query=string',\n            'REQUEST_URI' => '/ba%20se/index_dev.php/foo%20bar/in+fo?query=string',\n            'SCRIPT_NAME' => '/ba se/index_dev.php',\n            'PATH_TRANSLATED' => 'redirect:/index.php/foo bar/in+fo',\n            'PHP_SELF' => '/ba se/index_dev.php/path/info',\n            'SCRIPT_FILENAME' => '/some/where/ba se/index_dev.php',\n        );\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals(\n            'http://host:8080/ba%20se/index_dev.php/foo%20bar/in+fo?query=string',\n            $request->getUri()\n        );\n\n        // with user info\n\n        $server['PHP_AUTH_USER'] = 'fabien';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/ba%20se/index_dev.php/foo%20bar/in+fo?query=string', $request->getUri());\n\n        $server['PHP_AUTH_PW'] = 'symfony';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/ba%20se/index_dev.php/foo%20bar/in+fo?query=string', $request->getUri());\n    }\n\n    public function testGetUriForPath()\n    {\n        $request = Request::create('http://test.com/foo?bar=baz');\n        $this->assertEquals('http://test.com/some/path', $request->getUriForPath('/some/path'));\n\n        $request = Request::create('http://test.com:90/foo?bar=baz');\n        $this->assertEquals('http://test.com:90/some/path', $request->getUriForPath('/some/path'));\n\n        $request = Request::create('https://test.com/foo?bar=baz');\n        $this->assertEquals('https://test.com/some/path', $request->getUriForPath('/some/path'));\n\n        $request = Request::create('https://test.com:90/foo?bar=baz');\n        $this->assertEquals('https://test.com:90/some/path', $request->getUriForPath('/some/path'));\n\n        $server = array();\n\n        // Standard Request on non default PORT\n        // http://host:8080/index.php/path/info?query=string\n\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/index.php/path/info?query=string';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PATH_INFO'] = '/path/info';\n        $server['PATH_TRANSLATED'] = 'redirect:/index.php/path/info';\n        $server['PHP_SELF'] = '/index_dev.php/path/info';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request = new Request();\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host:8080/index.php/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with non default port');\n\n        // Use std port number\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/index.php/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/index.php/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with default port without HOST_HEADER');\n\n        // Request with URL REWRITING (hide index.php)\n        //   RewriteCond %{REQUEST_FILENAME} !-f\n        //   RewriteRule ^(.*)$ index.php [QSA,L]\n        // http://host:8080/path/info?query=string\n        $server = array();\n        $server['HTTP_HOST'] = 'host:8080';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '8080';\n\n        $server['REDIRECT_QUERY_STRING'] = 'query=string';\n        $server['REDIRECT_URL'] = '/path/info';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['QUERY_STRING'] = 'query=string';\n        $server['REQUEST_URI'] = '/path/info?toto=test&1=1';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['PHP_SELF'] = '/index.php';\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://host:8080/some/path', $request->getUriForPath('/some/path'), '->getUri() with rewrite');\n\n        // Use std port number\n        //  http://host/path/info?query=string\n        $server['HTTP_HOST'] = 'host';\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://host/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with rewrite and default port');\n\n        // Without HOST HEADER\n        unset($server['HTTP_HOST']);\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '80';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('http://servername/some/path', $request->getUriForPath('/some/path'), '->getUriForPath() with rewrite, default port without HOST_HEADER');\n        $this->assertEquals('servername', $request->getHttpHost());\n\n        // with user info\n\n        $server['PHP_AUTH_USER'] = 'fabien';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername/some/path', $request->getUriForPath('/some/path'));\n\n        $server['PHP_AUTH_PW'] = 'symfony';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername/some/path', $request->getUriForPath('/some/path'));\n    }\n\n    /**\n     * @dataProvider getRelativeUriForPathData()\n     */\n    public function testGetRelativeUriForPath($expected, $pathinfo, $path)\n    {\n        $this->assertEquals($expected, Request::create($pathinfo)->getRelativeUriForPath($path));\n    }\n\n    public function getRelativeUriForPathData()\n    {\n        return array(\n            array('me.png', '/foo', '/me.png'),\n            array('../me.png', '/foo/bar', '/me.png'),\n            array('me.png', '/foo/bar', '/foo/me.png'),\n            array('../baz/me.png', '/foo/bar/b', '/foo/baz/me.png'),\n            array('../../fooz/baz/me.png', '/foo/bar/b', '/fooz/baz/me.png'),\n            array('baz/me.png', '/foo/bar/b', 'baz/me.png'),\n        );\n    }\n\n    public function testGetUserInfo()\n    {\n        $request = new Request();\n\n        $server = array('PHP_AUTH_USER' => 'fabien');\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('fabien', $request->getUserInfo());\n\n        $server['PHP_AUTH_USER'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('0', $request->getUserInfo());\n\n        $server['PHP_AUTH_PW'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('0:0', $request->getUserInfo());\n    }\n\n    public function testGetSchemeAndHttpHost()\n    {\n        $request = new Request();\n\n        $server = array();\n        $server['SERVER_NAME'] = 'servername';\n        $server['SERVER_PORT'] = '90';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n\n        $server['PHP_AUTH_USER'] = 'fabien';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n\n        $server['PHP_AUTH_USER'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n\n        $server['PHP_AUTH_PW'] = '0';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('http://servername:90', $request->getSchemeAndHttpHost());\n    }\n\n    /**\n     * @dataProvider getQueryStringNormalizationData\n     */\n    public function testGetQueryString($query, $expectedQuery, $msg)\n    {\n        $request = new Request();\n\n        $request->server->set('QUERY_STRING', $query);\n        $this->assertSame($expectedQuery, $request->getQueryString(), $msg);\n    }\n\n    public function getQueryStringNormalizationData()\n    {\n        return array(\n            array('foo', 'foo', 'works with valueless parameters'),\n            array('foo=', 'foo=', 'includes a dangling equal sign'),\n            array('bar=&foo=bar', 'bar=&foo=bar', '->works with empty parameters'),\n            array('foo=bar&bar=', 'bar=&foo=bar', 'sorts keys alphabetically'),\n\n            // GET parameters, that are submitted from a HTML form, encode spaces as \"+\" by default (as defined in enctype application/x-www-form-urlencoded).\n            // PHP also converts \"+\" to spaces when filling the global _GET or when using the function parse_str.\n            array('him=John%20Doe&her=Jane+Doe', 'her=Jane%20Doe&him=John%20Doe', 'normalizes spaces in both encodings \"%20\" and \"+\"'),\n\n            array('foo[]=1&foo[]=2', 'foo%5B%5D=1&foo%5B%5D=2', 'allows array notation'),\n            array('foo=1&foo=2', 'foo=1&foo=2', 'allows repeated parameters'),\n            array('pa%3Dram=foo%26bar%3Dbaz&test=test', 'pa%3Dram=foo%26bar%3Dbaz&test=test', 'works with encoded delimiters'),\n            array('0', '0', 'allows \"0\"'),\n            array('Jane Doe&John%20Doe', 'Jane%20Doe&John%20Doe', 'normalizes encoding in keys'),\n            array('her=Jane Doe&him=John%20Doe', 'her=Jane%20Doe&him=John%20Doe', 'normalizes encoding in values'),\n            array('foo=bar&&&test&&', 'foo=bar&test', 'removes unneeded delimiters'),\n            array('formula=e=m*c^2', 'formula=e%3Dm%2Ac%5E2', 'correctly treats only the first \"=\" as delimiter and the next as value'),\n\n            // Ignore pairs with empty key, even if there was a value, e.g. \"=value\", as such nameless values cannot be retrieved anyway.\n            // PHP also does not include them when building _GET.\n            array('foo=bar&=a=b&=x=y', 'foo=bar', 'removes params with empty key'),\n        );\n    }\n\n    public function testGetQueryStringReturnsNull()\n    {\n        $request = new Request();\n\n        $this->assertNull($request->getQueryString(), '->getQueryString() returns null for non-existent query string');\n\n        $request->server->set('QUERY_STRING', '');\n        $this->assertNull($request->getQueryString(), '->getQueryString() returns null for empty query string');\n    }\n\n    public function testGetHost()\n    {\n        $request = new Request();\n\n        $request->initialize(array('foo' => 'bar'));\n        $this->assertEquals('', $request->getHost(), '->getHost() return empty string if not initialized');\n\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_HOST' => 'www.example.com'));\n        $this->assertEquals('www.example.com', $request->getHost(), '->getHost() from Host Header');\n\n        // Host header with port number\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_HOST' => 'www.example.com:8080'));\n        $this->assertEquals('www.example.com', $request->getHost(), '->getHost() from Host Header with port number');\n\n        // Server values\n        $request->initialize(array(), array(), array(), array(), array(), array('SERVER_NAME' => 'www.example.com'));\n        $this->assertEquals('www.example.com', $request->getHost(), '->getHost() from server name');\n\n        $request->initialize(array(), array(), array(), array(), array(), array('SERVER_NAME' => 'www.example.com', 'HTTP_HOST' => 'www.host.com'));\n        $this->assertEquals('www.host.com', $request->getHost(), '->getHost() value from Host header has priority over SERVER_NAME ');\n    }\n\n    public function testGetPort()\n    {\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'https',\n            'HTTP_X_FORWARDED_PORT' => '443',\n        ));\n        $port = $request->getPort();\n\n        $this->assertEquals(80, $port, 'Without trusted proxies FORWARDED_PROTO and FORWARDED_PORT are ignored.');\n\n        Request::setTrustedProxies(array('1.1.1.1'));\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'https',\n            'HTTP_X_FORWARDED_PORT' => '8443',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With PROTO and PORT on untrusted connection server value takes precedence.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(8443, $request->getPort(), 'With PROTO and PORT set PORT takes precedence.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'https',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With only PROTO set getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(443, $request->getPort(), 'With only PROTO set getPort() defaults to 443.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'http',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'If X_FORWARDED_PROTO is set to HTTP getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(80, $request->getPort(), 'If X_FORWARDED_PROTO is set to HTTP getPort() returns port of the original request.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'On',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With only PROTO set and value is On, getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(443, $request->getPort(), 'With only PROTO set and value is On, getPort() defaults to 443.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => '1',\n        ));\n        $this->assertEquals(80, $request->getPort(), 'With only PROTO set and value is 1, getPort() ignores trusted headers on untrusted connection.');\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertEquals(443, $request->getPort(), 'With only PROTO set and value is 1, getPort() defaults to 443.');\n\n        $request = Request::create('http://example.com', 'GET', array(), array(), array(), array(\n            'HTTP_X_FORWARDED_PROTO' => 'something-else',\n        ));\n        $port = $request->getPort();\n        $this->assertEquals(80, $port, 'With only PROTO set and value is not recognized, getPort() defaults to 80.');\n    }\n\n    /**\n     * @expectedException \\RuntimeException\n     */\n    public function testGetHostWithFakeHttpHostValue()\n    {\n        $request = new Request();\n        $request->initialize(array(), array(), array(), array(), array(), array('HTTP_HOST' => 'www.host.com?query=string'));\n        $request->getHost();\n    }\n\n    public function testGetSetMethod()\n    {\n        $request = new Request();\n\n        $this->assertEquals('GET', $request->getMethod(), '->getMethod() returns GET if no method is defined');\n\n        $request->setMethod('get');\n        $this->assertEquals('GET', $request->getMethod(), '->getMethod() returns an uppercased string');\n\n        $request->setMethod('PURGE');\n        $this->assertEquals('PURGE', $request->getMethod(), '->getMethod() returns the method even if it is not a standard one');\n\n        $request->setMethod('POST');\n        $this->assertEquals('POST', $request->getMethod(), '->getMethod() returns the method POST if no _method is defined');\n\n        $request->setMethod('POST');\n        $request->request->set('_method', 'purge');\n        $this->assertEquals('POST', $request->getMethod(), '->getMethod() does not return the method from _method if defined and POST but support not enabled');\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->request->set('_method', 'purge');\n\n        $this->assertFalse(Request::getHttpMethodParameterOverride(), 'httpMethodParameterOverride should be disabled by default');\n\n        Request::enableHttpMethodParameterOverride();\n\n        $this->assertTrue(Request::getHttpMethodParameterOverride(), 'httpMethodParameterOverride should be enabled now but it is not');\n\n        $this->assertEquals('PURGE', $request->getMethod(), '->getMethod() returns the method from _method if defined and POST');\n        $this->disableHttpMethodParameterOverride();\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->query->set('_method', 'purge');\n        $this->assertEquals('POST', $request->getMethod(), '->getMethod() does not return the method from _method if defined and POST but support not enabled');\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->query->set('_method', 'purge');\n        Request::enableHttpMethodParameterOverride();\n        $this->assertEquals('PURGE', $request->getMethod(), '->getMethod() returns the method from _method if defined and POST');\n        $this->disableHttpMethodParameterOverride();\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->headers->set('X-HTTP-METHOD-OVERRIDE', 'delete');\n        $this->assertEquals('DELETE', $request->getMethod(), '->getMethod() returns the method from X-HTTP-Method-Override even though _method is set if defined and POST');\n\n        $request = new Request();\n        $request->setMethod('POST');\n        $request->headers->set('X-HTTP-METHOD-OVERRIDE', 'delete');\n        $this->assertEquals('DELETE', $request->getMethod(), '->getMethod() returns the method from X-HTTP-Method-Override if defined and POST');\n    }\n\n    /**\n     * @dataProvider getClientIpsProvider\n     */\n    public function testGetClientIp($expected, $remoteAddr, $httpForwardedFor, $trustedProxies)\n    {\n        $request = $this->getRequestInstanceForClientIpTests($remoteAddr, $httpForwardedFor, $trustedProxies);\n\n        $this->assertEquals($expected[0], $request->getClientIp());\n    }\n\n    /**\n     * @dataProvider getClientIpsProvider\n     */\n    public function testGetClientIps($expected, $remoteAddr, $httpForwardedFor, $trustedProxies)\n    {\n        $request = $this->getRequestInstanceForClientIpTests($remoteAddr, $httpForwardedFor, $trustedProxies);\n\n        $this->assertEquals($expected, $request->getClientIps());\n    }\n\n    /**\n     * @dataProvider getClientIpsForwardedProvider\n     */\n    public function testGetClientIpsForwarded($expected, $remoteAddr, $httpForwarded, $trustedProxies)\n    {\n        $request = $this->getRequestInstanceForClientIpsForwardedTests($remoteAddr, $httpForwarded, $trustedProxies);\n\n        $this->assertEquals($expected, $request->getClientIps());\n    }\n\n    public function getClientIpsForwardedProvider()\n    {\n        //              $expected                                  $remoteAddr  $httpForwarded                                       $trustedProxies\n        return array(\n            array(array('127.0.0.1'),                              '127.0.0.1', 'for=\"_gazonk\"',                                      null),\n            array(array('127.0.0.1'),                              '127.0.0.1', 'for=\"_gazonk\"',                                      array('127.0.0.1')),\n            array(array('88.88.88.88'),                            '127.0.0.1', 'for=\"88.88.88.88:80\"',                               array('127.0.0.1')),\n            array(array('192.0.2.60'),                             '::1',       'for=192.0.2.60;proto=http;by=203.0.113.43',          array('::1')),\n            array(array('2620:0:1cfe:face:b00c::3', '192.0.2.43'), '::1',       'for=192.0.2.43, for=2620:0:1cfe:face:b00c::3',       array('::1')),\n            array(array('2001:db8:cafe::17'),                      '::1',       'for=\"[2001:db8:cafe::17]:4711',                      array('::1')),\n        );\n    }\n\n    public function getClientIpsProvider()\n    {\n        //        $expected                   $remoteAddr                $httpForwardedFor            $trustedProxies\n        return array(\n            // simple IPv4\n            array(array('88.88.88.88'),              '88.88.88.88',              null,                        null),\n            // trust the IPv4 remote addr\n            array(array('88.88.88.88'),              '88.88.88.88',              null,                        array('88.88.88.88')),\n\n            // simple IPv6\n            array(array('::1'),                      '::1',                      null,                        null),\n            // trust the IPv6 remote addr\n            array(array('::1'),                      '::1',                      null,                        array('::1')),\n\n            // forwarded for with remote IPv4 addr not trusted\n            array(array('127.0.0.1'),                '127.0.0.1',                '88.88.88.88',               null),\n            // forwarded for with remote IPv4 addr trusted\n            array(array('88.88.88.88'),              '127.0.0.1',                '88.88.88.88',               array('127.0.0.1')),\n            // forwarded for with remote IPv4 and all FF addrs trusted\n            array(array('88.88.88.88'),              '127.0.0.1',                '88.88.88.88',               array('127.0.0.1', '88.88.88.88')),\n            // forwarded for with remote IPv4 range trusted\n            array(array('88.88.88.88'),              '123.45.67.89',             '88.88.88.88',               array('123.45.67.0/24')),\n\n            // forwarded for with remote IPv6 addr not trusted\n            array(array('1620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '2620:0:1cfe:face:b00c::3',  null),\n            // forwarded for with remote IPv6 addr trusted\n            array(array('2620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '2620:0:1cfe:face:b00c::3',  array('1620:0:1cfe:face:b00c::3')),\n            // forwarded for with remote IPv6 range trusted\n            array(array('88.88.88.88'),              '2a01:198:603:0:396e:4789:8e99:890f', '88.88.88.88',     array('2a01:198:603:0::/65')),\n\n            // multiple forwarded for with remote IPv4 addr trusted\n            array(array('88.88.88.88', '87.65.43.21', '127.0.0.1'), '123.45.67.89', '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89')),\n            // multiple forwarded for with remote IPv4 addr and some reverse proxies trusted\n            array(array('87.65.43.21', '127.0.0.1'), '123.45.67.89',             '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89', '88.88.88.88')),\n            // multiple forwarded for with remote IPv4 addr and some reverse proxies trusted but in the middle\n            array(array('88.88.88.88', '127.0.0.1'), '123.45.67.89',             '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89', '87.65.43.21')),\n            // multiple forwarded for with remote IPv4 addr and all reverse proxies trusted\n            array(array('127.0.0.1'),                '123.45.67.89',             '127.0.0.1, 87.65.43.21, 88.88.88.88', array('123.45.67.89', '87.65.43.21', '88.88.88.88', '127.0.0.1')),\n\n            // multiple forwarded for with remote IPv6 addr trusted\n            array(array('2620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3,2620:0:1cfe:face:b00c::3', array('1620:0:1cfe:face:b00c::3')),\n            // multiple forwarded for with remote IPv6 addr and some reverse proxies trusted\n            array(array('3620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3,2620:0:1cfe:face:b00c::3', array('1620:0:1cfe:face:b00c::3', '2620:0:1cfe:face:b00c::3')),\n            // multiple forwarded for with remote IPv4 addr and some reverse proxies trusted but in the middle\n            array(array('2620:0:1cfe:face:b00c::3', '4620:0:1cfe:face:b00c::3'), '1620:0:1cfe:face:b00c::3', '4620:0:1cfe:face:b00c::3,3620:0:1cfe:face:b00c::3,2620:0:1cfe:face:b00c::3', array('1620:0:1cfe:face:b00c::3', '3620:0:1cfe:face:b00c::3')),\n\n            // client IP with port\n            array(array('88.88.88.88'), '127.0.0.1', '88.88.88.88:12345, 127.0.0.1', array('127.0.0.1')),\n\n            // invalid forwarded IP is ignored\n            array(array('88.88.88.88'), '127.0.0.1', 'unknown,88.88.88.88', array('127.0.0.1')),\n            array(array('88.88.88.88'), '127.0.0.1', '}__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:{s:2,88.88.88.88', array('127.0.0.1')),\n        );\n    }\n\n    /**\n     * @expectedException \\Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException\n     * @dataProvider getClientIpsWithConflictingHeadersProvider\n     */\n    public function testGetClientIpsWithConflictingHeaders($httpForwarded, $httpXForwardedFor)\n    {\n        $request = new Request();\n\n        $server = array(\n            'REMOTE_ADDR' => '88.88.88.88',\n            'HTTP_FORWARDED' => $httpForwarded,\n            'HTTP_X_FORWARDED_FOR' => $httpXForwardedFor,\n        );\n\n        Request::setTrustedProxies(array('88.88.88.88'));\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $request->getClientIps();\n    }\n\n    public function getClientIpsWithConflictingHeadersProvider()\n    {\n        //        $httpForwarded                   $httpXForwardedFor\n        return array(\n            array('for=87.65.43.21',                 '192.0.2.60'),\n            array('for=87.65.43.21, for=192.0.2.60', '192.0.2.60'),\n            array('for=192.0.2.60',                  '192.0.2.60,87.65.43.21'),\n            array('for=\"::face\", for=192.0.2.60',    '192.0.2.60,192.0.2.43'),\n            array('for=87.65.43.21, for=192.0.2.60', '192.0.2.60,87.65.43.21'),\n        );\n    }\n\n    /**\n     * @dataProvider getClientIpsWithAgreeingHeadersProvider\n     */\n    public function testGetClientIpsWithAgreeingHeaders($httpForwarded, $httpXForwardedFor, $expectedIps)\n    {\n        $request = new Request();\n\n        $server = array(\n            'REMOTE_ADDR' => '88.88.88.88',\n            'HTTP_FORWARDED' => $httpForwarded,\n            'HTTP_X_FORWARDED_FOR' => $httpXForwardedFor,\n        );\n\n        Request::setTrustedProxies(array('88.88.88.88'));\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $clientIps = $request->getClientIps();\n\n        $this->assertSame($expectedIps, $clientIps);\n    }\n\n    public function getClientIpsWithAgreeingHeadersProvider()\n    {\n        //        $httpForwarded                               $httpXForwardedFor\n        return array(\n            array('for=\"192.0.2.60\"',                          '192.0.2.60',             array('192.0.2.60')),\n            array('for=192.0.2.60, for=87.65.43.21',           '192.0.2.60,87.65.43.21', array('87.65.43.21', '192.0.2.60')),\n            array('for=\"[::face]\", for=192.0.2.60',            '::face,192.0.2.60',      array('192.0.2.60', '::face')),\n            array('for=\"192.0.2.60:80\"',                       '192.0.2.60',             array('192.0.2.60')),\n            array('for=192.0.2.60;proto=http;by=203.0.113.43', '192.0.2.60',             array('192.0.2.60')),\n            array('for=\"[2001:db8:cafe::17]:4711\"',            '2001:db8:cafe::17',      array('2001:db8:cafe::17')),\n        );\n    }\n\n    public function testGetContentWorksTwiceInDefaultMode()\n    {\n        $req = new Request();\n        $this->assertEquals('', $req->getContent());\n        $this->assertEquals('', $req->getContent());\n    }\n\n    public function testGetContentReturnsResource()\n    {\n        $req = new Request();\n        $retval = $req->getContent(true);\n        $this->assertInternalType('resource', $retval);\n        $this->assertEquals('', fread($retval, 1));\n        $this->assertTrue(feof($retval));\n    }\n\n    public function testGetContentReturnsResourceWhenContentSetInConstructor()\n    {\n        $req = new Request(array(), array(), array(), array(), array(), array(), 'MyContent');\n        $resource = $req->getContent(true);\n\n        $this->assertInternalType('resource', $resource);\n        $this->assertEquals('MyContent', stream_get_contents($resource));\n    }\n\n    public function testContentAsResource()\n    {\n        $resource = fopen('php://memory', 'r+');\n        fwrite($resource, 'My other content');\n        rewind($resource);\n\n        $req = new Request(array(), array(), array(), array(), array(), array(), $resource);\n        $this->assertEquals('My other content', stream_get_contents($req->getContent(true)));\n        $this->assertEquals('My other content', $req->getContent());\n    }\n\n    /**\n     * @expectedException \\LogicException\n     * @dataProvider getContentCantBeCalledTwiceWithResourcesProvider\n     */\n    public function testGetContentCantBeCalledTwiceWithResources($first, $second)\n    {\n        if (\\PHP_VERSION_ID >= 50600) {\n            $this->markTestSkipped('PHP >= 5.6 allows to open php://input several times.');\n        }\n\n        $req = new Request();\n        $req->getContent($first);\n        $req->getContent($second);\n    }\n\n    public function getContentCantBeCalledTwiceWithResourcesProvider()\n    {\n        return array(\n            'Resource then fetch' => array(true, false),\n            'Resource then resource' => array(true, true),\n        );\n    }\n\n    /**\n     * @dataProvider getContentCanBeCalledTwiceWithResourcesProvider\n     * @requires PHP 5.6\n     */\n    public function testGetContentCanBeCalledTwiceWithResources($first, $second)\n    {\n        $req = new Request();\n        $a = $req->getContent($first);\n        $b = $req->getContent($second);\n\n        if ($first) {\n            $a = stream_get_contents($a);\n        }\n\n        if ($second) {\n            $b = stream_get_contents($b);\n        }\n\n        $this->assertSame($a, $b);\n    }\n\n    public function getContentCanBeCalledTwiceWithResourcesProvider()\n    {\n        return array(\n            'Fetch then fetch' => array(false, false),\n            'Fetch then resource' => array(false, true),\n            'Resource then fetch' => array(true, false),\n            'Resource then resource' => array(true, true),\n        );\n    }\n\n    public function provideOverloadedMethods()\n    {\n        return array(\n            array('PUT'),\n            array('DELETE'),\n            array('PATCH'),\n            array('put'),\n            array('delete'),\n            array('patch'),\n        );\n    }\n\n    /**\n     * @dataProvider provideOverloadedMethods\n     */\n    public function testCreateFromGlobals($method)\n    {\n        $normalizedMethod = strtoupper($method);\n\n        $_GET['foo1'] = 'bar1';\n        $_POST['foo2'] = 'bar2';\n        $_COOKIE['foo3'] = 'bar3';\n        $_FILES['foo4'] = array('bar4');\n        $_SERVER['foo5'] = 'bar5';\n\n        $request = Request::createFromGlobals();\n        $this->assertEquals('bar1', $request->query->get('foo1'), '::fromGlobals() uses values from $_GET');\n        $this->assertEquals('bar2', $request->request->get('foo2'), '::fromGlobals() uses values from $_POST');\n        $this->assertEquals('bar3', $request->cookies->get('foo3'), '::fromGlobals() uses values from $_COOKIE');\n        $this->assertEquals(array('bar4'), $request->files->get('foo4'), '::fromGlobals() uses values from $_FILES');\n        $this->assertEquals('bar5', $request->server->get('foo5'), '::fromGlobals() uses values from $_SERVER');\n\n        unset($_GET['foo1'], $_POST['foo2'], $_COOKIE['foo3'], $_FILES['foo4'], $_SERVER['foo5']);\n\n        $_SERVER['REQUEST_METHOD'] = $method;\n        $_SERVER['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n        $request = RequestContentProxy::createFromGlobals();\n        $this->assertEquals($normalizedMethod, $request->getMethod());\n        $this->assertEquals('mycontent', $request->request->get('content'));\n\n        unset($_SERVER['REQUEST_METHOD'], $_SERVER['CONTENT_TYPE']);\n\n        Request::createFromGlobals();\n        Request::enableHttpMethodParameterOverride();\n        $_POST['_method'] = $method;\n        $_POST['foo6'] = 'bar6';\n        $_SERVER['REQUEST_METHOD'] = 'PoSt';\n        $request = Request::createFromGlobals();\n        $this->assertEquals($normalizedMethod, $request->getMethod());\n        $this->assertEquals('POST', $request->getRealMethod());\n        $this->assertEquals('bar6', $request->request->get('foo6'));\n\n        unset($_POST['_method'], $_POST['foo6'], $_SERVER['REQUEST_METHOD']);\n        $this->disableHttpMethodParameterOverride();\n    }\n\n    public function testOverrideGlobals()\n    {\n        $request = new Request();\n        $request->initialize(array('foo' => 'bar'));\n\n        // as the Request::overrideGlobals really work, it erase $_SERVER, so we must backup it\n        $server = $_SERVER;\n\n        $request->overrideGlobals();\n\n        $this->assertEquals(array('foo' => 'bar'), $_GET);\n\n        $request->initialize(array(), array('foo' => 'bar'));\n        $request->overrideGlobals();\n\n        $this->assertEquals(array('foo' => 'bar'), $_POST);\n\n        $this->assertArrayNotHasKey('HTTP_X_FORWARDED_PROTO', $_SERVER);\n\n        $request->headers->set('X_FORWARDED_PROTO', 'https');\n\n        Request::setTrustedProxies(array('1.1.1.1'));\n        $this->assertFalse($request->isSecure());\n        $request->server->set('REMOTE_ADDR', '1.1.1.1');\n        $this->assertTrue($request->isSecure());\n        Request::setTrustedProxies(array());\n\n        $request->overrideGlobals();\n\n        $this->assertArrayHasKey('HTTP_X_FORWARDED_PROTO', $_SERVER);\n\n        $request->headers->set('CONTENT_TYPE', 'multipart/form-data');\n        $request->headers->set('CONTENT_LENGTH', 12345);\n\n        $request->overrideGlobals();\n\n        $this->assertArrayHasKey('CONTENT_TYPE', $_SERVER);\n        $this->assertArrayHasKey('CONTENT_LENGTH', $_SERVER);\n\n        $request->initialize(array('foo' => 'bar', 'baz' => 'foo'));\n        $request->query->remove('baz');\n\n        $request->overrideGlobals();\n\n        $this->assertEquals(array('foo' => 'bar'), $_GET);\n        $this->assertEquals('foo=bar', $_SERVER['QUERY_STRING']);\n        $this->assertEquals('foo=bar', $request->server->get('QUERY_STRING'));\n\n        // restore initial $_SERVER array\n        $_SERVER = $server;\n    }\n\n    public function testGetScriptName()\n    {\n        $request = new Request();\n        $this->assertEquals('', $request->getScriptName());\n\n        $server = array();\n        $server['SCRIPT_NAME'] = '/index.php';\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/index.php', $request->getScriptName());\n\n        $server = array();\n        $server['ORIG_SCRIPT_NAME'] = '/frontend.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/frontend.php', $request->getScriptName());\n\n        $server = array();\n        $server['SCRIPT_NAME'] = '/index.php';\n        $server['ORIG_SCRIPT_NAME'] = '/frontend.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/index.php', $request->getScriptName());\n    }\n\n    public function testGetBasePath()\n    {\n        $request = new Request();\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $server['SCRIPT_NAME'] = '/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $server['PHP_SELF'] = '/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('', $request->getBasePath());\n\n        $server = array();\n        $server['SCRIPT_FILENAME'] = '/some/where/index.php';\n        $server['ORIG_SCRIPT_NAME'] = '/index.php';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('', $request->getBasePath());\n    }\n\n    public function testGetPathInfo()\n    {\n        $request = new Request();\n        $this->assertEquals('/', $request->getPathInfo());\n\n        $server = array();\n        $server['REQUEST_URI'] = '/path/info';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/path/info', $request->getPathInfo());\n\n        $server = array();\n        $server['REQUEST_URI'] = '/path%20test/info';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/path%20test/info', $request->getPathInfo());\n\n        $server = array();\n        $server['REQUEST_URI'] = '?a=b';\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals('/', $request->getPathInfo());\n    }\n\n    public function testGetPreferredLanguage()\n    {\n        $request = new Request();\n        $this->assertNull($request->getPreferredLanguage());\n        $this->assertNull($request->getPreferredLanguage(array()));\n        $this->assertEquals('fr', $request->getPreferredLanguage(array('fr')));\n        $this->assertEquals('fr', $request->getPreferredLanguage(array('fr', 'en')));\n        $this->assertEquals('en', $request->getPreferredLanguage(array('en', 'fr')));\n        $this->assertEquals('fr-ch', $request->getPreferredLanguage(array('fr-ch', 'fr-fr')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('en', 'en-us')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('fr', 'en')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('fr', 'en')));\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, fr-fr; q=0.6, fr; q=0.5');\n        $this->assertEquals('en', $request->getPreferredLanguage(array('fr', 'en')));\n    }\n\n    public function testIsXmlHttpRequest()\n    {\n        $request = new Request();\n        $this->assertFalse($request->isXmlHttpRequest());\n\n        $request->headers->set('X-Requested-With', 'XMLHttpRequest');\n        $this->assertTrue($request->isXmlHttpRequest());\n\n        $request->headers->remove('X-Requested-With');\n        $this->assertFalse($request->isXmlHttpRequest());\n    }\n\n    /**\n     * @requires extension intl\n     */\n    public function testIntlLocale()\n    {\n        $request = new Request();\n\n        $request->setDefaultLocale('fr');\n        $this->assertEquals('fr', $request->getLocale());\n        $this->assertEquals('fr', \\Locale::getDefault());\n\n        $request->setLocale('en');\n        $this->assertEquals('en', $request->getLocale());\n        $this->assertEquals('en', \\Locale::getDefault());\n\n        $request->setDefaultLocale('de');\n        $this->assertEquals('en', $request->getLocale());\n        $this->assertEquals('en', \\Locale::getDefault());\n    }\n\n    public function testGetCharsets()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getCharsets());\n        $request->headers->set('Accept-Charset', 'ISO-8859-1, US-ASCII, UTF-8; q=0.8, ISO-10646-UCS-2; q=0.6');\n        $this->assertEquals(array(), $request->getCharsets()); // testing caching\n\n        $request = new Request();\n        $request->headers->set('Accept-Charset', 'ISO-8859-1, US-ASCII, UTF-8; q=0.8, ISO-10646-UCS-2; q=0.6');\n        $this->assertEquals(array('ISO-8859-1', 'US-ASCII', 'UTF-8', 'ISO-10646-UCS-2'), $request->getCharsets());\n\n        $request = new Request();\n        $request->headers->set('Accept-Charset', 'ISO-8859-1,utf-8;q=0.7,*;q=0.7');\n        $this->assertEquals(array('ISO-8859-1', 'utf-8', '*'), $request->getCharsets());\n    }\n\n    public function testGetEncodings()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getEncodings());\n        $request->headers->set('Accept-Encoding', 'gzip,deflate,sdch');\n        $this->assertEquals(array(), $request->getEncodings()); // testing caching\n\n        $request = new Request();\n        $request->headers->set('Accept-Encoding', 'gzip,deflate,sdch');\n        $this->assertEquals(array('gzip', 'deflate', 'sdch'), $request->getEncodings());\n\n        $request = new Request();\n        $request->headers->set('Accept-Encoding', 'gzip;q=0.4,deflate;q=0.9,compress;q=0.7');\n        $this->assertEquals(array('deflate', 'compress', 'gzip'), $request->getEncodings());\n    }\n\n    public function testGetAcceptableContentTypes()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getAcceptableContentTypes());\n        $request->headers->set('Accept', 'application/vnd.wap.wmlscriptc, text/vnd.wap.wml, application/vnd.wap.xhtml+xml, application/xhtml+xml, text/html, multipart/mixed, */*');\n        $this->assertEquals(array(), $request->getAcceptableContentTypes()); // testing caching\n\n        $request = new Request();\n        $request->headers->set('Accept', 'application/vnd.wap.wmlscriptc, text/vnd.wap.wml, application/vnd.wap.xhtml+xml, application/xhtml+xml, text/html, multipart/mixed, */*');\n        $this->assertEquals(array('application/vnd.wap.wmlscriptc', 'text/vnd.wap.wml', 'application/vnd.wap.xhtml+xml', 'application/xhtml+xml', 'text/html', 'multipart/mixed', '*/*'), $request->getAcceptableContentTypes());\n    }\n\n    public function testGetLanguages()\n    {\n        $request = new Request();\n        $this->assertEquals(array(), $request->getLanguages());\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $this->assertEquals(array('zh', 'en_US', 'en'), $request->getLanguages());\n        $this->assertEquals(array('zh', 'en_US', 'en'), $request->getLanguages());\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.6, en; q=0.8');\n        $this->assertEquals(array('zh', 'en', 'en_US'), $request->getLanguages()); // Test out of order qvalues\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, en, en-us');\n        $this->assertEquals(array('zh', 'en', 'en_US'), $request->getLanguages()); // Test equal weighting without qvalues\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh; q=0.6, en, en-us; q=0.6');\n        $this->assertEquals(array('en', 'zh', 'en_US'), $request->getLanguages()); // Test equal weighting with qvalues\n\n        $request = new Request();\n        $request->headers->set('Accept-language', 'zh, i-cherokee; q=0.6');\n        $this->assertEquals(array('zh', 'cherokee'), $request->getLanguages());\n    }\n\n    public function testGetRequestFormat()\n    {\n        $request = new Request();\n        $this->assertEquals('html', $request->getRequestFormat());\n\n        // Ensure that setting different default values over time is possible,\n        // aka. setRequestFormat determines the state.\n        $this->assertEquals('json', $request->getRequestFormat('json'));\n        $this->assertEquals('html', $request->getRequestFormat('html'));\n\n        $request = new Request();\n        $this->assertNull($request->getRequestFormat(null));\n\n        $request = new Request();\n        $this->assertNull($request->setRequestFormat('foo'));\n        $this->assertEquals('foo', $request->getRequestFormat(null));\n    }\n\n    public function testHasSession()\n    {\n        $request = new Request();\n\n        $this->assertFalse($request->hasSession());\n        $request->setSession(new Session(new MockArraySessionStorage()));\n        $this->assertTrue($request->hasSession());\n    }\n\n    public function testGetSession()\n    {\n        $request = new Request();\n\n        $request->setSession(new Session(new MockArraySessionStorage()));\n        $this->assertTrue($request->hasSession());\n\n        $session = $request->getSession();\n        $this->assertObjectHasAttribute('storage', $session);\n        $this->assertObjectHasAttribute('flashName', $session);\n        $this->assertObjectHasAttribute('attributeName', $session);\n    }\n\n    public function testHasPreviousSession()\n    {\n        $request = new Request();\n\n        $this->assertFalse($request->hasPreviousSession());\n        $request->cookies->set('MOCKSESSID', 'foo');\n        $this->assertFalse($request->hasPreviousSession());\n        $request->setSession(new Session(new MockArraySessionStorage()));\n        $this->assertTrue($request->hasPreviousSession());\n    }\n\n    public function testToString()\n    {\n        $request = new Request();\n\n        $request->headers->set('Accept-language', 'zh, en-us; q=0.8, en; q=0.6');\n        $request->cookies->set('Foo', 'Bar');\n\n        $asString = (string) $request;\n\n        $this->assertContains('Accept-Language: zh, en-us; q=0.8, en; q=0.6', $asString);\n        $this->assertContains('Cookie: Foo=Bar', $asString);\n\n        $request->cookies->set('Another', 'Cookie');\n\n        $asString = (string) $request;\n\n        $this->assertContains('Cookie: Foo=Bar; Another=Cookie', $asString);\n    }\n\n    public function testIsMethod()\n    {\n        $request = new Request();\n        $request->setMethod('POST');\n        $this->assertTrue($request->isMethod('POST'));\n        $this->assertTrue($request->isMethod('post'));\n        $this->assertFalse($request->isMethod('GET'));\n        $this->assertFalse($request->isMethod('get'));\n\n        $request->setMethod('GET');\n        $this->assertTrue($request->isMethod('GET'));\n        $this->assertTrue($request->isMethod('get'));\n        $this->assertFalse($request->isMethod('POST'));\n        $this->assertFalse($request->isMethod('post'));\n    }\n\n    /**\n     * @dataProvider getBaseUrlData\n     */\n    public function testGetBaseUrl($uri, $server, $expectedBaseUrl, $expectedPathInfo)\n    {\n        $request = Request::create($uri, 'GET', array(), array(), array(), $server);\n\n        $this->assertSame($expectedBaseUrl, $request->getBaseUrl(), 'baseUrl');\n        $this->assertSame($expectedPathInfo, $request->getPathInfo(), 'pathInfo');\n    }\n\n    public function getBaseUrlData()\n    {\n        return array(\n            array(\n                '/fruit/strawberry/1234index.php/blah',\n                array(\n                    'SCRIPT_FILENAME' => 'E:/Sites/cc-new/public_html/fruit/index.php',\n                    'SCRIPT_NAME' => '/fruit/index.php',\n                    'PHP_SELF' => '/fruit/index.php',\n                ),\n                '/fruit',\n                '/strawberry/1234index.php/blah',\n            ),\n            array(\n                '/fruit/strawberry/1234index.php/blah',\n                array(\n                    'SCRIPT_FILENAME' => 'E:/Sites/cc-new/public_html/index.php',\n                    'SCRIPT_NAME' => '/index.php',\n                    'PHP_SELF' => '/index.php',\n                ),\n                '',\n                '/fruit/strawberry/1234index.php/blah',\n            ),\n            array(\n                '/foo%20bar/',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar',\n                '/',\n            ),\n            array(\n                '/foo%20bar/home',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar',\n                '/home',\n            ),\n            array(\n                '/foo%20bar/app.php/home',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar/app.php',\n                '/home',\n            ),\n            array(\n                '/foo%20bar/app.php/home%3Dbaz',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo bar/app.php',\n                    'SCRIPT_NAME' => '/foo bar/app.php',\n                    'PHP_SELF' => '/foo bar/app.php',\n                ),\n                '/foo%20bar/app.php',\n                '/home%3Dbaz',\n            ),\n            array(\n                '/foo/bar+baz',\n                array(\n                    'SCRIPT_FILENAME' => '/home/John Doe/public_html/foo/app.php',\n                    'SCRIPT_NAME' => '/foo/app.php',\n                    'PHP_SELF' => '/foo/app.php',\n                ),\n                '/foo',\n                '/bar+baz',\n            ),\n        );\n    }\n\n    /**\n     * @dataProvider urlencodedStringPrefixData\n     */\n    public function testUrlencodedStringPrefix($string, $prefix, $expect)\n    {\n        $request = new Request();\n\n        $me = new \\ReflectionMethod($request, 'getUrlencodedPrefix');\n        $me->setAccessible(true);\n\n        $this->assertSame($expect, $me->invoke($request, $string, $prefix));\n    }\n\n    public function urlencodedStringPrefixData()\n    {\n        return array(\n            array('foo', 'foo', 'foo'),\n            array('fo%6f', 'foo', 'fo%6f'),\n            array('foo/bar', 'foo', 'foo'),\n            array('fo%6f/bar', 'foo', 'fo%6f'),\n            array('f%6f%6f/bar', 'foo', 'f%6f%6f'),\n            array('%66%6F%6F/bar', 'foo', '%66%6F%6F'),\n            array('fo+o/bar', 'fo+o', 'fo+o'),\n            array('fo%2Bo/bar', 'fo+o', 'fo%2Bo'),\n        );\n    }\n\n    private function disableHttpMethodParameterOverride()\n    {\n        $class = new \\ReflectionClass('Symfony\\\\Component\\\\HttpFoundation\\\\Request');\n        $property = $class->getProperty('httpMethodParameterOverride');\n        $property->setAccessible(true);\n        $property->setValue(false);\n    }\n\n    private function getRequestInstanceForClientIpTests($remoteAddr, $httpForwardedFor, $trustedProxies)\n    {\n        $request = new Request();\n\n        $server = array('REMOTE_ADDR' => $remoteAddr);\n        if (null !== $httpForwardedFor) {\n            $server['HTTP_X_FORWARDED_FOR'] = $httpForwardedFor;\n        }\n\n        if ($trustedProxies) {\n            Request::setTrustedProxies($trustedProxies);\n        }\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        return $request;\n    }\n\n    private function getRequestInstanceForClientIpsForwardedTests($remoteAddr, $httpForwarded, $trustedProxies)\n    {\n        $request = new Request();\n\n        $server = array('REMOTE_ADDR' => $remoteAddr);\n\n        if (null !== $httpForwarded) {\n            $server['HTTP_FORWARDED'] = $httpForwarded;\n        }\n\n        if ($trustedProxies) {\n            Request::setTrustedProxies($trustedProxies);\n        }\n\n        $request->initialize(array(), array(), array(), array(), array(), $server);\n\n        return $request;\n    }\n\n    public function testTrustedProxiesXForwardedFor()\n    {\n        $request = Request::create('http://example.com/');\n        $request->server->set('REMOTE_ADDR', '3.3.3.3');\n        $request->headers->set('X_FORWARDED_FOR', '1.1.1.1, 2.2.2.2');\n        $request->headers->set('X_FORWARDED_HOST', 'foo.example.com:1234, real.example.com:8080');\n        $request->headers->set('X_FORWARDED_PROTO', 'https');\n        $request->headers->set('X_FORWARDED_PORT', 443);\n        $request->headers->set('X_MY_FOR', '3.3.3.3, 4.4.4.4');\n        $request->headers->set('X_MY_HOST', 'my.example.com');\n        $request->headers->set('X_MY_PROTO', 'http');\n        $request->headers->set('X_MY_PORT', 81);\n\n        // no trusted proxies\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // disabling proxy trusting\n        Request::setTrustedProxies(array());\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // request is forwarded by a non-trusted proxy\n        Request::setTrustedProxies(array('2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $this->assertEquals('1.1.1.1', $request->getClientIp());\n        $this->assertEquals('foo.example.com', $request->getHost());\n        $this->assertEquals(443, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.4', '2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // check various X_FORWARDED_PROTO header values\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $request->headers->set('X_FORWARDED_PROTO', 'ssl');\n        $this->assertTrue($request->isSecure());\n\n        $request->headers->set('X_FORWARDED_PROTO', 'https, http');\n        $this->assertTrue($request->isSecure());\n\n        // custom header names\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, 'X_MY_FOR');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_HOST, 'X_MY_HOST');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PORT, 'X_MY_PORT');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PROTO, 'X_MY_PROTO');\n        $this->assertEquals('4.4.4.4', $request->getClientIp());\n        $this->assertEquals('my.example.com', $request->getHost());\n        $this->assertEquals(81, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // disabling via empty header names\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, null);\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_HOST, null);\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PORT, null);\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PROTO, null);\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // reset\n        Request::setTrustedProxies(array());\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_IP, 'X_FORWARDED_FOR');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_HOST, 'X_FORWARDED_HOST');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PORT, 'X_FORWARDED_PORT');\n        Request::setTrustedHeaderName(Request::HEADER_CLIENT_PROTO, 'X_FORWARDED_PROTO');\n    }\n\n    public function testTrustedProxiesForwarded()\n    {\n        $request = Request::create('http://example.com/');\n        $request->server->set('REMOTE_ADDR', '3.3.3.3');\n        $request->headers->set('FORWARDED', 'for=1.1.1.1, host=foo.example.com:8080, proto=https, for=2.2.2.2, host=real.example.com:8080');\n\n        // no trusted proxies\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // disabling proxy trusting\n        Request::setTrustedProxies(array());\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // request is forwarded by a non-trusted proxy\n        Request::setTrustedProxies(array('2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $this->assertEquals('1.1.1.1', $request->getClientIp());\n        $this->assertEquals('foo.example.com', $request->getHost());\n        $this->assertEquals(8080, $request->getPort());\n        $this->assertTrue($request->isSecure());\n\n        // trusted proxy via setTrustedProxies()\n        Request::setTrustedProxies(array('3.3.3.4', '2.2.2.2'));\n        $this->assertEquals('3.3.3.3', $request->getClientIp());\n        $this->assertEquals('example.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n        $this->assertFalse($request->isSecure());\n\n        // check various X_FORWARDED_PROTO header values\n        Request::setTrustedProxies(array('3.3.3.3', '2.2.2.2'));\n        $request->headers->set('FORWARDED', 'proto=ssl');\n        $this->assertTrue($request->isSecure());\n\n        $request->headers->set('FORWARDED', 'proto=https, proto=http');\n        $this->assertTrue($request->isSecure());\n    }\n\n    /**\n     * @expectedException \\InvalidArgumentException\n     */\n    public function testSetTrustedProxiesInvalidHeaderName()\n    {\n        Request::create('http://example.com/');\n        Request::setTrustedHeaderName('bogus name', 'X_MY_FOR');\n    }\n\n    /**\n     * @expectedException \\InvalidArgumentException\n     */\n    public function testGetTrustedProxiesInvalidHeaderName()\n    {\n        Request::create('http://example.com/');\n        Request::getTrustedHeaderName('bogus name');\n    }\n\n    /**\n     * @dataProvider iisRequestUriProvider\n     */\n    public function testIISRequestUri($headers, $server, $expectedRequestUri)\n    {\n        $request = new Request();\n        $request->headers->replace($headers);\n        $request->server->replace($server);\n\n        $this->assertEquals($expectedRequestUri, $request->getRequestUri(), '->getRequestUri() is correct');\n\n        $subRequestUri = '/bar/foo';\n        $subRequest = Request::create($subRequestUri, 'get', array(), array(), array(), $request->server->all());\n        $this->assertEquals($subRequestUri, $subRequest->getRequestUri(), '->getRequestUri() is correct in sub request');\n    }\n\n    public function iisRequestUriProvider()\n    {\n        return array(\n            array(\n                array(),\n                array(\n                    'IIS_WasUrlRewritten' => '1',\n                    'UNENCODED_URL' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(),\n                array(\n                    'ORIG_PATH_INFO' => '/foo/bar',\n                ),\n                '/foo/bar',\n            ),\n            array(\n                array(),\n                array(\n                    'ORIG_PATH_INFO' => '/foo/bar',\n                    'QUERY_STRING' => 'foo=bar',\n                ),\n                '/foo/bar?foo=bar',\n            ),\n        );\n    }\n\n    public function testTrustedHosts()\n    {\n        // create a request\n        $request = Request::create('/');\n\n        // no trusted host set -> no host check\n        $request->headers->set('host', 'evil.com');\n        $this->assertEquals('evil.com', $request->getHost());\n\n        // add a trusted domain and all its subdomains\n        Request::setTrustedHosts(array('^([a-z]{9}\\.)?trusted\\.com$'));\n\n        // untrusted host\n        $request->headers->set('host', 'evil.com');\n        try {\n            $request->getHost();\n            $this->fail('Request::getHost() should throw an exception when host is not trusted.');\n        } catch (\\UnexpectedValueException $e) {\n            $this->assertEquals('Untrusted Host \"evil.com\"', $e->getMessage());\n        }\n\n        // trusted hosts\n        $request->headers->set('host', 'trusted.com');\n        $this->assertEquals('trusted.com', $request->getHost());\n        $this->assertEquals(80, $request->getPort());\n\n        $request->server->set('HTTPS', true);\n        $request->headers->set('host', 'trusted.com');\n        $this->assertEquals('trusted.com', $request->getHost());\n        $this->assertEquals(443, $request->getPort());\n        $request->server->set('HTTPS', false);\n\n        $request->headers->set('host', 'trusted.com:8000');\n        $this->assertEquals('trusted.com', $request->getHost());\n        $this->assertEquals(8000, $request->getPort());\n\n        $request->headers->set('host', 'subdomain.trusted.com');\n        $this->assertEquals('subdomain.trusted.com', $request->getHost());\n    }\n\n    public function testSetTrustedHostsDoesNotBreakOnSpecialCharacters()\n    {\n        Request::setTrustedHosts(array('localhost(\\.local){0,1}#,example.com', 'localhost'));\n\n        $request = Request::create('/');\n        $request->headers->set('host', 'localhost');\n        $this->assertSame('localhost', $request->getHost());\n    }\n\n    public function testFactory()\n    {\n        Request::setFactory(function (array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) {\n            return new NewRequest();\n        });\n\n        $this->assertEquals('foo', Request::create('/')->getFoo());\n\n        Request::setFactory(null);\n    }\n\n    /**\n     * @dataProvider getLongHostNames\n     */\n    public function testVeryLongHosts($host)\n    {\n        $start = microtime(true);\n\n        $request = Request::create('/');\n        $request->headers->set('host', $host);\n        $this->assertEquals($host, $request->getHost());\n        $this->assertLessThan(5, microtime(true) - $start);\n    }\n\n    /**\n     * @dataProvider getHostValidities\n     */\n    public function testHostValidity($host, $isValid, $expectedHost = null, $expectedPort = null)\n    {\n        $request = Request::create('/');\n        $request->headers->set('host', $host);\n\n        if ($isValid) {\n            $this->assertSame($expectedHost ?: $host, $request->getHost());\n            if ($expectedPort) {\n                $this->assertSame($expectedPort, $request->getPort());\n            }\n        } else {\n            if (method_exists($this, 'expectException')) {\n                $this->expectException('UnexpectedValueException');\n                $this->expectExceptionMessage('Invalid Host');\n            } else {\n                $this->setExpectedException('UnexpectedValueException', 'Invalid Host');\n            }\n\n            $request->getHost();\n        }\n    }\n\n    public function getHostValidities()\n    {\n        return array(\n            array('.a', false),\n            array('a..', false),\n            array('a.', true),\n            array(\"\\xE9\", false),\n            array('[::1]', true),\n            array('[::1]:80', true, '[::1]', 80),\n            array(str_repeat('.', 101), false),\n        );\n    }\n\n    public function getLongHostNames()\n    {\n        return array(\n            array('a'.str_repeat('.a', 40000)),\n            array(str_repeat(':', 101)),\n        );\n    }\n\n    /**\n     * @dataProvider methodSafeProvider\n     */\n    public function testMethodSafe($method, $safe)\n    {\n        $request = new Request();\n        $request->setMethod($method);\n        $this->assertEquals($safe, $request->isMethodSafe(false));\n    }\n\n    public function methodSafeProvider()\n    {\n        return array(\n            array('HEAD', true),\n            array('GET', true),\n            array('POST', false),\n            array('PUT', false),\n            array('PATCH', false),\n            array('DELETE', false),\n            array('PURGE', false),\n            array('OPTIONS', true),\n            array('TRACE', true),\n            array('CONNECT', false),\n        );\n    }\n\n    public function testMethodSafeChecksCacheable()\n    {\n        $request = new Request();\n        $request->setMethod('OPTIONS');\n        $this->assertFalse($request->isMethodSafe());\n    }\n\n    /**\n     * @dataProvider methodCacheableProvider\n     */\n    public function testMethodCacheable($method, $cacheable)\n    {\n        $request = new Request();\n        $request->setMethod($method);\n        $this->assertEquals($cacheable, $request->isMethodCacheable());\n    }\n\n    public function methodCacheableProvider()\n    {\n        return array(\n            array('HEAD', true),\n            array('GET', true),\n            array('POST', false),\n            array('PUT', false),\n            array('PATCH', false),\n            array('DELETE', false),\n            array('PURGE', false),\n            array('OPTIONS', false),\n            array('TRACE', false),\n            array('CONNECT', false),\n        );\n    }\n\n    public function nonstandardRequestsData()\n    {\n        return array(\n            array('',  '', '/', 'http://host:8080/', ''),\n            array('/', '', '/', 'http://host:8080/', ''),\n\n            array('hello/app.php/x',  '', '/x', 'http://host:8080/hello/app.php/x', '/hello', '/hello/app.php'),\n            array('/hello/app.php/x', '', '/x', 'http://host:8080/hello/app.php/x', '/hello', '/hello/app.php'),\n\n            array('',      'a=b', '/', 'http://host:8080/?a=b'),\n            array('?a=b',  'a=b', '/', 'http://host:8080/?a=b'),\n            array('/?a=b', 'a=b', '/', 'http://host:8080/?a=b'),\n\n            array('x',      'a=b', '/x', 'http://host:8080/x?a=b'),\n            array('x?a=b',  'a=b', '/x', 'http://host:8080/x?a=b'),\n            array('/x?a=b', 'a=b', '/x', 'http://host:8080/x?a=b'),\n\n            array('hello/x',  '', '/x', 'http://host:8080/hello/x', '/hello'),\n            array('/hello/x', '', '/x', 'http://host:8080/hello/x', '/hello'),\n\n            array('hello/app.php/x',      'a=b', '/x', 'http://host:8080/hello/app.php/x?a=b', '/hello', '/hello/app.php'),\n            array('hello/app.php/x?a=b',  'a=b', '/x', 'http://host:8080/hello/app.php/x?a=b', '/hello', '/hello/app.php'),\n            array('/hello/app.php/x?a=b', 'a=b', '/x', 'http://host:8080/hello/app.php/x?a=b', '/hello', '/hello/app.php'),\n        );\n    }\n\n    /**\n     * @dataProvider nonstandardRequestsData\n     */\n    public function testNonstandardRequests($requestUri, $queryString, $expectedPathInfo, $expectedUri, $expectedBasePath = '', $expectedBaseUrl = null)\n    {\n        if (null === $expectedBaseUrl) {\n            $expectedBaseUrl = $expectedBasePath;\n        }\n\n        $server = array(\n            'HTTP_HOST' => 'host:8080',\n            'SERVER_PORT' => '8080',\n            'QUERY_STRING' => $queryString,\n            'PHP_SELF' => '/hello/app.php',\n            'SCRIPT_FILENAME' => '/some/path/app.php',\n            'REQUEST_URI' => $requestUri,\n        );\n\n        $request = new Request(array(), array(), array(), array(), array(), $server);\n\n        $this->assertEquals($expectedPathInfo, $request->getPathInfo());\n        $this->assertEquals($expectedUri, $request->getUri());\n        $this->assertEquals($queryString, $request->getQueryString());\n        $this->assertEquals(8080, $request->getPort());\n        $this->assertEquals('host:8080', $request->getHttpHost());\n        $this->assertEquals($expectedBaseUrl, $request->getBaseUrl());\n        $this->assertEquals($expectedBasePath, $request->getBasePath());\n    }\n}\n\nclass RequestContentProxy extends Request\n{\n    public function getContent($asResource = false)\n    {\n        return http_build_query(array('_method' => 'PUT', 'content' => 'mycontent'), '', '&');\n    }\n}\n\nclass NewRequest extends Request\n{\n    public function getFoo()\n    {\n        return 'foo';\n    }\n}\n"], "filenames": ["src/Symfony/Component/HttpFoundation/CHANGELOG.md", "src/Symfony/Component/HttpFoundation/Request.php", "src/Symfony/Component/HttpFoundation/Tests/RequestTest.php"], "buggy_code_start_loc": [2, 1694, 1812], "buggy_code_end_loc": [2, 1706, 1858], "fixing_code_start_loc": [3, 1694, 1811], "fixing_code_end_loc": [9, 1695, 1813], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in Http Foundation in Symfony 2.7.0 through 2.7.48, 2.8.0 through 2.8.43, 3.3.0 through 3.3.17, 3.4.0 through 3.4.13, 4.0.0 through 4.0.13, and 4.1.0 through 4.1.2. It arises from support for a (legacy) IIS header that lets users override the path in the request URL via the X-Original-URL or X-Rewrite-URL HTTP request header. These headers are designed for IIS support, but it's not verified that the server is in fact running IIS, which means anybody who can send these requests to an application can trigger this. This affects \\Symfony\\Component\\HttpFoundation\\Request::prepareRequestUri() where X-Original-URL and X_REWRITE_URL are both used. The fix drops support for these methods so that they cannot be used as attack vectors such as web cache poisoning.", "other": {"cve": {"id": "CVE-2018-14773", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-03T17:29:00.297", "lastModified": "2021-09-29T16:21:53.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Http Foundation in Symfony 2.7.0 through 2.7.48, 2.8.0 through 2.8.43, 3.3.0 through 3.3.17, 3.4.0 through 3.4.13, 4.0.0 through 4.0.13, and 4.1.0 through 4.1.2. It arises from support for a (legacy) IIS header that lets users override the path in the request URL via the X-Original-URL or X-Rewrite-URL HTTP request header. These headers are designed for IIS support, but it's not verified that the server is in fact running IIS, which means anybody who can send these requests to an application can trigger this. This affects \\Symfony\\Component\\HttpFoundation\\Request::prepareRequestUri() where X-Original-URL and X_REWRITE_URL are both used. The fix drops support for these methods so that they cannot be used as attack vectors such as web cache poisoning."}, {"lang": "es", "value": "Se ha descubierto un problema en Http Foundation en Symfony, desde la versi\u00f3n 2.7.0 hasta la 2.7.48, desde la versi\u00f3n 2.8.0 hasta la 2.8.43, desde la versi\u00f3n 3.3.0 hasta la 3.3.17, desde la versi\u00f3n 3.4.0 hasta la 3.4.13, desde la versi\u00f3n 4.0.0 hasta la 4.0.13 y desde la versi\u00f3n 4.1.0 hasta la 4.1.2. Se origina desde el soporte a una cabecera IIS (heredada) que deja que los usuarios sobrescriban la ruta en la URL de petici\u00f3n mediante la cabecera de petici\u00f3n HTTP X-Original-URL o X-Rewrite-URL. Estas cabeceras han sido dise\u00f1adas para ser compatibles con IIS, pero no est\u00e1 verificado que el servidor est\u00e9, de hecho, ejecutando IIS, lo que significa que cualquiera que pueda enviar estas peticiones a la aplicaci\u00f3n puede desencadenar este problema. Esto afecta a \\Symfony\\Component\\HttpFoundation\\Request::prepareRequestUri() donde se emplean tanto X-Original-URL como X_REWRITE_URL. La soluci\u00f3n elimina el soporte a estos m\u00e9todos para que no puedan ser empleados como vectores de ataque, como el envenenamiento de la cach\u00e9 web."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartExcluding": "2.7.0", "versionEndIncluding": "2.7.48", "matchCriteriaId": "75150355-4AEB-4409-B8AE-413A1A7E6EA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndIncluding": "2.8.43", "matchCriteriaId": "D9158CA7-0193-4342-9A09-126D8F667591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3.0", "versionEndIncluding": "3.3.17", "matchCriteriaId": "933F48FF-3D58-455A-85D5-563A5C454020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndIncluding": "3.4.13", "matchCriteriaId": "09200F9D-A68B-4322-9626-7A869EC1E18A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.0.13", "matchCriteriaId": "77747DC8-9E86-4619-A98F-CAC8BF7BA7B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndIncluding": "4.1.2", "matchCriteriaId": "0261DC21-9664-4D09-AE19-632C0D083D48"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.5.6", "matchCriteriaId": "60BDF39F-889D-47FE-9345-BBC78FBC1A44"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104943", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1041405", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/symfony/symfony/commit/e447e8b92148ddb3d1956b96638600ec95e08f6b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/May/21", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://symfony.com/blog/cve-2018-14773-remove-support-for-legacy-and-risky-http-headers", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4441", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.drupal.org/SA-CORE-2018-005", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/e447e8b92148ddb3d1956b96638600ec95e08f6b"}}