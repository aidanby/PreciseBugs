{"buggy_code": ["// Copyright 2012-2018 (c) Peter \u0160irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module Framework\n * @version 3.2.0\n */\n\n'use strict';\n\nconst Qs = require('querystring');\nconst Os = require('os');\nconst Fs = require('fs');\nconst Zlib = require('zlib');\nconst Path = require('path');\nconst Crypto = require('crypto');\nconst Parser = require('url');\nconst Child = require('child_process');\nconst Util = require('util');\nconst http = require('http');\n\nconst ENCODING = 'utf8';\nconst HEADER_CACHE = 'Cache-Control';\nconst HEADER_TYPE = 'Content-Type';\nconst HEADER_LENGTH = 'Content-Length';\nconst CT_TEXT = 'text/plain';\nconst CT_HTML = 'text/html';\nconst CT_JSON = 'application/json';\nconst COMPRESSION = { 'text/plain': true, 'text/javascript': true, 'text/css': true, 'text/jsx': true, 'application/javascript': true, 'application/x-javascript': true, 'application/json': true, 'text/xml': true, 'image/svg+xml': true, 'text/x-markdown': true, 'text/html': true };\nconst COMPRESSIONSPECIAL = { 'js': 1, 'css': 1 };\nconst REG_TEMPORARY = /\\//g;\nconst REG_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet/i;\nconst REG_ROBOT = /search|agent|bot|crawler|spider/i;\nconst REG_VERSIONS = /(href|src)=\"[a-zA-Z0-9/:\\-._]+\\.(jpg|js|css|png|apng|gif|svg|html|ico|json|less|sass|scss|swf|txt|webp|heif|heic|jpeg|woff|woff2|xls|xlsx|xml|xsl|xslt|zip|rar|csv|doc|docx|eps|gzip|jpe|jpeg|manifest|mov|mp3|flac|mp4|ogg|package|pdf)\"/gi;\nconst REG_COMPILECSS = /url\\(.*?\\)/g;\nconst REG_ROUTESTATIC = /^(\\/\\/|https:|http:)+/;\nconst REG_NEWIMPL = /^(async\\s)?function(\\s)?([a-zA-Z$][a-zA-Z0-9$]+)?(\\s)?\\([a-zA-Z0-9$]+\\)|^function anonymous\\(\\$/;\nconst REG_RANGE = /bytes=/;\nconst REG_EMPTY = /\\s/g;\nconst REG_ACCEPTCLEANER = /\\s|\\./g;\nconst REG_SANITIZE_BACKSLASH = /\\/\\//g;\nconst REG_WEBSOCKET_ERROR = /ECONNRESET|EHOSTUNREACH|EPIPE|is closed/i;\nconst REG_WINDOWSPATH = /\\\\/g;\nconst REG_SCRIPTCONTENT = /<|>|;/;\nconst REG_HTTPHTTPS = /^(\\/)?(http|https):\\/\\//i;\nconst REG_NOCOMPRESS = /[.|-]+min(@[a-z0-9]*)?\\.(css|js)$/i;\nconst REG_WWW = /^www\\./i;\nconst REG_TEXTAPPLICATION = /text|application/;\nconst REG_ENCODINGCLEANER = /[;\\s]charset=utf-8/g;\nconst REG_SKIPERROR = /epipe|invalid\\sdistance/i;\nconst REG_OLDCONF = /-/g;\nconst REG_UTF8 = /[^\\x20-\\x7E]+/;\nconst REG_TRAVEL = /(\\/)?\\.\\.\\//g;\nconst FLAGS_INSTALL = ['get'];\nconst FLAGS_DOWNLOAD = ['get', 'dnscache'];\nconst QUERYPARSEROPTIONS = { maxKeys: 33 };\nconst EMPTYARRAY = [];\nconst EMPTYOBJECT = {};\nconst EMPTYREQUEST = { uri: {} };\nconst SINGLETONS = {};\nconst REPOSITORY_HEAD = '$head';\nconst REPOSITORY_META_TITLE = '$title';\nconst REPOSITORY_META_DESCRIPTION = '$description';\nconst REPOSITORY_META_KEYWORDS = '$keywords';\nconst REPOSITORY_META_AUTHOR = '$author';\nconst REPOSITORY_META_IMAGE = '$image';\nconst REPOSITORY_PLACE = '$place';\nconst REPOSITORY_SITEMAP = '$sitemap';\nconst REPOSITORY_COMPONENTS = '$components';\nconst ATTR_END = '\"';\nconst ETAG = '858';\nconst CONCAT = [null, null];\nconst CLUSTER_CACHE_SET = { TYPE: 'cache-set' };\nconst CLUSTER_CACHE_REMOVE = { TYPE: 'cache-remove' };\nconst CLUSTER_CACHE_REMOVEALL = { TYPE: 'cache-remove-all' };\nconst CLUSTER_CACHE_CLEAR = { TYPE: 'cache-clear' };\nconst GZIPFILE = { memLevel: 9 };\nconst GZIPSTREAM = { memLevel: 1 };\nconst MODELERROR = {};\nconst IMAGES = { jpg: 1, png: 1, gif: 1, apng: 1, jpeg: 1, heif: 1, heic: 1, webp: 1 };\n\nvar PATHMODULES = require.resolve('./index');\nPATHMODULES = PATHMODULES.substring(0, PATHMODULES.length - 8);\n\nObject.freeze(EMPTYOBJECT);\nObject.freeze(EMPTYARRAY);\nObject.freeze(EMPTYREQUEST);\n\nglobal.EMPTYOBJECT = EMPTYOBJECT;\nglobal.EMPTYARRAY = EMPTYARRAY;\nglobal.NOW = new Date();\n\nvar PROTORES, PROTOREQ;\n\nvar RANGE = { start: 0, end: 0 };\nvar HEADERS = {};\nvar SUCCESSHELPER = { success: true };\n\n// Cached headers for repeated usage\nHEADERS.responseCode = {};\nHEADERS.responseCode[HEADER_TYPE] = CT_TEXT;\nHEADERS.redirect = {};\nHEADERS.redirect[HEADER_TYPE] = CT_HTML + '; charset=utf-8';\nHEADERS.redirect[HEADER_LENGTH] = '0';\nHEADERS.sse = {};\nHEADERS.sse[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.sse['Pragma'] = 'no-cache';\nHEADERS.sse['Expires'] = '-1';\nHEADERS.sse[HEADER_TYPE] = 'text/event-stream';\nHEADERS.file_lastmodified = {};\nHEADERS.file_lastmodified['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_lastmodified[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress = {};\nHEADERS.file_release_compress[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_compress['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_compress['Content-Encoding'] = 'gzip';\nHEADERS.file_release_compress_range = {};\nHEADERS.file_release_compress_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_release_compress_range[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_compress_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_compress_range['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_compress_range['Content-Encoding'] = 'gzip';\nHEADERS.file_release_compress_range[HEADER_LENGTH] = '0';\nHEADERS.file_release_compress_range['Content-Range'] = '';\nHEADERS.file_release = {};\nHEADERS.file_release[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release['Vary'] = 'Accept-Encoding';\nHEADERS.file_release['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_range = {};\nHEADERS.file_release_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_release_range[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_range['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_range[HEADER_LENGTH] = '0';\nHEADERS.file_release_range['Content-Range'] = '';\nHEADERS.file_debug_compress = {};\nHEADERS.file_debug_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_compress['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_compress['Pragma'] = 'no-cache';\nHEADERS.file_debug_compress['Expires'] = '-1';\nHEADERS.file_debug_compress['Content-Encoding'] = 'gzip';\nHEADERS.file_debug_compress_range = {};\nHEADERS.file_debug_compress_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_debug_compress_range[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_compress_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_compress_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_compress_range['Content-Encoding'] = 'gzip';\nHEADERS.file_debug_compress_range['Pragma'] = 'no-cache';\nHEADERS.file_debug_compress_range['Expires'] = '-1';\nHEADERS.file_debug_compress_range[HEADER_LENGTH] = '0';\nHEADERS.file_debug_compress_range['Content-Range'] = '';\nHEADERS.file_debug = {};\nHEADERS.file_debug[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug['Pragma'] = 'no-cache';\nHEADERS.file_debug['Expires'] = '-1';\nHEADERS.file_debug['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_range = {};\nHEADERS.file_debug_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_debug_range[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_range['Pragma'] = 'no-cache';\nHEADERS.file_debug_range['Expires'] = '-1';\nHEADERS.file_debug_range[HEADER_LENGTH] = '0';\nHEADERS.file_debug_range['Content-Range'] = '';\nHEADERS.content_mobile_release = {};\nHEADERS.content_mobile_release[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_mobile_release['Vary'] = 'Accept-Encoding, User-Agent';\nHEADERS.content_mobile_release['Content-Encoding'] = 'gzip';\nHEADERS.content_mobile_release['Expires'] = '-1';\nHEADERS.content_mobile = {};\nHEADERS.content_mobile[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_mobile['Vary'] = 'Accept-Encoding, User-Agent';\nHEADERS.content_mobile['Expires'] = '-1';\nHEADERS.content_compress = {};\nHEADERS.content_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_compress['Vary'] = 'Accept-Encoding';\nHEADERS.content_compress['Content-Encoding'] = 'gzip';\nHEADERS.content_compress['Expires'] = '-1';\nHEADERS.content = {};\nHEADERS.content[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content['Vary'] = 'Accept-Encoding';\nHEADERS.content['Expires'] = '-1';\nHEADERS.stream_release_compress = {};\nHEADERS.stream_release_compress[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.stream_release_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_release_compress['Content-Encoding'] = 'gzip';\nHEADERS.stream_release = {};\nHEADERS.stream_release[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.stream_release['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_debug_compress = {};\nHEADERS.stream_debug_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.stream_debug_compress['Pragma'] = 'no-cache';\nHEADERS.stream_debug_compress['Expires'] = '-1';\nHEADERS.stream_debug_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_debug_compress['Content-Encoding'] = 'gzip';\nHEADERS.stream_debug = {};\nHEADERS.stream_debug[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.stream_debug['Pragma'] = 'no-cache';\nHEADERS.stream_debug['Expires'] = '-1';\nHEADERS.stream_debug['Access-Control-Allow-Origin'] = '*';\nHEADERS.binary_compress = {};\nHEADERS.binary_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.binary_compress['Content-Encoding'] = 'gzip';\nHEADERS.binary = {};\nHEADERS.binary[HEADER_CACHE] = 'public';\nHEADERS.authorization = { user: '', password: '', empty: true };\nHEADERS.fsStreamRead = { flags: 'r', mode: '0666', autoClose: true };\nHEADERS.fsStreamReadRange = { flags: 'r', mode: '0666', autoClose: true, start: 0, end: 0 };\nHEADERS.workers = { cwd: '', silent: true };\nHEADERS.responseLocalize = {};\nHEADERS.responseNotModified = {};\nHEADERS.responseNotModified[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.response503 = {};\nHEADERS.response503[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.response503[HEADER_TYPE] = CT_HTML;\n\nObject.freeze(HEADERS.authorization);\n\nvar IMAGEMAGICK = false;\nvar _controller = '';\nvar _owner = '';\nvar _flags;\nvar _prefix;\n\n// GO ONLINE MODE\n!global.framework_internal && (global.framework_internal = require('./internal'));\n!global.framework_builders && (global.framework_builders = require('./builders'));\n!global.framework_utils && (global.framework_utils = require('./utils'));\n!global.framework_mail && (global.framework_mail = require('./mail'));\n!global.framework_image && (global.framework_image = require('./image'));\n!global.framework_nosql && (global.framework_nosql = require('./nosql'));\n\nglobal.Builders = framework_builders;\nvar U = global.Utils = global.utils = global.U = global.framework_utils;\nglobal.Mail = framework_mail;\n\nglobal.WTF = (message, name, uri) => F.problem(message, name, uri);\nglobal.NOBIN = global.NOSQLBINARY = (name) => F.nosql(name).binary;\nglobal.NOSQLSTORAGE = (name) => F.nosql(name).storage;\nglobal.NOCOUNTER = global.NOSQLCOUNTER = (name) => F.nosql(name).counter;\nglobal.NOMEM = global.NOSQLMEMORY = (name, view) => global.framework_nosql.inmemory(name, view);\nglobal.CONFIG = function(name, val) {\n\treturn arguments.length === 1 ? CONF[name] : (CONF[name] = val);\n};\n\nglobal.CACHE = function(name, value, expire, persistent) {\n\treturn arguments.length === 1 ? F.cache.get2(name) : F.cache.set(name, value, expire, null, persistent);\n};\n\nglobal.UPTODATE = (type, url, options, interval, callback) => F.uptodate(type, url, options, interval, callback);\nglobal.INSTALL = (type, name, declaration, options, callback) => F.install(type, name, declaration, options, callback);\nglobal.UNINSTALL = (type, name, options) => F.uninstall(type, name, options);\nglobal.RESOURCE = (name, key) => F.resource(name, key);\nglobal.TRANSLATE = (name, key) => F.translate(name, key);\nglobal.TRANSLATOR = (name, text) => F.translator(name, text);\nglobal.TRACE = (message, name, uri, ip) => F.trace(message, name, uri, ip);\nglobal.CREATE = (group, name) => framework_builders.getschema(group, name).default();\nglobal.SCRIPT = (body, value, callback, param) => F.script(body, value, callback, param);\nglobal.SINGLETON = (name, def) => SINGLETONS[name] || (SINGLETONS[name] = (new Function('return ' + (def || '{}')))());\nglobal.FUNCTION = (name) => F.functions[name] || NOOP;\nglobal.SCHEDULE = (date, each, fn, param) => F.schedule(date, each, fn, param);\nglobal.FINISHED = framework_internal.onFinished;\nglobal.DESTROY = framework_internal.destroyStream;\nglobal.FILESTORAGE = function(name) {\n\tvar key = 'storage_' + name;\n\treturn F.databases[key] ? F.databases[key] : (F.databases[key] = new framework_nosql.DatabaseBinary({ name: name }, F.path.databases('fs-' + name + '/'), '.file'));\n};\n\nglobal.UID = function(type) {\n\n\tvar index;\n\n\tif (type) {\n\t\tif (UIDGENERATOR.types[type])\n\t\t\tindex = UIDGENERATOR.types[type] = UIDGENERATOR.types[type] + 1;\n\t\telse {\n\t\t\tUIDGENERATOR.multiple = true;\n\t\t\tindex = UIDGENERATOR.types[type] = 1;\n\t\t}\n\t} else\n\t\tindex = UIDGENERATOR.index++;\n\n\treturn UIDGENERATOR.date + index.padLeft(4, '0') + UIDGENERATOR.instance + (index % 2 ? 1 : 0);\n};\n\nglobal.ERROR = function(name) {\n\treturn name == null ? F.errorcallback : function(err) {\n\t\terr && F.error(err, name);\n\t};\n};\n\nglobal.AUTH = function(fn) {\n\tF.onAuthorize = fn;\n};\n\nglobal.WEBSOCKETCLIENT = function(callback) {\n\tvar ws = require('./websocketclient').create();\n\tcallback && callback.call(ws, ws);\n\treturn ws;\n};\n\nglobal.$CREATE = function(schema) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\treturn o ? o.default() : null;\n};\n\nglobal.$MAKE = function(schema, model, filter, callback, novalidate, argument) {\n\tschema = parseSchema(schema);\n\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tvar w = null;\n\n\tif (typeof(filter) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = filter;\n\t\tfilter = tmp;\n\t}\n\n\tif (filter instanceof Array) {\n\t\tw = {};\n\t\tfor (var i = 0; i < filter.length; i++)\n\t\t\tw[filter[i]] = i + 1;\n\t\tfilter = null;\n\t} else if (filter instanceof Object) {\n\t\tif (!(filter instanceof RegExp)) {\n\t\t\tfilter = null;\n\t\t\tw = filter;\n\t\t}\n\t}\n\n\treturn o ? o.make(model, filter, callback, argument, novalidate, w) : undefined;\n};\n\nglobal.$QUERY = function(schema, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.query(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$GET = function(schema, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.get(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$WORKFLOW = function(schema, name, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.workflow2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$TRANSFORM = function(schema, name, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.transform2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$REMOVE = function(schema, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = EMPTYOBJECT;\n\t}\n\n\tif (o)\n\t\to.remove(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$SAVE = function(schema, model, options, callback, controller) {\n\treturn performschema('$save', schema, model, options, callback, controller);\n};\n\nglobal.$INSERT = function(schema, model, options, callback, controller) {\n\treturn performschema('$insert', schema, model, options, callback, controller);\n};\n\nglobal.$UPDATE = function(schema, model, options, callback, controller) {\n\treturn performschema('$update', schema, model, options, callback, controller);\n};\n\n// type, schema, model, options, callback, controller\nfunction performschema(type, schema, model, options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = null;\n\t}\n\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\n\tif (!o) {\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\t\treturn false;\n\t}\n\n\tvar workflow = {};\n\tworkflow[type.substring(1)] = 1;\n\n\to.make(model, null, function(err, model) {\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t} else {\n\t\t\tmodel.$$controller = controller;\n\t\t\tmodel[type](options, callback);\n\t\t}\n\t}, null, false, workflow);\n\n\treturn !!o;\n}\n\nglobal.$ASYNC = function(schema, callback, index, controller) {\n\n\tif (index && typeof(index) === 'object') {\n\t\tcontroller = index;\n\t\tindex = undefined;\n\t}\n\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]).default();\n\n\tif (!o) {\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\t\treturn EMPTYOBJECT;\n\t}\n\n\tcontroller && (o.$$controller = controller);\n\treturn o.$async(callback, index);\n};\n\nglobal.$OPERATION = function(schema, name, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.operation2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.DB = global.DATABASE = function(a, b, c, d) {\n\treturn typeof(F.database) === 'object' ? F.database : F.database(a, b, c, d);\n};\n\nglobal.OFF = function() {\n\treturn arguments.length > 1 ? F.removeListener.apply(F, arguments) : F.removeAllListeners.apply(F, arguments);\n};\n\nglobal.NEWSCHEMA = function(group, name, make) {\n\n\tif (typeof(name) === 'function') {\n\t\tmake = name;\n\t\tname = undefined;\n\t}\n\n\tif (!name) {\n\t\tvar arr = group.split('/');\n\t\tif (arr.length === 2) {\n\t\t\tname = arr[1];\n\t\t\tgroup = arr[0];\n\t\t} else {\n\t\t\tname = group;\n\t\t\tgroup = 'default';\n\t\t}\n\t}\n\n\tvar schema = framework_builders.newschema(group, name);\n\tmake && make.call(schema, schema);\n\treturn schema;\n};\n\nglobal.CLEANUP = function(stream, callback) {\n\tFINISHED(stream, function() {\n\t\tDESTROY(stream);\n\t\tif (callback) {\n\t\t\tcallback();\n\t\t\tcallback = null;\n\t\t}\n\t});\n};\n\nglobal.SUCCESS = function(success, value) {\n\n\tif (typeof(success) === 'function') {\n\t\treturn function(err, value) {\n\t\t\tsuccess(err, SUCCESS(err, value));\n\t\t};\n\t}\n\n\tvar err;\n\n\tif (success instanceof Error) {\n\t\terr = success.toString();\n\t\tsuccess = false;\n\t} else if (success instanceof framework_builders.ErrorBuilder) {\n\t\tif (success.hasError()) {\n\t\t\terr = success.output();\n\t\t\tsuccess = false;\n\t\t} else\n\t\t\tsuccess = true;\n\t} else if (success == null)\n\t\tsuccess = true;\n\n\tSUCCESSHELPER.success = !!success;\n\tSUCCESSHELPER.value = value == null ? undefined : (framework_builders.isSchema(value) ? value.$clean() : value);\n\tSUCCESSHELPER.error = err ? err : undefined;\n\treturn SUCCESSHELPER;\n};\n\nglobal.TRY = function(fn, err) {\n\ttry {\n\t\tfn();\n\t\treturn true;\n\t} catch (e) {\n\t\terr && err(e);\n\t\treturn false;\n\t}\n};\n\nglobal.OBSOLETE = function(name, message) {\n\tconsole.log(NOW.format('yyyy-MM-dd HH:mm:ss') + ' :: OBSOLETE / IMPORTANT ---> \"' + name + '\"', message);\n\tif (global.F)\n\t\tF.stats.other.obsolete++;\n};\n\nglobal.DEBUG = false;\nglobal.TEST = false;\nglobal.RELEASE = false;\nglobal.is_client = false;\nglobal.is_server = true;\n\nvar directory = U.$normalize(require.main ? Path.dirname(require.main.filename) : process.cwd());\n\n// F.service() changes the values below:\nvar DATE_EXPIRES = new Date().add('y', 1).toUTCString();\n\nconst _randomstring = 'abcdefghijklmnoprstuwxy'.split('');\nfunction random3string() {\n\treturn _randomstring[(Math.random() * _randomstring.length) >> 0] + _randomstring[(Math.random() * _randomstring.length) >> 0] + _randomstring[(Math.random() * _randomstring.length) >> 0];\n}\n\nconst WEBSOCKET_COMPRESS = U.createBuffer([0x00, 0x00, 0xFF, 0xFF]);\nconst WEBSOCKET_COMPRESS_OPTIONS = { windowBits: Zlib.Z_DEFAULT_WINDOWBITS };\nconst UIDGENERATOR = { types: {}  };\n\nfunction UIDGENERATOR_REFRESH() {\n\n\tUIDGENERATOR.date = NOW.format('yyMMddHHmm');\n\tUIDGENERATOR.index = 1;\n\tUIDGENERATOR.instance = random3string();\n\n\tvar keys;\n\n\tif (UIDGENERATOR.multiple) {\n\t\tkeys = Object.keys(UIDGENERATOR.types);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tUIDGENERATOR.types[keys[i]] = 0;\n\t}\n}\n\nUIDGENERATOR_REFRESH();\n\nconst EMPTYBUFFER = U.createBufferSize(0);\nglobal.EMPTYBUFFER = EMPTYBUFFER;\n\nconst controller_error_status = function(controller, status, problem) {\n\n\tif (status !== 500 && problem)\n\t\tcontroller.problem(problem);\n\n\tif (controller.res.success || controller.res.headersSent || !controller.isConnected)\n\t\treturn controller;\n\n\tcontroller.precache && controller.precache(null, null, null);\n\tcontroller.req.path = EMPTYARRAY;\n\tcontroller.req.$total_success();\n\tcontroller.req.$total_route = F.lookup(controller.req, '#' + status, EMPTYARRAY, 0);\n\tcontroller.req.$total_exception = problem;\n\tcontroller.req.$total_execute(status, true);\n\treturn controller;\n};\n\nvar PERF = {};\n\nfunction Framework() {\n\n\tvar self = this;\n\n\tself.$id = null; // F.id ==> property\n\tself.version = 3200;\n\tself.version_header = '3.2.0';\n\tself.version_node = process.version.toString();\n\tself.syshash = (__dirname + '-' + Os.hostname() + '-' + Os.platform() + '-' + Os.arch() + '-' + Os.release() + '-' + Os.tmpdir() + JSON.stringify(process.versions)).md5();\n\n\tglobal.CONF = self.config = {\n\n\t\tdebug: true,\n\t\ttrace: true,\n\t\ttrace_console: true,\n\n\t\tname: 'Total.js',\n\t\tversion: '1.0.0',\n\t\tauthor: '',\n\t\tsecret: self.syshash,\n\t\tsecret_uid: self.syshash.substring(10),\n\n\t\t'security.txt': 'Contact: mailto:support@totaljs.com\\nContact: https://www.totaljs.com/contact/',\n\t\tetag_version: '',\n\t\tdirectory_src: '/.src/',\n\t\tdirectory_bundles: '/bundles/',\n\t\tdirectory_controllers: '/controllers/',\n\t\tdirectory_components: '/components/',\n\t\tdirectory_views: '/views/',\n\t\tdirectory_definitions: '/definitions/',\n\t\tdirectory_temp: '/tmp/',\n\t\tdirectory_models: '/models/',\n\t\tdirectory_schemas: '/schemas/',\n\t\tdirectory_operations: '/operations/',\n\t\tdirectory_resources: '/resources/',\n\t\tdirectory_public: '/public/',\n\t\tdirectory_public_virtual: '/app/',\n\t\tdirectory_modules: '/modules/',\n\t\tdirectory_source: '/source/',\n\t\tdirectory_logs: '/logs/',\n\t\tdirectory_tests: '/tests/',\n\t\tdirectory_databases: '/databases/',\n\t\tdirectory_workers: '/workers/',\n\t\tdirectory_packages: '/packages/',\n\t\tdirectory_private: '/private/',\n\t\tdirectory_isomorphic: '/isomorphic/',\n\t\tdirectory_configs: '/configs/',\n\t\tdirectory_services: '/services/',\n\t\tdirectory_themes: '/themes/',\n\n\t\t// all HTTP static request are routed to directory-public\n\t\tstatic_url: '',\n\t\tstatic_url_script: '/js/',\n\t\tstatic_url_style: '/css/',\n\t\tstatic_url_image: '/img/',\n\t\tstatic_url_video: '/video/',\n\t\tstatic_url_font: '/fonts/',\n\t\tstatic_url_download: '/download/',\n\t\tstatic_url_components: '/components.',\n\t\tstatic_accepts: { flac: true, jpg: true, jpeg: true, png: true, gif: true, ico: true, js: true, css: true, txt: true, xml: true, woff: true, woff2: true, otf: true, ttf: true, eot: true, svg: true, zip: true, rar: true, pdf: true, docx: true, xlsx: true, doc: true, xls: true, html: true, htm: true, appcache: true, manifest: true, map: true, ogv: true, ogg: true, mp4: true, mp3: true, webp: true, webm: true, swf: true, package: true, json: true, md: true, m4v: true, jsx: true, heif: true, heic: true, ics: true },\n\n\t\t// 'static-accepts-custom': [],\n\n\t\tdefault_xpoweredby: '',\n\t\tdefault_layout: 'layout',\n\t\tdefault_theme: '',\n\t\tdefault_proxy: '',\n\t\tdefault_request_maxkeys: 33,\n\n\t\t// default maximum request size / length\n\t\t// default 10 kB\n\t\tdefault_request_maxlength: 10,\n\t\tdefault_websocket_maxlength: 2,\n\t\tdefault_websocket_encodedecode: true,\n\t\tdefault_maxopenfiles: 0,\n\t\tdefault_timezone: '',\n\t\tdefault_root: '',\n\t\tdefault_response_maxage: '11111111',\n\t\tdefault_errorbuilder_status: 200,\n\n\t\t// Default originators\n\t\tdefault_cors: null,\n\n\t\t// Seconds (2 minutes)\n\t\tdefault_cors_maxage: 120,\n\n\t\t// in milliseconds\n\t\tdefault_request_timeout: 3000,\n\t\tdefault_dependency_timeout: 1500,\n\t\tdefault_restbuilder_timeout: 10000,\n\n\t\t// otherwise is used ImageMagick (Heroku supports ImageMagick)\n\t\t// gm = graphicsmagick or im = imagemagick\n\t\tdefault_image_converter: 'gm',\n\t\tdefault_image_quality: 93,\n\t\tdefault_image_consumption: 30,\n\n\t\tallow_static_files: true,\n\t\tallow_gzip: true,\n\t\tallow_websocket: true,\n\t\tallow_websocket_compression: true,\n\t\tallow_compile: true,\n\t\tallow_compile_script: true,\n\t\tallow_compile_style: true,\n\t\tallow_compile_html: true,\n\t\tallow_performance: false,\n\t\tallow_custom_titles: false,\n\t\tallow_cache_snapshot: false,\n\t\tallow_cache_cluster: false,\n\t\tallow_debug: false,\n\t\tallow_head: false,\n\t\tallow_filter_errors: true,\n\t\tallow_clear_temp: true,\n\t\tallow_ssc_validation: false,\n\t\tnosql_worker: false,\n\t\tnosql_inmemory: null, // String Array\n\t\tnosql_cleaner: 1440,\n\t\tnosql_logger: true,\n\t\tlogger: false,\n\n\t\t// Used in F.service()\n\t\t// All values are in minutes\n\t\tdefault_interval_clear_resources: 20,\n\t\tdefault_interval_clear_cache: 10,\n\t\tdefault_interval_clear_dnscache: 120,\n\t\tdefault_interval_precompile_views: 61,\n\t\tdefault_interval_websocket_ping: 3,\n\t\tdefault_interval_uptodate: 5,\n\n\t\tset ['mail-smtp'] (val) {\n\t\t\tCONF['mail_smtp'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-smtp-options'] (val) {\n\t\t\tCONF['mail_smtp_options'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-reply'] (val) {\n\t\t\tCONF['mail_address_reply'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-from'] (val) {\n\t\t\tCONF['mail_address_from'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-copy'] (val) {\n\t\t\tCONF['mail_address_copy'] = val;\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tglobal.G = self.global = {};\n\tself.$bundling = true;\n\tself.resources = {};\n\tself.connections = {};\n\tglobal.FUNC = self.functions = {};\n\tself.themes = {};\n\tself.versions = null;\n\tself.workflows = {};\n\tself.uptodates = null;\n\tself.schedules = [];\n\n\tself.isDebug = true;\n\tself.isTest = false;\n\tself.isLoaded = false;\n\tself.isWorker = true;\n\tself.isCluster = process.env.PASSENGER_APP_ENV ? false : require('cluster').isWorker;\n\n\tself.routes = {\n\t\tsitemap: null,\n\t\tweb: [],\n\t\tsystem: {},\n\t\tfiles: [],\n\t\tcors: [],\n\t\tcorsall: false,\n\t\twebsockets: [],\n\t\tmiddleware: {},\n\t\tredirects: {},\n\t\tresize: {},\n\t\trequest: [],\n\t\tviews: {},\n\t\tmerge: {},\n\t\tmapping: {},\n\t\tpackages: {},\n\t\tblocks: {},\n\t\tresources: {}\n\t};\n\n\tself.owners = [];\n\tself.modificators = null;\n\tself.helpers = {};\n\tself.modules = {};\n\tself.models = {};\n\tself.sources = {};\n\tself.controllers = {};\n\tself.dependencies = {};\n\tself.isomorphic = {};\n\tself.components = { has: false, css: false, js: false, views: {}, instances: {}, version: null, links: '', groups: {}, files: {} };\n\tself.convertors = [];\n\tself.convertors2 = null;\n\tself.tests = [];\n\tself.errors = [];\n\tself.problems = [];\n\tself.changes = [];\n\tself.server = null;\n\tself.port = 0;\n\tself.ip = '';\n\n\tself.validators = {\n\t\temail: new RegExp('^[a-zA-Z0-9-_.+]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$'),\n\t\turl: /^(https?:\\/\\/(?:www\\.|(?!www))[^\\s.#!:?+=&@!$'~*,;/()[\\]]+\\.[^\\s#!?+=&@!$'~*,;()[\\]\\\\]{2,}\\/?|www\\.[^\\s#!:.?+=&@!$'~*,;/()[\\]]+\\.[^\\s#!?+=&@!$'~*,;()[\\]\\\\]{2,}\\/?)/i,\n\t\tphone: /^[+]?[(]?[0-9]{3}[)]?[-\\s.]?[0-9]{3}[-\\s.]?[0-9]{4,6}$/im,\n\t\tzip: /^\\d{5}(?:[-\\s]\\d{4})?$/,\n\t\tuid: /^\\d{14,}[a-z]{3}[01]{1}$/\n\t};\n\n\tself.workers = {};\n\tself.databases = {};\n\tself.databasescleaner = {};\n\tself.directory = HEADERS.workers.cwd = directory;\n\tself.isLE = Os.endianness ? Os.endianness() === 'LE' : true;\n\tself.isHTTPS = false;\n\n\t// Fix for workers crash (port in use) when debugging main process with --inspect or --debug\n\t// See: https://github.com/nodejs/node/issues/14325 and https://github.com/nodejs/node/issues/9435\n\tfor (var i = 0; i < process.execArgv.length; i++) {\n\t\t// Setting inspect/debug port to random unused\n\t\tif ((/inspect|debug/).test(process.execArgv[i])) {\n\t\t\tprocess.execArgv[i] = '--inspect=0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tHEADERS.workers.execArgv = process.execArgv;\n\n\t// It's hidden\n\t// self.waits = {};\n\n\tself.temporary = {\n\t\tpath: {},\n\t\tnotfound: {},\n\t\tprocessing: {},\n\t\trange: {},\n\t\tviews: {},\n\t\tversions: {},\n\t\tdependencies: {}, // temporary for module dependencies\n\t\tother: {},\n\t\tinternal: {}, // controllers/modules names for the routing\n\t\towners: {},\n\t\tready: {},\n\t\tservice: { redirect: 0, request: 0, file: 0 }\n\t};\n\n\tself.stats = {\n\n\t\tperformance: {\n\t\t\trequest: 0,\n\t\t\tfile: 0\n\t\t},\n\n\t\tother: {\n\t\t\twebsocketPing: 0,\n\t\t\twebsocketCleaner: 0,\n\t\t\tobsolete: 0,\n\t\t\tmail: 0\n\t\t},\n\n\t\trequest: {\n\t\t\trequest: 0,\n\t\t\tpending: 0,\n\t\t\tweb: 0,\n\t\t\txhr: 0,\n\t\t\tfile: 0,\n\t\t\twebsocket: 0,\n\t\t\tget: 0,\n\t\t\toptions: 0,\n\t\t\thead: 0,\n\t\t\tpost: 0,\n\t\t\tput: 0,\n\t\t\tpath: 0,\n\t\t\tupload: 0,\n\t\t\tschema: 0,\n\t\t\toperation: 0,\n\t\t\tblocked: 0,\n\t\t\t'delete': 0,\n\t\t\tmobile: 0,\n\t\t\tdesktop: 0\n\t\t},\n\t\tresponse: {\n\t\t\tview: 0,\n\t\t\tjson: 0,\n\t\t\twebsocket: 0,\n\t\t\ttimeout: 0,\n\t\t\tcustom: 0,\n\t\t\tbinary: 0,\n\t\t\tpipe: 0,\n\t\t\tfile: 0,\n\t\t\timage: 0,\n\t\t\tdestroy: 0,\n\t\t\tstream: 0,\n\t\t\tstreaming: 0,\n\t\t\tplain: 0,\n\t\t\tempty: 0,\n\t\t\tredirect: 0,\n\t\t\tforward: 0,\n\t\t\tnotModified: 0,\n\t\t\tsse: 0,\n\t\t\terrorBuilder: 0,\n\t\t\terror400: 0,\n\t\t\terror401: 0,\n\t\t\terror403: 0,\n\t\t\terror404: 0,\n\t\t\terror408: 0,\n\t\t\terror409: 0,\n\t\t\terror431: 0,\n\t\t\terror500: 0,\n\t\t\terror501: 0,\n\t\t\terror503: 0\n\t\t}\n\t};\n\n\t// intialize cache\n\tself.cache = new FrameworkCache();\n\tself.path = global.PATH = new FrameworkPath();\n\n\tself._request_check_redirect = false;\n\tself._request_check_referer = false;\n\tself._request_check_POST = false;\n\tself._request_check_robot = false;\n\tself._request_check_mobile = false;\n\tself._length_middleware = 0;\n\tself._length_request_middleware = 0;\n\tself._length_files = 0;\n\tself._length_wait = 0;\n\tself._length_themes = 0;\n\tself._length_cors = 0;\n\tself._length_subdomain_web = 0;\n\tself._length_subdomain_websocket = 0;\n\tself._length_convertors = 0;\n\n\tself.isVirtualDirectory = false;\n\tself.isTheme = false;\n\tself.isWindows = Os.platform().substring(0, 3).toLowerCase() === 'win';\n\n\tself.$events = {};\n}\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\nFramework.prototype = {\n\tget datetime() {\n\t\treturn global.NOW;\n\t},\n\tset datetime(val) {\n\t\tglobal.NOW = val;\n\t},\n\tget cluster() {\n\t\treturn require('./cluster');\n\t},\n\tget id() {\n\t\treturn F.$id;\n\t},\n\tset id(value) {\n\t\tCLUSTER_CACHE_SET.id = value;\n\t\tCLUSTER_CACHE_REMOVE.id = value;\n\t\tCLUSTER_CACHE_REMOVEALL.id = value;\n\t\tCLUSTER_CACHE_CLEAR.id = value;\n\t\tF.$id = value;\n\t\treturn F.$id;\n\t},\n\tget onLocate() {\n\t\treturn this.onLocale;\n\t},\n\tset onLocate(value) {\n\t\tOBSOLETE('F.onLocate', 'Rename \"F.onLocate\" method for \"F.onLocale\".');\n\t\tthis.onLocale = value;\n\t}\n};\n\nvar framework = new Framework();\nglobal.framework = global.F = module.exports = framework;\n\nF.callback_redirect = function(url) {\n\tthis.url = url;\n};\n\nF.dir = function(path) {\n\tF.directory = path;\n\tdirectory = path;\n};\n\nF.refresh = function() {\n\n\tNOW = new Date();\n\n\tF.$events.clear && EMIT('clear', 'temporary', F.temporary);\n\tF.temporary.path = {};\n\tF.temporary.range = {};\n\tF.temporary.views = {};\n\tF.temporary.other = {};\n\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\n\t// Clears command cache\n\tImage.clear();\n\n\tCONF.allow_debug && F.consoledebug('clear temporary cache');\n\n\tvar keys = Object.keys(F.temporary.internal);\n\tfor (var i = 0; i < keys.length; i++)\n\t\tif (!F.temporary.internal[keys[i]])\n\t\t\tdelete F.temporary.internal[keys[i]];\n\n\tF.$events.clear && EMIT('clear', 'resources');\n\tF.resources = {};\n\tCONF.allow_debug && F.consoledebug('clear resources');\n\n\tF.$events.clear && EMIT('clear', 'dns');\n\tU.clearDNS();\n\tCONF.allow_debug && F.consoledebug('clear DNS cache');\n\n\treturn F;\n};\n\nF.prototypes = function(fn) {\n\tvar proto = {};\n\tproto.Chunker = framework_utils.Chunker.prototype;\n\tproto.Controller = Controller.prototype;\n\tproto.Database = framework_nosql.Database.prototype;\n\tproto.DatabaseBinary = framework_nosql.DatabaseBinary.prototype;\n\tproto.DatabaseBuilder = framework_nosql.DatabaseBuilder.prototype;\n\tproto.DatabaseBuilder2 = framework_nosql.DatabaseBuilder2.prototype;\n\tproto.DatabaseCounter = framework_nosql.DatabaseCounter.prototype;\n\tproto.DatabaseStorage = framework_nosql.DatabaseStorage.prototype;\n\tproto.DatabaseTable = framework_nosql.DatabaseTable.prototype;\n\tproto.ErrorBuilder = framework_builders.ErrorBuilder.prototype;\n\tproto.HttpFile = framework_internal.HttpFile.prototype;\n\tproto.HttpRequest = PROTOREQ;\n\tproto.HttpResponse = PROTORES;\n\tproto.Image = framework_image.Image.prototype;\n\tproto.Message = Mail.Message.prototype;\n\tproto.MiddlewareOptions = MiddlewareOptions;\n\tproto.OperationOptions = framework_builders.OperationOptions.prototype;\n\tproto.Page = framework_builders.Page.prototype;\n\tproto.Pagination = framework_builders.Pagination.prototype;\n\tproto.RESTBuilder = framework_builders.RESTBuilder.prototype;\n\tproto.RESTBuilderResponse = framework_builders.RESTBuilderResponse.prototype;\n\tproto.SchemaBuilder = framework_builders.SchemaBuilder.prototype;\n\tproto.SchemaOptions = framework_builders.SchemaOptions.prototype;\n\tproto.UrlBuilder = framework_builders.UrlBuilder.prototype;\n\tproto.WebSocket = WebSocket.prototype;\n\tproto.WebSocketClient = WebSocketClient.prototype;\n\tfn.call(proto, proto);\n\treturn F;\n};\n\nglobal.ON = F.on = function(name, fn) {\n\n\tif (name === 'init' || name === 'ready' || name === 'load') {\n\t\tif (F.isLoaded) {\n\t\t\tfn.call(F);\n\t\t\treturn;\n\t\t}\n\t} else if (name.indexOf('#') !== -1) {\n\t\tvar arr = name.split('#');\n\t\tswitch (arr[0]) {\n\t\t\tcase 'middleware':\n\t\t\t\tF.temporary.ready[name] && fn.call(F);\n\t\t\t\tbreak;\n\t\t\tcase 'component':\n\t\t\t\tF.temporary.ready[name] && fn.call(F);\n\t\t\t\tbreak;\n\t\t\tcase 'model':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.models[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'source':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.sources[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'package':\n\t\t\tcase 'module':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.modules[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'controller':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.controllers[arr[1]]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (F.$events[name])\n\t\tF.$events[name].push(fn);\n\telse\n\t\tF.$events[name] = [fn];\n\n\treturn F;\n};\n\nglobal.EMIT = F.emit = function(name, a, b, c, d, e, f, g) {\n\n\tvar evt = F.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(F, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tF.$events[name] = evt;\n\t\t\telse\n\t\t\t\tF.$events[name] = undefined;\n\t\t}\n\t}\n\treturn F;\n};\n\nglobal.ONCE = F.once = function(name, fn) {\n\tfn.$once = true;\n\treturn F.on(name, fn);\n};\n\nF.removeListener = function(name, fn) {\n\tvar evt = F.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tF.$events[name] = evt;\n\t\telse\n\t\t\tF.$events[name] = undefined;\n\t}\n\treturn F;\n};\n\nF.removeAllListeners = function(name) {\n\tif (name)\n\t\tF.$events[name] = undefined;\n\telse\n\t\tF.$events = {};\n\treturn F;\n};\n\n/**\n * Internal function\n * @return {String} Returns current (dependency type and name) owner.\n */\nF.$owner = function() {\n\treturn _owner;\n};\n\nF.isSuccess = function(obj) {\n\treturn obj === SUCCESSHELPER;\n};\n\nF.convert = function(value, convertor) {\n\n\tif (convertor) {\n\n\t\tif (F.convertors.findIndex('name', value) !== -1) {\n\t\t\tif (convertor == null)\n\t\t\t\tF.convertors = F.convertors.remove('name', value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (convertor === Number)\n\t\t\tconvertor = U.parseFloat;\n\t\telse if (convertor === Boolean)\n\t\t\tconvertor = U.parseBoolean;\n\t\telse if (typeof(convertor) === 'string') {\n\t\t\tswitch (convertor.toLowerCase()) {\n\t\t\t\tcase 'json':\n\t\t\t\t\tconvertor = U.parseJSON;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'double':\n\t\t\t\t\tconvertor = U.parseFloat;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'integer':\n\t\t\t\t\tconvertor = U.parseInt2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn console.log('F.convert unknown convertor type:', convertor);\n\t\t\t}\n\t\t}\n\n\t\tF.convertors.push({ name: value, convertor: convertor });\n\t\tF._length_convertors = F.convertors.length;\n\t\treturn true;\n\t}\n\n\tfor (var i = 0, length = F.convertors.length; i < length; i++) {\n\t\tif (value[F.convertors[i].name] != null)\n\t\t\tvalue[F.convertors[i].name] = F.convertors[i].convertor(value[F.convertors[i].name]);\n\t}\n\n\treturn value;\n};\n\n/**\n * Get a controller\n * @param {String} name\n * @return {Object}\n */\nF.controller = function(name) {\n\treturn F.controllers[name] || null;\n};\n\n/**\n * Use configuration\n * @param {String} filename\n * @return {Framework}\n */\nF.useConfig = function(name) {\n\treturn F.$configure_configs(name, true);\n};\n\nF.useSMTP = function(smtp, options, callback) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tMail.try(smtp, options, function(err) {\n\n\t\tif (!err) {\n\t\t\tdelete F.temporary.mail_settings;\n\t\t\tCONF.mail_smtp = smtp;\n\t\t\tCONF.mail_smtp_options = options;\n\t\t}\n\n\t\tif (callback)\n\t\t\tcallback(err);\n\t\telse if (err)\n\t\t\tF.error(err, 'F.useSMTP()', null);\n\t});\n\n\treturn F;\n};\n\n/**\n * Sort all routes\n * @return {Framework}\n */\nF.$routesSort = function(type) {\n\n\tF.routes.web.sort((a, b) => a.priority > b.priority ? -1 : a.priority < b.priority ? 1 : 0);\n\tF.routes.websockets.sort((a, b) => a.priority > b.priority ? -1 : a.priority < b.priority ? 1 : 0);\n\n\tvar cache = {};\n\tvar length = F.routes.web.length;\n\tvar url;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tvar name = F.temporary.internal[route.controller];\n\t\tif (name)\n\t\t\troute.controller = name;\n\t\tif (!route.isMOBILE || route.isUPLOAD || route.isXHR || route.isJSON || route.isSYSTEM || route.isXML || route.flags.indexOf('get') === -1)\n\t\t\tcontinue;\n\t\turl = route.url.join('/');\n\t\tcache[url] = true;\n\t}\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tif (route.isMOBILE || route.isUPLOAD || route.isXHR || route.isJSON || route.isSYSTEM || route.isXML || route.flags.indexOf('get') === -1)\n\t\t\tcontinue;\n\t\turl = route.url.join('/');\n\t\troute.isMOBILE_VARY = cache[url] === true;\n\t}\n\n\t(!type || type === 1) && F.routes.web.forEach(function(route) {\n\t\tvar tmp = F.routes.web.findItem(item => item.hash === route.hash && item !== route);\n\t\troute.isUNIQUE = tmp == null;\n\t});\n\n\t// Clears cache\n\tObject.keys(F.temporary.other).forEach(function(key) {\n\t\tif (key[0] === '1')\n\t\t\tF.temporary.other[key] = undefined;\n\t});\n\n\treturn F;\n};\n\nF.parseComponent = parseComponent;\n\nF.script = function(body, value, callback, param) {\n\n\tvar fn;\n\tvar compilation = value === undefined && callback === undefined;\n\tvar err;\n\n\ttry {\n\t\tfn = new Function('next', 'value', 'now', 'var model=value;var global,require,process,GLOBAL,root,clearImmediate,clearInterval,clearTimeout,setImmediate,setInterval,setTimeout,console,$STRING,$VIEWCACHE,framework_internal,TransformBuilder,Pagination,Page,URLBuilder,UrlBuilder,SchemaBuilder,framework_builders,framework_utils,framework_mail,Image,framework_image,framework_nosql,Builders,U,utils,Utils,Mail,WTF,SOURCE,INCLUDE,MODULE,NOSQL,NOBIN,NOCOUNTER,NOSQLMEMORY,NOMEM,DATABASE,DB,CONFIG,INSTALL,UNINSTALL,RESOURCE,TRANSLATOR,LOG,LOGGER,MODEL,GETSCHEMA,CREATE,UID,TRANSFORM,MAKE,SINGLETON,NEWTRANSFORM,NEWSCHEMA,EACHSCHEMA,FUNCTION,ROUTING,SCHEDULE,OBSOLETE,DEBUG,TEST,RELEASE,is_client,is_server,F,framework,Controller,setTimeout2,clearTimeout2,String,Number,Boolean,Object,Function,Date,isomorphic,I,eval;UPTODATE,NEWOPERATION,OPERATION,$$$,EMIT,ON,$QUERY,$GET,$WORKFLOW,$TRANSFORM,$OPERATION,$MAKE,$CREATE,HttpFile;EMPTYCONTROLLER,ROUTE,FILE,TEST,WEBSOCKET,MAIL,LOGMAIL;try{' + body + ';\\n}catch(e){next(e)}');\n\t} catch(e) {\n\t\terr = e;\n\t}\n\n\tif (err) {\n\t\tcallback && callback(err);\n\t\treturn compilation ? err : F;\n\t}\n\n\tif (compilation) {\n\t\treturn (function() {\n\t\t\treturn function(model, callback, param) {\n\t\t\t\treturn fn.call(EMPTYOBJECT, function(value) {\n\t\t\t\t\tif (value instanceof Error)\n\t\t\t\t\t\tcallback(value, undefined, param);\n\t\t\t\t\telse\n\t\t\t\t\t\tcallback(null, value, param);\n\t\t\t\t}, model, scriptNow);\n\t\t\t};\n\t\t})();\n\t}\n\n\tfn.call(EMPTYOBJECT, function(value) {\n\n\t\tif (!callback)\n\t\t\treturn;\n\n\t\tif (value instanceof Error)\n\t\t\tcallback(value);\n\t\telse\n\t\t\tcallback(null, value);\n\n\t}, value, scriptNow, param);\n\n\treturn F;\n};\n\nfunction scriptNow() {\n\treturn new Date();\n}\n\nF.database = global.NOSQL = F.nosql = function(name) {\n\tvar db = F.databases[name];\n\tif (db)\n\t\treturn db;\n\n\tvar is = name.substring(0, 6);\n\tif (is === 'http:/' || is === 'https:')\n\t\tdb = framework_nosql.load(U.getName(name), name);\n\telse {\n\t\tF.path.verify('databases');\n\t\tdb = framework_nosql.load(name, F.path.databases(name));\n\t}\n\n\tF.databases[name] = db;\n\treturn db;\n};\n\nglobal.TABLE = function(name) {\n\tvar db = F.databases['$' + name];\n\tif (db)\n\t\treturn db;\n\tF.path.verify('databases');\n\tdb = framework_nosql.table(name, F.path.databases(name));\n\tF.databases['$' + name] = db;\n\treturn db;\n};\n\nF.stop = F.kill = function(signal) {\n\n\tif (F.isKilled)\n\t\treturn F;\n\n\tF.isKilled = true;\n\n\tif (!signal)\n\t\tsignal = 'SIGTERM';\n\n\tfor (var m in F.workers) {\n\t\tvar worker = F.workers[m];\n\t\tTRY(() => worker && worker.kill && worker.kill(signal));\n\t}\n\n\tframework_nosql.kill(signal);\n\n\tEMIT('exit', signal);\n\n\tif (!F.isWorker && process.send)\n\t\tTRY(() => process.send('total:stop'));\n\n\tF.cache.stop();\n\n\tif (F.server) {\n\t\tF.server.setTimeout(1);\n\t\tF.server.close();\n\t}\n\n\tvar extenddelay = F.grapdbinstance && require('./graphdb').getImportantOperations() > 0;\n\tsetTimeout(() => process.exit(signal), global.TEST || extenddelay ? 2000 : 300);\n\treturn F;\n};\n\nglobal.REDIRECT = F.redirect = function(host, newHost, withPath, permanent) {\n\n\tvar external = host.startsWith('http://') || host.startsWith('https');\n\tif (external) {\n\n\t\tif (host[host.length - 1] === '/')\n\t\t\thost = host.substring(0, host.length - 1);\n\n\t\tif (newHost[newHost.length - 1] === '/')\n\t\t\tnewHost = newHost.substring(0, newHost.length - 1);\n\n\t\tF.routes.redirects[host] = { url: newHost, path: withPath, permanent: permanent };\n\t\tF._request_check_redirect = true;\n\t\tF.owners.push({ type: 'redirects', owner: _owner, id: host });\n\t\treturn F;\n\t}\n\n\tif (host[0] !== '/')\n\t\thost = '/' + host;\n\n\tvar flags;\n\n\tif (withPath instanceof Array) {\n\t\tflags = withPath;\n\t\twithPath = permanent === true;\n\t} else if (permanent instanceof Array) {\n\t\tflags = permanent;\n\t\twithPath = withPath === true;\n\t} else\n\t\twithPath = withPath === true;\n\n\tpermanent = withPath;\n\n\tif (U.isStaticFile(host)) {\n\t\tF.file(host, function(req, res) {\n\t\t\tif (newHost.startsWith('http://') || newHost.startsWith('https://'))\n\t\t\t\tres.redirect(newHost, permanent);\n\t\t\telse\n\t\t\t\tres.redirect(newHost[0] !== '/' ? '/' + newHost : newHost, permanent);\n\t\t});\n\t\treturn F;\n\t}\n\n\tF.route(host, function() {\n\n\t\tif (newHost.startsWith('http://') || newHost.startsWith('https://')) {\n\t\t\tthis.redirect(newHost + this.href(), permanent);\n\t\t\treturn;\n\t\t}\n\n\t\tif (newHost[0] !== '/')\n\t\t\tnewHost = '/' + newHost;\n\n\t\tthis.redirect(newHost + this.href(), permanent);\n\t}, flags);\n\n\treturn F;\n};\n\n/**\n * Schedule job\n * @param {Date or String} date\n * @param {Boolean} repeat Repeat schedule\n * @param {Function} fn\n * @return {Framework}\n */\nF.schedule = function(date, repeat, fn) {\n\n\tif (fn === undefined) {\n\t\tfn = repeat;\n\t\trepeat = false;\n\t}\n\n\tvar type = typeof(date);\n\n\tif (type === 'string') {\n\t\tdate = date.parseDate().toUTC();\n\t\trepeat && date < NOW && (date = date.add(repeat));\n\t} else if (type === 'number')\n\t\tdate = new Date(date);\n\n\tvar sum = date.getTime();\n\trepeat && (repeat = repeat.replace('each', '1'));\n\tvar id = U.GUID(5);\n\tF.schedules.push({ expire: sum, fn: fn, repeat: repeat, owner: _owner, id: id });\n\treturn id;\n};\n\nF.clearSchedule = function(id) {\n\tF.schedules = F.schedules.remove('id', id);\n\treturn F;\n};\n\n\n/**\n * Auto resize picture according the path\n * @param {String} url Relative path.\n * @param {Function(image)} fn Processing.\n * @param {String Array} flags Optional, can contains extensions `.jpg`, `.gif' or watching path `/img/gallery/`\n * @return {Framework}\n */\nF.resize = function(url, fn, flags) {\n\n\tvar extensions = {};\n\tvar cache = true;\n\n\tif (typeof(flags) === 'function') {\n\t\tvar tmp = flags;\n\t\tflags = fn;\n\t\tfn = tmp;\n\t}\n\n\tvar ext = url.match(/\\*.\\*$|\\*?\\.(jpg|png|gif|jpeg|heif|heic|apng)$/gi);\n\tif (ext) {\n\t\turl = url.replace(ext, '');\n\t\tswitch (ext.toString().toLowerCase()) {\n\t\t\tcase '*.*':\n\t\t\t\textensions['*'] = true;\n\t\t\t\tbreak;\n\t\t\tcase '*.jpg':\n\t\t\tcase '*.gif':\n\t\t\tcase '*.png':\n\t\t\tcase '*.heif':\n\t\t\tcase '*.heic':\n\t\t\tcase '*.apng':\n\t\t\tcase '*.jpeg':\n\t\t\t\textensions[ext.toString().toLowerCase().replace(/\\*/g, '').substring(1)] = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar path = url;\n\n\tif (flags && flags.length) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tif (flag[0] === '.')\n\t\t\t\textensions[flag.substring(1)] = true;\n\t\t\telse if (flag[0] === '~' || flag[0] === '/' || flag.match(/^http:|https:/gi))\n\t\t\t\tpath = flag;\n\t\t\telse if (flag === 'nocache')\n\t\t\t\tcache = false;\n\t\t}\n\t}\n\n\tif (!extensions.length) {\n\t\textensions['jpg'] = true;\n\t\textensions['jpeg'] = true;\n\t\textensions['png'] = true;\n\t\textensions['gif'] = true;\n\t\textensions['heic'] = true;\n\t\textensions['heif'] = true;\n\t\textensions['apng'] = true;\n\t}\n\n\tif (extensions['jpg'] && !extensions['jpeg'])\n\t\textensions['jpeg'] = true;\n\telse if (extensions['jpeg'] && !extensions['jpg'])\n\t\textensions['jpg'] = true;\n\n\tF.routes.resize[url] = { fn: fn, path: U.path(path || url), ishttp: path.match(/http:|https:/gi) ? true : false, extension: extensions, cache: cache };\n\tF.owners.push({ type: 'resize', owner: _owner, id: url });\n\treturn F;\n};\n\n/**\n * RESTful routing\n * @param {String} url A relative url.\n * @param {String Array} flags\n * @param {Function} onQuery\n * @param {Function(id)} onGet\n * @param {Function([id])} onSave\n * @param {Function(id)} onDelete\n * @return {Framework}\n */\nF.restful = function(url, flags, onQuery, onGet, onSave, onDelete) {\n\n\tvar tmp;\n\tvar index = flags ? flags.indexOf('cors') : -1;\n\tvar cors = {};\n\n\tif (index !== -1)\n\t\tflags.splice(index, 1);\n\n\tif (onQuery) {\n\t\ttmp = [];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onQuery);\n\t\tcors['get'] = true;\n\t}\n\n\tvar restful = U.path(url) + '{id}';\n\n\tif (onGet) {\n\t\tcors['get'] = true;\n\t\ttmp = [];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onGet);\n\t}\n\n\tif (onSave) {\n\t\tcors['post'] = true;\n\t\ttmp = ['post'];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onSave);\n\t\ttmp = ['put'];\n\t\tcors['put'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onSave);\n\t}\n\n\tif (onDelete) {\n\t\tcors['delete'] = true;\n\t\ttmp = ['delete'];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onDelete);\n\t}\n\n\tif (index !== -1)\n\t\tF.cors(U.path(url) + '*', Object.keys(cors), flags.indexOf('authorize') === -1);\n\n\treturn F;\n};\n\n// This version of RESTful doesn't create advanced routing for insert/update/delete and all URL address of all operations are without \"{id}\" param because they expect some identificator in request body\nF.restful2 = function(url, flags, onQuery, onGet, onSave, onDelete) {\n\n\tvar tmp;\n\tvar index = flags ? flags.indexOf('cors') : -1;\n\tvar cors = {};\n\n\tif (index !== -1)\n\t\tflags.splice(index, 1);\n\n\tif (onQuery) {\n\t\ttmp = [];\n\t\tcors['get'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onQuery);\n\t}\n\n\tif (onGet) {\n\t\ttmp = [];\n\t\tcors['get'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(U.path(url) + '{id}', tmp, onGet);\n\t}\n\n\tif (onSave) {\n\t\ttmp = ['post'];\n\t\tcors['post'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onSave);\n\t}\n\n\tif (onDelete) {\n\t\ttmp = ['delete'];\n\t\tcors['delete'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onDelete);\n\t}\n\n\tif (index !== -1)\n\t\tF.cors(U.path(url) + '*', Object.keys(cors), flags.indexOf('authorize') === -1);\n\n\treturn F;\n};\n\n/**\n * Register cors\n * @param {String} url\n * @param {String Array or String} origin\n * @param {String Array or String} methods\n * @param {String Array or String} headers\n * @param {Boolean} credentials\n * @return {Framework}\n */\nglobal.CORS = F.cors = function(url, flags, credentials) {\n\n\tif (!arguments.length) {\n\t\tF.routes.corsall = true;\n\t\tPERF.OPTIONS = true;\n\t\treturn F;\n\t}\n\n\tif (flags === true) {\n\t\tcredentials = true;\n\t\tflags = null;\n\t}\n\n\tvar route = {};\n\tvar origin = [];\n\tvar methods = [];\n\tvar headers = [];\n\tvar age;\n\tvar id;\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tvar type = typeof(flag);\n\n\t\t\tif (type === 'string')\n\t\t\t\tflag = flag.toLowerCase();\n\t\t\telse if (type === 'number') {\n\t\t\t\tage = flag;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type === 'boolean' || flag.startsWith('credential')) {\n\t\t\t\tcredentials = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.substring(0, 2) === '//') {\n\t\t\t\torigin.push(flag.substring(2));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t\torigin.push(flag.substring(flag.indexOf('/') + 2));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.substring(0, 3) === 'id:') {\n\t\t\t\tid = flag.substring(3);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flag) {\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'get':\n\t\t\t\t\tmethods.push(flag.toUpperCase());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\theaders.push(flags[i].toLowerCase());\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!methods.length)\n\t\tmethods = 'POST,PUT,GET,DELETE,PATCH,GET,HEAD'.split(',');\n\n\tif (!origin.length && CONF.default_cors)\n\t\torigin = CONF.default_cors;\n\n\troute.isWILDCARD = url.lastIndexOf('*') !== -1;\n\n\tvar index = url.indexOf('{');\n\tif (index !== -1) {\n\t\troute.isWILDCARD = true;\n\t\turl = url.substring(0, index);\n\t}\n\n\tif (route.isWILDCARD)\n\t\turl = url.replace('*', '');\n\n\tif (url[url.length - 1] !== '/')\n\t\turl += '/';\n\n\turl = framework_internal.preparePath(framework_internal.encodeUnicodeURL(url.trim()));\n\troute.hash = url.hash();\n\troute.owner = _owner;\n\troute.url = framework_internal.routeSplitCreate(url);\n\troute.origin = origin.length ? origin : null;\n\troute.methods = methods.length ? methods : null;\n\troute.headers = headers.length ? headers : null;\n\troute.credentials = credentials;\n\troute.age = age || CONF.default_cors_maxage;\n\n\tvar e = F.routes.cors.findItem(function(item) {\n\t\treturn item.hash === route.hash;\n\t});\n\n\tif (e) {\n\n\t\t// Extends existing\n\t\tif (route.origin && e.origin)\n\t\t\tcorsextend(route.origin, e.origin);\n\t\telse if (e.origin && !route.origin)\n\t\t\te.origin = null;\n\n\t\tif (route.methods && e.methods)\n\t\t\tcorsextend(route.methods, e.methods);\n\n\t\tif (route.headers && e.headers)\n\t\t\tcorsextend(route.headers, e.headers);\n\n\t\tif (route.credentials && !e.credentials)\n\t\t\te.credentials = true;\n\n\t\tif (route.isWILDCARD && !e.isWILDCARD)\n\t\t\te.isWILDCARD = true;\n\n\t} else {\n\t\tF.routes.cors.push(route);\n\t\troute.id = id;\n\t}\n\n\tF._length_cors = F.routes.cors.length;\n\n\tF.routes.cors.sort(function(a, b) {\n\t\tvar al = a.url.length;\n\t\tvar bl = b.url.length;\n\t\treturn al > bl ? - 1 : al < bl ? 1 : a.isWILDCARD && b.isWILDCARD ? 1 : 0;\n\t});\n\n\tPERF.OPTIONS = true;\n\treturn F;\n};\n\nfunction corsextend(a, b) {\n\tfor (var i = 0; i < a.length; i++)\n\t\tb.indexOf(a[i]) === -1 && b.push(a[i]);\n}\n\nglobal.GROUP = F.group = function() {\n\n\tvar fn = null;\n\n\t_flags = null;\n\t_prefix = null;\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar o = arguments[i];\n\n\t\tif (o instanceof Array) {\n\t\t\t_flags = o;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (typeof(o)) {\n\t\t\tcase 'string':\n\t\t\t\tif (o.endsWith('/'))\n\t\t\t\t\to = o.substring(0, o.length - 1);\n\t\t\t\t_prefix = o;\n\t\t\t\tbreak;\n\t\t\tcase 'function':\n\t\t\t\tfn = o;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfn && fn.call(F);\n\t_prefix = undefined;\n\t_flags = undefined;\n\treturn F;\n};\n\n/**\n * Add a route\n * @param {String} url\n * @param {Function} funcExecute Action.\n * @param {String Array} flags\n * @param {Number} length Maximum length of request data.\n * @param {String Array} middleware Loads custom middleware.\n * @param {Number} timeout Response timeout.\n * @return {Framework}\n */\nglobal.ROUTE = F.web = F.route = function(url, funcExecute, flags, length, language) {\n\n\tvar name;\n\tvar tmp;\n\tvar viewname;\n\tvar sitemap;\n\n\tif (url instanceof Array) {\n\t\turl.forEach(url => F.route(url, funcExecute, flags, length));\n\t\treturn F;\n\t}\n\n\tif (typeof(flags) === 'number') {\n\t\tlength = flags;\n\t\tflags = null;\n\t}\n\n\tvar type = typeof(funcExecute);\n\n\tif (funcExecute instanceof Array) {\n\t\ttmp = funcExecute;\n\t\tfuncExecute = flags;\n\t\tflags = tmp;\n\t}\n\n\tvar search = (typeof(url) === 'string' ? url.toLowerCase().replace(/\\s{2,}/g, ' ') : '') + (flags ? (' ' + flags.where(n => typeof(n) === 'string' && n.substring(0, 2) !== '//' && n[2] !== ':').join(' ')).toLowerCase() : '');\n\tvar method = '';\n\tvar CUSTOM = typeof(url) === 'function' ? url : null;\n\tif (CUSTOM)\n\t\turl = '/';\n\n\tif (url) {\n\n\t\turl = url.replace(/\\t/g, ' ');\n\n\t\turl = url.replace(/(^|\\s?)\\*([{}a-z0-9}]|\\s).*?$/i, function(text) {\n\t\t\t!flags && (flags = []);\n\t\t\tflags.push(text.trim());\n\t\t\treturn '';\n\t\t}).trim();\n\n\t\tvar index = url.indexOf(' ');\n\t\tif (index !== -1) {\n\t\t\tmethod = url.substring(0, index).toLowerCase().trim();\n\t\t\turl = url.substring(index + 1).trim();\n\t\t}\n\n\t\tif (method.indexOf(',') !== -1) {\n\t\t\t!flags && (flags = []);\n\t\t\tmethod.split(',').forEach(m => flags.push(m.trim()));\n\t\t\tmethod = '';\n\t\t}\n\t}\n\n\tif (url[0] === '#') {\n\t\turl = url.substring(1);\n\t\tif (url !== '400' && url !== '401' && url !== '403' && url !== '404' && url !== '408' && url !== '409' && url !== '431' && url !== '500' && url !== '501') {\n\n\t\t\tvar sitemapflags = funcExecute instanceof Array ? funcExecute : flags;\n\t\t\tif (!(sitemapflags instanceof Array))\n\t\t\t\tsitemapflags = EMPTYARRAY;\n\n\t\t\tvar index = url.indexOf('/');\n\t\t\tif (index !== -1) {\n\t\t\t\ttmp = url.substring(index);\n\t\t\t\turl = url.substring(0, index);\n\t\t\t} else\n\t\t\t\ttmp = '';\n\n\t\t\tsitemap = F.sitemap(url, true, language);\n\n\t\t\tif (sitemap) {\n\n\t\t\t\tname = url;\n\t\t\t\turl = sitemap.url;\n\n\t\t\t\tif (sitemap.localizeUrl && language === undefined) {\n\t\t\t\t\tvar sitemaproutes = {};\n\t\t\t\t\tF.temporary.internal.resources.forEach(function(language) {\n\t\t\t\t\t\tvar item = F.sitemap(sitemap.id, true, language);\n\t\t\t\t\t\tif (item.url && item.url !== url)\n\t\t\t\t\t\t\tsitemaproutes[item.url] = { name: sitemap.id, language: language };\n\t\t\t\t\t});\n\t\t\t\t\tObject.keys(sitemaproutes).forEach(key => F.route('#' + sitemap.id, funcExecute, flags, length, sitemaproutes[key].language));\n\t\t\t\t}\n\n\t\t\t\tif (tmp)\n\t\t\t\t\turl += url[url.length - 1] === '/' ? tmp.substring(1) : tmp;\n\t\t\t\telse if (sitemap.wildcard)\n\t\t\t\t\turl += '*';\n\t\t\t} else\n\t\t\t\tthrow new Error('Sitemap item \"' + url + '\" not found.');\n\t\t} else\n\t\t\turl = '#' + url;\n\t}\n\n\tif (!url)\n\t\turl = '/';\n\n\tif (url[0] !== '[' && url[0] !== '/')\n\t\turl = '/' + url;\n\n\tif (_prefix)\n\t\turl = _prefix + url;\n\n\tif (url.endsWith('/'))\n\t\turl = url.substring(0, url.length - 1);\n\n\turl = framework_internal.encodeUnicodeURL(url);\n\n\tvar urlcache = url;\n\n\tif (!name)\n\t\tname = url;\n\n\tif (method) {\n\t\t!flags && (flags = []);\n\t\tflags.push(method);\n\t\tmethod = '';\n\t}\n\n\tvar priority = 0;\n\tvar subdomain = null;\n\n\tpriority = url.count('/');\n\n\tif (url[0] === '[') {\n\t\tindex = url.indexOf(']');\n\t\tif (index > 0) {\n\t\t\tsubdomain = url.substring(1, index).trim().toLowerCase().split(',');\n\t\t\turl = url.substring(index + 1);\n\t\t\tpriority += subdomain.indexOf('*') !== -1 ? 50 : 100;\n\t\t}\n\t}\n\n\tvar isWILDCARD = url.indexOf('*') !== -1;\n\tif (isWILDCARD) {\n\t\turl = url.replace('*', '').replace('//', '/');\n\t\tpriority = priority - 100;\n\t}\n\n\tvar isRaw = false;\n\tvar isNOXHR = false;\n\tvar schema;\n\tvar workflow;\n\tvar isMOBILE = false;\n\tvar isJSON = false;\n\tvar isDELAY = false;\n\tvar isROBOT = false;\n\tvar isBINARY = false;\n\tvar isCORS = false;\n\tvar isROLE = false;\n\tvar novalidate = false;\n\tvar middleware = null;\n\tvar timeout;\n\tvar options;\n\tvar corsflags = [];\n\tvar membertype = 0;\n\tvar isGENERATOR = false;\n\tvar isDYNAMICSCHEMA = false;\n\tvar description;\n\tvar id = null;\n\tvar groups = [];\n\n\tif (_flags) {\n\t\t!flags && (flags = []);\n\t\t_flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\t}\n\n\tif (flags) {\n\n\t\ttmp = [];\n\t\tvar count = 0;\n\n\t\tfor (var i = 0; i < flags.length; i++) {\n\n\t\t\tvar tt = typeof(flags[i]);\n\n\t\t\tif (tt === 'number') {\n\t\t\t\ttimeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tt === 'object') {\n\t\t\t\toptions = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tflags[i] = flags[i].replace(/\\t/g, ' ');\n\n\t\t\tvar first = flags[i][0];\n\t\t\tif (first === '&') {\n\t\t\t\tgroups.push(flags[i].substring(1).trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ROUTE identificator\n\t\t\tif (flags[i].substring(0, 3) === 'id:') {\n\t\t\t\tid = flags[i].substring(3).trim();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first === '#') {\n\t\t\t\t!middleware && (middleware = []);\n\t\t\t\tmiddleware.push(flags[i].substring(1).trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first === '*') {\n\n\t\t\t\tworkflow = flags[i].trim().substring(1);\n\t\t\t\tindex = workflow.indexOf('-->');\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tschema = workflow.substring(0, index).trim();\n\t\t\t\t\tworkflow = workflow.substring(index + 3).trim();\n\t\t\t\t} else {\n\t\t\t\t\tschema = workflow;\n\t\t\t\t\tworkflow = null;\n\t\t\t\t}\n\n\t\t\t\tschema = schema.replace(/\\\\/g, '/').split('/').trim();\n\n\t\t\t\tif (schema.length) {\n\n\t\t\t\t\tif (schema.length === 1) {\n\t\t\t\t\t\tschema[1] = schema[0];\n\t\t\t\t\t\tschema[0] = 'default';\n\n\t\t\t\t\t\t// Is dynamic schema?\n\t\t\t\t\t\tif (schema[1][0] === '{') {\n\t\t\t\t\t\t\tisDYNAMICSCHEMA = true;\n\t\t\t\t\t\t\tschema[1] = schema[1].substring(1, schema[1].length - 1).trim();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = schema[1].indexOf('#');\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tschema[2] = schema[1].substring(index + 1).trim();\n\t\t\t\t\t\tschema[1] = schema[1].substring(0, index).trim();\n\t\t\t\t\t\t(schema[2] && schema[2][0] !== '*') && (schema[2] = '*' + schema[2]);\n\t\t\t\t\t}\n\n\t\t\t\t} // else it's an operation\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Comment\n\t\t\tif (flags[i].substring(0, 3) === '// ') {\n\t\t\t\tdescription = flags[i].substring(3).trim();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar flag = flags[i].toString().toLowerCase();\n\t\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t\tcorsflags.push(flag);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tswitch (flag) {\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tisJSON = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'delay':\n\t\t\t\t\tcount--;\n\t\t\t\t\tisDELAY = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'binary':\n\t\t\t\t\tisBINARY = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'cors':\n\t\t\t\t\tisCORS = true;\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'credential':\n\t\t\t\tcase 'credentials':\n\t\t\t\t\tcorsflags.push(flag);\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'sync':\n\t\t\t\tcase 'yield':\n\t\t\t\tcase 'synchronize':\n\t\t\t\t\tisGENERATOR = true;\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'novalidate':\n\t\t\t\t\tnovalidate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'noxhr':\n\t\t\t\tcase '-xhr':\n\t\t\t\t\tisNOXHR = true;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'raw':\n\t\t\t\t\tisRaw = true;\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tisMOBILE = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'robot':\n\t\t\t\t\tisROBOT = true;\n\t\t\t\t\tF._request_check_robot = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'authorize':\n\t\t\t\tcase 'authorized':\n\t\t\t\tcase 'logged':\n\t\t\t\t\tmembertype = 1;\n\t\t\t\t\tpriority += 2;\n\t\t\t\t\ttmp.push('authorize');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unauthorize':\n\t\t\t\tcase 'unauthorized':\n\t\t\t\tcase 'unlogged':\n\t\t\t\t\tmembertype = 2;\n\t\t\t\t\tpriority += 2;\n\t\t\t\t\ttmp.push('unauthorize');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'referer':\n\t\t\t\tcase 'referrer':\n\t\t\t\t\ttmp.push('referer');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'propfind':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'trace':\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tmethod += (method ? ',' : '') + flag;\n\t\t\t\t\tcorsflags.push(flag);\n\t\t\t\t\tPERF[flag.toUpperCase()] = true;\n\t\t\t\t\tPERF[flag] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (flag[0] === '@')\n\t\t\t\t\t\tisROLE = true;\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flag === 'get')\n\t\t\t\tpriority -= 2;\n\n\t\t}\n\n\t\tif (isROLE && !membertype) {\n\t\t\ttmp.push('authorize');\n\t\t\tpriority += 2;\n\t\t\tmembertype = 1;\n\t\t\tcount++;\n\t\t}\n\n\t\tflags = tmp;\n\t\tpriority += (count * 2);\n\t} else {\n\t\tflags = ['get'];\n\t\tmethod = 'get';\n\t}\n\n\tif (workflow && workflow[0] === '@') {\n\t\tvar tmpa = workflow.replace(/,/g, ' ').split('@').trim();\n\t\tvar rindex = null;\n\t\tfor (var i = 0; i < tmpa.length; i++) {\n\t\t\tvar a = tmpa[i].split(' ');\n\t\t\tif (a[1] && (/response|res/i).test(a[1]))\n\t\t\t\trindex = i;\n\t\t\ttmpa[i] = a[0];\n\t\t}\n\t\tworkflow = { id: tmpa.length > 1 ? tmpa : tmpa[0], index: rindex };\n\t}\n\n\tif (type === 'string') {\n\t\tviewname = funcExecute;\n\t\tfuncExecute = (function(name, sitemap, language, workflow) {\n\t\t\tvar themeName = U.parseTheme(name);\n\t\t\tif (themeName)\n\t\t\t\tname = prepare_viewname(name);\n\t\t\treturn function(id) {\n\t\t\t\tif (language && !this.language)\n\t\t\t\t\tthis.language = language;\n\t\t\t\tsitemap && this.sitemap(sitemap.id, language);\n\t\t\t\tif (name[0] === '~')\n\t\t\t\t\tthis.themeName = '';\n\t\t\t\telse if (themeName)\n\t\t\t\t\tthis.themeName = themeName;\n\t\t\t\tif (!this.route.workflow)\n\t\t\t\t\treturn this.view(name);\n\n\t\t\t\tvar self = this;\n\t\t\t\tif (this.route.workflow instanceof Object) {\n\t\t\t\t\tworkflow.view = name;\n\t\t\t\t\tif (workflow.id instanceof Array)\n\t\t\t\t\t\tcontroller_json_workflow_multiple.call(self, id);\n\t\t\t\t\telse\n\t\t\t\t\t\tcontroller_json_workflow.call(self, id);\n\t\t\t\t} else {\n\t\t\t\t\tthis.$exec(this.route.workflow, null, function(err, response) {\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tself.content(err);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tself.view(name, response);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t})(viewname, sitemap, language, workflow);\n\t} else if (typeof(funcExecute) !== 'function') {\n\n\t\tviewname = (sitemap && sitemap.url !== '/' ? sitemap.id : workflow ? '' : url) || '';\n\t\tif (!workflow || (!viewname && !workflow)) {\n\t\t\tif (viewname.endsWith('/'))\n\t\t\t\tviewname = viewname.substring(0, viewname.length - 1);\n\n\t\t\tindex = viewname.lastIndexOf('/');\n\t\t\tif (index !== -1)\n\t\t\t\tviewname = viewname.substring(index + 1);\n\n\t\t\tif (!viewname || viewname === '/')\n\t\t\t\tviewname = 'index';\n\n\t\t\tfuncExecute = (function(name, sitemap, language) {\n\t\t\t\treturn function(id) {\n\t\t\t\t\tvar self = this;\n\n\t\t\t\t\tif (language && !self.language)\n\t\t\t\t\t\tself.language = language;\n\n\t\t\t\t\tsitemap && self.sitemap(sitemap.id, language);\n\n\t\t\t\t\tif (name[0] === '~')\n\t\t\t\t\t\tself.themeName = '';\n\n\t\t\t\t\tif (!self.route.workflow)\n\t\t\t\t\t\treturn self.view(name);\n\n\t\t\t\t\tif (self.route.workflow instanceof Object) {\n\t\t\t\t\t\tworkflow.view = name;\n\t\t\t\t\t\tif (workflow.id instanceof Array)\n\t\t\t\t\t\t\tcontroller_json_workflow_multiple.call(self, id);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontroller_json_workflow.call(self, id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.$exec(self.route.workflow, null, function(err, response) {\n\t\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\t\tself.content(err);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tself.view(name, response);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(viewname, sitemap, language);\n\t\t} else if (workflow)\n\t\t\tfuncExecute = workflow.id instanceof Array ? controller_json_workflow_multiple : controller_json_workflow;\n\t}\n\n\tif (!isGENERATOR)\n\t\tisGENERATOR = (funcExecute.constructor.name === 'GeneratorFunction' || funcExecute.toString().indexOf('function*') === 0);\n\n\tvar url2 = framework_internal.preparePath(url.trim());\n\tvar urlraw = U.path(url2) + (isWILDCARD ? '*' : '');\n\tvar hash = url2.hash();\n\tvar routeURL = framework_internal.routeSplitCreate(url2);\n\tvar arr = [];\n\tvar params = [];\n\tvar reg = null;\n\tvar regIndex = null;\n\tvar dynamicidindex = -1;\n\n\tif (url.indexOf('{') !== -1) {\n\t\trouteURL.forEach(function(o, i) {\n\t\t\tif (o.substring(0, 1) !== '{')\n\t\t\t\treturn;\n\n\t\t\tarr.push(i);\n\n\t\t\tvar sub = o.substring(1, o.length - 1);\n\t\t\tvar name = o.substring(1, o.length - 1).trim();\n\n\t\t\tif (name === 'id')\n\t\t\t\tdynamicidindex = i;\n\n\t\t\tparams.push(name);\n\n\t\t\tif (sub[0] !== '/')\n\t\t\t\treturn;\n\n\t\t\tvar index = sub.lastIndexOf('/');\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = {};\n\t\t\t\tregIndex = [];\n\t\t\t}\n\n\t\t\tparams[params.length - 1] = 'regexp' + (regIndex.length + 1);\n\t\t\treg[i] = new RegExp(sub.substring(1, index), sub.substring(index + 1));\n\t\t\tregIndex.push(i);\n\t\t});\n\n\t\tpriority -= arr.length + 1;\n\t}\n\n\tif (url.indexOf('#') !== -1)\n\t\tpriority -= 100;\n\n\tif ((isJSON || flags.indexOf('xml') !== -1 || isRaw) && (flags.indexOf('delete') === -1 && flags.indexOf('post') === -1 && flags.indexOf('put') === -1) && flags.indexOf('patch') === -1) {\n\t\tflags.push('post');\n\t\tmethod += (method ? ',' : '') + 'post';\n\t\tpriority++;\n\t}\n\n\tif (flags.indexOf('upload') !== -1) {\n\t\tif (flags.indexOf('post') === -1 && flags.indexOf('put') === -1) {\n\t\t\tflags.push('post');\n\t\t\tmethod += (method ? ',' : '') + 'post';\n\t\t}\n\t}\n\n\tif (flags.indexOf('get') === -1 && flags.indexOf('options') === -1 && flags.indexOf('post') === -1 && flags.indexOf('delete') === -1 && flags.indexOf('put') === -1 && flags.indexOf('upload') === -1 && flags.indexOf('head') === -1 && flags.indexOf('trace') === -1 && flags.indexOf('patch') === -1 && flags.indexOf('propfind') === -1) {\n\t\tflags.push('get');\n\t\tmethod += (method ? ',' : '') + 'get';\n\t}\n\n\tif (CONF.allow_head && flags.indexOf('get') !== -1) {\n\t\tflags.append('head');\n\t\tmethod += (method ? ',' : '') + 'head';\n\t}\n\n\tif (flags.indexOf('referer') !== -1)\n\t\tF._request_check_referer = true;\n\n\tif (!F._request_check_POST && (flags.indexOf('delete') !== -1 || flags.indexOf('post') !== -1 || flags.indexOf('put') !== -1 || flags.indexOf('upload') !== -1 || flags.indexOf('json') !== -1 || flags.indexOf('patch') !== -1 || flags.indexOf('options') !== -1))\n\t\tF._request_check_POST = true;\n\n\tvar isMULTIPLE = false;\n\n\tif (method.indexOf(',') !== -1)\n\t\tisMULTIPLE = true;\n\n\tif (method.indexOf(',') !== -1 || method === '')\n\t\tmethod = undefined;\n\telse\n\t\tmethod = method.toUpperCase();\n\n\tif (name[1] === '#')\n\t\tname = name.substring(1);\n\n\tif (isBINARY && !isRaw) {\n\t\tisBINARY = false;\n\t\tconsole.warn('F.route() skips \"binary\" flag because the \"raw\" flag is not defined.');\n\t}\n\n\tif (workflow && workflow.id) {\n\t\tworkflow.meta = {};\n\t\tif (workflow.id instanceof Array) {\n\t\t\tfor (var i = 0; i < workflow.id.length; i++)\n\t\t\t\tworkflow.meta[workflow.id[i]] = i + 1;\n\t\t} else\n\t\t\tworkflow.meta[workflow.id] = 1;\n\t}\n\n\tif (subdomain)\n\t\tF._length_subdomain_web++;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.hash = hash;\n\tr.search = search.split(' ');\n\tr.id = id;\n\tr.name = name.trim();\n\tr.groups = flags_to_object(groups);\n\tr.priority = priority;\n\tr.sitemap = sitemap ? sitemap.id : '';\n\tr.schema = schema;\n\tr.novalidate = novalidate;\n\tr.workflow = workflow;\n\tr.subdomain = subdomain;\n\tr.description = description;\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.urlraw = urlraw;\n\tr.url = routeURL;\n\tr.param = arr;\n\tr.paramidindex = isDYNAMICSCHEMA ? dynamicidindex : -1;\n\tr.paramnames = params.length ? params : null;\n\tr.flags = flags || EMPTYARRAY;\n\tr.flags2 = flags_to_object(flags);\n\tr.method = method;\n\tr.execute = funcExecute;\n\tr.length = (length || CONF.default_request_maxlength) * 1024;\n\tr.middleware = middleware;\n\tr.timeout = timeout === undefined ? (isDELAY ? 0 : CONF.default_request_timeout) : timeout;\n\tr.isGET = flags.indexOf('get') !== -1;\n\tr.isMULTIPLE = isMULTIPLE;\n\tr.isJSON = isJSON;\n\tr.isXML = flags.indexOf('xml') !== -1;\n\tr.isRAW = isRaw;\n\tr.isBINARY = isBINARY;\n\tr.isMOBILE = isMOBILE;\n\tr.isROBOT = isROBOT;\n\tr.isMOBILE_VARY = isMOBILE;\n\tr.isGENERATOR = isGENERATOR;\n\tr.MEMBER = membertype;\n\tr.isWILDCARD = isWILDCARD;\n\tr.isROLE = isROLE;\n\tr.isREFERER = flags.indexOf('referer') !== -1;\n\tr.isHTTPS = flags.indexOf('https') !== -1;\n\tr.isHTTP = flags.indexOf('http') !== -1;\n\tr.isDEBUG = flags.indexOf('debug') !== -1;\n\tr.isRELEASE = flags.indexOf('release') !== -1;\n\tr.isBOTH = isNOXHR ? false : true;\n\tr.isXHR = flags.indexOf('xhr') !== -1;\n\tr.isUPLOAD = flags.indexOf('upload') !== -1;\n\tr.isSYSTEM = url.startsWith('/#');\n\tr.isCACHE = !url.startsWith('/#') && !CUSTOM && !arr.length && !isWILDCARD;\n\tr.isPARAM = arr.length > 0;\n\tr.isDELAY = isDELAY;\n\tr.isDYNAMICSCHEMA = isDYNAMICSCHEMA;\n\tr.CUSTOM = CUSTOM;\n\tr.options = options;\n\tr.regexp = reg;\n\tr.regexpIndexer = regIndex;\n\tr.type = 'web';\n\tr.remove = remove_route_web;\n\n\tif (r.isUPLOAD)\n\t\tPERF.upload = true;\n\tif (r.isJSON)\n\t\tPERF.json = true;\n\tif (r.isXML)\n\t\tPERF.xml = true;\n\tif (r.isBINARY)\n\t\tPERF.binary = true;\n\tif (r.MEMBER === 1)\n\t\tPERF.auth = true;\n\tif (r.MEMBER === 2)\n\t\tPERF.unauth = true;\n\n\tvar arr = method ? method.split(',') : EMPTYARRAY;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tPERF[arr[i]] = true;\n\t\tPERF[arr[i].toLowerCase()] = true;\n\t}\n\n\tif (r.isSYSTEM)\n\t\tF.routes.system[url.substring(1)] = r;\n\telse {\n\t\tF.routes.web.push(r);\n\n\t\t// Appends cors route\n\t\tisCORS && F.cors(urlcache, corsflags);\n\t\t!_controller && F.$routesSort(1);\n\t}\n\n\tif (isMOBILE)\n\t\tF._request_check_mobile = true;\n\n\tEMIT('route', 'web', instance);\n\treturn instance;\n};\n\nfunction flags_to_object(flags) {\n\tvar obj = {};\n\tflags.forEach(flag => obj[flag] = true);\n\treturn obj;\n}\n\nfunction remove_route_web() {\n\n\tif (this.isSYSTEM) {\n\t\tvar keys = Object.keys(F.routes.system);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (F.routes.system[keys[i]] === this) {\n\t\t\t\tdelete F.routes.system[keys];\n\t\t\t\tF.temporary.other = {};\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar index = F.routes.web.indexOf(this);\n\tif (index !== -1) {\n\t\tF.routes.web.splice(index, 1);\n\t\tF.$routesSort();\n\t\tF.temporary.other = {};\n\t}\n}\n\n/**\n * Get routing by name\n * @param {String} name\n * @return {Object}\n */\nglobal.ROUTING = F.routing = function(name, flags) {\n\n\tvar id = name.substring(0, 3) === 'id:' ? name.substring(3) : null;\n\tif (id)\n\t\tname = null;\n\n\tvar search = id ? null : (name.toLowerCase().replace(/\\s{2,}/g, ' ') + (flags ? (' ' + flags.where(n => typeof(n) === 'string' && n.substring(0, 2) !== '//' && n[2] !== ':').join(' ')).toLowerCase() : '')).split(' ');\n\n\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tvar is = true;\n\t\tif (id && route.id !== id)\n\t\t\tis = false;\n\t\telse if (search) {\n\t\t\tfor (var j = 0; j < search.length; j++) {\n\t\t\t\tif (route.search.indexOf(search[j]) === -1) {\n\t\t\t\t\tis = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!is)\n\t\t\tcontinue;\n\n\t\tvar url = U.path(route.url.join('/'));\n\t\tif (url[0] !== '/')\n\t\t\turl = '/' + url;\n\n\t\treturn route;\n\t}\n};\n\n/**\n * Merge files\n * @param {String} url Relative URL.\n * @param {String/String Array} file1 Filename or URL.\n * @param {String/String Array} file2 Filename or URL.\n * @param {String/String Array} file3 Filename or URL.\n * @param {String/String Array} fileN Filename or URL.\n * @return {Framework}\n */\nglobal.MERGE = F.merge = function(url) {\n\n\tF.temporary.other['merge_' + url] = 1;\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\turl = F.$version(url);\n\n\tif (url === 'auto') {\n\t\t// auto-generating\n\t\tvar arg = arguments;\n\t\tsetTimeout(function(arg) {\n\t\t\tF.merge.apply(F, arg);\n\t\t}, 500, arg);\n\t\treturn F;\n\t}\n\n\turl = framework_internal.preparePath(url);\n\n\tvar arr = [];\n\n\tfor (var i = 1, length = arguments.length; i < length; i++) {\n\n\t\tvar items = arguments[i];\n\t\tif (!(items instanceof Array))\n\t\t\titems = [items];\n\n\t\tfor (var j = 0, lengthsub = items.length; j < lengthsub; j++) {\n\t\t\tvar fn = items[j];\n\t\t\tvar c = fn[0];\n\t\t\tif (c === '@')\n\t\t\t\tfn = '~' + F.path.package(fn.substring(1));\n\t\t\telse if (c === '=')\n\t\t\t\tfn = '~' + F.path.themes(fn.substring(1));\n\t\t\telse if (c === '#')\n\t\t\t\tfn = '~' + F.path.temp('isomorphic_' + fn.substring(1) + '.min.js');\n\t\t\tarr.push(fn);\n\t\t}\n\t}\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar key = createTemporaryKey(url);\n\tvar filename = F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'merged_' + key);\n\tF.routes.merge[url] = { filename: filename.replace(/\\.(js|css)$/g, ext => '.min' + ext), files: arr };\n\tFs.unlink(F.routes.merge[url].filename, NOOP);\n\tF.owners.push({ type: 'merge', owner: _owner, id: url });\n\tdelete F.temporary.notfound[key];\n\treturn F;\n};\n\nF.mapping = function() {\n\treturn F.map.apply(F, arguments);\n};\n\n/**\n * Send message\n * @param  {Object} message\n * @param  {Object} handle\n * @return {Framework}\n */\nF.send = function(message, handle) {\n\tprocess.send(message, handle);\n\treturn F;\n};\n\n/**\n * Mapping of static file\n * @param {String} url\n * @param {String} filename\tFilename or Directory.\n * @param {Function(filename) or String Array} filter\n * @return {Framework}\n */\nglobal.MAP = F.map = function(url, filename, filter) {\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar isPackage = false;\n\n\tfilename = U.$normalize(filename);\n\turl = framework_internal.preparePath(F.$version(url));\n\n\t// isomorphic\n\tif (filename[0] === '#') {\n\t\tF.owners.push({ type: 'mapping', owner: _owner, id: url });\n\t\tF.routes.mapping[url] = F.path.temp('isomorphic_' + filename.substring(1) + '.min.js');\n\t\treturn F;\n\t}\n\n\tvar index = filename.indexOf('#');\n\tvar block;\n\n\tif (index !== -1) {\n\t\tvar tmp = filename.split('#');\n\t\tfilename = tmp[0];\n\t\tblock = tmp[1];\n\t}\n\n\tvar c = filename[0];\n\n\t// package\n\tif (c === '@') {\n\t\tfilename = F.path.package(filename.substring(1));\n\t\tisPackage = true;\n\t} else if (c === '=') {\n\t\tif (F.isWindows)\n\t\t\tfilename = U.combine(CONF.directory_themes, filename.substring(1));\n\t\telse\n\t\t\tfilename = F.path.themes(filename.substring(1));\n\t\tisPackage = true;\n\t}\n\n\tvar isFile = U.getExtension(filename).length > 0;\n\n\t// Checks if the directory exists\n\tif (!isPackage && !filename.startsWith(directory)) {\n\t\tvar tmp = filename[0] === '~' ? F.path.root(filename.substring(1)) : F.path.public(filename);\n\t\tif (existsSync(tmp))\n\t\t\tfilename = tmp;\n\t}\n\n\tif (isFile) {\n\t\tF.routes.mapping[url] = filename;\n\t\tF.owners.push({ type: 'mapping', owner: _owner, id: url });\n\t\tif (block) {\n\t\t\tF.owners.push({ type: 'blocks', owner: _owner, id: url });\n\t\t\tF.routes.blocks[url] = block;\n\t\t}\n\t\treturn F;\n\t}\n\n\turl = U.path(url);\n\tfilename = U.path(filename);\n\n\tvar replace = filename;\n\tvar plus = '';\n\tvar isRoot = false;\n\n\tif (replace[0] === '/')\n\t\tisRoot = true;\n\n\tif (replace[0] === '~') {\n\t\tplus += '~';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (replace[0] === '.') {\n\t\tplus += '.';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (!isRoot && replace[0] === '/') {\n\t\tplus += '/';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (filter instanceof Array) {\n\t\tfor (var i = 0, length = filter.length; i < length; i++) {\n\t\t\tif (filter[i][0] === '.')\n\t\t\t\tfilter[i] = filter[i].substring(1);\n\t\t\tfilter[i] = filter[i].toLowerCase();\n\t\t}\n\t}\n\n\tsetTimeout(function() {\n\t\tU.ls(F.isWindows ? filename.replace(/\\//g, '\\\\') : filename, function(files) {\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\n\t\t\t\tif (F.isWindows)\n\t\t\t\t\tfiles[i] = files[i].replace(filename, '').replace(/\\\\/g, '/');\n\n\t\t\t\tvar file = files[i].replace(replace, '');\n\n\t\t\t\tif (filter) {\n\t\t\t\t\tif (typeof(filter) === 'function') {\n\t\t\t\t\t\tif (!filter(file))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (filter.indexOf(U.getExtension(file)) === -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (file[0] === '/')\n\t\t\t\t\tfile = file.substring(1);\n\n\t\t\t\tvar key = url + file;\n\t\t\t\tF.routes.mapping[key] = plus + files[i];\n\t\t\t\tF.owners.push({ type: 'mapping', owner: _owner, id: key });\n\n\t\t\t\tif (block) {\n\t\t\t\t\tF.owners.push({ type: 'blocks', owner: _owner, id: key });\n\t\t\t\t\tF.routes.blocks[key] = block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}, isPackage ? 500 : 1);\n\n\treturn F;\n};\n\n/**\n * Add a middleware\n * @param {String} name\n * @param {Function(req, res, next, options)} funcExecute\n * @return {Framework}\n */\nglobal.MIDDLEWARE = F.middleware = function(name, funcExecute) {\n\tF.install('middleware', name, funcExecute);\n\t_owner && F.owners.push({ type: 'middleware', owner: _owner, id: name });\n\treturn F;\n};\n\n/**\n * Uses middleware\n * @name {String or String Array} name\n * @url {String} url A url address (optional)\n * @types {String Array} It can be `web`, `file` or `websocket`\n * @first {Boolean} Optional, add a middleware as first\n * @return {Framework}\n */\nF.use = function(name, url, types, first) {\n\n\tif (typeof(name) === 'function') {\n\t\tvar tmp = 'mid' + GUID(5);\n\t\tMIDDLEWARE(tmp, name);\n\t\tname = tmp;\n\t}\n\n\tif (!url && !types) {\n\t\tif (name instanceof Array) {\n\t\t\tfor (var i = 0; i < name.length; i++)\n\t\t\t\tF.routes.request.push(name[i]);\n\t\t} else\n\t\t\tF.routes.request.push(name);\n\t\tF._length_request_middleware = F.routes.request.length;\n\t\treturn F;\n\t}\n\n\tif (url instanceof Array) {\n\t\ttypes = url;\n\t\turl = null;\n\t}\n\n\tif (url === '*')\n\t\turl = null;\n\n\tvar route;\n\n\tif (url)\n\t\turl = framework_internal.routeSplitCreate(framework_internal.preparePath(url.trim())).join('/');\n\n\tif (!types || types.indexOf('web') !== -1) {\n\t\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\t\troute = F.routes.web[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\tif (!types || types.indexOf('file') !== -1 || types.indexOf('files') !== -1) {\n\t\tfor (var i = 0, length = F.routes.files.length; i < length; i++) {\n\t\t\troute = F.routes.files[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\tif (!types || types.indexOf('websocket') !== -1 || types.indexOf('websockets') !== -1) {\n\t\tfor (var i = 0, length = F.routes.websockets.length; i < length; i++) {\n\t\t\troute = F.routes.websockets[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\treturn F;\n};\n\nfunction merge_middleware(a, b, first) {\n\n\tif (typeof(b) === 'string')\n\t\tb = [b];\n\n\tfor (var i = 0, length = b.length; i < length; i++) {\n\t\tvar index = a.indexOf(b[i]);\n\t\tif (index === -1) {\n\t\t\tif (first)\n\t\t\t\ta.unshift(b[i]);\n\t\t\telse\n\t\t\t\ta.push(b[i]);\n\t\t}\n\t}\n\n\treturn a;\n}\n\n/**\n * Add a new websocket route\n * @param {String} url\n * @param {Function()} funcInitialize\n * @param {String Array} flags Optional.\n * @param {String Array} protocols Optional, framework compares this array with request protocol (http or https)\n * @param {String Array} allow Optional, framework compares this array with \"origin\" request header\n * @param {Number} length Optional, maximum message length.\n * @param {String Array} middleware Optional, middlewares.\n * @param {Object} options Optional, additional options for middleware.\n * @return {Framework}\n */\nglobal.WEBSOCKET = F.websocket = function(url, funcInitialize, flags, length) {\n\n\tvar tmp;\n\n\tvar CUSTOM = typeof(url) === 'function' ? url : null;\n\tif (CUSTOM)\n\t\turl = '/';\n\n\tif (url[0] === '#') {\n\n\t\tvar index = url.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\ttmp = url.substring(index);\n\t\t\turl = url.substring(0, index);\n\t\t}\n\n\t\turl = url.substring(1);\n\t\tvar sitemap = F.sitemap(url, true);\n\t\tif (sitemap) {\n\t\t\turl = sitemap.url;\n\t\t\tif (tmp)\n\t\t\t\turl += url[url.length - 1] === '/' ? tmp.substring(1) : tmp;\n\t\t\telse if (sitemap.wildcard)\n\t\t\t\turl += '*';\n\t\t} else\n\t\t\tthrow new Error('Sitemap item \"' + url + '\" not found.');\n\t}\n\n\tif (url === '')\n\t\turl = '/';\n\n\t// Unicode encoding\n\turl = framework_internal.encodeUnicodeURL(url);\n\n\tvar priority = 0;\n\tvar index = url.indexOf(']');\n\tvar subdomain = null;\n\tvar middleware;\n\tvar allow;\n\tvar options;\n\tvar protocols;\n\tvar id;\n\tvar groups = [];\n\n\tpriority = url.count('/');\n\n\tif (index > 0) {\n\t\tsubdomain = url.substring(1, index).trim().toLowerCase().split(',');\n\t\turl = url.substring(index + 1);\n\t\tpriority += subdomain.indexOf('*') !== -1 ? 50 : 100;\n\t}\n\n\tvar isWILDCARD = url.indexOf('*') !== -1;\n\tif (isWILDCARD) {\n\t\turl = url.replace('*', '').replace('//', '/');\n\t\tpriority = (-10) - priority;\n\t}\n\n\tvar url2 = framework_internal.preparePath(url.trim());\n\tvar routeURL = framework_internal.routeSplitCreate(url2);\n\tvar arr = [];\n\tvar reg = null;\n\tvar regIndex = null;\n\tvar hash = url2.hash();\n\tvar urlraw = U.path(url2) + (isWILDCARD ? '*' : '');\n\tvar params = [];\n\n\tif (url.indexOf('{') !== -1) {\n\t\trouteURL.forEach(function(o, i) {\n\n\t\t\tif (o.substring(0, 1) !== '{')\n\t\t\t\treturn;\n\n\t\t\tarr.push(i);\n\n\t\t\tvar sub = o.substring(1, o.length - 1);\n\t\t\tvar name = o.substring(1, o.length - 1).trim();\n\n\t\t\tparams.push(name);\n\n\t\t\tif (sub[0] !== '/')\n\t\t\t\treturn;\n\n\t\t\tvar index = sub.lastIndexOf('/');\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = {};\n\t\t\t\tregIndex = [];\n\t\t\t}\n\n\t\t\tparams[params.length - 1] = 'regexp' + (regIndex.length + 1);\n\t\t\treg[i] = new RegExp(sub.substring(1, index), sub.substring(index + 1));\n\t\t\tregIndex.push(i);\n\t\t});\n\t}\n\n\tif (typeof(allow) === 'string')\n\t\tallow = allow[allow];\n\n\tif (typeof(protocols) === 'string')\n\t\tprotocols = protocols[protocols];\n\n\ttmp = [];\n\n\tvar isJSON = false;\n\tvar isBINARY = false;\n\tvar isROLE = false;\n\tvar count = 0;\n\tvar membertype = 0;\n\n\t!flags && (flags = []);\n\t_flags && _flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\n\tfor (var i = 0; i < flags.length; i++) {\n\n\t\tvar flag = flags[i];\n\t\tvar type = typeof(flag);\n\n\t\t// Middleware options\n\t\tif (type === 'object') {\n\t\t\toptions = flag;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Length\n\t\tif (type === 'number') {\n\t\t\tlength = flag;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flag.substring(0, 3) === 'id:') {\n\t\t\tid = flag.substring(3).trim();\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Groups\n\t\tif (flag[0] === '&') {\n\t\t\tgroups.push(flag.substring(1).trim());\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Middleware\n\t\tif (flag[0] === '#') {\n\t\t\t!middleware && (middleware = []);\n\t\t\tmiddleware.push(flag.substring(1).trim());\n\t\t\tcontinue;\n\t\t}\n\n\t\tflag = flag.toString().toLowerCase();\n\n\t\t// Origin\n\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t!allow && (allow = []);\n\t\t\tallow.push(flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (flag === 'json')\n\t\t\tisJSON = true;\n\n\t\tif (flag === 'binary')\n\t\t\tisBINARY = true;\n\n\t\tif (flag === 'raw') {\n\t\t\tisBINARY = false;\n\t\t\tisJSON = false;\n\t\t}\n\n\t\tif (flag[0] === '@') {\n\t\t\tisROLE = true;\n\t\t\ttmp.push(flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flag === 'json' || flag === 'binary' || flag === 'raw')\n\t\t\tcontinue;\n\n\t\tswitch (flag) {\n\t\t\tcase 'authorize':\n\t\t\tcase 'authorized':\n\t\t\tcase 'logged':\n\t\t\t\tmembertype = 1;\n\t\t\t\tpriority++;\n\t\t\t\ttmp.push('authorize');\n\t\t\t\tbreak;\n\t\t\tcase 'unauthorize':\n\t\t\tcase 'unauthorized':\n\t\t\tcase 'unlogged':\n\t\t\t\tmembertype = 2;\n\t\t\t\tpriority++;\n\t\t\t\ttmp.push('unauthorize');\n\t\t\t\tbreak;\n\t\t\tcase 'get':\n\t\t\tcase 'http':\n\t\t\tcase 'https':\n\t\t\tcase 'debug':\n\t\t\tcase 'release':\n\t\t\t\ttmp.push(flag);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t!protocols && (protocols = []);\n\t\t\t\tprotocols.push(flag);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isROLE && !membertype) {\n\t\ttmp.push('authorize');\n\t\tmembertype = 1;\n\t\tpriority++;\n\t\tcount++;\n\t}\n\n\tflags = tmp;\n\n\tflags.indexOf('get') === -1 && flags.unshift('get');\n\tpriority += (count * 2);\n\n\tif (subdomain)\n\t\tF._length_subdomain_websocket++;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.id = id;\n\tr.urlraw = urlraw;\n\tr.hash = hash;\n\tr.groups = flags_to_object(groups);\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.url = routeURL;\n\tr.paramnames = params.length ? params : null;\n\tr.param = arr;\n\tr.subdomain = subdomain;\n\tr.priority = priority;\n\tr.flags = flags || EMPTYARRAY;\n\tr.flags2 = flags_to_object(flags);\n\tr.onInitialize = funcInitialize;\n\tr.protocols = protocols || EMPTYARRAY;\n\tr.allow = allow || [];\n\tr.length = (length || CONF.default_websocket_maxlength) * 1024;\n\tr.isWEBSOCKET = true;\n\tr.MEMBER = membertype;\n\tr.isJSON = isJSON;\n\tr.isBINARY = isBINARY;\n\tr.isROLE = isROLE;\n\tr.isWILDCARD = isWILDCARD;\n\tr.isHTTPS = flags.indexOf('https');\n\tr.isHTTP = flags.indexOf('http');\n\tr.isDEBUG = flags.indexOf('debug');\n\tr.isRELEASE = flags.indexOf('release');\n\tr.CUSTOM = CUSTOM;\n\tr.middleware = middleware ? middleware : null;\n\tr.options = options;\n\tr.isPARAM = arr.length > 0;\n\tr.regexp = reg;\n\tr.regexpIndexer = regIndex;\n\tr.type = 'websocket';\n\tF.routes.websockets.push(r);\n\tF.initwebsocket && F.initwebsocket();\n\tEMIT('route', 'websocket', r);\n\t!_controller && F.$routesSort(2);\n\treturn instance;\n};\n\nF.initwebsocket = function() {\n\tif (F.routes.websockets.length && CONF.allow_websocket && F.server) {\n\t\tF.server.on('upgrade', F.$upgrade);\n\t\tF.initwebsocket = null;\n\t}\n};\n\n/**\n * Create a file route\n * @param {String} name\n * @param {Function} funcValidation\n * @param {Function} fnExecute\n * @param {String Array} middleware\n * @return {Framework}\n */\nglobal.FILE = F.file = function(fnValidation, fnExecute, flags) {\n\n\tvar a;\n\n\tif (fnValidation instanceof Array) {\n\t\ta = fnExecute;\n\t\tvar b = flags;\n\t\tflags = fnValidation;\n\t\tfnValidation = a;\n\t\tfnExecute = b;\n\t} else if (fnExecute instanceof Array) {\n\t\ta = fnExecute;\n\t\tfnExecute = flags;\n\t\tflags = a;\n\t}\n\n\tif (!fnExecute && fnValidation) {\n\t\tfnExecute = fnValidation;\n\t\tfnValidation = undefined;\n\t}\n\n\tvar extensions;\n\tvar middleware;\n\tvar options;\n\tvar url;\n\tvar wildcard = false;\n\tvar fixedfile = false;\n\tvar id = null;\n\tvar urlraw = fnValidation;\n\tvar groups = [];\n\n\tif (_flags) {\n\t\t!flags && (flags = []);\n\t\t_flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\t}\n\n\tif (flags) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tif (typeof(flag) === 'object')\n\t\t\t\toptions = flag;\n\t\t\telse if (flag[0] === '&')\n\t\t\t\tgroups.push(flag.substring(1).trim());\n\t\t\telse if (flag[0] === '#') {\n\t\t\t\t!middleware && (middleware = []);\n\t\t\t\tmiddleware.push(flag.substring(1).trim());\n\t\t\t} else if (flag[0] === '.') {\n\t\t\t\tflag = flag.substring(1).toLowerCase().trim();\n\t\t\t\t!extensions && (extensions = {});\n\t\t\t\textensions[flag] = true;\n\t\t\t} else if (flag.substring(0, 3) === 'id:')\n\t\t\t\tid = flag.substring(3).trim();\n\t\t}\n\t}\n\n\tif (typeof(fnValidation) === 'string') {\n\n\t\tif (fnValidation === '/')\n\t\t\tfnValidation = '';\n\n\t\turl = fnValidation ? framework_internal.routeSplitCreate(fnValidation) : EMPTYARRAY;\n\t\tfnValidation = undefined;\n\t\ta = url.last();\n\t\tif (a === '*.*') {\n\t\t\twildcard = true;\n\t\t\turl.splice(url.length - 1, 1);\n\t\t} else if (a) {\n\t\t\tvar index = a.indexOf('*.');\n\t\t\tif (index !== -1) {\n\t\t\t\textensions = {};\n\t\t\t\textensions[a.substring(index + 2).trim()] = true;\n\t\t\t\twildcard = false;\n\t\t\t\turl.splice(url.length - 1, 1);\n\t\t\t} else if (a === '*') {\n\t\t\t\twildcard = true;\n\t\t\t\turl.splice(url.length - 1, 1);\n\t\t\t} else if (U.getExtension(a)) {\n\t\t\t\tfixedfile = true;\n\t\t\t\twildcard = false;\n\t\t\t}\n\t\t}\n\t} else if (!extensions && !fnValidation)\n\t\tfnValidation = fnExecute;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.id = id;\n\tr.urlraw = urlraw;\n\tr.groups = flags_to_object(groups);\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.url = url;\n\tr.fixedfile = fixedfile;\n\tr.wildcard = wildcard;\n\tr.extensions = extensions;\n\tr.onValidate = fnValidation;\n\tr.execute = fnExecute;\n\tr.middleware = middleware;\n\tr.options = options;\n\tr.type = 'file';\n\n\tF.routes.files.push(r);\n\tF.routes.files.sort((a, b) => !a.url ? -1 : !b.url ? 1 : a.url.length > b.url.length ? -1 : 1);\n\tEMIT('route', 'file', r);\n\tF._length_files++;\n\treturn F;\n};\n\nfunction sitemapurl(url) {\n\n\tvar index = url.indexOf('/');\n\tvar tmp;\n\n\tif (index !== -1) {\n\t\ttmp = url.substring(index);\n\t\turl = url.substring(0, index);\n\t}\n\n\tvar sitemap = F.sitemap(url, true, '');\n\tif (sitemap) {\n\t\turl = sitemap.url;\n\t\tif (tmp) {\n\t\t\tif (url[url.length - 1] === '/')\n\t\t\t\turl += tmp.substring(1);\n\t\t\telse\n\t\t\t\turl += tmp;\n\t\t}\n\t}\n\n\treturn url;\n}\n\nglobal.LOCALIZE = F.localize = function(url, flags, minify) {\n\n\tif (typeof(url) === 'function') {\n\t\tF.onLocale = url;\n\t\treturn;\n\t}\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\turl = url.replace('*.*', '');\n\n\tif (minify == null)\n\t\tminify = true;\n\n\tif (flags === true) {\n\t\tflags = [];\n\t\tminify = true;\n\t} else if (!flags)\n\t\tflags = [];\n\n\tvar index;\n\tvar ext = false;\n\n\tflags = flags.remove(function(item) {\n\t\titem = item.toLowerCase();\n\t\tif (item === 'nocompress')\n\t\t\tminify = false;\n\t\tif (item[0] === '.')\n\t\t\text = true;\n\t\treturn item === 'compress' || item === 'nocompress' || item === 'minify';\n\t});\n\n\tvar index = url.lastIndexOf('.');\n\n\tif (!ext) {\n\t\tif (index === -1)\n\t\t\tflags.push('.html', '.htm', '.md', '.txt');\n\t\telse {\n\t\t\tflags.push(url.substring(index).toLowerCase());\n\t\t\turl = url.substring(0, index).replace('*', '');\n\t\t}\n\t}\n\n\turl = framework_internal.preparePath(url.replace('.*', ''));\n\n\tF.file(url, function(req, res) {\n\n\t\tF.onLocale && (req.$language = F.onLocale(req, res, req.isStaticFile));\n\n\t\tvar key = 'locate_' + (req.$language ? req.$language : 'default') + '_' + req.url;\n\t\tvar output = F.temporary.other[key];\n\n\t\tif (output) {\n\t\t\tif (!F.$notModified(req, res, output.$mtime)) {\n\t\t\t\tHEADERS.responseLocalize['Last-Modified'] = output.$mtime;\n\t\t\t\tres.options.body = output;\n\t\t\t\tres.options.type = U.getContentType(req.extension);\n\t\t\t\tres.$text();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar name = req.uri.pathname;\n\t\tvar filename = F.onMapping(name, name, true, true);\n\n\t\tFs.readFile(filename, function(err, content) {\n\n\t\t\tif (err)\n\t\t\t\treturn res.throw404();\n\n\t\t\tcontent = framework_internal.markup(F.translator(req.$language, framework_internal.modificators(content.toString(ENCODING), filename, 'static')));\n\n\t\t\tFs.lstat(filename, function(err, stats) {\n\n\t\t\t\tvar mtime = stats.mtime.toUTCString();\n\n\t\t\t\tif (minify && (req.extension === 'html' || req.extension === 'htm'))\n\t\t\t\t\tcontent = framework_internal.compile_html(content, filename);\n\n\t\t\t\tif (RELEASE) {\n\t\t\t\t\tF.temporary.other[key] = U.createBuffer(content);\n\t\t\t\t\tF.temporary.other[key].$mtime = mtime;\n\t\t\t\t\tif (F.$notModified(req, res, mtime))\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tHEADERS.responseLocalize['Last-Modified'] = mtime;\n\t\t\t\tres.options.body = content;\n\t\t\t\tres.options.type = U.getContentType(req.extension);\n\t\t\t\tres.options.headers = HEADERS.responseLocalize;\n\t\t\t\tres.$text();\n\t\t\t});\n\t\t});\n\n\t}, flags);\n};\n\nF.$notModified = function(req, res, date) {\n\tif (date === req.headers['if-modified-since']) {\n\t\tHEADERS.responseNotModified['Last-Modified'] = date;\n\t\tres.success = true;\n\t\tres.writeHead(304, HEADERS.responseNotModified);\n\t\tres.end();\n\t\tF.stats.response.notModified++;\n\t\tF.reqstats(false, req.isStaticFile);\n\t\treturn true;\n\t}\n};\n\n/**\n * Error caller\n * @param {Error} err\n * @param {String} name Controller or Script name.\n * @param {Object} uri\n * @return {Framework}\n */\nF.error = function(err, name, uri) {\n\n\tif (!arguments.length)\n\t\treturn F.errorcallback;\n\n\tif (!err)\n\t\treturn F;\n\n\tif (F.errors) {\n\t\tNOW = new Date();\n\t\tF.errors.push({ error: err.stack, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, date: NOW });\n\t\tF.errors.length > 50 && F.errors.shift();\n\t}\n\n\tF.onError(err, name, uri);\n\treturn F;\n};\n\nF.errorcallback = function(err) {\n\terr && F.error(err);\n};\n\n/**\n * Registers a new problem\n * @param {String} message\n * @param {String} name A controller name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.problem = F.wtf = function(message, name, uri, ip) {\n\tF.$events.problem && EMIT('problem', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip };\n\tF.logger('problems', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.problems) {\n\t\tF.problems.push(obj);\n\t\tF.problems.length > 50 && F.problems.shift();\n\t}\n\n\treturn F;\n};\n\nglobal.PRINTLN = function(msg) {\n\tconsole.log('------>', '[' + new Date().format('yyyy-MM-dd HH:mm:ss') + ']', msg);\n};\n\n/**\n * Registers a new change\n * @param {String} message\n * @param {String} name A source name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.change = function(message, name, uri, ip) {\n\tF.$events.change && EMIT('change', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip };\n\tF.logger('changes', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.changes) {\n\t\tF.changes.push(obj);\n\t\tF.changes.length > 50 && F.changes.shift();\n\t}\n\n\treturn F;\n};\n\n/**\n * Trace\n * @param {String} message\n * @param {String} name A controller name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.trace = function(message, name, uri, ip) {\n\n\tif (!CONF.trace)\n\t\treturn F;\n\n\tF.$events.trace && EMIT('trace', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tNOW = new Date();\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip, date: NOW };\n\tF.logger('traces', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tCONF.trace_console && console.log(NOW.format('yyyy-MM-dd HH:mm:ss'), '[trace]', message, '|', 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.traces) {\n\t\tF.traces.push(obj);\n\t\tF.traces.length > 50 && F.traces.shift();\n\t}\n\n\treturn F;\n};\n\n/**\n * Get a module\n * @param {String} name\n * @return {Object}\n */\nglobal.MODULE = F.module = function(name) {\n\treturn F.modules[name] || null;\n};\n\n/**\n * Add a new modificator\n * @param {Function(type, filename, content)} fn The `fn` must return modified value.\n * @return {Framework}\n */\nF.modify = function(fn) {\n\tOBSOLETE('F.modify()', 'This method will be removed in new versions.');\n\tif (!F.modificators)\n\t\tF.modificators = [];\n\tF.modificators.push(fn);\n\tfn.$owner = _owner;\n\treturn F;\n};\n\nF.$bundle = function(callback) {\n\n\tvar bundledir = F.path.root(CONF.directory_bundles);\n\n\tvar makebundle = function() {\n\n\t\tvar arr = Fs.readdirSync(bundledir);\n\t\tvar url = [];\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i].endsWith('.url'))\n\t\t\t\turl.push(arr[i]);\n\t\t}\n\n\t\turl.wait(function(item, next) {\n\n\t\t\tvar filename = F.path.root(CONF.directory_bundles) + item.replace('.url', '.bundle');\n\t\t\tvar link = Fs.readFileSync(F.path.root(CONF.directory_bundles) + item).toString('utf8');\n\n\t\t\tF.consoledebug('Download bundle: ' + link);\n\n\t\t\tU.download(link, FLAGS_INSTALL, function(err, response) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'Bundle: ' + link);\n\t\t\t\t\tnext();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar stream = Fs.createWriteStream(filename);\n\n\t\t\t\tresponse.pipe(stream);\n\t\t\t\tresponse.on('error', function(err) {\n\t\t\t\t\tF.error(err, 'Bundle: ' + link);\n\t\t\t\t\tnext();\n\t\t\t\t});\n\n\t\t\t\tCLEANUP(stream, next);\n\t\t\t});\n\n\t\t}, function() {\n\t\t\trequire('./bundles').make(function() {\n\t\t\t\tF.directory = HEADERS.workers.cwd = directory = F.path.root(CONF.directory_src);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t});\n\t};\n\n\ttry {\n\t\tFs.statSync(bundledir);\n\t\tif (F.$bundling) {\n\t\t\tmakebundle();\n\t\t\treturn;\n\t\t} else\n\t\t\tF.directory = HEADERS.workers.cwd = directory = F.path.root(CONF.directory_src);\n\t} catch(e) {}\n\tcallback();\n};\n\nF.$load = function(types, targetdirectory, callback, packageName) {\n\n\tvar arr = [];\n\tvar dir = '';\n\n\tif (!targetdirectory)\n\t\ttargetdirectory = directory;\n\n\ttargetdirectory = '~' + targetdirectory;\n\n\tfunction listing(directory, level, output, extension, isTheme) {\n\n\t\tif (!existsSync(dir))\n\t\t\treturn;\n\n\t\tif (!extension)\n\t\t\textension = '.js';\n\n\t\tFs.readdirSync(directory).forEach(function(o) {\n\t\t\tvar isDirectory = Fs.statSync(Path.join(directory, o)).isDirectory();\n\n\t\t\tif (isDirectory && isTheme) {\n\t\t\t\toutput.push({ name: o });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isDirectory) {\n\n\t\t\t\tif (extension === '.package' && o.endsWith(extension)) {\n\t\t\t\t\tvar name = o.substring(0, o.length - extension.length);\n\t\t\t\t\toutput.push({ name: name[0] === '/' ? name.substring(1) : name, filename: Path.join(dir, o), is: true });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlevel++;\n\t\t\t\tlisting(Path.join(directory, o), level, output, extension);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar ext = U.getExtension(o);\n\t\t\tif (ext)\n\t\t\t\text = '.' + ext;\n\t\t\tif (ext !== extension || o[0] === '.' || o.endsWith('-bk' + extension))\n\t\t\t\treturn;\n\n\t\t\tvar name = (level ? U.$normalize(directory).replace(dir, '') + '/' : '') + o.substring(0, o.length - ext.length);\n\t\t\toutput.push({ name: name[0] === '/' ? name.substring(1) : name, filename: Path.join(dir, name) + extension });\n\t\t});\n\t}\n\n\ttry {\n\t\t// Reads name of resources\n\t\tF.temporary.internal.resources = Fs.readdirSync(F.path.resources()).map(n => n.substring(0, n.lastIndexOf('.')));\n\t} catch (e) {\n\t\tF.temporary.internal.resources = [];\n\t}\n\n\tvar dependencies = [];\n\tvar operations = [];\n\tvar isPackage = targetdirectory.indexOf('.package') !== -1;\n\n\tif (!types || types.indexOf('modules') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/modules/' : CONF.directory_modules);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.js');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('module', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('isomorphic') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/isomorphic/' : CONF.directory_isomorphic);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.js');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('isomorphic', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('packages') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/packages/' : CONF.directory_packages);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.package');\n\t\t\tvar dirtmp = U.$normalize(dir);\n\n\t\t\tarr.wait(function(item, next2) {\n\n\t\t\t\tif (!item.is) {\n\t\t\t\t\tdependencies.push(next => F.install('package', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t\t\treturn next2();\n\t\t\t\t}\n\n\t\t\t\tU.ls(item.filename, function(files, directories) {\n\t\t\t\t\tvar dir = F.path.temp(item.name) + '.package';\n\t\t\t\t\t!existsSync(dir) && Fs.mkdirSync(dir);\n\n\t\t\t\t\tfor (var i = 0, length = directories.length; i < length; i++) {\n\t\t\t\t\t\tvar target = F.path.temp(U.$normalize(directories[i]).replace(dirtmp, '') + '/');\n\t\t\t\t\t\t!existsSync(target) && Fs.mkdirSync(target);\n\t\t\t\t\t}\n\n\t\t\t\t\tfiles.wait(function(filename, next) {\n\n\t\t\t\t\t\tif (F.$bundling) {\n\t\t\t\t\t\t\tvar stream = Fs.createReadStream(filename);\n\t\t\t\t\t\t\tvar writer = Fs.createWriteStream(Path.join(dir, filename.replace(item.filename, '').replace(/\\.package$/i, '')));\n\t\t\t\t\t\t\tstream.pipe(writer);\n\t\t\t\t\t\t\twriter.on('finish', next);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tnext();\n\n\t\t\t\t\t}, function() {\n\n\t\t\t\t\t\t// Windows sometimes doesn't load package and this delay solves the problem.\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tdependencies.push(next => F.install('package2', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t\t\t\t\tnext2();\n\t\t\t\t\t\t}, 50);\n\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, resume);\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('models') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/models/' : CONF.directory_models);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('model', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('schemas') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/schemas/' : CONF.directory_schemas);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('schema', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('operations') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/operations/' : CONF.directory_operations);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('operation', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('themes') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/themes/' : CONF.directory_themes);\n\t\t\tlisting(dir, 0, arr, undefined, true);\n\t\t\tarr.forEach(function(item) {\n\t\t\t\tvar themeName = item.name;\n\t\t\t\tvar themeDirectory = Path.join(dir, themeName);\n\t\t\t\tvar filename = Path.join(themeDirectory, 'index.js');\n\t\t\t\tF.themes[item.name] = U.path(themeDirectory);\n\t\t\t\tF._length_themes++;\n\t\t\t\texistsSync(filename) && dependencies.push(next => F.install('theme', item.name, filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t});\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('definitions') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/definitions/' : CONF.directory_definitions);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('definition', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('controllers') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/controllers/' : CONF.directory_controllers);\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('controller', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('components') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/components/' : CONF.directory_components);\n\t\t\tlisting(dir, 0, arr, '.html');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('component', item.name, item.filename, undefined, undefined, undefined, undefined, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\toperations.async(function() {\n\t\tvar count = dependencies.length;\n\t\tF.consoledebug('load dependencies ' + count + 'x');\n\t\tdependencies.async(function() {\n\t\t\ttypes && types.indexOf('service') === -1 && F.cache.stop();\n\t\t\tF.$routesSort();\n\t\t\t(!types || types.indexOf('dependencies') !== -1) && F.$configure_dependencies();\n\t\t\tF.consoledebug('load dependencies {0}x (done)'.format(count));\n\t\t\tcallback && callback();\n\t\t});\n\t});\n\n\treturn F;\n};\n\nF.$startup = function(callback) {\n\n\tvar dir = Path.join(directory, '/startup/');\n\n\tif (!existsSync(dir))\n\t\treturn callback();\n\n\tvar run = [];\n\n\tFs.readdirSync(dir).forEach(function(o) {\n\t\tvar extension = U.getExtension(o);\n\t\tif (extension === 'js')\n\t\t\trun.push(o);\n\t});\n\n\tif (!run.length)\n\t\treturn callback();\n\n\trun.wait(function(filename, next) {\n\t\tvar fn = dir + filename + new Date().format('yyMMdd_HHmmss');\n\t\tFs.renameSync(dir + filename, fn);\n\t\tvar fork = Child.fork(fn, [], { cwd: directory });\n\t\tfork.on('exit', function() {\n\t\t\tfork = null;\n\t\t\tnext();\n\t\t});\n\t}, callback);\n\n\treturn F;\n};\n\nF.uptodate = function(type, url, options, interval, callback, next) {\n\n\tif (typeof(options) === 'string' && typeof(interval) !== 'string') {\n\t\tinterval = options;\n\t\toptions = null;\n\t}\n\n\tvar obj = { type: type, name: '', url: url, interval: interval, options: options, count: 0, updated: NOW, errors: [], callback: callback };\n\n\tif (!F.uptodates)\n\t\tF.uptodates = [];\n\n\tF.uptodates.push(obj);\n\tF.install(type, url, options, function(err, name) {\n\t\terr && obj.errors.push(err);\n\t\tobj.name = name;\n\t\tobj.callback && obj.callback(err, name);\n\t}, undefined, undefined, undefined, undefined, next);\n\treturn F;\n};\n\n/**\n * Install type with its declaration\n * @param {String} type Available types: model, module, controller, source.\n * @param {String} name Default name (optional).\n * @param {String or Function} declaration\n * @param {Object} options Custom options, optional.\n * @param {Object} internal Internal/Temporary options, optional.\n * @param {Boolean} useRequired Internal, optional.\n * @param {Boolean} skipEmit Internal, optional.\n * @param {String} uptodateName Internal, optional.\n * @param {Function} next Internal, optional.\n * @param {String} packageName Internal, optional.\n * @return {Framework}\n */\nF.install = function(type, name, declaration, options, callback, internal, useRequired, skipEmit, uptodateName, next, packageName) {\n\n\tvar obj = null;\n\n\tif (type !== 'config' && type !== 'version' && typeof(name) === 'string') {\n\t\tif (name.startsWith('http://') || name.startsWith('https://')) {\n\t\t\tif (typeof(declaration) === 'object') {\n\t\t\t\tcallback = options;\n\t\t\t\toptions = declaration;\n\t\t\t\tdeclaration = name;\n\t\t\t\tname = '';\n\t\t\t}\n\t\t} else if (name[0] === '@') {\n\t\t\tdeclaration = F.path.package(name.substring(1));\n\t\t\tname = Path.basename(name).replace(/\\.js$/i, '');\n\t\t\tif (useRequired === undefined)\n\t\t\t\tuseRequired = true;\n\t\t}\n\t}\n\n\tvar t = typeof(declaration);\n\tvar key = '';\n\tvar tmp;\n\tvar content;\n\tvar err;\n\n\tNOW = new Date();\n\n\tif (t === 'object') {\n\t\tt = typeof(options);\n\t\tif (t === 'function')\n\t\t\tcallback = options;\n\t\toptions = declaration;\n\t\tdeclaration = undefined;\n\t}\n\n\tif (declaration === undefined) {\n\t\tdeclaration = name;\n\t\tname = '';\n\t}\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\t// Check if declaration is a valid URL address\n\tif (type !== 'eval' && typeof(declaration) === 'string') {\n\n\t\tif (declaration.startsWith('http://') || declaration.startsWith('https://')) {\n\t\t\tif (type === 'package') {\n\t\t\t\tF.consoledebug('download', type, declaration);\n\t\t\t\tU.download(declaration, FLAGS_INSTALL, function(err, response) {\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tF.error(err, 'F.install(\\'{0}\\', \\'{1}\\')'.format(type, declaration), null);\n\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\tcallback && callback(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar id = Path.basename(declaration, '.package');\n\t\t\t\t\tvar filename = F.path.temp(id + '.download');\n\t\t\t\t\tvar stream = Fs.createWriteStream(filename);\n\t\t\t\t\tvar md5 = Crypto.createHash('md5');\n\n\t\t\t\t\tresponse.on('data', (buffer) => md5.update(buffer));\n\t\t\t\t\tresponse.pipe(stream);\n\n\t\t\t\t\tstream.on('finish', function() {\n\t\t\t\t\t\tvar hash = md5.digest('hex');\n\n\t\t\t\t\t\tif (F.temporary.versions[declaration] === hash) {\n\t\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\t\tcallback && callback(null, uptodateName || name, true);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tF.temporary.versions[declaration] = hash;\n\t\t\t\t\t\tF.install(type, id, filename, options, callback, undefined, undefined, true, uptodateName, next);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn F;\n\t\t\t}\n\n\t\t\tF.consoledebug('download', type, declaration);\n\t\t\tU.request(declaration, FLAGS_INSTALL, function(err, data, code) {\n\n\t\t\t\tif (code !== 200 && !err)\n\t\t\t\t\terr = new Error(data);\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'F.install(\\'{0}\\', \\'{1}\\')'.format(type, declaration), null);\n\t\t\t\t\tnext && next();\n\t\t\t\t\tcallback && callback(err);\n\t\t\t\t} else {\n\n\t\t\t\t\tvar hash = data.hash('md5');\n\n\t\t\t\t\tif (F.temporary.versions[declaration] === hash) {\n\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\tcallback && callback(null, uptodateName || name, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tF.temporary.versions[declaration] = hash;\n\t\t\t\t\tF.install(type, name, data, options, callback, declaration, undefined, undefined, uptodateName, next);\n\t\t\t\t}\n\n\t\t\t});\n\t\t\treturn F;\n\t\t} else {\n\t\t\tif (declaration[0] === '~')\n\t\t\t\tdeclaration = declaration.substring(1);\n\t\t\tif (type !== 'config' && type !== 'resource' && type !== 'package' && type !== 'component' && !REG_SCRIPTCONTENT.test(declaration)) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tif (!existsSync(declaration))\n\t\t\t\t\tthrow new Error('The ' + type + ': ' + declaration + ' doesn\\'t exist.');\n\t\t\t\tuseRequired = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type === 'middleware') {\n\n\t\tF.routes.middleware[name] = typeof(declaration) === 'function' ? declaration : eval(declaration);\n\t\tF._length_middleware = Object.keys(F.routes.middleware).length;\n\n\t\tif (REG_NEWIMPL.test(F.routes.middleware[name].toString()))\n\t\t\tF.routes.middleware[name].$newversion = true;\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tkey = type + '.' + name;\n\n\t\tif (F.dependencies[key]) {\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t} else {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0 };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].count++;\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'config' || type === 'configuration' || type === 'settings') {\n\t\tF.$configure_configs(declaration instanceof Array ? declaration : declaration.toString().split('\\n'), true);\n\t\tsetTimeout(function() {\n\t\t\tdelete F.temporary.mail_settings;\n\t\t\tEMIT(type + '#' + name, CONF);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'version' || type === 'versions') {\n\n\t\tF.$configure_versions(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'workflow' || type === 'workflows') {\n\n\t\tF.$configure_workflows(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t\tF.consoledebug('install', type + '#' + name);\n\t\t}, 500);\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'sitemap') {\n\n\t\tF.$configure_sitemap(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t\tF.consoledebug('install', type + '#' + name);\n\t\t}, 500);\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'component') {\n\n\t\tif (!name && internal)\n\t\t\tname = U.getName(internal).replace(/\\.html/gi, '').trim();\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined);\n\n\t\tvar hash = '\\n/*' + name.crc32(true) + '*/\\n';\n\t\tvar temporary = (F.id ? 'i-' + F.id + '_' : '') + 'components';\n\n\t\tcontent = parseComponent(internal ? declaration : Fs.readFileSync(declaration).toString(ENCODING), name);\n\n\t\tif (F.$bundling) {\n\t\t\tcontent.js && Fs.appendFileSync(F.path.temp(temporary + '.js'), hash + (DEBUG ? component_debug(name, content.js, 'js') : content.js) + hash.substring(0, hash.length - 1));\n\t\t\tcontent.css && Fs.appendFileSync(F.path.temp(temporary + '.css'), hash + (DEBUG ? component_debug(name, content.css, 'css') : content.css) + hash.substring(0, hash.length - 1));\n\t\t}\n\n\t\tif (content.js)\n\t\t\tF.components.js = true;\n\n\t\tif (content.css)\n\t\t\tF.components.css = true;\n\n\t\tif (content.files)\n\t\t\tF.components.files[name] = content.files;\n\t\telse\n\t\t\tdelete F.components.files[name];\n\n\t\tif (content.body) {\n\t\t\tF.components.views[name] = '.' + F.path.temp('component_' + name);\n\t\t\tF.$bundling && Fs.writeFile(F.components.views[name].substring(1) + '.html', U.minifyHTML(content.body), NOOP);\n\t\t} else\n\t\t\tdelete F.components.views[name];\n\n\t\tF.components.has = true;\n\n\t\tvar link = CONF.static_url_components;\n\t\tF.components.version = NOW.getTime();\n\t\tF.components.links = (F.components.js ? '<script src=\"{0}js?version={1}\"></script>'.format(link, F.components.version) : '') + (F.components.css ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"{0}css?version={1}\" />'.format(link, F.components.version) : '');\n\n\t\tif (content.install) {\n\t\t\ttry {\n\t\t\t\tvar filecomponent = F.path.temp('component-' + name + '.js');\n\t\t\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\t\t\tFs.writeFileSync(filecomponent, content.install.trim());\n\t\t\t\tobj = require(filecomponent);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filecomponent));\n\t\t\t\tobj.$owner = _owner;\n\t\t\t\tF.temporary.owners[_owner] = true;\n\t\t\t\t_controller = '';\n\t\t\t\tobj.name = name;\n\t\t\t\tF.components.instances[name] = obj;\n\t\t\t\tobj && typeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\t\t\t} catch(e) {\n\t\t\t\tF.error(e, 'F.install(\\'component\\', \\'{0}\\')'.format(name));\n\t\t\t}\n\t\t} else if (!internal) {\n\t\t\tvar js = declaration.replace(/\\.html$/i, '.js');\n\t\t\tif (existsSync(js)) {\n\t\t\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\t\t\tF.temporary.owners[_owner] = true;\n\t\t\t\tobj = require(js);\n\t\t\t\tobj.name = name;\n\t\t\t\tobj.$owner = _owner;\n\t\t\t\t_controller = '';\n\t\t\t\tF.components.instances[name] = obj;\n\t\t\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t}\n\n\t\tif (obj) {\n\n\t\t\tif (!obj.group)\n\t\t\t\tobj.group = 'default';\n\n\t\t\tkey = obj.group.crc32(true);\n\t\t\ttemporary += '_g' + key;\n\t\t\ttmp = F.components.groups[obj.group];\n\t\t\tif (!tmp)\n\t\t\t\ttmp = F.components.groups[obj.group] = {};\n\n\t\t\tif (content.js) {\n\t\t\t\tFs.appendFileSync(F.path.temp(temporary + '.js'), hash + (DEBUG ? component_debug(name, content.js, 'js') : content.js) + hash.substring(0, hash.length - 1));\n\t\t\t\ttmp.js = true;\n\t\t\t}\n\n\t\t\tif (content.css) {\n\t\t\t\tFs.appendFileSync(F.path.temp(temporary + '.css'), hash + (DEBUG ? component_debug(name, content.css, 'css') : content.css) + hash.substring(0, hash.length - 1));\n\t\t\t\ttmp.css = true;\n\t\t\t}\n\n\t\t\ttmp.version = GUID(5);\n\t\t\ttmp.links = (tmp.js ? '<script src=\"{0}js?group={2}_{1}\"></script>'.format(link, tmp.version, key) : '') + (tmp.css ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"{0}css?group={2}_{1}\" />'.format(link, tmp.version, key) : '');\n\t\t}\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'package') {\n\n\t\tvar id = Path.basename(declaration, '.' + U.getExtension(declaration));\n\t\tvar dir = CONF.directory_temp[0] === '~' ? Path.join(CONF.directory_temp.substring(1), id + '.package') : Path.join(F.path.root(), CONF.directory_temp, id + '.package');\n\n\t\tF.routes.packages[id] = dir;\n\n\t\tvar restorecb = function() {\n\t\t\tvar filename = Path.join(dir, 'index.js');\n\t\t\tif (!existsSync(filename)) {\n\t\t\t\tnext && next();\n\t\t\t\tcallback && callback(null, name);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tF.install('module', id, filename, options || CONF['package#' + name], function(err) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tEMIT('module#' + name);\n\t\t\t\t\tEMIT(type + '#' + name);\n\t\t\t\t\tEMIT('install', 'module', name);\n\t\t\t\t\tEMIT('install', type, name);\n\t\t\t\t\tF.temporary.ready['package#' + name] = NOW;\n\t\t\t\t\tF.temporary.ready['module#' + name] = NOW;\n\t\t\t\t}, 500);\n\t\t\t\tF.consoledebug('install', 'package#' + name);\n\t\t\t\tcallback && callback(err, name);\n\t\t\t}, internal, useRequired, true, undefined);\n\t\t\tnext && next();\n\t\t};\n\n\t\tif (F.$bundling)\n\t\t\tF.restore(declaration, dir, restorecb);\n\t\telse\n\t\t\trestorecb();\n\n\t\treturn F;\n\t}\n\n\tif (type === 'theme') {\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj = require(declaration);\n\t\tobj.$owner = _owner;\n\t\tF.temporary.owners[_owner] = true;\n\n\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\t(function(name) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tdelete require.cache[name];\n\t\t\t}, 1000);\n\t\t})(require.resolve(declaration));\n\t\treturn F;\n\t}\n\n\tif (type === 'package2') {\n\t\ttype = type.substring(0, type.length - 1);\n\t\tvar id = U.getName(declaration, '.package');\n\t\tvar dir = CONF.directory_temp[0] === '~' ? Path.join(CONF.directory_temp.substring(1), id) : Path.join(F.path.root(), CONF.directory_temp, id);\n\t\tvar filename = Path.join(dir, 'index.js');\n\t\tF.install('module', id.replace(/\\.package$/i, ''), filename, options || CONF['package#' + name], function(err) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tEMIT('module#' + name);\n\t\t\t\tEMIT(type + '#' + name);\n\t\t\t\tEMIT('install', type, name);\n\t\t\t\tEMIT('install', 'module', name);\n\t\t\t\tF.temporary.ready['package#' + name] = NOW;\n\t\t\t\tF.temporary.ready['module#' + name] = NOW;\n\t\t\t}, 500);\n\t\t\tF.consoledebug('install', 'package#' + name);\n\t\t\tcallback && callback(err, name);\n\t\t}, internal, useRequired, true);\n\t\tnext && next();\n\t\treturn F;\n\t}\n\n\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\tif (type === 'view') {\n\n\t\tvar item = F.routes.views[name];\n\t\tkey = type + '.' + name;\n\n\t\tif (item === undefined) {\n\t\t\titem = {};\n\t\t\titem.filename = F.path.temporary(plus + 'installed-view-' + U.GUID(10) + '.tmp');\n\t\t\titem.url = internal;\n\t\t\titem.count = 0;\n\t\t\tF.routes.views[name] = item;\n\t\t}\n\n\t\titem.count++;\n\t\tFs.writeFileSync(item.filename, framework_internal.modificators(declaration, name));\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'definition' || type === 'eval' || type === 'schema' || type === 'operation') {\n\n\t\t_controller = '';\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tF.temporary.owners[_owner] = true;\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tdelete require.cache[require.resolve(declaration)];\n\t\t\t\tobj = require(declaration);\n\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse\n\t\t\t\tobj = typeof(declaration) === 'function' ? eval('(' + declaration.toString() + ')()') : eval(declaration);\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tF.consoledebug('install', type + '#' + (name || '::undefined::'));\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\treturn F;\n\t}\n\n\tif (type === 'isomorphic') {\n\n\t\tcontent = '';\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\tif (tmp)\n\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t}\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tdelete require.cache[require.resolve(declaration)];\n\t\t\t\tobj = require(declaration);\n\t\t\t\tcontent = Fs.readFileSync(declaration).toString(ENCODING);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = typeof(declaration) === 'function' ? eval('(' + declaration.toString() + ')()') : eval(declaration);\n\t\t\t\tcontent = declaration.toString();\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\tif (obj.url) {\n\t\t\tif (obj.url[0] !== '/')\n\t\t\t\tobj.url = '/' + obj.url;\n\t\t} else\n\t\t\tobj.url = '/' + name + '.js';\n\n\t\ttmp = F.path.temp('isomorphic_' + name + '.min.js');\n\t\tF.map(framework_internal.preparePath(obj.url), tmp);\n\t\tF.isomorphic[name] = obj;\n\n\t\tF.$bundling && Fs.writeFileSync(tmp, prepare_isomorphic(name, framework_internal.compile_javascript(content, '#' + name)));\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\treturn F;\n\t}\n\n\tif (type === 'model' || type === 'source') {\n\n\t\t_controller = '';\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tF.temporary.owners[_owner] = true;\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tobj = require(declaration);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (typeof(declaration) !== 'string')\n\t\t\t\t\tdeclaration = declaration.toString();\n\n\t\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t\t}\n\n\t\t\t\tvar filename = F.path.temporary(plus + 'installed-' + type + '-' + U.GUID(10) + '.js');\n\t\t\t\tFs.writeFileSync(filename, declaration);\n\t\t\t\tobj = require(filename);\n\n\t\t\t\t(function(name, filename) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tFs.unlinkSync(filename);\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filename), filename);\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\', \\'' + name + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj.$owner = _owner;\n\n\t\tif (!name)\n\t\t\tname = (Math.random() * 10000) >> 0;\n\n\t\tkey = type + '.' + name;\n\t\ttmp = F.dependencies[key];\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined);\n\t\tF.temporary.owners[_owner] = true;\n\n\t\tif (tmp) {\n\t\t\tF.dependencies[key] = tmp;\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t}\n\t\telse {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0 };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].count++;\n\n\t\tif (obj.reinstall)\n\t\t\tF.dependencies[key].reinstall = obj.reinstall.toString().parseDateExpiration();\n\t\telse\n\t\t\tdelete F.dependencies[key];\n\n\t\tif (type === 'model')\n\t\t\tF.models[name] = obj;\n\t\telse\n\t\t\tF.sources[name] = obj;\n\n\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[type + '#' + name], name);\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'module' || type === 'controller') {\n\n\t\t// for inline routes\n\t\tvar _ID = _controller = 'TMP' + U.random(10000);\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\terr = null;\n\n\t\ttry {\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tobj = require(declaration);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t} else {\n\n\t\t\t\tif (typeof(declaration) !== 'string')\n\t\t\t\t\tdeclaration = declaration.toString();\n\n\t\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t\t}\n\n\t\t\t\tfilename = F.path.temporary(plus + 'installed-' + type + '-' + U.GUID(10) + '.js');\n\t\t\t\tFs.writeFileSync(filename, declaration);\n\t\t\t\tobj = require(filename);\n\t\t\t\t(function(name, filename) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tFs.unlinkSync(filename);\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filename), filename);\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\', \\'' + (name ? '' : internal) + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\tif (!name)\n\t\t\tname = (Math.random() * 10000) >> 0;\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj.$owner = _owner;\n\n\t\tobj.booting && setTimeout(function() {\n\n\t\t\tvar tmpdir = F.path.temp(name + (U.getExtension(name) === 'package' ? '' : '.package/'));\n\n\t\t\tif (obj.booting === 'root') {\n\t\t\t\tF.directory = directory = tmpdir;\n\t\t\t\tF.temporary.path = {};\n\t\t\t\tF.temporary.notfound = {};\n\t\t\t\tF.$configure_configs();\n\t\t\t\tF.$configure_versions();\n\t\t\t\tF.$configure_dependencies();\n\t\t\t\tF.$configure_sitemap();\n\t\t\t\tF.$configure_workflows();\n\t\t\t} else {\n\t\t\t\tF.$configure_configs('@' + name + '/config');\n\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tF.$configure_configs('@' + name + '/config-debug');\n\t\t\t\telse\n\t\t\t\t\tF.$configure_configs('@' + name + '/config-release');\n\t\t\t\tF.isTest && F.$configure_configs('@' + name + '/config-test');\n\t\t\t\tF.$configure_versions('@' + name + '/versions');\n\t\t\t\tF.$configure_dependencies('@' + name + '/dependencies');\n\t\t\t\tF.$configure_sitemap('@' + name + '/sitemap');\n\t\t\t\tF.$configure_workflows('@' + name + '/workflows');\n\t\t\t}\n\n\t\t\tF.$bundle(() => F.$load(undefined, tmpdir, undefined, name));\n\t\t}, 100);\n\n\t\tkey = type + '.' + name;\n\t\ttmp = F.dependencies[key];\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined, undefined, packageName);\n\t\tF.temporary.owners[_owner] = true;\n\n\t\tif (tmp) {\n\t\t\tF.dependencies[key] = tmp;\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t}\n\t\telse {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0, _id: _ID };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].dependencies = obj.dependencies;\n\t\tF.dependencies[key].count++;\n\t\tF.dependencies[key].processed = false;\n\n\t\tif (obj.reinstall)\n\t\t\tF.dependencies[key].reinstall = obj.reinstall.toString().parseDateExpiration();\n\t\telse\n\t\t\tdelete F.dependencies[key].reinstall;\n\n\t\t_controller = _ID;\n\n\t\tif (obj.dependencies instanceof Array) {\n\t\t\tfor (var i = 0, length = obj.dependencies.length; i < length; i++) {\n\t\t\t\tif (!F.dependencies[type + '.' + obj.dependencies[i]]) {\n\t\t\t\t\tF.temporary.dependencies[key] = { obj: obj, options: options, callback: callback, skipEmit: skipEmit };\n\t\t\t\t\tnext && next();\n\t\t\t\t\treturn F;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tF.install_make(key, name, obj, options, callback, skipEmit, type);\n\n\t\tif (type === 'module')\n\t\t\tF.modules[name] = obj;\n\t\telse\n\t\t\tF.controllers[name] = obj;\n\n\t\tF.install_prepare();\n\t\tnext && next();\n\t}\n\n\treturn F;\n};\n\nF.restart = function() {\n\tOBSOLETE('F.restart()', 'This function is not supported');\n\treturn F;\n};\n\nF.install_prepare = function(noRecursive) {\n\n\tvar keys = Object.keys(F.temporary.dependencies);\n\n\tif (!keys.length)\n\t\treturn;\n\n\t// check dependencies\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar k = keys[i];\n\t\tvar a = F.temporary.dependencies[k];\n\t\tvar b = F.dependencies[k];\n\t\tvar skip = false;\n\n\t\tif (b.processed)\n\t\t\tcontinue;\n\n\t\tfor (var j = 0, jl = b.dependencies.length; j < jl; j++) {\n\t\t\tvar d = F.dependencies['module.' + b.dependencies[j]];\n\t\t\tif (!d || !d.processed) {\n\t\t\t\tskip = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tdelete F.temporary.dependencies[k];\n\n\t\tif (b.type === 'module')\n\t\t\tF.modules[b.name] = a.obj;\n\t\telse\n\t\t\tF.controllers[b.name] = a.obj;\n\n\t\tF.install_make(k, b.name, a.obj, a.options, a.callback, a.skipEmit, b.type);\n\t}\n\n\tkeys = Object.keys(F.temporary.dependencies);\n\n\tclearTimeout(F.temporary.other.dependencies);\n\tF.temporary.other.dependencies = setTimeout(function() {\n\t\tvar keys = Object.keys(F.temporary.dependencies);\n\t\tif (keys.length)\n\t\t\tthrow new Error('Dependency exception, missing dependencies for: ' + keys.join(', ').trim());\n\t\tdelete F.temporary.other.dependencies;\n\t}, CONF.default_dependency_timeout);\n\n\tif (!keys.length || noRecursive)\n\t\treturn F;\n\n\tF.install_prepare(true);\n\treturn F;\n};\n\nF.install_make = function(key, name, obj, options, callback, skipEmit, type) {\n\n\tvar me = F.dependencies[key];\n\tvar routeID = me._id;\n\tvar type = me.type;\n\n\tF.temporary.internal[me._id] = name;\n\t_controller = routeID;\n\t_owner = type + '#' + name.replace(/\\.package$/gi, '');\n\n\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\tme.processed = true;\n\n\tvar id = (type === 'module' ? '#' : '') + name;\n\tvar length = F.routes.web.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.web[i].controller === routeID)\n\t\t\tF.routes.web[i].controller = id;\n\t}\n\n\tvar tmp = Object.keys(F.routes.system);\n\tlength = tmp.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.system[tmp[i]].controller === routeID)\n\t\t\tF.routes.system[tmp[i]].controller = id;\n\t}\n\n\tlength = F.routes.websockets.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.websockets[i].controller === routeID)\n\t\t\tF.routes.websockets[i].controller = id;\n\t}\n\n\tlength = F.routes.files.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.files[i].controller === routeID)\n\t\t\tF.routes.files[i].controller = id;\n\t}\n\n\tF.$routesSort();\n\t_controller = '';\n\tname = name.replace(/\\.package$/gi, '');\n\n\tif (!skipEmit) {\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\t}\n\n\tF.consoledebug('install', type + '#' + name);\n\tcallback && callback(null, name);\n\treturn F;\n};\n\n/**\n * Uninstall type\n * @param {String} type Available types: model, module, controller, source.\n * @param {String} name\n * @param {Object} options Custom options, optional.\n * @param {Object} skipEmit Internal, optional.\n * @return {Framework}\n */\nF.uninstall = function(type, name, options, skipEmit, packageName) {\n\n\tvar obj = null;\n\tvar k, v, tmp;\n\n\tif (type === 'route' || type === 'web') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'execute';\n\t\tv = k === 'execute' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tif (k === 'urlraw' && v[0] === '#')\n\t\t\tdelete F.routes.system[v];\n\t\telse\n\t\t\tF.routes.web = F.routes.web.remove(k, v);\n\t\tF.$routesSort();\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\tF.temporary.other = {};\n\t\treturn F;\n\t}\n\n\tif (type === 'cors') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'hash' : 'hash';\n\t\tv = k === 'id' ? name.substring(3).trim() : name;\n\t\tif (k !== 'id')\n\t\t\tv = framework_internal.preparePath(framework_internal.encodeUnicodeURL(v.replace('*', '').trim()));\n\t\tF.routes.cors = F.routes.cors.remove(k, v);\n\t\tF._length_cors = F.routes.cors.length;\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'operation') {\n\t\tNEWOPERATION(name, null);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'convertor') {\n\t\tF.convertor(name, null);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'schedule') {\n\t\tF.clearSchedule(name);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tvar id = (packageName ? packageName + '@' : '') +  type + '#' + name;\n\n\tif (type === 'websocket') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'onInitialize';\n\t\tv = k === 'onInitialize' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tF.routes.websockets = F.routes.websockets.remove(k, v);\n\t\tF.$routesSort();\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'file') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'execute';\n\t\tv = k === 'execute' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tF.routes.files = F.routes.files.remove(k, v);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'schema') {\n\t\ttmp = name.split('/');\n\t\ttmp.length === 2 ? framework_builders.remove(tmp[0], tmp[1]) : framework_builders.remove(undefined, tmp[0]);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'mapping') {\n\t\tdelete F.routes.mapping[name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'isomorphic') {\n\t\tvar obj = F.isomorphic[name];\n\t\tif (obj.url)\n\t\t\tdelete F.routes.mapping[F.$version(obj.url)];\n\t\tdelete F.isomorphic[name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'middleware') {\n\n\t\tif (!F.routes.middleware[name])\n\t\t\treturn F;\n\n\t\tdelete F.routes.middleware[name];\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF._length_middleware = Object.keys(F.routes.middleware).length;\n\n\t\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\t\ttmp = F.routes.web[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tfor (var i = 0, length = F.routes.websockets.length; i < length; i++) {\n\t\t\ttmp = F.routes.websockets[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tfor (var i = 0, length = F.routes.files.length; i < length; i++) {\n\t\t\ttmp = F.routes.files[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t} else if (type === 'package') {\n\t\tdelete F.routes.packages[name];\n\t\tdelete F.temporary.ready['package#' + name];\n\t\tF.uninstall('module', name, options, true);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t} else if (type === 'view' || type === 'precompile') {\n\n\t\tobj = F.routes.views[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tdelete F.routes.views[name];\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\n\t\tfsFileExists(obj.filename, function(e) {\n\t\t\te && Fs.unlink(obj.filename, NOOP);\n\t\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\t});\n\n\t} else if (type === 'model' || type === 'source') {\n\n\t\tobj = type === 'model' ? F.models[name] : F.sources[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tF.$uninstall(id);\n\t\ttypeof(obj.uninstall) === 'function' && obj.uninstall(options, name);\n\n\t\tif (type === 'model')\n\t\t\tdelete F.models[name];\n\t\telse\n\t\t\tdelete F.sources[name];\n\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t} else if (type === 'module' || type === 'controller') {\n\n\t\tvar isModule = type === 'module';\n\t\tobj = isModule ? F.modules[name] : F.controllers[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tF.$uninstall(id, packageName ? '' : ((isModule ? '#' : '') + name));\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t\tif (obj) {\n\t\t\tobj.uninstall && obj.uninstall(options, name);\n\t\t\tif (isModule)\n\t\t\t\tdelete F.modules[name];\n\t\t\telse\n\t\t\t\tdelete F.controllers[name];\n\t\t}\n\n\t} else if (type === 'component') {\n\n\t\tif (!F.components.instances[name])\n\t\t\treturn F;\n\n\t\tobj = F.components.instances[name];\n\n\t\tif (obj) {\n\t\t\tF.$uninstall(id);\n\t\t\tobj.uninstall && obj.uninstall(options, name);\n\t\t\tdelete F.components.instances[name];\n\t\t}\n\n\t\tdelete F.components.instances[name];\n\t\tdelete F.components.views[name];\n\t\tdelete F.components.files[name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\n\t\tvar temporary = (F.id ? 'i-' + F.id + '_' : '') + 'components';\n\t\tvar data;\n\t\tvar index;\n\t\tvar beg = '\\n/*' + name.hash() + '*/\\n';\n\t\tvar end = beg.substring(0, beg.length - 1);\n\t\tvar is = false;\n\n\t\tif (F.components.js) {\n\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.js')).toString('utf-8');\n\t\t\tindex = data.indexOf(beg);\n\t\t\tif (index !== -1) {\n\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.js'), data);\n\t\t\t\tis = true;\n\t\t\t}\n\t\t}\n\n\t\tif (F.components.css) {\n\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.css')).toString('utf-8');\n\t\t\tindex = data.indexOf(beg);\n\t\t\tif (index !== -1) {\n\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.css'), data);\n\t\t\t\tis = true;\n\t\t\t}\n\t\t}\n\n\t\tif (obj.group) {\n\t\t\ttemporary += '_g' + obj.group.hash();\n\t\t\ttmp = F.components.groups[obj.group];\n\t\t\tif (tmp) {\n\n\t\t\t\tif (tmp.js) {\n\t\t\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.js')).toString('utf-8');\n\t\t\t\t\tindex = data.indexOf(beg);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.js'), data);\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tmp.css) {\n\t\t\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.css')).toString('utf-8');\n\t\t\t\t\tindex = data.indexOf(beg);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.css'), data);\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttmp.version = NOW.getTime();\n\t\t\t}\n\t\t}\n\n\t\tif (is)\n\t\t\tF.components.version = NOW.getTime();\n\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t}\n\n\t!skipEmit && EMIT('uninstall', type, name);\n\treturn F;\n};\n\nF.$uninstall = function(owner, controller) {\n\n\tif (!F.temporary.owners[owner])\n\t\treturn F;\n\n\tif (controller) {\n\t\tF.routes.web = F.routes.web.remove('controller', controller);\n\t\tF.routes.files = F.routes.files.remove('controller', controller);\n\t\tF.routes.websockets = F.routes.websockets.remove('controller', controller);\n\t}\n\n\tF.routes.web = F.routes.web.remove('owner', owner);\n\tF.routes.files = F.routes.files.remove('owner', owner);\n\tF.routes.websockets = F.routes.websockets.remove('owner', owner);\n\tF.routes.cors = F.routes.cors.remove('owner', owner);\n\tF.schedules = F.schedules.remove('owner', owner);\n\n\tif (F.modificators)\n\t\tF.modificators = F.modificators.remove('$owner', owner);\n\n\tframework_builders.uninstall(owner);\n\n\tvar owners = [];\n\tvar redirects = false;\n\n\tfor (var i = 0, length = F.owners.length; i < length; i++) {\n\n\t\tvar m = F.owners[i];\n\t\tif (m.owner !== owner) {\n\t\t\towners.push(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (m.type) {\n\t\t\tcase 'redirects':\n\t\t\t\tdelete F.routes.redirects[m.id];\n\t\t\t\tredirects = true;\n\t\t\t\tbreak;\n\t\t\tcase 'resize':\n\t\t\t\tdelete F.routes.resize[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tdelete F.routes.merge[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'mapping':\n\t\t\t\tdelete F.routes.mapping[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'blocks':\n\t\t\t\tdelete F.routes.blocks[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'middleware':\n\t\t\t\tUNINSTALL('middleware', m.id);\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (redirects)\n\t\tF._request_check_redirect = Object.keys(F.routes.redirects).length > 0;\n\n\tF.owners = owners;\n\tF.$routesSort();\n\tdelete F.temporary.owners[owner];\n\n\treturn F;\n};\n\n/**\n * Register internal mapping (e.g. Resource)\n * @param {String} path\n * @return {Framework}\n */\nF.register = function(path) {\n\n\tvar key;\n\tvar extension = '.' + U.getExtension(path);\n\tvar name = U.getName(path);\n\tvar c = path[0];\n\n\tif (c === '@')\n\t\tpath = F.path.package(path.substring(1));\n\telse if (c === '=') {\n\t\tif (path[1] === '?')\n\t\t\tF.path.themes(CONF.default_theme + path.substring(2));\n\t\telse\n\t\t\tpath = F.path.themes(path.substring(1));\n\t}\n\n\tswitch (extension) {\n\t\tcase '.resource':\n\t\t\tkey = name.replace(extension, '');\n\t\t\tif (F.routes.resources[key])\n\t\t\t\tF.routes.resources[key].push(path);\n\t\t\telse\n\t\t\t\tF.routes.resources[key] = [path];\n\t\t\t// clears cache\n\t\t\tdelete F.resources[key];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error('Not supported registration type \"' + extension + '\".');\n\t}\n\n\treturn F;\n};\n\n/**\n * Run code\n * @param {String or Function} script Function to eval or Code or URL address.\n * @return {Framework}\n */\nF.eval = function(script) {\n\treturn F.install('eval', script);\n};\n\n/**\n * Error handler\n * @param {Error} err\n * @param {String} name\n * @param {Object} uri URI address, optional.\n * @return {Framework}\n */\nF.onError = function(err, name, uri) {\n\tNOW = new Date();\n\tconsole.log('======= ' + (NOW.format('yyyy-MM-dd HH:mm:ss')) + ': ' + (name ? name + ' ---> ' : '') + err.toString() + (uri ? ' (' + Parser.format(uri) + ')' : ''), err.stack);\n\treturn F;\n};\n\n/*\n\tAuthorization handler\n\t@req {Request}\n\t@res {Response} OR {WebSocketClient}\n\t@flags {String array}\n\t@callback {Function} - @callback(Boolean), true is [authorize]d and false is [unauthorize]d\n*/\nF.onAuthorize = null;\n\n/*\n\tSets the current language for the current request\n\t@req {Request}\n\t@res {Response} OR {WebSocketClient}\n\t@return {String}\n*/\nF.onLocale = null;\n// OLD: F.onLocate = null;\n\n/**\n * Sets theme to controller\n * @controller {Controller}\n * @return {String}\n */\nF.onTheme = null;\n\n/*\n\tVersioning static files (this delegate call LESS CSS by the background property)\n\t@name {String} :: name of static file (style.css or script.js)\n\treturn {String} :: return new name of static file (style-new.css or script-new.js)\n*/\nF.onVersion = null;\n\n/**\n * On mapping static files\n * @param {String} url\n * @param {String} def Default value.\n * @return {String}\n */\nF.onMapping = function(url, def, ispublic, encode) {\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar tmp = url;\n\tif (CONF.default_root)\n\t\ttmp = tmp.substring(CONF.default_root.length - 1);\n\n\t// component files\n\tif (tmp[1] === '~') {\n\t\tvar index = tmp.indexOf('/', 2);\n\t\tvar name = tmp.substring(2, index);\n\t\treturn F.components.files[name] && F.components.files[name][tmp.substring(index + 1)] ? (F.path.temp() + tmp.substring(1)) : null;\n\t}\n\n\tif (F.routes.mapping[url])\n\t\treturn F.routes.mapping[url];\n\n\tif (F._length_themes) {\n\t\tvar index = tmp.indexOf('/', 2);\n\t\tif (index !== -1) {\n\t\t\tvar themeName = tmp.substring(1, index);\n\t\t\tif (F.themes[themeName])\n\t\t\t\treturn F.themes[themeName] + 'public' + tmp.substring(index);\n\t\t}\n\t}\n\n\tdef = framework_internal.preparePath(def, true);\n\n\tif (encode)\n\t\tdef = $decodeURIComponent(def);\n\n\tif (ispublic)\n\t\tdef = F.path.public_cache(def);\n\telse\n\t\tdef = def[0] === '~' ? def.substring(1) : def[0] === '.' ? def : F.path.public_cache(def);\n\n\treturn def;\n};\n\nF.download = F.snapshot = function(url, filename, callback) {\n\n\tif (!F.isLoaded) {\n\t\tsetTimeout(function(url, filename, callback) {\n\t\t\tF.snapshot(url, filename, callback);\n\t\t}, 200, url, filename, callback);\n\t\treturn F;\n\t}\n\n\turl = framework_internal.preparePath(url);\n\n\tif (!REG_HTTPHTTPS.test(url)) {\n\t\tif (url[0] !== '/')\n\t\t\turl = '/' + url;\n\t\tif (F.isWorker)\n\t\t\tthrow new Error('Worker can\\'t create a snapshot from relative URL address \"{0}\".'.format(url));\n\t\turl = 'http://' + (F.ip === 'auto' ? '0.0.0.0' : F.ip) + ':' + F.port + url;\n\t}\n\n\tU.download(url, FLAGS_INSTALL, function(err, response) {\n\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t\tcallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar stream = Fs.createWriteStream(filename);\n\t\tresponse.pipe(stream);\n\n\t\tresponse.on('error', function(err) {\n\t\t\tcallback && callback(err);\n\t\t\tcallback = null;\n\t\t});\n\n\t\tCLEANUP(stream, function() {\n\t\t\tcallback && callback(null, filename);\n\t\t\tcallback = null;\n\t\t});\n\t});\n\n\treturn F;\n};\n\n/**\n * Find WebSocket connection\n * @param {String/RegExp} path\n * @return {WebSocket}\n */\nF.findConnection = function(path) {\n\tvar arr = Object.keys(F.connections);\n\tvar is = U.isRegExp(path);\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar key = arr[i];\n\t\tif (is) {\n\t\t\tif (path.test(key))\n\t\t\t\treturn F.connections[key];\n\t\t} else {\n\t\t\tif (key.indexOf(path) !== -1)\n\t\t\t\treturn F.connections[key];\n\t\t}\n\t}\n};\n\n/**\n * Find WebSocket connections\n * @param {String/RegExp} path\n * @return {WebSocket Array}\n */\nF.findConnections = function(path) {\n\tvar arr = Object.keys(F.connections);\n\tvar is = U.isRegExp(path);\n\tvar output = [];\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar key = arr[i];\n\t\tif (!path)\n\t\t\toutput.push(F.connections[key]);\n\t\telse if (is)\n\t\t\tpath.test(key) && output.push(F.connections[key]);\n\t\telse\n\t\t\tkey.indexOf(path) !== -1 && output.push(F.connections[key]);\n\t}\n\treturn output;\n};\n\n/**\n * Global validation\n * @param {Function(name, value)} delegate\n * @type {Boolean or StringErrorMessage}\n */\nF.onValidate = null;\n\n/**\n * Global XML parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseXML = function(value) {\n\tvar val = U.parseXML(value);\n\tF._length_convertors && F.convert(val);\n\treturn val;\n};\nF.onParseXML.$def = true;\n\nF.$onParseXML = function(req) {\n\tif (F.onParseXML.$def) {\n\t\treq.body = U.parseXML(req.buffer_data);\n\t\tF._length_convertors && F.convert(req.body);\n\t} else\n\t\treq.body = F.onParseXML(req.buffer_data);\n};\n\n/**\n * Global JSON parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseJSON = function(value) {\n\tif (value) {\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {}\n\t}\n};\nF.onParseJSON.$def = true;\n\nF.$onParseJSON = function(req) {\n\treq.body = F.onParseJSON.$def ? JSON.parse(req.buffer_data) : F.onParseJSON(req.buffer_data);\n};\n\n/**\n * Global JSON parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseQuery = function(value) {\n\tif (value) {\n\t\tvar val = Qs.parse(value, null, null, QUERYPARSEROPTIONS);\n\t\tF._length_convertors && F.convert(val);\n\t\treturn val;\n\t}\n\treturn {};\n};\nF.onParseQuery.$def = true;\n\nF.$onParseQueryBody = function(req) {\n\tif (F.onParseQuery.$def) {\n\t\tif (req.buffer_data) {\n\t\t\treq.body = Qs.parse(req.buffer_data, null, null, QUERYPARSEROPTIONS);\n\t\t\tF._length_convertors && F.convert(req.body);\n\t\t} else\n\t\t\treq.body = {};\n\t} else\n\t\treq.body = F.onParseQuery(req.buffer_data, req);\n};\n\nF.$onParseQueryUrl = function(req) {\n\tif (F.onParseQuery.$def) {\n\t\treq._querydata = Qs.parse(req.uri.query, null, null, QUERYPARSEROPTIONS);\n\t\tF._length_convertors && F.convert(req._querydata);\n\t} else\n\t\treq._querydata = F.onParseQuery(req.uri.query, req);\n};\n\n/**\n * Schema parser delegate\n * @param {Request} req\n * @param {String} group\n * @param {String} name\n * @param {Function(err, body)} callback\n */\nF.onSchema = function(req, route, callback) {\n\n\tvar schema;\n\n\tif (route.isDYNAMICSCHEMA) {\n\t\tvar index = route.param[route.paramnames.indexOf(route.schema[1])];\n\t\treq.$schemaname = route.schema[0] + '/' + req.split[index];\n\t\tschema = framework_builders.findschema(req.$schemaname);\n\t} else\n\t\tschema = GETSCHEMA(route.schema[0], route.schema[1]);\n\n\tif (schema)\n\t\tschema.make(req.body, route.schema[2], onSchema_callback, callback, route.novalidate, route.workflow ? route.workflow.meta : null);\n\telse\n\t\tcallback('Schema \"' + (route.isDYNAMICSCHEMA ? req.$schemaname : (route.schema[0] + '/' + route.schema[1])) + '\" not found.');\n};\n\nfunction onSchema_callback(err, res, callback) {\n\tif (err)\n\t\tcallback(err);\n\telse\n\t\tcallback(null, res);\n}\n\n/**\n * Mail delegate\n * @param {String or Array String} address\n * @param {String} subject\n * @param {String} body\n * @param {Function(err)} callback\n * @param {String} replyTo\n * @return {MailMessage}\n */\nF.onMail = function(address, subject, body, callback, replyTo) {\n\n\tvar tmp;\n\n\tif (typeof(callback) === 'string') {\n\t\ttmp = replyTo;\n\t\treplyTo = callback;\n\t\tcallback = tmp;\n\t}\n\n\tvar message = Mail.create(subject, body);\n\n\tif (address instanceof Array) {\n\t\tfor (var i = 0, length = address.length; i < length; i++)\n\t\t\tmessage.to(address[i]);\n\t} else\n\t\tmessage.to(address);\n\n\tmessage.from(CONF.mail_address_from || '', CONF.name);\n\n\tif (replyTo)\n\t\tmessage.reply(replyTo);\n\telse {\n\t\ttmp = CONF.mail_address_reply;\n\t\ttmp && tmp.length > 3 && message.reply(tmp);\n\t}\n\n\ttmp = CONF.mail_address_copy;\n\ttmp && tmp.length > 3 && message.bcc(tmp);\n\n\tmessage.$sending = setImmediate(cb => message.send2(cb), callback);\n\treturn message;\n};\n\nF.onMeta = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\tvar self = this;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar arg = U.encode(arguments[i]);\n\t\tif (arg == null || !arg.length)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tbuilder += '<title>' + (arg + (F.url !== '/' && !CONF.allow_custom_titles ? ' - ' + CONF.name : '')) + '</title>';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuilder += '<meta name=\"description\" content=\"' + arg + '\" />';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuilder += '<meta name=\"keywords\" content=\"' + arg + '\" />';\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tvar tmp = arg.substring(0, 6);\n\t\t\t\tvar img = tmp === 'http:/' || tmp === 'https:' || arg.substring(0, 2) === '//' ? arg : self.hostname(self.routeImage(arg));\n\t\t\t\tbuilder += '<meta property=\"og:image\" content=\"' + img + '\" /><meta name=\"twitter:image\" content=\"' + img + '\" />';\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder;\n};\n\n// @arguments {Object params}\nglobal.LOG = F.log = function() {\n\n\tNOW = new Date();\n\tvar filename = NOW.getFullYear() + '-' + (NOW.getMonth() + 1).toString().padLeft(2, '0') + '-' + NOW.getDate().toString().padLeft(2, '0');\n\tvar time = NOW.getHours().toString().padLeft(2, '0') + ':' + NOW.getMinutes().toString().padLeft(2, '0') + ':' + NOW.getSeconds().toString().padLeft(2, '0');\n\tvar str = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar val = arguments[i];\n\t\tif (val === undefined)\n\t\t\tval = 'undefined';\n\t\telse if (val === null)\n\t\t\tval = 'null';\n\t\telse if (typeof(val) === 'object')\n\t\t\tval = Util.inspect(val);\n\t\tstr += (str ? ' ' : '') + val;\n\t}\n\n\tF.path.verify('logs');\n\tU.queue('F.log', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, filename + '.log'), time + ' | ' + str + '\\n', next));\n\treturn F;\n};\n\nglobal.LOGGER = F.logger = function() {\n\tNOW = new Date();\n\tvar dt = NOW.getFullYear() + '-' + (NOW.getMonth() + 1).toString().padLeft(2, '0') + '-' + NOW.getDate().toString().padLeft(2, '0') + ' ' + NOW.getHours().toString().padLeft(2, '0') + ':' + NOW.getMinutes().toString().padLeft(2, '0') + ':' + NOW.getSeconds().toString().padLeft(2, '0');\n\tvar str = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 1; i < length; i++) {\n\t\tvar val = arguments[i];\n\t\tif (val === undefined)\n\t\t\tval = 'undefined';\n\t\telse if (val === null)\n\t\t\tval = 'null';\n\t\telse if (typeof(val) === 'object')\n\t\t\tval = Util.inspect(val);\n\t\tstr += (str ? ' ' : '') + val;\n\t}\n\n\tF.path.verify('logs');\n\tU.queue('F.logger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, arguments[0] + '.log'), dt + ' | ' + str + '\\n', next));\n\treturn F;\n};\n\nglobal.LOGMAIL = F.logmail = function(address, subject, body, callback) {\n\n\tif (typeof(body) === FUNCTION) {\n\t\tcallback = body;\n\t\tbody = subject;\n\t\tsubject = null;\n\t} else if (body === undefined) {\n\t\tbody = subject;\n\t\tsubject = null;\n\t}\n\n\tif (!subject)\n\t\tsubject = CONF.name + ' v' + CONF.version;\n\n\tvar body = '<!DOCTYPE html><html><head><title>' + subject + '</title><meta charset=\"utf-8\" /></head><body><pre style=\"max-width:600px;font-size:13px;line-height:16px\">' + (typeof(body) === 'object' ? JSON.stringify(body).escape() : body) + '</pre></body></html>';\n\treturn F.onMail(address, subject, body, callback);\n};\n\nF.usage = function(detailed) {\n\n\tvar memory = process.memoryUsage();\n\tvar cache = Object.keys(F.cache.items);\n\tvar resources = Object.keys(F.resources);\n\tvar controllers = Object.keys(F.controllers);\n\tvar connections = Object.keys(F.connections);\n\tvar workers = Object.keys(F.workers);\n\tvar modules = Object.keys(F.modules);\n\tvar isomorphic = Object.keys(F.isomorphic);\n\tvar models = Object.keys(F.models);\n\tvar helpers = Object.keys(F.helpers);\n\tvar staticFiles = Object.keys(F.temporary.path);\n\tvar staticNotfound = Object.keys(F.temporary.notfound);\n\tvar staticRange = Object.keys(F.temporary.range);\n\tvar redirects = Object.keys(F.routes.redirects);\n\tvar output = {};\n\tvar nosqlcleaner = Object.keys(F.databasescleaner);\n\n\toutput.framework = {\n\t\tid: F.id,\n\t\tdatetime: NOW,\n\t\tpid: process.pid,\n\t\tnode: process.version,\n\t\tversion: 'v' + F.version_header,\n\t\tplatform: process.platform,\n\t\tprocessor: process.arch,\n\t\tuptime: Math.floor(process.uptime() / 60),\n\t\tmemoryTotal: (memory.heapTotal / 1024 / 1024).floor(2),\n\t\tmemoryUsage: (memory.heapUsed / 1024 / 1024).floor(2),\n\t\tmemoryRss: (memory.rss / 1024 / 1024).floor(2),\n\t\tmode: DEBUG,\n\t\tport: F.port,\n\t\tip: F.ip,\n\t\tdirectory: process.cwd()\n\t};\n\n\tif (CONF.nosql_worker)\n\t\toutput.framework.pidnosql = framework_nosql.pid();\n\n\tvar keys = Object.keys(U.queuecache);\n\tvar pending = 0;\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\tpending += U.queuecache[keys[i]].pending.length;\n\n\toutput.counter = {\n\t\tresource: resources.length,\n\t\tcontroller: controllers.length,\n\t\tmodule: modules.length,\n\t\tisomorphic: isomorphic.length,\n\t\tcache: cache.length,\n\t\tworker: workers.length,\n\t\tconnection: connections.length,\n\t\tschedule: F.schedules.length,\n\t\thelpers: helpers.length,\n\t\terror: F.errors.length,\n\t\tproblem: F.problems.length,\n\t\tqueue: pending,\n\t\tfiles: staticFiles.length,\n\t\tnotfound: staticNotfound.length,\n\t\tstreaming: staticRange.length,\n\t\tmodificator:  F.modificators ? F.modificators.length : 0,\n\t\tviewphrases: $VIEWCACHE.length,\n\t\tuptodates: F.uptodates ? F.uptodates.length : 0,\n\t\tnosqlcleaner: nosqlcleaner.length\n\t};\n\n\toutput.routing = {\n\t\twebpage: F.routes.web.length,\n\t\tsitemap: F.routes.sitemap ? Object.keys(F.routes.sitemap).length : 0,\n\t\twebsocket: F.routes.websockets.length,\n\t\tfile: F.routes.files.length,\n\t\tmiddleware: Object.keys(F.routes.middleware).length,\n\t\tredirect: redirects.length\n\t};\n\n\toutput.stats = F.stats;\n\toutput.redirects = redirects;\n\n\tif (!detailed)\n\t\treturn output;\n\n\toutput.controllers = [];\n\tfor (var i = 0, length = controllers.length; i < length; i++) {\n\t\tvar key = controllers[i];\n\t\tvar item = F.controllers[key];\n\t\toutput.controllers.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.connections = [];\n\tfor (var i = 0, length = connections.length; i < length; i++) {\n\t\tvar key = connections[i];\n\t\toutput.connections.push({ name: key, online: F.connections[key].online });\n\t}\n\n\toutput.modules = [];\n\tfor (var i = 0, length = modules.length; i < length; i++) {\n\t\tvar key = modules[i];\n\t\tvar item = F.modules[key];\n\t\toutput.modules.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.models = [];\n\tfor (var i = 0, length = models.length; i < length; i++) {\n\t\tvar key = models[i];\n\t\tvar item = F.models[key];\n\t\toutput.models.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.cache = cache;\n\toutput.changes = F.changes;\n\toutput.errors = F.errors;\n\toutput.files = staticFiles;\n\toutput.helpers = helpers;\n\toutput.nosqlcleaner = nosqlcleaner;\n\toutput.other = Object.keys(F.temporary.other);\n\toutput.problems = F.problems;\n\toutput.resources = resources;\n\toutput.streaming = staticRange;\n\toutput.traces = F.traces;\n\toutput.uptodates = F.uptodates;\n\n\treturn output;\n};\n\n/**\n * Compiles content in the view @{compile}...@{end}. The function has controller context, this === controler.\n * @param {String} name\n * @param {String} html HTML content to compile\n * @param {Object} model\n * @return {String}\n */\n// name, html, model\nF.onCompileView = function(name, html) {\n\treturn html;\n};\n\n/*\n\t3rd CSS compiler (Sync)\n\t@filename {String}\n\t@content {String} :: Content of CSS file\n\treturn {String}\n*/\nF.onCompileStyle = null;\n\n/*\n\t3rd JavaScript compiler (Sync)\n\t@filename {String}\n\t@content {String} :: Content of JavaScript file\n\treturn {String}\n*/\nF.onCompileScript = null;\n\nfunction compile_file(res) {\n\tfsFileRead(res.options.filename, function(err, buffer) {\n\n\t\tvar req = res.req;\n\t\tvar uri = req.uri;\n\n\t\tif (err) {\n\t\t\tF.error(err, res.options.filename, uri);\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t\treturn;\n\t\t}\n\n\t\tvar file = F.path.temp((F.id ? 'i-' + F.id + '_' : '') + createTemporaryKey(uri.pathname));\n\t\tF.path.verify('temp');\n\t\tFs.writeFileSync(file, compile_content(req.extension, framework_internal.parseBlock(F.routes.blocks[uri.pathname], buffer.toString(ENCODING)), res.options.filename), ENCODING);\n\t\tvar stats = Fs.statSync(file);\n\t\tvar tmp = [file, stats.size, stats.mtime.toUTCString()];\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t});\n\t});\n}\n\nfunction compile_merge(res) {\n\n\tvar req = res.req;\n\tvar uri = req.uri;\n\n\tvar merge = F.routes.merge[uri.pathname];\n\tvar filename = merge.filename;\n\n\tif (!DEBUG && existsSync(filename)) {\n\t\tvar stats = Fs.statSync(filename);\n\t\tvar tmp = [filename, stats.size, stats.mtime.toUTCString()];\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tres.$file();\n\t\t});\n\t\treturn;\n\t}\n\n\tvar writer = Fs.createWriteStream(filename);\n\n\twriter.on('finish', function() {\n\t\tvar stats = Fs.statSync(filename);\n\t\tvar tmp = [filename, stats.size, stats.mtime.toUTCString()];\n\t\tthis.destroy && this.destroy();\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t});\n\t});\n\n\tvar index = 0;\n\tvar remove = null;\n\n\tmerge.files.wait(function(filename, next) {\n\n\t\tvar block;\n\n\t\t// Skip isomorphic\n\t\tif (filename[0] !== '#') {\n\t\t\tvar blocks = filename.split('#');\n\t\t\tblock = blocks[1];\n\t\t\tblock && (filename = blocks[0]);\n\t\t}\n\n\t\tif (filename.startsWith('http://') || filename.startsWith('https://')) {\n\t\t\tU.request(filename, FLAGS_DOWNLOAD, function(err, data) {\n\n\t\t\t\tvar output = compile_content(req.extension, framework_internal.parseBlock(block, data), filename);\n\n\t\t\t\tif (req.extension === 'js') {\n\t\t\t\t\tif (output[output.length - 1] !== ';')\n\t\t\t\t\t\toutput += ';';\n\t\t\t\t} else if (req.extension === 'html') {\n\t\t\t\t\tif (output[output.length - 1] !== NEWLINE)\n\t\t\t\t\t\toutput += NEWLINE;\n\t\t\t\t}\n\n\t\t\t\tDEBUG && merge_debug_writer(writer, filename, req.extension, index++, block);\n\t\t\t\twriter.write(output);\n\t\t\t\tnext();\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tif (filename[0] !== '~') {\n\t\t\tvar tmp = F.path.public(filename);\n\t\t\tif (F.isVirtualDirectory && !existsSync(tmp))\n\t\t\t\ttmp = F.path.virtual(filename);\n\t\t\tfilename = tmp;\n\t\t} else\n\t\t\tfilename = filename.substring(1);\n\n\t\tvar indexer = filename.indexOf('*');\n\t\tif (indexer !== -1) {\n\n\t\t\tvar tmp = filename.substring(indexer + 1).toLowerCase();\n\t\t\tvar len = tmp.length;\n\t\t\t!remove && (remove = []);\n\n\t\t\t// Remove directory for all future requests\n\t\t\tremove.push(arguments[0]);\n\n\t\t\tU.ls(filename.substring(0, indexer), function(files) {\n\t\t\t\tfor (var j = 0, l = files.length; j < l; j++)\n\t\t\t\t\tmerge.files.push('~' + files[j]);\n\t\t\t\tnext();\n\t\t\t}, (path, isDirectory) => isDirectory ? true : path.substring(path.length - len).toLowerCase() === tmp);\n\t\t\treturn;\n\t\t}\n\n\t\tfsFileRead(filename, function(err, buffer) {\n\n\t\t\tif (err) {\n\t\t\t\tF.error(err, merge.filename, uri);\n\t\t\t\tnext();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar output = compile_content(req.extension, framework_internal.parseBlock(block, buffer.toString(ENCODING)), filename);\n\t\t\tif (req.extension === 'js') {\n\t\t\t\tif (output[output.length - 1] !== ';')\n\t\t\t\t\toutput += ';' + NEWLINE;\n\t\t\t} else if (req.extension === 'html') {\n\t\t\t\tif (output[output.length - 1] !== NEWLINE)\n\t\t\t\t\toutput += NEWLINE;\n\t\t\t}\n\n\t\t\tDEBUG && merge_debug_writer(writer, filename, req.extension, index++, block);\n\t\t\twriter.write(output);\n\t\t\tnext();\n\t\t});\n\n\t}, function() {\n\n\t\twriter.end();\n\n\t\t// Removes all directories from merge list (because the files are added into the queue)\n\t\tif (remove) {\n\t\t\tfor (var i = 0, length = remove.length; i < length; i++)\n\t\t\t\tmerge.files.splice(merge.files.indexOf(remove[i]), 1);\n\t\t}\n\t});\n\n\treturn F;\n}\n\nfunction merge_debug_writer(writer, filename, extension, index, block) {\n\tvar plus = '===========================================================================================';\n\tvar beg = extension === 'js' ? '/*\\n' : extension === 'css' ? '/*!\\n' : '<!--\\n';\n\tvar end = extension === 'js' || extension === 'css' ? '\\n */' : '\\n-->';\n\tvar mid = extension !== 'html' ? ' * ' : ' ';\n\twriter.write((index > 0 ? '\\n\\n' : '') + beg + mid + plus + '\\n' + mid + 'MERGED: ' + filename + '\\n' + (block ? mid + 'BLOCKS: ' + block + '\\n' : '') + mid + plus + end + '\\n\\n', ENCODING);\n}\n\nfunction component_debug(filename, value, extension) {\n\tvar plus = '===========================================================================================';\n\tvar beg = extension === 'js' ? '/*\\n' : extension === 'css' ? '/*!\\n' : '<!--\\n';\n\tvar end = extension === 'js' || extension === 'css' ? '\\n */' : '\\n-->';\n\tvar mid = extension !== 'html' ? ' * ' : ' ';\n\treturn beg + mid + plus + '\\n' + mid + 'COMPONENT: ' + filename + '\\n' + mid + plus + end + '\\n\\n' + value;\n}\n\nF.compile_virtual = function(res) {\n\n\tvar req = res.req;\n\tvar tmpname = res.options.filename.replace(CONF.directory_public, CONF.directory_public_virtual);\n\n\tif (tmpname === res.options.filename) {\n\t\tF.temporary.notfound[req.$key] = true;\n\t\tdelete F.temporary.processing[req.$key];\n\t\tres.$file();\n\t\treturn;\n\t}\n\n\tfsFileExists(tmpname, function(e, size, sfile, stats) {\n\n\t\tif (!e) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!res.noCompress && COMPRESSIONSPECIAL[req.extension] && CONF.allow_compile && !REG_NOCOMPRESS.test(res.options.filename)) {\n\t\t\tres.options.filename = tmpname;\n\t\t\treturn compile_file(res);\n\t\t}\n\n\t\tvar tmp = [tmpname, size, stats.mtime.toUTCString()];\n\t\tif (CONF.allow_gzip && COMPRESSION[U.getContentType(req.extension)]) {\n\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\tres.$file();\n\t\t\t});\n\t\t} else {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t}\n\t});\n\n\treturn;\n};\n\nfunction compile_check(res) {\n\n\tvar req = res.req;\n\tvar uri = req.uri;\n\n\tif (F.routes.merge[uri.pathname]) {\n\t\tcompile_merge(res);\n\t\treturn F;\n\t}\n\n\tfsFileExists(res.options.filename, function(e, size, sfile, stats) {\n\n\t\tif (e) {\n\n\t\t\tif (!res.noCompress && COMPRESSIONSPECIAL[req.extension] && CONF.allow_compile && !REG_NOCOMPRESS.test(res.options.filename))\n\t\t\t\treturn compile_file(res);\n\n\t\t\tvar tmp = [res.options.filename, size, stats.mtime.toUTCString()];\n\t\t\tif (CONF.allow_gzip && COMPRESSION[U.getContentType(req.extension)]) {\n\t\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\t\tres.$file();\n\t\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tres.$file();\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t}\n\n\t\t} else if (F.isVirtualDirectory)\n\t\t\tF.compile_virtual(res);\n\t\telse {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction compile_gzip(arr, callback) {\n\n\t// GZIP compression\n\n\tvar filename = F.path.temp('file' + arr[0].hash().toString().replace('-', '0') + '.gz');\n\tarr.push(filename);\n\n\tvar reader = Fs.createReadStream(arr[0]);\n\tvar writer = Fs.createWriteStream(filename);\n\n\tCLEANUP(writer, function() {\n\t\tfsFileExists(filename, function(e, size) {\n\t\t\tarr.push(size);\n\t\t\tcallback(arr);\n\t\t});\n\t});\n\n\treader.pipe(Zlib.createGzip(GZIPFILE)).pipe(writer);\n\tCLEANUP(reader);\n}\n\nfunction compile_content(extension, content, filename) {\n\n\tif (filename && REG_NOCOMPRESS.test(filename))\n\t\treturn content;\n\n\tswitch (extension) {\n\t\tcase 'js':\n\t\t\treturn CONF.allow_compile_script ? framework_internal.compile_javascript(content, filename) : content;\n\n\t\tcase 'css':\n\t\t\tcontent = CONF.allow_compile_style ? framework_internal.compile_css(content, filename) : content;\n\t\t\tvar matches = content.match(REG_COMPILECSS);\n\t\t\tif (matches) {\n\t\t\t\tfor (var i = 0, length = matches.length; i < length; i++) {\n\t\t\t\t\tvar key = matches[i];\n\t\t\t\t\tvar url = key.substring(4, key.length - 1);\n\t\t\t\t\tcontent = content.replace(key, 'url(' + F.$version(url, true) + ')');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn content;\n\t}\n\n\treturn content;\n}\n\nF.restore = function(filename, target, callback, filter) {\n\n\tvar buffer_key = U.createBuffer(':');\n\tvar buffer_new = U.createBuffer('\\n');\n\tvar buffer_dir = U.createBuffer('#');\n\tvar cache = {};\n\tvar data = null;\n\tvar type = 0;\n\tvar item = null;\n\tvar stream = Fs.createReadStream(filename);\n\tvar index = 0;\n\tvar parser = {};\n\tvar open = {};\n\tvar pending = 0;\n\tvar end = false;\n\tvar output = {};\n\n\toutput.count = 0;\n\toutput.path = target;\n\n\tparser.parse_key = function() {\n\n\t\tindex = data.indexOf(buffer_key);\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tindex++;\n\t\titem = data.slice(0, index - 1).toString('utf8').trim();\n\t\tdata = data.slice(index);\n\t\ttype = 1;\n\t\tparser.next();\n\t};\n\n\tparser.parse_meta = function() {\n\t\tvar path = Path.join(target, item);\n\n\t\t// Is directory?\n\t\tif (data[0] === buffer_dir[0]) {\n\t\t\tif (!cache[path]) {\n\t\t\t\tcache[path] = true;\n\t\t\t\tif (!filter || filter(item, true) !== false)\n\t\t\t\t\tF.path.mkdir(path);\n\t\t\t}\n\t\t\ttype = 3;\n\t\t\tparser.next();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!cache[path]) {\n\t\t\tcache[path] = true;\n\n\t\t\tvar npath = path.substring(0, path.lastIndexOf(F.isWindows ? '\\\\' : '/'));\n\n\t\t\tvar filename = filter && filter(item, false);\n\n\t\t\tif (!filter || filename || filename == null)\n\t\t\t\tF.path.mkdir(npath);\n\t\t\telse {\n\t\t\t\ttype = 5; // skip\n\t\t\t\tparser.next();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(filename) === 'string')\n\t\t\tpath = Path.join(target, filename);\n\n\t\t// File\n\t\ttype = 2;\n\t\tvar tmp = open[item] = {};\n\t\ttmp.path = path;\n\t\ttmp.name = item;\n\t\ttmp.writer = Fs.createWriteStream(path);\n\t\ttmp.zlib = Zlib.createGunzip();\n\t\ttmp.zlib.$self = tmp;\n\t\tpending++;\n\n\t\toutput.count++;\n\n\t\ttmp.zlib.on('error', function(e) {\n\t\t\tpending--;\n\t\t\tvar tmp = this.$self;\n\t\t\ttmp.writer.end();\n\t\t\ttmp.writer = null;\n\t\t\ttmp.zlib = null;\n\t\t\tdelete open[tmp.name];\n\t\t\tF.error(e, 'bundling', path);\n\t\t});\n\n\t\ttmp.zlib.on('data', function(chunk) {\n\t\t\tthis.$self.writer.write(chunk);\n\t\t});\n\n\t\ttmp.zlib.on('end', function() {\n\t\t\tpending--;\n\t\t\tvar tmp = this.$self;\n\t\t\ttmp.writer.end();\n\t\t\ttmp.writer = null;\n\t\t\ttmp.zlib = null;\n\t\t\tdelete open[tmp.name];\n\t\t});\n\n\t\tparser.next();\n\t};\n\n\tparser.parse_dir = function() {\n\t\tindex = data.indexOf(buffer_new);\n\t\tif (index !== -1) {\n\t\t\tdata = data.slice(index + 1);\n\t\t\ttype = 0;\n\t\t}\n\t\tparser.next();\n\t};\n\n\tparser.parse_data = function() {\n\n\t\tindex = data.indexOf(buffer_new);\n\n\t\tvar skip = false;\n\n\t\tif (index !== -1)\n\t\t\ttype = 0;\n\n\t\tif (type) {\n\t\t\tvar remaining = data.length % 4;\n\t\t\tif (remaining) {\n\t\t\t\topen[item].zlib.write(U.createBuffer(data.slice(0, data.length - remaining).toString('ascii'), 'base64'));\n\t\t\t\tdata = data.slice(data.length - remaining);\n\t\t\t\tskip = true;\n\t\t\t} else {\n\t\t\t\topen[item].zlib.write(U.createBuffer(data.toString('ascii'), 'base64'));\n\t\t\t\tdata = null;\n\t\t\t}\n\t\t} else {\n\t\t\topen[item].zlib.end(U.createBuffer(data.slice(0, index).toString('ascii'), 'base64'));\n\t\t\tdata = data.slice(index + 1);\n\t\t}\n\n\t\t!skip && data && data.length && parser.next();\n\t};\n\n\tparser.next = function() {\n\t\tswitch (type) {\n\t\t\tcase 0:\n\t\t\t\tparser.parse_key();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tparser.parse_meta();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparser.parse_data();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tparser.parse_dir();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tindex = data.indexOf(buffer_new);\n\t\t\t\tif (index === -1)\n\t\t\t\t\tdata = null;\n\t\t\t\telse {\n\t\t\t\t\tdata = data.slice(index + 1);\n\t\t\t\t\ttype = 0;\n\t\t\t\t\tparser.next();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tend && !data.length && callback && callback(null, output);\n\t};\n\n\tparser.end = function() {\n\t\tif (callback) {\n\t\t\tif (pending)\n\t\t\t\tsetTimeout(parser.end, 100);\n\t\t\telse if (end && !data.length)\n\t\t\t\tcallback(null, output);\n\t\t}\n\t};\n\n\tstream.on('data', function(chunk) {\n\n\t\tif (data) {\n\t\t\tCONCAT[0] = data;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tdata = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tdata = chunk;\n\n\t\tparser.next();\n\t});\n\n\tCLEANUP(stream, function() {\n\t\tend = true;\n\t\tparser.end();\n\t});\n\n\treturn F;\n};\n\nF.backup = function(filename, filelist, callback, filter) {\n\n\tvar padding = 100;\n\tvar path = filelist instanceof Array ? F.path.root() : filelist;\n\n\tif (!(filelist instanceof Array))\n\t\tfilelist = [''];\n\n\tvar counter = 0;\n\n\tFs.unlink(filename, function() {\n\n\t\tfilelist.sort(function(a, b) {\n\t\t\tvar ac = a.split('/');\n\t\t\tvar bc = b.split('/');\n\t\t\tif (ac.length < bc.length)\n\t\t\t\treturn -1;\n\t\t\telse if (ac.length > bc.length)\n\t\t\t\treturn 1;\n\t\t\treturn a.localeCompare(b);\n\t\t});\n\n\t\tvar writer = Fs.createWriteStream(filename);\n\n\t\twriter.on('finish', function() {\n\t\t\tcallback && Fs.stat(filename, (e, stat) => callback(null, { filename: filename, files: counter, size: stat.size }));\n\t\t});\n\n\t\tfilelist.wait(function(item, next) {\n\n\t\t\tvar file = Path.join(path, item);\n\n\t\t\tif (F.isWindows)\n\t\t\t\titem = item.replace(/\\\\/g, '/');\n\n\t\t\tif (item[0] !== '/')\n\t\t\t\titem = '/' + item;\n\n\t\t\tFs.stat(file, function(err, stats) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'F.backup()', filename);\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tvar dir = item.replace(/\\\\/g, '/') + '/';\n\t\t\t\t\tif (filter && !filter(dir, true))\n\t\t\t\t\t\treturn next();\n\t\t\t\t\tU.ls(file, function(f, d) {\n\t\t\t\t\t\tvar length = path.length;\n\t\t\t\t\t\td.wait(function(item, next) {\n\t\t\t\t\t\t\twriter.write(item.substring(length).padRight(padding) + ':#\\n', 'utf8');\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}, function() {\n\t\t\t\t\t\t\tfor (var i = 0; i < f.length; i++)\n\t\t\t\t\t\t\t\tfilelist.push(f[i].substring(length));\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar data = U.createBufferSize(0);\n\t\t\t\twriter.write(item.padRight(padding) + ':');\n\t\t\t\tFs.createReadStream(file).pipe(Zlib.createGzip(GZIPFILE)).on('data', function(chunk) {\n\n\t\t\t\t\tCONCAT[0] = data;\n\t\t\t\t\tCONCAT[1] = chunk;\n\t\t\t\t\tdata = Buffer.concat(CONCAT);\n\n\t\t\t\t\tvar remaining = data.length % 3;\n\t\t\t\t\tif (remaining) {\n\t\t\t\t\t\twriter.write(data.slice(0, data.length - remaining).toString('base64'));\n\t\t\t\t\t\tdata = data.slice(data.length - remaining);\n\t\t\t\t\t}\n\n\t\t\t\t}).on('end', function() {\n\t\t\t\t\tdata.length && writer.write(data.toString('base64'));\n\t\t\t\t\twriter.write('\\n', 'utf8');\n\t\t\t\t\tcounter++;\n\t\t\t\t\tsetImmediate(next);\n\t\t\t\t});\n\n\t\t\t});\n\t\t}, () => writer.end());\n\t});\n\n\treturn F;\n};\n\nF.exists = function(req, res, max, callback) {\n\n\tif (typeof(max) === 'function') {\n\t\tcallback = max;\n\t\tmax = 10;\n\t}\n\n\tvar name = req.$key = createTemporaryKey(req);\n\tvar filename = F.path.temp(name);\n\tvar httpcachevalid = RELEASE && (req.headers['if-none-match'] === (ETAG + CONF.etag_version));\n\n\tif (F.isProcessed(name) || httpcachevalid) {\n\t\tres.options.filename = filename;\n\t\tres.$file();\n\t\treturn F;\n\t}\n\n\tU.queue('F.exists', max, function(next) {\n\t\tfsFileExists(filename, function(e) {\n\t\t\tif (e) {\n\t\t\t\tres.options.filename = filename;\n\t\t\t\tres.options.callback = next;\n\t\t\t\tres.$file();\n\t\t\t} else\n\t\t\t\tcallback(next, filename, req, res);\n\t\t});\n\t});\n\n\treturn F;\n};\n\n/**\n * Is processed static file?\n * @param {String / Request} filename Filename or Request object.\n * @return {Boolean}\n */\nF.isProcessed = function(filename) {\n\n\tif (filename.url) {\n\t\tvar name = filename.url;\n\t\tvar index = name.indexOf('?');\n\t\tif (index !== -1)\n\t\t\tname = name.substring(0, index);\n\t\tfilename = F.path.public($decodeURIComponent(name));\n\t}\n\n\treturn !F.temporary.notfound[filename] && F.temporary.path[filename] !== undefined;\n};\n\n/**\n * Processing\n * @param {String / Request} filename Filename or Request object.\n * @return {Boolean}\n */\nF.isProcessing = function(filename) {\n\n\tif (!filename.url)\n\t\treturn !!F.temporary.processing[filename];\n\n\tvar name = filename.url;\n\tvar index = name.indexOf('?');\n\n\tif (index !== -1)\n\t\tname = name.substring(0, index);\n\n\tfilename = U.combine(CONF.directory_public, $decodeURIComponent(name));\n\treturn !!F.temporary.processing[filename];\n};\n\n/**\n * Clears file information in release mode\n * @param {String/Request} url\n * @return {Framework}\n */\nF.touch = function(url) {\n\tif (url) {\n\t\tvar key = createTemporaryKey(url);\n\t\tdelete F.temporary.path[key];\n\t\tdelete F.temporary.notfound[key];\n\t} else {\n\t\tF.temporary.path = {};\n\t\tF.temporary.notfound = {};\n\t}\n\treturn F;\n};\n\n// OBSOLETE\nF.responseImage = function(req, res, filename, make, headers, done) {\n\tOBSOLETE('F.responseImage()', 'This method is obsolete, use res.img()');\n\n\tif (typeof(filename) === 'object')\n\t\tres.options.stream = filename;\n\telse\n\t\tres.options.filename = filename;\n\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\tres.options.make = make;\n\tres.$image();\n\treturn F;\n};\n\n// OBSOLETE\nF.responseFile = function(req, res, filename, downloadName, headers, done, key) {\n\tOBSOLETE('F.responseFile()', 'This method is obsolete, use res.file()');\n\tres.$key = key;\n\tres.options.filename = filename;\n\tres.options.download = downloadName;\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\tres.$file();\n\treturn F;\n};\n\nF.response503 = function(req, res) {\n\tres.options.code = 503;\n\tres.options.headers = HEADERS.response503;\n\tres.options.body = F.view('.' + PATHMODULES + '503', F.waits);\n\tres.$text();\n\treturn F;\n};\n\nglobal.LOAD = F.load = function(debug, types, pwd) {\n\n\tif (pwd && pwd[0] === '.' && pwd.length < 4)\n\t\tF.directory = directory = U.$normalize(Path.normalize(directory + '/..'));\n\telse if (pwd)\n\t\tF.directory = directory = U.$normalize(pwd);\n\n\tif (typeof(debug) === 'string') {\n\t\tswitch (debug.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\t\tcase 'release':\n\t\t\tcase 'production':\n\t\t\t\tdebug = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'debug':\n\t\t\tcase 'develop':\n\t\t\tcase 'development':\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'test-debug':\n\t\t\tcase 'debug-test':\n\t\t\tcase 'testing-debug':\n\t\t\t\tdebug = true;\n\t\t\t\tF.isTest = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'test':\n\t\t\tcase 'testing':\n\t\t\tcase 'test-release':\n\t\t\tcase 'release-test':\n\t\t\tcase 'testing-release':\n\t\t\tcase 'test-production':\n\t\t\tcase 'testing-production':\n\t\t\t\tdebug = false;\n\t\t\t\tF.isTest = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tF.isWorker = true;\n\tF.isDebug = debug;\n\n\tglobal.DEBUG = debug;\n\tglobal.RELEASE = !debug;\n\tglobal.I = global.isomorphic = F.isomorphic;\n\n\tF.$bundle(function() {\n\t\tF.consoledebug('startup');\n\t\tF.$startup(function() {\n\n\t\t\tF.consoledebug('startup (done)');\n\t\t\tF.$configure_configs();\n\n\t\t\tif (!types || types.indexOf('versions') !== -1)\n\t\t\t\tF.$configure_versions();\n\n\t\t\tif (!types || types.indexOf('workflows') !== -1)\n\t\t\t\tF.$configure_workflows();\n\n\t\t\tif (!types || types.indexOf('sitemap') !== -1)\n\t\t\t\tF.$configure_sitemap();\n\n\t\t\tF.consoledebug('init');\n\t\t\tF.cache.init();\n\t\t\tEMIT('init');\n\n\t\t\tF.$load(types, directory, function() {\n\n\t\t\t\tF.isLoaded = true;\n\t\t\t\tprocess.send && process.send('total:ready');\n\n\t\t\t\tsetTimeout(function() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tEMIT('load', F);\n\t\t\t\t\t\tEMIT('ready', F);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tF.error(err, 'F.on(\"load/ready\")');\n\t\t\t\t\t}\n\n\t\t\t\t\tF.removeAllListeners('load');\n\t\t\t\t\tF.removeAllListeners('ready');\n\n\t\t\t\t\tif (F.isTest) {\n\t\t\t\t\t\tF.console();\n\t\t\t\t\t\tF.test();\n\t\t\t\t\t\treturn F;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tif (!F.isTest)\n\t\t\t\t\t\t\tdelete F.test;\n\t\t\t\t\t}, 5000);\n\n\t\t\t\t}, 500);\n\n\t\t\t\tif (CONF.allow_debug) {\n\t\t\t\t\tF.consoledebug('done');\n\t\t\t\t\tF.usagesnapshot();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}, !types || types.indexOf('bundles') !== -1);\n\n\treturn F;\n};\n\n/**\n * Initialize framework\n * @param  {Object} http\n * @param  {Boolean} debug\n * @param  {Object} options\n * @return {Framework}\n */\nF.initialize = function(http, debug, options) {\n\n\tif (!options)\n\t\toptions = {};\n\n\tvar port = options.port;\n\tvar ip = options.ip;\n\tvar listenpath = options.listenpath;\n\n\toptions.config && U.extend_headers2(CONF, options.config);\n\n\tif (options.debug || options['allow-debug'] || options.allow_debug)\n\t\tCONF.allow_debug = true;\n\n\tF.isHTTPS = http.STATUS_CODES === undefined;\n\n\tif (isNaN(port) && typeof(port) !== 'string')\n\t\tport = null;\n\n\tif (options.id)\n\t\tF.id = options.id;\n\n\tF.isDebug = debug;\n\n\tif (options.bundling != null)\n\t\tF.$bundling = options.bundling == true;\n\n\tglobal.DEBUG = debug;\n\tglobal.RELEASE = !debug;\n\tglobal.I = global.isomorphic = F.isomorphic;\n\n\tif (options.tests) {\n\t\tF.testlist = options.tests;\n\t\tfor (var i = 0; i < F.testlist.length; i++)\n\t\t\tF.testlist[i] = F.testlist[i].replace(/\\.js$/, '');\n\t}\n\n\tF.$bundle(function() {\n\n\t\tF.$configure_configs();\n\t\tF.$configure_versions();\n\t\tF.$configure_workflows();\n\t\tF.$configure_sitemap();\n\t\tF.isTest && F.$configure_configs('config-test', true);\n\t\tF.cache.init();\n\t\tF.consoledebug('init');\n\t\tEMIT('init');\n\n\t\tif (!port) {\n\t\t\tif (CONF.default_port === 'auto') {\n\t\t\t\tvar envPort = +(process.env.PORT || '');\n\t\t\t\tif (!isNaN(envPort))\n\t\t\t\t\tport = envPort;\n\t\t\t} else\n\t\t\t\tport = CONF.default_port;\n\t\t}\n\n\t\tF.port = port || 8000;\n\n\t\tif (ip !== null) {\n\t\t\tF.ip = ip || CONF.default_ip || '0.0.0.0';\n\t\t\tif (F.ip === 'null' || F.ip === 'undefined' || F.ip === 'auto')\n\t\t\t\tF.ip = null;\n\t\t} else\n\t\t\tF.ip = undefined;\n\n\t\tif (F.ip == null)\n\t\t\tF.ip = '0.0.0.0';\n\n\t\t!listenpath && (listenpath = CONF.default_listenpath);\n\t\tF.listenpath = listenpath;\n\n\t\tif (F.server) {\n\t\t\tF.server.removeAllListeners();\n\t\t\tObject.keys(F.connections).forEach(function(key) {\n\t\t\t\tvar item = F.connections[key];\n\t\t\t\tif (item) {\n\t\t\t\t\titem.removeAllListeners();\n\t\t\t\t\titem.close();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tF.server.close();\n\t\t}\n\n\t\tvar listen = function() {\n\n\t\t\tif (options.https) {\n\n\t\t\t\tvar meta = options.https;\n\n\t\t\t\tif (typeof(meta.key) === 'string') {\n\t\t\t\t\tif (meta.key.indexOf('.') === -1)\n\t\t\t\t\t\tmeta.key = U.createBuffer(meta.key, 'base64');\n\t\t\t\t\telse\n\t\t\t\t\t\tmeta.key = Fs.readFileSync(meta.key);\n\t\t\t\t}\n\n\t\t\t\tif (typeof(meta.cert) === 'string') {\n\t\t\t\t\tif (meta.cert.indexOf('.') === -1)\n\t\t\t\t\t\tmeta.cert = U.createBuffer(meta.cert, 'base64');\n\t\t\t\t\telse\n\t\t\t\t\t\tmeta.cert = Fs.readFileSync(meta.cert);\n\t\t\t\t}\n\n\t\t\t\tF.server = http.createServer(meta, F.listener);\n\n\t\t\t} else\n\t\t\t\tF.server = http.createServer(F.listener);\n\n\t\t\tCONF.allow_performance && F.server.on('connection', connection_tunning);\n\t\t\tF.initwebsocket && F.initwebsocket();\n\t\t\tF.consoledebug('HTTP listening');\n\n\t\t\tif (listenpath)\n\t\t\t\tF.server.listen(listenpath);\n\t\t\telse\n\t\t\t\tF.server.listen(F.port, F.ip);\n\t\t};\n\n\t\t// clears static files\n\t\tF.consoledebug('clear temporary');\n\t\tF.clear(function() {\n\n\t\t\tF.consoledebug('clear temporary (done)');\n\t\t\tF.$load(undefined, directory, function() {\n\n\t\t\t\tF.isLoaded = true;\n\t\t\t\tprocess.send && process.send('total:ready');\n\n\t\t\t\tif (options.middleware)\n\t\t\t\t\toptions.middleware(listen);\n\t\t\t\telse\n\t\t\t\t\tlisten();\n\n\t\t\t\tif (CONF.allow_debug) {\n\t\t\t\t\tF.consoledebug('done');\n\t\t\t\t\tF.usagesnapshot();\n\t\t\t\t}\n\n\t\t\t\tif (!process.connected)\n\t\t\t\t\tF.console();\n\n\t\t\t\tsetTimeout(function() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tEMIT('load', F);\n\t\t\t\t\t\tEMIT('ready', F);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tF.error(err, 'F.on(\"load/ready\")');\n\t\t\t\t\t}\n\n\t\t\t\t\tF.removeAllListeners('load');\n\t\t\t\t\tF.removeAllListeners('ready');\n\t\t\t\t\toptions.package && INSTALL('package', options.package);\n\t\t\t\t}, 500);\n\n\t\t\t\tif (F.isTest) {\n\t\t\t\t\tvar sleep = options.sleep || options.delay || 1000;\n\t\t\t\t\tsetTimeout(F.test, sleep);\n\t\t\t\t\treturn F;\n\t\t\t\t}\n\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif (!F.isTest)\n\t\t\t\t\t\tdelete F.test;\n\t\t\t\t}, 5000);\n\t\t\t});\n\t\t}, true);\n\t});\n\n\treturn F;\n};\n\nfunction connection_tunning(socket) {\n\tsocket.setNoDelay(true);\n\tsocket.setKeepAlive(true, 10);\n}\n\n/**\n * Run framework \u2013> HTTP\n * @param  {String} mode Framework mode.\n * @param  {Object} options Framework settings.\n * @param {Function(listen)} middleware A middleware for manual calling of HTTP listener\n * @return {Framework}\n */\nF.http = function(mode, options, middleware) {\n\tF.consoledebug('begin');\n\n\tif (typeof(options) === 'function') {\n\t\tmiddleware = options;\n\t\toptions = null;\n\t}\n\n\toptions == null && (options = {});\n\t!options.port && (options.port = +process.argv[2]);\n\n\tif (options.port && isNaN(options.port))\n\t\toptions.port = 0;\n\n\tif (typeof(middleware) === 'function')\n\t\toptions.middleware = middleware;\n\n\tif (options.bundling != null)\n\t\tF.$bundling = options.bundling;\n\n\tvar http = require('http');\n\textend_request(http.IncomingMessage.prototype);\n\textend_response(http.ServerResponse.prototype);\n\treturn F.mode(http, mode, options);\n};\n\n/**\n * Run framework \u2013> HTTPS\n * @param {String} mode Framework mode.\n * @param {Object} options Framework settings.\n * @param {Function(listen)} middleware A middleware for manual calling of HTTP listener\n * @return {Framework}\n */\nF.https = function(mode, options, middleware) {\n\tF.consoledebug('begin');\n\tvar http = require('http');\n\n\tif (typeof(options) === 'function') {\n\t\tmiddleware = options;\n\t\toptions = null;\n\t}\n\n\toptions == null && (options = {});\n\t!options.port && (options.port = +process.argv[2]);\n\n\tif (options.port && isNaN(options.port))\n\t\toptions.port = 0;\n\n\tif (typeof(middleware) === 'function')\n\t\toptions.middleware = middleware;\n\n\textend_request(http.IncomingMessage.prototype);\n\textend_response(http.ServerResponse.prototype);\n\treturn F.mode(require('https'), mode, options);\n};\n\nF.mode = function(http, name, options) {\n\n\tvar debug = false;\n\n\tif (options.directory)\n\t\tF.directory = directory = options.directory;\n\n\tif (typeof(http) === 'string') {\n\t\tswitch (http) {\n\t\t\tcase 'debug':\n\t\t\tcase 'development':\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\t\t}\n\t\tDEBUG = debug;\n\t\tCONF.trace = debug;\n\t\tF.isDebug = debug;\n\t\tglobal.DEBUG = debug;\n\t\tglobal.RELEASE = !debug;\n\t\treturn F;\n\t}\n\n\tF.isWorker = false;\n\n\tswitch (name.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\tcase 'release':\n\t\tcase 'production':\n\t\t\tbreak;\n\n\t\tcase 'debug':\n\t\tcase 'develop':\n\t\tcase 'development':\n\t\t\tdebug = true;\n\t\t\tbreak;\n\n\t\tcase 'test-debug':\n\t\tcase 'debug-test':\n\t\tcase 'testing-debug':\n\t\t\tdebug = true;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\n\t\tcase 'test':\n\t\tcase 'testing':\n\t\tcase 'test-release':\n\t\tcase 'release-test':\n\t\tcase 'testing-release':\n\t\tcase 'test-production':\n\t\tcase 'testing-production':\n\t\t\tdebug = false;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\t}\n\n\tCONF.trace = debug;\n\tF.consoledebug('startup');\n\tF.$startup(function() {\n\t\tF.consoledebug('startup (done)');\n\t\tF.initialize(http, debug, options);\n\t});\n\treturn F;\n};\n\nF.custom = function(mode, http, request, response, options) {\n\tvar debug = false;\n\n\tif (options.directory)\n\t\tF.directory = directory = options.directory;\n\n\tF.consoledebug('begin');\n\n\textend_request(request);\n\textend_response(response);\n\n\tswitch (mode.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\tcase 'release':\n\t\tcase 'production':\n\t\t\tbreak;\n\n\t\tcase 'debug':\n\t\tcase 'develop':\n\t\tcase 'development':\n\t\t\tdebug = true;\n\t\t\tbreak;\n\n\t\tcase 'test':\n\t\tcase 'testing':\n\t\tcase 'test-debug':\n\t\tcase 'debug-test':\n\t\tcase 'testing-debug':\n\t\t\tdebug = true;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\n\t\tcase 'test-release':\n\t\tcase 'release-test':\n\t\tcase 'testing-release':\n\t\tcase 'test-production':\n\t\tcase 'testing-production':\n\t\t\tdebug = false;\n\t\t\tbreak;\n\t}\n\n\tCONF.trace = debug;\n\tF.consoledebug('startup');\n\tF.$startup(function() {\n\t\tF.consoledebug('startup (done)');\n\t\tF.initialize(http, debug, options);\n\t});\n\n\treturn F;\n};\n\nF.console = function() {\n\tvar memory = process.memoryUsage();\n\tconsole.log('====================================================');\n\tconsole.log('PID           : ' + process.pid);\n\tconsole.log('Node.js       : ' + process.version);\n\tconsole.log('Total.js      : v' + F.version_header);\n\tconsole.log('OS            : ' + Os.platform() + ' ' + Os.release());\n\tCONF.nosql_worker && console.log('NoSQL PID     : ' + framework_nosql.pid());\n\tconsole.log('Memory        : ' + memory.heapUsed.filesize(2) + ' / ' + memory.heapTotal.filesize(2));\n\tconsole.log('User          : ' + Os.userInfo().username);\n\tconsole.log('====================================================');\n\tconsole.log('Name          : ' + CONF.name);\n\tconsole.log('Version       : ' + CONF.version);\n\tCONF.author && console.log('Author        : ' + CONF.author);\n\tconsole.log('Date          : ' + NOW.format('yyyy-MM-dd HH:mm:ss'));\n\tconsole.log('Mode          : ' + (DEBUG ? 'debug' : 'release'));\n\tconsole.log('====================================================');\n\tconsole.log('Directory     : ' + process.cwd());\n\tconsole.log('node_modules  : ' + PATHMODULES);\n\tconsole.log('====================================================\\n');\n\tif (!F.isWorker) {\n\t\tconsole.log('{2}://{0}:{1}/'.format(F.ip, F.port, F.isHTTPS ? 'https' : 'http'));\n\t\tconsole.log('');\n\t}\n};\n\nF.usagesnapshot = function(filename) {\n\tFs.writeFile(filename || F.path.root('usage' + (F.id ? ('-' + F.id) : '') + '.log'), JSON.stringify(F.usage(true), null, '    '), NOOP);\n\treturn F;\n};\n\nF.consoledebug = function() {\n\n\tif (!CONF.allow_debug)\n\t\treturn F;\n\n\tvar arr = [new Date().format('yyyy-MM-dd HH:mm:ss'), '--------->'];\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tarr.push(arguments[i]);\n\tconsole.log.apply(console, arr);\n\treturn F;\n};\n\n/**\n * Re-connect server\n * @return {Framework}\n */\nF.reconnect = function() {\n\tif (CONF.default_port !== undefined)\n\t\tF.port = CONF.default_port;\n\tif (CONF.default_ip !== undefined)\n\t\tF.ip = CONF.default_ip;\n\tF.server.close(() => F.server.listen(F.port, F.ip));\n\treturn F;\n};\n\n/**\n * Internal service\n * @private\n * @param {Number} count Run count.\n * @return {Framework}\n */\nF.service = function(count) {\n\n\tUIDGENERATOR_REFRESH();\n\n\tvar keys;\n\tvar releasegc = false;\n\n\tif (F.temporary.service.request)\n\t\tF.temporary.service.request++;\n\telse\n\t\tF.temporary.service.request = 1;\n\n\tif (F.temporary.service.file)\n\t\tF.temporary.service.file++;\n\telse\n\t\tF.temporary.service.file = 1;\n\n\tF.stats.performance.request = F.stats.request.request ? F.stats.request.request / F.temporary.service.request : 0;\n\tF.stats.performance.file = F.stats.request.file ? F.stats.request.file / F.temporary.service.file : 0;\n\n\t// clears temporary memory for non-exist files\n\tF.temporary.notfound = {};\n\n\t// every 7 minutes (default) service clears static cache\n\tif (count % CONF.default_interval_clear_cache === 0) {\n\t\tF.$events.clear && EMIT('clear', 'temporary', F.temporary);\n\t\tF.temporary.path = {};\n\t\tF.temporary.range = {};\n\t\tF.temporary.views = {};\n\t\tF.temporary.other = {};\n\t\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\n\t\t// Clears command cache\n\t\tImage.clear();\n\n\t\tvar dt = NOW.add('-5 minutes');\n\t\tfor (var key in F.databases)\n\t\t\tF.databases[key] && F.databases[key].inmemorylastusage < dt && F.databases[key].release();\n\n\t\treleasegc = true;\n\t\tCONF.allow_debug && F.consoledebug('clear temporary cache');\n\n\t\tkeys = Object.keys(F.temporary.internal);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tif (!F.temporary.internal[keys[i]])\n\t\t\t\tdelete F.temporary.internal[keys[i]];\n\t}\n\n\t// every 61 minutes (default) services precompile all (installed) views\n\tif (count % CONF.default_interval_precompile_views === 0) {\n\t\tfor (var key in F.routes.views) {\n\t\t\tvar item = F.routes.views[key];\n\t\t\tF.install('view', key, item.url, null);\n\t\t}\n\t}\n\n\tif (count % CONF.default_interval_clear_dnscache === 0) {\n\t\tF.$events.clear && EMIT('clear', 'dns');\n\t\tU.clearDNS();\n\t\tCONF.allow_debug && F.consoledebug('clear DNS cache');\n\t}\n\n\tvar ping = CONF.default_interval_websocket_ping;\n\tif (ping > 0 && count % ping === 0) {\n\t\tvar has = false;\n\t\tfor (var item in F.connections) {\n\t\t\tvar conn = F.connections[item];\n\t\t\tif (conn) {\n\t\t\t\tconn.check();\n\t\t\t\tconn.ping();\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\thas && CONF.allow_debug && F.consoledebug('ping websocket connections');\n\t}\n\n\tif (F.uptodates && (count % CONF.default_interval_uptodate === 0) && F.uptodates.length) {\n\t\tvar hasUpdate = false;\n\t\tF.uptodates.wait(function(item, next) {\n\n\t\t\tif (item.updated.add(item.interval) > NOW)\n\t\t\t\treturn next();\n\n\t\t\titem.updated = NOW;\n\t\t\titem.count++;\n\n\t\t\tsetTimeout(function() {\n\t\t\t\tCONF.allow_debug && F.consoledebug('uptodate', item.type + '#' + item.url);\n\t\t\t\tF.install(item.type, item.url, item.options, function(err, name, skip) {\n\n\t\t\t\t\tCONF.allow_debug && F.consoledebug('uptodate', item.type + '#' + item.url + ' (done)');\n\n\t\t\t\t\tif (skip)\n\t\t\t\t\t\treturn next();\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\titem.errors.push(err);\n\t\t\t\t\t\titem.errors.length > 50 && F.errors.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thasUpdate = true;\n\t\t\t\t\t\titem.name = name;\n\t\t\t\t\t\tF.$events.uptodate && EMIT('uptodate', item.type, name);\n\t\t\t\t\t}\n\n\t\t\t\t\titem.callback && item.callback(err, name);\n\t\t\t\t\tnext();\n\n\t\t\t\t}, undefined, undefined, undefined, undefined, item.name);\n\n\t\t\t}, item.name ? 500 : 1);\n\n\t\t}, function() {\n\t\t\tif (hasUpdate) {\n\t\t\t\tF.temporary.path = {};\n\t\t\t\tF.temporary.range = {};\n\t\t\t\tF.temporary.views = {};\n\t\t\t\tF.temporary.other = {};\n\t\t\t\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\t\t\t}\n\t\t});\n\t}\n\n\t// every 20 minutes (default) service clears resources\n\tif (count % CONF.default_interval_clear_resources === 0) {\n\t\tF.$events.clear && EMIT('clear', 'resources');\n\t\tF.resources = {};\n\t\treleasegc = true;\n\t\tCONF.allow_debug && F.consoledebug('clear resources');\n\t}\n\n\t// Update expires date\n\tcount % 1000 === 0 && (DATE_EXPIRES = NOW.add('y', 1).toUTCString());\n\n\tif (count % CONF.nosql_cleaner === 0 && CONF.nosql_cleaner) {\n\t\tkeys = Object.keys(F.databasescleaner);\n\t\tkeys.wait(function(item, next) {\n\t\t\tif (item[0] === '$')\n\t\t\t\tTABLE(item.substring(1)).clean(next);\n\t\t\telse\n\t\t\t\tNOSQL(item).clean(next);\n\t\t});\n\t}\n\n\tF.$events.service && EMIT('service', count);\n\n\tif (CONF.allow_debug) {\n\t\tF.consoledebug('service ({0}x)'.format(count));\n\t\tF.usagesnapshot();\n\t}\n\n\treleasegc && global.gc && setTimeout(function() {\n\t\tglobal.gc();\n\t\tCONF.allow_debug && F.consoledebug('gc()');\n\t}, 1000);\n\n\tif (WORKERID > 9999999999)\n\t\tWORKERID = 0;\n\n\t// Run schedules\n\tif (!F.schedules.length)\n\t\treturn F;\n\n\tvar expire = NOW.getTime();\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar schedule = F.schedules[index++];\n\t\tif (!schedule)\n\t\t\tbreak;\n\t\tif (schedule.expire > expire)\n\t\t\tcontinue;\n\n\t\tindex--;\n\n\t\tif (schedule.repeat)\n\t\t\tschedule.expire = NOW.add(schedule.repeat);\n\t\telse\n\t\t\tF.schedules.splice(index, 1);\n\n\t\tCONF.allow_debug && F.consoledebug('schedule', schedule.id);\n\t\tschedule.fn.call(F);\n\t}\n\n\treturn F;\n};\n\n/**\n * Request processing\n * @private\n * @param {Request} req\n * @param {Response} res\n */\nF.listener = function(req, res) {\n\n\treq.options = res.options = {};\n\tres.req = req;\n\treq.res = res;\n\n\tif (F._length_wait)\n\t\treturn F.response503(req, res);\n\telse if (!req.host) // HTTP 1.0 without host\n\t\treturn res.throw400();\n\n\tvar headers = req.headers;\n\treq.$protocol = ((req.connection && req.connection.encrypted) || ((headers['x-forwarded-proto'] || ['x-forwarded-protocol']) === 'https')) ? 'https' : 'http';\n\n\treq.url = req.url.replace(REG_TRAVEL, '');\n\treq.uri = framework_internal.parseURI(req);\n\n\tF.stats.request.request++;\n\tF.$events.request && EMIT('request', req, res);\n\n\tif (F._request_check_redirect) {\n\t\tvar redirect = F.routes.redirects[req.$protocol + '://' + req.host];\n\t\tif (redirect) {\n\t\t\tF.stats.response.forward++;\n\t\t\tres.options.url = redirect.url + (redirect.path ? req.url : '');\n\t\t\tres.options.permanent = redirect.permanent;\n\t\t\tres.$redirect();\n\t\t\treturn;\n\t\t}\n\t}\n\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\treq.processing = 0;\n\treq.isAuthorized = true;\n\treq.xhr = headers['x-requested-with'] === 'XMLHttpRequest';\n\tres.success = false;\n\treq.user = req.session = null;\n\treq.isStaticFile = CONF.allow_static_files && U.isStaticFile(req.uri.pathname);\n\n\tif (req.isStaticFile)\n\t\treq.extension = U.getExtension(req.uri.pathname);\n\telse if (F.onLocale)\n\t\treq.$language = F.onLocale(req, res, req.isStaticFile);\n\n\tF.reqstats(true, true);\n\n\tif (F._length_request_middleware)\n\t\tasync_middleware(0, req, res, F.routes.request, requestcontinue_middleware);\n\telse\n\t\tF.$requestcontinue(req, res, headers);\n};\n\nfunction requestcontinue_middleware(req, res)  {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\tF.$requestcontinue(req, res, req.headers);\n}\n\n/**\n * Continue to process\n * @private\n * @param {Request} req\n * @param {Response} res\n * @param {Object} headers\n * @param {String} protocol [description]\n * @return {Framework}\n */\nF.$requestcontinue = function(req, res, headers) {\n\n\tif (!req || !res || res.headersSent || res.success)\n\t\treturn;\n\n\t// Validates if this request is the file (static file)\n\tif (req.isStaticFile) {\n\t\tF.stats.request.file++;\n\t\tif (F._length_files)\n\t\t\treq.$total_file();\n\t\telse\n\t\t\tres.continue();\n\t\treturn;\n\t}\n\n\tif (!PERF[req.method]) {\n\t\treq.$total_status(404);\n\t\treturn;\n\t}\n\n\tF.stats.request.web++;\n\n\treq.body = EMPTYOBJECT;\n\treq.files = EMPTYARRAY;\n\treq.buffer_exceeded = false;\n\treq.buffer_has = false;\n\treq.$flags = req.method[0] + req.method[1];\n\n\tvar flags = [req.method.toLowerCase()];\n\tvar multipart;\n\n\tif (F._request_check_mobile && req.mobile) {\n\t\treq.$flags += 'a';\n\t\tF.stats.request.mobile++;\n\t} else\n\t\tF.stats.request.desktop++;\n\n\treq.$protocol[5] && (req.$flags += req.$protocol[5]);\n\treq.$type = 0;\n\tflags.push(req.$protocol);\n\n\tvar method = req.method;\n\tvar first = method[0];\n\n\tif (first === 'P' || first === 'D') {\n\t\tmultipart = req.headers['content-type'] || '';\n\t\treq.buffer_data = U.createBuffer();\n\t\tvar index = multipart.lastIndexOf(';');\n\t\tvar tmp = multipart;\n\t\tif (index !== -1)\n\t\t\ttmp = tmp.substring(0, index);\n\t\tswitch (tmp.substring(tmp.length - 4)) {\n\t\t\tcase 'json':\n\t\t\t\treq.$flags += 'b';\n\t\t\t\tflags.push('json');\n\t\t\t\treq.$type = 1;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tcase 'oded':\n\t\t\t\treq.$type = 3;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\treq.$flags += 'c';\n\t\t\t\treq.$upload = true;\n\t\t\t\tflags.push('upload');\n\t\t\t\tbreak;\n\t\t\tcase '/xml':\n\t\t\t\treq.$flags += 'd';\n\t\t\t\tflags.push('xml');\n\t\t\t\treq.$type = 2;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (multipart) {\n\t\t\t\t\t// 'undefined' DATA\n\t\t\t\t\tmultipart = '';\n\t\t\t\t\tflags.push('raw');\n\t\t\t\t} else {\n\t\t\t\t\treq.$type = 3;\n\t\t\t\t\tmultipart = '';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (headers.accept === 'text/event-stream') {\n\t\treq.$flags += 'g';\n\t\tflags.push('sse');\n\t}\n\n\tif (DEBUG) {\n\t\treq.$flags += 'h';\n\t\tflags.push('debug');\n\t}\n\n\tif (req.xhr) {\n\t\tF.stats.request.xhr++;\n\t\treq.$flags += 'i';\n\t\tflags.push('xhr');\n\t}\n\n\tif (F._request_check_robot && req.robot)\n\t\treq.$flags += 'j';\n\n\tif (F._request_check_referer) {\n\t\tvar referer = headers['referer'];\n\t\tif (referer && referer.indexOf(headers['host']) !== -1) {\n\t\t\treq.$flags += 'k';\n\t\t\tflags.push('referer');\n\t\t}\n\t}\n\n\treq.flags = flags;\n\tF.$events['request-begin'] && EMIT('request-begin', req, res);\n\n\tvar isCORS = (F._length_cors || F.routes.corsall) && req.headers.origin != null;\n\n\tswitch (first) {\n\t\tcase 'G':\n\t\t\tF.stats.request.get++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'O':\n\t\t\tF.stats.request.options++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'H':\n\t\t\tF.stats.request.head++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'D':\n\t\t\tF.stats.request['delete']++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback1);\n\t\t\telse\n\t\t\t\treq.$total_urlencoded();\n\t\t\treturn;\n\n\t\tcase 'P':\n\t\t\tif (F._request_check_POST) {\n\t\t\t\tif (multipart) {\n\t\t\t\t\tif (isCORS)\n\t\t\t\t\t\tF.$cors(req, res, cors_callback_multipart, multipart);\n\t\t\t\t\telse\n\t\t\t\t\t\treq.$total_multipart(multipart);\n\t\t\t\t} else {\n\t\t\t\t\tif (method === 'PUT')\n\t\t\t\t\t\tF.stats.request.put++;\n\t\t\t\t\telse if (method === 'PATCH')\n\t\t\t\t\t\tF.stats.request.path++;\n\t\t\t\t\telse\n\t\t\t\t\t\tF.stats.request.post++;\n\t\t\t\t\tif (isCORS)\n\t\t\t\t\t\tF.$cors(req, res, cors_callback1);\n\t\t\t\t\telse\n\t\t\t\t\t\treq.$total_urlencoded();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treq.$total_status(404);\n};\n\nfunction cors_callback0(req) {\n\treq.$total_end();\n}\n\nfunction cors_callback1(req) {\n\treq.$total_urlencoded();\n}\n\nfunction cors_callback_multipart(req, res, multipart) {\n\treq.$total_multipart(multipart);\n}\n\nF.$cors = function(req, res, fn, arg) {\n\n\tvar isAllowed = F.routes.corsall;\n\tvar cors, origin;\n\tvar headers = req.headers;\n\tvar key;\n\n\tif (!isAllowed) {\n\n\t\tfor (var i = 0; i < F._length_cors; i++) {\n\t\t\tcors = F.routes.cors[i];\n\t\t\tif (framework_internal.routeCompare(req.path, cors.url, false, cors.isWILDCARD)) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!isAllowed)\n\t\t\treturn fn(req, res, arg);\n\n\t\tvar stop = false;\n\n\t\tkey = 'cors' + cors.hash + '_' + headers.origin;\n\n\t\tif (F.temporary.other[key]) {\n\t\t\tstop = F.temporary.other[key] === 2;\n\t\t} else {\n\n\t\t\tisAllowed = false;\n\n\t\t\tif (cors.headers) {\n\t\t\t\tisAllowed = false;\n\t\t\t\tfor (var i = 0, length = cors.headers.length; i < length; i++) {\n\t\t\t\t\tif (headers[cors.headers[i]]) {\n\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isAllowed)\n\t\t\t\t\tstop = true;\n\t\t\t}\n\n\t\t\tif (!stop && cors.methods) {\n\t\t\t\tisAllowed = false;\n\t\t\t\tvar current = headers['access-control-request-method'] || req.method;\n\t\t\t\tif (current !== 'OPTIONS') {\n\t\t\t\t\tfor (var i = 0, length = cors.methods.length; i < length; i++) {\n\t\t\t\t\t\tif (current === cors.methods[i]) {\n\t\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!isAllowed)\n\t\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!stop && cors.origin) {\n\t\t\t\torigin = headers.origin.toLowerCase().substring(headers.origin.indexOf('/') + 2);\n\t\t\t\tif (origin !== headers.host) {\n\t\t\t\t\tisAllowed = false;\n\t\t\t\t\tfor (var i = 0, length = cors.origin.length; i < length; i++) {\n\t\t\t\t\t\tif (cors.origin[i].indexOf(origin) !== -1) {\n\t\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!isAllowed)\n\t\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tF.temporary.other[key] = stop ? 2 : 1;\n\t\t}\n\t} else if (CONF.default_cors) {\n\t\tkey = headers.origin;\n\t\tif (F.temporary.other[key]) {\n\t\t\tstop = F.temporary.other[key] === 2;\n\t\t} else {\n\t\t\torigin = key.toLowerCase().substring(key.indexOf('/') + 2);\n\t\t\tstop = origin !== headers.host && CONF.default_cors.indexOf(origin) === -1;\n\t\t\tF.temporary.other[key] = stop ? 2 : 1;\n\t\t}\n\t}\n\n\tif (stop)\n\t\torigin = 'null';\n\telse\n\t\torigin = headers.origin;\n\n\tres.setHeader('Access-Control-Allow-Origin', origin);\n\n\tif (!cors || cors.credentials)\n\t\tres.setHeader('Access-Control-Allow-Credentials', 'true');\n\n\tvar name = 'Access-Control-Allow-Methods';\n\tvar isOPTIONS = req.method === 'OPTIONS';\n\n\tif (cors && cors.methods)\n\t\tres.setHeader(name, cors.methods.join(', '));\n\telse\n\t\tres.setHeader(name, isOPTIONS ? headers['access-control-request-method'] || '*' : req.method);\n\n\tname = 'Access-Control-Allow-Headers';\n\n\tif (cors && cors.headers)\n\t\tres.setHeader(name, cors.headers.join(', '));\n\telse\n\t\tres.setHeader(name, headers['access-control-request-headers'] || '*');\n\n\tcors && cors.age && res.setHeader('Access-Control-Max-Age', cors.age);\n\n\tif (stop) {\n\t\tfn = null;\n\t\tF.$events['request-end'] && EMIT('request-end', req, res);\n\t\tF.reqstats(false, false);\n\t\tF.stats.request.blocked++;\n\t\tres.writeHead(404);\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tif (!isOPTIONS)\n\t\treturn fn(req, res, arg);\n\n\tfn = null;\n\tF.$events['request-end'] && EMIT('request-end', req, res);\n\tF.reqstats(false, false);\n\tres.writeHead(200);\n\tres.end();\n\treturn F;\n};\n\n/**\n * Upgrade HTTP (WebSocket)\n * @param {HttpRequest} req\n * @param {Socket} socket\n * @param {Buffer} head\n */\nF.$upgrade = function(req, socket, head) {\n\n\tif ((req.headers.upgrade || '').toLowerCase() !== 'websocket' || F._length_wait)\n\t\treturn;\n\n\t// disables timeout\n\tsocket.setTimeout(0);\n\tsocket.on('error', NOOP);\n\n\tvar headers = req.headers;\n\treq.$protocol = req.connection.encrypted || headers['x-forwarded-protocol'] === 'https' ? 'https' : 'http';\n\n\treq.uri = framework_internal.parseURI(req);\n\n\tF.$events.websocket && EMIT('websocket', req, socket, head);\n\tF.stats.request.websocket++;\n\n\treq.session = null;\n\treq.user = null;\n\treq.flags = [req.secured ? 'https' : 'http', 'get'];\n\n\treq.$wspath = U.path(req.uri.pathname);\n\tvar websocket = new WebSocketClient(req, socket, head);\n\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\treq.websocket = websocket;\n\n\tif (F.onLocale)\n\t\treq.$language = F.onLocale(req, socket);\n\n\tif (F._length_request_middleware)\n\t\tasync_middleware(0, req, req.websocket, F.routes.request, websocketcontinue_middleware);\n\telse\n\t\tF.$websocketcontinue(req, req.$wspath, headers);\n};\n\nfunction websocketcontinue_middleware(req) {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\tF.$websocketcontinue(req, req.$wspath, req.headers);\n}\n\nF.$websocketcontinue = function(req, path) {\n\tvar auth = F.onAuthorize;\n\tif (auth) {\n\t\tauth.call(F, req, req.websocket, req.flags, function(isLogged, user) {\n\t\t\tif (user)\n\t\t\t\treq.user = user;\n\t\t\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, isLogged ? 1 : 2);\n\t\t\tif (route) {\n\t\t\t\tF.$websocketcontinue_process(route, req, path);\n\t\t\t} else\n\t\t\t\treq.websocket.$close(4001, '401: unauthorized');\n\t\t});\n\t} else {\n\t\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, 0);\n\t\tif (route) {\n\t\t\tF.$websocketcontinue_process(route, req, path);\n\t\t} else\n\t\t\treq.websocket.$close(4004, '404: not found');\n\t}\n};\n\nF.$websocketcontinue_process = function(route, req, path) {\n\n\tvar socket = req.websocket;\n\n\tif (!socket.prepare(route.flags, route.protocols, route.allow, route.length)) {\n\t\tsocket.$close(4001, '401: unauthorized');\n\t\treturn;\n\t}\n\n\tvar id = path + (route.flags.length ? '#' + route.flags.join('-') : '');\n\n\tif (route.isBINARY)\n\t\tsocket.type = 1;\n\telse if (route.isJSON)\n\t\tsocket.type = 3;\n\n\tvar next = function() {\n\n\t\tif (req.$total_middleware)\n\t\t\treq.$total_middleware = null;\n\n\t\tif (F.connections[id]) {\n\t\t\tsocket.upgrade(F.connections[id]);\n\t\t\treturn;\n\t\t}\n\n\t\tvar connection = new WebSocket(path, route.controller, id);\n\t\tconnection.route = route;\n\t\tconnection.options = route.options;\n\t\tF.connections[id] = connection;\n\t\troute.onInitialize.apply(connection, framework_internal.routeParam(route.param.length ? req.split : req.path, route));\n\t\tsetImmediate(next_upgrade_continue, socket, connection);\n\t};\n\n\tif (route.middleware)\n\t\tasync_middleware(0, req, req.websocket, route.middleware, next, route.options);\n\telse\n\t\tnext();\n};\n\nfunction next_upgrade_continue(socket, connection) {\n\tsocket.upgrade(connection);\n}\n\n/**\n * Request statistics writer\n * @private\n * @param {Boolean} beg\n * @param {Boolean} isStaticFile\n * @return {Framework}\n */\nF.reqstats = function(beg) {\n\n\tif (beg)\n\t\tF.stats.request.pending++;\n\telse\n\t\tF.stats.request.pending--;\n\n\tif (F.stats.request.pending < 0)\n\t\tF.stats.request.pending = 0;\n\n\treturn F;\n};\n\n/**\n * Get a model\n * @param {String} name\n * @return {Object}\n */\nglobal.MODEL = F.model = function(name) {\n\tvar obj = F.models[name];\n\tif (obj || obj === null)\n\t\treturn obj;\n\tvar filename = U.combine(CONF.directory_models, name + '.js');\n\texistsSync(filename) && F.install('model', name, filename, undefined, undefined, undefined, true);\n\treturn F.models[name] || null;\n};\n\n/**\n * Load a source code\n * @param {String} name\n * @param {Object} options Custom initial options, optional.\n * @return {Object}\n */\nglobal.INCLUDE = global.SOURCE = F.source = function(name, options, callback) {\n\tvar obj = F.sources[name];\n\tif (obj || obj === null)\n\t\treturn obj;\n\tvar filename = U.combine(CONF.directory_source, name + '.js');\n\texistsSync(filename) && F.install('source', name, filename, options, callback, undefined, true);\n\treturn F.sources[name] || null;\n};\n\n/**\n * Load a source code (alias for F.source())\n * @param {String} name\n * @param {Object} options Custom initial options, optional.\n * @return {Object}\n */\nF.include = function(name, options, callback) {\n\treturn F.source(name, options, callback);\n};\n\n/**\n * Send e-mail\n * @param {String or Array} address E-mail address.\n * @param {String} subject E-mail subject.\n * @param {String} view View name.\n * @param {Object} model Optional.\n * @param {Function(err)} callback Optional.\n * @param {String} language Optional.\n * @return {MailMessage}\n */\nglobal.MAIL = F.mail = function(address, subject, view, model, callback, language) {\n\n\tif (typeof(callback) === 'string') {\n\t\tvar tmp = language;\n\t\tlanguage = callback;\n\t\tcallback = tmp;\n\t}\n\n\tvar controller = EMPTYCONTROLLER;\n\tcontroller.layoutName = '';\n\tcontroller.themeName = U.parseTheme(view);\n\n\tif (controller.themeName)\n\t\tview = prepare_viewname(view);\n\telse if (F.onTheme)\n\t\tcontroller.themeName = F.onTheme(controller);\n\telse\n\t\tcontroller.themeName = '';\n\n\tvar replyTo;\n\n\t// Translation\n\tif (typeof(language) === 'string') {\n\t\tsubject = subject.indexOf('@(') === -1 ? F.translate(language, subject) : F.translator(language, subject);\n\t\tcontroller.language = language;\n\t}\n\n\treturn controller.mail(address, subject, view, model, callback, replyTo);\n};\n\n/**\n * Renders view\n * @param {String} name View name.\n * @param {Object} model Model.\n * @param {String} layout Layout for the view, optional. Default without layout.\n * @param {Object} repository A repository object, optional. Default empty.\n * @param {String} language Optional.\n * @return {String}\n */\nglobal.VIEW = F.view = function(name, model, layout, repository, language) {\n\n\tvar controller = EMPTYCONTROLLER;\n\n\tif (typeof(layout) === 'object') {\n\t\tvar tmp = repository;\n\t\trepository = layout;\n\t\tlayout = tmp;\n\t}\n\n\tcontroller.layoutName = layout || '';\n\tcontroller.language = language || '';\n\tcontroller.repository = typeof(repository) === 'object' && repository ? repository : EMPTYOBJECT;\n\n\tvar theme = U.parseTheme(name);\n\tif (theme) {\n\t\tcontroller.themeName = theme;\n\t\tname = prepare_viewname(name);\n\t} else if (F.onTheme)\n\t\tcontroller.themeName = F.onTheme(controller);\n\telse\n\t\tcontroller.themeName = undefined;\n\n\treturn controller.view(name, model, true);\n};\n\n/**\n * Compiles and renders view\n * @param {String} body HTML body.\n * @param {Object} model Model.\n * @param {String} layout Layout for the view, optional. Default without layout.\n * @param {Object} repository A repository object, optional. Default empty.\n * @param {String} language Optional.\n * @return {String}\n */\nF.viewCompile = function(body, model, layout, repository, language) {\n\n\tvar controller = EMPTYCONTROLLER;\n\n\tif (typeof(layout) === 'object') {\n\t\tvar tmp = repository;\n\t\trepository = layout;\n\t\tlayout = tmp;\n\t}\n\n\tcontroller.layoutName = layout || '';\n\tcontroller.language = language || '';\n\tcontroller.themeName = undefined;\n\tcontroller.repository = typeof(repository) === 'object' && repository ? repository : EMPTYOBJECT;\n\n\treturn controller.viewCompile(body, model, true);\n};\n\n/**\n * Load tests\n * @private\n * @param {Boolean} stop Stop framework after end.\n * @param {String Array} names Test names, optional.\n * @param {Function()} cb\n * @return {Framework}\n */\nF.test = function() {\n\tF.isTest = true;\n\tF.$configure_configs('config-test', true);\n\trequire('./test').load();\n\treturn F;\n};\n\n/**\n * Clear temporary directory\n * @param {Function} callback\n * @param {Boolean} isInit Private argument.\n * @return {Framework}\n */\nF.clear = function(callback, isInit) {\n\n\tvar dir = F.path.temp();\n\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\n\tif (isInit) {\n\t\tif (!CONF.allow_clear_temp) {\n\t\t\tif (F.$bundling) {\n\t\t\t\t// clears only JS and CSS files\n\t\t\t\tU.ls(dir, function(files) {\n\t\t\t\t\tF.unlink(files, function() {\n\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t});\n\t\t\t\t}, function(filename, folder) {\n\t\t\t\t\tif (folder || (plus && !filename.substring(dir.length).startsWith(plus)))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (filename.indexOf('.package') !== -1)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tvar ext = U.getExtension(filename);\n\t\t\t\t\treturn ext === 'js' || ext === 'css' || ext === 'tmp' || ext === 'upload' || ext === 'html' || ext === 'htm';\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn F;\n\t\t}\n\t}\n\n\tif (!existsSync(dir) || !F.$bundling) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tU.ls(dir, function(files, directories) {\n\n\t\tif (isInit) {\n\t\t\tvar arr = [];\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\t\tvar filename = files[i].substring(dir.length);\n\t\t\t\tif (plus && !filename.startsWith(plus))\n\t\t\t\t\tcontinue;\n\t\t\t\t(filename.indexOf('/') === -1 || filename.indexOf('.package/') !== -1) && !filename.endsWith('.jsoncache') && arr.push(files[i]);\n\t\t\t}\n\n\t\t\tfiles = arr;\n\t\t\tdirectories = directories.remove(function(name) {\n\t\t\t\tname = U.getName(name);\n\n\t\t\t\tif (name[0] === '~')\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (name.endsWith('.package'))\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tF.unlink(files, () => F.rmdir(directories, callback));\n\t});\n\n\tif (!isInit) {\n\t\t// clear static cache\n\t\tF.temporary.path = {};\n\t\tF.temporary.range = {};\n\t\tF.temporary.notfound = {};\n\t}\n\n\treturn F;\n};\n\n/**\n * Remove files in array\n * @param {String Array} arr File list.\n * @param {Function} callback\n * @return {Framework}\n */\nF.unlink = F.path.unlink = function(arr, callback) {\n\n\tif (typeof(arr) === 'string')\n\t\tarr = [arr];\n\n\tif (!arr.length) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tvar filename = arr.shift();\n\tif (filename)\n\t\tFs.unlink(filename, () => F.unlink(arr, callback));\n\telse\n\t\tcallback && callback();\n\n\treturn F;\n};\n\n/**\n * Remove directories in array\n * @param {String Array} arr\n * @param {Function} callback\n * @return {Framework}\n */\nF.rmdir = F.path.rmdir = function(arr, callback) {\n\tif (typeof(arr) === 'string')\n\t\tarr = [arr];\n\n\tif (!arr.length) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tvar path = arr.shift();\n\tif (path) {\n\t\tU.ls(path, function(files, directories) {\n\t\t\tdirectories.reverse();\n\t\t\tdirectories.push(path);\n\t\t\tfiles.wait((item, next) => Fs.unlink(item, next), function() {\n\t\t\t\tdirectories.wait(function(item, next) {\n\t\t\t\t\tFs.rmdir(item, next);\n\t\t\t\t}, () => F.rmdir(arr, callback));\n\t\t\t});\n\t\t});\n\t} else\n\t\tcallback && callback();\n\n\treturn F;\n};\n\n/**\n * Cryptography (encrypt)\n * @param {String} value\n * @param {String} key Encrypt key.\n * @param {Boolean} isUnique Optional, default true.\n * @return {String}\n */\nF.encrypt = function(value, key, isUnique) {\n\n\tif (value === undefined)\n\t\treturn '';\n\n\tvar type = typeof(value);\n\n\tif (typeof(key) === 'boolean') {\n\t\tvar tmp = isUnique;\n\t\tisUnique = key;\n\t\tkey = tmp;\n\t}\n\n\tif (type === 'function')\n\t\tvalue = value();\n\telse if (type === 'number')\n\t\tvalue = value.toString();\n\telse if (type === 'object')\n\t\tvalue = JSON.stringify(value);\n\n\treturn value.encrypt(CONF.secret + '=' + key, isUnique);\n};\n\n/**\n * Cryptography (decrypt)\n * @param {String} value\n * @param {String} key Decrypt key.\n * @param {Boolean} jsonConvert Optional, default true.\n * @return {Object or String}\n */\nF.decrypt = function(value, key, jsonConvert) {\n\n\tif (typeof(key) === 'boolean') {\n\t\tvar tmp = jsonConvert;\n\t\tjsonConvert = key;\n\t\tkey = tmp;\n\t}\n\n\tif (typeof(jsonConvert) !== 'boolean')\n\t\tjsonConvert = true;\n\n\tvar response = (value || '').decrypt(CONF.secret + '=' + key);\n\treturn response ? (jsonConvert ? (response.isJSON() ? response.parseJSON(true) : null) : response) : null;\n};\n\n/**\n * Create hash\n * @param {String} type Type (md5, sha1, sha256, etc.)\n * @param {String} value\n * @param {String} salt Optional, default false.\n * @return {String}\n */\nF.hash = function(type, value, salt) {\n\tvar hash = Crypto.createHash(type);\n\tvar plus = '';\n\n\tif (typeof(salt) === 'string')\n\t\tplus = salt;\n\telse if (salt !== false)\n\t\tplus = (CONF.secret || '');\n\n\thash.update(value.toString() + plus, ENCODING);\n\treturn hash.digest('hex');\n};\n\n/**\n * Resource reader\n * @param {String} name Optional, resource file name. Default: \"default\".\n * @param {String} key Resource key.\n * @return {String} String\n */\nF.resource = function(name, key) {\n\n\tif (!key) {\n\t\tkey = name;\n\t\tname = null;\n\t}\n\n\tif (!name)\n\t\tname = 'default';\n\n\tvar res = F.resources[name];\n\tif (res)\n\t\treturn res[key] == null ? '' : res[key];\n\n\tvar routes = F.routes.resources[name];\n\tvar body = '';\n\tvar filename;\n\tif (routes) {\n\t\tfor (var i = 0, length = routes.length; i < length; i++) {\n\t\t\tfilename = routes[i];\n\t\t\tif (existsSync(filename))\n\t\t\t\tbody += (body ? '\\n' : '') + Fs.readFileSync(filename).toString(ENCODING);\n\t\t}\n\t}\n\n\tvar filename = U.combine(CONF.directory_resources, name + '.resource');\n\tvar empty = false;\n\tif (existsSync(filename))\n\t\tbody += (body ? '\\n' : '') + Fs.readFileSync(filename).toString(ENCODING);\n\telse\n\t\tempty = true;\n\n\tvar obj = body.parseConfig();\n\tF.resources[name] = obj;\n\tobj.$empty = empty;\n\treturn obj[key] == null ? '' : obj[key];\n};\n\n/**\n * Translates text\n * @param {String} language A resource filename, optional.\n * @param {String} text\n * @return {String}\n */\nF.translate = function(language, text) {\n\n\tif (!text) {\n\t\ttext = language;\n\t\tlanguage = undefined;\n\t}\n\n\tif (text[0] === '#' && text[1] !== ' ')\n\t\treturn F.resource(language, text.substring(1));\n\n\tvar value = F.resource(language, 'T' + text.hash());\n\treturn value ? value : text;\n};\n\n/**\n * The translator for the text from the View Engine @(TEXT TO TRANSLATE)\n * @param {String} language A resource filename, optional.\n * @param {String} text\n * @return {String}\n */\nF.translator = function(language, text) {\n\treturn framework_internal.parseLocalization(text, language);\n};\n\nF.$configure_sitemap = function(arr, clean) {\n\n\tif (!arr || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'sitemap');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tif (clean || !F.routes.sitemap)\n\t\tF.routes.sitemap = {};\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(' :');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar val = str.substring(index + 2).trim();\n\t\tvar a = val.split('-->');\n\t\tvar url = a[1].trim();\n\t\tvar wildcard = false;\n\n\t\tif (url.endsWith('*')) {\n\t\t\twildcard = true;\n\t\t\turl = url.substring(0, url.length - 1);\n\t\t} else if (url.endsWith('*)')) {\n\t\t\t// localization\n\t\t\twildcard = true;\n\t\t\turl = url.substring(0, url.length - 2);\n\t\t}\n\n\t\tvar name = a[0].trim();\n\t\tvar localizeName = name.startsWith('@(');\n\t\tvar localizeUrl = url.startsWith('@(');\n\n\t\tif (localizeName)\n\t\t\tname = name.substring(2, name.length - 1).trim();\n\n\t\tif (localizeUrl)\n\t\t\turl = url.substring(2, url.length - 1).trim();\n\n\t\tF.routes.sitemap[key] = { name: name, url: url, parent: a[2] ? a[2].trim() : null, wildcard: wildcard, formatName: name.indexOf('{') !== -1, formatUrl: url.indexOf('{') !== -1, localizeName: localizeName, localizeUrl: localizeUrl };\n\t}\n\n\treturn F;\n};\n\nF.sitemap = function(name, me, language) {\n\n\tif (!F.routes.sitemap)\n\t\treturn me ? null : EMPTYARRAY;\n\n\tif (typeof(me) === 'string') {\n\t\tlanguage = me;\n\t\tme = false;\n\t}\n\n\tvar key = REPOSITORY_SITEMAP + name + '$' + (me ? '1' : '0') + '$' + (language || '');\n\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tvar sitemap;\n\tvar id = name;\n\tvar url;\n\tvar title;\n\n\tif (me === true) {\n\t\tsitemap = F.routes.sitemap[name];\n\t\tvar item = { sitemap: id, id: '', name: '', url: '', last: true, selected: true, index: 0, wildcard: false, formatName: false, formatUrl: false };\n\t\tif (!sitemap)\n\t\t\treturn item;\n\n\t\ttitle = sitemap.name;\n\t\tif (sitemap.localizeName)\n\t\t\ttitle = F.translate(language, title);\n\n\t\turl = sitemap.url;\n\t\tvar wildcard = sitemap.wildcard;\n\n\t\tif (sitemap.localizeUrl) {\n\t\t\tif (sitemap.wildcard) {\n\t\t\t\tif (url[url.length - 1] !== '/')\n\t\t\t\t\turl += '/';\n\t\t\t\turl += '*';\n\t\t\t}\n\n\t\t\turl = F.translate(language, url);\n\n\t\t\tif (url.endsWith('*')) {\n\t\t\t\turl = url.substring(0, url.length - 1);\n\t\t\t\twildcard = true;\n\t\t\t} else\n\t\t\t\twildcard = false;\n\t\t}\n\n\t\titem.sitemap = id;\n\t\titem.id = name;\n\t\titem.formatName = sitemap.formatName;\n\t\titem.formatUrl = sitemap.formatUrl;\n\t\titem.localizeUrl = sitemap.localizeUrl;\n\t\titem.localizeName = sitemap.localizeName;\n\t\titem.name = title;\n\t\titem.url = url;\n\t\titem.wildcard = wildcard;\n\t\tF.temporary.other[key] = item;\n\t\treturn item;\n\t}\n\n\tvar arr = [];\n\tvar index = 0;\n\n\twhile (true) {\n\t\tsitemap = F.routes.sitemap[name];\n\t\tif (!sitemap)\n\t\t\tbreak;\n\n\t\ttitle = sitemap.name;\n\t\turl = sitemap.url;\n\n\t\tvar wildcard = sitemap.wildcard;\n\n\t\tif (sitemap.localizeName)\n\t\t\ttitle = F.translate(language, sitemap.name);\n\n\t\tif (sitemap.localizeUrl) {\n\t\t\tif (sitemap.wildcard) {\n\t\t\t\tif (url[url.length - 1] !== '/')\n\t\t\t\t\turl += '/';\n\t\t\t\turl += '*';\n\t\t\t}\n\t\t\turl = F.translate(language, url);\n\n\t\t\tif (url.endsWith('*')) {\n\t\t\t\turl = url.substring(0, url.length - 1);\n\t\t\t\twildcard = true;\n\t\t\t} else\n\t\t\t\twildcard = false;\n\t\t}\n\n\t\tarr.push({ sitemap: id, id: name, name: title, url: url, last: index === 0, first: sitemap.parent ? false : true, selected: index === 0, index: index, wildcard: wildcard, formatName: sitemap.formatName, formatUrl: sitemap.formatUrl, localizeName: sitemap.localizeName, localizeUrl: sitemap.localizeUrl });\n\t\tindex++;\n\t\tname = sitemap.parent;\n\t\tif (!name)\n\t\t\tbreak;\n\t}\n\n\tarr.reverse();\n\tF.temporary.other[key] = arr;\n\treturn arr;\n};\n\n/**\n * Gets a list of all items in sitemap\n * @param {String} parent\n * @param {String} language Optional, language\n * @return {Array}\n */\nF.sitemap_navigation = function(parent, language) {\n\n\tvar key = REPOSITORY_SITEMAP + '_n_' + (parent || '') + '$' + (language || '');\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tvar keys = Object.keys(F.routes.sitemap);\n\tvar arr = [];\n\tvar index = 0;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar item = F.routes.sitemap[keys[i]];\n\t\tif ((parent && item.parent !== parent) || (!parent && item.parent))\n\t\t\tcontinue;\n\n\t\tvar title = item.name;\n\t\tvar url = item.url;\n\n\t\tif (item.localizeName)\n\t\t\ttitle = F.translate(language, title);\n\n\t\tif (item.localizeUrl)\n\t\t\turl = F.translate(language, url);\n\n\t\tarr.push({ id: parent || '', name: title, url: url, last: index === 0, first: item.parent ? false : true, selected: index === 0, index: index, wildcard: item.wildcard, formatName: item.formatName, formatUrl: item.formatUrl });\n\t\tindex++;\n\t}\n\n\tarr.quicksort('name');\n\tF.temporary.other[key] = arr;\n\treturn arr;\n};\n\n/**\n * Adds an item(s) to sitemap\n * @param {String|Array} obj - 'ID : Title ---> URL --> [Parent]' parent is optional\n * @return {framework}\n */\nF.sitemap_add = function (obj) {\n\tF.$configure_sitemap(obj instanceof Array ? obj : [obj]);\n\treturn F;\n};\n\nF.$configure_dependencies = function(arr, callback) {\n\n\tif (!arr || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'dependencies');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr)\n\t\treturn F;\n\n\tvar type;\n\tvar options;\n\tvar interval;\n\tvar dependencies = [];\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(' :');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar url = str.substring(index + 2).trim();\n\t\tvar priority = 0;\n\n\t\toptions = undefined;\n\t\tinterval = undefined;\n\n\t\tindex = key.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tinterval = key.substring(index, key.indexOf(')', index)).replace(/\\(|\\)/g, '').trim();\n\t\t\tkey = key.substring(0, index).trim();\n\t\t}\n\n\t\tindex = url.indexOf('-->');\n\t\tif (index !== -1) {\n\t\t\tvar opt = url.substring(index + 3).trim();\n\t\t\tif (opt.isJSON())\n\t\t\t\toptions = opt.parseJSON(true);\n\t\t\turl = url.substring(0, index).trim();\n\t\t}\n\n\t\tswitch (key) {\n\t\t\tcase 'package':\n\t\t\tcase 'packages':\n\t\t\tcase 'pkg':\n\t\t\t\ttype = 'package';\n\t\t\t\tpriority = 9;\n\t\t\t\tbreak;\n\t\t\tcase 'module':\n\t\t\tcase 'modules':\n\t\t\t\ttype = 'module';\n\t\t\t\tpriority = 10;\n\t\t\t\tbreak;\n\t\t\tcase 'model':\n\t\t\tcase 'models':\n\t\t\t\ttype = 'model';\n\t\t\t\tpriority = 8;\n\t\t\t\tbreak;\n\t\t\tcase 'source':\n\t\t\tcase 'sources':\n\t\t\t\ttype = 'source';\n\t\t\t\tpriority = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'controller':\n\t\t\tcase 'controllers':\n\t\t\t\ttype = 'controller';\n\t\t\t\tpriority = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'view':\n\t\t\tcase 'views':\n\t\t\t\tpriority = 3;\n\t\t\t\ttype = 'view';\n\t\t\t\tbreak;\n\t\t\tcase 'version':\n\t\t\tcase 'versions':\n\t\t\t\tpriority = 3;\n\t\t\t\ttype = 'version';\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\tcase 'configuration':\n\t\t\t\tpriority = 11;\n\t\t\t\ttype = 'config';\n\t\t\t\tbreak;\n\t\t\tcase 'isomorphic':\n\t\t\tcase 'isomorphics':\n\t\t\t\tpriority = 6;\n\t\t\t\ttype = 'isomorphic';\n\t\t\t\tbreak;\n\t\t\tcase 'definition':\n\t\t\tcase 'definitions':\n\t\t\t\tpriority = 5;\n\t\t\t\ttype = 'definition';\n\t\t\t\tbreak;\n\t\t\tcase 'middleware':\n\t\t\tcase 'middlewares':\n\t\t\t\ttype = 'middleware';\n\t\t\t\tpriority = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'component':\n\t\t\tcase 'components':\n\t\t\t\tpriority = 7;\n\t\t\t\ttype = 'component';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (type) {\n\t\t\t(function(type, url, options, interval) {\n\t\t\t\tif (interval)\n\t\t\t\t\tdependencies.push({ priority: priority, fn: next => F.uptodate(type, url, options, interval, next) });\n\t\t\t\telse\n\t\t\t\t\tdependencies.push({ priority: priority, fn: next => F.install(type, url, options, undefined, undefined, undefined, undefined, undefined, undefined, next) });\n\t\t\t})(type, url, options, interval);\n\t\t}\n\t}\n\n\tdependencies.quicksort('priority', false);\n\tdependencies.wait(function(item, next) {\n\t\titem.fn(next);\n\t}, callback);\n\treturn F;\n};\n\nF.$configure_workflows = function(arr, clean) {\n\n\tif (arr === undefined || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'workflows');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (clean)\n\t\tF.workflows = {};\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tarr.forEach(function(line) {\n\t\tline = line.trim();\n\t\tif (line.startsWith('//'))\n\t\t\treturn;\n\t\tvar index = line.indexOf(':');\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tvar key = line.substring(0, index).trim();\n\t\tvar response = -1;\n\t\tvar builder = [];\n\n\t\t// sub-type\n\t\tvar subindex = key.indexOf('(');\n\t\tif (subindex !== -1) {\n\t\t\tvar type = key.substring(subindex + 1, key.indexOf(')', subindex + 1)).trim();\n\t\t\tkey = key.substring(0, subindex).trim();\n\t\t\ttype = type.replace(/^default\\//gi, '');\n\t\t\tkey = type + '#' + key;\n\t\t}\n\n\t\tline.substring(index + 1).split('-->').forEach(function(operation, index) {\n\n\t\t\tvar options = 'options||EMPTYOBJECT';\n\t\t\toperation = operation.trim().replace(/\"/g, '\\'');\n\n\t\t\tvar oindex = operation.indexOf('{');\n\t\t\tif (oindex !== -1) {\n\t\t\t\toptions = operation.substring(oindex, operation.lastIndexOf('}') + 1);\n\t\t\t\toperation = operation.replace(options, '').trim();\n\t\t\t\toptions = 'options||' + options;\n\t\t\t}\n\n\t\t\tif (operation.endsWith('(response)')) {\n\t\t\t\tresponse = index;\n\t\t\t\toperation = operation.replace('(response)', '').trim();\n\t\t\t}\n\n\t\t\tvar what = operation.split(':');\n\t\t\tif (what.length === 2)\n\t\t\t\tbuilder.push('$' + what[0].trim() + '(' + what[1].trim() + ', {0})'.format(options));\n\t\t\telse\n\t\t\t\tbuilder.push('$' + what[0] + '({0})'.format(options));\n\n\t\t});\n\n\t\tF.workflows[key] = new Function('model', 'options', 'callback', 'return model.$async(callback' + (response === -1 ? '' : ', ' + response) + ').' + builder.join('.') + ';');\n\t});\n\n\treturn F;\n};\n\nF.$configure_versions = function(arr, clean) {\n\n\tif (arr === undefined || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'versions');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr) {\n\t\tif (clean)\n\t\t\tF.versions = null;\n\t\treturn F;\n\t}\n\n\tif (!clean)\n\t\tF.versions = {};\n\n\tif (!F.versions)\n\t\tF.versions = {};\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tif (str[0] !== '/')\n\t\t\tstr = '/' + str;\n\n\t\tvar index = str.indexOf(' :');\n\t\tvar ismap = false;\n\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1) {\n\t\t\t\tindex = str.indexOf('-->');\n\t\t\t\tif (index === -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tismap = true;\n\t\t\t}\n\t\t}\n\n\t\tvar len = ismap ? 3 : 2;\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar filename = str.substring(index + len).trim();\n\n\t\tif (filename === 'auto') {\n\n\t\t\tif (ismap)\n\t\t\t\tthrow new Error('/versions: \"auto\" value can\\'t be used with mapping');\n\n\t\t\tF.versions[key] = filename;\n\n\t\t\t(function(key, filename) {\n\t\t\t\tON('ready', function() {\n\t\t\t\t\tF.consoledebug('\"versions\" is getting checksum of ' + key);\n\t\t\t\t\tmakehash(key, function(hash) {\n\t\t\t\t\t\tF.consoledebug('\"versions\" is getting checksum of ' + key + ' (done)');\n\t\t\t\t\t\tif (hash) {\n\t\t\t\t\t\t\tvar index = key.lastIndexOf('.');\n\t\t\t\t\t\t\tfilename = key.substring(0, index) + '-' + hash + key.substring(index);\n\n\t\t\t\t\t\t\tF.versions[key] = filename;\n\n\t\t\t\t\t\t\tif (!F.routes.merge[key] && !F.temporary.other['merge_' + key]) {\n\t\t\t\t\t\t\t\tvar index = key.indexOf('/', 1);\n\t\t\t\t\t\t\t\tvar theme = index === -1 ? null : key.substring(1, index);\n\t\t\t\t\t\t\t\tif (theme) {\n\t\t\t\t\t\t\t\t\tif (F.themes[theme])\n\t\t\t\t\t\t\t\t\t\tkey = F.themes[theme] + 'public' + key.substring(index);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tkey = F.path.public(key);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tkey = F.path.public(key);\n\t\t\t\t\t\t\t\tF.map(filename, key);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tF.temporary.views = {};\n\t\t\t\t\t\t\tF.temporary.other = {};\n\t\t\t\t\t\t\tglobal.$VIEWCACHE = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})(key, filename);\n\n\t\t} else {\n\t\t\tF.versions[key] = filename;\n\t\t\tismap && F.map(filename, F.path.public(key));\n\t\t}\n\t}\n\n\treturn F;\n};\n\nfunction makehash(url, callback, count) {\n\tvar target = 'http://' + (F.ip === 'auto' ? '0.0.0.0' : F.ip) + ':' + F.port + url;\n\tU.download(target, ['get'], function(err, stream, status) {\n\n\t\t// Maybe F.wait()\n\t\tif (status === 503) {\n\t\t\t// Unhandled problem\n\t\t\tif (count > 60)\n\t\t\t\tcallback('');\n\t\t\telse\n\t\t\t\tsetTimeout((url, callback, count) => makehash(url, callback, (count || 1) + 1), 1000, url, callback, count);\n\t\t\treturn;\n\t\t}\n\n\t\tif (status !== 200) {\n\t\t\tcallback('');\n\t\t\treturn;\n\t\t}\n\n\t\tvar hash = Crypto.createHash('md5');\n\t\thash.setEncoding('hex');\n\t\tstream.pipe(hash);\n\t\tstream.on('end', function() {\n\t\t\thash.end();\n\t\t\tcallback(hash.read().crc32(true));\n\t\t});\n\n\t\tstream.on('error', () => callback(''));\n\t});\n}\n\nF.$configure_configs = function(arr, rewrite) {\n\n\tvar type = typeof(arr);\n\tif (type === 'string') {\n\t\tvar filename = prepare_filename(arr);\n\t\tif (!existsSync(filename, true))\n\t\t\treturn F;\n\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t}\n\n\tif (!arr) {\n\n\t\tvar filenameA = U.combine('/', 'config');\n\t\tvar filenameB = U.combine('/', 'config-' + (DEBUG ? 'debug' : 'release'));\n\n\t\tarr = [];\n\n\t\t// read all files from \"configs\" directory\n\t\tvar configs = F.path.configs();\n\t\tif (existsSync(configs)) {\n\t\t\tvar tmp = Fs.readdirSync(configs);\n\t\t\tfor (var i = 0, length = tmp.length; i < length; i++) {\n\t\t\t\tvar skip = tmp[i].match(/-(debug|release|test)$/i);\n\t\t\t\tif (skip) {\n\t\t\t\t\tskip = skip[0].toString().toLowerCase();\n\t\t\t\t\tif (skip === '-debug' && !F.isDebug)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (skip === '-release' && F.isDebug)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (skip === '-test' && !F.isTest)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tarr = arr.concat(Fs.readFileSync(configs + tmp[i]).toString(ENCODING).split('\\n'));\n\t\t\t}\n\t\t}\n\n\t\tif (existsSync(filenameA) && Fs.lstatSync(filenameA).isFile())\n\t\t\tarr = arr.concat(Fs.readFileSync(filenameA).toString(ENCODING).split('\\n'));\n\n\t\tif (existsSync(filenameB) && Fs.lstatSync(filenameB).isFile())\n\t\t\tarr = arr.concat(Fs.readFileSync(filenameB).toString(ENCODING).split('\\n'));\n\t}\n\n\tvar done = function() {\n\t\tprocess.title = 'total: ' + CONF.name.removeDiacritics().toLowerCase().replace(REG_EMPTY, '-').substring(0, 8);\n\t\tF.isVirtualDirectory = existsSync(U.combine(CONF.directory_public_virtual));\n\t};\n\n\tif (!(arr instanceof Array) || !arr.length) {\n\t\tdone();\n\t\treturn F;\n\t}\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tvar obj = {};\n\tvar accepts = null;\n\tvar length = arr.length;\n\tvar tmp;\n\tvar subtype;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || (str[0] === '/' || str[1] === '/'))\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(':');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar name = str.substring(0, index).trim();\n\t\tif (name === 'debug' || name === 'resources')\n\t\t\tcontinue;\n\n\t\tvalue = str.substring(index + 1).trim();\n\t\tindex = name.indexOf('(');\n\n\t\tif (value.substring(0, 7) === 'base64 ' && value.length > 8)\n\t\t\tvalue = U.createBuffer(value.substring(7).trim(), 'base64').toString('utf8');\n\t\telse if (value.substring(0, 4) === 'hex ' && value.length > 6)\n\t\t\tvalue = U.createBuffer(value.substring(4).trim(), 'hex').toString('utf8');\n\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (name) {\n\t\t\tcase 'secret':\n\t\t\tcase 'secret-uid':\n\t\t\tcase 'secret_uid':\n\t\t\t\tname = name.replace(REG_OLDCONF, '_');\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'default-request-length':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_request_maxlength\"');\n\t\t\t\tobj.default_request_maxlength = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-websocket-request-length':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_websocket_maxlength\"');\n\t\t\t\tobj.default_websocket_maxlength = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-maximum-file-descriptors':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_maxopenfiles\"');\n\t\t\t\tobj.default_maxopenfiles = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-cors-maxage': // old\n\t\t\tcase 'default-request-timeout': // old\n\t\t\tcase 'default-request-maxlength': // old\n\t\t\tcase 'default-request-maxkeys': // old\n\t\t\tcase 'default-websocket-maxlength': // old\n\t\t\tcase 'default-interval-clear-cache': // old\n\t\t\tcase 'default-interval-clear-resources': // old\n\t\t\tcase 'default-interval-precompile-views': // old\n\t\t\tcase 'default-interval-uptodate': // old\n\t\t\tcase 'default-interval-websocket-ping': // old\n\t\t\tcase 'default-interval-clear-dnscache': // old\n\t\t\tcase 'default-dependency-timeout': // old\n\t\t\tcase 'default-restbuilder-timeout': // old\n\t\t\tcase 'nosql-cleaner': // old\n\t\t\tcase 'default-errorbuilder-status': // old\n\t\t\tcase 'default-maxopenfiles': // old\n\t\t\tcase 'default_maxopenfiles':\n\t\t\tcase 'default_errorbuilder_status':\n\t\t\tcase 'default_cors_maxage':\n\t\t\tcase 'default_request_timeout':\n\t\t\tcase 'default_request_maxlength':\n\t\t\tcase 'default_request_maxkeys':\n\t\t\tcase 'default_websocket_maxlength':\n\t\t\tcase 'default_interval_clear_cache':\n\t\t\tcase 'default_interval_clear_resources':\n\t\t\tcase 'default_interval_precompile_views':\n\t\t\tcase 'default_interval_uptodate':\n\t\t\tcase 'default_interval_websocket_ping':\n\t\t\tcase 'default_interval_clear_dnscache':\n\t\t\tcase 'default_dependency_timeout':\n\t\t\tcase 'default_restbuilder_timeout':\n\t\t\tcase 'nosql_cleaner':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-image-consumption': // old\n\t\t\tcase 'default-image-quality': // old\n\t\t\tcase 'default_image_consumption':\n\t\t\tcase 'default_image_quality':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = U.parseInt(value.replace(/%|\\s/g, ''));\n\t\t\t\tbreak;\n\n\t\t\tcase 'static-accepts-custom': // old\n\t\t\tcase 'static_accepts_custom':\n\t\t\t\taccepts = value.replace(REG_ACCEPTCLEANER, '').split(',');\n\t\t\t\tbreak;\n\n\t\t\tcase 'default-root': // old\n\t\t\tcase 'default_root':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tif (value)\n\t\t\t\t\tobj[name] = U.path(value);\n\t\t\t\tbreak;\n\n\t\t\tcase 'static-accepts': // old\n\t\t\tcase 'static_accepts':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = {};\n\t\t\t\ttmp = value.replace(REG_ACCEPTCLEANER, '').split(',');\n\t\t\t\tfor (var j = 0; j < tmp.length; j++)\n\t\t\t\t\tobj[name][tmp[j]] = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'mail.smtp':\n\t\t\tcase 'mail.smtp.options':\n\t\t\tcase 'mail.address.from':\n\t\t\tcase 'mail.address.copy':\n\t\t\tcase 'mail.address.bcc':\n\t\t\tcase 'mail.address.reply':\n\n\t\t\t\tif (name === 'mail.address.bcc')\n\t\t\t\t\ttmp = 'mail_address_copy';\n\t\t\t\telse\n\t\t\t\t\ttmp = name.replace(/\\./g, '-');\n\n\t\t\t\tOBSOLETE(name, 'is renamed to \"' + tmp + '\"');\n\t\t\t\tobj[tmp] = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'default-cors': // old\n\t\t\tcase 'default_cors':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tvalue = value.replace(/,/g, ' ').split(' ');\n\t\t\t\ttmp = [];\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar co = (value[j] || '').trim();\n\t\t\t\t\tif (co) {\n\t\t\t\t\t\tco = co.toLowerCase();\n\t\t\t\t\t\tif (co.substring(0, 2) === '//') {\n\t\t\t\t\t\t\ttmp.push(co);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\ttmp.push(co.substring(co.indexOf('/') + 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobj[name] = tmp.length ? tmp : null;\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-handle-static-files':\n\t\t\t\tOBSOLETE('config[\"allow-handle-static-files\"]', 'The key has been renamed to \"allow_static_files\"');\n\t\t\t\tobj.allow_static_files = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'disable-clear-temporary-directory':\n\t\t\t\tOBSOLETE('disable-clear-temporary-directory', 'You need to use \"allow_clear_temp : true|false\"');\n\t\t\t\tobj.allow_clear_temp = !(value.toLowerCase() === 'true' || value === '1' || value === 'on');\n\t\t\t\tbreak;\n\n\t\t\tcase 'disable-strict-server-certificate-validation':\n\t\t\t\tOBSOLETE('disable-strict-server-certificate-validation', 'You need to use \"allow_ssc_validation : true|false\"');\n\t\t\t\tobj.allow_ssc_validation = !(value.toLowerCase() === 'true' || value === '1' || value === 'on');\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-compile': // old\n\t\t\tcase 'allow-compile-html': // old\n\t\t\tcase 'allow-compile-script': // old\n\t\t\tcase 'allow-compile-style': // old\n\t\t\tcase 'allow-ssc-validation': // old\n\t\t\tcase 'allow-debug': // old\n\t\t\tcase 'allow-gzip': // old\n\t\t\tcase 'allow-head': // old\n\t\t\tcase 'allow-performance': // old\n\t\t\tcase 'allow-static-files': // old\n\t\t\tcase 'allow-websocket': // old\n\t\t\tcase 'allow-websocket-compression': // old\n\t\t\tcase 'allow-clear-temp': // old\n\t\t\tcase 'allow-cache-snapshot': // old\n\t\t\tcase 'allow-cache-cluster': // old\n\t\t\tcase 'allow-custom-titles': // old\n\t\t\tcase 'nosql-worker': // old\n\t\t\tcase 'nosql-logger': // old\n\t\t\tcase 'allow-filter-errors': // old\n\t\t\tcase 'default-websocket-encodedecode': // old\n\t\t\tcase 'allow_compile':\n\t\t\tcase 'allow_compile_html':\n\t\t\tcase 'allow_compile_script':\n\t\t\tcase 'allow_compile_style':\n\t\t\tcase 'allow_ssc_validation':\n\t\t\tcase 'allow_debug':\n\t\t\tcase 'allow_gzip':\n\t\t\tcase 'allow_head':\n\t\t\tcase 'allow_performance':\n\t\t\tcase 'allow_static_files':\n\t\t\tcase 'allow_websocket':\n\t\t\tcase 'allow_websocket_compression':\n\t\t\tcase 'allow_clear_temp':\n\t\t\tcase 'allow_cache_snapshot':\n\t\t\tcase 'allow_cache_cluster':\n\t\t\tcase 'allow_filter_errors':\n\t\t\tcase 'allow_custom_titles':\n\t\t\tcase 'trace':\n\t\t\tcase 'nosql_worker':\n\t\t\tcase 'nosql_logger':\n\t\t\tcase 'default_websocket_encodedecode':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = value.toLowerCase() === 'true' || value === '1' || value === 'on';\n\t\t\t\tbreak;\n\n\t\t\tcase 'nosql-inmemory': // old\n\t\t\tcase 'nosql_inmemory':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = typeof(value) === 'string' ? value.split(',').trim() : value instanceof Array ? value : null;\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-compress-html':\n\t\t\t\tobj.allow_compile_html = value.toLowerCase() === 'true' || value === '1' || value === 'on';\n\t\t\t\tbreak;\n\n\t\t\tcase 'version':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'security.txt':\n\t\t\t\tobj[name] = value ? value.split(',').trim().join('\\n') : '';\n\t\t\t\tbreak;\n\n\t\t\t// backward compatibility\n\t\t\tcase 'mail-smtp': // old\n\t\t\tcase 'mail-smtp-options': // old\n\t\t\tcase 'mail-address-from': // old\n\t\t\tcase 'mail-address-copy': // old\n\t\t\tcase 'mail-address-bcc': // old\n\t\t\tcase 'mail-address-reply': // old\n\t\t\tcase 'default-image-converter': // old\n\t\t\tcase 'static-url': // old\n\t\t\tcase 'static-url-script': // old\n\t\t\tcase 'static-url-style': // old\n\t\t\tcase 'static-url-image': // old\n\t\t\tcase 'static-url-video': // old\n\t\t\tcase 'static-url-font': // old\n\t\t\tcase 'static-url-download': // old\n\t\t\tcase 'static-url-components': // old\n\t\t\tcase 'default-xpoweredby': // old\n\t\t\tcase 'default-layout': // old\n\t\t\tcase 'default-theme': // old\n\t\t\tcase 'default-proxy': // old\n\t\t\tcase 'default-timezone': // old\n\t\t\tcase 'default-response-maxage': // old\n\t\t\tcase 'default-errorbuilder-resource-name': // old\n\t\t\tcase 'default-errorbuilder-resource-prefix': // old\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif (subtype === 'string')\n\t\t\t\t\tobj[name] = value;\n\t\t\t\telse if (subtype === 'number' || subtype === 'currency' || subtype === 'float' || subtype === 'double')\n\t\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\telse if (subtype === 'boolean' || subtype === 'bool')\n\t\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\telse if (subtype === 'eval' || subtype === 'object' || subtype === 'array') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tF.error(e, 'F.configure(' + name + ')');\n\t\t\t\t\t}\n\t\t\t\t} else if (subtype === 'json')\n\t\t\t\t\tobj[name] = value.parseJSON();\n\t\t\t\telse if (subtype === 'date' || subtype === 'datetime' || subtype === 'time')\n\t\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\telse if (subtype === 'env' || subtype === 'environment')\n\t\t\t\t\tobj[name] = process.env[value];\n\t\t\t\telse {\n\t\t\t\t\tif (value.isNumber()) {\n\t\t\t\t\t\tobj[name] = value[0] !== '0' ? U.parseInt(value) : value;\n\t\t\t\t\t} else if (value.isNumber(true))\n\t\t\t\t\t\tobj[name] = value.indexOf(',') === -1 && !(/^0{2,}/).test(value) ? U.parseFloat(value) : value;\n\t\t\t\t\telse\n\t\t\t\t\t\tobj[name] = value.isBoolean() ? value.toLowerCase() === 'true' : value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tU.extend(CONF, obj, rewrite);\n\n\tif (!CONF.secret_uid)\n\t\tCONF.secret_uid = (CONF.name).crc32(true).toString();\n\n\tvar tmp = CONF.mail_smtp_options;\n\tif (typeof(tmp) === 'string' && tmp) {\n\t\ttmp = new Function('return ' + tmp)();\n\t\tCONF.mail_smtp_options = tmp;\n\t}\n\n\tprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = CONF.allow_ssc_validation === false ? '0' : '1';\n\n\tif (!CONF.directory_temp)\n\t\tCONF.directory_temp = '~' + U.path(Path.join(Os.tmpdir(), 'totaljs' + F.directory.hash()));\n\n\tif (!CONF.etag_version)\n\t\tCONF.etag_version = CONF.version.replace(/\\.|\\s/g, '');\n\n\tif (CONF.default_timezone)\n\t\tprocess.env.TZ = CONF.default_timezone;\n\n\tCONF.nosql_worker && framework_nosql.worker();\n\tCONF.nosql_inmemory && CONF.nosql_inmemory.forEach(n => framework_nosql.inmemory(n));\n\taccepts && accepts.length && accepts.forEach(accept => CONF.static_accepts[accept] = true);\n\n\tif (CONF.allow_performance)\n\t\thttp.globalAgent.maxSockets = 9999;\n\n\tQUERYPARSEROPTIONS.maxKeys = CONF.default_request_maxkeys || 33;\n\n\tvar xpowered = CONF.default_xpoweredby;\n\n\tObject.keys(HEADERS).forEach(function(key) {\n\t\tObject.keys(HEADERS[key]).forEach(function(subkey) {\n\t\t\tif (RELEASE && subkey === 'Cache-Control')\n\t\t\t\tHEADERS[key][subkey] = HEADERS[key][subkey].replace(/max-age=\\d+/, 'max-age=' + CONF.default_response_maxage);\n\t\t\tif (subkey === 'X-Powered-By') {\n\t\t\t\tif (xpowered)\n\t\t\t\t\tHEADERS[key][subkey] = xpowered;\n\t\t\t\telse\n\t\t\t\t\tdelete HEADERS[key][subkey];\n\t\t\t}\n\t\t});\n\t});\n\n\tIMAGEMAGICK = CONF.default_image_converter === 'im';\n\tdone();\n\tEMIT('configure', CONF);\n\treturn F;\n};\n\nfunction obsolete_config(name) {\n\tif (name.indexOf('-') === -1)\n\t\treturn name;\n\tvar n = name.replace(REG_OLDCONF, '_');\n\tOBSOLETE('config[\\'' + name + '\\']', 'Replace key \"{0}\" to \"{1}\" in your config file'.format(name, n));\n\treturn n;\n}\n\n/**\n * Create URL: JavaScript (according to config['static-url-script'])\n * @param {String} name\n * @return {String}\n */\nF.routeScript = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_script, theme);\n};\n\n/**\n * Create URL: CSS (according to config['static-url-style'])\n * @param {String} name\n * @return {String}\n */\nF.routeStyle = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_style, theme);\n};\n\nF.routeImage = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_image, theme);\n};\n\nF.routeVideo = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_video, theme);\n};\n\nF.routeFont = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_font, theme);\n};\n\nF.routeDownload = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_download, theme);\n};\n\nF.routeStatic = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url, theme);\n};\n\nF.$routeStatic = function(name, directory, theme) {\n\tvar key = name + directory + '$' + theme;\n\tvar val = F.temporary.other[key];\n\tif (RELEASE && val)\n\t\treturn val;\n\n\n\tif (name[0] === '~') {\n\t\tname = name.substring(name[1] === '~' ? 2 : 1);\n\t\ttheme = '';\n\t} else if (name[0] === '=') {\n\t\t// theme\n\t\tvar index = name.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\ttheme = name.substring(1, index);\n\t\t\tif (theme === '?') {\n\t\t\t\ttheme = CONF.default_theme;\n\t\t\t\tname = name.substring(index);\n\t\t\t} else\n\t\t\t\tname = name.substring(index + 1);\n\t\t}\n\t}\n\n\tvar filename;\n\n\tif (REG_ROUTESTATIC.test(name))\n\t\tfilename = name;\n\telse if (name[0] === '/')\n\t\tfilename = U.join(theme, F.$version(name, true));\n\telse {\n\t\tfilename = U.join(theme, directory, F.$version(name, true));\n\t\tif (REG_HTTPHTTPS.test(filename) && filename[0] === '/')\n\t\t\tfilename = filename.substring(1);\n\t}\n\n\treturn F.temporary.other[key] = framework_internal.preparePath(F.$version(filename, true));\n};\n\nF.$version = function(name, def) {\n\tvar tmp;\n\tif (F.versions)\n\t\ttmp = F.versions[name] || name;\n\tif (F.onVersion)\n\t\ttmp = F.onVersion(name) || name;\n\treturn tmp === 'auto' && def ? name : (tmp || name);\n};\n\nF.$versionprepare = function(html) {\n\tvar match = html.match(REG_VERSIONS);\n\tif (!match)\n\t\treturn html;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\n\t\tvar src = match[i].toString();\n\t\tvar end = 5;\n\n\t\t// href\n\t\tif (src[0] === 'h')\n\t\t\tend = 6;\n\n\t\tvar name = src.substring(end, src.length - 1);\n\t\thtml = html.replace(match[i], src.substring(0, end) + F.$version(name, true) + '\"');\n\t}\n\n\treturn html;\n};\n\n/**\n * Lookup for the route\n * @param {HttpRequest} req\n * @param {String} url URL address.\n * @param {String Array} flags\n * @param {Boolean} membertype Not defined = 0, Authorized = 1, Unauthorized = 2\n * @return {Object}\n */\nF.lookup = function(req, url, flags, membertype) {\n\n\tvar isSystem = url[0] === '#';\n\tvar subdomain = F._length_subdomain_web && req.subdomain ? req.subdomain.join('.') : null;\n\n\tif (isSystem)\n\t\treturn F.routes.system[url];\n\n\tif (isSystem)\n\t\treq.path = [url];\n\n\tvar key;\n\n\t// helper for 401 http status\n\treq.$isAuthorized = true;\n\n\tif (!isSystem) {\n\t\tkey = '1' + url + '$' + membertype + req.$flags + (subdomain ? '$' + subdomain : '') + (req.$roles ? 'R' : '');\n\t\tif (F.temporary.other[key])\n\t\t\treturn F.temporary.other[key];\n\t}\n\n\tvar length = F.routes.web.length;\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.web[i];\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req, flags))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (F._length_subdomain_web && !framework_internal.routeCompareSubdomain(subdomain, route.subdomain))\n\t\t\t\tcontinue;\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (isSystem) {\n\t\t\tif (route.isSYSTEM)\n\t\t\t\treturn route;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags2(req, route, membertype);\n\t\t\tif (result === -1)\n\t\t\t\treq.$isAuthorized = false; // request is not authorized\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (key && route.isCACHE && (req.$isAuthorized || membertype === 1))\n\t\t\tF.temporary.other[key] = route;\n\n\t\treturn route;\n\t}\n\n\treturn null;\n};\n\nF.lookup_websocket = function(req, url, membertype) {\n\n\tvar subdomain = F._length_subdomain_websocket && req.subdomain ? req.subdomain.join('.') : null;\n\tvar length = F.routes.websockets.length;\n\n\treq.$isAuthorized = true;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.websockets[i];\n\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req))\n\t\t\t\tcontinue;\n\t\t} else {\n\n\t\t\tif (F._length_subdomain_websocket && !framework_internal.routeCompareSubdomain(subdomain, route.subdomain))\n\t\t\t\tcontinue;\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, false, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, false))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags2(req, route, membertype);\n\t\t\tif (result === -1)\n\t\t\t\treq.$isAuthorized = false;\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn route;\n\t}\n\n\treturn null;\n};\n\n/**\n * Accept file type\n * @param {String} extension\n * @param {String} contentType Content-Type for file extension, optional.\n * @return {Framework}\n */\nF.accept = function(extension, contentType) {\n\tif (extension[0] === '.')\n\t\textension = extension.substring(1);\n\tCONF.static_accepts[extension] = true;\n\tcontentType && U.setContentType(extension, contentType);\n\treturn F;\n};\n\n// A temporary variable for generating Worker ID\n// It's faster than Date.now()\nvar WORKERID = 0;\n\n/**\n * Run worker\n * @param {String} name\n * @param {String} id Worker id, optional.\n * @param {Number} timeout Timeout, optional.\n * @param {Array} args Additional arguments, optional.\n * @return {ChildProcess}\n */\nglobal.WORKER = F.worker = function(name, id, timeout, args) {\n\n\tvar fork = null;\n\tvar type = typeof(id);\n\n\tif (type === 'number' && timeout === undefined) {\n\t\ttimeout = id;\n\t\tid = null;\n\t\ttype = 'undefined';\n\t}\n\n\tif (type === 'string')\n\t\tfork = F.workers[id];\n\n\tif (id instanceof Array) {\n\t\targs = id;\n\t\tid = null;\n\t\ttimeout = undefined;\n\t}\n\n\tif (timeout instanceof Array) {\n\t\targs = timeout;\n\t\ttimeout = undefined;\n\t}\n\n\tif (fork)\n\t\treturn fork;\n\n\tvar filename = name[0] === '@' ? F.path.package(name.substring(1)) : U.combine(CONF.directory_workers, name);\n\n\tif (!args)\n\t\targs = [];\n\n\tfork = Child.fork(filename[filename.length - 3] === '.' ? filename : filename + '.js', args, HEADERS.workers);\n\n\tif (!id)\n\t\tid = name + '_' + (WORKERID++);\n\n\tfork.__id = id;\n\tF.workers[id] = fork;\n\n\tfork.on('exit', function() {\n\t\tvar self = this;\n\t\tself.__timeout && clearTimeout(self.__timeout);\n\t\tdelete F.workers[self.__id];\n\t\tif (fork) {\n\t\t\tfork.removeAllListeners();\n\t\t\tfork = null;\n\t\t}\n\t});\n\n\tif (typeof(timeout) !== 'number')\n\t\treturn fork;\n\n\tfork.__timeout = setTimeout(function() {\n\t\tfork && fork.kill('SIGKILL');\n\t}, timeout);\n\n\treturn fork;\n};\n\nglobal.WORKER2 = F.worker2 = function(name, args, callback, timeout) {\n\n\tif (typeof(args) === 'function') {\n\t\ttimeout = callback;\n\t\tcallback = args;\n\t\targs = undefined;\n\t} else if (typeof(callback) === 'number') {\n\t\tvar tmp = timeout;\n\t\ttimeout = callback;\n\t\tcallback = tmp;\n\t}\n\n\tif (args && !(args instanceof Array))\n\t\targs = [args];\n\n\tvar fork = F.worker(name, 'worker' + (WORKERID++), timeout, args);\n\tif (fork.__worker2)\n\t\treturn fork;\n\n\tvar output = U.createBufferSize(0);\n\n\tfork.__worker2 = true;\n\tfork.on('error', function(e) {\n\t\tcallback && callback(e, output);\n\t\tcallback = null;\n\t});\n\n\tfork.stdout.on('data', function(data) {\n\t\tCONCAT[0] = output;\n\t\tCONCAT[1] = data;\n\t\toutput = Buffer.concat(CONCAT);\n\t});\n\n\tfork.on('exit', function() {\n\t\tcallback && callback(null, output);\n\t\tcallback = null;\n\t});\n\n\treturn fork;\n};\n\n/**\n * This method suspends\n * @param {String} name Operation name.\n * @param {Boolean} enable Enable waiting (optional, default: by the current state).\n * @return {Boolean}\n */\nF.wait = function(name, enable) {\n\n\tif (!F.waits)\n\t\tF.waits = {};\n\n\tif (enable !== undefined) {\n\t\tif (enable)\n\t\t\tF.waits[name] = true;\n\t\telse\n\t\t\tdelete F.waits[name];\n\t\tF._length_wait = Object.keys(F.waits).length;\n\t\treturn enable;\n\t}\n\n\tif (F.waits[name])\n\t\tdelete F.waits[name];\n\telse {\n\t\tF.waits[name] = true;\n\t\tenable = true;\n\t}\n\n\tF._length_wait = Object.keys(F.waits).length;\n\treturn enable === true;\n};\n\n// =================================================================================\n// Framework route\n// =================================================================================\n\nfunction FrameworkRoute() {\n\tthis.route = {};\n}\n\nFrameworkRoute.prototype = {\n\tget id() {\n\t\treturn this.route.id;\n\t},\n\tset id(value) {\n\t\tthis.route.id = value;\n\t},\n\tget description() {\n\t\treturn this.route.description;\n\t},\n\tset description(value) {\n\t\tthis.route.description = value;\n\t},\n\tget maxlength() {\n\t\treturn this.route.length;\n\t},\n\tset maxlength(value) {\n\t\tthis.route.length = value;\n\t},\n\tget options() {\n\t\treturn this.route.options;\n\t},\n\tset options(value) {\n\t\tthis.route.options = value;\n\t},\n\tget url() {\n\t\treturn this.route.urlraw;\n\t},\n\tget flags() {\n\t\treturn this.route.flags || EMPTYARRAY;\n\t},\n\tset groups(value) {\n\t\tthis.route.groups = value;\n\t},\n\tget groups() {\n\t\treturn this.route.groups;\n\t}\n};\n\nFrameworkRoute.prototype.make = function(fn) {\n\tfn && fn.call(this, this);\n\treturn this;\n};\n\nFrameworkRoute.prototype.setId = function(value) {\n\tthis.route.id = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setDecription = function(value) {\n\tthis.route.description = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setTimeout = function(value) {\n\tthis.route.timeout = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setMaxLength = function(value) {\n\tthis.route.length = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setOptions = function(value) {\n\tthis.route.options = value;\n\treturn this;\n};\n\n// =================================================================================\n// Framework path\n// =================================================================================\n\nfunction FrameworkPath() {}\n\nFrameworkPath.prototype.verify = function(name) {\n\tvar prop = '$directory-' + name;\n\tif (F.temporary.path[prop])\n\t\treturn F;\n\tvar directory = CONF['directory_' + name] || name;\n\tvar dir = U.combine(directory);\n\t!existsSync(dir) && Fs.mkdirSync(dir);\n\tF.temporary.path[prop] = true;\n\treturn F;\n};\n\nFrameworkPath.prototype.mkdir = function(p, cache) {\n\n\tvar key = '$directory-' + p;\n\n\tif (cache && F.temporary.path[key])\n\t\treturn F;\n\n\tF.temporary.path[key] = true;\n\n\tvar is = F.isWindows;\n\tvar s = '';\n\n\tif (p[0] === '/') {\n\t\ts = is ? '\\\\' : '/';\n\t\tp = p.substring(1);\n\t}\n\n\tvar l = p.length - 1;\n\tvar beg = 0;\n\n\tif (is) {\n\t\tif (p[l] === '\\\\')\n\t\t\tp = p.substring(0, l);\n\n\t\tif (p[1] === ':')\n\t\t\tbeg = 1;\n\n\t} else {\n\t\tif (p[l] === '/')\n\t\t\tp = p.substring(0, l);\n\t}\n\n\tif (existsSync(p))\n\t\treturn F;\n\n\tvar arr = is ? p.replace(/\\//g, '\\\\').split('\\\\') : p.split('/');\n\tvar directory = s;\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar name = arr[i];\n\t\tif (is)\n\t\t\tdirectory += (i && directory ? '\\\\' : '') + name;\n\t\telse\n\t\t\tdirectory += (i && directory ? '/' : '') + name;\n\n\t\tif (i >= beg && !existsSync(directory))\n\t\t\tFs.mkdirSync(directory);\n\t}\n\n\treturn F;\n};\n\nFrameworkPath.prototype.exists = function(path, callback) {\n\tFs.lstat(path, (err, stats) => callback(err ? false : true, stats ? stats.size : 0, stats ? stats.isFile() : false));\n\treturn F;\n};\n\nFrameworkPath.prototype.public = function(filename) {\n\treturn U.combine(CONF.directory_public, filename);\n};\n\nFrameworkPath.prototype.public_cache = function(filename) {\n\tvar key = 'public_' + filename;\n\tvar item = F.temporary.other[key];\n\treturn item ? item : F.temporary.other[key] = U.combine(CONF.directory_public, filename);\n};\n\nFrameworkPath.prototype.private = function(filename) {\n\treturn U.combine(CONF.directory_private, filename);\n};\n\nFrameworkPath.prototype.isomorphic = function(filename) {\n\treturn U.combine(CONF.directory_isomorphic, filename);\n};\n\nFrameworkPath.prototype.configs = function(filename) {\n\treturn U.combine(CONF.directory_configs, filename);\n};\n\nFrameworkPath.prototype.virtual = function(filename) {\n\treturn U.combine(CONF.directory_public_virtual, filename);\n};\n\nFrameworkPath.prototype.logs = function(filename) {\n\tthis.verify('logs');\n\treturn U.combine(CONF.directory_logs, filename);\n};\n\nFrameworkPath.prototype.models = function(filename) {\n\treturn U.combine(CONF.directory_models, filename);\n};\n\nFrameworkPath.prototype.temp = function(filename) {\n\tthis.verify('temp');\n\treturn U.combine(CONF.directory_temp, filename);\n};\n\nFrameworkPath.prototype.temporary = function(filename) {\n\treturn this.temp(filename);\n};\n\nFrameworkPath.prototype.views = function(filename) {\n\treturn U.combine(CONF.directory_views, filename);\n};\n\nFrameworkPath.prototype.workers = function(filename) {\n\treturn U.combine(CONF.directory_workers, filename);\n};\n\nFrameworkPath.prototype.databases = function(filename) {\n\tthis.verify('databases');\n\treturn U.combine(CONF.directory_databases, filename);\n};\n\nFrameworkPath.prototype.modules = function(filename) {\n\treturn U.combine(CONF.directory_modules, filename);\n};\n\nFrameworkPath.prototype.controllers = function(filename) {\n\treturn U.combine(CONF.directory_controllers, filename);\n};\n\nFrameworkPath.prototype.definitions = function(filename) {\n\treturn U.combine(CONF.directory_definitions, filename);\n};\n\nFrameworkPath.prototype.tests = function(filename) {\n\treturn U.combine(CONF.directory_tests, filename);\n};\n\nFrameworkPath.prototype.resources = function(filename) {\n\treturn U.combine(CONF.directory_resources, filename);\n};\n\nFrameworkPath.prototype.services = function(filename) {\n\treturn U.combine(CONF.directory_services, filename);\n};\n\nFrameworkPath.prototype.packages = function(filename) {\n\treturn U.combine(CONF.directory_packages, filename);\n};\n\nFrameworkPath.prototype.themes = function(filename) {\n\treturn U.combine(CONF.directory_themes, filename);\n};\n\nFrameworkPath.prototype.components = function(filename) {\n\treturn U.combine(CONF.directory_components, filename);\n};\n\nFrameworkPath.prototype.root = function(filename) {\n\tvar p = Path.join(directory, filename || '');\n\treturn F.isWindows ? p.replace(/\\\\/g, '/') : p;\n};\n\nFrameworkPath.prototype.package = function(name, filename) {\n\n\tif (filename === undefined) {\n\t\tvar index = name.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\tfilename = name.substring(index + 1);\n\t\t\tname = name.substring(0, index);\n\t\t}\n\t}\n\n\tvar tmp = CONF.directory_temp;\n\tvar p = tmp[0] === '~' ? Path.join(tmp.substring(1), name + '.package', filename || '') : Path.join(directory, tmp, name + '.package', filename || '');\n\treturn F.isWindows ? p.replace(REG_WINDOWSPATH, '/') : p;\n};\n\n// =================================================================================\n// Cache declaration\n// =================================================================================\n\nfunction FrameworkCache() {\n\tthis.items = {};\n\tthis.count = 1;\n\tthis.interval;\n}\n\nFrameworkCache.prototype.init = function() {\n\tvar self = this;\n\tclearInterval(self.interval);\n\tself.interval = setInterval(() => F.cache.recycle(), 1000 * 60);\n\tif (CONF.allow_cache_snapshot)\n\t\tself.load(() => self.loadpersistent());\n\telse\n\t\tself.loadpersistent();\n\treturn self;\n};\n\nFrameworkCache.prototype.save = function() {\n\tFs.writeFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachesnapshot.jsoncache'), JSON.stringify(this.items), NOOP);\n\treturn this;\n};\n\nFrameworkCache.prototype.load = function(callback) {\n\tvar self = this;\n\tFs.readFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachesnapshot.jsoncache'), function(err, data) {\n\t\tif (!err) {\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(data.toString('utf8'), (key, value) => typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value);\n\t\t\t\tself.items = data;\n\t\t\t} catch (e) {}\n\t\t}\n\t\tcallback && callback();\n\t});\n\treturn self;\n};\n\nFrameworkCache.prototype.savePersist = function() {\n\tsetTimeout2('framework_cachepersist', function(self) {\n\t\tvar keys = Object.keys(self.items);\n\t\tvar obj = {};\n\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tvar item = self.items[key];\n\t\t\tif (item && item.persist)\n\t\t\t\tobj[key] = item;\n\t\t}\n\n\t\tFs.writeFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachepersist.jsoncache'), JSON.stringify(obj), NOOP);\n\t}, 1000, 50, this);\n\treturn this;\n};\n\nFrameworkCache.prototype.loadpersistent = function(callback) {\n\tvar self = this;\n\tFs.readFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachepersist.jsoncache'), function(err, data) {\n\t\tif (!err) {\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(data.toString('utf8'), (key, value) => typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value);\n\t\t\t\tvar keys = Object.keys(data);\n\t\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\tvar item = data[key];\n\t\t\t\t\tif (item.expire >= NOW)\n\t\t\t\t\t\tself.items[key] = item;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\tcallback && callback();\n\t});\n\treturn self;\n};\n\nFrameworkCache.prototype.stop = function() {\n\tclearInterval(this.interval);\n\treturn this;\n};\n\nFrameworkCache.prototype.clear = function(sync) {\n\tthis.items = {};\n\tF.isCluster && sync !== false && CONF.allow_cache_cluster && process.send(CLUSTER_CACHE_CLEAR);\n\tthis.savePersist();\n\treturn this;\n};\n\nFrameworkCache.prototype.recycle = function() {\n\n\tvar items = this.items;\n\tvar isPersist = false;\n\n\tNOW = new Date();\n\n\tthis.count++;\n\n\tfor (var o in items) {\n\t\tvar value = items[o];\n\t\tif (!value)\n\t\t\tdelete items[o];\n\t\telse if (value.expire < NOW) {\n\t\t\tif (value.persist)\n\t\t\t\tisPersist = true;\n\t\t\tEMIT('cache-expire', o, value.value);\n\t\t\tdelete items[o];\n\t\t}\n\t}\n\n\tisPersist && this.savePersist();\n\tCONF.allow_cache_snapshot && this.save();\n\tF.service(this.count);\n\treturn this;\n};\n\nFrameworkCache.prototype.set2 = function(name, value, expire, sync) {\n\treturn this.set(name, value, expire, sync, true);\n};\n\nFrameworkCache.prototype.set = FrameworkCache.prototype.add = function(name, value, expire, sync, persist) {\n\tvar type = typeof(expire);\n\n\tif (F.isCluster && sync !== false && CONF.allow_cache_cluster) {\n\t\tCLUSTER_CACHE_SET.key = name;\n\t\tCLUSTER_CACHE_SET.value = value;\n\t\tCLUSTER_CACHE_SET.expire = expire;\n\t\tprocess.send(CLUSTER_CACHE_SET);\n\t}\n\n\tswitch (type) {\n\t\tcase 'string':\n\t\t\texpire = expire.parseDateExpiration();\n\t\t\tbreak;\n\t\tcase 'undefined':\n\t\t\texpire = NOW.add('m', 5);\n\t\t\tbreak;\n\t}\n\n\tvar obj = { value: value, expire: expire };\n\n\tif (persist) {\n\t\tobj.persist = true;\n\t\tthis.savePersist();\n\t}\n\n\tthis.items[name] = obj;\n\tF.$events['cache-set'] && EMIT('cache-set', name, value, expire, sync !== false);\n\treturn value;\n};\n\nFrameworkCache.prototype.read = FrameworkCache.prototype.get = function(key, def) {\n\n\tvar value = this.items[key];\n\tif (!value)\n\t\treturn def;\n\n\tNOW = new Date();\n\n\tif (value.expire < NOW) {\n\t\tthis.items[key] = undefined;\n\t\tF.$events['cache-expire'] && EMIT('cache-expire', key, value.value);\n\t\treturn def;\n\t}\n\n\treturn value.value;\n};\n\nFrameworkCache.prototype.read2 = FrameworkCache.prototype.get2 = function(key, def) {\n\tvar value = this.items[key];\n\n\tif (!value)\n\t\treturn def;\n\n\tif (value.expire < NOW) {\n\t\tthis.items[key] = undefined;\n\t\tF.$events['cache-expire'] && EMIT('cache-expire', key, value.value);\n\t\treturn def;\n\t}\n\n\treturn value.value;\n};\n\nFrameworkCache.prototype.setExpire = function(name, expire) {\n\tvar obj = this.items[name];\n\tif (obj)\n\t\tobj.expire = typeof(expire) === 'string' ? expire.parseDateExpiration() : expire;\n\treturn this;\n};\n\nFrameworkCache.prototype.remove = function(name, sync) {\n\tvar value = this.items[name];\n\n\tif (value) {\n\t\tthis.items[name].persist && this.savePersist();\n\t\tthis.items[name] = undefined;\n\t}\n\n\tif (F.isCluster && sync !== false && CONF.allow_cache_cluster) {\n\t\tCLUSTER_CACHE_REMOVE.key = name;\n\t\tprocess.send(CLUSTER_CACHE_REMOVE);\n\t}\n\n\treturn value;\n};\n\nFrameworkCache.prototype.removeAll = function(search, sync) {\n\tvar count = 0;\n\tvar isReg = U.isRegExp(search);\n\n\tfor (var key in this.items) {\n\n\t\tif (isReg) {\n\t\t\tif (!search.test(key))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (key.indexOf(search) === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tthis.remove(key);\n\t\tcount++;\n\t}\n\n\tif (F.isCluster && sync !== false && CONF.allow_cache_cluster) {\n\t\tCLUSTER_CACHE_REMOVEALL.key = search;\n\t\tprocess.send(CLUSTER_CACHE_REMOVEALL);\n\t}\n\n\treturn count;\n};\n\nFrameworkCache.prototype.fn = function(name, fnCache, fnCallback) {\n\n\tvar self = this;\n\tvar value = self.read2(name);\n\n\tif (value) {\n\t\tfnCallback && fnCallback(value, true);\n\t\treturn self;\n\t}\n\n\tfnCache(function(value, expire) {\n\t\tself.add(name, value, expire);\n\t\tfnCallback && fnCallback(value, false);\n\t});\n\n\treturn self;\n};\n\nfunction subscribe_timeout(req) {\n\treq.controller && req.controller.precache && req.controller.precache(null, null, null);\n\treq.$total_cancel();\n}\n\nfunction subscribe_timeout_middleware(req) {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\treq.$total_execute2();\n}\n\nfunction subscribe_validate_callback(req, code) {\n\treq.$total_execute(code);\n}\n\n/**\n * FrameworkController\n * @class\n * @param {String} name Controller name.\n * @param {Request} req\n * @param {Response} res\n * @param {FrameworkSubscribe} subscribe\n */\nfunction Controller(name, req, res, currentView) {\n\n\tthis.name = name;\n\t// this.exception;\n\n\t// Sets the default language\n\tif (req) {\n\t\tthis.language = req.$language;\n\t\tthis.req = req;\n\t\tthis.route = req.$total_route;\n\t} else\n\t\tthis.req = EMPTYREQUEST;\n\n\t// controller.type === 0 - classic\n\t// controller.type === 1 - server sent events\n\t// this.type = 0;\n\n\t// this.layoutName =CONF.default_layout;\n\t// this.themeName =CONF.default_theme;\n\t// this.status = 200;\n\n\t// this.isLayout = false;\n\t// this.isCanceled = false;\n\t// this.isTimeout = false;\n\t// this.isTransfer = false;\n\n\tthis.isConnected = true;\n\tthis.isController = true;\n\n\t// render output\n\t// this.output = null;\n\t// this.outputPartial = null;\n\t// this.$model = null;\n\n\tthis._currentView = currentView;\n\n\tif (res) {\n\t\tthis.res = res;\n\t\tthis.req.controller = this.res.controller = this;\n\t} else\n\t\tthis.res = EMPTYOBJECT;\n}\n\nController.prototype = {\n\n\tget repository() {\n\t\tif (this.$repository)\n\t\t\treturn this.$repository;\n\t\telse\n\t\t\treturn this.$repository ? this.$repository : (this.$repository = {});\n\t},\n\n\tset repository(val) {\n\t\tthis.$repository = val;\n\t},\n\n\tget schema() {\n\t\treturn this.route.schema[0] === 'default' ? this.route.schema[1] : this.route.schema.join('/');\n\t},\n\n\tget workflow() {\n\t\treturn this.route.schema_workflow;\n\t},\n\n\tget sseID() {\n\t\treturn this.req.headers['last-event-id'] || null;\n\t},\n\n\tget options() {\n\t\treturn this.route.options;\n\t},\n\n\tget split() {\n\t\treturn this.req.split;\n\t},\n\n\tget flags() {\n\t\treturn this.route.flags;\n\t},\n\n\tget path() {\n\t\tOBSOLETE('controller.path', 'Use: PATH');\n\t\treturn F.path;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget subdomain() {\n\t\treturn this.req.subdomain;\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget xhr() {\n\t\treturn this.req.xhr;\n\t},\n\n\tget url() {\n\t\treturn U.path(this.req.uri.pathname);\n\t},\n\n\tget uri() {\n\t\treturn this.req.uri;\n\t},\n\n\tget cache() {\n\t\tOBSOLETE('controller.cache', 'Use: F.cache or CACHE()');\n\t\treturn F.cache;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn CONF;\n\t},\n\n\tget controllers() {\n\t\treturn F.controllers;\n\t},\n\n\tget isTest() {\n\t\treturn this.req.headers['x-assertion-testing'] === '1';\n\t},\n\n\tget isSecure() {\n\t\tOBSOLETE('controller.isSecure', 'Use: controller.secured');\n\t\treturn this.req.isSecure;\n\t},\n\n\tget secured() {\n\t\treturn this.req.secured;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tset session(value) {\n\t\tthis.req.session = value;\n\t},\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tget referrer() {\n\t\treturn this.req.headers['referer'] || '';\n\t},\n\n\tset user(value) {\n\t\tthis.req.user = value;\n\t},\n\n\tget mobile() {\n\t\treturn this.req.mobile;\n\t},\n\n\tget robot() {\n\t\treturn this.req.robot;\n\t},\n\n\tget viewname() {\n\t\tvar name = this.req.path[this.req.path.length - 1];\n\t\treturn !name || name === '/' ? 'index' : name;\n\t},\n\n\tget sitemapid() {\n\t\treturn this.$sitemapid || this.route.sitemap;\n\t},\n\n\tget params() {\n\t\tif (this.$params)\n\t\t\treturn this.$params;\n\t\tvar route = this.route;\n\t\tvar names = route.paramnames;\n\t\tif (names) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < names.length; i++)\n\t\t\t\tobj[names[i]] = this.req.split[route.param[i]];\n\t\t\tthis.$params = obj;\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tthis.$params = EMPTYOBJECT;\n\t\t\treturn EMPTYOBJECT;\n\t\t}\n\t}\n};\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\n// Schema operations\n\nController.prototype.$get = Controller.prototype.$read = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tthis.getSchema().get(helper, callback, this);\n\treturn this;\n};\n\nController.prototype.$query = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tthis.getSchema().query(helper, callback, this);\n\treturn this;\n};\n\nController.prototype.$save = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$save(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$save(helper, callback);\n\t}\n\treturn self;\n};\n\nController.prototype.$insert = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$insert(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$insert(helper, callback);\n\t}\n\treturn self;\n};\n\nController.prototype.$update = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$update(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$update(helper, callback);\n\t}\n\treturn self;\n};\n\nController.prototype.$remove = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tself.getSchema().remove(helper, callback, self);\n\treturn this;\n};\n\nController.prototype.$workflow = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$workflow(name, helper, callback);\n\t} else\n\t\tself.getSchema().workflow2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$workflow2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tself.getSchema().workflow2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$hook = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$hook(name, helper, callback);\n\t} else\n\t\tself.getSchema().hook2(name, helper, callback, self);\n\n\treturn self;\n};\n\nController.prototype.$hook2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().hook2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$transform = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$transform(name, helper, callback);\n\t} else\n\t\tself.getSchema().transform2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$transform2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().transform2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$operation = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$operation(name, helper, callback);\n\t} else\n\t\tself.getSchema().operation2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.operation = function(name, value, callback, options) {\n\tOPERATION(name, value, callback, options, this);\n\treturn this;\n};\n\nController.prototype.tasks = function() {\n\tvar tb = new TaskBuilder(this);\n\t// tb.callback(this.callback());\n\treturn tb;\n};\n\nController.prototype.$operation2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().operation2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$exec = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tif (callback == null)\n\t\tcallback = self.callback();\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$exec(name, helper, callback);\n\t\treturn self;\n\t}\n\n\tvar tmp = self.getSchema().create();\n\ttmp.$$controller = self;\n\ttmp.$exec(name, helper, callback);\n\treturn self;\n};\n\nController.prototype.$async = function(callback, index) {\n\tvar self = this;\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\treturn self.body.$async(callback, index);\n\t}\n\n\tvar model = self.getSchema().default();\n\tmodel.$$controller = self;\n\treturn model.$async(callback, index);\n};\n\nController.prototype.getSchema = function() {\n\tvar route = this.route;\n\tif (!route.schema || !route.schema[1])\n\t\tthrow new Error('The controller\\'s route does not define any schema.');\n\tvar schema = route.isDYNAMICSCHEMA ? framework_builders.findschema(route.schema[0] + '/' + this.params[route.schema[1]]) : GETSCHEMA(route.schema[0], route.schema[1]);\n\tif (schema)\n\t\treturn schema;\n\tthrow new Error('Schema \"{0}\" does not exist.'.format(route.schema[1]));\n};\n\n/**\n * Renders component\n * @param {String} name A component name\n * @param {Object} settings Optional, settings.\n * @model {Object} settings Optional, model for the component.\n * @return {String}\n */\nController.prototype.component = function(name, settings, model) {\n\tvar filename = F.components.views[name];\n\tif (filename) {\n\t\tvar self = this;\n\t\tvar generator = framework_internal.viewEngine(name, filename, self, true);\n\t\tif (generator) {\n\t\t\tif (generator.components.length) {\n\t\t\t\tif (!self.repository[REPOSITORY_COMPONENTS])\n\t\t\t\t\tself.repository[REPOSITORY_COMPONENTS] = {};\n\t\t\t\tfor (var i = 0; i < generator.components.length; i++)\n\t\t\t\t\tself.repository[REPOSITORY_COMPONENTS][generator.components[i]] = 1;\n\t\t\t}\n\t\t\treturn generator.call(self, self, self.repository, model || self.$model, self.session, self.query, self.body, self.url, F.global, F.helpers, self.user, CONF, F.functions, 0, self.outputPartial, self.req.files, self.req.mobile, settings || EMPTYOBJECT);\n\t\t}\n\t}\n\treturn '';\n};\n\nController.prototype.$components = function(group, settings) {\n\n\tif (group) {\n\t\tvar keys = Object.keys(F.components.instances);\n\t\tvar output = [];\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar component = F.components.instances[keys[i]];\n\t\t\tif (component.group === group) {\n\t\t\t\tif (component.render) {\n\t\t\t\t\t!this.$viewasync && (this.$viewasync = []);\n\t\t\t\t\t$VIEWASYNC++;\n\t\t\t\t\tvar name = '@{-' + $VIEWASYNC + '-}';\n\t\t\t\t\tthis.$viewasync.push({ replace: name, name: component.name, settings: settings });\n\t\t\t\t\toutput.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tvar tmp = this.component(keys[i], settings);\n\t\t\t\t\ttmp && output.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output.join('\\n');\n\t}\n\n\treturn '';\n};\n\n/**\n * Reads / Writes cookie\n * @param {String} name\n * @param {String} value\n * @param {String/Date} expires\n * @param {Object} options\n * @return {String/Controller}\n */\nController.prototype.cookie = function(name, value, expires, options) {\n\tvar self = this;\n\tif (value === undefined)\n\t\treturn self.req.cookie(name);\n\tself.res.cookie(name, value, expires, options);\n\treturn self;\n};\n\n/**\n * Clears uploaded files\n * @return {Controller}\n */\nController.prototype.clear = function() {\n\tvar self = this;\n\tself.req.clear();\n\treturn self;\n};\n\n/**\n * Translates text\n * @param {String} text\n * @return {String}\n */\nController.prototype.translate = function(language, text) {\n\n\tif (!text) {\n\t\ttext = language;\n\t\tlanguage = this.language;\n\t}\n\n\treturn F.translate(language, text);\n};\n\n/**\n * Exec middleware\n * @param {String Array} names Middleware name.\n * @param {Object} options Custom options for middleware.\n * @param {Function} callback\n * @return {Controller}\n */\nController.prototype.middleware = function(names, options, callback) {\n\n\tif (typeof(names) === 'string')\n\t\tnames = [names];\n\n\tif (typeof(options) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = options;\n\t\toptions = tmp;\n\t}\n\n\tif (!options)\n\t\toptions = EMPTYOBJECT;\n\n\tvar self = this;\n\n\tif (self.req.$total_middleware)\n\t\tself.req.$total_middleware = null;\n\n\tasync_middleware(0, self.req, self.res, names, () => callback && callback(), options, self);\n\treturn self;\n};\n\n/**\n * Creates a pipe between the current request and target URL\n * @param {String} url\n * @param {Object} headers Optional, custom headers.\n * @param {Function(err)} callback Optional.\n * @return {Controller}\n */\nController.prototype.pipe = function(url, headers, callback) {\n\tthis.res.proxy(url, headers, null, callback);\n\treturn this;\n};\n\nController.prototype.encrypt = function() {\n\treturn F.encrypt.apply(framework, arguments);\n};\n\nController.prototype.decrypt = function() {\n\treturn F.decrypt.apply(framework, arguments);\n};\n\n/**\n * Creates a hash (alias for F.hash())\n * @return {Controller}\n */\nController.prototype.hash = function() {\n\treturn F.hash.apply(framework, arguments);\n};\n\n/**\n * Sets a response header\n * @param {String} name\n * @param {String} value\n * @return {Controller}\n */\nController.prototype.header = function(name, value) {\n\tthis.res.setHeader(name, value);\n\treturn this;\n};\n\n/**\n * Gets a hostname\n * @param {String} path\n * @return {Controller}\n */\nController.prototype.host = function(path) {\n\treturn this.req.hostname(path);\n};\n\nController.prototype.hostname = function(path) {\n\treturn this.req.hostname(path);\n};\n\nController.prototype.resource = function(name, key) {\n\treturn F.resource(name, key);\n};\n\n/**\n * Error caller\n * @param {Error/String} err\n * @return {Controller/Function}\n */\nController.prototype.error = function(err) {\n\tvar self = this;\n\n\t// Custom errors\n\tif (err instanceof ErrorBuilder) {\n\t\tself.content(err);\n\t\treturn self;\n\t}\n\n\tvar result = F.error(typeof(err) === 'string' ? new Error(err) : err, self.name, self.uri);\n\tif (err === undefined)\n\t\treturn result;\n\n\tself.req.$total_exception = err;\n\tself.exception = err;\n\treturn self;\n};\n\nController.prototype.invalid = function(status) {\n\n\tvar self = this;\n\n\tif (status instanceof ErrorBuilder) {\n\t\tsetImmediate(next_controller_invalid, self, status);\n\t\treturn status;\n\t}\n\n\tvar type = typeof(status);\n\n\tif (type === 'number')\n\t\tself.status = status;\n\n\tvar builder = new ErrorBuilder();\n\n\tif (type === 'string')\n\t\tbuilder.push(status);\n\n\tsetImmediate(next_controller_invalid, self, builder);\n\treturn builder;\n};\n\nfunction next_controller_invalid(self, builder) {\n\tself.content(builder);\n}\n\n/**\n * Registers a new problem\n * @param {String} message\n * @return {Controller}\n */\nController.prototype.wtf = Controller.prototype.problem = function(message) {\n\tF.problem(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Registers a new change\n * @param {String} message\n * @return {Controller}\n */\nController.prototype.change = function(message) {\n\tF.change(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Trace\n * @param {String} message\n * @return {Controller}\n */\nController.prototype.trace = function(message) {\n\tF.trace(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Transfer to new route\n * @param {String} url Relative URL.\n * @param {String Array} flags Route flags (optional).\n * @return {Boolean}\n */\nController.prototype.transfer = function(url, flags) {\n\n\tvar self = this;\n\tvar length = F.routes.web.length;\n\tvar path = framework_internal.routeSplit(url.trim());\n\n\tvar isSystem = url[0] === '#';\n\tvar noFlag = !flags || flags.length === 0 ? true : false;\n\tvar selected = null;\n\n\tself.req.$isAuthorized = true;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.web[i];\n\n\t\tif (route.isWILDCARD) {\n\t\t\tif (!framework_internal.routeCompare(path, route.url, isSystem, true))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!framework_internal.routeCompare(path, route.url, isSystem))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (noFlag) {\n\t\t\tselected = route;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags(route.flags, flags, true);\n\t\t\tif (result === -1)\n\t\t\t\tself.req.$isAuthorized = false;\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tselected = route;\n\t\tbreak;\n\t}\n\n\n\tif (!selected)\n\t\treturn false;\n\n\tself.cancel();\n\tself.req.path = EMPTYARRAY;\n\tself.req.$total_transfer = true;\n\tself.req.$total_success();\n\n\t// Because of dynamic params\n\t// Hidden variable\n\tself.req.$path = framework_internal.routeSplit(url, true);\n\n\tself.route = self.req.$total_route = selected;\n\tself.req.$total_execute(404);\n\treturn true;\n};\n\nController.prototype.cancel = function() {\n\tthis.isCanceled = true;\n\treturn this;\n};\n\nController.prototype.log = function() {\n\tF.log.apply(F, arguments);\n\treturn this;\n};\n\nController.prototype.logger = function() {\n\tF.logger.apply(F, arguments);\n\treturn this;\n};\n\nController.prototype.meta = function() {\n\tvar self = this;\n\n\tif (arguments[0])\n\t\tself.repository[REPOSITORY_META_TITLE] = arguments[0];\n\n\tif (arguments[1])\n\t\tself.repository[REPOSITORY_META_DESCRIPTION] = arguments[1];\n\n\tif (arguments[2] && arguments[2].length)\n\t\tself.repository[REPOSITORY_META_KEYWORDS] = arguments[2] instanceof Array ? arguments[2].join(', ') : arguments[2];\n\n\tif (arguments[3])\n\t\tself.repository[REPOSITORY_META_IMAGE] = arguments[3];\n\n\treturn self;\n};\n\nController.prototype.$dns = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"dns-prefetch\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nController.prototype.$prefetch = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"prefetch\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nController.prototype.$prerender = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"prerender\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nController.prototype.$next = function(value) {\n\tthis.head('<link rel=\"next\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nController.prototype.$prev = function(value) {\n\tthis.head('<link rel=\"prev\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nController.prototype.$canonical = function(value) {\n\tthis.head('<link rel=\"canonical\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nController.prototype.$meta = function() {\n\tvar self = this;\n\n\tif (arguments.length) {\n\t\tself.meta.apply(self, arguments);\n\t\treturn '';\n\t}\n\n\tF.$events['controller-render-meta'] && EMIT('controller-render-meta', self);\n\tvar repository = self.repository;\n\treturn F.onMeta.call(self, repository[REPOSITORY_META_TITLE], repository[REPOSITORY_META_DESCRIPTION], repository[REPOSITORY_META_KEYWORDS], repository[REPOSITORY_META_IMAGE]);\n};\n\nController.prototype.title = function(value) {\n\tthis.$title(value);\n\treturn this;\n};\n\nController.prototype.description = function(value) {\n\tthis.$description(value);\n\treturn this;\n};\n\nController.prototype.keywords = function(value) {\n\tthis.$keywords(value);\n\treturn this;\n};\n\nController.prototype.author = function(value) {\n\tthis.$author(value);\n\treturn this;\n};\n\nController.prototype.$title = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_TITLE] = value;\n\treturn '';\n};\n\nController.prototype.$title2 = function(value) {\n\tvar current = this.repository[REPOSITORY_META_TITLE];\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_TITLE] = (current ? current : '') + value;\n\treturn '';\n};\n\nController.prototype.$description = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_DESCRIPTION] = value;\n\treturn '';\n};\n\nController.prototype.$keywords = function(value) {\n\tif (value && value.length)\n\t\tthis.repository[REPOSITORY_META_KEYWORDS] = value instanceof Array ? value.join(', ') : value;\n\treturn '';\n};\n\nController.prototype.$author = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_AUTHOR] = value;\n\treturn '';\n};\n\nController.prototype.sitemap_navigation = function(name, language) {\n\treturn F.sitemap_navigation(name || this.sitemapid, language || this.language);\n};\n\nController.prototype.sitemap_url = function(name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, this.language);\n\treturn item ? item.url.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_name = function(name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, this.language);\n\treturn item ? item.name.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_url2 = function(language, name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, language);\n\treturn item ? item.url.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_name2 = function(language, name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, language);\n\treturn item ? item.name.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_add = function(parent, name, url) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tvar index = sitemap.findIndex('id', parent);\n\tif (index === -1)\n\t\treturn sitemap;\n\n\tvar obj = { sitemap: '', id: '', name: name, url: url, last: false, first: false, index: index, wildcard: false, formatName: false, formatUrl: false, localizeName: false, localizeUrl: false };\n\n\tsitemap.splice(index + 1, 0, obj);\n\n\tif (index) {\n\t\tvar tmp = index;\n\t\tfor (var i = index + 1; i > -1; i--)\n\t\t\tsitemap[i].index = tmp++;\n\t}\n\n\treturn sitemap;\n};\n\nController.prototype.sitemap_change = function(name, type, a, b, c, d, e, f) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tif (!sitemap.$cloned) {\n\t\tsitemap = U.clone(sitemap);\n\t\tsitemap.$cloned = true;\n\t\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\t}\n\n\tvar isFn = typeof(a) === 'function';\n\n\tfor (var i = 0, length = sitemap.length; i < length; i++) {\n\n\t\tvar item = sitemap[i];\n\t\tif (item.id !== name)\n\t\t\tcontinue;\n\n\t\tvar tmp = item[type];\n\n\t\tif (isFn)\n\t\t\titem[type] = a(item[type]);\n\t\telse if (type === 'name')\n\t\t\titem[type] = item.formatName ? item[type].format(a, b, c, d, e, f) : a;\n\t\telse if (type === 'url')\n\t\t\titem[type] = item.formatUrl ? item[type].format(a, b, c, d, e, f) : a;\n\t\telse\n\t\t\titem[type] = a;\n\n\t\tif (type === 'name' && self.repository[REPOSITORY_META_TITLE] === tmp)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = item[type];\n\n\t\treturn sitemap;\n\t}\n\n\treturn sitemap;\n};\n\nController.prototype.sitemap_replace = function(name, title, url) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tif (!sitemap.$cloned) {\n\t\tsitemap = U.clone(sitemap);\n\t\tsitemap.$cloned = true;\n\t\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\t}\n\n\tfor (var i = 0, length = sitemap.length; i < length; i++) {\n\t\tvar item = sitemap[i];\n\t\tif (item.id !== name)\n\t\t\tcontinue;\n\n\t\tvar is = self.repository[REPOSITORY_META_TITLE] === item.name;\n\n\t\tif (title)\n\t\t\titem.name = typeof(title) === 'function' ? title(item.name) : item.formatName ? item.name.format(title) : title;\n\n\t\tif (url)\n\t\t\titem.url = typeof(url) === 'function' ? url(item.url) : item.formatUrl ? item.url.format(url) : url;\n\n\t\tif (is)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = item.name;\n\n\t\treturn sitemap;\n\t}\n\n\treturn sitemap;\n};\n\n// Arguments: parent, name, url\nController.prototype.$sitemap_add = function(parent, name, url) {\n\tthis.sitemap_add(parent, name, url);\n\treturn '';\n};\n\n// Arguments: name, type, value, format\nController.prototype.$sitemap_change = function(a, b, c, d, e, f, g, h) {\n\tthis.sitemap_change(a, b, c, d, e, f, g, h);\n\treturn '';\n};\n\n// Arguments: name, title, url\nController.prototype.$sitemap_replace =function(a, b, c) {\n\tthis.sitemap_replace(a, b, c);\n\treturn '';\n};\n\nController.prototype.sitemap = function(name) {\n\tvar self = this;\n\tvar sitemap;\n\n\tif (!name) {\n\t\tsitemap = self.repository[REPOSITORY_SITEMAP];\n\t\tif (!sitemap && (self.$sitemapid || self.route.sitemap))\n\t\t\treturn self.sitemap(self.$sitemapid || self.route.sitemap);\n\t\treturn sitemap ? sitemap : self.repository.sitemap || EMPTYARRAY;\n\t}\n\n\tif (name instanceof Array) {\n\t\tself.repository[REPOSITORY_SITEMAP] = name;\n\t\treturn self;\n\t}\n\n\tself.$sitemapid = name;\n\tsitemap = U.clone(F.sitemap(name, false, self.language));\n\tsitemap.$cloned = true;\n\n\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\n\tif (!self.repository[REPOSITORY_META_TITLE]) {\n\t\tsitemap = sitemap.last();\n\t\tif (sitemap)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = sitemap.name;\n\t}\n\n\treturn self.repository[REPOSITORY_SITEMAP];\n};\n\n// Arguments: name\nController.prototype.$sitemap = function(name) {\n\tvar self = this;\n\tself.sitemap(name);\n\treturn '';\n};\n\nController.prototype.module = function(name) {\n\treturn F.module(name);\n};\n\nController.prototype.layout = function(name) {\n\tvar self = this;\n\tself.layoutName = name;\n\treturn self;\n};\n\nController.prototype.theme = function(name) {\n\tvar self = this;\n\tself.themeName = name;\n\treturn self;\n};\n\n/**\n * Layout setter for views\n * @param {String} name Layout name\n * @return {String}\n */\nController.prototype.$layout = function(name) {\n\tvar self = this;\n\tself.layoutName = name;\n\treturn '';\n};\n\nController.prototype.model = function(name) {\n\treturn F.model(name);\n};\n\n/**\n * Send e-mail\n * @param {String or Array} address E-mail address.\n * @param {String} subject E-mail subject.\n * @param {String} view View name.\n * @param {Object} model Optional.\n * @param {Function(err)} callback Optional.\n * @return {MailMessage}\n */\nController.prototype.mail = function(address, subject, view, model, callback) {\n\n\tif (typeof(model) === 'function') {\n\t\tcallback = model;\n\t\tmodel = null;\n\t}\n\n\tvar self = this;\n\n\tif (typeof(self.language) === 'string')\n\t\tsubject = subject.indexOf('@(') === -1 ? F.translate(self.language, subject) : F.translator(self.language, subject);\n\n\t// Backup layout\n\tvar layoutName = self.layoutName;\n\tvar body = self.view(view, model, true);\n\n\tvar message;\n\n\tif (body instanceof Function) {\n\t\tmessage = F.onMail(address, subject, '');\n\t\tmessage.manually();\n\t\tbody(function(err, body) {\n\t\t\tmessage.body = body;\n\t\t\tmessage.send2(callback);\n\t\t});\n\t} else {\n\t\tmessage = F.onMail(address, subject, body, callback);\n\t\tself.layoutName = layoutName;\n\t}\n\n\treturn message;\n};\n\nController.prototype.$template = function(name, model, expire, key) {\n\treturn this.$viewToggle(true, name, model, expire, key);\n};\n\nController.prototype.$templateToggle = function(visible, name, model, expire, key) {\n\treturn this.$viewToggle(visible, name, model, expire, key);\n};\n\nController.prototype.$view = function(name, model, expire, key) {\n\n\tvar self = this;\n\tvar cache;\n\n\tif (expire) {\n\t\tcache = '$view.' + name + '.' + (key || '');\n\t\tvar output = F.cache.read2(cache);\n\t\tif (output)\n\t\t\treturn output.body;\n\t}\n\n\tvar value = self.view(name, model, null, true, true, cache);\n\n\tif (!value)\n\t\treturn '';\n\n\texpire && F.cache.add(cache, { components: value instanceof Function, body: value instanceof Function ? '' : value }, expire, false);\n\treturn value;\n};\n\nController.prototype.$viewCompile = function(body, model, key) {\n\tvar self = this;\n\tvar layout = self.layoutName;\n\tself.layoutName = '';\n\tvar value = self.viewCompile(body, model, null, true, key);\n\tself.layoutName = layout;\n\treturn value || '';\n};\n\nController.prototype.$viewToggle = function(visible, name, model, expire, key, async) {\n\treturn visible ? this.$view(name, model, expire, key, async) : '';\n};\n\n/**\n * Adds a place into the places.\n * @param {String} name A place name.\n * @param {String} arg1 A content 1, optional\n * @param {String} arg2 A content 2, optional\n * @param {String} argN A content 2, optional\n * @return {String/Controller} String is returned when the method contains only `name` argument\n */\nController.prototype.place = function(name) {\n\n\tvar key = REPOSITORY_PLACE + '_' + name;\n\tvar length = arguments.length;\n\n\tif (length === 1)\n\t\treturn this.repository[key] || '';\n\n\tvar output = '';\n\tfor (var i = 1; i < length; i++) {\n\t\tvar val = arguments[i];\n\n\t\tif (val)\n\t\t\tval = val.toString();\n\t\telse\n\t\t\tval = '';\n\n\t\tswitch (U.getExtension(val)) {\n\t\t\tcase 'js':\n\t\t\t\tval = '<script src=\"' + val + '\"></script>';\n\t\t\t\tbreak;\n\t\t\tcase 'css':\n\t\t\t\tval = '<link rel=\"stylesheet\" href=\"' + val + '\" />';\n\t\t\t\tbreak;\n\t\t}\n\n\t\toutput += val;\n\t}\n\n\tthis.repository[key] = (this.repository[key] || '') + output;\n\treturn this;\n};\n\n/**\n * Adds a content into the section\n * @param {String} name A section name.\n * @param {String} value A content.\n * @param {Boolean} replace Optional, default `false` otherwise concats contents.\n * @return {String/Controller} String is returned when the method contains only `name` argument\n */\nController.prototype.section = function(name, value, replace) {\n\n\tvar key = '$section_' + name;\n\n\tif (value === undefined)\n\t\treturn this.repository[key];\n\n\tif (replace) {\n\t\tthis.repository[key] = value;\n\t\treturn this;\n\t}\n\n\tif (this.repository[key])\n\t\tthis.repository[key] += value;\n\telse\n\t\tthis.repository[key] = value;\n\n\treturn this;\n};\n\nController.prototype.$place = function() {\n\tvar self = this;\n\tif (arguments.length === 1)\n\t\treturn self.place.apply(self, arguments);\n\tself.place.apply(self, arguments);\n\treturn '';\n};\n\nController.prototype.$url = function(host) {\n\treturn host ? this.req.hostname(this.url) : this.url;\n};\n\n// Argument: name\nController.prototype.$helper = function() {\n\treturn this.helper.apply(this, arguments);\n};\n\nfunction querystring_encode(value, def, key) {\n\n\tif (value instanceof Array) {\n\t\tvar tmp = '';\n\t\tfor (var i = 1; i < value.length; i++)\n\t\t\ttmp += (tmp ? '&' : '') + key + '=' + querystring_encode(value[i], def);\n\t\treturn querystring_encode(value[0], def) + (tmp ? tmp : '');\n\t}\n\n\treturn value != null ? value instanceof Date ? encodeURIComponent(value.format()) : typeof(value) === 'string' ? encodeURIComponent(value) : value.toString() : def || '';\n}\n\n// @{href({ key1: 1, key2: 2 })}\n// @{href('key', 'value')}\nController.prototype.href = function(key, value) {\n\tvar self = this;\n\n\tif (!arguments.length) {\n\t\tvar val = Qs.stringify(self.query);\n\t\treturn val ? '?' + val : '';\n\t}\n\n\tvar type = typeof(key);\n\tvar obj;\n\n\tif (type === 'string') {\n\n\t\tvar cachekey = '$href' + key;\n\t\tvar str = self[cachekey] || '';\n\n\t\tif (!str) {\n\n\t\t\tobj = U.copy(self.query);\n\n\t\t\tfor (var i = 2; i < arguments.length; i++)\n\t\t\t\tobj[arguments[i]] = undefined;\n\n\t\t\tobj[key] = '\\0';\n\n\t\t\tvar arr = Object.keys(obj);\n\t\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\t\tvar val = obj[arr[i]];\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tif (val instanceof Array) {\n\t\t\t\t\t\tfor (var j = 0; j < val.length; j++)\n\t\t\t\t\t\t\tstr += (str ? '&' : '') + arr[i] + '=' + (key === arr[i] ? '\\0' : querystring_encode(val[j]));\n\t\t\t\t\t} else\n\t\t\t\t\t\tstr += (str ? '&' : '') + arr[i] + '=' + (key === arr[i] ? '\\0' : querystring_encode(val));\n\t\t\t\t}\n\t\t\t}\n\t\t\tself[cachekey] = str;\n\t\t}\n\n\t\tstr = str.replace('\\0', querystring_encode(value, self.query[key], key));\n\n\t\tfor (var i = 2; i < arguments.length; i++) {\n\t\t\tvar beg = str.indexOf(arguments[i] + '=');\n\t\t\tif (beg === -1)\n\t\t\t\tcontinue;\n\t\t\tvar end = str.indexOf('&', beg);\n\t\t\tstr = str.substring(0, beg) + str.substring(end === -1 ? str.length : end + 1);\n\t\t}\n\n\t\treturn str ? '?' + str : '';\n\t}\n\n\tif (value) {\n\t\tobj = U.copy(self.query);\n\t\tU.extend(obj, value);\n\t}\n\n\tif (value != null)\n\t\tobj[key] = value;\n\n\tobj = Qs.stringify(obj);\n\n\tif (value === undefined && type === 'string')\n\t\tobj += (obj ? '&' : '') + key;\n\n\treturn self.url + (obj ? '?' + obj : '');\n};\n\nController.prototype.$checked = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'checked=\"checked\"');\n};\n\nController.prototype.$disabled = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'disabled=\"disabled\"');\n};\n\nController.prototype.$selected = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'selected=\"selected\"');\n};\n\n/**\n * Fake function for assign value\n * @private\n * @param {Object} value Value to eval.\n * return {String} Returns empty string.\n */\n// Argument: value\nController.prototype.$set = function() {\n\treturn '';\n};\n\nController.prototype.$readonly = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'readonly=\"readonly\"');\n};\n\nController.prototype.$header = function(name, value) {\n\tthis.header(name, value);\n\treturn '';\n};\n\nController.prototype.$text = function(model, name, attr) {\n\treturn this.$input(model, 'text', name, attr);\n};\n\nController.prototype.$password = function(model, name, attr) {\n\treturn this.$input(model, 'password', name, attr);\n};\n\nController.prototype.$hidden = function(model, name, attr) {\n\treturn this.$input(model, 'hidden', name, attr);\n};\n\nController.prototype.$radio = function(model, name, value, attr) {\n\n\tif (typeof(attr) === 'string') {\n\t\tvar label = attr;\n\t\tattr = SINGLETON('!$radio');\n\t\tattr.label = label;\n\t}\n\n\tattr.value = value;\n\treturn this.$input(model, 'radio', name, attr);\n};\n\nController.prototype.$checkbox = function(model, name, attr) {\n\n\tif (typeof(attr) === 'string') {\n\t\tvar label = attr;\n\t\tattr = SINGLETON('!$checkbox');\n\t\tattr.label = label;\n\t}\n\n\treturn this.$input(model, 'checkbox', name, attr);\n};\n\nController.prototype.$textarea = function(model, name, attr) {\n\n\tvar builder = '<textarea';\n\n\tif (typeof(attr) !== 'object')\n\t\tattr = EMPTYOBJECT;\n\n\tbuilder += ' name=\"' + name + '\" id=\"' + (attr.id || name) + ATTR_END;\n\n\tfor (var key in attr) {\n\t\tswitch (key) {\n\t\t\tcase 'name':\n\t\t\tcase 'id':\n\t\t\t\tbreak;\n\t\t\tcase 'required':\n\t\t\tcase 'disabled':\n\t\t\tcase 'readonly':\n\t\t\tcase 'value':\n\t\t\t\tbuilder += ' ' + key + '=\"' + key + ATTR_END;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += ' ' + key + '=\"' + attr[key].toString().encode() + ATTR_END;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (model === undefined)\n\t\treturn builder + '></textarea>';\n\n\treturn builder + '>' + ((model[name] || attr.value) || '') + '</textarea>';\n};\n\nController.prototype.$input = function(model, type, name, attr) {\n\n\tvar builder = ['<input'];\n\n\tif (typeof(attr) !== 'object')\n\t\tattr = EMPTYOBJECT;\n\n\tvar val = attr.value || '';\n\n\tbuilder += ' type=\"' + type + ATTR_END;\n\n\tif (type === 'radio')\n\t\tbuilder += ' name=\"' + name + ATTR_END;\n\telse\n\t\tbuilder += ' name=\"' + name + '\" id=\"' + (attr.id || name) + ATTR_END;\n\n\tif (attr.autocomplete) {\n\t\tif (attr.autocomplete === true || attr.autocomplete === 'on')\n\t\t\tbuilder += ' autocomplete=\"on\"';\n\t\telse\n\t\t\tbuilder += ' autocomplete=\"off\"';\n\t}\n\n\tfor (var key in attr) {\n\t\tswitch (key) {\n\t\t\tcase 'name':\n\t\t\tcase 'id':\n\t\t\tcase 'type':\n\t\t\tcase 'autocomplete':\n\t\t\tcase 'checked':\n\t\t\tcase 'value':\n\t\t\tcase 'label':\n\t\t\t\tbreak;\n\t\t\tcase 'required':\n\t\t\tcase 'disabled':\n\t\t\tcase 'readonly':\n\t\t\tcase 'autofocus':\n\t\t\t\tbuilder += ' ' + key + '=\"' + key + ATTR_END;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += ' ' + key + '=\"' + attr[key].toString().encode() + ATTR_END;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar value = '';\n\n\tif (model !== undefined) {\n\t\tvalue = model[name];\n\n\t\tif (type === 'checkbox') {\n\t\t\tif (value == '1' || value === 'true' || value === true || value === 'on')\n\t\t\t\tbuilder += ' checked=\"checked\"';\n\t\t\tvalue = val || '1';\n\t\t}\n\n\t\tif (type === 'radio') {\n\n\t\t\tval = (val || '').toString();\n\n\t\t\tif (value.toString() === val)\n\t\t\t\tbuilder += ' checked=\"checked\"';\n\n\t\t\tvalue = val || '';\n\t\t}\n\t}\n\n\tif (value === undefined)\n\t\tbuilder += ' value=\"' + (attr.value || '').toString().encode() + ATTR_END;\n\telse\n\t\tbuilder += ' value=\"' + (value || '').toString().encode() + ATTR_END;\n\n\tbuilder += ' />';\n\treturn attr.label ? ('<label>' + builder + ' <span>' + attr.label + '</span></label>') : builder;\n};\n\nController.prototype._preparehostname = function(value) {\n\tif (!value)\n\t\treturn value;\n\tvar tmp = value.substring(0, 5);\n\treturn tmp !== 'http:' && tmp !== 'https' && (tmp[0] !== '/' || tmp[1] !== '/') ? this.host(value) : value;\n};\n\nController.prototype.head = function() {\n\n\tvar self = this;\n\n\tif (!arguments.length) {\n\t\tvar author = self.repository[REPOSITORY_META_AUTHOR] || CONF.author;\n\t\tvar plus = '';\n\t\tvar components = self.repository[REPOSITORY_COMPONENTS];\n\t\tif (components) {\n\t\t\tvar keys = Object.keys(components);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar com = F.components.groups[keys[i]];\n\t\t\t\tif (com)\n\t\t\t\t\tplus += com.links;\n\t\t\t}\n\t\t}\n\t\treturn (author ? '<meta name=\"author\" content=\"' + author + '\" />' : '') + (self.repository[REPOSITORY_HEAD] || '') + plus;\n\t}\n\n\tvar header = (self.repository[REPOSITORY_HEAD] || '');\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\tvar val = arguments[i];\n\t\tvar key = '$head-' + val;\n\n\t\tif (self.repository[key])\n\t\t\tcontinue;\n\n\t\tself.repository[key] = true;\n\n\t\tif (val[0] === '<') {\n\t\t\theader += val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar tmp = val.substring(0, 7);\n\t\tvar is = (tmp[0] !== '/' && tmp[1] !== '/') && tmp !== 'http://' && tmp !== 'https:/';\n\t\tvar ext = U.getExtension(val);\n\t\tif (ext === 'css')\n\t\t\theader += '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + (is ? self.routeStyle(val) : val) + '\" />';\n\t\telse if (ext === 'js')\n\t\t\theader += '<script src=\"' + (is ? self.routeScript(val) : val) + '\"></script>';\n\t}\n\n\tself.repository[REPOSITORY_HEAD] = header;\n\treturn self;\n};\n\nController.prototype.$head = function() {\n\tthis.head.apply(this, arguments);\n\treturn '';\n};\n\nController.prototype.$isValue = function(bool, charBeg, charEnd, value) {\n\tif (!bool)\n\t\treturn '';\n\tcharBeg = charBeg || ' ';\n\tcharEnd = charEnd || '';\n\treturn charBeg + value + charEnd;\n};\n\nController.prototype.$options = function(arr, selected, name, value, disabled) {\n\n\tvar type = typeof(arr);\n\tif (!arr)\n\t\treturn '';\n\n\tvar isObject = false;\n\tvar tmp = null;\n\n\tif (!(arr instanceof Array) && type === 'object') {\n\t\tisObject = true;\n\t\ttmp = arr;\n\t\tarr = Object.keys(arr);\n\t}\n\n\tif (!(arr instanceof Array))\n\t\tarr = [arr];\n\n\tselected = selected || '';\n\n\tvar options = '';\n\n\tif (!isObject) {\n\t\tif (value == null)\n\t\t\tvalue = value || name || 'value';\n\t\tif (name == null)\n\t\t\tname = 'name';\n\t\tif (disabled == null)\n\t\t\tdisabled = 'disabled';\n\t}\n\n\tvar isSelected = false;\n\tvar length = 0;\n\n\tlength = arr.length;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar o = arr[i];\n\t\tvar type = typeof(o);\n\t\tvar text = '';\n\t\tvar val = '';\n\t\tvar sel = false;\n\t\tvar dis = false;\n\n\t\tif (isObject) {\n\t\t\tif (name === true) {\n\t\t\t\tval = tmp[o];\n\t\t\t\ttext = o;\n\t\t\t\tif (!value)\n\t\t\t\t\tvalue = '';\n\t\t\t} else {\n\t\t\t\tval = o;\n\t\t\t\ttext = tmp[o];\n\t\t\t\tif (!text)\n\t\t\t\t\ttext = '';\n\t\t\t}\n\n\t\t} else if (type === 'object') {\n\n\t\t\ttext = (o[name] || '');\n\t\t\tval = (o[value] || '');\n\n\t\t\tif (typeof(text) === 'function')\n\t\t\t\ttext = text(i);\n\n\t\t\tif (typeof(val) === 'function')\n\t\t\t\tval = val(i, text);\n\n\t\t\tdis = o[disabled];\n\n\t\t\tif (typeof(disabled) === 'function')\n\t\t\t\tdis = disabled(i, val, text);\n\t\t\telse\n\t\t\t\tdis = dis ? true : false;\n\n\t\t} else {\n\t\t\ttext = o;\n\t\t\tval = o;\n\t\t}\n\n\t\tif (!isSelected) {\n\t\t\tsel = val == selected;\n\t\t\tisSelected = sel;\n\t\t}\n\n\t\toptions += '<option value=\"' + val.toString().encode() + '\"' + (sel ? ' selected=\"selected\"' : '') + (dis ? ' disabled=\"disabled\"' : '') + '>' + text.toString().encode() + '</option>';\n\t}\n\n\treturn options;\n};\n\n/**\n * Append <script> TAG\n * @private\n * @return {String}\n */\nController.prototype.$script = function() {\n\treturn arguments.length === 1 ? this.$js(arguments[0]) : this.$js.apply(this, arguments);\n};\n\n/**\n * Append <script> TAG\n * @private\n * @return {String}\n */\nController.prototype.$js = function() {\n\tvar self = this;\n\tvar builder = '';\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tbuilder += self.routeScript(arguments[i], true);\n\treturn builder;\n};\n\n/**\n * Append <script> or <style> TAG\n * @private\n * @return {String}\n */\nController.prototype.$absolute = function(files, base) {\n\n\tvar self = this;\n\tvar builder;\n\tvar ftype;\n\n\tif (!base)\n\t\tbase = self.hostname();\n\n\tif (files instanceof Array) {\n\n\t\tftype = U.getExtension(files[0]);\n\t\tbuilder = '';\n\n\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\tswitch (ftype) {\n\t\t\t\tcase 'js':\n\t\t\t\t\tbuilder += self.routeScript(files[i], true, base);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'css':\n\t\t\t\t\tbuilder += self.routeStyle(files[i], true, base);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuilder += self.routeStatic(files[i], base);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn builder;\n\t}\n\n\tftype = U.getExtension(files);\n\n\tswitch (ftype) {\n\t\tcase 'js':\n\t\t\treturn self.routeScript(files, true, base);\n\t\tcase 'css':\n\t\t\treturn self.routeStyle(files, true, base);\n\t}\n\n\treturn self.routeStatic(files, base);\n};\n\nController.prototype.$import = function() {\n\n\tvar self = this;\n\tvar builder = '';\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar filename = arguments[i];\n\n\t\tif (filename === 'head') {\n\t\t\tbuilder += self.head();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'meta') {\n\t\t\tbuilder += self.$meta();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'components' && F.components.has) {\n\t\t\t// Generated in controller.head()\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'manifest' || filename === 'manifest.json') {\n\t\t\tbuilder += '<link rel=\"manifest\" href=\"' + F.$version('/manifest.json') + '\">';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'favicon.ico' || filename === 'favicon.png') {\n\t\t\tbuilder += self.$favicon(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename[0] === 'l' && filename[9] === 'd' && filename.substring(0, 10) === 'livereload') {\n\t\t\tif (DEBUG) {\n\t\t\t\tvar url = filename.substring(11).trim();\n\t\t\t\tbuilder += '<script src=\"//cdn.totaljs.com/livereload.js\"' + (url ? (' data-url=\"' + url + '\"') : '') + '></script>';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar extension = filename.substring(filename.lastIndexOf('.'));\n\t\tvar tag = filename[0] !== '!';\n\t\tif (!tag)\n\t\t\tfilename = filename.substring(1);\n\n\t\tif (filename[0] === '#')\n\t\t\textension = '.js';\n\n\t\tswitch (extension) {\n\t\t\tcase '.js':\n\t\t\t\tbuilder += self.routeScript(filename, tag);\n\t\t\t\tbreak;\n\t\t\tcase '.css':\n\t\t\t\tbuilder += self.routeStyle(filename, tag);\n\t\t\t\tbreak;\n\t\t\tcase '.ico':\n\t\t\t\tbuilder += self.$favicon(filename);\n\t\t\t\tbreak;\n\t\t\tcase '.jpg':\n\t\t\tcase '.gif':\n\t\t\tcase '.svg':\n\t\t\tcase '.png':\n\t\t\tcase '.jpeg':\n\t\t\tcase '.heif':\n\t\t\tcase '.webp':\n\t\t\tcase '.heic':\n\t\t\tcase '.apng':\n\t\t\t\tbuilder += self.routeImage(filename);\n\t\t\t\tbreak;\n\t\t\tcase '.mp4':\n\t\t\tcase '.avi':\n\t\t\tcase '.ogv':\n\t\t\tcase '.webm':\n\t\t\tcase '.mov':\n\t\t\tcase '.mpg':\n\t\t\tcase '.mpe':\n\t\t\tcase '.mpeg':\n\t\t\tcase '.m4v':\n\t\t\t\tbuilder += self.routeVideo(filename);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += self.routeStatic(filename);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder;\n};\n\n/**\n * Append <link> TAG\n * @private\n * @return {String}\n */\nController.prototype.$css = function() {\n\n\tvar self = this;\n\tvar builder = '';\n\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tbuilder += self.routeStyle(arguments[i], true);\n\n\treturn builder;\n};\n\nController.prototype.$image = function(name, width, height, alt, className) {\n\n\tvar style = '';\n\n\tif (typeof(width) === 'object') {\n\t\theight = width.height;\n\t\talt = width.alt;\n\t\tclassName = width.class;\n\t\tstyle = width.style;\n\t\twidth = width.width;\n\t}\n\n\tvar builder = '<img src=\"' + this.routeImage(name) + ATTR_END;\n\n\tif (width > 0)\n\t\tbuilder += ' width=\"' + width + ATTR_END;\n\n\tif (height > 0)\n\t\tbuilder += ' height=\"' + height + ATTR_END;\n\n\tif (alt)\n\t\tbuilder += ' alt=\"' + alt.encode() + ATTR_END;\n\n\tif (className)\n\t\tbuilder += ' class=\"' + className + ATTR_END;\n\n\tif (style)\n\t\tbuilder += ' style=\"' + style + ATTR_END;\n\n\treturn builder + ' border=\"0\" />';\n};\n\n/**\n * Create URL: DOWNLOAD (<a href=\"...\" download=\"...\")\n * @private\n * @param {String} filename\n * @param {String} innerHTML\n * @param {String} downloadName Optional.\n * @param {String} className Optional.\n * @return {String}\n */\nController.prototype.$download = function(filename, innerHTML, downloadName, className) {\n\tvar builder = '<a href=\"' + F.routeDownload(filename) + ATTR_END;\n\n\tif (downloadName)\n\t\tbuilder += ' download=\"' + downloadName + ATTR_END;\n\n\tif (className)\n\t\tbuilder += ' class=\"' + className + ATTR_END;\n\n\treturn builder + '>' + (innerHTML || filename) + '</a>';\n};\n\n/**\n * Serialize object into the JSON\n * @private\n * @param {Object} obj\n * @param {String} id Optional.\n * @param {Boolean} beautify Optional.\n * @return {String}\n */\nController.prototype.$json = function(obj, id, beautify, replacer) {\n\n\tif (typeof(id) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = id;\n\t\tid = null;\n\t}\n\n\tif (typeof(beautify) === 'function') {\n\t\treplacer = beautify;\n\t\tbeautify = false;\n\t}\n\n\tif (framework_builders.isSchema(obj))\n\t\tobj = obj.$clean();\n\n\tvar value = beautify ? JSON.stringify(obj, replacer, 4) : JSON.stringify(obj, replacer);\n\treturn id ? ('<script type=\"application/json\" id=\"' + id + '\">' + value + '</script>') : value;\n};\n\n/**\n * Append FAVICON tag\n * @private\n * @param {String} name\n * @return {String}\n */\nController.prototype.$favicon = function(name) {\n\n\tvar contentType = 'image/x-icon';\n\n\tif (!name)\n\t\tname = 'favicon.ico';\n\n\tvar key = 'favicon#' + name;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (name.lastIndexOf('.png') !== -1)\n\t\tcontentType = 'image/png';\n\telse if (name.lastIndexOf('.gif') !== -1)\n\t\tcontentType = 'image/gif';\n\n\treturn F.temporary.other[key] = '<link rel=\"icon\" href=\"' + F.routeStatic('/' + name) + '\" type=\"' + contentType + '\" />';\n};\n\n/**\n * Route static file helper\n * @private\n * @param {String} current\n * @param {String} name\n * @param {Function} fn\n * @return {String}\n */\nController.prototype._routeHelper = function(name, fn) {\n\treturn fn.call(framework, prepare_staticurl(name, false), this.themeName);\n};\n\n/**\n * Create URL: JavaScript\n * @param {String} name\n * @param {Boolean} tag Optional, default \"false\"\n * @param {String} path Optional, default undefined\n * @return {String}\n */\nController.prototype.routeScript = function(name, tag, path) {\n\n\tif (name === undefined)\n\t\tname = 'default.js';\n\n\tvar async = false;\n\tvar url;\n\n\t// Checks \"async \"\n\tif (tag && name[0] === 'a' && name[5] === ' ') {\n\t\tasync = true;\n\t\tname = name.substring(6);\n\t}\n\n\t// Isomorphic\n\tif (name[0] === '#') {\n\t\tvar tmp = F.isomorphic[name.substring(1)];\n\t\tif (tmp)\n\t\t\turl = tmp.url;\n\t\telse {\n\t\t\tF.error('Isomorphic library {0} doesn\\'t exist.'.format(name.substring(1)));\n\t\t\treturn '';\n\t\t}\n\t} else {\n\t\turl = this._routeHelper(name, F.routeScript);\n\t\tif (path && U.isRelative(url))\n\t\t\turl = F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\t}\n\n\treturn tag ? ('<script src=\"' + url + '\"' + (async ? ' async' : '') + '></script>') : url;\n};\n\n/**\n * Create URL: CSS\n * @param {String} name\n * @param {Boolean} tag Append tag?\n * @return {String}\n */\nController.prototype.routeStyle = function(name, tag, path) {\n\tvar self = this;\n\n\tif (name === undefined)\n\t\tname = 'default.css';\n\n\tvar url = self._routeHelper(name, F.routeStyle);\n\tif (path && U.isRelative(url))\n\t\turl = F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\n\treturn tag ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + url + '\" />' : url;\n};\n\n/**\n * Create URL: IMG\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeImage = function(name) {\n\treturn this._routeHelper(name, F.routeImage);\n};\n\n/**\n * Create URL: VIDEO\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeVideo = function(name) {\n\treturn this._routeHelper(name, F.routeVideo);\n};\n\n/**\n * Create URL: FONT\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeFont = function(name) {\n\treturn F.routeFont(name);\n};\n\n/**\n * Create URL: DOWNLOAD\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeDownload = function(name) {\n\treturn this._routeHelper(name, F.routeDownload);\n};\n\n/**\n * Create URL: static files (by the config['static-url'])\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeStatic = function(name, path) {\n\tvar url = this._routeHelper(name, F.routeStatic);\n\tif (path && U.isRelative(url))\n\t\treturn F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\treturn url;\n};\n\n/**\n * Creates a string from the view\n * @param {String} name A view name without `.html` extension.\n * @param {Object} model A model, optional.\n * @return {String}\n */\nController.prototype.template = function(name, model) {\n\treturn this.view(name, model, true);\n};\n\n/**\n * Renders a custom helper to a string\n * @param {String} name A helper name.\n * @return {String}\n */\nController.prototype.helper = function(name) {\n\tvar helper = F.helpers[name];\n\tif (!helper)\n\t\treturn '';\n\n\tvar params = [];\n\tfor (var i = 1; i < arguments.length; i++)\n\t\tparams.push(arguments[i]);\n\n\treturn helper.apply(this, params);\n};\n\n/**\n * Response JSON\n * @param {Object} obj\n * @param {Object} headers Custom headers, optional.\n * @param {Boolean} beautify Beautify JSON.\n * @param {Function(key, value)} replacer JSON replacer.\n * @return {Controller}\n */\nController.prototype.json = function(obj, headers, beautify, replacer) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = headers;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.type = CT_JSON;\n\tres.options.headers = headers;\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.options.type = CT_JSON;\n\t\tres.$text();\n\t\tF.stats.response.json++;\n\t\treturn self;\n\t}\n\n\tif (obj instanceof framework_builders.ErrorBuilder) {\n\t\tself.req.$language && !obj.isResourceCustom && obj.setResource(self.req.$language);\n\n\t\tvar json = obj.output(true);\n\n\t\tif (obj.contentType)\n\t\t\tres.options.type = obj.contentType;\n\t\telse\n\t\t\tres.options.type = CT_JSON;\n\n\t\tif (obj.status !== 200)\n\t\t\tres.options.code = obj.status;\n\n\t\tobj = json;\n\t\tF.stats.response.errorBuilder++;\n\t} else {\n\n\t\tif (framework_builders.isSchema(obj))\n\t\t\tobj = obj.$clean();\n\n\t\tif (beautify)\n\t\t\tobj = JSON.stringify(obj, replacer, 4);\n\t\telse\n\t\t\tobj = JSON.stringify(obj, replacer);\n\t}\n\n\tF.stats.response.json++;\n\tres.options.body = obj;\n\tres.$text();\n\tself.precache && self.precache(obj, res.options.type, headers);\n\treturn self;\n};\n\nController.prototype.success = function(is, value) {\n\treturn this.json(SUCCESS(is === undefined ? true : is, value));\n};\n\n/**\n * Responds with JSONP\n * @param {String} name A method name.\n * @param {Object} obj Object to serialize.\n * @param {Object} headers A custom headers.\n * @param {Boolean} beautify Should be the JSON prettified? Optional, default `false`\n * @param {Function} replacer Optional, the JSON replacer.\n * @return {Controller}\n */\nController.prototype.jsonp = function(name, obj, headers, beautify, replacer) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = headers;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.type = 'application/x-javascript';\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.$text();\n\t\tF.stats.response.json++;\n\t\treturn self;\n\t}\n\n\t!name && (name = 'callback');\n\n\tif (obj instanceof framework_builders.ErrorBuilder) {\n\t\tself.req.$language && !obj.isResourceCustom && obj.setResource(self.req.$language);\n\t\tobj = obj.json(beautify);\n\t\tif (obj.status !== 200)\n\t\t\tres.options.code = obj.status;\n\t\tF.stats.response.errorBuilder++;\n\t} else {\n\n\t\tif (framework_builders.isSchema(obj))\n\t\t\tobj = obj.$clean();\n\n\t\tif (beautify)\n\t\t\tobj = JSON.stringify(obj, replacer, 4);\n\t\telse\n\t\t\tobj = JSON.stringify(obj, replacer);\n\t}\n\n\tres.options.body = name + '(' + obj + ')';\n\tres.$text();\n\n\tF.stats.response.json++;\n\tself.precache && self.precache(name + '(' + obj + ')', res.options.type, headers);\n\treturn self;\n};\n\n/**\n * Creates View or JSON callback\n * @param {String} view Optional, undefined or null returns JSON.\n * @return {Function}\n */\nController.prototype.callback = function(view) {\n\tvar self = this;\n\treturn function(err, data) {\n\n\t\tCONF.logger && self.req.$logger && F.ilogger(null, self.req);\n\n\t\tif (self.res && self.res.success)\n\t\t\treturn;\n\n\t\tvar is = err instanceof framework_builders.ErrorBuilder;\n\n\t\t// NoSQL embedded database\n\t\tif (data === undefined && !U.isError(err) && !is) {\n\t\t\tdata = err;\n\t\t\terr = null;\n\t\t}\n\n\t\tif (err) {\n\t\t\tif (is && !view) {\n\t\t\t\tself.req.$language && !err.isResourceCustom && err.setResource(self.req.$language);\n\t\t\t\treturn self.content(err);\n\t\t\t}\n\t\t\treturn is && err.unexpected ? self.view500(err) : self.view404(err);\n\t\t}\n\n\t\t// Hack for schemas\n\t\tif (data instanceof F.callback_redirect)\n\t\t\treturn self.redirect(data.url);\n\n\t\tif (typeof(view) === 'string')\n\t\t\tself.view(view, data);\n\t\telse\n\t\t\tself.json(data);\n\t};\n};\n\nController.prototype.custom = function() {\n\tif (this.res.success)\n\t\treturn false;\n\tthis.res.$custom();\n\treturn true;\n};\n\n/**\n * Prevents cleaning uploaded files (need to call `controller.clear()` manually).\n * @param {Boolean} enable Optional, default `true`.\n * @return {Controller}\n */\nController.prototype.noClear = function(enable) {\n\tOBSOLETE('controller.noClear()', 'You need to use controller.autoclear(false)');\n\tthis.req._manual = enable === undefined ? true : enable;\n\treturn this;\n};\n\nController.prototype.autoclear = function(enable) {\n\tthis.req._manual = enable === false;\n\treturn this;\n};\n\nController.prototype.html = function(body, headers) {\n\treturn this.content(body, 'text/html', headers);\n};\n\nController.prototype.content = function(body, type, headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tres.options.headers = headers;\n\tres.options.code = self.status || 200;\n\n\tif (body instanceof ErrorBuilder) {\n\n\t\tif (self.language && !body.resourceName)\n\t\t\tbody.resourceName = self.language;\n\n\t\tvar tmp = body.output(true);\n\t\tif (body.contentType)\n\t\t\tres.options.type = body.contentType;\n\t\telse\n\t\t\tres.options.type = CT_JSON;\n\n\t\tif (body.status !== 200)\n\t\t\tres.options.code = body.status;\n\n\t\tbody = tmp;\n\t\tF.stats.response.errorBuilder++;\n\t} else\n\t\tres.options.type = type || CT_TEXT;\n\n\tres.options.body = body;\n\tres.$text();\n\n\tif (self.precache && (!self.status || self.status === 200)) {\n\t\tself.layout('');\n\t\tself.precache(body, res.options.type, headers, true);\n\t}\n\n\treturn self;\n};\n\n/**\n * Responds with plain/text body\n * @param {String} body A response body (object is serialized into the JSON automatically).\n * @param {Boolean} headers A custom headers.\n * @return {Controller}\n */\nController.prototype.plain = function(body, headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.type = CT_TEXT;\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.$text();\n\t\tF.stats.response.plain++;\n\t\treturn self;\n\t}\n\n\tvar type = typeof(body);\n\n\tif (body == null)\n\t\tbody = '';\n\telse if (type === 'object') {\n\t\tif (framework_builders.isSchema(body))\n\t\t\tbody = body.$clean();\n\t\tbody = body ? JSON.stringify(body, null, 4) : '';\n\t} else\n\t\tbody = body ? body.toString() : '';\n\n\tres.options.body = body;\n\tres.$text();\n\tF.stats.response.plain++;\n\tself.precache && self.precache(body, res.options.type, headers);\n\treturn self;\n};\n\n/**\n * Creates an empty response\n * @param {Object/Number} headers A custom headers or a custom HTTP status.\n * @return {Controller}\n */\nController.prototype.empty = function(headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'number') {\n\t\tself.status = headers;\n\t\theaders = null;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.body = EMPTYBUFFER;\n\tres.options.type = CT_TEXT;\n\tres.options.compress = false;\n\tres.$text();\n\tF.stats.response.empty++;\n\treturn self;\n};\n\n/**\n * Destroys a request (closes it)\n * @param {String} problem Optional.\n * @return {Controller}\n */\nController.prototype.destroy = function(problem) {\n\tvar self = this;\n\n\tproblem && self.problem(problem);\n\tif (self.res.success || self.res.headersSent || !self.isConnected)\n\t\treturn self;\n\n\tself.req.$total_success();\n\tself.req.connection && self.req.connection.destroy();\n\tF.stats.response.destroy++;\n\treturn self;\n};\n\n/**\n * Responds with a file\n * @param {String} filename\n * @param {String} download Optional, a download name.\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optinoal, callback.\n * @return {Controller}\n */\nController.prototype.file = function(filename, download, headers, done) {\n\n\tif (filename[0] === '~')\n\t\tfilename = filename.substring(1);\n\telse\n\t\tfilename = F.path.public_cache(filename);\n\n\tvar res = this.res;\n\tres.options.filename = filename;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\tres.$file();\n\treturn this;\n};\n\n/**\n * Responds with an image\n * @param {String or Stream} filename\n * @param {Function(image)} fnProcess\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optional, callback.\n * @return {Controller}\n */\nController.prototype.image = function(filename, make, headers, done) {\n\n\tvar res = this.res;\n\n\tif (typeof(filename) === 'string') {\n\t\tif (filename[0] === '~')\n\t\t\tfilename = filename.substring(1);\n\t\telse\n\t\t\tfilename = F.path.public_cache(filename);\n\n\t\tres.options.filename = filename;\n\t} else\n\t\tres.options.stream = filename;\n\n\tres.options.make = make;\n\theaders && (res.options.headers = headers);\n\tdone && (res.options.callback = done);\n\tres.$image();\n\treturn this;\n};\n\n/**\n * Responds with a stream\n * @param {String} contentType\n * @param {Stream} stream\n * @param {String} download Optional, a download name.\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optinoal, callback.\n * @return {Controller}\n */\nController.prototype.stream = function(type, stream, download, headers, done, nocompress) {\n\tvar res = this.res;\n\tres.options.type = type;\n\tres.options.stream = stream;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.done = done;\n\tres.options.compress = nocompress ? false : true;\n\tres.$stream();\n\treturn this;\n};\n\n/**\n * Throw 400 - Bad request.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw400 = Controller.prototype.view400 = function(problem) {\n\treturn controller_error_status(this, 400, problem);\n};\n\n/**\n * Throw 401 - Unauthorized.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw401 = Controller.prototype.view401 = function(problem) {\n\treturn controller_error_status(this, 401, problem);\n};\n\n/**\n * Throw 403 - Forbidden.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw403 = Controller.prototype.view403 = function(problem) {\n\treturn controller_error_status(this, 403, problem);\n};\n\n/**\n * Throw 404 - Not found.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw404 = Controller.prototype.view404 = function(problem) {\n\treturn controller_error_status(this, 404, problem);\n};\n\n/**\n * Throw 409 - Conflict.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw409 = Controller.prototype.view409 = function(problem) {\n\treturn controller_error_status(this, 409, problem);\n};\n\n/**\n * Throw 500 - Internal Server Error.\n * @param {Error} error\n * @return {Controller}\n */\nController.prototype.throw500 = Controller.prototype.view500 = function(error) {\n\tvar self = this;\n\tF.error(error instanceof Error ? error : new Error((error || '').toString()), self.name, self.req.uri);\n\treturn controller_error_status(self, 500, error);\n};\n\n/**\n * Throw 501 - Not implemented\n * @param  {String} problem Description of the problem (optional)\n * @return {Controller}\n */\nController.prototype.throw501 = Controller.prototype.view501 = function(problem) {\n\treturn controller_error_status(this, 501, problem);\n};\n\n/**\n * Throw 503 - Service unavailable\n * @param  {String} problem Description of the problem (optional)\n * @return {Controller}\n */\nController.prototype.throw503 = Controller.prototype.view503 = function(problem) {\n\treturn controller_error_status(this, 503, problem);\n};\n\n/**\n * Creates a redirect\n * @param {String} url\n * @param {Boolean} permanent Is permanent? Default: `false`\n * @return {Controller}\n */\nController.prototype.redirect = function(url, permanent) {\n\tthis.precache && this.precache(null, null, null);\n\tvar res = this.res;\n\tres.options.url = url;\n\tres.options.permanent = permanent;\n\tres.$redirect();\n\treturn this;\n};\n\n/**\n * A binary response\n * @param {Buffer} buffer\n * @param {String} type\n * @param {String} encoding Transformation type: `binary`, `utf8`, `ascii`.\n * @param {String} download Optional, download name.\n * @param {Object} headers Optional, additional headers.\n * @return {Controller}\n */\nController.prototype.binary = function(buffer, type, encoding, download, headers) {\n\n\tvar res = this.res;\n\n\tif (typeof(encoding) === 'object') {\n\t\tvar tmp = encoding;\n\t\tencoding = download;\n\t\tdownload = headers;\n\t\theaders = tmp;\n\t}\n\n\tif (typeof(download) === 'object') {\n\t\theaders = download;\n\t\tdownload = headers;\n\t}\n\n\tres.options.body = buffer;\n\tres.options.type = type;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.encoding = encoding;\n\tres.$binary();\n\treturn this;\n};\n\n/**\n * Basic access authentication (baa)\n * @param {String} label\n * @return {Object}\n */\nController.prototype.baa = function(label) {\n\n\tvar self = this;\n\tself.precache && self.precache(null, null, null);\n\n\tif (label === undefined)\n\t\treturn self.req.authorization();\n\n\tvar res = self.res;\n\tvar headers = SINGLETON('!controller.baa');\n\n\theaders['WWW-Authenticate'] = 'Basic realm=\"' + (label || 'Administration') + '\"';\n\n\tres.options.code = 401;\n\tres.options.body = '401: NOT AUTHORIZED';\n\tres.options.compress = false;\n\tres.options.headers = headers;\n\tres.options.type = CT_TEXT;\n\tres.$text();\n\tself.cancel();\n\treturn null;\n};\n\n/**\n * Sends server-sent event message\n * @param {String/Object} data\n * @param {String} eventname Optional, an event name.\n * @param {String} id Optional, a custom ID.\n * @param {Number} retry A reconnection timeout in milliseconds when is an unexpected problem.\n * @return {Controller}\n */\nController.prototype.sse = function(data, eventname, id, retry) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (!self.isConnected)\n\t\treturn self;\n\n\tif (!self.type && res.success)\n\t\tthrow new Error('Response was sent.');\n\n\tif (self.type > 0 && self.type !== 1)\n\t\tthrow new Error('Response was used.');\n\n\tif (!self.type) {\n\n\t\tself.type = 1;\n\n\t\tif (retry === undefined)\n\t\t\tretry = self.route.timeout;\n\n\t\tself.req.$total_success();\n\t\tself.req.on('close', () => self.close());\n\t\tres.success = true;\n\t\tres.writeHead(self.status || 200, HEADERS.sse);\n\t}\n\n\tif (typeof(data) === 'object')\n\t\tdata = JSON.stringify(data);\n\telse\n\t\tdata = data.replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n\n\tvar newline = '\\n';\n\tvar builder = '';\n\n\tif (eventname)\n\t\tbuilder = 'event: ' + eventname + newline;\n\n\tbuilder += 'data: ' + data + newline;\n\n\tif (id)\n\t\tbuilder += 'id: ' + id + newline;\n\n\tif (retry > 0)\n\t\tbuilder += 'retry: ' + retry + newline;\n\n\tbuilder += newline;\n\tres.write(builder);\n\tF.stats.response.sse++;\n\treturn self;\n};\n\n/**\n * Close a response\n * @param {Boolean} end\n * @return {Controller}\n */\nController.prototype.close = function(end) {\n\tvar self = this;\n\n\tif (end === undefined)\n\t\tend = true;\n\n\tif (!self.isConnected)\n\t\treturn self;\n\n\tif (self.type) {\n\t\tself.isConnected = false;\n\t\tself.res.success = true;\n\t\tF.reqstats(false, false);\n\t\tF.$events['request-end'] && EMIT('request-end', self.req, self.res);\n\t\tself.type = 0;\n\t\tend && self.res.end();\n\t\tself.req.clear(true);\n\t\treturn self;\n\t}\n\n\tself.isConnected = false;\n\n\tif (self.res.success)\n\t\treturn self;\n\n\tself.res.success = true;\n\tF.reqstats(false, false);\n\tF.$events['request-end'] && EMIT('request-end', self.req, self.res);\n\tend && self.res.end();\n\tself.req.clear(true);\n\treturn self;\n};\n\n/**\n * Creates a proxy between current request and new URL\n * @param {String} url\n * @param {Function(err, response, headers)} callback Optional.\n * @param {Object} headers Optional, additional headers.\n * @param {Number} timeout Optional, timeout (default: 10000)\n * @return {EventEmitter}\n */\nController.prototype.proxy = Controller.prototype.proxy2 = function(url, callback, headers, timeout) {\n\n\tif (typeof(callback) === 'object') {\n\t\ttimeout = headers;\n\t\theaders = callback;\n\t\tcallback = undefined;\n\t}\n\n\tvar self = this;\n\tvar flags = [];\n\tvar req = self.req;\n\tvar type = req.headers['content-type'];\n\tvar h = {};\n\n\tflags.push(req.method);\n\tflags.push('dnscache');\n\n\tif ((/\\/json/i).test(type))\n\t\tflags.push('json');\n\n\tvar tmp;\n\n\tif (url.indexOf('?') === -1) {\n\t\ttmp = Qs.stringify(self.query);\n\t\tif (tmp)\n\t\t\turl += '?' + tmp;\n\t}\n\n\tvar keys = Object.keys(req.headers);\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tswitch (keys[i]) {\n\t\t\tcase 'x-forwarded-for':\n\t\t\tcase 'x-forwarded-protocol':\n\t\t\tcase 'x-nginx-proxy':\n\t\t\tcase 'connection':\n\t\t\tcase 'content-type':\n\t\t\tcase 'host':\n\t\t\tcase 'accept-encoding':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\th[keys[i]] = req.headers[keys[i]];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (headers) {\n\t\tkeys = Object.keys(headers);\n\t\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\t\th[keys[i]] = headers[keys[i]];\n\t}\n\n\treturn U.request(url, flags, self.body, function(err, data, code, headers) {\n\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t\tself.invalid().push(err);\n\t\t} else {\n\t\t\tself.status = code;\n\t\t\tcallback && callback(err, data, code, headers);\n\t\t\tvar ct = (headers['content-type'] || 'text/plain').replace(REG_ENCODINGCLEANER, '');\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tself.binary(data, ct);\n\t\t\telse\n\t\t\t\tself.content(data, ct);\n\t\t}\n\n\t}, null, h, ENCODING, timeout || 10000);\n};\n\n/**\n * Renders view to response\n * @param {String} name View name without `.html` extension.\n * @param {Object} model A model, optional default: `undefined`.\n * @param {Object} headers A custom headers, optional.\n * @param {Boolean} isPartial When is `true` the method returns rendered HTML as `String`\n * @return {Controller/String}\n */\nController.prototype.view = function(name, model, headers, partial, noasync, cachekey) {\n\n\tvar self = this;\n\n\tif (typeof(name) !== 'string') {\n\t\tpartial = headers;\n\t\theaders = model;\n\t\tmodel = name;\n\t\tname = self.viewname;\n\t} else if (partial === undefined && typeof(headers) === 'boolean') {\n\t\tpartial = headers;\n\t\theaders = null;\n\t}\n\n\tif (!partial && self.res && self.res.success)\n\t\treturn self;\n\n\tif (self.layoutName === undefined)\n\t\tself.layoutName = CONF.default_layout;\n\tif (self.themeName === undefined)\n\t\tself.themeName = CONF.default_theme;\n\n\t// theme root `~some_view`\n\t// views root `~~some_view`\n\t// package    `@some_view`\n\t// theme      `=theme/view`\n\n\tvar key = 'view#=' + this.themeName + '/' + self._currentView + '/' + name;\n\tvar filename = F.temporary.other[key];\n\tvar isLayout = self.isLayout;\n\n\tself.isLayout = false;\n\n\t// A small cache\n\tif (!filename) {\n\n\t\t// ~   --> routed into the root of views (if the controller uses a theme then is routed into the root views of the theme)\n\t\t// ~~  --> routed into the root of views (if the controller contains theme)\n\t\t// /   --> routed into the views (skipped)\n\t\t// @   --> routed into the packages\n\t\t// .   --> routed into the opened path\n\t\t// =   --> routed into the theme\n\n\t\tvar c = name[0];\n\t\tvar skip = c === '/' ? 1 : c === '~' && name[1] === '~' ? 4 : c === '~' ? 2 : c === '@' ? 3 : c === '.' ? 5 : c === '=' ? 6 : 0;\n\t\tvar isTheme = false;\n\n\t\tif (REG_HTTPHTTPS.test(name))\n\t\t\tskip = 7;\n\n\t\tfilename = name;\n\n\t\tif (self.themeName && skip < 3) {\n\t\t\tfilename = '.' + F.path.themes(self.themeName + '/views/' + (isLayout || skip ? '' : self._currentView.substring(1)) + (skip ? name.substring(1) : name)).replace(REG_SANITIZE_BACKSLASH, '/');\n\t\t\tisTheme = true;\n\t\t}\n\n\t\tif (skip === 4) {\n\t\t\tfilename = filename.substring(1);\n\t\t\tname = name.substring(1);\n\t\t\tskip = 2;\n\t\t}\n\n\t\tif (!isTheme && !isLayout && !skip)\n\t\t\tfilename = self._currentView + name;\n\n\t\tif (!isTheme && (skip === 2 || skip === 3))\n\t\t\tfilename = name.substring(1);\n\n\t\tif (skip === 3)\n\t\t\tfilename = '.' + F.path.package(filename);\n\n\t\tif (skip === 6) {\n\t\t\tc = U.parseTheme(filename);\n\t\t\tname = name.substring(name.indexOf('/') + 1);\n\t\t\tfilename = '.' + F.path.themes(c + '/views/' + name).replace(REG_SANITIZE_BACKSLASH, '/');\n\t\t}\n\n\t\tif (skip === 7) {\n\n\t\t\tif (F.temporary.other[key] === 0) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tself.view(name, model, headers, partial);\n\t\t\t\t}, 100, self);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfilename = F.path.temp('view' + name.hash() + '.html');\n\t\t\tF.temporary.other[key] = 0;\n\n\t\t\tvar done = { callback: NOOP };\n\n\t\t\tF.download(name, filename, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tF.temporary.other[key] = undefined;\n\t\t\t\t\tif (done.callback === NOOP)\n\t\t\t\t\t\tF.throw500(err);\n\t\t\t\t\telse\n\t\t\t\t\t\tdone.callback(err);\n\t\t\t\t} else {\n\t\t\t\t\tF.temporary.other[key] = '.' + filename.substring(0, filename.length - 5);\n\t\t\t\t\tdone.callback(null, self.view(name, model, headers, partial));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn function(cb) {\n\t\t\t\tdone.callback = cb;\n\t\t\t};\n\t\t}\n\t}\n\n\treturn self.$viewrender(filename, framework_internal.viewEngine(name, filename, self), model, headers, partial, isLayout, noasync, cachekey);\n};\n\nController.prototype.viewCompile = function(body, model, headers, partial, key) {\n\n\tif (headers === true) {\n\t\tkey = partial;\n\t\tpartial = true;\n\t\theaders = undefined;\n\t} else if (typeof(headers) === 'string') {\n\t\tkey = headers;\n\t\theaders = undefined;\n\t} else if (typeof(partial) === 'string') {\n\t\tkey = partial;\n\t\tpartial = undefined;\n\t}\n\n\treturn this.$viewrender('[dynamic view]', framework_internal.viewEngineCompile(body, this.language, this, key), model, headers, partial);\n};\n\nController.prototype.$viewrender = function(filename, generator, model, headers, partial, isLayout, noasync, cachekey) {\n\n\tvar self = this;\n\tvar err;\n\n\tif (!generator) {\n\n\t\terr = new Error('View \"' + filename + '\" not found.');\n\n\t\tif (partial) {\n\t\t\tF.error(err, self.name, self.uri);\n\t\t\treturn self.outputPartial;\n\t\t}\n\n\t\tif (isLayout) {\n\t\t\tself.res.throw500(err);\n\t\t\treturn self;\n\t\t}\n\n\t\tself.view500(err);\n\t\treturn self;\n\t}\n\n\tvar value = '';\n\tself.$model = model;\n\n\tif (isLayout)\n\t\tself._currentView = self._defaultView || '';\n\n\tvar helpers = F.helpers;\n\n\ttry {\n\n\t\tif (generator.components.length) {\n\t\t\tif (!self.repository[REPOSITORY_COMPONENTS])\n\t\t\t\tself.repository[REPOSITORY_COMPONENTS] = {};\n\t\t\tfor (var i = 0; i < generator.components.length; i++)\n\t\t\t\tself.repository[REPOSITORY_COMPONENTS][generator.components[i]] = 1;\n\t\t}\n\n\t\tvalue = generator.call(self, self, self.repository, model, self.session, self.query, self.body, self.url, F.global, helpers, self.user, CONF, F.functions, 0, partial ? self.outputPartial : self.output, self.req.files, self.req.mobile, EMPTYOBJECT);\n\n\t} catch (ex) {\n\n\t\terr = new Error('View \"' + filename + '\": ' + ex.message);\n\n\t\tif (!partial) {\n\t\t\tself.view500(err);\n\t\t\treturn self;\n\t\t}\n\n\t\tself.error(err);\n\n\t\tif (self.partial)\n\t\t\tself.outputPartial = '';\n\t\telse\n\t\t\tself.output = '';\n\n\t\tisLayout = false;\n\t\treturn value;\n\t}\n\n\t// noasync = true --> rendered inline view in view\n\n\tif (self.$viewasync && self.$viewasync.length) {\n\n\t\tvar can = ((isLayout || !self.layoutName) && noasync !== true) || !!cachekey;\n\t\tif (can) {\n\t\t\tvar done = {};\n\t\t\tvar obj = {};\n\n\t\t\tobj.repository = self.repository;\n\t\t\tobj.model = self.$model;\n\t\t\tobj.user = self.user;\n\t\t\tobj.session = self.session;\n\t\t\tobj.controller = self;\n\t\t\tobj.query = self.query;\n\t\t\tobj.body = self.body;\n\t\t\tobj.files = self.files;\n\n\t\t\tself.$viewasync.waitFor(function(item, next) {\n\n\t\t\t\tif (item.value) {\n\t\t\t\t\tvalue = value.replace(item.replace, item.value);\n\t\t\t\t\tif (isLayout && self.precache)\n\t\t\t\t\t\tself.output = self.output.replace(item.replace, item.value);\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tobj.options = obj.settings = item.settings;\n\t\t\t\tobj.next = obj.callback = function(model) {\n\t\t\t\t\tif (arguments.length > 1)\n\t\t\t\t\t\tmodel = arguments[1];\n\t\t\t\t\titem.value = self.component(item.name, item.settings, model);\n\t\t\t\t\tvalue = value.replace(item.replace, item.value);\n\t\t\t\t\tif (isLayout && self.precache)\n\t\t\t\t\t\tself.output = self.output.replace(item.replace, item.value);\n\t\t\t\t\tnext();\n\t\t\t\t};\n\n\t\t\t\tF.components.instances[item.name].render(obj);\n\n\t\t\t}, function() {\n\n\t\t\t\tif (cachekey && F.cache.items[cachekey]) {\n\t\t\t\t\tvar cache = F.cache.items[cachekey].value;\n\t\t\t\t\tcache.body = value;\n\t\t\t\t\tcache.components = true;\n\t\t\t\t}\n\n\t\t\t\tif (isLayout && self.precache && (!self.status || self.status === 200) && !partial)\n\t\t\t\t\tself.precache(self.output, CT_HTML, headers, true);\n\n\t\t\t\tif (isLayout || !self.layoutName) {\n\n\t\t\t\t\tself.outputPartial = '';\n\t\t\t\t\tself.output = '';\n\t\t\t\t\tisLayout = false;\n\n\t\t\t\t\tif (partial) {\n\t\t\t\t\t\tdone.callback && done.callback(null, value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tself.req.$total_success();\n\n\t\t\t\t\tif (!self.isConnected)\n\t\t\t\t\t\treturn self;\n\n\t\t\t\t\tvar res = self.res;\n\t\t\t\t\tres.options.body = value;\n\t\t\t\t\tres.options.code = self.status || 200;\n\t\t\t\t\tres.options.type = CT_HTML;\n\t\t\t\t\tres.options.headers = headers;\n\t\t\t\t\tres.$text();\n\t\t\t\t\tF.stats.response.view++;\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\n\t\t\t\tif (partial)\n\t\t\t\t\tself.outputPartial = value;\n\t\t\t\telse\n\t\t\t\t\tself.output = value;\n\n\t\t\t\tif (!cachekey && !noasync) {\n\t\t\t\t\tself.isLayout = true;\n\t\t\t\t\tvalue = self.view(self.layoutName, self.$model, headers, partial);\n\t\t\t\t}\n\n\t\t\t\t// Async\n\t\t\t\tif (partial) {\n\t\t\t\t\tself.outputPartial = '';\n\t\t\t\t\tself.isLayout = false;\n\t\t\t\t\tdone.callback && done.callback(null, value);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\treturn cachekey ? value : (partial ? (fn => done.callback = fn) : self);\n\t\t}\n\t}\n\n\tif (!isLayout && self.precache && (!self.status || self.status === 200) && !partial && !self.$viewasync)\n\t\tself.precache(value, CT_HTML, headers, true);\n\n\tif (isLayout || !self.layoutName) {\n\n\t\tself.outputPartial = '';\n\t\tself.output = '';\n\t\tisLayout = false;\n\n\t\tif (partial)\n\t\t\treturn value;\n\n\t\tself.req.$total_success();\n\n\t\tif (!self.isConnected)\n\t\t\treturn self;\n\n\t\tvar res = self.res;\n\t\tres.options.body = value;\n\t\tres.options.code = self.status || 200;\n\t\tres.options.type = CT_HTML;\n\t\tres.options.headers = headers;\n\t\tres.$text();\n\t\tF.stats.response.view++;\n\t\treturn self;\n\t}\n\n\tif (partial)\n\t\tself.outputPartial = value;\n\telse\n\t\tself.output = value;\n\n\tif (!cachekey && !noasync) {\n\t\tself.isLayout = true;\n\t\tvalue = self.view(self.layoutName, self.$model, headers, partial);\n\t}\n\n\t// Async\n\tif (partial) {\n\t\tself.outputPartial = '';\n\t\tself.isLayout = false;\n\t\treturn value;\n\t}\n\n\treturn self;\n};\n\n/**\n * Creates a cache for the response without caching layout\n * @param {String} key\n * @param {String} expires Expiration, e.g. `1 minute`\n * @param {Boolean} disabled Disables a caching, optinoal (e.g. for debug mode you can disable a cache), default: `false`\n * @param {Function()} fnTo This method is executed when the content is prepared for the cache.\n * @param {Function()} fnFrom This method is executed when the content is readed from the cache.\n * @return {Controller}\n */\nController.prototype.memorize = function(key, expires, disabled, fnTo, fnFrom) {\n\n\tvar self = this;\n\n\tif (disabled === true) {\n\t\tfnTo.call(self);\n\t\treturn self;\n\t}\n\n\tself.themeName && (key += '#' + self.themeName);\n\n\tvar output = F.cache.read2(key);\n\tif (!output)\n\t\treturn self.$memorize_prepare(key, expires, disabled, fnTo, fnFrom);\n\n\tif (typeof(disabled) === 'function') {\n\t\tvar tmp = fnTo;\n\t\tfnTo = disabled;\n\t\tfnFrom = tmp;\n\t}\n\n\tself.layoutName = output.layout;\n\tself.themeName = output.theme;\n\n\tvar res = self.res;\n\n\tres.options.code = self.status || 200;\n\tres.options.type = output.type;\n\tres.options.headers = output.headers;\n\tres.options.body = output.content;\n\n\tif (output.type !== CT_HTML) {\n\t\tfnFrom && fnFrom.call(self);\n\t\tres.$text();\n\t\treturn;\n\t}\n\n\tswitch (output.type) {\n\t\tcase CT_TEXT:\n\t\t\tF.stats.response.plain++;\n\t\t\treturn self;\n\t\tcase CT_JSON:\n\t\t\tF.stats.response.json++;\n\t\t\treturn self;\n\t\tcase CT_HTML:\n\t\t\tF.stats.response.view++;\n\t\t\tbreak;\n\t}\n\n\tvar length = output.repository.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = output.repository[i].key;\n\t\tif (self.repository[key] === undefined)\n\t\t\tself.repository[key] = output.repository[i].value;\n\t}\n\n\tfnFrom && fnFrom.call(self);\n\n\tif (self.layoutName) {\n\t\tself.output = U.createBuffer(output.content);\n\t\tself.isLayout = true;\n\t\tself.view(self.layoutName, null);\n\t} else {\n\t\tself.req.$total_success();\n\t\tres.$text();\n\t}\n\n\treturn self;\n};\n\nController.prototype.$memorize_prepare = function(key, expires, disabled, fnTo, fnFrom) {\n\n\tvar self = this;\n\tvar pk = '$memorize' + key;\n\n\tif (F.temporary.processing[pk]) {\n\t\tsetTimeout(function() {\n\t\t\t!self.req.$total_canceled && self.memorize(key, expires, disabled, fnTo, fnFrom);\n\t\t}, 500);\n\t\treturn self;\n\t}\n\n\tself.precache = function(value, contentType, headers, isView) {\n\n\t\tif (!value && !contentType && !headers) {\n\t\t\tdelete F.temporary.processing[pk];\n\t\t\tself.precache = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar options = { content: value, type: contentType || CT_TEXT, layout: self.layoutName, theme: self.themeName };\n\t\tif (headers)\n\t\t\toptions.headers = headers;\n\n\t\tif (isView) {\n\t\t\toptions.repository = [];\n\t\t\tfor (var name in self.repository) {\n\t\t\t\tvar value = self.repository[name];\n\t\t\t\tvalue !== undefined && options.repository.push({ key: name, value: value });\n\t\t\t}\n\t\t}\n\n\t\tF.cache.add(key, options, expires, false);\n\t\tself.precache = null;\n\t\tdelete F.temporary.processing[pk];\n\t};\n\n\tif (typeof(disabled) === 'function')\n\t\tfnTo = disabled;\n\n\tF.temporary.processing[pk] = true;\n\tfnTo.call(self);\n\treturn self;\n};\n\n// *********************************************************************************\n// =================================================================================\n// F.WebSocket\n// =================================================================================\n// *********************************************************************************\n\nconst NEWLINE = '\\r\\n';\nconst SOCKET_RESPONSE = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_COMPRESS = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Extensions: permessage-deflate\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_PROTOCOL = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Protocol: {1}\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_PROTOCOL_COMPRESS = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Protocol: {1}\\r\\nSec-WebSocket-Extensions: permessage-deflate\\r\\n\\r\\n';\nconst SOCKET_HASH = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst SOCKET_ALLOW_VERSION = [13];\n\nfunction WebSocket(path, name, id) {\n\tthis._keys = [];\n\tthis.id = id;\n\tthis.online = 0;\n\tthis.connections = {};\n\tthis.name = name;\n\tthis.isController = true;\n\tthis.url = U.path(path);\n\tthis.route = null;\n\tthis.$events = {};\n\n\t// on('open', function(client) {});\n\t// on('close', function(client) {});\n\t// on('message', function(client, message) {});\n\t// on('error', function(error, client) {});\n\t// Events.EventEmitter.call(this);\n}\n\nWebSocket.prototype = {\n\n\tget repository() {\n\t\tif (this.$repository)\n\t\t\treturn this.$repository;\n\t\telse\n\t\t\treturn this.$repository ? this.$repository : (this.$repository = {});\n\t},\n\n\tget global() {\n\t\tOBSOLETE('controller.global', 'Use: G');\n\t\treturn F.global;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn CONF;\n\t},\n\n\tget cache() {\n\t\tOBSOLETE('controller.cache', 'Use: F.cache or CACHE()');\n\t\treturn F.cache;\n\t},\n\n\tget isDebug() {\n\t\tOBSOLETE('controller.isDebug', 'Use: DEBUG');\n\t\treturn DEBUG;\n\t},\n\n\tget path() {\n\t\tOBSOLETE('controller.path', 'Use: PATH');\n\t\treturn F.path;\n\t},\n\n\tget isSecure() {\n\t\tOBSOLETE('controller.isSecure', 'Use: controller.secured');\n\t\treturn this.req.isSecure;\n\t},\n\n\tget secured() {\n\t\treturn this.req.secured;\n\t},\n\n\tget params() {\n\t\tif (this.$params)\n\t\t\treturn this.$params;\n\t\tvar split = framework_internal.routeSplit(this.url, true);\n\t\tvar names = this.route.paramnames;\n\t\tif (names) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < names.length; i++)\n\t\t\t\tobj[names[i]] = split[this.route.param[i]];\n\t\t\tthis.$params = obj;\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tthis.$params = EMPTYOBJECT;\n\t\t\treturn EMPTYOBJECT;\n\t\t}\n\t}\n};\n\nWebSocket.prototype.operation = function(name, value, callback, options) {\n\tOPERATION(name, value, callback, options, this);\n\treturn this;\n};\n\nWebSocket.prototype.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nWebSocket.prototype.on = function(name, fn) {\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nWebSocket.prototype.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nWebSocket.prototype.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nWebSocket.prototype.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\n/**\n * Sends a message\n * @param {String} message\n * @param {String Array or Function(id, client)} id (optional)\n * @param {String Array or Function(id, client)} blacklist (optional)\n * @param {Function(key, value)} replacer for JSON (optional)\n * @return {WebSocket}\n */\nWebSocket.prototype.send = function(message, id, blacklist, replacer) {\n\n\tvar self = this;\n\tvar keys = self._keys;\n\n\tif (!keys || !keys.length || message === undefined)\n\t\treturn self;\n\n\tvar data;\n\tvar raw = false;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar conn = self.connections[keys[i]];\n\n\t\tif (id) {\n\t\t\tif (id instanceof Array) {\n\t\t\t\tif (!websocket_valid_array(conn.id, id))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (id instanceof Function) {\n\t\t\t\tif (!websocket_valid_fn(conn.id, conn, id, message))\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tthrow new Error('Invalid \"id\" argument.');\n\t\t}\n\n\t\tif (blacklist) {\n\t\t\tif (blacklist instanceof Array) {\n\t\t\t\tif (websocket_valid_array(conn.id, blacklist))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (blacklist instanceof Function) {\n\t\t\t\tif (websocket_valid_fn(conn.id, conn, blacklist, message))\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tthrow new Error('Invalid \"blacklist\" argument.');\n\t\t}\n\n\t\tif (data === undefined) {\n\t\t\tif (conn.type === 3) {\n\t\t\t\traw = true;\n\t\t\t\tdata = JSON.stringify(message, replacer);\n\t\t\t} else\n\t\t\t\tdata = message;\n\t\t}\n\n\t\tconn.send(data, raw);\n\t\tF.stats.response.websocket++;\n\t}\n\n\treturn self;\n};\n\nWebSocket.prototype.send2 = function(message, comparer, replacer) {\n\n\tvar self = this;\n\tvar keys = self._keys;\n\tif (!keys || !keys.length || message === undefined)\n\t\treturn self;\n\n\tvar data;\n\tvar raw = false;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar conn = self.connections[keys[i]];\n\n\t\tif (data === undefined) {\n\t\t\tif (conn.type === 3) {\n\t\t\t\traw = true;\n\t\t\t\tdata = JSON.stringify(message, replacer);\n\t\t\t} else\n\t\t\t\tdata = message;\n\t\t}\n\n\t\tif (comparer && !comparer(conn, message))\n\t\t\tcontinue;\n\n\t\tconn.send(data, raw);\n\t\tF.stats.response.websocket++;\n\t}\n\n\treturn self;\n};\n\nfunction websocket_valid_array(id, arr) {\n\treturn arr.indexOf(id) !== -1;\n}\n\nfunction websocket_valid_fn(id, client, fn, msg) {\n\treturn fn && fn(id, client, msg) ? true : false;\n}\n\n/**\n * Sends a ping message\n * @return {WebSocket}\n */\nWebSocket.prototype.ping = function() {\n\n\tvar keys = this._keys;\n\tif (!keys)\n\t\treturn this;\n\n\tvar length = keys.length;\n\tif (length) {\n\t\tthis.$ping = true;\n\t\tF.stats.other.websocketPing++;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tthis.connections[keys[i]].ping();\n\t}\n\n\treturn this;\n};\n\n/**\n * Closes a connection\n * @param {String Array} id Client id, optional, default `null`.\n * @param {String} message A message for the browser.\n * @param {Number} code Optional default 1000.\n * @return {Websocket}\n */\nWebSocket.prototype.close = function(id, message, code) {\n\n\tvar keys = this._keys;\n\n\tif (!keys)\n\t\treturn this;\n\n\tif (typeof(id) === 'string') {\n\t\tcode = message;\n\t\tmessage = id;\n\t\tid = null;\n\t}\n\n\tvar length = keys.length;\n\tif (!length)\n\t\treturn this;\n\n\tif (!id || !id.length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar _id = keys[i];\n\t\t\tthis.connections[_id].close(message, code);\n\t\t\tthis.$remove(_id);\n\t\t}\n\t\tthis.$refresh();\n\t\treturn this;\n\t}\n\n\tvar is = id instanceof Array;\n\tvar fn = typeof(id) === 'function' ? id : null;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar _id = keys[i];\n\t\tif (is && id.indexOf(_id) === -1)\n\t\t\tcontinue;\n\n\t\tvar conn = this.connections[_id];\n\t\tif (fn && !fn.call(this, _id, conn))\n\t\t\tcontinue;\n\n\t\tconn.close(message, code);\n\t\tthis.$remove(_id);\n\t}\n\n\tthis.$refresh();\n\treturn this;\n};\n\n/**\n * Error caller\n * @param {Error/String} err\n * @return {WebSocket/Function}\n */\nWebSocket.prototype.error = function(err) {\n\tvar result = F.error(typeof(err) === 'string' ? new Error(err) : err, this.name, this.path);\n\treturn err ? this : result;\n};\n\n/**\n * Creates a problem\n * @param {String} message\n * @return {WebSocket}\n */\nWebSocket.prototype.wtf = WebSocket.prototype.problem = function(message) {\n\tF.problem(message, this.name, this.uri);\n\treturn this;\n};\n\n/**\n * Creates a change\n * @param {String} message\n * @return {WebSocket}\n */\nWebSocket.prototype.change = function(message) {\n\tF.change(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * The method executes a provided function once per client.\n * @param {Function(connection, index)} fn\n * @return {WebSocket}\n */\nWebSocket.prototype.all = function(fn) {\n\tvar arr = fn == null || fn == true ? [] : null;\n\tvar self = this;\n\tif (self._keys) {\n\t\tfor (var i = 0, length = self._keys.length; i < length; i++) {\n\t\t\tif (arr)\n\t\t\t\tarr.push(self.connections[self._keys[i]]);\n\t\t\telse\n\t\t\t\tfn(self.connections[self._keys[i]], i);\n\t\t}\n\t}\n\treturn arr ? arr : self;\n};\n\n/**\n * Finds a connection\n * @param {String} id\n * @return {WebSocketClient}\n */\nWebSocket.prototype.find = function(id) {\n\tvar self = this;\n\n\tif (!self._keys)\n\t\treturn self;\n\n\tvar length = self._keys.length;\n\tvar isFn = typeof(id) === 'function';\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar connection = self.connections[self._keys[i]];\n\t\tif (isFn) {\n\t\t\tif (id(connection, connection.id))\n\t\t\t\treturn connection;\n\t\t} else if (connection.id === id)\n\t\t\treturn connection;\n\t}\n\treturn null;\n};\n\n/**\n * Destroys a WebSocket controller\n * @param {String} problem Optional.\n * @return {WebSocket}\n */\nWebSocket.prototype.destroy = function(problem) {\n\tvar self = this;\n\n\tproblem && self.problem(problem);\n\tif (!self.connections && !self._keys)\n\t\treturn self;\n\n\tself.close();\n\tself.$events.destroy && self.emit('destroy');\n\n\tsetTimeout(function() {\n\n\t\tself._keys.forEach(function(key) {\n\t\t\tvar conn = self.connections[key];\n\t\t\tif (conn) {\n\t\t\t\tconn._isClosed = true;\n\t\t\t\tconn.socket.removeAllListeners();\n\t\t\t}\n\t\t});\n\n\t\tself.connections = null;\n\t\tself._keys = null;\n\t\tself.route = null;\n\t\tself.buffer = null;\n\t\tdelete F.connections[self.id];\n\t\tself.removeAllListeners();\n\t}, 1000);\n\n\treturn self;\n};\n\n/**\n * Enables auto-destroy websocket controller when any user is not online\n * @param {Function} callback\n * @return {WebSocket]\n */\nWebSocket.prototype.autodestroy = function(callback) {\n\tvar self = this;\n\tvar key = 'websocket:' + self.id;\n\tself.on('open', () => clearTimeout2(key));\n\tself.on('close', function() {\n\t\t!self.online && setTimeout2(key, function() {\n\t\t\tcallback && callback.call(self);\n\t\t\tself.destroy();\n\t\t}, 5000);\n\t});\n\treturn self;\n};\n\n/**\n * Internal function\n * @return {WebSocket}\n */\nWebSocket.prototype.$refresh = function() {\n\tif (this.connections) {\n\t\tthis._keys = Object.keys(this.connections);\n\t\tthis.online = this._keys.length;\n\t} else\n\t\tthis.online = 0;\n\treturn this;\n};\n\n/**\n * Internal function\n * @param {String} id\n * @return {WebSocket}\n */\nWebSocket.prototype.$remove = function(id) {\n\tif (this.connections)\n\t\tdelete this.connections[id];\n\treturn this;\n};\n\n/**\n * Internal function\n * @param {WebSocketClient} client\n * @return {WebSocket}\n */\nWebSocket.prototype.$add = function(client) {\n\tthis.connections[client._id] = client;\n\treturn this;\n};\n\n/**\n * A resource header\n * @param {String} name A resource name.\n * @param {String} key A resource key.\n * @return {String}\n */\nWebSocket.prototype.resource = function(name, key) {\n\treturn F.resource(name, key);\n};\n\nWebSocket.prototype.log = function() {\n\tF.log.apply(framework, arguments);\n\treturn this;\n};\n\nWebSocket.prototype.logger = function() {\n\tF.logger.apply(framework, arguments);\n\treturn this;\n};\n\nWebSocket.prototype.check = function() {\n\tthis.$ping && this.all(websocketcheck_ping);\n\treturn this;\n};\n\nfunction websocketcheck_ping(client) {\n\tif (!client.$ping) {\n\t\tclient.close();\n\t\tF.stats.other.websocketCleaner++;\n\t}\n}\n\n/**\n * WebSocket controller\n * @param {Request} req\n * @param {Socket} socket\n */\nfunction WebSocketClient(req, socket) {\n\tthis.$ping = true;\n\tthis.container;\n\tthis._id;\n\tthis.id = '';\n\tthis.socket = socket;\n\tthis.req = req;\n\n\t// this.isClosed = false;\n\tthis.errors = 0;\n\tthis.length = 0;\n\tthis.current = {};\n\n\t// 1 = raw - not implemented\n\t// 2 = plain\n\t// 3 = JSON\n\n\tthis.type = 2;\n\t// this._isClosed = false;\n}\n\nWebSocketClient.prototype = {\n\n\tget protocol() {\n\t\treturn (this.req.headers['sec-websocket-protocol'] || '').replace(REG_EMPTY, '').split(',');\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget get() {\n\t\treturn this.req.query;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tget uri() {\n\t\treturn this.req.uri;\n\t},\n\n\tget config() {\n\t\treturn this.container.config;\n\t},\n\n\tget global() {\n\t\treturn this.container.global;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tset session(value) {\n\t\tthis.req.session = value;\n\t},\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tset user(value) {\n\t\tthis.req.user = value;\n\t},\n\n\tget mobile() {\n\t\treturn this.req.mobile;\n\t}\n};\n\nWebSocketClient.prototype.isWebSocket = true;\n\nWebSocketClient.prototype.cookie = function(name) {\n\treturn this.req.cookie(name);\n};\n\nWebSocketClient.prototype.$close = function(code, message) {\n\n\tvar self = this;\n\n\tif ((self.req.headers['user-agent'] || '').indexOf('Total.js') !== -1) {\n\t\tself.close();\n\t\treturn;\n\t}\n\n\tvar header = SOCKET_RESPONSE.format(self.$websocket_key(self.req));\n\tself.socket.write(U.createBuffer(header, 'binary'));\n\tself.ready = true;\n\tself.close(message, code);\n\n\tsetTimeout(function(self) {\n\t\tself.req = null;\n\t\tself.socket = null;\n\t}, 1000, self);\n\n\treturn self;\n};\n\nWebSocketClient.prototype.prepare = function(flags, protocols, allow, length) {\n\n\tflags = flags || EMPTYARRAY;\n\tprotocols = protocols || EMPTYARRAY;\n\tallow = allow || EMPTYARRAY;\n\n\tvar self = this;\n\n\tif (SOCKET_ALLOW_VERSION.indexOf(U.parseInt(self.req.headers['sec-websocket-version'])) === -1)\n\t\treturn false;\n\n\tself.length = length;\n\n\tvar origin = self.req.headers.origin || '';\n\tvar length = allow.length;\n\n\tif (length && allow.indexOf('*') === -1) {\n\t\tvar is = false;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (origin.indexOf(allow[i]) !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\treturn false;\n\t}\n\n\tlength = protocols.length;\n\tif (length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (self.protocol.indexOf(protocols[i]) === -1)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tvar compress = (CONF.allow_websocket_compression && self.req.headers['sec-websocket-extensions'] || '').indexOf('permessage-deflate') !== -1;\n\tvar header = protocols.length ? (compress ? SOCKET_RESPONSE_PROTOCOL_COMPRESS : SOCKET_RESPONSE_PROTOCOL).format(self.$websocket_key(self.req), protocols.join(', ')) : (compress ? SOCKET_RESPONSE_COMPRESS : SOCKET_RESPONSE).format(self.$websocket_key(self.req));\n\n\tself.socket.write(U.createBuffer(header, 'binary'));\n\tself.ready = true;\n\n\tif (compress) {\n\t\tself.inflatepending = [];\n\t\tself.inflatelock = false;\n\t\tself.inflate = Zlib.createInflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\tself.inflate.$websocket = self;\n\t\tself.inflate.on('error', function() {\n\t\t\tif (!self.$uerror) {\n\t\t\t\tself.$uerror = true;\n\t\t\t\tself.close('Invalid data', 1003);\n\t\t\t}\n\t\t});\n\t\tself.inflate.on('data', websocket_inflate);\n\n\t\tself.deflatepending = [];\n\t\tself.deflatelock = false;\n\t\tself.deflate = Zlib.createDeflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\tself.deflate.$websocket = self;\n\t\tself.deflate.on('error', function() {\n\t\t\tif (!self.$uerror) {\n\t\t\t\tself.$uerror = true;\n\t\t\t\tself.close('Invalid data', 1003);\n\t\t\t}\n\t\t});\n\t\tself.deflate.on('data', websocket_deflate);\n\t}\n\n\tself._id = Date.now() + U.GUID(5);\n\tself.id = self._id;\n\treturn true;\n};\n\nfunction websocket_inflate(data) {\n\tthis.$websocket.inflatechunks.push(data);\n\tthis.$websocket.inflatechunkslength += data.length;\n}\n\nfunction websocket_deflate(data) {\n\tthis.$websocket.deflatechunks.push(data);\n\tthis.$websocket.deflatechunkslength += data.length;\n}\n\n/**\n * Add a container to client\n * @param {WebSocket} container\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.upgrade = function(container) {\n\tvar self = this;\n\tself.req.on('error', websocket_onerror);\n\tself.container = container;\n\tself.socket.$websocket = this;\n\tself.socket.on('data', websocket_ondata);\n\tself.socket.on('error', websocket_onerror);\n\tself.socket.on('close', websocket_close);\n\tself.socket.on('end', websocket_close);\n\tself.container.$add(self);\n\tself.container.$refresh();\n\tF.$events['websocket-begin'] && EMIT('websocket-begin', self.container, self);\n\tself.container.$events.open && self.container.emit('open', self);\n\treturn self;\n};\n\nfunction websocket_ondata(chunk) {\n\tthis.$websocket.$ondata(chunk);\n}\n\nfunction websocket_onerror(e) {\n\tthis.destroy && this.destroy();\n\tthis.$websocket.$onerror(e);\n}\n\nfunction websocket_close() {\n\tthis.destroy && this.destroy();\n\tthis.$websocket.$onclose();\n}\n\nWebSocketClient.prototype.$ondata = function(data) {\n\n\tif (this.isClosed)\n\t\treturn;\n\n\tvar current = this.current;\n\n\tif (data) {\n\t\tif (current.buffer) {\n\t\t\tCONCAT[0] = current.buffer;\n\t\t\tCONCAT[1] = data;\n\t\t\tcurrent.buffer = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tcurrent.buffer = data;\n\t}\n\n\tif (!this.$parse())\n\t\treturn;\n\n\tif (!current.final && current.type !== 0x00)\n\t\tcurrent.type2 = current.type;\n\n\tvar tmp;\n\n\tswitch (current.type === 0x00 ? current.type2 : current.type) {\n\t\tcase 0x01:\n\n\t\t\t// text\n\t\t\tif (this.inflate) {\n\t\t\t\tcurrent.final && this.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = this.$readbody();\n\t\t\t\tif (current.body)\n\t\t\t\t\tcurrent.body += tmp;\n\t\t\t\telse\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && this.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\n\t\t\t// binary\n\t\t\tif (this.inflate) {\n\t\t\t\tcurrent.final && this.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = this.$readbody();\n\t\t\t\tif (current.body) {\n\t\t\t\t\tCONCAT[0] = current.body;\n\t\t\t\t\tCONCAT[1] = tmp;\n\t\t\t\t\tcurrent.body = Buffer.concat(CONCAT);\n\t\t\t\t} else\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && this.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\t// close\n\t\t\tthis.closemessage = current.buffer.slice(4).toString('utf8');\n\t\t\tthis.closecode = current.buffer[2] << 8 | current.buffer[3];\n\n\t\t\tif (this.closemessage && CONF.default_websocket_encodedecode)\n\t\t\t\tthis.closemessage = $decodeURIComponent(this.closemessage);\n\n\t\t\tthis.close();\n\t\t\tbreak;\n\n\t\tcase 0x09:\n\t\t\t// ping, response pong\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, 'PONG', 0x0A));\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tthis.$ping = true;\n\t\t\tbreak;\n\n\t\tcase 0x0a:\n\t\t\t// pong\n\t\t\tthis.$ping = true;\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tbreak;\n\t}\n\n\tif (current.buffer) {\n\t\tcurrent.buffer = current.buffer.slice(current.length, current.buffer.length);\n\t\tcurrent.buffer.length && this.$ondata();\n\t}\n};\n\nfunction buffer_concat(buffers, length) {\n\tvar buffer = U.createBufferSize(length);\n\tvar offset = 0;\n\tfor (var i = 0, n = buffers.length; i < n; i++) {\n\t\tbuffers[i].copy(buffer, offset);\n\t\toffset += buffers[i].length;\n\t}\n\treturn buffer;\n}\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nWebSocketClient.prototype.$parse = function() {\n\n\tvar self = this;\n\tvar current = self.current;\n\n\t// check end message\n\tif (!current.buffer || current.buffer.length <= 2 || ((current.buffer[0] & 0x80) >> 7) !== 1)\n\t\treturn;\n\n\t// webSocked - Opcode\n\tcurrent.type = current.buffer[0] & 0x0f;\n\n\t// is final message?\n\tcurrent.final = ((current.buffer[0] & 0x80) >> 7) === 0x01;\n\n\t// does frame contain mask?\n\tcurrent.isMask = ((current.buffer[1] & 0xfe) >> 7) === 0x01;\n\n\t// data length\n\tvar length = U.getMessageLength(current.buffer, F.isLE);\n\t// index for data\n\n\tvar index = current.buffer[1] & 0x7f;\n\tindex = ((index === 126) ? 4 : (index === 127 ? 10 : 2)) + (current.isMask ? 4 : 0);\n\n\t// total message length (data + header)\n\tvar mlength = index + length;\n\n\tif (mlength > this.length) {\n\t\tthis.close('Frame is too large', 1009);\n\t\treturn;\n\t}\n\n\t// Check length of data\n\tif (current.buffer.length < mlength)\n\t\treturn;\n\n\tcurrent.length = mlength;\n\n\t// Not Ping & Pong\n\tif (current.type !== 0x09 && current.type !== 0x0A) {\n\n\t\t// does frame contain mask?\n\t\tif (current.isMask) {\n\t\t\tcurrent.mask = U.createBufferSize(4);\n\t\t\tcurrent.buffer.copy(current.mask, 0, index - 4, index);\n\t\t}\n\n\t\tif (this.inflate) {\n\n\t\t\tvar buf = U.createBufferSize(length);\n\t\t\tcurrent.buffer.copy(buf, 0, index, mlength);\n\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask) {\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t\tbuf[i] = buf[i] ^ current.mask[i % 4];\n\t\t\t}\n\n\t\t\t// Does the buffer continue?\n\t\t\tbuf.$continue = current.final === false;\n\t\t\tthis.inflatepending.push(buf);\n\t\t} else {\n\t\t\tcurrent.data = U.createBufferSize(length);\n\t\t\tcurrent.buffer.copy(current.data, 0, index, mlength);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nWebSocketClient.prototype.$readbody = function() {\n\n\tvar current = this.current;\n\tvar length = current.data.length;\n\tvar buf;\n\n\tif (current.type === 1) {\n\n\t\tbuf = U.createBufferSize(length);\n\t\tfor (var i = 0; i < length; i++)  {\n\t\t\tif (current.isMask)\n\t\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\t\telse\n\t\t\t\tbuf[i] = current.data[i];\n\t\t}\n\n\t\treturn buf.toString('utf8');\n\n\t} else {\n\n\t\tbuf = U.createBufferSize(length);\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask)\n\t\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\t\telse\n\t\t\t\tbuf[i] = current.data[i];\n\t\t}\n\t\treturn buf;\n\t}\n};\n\nWebSocketClient.prototype.$decode = function() {\n\tvar data = this.current.body;\n\n\tswitch (this.type) {\n\n\t\tcase 1: // BINARY\n\t\t\tthis.container.emit('message', this, new Uint8Array(data).buffer);\n\t\t\tbreak;\n\n\t\tcase 3: // JSON\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tCONF.default_websocket_encodedecode === true && (data = $decodeURIComponent(data));\n\t\t\tif (data.isJSON()) {\n\t\t\t\tvar tmp = F.onParseJSON(data, this.req);\n\t\t\t\tif (tmp !== undefined)\n\t\t\t\t\tthis.container.emit('message', this, tmp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: // TEXT\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tthis.container.emit('message', this, CONF.default_websocket_encodedecode === true ? $decodeURIComponent(data) : data);\n\t\t\tbreak;\n\t}\n\n\tthis.current.body = null;\n};\n\nWebSocketClient.prototype.parseInflate = function() {\n\tvar self = this;\n\n\tif (self.inflatelock)\n\t\treturn;\n\n\tvar buf = self.inflatepending.shift();\n\tif (buf) {\n\t\tself.inflatechunks = [];\n\t\tself.inflatechunkslength = 0;\n\t\tself.inflatelock = true;\n\t\tself.inflate.write(buf);\n\t\t!buf.$continue && self.inflate.write(U.createBuffer(WEBSOCKET_COMPRESS));\n\t\tself.inflate.flush(function() {\n\n\t\t\tif (!self.inflatechunks)\n\t\t\t\treturn;\n\n\t\t\tvar data = buffer_concat(self.inflatechunks, self.inflatechunkslength);\n\n\t\t\tself.inflatechunks = null;\n\t\t\tself.inflatelock = false;\n\n\t\t\tif (data.length > self.length) {\n\t\t\t\tself.close('Frame is too large', 1009);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (self.current.body) {\n\t\t\t\tCONCAT[0] = self.current.body;\n\t\t\t\tCONCAT[1] = data;\n\t\t\t\tself.current.body = Buffer.concat(CONCAT);\n\t\t\t} else\n\t\t\t\tself.current.body = data;\n\n\t\t\t!buf.$continue && self.$decode();\n\t\t\tself.parseInflate();\n\t\t});\n\t}\n};\n\nWebSocketClient.prototype.$onerror = function(err) {\n\n\tif (this.isClosed)\n\t\treturn;\n\n\tif (REG_WEBSOCKET_ERROR.test(err.stack)) {\n\t\tthis.isClosed = true;\n\t\tthis.$onclose();\n\t} else\n\t\tthis.container.$events.error && this.container.emit('error', err, this);\n};\n\nWebSocketClient.prototype.$onclose = function() {\n\tif (this._isClosed)\n\t\treturn;\n\n\tthis.isClosed = true;\n\tthis._isClosed = true;\n\n\tif (this.inflate) {\n\t\tthis.inflate.removeAllListeners();\n\t\tthis.inflate = null;\n\t\tthis.inflatechunks = null;\n\t}\n\n\tif (this.deflate) {\n\t\tthis.deflate.removeAllListeners();\n\t\tthis.deflate = null;\n\t\tthis.deflatechunks = null;\n\t}\n\n\tthis.container.$remove(this._id);\n\tthis.container.$refresh();\n\tthis.container.$events.close && this.container.emit('close', this, this.closecode, this.closemessage);\n\tthis.socket.removeAllListeners();\n\tF.$events['websocket-end'] && EMIT('websocket-end', this.container, this);\n};\n\n/**\n * Sends a message\n * @param {String/Object} message\n * @param {Boolean} raw The message won't be converted e.g. to JSON.\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.send = function(message, raw, replacer) {\n\n\tvar self = this;\n\n\tif (self.isClosed)\n\t\treturn self;\n\n\tif (self.type !== 1) {\n\t\tvar data = self.type === 3 ? (raw ? message : JSON.stringify(message, replacer)) : typeof(message) === 'object' ? JSON.stringify(message, replacer) : message.toString();\n\t\tif (CONF.default_websocket_encodedecode === true && data)\n\t\t\tdata = encodeURIComponent(data);\n\t\tif (self.deflate) {\n\t\t\tself.deflatepending.push(U.createBuffer(data));\n\t\t\tself.sendDeflate();\n\t\t} else\n\t\t\tself.socket.write(U.getWebSocketFrame(0, data, 0x01));\n\t} else if (message) {\n\t\tif (self.deflate) {\n\t\t\tself.deflatepending.push(U.createBuffer(message));\n\t\t\tself.sendDeflate();\n\t\t} else\n\t\t\tself.socket.write(U.getWebSocketFrame(0, new Int8Array(message), 0x02));\n\t}\n\n\treturn self;\n};\n\nWebSocketClient.prototype.sendDeflate = function() {\n\tvar self = this;\n\n\tif (self.deflatelock)\n\t\treturn;\n\n\tvar buf = self.deflatepending.shift();\n\tif (buf) {\n\t\tself.deflatechunks = [];\n\t\tself.deflatechunkslength = 0;\n\t\tself.deflatelock = true;\n\t\tself.deflate.write(buf);\n\t\tself.deflate.flush(function() {\n\t\t\tif (self.deflatechunks) {\n\t\t\t\tvar data = buffer_concat(self.deflatechunks, self.deflatechunkslength);\n\t\t\t\tdata = data.slice(0, data.length - 4);\n\t\t\t\tself.deflatelock = false;\n\t\t\t\tself.deflatechunks = null;\n\t\t\t\tself.socket.write(U.getWebSocketFrame(0, data, self.type === 1 ? 0x02 : 0x01, true));\n\t\t\t\tself.sendDeflate();\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Ping message\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.ping = function() {\n\tif (!this.isClosed) {\n\t\tthis.socket.write(U.getWebSocketFrame(0, 'PING', 0x09));\n\t\tthis.$ping = false;\n\t}\n\treturn this;\n};\n\n/**\n * Close connection\n * @param {String} message Message.\n * @param {Number} code WebSocket code.\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.close = function(message, code) {\n\tvar self = this;\n\tif (!self.isClosed) {\n\t\tself.isClosed = true;\n\t\tif (self.ready)\n\t\t\tself.socket.end(U.getWebSocketFrame(code || 1000, message ? (CONF.default_websocket_encodedecode ? encodeURIComponent(message) : message) : '', 0x08));\n\t\telse\n\t\t\tself.socket.end();\n\t\tself.req.connection.destroy();\n\t}\n\treturn self;\n};\n\n/**\n * Create a signature for the WebSocket\n * @param {Request} req\n * @return {String}\n */\nWebSocketClient.prototype.$websocket_key = function(req) {\n\tvar sha1 = Crypto.createHash('sha1');\n\tsha1.update((req.headers['sec-websocket-key'] || '') + SOCKET_HASH);\n\treturn sha1.digest('base64');\n};\n\n// *********************************************************************************\n// =================================================================================\n// Prototypes\n// =================================================================================\n// *********************************************************************************\n\nfunction extend_request(PROTO) {\n\n\tPROTOREQ = PROTO;\n\n\tObject.defineProperty(PROTO, 'ip', {\n\t\tget: function() {\n\t\t\tif (this._ip)\n\t\t\t\treturn this._ip;\n\n\t\t\t//  x-forwarded-for: client, proxy1, proxy2, ...\n\t\t\tvar proxy = this.headers['x-forwarded-for'];\n\t\t\tif (proxy)\n\t\t\t\tthis._ip = proxy.split(',', 1)[0] || this.connection.remoteAddress;\n\t\t\telse if (!this._ip)\n\t\t\t\tthis._ip = this.connection.remoteAddress;\n\n\t\t\treturn this._ip;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'query', {\n\t\tget: function() {\n\t\t\t!this._querydata && F.$onParseQueryUrl(this);\n\t\t\treturn this._querydata;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis._querydata = value;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'subdomain', {\n\t\tget: function() {\n\t\t\tif (this._subdomain)\n\t\t\t\treturn this._subdomain;\n\t\t\tvar subdomain = this.uri.hostname.toLowerCase().replace(REG_WWW, '').split('.');\n\t\t\tif (subdomain.length > 2) // example: [subdomain].domain.com\n\t\t\t\tthis._subdomain = subdomain.slice(0, subdomain.length - 2);\n\t\t\telse if (subdomain.length > 1 && subdomain[subdomain.length - 1] === 'localhost') // example: [subdomain].localhost\n\t\t\t\tthis._subdomain = subdomain.slice(0, subdomain.length - 1);\n\t\t\telse\n\t\t\t\tthis._subdomain = null;\n\t\t\treturn this._subdomain;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'host', {\n\t\tget: function() {\n\t\t\treturn this.headers['host'];\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'split', {\n\t\tget: function() {\n\t\t\treturn this.$path ? this.$path : this.$path = framework_internal.routeSplit(this.uri.pathname, true);\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'secured', {\n\t\tget: function() {\n\t\t\treturn this.uri.protocol === 'https:' || this.uri.protocol === 'wss:';\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'language', {\n\t\tget: function() {\n\t\t\tif (!this.$language)\n\t\t\t\tthis.$language = (((this.headers['accept-language'] || '').split(';')[0] || '').split(',')[0] || '').toLowerCase();\n\t\t\treturn this.$language;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.$language = value;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'mobile', {\n\t\tget: function() {\n\t\t\tif (this.$mobile === undefined)\n\t\t\t\tthis.$mobile = REG_MOBILE.test(this.headers['user-agent']);\n\t\t\treturn this.$mobile;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'robot', {\n\t\tget: function() {\n\t\t\tif (this.$robot === undefined)\n\t\t\t\tthis.$robot = REG_ROBOT.test(this.headers['user-agent']);\n\t\t\treturn this.$robot;\n\t\t}\n\t});\n\n\t/**\n\t * Signature request (user-agent + ip + referer + current URL + custom key)\n\t * @param {String} key Custom key.\n\t * @return {Request}\n\t */\n\tPROTO.signature = function(key) {\n\t\treturn F.encrypt((this.headers['user-agent'] || '') + '#' + this.ip + '#' + this.url + '#' + (key || ''), 'request-signature', false);\n\t};\n\n\tPROTO.localize = function() {\n\t\tF.onLocale && (this.$language = F.onLocale(this, this.res, this.isStaticFile));\n\t\treturn this.$language;\n\t};\n\n\t/**\n\t * Disable HTTP cache for current request\n\t * @return {Request}\n\t */\n\tPROTO.noCache = function() {\n\t\tthis.res && this.res.noCache();\n\t\treturn this;\n\t};\n\n\t/**\n\t * Read a cookie from current request\n\t * @param {String} name Cookie name.\n\t * @return {String} Cookie value (default: '')\n\t */\n\tPROTO.cookie = function(name) {\n\n\t\tif (this.cookies)\n\t\t\treturn $decodeURIComponent(this.cookies[name] || '');\n\n\t\tvar cookie = this.headers['cookie'];\n\t\tif (!cookie)\n\t\t\treturn '';\n\n\t\tthis.cookies = {};\n\n\t\tvar arr = cookie.split(';');\n\n\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\tvar line = arr[i].trim();\n\t\t\tvar index = line.indexOf('=');\n\t\t\tif (index !== -1)\n\t\t\t\tthis.cookies[line.substring(0, index)] = line.substring(index + 1);\n\t\t}\n\n\t\treturn $decodeURIComponent(this.cookies[name] || '');\n\t};\n\n\t/**\n\t * Read authorization header\n\t * @return {Object}\n\t */\n\tPROTO.authorization = function() {\n\n\t\tvar authorization = this.headers['authorization'];\n\t\tif (!authorization)\n\t\t\treturn HEADERS.authorization;\n\n\t\tvar result = { user: '', password: '', empty: true };\n\n\t\ttry {\n\t\t\tvar arr = U.createBuffer(authorization.replace('Basic ', '').trim(), 'base64').toString(ENCODING).split(':');\n\t\t\tresult.user = arr[0] || '';\n\t\t\tresult.password = arr[1] || '';\n\t\t\tresult.empty = !result.user || !result.password;\n\t\t} catch (e) {}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Authorization for custom delegates\n\t * @param  {Function(err, userprofile, isAuthorized)} callback\n\t * @return {Request}\n\t */\n\tPROTO.authorize = function(callback) {\n\n\t\tvar auth = F.onAuthorize;\n\n\t\tif (!auth) {\n\t\t\tcallback(null, null, false);\n\t\t\treturn this;\n\t\t}\n\n\t\tvar req = this;\n\n\t\tauth(req, req.res, req.flags || [], function(isAuthorized, user) {\n\t\t\tif (typeof(isAuthorized) !== 'boolean') {\n\t\t\t\tuser = isAuthorized;\n\t\t\t\tisAuthorized = !user;\n\t\t\t}\n\t\t\treq.isAuthorized = isAuthorized;\n\t\t\tcallback(null, user, isAuthorized);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Clear all uplaoded files\n\t * @private\n\t * @param {Boolean} isAuto\n\t * @return {Request}\n\t */\n\tPROTO.clear = function(isAuto) {\n\n\t\tvar self = this;\n\t\tvar files = self.files;\n\n\t\tif (!files || (isAuto && self._manual))\n\t\t\treturn self;\n\n\t\tself.body = null;\n\t\tself.query = null;\n\t\tself.cookies = null;\n\n\t\tvar length = files.length;\n\t\tif (!length)\n\t\t\treturn self;\n\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tfiles[i].rem && arr.push(files[i].path);\n\n\t\tF.unlink(arr);\n\t\tself.files = null;\n\t\treturn self;\n\t};\n\n\t/**\n\t * Get host name from URL\n\t * @param {String} path Additional path.\n\t * @return {String}\n\t */\n\tPROTO.hostname = function(path) {\n\n\t\tvar self = this;\n\t\tvar uri = self.uri;\n\n\t\tif (path && path[0] !== '/')\n\t\t\tpath = '/' + path;\n\n\t\treturn uri.protocol + '//' + uri.hostname + (uri.port && uri.port !== 80 ? ':' + uri.port : '') + (path || '');\n\t};\n\n\tPROTO.$total_success = function() {\n\t\tthis.$total_timeout && clearTimeout(this.$total_timeout);\n\t\tthis.$total_canceled = true;\n\t\tif (this.controller) {\n\t\t\tthis.controller.res.controller = null;\n\t\t\tthis.controller = null;\n\t\t}\n\t};\n\n\tPROTO.$total_file = function() {\n\t\tvar h = this.method[0];\n\t\tif (h === 'G' || h === 'H')\n\t\t\tthis.$total_endfile();\n\t\telse\n\t\t\tthis.on('end', this.$total_endfile);\n\t};\n\n\tPROTO.$total_multipart = function(header) {\n\t\tF.stats.request.upload++;\n\t\tthis.$total_route = F.lookup(this, this.uri.pathname, this.flags, 0);\n\t\tthis.$total_header = header;\n\t\tif (this.$total_route) {\n\t\t\tF.path.verify('temp');\n\t\t\tframework_internal.parseMULTIPART(this, header, this.$total_route, CONF.directory_temp);\n\t\t} else\n\t\t\tthis.$total_status(404);\n\t};\n\n\tPROTO.$total_urlencoded = function() {\n\t\tthis.$total_route = F.lookup(this, this.uri.pathname, this.flags, 0);\n\t\tif (this.$total_route) {\n\t\t\tthis.buffer_has = true;\n\t\t\tthis.buffer_exceeded = false;\n\t\t\tthis.on('data', this.$total_parsebody);\n\t\t\tthis.$total_end();\n\t\t} else\n\t\t\tthis.$total_status(404);\n\t};\n\n\tPROTO.$total_status = function(status) {\n\n\t\tif (status == null)\n\t\t\tF.stats.request.blocked++;\n\t\telse\n\t\t\tF.stats.request['error' + status]++;\n\n\t\tF.reqstats(false, false);\n\t\tthis.res.writeHead(status);\n\t\tthis.res.end(U.httpStatus(status));\n\t\tF.$events['request-end'] && EMIT('request-end', this, this.res);\n\t\tthis.clear(true);\n\t};\n\n\tPROTO.$total_end = function() {\n\t\tvar h = this.method[0];\n\t\tif (h === 'G' || h === 'H' || h === 'O') {\n\t\t\tif (this.$total_route && this.$total_route.schema)\n\t\t\t\tthis.$total_schema = true;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t} else\n\t\t\tthis.on('end', this.$total_end2);\n\t};\n\n\tPROTO.$total_execute = function(status, isError) {\n\n\t\tvar route = this.$total_route;\n\t\tvar res = this.res;\n\n\t\tif (isError || !route) {\n\t\t\tF.stats.response['error' + status]++;\n\t\t\tstatus !== 500 && F.$events['error'] && EMIT('error' + status, this, res, this.$total_exception);\n\t\t}\n\n\t\tif (!route) {\n\t\t\tif (status === 400 && this.$total_exception instanceof framework_builders.ErrorBuilder) {\n\t\t\t\tF.stats.response.errorBuilder++;\n\t\t\t\tthis.$language && this.$total_exception.setResource(this.$language);\n\t\t\t\tres.options.body = this.$total_exception.output(true);\n\t\t\t\tres.options.code = this.$total_exception.status;\n\t\t\t\tres.options.type = this.$total_exception.contentType;\n\t\t\t\tres.$text();\n\t\t\t} else {\n\n\t\t\t\tMODELERROR.code = status;\n\t\t\t\tMODELERROR.status = U.httpStatus(status, false);\n\t\t\t\tMODELERROR.error = this.$total_exception ? prepare_error(this.$total_exception) : null;\n\n\t\t\t\tres.options.body = F.view('.' + PATHMODULES + 'error', MODELERROR);\n\t\t\t\tres.options.type = CT_HTML;\n\t\t\t\tres.options.code = status || 404;\n\t\t\t\tres.$text();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar name = route.controller;\n\n\t\tif (route.isMOBILE_VARY)\n\t\t\tthis.$mobile = true;\n\n\t\tif (route.currentViewDirectory === undefined)\n\t\t\troute.currentViewDirectory = name && name[0] !== '#' && name !== 'default' && name !== 'unknown' ? '/' + name + '/' : '';\n\n\t\tvar controller = new Controller(name, this, res, route.currentViewDirectory);\n\n\t\tcontroller.isTransfer = this.$total_transfer;\n\t\tcontroller.exception = this.$total_exception;\n\t\tthis.controller = controller;\n\n\t\tif (!this.$total_canceled && route.timeout) {\n\t\t\tthis.$total_timeout && clearTimeout(this.$total_timeout);\n\t\t\tthis.$total_timeout = setTimeout(subscribe_timeout, route.timeout, this);\n\t\t}\n\n\t\troute.isDELAY && res.writeContinue();\n\n\t\tif (this.$total_schema)\n\t\t\tthis.body.$$controller = controller;\n\n\t\tif (route.middleware)\n\t\t\tasync_middleware(0, this, res, route.middleware, subscribe_timeout_middleware, route.options, controller);\n\t\telse\n\t\t\tthis.$total_execute2();\n\t};\n\n\tPROTO.$total_execute2 = function() {\n\n\t\tvar name = this.$total_route.controller;\n\t\tvar controller = this.controller;\n\n\t\ttry {\n\n\t\t\tif (F.onTheme)\n\t\t\t\tcontroller.themeName = F.onTheme(controller);\n\n\t\t\tif (controller.isCanceled)\n\t\t\t\treturn;\n\n\t\t\tvar ctrlname = '@' + name;\n\t\t\tF.$events.controller && EMIT('controller', controller, name, this.$total_route.options);\n\t\t\tF.$events[ctrlname] && EMIT(ctrlname, controller, name, this.$total_route.options);\n\n\t\t\tif (controller.isCanceled)\n\t\t\t\treturn;\n\n\t\t\tif (this.$total_route.isCACHE && !F.temporary.other[this.uri.pathname])\n\t\t\t\tF.temporary.other[this.uri.pathname] = this.path;\n\n\t\t\tif (this.$total_route.isGENERATOR)\n\t\t\t\tasync.call(controller, this.$total_route.execute, true)(controller, framework_internal.routeParam(this.$total_route.param.length ? this.split : this.path, this.$total_route));\n\t\t\telse {\n\t\t\t\tif (this.$total_route.param.length)\n\t\t\t\t\tthis.$total_route.execute.apply(controller, framework_internal.routeParam(this.split, this.$total_route));\n\t\t\t\telse\n\t\t\t\t\tthis.$total_route.execute.call(controller);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tF.error(err, name, this.uri);\n\t\t\tthis.$total_exception = err;\n\t\t\tthis.$total_route = F.lookup(this, '#500', EMPTYARRAY, 0);\n\t\t\tthis.$total_execute(500, true);\n\t\t}\n\t};\n\n\tPROTO.$total_parsebody = function(chunk) {\n\n\t\tif (this.buffer_exceeded)\n\t\t\treturn;\n\n\t\tif (!this.buffer_exceeded) {\n\t\t\tCONCAT[0] = this.buffer_data;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tthis.buffer_data = Buffer.concat(CONCAT);\n\t\t}\n\n\t\tif ((this.buffer_data.length / 1024) < this.$total_route.length)\n\t\t\treturn;\n\n\t\tthis.buffer_exceeded = true;\n\t\tthis.buffer_data = U.createBuffer();\n\t};\n\n\tPROTO.$total_cancel = function() {\n\t\tF.stats.response.timeout++;\n\t\tclearTimeout(this.$total_timeout);\n\t\tif (!this.controller)\n\t\t\treturn;\n\t\tthis.controller.isTimeout = true;\n\t\tthis.controller.isCanceled = true;\n\t\tthis.$total_route = F.lookup(this, '#408', EMPTYARRAY, 0);\n\t\tthis.$total_execute(408, true);\n\t};\n\n\tPROTO.$total_validate = function(route, next, code) {\n\n\t\tvar self = this;\n\t\tself.$total_schema = false;\n\n\t\tif (!self.$total_route.schema || self.method === 'DELETE')\n\t\t\treturn next(self, code);\n\n\t\tif (!self.$total_route.schema[1]) {\n\t\t\tF.stats.request.operation++;\n\t\t\treturn next(self, code);\n\t\t}\n\n\t\tF.onSchema(self, self.$total_route, function(err, body) {\n\t\t\tif (err) {\n\t\t\t\tif (self.$total_route.isDYNAMICSCHEMA)\n\t\t\t\t\tself.$total_404(err);\n\t\t\t\telse\n\t\t\t\t\tself.$total_400(err);\n\t\t\t\tnext = null;\n\t\t\t} else {\n\t\t\t\tF.stats.request.schema++;\n\t\t\t\tself.body = body;\n\t\t\t\tself.$total_schema = true;\n\t\t\t\tnext(self, code);\n\t\t\t}\n\t\t});\n\t};\n\n\tPROTO.$total_authorize = function(isLogged, user, roles) {\n\n\t\tvar membertype = isLogged ? 1 : 2;\n\t\tvar code = this.buffer_exceeded ? 431 : 401;\n\n\t\tthis.$flags += membertype;\n\t\tuser && (this.user = user);\n\n\t\tif (this.$total_route && this.$total_route.isUNIQUE && !roles && (!this.$total_route.MEMBER || this.$total_route.MEMBER === membertype)) {\n\t\t\tif (code === 401 && this.$total_schema)\n\t\t\t\tthis.$total_validate(this.$total_route, subscribe_validate_callback, code);\n\t\t\telse\n\t\t\t\tthis.$total_execute(code, true);\n\t\t} else {\n\t\t\tvar route = F.lookup(this, this.buffer_exceeded ? '#431' : this.uri.pathname, this.flags, this.buffer_exceeded ? 0 : membertype);\n\t\t\tvar status = this.$isAuthorized ? 404 : 401;\n\t\t\tvar code = this.buffer_exceeded ? 431 : status;\n\t\t\t!route && (route = F.lookup(this, '#' + status, EMPTYARRAY, 0));\n\n\t\t\tthis.$total_route = route;\n\n\t\t\tif (this.$total_route && this.$total_schema)\n\t\t\t\tthis.$total_validate(this.$total_route, subscribe_validate_callback, code);\n\t\t\telse\n\t\t\t\tthis.$total_execute(code);\n\t\t}\n\t};\n\n\tPROTO.$total_end2 = function() {\n\n\t\tvar route = this.$total_route;\n\n\t\tif (this.buffer_exceeded) {\n\t\t\troute = F.lookup(this, '#431', EMPTYARRAY, 0);\n\t\t\tthis.buffer_data = null;\n\t\t\tif (route) {\n\t\t\t\tthis.$total_route = route;\n\t\t\t\tthis.$total_execute(431, true);\n\t\t\t} else\n\t\t\t\tthis.res.throw431();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.buffer_data && (!route || !route.isBINARY))\n\t\t\tthis.buffer_data = this.buffer_data.toString(ENCODING);\n\n\t\tif (!this.buffer_data) {\n\t\t\tif (route && route.schema)\n\t\t\t\tthis.$total_schema = true;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t\treturn;\n\t\t}\n\n\t\tif (route.isXML) {\n\n\t\t\tif (this.$type !== 2) {\n\t\t\t\tthis.$total_400('Invalid \"Content-Type\".');\n\t\t\t\tthis.buffer_data = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tF.$onParseXML(this);\n\t\t\t\tthis.buffer_data = null;\n\t\t\t\tthis.$total_prepare();\n\t\t\t} catch (err) {\n\t\t\t\tF.error(err, null, this.uri);\n\t\t\t\tthis.$total_500(err);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (route.isRAW) {\n\t\t\tthis.body = this.buffer_data;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.$type) {\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_400('Invalid \"Content-Type\".');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.$type === 1) {\n\t\t\ttry {\n\t\t\t\tF.$onParseJSON(this);\n\t\t\t\tthis.buffer_data = null;\n\t\t\t} catch (e) {\n\t\t\t\tthis.$total_400('Invalid JSON data.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tF.$onParseQueryBody(this);\n\n\t\troute.schema && (this.$total_schema = true);\n\t\tthis.buffer_data = null;\n\t\tthis.$total_prepare();\n\t};\n\n\tPROTO.$total_endfile = function() {\n\n\t\tvar req = this;\n\t\tvar res = this.res;\n\n\t\tif (!F._length_files)\n\t\t\treturn res.continue();\n\n\t\tfor (var i = 0; i < F._length_files; i++) {\n\n\t\t\tvar file = F.routes.files[i];\n\t\t\t// try {\n\n\t\t\tif (file.extensions && !file.extensions[req.extension])\n\t\t\t\tcontinue;\n\n\t\t\tif (file.url) {\n\t\t\t\tvar skip = false;\n\t\t\t\tvar length = file.url.length;\n\n\t\t\t\tif (!file.wildcard && !file.fixedfile && length !== req.path.length - 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tif (file.url[j] === req.path[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t} else if (file.onValidate && !file.onValidate(req, res, true))\n\t\t\t\tcontinue;\n\n\t\t\tif (file.middleware)\n\t\t\t\treq.$total_endfilemiddleware(file);\n\t\t\telse\n\t\t\t\tfile.execute(req, res, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tres.continue();\n\t};\n\n\tPROTO.$total_endfilemiddleware = function(file) {\n\t\tthis.$total_filemiddleware = file;\n\t\tasync_middleware(0, this, this.res, file.middleware, total_endmiddleware, file.options);\n\t};\n\n\tPROTO.$total_400 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#400', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(400, true);\n\t};\n\n\tPROTO.$total_404 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#404', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(404, true);\n\t};\n\n\tPROTO.$total_500 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#500', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(500, true);\n\t};\n\n\tPROTO.$total_prepare = function() {\n\t\tvar req = this;\n\t\tvar length = req.flags.length;\n\t\tif (F.onAuthorize) {\n\t\t\tF.onAuthorize(req, req.res, req.flags, function(isAuthorized, user) {\n\t\t\t\tvar hasRoles = length !== req.flags.length;\n\n\t\t\t\tif (hasRoles) {\n\t\t\t\t\treq.$flags += req.flags.slice(length).join('');\n\t\t\t\t\treq.$roles = true;\n\t\t\t\t}\n\n\t\t\t\tif (typeof(isAuthorized) !== 'boolean') {\n\t\t\t\t\tuser = isAuthorized;\n\t\t\t\t\tisAuthorized = !user;\n\t\t\t\t}\n\t\t\t\treq.isAuthorized = isAuthorized;\n\t\t\t\treq.$total_authorize(isAuthorized, user, hasRoles);\n\t\t\t});\n\t\t} else {\n\t\t\tif (!req.$total_route)\n\t\t\t\treq.$total_route = F.lookup(req, req.buffer_exceeded ? '#431' : req.uri.pathname, req.flags, 0);\n\t\t\tif (!req.$total_route)\n\t\t\t\treq.$total_route = F.lookup(req, '#404', EMPTYARRAY, 0);\n\t\t\tvar code = req.buffer_exceeded ? 431 : 404;\n\t\t\tif (!req.$total_schema || !req.$total_route)\n\t\t\t\treq.$total_execute(code);\n\t\t\telse\n\t\t\t\treq.$total_validate(req.$total_route, subscribe_validate_callback, code);\n\t\t}\n\t};\n}\n\nfunction total_endmiddleware(req) {\n\n\tif (req.total_middleware)\n\t\treq.total_middleware = null;\n\n\ttry {\n\t\treq.$total_filemiddleware.execute(req, req.res, false);\n\t} catch (err) {\n\t\tF.error(err, req.$total_filemiddleware.controller + ' :: ' + req.$total_filemiddleware.name, req.uri);\n\t\treq.res.throw500();\n\t}\n}\n\nfunction extend_response(PROTO) {\n\n\tPROTORES = PROTO;\n\n\t/**\n\t * Add a cookie into the response\n\t * @param {String} name\n\t * @param {Object} value\n\t * @param {Date/String} expires\n\t * @param {Object} options Additional options.\n\t * @return {Response}\n\t */\n\tPROTO.cookie = function(name, value, expires, options) {\n\n\t\tvar self = this;\n\n\t\tif (self.headersSent || self.success)\n\t\t\treturn;\n\n\t\tvar cookiename = name + '=';\n\t\tvar builder = [cookiename + value];\n\t\tvar type = typeof(expires);\n\n\t\tif (expires && !U.isDate(expires) && type === 'object') {\n\t\t\toptions = expires;\n\t\t\texpires = options.expires || options.expire || null;\n\t\t}\n\n\t\tif (type === 'string')\n\t\t\texpires = expires.parseDateExpiration();\n\n\t\tif (!options)\n\t\t\toptions = {};\n\n\t\toptions.path = options.path || '/';\n\t\texpires && builder.push('Expires=' + expires.toUTCString());\n\t\toptions.domain && builder.push('Domain=' + options.domain);\n\t\toptions.path && builder.push('Path=' + options.path);\n\t\toptions.secure && builder.push('Secure');\n\n\t\tif (options.httpOnly || options.httponly || options.HttpOnly)\n\t\t\tbuilder.push('HttpOnly');\n\n\t\tvar same = options.security || options.samesite || options.sameSite;\n\t\tif (same) {\n\t\t\tswitch (same) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsame = 'lax';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsame = 'strict';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuilder.push('SameSite=' + same);\n\t\t}\n\n\t\tvar arr = self.getHeader('set-cookie') || [];\n\n\t\t// Cookie, already, can be in array, resulting in duplicate 'set-cookie' header\n\t\tif (arr.length) {\n\t\t\tvar l = cookiename.length;\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tif (arr[i].substring(0, l) === cookiename) {\n\t\t\t\t\tarr.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tarr.push(builder.join('; '));\n\t\tself.setHeader('Set-Cookie', arr);\n\t\treturn self;\n\t};\n\n\t/**\n\t * Disable HTTP cache for current response\n\t * @return {Response}\n\t */\n\tPROTO.noCache = function() {\n\t\tvar self = this;\n\n\t\tif (self.$nocache)\n\t\t\treturn self;\n\n\t\tif (self.req) {\n\t\t\tdelete self.req.headers['if-none-match'];\n\t\t\tdelete self.req.headers['if-modified-since'];\n\t\t}\n\n\t\tif (self.getHeader(HEADER_CACHE)) {\n\t\t\tself.removeHeader(HEADER_CACHE);\n\t\t\tself.removeHeader('Expires');\n\t\t\tself.removeHeader('Etag');\n\t\t\tself.removeHeader('Last-Modified');\n\t\t\tself.setHeader(HEADER_CACHE, 'private, no-cache, no-store, max-age=0');\n\t\t\tself.setHeader('Expires', -1);\n\t\t}\n\n\t\tself.$nocache = true;\n\t\treturn self;\n\t};\n\n\t// For express middleware\n\tPROTO.status = function(code) {\n\t\tthis.options.code = code;\n\t\treturn this;\n\t};\n\n\t// For express middleware\n\tPROTO.send = function(code, body, type) {\n\n\t\tif (this.headersSent)\n\t\t\treturn this;\n\n\t\tthis.controller && this.req.$total_success();\n\n\t\tif (code instanceof Buffer) {\n\t\t\t// express.js static file\n\t\t\tif (!body && !type) {\n\t\t\t\tthis.end(code);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\tvar res = this;\n\t\tvar req = this.req;\n\t\tvar contentType = type;\n\t\tvar isHEAD = req.method === 'HEAD';\n\n\t\tif (body === undefined) {\n\t\t\tbody = code;\n\t\t\tcode = res.$statuscode || 200;\n\t\t}\n\n\t\tswitch (typeof(body)) {\n\t\t\tcase 'string':\n\t\t\t\tif (!contentType)\n\t\t\t\t\tcontentType = 'text/html';\n\t\t\t\tbreak;\n\n\t\t\tcase 'number':\n\t\t\t\tif (!contentType)\n\t\t\t\t\tcontentType = 'text/plain';\n\t\t\t\tbody = U.httpStatus(body);\n\t\t\t\tbreak;\n\n\t\t\tcase 'boolean':\n\t\t\tcase 'object':\n\t\t\t\tif (!isHEAD) {\n\t\t\t\t\tif (body instanceof framework_builders.ErrorBuilder) {\n\t\t\t\t\t\tvar json = body.output(true);\n\t\t\t\t\t\tif (body.status !== 200)\n\t\t\t\t\t\t\tres.options.code = body.status;\n\t\t\t\t\t\tif (body.contentType)\n\t\t\t\t\t\t\tcontentType = body.contentType;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontentType = CT_JSON;\n\t\t\t\t\t\tbody = json;\n\t\t\t\t\t\tF.stats.response.errorBuilder++;\n\t\t\t\t\t} else\n\t\t\t\t\t\tbody = JSON.stringify(body);\n\t\t\t\t\t!contentType && (contentType = CT_JSON);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\tvar headers = {};\n\n\t\theaders[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\n\t\theaders['Vary'] = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif ((/text|application/).test(contentType))\n\t\t\tcontentType += '; charset=utf-8';\n\n\t\theaders[HEADER_TYPE] = contentType;\n\t\tres.$custom();\n\n\t\tif (!accept && isGZIP(req))\n\t\t\taccept = 'gzip';\n\n\t\tvar compress = CONF.allow_gzip && accept.indexOf('gzip') !== -1;\n\t\tif (isHEAD) {\n\t\t\tcompress && (headers['Content-Encoding'] = 'gzip');\n\t\t\tres.writeHead(200, headers);\n\t\t\tres.end();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!compress) {\n\t\t\tres.writeHead(code, headers);\n\t\t\tres.end(body, ENCODING);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar buffer = U.createBuffer(body);\n\t\tZlib.gzip(buffer, function(err, data) {\n\n\t\t\tif (err) {\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.end(body, ENCODING);\n\t\t\t} else {\n\t\t\t\theaders['Content-Encoding'] = 'gzip';\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.end(data, ENCODING);\n\t\t\t}\n\t\t});\n\n\t\treturn res;\n\t};\n\n\t/**\n\t * Response a custom content\n\t * @param {Number} code\n\t * @param {String} body\n\t * @param {String} type\n\t * @param {Boolean} compress Disallows GZIP compression. Optional, default: true.\n\t * @param {Object} headers Optional, additional headers.\n\t * @return {Response}\n\t */\n\tPROTO.content = function(code, body, type, compress, headers) {\n\n\t\tif (typeof(compress) === 'object') {\n\t\t\tvar tmp = headers;\n\t\t\theaders = compress;\n\t\t\tcompress = tmp;\n\t\t}\n\n\t\tvar res = this;\n\t\tres.options.code = code;\n\t\tres.options.compress = compress === undefined || compress === true;\n\t\tres.options.body = body;\n\t\tres.options.type = type;\n\t\theaders && (res.options.headers = headers);\n\t\tres.$text();\n\t\treturn res;\n\t};\n\n\t/**\n\t * Response redirect\n\t * @param {String} url\n\t * @param {Boolean} permanent Optional, default: false.\n\t * @return {Framework}\n\t */\n\tPROTO.redirect = function(url, permanent) {\n\t\tthis.options.url = url;\n\t\tpermanent && (this.options.permanent = permanent);\n\t\tthis.$redirect();\n\t\treturn this;\n\t};\n\n\t/**\n\t * Responds with a file\n\t * @param {String} filename\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.file = function(filename, download, headers, callback) {\n\t\tthis.options.filename = filename;\n\t\theaders && (this.options.headers = headers);\n\t\tcallback && (this.options.callback = callback);\n\t\tdownload && (this.options.download = download);\n\t\treturn this.$file();\n\t};\n\n\t/**\n\t * Responds with a file from FileStorage\n\t * @param {String} name A name of FileStorage\n\t * @param {String/Number} id\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.filefs = function(name, id, download, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.download = download;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tFILESTORAGE(name).res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.filenosql = function(name, id, download, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.download = download;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tNOSQL(name).binary.res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.imagefs = function(name, id, make, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.image = true;\n\t\toptions.make = make;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tFILESTORAGE(name).res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.imagenosql = function(name, id, make, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.image = true;\n\t\toptions.make = make;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tNOSQL(name).binary.res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\t/**\n\t * Responds with a stream\n\t * @param {String} contentType\n\t * @param {Stream} stream\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.stream = function(type, stream, download, headers, callback, nocompress) {\n\t\tvar res = this;\n\t\tres.options.type = type;\n\t\tres.options.stream = stream;\n\t\tdownload && (res.options.download = download);\n\t\theaders && (res.options.headers = headers);\n\t\tcallback && (res.options.callback = callback);\n\t\tres.options.compress = nocompress ? false : true;\n\t\tres.$stream();\n\t\treturn res;\n\t};\n\n\tPROTO.binary = function(body, type, encoding, download, headers) {\n\n\t\tif (typeof(encoding) === 'object') {\n\t\t\tvar tmp = encoding;\n\t\t\tencoding = download;\n\t\t\tdownload = headers;\n\t\t\theaders = tmp;\n\t\t}\n\n\t\tif (typeof(download) === 'object') {\n\t\t\theaders = download;\n\t\t\tdownload = headers;\n\t\t}\n\n\t\tthis.options.type = type;\n\t\tthis.options.body = body;\n\t\tthis.options.encoding = encoding;\n\t\tdownload && (this.options.download = download);\n\t\theaders && (this.options.headers = headers);\n\t\tthis.$binary();\n\t\treturn this;\n\t};\n\n\tPROTO.proxy = function(url, headers, timeout, callback) {\n\n\t\tOBSOLETE('res.proxy()', 'You need to use controller.proxy()');\n\n\t\tvar res = this;\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tcallback && (res.options.callback = callback);\n\t\theaders && (res.options.headers = headers);\n\t\ttimeout && (res.options.timeout = timeout);\n\n\t\tU.resolve(url, function(err, uri) {\n\n\t\t\tvar headers = {};\n\n\t\t\theaders[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\n\t\t\tres.options.headers && U.extend_headers2(headers, res.options.headers);\n\n\t\t\tvar options = { protocol: uri.protocol, auth: uri.auth, method: 'GET', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: headers };\n\t\t\tvar connection = options.protocol === 'https:' ? require('https') : http;\n\t\t\tvar gzip = CONF.allow_gzip && (res.req.headers['accept-encoding'] || '').lastIndexOf('gzip') !== -1;\n\n\t\t\tvar client = connection.get(options, function(response) {\n\n\t\t\t\tif (res.success || res.headersSent)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar contentType = response.headers['content-type'];\n\t\t\t\tvar isGZIP = (response.headers['content-encoding'] || '').lastIndexOf('gzip') !== -1;\n\t\t\t\tvar compress = !isGZIP && gzip && (contentType.indexOf('text/') !== -1 || contentType.lastIndexOf('javascript') !== -1 || contentType.lastIndexOf('json') !== -1);\n\t\t\t\tvar attachment = response.headers['content-disposition'] || '';\n\n\t\t\t\tattachment && res.setHeader('Content-Disposition', attachment);\n\t\t\t\tres.setHeader(HEADER_TYPE, contentType);\n\t\t\t\tres.setHeader('Vary', 'Accept-Encoding' + (res.req.$mobile ? ', User-Agent' : ''));\n\n\t\t\t\tres.on('error', function() {\n\t\t\t\t\tresponse.close();\n\t\t\t\t\tresponse_end(res);\n\t\t\t\t});\n\n\t\t\t\tif (compress) {\n\t\t\t\t\tres.setHeader('Content-Encoding', 'gzip');\n\t\t\t\t\tresponse.pipe(Zlib.createGzip(GZIPSTREAM)).pipe(res);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isGZIP && !gzip)\n\t\t\t\t\tresponse.pipe(Zlib.createGunzip()).pipe(res);\n\t\t\t\telse\n\t\t\t\t\tresponse.pipe(res);\n\t\t\t});\n\n\t\t\ttimeout && client.setTimeout(timeout, function() {\n\t\t\t\tres.throw408();\n\t\t\t});\n\n\t\t\tclient.on('close', function() {\n\t\t\t\tif (!res.success) {\n\t\t\t\t\tF.stats.response.pipe++;\n\t\t\t\t\tresponse_end(res);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn res;\n\t};\n\n\t/**\n\t * Responds with an image\n\t * @param {String or Stream} filename\n\t * @param {String} make\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} callback Optional.\n\t * @return {Framework}\n\t */\n\tPROTO.image = function(filename, make, headers, callback) {\n\n\t\tvar res = this;\n\n\t\tres.options.make = make;\n\n\t\theaders && (res.options.headers = headers);\n\t\tcallback && (res.options.callback = callback);\n\n\t\tif (typeof(filename) === 'object')\n\t\t\tres.options.stream = filename;\n\t\telse\n\t\t\tres.options.filename = filename;\n\n\t\tres.$image();\n\t\treturn res;\n\t};\n\n\tPROTO.image_nocache = function(filename, make, headers, callback) {\n\t\tthis.options.cache = false;\n\t\treturn this.image(filename, make, headers, callback);\n\t};\n\n\t/**\n\t * Response JSON\n\t * @param {Object} obj\n\t * @return {Response}\n\t */\n\tPROTO.json = function(obj) {\n\t\tvar res = this;\n\t\tF.stats.response.json++;\n\t\tif (framework_builders.isSchema(obj))\n\t\t\tobj = obj.$clean();\n\t\tres.options.body = JSON.stringify(obj);\n\t\tres.options.type = CT_JSON;\n\t\treturn res.$text();\n\t};\n\n\tconst SECURITYTXT = { '/security.txt': 1, '/.well-known/security.txt': 1 };\n\n\tPROTO.continue = function(callback) {\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\n\t\tcallback && (res.options.callback = callback);\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tif (!CONF.static_accepts[req.extension]) {\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (SECURITYTXT[req.url] && CONF['security.txt']) {\n\t\t\tres.send(200, CONF['security.txt'], 'text/plain');\n\t\t\treturn;\n\t\t}\n\n\t\treq.$key = createTemporaryKey(req);\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar canresize = false;\n\t\tvar filename = null;\n\t\tvar name = req.uri.pathname;\n\n\t\tif (IMAGES[req.extension]) {\n\t\t\tvar index = name.lastIndexOf('/');\n\t\t\tvar resizer = F.routes.resize[name.substring(0, index + 1)];\n\t\t\tif (resizer) {\n\t\t\t\tname = name.substring(index + 1);\n\t\t\t\tcanresize = resizer.extension['*'] || resizer.extension[req.extension];\n\t\t\t\tif (canresize) {\n\t\t\t\t\tname = resizer.path + $decodeURIComponent(name);\n\t\t\t\t\tfilename = F.onMapping(name, name, false, false);\n\t\t\t\t} else\n\t\t\t\t\tfilename = F.onMapping(name, name, true, true);\n\t\t\t} else\n\t\t\t\tfilename = F.onMapping(name, name, true, true);\n\t\t} else\n\t\t\tfilename = F.onMapping(name, name, true, true);\n\n\t\tif (!filename) {\n\t\t\tres.throw404();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!canresize) {\n\n\t\t\tif (F.components.has && F.components[req.extension] && req.uri.pathname === CONF.static_url_components + req.extension) {\n\t\t\t\tres.noCompress = true;\n\t\t\t\tres.options.components = true;\n\t\t\t\tvar g = req.query.group ? req.query.group.substring(0, req.query.group.length - 6) : '';\n\t\t\t\tfilename = F.path.temp('components' + (g ? '_g' + g : '') + '.' + req.extension);\n\t\t\t\tif (g)\n\t\t\t\t\treq.$key = 'components_' + g + '.' + req.extension;\n\t\t\t\telse\n\t\t\t\t\treq.$key = 'components.' + req.extension;\n\t\t\t}\n\n\t\t\tres.options.filename = filename;\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!resizer.ishttp) {\n\t\t\tres.options.cache = resizer.cache;\n\t\t\tres.options.make = resizer.fn;\n\t\t\tres.options.filename = filename;\n\t\t\tres.$image();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (F.temporary.processing[req.uri.pathname]) {\n\t\t\tsetTimeout($continue_timeout, 500, res);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar tmp = F.path.temp(req.$key);\n\t\tif (F.temporary.path[req.$key]) {\n\t\t\tres.options.filename = req.uri.pathname;\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tF.temporary.processing[req.uri.pathname] = true;\n\n\t\tU.download(name, FLAGS_DOWNLOAD, function(err, response) {\n\t\t\tvar writer = Fs.createWriteStream(tmp);\n\t\t\tresponse.pipe(writer);\n\t\t\tCLEANUP(writer, function() {\n\n\t\t\t\tdelete F.temporary.processing[req.uri.pathname];\n\t\t\t\tvar contentType = response.headers['content-type'];\n\n\t\t\t\tif (response.statusCode !== 200 || !contentType || !contentType.startsWith('image/')) {\n\t\t\t\t\tres.throw404();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tres.options.cache = resizer.cache;\n\t\t\t\tres.options.filename = tmp;\n\t\t\t\tres.options.maker = resizer.fn;\n\t\t\t\tres.$image();\n\t\t\t});\n\t\t});\n\n\t\treturn res;\n\t};\n\n\tPROTO.$file = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.code\n\t\t// res.options.callback\n\t\t// res.options.headers\n\t\t// res.options.download\n\n\t\tvar res = this;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = this.req;\n\n\t\t!req.$key && (req.$key = createTemporaryKey(req));\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\t// Is package?\n\t\tif (options.filename && options.filename[0] === '@')\n\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\tvar name = F.temporary.path[req.$key];\n\t\tvar index;\n\n\t\tif (!req.extension) {\n\t\t\treq.$key && (req.extension = U.getExtension(req.$key));\n\t\t\tif (!req.extension && name) {\n\t\t\t\treq.extension = U.getExtension(name);\n\t\t\t\tindex = req.extension.lastIndexOf(';');\n\t\t\t\tindex !== -1 && (req.extension = req.extension.substring(0, index));\n\t\t\t}\n\t\t\t!req.extension && options.filename && (req.extension = U.getExtension(options.filename));\n\t\t}\n\n\t\tif (name && RELEASE && !res.$nocache && req.headers['if-modified-since'] === name[2]) {\n\t\t\t$file_notmodified(res, name);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (name === undefined) {\n\n\t\t\tif (F.temporary.processing[req.$key]) {\n\t\t\t\tif (req.processing > CONF.default_request_timeout) {\n\t\t\t\t\tres.throw408();\n\t\t\t\t} else {\n\t\t\t\t\treq.processing += 500;\n\t\t\t\t\tsetTimeout($file_processing, 500, res);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\t// waiting\n\t\t\tF.temporary.processing[req.$key] = true;\n\t\t\tcompile_check(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar contentType = U.getContentType(req.extension);\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\tvar headers;\n\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = CONF.allow_gzip && COMPRESSION[contentType] && accept.indexOf('gzip') !== -1 && name.length > 2;\n\t\tvar range = req.headers.range;\n\t\tvar canCache = !res.$nocache && RELEASE && contentType !== 'text/cache-manifest';\n\n\t\tif (canCache) {\n\t\t\tif (compress)\n\t\t\t\theaders = range ? HEADERS.file_release_compress_range : HEADERS.file_release_compress;\n\t\t\telse\n\t\t\t\theaders = range ? HEADERS.file_release_range : HEADERS.file_release;\n\t\t} else {\n\t\t\tif (compress)\n\t\t\t\theaders = range ? HEADERS.file_debug_compress_range : HEADERS.file_debug_compress;\n\t\t\telse\n\t\t\t\theaders = range ? HEADERS.file_debug_range : HEADERS.file_debug;\n\t\t}\n\n\t\tif (req.$mobile)\n\t\t\theaders.Vary = 'Accept-Encoding, User-Agent';\n\t\telse\n\t\t\theaders.Vary = 'Accept-Encoding';\n\n\t\theaders[HEADER_TYPE] = contentType;\n\t\tif (REG_TEXTAPPLICATION.test(contentType))\n\t\t\theaders[HEADER_TYPE] += '; charset=utf-8';\n\n\t\tif (canCache && !res.getHeader('Expires')) {\n\t\t\theaders.Expires = DATE_EXPIRES;\n\t\t} else if (headers.Expires && RELEASE)\n\t\t\tdelete headers.Expires;\n\n\t\tif (res.options.headers)\n\t\t\theaders = U.extend_headers(headers, res.options.headers);\n\n\t\tif (res.options.download) {\n\t\t\tvar encoded = encodeURIComponent(res.options.download);\n\t\t\theaders['Content-Disposition'] = 'attachment; ' + (REG_UTF8.test(res.options.download) ? 'filename*=utf-8\\'\\'' + encoded : ('filename=\"' + encoded + '\"'));\n\t\t} else if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\tif (res.getHeader('Last-Modified'))\n\t\t\tdelete headers['Last-Modified'];\n\t\telse if (!res.options.lastmodified)\n\t\t\theaders['Last-Modified'] = name[2];\n\n\t\theaders.Etag = ETAG + CONF.etag_version;\n\n\t\tif (range) {\n\t\t\t$file_range(name[0], range, headers, res);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!res.options.components && (DEBUG || res.$nocache))\n\t\t\tF.isProcessed(req.$key) && (F.temporary.path[req.$key] = undefined);\n\n\t\tif (name[1] && !compress)\n\t\t\theaders[HEADER_LENGTH] = name[1];\n\t\telse if (compress && name[4])\n\t\t\theaders[HEADER_LENGTH] = name[4];\n\t\telse if (headers[HEADER_LENGTH])\n\t\t\tdelete headers[HEADER_LENGTH];\n\n\t\tF.stats.response.file++;\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t} else if (compress) {\n\n\t\t\tif (name[4])\n\t\t\t\theaders[HEADER_LENGTH] = name[4];\n\t\t\telse\n\t\t\t\tdelete headers[HEADER_LENGTH];\n\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tfsStreamRead(name[3], undefined, $file_nocompress, res);\n\t\t} else {\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tfsStreamRead(name[0], undefined, $file_nocompress, res);\n\t\t}\n\t};\n\n\tPROTO.$redirect = function() {\n\n\t\t// res.options.permanent\n\t\t// res.options.url\n\n\t\tvar res = this;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tHEADERS.redirect.Location = res.options.url;\n\t\tres.writeHead(res.options.permanent ? 301 : 302, HEADERS.redirect);\n\t\tres.end();\n\t\tresponse_end(res);\n\t\tF.stats.response.redirect++;\n\t\treturn res;\n\t};\n\n\tPROTO.$binary = function() {\n\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.encoding\n\t\t// res.options.download\n\t\t// res.options.type\n\t\t// res.options.body\n\t\t// res.options.headers\n\n\t\tvar res = this;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\t/*\n\t\tif (options.type.lastIndexOf('/') === -1)\n\t\t\toptions.type = U.getContentType(options.type);\n\t\t*/\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = CONF.allow_gzip && COMPRESSION[options.type] && accept.indexOf('gzip') !== -1;\n\t\tvar headers = compress ? HEADERS.binary_compress : HEADERS.binary;\n\n\t\theaders['Vary'] = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif (options.download)\n\t\t\theaders['Content-Disposition'] = 'attachment; filename=' + encodeURIComponent(options.download);\n\t\telse if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tF.stats.response.binary++;\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t} else if (compress) {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tZlib.gzip(!options.encoding || options.encoding === 'binary' ? options.body : options.body.toString(options.encoding), (err, buffer) => res.end(buffer));\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end(!options.encoding || options.encoding === 'binary' ? options.body : options.body.toString(options.encoding));\n\t\t\tresponse_end(res);\n\t\t}\n\n\t\treturn res;\n\t};\n\n\tPROTO.$stream = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.options\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.stream\n\t\t// res.options.type\n\t\t// res.options.compress\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\t/*\n\t\tif (options.type.lastIndexOf('/') === -1)\n\t\t\toptions.type = U.getContentType(options.type);\n\t\t*/\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = (options.compress === undefined || options.compress) && CONF.allow_gzip && COMPRESSION[options.type] && accept.indexOf('gzip') !== -1;\n\t\tvar headers;\n\n\t\tif (RELEASE) {\n\t\t\tif (compress)\n\t\t\t\theaders = HEADERS.stream_release_compress;\n\t\t\telse\n\t\t\t\theaders = HEADERS.stream_release;\n\t\t} else {\n\t\t\tif (compress)\n\t\t\t\theaders = HEADERS.stream_debug_compress;\n\t\t\telse\n\t\t\t\theaders = HEADERS.stream_debug;\n\t\t}\n\n\t\theaders.Vary = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif (RELEASE) {\n\t\t\theaders.Expires = DATE_EXPIRES;\n\t\t\theaders['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\n\t\t}\n\n\t\tif (options.download)\n\t\t\theaders['Content-Disposition'] = 'attachment; filename=' + encodeURIComponent(options.download);\n\t\telse if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tF.stats.response.stream++;\n\t\tF.reqstats(false, req.isStaticFile);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (compress) {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.on('error', () => options.stream.close());\n\t\t\toptions.stream.pipe(Zlib.createGzip(GZIPSTREAM)).pipe(res);\n\t\t\tframework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\t\tresponse_end(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tres.writeHead(options.code || 200, headers);\n\t\tframework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\toptions.stream.pipe(res);\n\t\tresponse_end(res);\n\t\treturn res;\n\t};\n\n\tPROTO.$image = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.stream\n\t\t// res.options.options\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.cache\n\t\t// res.options.headers\n\t\t// res.options.make = function(image, res)\n\n\t\tvar res = this;\n\t\tvar options = res.options;\n\n\t\tif (options.cache === false)\n\t\t\treturn $image_nocache(res);\n\n\t\tvar req = this.req;\n\t\t!req.$key && (req.$key = createTemporaryKey(req));\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar key = req.$key || createTemporaryKey(req);\n\t\tif (F.temporary.notfound[key]) {\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar name = F.temporary.path[key];\n\n\t\tif (options.filename && options.filename[0] === '@')\n\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\tif (name !== undefined) {\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (F.temporary.processing[req.$key]) {\n\t\t\tif (req.processing > CONF.default_request_timeout) {\n\t\t\t\tres.throw408();\n\t\t\t} else {\n\t\t\t\treq.processing += 500;\n\t\t\t\tsetTimeout($image_processing, 500, res);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\n\t\toptions.name = F.path.temp(plus + key);\n\t\tF.temporary.processing[key] = true;\n\n\t\tif (options.stream)\n\t\t\tfsFileExists(options.name, $image_stream, res);\n\t\telse\n\t\t\tfsFileExists(options.filename, $image_filename, res);\n\n\t\treturn res;\n\t};\n\n\tPROTO.$custom = function() {\n\t\tF.stats.response.custom++;\n\t\tresponse_end(this);\n\t\treturn this;\n\t};\n\n\tPROTO.$text = function() {\n\n\t\t// res.options.type\n\t\t// res.options.body\n\t\t// res.options.code\n\t\t// res.options.headers\n\t\t// res.options.callback\n\t\t// res.options.compress\n\t\t// res.options.encoding\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar gzip = CONF.allow_gzip && (options.compress === undefined || options.compress) ? accept.indexOf('gzip') !== -1 : false;\n\t\tvar headers;\n\n\t\tif (req.$mobile)\n\t\t\theaders = gzip ? HEADERS.content_mobile_release : HEADERS.content_mobile;\n\t\telse\n\t\t\theaders = gzip ? HEADERS.content_compress : HEADERS.content;\n\n\t\tif (REG_TEXTAPPLICATION.test(options.type))\n\t\t\toptions.type += '; charset=utf-8';\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t} else {\n\t\t\tif (gzip) {\n\t\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\t\tZlib.gzip(options.body instanceof Buffer ? options.body : U.createBuffer(options.body), (err, data) => res.end(data, res.options.encoding || ENCODING));\n\t\t\t} else {\n\t\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\t\tres.end(options.body, res.options.encoding || ENCODING);\n\t\t\t}\n\t\t}\n\n\t\tresponse_end(res);\n\t\treturn res;\n\t};\n\n\tPROTO.throw400 = function(problem) {\n\t\tthis.options.code = 400;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw401 = function(problem) {\n\t\tthis.options.code = 401;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw403 = function(problem) {\n\t\tthis.options.code = 403;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw404 = function(problem) {\n\t\tthis.options.code = 404;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw408 = function(problem) {\n\t\tthis.options.code = 408;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw409 = function(problem) {\n\t\tthis.options.code = 409;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw431 = function(problem) {\n\t\tthis.options.code = 431;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw500 = function(error) {\n\t\terror && F.error(error, null, this.req.uri);\n\t\tthis.options.code = 500;\n\t\tthis.options.body = U.httpStatus(500) + error ? prepare_error(error) : '';\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw501 = function(problem) {\n\t\tthis.options.code = 501;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.$throw = function() {\n\n\t\t// res.options.code\n\t\t// res.options.body\n\t\t// res.options.problem\n\n\t\tvar res = this;\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = res.req;\n\t\tvar key = 'error' + res.options.code;\n\n\t\tres.options.problem && F.problem(res.options.problem, 'response' + res.options.code + '()', req.uri, req.ip);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(res.options.code || 501, res.options.headers || HEADERS.responseCode);\n\t\t\tres.end();\n\t\t\tF.stats.response[key]++;\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\treq.$total_route = F.lookup(req, '#' + res.options.code, EMPTYARRAY, 0);\n\t\t\treq.$total_exception = res.options.problem;\n\t\t\treq.$total_execute(res.options.code, true);\n\t\t}\n\n\t\tF.$events[key] && EMIT(key, req, res, res.options.problem);\n\t\treturn res;\n\t};\n}\n\nfunction $continue_timeout(res) {\n\tres.continue();\n}\n\nfunction $file_processing(res) {\n\tres.$file();\n}\n\nfunction $file_notmodified(res, name) {\n\tvar req = res.req;\n\tvar headers = HEADERS.file_lastmodified;\n\n\tif (res.getHeader('Last-Modified'))\n\t\tdelete headers['Last-Modified'];\n\telse\n\t\theaders['Last-Modified'] = name instanceof Array ? name[2] : name;\n\n\tif (res.getHeader('Expires'))\n\t\tdelete headers.Expires;\n\telse\n\t\theaders.Expires = DATE_EXPIRES;\n\n\tif (res.getHeader('ETag'))\n\t\tdelete headers.Etag;\n\telse\n\t\theaders.Etag = ETAG + CONF.etag_version;\n\n\theaders[HEADER_TYPE] = U.getContentType(req.extension);\n\tres.writeHead(304, headers);\n\tres.end();\n\tF.stats.response.notModified++;\n\tresponse_end(res);\n}\n\nfunction $file_nocompress(stream, next, res) {\n\tstream.pipe(res);\n\n\tframework_internal.onFinished(res, function() {\n\t\tnext();\n\t\tframework_internal.destroyStream(stream);\n\t});\n\n\tresponse_end(res);\n}\n\nfunction $file_range(name, range, headers, res) {\n\n\tvar arr = range.replace(REG_RANGE, '').split('-');\n\tvar beg = +arr[0] || 0;\n\tvar end = +arr[1] || 0;\n\tvar total = F.temporary.range[name];\n\n\tif (!total) {\n\t\ttotal = Fs.statSync(name).size;\n\t\tRELEASE && (F.temporary.range[name] = total);\n\t}\n\n\tif (end === 0)\n\t\tend = total - 1;\n\n\tif (beg > end) {\n\t\tbeg = 0;\n\t\tend = total - 1;\n\t}\n\n\tif (end > total)\n\t\tend = total - 1;\n\n\tvar length = (end - beg) + 1;\n\n\theaders[HEADER_LENGTH] = length;\n\theaders['Content-Range'] = 'bytes ' + beg + '-' + end + '/' + total;\n\n\tvar req = res;\n\tF.stats.response.streaming++;\n\n\tif (req.method === 'HEAD') {\n\t\tres.writeHead(206, headers);\n\t\tres.end();\n\t\tresponse_end(res);\n\t\treturn F;\n\t}\n\n\tres.writeHead(206, headers);\n\tRANGE.start = beg;\n\tRANGE.end = end;\n\tfsStreamRead(name, RANGE, $file_range_callback, res);\n\treturn F;\n}\n\nfunction $file_range_callback(stream, next, res) {\n\tframework_internal.onFinished(res, function() {\n\t\tframework_internal.destroyStream(stream);\n\t\tnext();\n\t});\n\tstream.pipe(res);\n\tresponse_end(res);\n}\n\nfunction $image_nocache(res) {\n\n\tvar options = res.options;\n\n\t// STREAM\n\tif (options.stream) {\n\t\tvar image = framework_image.load(options.stream, IMAGEMAGICK);\n\t\toptions.make.call(image, image, res);\n\t\toptions.type = U.getContentType(image.outputType);\n\t\toptions.stream = image;\n\t\tF.stats.response.image++;\n\t\tres.$stream();\n\t\treturn F;\n\t}\n\n\t// FILENAME\n\tfsFileExists(options.filename, function(e) {\n\n\t\tif (e) {\n\t\t\tF.path.verify('temp');\n\t\t\tvar image = framework_image.load(options.filename, IMAGEMAGICK);\n\t\t\toptions.make.call(image, image, res);\n\t\t\tF.stats.response.image++;\n\t\t\toptions.type = U.getContentType(image.outputType);\n\t\t\toptions.stream = image;\n\t\t\tres.$stream();\n\t\t} else {\n\t\t\toptions.headers = null;\n\t\t\tres.throw404();\n\t\t}\n\t});\n}\n\nfunction $image_processing(res) {\n\tres.$image();\n}\n\nfunction $image_stream(exists, size, isFile, stats, res) {\n\n\tvar req = res.req;\n\tvar options = res.options;\n\n\tif (exists) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\tres.options.filename = options.name;\n\t\tres.options.stream = null;\n\t\tres.$file();\n\t\tDEBUG && (F.temporary.path[req.$key] = undefined);\n\t\treturn;\n\t}\n\n\tF.path.verify('temp');\n\n\tvar image = framework_image.load(options.stream, IMAGEMAGICK);\n\toptions.make.call(image, image, res);\n\treq.extension = U.getExtension(options.name);\n\n\tif (req.extension !== image.outputType) {\n\t\tvar index = options.name.lastIndexOf('.' + req.extension);\n\t\tif (index !== -1)\n\t\t\toptions.name = options.name.substring(0, index) + '.' + image.outputType;\n\t\telse\n\t\t\toptions.name += '.' + image.outputType;\n\t}\n\n\tF.stats.response.image++;\n\timage.save(options.name, function(err) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tif (err) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tres.throw500(err);\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t} else {\n\t\t\tvar stats = Fs.statSync(options.name);\n\t\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\t\toptions.filename = options.name;\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction $image_filename(exists, size, isFile, stats, res) {\n\n\tvar req = res.req;\n\tvar options = res.options;\n\n\tif (!exists) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tF.temporary.notfound[req.$key] = true;\n\t\tres.throw404();\n\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\treturn;\n\t}\n\n\tF.path.verify('temp');\n\n\tvar image = framework_image.load(options.filename, IMAGEMAGICK);\n\toptions.make.call(image, image, res);\n\treq.extension = U.getExtension(options.name);\n\n\tif (req.extension !== image.outputType) {\n\t\tvar index = options.name.lastIndexOf('.' + req.extension);\n\t\tif (index === -1)\n\t\t\toptions.name += '.' + image.outputType;\n\t\telse\n\t\t\toptions.name = options.name.substring(0, index) + '.' + image.outputType;\n\t}\n\n\tF.stats.response.image++;\n\timage.save(options.name, function(err) {\n\n\t\tdelete F.temporary.processing[req.$key];\n\n\t\tif (err) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tres.throw500(err);\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t} else {\n\t\t\tvar stats = Fs.statSync(options.name);\n\t\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\t\tres.options.filename = options.name;\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction response_end(res) {\n\tF.reqstats(false, res.req.isStaticFile);\n\tres.success = true;\n\t!res.req.isStaticFile && F.$events['request-end'] && EMIT('request-end', res.req, res);\n\tres.req.clear(true);\n\tres.controller && res.req.$total_success();\n\n\tif (res.options.callback) {\n\t\tres.options.callback();\n\t\tres.options.callback = null;\n\t}\n\n\tif (res.options.done) {\n\t\tres.options.done();\n\t\tres.options.done = null;\n\t}\n\n\t// res.options = EMPTYOBJECT;\n\tres.controller = null;\n}\n\n// Handle errors of decodeURIComponent\nfunction $decodeURIComponent(value) {\n\ttry\n\t{\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\treturn value;\n\t}\n}\n\nglobal.Controller = Controller;\n\nprocess.on('unhandledRejection', function(e) {\n\tF.error(e, '', null);\n});\n\nprocess.on('uncaughtException', function(e) {\n\n\tvar err = e.toString();\n\n\tif (err.indexOf('listen EADDRINUSE') !== -1) {\n\t\tprocess.send && process.send('total:eaddrinuse');\n\t\tconsole.log('\\nThe IP address and the PORT is already in use.\\nYou must change the PORT\\'s number or IP address.\\n');\n\t\tprocess.exit('SIGTERM');\n\t\treturn;\n\t} else if (CONF.allow_filter_errors && REG_SKIPERROR.test(err))\n\t\treturn;\n\n\tF.error(e, '', null);\n});\n\nfunction fsFileRead(filename, callback, a, b, c) {\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tFs.readFile(filename, function(err, result) {\n\t\t\tnext();\n\t\t\tcallback(err, result, a, b, c);\n\t\t});\n\t});\n}\n\nfunction fsFileExists(filename, callback, a, b, c) {\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tFs.lstat(filename, function(err, stats) {\n\t\t\tnext();\n\t\t\tcallback(!err && stats.isFile(), stats ? stats.size : 0, stats ? stats.isFile() : false, stats, a, b, c);\n\t\t});\n\t});\n}\n\nfunction fsStreamRead(filename, options, callback, res) {\n\n\tif (!callback) {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tvar opt;\n\n\tif (options) {\n\n\t\topt = HEADERS.fsStreamReadRange;\n\t\topt.start = options.start;\n\t\topt.end = options.end;\n\n\t\tif (opt.start > opt.end)\n\t\t\tdelete opt.end;\n\n\t} else\n\t\topt = HEADERS.fsStreamRead;\n\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tvar stream = Fs.createReadStream(filename, opt);\n\t\tstream.on('error', NOOP);\n\t\tcallback(stream, next, res);\n\t}, filename);\n}\n\n/**\n * Prepare URL address to temporary key (for caching)\n * @param {ServerRequest or String} req\n * @return {String}\n */\nfunction createTemporaryKey(req) {\n\treturn (req.uri ? req.uri.pathname : req).replace(REG_TEMPORARY, '-').substring(1);\n}\n\nfunction MiddlewareOptions() {}\n\nMiddlewareOptions.prototype = {\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tget language() {\n\t\treturn this.req.$language;\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t}\n};\n\nMiddlewareOptions.prototype.callback = function() {\n\tthis.next();\n\treturn this;\n};\n\nMiddlewareOptions.prototype.cancel = function() {\n\tthis.next(false);\n\treturn this;\n};\n\nprocess.on('SIGTERM', () => F.stop());\nprocess.on('SIGINT', () => F.stop());\nprocess.on('exit', () => F.stop());\n\nprocess.on('message', function(msg, h) {\n\tif (msg === 'total:debug') {\n\t\tU.wait(() => F.isLoaded, function() {\n\t\t\tF.isLoaded = undefined;\n\t\t\tF.console();\n\t\t}, 10000, 500);\n\t} else if (msg === 'reconnect')\n\t\tF.reconnect();\n\telse if (msg === 'reset')\n\t\tF.cache.clear();\n\telse if (msg === 'stop' || msg === 'exit' || msg === 'kill')\n\t\tF.stop();\n\telse if (msg && msg.TYPE && msg.id !== F.id) {\n\t\tmsg.TYPE === 'cache-set' && F.cache.set(msg.key, msg.value, msg.expire, false);\n\t\tmsg.TYPE === 'cache-remove' && F.cache.remove(msg.key, false);\n\t\tmsg.TYPE === 'cache-remove-all' && F.cache.removeAll(msg.key, false);\n\t\tmsg.TYPE === 'cache-clear' && F.cache.clear(false);\n\t\tmsg.TYPE === 'req' && F.cluster.req(msg);\n\t\tmsg.TYPE === 'res' && msg.target === F.id && F.cluster.res(msg);\n\t\tmsg.TYPE === 'emit' && F.$events[msg.name] && EMIT(msg.name, msg.a, msg.b, msg.c, msg.d, msg.e);\n\t\tmsg.TYPE === 'nosql-meta' && NOSQL(msg.name).meta(msg.key, msg.value, true);\n\t\tmsg.TYPE === 'table-meta' && TABLE(msg.name).meta(msg.key, msg.value, true);\n\t}\n\tF.$events.message && EMIT('message', msg, h);\n});\n\nfunction prepare_error(e) {\n\tif (!e)\n\t\treturn '';\n\telse if (e instanceof ErrorBuilder)\n\t\treturn e.plain();\n\telse if (DEBUG)\n\t\treturn e.stack ? e.stack : e.toString();\n}\n\nfunction prepare_filename(name) {\n\treturn name[0] === '@' ? (F.isWindows ? U.combine(CONF.directory_temp, name.substring(1)) : F.path.package(name.substring(1))) : U.combine('/', name);\n}\n\nfunction prepare_staticurl(url, isDirectory) {\n\tif (!url)\n\t\treturn url;\n\tif (url[0] === '~') {\n\t\tif (isDirectory)\n\t\t\treturn U.path(url.substring(1));\n\t} else if (url.substring(0, 2) === '//' || url.substring(0, 6) === 'http:/' || url.substring(0, 7) === 'https:/')\n\t\treturn url;\n\treturn url;\n}\n\nfunction prepare_isomorphic(name, value) {\n\treturn 'if(window[\"isomorphic\"]===undefined)window.isomorphic=window.I={};isomorphic[\"' + name.replace(/\\.js$/i, '') + '\"]=(function(framework,F,U,utils,Utils,is_client,is_server){var module={},exports=module.exports={};' + value + ';return exports;})(null,null,null,null,null,true,false)';\n}\n\nfunction isGZIP(req) {\n\tvar ua = req.headers['user-agent'];\n\treturn ua && ua.lastIndexOf('Firefox') !== -1;\n}\n\nfunction prepare_viewname(value) {\n\t// Cleans theme name\n\treturn value.substring(value.indexOf('/', 2) + 1);\n}\n\nfunction existsSync(filename, file) {\n\ttry {\n\t\tvar val = Fs.statSync(filename);\n\t\treturn val ? (file ? val.isFile() : true) : false;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction getLoggerMiddleware(name) {\n\treturn 'MIDDLEWARE(\"' + name + '\")';\n}\n\nfunction async_middleware(index, req, res, middleware, callback, options, controller) {\n\n\tif (res.success || res.headersSent || res.finished) {\n\t\treq.$total_route && req.$total_success();\n\t\tcallback = null;\n\t\treturn;\n\t}\n\n\tvar name = middleware[index++];\n\tif (!name)\n\t\treturn callback && callback(req, res);\n\n\tvar item = F.routes.middleware[name];\n\tif (!item) {\n\t\tF.error('Middleware not found: ' + name, null, req.uri);\n\t\treturn async_middleware(index, req, res, middleware, callback, options, controller);\n\t}\n\n\tvar output;\n\tvar $now;\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tif (item.$newversion) {\n\t\tvar opt = req.$total_middleware;\n\t\tif (!index || !opt) {\n\t\t\topt = req.$total_middleware = new MiddlewareOptions();\n\t\t\topt.req = req;\n\t\t\topt.res = res;\n\t\t\topt.middleware = middleware;\n\t\t\topt.options = options || EMPTYOBJECT;\n\t\t\topt.controller = controller;\n\t\t\topt.callback2 = callback;\n\t\t\topt.next = function(err) {\n\t\t\t\tCONF.logger && F.ilogger(getLoggerMiddleware(name), req, $now);\n\t\t\t\tvar mid = req.$total_middleware;\n\t\t\t\tif (err === false) {\n\t\t\t\t\treq.$total_route && req.$total_success();\n\t\t\t\t\treq.$total_middleware = null;\n\t\t\t\t\tcallback = null;\n\t\t\t\t} else if (err instanceof Error || err instanceof ErrorBuilder) {\n\t\t\t\t\tres.throw500(err);\n\t\t\t\t\treq.$total_middleware = null;\n\t\t\t\t\tcallback = null;\n\t\t\t\t} else\n\t\t\t\t\tasync_middleware(mid.index, mid.req, mid.res, mid.middleware, mid.callback2, mid.options, mid.controller);\n\t\t\t};\n\t\t}\n\n\t\topt.index = index;\n\t\toutput = item(opt);\n\n\t} else {\n\t\toutput = item.call(framework, req, res, function(err) {\n\t\t\tCONF.logger && F.ilogger(getLoggerMiddleware(name), req, $now);\n\t\t\tif (err === false) {\n\t\t\t\treq.$total_route && req.$total_success();\n\t\t\t\tcallback = null;\n\t\t\t} else if (err instanceof Error || err instanceof ErrorBuilder) {\n\t\t\t\tres.throw500(err);\n\t\t\t\tcallback = null;\n\t\t\t} else\n\t\t\t\tasync_middleware(index, req, res, middleware, callback, options, controller);\n\t\t}, options, controller);\n\t}\n\n\tif (res.headersSent || res.finished) {\n\t\treq.$total_route && req.$total_success();\n\t\tcallback = null;\n\t\treturn;\n\t} else if (output !== false)\n\t\treturn;\n\n\treq.$total_route && req.$total_success();\n\tcallback = null;\n}\n\nglobal.setTimeout2 = function(name, fn, timeout, limit, param) {\n\tvar key = ':' + name;\n\tvar internal = F.temporary.internal;\n\n\tif (limit > 0) {\n\n\t\tvar key2 = key + '_limit';\n\t\tvar key3 = key + '_fn';\n\n\t\tif (internal[key2] >= limit) {\n\t\t\tinternal[key] && clearTimeout(internal[key]);\n\t\t\tinternal[key] = internal[key2] = internal[key3] = undefined;\n\t\t\tfn();\n\t\t\treturn;\n\t\t}\n\n\t\tinternal[key] && clearTimeout(internal[key]);\n\t\tinternal[key2] = (internal[key2] || 0) + 1;\n\n\t\treturn internal[key] = setTimeout(function(param, key) {\n\t\t\tF.temporary.internal[key] = F.temporary.internal[key + '_limit'] = F.temporary.internal[key + '_fn'] = undefined;\n\t\t\tfn && fn(param);\n\t\t}, timeout, param, key);\n\t}\n\n\tif (internal[key]) {\n\t\tclearTimeout(internal[key]);\n\t\tinternal[key] = undefined;\n\t}\n\n\treturn internal[key] = setTimeout(fn, timeout, param);\n};\n\nglobal.clearTimeout2 = function(name) {\n\tvar key = ':' + name;\n\n\tif (F.temporary.internal[key]) {\n\t\tclearTimeout(F.temporary.internal[key]);\n\t\tF.temporary.internal[key] = undefined;\n\t\tF.temporary.internal[key + ':limit'] && (F.temporary.internal[key + ':limit'] = undefined);\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nfunction parseComponent(body, filename) {\n\tvar response = {};\n\n\tresponse.css = '';\n\tresponse.js = '';\n\tresponse.install = '';\n\tresponse.files = {};\n\n\tvar beg = 0;\n\tvar end = 0;\n\tvar comname = U.getName(filename);\n\n\t// Files\n\twhile (true) {\n\t\tbeg = body.indexOf('<file name=\"');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = body.indexOf('</file>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar base64 = body.substring(beg, end);\n\n\t\tbody = body.substring(0, beg) + body.substring(end + 7);\n\n\t\t// Creates directory\n\t\tvar p = F.path.temp() + '~' + comname;\n\t\ttry {\n\t\t\tFs.mkdirSync(p);\n\t\t} catch (e) {}\n\n\t\tvar tmp = base64.indexOf('>');\n\t\tvar name = base64.substring(base64.lastIndexOf('name=\"', tmp), tmp);\n\t\tname = name.substring(6, name.length - 1);\n\t\tbase64 = base64.substring(tmp + 1);\n\t\tF.$bundling && Fs.writeFile(U.join(p, name), base64, 'base64', NOOP);\n\t\tresponse.files[name] = 1;\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<script type=\"text/totaljs\">');\n\t\tif (beg === -1) {\n\t\t\tbeg = body.indexOf('<script total>');\n\t\t\tif (beg === -1)\n\t\t\t\tbeg = body.indexOf('<script totaljs>');\n\t\t\tif (beg === -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tend = body.indexOf('</script>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.install += (response.install ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?script.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 9).trim();\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<style');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = body.indexOf('</style>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.css += (response.css ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?style.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 8).trim();\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<script>');\n\t\tif (beg === -1) {\n\t\t\tbeg = body.indexOf('<script type=\"text/javascript\">');\n\t\t\tif (beg === -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tend = body.indexOf('</script>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.js += (response.js ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?script.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 9).trim();\n\t}\n\n\tif (response.js)\n\t\tresponse.js = framework_internal.compile_javascript(response.js, filename);\n\n\tif (response.css)\n\t\tresponse.css = framework_internal.compile_css(response.css, filename);\n\n\tresponse.body = body;\n\treturn response;\n}\n\nfunction getSchemaName(schema, params) {\n\treturn schema[0] === 'default' ? (params ? params[schema[1]] : schema[1]) : schema[0] + '/' + schema[1];\n}\n\n// Default action for workflow routing\nfunction controller_json_workflow(id) {\n\tvar self = this;\n\tvar w = self.route.workflow;\n\n\tself.id = self.route.paramidindex === -1 ? id : self.req.split[self.route.paramidindex];\n\n\tCONF.logger && (self.req.$logger = []);\n\n\tif (w instanceof Object) {\n\n\t\tif (!w.type) {\n\n\t\t\t// IS IT AN OPERATION?\n\t\t\tif (!self.route.schema.length) {\n\t\t\t\tOPERATION(w.id, self.body, w.view ? self.callback(w.view) : self.callback(), self);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar schema = self.route.isDYNAMICSCHEMA ? framework_builders.findschema(self.req.$schemaname || (self.route.schema[0] + '/' + self.params[self.route.schema[1]])) : GETSCHEMA(self.route.schema[0], self.route.schema[1]);\n\t\t\tif (!schema) {\n\t\t\t\tvar err = 'Schema \"{0}\" not found.'.format(getSchemaName(self.route.schema, self.route.isDYNAMICSCHEMA ? self.params : null));\n\t\t\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\t\t\tself.throw404(err);\n\t\t\t\telse\n\t\t\t\t\tself.throw500(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (schema.meta[w.id] !== undefined) {\n\t\t\t\tw.type = '$' + w.id;\n\t\t\t} else if (schema.meta['workflow#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$workflow';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['workflow#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$transform';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['operation#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$operation';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['hook#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$hook';\n\t\t\t\tw.name = w.id;\n\t\t\t}\n\t\t}\n\n\t\tif (w.name)\n\t\t\tself[w.type](w.name, self.callback());\n\t\telse {\n\t\t\tif (w.type)\n\t\t\t\tself[w.type](self.callback(w.view));\n\t\t\telse\n\t\t\t\tself.throw500('Operation @' + w.id + ' not found.');\n\t\t}\n\n\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\tw.type = '';\n\n\t} else\n\t\tself.$exec(w, null, self.callback());\n}\n\n// Default action for workflow routing\nfunction controller_json_workflow_multiple(id) {\n\n\tvar self = this;\n\tvar w = self.route.workflow;\n\n\tself.id = self.route.paramidindex === -1 ? id : self.req.split[self.route.paramidindex];\n\n\tCONF.logger && (self.req.$logger = []);\n\n\tif (w instanceof Object) {\n\t\tif (!w.type) {\n\n\t\t\t// IS IT AN OPERATION?\n\t\t\tif (!self.route.schema.length) {\n\t\t\t\tRUN(w.id, EMPTYOBJECT, w.view ? self.callback(w.view) : self.callback(), null, self, w.index ? w.id[w.index] : null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar schema = self.route.isDYNAMICSCHEMA ? framework_builders.findschema(self.route.schema[0] + '/' + self.params[self.route.schema[1]]) : GETSCHEMA(self.route.schema[0], self.route.schema[1]);\n\t\t\tif (!schema) {\n\t\t\t\tself.throw500('Schema \"{0}\" not found.'.format(getSchemaName(self.route.schema, self.isDYNAMICSCHEMA ? self.params : null)));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar op = [];\n\t\t\tfor (var i = 0; i < w.id.length; i++) {\n\t\t\t\tvar id = w.id[i];\n\t\t\t\tif (schema.meta[id] !== undefined) {\n\t\t\t\t\top.push({ name: '$' + id });\n\t\t\t\t} else if (schema.meta['workflow#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$workflow', id: id });\n\t\t\t\t} else if (schema.meta['workflow#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$transform', id: id });\n\t\t\t\t} else if (schema.meta['operation#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$operation', id: id });\n\t\t\t\t} else if (schema.meta['hook#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$hook', id: id });\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.async = op;\n\t\t}\n\n\t\tvar async = self.$async(self.callback(w.view), w.index);\n\t\tfor (var i = 0; i < w.async.length; i++) {\n\t\t\tvar a = w.async[i];\n\t\t\tif (a.id)\n\t\t\t\tasync[a.name](a.id);\n\t\t\telse\n\t\t\t\tasync[a.name]();\n\t\t}\n\t} else\n\t\tself.$exec(w, null, self.callback());\n}\n\n// Parses schema group and schema name from string e.g. \"User\" or \"Company/User\"\nfunction parseSchema(name) {\n\tvar schema = F.temporary.internal['$$$' + name];\n\tif (schema)\n\t\treturn schema;\n\n\tschema = name.split('/');\n\n\tif (!schema[1]) {\n\t\tschema[1] = schema[0];\n\t\tschema[0] = 'default';\n\t}\n\n\tF.temporary.internal['$$$' + name] = schema;\n\treturn schema;\n}\n\nfunction ilogger(body) {\n\tF.path.verify('logs');\n\tU.queue('F.ilogger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, 'logger.log'), body, next));\n}\n\nF.ilogger = function(name, req, ts) {\n\n\tif (req && req instanceof Controller)\n\t\treq = req.req;\n\n\tvar isc = CONF.logger === 'console';\n\tvar divider = '';\n\n\tfor (var i = 0; i < (isc ? 64 : 220); i++)\n\t\tdivider += '-';\n\n\tvar msg;\n\n\tif (req && !name && req.$logger && req.$logger.length) {\n\n\t\tmsg = req.method + ' ' + req.url;\n\n\t\treq.$logger.unshift(msg);\n\t\treq.$logger.push(divider);\n\n\t\tif (isc)\n\t\t\tconsole.log(req.$logger.join('\\n'));\n\t\telse {\n\t\t\treq.$logger.push('');\n\t\t\tilogger(req.$logger.join('\\n'));\n\t\t}\n\n\t\treq.$logger = null;\n\t\treturn;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tvar dt = new Date();\n\n\tmsg = dt.format('yyyy-MM-dd HH:mm:ss') + ' | ' + name.padRight(40, ' ') + ' | ' + (((dt.getTime() - ts) / 1000).format(3) + ' sec.').padRight(12) + ' | ' + (req ? (req.method + ' ' + req.url).max(70) : '').padRight(70);\n\n\tif (isc) {\n\t\tif (req && req.$logger)\n\t\t\treq.$logger.push(msg);\n\t\telse\n\t\t\tconsole.log(msg + '\\n' + divider);\n\t} else {\n\t\tmsg = msg + ' | ' + (req ? (req.ip || '') : '').padRight(20) + ' | ' + (req && req.headers ? (req.headers['user-agent'] || '') : '');\n\t\tif (req && req.$logger)\n\t\t\treq.$logger.push(msg);\n\t\telse\n\t\t\tilogger(msg + '\\n' + divider + '\\n');\n\t}\n};\n\n// Because of controller prototypes\n// It's used in F.view() and F.viewCompile()\nconst EMPTYCONTROLLER = new Controller('', null, null, '');\nEMPTYCONTROLLER.isConnected = false;\nEMPTYCONTROLLER.req = {};\nEMPTYCONTROLLER.req.url = '';\nEMPTYCONTROLLER.req.uri = EMPTYOBJECT;\nEMPTYCONTROLLER.req.query = EMPTYOBJECT;\nEMPTYCONTROLLER.req.body = EMPTYOBJECT;\nEMPTYCONTROLLER.req.files = EMPTYARRAY;\nglobal.EMPTYCONTROLLER = EMPTYCONTROLLER;\n", "{\n    \"_from\": \"total.js\",\n    \"author\": {\n        \"name\": \"Peter Sirka\",\n        \"email\": \"petersirka@gmail.com\",\n        \"url\": \"http://www.petersirka.com\"\n    },\n    \"bin\": {\n        \"total\": \"./bin/totaljs\",\n        \"total.js\": \"./bin/totaljs\",\n        \"totaljs\": \"./bin/totaljs\",\n        \"tpm\": \"./bin/tpm\",\n        \"totalpackage\": \"./bin/tpm\"\n    },\n    \"description\": \"Web framework for Node.js\",\n    \"devDependencies\": {},\n    \"directories\": {\n        \"test\": \"test\"\n    },\n    \"engines\": {\n        \"node\": \">=8.0.0\"\n    },\n    \"keywords\": [\"total\", \"iot\", \"framework\", \"web\", \"websocket\", \"mvc\", \"controller\", \"view\", \"angular.js\", \"upload\", \"picture\", \"graphicsmagick\", \"imagemagick\", \"eshop\", \"blog\", \"forum\", \"chat\", \"game\", \"nosql\", \"database\", \"streaming\", \"live\", \"server sent events\", \"sse\", \"multipart\", \"x-mixed-replace\"],\n    \"license\": \"MIT\",\n    \"main\": \"./index.js\",\n    \"name\": \"total.js\",\n    \"readmeFilename\": \"readme.md\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/totaljs/framework.git\"\n    },\n    \"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n    },\n    \"contributors\": [{\n        \"name\": \"Peter \u0160irka\",\n        \"email\": \"petersirka@gmail.com\"\n    }, {\n        \"name\": \"Jozef Gula\",\n        \"email\": \"gula.jozef@gmail.com\"\n    }, {\n        \"name\": \"Mat\u00fa\u0161 Szabo\",\n        \"email\": \"matus.szabo@gmail.com\"\n    }, {\n        \"name\": \"Andrea Sessa\",\n        \"email\": \"andrea.sessa@gmail.com\"\n    }, {\n        \"name\": \"Tom Spaccialbelli\",\n        \"email\": \"tom.spaccialbelli@gmail.com\"\n    }, {\n        \"name\": \"Gera G. G\u00fciles\",\n        \"email\": \"gerardo.gonzalezg@gmail.com\"\n    }, {\n        \"name\": \"Radek / rsmogura\",\n        \"email\": \"\"\n    },{\n        \"name\": \"Liao San-Kai\",\n        \"email\": \"liaosankai@gmail.com\"\n    },{\n        \"name\": \"Marchukov Ivan\",\n        \"email\": \"marchukov.ivan@gmail.com\"\n    },{\n        \"name\": \"Dusan Dragula\",\n        \"email\": \"dusan.dragula@goodrequest.com\"\n    },{\n        \"name\": \"\u0421\u043a\u043e\u0432\u043e\u0440\u043e\u0434\u0430 \u041d\u0438\u043a\u0438\u0442\u0430 \u0410\u043d\u0434\u0440\u0435\u0435\u0432\u0438\u0447\",\n        \"email\": \"chalkerx@gmail.com\"\n    },{\n        \"name\": \"Guy Fraser\",\n        \"email\": \"guy.fraser1@gmail.com\"\n    },{\n        \"name\": \"Martin Smola\",\n        \"email\": \"smola.martin@gmail.com\"\n    },{\n        \"name\": \"Peter \u0160tolc\",\n        \"email\": \"stolcp@gmail.com\"\n    },{\n        \"name\": \"Denis Granec\",\n        \"email\": \"danis1999@gmail.com\"\n    },{\n        \"name\": \"Chao Tang Chang\",\n        \"email\": \"mrgmp2004@hotmail.com\"\n    },{\n        \"name\": \"luoage\",\n        \"email\": \"luoage@msn.cn\"\n    },{\n        \"name\": \"Mato Holly\",\n        \"email\": \"mato.holly@gmail.com\"\n    },{\n        \"name\": \"Tema Smirnov\",\n        \"email\": \"github.tema@smirnov.one\"\n    }, {\n        \"name\": \"Jeroen van Hilst\",\n        \"email\": \"frunjik@gmail.com\"\n    }, {\n        \"name\": \"Pedro Costa\",\n        \"email\": \"pedro@pmcdigital.pt\"\n    }, {\n        \"name\": \"Sarp Aykent\",\n        \"email\": \"shackhers@gmail.com\"\n    }],\n    \"version\": \"3.2.0\",\n    \"homepage\": \"http://www.totaljs.com\",\n    \"bugs\": {\n        \"url\": \"https://github.com/totaljs/framework/issues\",\n        \"email\": \"petersirka@gmail.com\"\n    }\n}\n"], "fixing_code": ["// Copyright 2012-2018 (c) Peter \u0160irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module Framework\n * @version 3.2.0\n */\n\n'use strict';\n\nconst Qs = require('querystring');\nconst Os = require('os');\nconst Fs = require('fs');\nconst Zlib = require('zlib');\nconst Path = require('path');\nconst Crypto = require('crypto');\nconst Parser = require('url');\nconst Child = require('child_process');\nconst Util = require('util');\nconst http = require('http');\n\nconst ENCODING = 'utf8';\nconst HEADER_CACHE = 'Cache-Control';\nconst HEADER_TYPE = 'Content-Type';\nconst HEADER_LENGTH = 'Content-Length';\nconst CT_TEXT = 'text/plain';\nconst CT_HTML = 'text/html';\nconst CT_JSON = 'application/json';\nconst COMPRESSION = { 'text/plain': true, 'text/javascript': true, 'text/css': true, 'text/jsx': true, 'application/javascript': true, 'application/x-javascript': true, 'application/json': true, 'text/xml': true, 'image/svg+xml': true, 'text/x-markdown': true, 'text/html': true };\nconst COMPRESSIONSPECIAL = { 'js': 1, 'css': 1 };\nconst REG_TEMPORARY = /\\//g;\nconst REG_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet/i;\nconst REG_ROBOT = /search|agent|bot|crawler|spider/i;\nconst REG_VERSIONS = /(href|src)=\"[a-zA-Z0-9/:\\-._]+\\.(jpg|js|css|png|apng|gif|svg|html|ico|json|less|sass|scss|swf|txt|webp|heif|heic|jpeg|woff|woff2|xls|xlsx|xml|xsl|xslt|zip|rar|csv|doc|docx|eps|gzip|jpe|jpeg|manifest|mov|mp3|flac|mp4|ogg|package|pdf)\"/gi;\nconst REG_COMPILECSS = /url\\(.*?\\)/g;\nconst REG_ROUTESTATIC = /^(\\/\\/|https:|http:)+/;\nconst REG_NEWIMPL = /^(async\\s)?function(\\s)?([a-zA-Z$][a-zA-Z0-9$]+)?(\\s)?\\([a-zA-Z0-9$]+\\)|^function anonymous\\(\\$/;\nconst REG_RANGE = /bytes=/;\nconst REG_EMPTY = /\\s/g;\nconst REG_ACCEPTCLEANER = /\\s|\\./g;\nconst REG_SANITIZE_BACKSLASH = /\\/\\//g;\nconst REG_WEBSOCKET_ERROR = /ECONNRESET|EHOSTUNREACH|EPIPE|is closed/i;\nconst REG_WINDOWSPATH = /\\\\/g;\nconst REG_SCRIPTCONTENT = /<|>|;/;\nconst REG_HTTPHTTPS = /^(\\/)?(http|https):\\/\\//i;\nconst REG_NOCOMPRESS = /[.|-]+min(@[a-z0-9]*)?\\.(css|js)$/i;\nconst REG_WWW = /^www\\./i;\nconst REG_TEXTAPPLICATION = /text|application/;\nconst REG_ENCODINGCLEANER = /[;\\s]charset=utf-8/g;\nconst REG_SKIPERROR = /epipe|invalid\\sdistance/i;\nconst REG_OLDCONF = /-/g;\nconst REG_UTF8 = /[^\\x20-\\x7E]+/;\nconst FLAGS_INSTALL = ['get'];\nconst FLAGS_DOWNLOAD = ['get', 'dnscache'];\nconst QUERYPARSEROPTIONS = { maxKeys: 33 };\nconst EMPTYARRAY = [];\nconst EMPTYOBJECT = {};\nconst EMPTYREQUEST = { uri: {} };\nconst SINGLETONS = {};\nconst REPOSITORY_HEAD = '$head';\nconst REPOSITORY_META_TITLE = '$title';\nconst REPOSITORY_META_DESCRIPTION = '$description';\nconst REPOSITORY_META_KEYWORDS = '$keywords';\nconst REPOSITORY_META_AUTHOR = '$author';\nconst REPOSITORY_META_IMAGE = '$image';\nconst REPOSITORY_PLACE = '$place';\nconst REPOSITORY_SITEMAP = '$sitemap';\nconst REPOSITORY_COMPONENTS = '$components';\nconst ATTR_END = '\"';\nconst ETAG = '858';\nconst CONCAT = [null, null];\nconst CLUSTER_CACHE_SET = { TYPE: 'cache-set' };\nconst CLUSTER_CACHE_REMOVE = { TYPE: 'cache-remove' };\nconst CLUSTER_CACHE_REMOVEALL = { TYPE: 'cache-remove-all' };\nconst CLUSTER_CACHE_CLEAR = { TYPE: 'cache-clear' };\nconst GZIPFILE = { memLevel: 9 };\nconst GZIPSTREAM = { memLevel: 1 };\nconst MODELERROR = {};\nconst IMAGES = { jpg: 1, png: 1, gif: 1, apng: 1, jpeg: 1, heif: 1, heic: 1, webp: 1 };\n\nvar PATHMODULES = require.resolve('./index');\nPATHMODULES = PATHMODULES.substring(0, PATHMODULES.length - 8);\n\nObject.freeze(EMPTYOBJECT);\nObject.freeze(EMPTYARRAY);\nObject.freeze(EMPTYREQUEST);\n\nglobal.EMPTYOBJECT = EMPTYOBJECT;\nglobal.EMPTYARRAY = EMPTYARRAY;\nglobal.NOW = new Date();\n\nvar PROTORES, PROTOREQ;\n\nvar RANGE = { start: 0, end: 0 };\nvar HEADERS = {};\nvar SUCCESSHELPER = { success: true };\n\n// Cached headers for repeated usage\nHEADERS.responseCode = {};\nHEADERS.responseCode[HEADER_TYPE] = CT_TEXT;\nHEADERS.redirect = {};\nHEADERS.redirect[HEADER_TYPE] = CT_HTML + '; charset=utf-8';\nHEADERS.redirect[HEADER_LENGTH] = '0';\nHEADERS.sse = {};\nHEADERS.sse[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.sse['Pragma'] = 'no-cache';\nHEADERS.sse['Expires'] = '-1';\nHEADERS.sse[HEADER_TYPE] = 'text/event-stream';\nHEADERS.file_lastmodified = {};\nHEADERS.file_lastmodified['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_lastmodified[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress = {};\nHEADERS.file_release_compress[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_compress['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_compress['Content-Encoding'] = 'gzip';\nHEADERS.file_release_compress_range = {};\nHEADERS.file_release_compress_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_release_compress_range[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_compress_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_compress_range['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_compress_range['Content-Encoding'] = 'gzip';\nHEADERS.file_release_compress_range[HEADER_LENGTH] = '0';\nHEADERS.file_release_compress_range['Content-Range'] = '';\nHEADERS.file_release = {};\nHEADERS.file_release[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release['Vary'] = 'Accept-Encoding';\nHEADERS.file_release['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_range = {};\nHEADERS.file_release_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_release_range[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_range['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_range[HEADER_LENGTH] = '0';\nHEADERS.file_release_range['Content-Range'] = '';\nHEADERS.file_debug_compress = {};\nHEADERS.file_debug_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_compress['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_compress['Pragma'] = 'no-cache';\nHEADERS.file_debug_compress['Expires'] = '-1';\nHEADERS.file_debug_compress['Content-Encoding'] = 'gzip';\nHEADERS.file_debug_compress_range = {};\nHEADERS.file_debug_compress_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_debug_compress_range[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_compress_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_compress_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_compress_range['Content-Encoding'] = 'gzip';\nHEADERS.file_debug_compress_range['Pragma'] = 'no-cache';\nHEADERS.file_debug_compress_range['Expires'] = '-1';\nHEADERS.file_debug_compress_range[HEADER_LENGTH] = '0';\nHEADERS.file_debug_compress_range['Content-Range'] = '';\nHEADERS.file_debug = {};\nHEADERS.file_debug[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug['Pragma'] = 'no-cache';\nHEADERS.file_debug['Expires'] = '-1';\nHEADERS.file_debug['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_range = {};\nHEADERS.file_debug_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_debug_range[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_range['Pragma'] = 'no-cache';\nHEADERS.file_debug_range['Expires'] = '-1';\nHEADERS.file_debug_range[HEADER_LENGTH] = '0';\nHEADERS.file_debug_range['Content-Range'] = '';\nHEADERS.content_mobile_release = {};\nHEADERS.content_mobile_release[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_mobile_release['Vary'] = 'Accept-Encoding, User-Agent';\nHEADERS.content_mobile_release['Content-Encoding'] = 'gzip';\nHEADERS.content_mobile_release['Expires'] = '-1';\nHEADERS.content_mobile = {};\nHEADERS.content_mobile[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_mobile['Vary'] = 'Accept-Encoding, User-Agent';\nHEADERS.content_mobile['Expires'] = '-1';\nHEADERS.content_compress = {};\nHEADERS.content_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_compress['Vary'] = 'Accept-Encoding';\nHEADERS.content_compress['Content-Encoding'] = 'gzip';\nHEADERS.content_compress['Expires'] = '-1';\nHEADERS.content = {};\nHEADERS.content[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content['Vary'] = 'Accept-Encoding';\nHEADERS.content['Expires'] = '-1';\nHEADERS.stream_release_compress = {};\nHEADERS.stream_release_compress[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.stream_release_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_release_compress['Content-Encoding'] = 'gzip';\nHEADERS.stream_release = {};\nHEADERS.stream_release[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.stream_release['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_debug_compress = {};\nHEADERS.stream_debug_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.stream_debug_compress['Pragma'] = 'no-cache';\nHEADERS.stream_debug_compress['Expires'] = '-1';\nHEADERS.stream_debug_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_debug_compress['Content-Encoding'] = 'gzip';\nHEADERS.stream_debug = {};\nHEADERS.stream_debug[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.stream_debug['Pragma'] = 'no-cache';\nHEADERS.stream_debug['Expires'] = '-1';\nHEADERS.stream_debug['Access-Control-Allow-Origin'] = '*';\nHEADERS.binary_compress = {};\nHEADERS.binary_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.binary_compress['Content-Encoding'] = 'gzip';\nHEADERS.binary = {};\nHEADERS.binary[HEADER_CACHE] = 'public';\nHEADERS.authorization = { user: '', password: '', empty: true };\nHEADERS.fsStreamRead = { flags: 'r', mode: '0666', autoClose: true };\nHEADERS.fsStreamReadRange = { flags: 'r', mode: '0666', autoClose: true, start: 0, end: 0 };\nHEADERS.workers = { cwd: '', silent: true };\nHEADERS.responseLocalize = {};\nHEADERS.responseNotModified = {};\nHEADERS.responseNotModified[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.response503 = {};\nHEADERS.response503[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.response503[HEADER_TYPE] = CT_HTML;\n\nObject.freeze(HEADERS.authorization);\n\nvar IMAGEMAGICK = false;\nvar _controller = '';\nvar _owner = '';\nvar _flags;\nvar _prefix;\n\n// GO ONLINE MODE\n!global.framework_internal && (global.framework_internal = require('./internal'));\n!global.framework_builders && (global.framework_builders = require('./builders'));\n!global.framework_utils && (global.framework_utils = require('./utils'));\n!global.framework_mail && (global.framework_mail = require('./mail'));\n!global.framework_image && (global.framework_image = require('./image'));\n!global.framework_nosql && (global.framework_nosql = require('./nosql'));\n\nglobal.Builders = framework_builders;\nvar U = global.Utils = global.utils = global.U = global.framework_utils;\nglobal.Mail = framework_mail;\n\nglobal.WTF = (message, name, uri) => F.problem(message, name, uri);\nglobal.NOBIN = global.NOSQLBINARY = (name) => F.nosql(name).binary;\nglobal.NOSQLSTORAGE = (name) => F.nosql(name).storage;\nglobal.NOCOUNTER = global.NOSQLCOUNTER = (name) => F.nosql(name).counter;\nglobal.NOMEM = global.NOSQLMEMORY = (name, view) => global.framework_nosql.inmemory(name, view);\nglobal.CONFIG = function(name, val) {\n\treturn arguments.length === 1 ? CONF[name] : (CONF[name] = val);\n};\n\nglobal.CACHE = function(name, value, expire, persistent) {\n\treturn arguments.length === 1 ? F.cache.get2(name) : F.cache.set(name, value, expire, null, persistent);\n};\n\nglobal.UPTODATE = (type, url, options, interval, callback) => F.uptodate(type, url, options, interval, callback);\nglobal.INSTALL = (type, name, declaration, options, callback) => F.install(type, name, declaration, options, callback);\nglobal.UNINSTALL = (type, name, options) => F.uninstall(type, name, options);\nglobal.RESOURCE = (name, key) => F.resource(name, key);\nglobal.TRANSLATE = (name, key) => F.translate(name, key);\nglobal.TRANSLATOR = (name, text) => F.translator(name, text);\nglobal.TRACE = (message, name, uri, ip) => F.trace(message, name, uri, ip);\nglobal.CREATE = (group, name) => framework_builders.getschema(group, name).default();\nglobal.SCRIPT = (body, value, callback, param) => F.script(body, value, callback, param);\nglobal.SINGLETON = (name, def) => SINGLETONS[name] || (SINGLETONS[name] = (new Function('return ' + (def || '{}')))());\nglobal.FUNCTION = (name) => F.functions[name] || NOOP;\nglobal.SCHEDULE = (date, each, fn, param) => F.schedule(date, each, fn, param);\nglobal.FINISHED = framework_internal.onFinished;\nglobal.DESTROY = framework_internal.destroyStream;\nglobal.FILESTORAGE = function(name) {\n\tvar key = 'storage_' + name;\n\treturn F.databases[key] ? F.databases[key] : (F.databases[key] = new framework_nosql.DatabaseBinary({ name: name }, F.path.databases('fs-' + name + '/'), '.file'));\n};\n\nglobal.UID = function(type) {\n\n\tvar index;\n\n\tif (type) {\n\t\tif (UIDGENERATOR.types[type])\n\t\t\tindex = UIDGENERATOR.types[type] = UIDGENERATOR.types[type] + 1;\n\t\telse {\n\t\t\tUIDGENERATOR.multiple = true;\n\t\t\tindex = UIDGENERATOR.types[type] = 1;\n\t\t}\n\t} else\n\t\tindex = UIDGENERATOR.index++;\n\n\treturn UIDGENERATOR.date + index.padLeft(4, '0') + UIDGENERATOR.instance + (index % 2 ? 1 : 0);\n};\n\nglobal.ERROR = function(name) {\n\treturn name == null ? F.errorcallback : function(err) {\n\t\terr && F.error(err, name);\n\t};\n};\n\nglobal.AUTH = function(fn) {\n\tF.onAuthorize = fn;\n};\n\nglobal.WEBSOCKETCLIENT = function(callback) {\n\tvar ws = require('./websocketclient').create();\n\tcallback && callback.call(ws, ws);\n\treturn ws;\n};\n\nglobal.$CREATE = function(schema) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\treturn o ? o.default() : null;\n};\n\nglobal.$MAKE = function(schema, model, filter, callback, novalidate, argument) {\n\tschema = parseSchema(schema);\n\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tvar w = null;\n\n\tif (typeof(filter) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = filter;\n\t\tfilter = tmp;\n\t}\n\n\tif (filter instanceof Array) {\n\t\tw = {};\n\t\tfor (var i = 0; i < filter.length; i++)\n\t\t\tw[filter[i]] = i + 1;\n\t\tfilter = null;\n\t} else if (filter instanceof Object) {\n\t\tif (!(filter instanceof RegExp)) {\n\t\t\tfilter = null;\n\t\t\tw = filter;\n\t\t}\n\t}\n\n\treturn o ? o.make(model, filter, callback, argument, novalidate, w) : undefined;\n};\n\nglobal.$QUERY = function(schema, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.query(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$GET = function(schema, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.get(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$WORKFLOW = function(schema, name, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.workflow2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$TRANSFORM = function(schema, name, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.transform2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$REMOVE = function(schema, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = EMPTYOBJECT;\n\t}\n\n\tif (o)\n\t\to.remove(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$SAVE = function(schema, model, options, callback, controller) {\n\treturn performschema('$save', schema, model, options, callback, controller);\n};\n\nglobal.$INSERT = function(schema, model, options, callback, controller) {\n\treturn performschema('$insert', schema, model, options, callback, controller);\n};\n\nglobal.$UPDATE = function(schema, model, options, callback, controller) {\n\treturn performschema('$update', schema, model, options, callback, controller);\n};\n\n// type, schema, model, options, callback, controller\nfunction performschema(type, schema, model, options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = null;\n\t}\n\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\n\tif (!o) {\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\t\treturn false;\n\t}\n\n\tvar workflow = {};\n\tworkflow[type.substring(1)] = 1;\n\n\to.make(model, null, function(err, model) {\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t} else {\n\t\t\tmodel.$$controller = controller;\n\t\t\tmodel[type](options, callback);\n\t\t}\n\t}, null, false, workflow);\n\n\treturn !!o;\n}\n\nglobal.$ASYNC = function(schema, callback, index, controller) {\n\n\tif (index && typeof(index) === 'object') {\n\t\tcontroller = index;\n\t\tindex = undefined;\n\t}\n\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]).default();\n\n\tif (!o) {\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\t\treturn EMPTYOBJECT;\n\t}\n\n\tcontroller && (o.$$controller = controller);\n\treturn o.$async(callback, index);\n};\n\nglobal.$OPERATION = function(schema, name, options, callback, controller) {\n\tschema = parseSchema(schema);\n\tvar o = framework_builders.getschema(schema[0], schema[1]);\n\tif (o)\n\t\to.operation2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.DB = global.DATABASE = function(a, b, c, d) {\n\treturn typeof(F.database) === 'object' ? F.database : F.database(a, b, c, d);\n};\n\nglobal.OFF = function() {\n\treturn arguments.length > 1 ? F.removeListener.apply(F, arguments) : F.removeAllListeners.apply(F, arguments);\n};\n\nglobal.NEWSCHEMA = function(group, name, make) {\n\n\tif (typeof(name) === 'function') {\n\t\tmake = name;\n\t\tname = undefined;\n\t}\n\n\tif (!name) {\n\t\tvar arr = group.split('/');\n\t\tif (arr.length === 2) {\n\t\t\tname = arr[1];\n\t\t\tgroup = arr[0];\n\t\t} else {\n\t\t\tname = group;\n\t\t\tgroup = 'default';\n\t\t}\n\t}\n\n\tvar schema = framework_builders.newschema(group, name);\n\tmake && make.call(schema, schema);\n\treturn schema;\n};\n\nglobal.CLEANUP = function(stream, callback) {\n\tFINISHED(stream, function() {\n\t\tDESTROY(stream);\n\t\tif (callback) {\n\t\t\tcallback();\n\t\t\tcallback = null;\n\t\t}\n\t});\n};\n\nglobal.SUCCESS = function(success, value) {\n\n\tif (typeof(success) === 'function') {\n\t\treturn function(err, value) {\n\t\t\tsuccess(err, SUCCESS(err, value));\n\t\t};\n\t}\n\n\tvar err;\n\n\tif (success instanceof Error) {\n\t\terr = success.toString();\n\t\tsuccess = false;\n\t} else if (success instanceof framework_builders.ErrorBuilder) {\n\t\tif (success.hasError()) {\n\t\t\terr = success.output();\n\t\t\tsuccess = false;\n\t\t} else\n\t\t\tsuccess = true;\n\t} else if (success == null)\n\t\tsuccess = true;\n\n\tSUCCESSHELPER.success = !!success;\n\tSUCCESSHELPER.value = value == null ? undefined : (framework_builders.isSchema(value) ? value.$clean() : value);\n\tSUCCESSHELPER.error = err ? err : undefined;\n\treturn SUCCESSHELPER;\n};\n\nglobal.TRY = function(fn, err) {\n\ttry {\n\t\tfn();\n\t\treturn true;\n\t} catch (e) {\n\t\terr && err(e);\n\t\treturn false;\n\t}\n};\n\nglobal.OBSOLETE = function(name, message) {\n\tconsole.log(NOW.format('yyyy-MM-dd HH:mm:ss') + ' :: OBSOLETE / IMPORTANT ---> \"' + name + '\"', message);\n\tif (global.F)\n\t\tF.stats.other.obsolete++;\n};\n\nglobal.DEBUG = false;\nglobal.TEST = false;\nglobal.RELEASE = false;\nglobal.is_client = false;\nglobal.is_server = true;\n\nvar directory = U.$normalize(require.main ? Path.dirname(require.main.filename) : process.cwd());\n\n// F.service() changes the values below:\nvar DATE_EXPIRES = new Date().add('y', 1).toUTCString();\n\nconst _randomstring = 'abcdefghijklmnoprstuwxy'.split('');\nfunction random3string() {\n\treturn _randomstring[(Math.random() * _randomstring.length) >> 0] + _randomstring[(Math.random() * _randomstring.length) >> 0] + _randomstring[(Math.random() * _randomstring.length) >> 0];\n}\n\nconst WEBSOCKET_COMPRESS = U.createBuffer([0x00, 0x00, 0xFF, 0xFF]);\nconst WEBSOCKET_COMPRESS_OPTIONS = { windowBits: Zlib.Z_DEFAULT_WINDOWBITS };\nconst UIDGENERATOR = { types: {}  };\n\nfunction UIDGENERATOR_REFRESH() {\n\n\tUIDGENERATOR.date = NOW.format('yyMMddHHmm');\n\tUIDGENERATOR.index = 1;\n\tUIDGENERATOR.instance = random3string();\n\n\tvar keys;\n\n\tif (UIDGENERATOR.multiple) {\n\t\tkeys = Object.keys(UIDGENERATOR.types);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tUIDGENERATOR.types[keys[i]] = 0;\n\t}\n}\n\nUIDGENERATOR_REFRESH();\n\nconst EMPTYBUFFER = U.createBufferSize(0);\nglobal.EMPTYBUFFER = EMPTYBUFFER;\n\nconst controller_error_status = function(controller, status, problem) {\n\n\tif (status !== 500 && problem)\n\t\tcontroller.problem(problem);\n\n\tif (controller.res.success || controller.res.headersSent || !controller.isConnected)\n\t\treturn controller;\n\n\tcontroller.precache && controller.precache(null, null, null);\n\tcontroller.req.path = EMPTYARRAY;\n\tcontroller.req.$total_success();\n\tcontroller.req.$total_route = F.lookup(controller.req, '#' + status, EMPTYARRAY, 0);\n\tcontroller.req.$total_exception = problem;\n\tcontroller.req.$total_execute(status, true);\n\treturn controller;\n};\n\nvar PERF = {};\n\nfunction Framework() {\n\n\tvar self = this;\n\n\tself.$id = null; // F.id ==> property\n\tself.version = 3200;\n\tself.version_header = '3.2.0';\n\tself.version_node = process.version.toString();\n\tself.syshash = (__dirname + '-' + Os.hostname() + '-' + Os.platform() + '-' + Os.arch() + '-' + Os.release() + '-' + Os.tmpdir() + JSON.stringify(process.versions)).md5();\n\n\tglobal.CONF = self.config = {\n\n\t\tdebug: true,\n\t\ttrace: true,\n\t\ttrace_console: true,\n\n\t\tname: 'Total.js',\n\t\tversion: '1.0.0',\n\t\tauthor: '',\n\t\tsecret: self.syshash,\n\t\tsecret_uid: self.syshash.substring(10),\n\n\t\t'security.txt': 'Contact: mailto:support@totaljs.com\\nContact: https://www.totaljs.com/contact/',\n\t\tetag_version: '',\n\t\tdirectory_src: '/.src/',\n\t\tdirectory_bundles: '/bundles/',\n\t\tdirectory_controllers: '/controllers/',\n\t\tdirectory_components: '/components/',\n\t\tdirectory_views: '/views/',\n\t\tdirectory_definitions: '/definitions/',\n\t\tdirectory_temp: '/tmp/',\n\t\tdirectory_models: '/models/',\n\t\tdirectory_schemas: '/schemas/',\n\t\tdirectory_operations: '/operations/',\n\t\tdirectory_resources: '/resources/',\n\t\tdirectory_public: '/public/',\n\t\tdirectory_public_virtual: '/app/',\n\t\tdirectory_modules: '/modules/',\n\t\tdirectory_source: '/source/',\n\t\tdirectory_logs: '/logs/',\n\t\tdirectory_tests: '/tests/',\n\t\tdirectory_databases: '/databases/',\n\t\tdirectory_workers: '/workers/',\n\t\tdirectory_packages: '/packages/',\n\t\tdirectory_private: '/private/',\n\t\tdirectory_isomorphic: '/isomorphic/',\n\t\tdirectory_configs: '/configs/',\n\t\tdirectory_services: '/services/',\n\t\tdirectory_themes: '/themes/',\n\n\t\t// all HTTP static request are routed to directory-public\n\t\tstatic_url: '',\n\t\tstatic_url_script: '/js/',\n\t\tstatic_url_style: '/css/',\n\t\tstatic_url_image: '/img/',\n\t\tstatic_url_video: '/video/',\n\t\tstatic_url_font: '/fonts/',\n\t\tstatic_url_download: '/download/',\n\t\tstatic_url_components: '/components.',\n\t\tstatic_accepts: { flac: true, jpg: true, jpeg: true, png: true, gif: true, ico: true, js: true, css: true, txt: true, xml: true, woff: true, woff2: true, otf: true, ttf: true, eot: true, svg: true, zip: true, rar: true, pdf: true, docx: true, xlsx: true, doc: true, xls: true, html: true, htm: true, appcache: true, manifest: true, map: true, ogv: true, ogg: true, mp4: true, mp3: true, webp: true, webm: true, swf: true, package: true, json: true, md: true, m4v: true, jsx: true, heif: true, heic: true, ics: true },\n\n\t\t// 'static-accepts-custom': [],\n\n\t\tdefault_xpoweredby: '',\n\t\tdefault_layout: 'layout',\n\t\tdefault_theme: '',\n\t\tdefault_proxy: '',\n\t\tdefault_request_maxkeys: 33,\n\n\t\t// default maximum request size / length\n\t\t// default 10 kB\n\t\tdefault_request_maxlength: 10,\n\t\tdefault_websocket_maxlength: 2,\n\t\tdefault_websocket_encodedecode: true,\n\t\tdefault_maxopenfiles: 0,\n\t\tdefault_timezone: '',\n\t\tdefault_root: '',\n\t\tdefault_response_maxage: '11111111',\n\t\tdefault_errorbuilder_status: 200,\n\n\t\t// Default originators\n\t\tdefault_cors: null,\n\n\t\t// Seconds (2 minutes)\n\t\tdefault_cors_maxage: 120,\n\n\t\t// in milliseconds\n\t\tdefault_request_timeout: 3000,\n\t\tdefault_dependency_timeout: 1500,\n\t\tdefault_restbuilder_timeout: 10000,\n\n\t\t// otherwise is used ImageMagick (Heroku supports ImageMagick)\n\t\t// gm = graphicsmagick or im = imagemagick\n\t\tdefault_image_converter: 'gm',\n\t\tdefault_image_quality: 93,\n\t\tdefault_image_consumption: 30,\n\n\t\tallow_static_files: true,\n\t\tallow_gzip: true,\n\t\tallow_websocket: true,\n\t\tallow_websocket_compression: true,\n\t\tallow_compile: true,\n\t\tallow_compile_script: true,\n\t\tallow_compile_style: true,\n\t\tallow_compile_html: true,\n\t\tallow_performance: false,\n\t\tallow_custom_titles: false,\n\t\tallow_cache_snapshot: false,\n\t\tallow_cache_cluster: false,\n\t\tallow_debug: false,\n\t\tallow_head: false,\n\t\tallow_filter_errors: true,\n\t\tallow_clear_temp: true,\n\t\tallow_ssc_validation: false,\n\t\tnosql_worker: false,\n\t\tnosql_inmemory: null, // String Array\n\t\tnosql_cleaner: 1440,\n\t\tnosql_logger: true,\n\t\tlogger: false,\n\n\t\t// Used in F.service()\n\t\t// All values are in minutes\n\t\tdefault_interval_clear_resources: 20,\n\t\tdefault_interval_clear_cache: 10,\n\t\tdefault_interval_clear_dnscache: 120,\n\t\tdefault_interval_precompile_views: 61,\n\t\tdefault_interval_websocket_ping: 3,\n\t\tdefault_interval_uptodate: 5,\n\n\t\tset ['mail-smtp'] (val) {\n\t\t\tCONF['mail_smtp'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-smtp-options'] (val) {\n\t\t\tCONF['mail_smtp_options'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-reply'] (val) {\n\t\t\tCONF['mail_address_reply'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-from'] (val) {\n\t\t\tCONF['mail_address_from'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-copy'] (val) {\n\t\t\tCONF['mail_address_copy'] = val;\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tglobal.G = self.global = {};\n\tself.$bundling = true;\n\tself.resources = {};\n\tself.connections = {};\n\tglobal.FUNC = self.functions = {};\n\tself.themes = {};\n\tself.versions = null;\n\tself.workflows = {};\n\tself.uptodates = null;\n\tself.schedules = [];\n\n\tself.isDebug = true;\n\tself.isTest = false;\n\tself.isLoaded = false;\n\tself.isWorker = true;\n\tself.isCluster = process.env.PASSENGER_APP_ENV ? false : require('cluster').isWorker;\n\n\tself.routes = {\n\t\tsitemap: null,\n\t\tweb: [],\n\t\tsystem: {},\n\t\tfiles: [],\n\t\tcors: [],\n\t\tcorsall: false,\n\t\twebsockets: [],\n\t\tmiddleware: {},\n\t\tredirects: {},\n\t\tresize: {},\n\t\trequest: [],\n\t\tviews: {},\n\t\tmerge: {},\n\t\tmapping: {},\n\t\tpackages: {},\n\t\tblocks: {},\n\t\tresources: {}\n\t};\n\n\tself.owners = [];\n\tself.modificators = null;\n\tself.helpers = {};\n\tself.modules = {};\n\tself.models = {};\n\tself.sources = {};\n\tself.controllers = {};\n\tself.dependencies = {};\n\tself.isomorphic = {};\n\tself.components = { has: false, css: false, js: false, views: {}, instances: {}, version: null, links: '', groups: {}, files: {} };\n\tself.convertors = [];\n\tself.convertors2 = null;\n\tself.tests = [];\n\tself.errors = [];\n\tself.problems = [];\n\tself.changes = [];\n\tself.server = null;\n\tself.port = 0;\n\tself.ip = '';\n\n\tself.validators = {\n\t\temail: new RegExp('^[a-zA-Z0-9-_.+]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$'),\n\t\turl: /^(https?:\\/\\/(?:www\\.|(?!www))[^\\s.#!:?+=&@!$'~*,;/()[\\]]+\\.[^\\s#!?+=&@!$'~*,;()[\\]\\\\]{2,}\\/?|www\\.[^\\s#!:.?+=&@!$'~*,;/()[\\]]+\\.[^\\s#!?+=&@!$'~*,;()[\\]\\\\]{2,}\\/?)/i,\n\t\tphone: /^[+]?[(]?[0-9]{3}[)]?[-\\s.]?[0-9]{3}[-\\s.]?[0-9]{4,6}$/im,\n\t\tzip: /^\\d{5}(?:[-\\s]\\d{4})?$/,\n\t\tuid: /^\\d{14,}[a-z]{3}[01]{1}$/\n\t};\n\n\tself.workers = {};\n\tself.databases = {};\n\tself.databasescleaner = {};\n\tself.directory = HEADERS.workers.cwd = directory;\n\tself.isLE = Os.endianness ? Os.endianness() === 'LE' : true;\n\tself.isHTTPS = false;\n\n\t// Fix for workers crash (port in use) when debugging main process with --inspect or --debug\n\t// See: https://github.com/nodejs/node/issues/14325 and https://github.com/nodejs/node/issues/9435\n\tfor (var i = 0; i < process.execArgv.length; i++) {\n\t\t// Setting inspect/debug port to random unused\n\t\tif ((/inspect|debug/).test(process.execArgv[i])) {\n\t\t\tprocess.execArgv[i] = '--inspect=0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tHEADERS.workers.execArgv = process.execArgv;\n\n\t// It's hidden\n\t// self.waits = {};\n\n\tself.temporary = {\n\t\tpath: {},\n\t\tnotfound: {},\n\t\tprocessing: {},\n\t\trange: {},\n\t\tviews: {},\n\t\tversions: {},\n\t\tdependencies: {}, // temporary for module dependencies\n\t\tother: {},\n\t\tinternal: {}, // controllers/modules names for the routing\n\t\towners: {},\n\t\tready: {},\n\t\tservice: { redirect: 0, request: 0, file: 0 }\n\t};\n\n\tself.stats = {\n\n\t\tperformance: {\n\t\t\trequest: 0,\n\t\t\tfile: 0\n\t\t},\n\n\t\tother: {\n\t\t\twebsocketPing: 0,\n\t\t\twebsocketCleaner: 0,\n\t\t\tobsolete: 0,\n\t\t\tmail: 0\n\t\t},\n\n\t\trequest: {\n\t\t\trequest: 0,\n\t\t\tpending: 0,\n\t\t\tweb: 0,\n\t\t\txhr: 0,\n\t\t\tfile: 0,\n\t\t\twebsocket: 0,\n\t\t\tget: 0,\n\t\t\toptions: 0,\n\t\t\thead: 0,\n\t\t\tpost: 0,\n\t\t\tput: 0,\n\t\t\tpath: 0,\n\t\t\tupload: 0,\n\t\t\tschema: 0,\n\t\t\toperation: 0,\n\t\t\tblocked: 0,\n\t\t\t'delete': 0,\n\t\t\tmobile: 0,\n\t\t\tdesktop: 0\n\t\t},\n\t\tresponse: {\n\t\t\tview: 0,\n\t\t\tjson: 0,\n\t\t\twebsocket: 0,\n\t\t\ttimeout: 0,\n\t\t\tcustom: 0,\n\t\t\tbinary: 0,\n\t\t\tpipe: 0,\n\t\t\tfile: 0,\n\t\t\timage: 0,\n\t\t\tdestroy: 0,\n\t\t\tstream: 0,\n\t\t\tstreaming: 0,\n\t\t\tplain: 0,\n\t\t\tempty: 0,\n\t\t\tredirect: 0,\n\t\t\tforward: 0,\n\t\t\tnotModified: 0,\n\t\t\tsse: 0,\n\t\t\terrorBuilder: 0,\n\t\t\terror400: 0,\n\t\t\terror401: 0,\n\t\t\terror403: 0,\n\t\t\terror404: 0,\n\t\t\terror408: 0,\n\t\t\terror409: 0,\n\t\t\terror431: 0,\n\t\t\terror500: 0,\n\t\t\terror501: 0,\n\t\t\terror503: 0\n\t\t}\n\t};\n\n\t// intialize cache\n\tself.cache = new FrameworkCache();\n\tself.path = global.PATH = new FrameworkPath();\n\n\tself._request_check_redirect = false;\n\tself._request_check_referer = false;\n\tself._request_check_POST = false;\n\tself._request_check_robot = false;\n\tself._request_check_mobile = false;\n\tself._length_middleware = 0;\n\tself._length_request_middleware = 0;\n\tself._length_files = 0;\n\tself._length_wait = 0;\n\tself._length_themes = 0;\n\tself._length_cors = 0;\n\tself._length_subdomain_web = 0;\n\tself._length_subdomain_websocket = 0;\n\tself._length_convertors = 0;\n\n\tself.isVirtualDirectory = false;\n\tself.isTheme = false;\n\tself.isWindows = Os.platform().substring(0, 3).toLowerCase() === 'win';\n\n\tself.$events = {};\n}\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\nFramework.prototype = {\n\tget datetime() {\n\t\treturn global.NOW;\n\t},\n\tset datetime(val) {\n\t\tglobal.NOW = val;\n\t},\n\tget cluster() {\n\t\treturn require('./cluster');\n\t},\n\tget id() {\n\t\treturn F.$id;\n\t},\n\tset id(value) {\n\t\tCLUSTER_CACHE_SET.id = value;\n\t\tCLUSTER_CACHE_REMOVE.id = value;\n\t\tCLUSTER_CACHE_REMOVEALL.id = value;\n\t\tCLUSTER_CACHE_CLEAR.id = value;\n\t\tF.$id = value;\n\t\treturn F.$id;\n\t},\n\tget onLocate() {\n\t\treturn this.onLocale;\n\t},\n\tset onLocate(value) {\n\t\tOBSOLETE('F.onLocate', 'Rename \"F.onLocate\" method for \"F.onLocale\".');\n\t\tthis.onLocale = value;\n\t}\n};\n\nvar framework = new Framework();\nglobal.framework = global.F = module.exports = framework;\n\nF.callback_redirect = function(url) {\n\tthis.url = url;\n};\n\nF.dir = function(path) {\n\tF.directory = path;\n\tdirectory = path;\n};\n\nF.refresh = function() {\n\n\tNOW = new Date();\n\n\tF.$events.clear && EMIT('clear', 'temporary', F.temporary);\n\tF.temporary.path = {};\n\tF.temporary.range = {};\n\tF.temporary.views = {};\n\tF.temporary.other = {};\n\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\n\t// Clears command cache\n\tImage.clear();\n\n\tCONF.allow_debug && F.consoledebug('clear temporary cache');\n\n\tvar keys = Object.keys(F.temporary.internal);\n\tfor (var i = 0; i < keys.length; i++)\n\t\tif (!F.temporary.internal[keys[i]])\n\t\t\tdelete F.temporary.internal[keys[i]];\n\n\tF.$events.clear && EMIT('clear', 'resources');\n\tF.resources = {};\n\tCONF.allow_debug && F.consoledebug('clear resources');\n\n\tF.$events.clear && EMIT('clear', 'dns');\n\tU.clearDNS();\n\tCONF.allow_debug && F.consoledebug('clear DNS cache');\n\n\treturn F;\n};\n\nF.prototypes = function(fn) {\n\tvar proto = {};\n\tproto.Chunker = framework_utils.Chunker.prototype;\n\tproto.Controller = Controller.prototype;\n\tproto.Database = framework_nosql.Database.prototype;\n\tproto.DatabaseBinary = framework_nosql.DatabaseBinary.prototype;\n\tproto.DatabaseBuilder = framework_nosql.DatabaseBuilder.prototype;\n\tproto.DatabaseBuilder2 = framework_nosql.DatabaseBuilder2.prototype;\n\tproto.DatabaseCounter = framework_nosql.DatabaseCounter.prototype;\n\tproto.DatabaseStorage = framework_nosql.DatabaseStorage.prototype;\n\tproto.DatabaseTable = framework_nosql.DatabaseTable.prototype;\n\tproto.ErrorBuilder = framework_builders.ErrorBuilder.prototype;\n\tproto.HttpFile = framework_internal.HttpFile.prototype;\n\tproto.HttpRequest = PROTOREQ;\n\tproto.HttpResponse = PROTORES;\n\tproto.Image = framework_image.Image.prototype;\n\tproto.Message = Mail.Message.prototype;\n\tproto.MiddlewareOptions = MiddlewareOptions;\n\tproto.OperationOptions = framework_builders.OperationOptions.prototype;\n\tproto.Page = framework_builders.Page.prototype;\n\tproto.Pagination = framework_builders.Pagination.prototype;\n\tproto.RESTBuilder = framework_builders.RESTBuilder.prototype;\n\tproto.RESTBuilderResponse = framework_builders.RESTBuilderResponse.prototype;\n\tproto.SchemaBuilder = framework_builders.SchemaBuilder.prototype;\n\tproto.SchemaOptions = framework_builders.SchemaOptions.prototype;\n\tproto.UrlBuilder = framework_builders.UrlBuilder.prototype;\n\tproto.WebSocket = WebSocket.prototype;\n\tproto.WebSocketClient = WebSocketClient.prototype;\n\tfn.call(proto, proto);\n\treturn F;\n};\n\nglobal.ON = F.on = function(name, fn) {\n\n\tif (name === 'init' || name === 'ready' || name === 'load') {\n\t\tif (F.isLoaded) {\n\t\t\tfn.call(F);\n\t\t\treturn;\n\t\t}\n\t} else if (name.indexOf('#') !== -1) {\n\t\tvar arr = name.split('#');\n\t\tswitch (arr[0]) {\n\t\t\tcase 'middleware':\n\t\t\t\tF.temporary.ready[name] && fn.call(F);\n\t\t\t\tbreak;\n\t\t\tcase 'component':\n\t\t\t\tF.temporary.ready[name] && fn.call(F);\n\t\t\t\tbreak;\n\t\t\tcase 'model':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.models[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'source':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.sources[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'package':\n\t\t\tcase 'module':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.modules[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'controller':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.controllers[arr[1]]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (F.$events[name])\n\t\tF.$events[name].push(fn);\n\telse\n\t\tF.$events[name] = [fn];\n\n\treturn F;\n};\n\nglobal.EMIT = F.emit = function(name, a, b, c, d, e, f, g) {\n\n\tvar evt = F.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(F, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tF.$events[name] = evt;\n\t\t\telse\n\t\t\t\tF.$events[name] = undefined;\n\t\t}\n\t}\n\treturn F;\n};\n\nglobal.ONCE = F.once = function(name, fn) {\n\tfn.$once = true;\n\treturn F.on(name, fn);\n};\n\nF.removeListener = function(name, fn) {\n\tvar evt = F.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tF.$events[name] = evt;\n\t\telse\n\t\t\tF.$events[name] = undefined;\n\t}\n\treturn F;\n};\n\nF.removeAllListeners = function(name) {\n\tif (name)\n\t\tF.$events[name] = undefined;\n\telse\n\t\tF.$events = {};\n\treturn F;\n};\n\n/**\n * Internal function\n * @return {String} Returns current (dependency type and name) owner.\n */\nF.$owner = function() {\n\treturn _owner;\n};\n\nF.isSuccess = function(obj) {\n\treturn obj === SUCCESSHELPER;\n};\n\nF.convert = function(value, convertor) {\n\n\tif (convertor) {\n\n\t\tif (F.convertors.findIndex('name', value) !== -1) {\n\t\t\tif (convertor == null)\n\t\t\t\tF.convertors = F.convertors.remove('name', value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (convertor === Number)\n\t\t\tconvertor = U.parseFloat;\n\t\telse if (convertor === Boolean)\n\t\t\tconvertor = U.parseBoolean;\n\t\telse if (typeof(convertor) === 'string') {\n\t\t\tswitch (convertor.toLowerCase()) {\n\t\t\t\tcase 'json':\n\t\t\t\t\tconvertor = U.parseJSON;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'double':\n\t\t\t\t\tconvertor = U.parseFloat;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'integer':\n\t\t\t\t\tconvertor = U.parseInt2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn console.log('F.convert unknown convertor type:', convertor);\n\t\t\t}\n\t\t}\n\n\t\tF.convertors.push({ name: value, convertor: convertor });\n\t\tF._length_convertors = F.convertors.length;\n\t\treturn true;\n\t}\n\n\tfor (var i = 0, length = F.convertors.length; i < length; i++) {\n\t\tif (value[F.convertors[i].name] != null)\n\t\t\tvalue[F.convertors[i].name] = F.convertors[i].convertor(value[F.convertors[i].name]);\n\t}\n\n\treturn value;\n};\n\n/**\n * Get a controller\n * @param {String} name\n * @return {Object}\n */\nF.controller = function(name) {\n\treturn F.controllers[name] || null;\n};\n\n/**\n * Use configuration\n * @param {String} filename\n * @return {Framework}\n */\nF.useConfig = function(name) {\n\treturn F.$configure_configs(name, true);\n};\n\nF.useSMTP = function(smtp, options, callback) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tMail.try(smtp, options, function(err) {\n\n\t\tif (!err) {\n\t\t\tdelete F.temporary.mail_settings;\n\t\t\tCONF.mail_smtp = smtp;\n\t\t\tCONF.mail_smtp_options = options;\n\t\t}\n\n\t\tif (callback)\n\t\t\tcallback(err);\n\t\telse if (err)\n\t\t\tF.error(err, 'F.useSMTP()', null);\n\t});\n\n\treturn F;\n};\n\n/**\n * Sort all routes\n * @return {Framework}\n */\nF.$routesSort = function(type) {\n\n\tF.routes.web.sort((a, b) => a.priority > b.priority ? -1 : a.priority < b.priority ? 1 : 0);\n\tF.routes.websockets.sort((a, b) => a.priority > b.priority ? -1 : a.priority < b.priority ? 1 : 0);\n\n\tvar cache = {};\n\tvar length = F.routes.web.length;\n\tvar url;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tvar name = F.temporary.internal[route.controller];\n\t\tif (name)\n\t\t\troute.controller = name;\n\t\tif (!route.isMOBILE || route.isUPLOAD || route.isXHR || route.isJSON || route.isSYSTEM || route.isXML || route.flags.indexOf('get') === -1)\n\t\t\tcontinue;\n\t\turl = route.url.join('/');\n\t\tcache[url] = true;\n\t}\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tif (route.isMOBILE || route.isUPLOAD || route.isXHR || route.isJSON || route.isSYSTEM || route.isXML || route.flags.indexOf('get') === -1)\n\t\t\tcontinue;\n\t\turl = route.url.join('/');\n\t\troute.isMOBILE_VARY = cache[url] === true;\n\t}\n\n\t(!type || type === 1) && F.routes.web.forEach(function(route) {\n\t\tvar tmp = F.routes.web.findItem(item => item.hash === route.hash && item !== route);\n\t\troute.isUNIQUE = tmp == null;\n\t});\n\n\t// Clears cache\n\tObject.keys(F.temporary.other).forEach(function(key) {\n\t\tif (key[0] === '1')\n\t\t\tF.temporary.other[key] = undefined;\n\t});\n\n\treturn F;\n};\n\nF.parseComponent = parseComponent;\n\nF.script = function(body, value, callback, param) {\n\n\tvar fn;\n\tvar compilation = value === undefined && callback === undefined;\n\tvar err;\n\n\ttry {\n\t\tfn = new Function('next', 'value', 'now', 'var model=value;var global,require,process,GLOBAL,root,clearImmediate,clearInterval,clearTimeout,setImmediate,setInterval,setTimeout,console,$STRING,$VIEWCACHE,framework_internal,TransformBuilder,Pagination,Page,URLBuilder,UrlBuilder,SchemaBuilder,framework_builders,framework_utils,framework_mail,Image,framework_image,framework_nosql,Builders,U,utils,Utils,Mail,WTF,SOURCE,INCLUDE,MODULE,NOSQL,NOBIN,NOCOUNTER,NOSQLMEMORY,NOMEM,DATABASE,DB,CONFIG,INSTALL,UNINSTALL,RESOURCE,TRANSLATOR,LOG,LOGGER,MODEL,GETSCHEMA,CREATE,UID,TRANSFORM,MAKE,SINGLETON,NEWTRANSFORM,NEWSCHEMA,EACHSCHEMA,FUNCTION,ROUTING,SCHEDULE,OBSOLETE,DEBUG,TEST,RELEASE,is_client,is_server,F,framework,Controller,setTimeout2,clearTimeout2,String,Number,Boolean,Object,Function,Date,isomorphic,I,eval;UPTODATE,NEWOPERATION,OPERATION,$$$,EMIT,ON,$QUERY,$GET,$WORKFLOW,$TRANSFORM,$OPERATION,$MAKE,$CREATE,HttpFile;EMPTYCONTROLLER,ROUTE,FILE,TEST,WEBSOCKET,MAIL,LOGMAIL;try{' + body + ';\\n}catch(e){next(e)}');\n\t} catch(e) {\n\t\terr = e;\n\t}\n\n\tif (err) {\n\t\tcallback && callback(err);\n\t\treturn compilation ? err : F;\n\t}\n\n\tif (compilation) {\n\t\treturn (function() {\n\t\t\treturn function(model, callback, param) {\n\t\t\t\treturn fn.call(EMPTYOBJECT, function(value) {\n\t\t\t\t\tif (value instanceof Error)\n\t\t\t\t\t\tcallback(value, undefined, param);\n\t\t\t\t\telse\n\t\t\t\t\t\tcallback(null, value, param);\n\t\t\t\t}, model, scriptNow);\n\t\t\t};\n\t\t})();\n\t}\n\n\tfn.call(EMPTYOBJECT, function(value) {\n\n\t\tif (!callback)\n\t\t\treturn;\n\n\t\tif (value instanceof Error)\n\t\t\tcallback(value);\n\t\telse\n\t\t\tcallback(null, value);\n\n\t}, value, scriptNow, param);\n\n\treturn F;\n};\n\nfunction scriptNow() {\n\treturn new Date();\n}\n\nF.database = global.NOSQL = F.nosql = function(name) {\n\tvar db = F.databases[name];\n\tif (db)\n\t\treturn db;\n\n\tvar is = name.substring(0, 6);\n\tif (is === 'http:/' || is === 'https:')\n\t\tdb = framework_nosql.load(U.getName(name), name);\n\telse {\n\t\tF.path.verify('databases');\n\t\tdb = framework_nosql.load(name, F.path.databases(name));\n\t}\n\n\tF.databases[name] = db;\n\treturn db;\n};\n\nglobal.TABLE = function(name) {\n\tvar db = F.databases['$' + name];\n\tif (db)\n\t\treturn db;\n\tF.path.verify('databases');\n\tdb = framework_nosql.table(name, F.path.databases(name));\n\tF.databases['$' + name] = db;\n\treturn db;\n};\n\nF.stop = F.kill = function(signal) {\n\n\tif (F.isKilled)\n\t\treturn F;\n\n\tF.isKilled = true;\n\n\tif (!signal)\n\t\tsignal = 'SIGTERM';\n\n\tfor (var m in F.workers) {\n\t\tvar worker = F.workers[m];\n\t\tTRY(() => worker && worker.kill && worker.kill(signal));\n\t}\n\n\tframework_nosql.kill(signal);\n\n\tEMIT('exit', signal);\n\n\tif (!F.isWorker && process.send)\n\t\tTRY(() => process.send('total:stop'));\n\n\tF.cache.stop();\n\n\tif (F.server) {\n\t\tF.server.setTimeout(1);\n\t\tF.server.close();\n\t}\n\n\tvar extenddelay = F.grapdbinstance && require('./graphdb').getImportantOperations() > 0;\n\tsetTimeout(() => process.exit(signal), global.TEST || extenddelay ? 2000 : 300);\n\treturn F;\n};\n\nglobal.REDIRECT = F.redirect = function(host, newHost, withPath, permanent) {\n\n\tvar external = host.startsWith('http://') || host.startsWith('https');\n\tif (external) {\n\n\t\tif (host[host.length - 1] === '/')\n\t\t\thost = host.substring(0, host.length - 1);\n\n\t\tif (newHost[newHost.length - 1] === '/')\n\t\t\tnewHost = newHost.substring(0, newHost.length - 1);\n\n\t\tF.routes.redirects[host] = { url: newHost, path: withPath, permanent: permanent };\n\t\tF._request_check_redirect = true;\n\t\tF.owners.push({ type: 'redirects', owner: _owner, id: host });\n\t\treturn F;\n\t}\n\n\tif (host[0] !== '/')\n\t\thost = '/' + host;\n\n\tvar flags;\n\n\tif (withPath instanceof Array) {\n\t\tflags = withPath;\n\t\twithPath = permanent === true;\n\t} else if (permanent instanceof Array) {\n\t\tflags = permanent;\n\t\twithPath = withPath === true;\n\t} else\n\t\twithPath = withPath === true;\n\n\tpermanent = withPath;\n\n\tif (U.isStaticFile(host)) {\n\t\tF.file(host, function(req, res) {\n\t\t\tif (newHost.startsWith('http://') || newHost.startsWith('https://'))\n\t\t\t\tres.redirect(newHost, permanent);\n\t\t\telse\n\t\t\t\tres.redirect(newHost[0] !== '/' ? '/' + newHost : newHost, permanent);\n\t\t});\n\t\treturn F;\n\t}\n\n\tF.route(host, function() {\n\n\t\tif (newHost.startsWith('http://') || newHost.startsWith('https://')) {\n\t\t\tthis.redirect(newHost + this.href(), permanent);\n\t\t\treturn;\n\t\t}\n\n\t\tif (newHost[0] !== '/')\n\t\t\tnewHost = '/' + newHost;\n\n\t\tthis.redirect(newHost + this.href(), permanent);\n\t}, flags);\n\n\treturn F;\n};\n\n/**\n * Schedule job\n * @param {Date or String} date\n * @param {Boolean} repeat Repeat schedule\n * @param {Function} fn\n * @return {Framework}\n */\nF.schedule = function(date, repeat, fn) {\n\n\tif (fn === undefined) {\n\t\tfn = repeat;\n\t\trepeat = false;\n\t}\n\n\tvar type = typeof(date);\n\n\tif (type === 'string') {\n\t\tdate = date.parseDate().toUTC();\n\t\trepeat && date < NOW && (date = date.add(repeat));\n\t} else if (type === 'number')\n\t\tdate = new Date(date);\n\n\tvar sum = date.getTime();\n\trepeat && (repeat = repeat.replace('each', '1'));\n\tvar id = U.GUID(5);\n\tF.schedules.push({ expire: sum, fn: fn, repeat: repeat, owner: _owner, id: id });\n\treturn id;\n};\n\nF.clearSchedule = function(id) {\n\tF.schedules = F.schedules.remove('id', id);\n\treturn F;\n};\n\n\n/**\n * Auto resize picture according the path\n * @param {String} url Relative path.\n * @param {Function(image)} fn Processing.\n * @param {String Array} flags Optional, can contains extensions `.jpg`, `.gif' or watching path `/img/gallery/`\n * @return {Framework}\n */\nF.resize = function(url, fn, flags) {\n\n\tvar extensions = {};\n\tvar cache = true;\n\n\tif (typeof(flags) === 'function') {\n\t\tvar tmp = flags;\n\t\tflags = fn;\n\t\tfn = tmp;\n\t}\n\n\tvar ext = url.match(/\\*.\\*$|\\*?\\.(jpg|png|gif|jpeg|heif|heic|apng)$/gi);\n\tif (ext) {\n\t\turl = url.replace(ext, '');\n\t\tswitch (ext.toString().toLowerCase()) {\n\t\t\tcase '*.*':\n\t\t\t\textensions['*'] = true;\n\t\t\t\tbreak;\n\t\t\tcase '*.jpg':\n\t\t\tcase '*.gif':\n\t\t\tcase '*.png':\n\t\t\tcase '*.heif':\n\t\t\tcase '*.heic':\n\t\t\tcase '*.apng':\n\t\t\tcase '*.jpeg':\n\t\t\t\textensions[ext.toString().toLowerCase().replace(/\\*/g, '').substring(1)] = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar path = url;\n\n\tif (flags && flags.length) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tif (flag[0] === '.')\n\t\t\t\textensions[flag.substring(1)] = true;\n\t\t\telse if (flag[0] === '~' || flag[0] === '/' || flag.match(/^http:|https:/gi))\n\t\t\t\tpath = flag;\n\t\t\telse if (flag === 'nocache')\n\t\t\t\tcache = false;\n\t\t}\n\t}\n\n\tif (!extensions.length) {\n\t\textensions['jpg'] = true;\n\t\textensions['jpeg'] = true;\n\t\textensions['png'] = true;\n\t\textensions['gif'] = true;\n\t\textensions['heic'] = true;\n\t\textensions['heif'] = true;\n\t\textensions['apng'] = true;\n\t}\n\n\tif (extensions['jpg'] && !extensions['jpeg'])\n\t\textensions['jpeg'] = true;\n\telse if (extensions['jpeg'] && !extensions['jpg'])\n\t\textensions['jpg'] = true;\n\n\tF.routes.resize[url] = { fn: fn, path: U.path(path || url), ishttp: path.match(/http:|https:/gi) ? true : false, extension: extensions, cache: cache };\n\tF.owners.push({ type: 'resize', owner: _owner, id: url });\n\treturn F;\n};\n\n/**\n * RESTful routing\n * @param {String} url A relative url.\n * @param {String Array} flags\n * @param {Function} onQuery\n * @param {Function(id)} onGet\n * @param {Function([id])} onSave\n * @param {Function(id)} onDelete\n * @return {Framework}\n */\nF.restful = function(url, flags, onQuery, onGet, onSave, onDelete) {\n\n\tvar tmp;\n\tvar index = flags ? flags.indexOf('cors') : -1;\n\tvar cors = {};\n\n\tif (index !== -1)\n\t\tflags.splice(index, 1);\n\n\tif (onQuery) {\n\t\ttmp = [];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onQuery);\n\t\tcors['get'] = true;\n\t}\n\n\tvar restful = U.path(url) + '{id}';\n\n\tif (onGet) {\n\t\tcors['get'] = true;\n\t\ttmp = [];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onGet);\n\t}\n\n\tif (onSave) {\n\t\tcors['post'] = true;\n\t\ttmp = ['post'];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onSave);\n\t\ttmp = ['put'];\n\t\tcors['put'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onSave);\n\t}\n\n\tif (onDelete) {\n\t\tcors['delete'] = true;\n\t\ttmp = ['delete'];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onDelete);\n\t}\n\n\tif (index !== -1)\n\t\tF.cors(U.path(url) + '*', Object.keys(cors), flags.indexOf('authorize') === -1);\n\n\treturn F;\n};\n\n// This version of RESTful doesn't create advanced routing for insert/update/delete and all URL address of all operations are without \"{id}\" param because they expect some identificator in request body\nF.restful2 = function(url, flags, onQuery, onGet, onSave, onDelete) {\n\n\tvar tmp;\n\tvar index = flags ? flags.indexOf('cors') : -1;\n\tvar cors = {};\n\n\tif (index !== -1)\n\t\tflags.splice(index, 1);\n\n\tif (onQuery) {\n\t\ttmp = [];\n\t\tcors['get'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onQuery);\n\t}\n\n\tif (onGet) {\n\t\ttmp = [];\n\t\tcors['get'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(U.path(url) + '{id}', tmp, onGet);\n\t}\n\n\tif (onSave) {\n\t\ttmp = ['post'];\n\t\tcors['post'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onSave);\n\t}\n\n\tif (onDelete) {\n\t\ttmp = ['delete'];\n\t\tcors['delete'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onDelete);\n\t}\n\n\tif (index !== -1)\n\t\tF.cors(U.path(url) + '*', Object.keys(cors), flags.indexOf('authorize') === -1);\n\n\treturn F;\n};\n\n/**\n * Register cors\n * @param {String} url\n * @param {String Array or String} origin\n * @param {String Array or String} methods\n * @param {String Array or String} headers\n * @param {Boolean} credentials\n * @return {Framework}\n */\nglobal.CORS = F.cors = function(url, flags, credentials) {\n\n\tif (!arguments.length) {\n\t\tF.routes.corsall = true;\n\t\tPERF.OPTIONS = true;\n\t\treturn F;\n\t}\n\n\tif (flags === true) {\n\t\tcredentials = true;\n\t\tflags = null;\n\t}\n\n\tvar route = {};\n\tvar origin = [];\n\tvar methods = [];\n\tvar headers = [];\n\tvar age;\n\tvar id;\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tvar type = typeof(flag);\n\n\t\t\tif (type === 'string')\n\t\t\t\tflag = flag.toLowerCase();\n\t\t\telse if (type === 'number') {\n\t\t\t\tage = flag;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type === 'boolean' || flag.startsWith('credential')) {\n\t\t\t\tcredentials = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.substring(0, 2) === '//') {\n\t\t\t\torigin.push(flag.substring(2));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t\torigin.push(flag.substring(flag.indexOf('/') + 2));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.substring(0, 3) === 'id:') {\n\t\t\t\tid = flag.substring(3);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flag) {\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'get':\n\t\t\t\t\tmethods.push(flag.toUpperCase());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\theaders.push(flags[i].toLowerCase());\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!methods.length)\n\t\tmethods = 'POST,PUT,GET,DELETE,PATCH,GET,HEAD'.split(',');\n\n\tif (!origin.length && CONF.default_cors)\n\t\torigin = CONF.default_cors;\n\n\troute.isWILDCARD = url.lastIndexOf('*') !== -1;\n\n\tvar index = url.indexOf('{');\n\tif (index !== -1) {\n\t\troute.isWILDCARD = true;\n\t\turl = url.substring(0, index);\n\t}\n\n\tif (route.isWILDCARD)\n\t\turl = url.replace('*', '');\n\n\tif (url[url.length - 1] !== '/')\n\t\turl += '/';\n\n\turl = framework_internal.preparePath(framework_internal.encodeUnicodeURL(url.trim()));\n\troute.hash = url.hash();\n\troute.owner = _owner;\n\troute.url = framework_internal.routeSplitCreate(url);\n\troute.origin = origin.length ? origin : null;\n\troute.methods = methods.length ? methods : null;\n\troute.headers = headers.length ? headers : null;\n\troute.credentials = credentials;\n\troute.age = age || CONF.default_cors_maxage;\n\n\tvar e = F.routes.cors.findItem(function(item) {\n\t\treturn item.hash === route.hash;\n\t});\n\n\tif (e) {\n\n\t\t// Extends existing\n\t\tif (route.origin && e.origin)\n\t\t\tcorsextend(route.origin, e.origin);\n\t\telse if (e.origin && !route.origin)\n\t\t\te.origin = null;\n\n\t\tif (route.methods && e.methods)\n\t\t\tcorsextend(route.methods, e.methods);\n\n\t\tif (route.headers && e.headers)\n\t\t\tcorsextend(route.headers, e.headers);\n\n\t\tif (route.credentials && !e.credentials)\n\t\t\te.credentials = true;\n\n\t\tif (route.isWILDCARD && !e.isWILDCARD)\n\t\t\te.isWILDCARD = true;\n\n\t} else {\n\t\tF.routes.cors.push(route);\n\t\troute.id = id;\n\t}\n\n\tF._length_cors = F.routes.cors.length;\n\n\tF.routes.cors.sort(function(a, b) {\n\t\tvar al = a.url.length;\n\t\tvar bl = b.url.length;\n\t\treturn al > bl ? - 1 : al < bl ? 1 : a.isWILDCARD && b.isWILDCARD ? 1 : 0;\n\t});\n\n\tPERF.OPTIONS = true;\n\treturn F;\n};\n\nfunction corsextend(a, b) {\n\tfor (var i = 0; i < a.length; i++)\n\t\tb.indexOf(a[i]) === -1 && b.push(a[i]);\n}\n\nglobal.GROUP = F.group = function() {\n\n\tvar fn = null;\n\n\t_flags = null;\n\t_prefix = null;\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar o = arguments[i];\n\n\t\tif (o instanceof Array) {\n\t\t\t_flags = o;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (typeof(o)) {\n\t\t\tcase 'string':\n\t\t\t\tif (o.endsWith('/'))\n\t\t\t\t\to = o.substring(0, o.length - 1);\n\t\t\t\t_prefix = o;\n\t\t\t\tbreak;\n\t\t\tcase 'function':\n\t\t\t\tfn = o;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfn && fn.call(F);\n\t_prefix = undefined;\n\t_flags = undefined;\n\treturn F;\n};\n\n/**\n * Add a route\n * @param {String} url\n * @param {Function} funcExecute Action.\n * @param {String Array} flags\n * @param {Number} length Maximum length of request data.\n * @param {String Array} middleware Loads custom middleware.\n * @param {Number} timeout Response timeout.\n * @return {Framework}\n */\nglobal.ROUTE = F.web = F.route = function(url, funcExecute, flags, length, language) {\n\n\tvar name;\n\tvar tmp;\n\tvar viewname;\n\tvar sitemap;\n\n\tif (url instanceof Array) {\n\t\turl.forEach(url => F.route(url, funcExecute, flags, length));\n\t\treturn F;\n\t}\n\n\tif (typeof(flags) === 'number') {\n\t\tlength = flags;\n\t\tflags = null;\n\t}\n\n\tvar type = typeof(funcExecute);\n\n\tif (funcExecute instanceof Array) {\n\t\ttmp = funcExecute;\n\t\tfuncExecute = flags;\n\t\tflags = tmp;\n\t}\n\n\tvar search = (typeof(url) === 'string' ? url.toLowerCase().replace(/\\s{2,}/g, ' ') : '') + (flags ? (' ' + flags.where(n => typeof(n) === 'string' && n.substring(0, 2) !== '//' && n[2] !== ':').join(' ')).toLowerCase() : '');\n\tvar method = '';\n\tvar CUSTOM = typeof(url) === 'function' ? url : null;\n\tif (CUSTOM)\n\t\turl = '/';\n\n\tif (url) {\n\n\t\turl = url.replace(/\\t/g, ' ');\n\n\t\turl = url.replace(/(^|\\s?)\\*([{}a-z0-9}]|\\s).*?$/i, function(text) {\n\t\t\t!flags && (flags = []);\n\t\t\tflags.push(text.trim());\n\t\t\treturn '';\n\t\t}).trim();\n\n\t\tvar index = url.indexOf(' ');\n\t\tif (index !== -1) {\n\t\t\tmethod = url.substring(0, index).toLowerCase().trim();\n\t\t\turl = url.substring(index + 1).trim();\n\t\t}\n\n\t\tif (method.indexOf(',') !== -1) {\n\t\t\t!flags && (flags = []);\n\t\t\tmethod.split(',').forEach(m => flags.push(m.trim()));\n\t\t\tmethod = '';\n\t\t}\n\t}\n\n\tif (url[0] === '#') {\n\t\turl = url.substring(1);\n\t\tif (url !== '400' && url !== '401' && url !== '403' && url !== '404' && url !== '408' && url !== '409' && url !== '431' && url !== '500' && url !== '501') {\n\n\t\t\tvar sitemapflags = funcExecute instanceof Array ? funcExecute : flags;\n\t\t\tif (!(sitemapflags instanceof Array))\n\t\t\t\tsitemapflags = EMPTYARRAY;\n\n\t\t\tvar index = url.indexOf('/');\n\t\t\tif (index !== -1) {\n\t\t\t\ttmp = url.substring(index);\n\t\t\t\turl = url.substring(0, index);\n\t\t\t} else\n\t\t\t\ttmp = '';\n\n\t\t\tsitemap = F.sitemap(url, true, language);\n\n\t\t\tif (sitemap) {\n\n\t\t\t\tname = url;\n\t\t\t\turl = sitemap.url;\n\n\t\t\t\tif (sitemap.localizeUrl && language === undefined) {\n\t\t\t\t\tvar sitemaproutes = {};\n\t\t\t\t\tF.temporary.internal.resources.forEach(function(language) {\n\t\t\t\t\t\tvar item = F.sitemap(sitemap.id, true, language);\n\t\t\t\t\t\tif (item.url && item.url !== url)\n\t\t\t\t\t\t\tsitemaproutes[item.url] = { name: sitemap.id, language: language };\n\t\t\t\t\t});\n\t\t\t\t\tObject.keys(sitemaproutes).forEach(key => F.route('#' + sitemap.id, funcExecute, flags, length, sitemaproutes[key].language));\n\t\t\t\t}\n\n\t\t\t\tif (tmp)\n\t\t\t\t\turl += url[url.length - 1] === '/' ? tmp.substring(1) : tmp;\n\t\t\t\telse if (sitemap.wildcard)\n\t\t\t\t\turl += '*';\n\t\t\t} else\n\t\t\t\tthrow new Error('Sitemap item \"' + url + '\" not found.');\n\t\t} else\n\t\t\turl = '#' + url;\n\t}\n\n\tif (!url)\n\t\turl = '/';\n\n\tif (url[0] !== '[' && url[0] !== '/')\n\t\turl = '/' + url;\n\n\tif (_prefix)\n\t\turl = _prefix + url;\n\n\tif (url.endsWith('/'))\n\t\turl = url.substring(0, url.length - 1);\n\n\turl = framework_internal.encodeUnicodeURL(url);\n\n\tvar urlcache = url;\n\n\tif (!name)\n\t\tname = url;\n\n\tif (method) {\n\t\t!flags && (flags = []);\n\t\tflags.push(method);\n\t\tmethod = '';\n\t}\n\n\tvar priority = 0;\n\tvar subdomain = null;\n\n\tpriority = url.count('/');\n\n\tif (url[0] === '[') {\n\t\tindex = url.indexOf(']');\n\t\tif (index > 0) {\n\t\t\tsubdomain = url.substring(1, index).trim().toLowerCase().split(',');\n\t\t\turl = url.substring(index + 1);\n\t\t\tpriority += subdomain.indexOf('*') !== -1 ? 50 : 100;\n\t\t}\n\t}\n\n\tvar isWILDCARD = url.indexOf('*') !== -1;\n\tif (isWILDCARD) {\n\t\turl = url.replace('*', '').replace('//', '/');\n\t\tpriority = priority - 100;\n\t}\n\n\tvar isRaw = false;\n\tvar isNOXHR = false;\n\tvar schema;\n\tvar workflow;\n\tvar isMOBILE = false;\n\tvar isJSON = false;\n\tvar isDELAY = false;\n\tvar isROBOT = false;\n\tvar isBINARY = false;\n\tvar isCORS = false;\n\tvar isROLE = false;\n\tvar novalidate = false;\n\tvar middleware = null;\n\tvar timeout;\n\tvar options;\n\tvar corsflags = [];\n\tvar membertype = 0;\n\tvar isGENERATOR = false;\n\tvar isDYNAMICSCHEMA = false;\n\tvar description;\n\tvar id = null;\n\tvar groups = [];\n\n\tif (_flags) {\n\t\t!flags && (flags = []);\n\t\t_flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\t}\n\n\tif (flags) {\n\n\t\ttmp = [];\n\t\tvar count = 0;\n\n\t\tfor (var i = 0; i < flags.length; i++) {\n\n\t\t\tvar tt = typeof(flags[i]);\n\n\t\t\tif (tt === 'number') {\n\t\t\t\ttimeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tt === 'object') {\n\t\t\t\toptions = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tflags[i] = flags[i].replace(/\\t/g, ' ');\n\n\t\t\tvar first = flags[i][0];\n\t\t\tif (first === '&') {\n\t\t\t\tgroups.push(flags[i].substring(1).trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ROUTE identificator\n\t\t\tif (flags[i].substring(0, 3) === 'id:') {\n\t\t\t\tid = flags[i].substring(3).trim();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first === '#') {\n\t\t\t\t!middleware && (middleware = []);\n\t\t\t\tmiddleware.push(flags[i].substring(1).trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first === '*') {\n\n\t\t\t\tworkflow = flags[i].trim().substring(1);\n\t\t\t\tindex = workflow.indexOf('-->');\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tschema = workflow.substring(0, index).trim();\n\t\t\t\t\tworkflow = workflow.substring(index + 3).trim();\n\t\t\t\t} else {\n\t\t\t\t\tschema = workflow;\n\t\t\t\t\tworkflow = null;\n\t\t\t\t}\n\n\t\t\t\tschema = schema.replace(/\\\\/g, '/').split('/').trim();\n\n\t\t\t\tif (schema.length) {\n\n\t\t\t\t\tif (schema.length === 1) {\n\t\t\t\t\t\tschema[1] = schema[0];\n\t\t\t\t\t\tschema[0] = 'default';\n\n\t\t\t\t\t\t// Is dynamic schema?\n\t\t\t\t\t\tif (schema[1][0] === '{') {\n\t\t\t\t\t\t\tisDYNAMICSCHEMA = true;\n\t\t\t\t\t\t\tschema[1] = schema[1].substring(1, schema[1].length - 1).trim();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = schema[1].indexOf('#');\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tschema[2] = schema[1].substring(index + 1).trim();\n\t\t\t\t\t\tschema[1] = schema[1].substring(0, index).trim();\n\t\t\t\t\t\t(schema[2] && schema[2][0] !== '*') && (schema[2] = '*' + schema[2]);\n\t\t\t\t\t}\n\n\t\t\t\t} // else it's an operation\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Comment\n\t\t\tif (flags[i].substring(0, 3) === '// ') {\n\t\t\t\tdescription = flags[i].substring(3).trim();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar flag = flags[i].toString().toLowerCase();\n\t\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t\tcorsflags.push(flag);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tswitch (flag) {\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tisJSON = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'delay':\n\t\t\t\t\tcount--;\n\t\t\t\t\tisDELAY = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'binary':\n\t\t\t\t\tisBINARY = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'cors':\n\t\t\t\t\tisCORS = true;\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'credential':\n\t\t\t\tcase 'credentials':\n\t\t\t\t\tcorsflags.push(flag);\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'sync':\n\t\t\t\tcase 'yield':\n\t\t\t\tcase 'synchronize':\n\t\t\t\t\tisGENERATOR = true;\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'novalidate':\n\t\t\t\t\tnovalidate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'noxhr':\n\t\t\t\tcase '-xhr':\n\t\t\t\t\tisNOXHR = true;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'raw':\n\t\t\t\t\tisRaw = true;\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tisMOBILE = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'robot':\n\t\t\t\t\tisROBOT = true;\n\t\t\t\t\tF._request_check_robot = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'authorize':\n\t\t\t\tcase 'authorized':\n\t\t\t\tcase 'logged':\n\t\t\t\t\tmembertype = 1;\n\t\t\t\t\tpriority += 2;\n\t\t\t\t\ttmp.push('authorize');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unauthorize':\n\t\t\t\tcase 'unauthorized':\n\t\t\t\tcase 'unlogged':\n\t\t\t\t\tmembertype = 2;\n\t\t\t\t\tpriority += 2;\n\t\t\t\t\ttmp.push('unauthorize');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'referer':\n\t\t\t\tcase 'referrer':\n\t\t\t\t\ttmp.push('referer');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'propfind':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'trace':\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tmethod += (method ? ',' : '') + flag;\n\t\t\t\t\tcorsflags.push(flag);\n\t\t\t\t\tPERF[flag.toUpperCase()] = true;\n\t\t\t\t\tPERF[flag] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (flag[0] === '@')\n\t\t\t\t\t\tisROLE = true;\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flag === 'get')\n\t\t\t\tpriority -= 2;\n\n\t\t}\n\n\t\tif (isROLE && !membertype) {\n\t\t\ttmp.push('authorize');\n\t\t\tpriority += 2;\n\t\t\tmembertype = 1;\n\t\t\tcount++;\n\t\t}\n\n\t\tflags = tmp;\n\t\tpriority += (count * 2);\n\t} else {\n\t\tflags = ['get'];\n\t\tmethod = 'get';\n\t}\n\n\tif (workflow && workflow[0] === '@') {\n\t\tvar tmpa = workflow.replace(/,/g, ' ').split('@').trim();\n\t\tvar rindex = null;\n\t\tfor (var i = 0; i < tmpa.length; i++) {\n\t\t\tvar a = tmpa[i].split(' ');\n\t\t\tif (a[1] && (/response|res/i).test(a[1]))\n\t\t\t\trindex = i;\n\t\t\ttmpa[i] = a[0];\n\t\t}\n\t\tworkflow = { id: tmpa.length > 1 ? tmpa : tmpa[0], index: rindex };\n\t}\n\n\tif (type === 'string') {\n\t\tviewname = funcExecute;\n\t\tfuncExecute = (function(name, sitemap, language, workflow) {\n\t\t\tvar themeName = U.parseTheme(name);\n\t\t\tif (themeName)\n\t\t\t\tname = prepare_viewname(name);\n\t\t\treturn function(id) {\n\t\t\t\tif (language && !this.language)\n\t\t\t\t\tthis.language = language;\n\t\t\t\tsitemap && this.sitemap(sitemap.id, language);\n\t\t\t\tif (name[0] === '~')\n\t\t\t\t\tthis.themeName = '';\n\t\t\t\telse if (themeName)\n\t\t\t\t\tthis.themeName = themeName;\n\t\t\t\tif (!this.route.workflow)\n\t\t\t\t\treturn this.view(name);\n\n\t\t\t\tvar self = this;\n\t\t\t\tif (this.route.workflow instanceof Object) {\n\t\t\t\t\tworkflow.view = name;\n\t\t\t\t\tif (workflow.id instanceof Array)\n\t\t\t\t\t\tcontroller_json_workflow_multiple.call(self, id);\n\t\t\t\t\telse\n\t\t\t\t\t\tcontroller_json_workflow.call(self, id);\n\t\t\t\t} else {\n\t\t\t\t\tthis.$exec(this.route.workflow, null, function(err, response) {\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tself.content(err);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tself.view(name, response);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t})(viewname, sitemap, language, workflow);\n\t} else if (typeof(funcExecute) !== 'function') {\n\n\t\tviewname = (sitemap && sitemap.url !== '/' ? sitemap.id : workflow ? '' : url) || '';\n\t\tif (!workflow || (!viewname && !workflow)) {\n\t\t\tif (viewname.endsWith('/'))\n\t\t\t\tviewname = viewname.substring(0, viewname.length - 1);\n\n\t\t\tindex = viewname.lastIndexOf('/');\n\t\t\tif (index !== -1)\n\t\t\t\tviewname = viewname.substring(index + 1);\n\n\t\t\tif (!viewname || viewname === '/')\n\t\t\t\tviewname = 'index';\n\n\t\t\tfuncExecute = (function(name, sitemap, language) {\n\t\t\t\treturn function(id) {\n\t\t\t\t\tvar self = this;\n\n\t\t\t\t\tif (language && !self.language)\n\t\t\t\t\t\tself.language = language;\n\n\t\t\t\t\tsitemap && self.sitemap(sitemap.id, language);\n\n\t\t\t\t\tif (name[0] === '~')\n\t\t\t\t\t\tself.themeName = '';\n\n\t\t\t\t\tif (!self.route.workflow)\n\t\t\t\t\t\treturn self.view(name);\n\n\t\t\t\t\tif (self.route.workflow instanceof Object) {\n\t\t\t\t\t\tworkflow.view = name;\n\t\t\t\t\t\tif (workflow.id instanceof Array)\n\t\t\t\t\t\t\tcontroller_json_workflow_multiple.call(self, id);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontroller_json_workflow.call(self, id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.$exec(self.route.workflow, null, function(err, response) {\n\t\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\t\tself.content(err);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tself.view(name, response);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(viewname, sitemap, language);\n\t\t} else if (workflow)\n\t\t\tfuncExecute = workflow.id instanceof Array ? controller_json_workflow_multiple : controller_json_workflow;\n\t}\n\n\tif (!isGENERATOR)\n\t\tisGENERATOR = (funcExecute.constructor.name === 'GeneratorFunction' || funcExecute.toString().indexOf('function*') === 0);\n\n\tvar url2 = framework_internal.preparePath(url.trim());\n\tvar urlraw = U.path(url2) + (isWILDCARD ? '*' : '');\n\tvar hash = url2.hash();\n\tvar routeURL = framework_internal.routeSplitCreate(url2);\n\tvar arr = [];\n\tvar params = [];\n\tvar reg = null;\n\tvar regIndex = null;\n\tvar dynamicidindex = -1;\n\n\tif (url.indexOf('{') !== -1) {\n\t\trouteURL.forEach(function(o, i) {\n\t\t\tif (o.substring(0, 1) !== '{')\n\t\t\t\treturn;\n\n\t\t\tarr.push(i);\n\n\t\t\tvar sub = o.substring(1, o.length - 1);\n\t\t\tvar name = o.substring(1, o.length - 1).trim();\n\n\t\t\tif (name === 'id')\n\t\t\t\tdynamicidindex = i;\n\n\t\t\tparams.push(name);\n\n\t\t\tif (sub[0] !== '/')\n\t\t\t\treturn;\n\n\t\t\tvar index = sub.lastIndexOf('/');\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = {};\n\t\t\t\tregIndex = [];\n\t\t\t}\n\n\t\t\tparams[params.length - 1] = 'regexp' + (regIndex.length + 1);\n\t\t\treg[i] = new RegExp(sub.substring(1, index), sub.substring(index + 1));\n\t\t\tregIndex.push(i);\n\t\t});\n\n\t\tpriority -= arr.length + 1;\n\t}\n\n\tif (url.indexOf('#') !== -1)\n\t\tpriority -= 100;\n\n\tif ((isJSON || flags.indexOf('xml') !== -1 || isRaw) && (flags.indexOf('delete') === -1 && flags.indexOf('post') === -1 && flags.indexOf('put') === -1) && flags.indexOf('patch') === -1) {\n\t\tflags.push('post');\n\t\tmethod += (method ? ',' : '') + 'post';\n\t\tpriority++;\n\t}\n\n\tif (flags.indexOf('upload') !== -1) {\n\t\tif (flags.indexOf('post') === -1 && flags.indexOf('put') === -1) {\n\t\t\tflags.push('post');\n\t\t\tmethod += (method ? ',' : '') + 'post';\n\t\t}\n\t}\n\n\tif (flags.indexOf('get') === -1 && flags.indexOf('options') === -1 && flags.indexOf('post') === -1 && flags.indexOf('delete') === -1 && flags.indexOf('put') === -1 && flags.indexOf('upload') === -1 && flags.indexOf('head') === -1 && flags.indexOf('trace') === -1 && flags.indexOf('patch') === -1 && flags.indexOf('propfind') === -1) {\n\t\tflags.push('get');\n\t\tmethod += (method ? ',' : '') + 'get';\n\t}\n\n\tif (CONF.allow_head && flags.indexOf('get') !== -1) {\n\t\tflags.append('head');\n\t\tmethod += (method ? ',' : '') + 'head';\n\t}\n\n\tif (flags.indexOf('referer') !== -1)\n\t\tF._request_check_referer = true;\n\n\tif (!F._request_check_POST && (flags.indexOf('delete') !== -1 || flags.indexOf('post') !== -1 || flags.indexOf('put') !== -1 || flags.indexOf('upload') !== -1 || flags.indexOf('json') !== -1 || flags.indexOf('patch') !== -1 || flags.indexOf('options') !== -1))\n\t\tF._request_check_POST = true;\n\n\tvar isMULTIPLE = false;\n\n\tif (method.indexOf(',') !== -1)\n\t\tisMULTIPLE = true;\n\n\tif (method.indexOf(',') !== -1 || method === '')\n\t\tmethod = undefined;\n\telse\n\t\tmethod = method.toUpperCase();\n\n\tif (name[1] === '#')\n\t\tname = name.substring(1);\n\n\tif (isBINARY && !isRaw) {\n\t\tisBINARY = false;\n\t\tconsole.warn('F.route() skips \"binary\" flag because the \"raw\" flag is not defined.');\n\t}\n\n\tif (workflow && workflow.id) {\n\t\tworkflow.meta = {};\n\t\tif (workflow.id instanceof Array) {\n\t\t\tfor (var i = 0; i < workflow.id.length; i++)\n\t\t\t\tworkflow.meta[workflow.id[i]] = i + 1;\n\t\t} else\n\t\t\tworkflow.meta[workflow.id] = 1;\n\t}\n\n\tif (subdomain)\n\t\tF._length_subdomain_web++;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.hash = hash;\n\tr.search = search.split(' ');\n\tr.id = id;\n\tr.name = name.trim();\n\tr.groups = flags_to_object(groups);\n\tr.priority = priority;\n\tr.sitemap = sitemap ? sitemap.id : '';\n\tr.schema = schema;\n\tr.novalidate = novalidate;\n\tr.workflow = workflow;\n\tr.subdomain = subdomain;\n\tr.description = description;\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.urlraw = urlraw;\n\tr.url = routeURL;\n\tr.param = arr;\n\tr.paramidindex = isDYNAMICSCHEMA ? dynamicidindex : -1;\n\tr.paramnames = params.length ? params : null;\n\tr.flags = flags || EMPTYARRAY;\n\tr.flags2 = flags_to_object(flags);\n\tr.method = method;\n\tr.execute = funcExecute;\n\tr.length = (length || CONF.default_request_maxlength) * 1024;\n\tr.middleware = middleware;\n\tr.timeout = timeout === undefined ? (isDELAY ? 0 : CONF.default_request_timeout) : timeout;\n\tr.isGET = flags.indexOf('get') !== -1;\n\tr.isMULTIPLE = isMULTIPLE;\n\tr.isJSON = isJSON;\n\tr.isXML = flags.indexOf('xml') !== -1;\n\tr.isRAW = isRaw;\n\tr.isBINARY = isBINARY;\n\tr.isMOBILE = isMOBILE;\n\tr.isROBOT = isROBOT;\n\tr.isMOBILE_VARY = isMOBILE;\n\tr.isGENERATOR = isGENERATOR;\n\tr.MEMBER = membertype;\n\tr.isWILDCARD = isWILDCARD;\n\tr.isROLE = isROLE;\n\tr.isREFERER = flags.indexOf('referer') !== -1;\n\tr.isHTTPS = flags.indexOf('https') !== -1;\n\tr.isHTTP = flags.indexOf('http') !== -1;\n\tr.isDEBUG = flags.indexOf('debug') !== -1;\n\tr.isRELEASE = flags.indexOf('release') !== -1;\n\tr.isBOTH = isNOXHR ? false : true;\n\tr.isXHR = flags.indexOf('xhr') !== -1;\n\tr.isUPLOAD = flags.indexOf('upload') !== -1;\n\tr.isSYSTEM = url.startsWith('/#');\n\tr.isCACHE = !url.startsWith('/#') && !CUSTOM && !arr.length && !isWILDCARD;\n\tr.isPARAM = arr.length > 0;\n\tr.isDELAY = isDELAY;\n\tr.isDYNAMICSCHEMA = isDYNAMICSCHEMA;\n\tr.CUSTOM = CUSTOM;\n\tr.options = options;\n\tr.regexp = reg;\n\tr.regexpIndexer = regIndex;\n\tr.type = 'web';\n\tr.remove = remove_route_web;\n\n\tif (r.isUPLOAD)\n\t\tPERF.upload = true;\n\tif (r.isJSON)\n\t\tPERF.json = true;\n\tif (r.isXML)\n\t\tPERF.xml = true;\n\tif (r.isBINARY)\n\t\tPERF.binary = true;\n\tif (r.MEMBER === 1)\n\t\tPERF.auth = true;\n\tif (r.MEMBER === 2)\n\t\tPERF.unauth = true;\n\n\tvar arr = method ? method.split(',') : EMPTYARRAY;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tPERF[arr[i]] = true;\n\t\tPERF[arr[i].toLowerCase()] = true;\n\t}\n\n\tif (r.isSYSTEM)\n\t\tF.routes.system[url.substring(1)] = r;\n\telse {\n\t\tF.routes.web.push(r);\n\n\t\t// Appends cors route\n\t\tisCORS && F.cors(urlcache, corsflags);\n\t\t!_controller && F.$routesSort(1);\n\t}\n\n\tif (isMOBILE)\n\t\tF._request_check_mobile = true;\n\n\tEMIT('route', 'web', instance);\n\treturn instance;\n};\n\nfunction flags_to_object(flags) {\n\tvar obj = {};\n\tflags.forEach(flag => obj[flag] = true);\n\treturn obj;\n}\n\nfunction remove_route_web() {\n\n\tif (this.isSYSTEM) {\n\t\tvar keys = Object.keys(F.routes.system);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (F.routes.system[keys[i]] === this) {\n\t\t\t\tdelete F.routes.system[keys];\n\t\t\t\tF.temporary.other = {};\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar index = F.routes.web.indexOf(this);\n\tif (index !== -1) {\n\t\tF.routes.web.splice(index, 1);\n\t\tF.$routesSort();\n\t\tF.temporary.other = {};\n\t}\n}\n\n/**\n * Get routing by name\n * @param {String} name\n * @return {Object}\n */\nglobal.ROUTING = F.routing = function(name, flags) {\n\n\tvar id = name.substring(0, 3) === 'id:' ? name.substring(3) : null;\n\tif (id)\n\t\tname = null;\n\n\tvar search = id ? null : (name.toLowerCase().replace(/\\s{2,}/g, ' ') + (flags ? (' ' + flags.where(n => typeof(n) === 'string' && n.substring(0, 2) !== '//' && n[2] !== ':').join(' ')).toLowerCase() : '')).split(' ');\n\n\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tvar is = true;\n\t\tif (id && route.id !== id)\n\t\t\tis = false;\n\t\telse if (search) {\n\t\t\tfor (var j = 0; j < search.length; j++) {\n\t\t\t\tif (route.search.indexOf(search[j]) === -1) {\n\t\t\t\t\tis = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!is)\n\t\t\tcontinue;\n\n\t\tvar url = U.path(route.url.join('/'));\n\t\tif (url[0] !== '/')\n\t\t\turl = '/' + url;\n\n\t\treturn route;\n\t}\n};\n\n/**\n * Merge files\n * @param {String} url Relative URL.\n * @param {String/String Array} file1 Filename or URL.\n * @param {String/String Array} file2 Filename or URL.\n * @param {String/String Array} file3 Filename or URL.\n * @param {String/String Array} fileN Filename or URL.\n * @return {Framework}\n */\nglobal.MERGE = F.merge = function(url) {\n\n\tF.temporary.other['merge_' + url] = 1;\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\turl = F.$version(url);\n\n\tif (url === 'auto') {\n\t\t// auto-generating\n\t\tvar arg = arguments;\n\t\tsetTimeout(function(arg) {\n\t\t\tF.merge.apply(F, arg);\n\t\t}, 500, arg);\n\t\treturn F;\n\t}\n\n\turl = framework_internal.preparePath(url);\n\n\tvar arr = [];\n\n\tfor (var i = 1, length = arguments.length; i < length; i++) {\n\n\t\tvar items = arguments[i];\n\t\tif (!(items instanceof Array))\n\t\t\titems = [items];\n\n\t\tfor (var j = 0, lengthsub = items.length; j < lengthsub; j++) {\n\t\t\tvar fn = items[j];\n\t\t\tvar c = fn[0];\n\t\t\tif (c === '@')\n\t\t\t\tfn = '~' + F.path.package(fn.substring(1));\n\t\t\telse if (c === '=')\n\t\t\t\tfn = '~' + F.path.themes(fn.substring(1));\n\t\t\telse if (c === '#')\n\t\t\t\tfn = '~' + F.path.temp('isomorphic_' + fn.substring(1) + '.min.js');\n\t\t\tarr.push(fn);\n\t\t}\n\t}\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar key = createTemporaryKey(url);\n\tvar filename = F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'merged_' + key);\n\tF.routes.merge[url] = { filename: filename.replace(/\\.(js|css)$/g, ext => '.min' + ext), files: arr };\n\tFs.unlink(F.routes.merge[url].filename, NOOP);\n\tF.owners.push({ type: 'merge', owner: _owner, id: url });\n\tdelete F.temporary.notfound[key];\n\treturn F;\n};\n\nF.mapping = function() {\n\treturn F.map.apply(F, arguments);\n};\n\n/**\n * Send message\n * @param  {Object} message\n * @param  {Object} handle\n * @return {Framework}\n */\nF.send = function(message, handle) {\n\tprocess.send(message, handle);\n\treturn F;\n};\n\n/**\n * Mapping of static file\n * @param {String} url\n * @param {String} filename\tFilename or Directory.\n * @param {Function(filename) or String Array} filter\n * @return {Framework}\n */\nglobal.MAP = F.map = function(url, filename, filter) {\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar isPackage = false;\n\n\tfilename = U.$normalize(filename);\n\turl = framework_internal.preparePath(F.$version(url));\n\n\t// isomorphic\n\tif (filename[0] === '#') {\n\t\tF.owners.push({ type: 'mapping', owner: _owner, id: url });\n\t\tF.routes.mapping[url] = F.path.temp('isomorphic_' + filename.substring(1) + '.min.js');\n\t\treturn F;\n\t}\n\n\tvar index = filename.indexOf('#');\n\tvar block;\n\n\tif (index !== -1) {\n\t\tvar tmp = filename.split('#');\n\t\tfilename = tmp[0];\n\t\tblock = tmp[1];\n\t}\n\n\tvar c = filename[0];\n\n\t// package\n\tif (c === '@') {\n\t\tfilename = F.path.package(filename.substring(1));\n\t\tisPackage = true;\n\t} else if (c === '=') {\n\t\tif (F.isWindows)\n\t\t\tfilename = U.combine(CONF.directory_themes, filename.substring(1));\n\t\telse\n\t\t\tfilename = F.path.themes(filename.substring(1));\n\t\tisPackage = true;\n\t}\n\n\tvar isFile = U.getExtension(filename).length > 0;\n\n\t// Checks if the directory exists\n\tif (!isPackage && !filename.startsWith(directory)) {\n\t\tvar tmp = filename[0] === '~' ? F.path.root(filename.substring(1)) : F.path.public(filename);\n\t\tif (existsSync(tmp))\n\t\t\tfilename = tmp;\n\t}\n\n\tif (isFile) {\n\t\tF.routes.mapping[url] = filename;\n\t\tF.owners.push({ type: 'mapping', owner: _owner, id: url });\n\t\tif (block) {\n\t\t\tF.owners.push({ type: 'blocks', owner: _owner, id: url });\n\t\t\tF.routes.blocks[url] = block;\n\t\t}\n\t\treturn F;\n\t}\n\n\turl = U.path(url);\n\tfilename = U.path(filename);\n\n\tvar replace = filename;\n\tvar plus = '';\n\tvar isRoot = false;\n\n\tif (replace[0] === '/')\n\t\tisRoot = true;\n\n\tif (replace[0] === '~') {\n\t\tplus += '~';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (replace[0] === '.') {\n\t\tplus += '.';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (!isRoot && replace[0] === '/') {\n\t\tplus += '/';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (filter instanceof Array) {\n\t\tfor (var i = 0, length = filter.length; i < length; i++) {\n\t\t\tif (filter[i][0] === '.')\n\t\t\t\tfilter[i] = filter[i].substring(1);\n\t\t\tfilter[i] = filter[i].toLowerCase();\n\t\t}\n\t}\n\n\tsetTimeout(function() {\n\t\tU.ls(F.isWindows ? filename.replace(/\\//g, '\\\\') : filename, function(files) {\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\n\t\t\t\tif (F.isWindows)\n\t\t\t\t\tfiles[i] = files[i].replace(filename, '').replace(/\\\\/g, '/');\n\n\t\t\t\tvar file = files[i].replace(replace, '');\n\n\t\t\t\tif (filter) {\n\t\t\t\t\tif (typeof(filter) === 'function') {\n\t\t\t\t\t\tif (!filter(file))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (filter.indexOf(U.getExtension(file)) === -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (file[0] === '/')\n\t\t\t\t\tfile = file.substring(1);\n\n\t\t\t\tvar key = url + file;\n\t\t\t\tF.routes.mapping[key] = plus + files[i];\n\t\t\t\tF.owners.push({ type: 'mapping', owner: _owner, id: key });\n\n\t\t\t\tif (block) {\n\t\t\t\t\tF.owners.push({ type: 'blocks', owner: _owner, id: key });\n\t\t\t\t\tF.routes.blocks[key] = block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}, isPackage ? 500 : 1);\n\n\treturn F;\n};\n\n/**\n * Add a middleware\n * @param {String} name\n * @param {Function(req, res, next, options)} funcExecute\n * @return {Framework}\n */\nglobal.MIDDLEWARE = F.middleware = function(name, funcExecute) {\n\tF.install('middleware', name, funcExecute);\n\t_owner && F.owners.push({ type: 'middleware', owner: _owner, id: name });\n\treturn F;\n};\n\n/**\n * Uses middleware\n * @name {String or String Array} name\n * @url {String} url A url address (optional)\n * @types {String Array} It can be `web`, `file` or `websocket`\n * @first {Boolean} Optional, add a middleware as first\n * @return {Framework}\n */\nF.use = function(name, url, types, first) {\n\n\tif (typeof(name) === 'function') {\n\t\tvar tmp = 'mid' + GUID(5);\n\t\tMIDDLEWARE(tmp, name);\n\t\tname = tmp;\n\t}\n\n\tif (!url && !types) {\n\t\tif (name instanceof Array) {\n\t\t\tfor (var i = 0; i < name.length; i++)\n\t\t\t\tF.routes.request.push(name[i]);\n\t\t} else\n\t\t\tF.routes.request.push(name);\n\t\tF._length_request_middleware = F.routes.request.length;\n\t\treturn F;\n\t}\n\n\tif (url instanceof Array) {\n\t\ttypes = url;\n\t\turl = null;\n\t}\n\n\tif (url === '*')\n\t\turl = null;\n\n\tvar route;\n\n\tif (url)\n\t\turl = framework_internal.routeSplitCreate(framework_internal.preparePath(url.trim())).join('/');\n\n\tif (!types || types.indexOf('web') !== -1) {\n\t\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\t\troute = F.routes.web[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\tif (!types || types.indexOf('file') !== -1 || types.indexOf('files') !== -1) {\n\t\tfor (var i = 0, length = F.routes.files.length; i < length; i++) {\n\t\t\troute = F.routes.files[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\tif (!types || types.indexOf('websocket') !== -1 || types.indexOf('websockets') !== -1) {\n\t\tfor (var i = 0, length = F.routes.websockets.length; i < length; i++) {\n\t\t\troute = F.routes.websockets[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\treturn F;\n};\n\nfunction merge_middleware(a, b, first) {\n\n\tif (typeof(b) === 'string')\n\t\tb = [b];\n\n\tfor (var i = 0, length = b.length; i < length; i++) {\n\t\tvar index = a.indexOf(b[i]);\n\t\tif (index === -1) {\n\t\t\tif (first)\n\t\t\t\ta.unshift(b[i]);\n\t\t\telse\n\t\t\t\ta.push(b[i]);\n\t\t}\n\t}\n\n\treturn a;\n}\n\n/**\n * Add a new websocket route\n * @param {String} url\n * @param {Function()} funcInitialize\n * @param {String Array} flags Optional.\n * @param {String Array} protocols Optional, framework compares this array with request protocol (http or https)\n * @param {String Array} allow Optional, framework compares this array with \"origin\" request header\n * @param {Number} length Optional, maximum message length.\n * @param {String Array} middleware Optional, middlewares.\n * @param {Object} options Optional, additional options for middleware.\n * @return {Framework}\n */\nglobal.WEBSOCKET = F.websocket = function(url, funcInitialize, flags, length) {\n\n\tvar tmp;\n\n\tvar CUSTOM = typeof(url) === 'function' ? url : null;\n\tif (CUSTOM)\n\t\turl = '/';\n\n\tif (url[0] === '#') {\n\n\t\tvar index = url.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\ttmp = url.substring(index);\n\t\t\turl = url.substring(0, index);\n\t\t}\n\n\t\turl = url.substring(1);\n\t\tvar sitemap = F.sitemap(url, true);\n\t\tif (sitemap) {\n\t\t\turl = sitemap.url;\n\t\t\tif (tmp)\n\t\t\t\turl += url[url.length - 1] === '/' ? tmp.substring(1) : tmp;\n\t\t\telse if (sitemap.wildcard)\n\t\t\t\turl += '*';\n\t\t} else\n\t\t\tthrow new Error('Sitemap item \"' + url + '\" not found.');\n\t}\n\n\tif (url === '')\n\t\turl = '/';\n\n\t// Unicode encoding\n\turl = framework_internal.encodeUnicodeURL(url);\n\n\tvar priority = 0;\n\tvar index = url.indexOf(']');\n\tvar subdomain = null;\n\tvar middleware;\n\tvar allow;\n\tvar options;\n\tvar protocols;\n\tvar id;\n\tvar groups = [];\n\n\tpriority = url.count('/');\n\n\tif (index > 0) {\n\t\tsubdomain = url.substring(1, index).trim().toLowerCase().split(',');\n\t\turl = url.substring(index + 1);\n\t\tpriority += subdomain.indexOf('*') !== -1 ? 50 : 100;\n\t}\n\n\tvar isWILDCARD = url.indexOf('*') !== -1;\n\tif (isWILDCARD) {\n\t\turl = url.replace('*', '').replace('//', '/');\n\t\tpriority = (-10) - priority;\n\t}\n\n\tvar url2 = framework_internal.preparePath(url.trim());\n\tvar routeURL = framework_internal.routeSplitCreate(url2);\n\tvar arr = [];\n\tvar reg = null;\n\tvar regIndex = null;\n\tvar hash = url2.hash();\n\tvar urlraw = U.path(url2) + (isWILDCARD ? '*' : '');\n\tvar params = [];\n\n\tif (url.indexOf('{') !== -1) {\n\t\trouteURL.forEach(function(o, i) {\n\n\t\t\tif (o.substring(0, 1) !== '{')\n\t\t\t\treturn;\n\n\t\t\tarr.push(i);\n\n\t\t\tvar sub = o.substring(1, o.length - 1);\n\t\t\tvar name = o.substring(1, o.length - 1).trim();\n\n\t\t\tparams.push(name);\n\n\t\t\tif (sub[0] !== '/')\n\t\t\t\treturn;\n\n\t\t\tvar index = sub.lastIndexOf('/');\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = {};\n\t\t\t\tregIndex = [];\n\t\t\t}\n\n\t\t\tparams[params.length - 1] = 'regexp' + (regIndex.length + 1);\n\t\t\treg[i] = new RegExp(sub.substring(1, index), sub.substring(index + 1));\n\t\t\tregIndex.push(i);\n\t\t});\n\t}\n\n\tif (typeof(allow) === 'string')\n\t\tallow = allow[allow];\n\n\tif (typeof(protocols) === 'string')\n\t\tprotocols = protocols[protocols];\n\n\ttmp = [];\n\n\tvar isJSON = false;\n\tvar isBINARY = false;\n\tvar isROLE = false;\n\tvar count = 0;\n\tvar membertype = 0;\n\n\t!flags && (flags = []);\n\t_flags && _flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\n\tfor (var i = 0; i < flags.length; i++) {\n\n\t\tvar flag = flags[i];\n\t\tvar type = typeof(flag);\n\n\t\t// Middleware options\n\t\tif (type === 'object') {\n\t\t\toptions = flag;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Length\n\t\tif (type === 'number') {\n\t\t\tlength = flag;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flag.substring(0, 3) === 'id:') {\n\t\t\tid = flag.substring(3).trim();\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Groups\n\t\tif (flag[0] === '&') {\n\t\t\tgroups.push(flag.substring(1).trim());\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Middleware\n\t\tif (flag[0] === '#') {\n\t\t\t!middleware && (middleware = []);\n\t\t\tmiddleware.push(flag.substring(1).trim());\n\t\t\tcontinue;\n\t\t}\n\n\t\tflag = flag.toString().toLowerCase();\n\n\t\t// Origin\n\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t!allow && (allow = []);\n\t\t\tallow.push(flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (flag === 'json')\n\t\t\tisJSON = true;\n\n\t\tif (flag === 'binary')\n\t\t\tisBINARY = true;\n\n\t\tif (flag === 'raw') {\n\t\t\tisBINARY = false;\n\t\t\tisJSON = false;\n\t\t}\n\n\t\tif (flag[0] === '@') {\n\t\t\tisROLE = true;\n\t\t\ttmp.push(flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flag === 'json' || flag === 'binary' || flag === 'raw')\n\t\t\tcontinue;\n\n\t\tswitch (flag) {\n\t\t\tcase 'authorize':\n\t\t\tcase 'authorized':\n\t\t\tcase 'logged':\n\t\t\t\tmembertype = 1;\n\t\t\t\tpriority++;\n\t\t\t\ttmp.push('authorize');\n\t\t\t\tbreak;\n\t\t\tcase 'unauthorize':\n\t\t\tcase 'unauthorized':\n\t\t\tcase 'unlogged':\n\t\t\t\tmembertype = 2;\n\t\t\t\tpriority++;\n\t\t\t\ttmp.push('unauthorize');\n\t\t\t\tbreak;\n\t\t\tcase 'get':\n\t\t\tcase 'http':\n\t\t\tcase 'https':\n\t\t\tcase 'debug':\n\t\t\tcase 'release':\n\t\t\t\ttmp.push(flag);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t!protocols && (protocols = []);\n\t\t\t\tprotocols.push(flag);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isROLE && !membertype) {\n\t\ttmp.push('authorize');\n\t\tmembertype = 1;\n\t\tpriority++;\n\t\tcount++;\n\t}\n\n\tflags = tmp;\n\n\tflags.indexOf('get') === -1 && flags.unshift('get');\n\tpriority += (count * 2);\n\n\tif (subdomain)\n\t\tF._length_subdomain_websocket++;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.id = id;\n\tr.urlraw = urlraw;\n\tr.hash = hash;\n\tr.groups = flags_to_object(groups);\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.url = routeURL;\n\tr.paramnames = params.length ? params : null;\n\tr.param = arr;\n\tr.subdomain = subdomain;\n\tr.priority = priority;\n\tr.flags = flags || EMPTYARRAY;\n\tr.flags2 = flags_to_object(flags);\n\tr.onInitialize = funcInitialize;\n\tr.protocols = protocols || EMPTYARRAY;\n\tr.allow = allow || [];\n\tr.length = (length || CONF.default_websocket_maxlength) * 1024;\n\tr.isWEBSOCKET = true;\n\tr.MEMBER = membertype;\n\tr.isJSON = isJSON;\n\tr.isBINARY = isBINARY;\n\tr.isROLE = isROLE;\n\tr.isWILDCARD = isWILDCARD;\n\tr.isHTTPS = flags.indexOf('https');\n\tr.isHTTP = flags.indexOf('http');\n\tr.isDEBUG = flags.indexOf('debug');\n\tr.isRELEASE = flags.indexOf('release');\n\tr.CUSTOM = CUSTOM;\n\tr.middleware = middleware ? middleware : null;\n\tr.options = options;\n\tr.isPARAM = arr.length > 0;\n\tr.regexp = reg;\n\tr.regexpIndexer = regIndex;\n\tr.type = 'websocket';\n\tF.routes.websockets.push(r);\n\tF.initwebsocket && F.initwebsocket();\n\tEMIT('route', 'websocket', r);\n\t!_controller && F.$routesSort(2);\n\treturn instance;\n};\n\nF.initwebsocket = function() {\n\tif (F.routes.websockets.length && CONF.allow_websocket && F.server) {\n\t\tF.server.on('upgrade', F.$upgrade);\n\t\tF.initwebsocket = null;\n\t}\n};\n\n/**\n * Create a file route\n * @param {String} name\n * @param {Function} funcValidation\n * @param {Function} fnExecute\n * @param {String Array} middleware\n * @return {Framework}\n */\nglobal.FILE = F.file = function(fnValidation, fnExecute, flags) {\n\n\tvar a;\n\n\tif (fnValidation instanceof Array) {\n\t\ta = fnExecute;\n\t\tvar b = flags;\n\t\tflags = fnValidation;\n\t\tfnValidation = a;\n\t\tfnExecute = b;\n\t} else if (fnExecute instanceof Array) {\n\t\ta = fnExecute;\n\t\tfnExecute = flags;\n\t\tflags = a;\n\t}\n\n\tif (!fnExecute && fnValidation) {\n\t\tfnExecute = fnValidation;\n\t\tfnValidation = undefined;\n\t}\n\n\tvar extensions;\n\tvar middleware;\n\tvar options;\n\tvar url;\n\tvar wildcard = false;\n\tvar fixedfile = false;\n\tvar id = null;\n\tvar urlraw = fnValidation;\n\tvar groups = [];\n\n\tif (_flags) {\n\t\t!flags && (flags = []);\n\t\t_flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\t}\n\n\tif (flags) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tif (typeof(flag) === 'object')\n\t\t\t\toptions = flag;\n\t\t\telse if (flag[0] === '&')\n\t\t\t\tgroups.push(flag.substring(1).trim());\n\t\t\telse if (flag[0] === '#') {\n\t\t\t\t!middleware && (middleware = []);\n\t\t\t\tmiddleware.push(flag.substring(1).trim());\n\t\t\t} else if (flag[0] === '.') {\n\t\t\t\tflag = flag.substring(1).toLowerCase().trim();\n\t\t\t\t!extensions && (extensions = {});\n\t\t\t\textensions[flag] = true;\n\t\t\t} else if (flag.substring(0, 3) === 'id:')\n\t\t\t\tid = flag.substring(3).trim();\n\t\t}\n\t}\n\n\tif (typeof(fnValidation) === 'string') {\n\n\t\tif (fnValidation === '/')\n\t\t\tfnValidation = '';\n\n\t\turl = fnValidation ? framework_internal.routeSplitCreate(fnValidation) : EMPTYARRAY;\n\t\tfnValidation = undefined;\n\t\ta = url.last();\n\t\tif (a === '*.*') {\n\t\t\twildcard = true;\n\t\t\turl.splice(url.length - 1, 1);\n\t\t} else if (a) {\n\t\t\tvar index = a.indexOf('*.');\n\t\t\tif (index !== -1) {\n\t\t\t\textensions = {};\n\t\t\t\textensions[a.substring(index + 2).trim()] = true;\n\t\t\t\twildcard = false;\n\t\t\t\turl.splice(url.length - 1, 1);\n\t\t\t} else if (a === '*') {\n\t\t\t\twildcard = true;\n\t\t\t\turl.splice(url.length - 1, 1);\n\t\t\t} else if (U.getExtension(a)) {\n\t\t\t\tfixedfile = true;\n\t\t\t\twildcard = false;\n\t\t\t}\n\t\t}\n\t} else if (!extensions && !fnValidation)\n\t\tfnValidation = fnExecute;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.id = id;\n\tr.urlraw = urlraw;\n\tr.groups = flags_to_object(groups);\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.url = url;\n\tr.fixedfile = fixedfile;\n\tr.wildcard = wildcard;\n\tr.extensions = extensions;\n\tr.onValidate = fnValidation;\n\tr.execute = fnExecute;\n\tr.middleware = middleware;\n\tr.options = options;\n\tr.type = 'file';\n\n\tF.routes.files.push(r);\n\tF.routes.files.sort((a, b) => !a.url ? -1 : !b.url ? 1 : a.url.length > b.url.length ? -1 : 1);\n\tEMIT('route', 'file', r);\n\tF._length_files++;\n\treturn F;\n};\n\nfunction sitemapurl(url) {\n\n\tvar index = url.indexOf('/');\n\tvar tmp;\n\n\tif (index !== -1) {\n\t\ttmp = url.substring(index);\n\t\turl = url.substring(0, index);\n\t}\n\n\tvar sitemap = F.sitemap(url, true, '');\n\tif (sitemap) {\n\t\turl = sitemap.url;\n\t\tif (tmp) {\n\t\t\tif (url[url.length - 1] === '/')\n\t\t\t\turl += tmp.substring(1);\n\t\t\telse\n\t\t\t\turl += tmp;\n\t\t}\n\t}\n\n\treturn url;\n}\n\nglobal.LOCALIZE = F.localize = function(url, flags, minify) {\n\n\tif (typeof(url) === 'function') {\n\t\tF.onLocale = url;\n\t\treturn;\n\t}\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\turl = url.replace('*.*', '');\n\n\tif (minify == null)\n\t\tminify = true;\n\n\tif (flags === true) {\n\t\tflags = [];\n\t\tminify = true;\n\t} else if (!flags)\n\t\tflags = [];\n\n\tvar index;\n\tvar ext = false;\n\n\tflags = flags.remove(function(item) {\n\t\titem = item.toLowerCase();\n\t\tif (item === 'nocompress')\n\t\t\tminify = false;\n\t\tif (item[0] === '.')\n\t\t\text = true;\n\t\treturn item === 'compress' || item === 'nocompress' || item === 'minify';\n\t});\n\n\tvar index = url.lastIndexOf('.');\n\n\tif (!ext) {\n\t\tif (index === -1)\n\t\t\tflags.push('.html', '.htm', '.md', '.txt');\n\t\telse {\n\t\t\tflags.push(url.substring(index).toLowerCase());\n\t\t\turl = url.substring(0, index).replace('*', '');\n\t\t}\n\t}\n\n\turl = framework_internal.preparePath(url.replace('.*', ''));\n\n\tF.file(url, function(req, res) {\n\n\t\tF.onLocale && (req.$language = F.onLocale(req, res, req.isStaticFile));\n\n\t\tvar key = 'locate_' + (req.$language ? req.$language : 'default') + '_' + req.url;\n\t\tvar output = F.temporary.other[key];\n\n\t\tif (output) {\n\t\t\tif (!F.$notModified(req, res, output.$mtime)) {\n\t\t\t\tHEADERS.responseLocalize['Last-Modified'] = output.$mtime;\n\t\t\t\tres.options.body = output;\n\t\t\t\tres.options.type = U.getContentType(req.extension);\n\t\t\t\tres.$text();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar name = req.uri.pathname;\n\t\tvar filename = F.onMapping(name, name, true, true);\n\n\t\tFs.readFile(filename, function(err, content) {\n\n\t\t\tif (err)\n\t\t\t\treturn res.throw404();\n\n\t\t\tcontent = framework_internal.markup(F.translator(req.$language, framework_internal.modificators(content.toString(ENCODING), filename, 'static')));\n\n\t\t\tFs.lstat(filename, function(err, stats) {\n\n\t\t\t\tvar mtime = stats.mtime.toUTCString();\n\n\t\t\t\tif (minify && (req.extension === 'html' || req.extension === 'htm'))\n\t\t\t\t\tcontent = framework_internal.compile_html(content, filename);\n\n\t\t\t\tif (RELEASE) {\n\t\t\t\t\tF.temporary.other[key] = U.createBuffer(content);\n\t\t\t\t\tF.temporary.other[key].$mtime = mtime;\n\t\t\t\t\tif (F.$notModified(req, res, mtime))\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tHEADERS.responseLocalize['Last-Modified'] = mtime;\n\t\t\t\tres.options.body = content;\n\t\t\t\tres.options.type = U.getContentType(req.extension);\n\t\t\t\tres.options.headers = HEADERS.responseLocalize;\n\t\t\t\tres.$text();\n\t\t\t});\n\t\t});\n\n\t}, flags);\n};\n\nF.$notModified = function(req, res, date) {\n\tif (date === req.headers['if-modified-since']) {\n\t\tHEADERS.responseNotModified['Last-Modified'] = date;\n\t\tres.success = true;\n\t\tres.writeHead(304, HEADERS.responseNotModified);\n\t\tres.end();\n\t\tF.stats.response.notModified++;\n\t\tF.reqstats(false, req.isStaticFile);\n\t\treturn true;\n\t}\n};\n\n/**\n * Error caller\n * @param {Error} err\n * @param {String} name Controller or Script name.\n * @param {Object} uri\n * @return {Framework}\n */\nF.error = function(err, name, uri) {\n\n\tif (!arguments.length)\n\t\treturn F.errorcallback;\n\n\tif (!err)\n\t\treturn F;\n\n\tif (F.errors) {\n\t\tNOW = new Date();\n\t\tF.errors.push({ error: err.stack, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, date: NOW });\n\t\tF.errors.length > 50 && F.errors.shift();\n\t}\n\n\tF.onError(err, name, uri);\n\treturn F;\n};\n\nF.errorcallback = function(err) {\n\terr && F.error(err);\n};\n\n/**\n * Registers a new problem\n * @param {String} message\n * @param {String} name A controller name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.problem = F.wtf = function(message, name, uri, ip) {\n\tF.$events.problem && EMIT('problem', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip };\n\tF.logger('problems', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.problems) {\n\t\tF.problems.push(obj);\n\t\tF.problems.length > 50 && F.problems.shift();\n\t}\n\n\treturn F;\n};\n\nglobal.PRINTLN = function(msg) {\n\tconsole.log('------>', '[' + new Date().format('yyyy-MM-dd HH:mm:ss') + ']', msg);\n};\n\n/**\n * Registers a new change\n * @param {String} message\n * @param {String} name A source name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.change = function(message, name, uri, ip) {\n\tF.$events.change && EMIT('change', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip };\n\tF.logger('changes', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.changes) {\n\t\tF.changes.push(obj);\n\t\tF.changes.length > 50 && F.changes.shift();\n\t}\n\n\treturn F;\n};\n\n/**\n * Trace\n * @param {String} message\n * @param {String} name A controller name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.trace = function(message, name, uri, ip) {\n\n\tif (!CONF.trace)\n\t\treturn F;\n\n\tF.$events.trace && EMIT('trace', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tNOW = new Date();\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip, date: NOW };\n\tF.logger('traces', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tCONF.trace_console && console.log(NOW.format('yyyy-MM-dd HH:mm:ss'), '[trace]', message, '|', 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.traces) {\n\t\tF.traces.push(obj);\n\t\tF.traces.length > 50 && F.traces.shift();\n\t}\n\n\treturn F;\n};\n\n/**\n * Get a module\n * @param {String} name\n * @return {Object}\n */\nglobal.MODULE = F.module = function(name) {\n\treturn F.modules[name] || null;\n};\n\n/**\n * Add a new modificator\n * @param {Function(type, filename, content)} fn The `fn` must return modified value.\n * @return {Framework}\n */\nF.modify = function(fn) {\n\tOBSOLETE('F.modify()', 'This method will be removed in new versions.');\n\tif (!F.modificators)\n\t\tF.modificators = [];\n\tF.modificators.push(fn);\n\tfn.$owner = _owner;\n\treturn F;\n};\n\nF.$bundle = function(callback) {\n\n\tvar bundledir = F.path.root(CONF.directory_bundles);\n\n\tvar makebundle = function() {\n\n\t\tvar arr = Fs.readdirSync(bundledir);\n\t\tvar url = [];\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i].endsWith('.url'))\n\t\t\t\turl.push(arr[i]);\n\t\t}\n\n\t\turl.wait(function(item, next) {\n\n\t\t\tvar filename = F.path.root(CONF.directory_bundles) + item.replace('.url', '.bundle');\n\t\t\tvar link = Fs.readFileSync(F.path.root(CONF.directory_bundles) + item).toString('utf8');\n\n\t\t\tF.consoledebug('Download bundle: ' + link);\n\n\t\t\tU.download(link, FLAGS_INSTALL, function(err, response) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'Bundle: ' + link);\n\t\t\t\t\tnext();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar stream = Fs.createWriteStream(filename);\n\n\t\t\t\tresponse.pipe(stream);\n\t\t\t\tresponse.on('error', function(err) {\n\t\t\t\t\tF.error(err, 'Bundle: ' + link);\n\t\t\t\t\tnext();\n\t\t\t\t});\n\n\t\t\t\tCLEANUP(stream, next);\n\t\t\t});\n\n\t\t}, function() {\n\t\t\trequire('./bundles').make(function() {\n\t\t\t\tF.directory = HEADERS.workers.cwd = directory = F.path.root(CONF.directory_src);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t});\n\t};\n\n\ttry {\n\t\tFs.statSync(bundledir);\n\t\tif (F.$bundling) {\n\t\t\tmakebundle();\n\t\t\treturn;\n\t\t} else\n\t\t\tF.directory = HEADERS.workers.cwd = directory = F.path.root(CONF.directory_src);\n\t} catch(e) {}\n\tcallback();\n};\n\nF.$load = function(types, targetdirectory, callback, packageName) {\n\n\tvar arr = [];\n\tvar dir = '';\n\n\tif (!targetdirectory)\n\t\ttargetdirectory = directory;\n\n\ttargetdirectory = '~' + targetdirectory;\n\n\tfunction listing(directory, level, output, extension, isTheme) {\n\n\t\tif (!existsSync(dir))\n\t\t\treturn;\n\n\t\tif (!extension)\n\t\t\textension = '.js';\n\n\t\tFs.readdirSync(directory).forEach(function(o) {\n\t\t\tvar isDirectory = Fs.statSync(Path.join(directory, o)).isDirectory();\n\n\t\t\tif (isDirectory && isTheme) {\n\t\t\t\toutput.push({ name: o });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isDirectory) {\n\n\t\t\t\tif (extension === '.package' && o.endsWith(extension)) {\n\t\t\t\t\tvar name = o.substring(0, o.length - extension.length);\n\t\t\t\t\toutput.push({ name: name[0] === '/' ? name.substring(1) : name, filename: Path.join(dir, o), is: true });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlevel++;\n\t\t\t\tlisting(Path.join(directory, o), level, output, extension);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar ext = U.getExtension(o);\n\t\t\tif (ext)\n\t\t\t\text = '.' + ext;\n\t\t\tif (ext !== extension || o[0] === '.' || o.endsWith('-bk' + extension))\n\t\t\t\treturn;\n\n\t\t\tvar name = (level ? U.$normalize(directory).replace(dir, '') + '/' : '') + o.substring(0, o.length - ext.length);\n\t\t\toutput.push({ name: name[0] === '/' ? name.substring(1) : name, filename: Path.join(dir, name) + extension });\n\t\t});\n\t}\n\n\ttry {\n\t\t// Reads name of resources\n\t\tF.temporary.internal.resources = Fs.readdirSync(F.path.resources()).map(n => n.substring(0, n.lastIndexOf('.')));\n\t} catch (e) {\n\t\tF.temporary.internal.resources = [];\n\t}\n\n\tvar dependencies = [];\n\tvar operations = [];\n\tvar isPackage = targetdirectory.indexOf('.package') !== -1;\n\n\tif (!types || types.indexOf('modules') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/modules/' : CONF.directory_modules);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.js');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('module', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('isomorphic') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/isomorphic/' : CONF.directory_isomorphic);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.js');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('isomorphic', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('packages') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/packages/' : CONF.directory_packages);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.package');\n\t\t\tvar dirtmp = U.$normalize(dir);\n\n\t\t\tarr.wait(function(item, next2) {\n\n\t\t\t\tif (!item.is) {\n\t\t\t\t\tdependencies.push(next => F.install('package', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t\t\treturn next2();\n\t\t\t\t}\n\n\t\t\t\tU.ls(item.filename, function(files, directories) {\n\t\t\t\t\tvar dir = F.path.temp(item.name) + '.package';\n\t\t\t\t\t!existsSync(dir) && Fs.mkdirSync(dir);\n\n\t\t\t\t\tfor (var i = 0, length = directories.length; i < length; i++) {\n\t\t\t\t\t\tvar target = F.path.temp(U.$normalize(directories[i]).replace(dirtmp, '') + '/');\n\t\t\t\t\t\t!existsSync(target) && Fs.mkdirSync(target);\n\t\t\t\t\t}\n\n\t\t\t\t\tfiles.wait(function(filename, next) {\n\n\t\t\t\t\t\tif (F.$bundling) {\n\t\t\t\t\t\t\tvar stream = Fs.createReadStream(filename);\n\t\t\t\t\t\t\tvar writer = Fs.createWriteStream(Path.join(dir, filename.replace(item.filename, '').replace(/\\.package$/i, '')));\n\t\t\t\t\t\t\tstream.pipe(writer);\n\t\t\t\t\t\t\twriter.on('finish', next);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tnext();\n\n\t\t\t\t\t}, function() {\n\n\t\t\t\t\t\t// Windows sometimes doesn't load package and this delay solves the problem.\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tdependencies.push(next => F.install('package2', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t\t\t\t\tnext2();\n\t\t\t\t\t\t}, 50);\n\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, resume);\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('models') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/models/' : CONF.directory_models);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('model', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('schemas') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/schemas/' : CONF.directory_schemas);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('schema', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('operations') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/operations/' : CONF.directory_operations);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('operation', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('themes') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/themes/' : CONF.directory_themes);\n\t\t\tlisting(dir, 0, arr, undefined, true);\n\t\t\tarr.forEach(function(item) {\n\t\t\t\tvar themeName = item.name;\n\t\t\t\tvar themeDirectory = Path.join(dir, themeName);\n\t\t\t\tvar filename = Path.join(themeDirectory, 'index.js');\n\t\t\t\tF.themes[item.name] = U.path(themeDirectory);\n\t\t\t\tF._length_themes++;\n\t\t\t\texistsSync(filename) && dependencies.push(next => F.install('theme', item.name, filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t});\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('definitions') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/definitions/' : CONF.directory_definitions);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('definition', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('controllers') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/controllers/' : CONF.directory_controllers);\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('controller', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (!types || types.indexOf('components') !== -1) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/components/' : CONF.directory_components);\n\t\t\tlisting(dir, 0, arr, '.html');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('component', item.name, item.filename, undefined, undefined, undefined, undefined, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\toperations.async(function() {\n\t\tvar count = dependencies.length;\n\t\tF.consoledebug('load dependencies ' + count + 'x');\n\t\tdependencies.async(function() {\n\t\t\ttypes && types.indexOf('service') === -1 && F.cache.stop();\n\t\t\tF.$routesSort();\n\t\t\t(!types || types.indexOf('dependencies') !== -1) && F.$configure_dependencies();\n\t\t\tF.consoledebug('load dependencies {0}x (done)'.format(count));\n\t\t\tcallback && callback();\n\t\t});\n\t});\n\n\treturn F;\n};\n\nF.$startup = function(callback) {\n\n\tvar dir = Path.join(directory, '/startup/');\n\n\tif (!existsSync(dir))\n\t\treturn callback();\n\n\tvar run = [];\n\n\tFs.readdirSync(dir).forEach(function(o) {\n\t\tvar extension = U.getExtension(o);\n\t\tif (extension === 'js')\n\t\t\trun.push(o);\n\t});\n\n\tif (!run.length)\n\t\treturn callback();\n\n\trun.wait(function(filename, next) {\n\t\tvar fn = dir + filename + new Date().format('yyMMdd_HHmmss');\n\t\tFs.renameSync(dir + filename, fn);\n\t\tvar fork = Child.fork(fn, [], { cwd: directory });\n\t\tfork.on('exit', function() {\n\t\t\tfork = null;\n\t\t\tnext();\n\t\t});\n\t}, callback);\n\n\treturn F;\n};\n\nF.uptodate = function(type, url, options, interval, callback, next) {\n\n\tif (typeof(options) === 'string' && typeof(interval) !== 'string') {\n\t\tinterval = options;\n\t\toptions = null;\n\t}\n\n\tvar obj = { type: type, name: '', url: url, interval: interval, options: options, count: 0, updated: NOW, errors: [], callback: callback };\n\n\tif (!F.uptodates)\n\t\tF.uptodates = [];\n\n\tF.uptodates.push(obj);\n\tF.install(type, url, options, function(err, name) {\n\t\terr && obj.errors.push(err);\n\t\tobj.name = name;\n\t\tobj.callback && obj.callback(err, name);\n\t}, undefined, undefined, undefined, undefined, next);\n\treturn F;\n};\n\n/**\n * Install type with its declaration\n * @param {String} type Available types: model, module, controller, source.\n * @param {String} name Default name (optional).\n * @param {String or Function} declaration\n * @param {Object} options Custom options, optional.\n * @param {Object} internal Internal/Temporary options, optional.\n * @param {Boolean} useRequired Internal, optional.\n * @param {Boolean} skipEmit Internal, optional.\n * @param {String} uptodateName Internal, optional.\n * @param {Function} next Internal, optional.\n * @param {String} packageName Internal, optional.\n * @return {Framework}\n */\nF.install = function(type, name, declaration, options, callback, internal, useRequired, skipEmit, uptodateName, next, packageName) {\n\n\tvar obj = null;\n\n\tif (type !== 'config' && type !== 'version' && typeof(name) === 'string') {\n\t\tif (name.startsWith('http://') || name.startsWith('https://')) {\n\t\t\tif (typeof(declaration) === 'object') {\n\t\t\t\tcallback = options;\n\t\t\t\toptions = declaration;\n\t\t\t\tdeclaration = name;\n\t\t\t\tname = '';\n\t\t\t}\n\t\t} else if (name[0] === '@') {\n\t\t\tdeclaration = F.path.package(name.substring(1));\n\t\t\tname = Path.basename(name).replace(/\\.js$/i, '');\n\t\t\tif (useRequired === undefined)\n\t\t\t\tuseRequired = true;\n\t\t}\n\t}\n\n\tvar t = typeof(declaration);\n\tvar key = '';\n\tvar tmp;\n\tvar content;\n\tvar err;\n\n\tNOW = new Date();\n\n\tif (t === 'object') {\n\t\tt = typeof(options);\n\t\tif (t === 'function')\n\t\t\tcallback = options;\n\t\toptions = declaration;\n\t\tdeclaration = undefined;\n\t}\n\n\tif (declaration === undefined) {\n\t\tdeclaration = name;\n\t\tname = '';\n\t}\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\t// Check if declaration is a valid URL address\n\tif (type !== 'eval' && typeof(declaration) === 'string') {\n\n\t\tif (declaration.startsWith('http://') || declaration.startsWith('https://')) {\n\t\t\tif (type === 'package') {\n\t\t\t\tF.consoledebug('download', type, declaration);\n\t\t\t\tU.download(declaration, FLAGS_INSTALL, function(err, response) {\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tF.error(err, 'F.install(\\'{0}\\', \\'{1}\\')'.format(type, declaration), null);\n\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\tcallback && callback(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar id = Path.basename(declaration, '.package');\n\t\t\t\t\tvar filename = F.path.temp(id + '.download');\n\t\t\t\t\tvar stream = Fs.createWriteStream(filename);\n\t\t\t\t\tvar md5 = Crypto.createHash('md5');\n\n\t\t\t\t\tresponse.on('data', (buffer) => md5.update(buffer));\n\t\t\t\t\tresponse.pipe(stream);\n\n\t\t\t\t\tstream.on('finish', function() {\n\t\t\t\t\t\tvar hash = md5.digest('hex');\n\n\t\t\t\t\t\tif (F.temporary.versions[declaration] === hash) {\n\t\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\t\tcallback && callback(null, uptodateName || name, true);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tF.temporary.versions[declaration] = hash;\n\t\t\t\t\t\tF.install(type, id, filename, options, callback, undefined, undefined, true, uptodateName, next);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn F;\n\t\t\t}\n\n\t\t\tF.consoledebug('download', type, declaration);\n\t\t\tU.request(declaration, FLAGS_INSTALL, function(err, data, code) {\n\n\t\t\t\tif (code !== 200 && !err)\n\t\t\t\t\terr = new Error(data);\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'F.install(\\'{0}\\', \\'{1}\\')'.format(type, declaration), null);\n\t\t\t\t\tnext && next();\n\t\t\t\t\tcallback && callback(err);\n\t\t\t\t} else {\n\n\t\t\t\t\tvar hash = data.hash('md5');\n\n\t\t\t\t\tif (F.temporary.versions[declaration] === hash) {\n\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\tcallback && callback(null, uptodateName || name, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tF.temporary.versions[declaration] = hash;\n\t\t\t\t\tF.install(type, name, data, options, callback, declaration, undefined, undefined, uptodateName, next);\n\t\t\t\t}\n\n\t\t\t});\n\t\t\treturn F;\n\t\t} else {\n\t\t\tif (declaration[0] === '~')\n\t\t\t\tdeclaration = declaration.substring(1);\n\t\t\tif (type !== 'config' && type !== 'resource' && type !== 'package' && type !== 'component' && !REG_SCRIPTCONTENT.test(declaration)) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tif (!existsSync(declaration))\n\t\t\t\t\tthrow new Error('The ' + type + ': ' + declaration + ' doesn\\'t exist.');\n\t\t\t\tuseRequired = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type === 'middleware') {\n\n\t\tF.routes.middleware[name] = typeof(declaration) === 'function' ? declaration : eval(declaration);\n\t\tF._length_middleware = Object.keys(F.routes.middleware).length;\n\n\t\tif (REG_NEWIMPL.test(F.routes.middleware[name].toString()))\n\t\t\tF.routes.middleware[name].$newversion = true;\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tkey = type + '.' + name;\n\n\t\tif (F.dependencies[key]) {\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t} else {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0 };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].count++;\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'config' || type === 'configuration' || type === 'settings') {\n\t\tF.$configure_configs(declaration instanceof Array ? declaration : declaration.toString().split('\\n'), true);\n\t\tsetTimeout(function() {\n\t\t\tdelete F.temporary.mail_settings;\n\t\t\tEMIT(type + '#' + name, CONF);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'version' || type === 'versions') {\n\n\t\tF.$configure_versions(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'workflow' || type === 'workflows') {\n\n\t\tF.$configure_workflows(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t\tF.consoledebug('install', type + '#' + name);\n\t\t}, 500);\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'sitemap') {\n\n\t\tF.$configure_sitemap(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t\tF.consoledebug('install', type + '#' + name);\n\t\t}, 500);\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'component') {\n\n\t\tif (!name && internal)\n\t\t\tname = U.getName(internal).replace(/\\.html/gi, '').trim();\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined);\n\n\t\tvar hash = '\\n/*' + name.crc32(true) + '*/\\n';\n\t\tvar temporary = (F.id ? 'i-' + F.id + '_' : '') + 'components';\n\n\t\tcontent = parseComponent(internal ? declaration : Fs.readFileSync(declaration).toString(ENCODING), name);\n\n\t\tif (F.$bundling) {\n\t\t\tcontent.js && Fs.appendFileSync(F.path.temp(temporary + '.js'), hash + (DEBUG ? component_debug(name, content.js, 'js') : content.js) + hash.substring(0, hash.length - 1));\n\t\t\tcontent.css && Fs.appendFileSync(F.path.temp(temporary + '.css'), hash + (DEBUG ? component_debug(name, content.css, 'css') : content.css) + hash.substring(0, hash.length - 1));\n\t\t}\n\n\t\tif (content.js)\n\t\t\tF.components.js = true;\n\n\t\tif (content.css)\n\t\t\tF.components.css = true;\n\n\t\tif (content.files)\n\t\t\tF.components.files[name] = content.files;\n\t\telse\n\t\t\tdelete F.components.files[name];\n\n\t\tif (content.body) {\n\t\t\tF.components.views[name] = '.' + F.path.temp('component_' + name);\n\t\t\tF.$bundling && Fs.writeFile(F.components.views[name].substring(1) + '.html', U.minifyHTML(content.body), NOOP);\n\t\t} else\n\t\t\tdelete F.components.views[name];\n\n\t\tF.components.has = true;\n\n\t\tvar link = CONF.static_url_components;\n\t\tF.components.version = NOW.getTime();\n\t\tF.components.links = (F.components.js ? '<script src=\"{0}js?version={1}\"></script>'.format(link, F.components.version) : '') + (F.components.css ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"{0}css?version={1}\" />'.format(link, F.components.version) : '');\n\n\t\tif (content.install) {\n\t\t\ttry {\n\t\t\t\tvar filecomponent = F.path.temp('component-' + name + '.js');\n\t\t\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\t\t\tFs.writeFileSync(filecomponent, content.install.trim());\n\t\t\t\tobj = require(filecomponent);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filecomponent));\n\t\t\t\tobj.$owner = _owner;\n\t\t\t\tF.temporary.owners[_owner] = true;\n\t\t\t\t_controller = '';\n\t\t\t\tobj.name = name;\n\t\t\t\tF.components.instances[name] = obj;\n\t\t\t\tobj && typeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\t\t\t} catch(e) {\n\t\t\t\tF.error(e, 'F.install(\\'component\\', \\'{0}\\')'.format(name));\n\t\t\t}\n\t\t} else if (!internal) {\n\t\t\tvar js = declaration.replace(/\\.html$/i, '.js');\n\t\t\tif (existsSync(js)) {\n\t\t\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\t\t\tF.temporary.owners[_owner] = true;\n\t\t\t\tobj = require(js);\n\t\t\t\tobj.name = name;\n\t\t\t\tobj.$owner = _owner;\n\t\t\t\t_controller = '';\n\t\t\t\tF.components.instances[name] = obj;\n\t\t\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t}\n\n\t\tif (obj) {\n\n\t\t\tif (!obj.group)\n\t\t\t\tobj.group = 'default';\n\n\t\t\tkey = obj.group.crc32(true);\n\t\t\ttemporary += '_g' + key;\n\t\t\ttmp = F.components.groups[obj.group];\n\t\t\tif (!tmp)\n\t\t\t\ttmp = F.components.groups[obj.group] = {};\n\n\t\t\tif (content.js) {\n\t\t\t\tFs.appendFileSync(F.path.temp(temporary + '.js'), hash + (DEBUG ? component_debug(name, content.js, 'js') : content.js) + hash.substring(0, hash.length - 1));\n\t\t\t\ttmp.js = true;\n\t\t\t}\n\n\t\t\tif (content.css) {\n\t\t\t\tFs.appendFileSync(F.path.temp(temporary + '.css'), hash + (DEBUG ? component_debug(name, content.css, 'css') : content.css) + hash.substring(0, hash.length - 1));\n\t\t\t\ttmp.css = true;\n\t\t\t}\n\n\t\t\ttmp.version = GUID(5);\n\t\t\ttmp.links = (tmp.js ? '<script src=\"{0}js?group={2}_{1}\"></script>'.format(link, tmp.version, key) : '') + (tmp.css ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"{0}css?group={2}_{1}\" />'.format(link, tmp.version, key) : '');\n\t\t}\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'package') {\n\n\t\tvar id = Path.basename(declaration, '.' + U.getExtension(declaration));\n\t\tvar dir = CONF.directory_temp[0] === '~' ? Path.join(CONF.directory_temp.substring(1), id + '.package') : Path.join(F.path.root(), CONF.directory_temp, id + '.package');\n\n\t\tF.routes.packages[id] = dir;\n\n\t\tvar restorecb = function() {\n\t\t\tvar filename = Path.join(dir, 'index.js');\n\t\t\tif (!existsSync(filename)) {\n\t\t\t\tnext && next();\n\t\t\t\tcallback && callback(null, name);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tF.install('module', id, filename, options || CONF['package#' + name], function(err) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tEMIT('module#' + name);\n\t\t\t\t\tEMIT(type + '#' + name);\n\t\t\t\t\tEMIT('install', 'module', name);\n\t\t\t\t\tEMIT('install', type, name);\n\t\t\t\t\tF.temporary.ready['package#' + name] = NOW;\n\t\t\t\t\tF.temporary.ready['module#' + name] = NOW;\n\t\t\t\t}, 500);\n\t\t\t\tF.consoledebug('install', 'package#' + name);\n\t\t\t\tcallback && callback(err, name);\n\t\t\t}, internal, useRequired, true, undefined);\n\t\t\tnext && next();\n\t\t};\n\n\t\tif (F.$bundling)\n\t\t\tF.restore(declaration, dir, restorecb);\n\t\telse\n\t\t\trestorecb();\n\n\t\treturn F;\n\t}\n\n\tif (type === 'theme') {\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj = require(declaration);\n\t\tobj.$owner = _owner;\n\t\tF.temporary.owners[_owner] = true;\n\n\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\t(function(name) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tdelete require.cache[name];\n\t\t\t}, 1000);\n\t\t})(require.resolve(declaration));\n\t\treturn F;\n\t}\n\n\tif (type === 'package2') {\n\t\ttype = type.substring(0, type.length - 1);\n\t\tvar id = U.getName(declaration, '.package');\n\t\tvar dir = CONF.directory_temp[0] === '~' ? Path.join(CONF.directory_temp.substring(1), id) : Path.join(F.path.root(), CONF.directory_temp, id);\n\t\tvar filename = Path.join(dir, 'index.js');\n\t\tF.install('module', id.replace(/\\.package$/i, ''), filename, options || CONF['package#' + name], function(err) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tEMIT('module#' + name);\n\t\t\t\tEMIT(type + '#' + name);\n\t\t\t\tEMIT('install', type, name);\n\t\t\t\tEMIT('install', 'module', name);\n\t\t\t\tF.temporary.ready['package#' + name] = NOW;\n\t\t\t\tF.temporary.ready['module#' + name] = NOW;\n\t\t\t}, 500);\n\t\t\tF.consoledebug('install', 'package#' + name);\n\t\t\tcallback && callback(err, name);\n\t\t}, internal, useRequired, true);\n\t\tnext && next();\n\t\treturn F;\n\t}\n\n\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\tif (type === 'view') {\n\n\t\tvar item = F.routes.views[name];\n\t\tkey = type + '.' + name;\n\n\t\tif (item === undefined) {\n\t\t\titem = {};\n\t\t\titem.filename = F.path.temporary(plus + 'installed-view-' + U.GUID(10) + '.tmp');\n\t\t\titem.url = internal;\n\t\t\titem.count = 0;\n\t\t\tF.routes.views[name] = item;\n\t\t}\n\n\t\titem.count++;\n\t\tFs.writeFileSync(item.filename, framework_internal.modificators(declaration, name));\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'definition' || type === 'eval' || type === 'schema' || type === 'operation') {\n\n\t\t_controller = '';\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tF.temporary.owners[_owner] = true;\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tdelete require.cache[require.resolve(declaration)];\n\t\t\t\tobj = require(declaration);\n\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse\n\t\t\t\tobj = typeof(declaration) === 'function' ? eval('(' + declaration.toString() + ')()') : eval(declaration);\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tF.consoledebug('install', type + '#' + (name || '::undefined::'));\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\treturn F;\n\t}\n\n\tif (type === 'isomorphic') {\n\n\t\tcontent = '';\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\tif (tmp)\n\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t}\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tdelete require.cache[require.resolve(declaration)];\n\t\t\t\tobj = require(declaration);\n\t\t\t\tcontent = Fs.readFileSync(declaration).toString(ENCODING);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = typeof(declaration) === 'function' ? eval('(' + declaration.toString() + ')()') : eval(declaration);\n\t\t\t\tcontent = declaration.toString();\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\tif (obj.url) {\n\t\t\tif (obj.url[0] !== '/')\n\t\t\t\tobj.url = '/' + obj.url;\n\t\t} else\n\t\t\tobj.url = '/' + name + '.js';\n\n\t\ttmp = F.path.temp('isomorphic_' + name + '.min.js');\n\t\tF.map(framework_internal.preparePath(obj.url), tmp);\n\t\tF.isomorphic[name] = obj;\n\n\t\tF.$bundling && Fs.writeFileSync(tmp, prepare_isomorphic(name, framework_internal.compile_javascript(content, '#' + name)));\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\treturn F;\n\t}\n\n\tif (type === 'model' || type === 'source') {\n\n\t\t_controller = '';\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tF.temporary.owners[_owner] = true;\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tobj = require(declaration);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (typeof(declaration) !== 'string')\n\t\t\t\t\tdeclaration = declaration.toString();\n\n\t\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t\t}\n\n\t\t\t\tvar filename = F.path.temporary(plus + 'installed-' + type + '-' + U.GUID(10) + '.js');\n\t\t\t\tFs.writeFileSync(filename, declaration);\n\t\t\t\tobj = require(filename);\n\n\t\t\t\t(function(name, filename) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tFs.unlinkSync(filename);\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filename), filename);\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\', \\'' + name + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj.$owner = _owner;\n\n\t\tif (!name)\n\t\t\tname = (Math.random() * 10000) >> 0;\n\n\t\tkey = type + '.' + name;\n\t\ttmp = F.dependencies[key];\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined);\n\t\tF.temporary.owners[_owner] = true;\n\n\t\tif (tmp) {\n\t\t\tF.dependencies[key] = tmp;\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t}\n\t\telse {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0 };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].count++;\n\n\t\tif (obj.reinstall)\n\t\t\tF.dependencies[key].reinstall = obj.reinstall.toString().parseDateExpiration();\n\t\telse\n\t\t\tdelete F.dependencies[key];\n\n\t\tif (type === 'model')\n\t\t\tF.models[name] = obj;\n\t\telse\n\t\t\tF.sources[name] = obj;\n\n\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[type + '#' + name], name);\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'module' || type === 'controller') {\n\n\t\t// for inline routes\n\t\tvar _ID = _controller = 'TMP' + U.random(10000);\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\terr = null;\n\n\t\ttry {\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tobj = require(declaration);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t} else {\n\n\t\t\t\tif (typeof(declaration) !== 'string')\n\t\t\t\t\tdeclaration = declaration.toString();\n\n\t\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t\t}\n\n\t\t\t\tfilename = F.path.temporary(plus + 'installed-' + type + '-' + U.GUID(10) + '.js');\n\t\t\t\tFs.writeFileSync(filename, declaration);\n\t\t\t\tobj = require(filename);\n\t\t\t\t(function(name, filename) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tFs.unlinkSync(filename);\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filename), filename);\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\', \\'' + (name ? '' : internal) + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\tif (!name)\n\t\t\tname = (Math.random() * 10000) >> 0;\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj.$owner = _owner;\n\n\t\tobj.booting && setTimeout(function() {\n\n\t\t\tvar tmpdir = F.path.temp(name + (U.getExtension(name) === 'package' ? '' : '.package/'));\n\n\t\t\tif (obj.booting === 'root') {\n\t\t\t\tF.directory = directory = tmpdir;\n\t\t\t\tF.temporary.path = {};\n\t\t\t\tF.temporary.notfound = {};\n\t\t\t\tF.$configure_configs();\n\t\t\t\tF.$configure_versions();\n\t\t\t\tF.$configure_dependencies();\n\t\t\t\tF.$configure_sitemap();\n\t\t\t\tF.$configure_workflows();\n\t\t\t} else {\n\t\t\t\tF.$configure_configs('@' + name + '/config');\n\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tF.$configure_configs('@' + name + '/config-debug');\n\t\t\t\telse\n\t\t\t\t\tF.$configure_configs('@' + name + '/config-release');\n\t\t\t\tF.isTest && F.$configure_configs('@' + name + '/config-test');\n\t\t\t\tF.$configure_versions('@' + name + '/versions');\n\t\t\t\tF.$configure_dependencies('@' + name + '/dependencies');\n\t\t\t\tF.$configure_sitemap('@' + name + '/sitemap');\n\t\t\t\tF.$configure_workflows('@' + name + '/workflows');\n\t\t\t}\n\n\t\t\tF.$bundle(() => F.$load(undefined, tmpdir, undefined, name));\n\t\t}, 100);\n\n\t\tkey = type + '.' + name;\n\t\ttmp = F.dependencies[key];\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined, undefined, packageName);\n\t\tF.temporary.owners[_owner] = true;\n\n\t\tif (tmp) {\n\t\t\tF.dependencies[key] = tmp;\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t}\n\t\telse {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0, _id: _ID };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].dependencies = obj.dependencies;\n\t\tF.dependencies[key].count++;\n\t\tF.dependencies[key].processed = false;\n\n\t\tif (obj.reinstall)\n\t\t\tF.dependencies[key].reinstall = obj.reinstall.toString().parseDateExpiration();\n\t\telse\n\t\t\tdelete F.dependencies[key].reinstall;\n\n\t\t_controller = _ID;\n\n\t\tif (obj.dependencies instanceof Array) {\n\t\t\tfor (var i = 0, length = obj.dependencies.length; i < length; i++) {\n\t\t\t\tif (!F.dependencies[type + '.' + obj.dependencies[i]]) {\n\t\t\t\t\tF.temporary.dependencies[key] = { obj: obj, options: options, callback: callback, skipEmit: skipEmit };\n\t\t\t\t\tnext && next();\n\t\t\t\t\treturn F;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tF.install_make(key, name, obj, options, callback, skipEmit, type);\n\n\t\tif (type === 'module')\n\t\t\tF.modules[name] = obj;\n\t\telse\n\t\t\tF.controllers[name] = obj;\n\n\t\tF.install_prepare();\n\t\tnext && next();\n\t}\n\n\treturn F;\n};\n\nF.restart = function() {\n\tOBSOLETE('F.restart()', 'This function is not supported');\n\treturn F;\n};\n\nF.install_prepare = function(noRecursive) {\n\n\tvar keys = Object.keys(F.temporary.dependencies);\n\n\tif (!keys.length)\n\t\treturn;\n\n\t// check dependencies\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar k = keys[i];\n\t\tvar a = F.temporary.dependencies[k];\n\t\tvar b = F.dependencies[k];\n\t\tvar skip = false;\n\n\t\tif (b.processed)\n\t\t\tcontinue;\n\n\t\tfor (var j = 0, jl = b.dependencies.length; j < jl; j++) {\n\t\t\tvar d = F.dependencies['module.' + b.dependencies[j]];\n\t\t\tif (!d || !d.processed) {\n\t\t\t\tskip = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tdelete F.temporary.dependencies[k];\n\n\t\tif (b.type === 'module')\n\t\t\tF.modules[b.name] = a.obj;\n\t\telse\n\t\t\tF.controllers[b.name] = a.obj;\n\n\t\tF.install_make(k, b.name, a.obj, a.options, a.callback, a.skipEmit, b.type);\n\t}\n\n\tkeys = Object.keys(F.temporary.dependencies);\n\n\tclearTimeout(F.temporary.other.dependencies);\n\tF.temporary.other.dependencies = setTimeout(function() {\n\t\tvar keys = Object.keys(F.temporary.dependencies);\n\t\tif (keys.length)\n\t\t\tthrow new Error('Dependency exception, missing dependencies for: ' + keys.join(', ').trim());\n\t\tdelete F.temporary.other.dependencies;\n\t}, CONF.default_dependency_timeout);\n\n\tif (!keys.length || noRecursive)\n\t\treturn F;\n\n\tF.install_prepare(true);\n\treturn F;\n};\n\nF.install_make = function(key, name, obj, options, callback, skipEmit, type) {\n\n\tvar me = F.dependencies[key];\n\tvar routeID = me._id;\n\tvar type = me.type;\n\n\tF.temporary.internal[me._id] = name;\n\t_controller = routeID;\n\t_owner = type + '#' + name.replace(/\\.package$/gi, '');\n\n\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\tme.processed = true;\n\n\tvar id = (type === 'module' ? '#' : '') + name;\n\tvar length = F.routes.web.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.web[i].controller === routeID)\n\t\t\tF.routes.web[i].controller = id;\n\t}\n\n\tvar tmp = Object.keys(F.routes.system);\n\tlength = tmp.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.system[tmp[i]].controller === routeID)\n\t\t\tF.routes.system[tmp[i]].controller = id;\n\t}\n\n\tlength = F.routes.websockets.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.websockets[i].controller === routeID)\n\t\t\tF.routes.websockets[i].controller = id;\n\t}\n\n\tlength = F.routes.files.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.files[i].controller === routeID)\n\t\t\tF.routes.files[i].controller = id;\n\t}\n\n\tF.$routesSort();\n\t_controller = '';\n\tname = name.replace(/\\.package$/gi, '');\n\n\tif (!skipEmit) {\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\t}\n\n\tF.consoledebug('install', type + '#' + name);\n\tcallback && callback(null, name);\n\treturn F;\n};\n\n/**\n * Uninstall type\n * @param {String} type Available types: model, module, controller, source.\n * @param {String} name\n * @param {Object} options Custom options, optional.\n * @param {Object} skipEmit Internal, optional.\n * @return {Framework}\n */\nF.uninstall = function(type, name, options, skipEmit, packageName) {\n\n\tvar obj = null;\n\tvar k, v, tmp;\n\n\tif (type === 'route' || type === 'web') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'execute';\n\t\tv = k === 'execute' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tif (k === 'urlraw' && v[0] === '#')\n\t\t\tdelete F.routes.system[v];\n\t\telse\n\t\t\tF.routes.web = F.routes.web.remove(k, v);\n\t\tF.$routesSort();\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\tF.temporary.other = {};\n\t\treturn F;\n\t}\n\n\tif (type === 'cors') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'hash' : 'hash';\n\t\tv = k === 'id' ? name.substring(3).trim() : name;\n\t\tif (k !== 'id')\n\t\t\tv = framework_internal.preparePath(framework_internal.encodeUnicodeURL(v.replace('*', '').trim()));\n\t\tF.routes.cors = F.routes.cors.remove(k, v);\n\t\tF._length_cors = F.routes.cors.length;\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'operation') {\n\t\tNEWOPERATION(name, null);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'convertor') {\n\t\tF.convertor(name, null);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'schedule') {\n\t\tF.clearSchedule(name);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tvar id = (packageName ? packageName + '@' : '') +  type + '#' + name;\n\n\tif (type === 'websocket') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'onInitialize';\n\t\tv = k === 'onInitialize' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tF.routes.websockets = F.routes.websockets.remove(k, v);\n\t\tF.$routesSort();\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'file') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'execute';\n\t\tv = k === 'execute' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tF.routes.files = F.routes.files.remove(k, v);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'schema') {\n\t\ttmp = name.split('/');\n\t\ttmp.length === 2 ? framework_builders.remove(tmp[0], tmp[1]) : framework_builders.remove(undefined, tmp[0]);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'mapping') {\n\t\tdelete F.routes.mapping[name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'isomorphic') {\n\t\tvar obj = F.isomorphic[name];\n\t\tif (obj.url)\n\t\t\tdelete F.routes.mapping[F.$version(obj.url)];\n\t\tdelete F.isomorphic[name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'middleware') {\n\n\t\tif (!F.routes.middleware[name])\n\t\t\treturn F;\n\n\t\tdelete F.routes.middleware[name];\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF._length_middleware = Object.keys(F.routes.middleware).length;\n\n\t\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\t\ttmp = F.routes.web[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tfor (var i = 0, length = F.routes.websockets.length; i < length; i++) {\n\t\t\ttmp = F.routes.websockets[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tfor (var i = 0, length = F.routes.files.length; i < length; i++) {\n\t\t\ttmp = F.routes.files[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t} else if (type === 'package') {\n\t\tdelete F.routes.packages[name];\n\t\tdelete F.temporary.ready['package#' + name];\n\t\tF.uninstall('module', name, options, true);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t} else if (type === 'view' || type === 'precompile') {\n\n\t\tobj = F.routes.views[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tdelete F.routes.views[name];\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\n\t\tfsFileExists(obj.filename, function(e) {\n\t\t\te && Fs.unlink(obj.filename, NOOP);\n\t\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\t});\n\n\t} else if (type === 'model' || type === 'source') {\n\n\t\tobj = type === 'model' ? F.models[name] : F.sources[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tF.$uninstall(id);\n\t\ttypeof(obj.uninstall) === 'function' && obj.uninstall(options, name);\n\n\t\tif (type === 'model')\n\t\t\tdelete F.models[name];\n\t\telse\n\t\t\tdelete F.sources[name];\n\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t} else if (type === 'module' || type === 'controller') {\n\n\t\tvar isModule = type === 'module';\n\t\tobj = isModule ? F.modules[name] : F.controllers[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tF.$uninstall(id, packageName ? '' : ((isModule ? '#' : '') + name));\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t\tif (obj) {\n\t\t\tobj.uninstall && obj.uninstall(options, name);\n\t\t\tif (isModule)\n\t\t\t\tdelete F.modules[name];\n\t\t\telse\n\t\t\t\tdelete F.controllers[name];\n\t\t}\n\n\t} else if (type === 'component') {\n\n\t\tif (!F.components.instances[name])\n\t\t\treturn F;\n\n\t\tobj = F.components.instances[name];\n\n\t\tif (obj) {\n\t\t\tF.$uninstall(id);\n\t\t\tobj.uninstall && obj.uninstall(options, name);\n\t\t\tdelete F.components.instances[name];\n\t\t}\n\n\t\tdelete F.components.instances[name];\n\t\tdelete F.components.views[name];\n\t\tdelete F.components.files[name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\n\t\tvar temporary = (F.id ? 'i-' + F.id + '_' : '') + 'components';\n\t\tvar data;\n\t\tvar index;\n\t\tvar beg = '\\n/*' + name.hash() + '*/\\n';\n\t\tvar end = beg.substring(0, beg.length - 1);\n\t\tvar is = false;\n\n\t\tif (F.components.js) {\n\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.js')).toString('utf-8');\n\t\t\tindex = data.indexOf(beg);\n\t\t\tif (index !== -1) {\n\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.js'), data);\n\t\t\t\tis = true;\n\t\t\t}\n\t\t}\n\n\t\tif (F.components.css) {\n\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.css')).toString('utf-8');\n\t\t\tindex = data.indexOf(beg);\n\t\t\tif (index !== -1) {\n\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.css'), data);\n\t\t\t\tis = true;\n\t\t\t}\n\t\t}\n\n\t\tif (obj.group) {\n\t\t\ttemporary += '_g' + obj.group.hash();\n\t\t\ttmp = F.components.groups[obj.group];\n\t\t\tif (tmp) {\n\n\t\t\t\tif (tmp.js) {\n\t\t\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.js')).toString('utf-8');\n\t\t\t\t\tindex = data.indexOf(beg);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.js'), data);\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tmp.css) {\n\t\t\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.css')).toString('utf-8');\n\t\t\t\t\tindex = data.indexOf(beg);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.css'), data);\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttmp.version = NOW.getTime();\n\t\t\t}\n\t\t}\n\n\t\tif (is)\n\t\t\tF.components.version = NOW.getTime();\n\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t}\n\n\t!skipEmit && EMIT('uninstall', type, name);\n\treturn F;\n};\n\nF.$uninstall = function(owner, controller) {\n\n\tif (!F.temporary.owners[owner])\n\t\treturn F;\n\n\tif (controller) {\n\t\tF.routes.web = F.routes.web.remove('controller', controller);\n\t\tF.routes.files = F.routes.files.remove('controller', controller);\n\t\tF.routes.websockets = F.routes.websockets.remove('controller', controller);\n\t}\n\n\tF.routes.web = F.routes.web.remove('owner', owner);\n\tF.routes.files = F.routes.files.remove('owner', owner);\n\tF.routes.websockets = F.routes.websockets.remove('owner', owner);\n\tF.routes.cors = F.routes.cors.remove('owner', owner);\n\tF.schedules = F.schedules.remove('owner', owner);\n\n\tif (F.modificators)\n\t\tF.modificators = F.modificators.remove('$owner', owner);\n\n\tframework_builders.uninstall(owner);\n\n\tvar owners = [];\n\tvar redirects = false;\n\n\tfor (var i = 0, length = F.owners.length; i < length; i++) {\n\n\t\tvar m = F.owners[i];\n\t\tif (m.owner !== owner) {\n\t\t\towners.push(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (m.type) {\n\t\t\tcase 'redirects':\n\t\t\t\tdelete F.routes.redirects[m.id];\n\t\t\t\tredirects = true;\n\t\t\t\tbreak;\n\t\t\tcase 'resize':\n\t\t\t\tdelete F.routes.resize[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tdelete F.routes.merge[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'mapping':\n\t\t\t\tdelete F.routes.mapping[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'blocks':\n\t\t\t\tdelete F.routes.blocks[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'middleware':\n\t\t\t\tUNINSTALL('middleware', m.id);\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (redirects)\n\t\tF._request_check_redirect = Object.keys(F.routes.redirects).length > 0;\n\n\tF.owners = owners;\n\tF.$routesSort();\n\tdelete F.temporary.owners[owner];\n\n\treturn F;\n};\n\n/**\n * Register internal mapping (e.g. Resource)\n * @param {String} path\n * @return {Framework}\n */\nF.register = function(path) {\n\n\tvar key;\n\tvar extension = '.' + U.getExtension(path);\n\tvar name = U.getName(path);\n\tvar c = path[0];\n\n\tif (c === '@')\n\t\tpath = F.path.package(path.substring(1));\n\telse if (c === '=') {\n\t\tif (path[1] === '?')\n\t\t\tF.path.themes(CONF.default_theme + path.substring(2));\n\t\telse\n\t\t\tpath = F.path.themes(path.substring(1));\n\t}\n\n\tswitch (extension) {\n\t\tcase '.resource':\n\t\t\tkey = name.replace(extension, '');\n\t\t\tif (F.routes.resources[key])\n\t\t\t\tF.routes.resources[key].push(path);\n\t\t\telse\n\t\t\t\tF.routes.resources[key] = [path];\n\t\t\t// clears cache\n\t\t\tdelete F.resources[key];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error('Not supported registration type \"' + extension + '\".');\n\t}\n\n\treturn F;\n};\n\n/**\n * Run code\n * @param {String or Function} script Function to eval or Code or URL address.\n * @return {Framework}\n */\nF.eval = function(script) {\n\treturn F.install('eval', script);\n};\n\n/**\n * Error handler\n * @param {Error} err\n * @param {String} name\n * @param {Object} uri URI address, optional.\n * @return {Framework}\n */\nF.onError = function(err, name, uri) {\n\tNOW = new Date();\n\tconsole.log('======= ' + (NOW.format('yyyy-MM-dd HH:mm:ss')) + ': ' + (name ? name + ' ---> ' : '') + err.toString() + (uri ? ' (' + Parser.format(uri) + ')' : ''), err.stack);\n\treturn F;\n};\n\n/*\n\tAuthorization handler\n\t@req {Request}\n\t@res {Response} OR {WebSocketClient}\n\t@flags {String array}\n\t@callback {Function} - @callback(Boolean), true is [authorize]d and false is [unauthorize]d\n*/\nF.onAuthorize = null;\n\n/*\n\tSets the current language for the current request\n\t@req {Request}\n\t@res {Response} OR {WebSocketClient}\n\t@return {String}\n*/\nF.onLocale = null;\n// OLD: F.onLocate = null;\n\n/**\n * Sets theme to controller\n * @controller {Controller}\n * @return {String}\n */\nF.onTheme = null;\n\n/*\n\tVersioning static files (this delegate call LESS CSS by the background property)\n\t@name {String} :: name of static file (style.css or script.js)\n\treturn {String} :: return new name of static file (style-new.css or script-new.js)\n*/\nF.onVersion = null;\n\n/**\n * On mapping static files\n * @param {String} url\n * @param {String} def Default value.\n * @return {String}\n */\nF.onMapping = function(url, def, ispublic, encode) {\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar tmp = url;\n\tif (CONF.default_root)\n\t\ttmp = tmp.substring(CONF.default_root.length - 1);\n\n\t// component files\n\tif (tmp[1] === '~') {\n\t\tvar index = tmp.indexOf('/', 2);\n\t\tvar name = tmp.substring(2, index);\n\t\treturn F.components.files[name] && F.components.files[name][tmp.substring(index + 1)] ? (F.path.temp() + tmp.substring(1)) : null;\n\t}\n\n\tif (F.routes.mapping[url])\n\t\treturn F.routes.mapping[url];\n\n\tif (F._length_themes) {\n\t\tvar index = tmp.indexOf('/', 2);\n\t\tif (index !== -1) {\n\t\t\tvar themeName = tmp.substring(1, index);\n\t\t\tif (F.themes[themeName])\n\t\t\t\treturn F.themes[themeName] + 'public' + tmp.substring(index);\n\t\t}\n\t}\n\n\tdef = framework_internal.preparePath(def, true);\n\n\tif (encode)\n\t\tdef = $decodeURIComponent(def);\n\n\tif (ispublic)\n\t\tdef = F.path.public_cache(def);\n\telse\n\t\tdef = def[0] === '~' ? def.substring(1) : def[0] === '.' ? def : F.path.public_cache(def);\n\n\treturn def;\n};\n\nF.download = F.snapshot = function(url, filename, callback) {\n\n\tif (!F.isLoaded) {\n\t\tsetTimeout(function(url, filename, callback) {\n\t\t\tF.snapshot(url, filename, callback);\n\t\t}, 200, url, filename, callback);\n\t\treturn F;\n\t}\n\n\turl = framework_internal.preparePath(url);\n\n\tif (!REG_HTTPHTTPS.test(url)) {\n\t\tif (url[0] !== '/')\n\t\t\turl = '/' + url;\n\t\tif (F.isWorker)\n\t\t\tthrow new Error('Worker can\\'t create a snapshot from relative URL address \"{0}\".'.format(url));\n\t\turl = 'http://' + (F.ip === 'auto' ? '0.0.0.0' : F.ip) + ':' + F.port + url;\n\t}\n\n\tU.download(url, FLAGS_INSTALL, function(err, response) {\n\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t\tcallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar stream = Fs.createWriteStream(filename);\n\t\tresponse.pipe(stream);\n\n\t\tresponse.on('error', function(err) {\n\t\t\tcallback && callback(err);\n\t\t\tcallback = null;\n\t\t});\n\n\t\tCLEANUP(stream, function() {\n\t\t\tcallback && callback(null, filename);\n\t\t\tcallback = null;\n\t\t});\n\t});\n\n\treturn F;\n};\n\n/**\n * Find WebSocket connection\n * @param {String/RegExp} path\n * @return {WebSocket}\n */\nF.findConnection = function(path) {\n\tvar arr = Object.keys(F.connections);\n\tvar is = U.isRegExp(path);\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar key = arr[i];\n\t\tif (is) {\n\t\t\tif (path.test(key))\n\t\t\t\treturn F.connections[key];\n\t\t} else {\n\t\t\tif (key.indexOf(path) !== -1)\n\t\t\t\treturn F.connections[key];\n\t\t}\n\t}\n};\n\n/**\n * Find WebSocket connections\n * @param {String/RegExp} path\n * @return {WebSocket Array}\n */\nF.findConnections = function(path) {\n\tvar arr = Object.keys(F.connections);\n\tvar is = U.isRegExp(path);\n\tvar output = [];\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar key = arr[i];\n\t\tif (!path)\n\t\t\toutput.push(F.connections[key]);\n\t\telse if (is)\n\t\t\tpath.test(key) && output.push(F.connections[key]);\n\t\telse\n\t\t\tkey.indexOf(path) !== -1 && output.push(F.connections[key]);\n\t}\n\treturn output;\n};\n\n/**\n * Global validation\n * @param {Function(name, value)} delegate\n * @type {Boolean or StringErrorMessage}\n */\nF.onValidate = null;\n\n/**\n * Global XML parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseXML = function(value) {\n\tvar val = U.parseXML(value);\n\tF._length_convertors && F.convert(val);\n\treturn val;\n};\nF.onParseXML.$def = true;\n\nF.$onParseXML = function(req) {\n\tif (F.onParseXML.$def) {\n\t\treq.body = U.parseXML(req.buffer_data);\n\t\tF._length_convertors && F.convert(req.body);\n\t} else\n\t\treq.body = F.onParseXML(req.buffer_data);\n};\n\n/**\n * Global JSON parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseJSON = function(value) {\n\tif (value) {\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {}\n\t}\n};\nF.onParseJSON.$def = true;\n\nF.$onParseJSON = function(req) {\n\treq.body = F.onParseJSON.$def ? JSON.parse(req.buffer_data) : F.onParseJSON(req.buffer_data);\n};\n\n/**\n * Global JSON parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseQuery = function(value) {\n\tif (value) {\n\t\tvar val = Qs.parse(value, null, null, QUERYPARSEROPTIONS);\n\t\tF._length_convertors && F.convert(val);\n\t\treturn val;\n\t}\n\treturn {};\n};\nF.onParseQuery.$def = true;\n\nF.$onParseQueryBody = function(req) {\n\tif (F.onParseQuery.$def) {\n\t\tif (req.buffer_data) {\n\t\t\treq.body = Qs.parse(req.buffer_data, null, null, QUERYPARSEROPTIONS);\n\t\t\tF._length_convertors && F.convert(req.body);\n\t\t} else\n\t\t\treq.body = {};\n\t} else\n\t\treq.body = F.onParseQuery(req.buffer_data, req);\n};\n\nF.$onParseQueryUrl = function(req) {\n\tif (F.onParseQuery.$def) {\n\t\treq._querydata = Qs.parse(req.uri.query, null, null, QUERYPARSEROPTIONS);\n\t\tF._length_convertors && F.convert(req._querydata);\n\t} else\n\t\treq._querydata = F.onParseQuery(req.uri.query, req);\n};\n\n/**\n * Schema parser delegate\n * @param {Request} req\n * @param {String} group\n * @param {String} name\n * @param {Function(err, body)} callback\n */\nF.onSchema = function(req, route, callback) {\n\n\tvar schema;\n\n\tif (route.isDYNAMICSCHEMA) {\n\t\tvar index = route.param[route.paramnames.indexOf(route.schema[1])];\n\t\treq.$schemaname = route.schema[0] + '/' + req.split[index];\n\t\tschema = framework_builders.findschema(req.$schemaname);\n\t} else\n\t\tschema = GETSCHEMA(route.schema[0], route.schema[1]);\n\n\tif (schema)\n\t\tschema.make(req.body, route.schema[2], onSchema_callback, callback, route.novalidate, route.workflow ? route.workflow.meta : null);\n\telse\n\t\tcallback('Schema \"' + (route.isDYNAMICSCHEMA ? req.$schemaname : (route.schema[0] + '/' + route.schema[1])) + '\" not found.');\n};\n\nfunction onSchema_callback(err, res, callback) {\n\tif (err)\n\t\tcallback(err);\n\telse\n\t\tcallback(null, res);\n}\n\n/**\n * Mail delegate\n * @param {String or Array String} address\n * @param {String} subject\n * @param {String} body\n * @param {Function(err)} callback\n * @param {String} replyTo\n * @return {MailMessage}\n */\nF.onMail = function(address, subject, body, callback, replyTo) {\n\n\tvar tmp;\n\n\tif (typeof(callback) === 'string') {\n\t\ttmp = replyTo;\n\t\treplyTo = callback;\n\t\tcallback = tmp;\n\t}\n\n\tvar message = Mail.create(subject, body);\n\n\tif (address instanceof Array) {\n\t\tfor (var i = 0, length = address.length; i < length; i++)\n\t\t\tmessage.to(address[i]);\n\t} else\n\t\tmessage.to(address);\n\n\tmessage.from(CONF.mail_address_from || '', CONF.name);\n\n\tif (replyTo)\n\t\tmessage.reply(replyTo);\n\telse {\n\t\ttmp = CONF.mail_address_reply;\n\t\ttmp && tmp.length > 3 && message.reply(tmp);\n\t}\n\n\ttmp = CONF.mail_address_copy;\n\ttmp && tmp.length > 3 && message.bcc(tmp);\n\n\tmessage.$sending = setImmediate(cb => message.send2(cb), callback);\n\treturn message;\n};\n\nF.onMeta = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\tvar self = this;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar arg = U.encode(arguments[i]);\n\t\tif (arg == null || !arg.length)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tbuilder += '<title>' + (arg + (F.url !== '/' && !CONF.allow_custom_titles ? ' - ' + CONF.name : '')) + '</title>';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuilder += '<meta name=\"description\" content=\"' + arg + '\" />';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuilder += '<meta name=\"keywords\" content=\"' + arg + '\" />';\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tvar tmp = arg.substring(0, 6);\n\t\t\t\tvar img = tmp === 'http:/' || tmp === 'https:' || arg.substring(0, 2) === '//' ? arg : self.hostname(self.routeImage(arg));\n\t\t\t\tbuilder += '<meta property=\"og:image\" content=\"' + img + '\" /><meta name=\"twitter:image\" content=\"' + img + '\" />';\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder;\n};\n\n// @arguments {Object params}\nglobal.LOG = F.log = function() {\n\n\tNOW = new Date();\n\tvar filename = NOW.getFullYear() + '-' + (NOW.getMonth() + 1).toString().padLeft(2, '0') + '-' + NOW.getDate().toString().padLeft(2, '0');\n\tvar time = NOW.getHours().toString().padLeft(2, '0') + ':' + NOW.getMinutes().toString().padLeft(2, '0') + ':' + NOW.getSeconds().toString().padLeft(2, '0');\n\tvar str = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar val = arguments[i];\n\t\tif (val === undefined)\n\t\t\tval = 'undefined';\n\t\telse if (val === null)\n\t\t\tval = 'null';\n\t\telse if (typeof(val) === 'object')\n\t\t\tval = Util.inspect(val);\n\t\tstr += (str ? ' ' : '') + val;\n\t}\n\n\tF.path.verify('logs');\n\tU.queue('F.log', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, filename + '.log'), time + ' | ' + str + '\\n', next));\n\treturn F;\n};\n\nglobal.LOGGER = F.logger = function() {\n\tNOW = new Date();\n\tvar dt = NOW.getFullYear() + '-' + (NOW.getMonth() + 1).toString().padLeft(2, '0') + '-' + NOW.getDate().toString().padLeft(2, '0') + ' ' + NOW.getHours().toString().padLeft(2, '0') + ':' + NOW.getMinutes().toString().padLeft(2, '0') + ':' + NOW.getSeconds().toString().padLeft(2, '0');\n\tvar str = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 1; i < length; i++) {\n\t\tvar val = arguments[i];\n\t\tif (val === undefined)\n\t\t\tval = 'undefined';\n\t\telse if (val === null)\n\t\t\tval = 'null';\n\t\telse if (typeof(val) === 'object')\n\t\t\tval = Util.inspect(val);\n\t\tstr += (str ? ' ' : '') + val;\n\t}\n\n\tF.path.verify('logs');\n\tU.queue('F.logger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, arguments[0] + '.log'), dt + ' | ' + str + '\\n', next));\n\treturn F;\n};\n\nglobal.LOGMAIL = F.logmail = function(address, subject, body, callback) {\n\n\tif (typeof(body) === FUNCTION) {\n\t\tcallback = body;\n\t\tbody = subject;\n\t\tsubject = null;\n\t} else if (body === undefined) {\n\t\tbody = subject;\n\t\tsubject = null;\n\t}\n\n\tif (!subject)\n\t\tsubject = CONF.name + ' v' + CONF.version;\n\n\tvar body = '<!DOCTYPE html><html><head><title>' + subject + '</title><meta charset=\"utf-8\" /></head><body><pre style=\"max-width:600px;font-size:13px;line-height:16px\">' + (typeof(body) === 'object' ? JSON.stringify(body).escape() : body) + '</pre></body></html>';\n\treturn F.onMail(address, subject, body, callback);\n};\n\nF.usage = function(detailed) {\n\n\tvar memory = process.memoryUsage();\n\tvar cache = Object.keys(F.cache.items);\n\tvar resources = Object.keys(F.resources);\n\tvar controllers = Object.keys(F.controllers);\n\tvar connections = Object.keys(F.connections);\n\tvar workers = Object.keys(F.workers);\n\tvar modules = Object.keys(F.modules);\n\tvar isomorphic = Object.keys(F.isomorphic);\n\tvar models = Object.keys(F.models);\n\tvar helpers = Object.keys(F.helpers);\n\tvar staticFiles = Object.keys(F.temporary.path);\n\tvar staticNotfound = Object.keys(F.temporary.notfound);\n\tvar staticRange = Object.keys(F.temporary.range);\n\tvar redirects = Object.keys(F.routes.redirects);\n\tvar output = {};\n\tvar nosqlcleaner = Object.keys(F.databasescleaner);\n\n\toutput.framework = {\n\t\tid: F.id,\n\t\tdatetime: NOW,\n\t\tpid: process.pid,\n\t\tnode: process.version,\n\t\tversion: 'v' + F.version_header,\n\t\tplatform: process.platform,\n\t\tprocessor: process.arch,\n\t\tuptime: Math.floor(process.uptime() / 60),\n\t\tmemoryTotal: (memory.heapTotal / 1024 / 1024).floor(2),\n\t\tmemoryUsage: (memory.heapUsed / 1024 / 1024).floor(2),\n\t\tmemoryRss: (memory.rss / 1024 / 1024).floor(2),\n\t\tmode: DEBUG,\n\t\tport: F.port,\n\t\tip: F.ip,\n\t\tdirectory: process.cwd()\n\t};\n\n\tif (CONF.nosql_worker)\n\t\toutput.framework.pidnosql = framework_nosql.pid();\n\n\tvar keys = Object.keys(U.queuecache);\n\tvar pending = 0;\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\tpending += U.queuecache[keys[i]].pending.length;\n\n\toutput.counter = {\n\t\tresource: resources.length,\n\t\tcontroller: controllers.length,\n\t\tmodule: modules.length,\n\t\tisomorphic: isomorphic.length,\n\t\tcache: cache.length,\n\t\tworker: workers.length,\n\t\tconnection: connections.length,\n\t\tschedule: F.schedules.length,\n\t\thelpers: helpers.length,\n\t\terror: F.errors.length,\n\t\tproblem: F.problems.length,\n\t\tqueue: pending,\n\t\tfiles: staticFiles.length,\n\t\tnotfound: staticNotfound.length,\n\t\tstreaming: staticRange.length,\n\t\tmodificator:  F.modificators ? F.modificators.length : 0,\n\t\tviewphrases: $VIEWCACHE.length,\n\t\tuptodates: F.uptodates ? F.uptodates.length : 0,\n\t\tnosqlcleaner: nosqlcleaner.length\n\t};\n\n\toutput.routing = {\n\t\twebpage: F.routes.web.length,\n\t\tsitemap: F.routes.sitemap ? Object.keys(F.routes.sitemap).length : 0,\n\t\twebsocket: F.routes.websockets.length,\n\t\tfile: F.routes.files.length,\n\t\tmiddleware: Object.keys(F.routes.middleware).length,\n\t\tredirect: redirects.length\n\t};\n\n\toutput.stats = F.stats;\n\toutput.redirects = redirects;\n\n\tif (!detailed)\n\t\treturn output;\n\n\toutput.controllers = [];\n\tfor (var i = 0, length = controllers.length; i < length; i++) {\n\t\tvar key = controllers[i];\n\t\tvar item = F.controllers[key];\n\t\toutput.controllers.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.connections = [];\n\tfor (var i = 0, length = connections.length; i < length; i++) {\n\t\tvar key = connections[i];\n\t\toutput.connections.push({ name: key, online: F.connections[key].online });\n\t}\n\n\toutput.modules = [];\n\tfor (var i = 0, length = modules.length; i < length; i++) {\n\t\tvar key = modules[i];\n\t\tvar item = F.modules[key];\n\t\toutput.modules.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.models = [];\n\tfor (var i = 0, length = models.length; i < length; i++) {\n\t\tvar key = models[i];\n\t\tvar item = F.models[key];\n\t\toutput.models.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.cache = cache;\n\toutput.changes = F.changes;\n\toutput.errors = F.errors;\n\toutput.files = staticFiles;\n\toutput.helpers = helpers;\n\toutput.nosqlcleaner = nosqlcleaner;\n\toutput.other = Object.keys(F.temporary.other);\n\toutput.problems = F.problems;\n\toutput.resources = resources;\n\toutput.streaming = staticRange;\n\toutput.traces = F.traces;\n\toutput.uptodates = F.uptodates;\n\n\treturn output;\n};\n\n/**\n * Compiles content in the view @{compile}...@{end}. The function has controller context, this === controler.\n * @param {String} name\n * @param {String} html HTML content to compile\n * @param {Object} model\n * @return {String}\n */\n// name, html, model\nF.onCompileView = function(name, html) {\n\treturn html;\n};\n\n/*\n\t3rd CSS compiler (Sync)\n\t@filename {String}\n\t@content {String} :: Content of CSS file\n\treturn {String}\n*/\nF.onCompileStyle = null;\n\n/*\n\t3rd JavaScript compiler (Sync)\n\t@filename {String}\n\t@content {String} :: Content of JavaScript file\n\treturn {String}\n*/\nF.onCompileScript = null;\n\nfunction compile_file(res) {\n\tfsFileRead(res.options.filename, function(err, buffer) {\n\n\t\tvar req = res.req;\n\t\tvar uri = req.uri;\n\n\t\tif (err) {\n\t\t\tF.error(err, res.options.filename, uri);\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t\treturn;\n\t\t}\n\n\t\tvar file = F.path.temp((F.id ? 'i-' + F.id + '_' : '') + createTemporaryKey(uri.pathname));\n\t\tF.path.verify('temp');\n\t\tFs.writeFileSync(file, compile_content(req.extension, framework_internal.parseBlock(F.routes.blocks[uri.pathname], buffer.toString(ENCODING)), res.options.filename), ENCODING);\n\t\tvar stats = Fs.statSync(file);\n\t\tvar tmp = [file, stats.size, stats.mtime.toUTCString()];\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t});\n\t});\n}\n\nfunction compile_merge(res) {\n\n\tvar req = res.req;\n\tvar uri = req.uri;\n\n\tvar merge = F.routes.merge[uri.pathname];\n\tvar filename = merge.filename;\n\n\tif (!DEBUG && existsSync(filename)) {\n\t\tvar stats = Fs.statSync(filename);\n\t\tvar tmp = [filename, stats.size, stats.mtime.toUTCString()];\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tres.$file();\n\t\t});\n\t\treturn;\n\t}\n\n\tvar writer = Fs.createWriteStream(filename);\n\n\twriter.on('finish', function() {\n\t\tvar stats = Fs.statSync(filename);\n\t\tvar tmp = [filename, stats.size, stats.mtime.toUTCString()];\n\t\tthis.destroy && this.destroy();\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t});\n\t});\n\n\tvar index = 0;\n\tvar remove = null;\n\n\tmerge.files.wait(function(filename, next) {\n\n\t\tvar block;\n\n\t\t// Skip isomorphic\n\t\tif (filename[0] !== '#') {\n\t\t\tvar blocks = filename.split('#');\n\t\t\tblock = blocks[1];\n\t\t\tblock && (filename = blocks[0]);\n\t\t}\n\n\t\tif (filename.startsWith('http://') || filename.startsWith('https://')) {\n\t\t\tU.request(filename, FLAGS_DOWNLOAD, function(err, data) {\n\n\t\t\t\tvar output = compile_content(req.extension, framework_internal.parseBlock(block, data), filename);\n\n\t\t\t\tif (req.extension === 'js') {\n\t\t\t\t\tif (output[output.length - 1] !== ';')\n\t\t\t\t\t\toutput += ';';\n\t\t\t\t} else if (req.extension === 'html') {\n\t\t\t\t\tif (output[output.length - 1] !== NEWLINE)\n\t\t\t\t\t\toutput += NEWLINE;\n\t\t\t\t}\n\n\t\t\t\tDEBUG && merge_debug_writer(writer, filename, req.extension, index++, block);\n\t\t\t\twriter.write(output);\n\t\t\t\tnext();\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tif (filename[0] !== '~') {\n\t\t\tvar tmp = F.path.public(filename);\n\t\t\tif (F.isVirtualDirectory && !existsSync(tmp))\n\t\t\t\ttmp = F.path.virtual(filename);\n\t\t\tfilename = tmp;\n\t\t} else\n\t\t\tfilename = filename.substring(1);\n\n\t\tvar indexer = filename.indexOf('*');\n\t\tif (indexer !== -1) {\n\n\t\t\tvar tmp = filename.substring(indexer + 1).toLowerCase();\n\t\t\tvar len = tmp.length;\n\t\t\t!remove && (remove = []);\n\n\t\t\t// Remove directory for all future requests\n\t\t\tremove.push(arguments[0]);\n\n\t\t\tU.ls(filename.substring(0, indexer), function(files) {\n\t\t\t\tfor (var j = 0, l = files.length; j < l; j++)\n\t\t\t\t\tmerge.files.push('~' + files[j]);\n\t\t\t\tnext();\n\t\t\t}, (path, isDirectory) => isDirectory ? true : path.substring(path.length - len).toLowerCase() === tmp);\n\t\t\treturn;\n\t\t}\n\n\t\tfsFileRead(filename, function(err, buffer) {\n\n\t\t\tif (err) {\n\t\t\t\tF.error(err, merge.filename, uri);\n\t\t\t\tnext();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar output = compile_content(req.extension, framework_internal.parseBlock(block, buffer.toString(ENCODING)), filename);\n\t\t\tif (req.extension === 'js') {\n\t\t\t\tif (output[output.length - 1] !== ';')\n\t\t\t\t\toutput += ';' + NEWLINE;\n\t\t\t} else if (req.extension === 'html') {\n\t\t\t\tif (output[output.length - 1] !== NEWLINE)\n\t\t\t\t\toutput += NEWLINE;\n\t\t\t}\n\n\t\t\tDEBUG && merge_debug_writer(writer, filename, req.extension, index++, block);\n\t\t\twriter.write(output);\n\t\t\tnext();\n\t\t});\n\n\t}, function() {\n\n\t\twriter.end();\n\n\t\t// Removes all directories from merge list (because the files are added into the queue)\n\t\tif (remove) {\n\t\t\tfor (var i = 0, length = remove.length; i < length; i++)\n\t\t\t\tmerge.files.splice(merge.files.indexOf(remove[i]), 1);\n\t\t}\n\t});\n\n\treturn F;\n}\n\nfunction merge_debug_writer(writer, filename, extension, index, block) {\n\tvar plus = '===========================================================================================';\n\tvar beg = extension === 'js' ? '/*\\n' : extension === 'css' ? '/*!\\n' : '<!--\\n';\n\tvar end = extension === 'js' || extension === 'css' ? '\\n */' : '\\n-->';\n\tvar mid = extension !== 'html' ? ' * ' : ' ';\n\twriter.write((index > 0 ? '\\n\\n' : '') + beg + mid + plus + '\\n' + mid + 'MERGED: ' + filename + '\\n' + (block ? mid + 'BLOCKS: ' + block + '\\n' : '') + mid + plus + end + '\\n\\n', ENCODING);\n}\n\nfunction component_debug(filename, value, extension) {\n\tvar plus = '===========================================================================================';\n\tvar beg = extension === 'js' ? '/*\\n' : extension === 'css' ? '/*!\\n' : '<!--\\n';\n\tvar end = extension === 'js' || extension === 'css' ? '\\n */' : '\\n-->';\n\tvar mid = extension !== 'html' ? ' * ' : ' ';\n\treturn beg + mid + plus + '\\n' + mid + 'COMPONENT: ' + filename + '\\n' + mid + plus + end + '\\n\\n' + value;\n}\n\nF.compile_virtual = function(res) {\n\n\tvar req = res.req;\n\tvar tmpname = res.options.filename.replace(CONF.directory_public, CONF.directory_public_virtual);\n\n\tif (tmpname === res.options.filename) {\n\t\tF.temporary.notfound[req.$key] = true;\n\t\tdelete F.temporary.processing[req.$key];\n\t\tres.$file();\n\t\treturn;\n\t}\n\n\tfsFileExists(tmpname, function(e, size, sfile, stats) {\n\n\t\tif (!e) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!res.noCompress && COMPRESSIONSPECIAL[req.extension] && CONF.allow_compile && !REG_NOCOMPRESS.test(res.options.filename)) {\n\t\t\tres.options.filename = tmpname;\n\t\t\treturn compile_file(res);\n\t\t}\n\n\t\tvar tmp = [tmpname, size, stats.mtime.toUTCString()];\n\t\tif (CONF.allow_gzip && COMPRESSION[U.getContentType(req.extension)]) {\n\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\tres.$file();\n\t\t\t});\n\t\t} else {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t}\n\t});\n\n\treturn;\n};\n\nfunction compile_check(res) {\n\n\tvar req = res.req;\n\tvar uri = req.uri;\n\n\tif (F.routes.merge[uri.pathname]) {\n\t\tcompile_merge(res);\n\t\treturn F;\n\t}\n\n\tfsFileExists(res.options.filename, function(e, size, sfile, stats) {\n\n\t\tif (e) {\n\n\t\t\tif (!res.noCompress && COMPRESSIONSPECIAL[req.extension] && CONF.allow_compile && !REG_NOCOMPRESS.test(res.options.filename))\n\t\t\t\treturn compile_file(res);\n\n\t\t\tvar tmp = [res.options.filename, size, stats.mtime.toUTCString()];\n\t\t\tif (CONF.allow_gzip && COMPRESSION[U.getContentType(req.extension)]) {\n\t\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\t\tres.$file();\n\t\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tres.$file();\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t}\n\n\t\t} else if (F.isVirtualDirectory)\n\t\t\tF.compile_virtual(res);\n\t\telse {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction compile_gzip(arr, callback) {\n\n\t// GZIP compression\n\n\tvar filename = F.path.temp('file' + arr[0].hash().toString().replace('-', '0') + '.gz');\n\tarr.push(filename);\n\n\tvar reader = Fs.createReadStream(arr[0]);\n\tvar writer = Fs.createWriteStream(filename);\n\n\tCLEANUP(writer, function() {\n\t\tfsFileExists(filename, function(e, size) {\n\t\t\tarr.push(size);\n\t\t\tcallback(arr);\n\t\t});\n\t});\n\n\treader.pipe(Zlib.createGzip(GZIPFILE)).pipe(writer);\n\tCLEANUP(reader);\n}\n\nfunction compile_content(extension, content, filename) {\n\n\tif (filename && REG_NOCOMPRESS.test(filename))\n\t\treturn content;\n\n\tswitch (extension) {\n\t\tcase 'js':\n\t\t\treturn CONF.allow_compile_script ? framework_internal.compile_javascript(content, filename) : content;\n\n\t\tcase 'css':\n\t\t\tcontent = CONF.allow_compile_style ? framework_internal.compile_css(content, filename) : content;\n\t\t\tvar matches = content.match(REG_COMPILECSS);\n\t\t\tif (matches) {\n\t\t\t\tfor (var i = 0, length = matches.length; i < length; i++) {\n\t\t\t\t\tvar key = matches[i];\n\t\t\t\t\tvar url = key.substring(4, key.length - 1);\n\t\t\t\t\tcontent = content.replace(key, 'url(' + F.$version(url, true) + ')');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn content;\n\t}\n\n\treturn content;\n}\n\nF.restore = function(filename, target, callback, filter) {\n\n\tvar buffer_key = U.createBuffer(':');\n\tvar buffer_new = U.createBuffer('\\n');\n\tvar buffer_dir = U.createBuffer('#');\n\tvar cache = {};\n\tvar data = null;\n\tvar type = 0;\n\tvar item = null;\n\tvar stream = Fs.createReadStream(filename);\n\tvar index = 0;\n\tvar parser = {};\n\tvar open = {};\n\tvar pending = 0;\n\tvar end = false;\n\tvar output = {};\n\n\toutput.count = 0;\n\toutput.path = target;\n\n\tparser.parse_key = function() {\n\n\t\tindex = data.indexOf(buffer_key);\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tindex++;\n\t\titem = data.slice(0, index - 1).toString('utf8').trim();\n\t\tdata = data.slice(index);\n\t\ttype = 1;\n\t\tparser.next();\n\t};\n\n\tparser.parse_meta = function() {\n\t\tvar path = Path.join(target, item);\n\n\t\t// Is directory?\n\t\tif (data[0] === buffer_dir[0]) {\n\t\t\tif (!cache[path]) {\n\t\t\t\tcache[path] = true;\n\t\t\t\tif (!filter || filter(item, true) !== false)\n\t\t\t\t\tF.path.mkdir(path);\n\t\t\t}\n\t\t\ttype = 3;\n\t\t\tparser.next();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!cache[path]) {\n\t\t\tcache[path] = true;\n\n\t\t\tvar npath = path.substring(0, path.lastIndexOf(F.isWindows ? '\\\\' : '/'));\n\n\t\t\tvar filename = filter && filter(item, false);\n\n\t\t\tif (!filter || filename || filename == null)\n\t\t\t\tF.path.mkdir(npath);\n\t\t\telse {\n\t\t\t\ttype = 5; // skip\n\t\t\t\tparser.next();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(filename) === 'string')\n\t\t\tpath = Path.join(target, filename);\n\n\t\t// File\n\t\ttype = 2;\n\t\tvar tmp = open[item] = {};\n\t\ttmp.path = path;\n\t\ttmp.name = item;\n\t\ttmp.writer = Fs.createWriteStream(path);\n\t\ttmp.zlib = Zlib.createGunzip();\n\t\ttmp.zlib.$self = tmp;\n\t\tpending++;\n\n\t\toutput.count++;\n\n\t\ttmp.zlib.on('error', function(e) {\n\t\t\tpending--;\n\t\t\tvar tmp = this.$self;\n\t\t\ttmp.writer.end();\n\t\t\ttmp.writer = null;\n\t\t\ttmp.zlib = null;\n\t\t\tdelete open[tmp.name];\n\t\t\tF.error(e, 'bundling', path);\n\t\t});\n\n\t\ttmp.zlib.on('data', function(chunk) {\n\t\t\tthis.$self.writer.write(chunk);\n\t\t});\n\n\t\ttmp.zlib.on('end', function() {\n\t\t\tpending--;\n\t\t\tvar tmp = this.$self;\n\t\t\ttmp.writer.end();\n\t\t\ttmp.writer = null;\n\t\t\ttmp.zlib = null;\n\t\t\tdelete open[tmp.name];\n\t\t});\n\n\t\tparser.next();\n\t};\n\n\tparser.parse_dir = function() {\n\t\tindex = data.indexOf(buffer_new);\n\t\tif (index !== -1) {\n\t\t\tdata = data.slice(index + 1);\n\t\t\ttype = 0;\n\t\t}\n\t\tparser.next();\n\t};\n\n\tparser.parse_data = function() {\n\n\t\tindex = data.indexOf(buffer_new);\n\n\t\tvar skip = false;\n\n\t\tif (index !== -1)\n\t\t\ttype = 0;\n\n\t\tif (type) {\n\t\t\tvar remaining = data.length % 4;\n\t\t\tif (remaining) {\n\t\t\t\topen[item].zlib.write(U.createBuffer(data.slice(0, data.length - remaining).toString('ascii'), 'base64'));\n\t\t\t\tdata = data.slice(data.length - remaining);\n\t\t\t\tskip = true;\n\t\t\t} else {\n\t\t\t\topen[item].zlib.write(U.createBuffer(data.toString('ascii'), 'base64'));\n\t\t\t\tdata = null;\n\t\t\t}\n\t\t} else {\n\t\t\topen[item].zlib.end(U.createBuffer(data.slice(0, index).toString('ascii'), 'base64'));\n\t\t\tdata = data.slice(index + 1);\n\t\t}\n\n\t\t!skip && data && data.length && parser.next();\n\t};\n\n\tparser.next = function() {\n\t\tswitch (type) {\n\t\t\tcase 0:\n\t\t\t\tparser.parse_key();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tparser.parse_meta();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparser.parse_data();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tparser.parse_dir();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tindex = data.indexOf(buffer_new);\n\t\t\t\tif (index === -1)\n\t\t\t\t\tdata = null;\n\t\t\t\telse {\n\t\t\t\t\tdata = data.slice(index + 1);\n\t\t\t\t\ttype = 0;\n\t\t\t\t\tparser.next();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tend && !data.length && callback && callback(null, output);\n\t};\n\n\tparser.end = function() {\n\t\tif (callback) {\n\t\t\tif (pending)\n\t\t\t\tsetTimeout(parser.end, 100);\n\t\t\telse if (end && !data.length)\n\t\t\t\tcallback(null, output);\n\t\t}\n\t};\n\n\tstream.on('data', function(chunk) {\n\n\t\tif (data) {\n\t\t\tCONCAT[0] = data;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tdata = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tdata = chunk;\n\n\t\tparser.next();\n\t});\n\n\tCLEANUP(stream, function() {\n\t\tend = true;\n\t\tparser.end();\n\t});\n\n\treturn F;\n};\n\nF.backup = function(filename, filelist, callback, filter) {\n\n\tvar padding = 100;\n\tvar path = filelist instanceof Array ? F.path.root() : filelist;\n\n\tif (!(filelist instanceof Array))\n\t\tfilelist = [''];\n\n\tvar counter = 0;\n\n\tFs.unlink(filename, function() {\n\n\t\tfilelist.sort(function(a, b) {\n\t\t\tvar ac = a.split('/');\n\t\t\tvar bc = b.split('/');\n\t\t\tif (ac.length < bc.length)\n\t\t\t\treturn -1;\n\t\t\telse if (ac.length > bc.length)\n\t\t\t\treturn 1;\n\t\t\treturn a.localeCompare(b);\n\t\t});\n\n\t\tvar writer = Fs.createWriteStream(filename);\n\n\t\twriter.on('finish', function() {\n\t\t\tcallback && Fs.stat(filename, (e, stat) => callback(null, { filename: filename, files: counter, size: stat.size }));\n\t\t});\n\n\t\tfilelist.wait(function(item, next) {\n\n\t\t\tvar file = Path.join(path, item);\n\n\t\t\tif (F.isWindows)\n\t\t\t\titem = item.replace(/\\\\/g, '/');\n\n\t\t\tif (item[0] !== '/')\n\t\t\t\titem = '/' + item;\n\n\t\t\tFs.stat(file, function(err, stats) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'F.backup()', filename);\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tvar dir = item.replace(/\\\\/g, '/') + '/';\n\t\t\t\t\tif (filter && !filter(dir, true))\n\t\t\t\t\t\treturn next();\n\t\t\t\t\tU.ls(file, function(f, d) {\n\t\t\t\t\t\tvar length = path.length;\n\t\t\t\t\t\td.wait(function(item, next) {\n\t\t\t\t\t\t\twriter.write(item.substring(length).padRight(padding) + ':#\\n', 'utf8');\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}, function() {\n\t\t\t\t\t\t\tfor (var i = 0; i < f.length; i++)\n\t\t\t\t\t\t\t\tfilelist.push(f[i].substring(length));\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar data = U.createBufferSize(0);\n\t\t\t\twriter.write(item.padRight(padding) + ':');\n\t\t\t\tFs.createReadStream(file).pipe(Zlib.createGzip(GZIPFILE)).on('data', function(chunk) {\n\n\t\t\t\t\tCONCAT[0] = data;\n\t\t\t\t\tCONCAT[1] = chunk;\n\t\t\t\t\tdata = Buffer.concat(CONCAT);\n\n\t\t\t\t\tvar remaining = data.length % 3;\n\t\t\t\t\tif (remaining) {\n\t\t\t\t\t\twriter.write(data.slice(0, data.length - remaining).toString('base64'));\n\t\t\t\t\t\tdata = data.slice(data.length - remaining);\n\t\t\t\t\t}\n\n\t\t\t\t}).on('end', function() {\n\t\t\t\t\tdata.length && writer.write(data.toString('base64'));\n\t\t\t\t\twriter.write('\\n', 'utf8');\n\t\t\t\t\tcounter++;\n\t\t\t\t\tsetImmediate(next);\n\t\t\t\t});\n\n\t\t\t});\n\t\t}, () => writer.end());\n\t});\n\n\treturn F;\n};\n\nF.exists = function(req, res, max, callback) {\n\n\tif (typeof(max) === 'function') {\n\t\tcallback = max;\n\t\tmax = 10;\n\t}\n\n\tvar name = req.$key = createTemporaryKey(req);\n\tvar filename = F.path.temp(name);\n\tvar httpcachevalid = RELEASE && (req.headers['if-none-match'] === (ETAG + CONF.etag_version));\n\n\tif (F.isProcessed(name) || httpcachevalid) {\n\t\tres.options.filename = filename;\n\t\tres.$file();\n\t\treturn F;\n\t}\n\n\tU.queue('F.exists', max, function(next) {\n\t\tfsFileExists(filename, function(e) {\n\t\t\tif (e) {\n\t\t\t\tres.options.filename = filename;\n\t\t\t\tres.options.callback = next;\n\t\t\t\tres.$file();\n\t\t\t} else\n\t\t\t\tcallback(next, filename, req, res);\n\t\t});\n\t});\n\n\treturn F;\n};\n\n/**\n * Is processed static file?\n * @param {String / Request} filename Filename or Request object.\n * @return {Boolean}\n */\nF.isProcessed = function(filename) {\n\n\tif (filename.url) {\n\t\tvar name = filename.url;\n\t\tvar index = name.indexOf('?');\n\t\tif (index !== -1)\n\t\t\tname = name.substring(0, index);\n\t\tfilename = F.path.public($decodeURIComponent(name));\n\t}\n\n\treturn !F.temporary.notfound[filename] && F.temporary.path[filename] !== undefined;\n};\n\n/**\n * Processing\n * @param {String / Request} filename Filename or Request object.\n * @return {Boolean}\n */\nF.isProcessing = function(filename) {\n\n\tif (!filename.url)\n\t\treturn !!F.temporary.processing[filename];\n\n\tvar name = filename.url;\n\tvar index = name.indexOf('?');\n\n\tif (index !== -1)\n\t\tname = name.substring(0, index);\n\n\tfilename = U.combine(CONF.directory_public, $decodeURIComponent(name));\n\treturn !!F.temporary.processing[filename];\n};\n\n/**\n * Clears file information in release mode\n * @param {String/Request} url\n * @return {Framework}\n */\nF.touch = function(url) {\n\tif (url) {\n\t\tvar key = createTemporaryKey(url);\n\t\tdelete F.temporary.path[key];\n\t\tdelete F.temporary.notfound[key];\n\t} else {\n\t\tF.temporary.path = {};\n\t\tF.temporary.notfound = {};\n\t}\n\treturn F;\n};\n\n// OBSOLETE\nF.responseImage = function(req, res, filename, make, headers, done) {\n\tOBSOLETE('F.responseImage()', 'This method is obsolete, use res.img()');\n\n\tif (typeof(filename) === 'object')\n\t\tres.options.stream = filename;\n\telse\n\t\tres.options.filename = filename;\n\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\tres.options.make = make;\n\tres.$image();\n\treturn F;\n};\n\n// OBSOLETE\nF.responseFile = function(req, res, filename, downloadName, headers, done, key) {\n\tOBSOLETE('F.responseFile()', 'This method is obsolete, use res.file()');\n\tres.$key = key;\n\tres.options.filename = filename;\n\tres.options.download = downloadName;\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\tres.$file();\n\treturn F;\n};\n\nF.response503 = function(req, res) {\n\tres.options.code = 503;\n\tres.options.headers = HEADERS.response503;\n\tres.options.body = F.view('.' + PATHMODULES + '503', F.waits);\n\tres.$text();\n\treturn F;\n};\n\nglobal.LOAD = F.load = function(debug, types, pwd) {\n\n\tif (pwd && pwd[0] === '.' && pwd.length < 4)\n\t\tF.directory = directory = U.$normalize(Path.normalize(directory + '/..'));\n\telse if (pwd)\n\t\tF.directory = directory = U.$normalize(pwd);\n\n\tif (typeof(debug) === 'string') {\n\t\tswitch (debug.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\t\tcase 'release':\n\t\t\tcase 'production':\n\t\t\t\tdebug = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'debug':\n\t\t\tcase 'develop':\n\t\t\tcase 'development':\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'test-debug':\n\t\t\tcase 'debug-test':\n\t\t\tcase 'testing-debug':\n\t\t\t\tdebug = true;\n\t\t\t\tF.isTest = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'test':\n\t\t\tcase 'testing':\n\t\t\tcase 'test-release':\n\t\t\tcase 'release-test':\n\t\t\tcase 'testing-release':\n\t\t\tcase 'test-production':\n\t\t\tcase 'testing-production':\n\t\t\t\tdebug = false;\n\t\t\t\tF.isTest = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tF.isWorker = true;\n\tF.isDebug = debug;\n\n\tglobal.DEBUG = debug;\n\tglobal.RELEASE = !debug;\n\tglobal.I = global.isomorphic = F.isomorphic;\n\n\tF.$bundle(function() {\n\t\tF.consoledebug('startup');\n\t\tF.$startup(function() {\n\n\t\t\tF.consoledebug('startup (done)');\n\t\t\tF.$configure_configs();\n\n\t\t\tif (!types || types.indexOf('versions') !== -1)\n\t\t\t\tF.$configure_versions();\n\n\t\t\tif (!types || types.indexOf('workflows') !== -1)\n\t\t\t\tF.$configure_workflows();\n\n\t\t\tif (!types || types.indexOf('sitemap') !== -1)\n\t\t\t\tF.$configure_sitemap();\n\n\t\t\tF.consoledebug('init');\n\t\t\tF.cache.init();\n\t\t\tEMIT('init');\n\n\t\t\tF.$load(types, directory, function() {\n\n\t\t\t\tF.isLoaded = true;\n\t\t\t\tprocess.send && process.send('total:ready');\n\n\t\t\t\tsetTimeout(function() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tEMIT('load', F);\n\t\t\t\t\t\tEMIT('ready', F);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tF.error(err, 'F.on(\"load/ready\")');\n\t\t\t\t\t}\n\n\t\t\t\t\tF.removeAllListeners('load');\n\t\t\t\t\tF.removeAllListeners('ready');\n\n\t\t\t\t\tif (F.isTest) {\n\t\t\t\t\t\tF.console();\n\t\t\t\t\t\tF.test();\n\t\t\t\t\t\treturn F;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tif (!F.isTest)\n\t\t\t\t\t\t\tdelete F.test;\n\t\t\t\t\t}, 5000);\n\n\t\t\t\t}, 500);\n\n\t\t\t\tif (CONF.allow_debug) {\n\t\t\t\t\tF.consoledebug('done');\n\t\t\t\t\tF.usagesnapshot();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}, !types || types.indexOf('bundles') !== -1);\n\n\treturn F;\n};\n\n/**\n * Initialize framework\n * @param  {Object} http\n * @param  {Boolean} debug\n * @param  {Object} options\n * @return {Framework}\n */\nF.initialize = function(http, debug, options) {\n\n\tif (!options)\n\t\toptions = {};\n\n\tvar port = options.port;\n\tvar ip = options.ip;\n\tvar listenpath = options.listenpath;\n\n\toptions.config && U.extend_headers2(CONF, options.config);\n\n\tif (options.debug || options['allow-debug'] || options.allow_debug)\n\t\tCONF.allow_debug = true;\n\n\tF.isHTTPS = http.STATUS_CODES === undefined;\n\n\tif (isNaN(port) && typeof(port) !== 'string')\n\t\tport = null;\n\n\tif (options.id)\n\t\tF.id = options.id;\n\n\tF.isDebug = debug;\n\n\tif (options.bundling != null)\n\t\tF.$bundling = options.bundling == true;\n\n\tglobal.DEBUG = debug;\n\tglobal.RELEASE = !debug;\n\tglobal.I = global.isomorphic = F.isomorphic;\n\n\tif (options.tests) {\n\t\tF.testlist = options.tests;\n\t\tfor (var i = 0; i < F.testlist.length; i++)\n\t\t\tF.testlist[i] = F.testlist[i].replace(/\\.js$/, '');\n\t}\n\n\tF.$bundle(function() {\n\n\t\tF.$configure_configs();\n\t\tF.$configure_versions();\n\t\tF.$configure_workflows();\n\t\tF.$configure_sitemap();\n\t\tF.isTest && F.$configure_configs('config-test', true);\n\t\tF.cache.init();\n\t\tF.consoledebug('init');\n\t\tEMIT('init');\n\n\t\tif (!port) {\n\t\t\tif (CONF.default_port === 'auto') {\n\t\t\t\tvar envPort = +(process.env.PORT || '');\n\t\t\t\tif (!isNaN(envPort))\n\t\t\t\t\tport = envPort;\n\t\t\t} else\n\t\t\t\tport = CONF.default_port;\n\t\t}\n\n\t\tF.port = port || 8000;\n\n\t\tif (ip !== null) {\n\t\t\tF.ip = ip || CONF.default_ip || '0.0.0.0';\n\t\t\tif (F.ip === 'null' || F.ip === 'undefined' || F.ip === 'auto')\n\t\t\t\tF.ip = null;\n\t\t} else\n\t\t\tF.ip = undefined;\n\n\t\tif (F.ip == null)\n\t\t\tF.ip = '0.0.0.0';\n\n\t\t!listenpath && (listenpath = CONF.default_listenpath);\n\t\tF.listenpath = listenpath;\n\n\t\tif (F.server) {\n\t\t\tF.server.removeAllListeners();\n\t\t\tObject.keys(F.connections).forEach(function(key) {\n\t\t\t\tvar item = F.connections[key];\n\t\t\t\tif (item) {\n\t\t\t\t\titem.removeAllListeners();\n\t\t\t\t\titem.close();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tF.server.close();\n\t\t}\n\n\t\tvar listen = function() {\n\n\t\t\tif (options.https) {\n\n\t\t\t\tvar meta = options.https;\n\n\t\t\t\tif (typeof(meta.key) === 'string') {\n\t\t\t\t\tif (meta.key.indexOf('.') === -1)\n\t\t\t\t\t\tmeta.key = U.createBuffer(meta.key, 'base64');\n\t\t\t\t\telse\n\t\t\t\t\t\tmeta.key = Fs.readFileSync(meta.key);\n\t\t\t\t}\n\n\t\t\t\tif (typeof(meta.cert) === 'string') {\n\t\t\t\t\tif (meta.cert.indexOf('.') === -1)\n\t\t\t\t\t\tmeta.cert = U.createBuffer(meta.cert, 'base64');\n\t\t\t\t\telse\n\t\t\t\t\t\tmeta.cert = Fs.readFileSync(meta.cert);\n\t\t\t\t}\n\n\t\t\t\tF.server = http.createServer(meta, F.listener);\n\n\t\t\t} else\n\t\t\t\tF.server = http.createServer(F.listener);\n\n\t\t\tCONF.allow_performance && F.server.on('connection', connection_tunning);\n\t\t\tF.initwebsocket && F.initwebsocket();\n\t\t\tF.consoledebug('HTTP listening');\n\n\t\t\tif (listenpath)\n\t\t\t\tF.server.listen(listenpath);\n\t\t\telse\n\t\t\t\tF.server.listen(F.port, F.ip);\n\t\t};\n\n\t\t// clears static files\n\t\tF.consoledebug('clear temporary');\n\t\tF.clear(function() {\n\n\t\t\tF.consoledebug('clear temporary (done)');\n\t\t\tF.$load(undefined, directory, function() {\n\n\t\t\t\tF.isLoaded = true;\n\t\t\t\tprocess.send && process.send('total:ready');\n\n\t\t\t\tif (options.middleware)\n\t\t\t\t\toptions.middleware(listen);\n\t\t\t\telse\n\t\t\t\t\tlisten();\n\n\t\t\t\tif (CONF.allow_debug) {\n\t\t\t\t\tF.consoledebug('done');\n\t\t\t\t\tF.usagesnapshot();\n\t\t\t\t}\n\n\t\t\t\tif (!process.connected)\n\t\t\t\t\tF.console();\n\n\t\t\t\tsetTimeout(function() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tEMIT('load', F);\n\t\t\t\t\t\tEMIT('ready', F);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tF.error(err, 'F.on(\"load/ready\")');\n\t\t\t\t\t}\n\n\t\t\t\t\tF.removeAllListeners('load');\n\t\t\t\t\tF.removeAllListeners('ready');\n\t\t\t\t\toptions.package && INSTALL('package', options.package);\n\t\t\t\t}, 500);\n\n\t\t\t\tif (F.isTest) {\n\t\t\t\t\tvar sleep = options.sleep || options.delay || 1000;\n\t\t\t\t\tsetTimeout(F.test, sleep);\n\t\t\t\t\treturn F;\n\t\t\t\t}\n\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif (!F.isTest)\n\t\t\t\t\t\tdelete F.test;\n\t\t\t\t}, 5000);\n\t\t\t});\n\t\t}, true);\n\t});\n\n\treturn F;\n};\n\nfunction connection_tunning(socket) {\n\tsocket.setNoDelay(true);\n\tsocket.setKeepAlive(true, 10);\n}\n\n/**\n * Run framework \u2013> HTTP\n * @param  {String} mode Framework mode.\n * @param  {Object} options Framework settings.\n * @param {Function(listen)} middleware A middleware for manual calling of HTTP listener\n * @return {Framework}\n */\nF.http = function(mode, options, middleware) {\n\tF.consoledebug('begin');\n\n\tif (typeof(options) === 'function') {\n\t\tmiddleware = options;\n\t\toptions = null;\n\t}\n\n\toptions == null && (options = {});\n\t!options.port && (options.port = +process.argv[2]);\n\n\tif (options.port && isNaN(options.port))\n\t\toptions.port = 0;\n\n\tif (typeof(middleware) === 'function')\n\t\toptions.middleware = middleware;\n\n\tif (options.bundling != null)\n\t\tF.$bundling = options.bundling;\n\n\tvar http = require('http');\n\textend_request(http.IncomingMessage.prototype);\n\textend_response(http.ServerResponse.prototype);\n\treturn F.mode(http, mode, options);\n};\n\n/**\n * Run framework \u2013> HTTPS\n * @param {String} mode Framework mode.\n * @param {Object} options Framework settings.\n * @param {Function(listen)} middleware A middleware for manual calling of HTTP listener\n * @return {Framework}\n */\nF.https = function(mode, options, middleware) {\n\tF.consoledebug('begin');\n\tvar http = require('http');\n\n\tif (typeof(options) === 'function') {\n\t\tmiddleware = options;\n\t\toptions = null;\n\t}\n\n\toptions == null && (options = {});\n\t!options.port && (options.port = +process.argv[2]);\n\n\tif (options.port && isNaN(options.port))\n\t\toptions.port = 0;\n\n\tif (typeof(middleware) === 'function')\n\t\toptions.middleware = middleware;\n\n\textend_request(http.IncomingMessage.prototype);\n\textend_response(http.ServerResponse.prototype);\n\treturn F.mode(require('https'), mode, options);\n};\n\nF.mode = function(http, name, options) {\n\n\tvar debug = false;\n\n\tif (options.directory)\n\t\tF.directory = directory = options.directory;\n\n\tif (typeof(http) === 'string') {\n\t\tswitch (http) {\n\t\t\tcase 'debug':\n\t\t\tcase 'development':\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\t\t}\n\t\tDEBUG = debug;\n\t\tCONF.trace = debug;\n\t\tF.isDebug = debug;\n\t\tglobal.DEBUG = debug;\n\t\tglobal.RELEASE = !debug;\n\t\treturn F;\n\t}\n\n\tF.isWorker = false;\n\n\tswitch (name.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\tcase 'release':\n\t\tcase 'production':\n\t\t\tbreak;\n\n\t\tcase 'debug':\n\t\tcase 'develop':\n\t\tcase 'development':\n\t\t\tdebug = true;\n\t\t\tbreak;\n\n\t\tcase 'test-debug':\n\t\tcase 'debug-test':\n\t\tcase 'testing-debug':\n\t\t\tdebug = true;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\n\t\tcase 'test':\n\t\tcase 'testing':\n\t\tcase 'test-release':\n\t\tcase 'release-test':\n\t\tcase 'testing-release':\n\t\tcase 'test-production':\n\t\tcase 'testing-production':\n\t\t\tdebug = false;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\t}\n\n\tCONF.trace = debug;\n\tF.consoledebug('startup');\n\tF.$startup(function() {\n\t\tF.consoledebug('startup (done)');\n\t\tF.initialize(http, debug, options);\n\t});\n\treturn F;\n};\n\nF.custom = function(mode, http, request, response, options) {\n\tvar debug = false;\n\n\tif (options.directory)\n\t\tF.directory = directory = options.directory;\n\n\tF.consoledebug('begin');\n\n\textend_request(request);\n\textend_response(response);\n\n\tswitch (mode.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\tcase 'release':\n\t\tcase 'production':\n\t\t\tbreak;\n\n\t\tcase 'debug':\n\t\tcase 'develop':\n\t\tcase 'development':\n\t\t\tdebug = true;\n\t\t\tbreak;\n\n\t\tcase 'test':\n\t\tcase 'testing':\n\t\tcase 'test-debug':\n\t\tcase 'debug-test':\n\t\tcase 'testing-debug':\n\t\t\tdebug = true;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\n\t\tcase 'test-release':\n\t\tcase 'release-test':\n\t\tcase 'testing-release':\n\t\tcase 'test-production':\n\t\tcase 'testing-production':\n\t\t\tdebug = false;\n\t\t\tbreak;\n\t}\n\n\tCONF.trace = debug;\n\tF.consoledebug('startup');\n\tF.$startup(function() {\n\t\tF.consoledebug('startup (done)');\n\t\tF.initialize(http, debug, options);\n\t});\n\n\treturn F;\n};\n\nF.console = function() {\n\tvar memory = process.memoryUsage();\n\tconsole.log('====================================================');\n\tconsole.log('PID           : ' + process.pid);\n\tconsole.log('Node.js       : ' + process.version);\n\tconsole.log('Total.js      : v' + F.version_header);\n\tconsole.log('OS            : ' + Os.platform() + ' ' + Os.release());\n\tCONF.nosql_worker && console.log('NoSQL PID     : ' + framework_nosql.pid());\n\tconsole.log('Memory        : ' + memory.heapUsed.filesize(2) + ' / ' + memory.heapTotal.filesize(2));\n\tconsole.log('User          : ' + Os.userInfo().username);\n\tconsole.log('====================================================');\n\tconsole.log('Name          : ' + CONF.name);\n\tconsole.log('Version       : ' + CONF.version);\n\tCONF.author && console.log('Author        : ' + CONF.author);\n\tconsole.log('Date          : ' + NOW.format('yyyy-MM-dd HH:mm:ss'));\n\tconsole.log('Mode          : ' + (DEBUG ? 'debug' : 'release'));\n\tconsole.log('====================================================');\n\tconsole.log('Directory     : ' + process.cwd());\n\tconsole.log('node_modules  : ' + PATHMODULES);\n\tconsole.log('====================================================\\n');\n\tif (!F.isWorker) {\n\t\tconsole.log('{2}://{0}:{1}/'.format(F.ip, F.port, F.isHTTPS ? 'https' : 'http'));\n\t\tconsole.log('');\n\t}\n};\n\nF.usagesnapshot = function(filename) {\n\tFs.writeFile(filename || F.path.root('usage' + (F.id ? ('-' + F.id) : '') + '.log'), JSON.stringify(F.usage(true), null, '    '), NOOP);\n\treturn F;\n};\n\nF.consoledebug = function() {\n\n\tif (!CONF.allow_debug)\n\t\treturn F;\n\n\tvar arr = [new Date().format('yyyy-MM-dd HH:mm:ss'), '--------->'];\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tarr.push(arguments[i]);\n\tconsole.log.apply(console, arr);\n\treturn F;\n};\n\n/**\n * Re-connect server\n * @return {Framework}\n */\nF.reconnect = function() {\n\tif (CONF.default_port !== undefined)\n\t\tF.port = CONF.default_port;\n\tif (CONF.default_ip !== undefined)\n\t\tF.ip = CONF.default_ip;\n\tF.server.close(() => F.server.listen(F.port, F.ip));\n\treturn F;\n};\n\n/**\n * Internal service\n * @private\n * @param {Number} count Run count.\n * @return {Framework}\n */\nF.service = function(count) {\n\n\tUIDGENERATOR_REFRESH();\n\n\tvar keys;\n\tvar releasegc = false;\n\n\tif (F.temporary.service.request)\n\t\tF.temporary.service.request++;\n\telse\n\t\tF.temporary.service.request = 1;\n\n\tif (F.temporary.service.file)\n\t\tF.temporary.service.file++;\n\telse\n\t\tF.temporary.service.file = 1;\n\n\tF.stats.performance.request = F.stats.request.request ? F.stats.request.request / F.temporary.service.request : 0;\n\tF.stats.performance.file = F.stats.request.file ? F.stats.request.file / F.temporary.service.file : 0;\n\n\t// clears temporary memory for non-exist files\n\tF.temporary.notfound = {};\n\n\t// every 7 minutes (default) service clears static cache\n\tif (count % CONF.default_interval_clear_cache === 0) {\n\t\tF.$events.clear && EMIT('clear', 'temporary', F.temporary);\n\t\tF.temporary.path = {};\n\t\tF.temporary.range = {};\n\t\tF.temporary.views = {};\n\t\tF.temporary.other = {};\n\t\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\n\t\t// Clears command cache\n\t\tImage.clear();\n\n\t\tvar dt = NOW.add('-5 minutes');\n\t\tfor (var key in F.databases)\n\t\t\tF.databases[key] && F.databases[key].inmemorylastusage < dt && F.databases[key].release();\n\n\t\treleasegc = true;\n\t\tCONF.allow_debug && F.consoledebug('clear temporary cache');\n\n\t\tkeys = Object.keys(F.temporary.internal);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tif (!F.temporary.internal[keys[i]])\n\t\t\t\tdelete F.temporary.internal[keys[i]];\n\t}\n\n\t// every 61 minutes (default) services precompile all (installed) views\n\tif (count % CONF.default_interval_precompile_views === 0) {\n\t\tfor (var key in F.routes.views) {\n\t\t\tvar item = F.routes.views[key];\n\t\t\tF.install('view', key, item.url, null);\n\t\t}\n\t}\n\n\tif (count % CONF.default_interval_clear_dnscache === 0) {\n\t\tF.$events.clear && EMIT('clear', 'dns');\n\t\tU.clearDNS();\n\t\tCONF.allow_debug && F.consoledebug('clear DNS cache');\n\t}\n\n\tvar ping = CONF.default_interval_websocket_ping;\n\tif (ping > 0 && count % ping === 0) {\n\t\tvar has = false;\n\t\tfor (var item in F.connections) {\n\t\t\tvar conn = F.connections[item];\n\t\t\tif (conn) {\n\t\t\t\tconn.check();\n\t\t\t\tconn.ping();\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\thas && CONF.allow_debug && F.consoledebug('ping websocket connections');\n\t}\n\n\tif (F.uptodates && (count % CONF.default_interval_uptodate === 0) && F.uptodates.length) {\n\t\tvar hasUpdate = false;\n\t\tF.uptodates.wait(function(item, next) {\n\n\t\t\tif (item.updated.add(item.interval) > NOW)\n\t\t\t\treturn next();\n\n\t\t\titem.updated = NOW;\n\t\t\titem.count++;\n\n\t\t\tsetTimeout(function() {\n\t\t\t\tCONF.allow_debug && F.consoledebug('uptodate', item.type + '#' + item.url);\n\t\t\t\tF.install(item.type, item.url, item.options, function(err, name, skip) {\n\n\t\t\t\t\tCONF.allow_debug && F.consoledebug('uptodate', item.type + '#' + item.url + ' (done)');\n\n\t\t\t\t\tif (skip)\n\t\t\t\t\t\treturn next();\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\titem.errors.push(err);\n\t\t\t\t\t\titem.errors.length > 50 && F.errors.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thasUpdate = true;\n\t\t\t\t\t\titem.name = name;\n\t\t\t\t\t\tF.$events.uptodate && EMIT('uptodate', item.type, name);\n\t\t\t\t\t}\n\n\t\t\t\t\titem.callback && item.callback(err, name);\n\t\t\t\t\tnext();\n\n\t\t\t\t}, undefined, undefined, undefined, undefined, item.name);\n\n\t\t\t}, item.name ? 500 : 1);\n\n\t\t}, function() {\n\t\t\tif (hasUpdate) {\n\t\t\t\tF.temporary.path = {};\n\t\t\t\tF.temporary.range = {};\n\t\t\t\tF.temporary.views = {};\n\t\t\t\tF.temporary.other = {};\n\t\t\t\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\t\t\t}\n\t\t});\n\t}\n\n\t// every 20 minutes (default) service clears resources\n\tif (count % CONF.default_interval_clear_resources === 0) {\n\t\tF.$events.clear && EMIT('clear', 'resources');\n\t\tF.resources = {};\n\t\treleasegc = true;\n\t\tCONF.allow_debug && F.consoledebug('clear resources');\n\t}\n\n\t// Update expires date\n\tcount % 1000 === 0 && (DATE_EXPIRES = NOW.add('y', 1).toUTCString());\n\n\tif (count % CONF.nosql_cleaner === 0 && CONF.nosql_cleaner) {\n\t\tkeys = Object.keys(F.databasescleaner);\n\t\tkeys.wait(function(item, next) {\n\t\t\tif (item[0] === '$')\n\t\t\t\tTABLE(item.substring(1)).clean(next);\n\t\t\telse\n\t\t\t\tNOSQL(item).clean(next);\n\t\t});\n\t}\n\n\tF.$events.service && EMIT('service', count);\n\n\tif (CONF.allow_debug) {\n\t\tF.consoledebug('service ({0}x)'.format(count));\n\t\tF.usagesnapshot();\n\t}\n\n\treleasegc && global.gc && setTimeout(function() {\n\t\tglobal.gc();\n\t\tCONF.allow_debug && F.consoledebug('gc()');\n\t}, 1000);\n\n\tif (WORKERID > 9999999999)\n\t\tWORKERID = 0;\n\n\t// Run schedules\n\tif (!F.schedules.length)\n\t\treturn F;\n\n\tvar expire = NOW.getTime();\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar schedule = F.schedules[index++];\n\t\tif (!schedule)\n\t\t\tbreak;\n\t\tif (schedule.expire > expire)\n\t\t\tcontinue;\n\n\t\tindex--;\n\n\t\tif (schedule.repeat)\n\t\t\tschedule.expire = NOW.add(schedule.repeat);\n\t\telse\n\t\t\tF.schedules.splice(index, 1);\n\n\t\tCONF.allow_debug && F.consoledebug('schedule', schedule.id);\n\t\tschedule.fn.call(F);\n\t}\n\n\treturn F;\n};\n\n/**\n * Request processing\n * @private\n * @param {Request} req\n * @param {Response} res\n */\nF.listener = function(req, res) {\n\n\treq.options = res.options = {};\n\tres.req = req;\n\treq.res = res;\n\n\tif (F._length_wait)\n\t\treturn F.response503(req, res);\n\telse if (!req.host) // HTTP 1.0 without host\n\t\treturn res.throw400();\n\n\tvar headers = req.headers;\n\treq.$protocol = ((req.connection && req.connection.encrypted) || ((headers['x-forwarded-proto'] || ['x-forwarded-protocol']) === 'https')) ? 'https' : 'http';\n\n\tvar beg = 0;\n\n\t// Removes directory browsing\n\tfor (var i = 0; i < req.url.length; i++) {\n\t\tif (req.url[i] === '.' && req.url[i + 1] === '/')\n\t\t\tbeg = i + 1;\n\t\telse if (req.url[i] === '?')\n\t\t\tbreak;\n\t}\n\n\tif (beg)\n\t\treq.url = req.url.substring(beg);\n\n\treq.uri = framework_internal.parseURI(req);\n\n\tF.stats.request.request++;\n\tF.$events.request && EMIT('request', req, res);\n\n\tif (F._request_check_redirect) {\n\t\tvar redirect = F.routes.redirects[req.$protocol + '://' + req.host];\n\t\tif (redirect) {\n\t\t\tF.stats.response.forward++;\n\t\t\tres.options.url = redirect.url + (redirect.path ? req.url : '');\n\t\t\tres.options.permanent = redirect.permanent;\n\t\t\tres.$redirect();\n\t\t\treturn;\n\t\t}\n\t}\n\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\treq.processing = 0;\n\treq.isAuthorized = true;\n\treq.xhr = headers['x-requested-with'] === 'XMLHttpRequest';\n\tres.success = false;\n\treq.user = req.session = null;\n\treq.isStaticFile = CONF.allow_static_files && U.isStaticFile(req.uri.pathname);\n\n\tif (req.isStaticFile)\n\t\treq.extension = U.getExtension(req.uri.pathname);\n\telse if (F.onLocale)\n\t\treq.$language = F.onLocale(req, res, req.isStaticFile);\n\n\tF.reqstats(true, true);\n\n\tif (F._length_request_middleware)\n\t\tasync_middleware(0, req, res, F.routes.request, requestcontinue_middleware);\n\telse\n\t\tF.$requestcontinue(req, res, headers);\n};\n\nfunction requestcontinue_middleware(req, res)  {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\tF.$requestcontinue(req, res, req.headers);\n}\n\n/**\n * Continue to process\n * @private\n * @param {Request} req\n * @param {Response} res\n * @param {Object} headers\n * @param {String} protocol [description]\n * @return {Framework}\n */\nF.$requestcontinue = function(req, res, headers) {\n\n\tif (!req || !res || res.headersSent || res.success)\n\t\treturn;\n\n\t// Validates if this request is the file (static file)\n\tif (req.isStaticFile) {\n\t\tF.stats.request.file++;\n\t\tif (F._length_files)\n\t\t\treq.$total_file();\n\t\telse\n\t\t\tres.continue();\n\t\treturn;\n\t}\n\n\tif (!PERF[req.method]) {\n\t\treq.$total_status(404);\n\t\treturn;\n\t}\n\n\tF.stats.request.web++;\n\n\treq.body = EMPTYOBJECT;\n\treq.files = EMPTYARRAY;\n\treq.buffer_exceeded = false;\n\treq.buffer_has = false;\n\treq.$flags = req.method[0] + req.method[1];\n\n\tvar flags = [req.method.toLowerCase()];\n\tvar multipart;\n\n\tif (F._request_check_mobile && req.mobile) {\n\t\treq.$flags += 'a';\n\t\tF.stats.request.mobile++;\n\t} else\n\t\tF.stats.request.desktop++;\n\n\treq.$protocol[5] && (req.$flags += req.$protocol[5]);\n\treq.$type = 0;\n\tflags.push(req.$protocol);\n\n\tvar method = req.method;\n\tvar first = method[0];\n\n\tif (first === 'P' || first === 'D') {\n\t\tmultipart = req.headers['content-type'] || '';\n\t\treq.buffer_data = U.createBuffer();\n\t\tvar index = multipart.lastIndexOf(';');\n\t\tvar tmp = multipart;\n\t\tif (index !== -1)\n\t\t\ttmp = tmp.substring(0, index);\n\t\tswitch (tmp.substring(tmp.length - 4)) {\n\t\t\tcase 'json':\n\t\t\t\treq.$flags += 'b';\n\t\t\t\tflags.push('json');\n\t\t\t\treq.$type = 1;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tcase 'oded':\n\t\t\t\treq.$type = 3;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\treq.$flags += 'c';\n\t\t\t\treq.$upload = true;\n\t\t\t\tflags.push('upload');\n\t\t\t\tbreak;\n\t\t\tcase '/xml':\n\t\t\t\treq.$flags += 'd';\n\t\t\t\tflags.push('xml');\n\t\t\t\treq.$type = 2;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (multipart) {\n\t\t\t\t\t// 'undefined' DATA\n\t\t\t\t\tmultipart = '';\n\t\t\t\t\tflags.push('raw');\n\t\t\t\t} else {\n\t\t\t\t\treq.$type = 3;\n\t\t\t\t\tmultipart = '';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (headers.accept === 'text/event-stream') {\n\t\treq.$flags += 'g';\n\t\tflags.push('sse');\n\t}\n\n\tif (DEBUG) {\n\t\treq.$flags += 'h';\n\t\tflags.push('debug');\n\t}\n\n\tif (req.xhr) {\n\t\tF.stats.request.xhr++;\n\t\treq.$flags += 'i';\n\t\tflags.push('xhr');\n\t}\n\n\tif (F._request_check_robot && req.robot)\n\t\treq.$flags += 'j';\n\n\tif (F._request_check_referer) {\n\t\tvar referer = headers['referer'];\n\t\tif (referer && referer.indexOf(headers['host']) !== -1) {\n\t\t\treq.$flags += 'k';\n\t\t\tflags.push('referer');\n\t\t}\n\t}\n\n\treq.flags = flags;\n\tF.$events['request-begin'] && EMIT('request-begin', req, res);\n\n\tvar isCORS = (F._length_cors || F.routes.corsall) && req.headers.origin != null;\n\n\tswitch (first) {\n\t\tcase 'G':\n\t\t\tF.stats.request.get++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'O':\n\t\t\tF.stats.request.options++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'H':\n\t\t\tF.stats.request.head++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'D':\n\t\t\tF.stats.request['delete']++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback1);\n\t\t\telse\n\t\t\t\treq.$total_urlencoded();\n\t\t\treturn;\n\n\t\tcase 'P':\n\t\t\tif (F._request_check_POST) {\n\t\t\t\tif (multipart) {\n\t\t\t\t\tif (isCORS)\n\t\t\t\t\t\tF.$cors(req, res, cors_callback_multipart, multipart);\n\t\t\t\t\telse\n\t\t\t\t\t\treq.$total_multipart(multipart);\n\t\t\t\t} else {\n\t\t\t\t\tif (method === 'PUT')\n\t\t\t\t\t\tF.stats.request.put++;\n\t\t\t\t\telse if (method === 'PATCH')\n\t\t\t\t\t\tF.stats.request.path++;\n\t\t\t\t\telse\n\t\t\t\t\t\tF.stats.request.post++;\n\t\t\t\t\tif (isCORS)\n\t\t\t\t\t\tF.$cors(req, res, cors_callback1);\n\t\t\t\t\telse\n\t\t\t\t\t\treq.$total_urlencoded();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treq.$total_status(404);\n};\n\nfunction cors_callback0(req) {\n\treq.$total_end();\n}\n\nfunction cors_callback1(req) {\n\treq.$total_urlencoded();\n}\n\nfunction cors_callback_multipart(req, res, multipart) {\n\treq.$total_multipart(multipart);\n}\n\nF.$cors = function(req, res, fn, arg) {\n\n\tvar isAllowed = F.routes.corsall;\n\tvar cors, origin;\n\tvar headers = req.headers;\n\tvar key;\n\n\tif (!isAllowed) {\n\n\t\tfor (var i = 0; i < F._length_cors; i++) {\n\t\t\tcors = F.routes.cors[i];\n\t\t\tif (framework_internal.routeCompare(req.path, cors.url, false, cors.isWILDCARD)) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!isAllowed)\n\t\t\treturn fn(req, res, arg);\n\n\t\tvar stop = false;\n\n\t\tkey = 'cors' + cors.hash + '_' + headers.origin;\n\n\t\tif (F.temporary.other[key]) {\n\t\t\tstop = F.temporary.other[key] === 2;\n\t\t} else {\n\n\t\t\tisAllowed = false;\n\n\t\t\tif (cors.headers) {\n\t\t\t\tisAllowed = false;\n\t\t\t\tfor (var i = 0, length = cors.headers.length; i < length; i++) {\n\t\t\t\t\tif (headers[cors.headers[i]]) {\n\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isAllowed)\n\t\t\t\t\tstop = true;\n\t\t\t}\n\n\t\t\tif (!stop && cors.methods) {\n\t\t\t\tisAllowed = false;\n\t\t\t\tvar current = headers['access-control-request-method'] || req.method;\n\t\t\t\tif (current !== 'OPTIONS') {\n\t\t\t\t\tfor (var i = 0, length = cors.methods.length; i < length; i++) {\n\t\t\t\t\t\tif (current === cors.methods[i]) {\n\t\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!isAllowed)\n\t\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!stop && cors.origin) {\n\t\t\t\torigin = headers.origin.toLowerCase().substring(headers.origin.indexOf('/') + 2);\n\t\t\t\tif (origin !== headers.host) {\n\t\t\t\t\tisAllowed = false;\n\t\t\t\t\tfor (var i = 0, length = cors.origin.length; i < length; i++) {\n\t\t\t\t\t\tif (cors.origin[i].indexOf(origin) !== -1) {\n\t\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!isAllowed)\n\t\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tF.temporary.other[key] = stop ? 2 : 1;\n\t\t}\n\t} else if (CONF.default_cors) {\n\t\tkey = headers.origin;\n\t\tif (F.temporary.other[key]) {\n\t\t\tstop = F.temporary.other[key] === 2;\n\t\t} else {\n\t\t\torigin = key.toLowerCase().substring(key.indexOf('/') + 2);\n\t\t\tstop = origin !== headers.host && CONF.default_cors.indexOf(origin) === -1;\n\t\t\tF.temporary.other[key] = stop ? 2 : 1;\n\t\t}\n\t}\n\n\tif (stop)\n\t\torigin = 'null';\n\telse\n\t\torigin = headers.origin;\n\n\tres.setHeader('Access-Control-Allow-Origin', origin);\n\n\tif (!cors || cors.credentials)\n\t\tres.setHeader('Access-Control-Allow-Credentials', 'true');\n\n\tvar name = 'Access-Control-Allow-Methods';\n\tvar isOPTIONS = req.method === 'OPTIONS';\n\n\tif (cors && cors.methods)\n\t\tres.setHeader(name, cors.methods.join(', '));\n\telse\n\t\tres.setHeader(name, isOPTIONS ? headers['access-control-request-method'] || '*' : req.method);\n\n\tname = 'Access-Control-Allow-Headers';\n\n\tif (cors && cors.headers)\n\t\tres.setHeader(name, cors.headers.join(', '));\n\telse\n\t\tres.setHeader(name, headers['access-control-request-headers'] || '*');\n\n\tcors && cors.age && res.setHeader('Access-Control-Max-Age', cors.age);\n\n\tif (stop) {\n\t\tfn = null;\n\t\tF.$events['request-end'] && EMIT('request-end', req, res);\n\t\tF.reqstats(false, false);\n\t\tF.stats.request.blocked++;\n\t\tres.writeHead(404);\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tif (!isOPTIONS)\n\t\treturn fn(req, res, arg);\n\n\tfn = null;\n\tF.$events['request-end'] && EMIT('request-end', req, res);\n\tF.reqstats(false, false);\n\tres.writeHead(200);\n\tres.end();\n\treturn F;\n};\n\n/**\n * Upgrade HTTP (WebSocket)\n * @param {HttpRequest} req\n * @param {Socket} socket\n * @param {Buffer} head\n */\nF.$upgrade = function(req, socket, head) {\n\n\tif ((req.headers.upgrade || '').toLowerCase() !== 'websocket' || F._length_wait)\n\t\treturn;\n\n\t// disables timeout\n\tsocket.setTimeout(0);\n\tsocket.on('error', NOOP);\n\n\tvar headers = req.headers;\n\treq.$protocol = req.connection.encrypted || headers['x-forwarded-protocol'] === 'https' ? 'https' : 'http';\n\n\treq.uri = framework_internal.parseURI(req);\n\n\tF.$events.websocket && EMIT('websocket', req, socket, head);\n\tF.stats.request.websocket++;\n\n\treq.session = null;\n\treq.user = null;\n\treq.flags = [req.secured ? 'https' : 'http', 'get'];\n\n\treq.$wspath = U.path(req.uri.pathname);\n\tvar websocket = new WebSocketClient(req, socket, head);\n\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\treq.websocket = websocket;\n\n\tif (F.onLocale)\n\t\treq.$language = F.onLocale(req, socket);\n\n\tif (F._length_request_middleware)\n\t\tasync_middleware(0, req, req.websocket, F.routes.request, websocketcontinue_middleware);\n\telse\n\t\tF.$websocketcontinue(req, req.$wspath, headers);\n};\n\nfunction websocketcontinue_middleware(req) {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\tF.$websocketcontinue(req, req.$wspath, req.headers);\n}\n\nF.$websocketcontinue = function(req, path) {\n\tvar auth = F.onAuthorize;\n\tif (auth) {\n\t\tauth.call(F, req, req.websocket, req.flags, function(isLogged, user) {\n\t\t\tif (user)\n\t\t\t\treq.user = user;\n\t\t\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, isLogged ? 1 : 2);\n\t\t\tif (route) {\n\t\t\t\tF.$websocketcontinue_process(route, req, path);\n\t\t\t} else\n\t\t\t\treq.websocket.$close(4001, '401: unauthorized');\n\t\t});\n\t} else {\n\t\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, 0);\n\t\tif (route) {\n\t\t\tF.$websocketcontinue_process(route, req, path);\n\t\t} else\n\t\t\treq.websocket.$close(4004, '404: not found');\n\t}\n};\n\nF.$websocketcontinue_process = function(route, req, path) {\n\n\tvar socket = req.websocket;\n\n\tif (!socket.prepare(route.flags, route.protocols, route.allow, route.length)) {\n\t\tsocket.$close(4001, '401: unauthorized');\n\t\treturn;\n\t}\n\n\tvar id = path + (route.flags.length ? '#' + route.flags.join('-') : '');\n\n\tif (route.isBINARY)\n\t\tsocket.type = 1;\n\telse if (route.isJSON)\n\t\tsocket.type = 3;\n\n\tvar next = function() {\n\n\t\tif (req.$total_middleware)\n\t\t\treq.$total_middleware = null;\n\n\t\tif (F.connections[id]) {\n\t\t\tsocket.upgrade(F.connections[id]);\n\t\t\treturn;\n\t\t}\n\n\t\tvar connection = new WebSocket(path, route.controller, id);\n\t\tconnection.route = route;\n\t\tconnection.options = route.options;\n\t\tF.connections[id] = connection;\n\t\troute.onInitialize.apply(connection, framework_internal.routeParam(route.param.length ? req.split : req.path, route));\n\t\tsetImmediate(next_upgrade_continue, socket, connection);\n\t};\n\n\tif (route.middleware)\n\t\tasync_middleware(0, req, req.websocket, route.middleware, next, route.options);\n\telse\n\t\tnext();\n};\n\nfunction next_upgrade_continue(socket, connection) {\n\tsocket.upgrade(connection);\n}\n\n/**\n * Request statistics writer\n * @private\n * @param {Boolean} beg\n * @param {Boolean} isStaticFile\n * @return {Framework}\n */\nF.reqstats = function(beg) {\n\n\tif (beg)\n\t\tF.stats.request.pending++;\n\telse\n\t\tF.stats.request.pending--;\n\n\tif (F.stats.request.pending < 0)\n\t\tF.stats.request.pending = 0;\n\n\treturn F;\n};\n\n/**\n * Get a model\n * @param {String} name\n * @return {Object}\n */\nglobal.MODEL = F.model = function(name) {\n\tvar obj = F.models[name];\n\tif (obj || obj === null)\n\t\treturn obj;\n\tvar filename = U.combine(CONF.directory_models, name + '.js');\n\texistsSync(filename) && F.install('model', name, filename, undefined, undefined, undefined, true);\n\treturn F.models[name] || null;\n};\n\n/**\n * Load a source code\n * @param {String} name\n * @param {Object} options Custom initial options, optional.\n * @return {Object}\n */\nglobal.INCLUDE = global.SOURCE = F.source = function(name, options, callback) {\n\tvar obj = F.sources[name];\n\tif (obj || obj === null)\n\t\treturn obj;\n\tvar filename = U.combine(CONF.directory_source, name + '.js');\n\texistsSync(filename) && F.install('source', name, filename, options, callback, undefined, true);\n\treturn F.sources[name] || null;\n};\n\n/**\n * Load a source code (alias for F.source())\n * @param {String} name\n * @param {Object} options Custom initial options, optional.\n * @return {Object}\n */\nF.include = function(name, options, callback) {\n\treturn F.source(name, options, callback);\n};\n\n/**\n * Send e-mail\n * @param {String or Array} address E-mail address.\n * @param {String} subject E-mail subject.\n * @param {String} view View name.\n * @param {Object} model Optional.\n * @param {Function(err)} callback Optional.\n * @param {String} language Optional.\n * @return {MailMessage}\n */\nglobal.MAIL = F.mail = function(address, subject, view, model, callback, language) {\n\n\tif (typeof(callback) === 'string') {\n\t\tvar tmp = language;\n\t\tlanguage = callback;\n\t\tcallback = tmp;\n\t}\n\n\tvar controller = EMPTYCONTROLLER;\n\tcontroller.layoutName = '';\n\tcontroller.themeName = U.parseTheme(view);\n\n\tif (controller.themeName)\n\t\tview = prepare_viewname(view);\n\telse if (F.onTheme)\n\t\tcontroller.themeName = F.onTheme(controller);\n\telse\n\t\tcontroller.themeName = '';\n\n\tvar replyTo;\n\n\t// Translation\n\tif (typeof(language) === 'string') {\n\t\tsubject = subject.indexOf('@(') === -1 ? F.translate(language, subject) : F.translator(language, subject);\n\t\tcontroller.language = language;\n\t}\n\n\treturn controller.mail(address, subject, view, model, callback, replyTo);\n};\n\n/**\n * Renders view\n * @param {String} name View name.\n * @param {Object} model Model.\n * @param {String} layout Layout for the view, optional. Default without layout.\n * @param {Object} repository A repository object, optional. Default empty.\n * @param {String} language Optional.\n * @return {String}\n */\nglobal.VIEW = F.view = function(name, model, layout, repository, language) {\n\n\tvar controller = EMPTYCONTROLLER;\n\n\tif (typeof(layout) === 'object') {\n\t\tvar tmp = repository;\n\t\trepository = layout;\n\t\tlayout = tmp;\n\t}\n\n\tcontroller.layoutName = layout || '';\n\tcontroller.language = language || '';\n\tcontroller.repository = typeof(repository) === 'object' && repository ? repository : EMPTYOBJECT;\n\n\tvar theme = U.parseTheme(name);\n\tif (theme) {\n\t\tcontroller.themeName = theme;\n\t\tname = prepare_viewname(name);\n\t} else if (F.onTheme)\n\t\tcontroller.themeName = F.onTheme(controller);\n\telse\n\t\tcontroller.themeName = undefined;\n\n\treturn controller.view(name, model, true);\n};\n\n/**\n * Compiles and renders view\n * @param {String} body HTML body.\n * @param {Object} model Model.\n * @param {String} layout Layout for the view, optional. Default without layout.\n * @param {Object} repository A repository object, optional. Default empty.\n * @param {String} language Optional.\n * @return {String}\n */\nF.viewCompile = function(body, model, layout, repository, language) {\n\n\tvar controller = EMPTYCONTROLLER;\n\n\tif (typeof(layout) === 'object') {\n\t\tvar tmp = repository;\n\t\trepository = layout;\n\t\tlayout = tmp;\n\t}\n\n\tcontroller.layoutName = layout || '';\n\tcontroller.language = language || '';\n\tcontroller.themeName = undefined;\n\tcontroller.repository = typeof(repository) === 'object' && repository ? repository : EMPTYOBJECT;\n\n\treturn controller.viewCompile(body, model, true);\n};\n\n/**\n * Load tests\n * @private\n * @param {Boolean} stop Stop framework after end.\n * @param {String Array} names Test names, optional.\n * @param {Function()} cb\n * @return {Framework}\n */\nF.test = function() {\n\tF.isTest = true;\n\tF.$configure_configs('config-test', true);\n\trequire('./test').load();\n\treturn F;\n};\n\n/**\n * Clear temporary directory\n * @param {Function} callback\n * @param {Boolean} isInit Private argument.\n * @return {Framework}\n */\nF.clear = function(callback, isInit) {\n\n\tvar dir = F.path.temp();\n\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\n\tif (isInit) {\n\t\tif (!CONF.allow_clear_temp) {\n\t\t\tif (F.$bundling) {\n\t\t\t\t// clears only JS and CSS files\n\t\t\t\tU.ls(dir, function(files) {\n\t\t\t\t\tF.unlink(files, function() {\n\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t});\n\t\t\t\t}, function(filename, folder) {\n\t\t\t\t\tif (folder || (plus && !filename.substring(dir.length).startsWith(plus)))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (filename.indexOf('.package') !== -1)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tvar ext = U.getExtension(filename);\n\t\t\t\t\treturn ext === 'js' || ext === 'css' || ext === 'tmp' || ext === 'upload' || ext === 'html' || ext === 'htm';\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn F;\n\t\t}\n\t}\n\n\tif (!existsSync(dir) || !F.$bundling) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tU.ls(dir, function(files, directories) {\n\n\t\tif (isInit) {\n\t\t\tvar arr = [];\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\t\tvar filename = files[i].substring(dir.length);\n\t\t\t\tif (plus && !filename.startsWith(plus))\n\t\t\t\t\tcontinue;\n\t\t\t\t(filename.indexOf('/') === -1 || filename.indexOf('.package/') !== -1) && !filename.endsWith('.jsoncache') && arr.push(files[i]);\n\t\t\t}\n\n\t\t\tfiles = arr;\n\t\t\tdirectories = directories.remove(function(name) {\n\t\t\t\tname = U.getName(name);\n\n\t\t\t\tif (name[0] === '~')\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (name.endsWith('.package'))\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tF.unlink(files, () => F.rmdir(directories, callback));\n\t});\n\n\tif (!isInit) {\n\t\t// clear static cache\n\t\tF.temporary.path = {};\n\t\tF.temporary.range = {};\n\t\tF.temporary.notfound = {};\n\t}\n\n\treturn F;\n};\n\n/**\n * Remove files in array\n * @param {String Array} arr File list.\n * @param {Function} callback\n * @return {Framework}\n */\nF.unlink = F.path.unlink = function(arr, callback) {\n\n\tif (typeof(arr) === 'string')\n\t\tarr = [arr];\n\n\tif (!arr.length) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tvar filename = arr.shift();\n\tif (filename)\n\t\tFs.unlink(filename, () => F.unlink(arr, callback));\n\telse\n\t\tcallback && callback();\n\n\treturn F;\n};\n\n/**\n * Remove directories in array\n * @param {String Array} arr\n * @param {Function} callback\n * @return {Framework}\n */\nF.rmdir = F.path.rmdir = function(arr, callback) {\n\tif (typeof(arr) === 'string')\n\t\tarr = [arr];\n\n\tif (!arr.length) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tvar path = arr.shift();\n\tif (path) {\n\t\tU.ls(path, function(files, directories) {\n\t\t\tdirectories.reverse();\n\t\t\tdirectories.push(path);\n\t\t\tfiles.wait((item, next) => Fs.unlink(item, next), function() {\n\t\t\t\tdirectories.wait(function(item, next) {\n\t\t\t\t\tFs.rmdir(item, next);\n\t\t\t\t}, () => F.rmdir(arr, callback));\n\t\t\t});\n\t\t});\n\t} else\n\t\tcallback && callback();\n\n\treturn F;\n};\n\n/**\n * Cryptography (encrypt)\n * @param {String} value\n * @param {String} key Encrypt key.\n * @param {Boolean} isUnique Optional, default true.\n * @return {String}\n */\nF.encrypt = function(value, key, isUnique) {\n\n\tif (value === undefined)\n\t\treturn '';\n\n\tvar type = typeof(value);\n\n\tif (typeof(key) === 'boolean') {\n\t\tvar tmp = isUnique;\n\t\tisUnique = key;\n\t\tkey = tmp;\n\t}\n\n\tif (type === 'function')\n\t\tvalue = value();\n\telse if (type === 'number')\n\t\tvalue = value.toString();\n\telse if (type === 'object')\n\t\tvalue = JSON.stringify(value);\n\n\treturn value.encrypt(CONF.secret + '=' + key, isUnique);\n};\n\n/**\n * Cryptography (decrypt)\n * @param {String} value\n * @param {String} key Decrypt key.\n * @param {Boolean} jsonConvert Optional, default true.\n * @return {Object or String}\n */\nF.decrypt = function(value, key, jsonConvert) {\n\n\tif (typeof(key) === 'boolean') {\n\t\tvar tmp = jsonConvert;\n\t\tjsonConvert = key;\n\t\tkey = tmp;\n\t}\n\n\tif (typeof(jsonConvert) !== 'boolean')\n\t\tjsonConvert = true;\n\n\tvar response = (value || '').decrypt(CONF.secret + '=' + key);\n\treturn response ? (jsonConvert ? (response.isJSON() ? response.parseJSON(true) : null) : response) : null;\n};\n\n/**\n * Create hash\n * @param {String} type Type (md5, sha1, sha256, etc.)\n * @param {String} value\n * @param {String} salt Optional, default false.\n * @return {String}\n */\nF.hash = function(type, value, salt) {\n\tvar hash = Crypto.createHash(type);\n\tvar plus = '';\n\n\tif (typeof(salt) === 'string')\n\t\tplus = salt;\n\telse if (salt !== false)\n\t\tplus = (CONF.secret || '');\n\n\thash.update(value.toString() + plus, ENCODING);\n\treturn hash.digest('hex');\n};\n\n/**\n * Resource reader\n * @param {String} name Optional, resource file name. Default: \"default\".\n * @param {String} key Resource key.\n * @return {String} String\n */\nF.resource = function(name, key) {\n\n\tif (!key) {\n\t\tkey = name;\n\t\tname = null;\n\t}\n\n\tif (!name)\n\t\tname = 'default';\n\n\tvar res = F.resources[name];\n\tif (res)\n\t\treturn res[key] == null ? '' : res[key];\n\n\tvar routes = F.routes.resources[name];\n\tvar body = '';\n\tvar filename;\n\tif (routes) {\n\t\tfor (var i = 0, length = routes.length; i < length; i++) {\n\t\t\tfilename = routes[i];\n\t\t\tif (existsSync(filename))\n\t\t\t\tbody += (body ? '\\n' : '') + Fs.readFileSync(filename).toString(ENCODING);\n\t\t}\n\t}\n\n\tvar filename = U.combine(CONF.directory_resources, name + '.resource');\n\tvar empty = false;\n\tif (existsSync(filename))\n\t\tbody += (body ? '\\n' : '') + Fs.readFileSync(filename).toString(ENCODING);\n\telse\n\t\tempty = true;\n\n\tvar obj = body.parseConfig();\n\tF.resources[name] = obj;\n\tobj.$empty = empty;\n\treturn obj[key] == null ? '' : obj[key];\n};\n\n/**\n * Translates text\n * @param {String} language A resource filename, optional.\n * @param {String} text\n * @return {String}\n */\nF.translate = function(language, text) {\n\n\tif (!text) {\n\t\ttext = language;\n\t\tlanguage = undefined;\n\t}\n\n\tif (text[0] === '#' && text[1] !== ' ')\n\t\treturn F.resource(language, text.substring(1));\n\n\tvar value = F.resource(language, 'T' + text.hash());\n\treturn value ? value : text;\n};\n\n/**\n * The translator for the text from the View Engine @(TEXT TO TRANSLATE)\n * @param {String} language A resource filename, optional.\n * @param {String} text\n * @return {String}\n */\nF.translator = function(language, text) {\n\treturn framework_internal.parseLocalization(text, language);\n};\n\nF.$configure_sitemap = function(arr, clean) {\n\n\tif (!arr || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'sitemap');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tif (clean || !F.routes.sitemap)\n\t\tF.routes.sitemap = {};\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(' :');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar val = str.substring(index + 2).trim();\n\t\tvar a = val.split('-->');\n\t\tvar url = a[1].trim();\n\t\tvar wildcard = false;\n\n\t\tif (url.endsWith('*')) {\n\t\t\twildcard = true;\n\t\t\turl = url.substring(0, url.length - 1);\n\t\t} else if (url.endsWith('*)')) {\n\t\t\t// localization\n\t\t\twildcard = true;\n\t\t\turl = url.substring(0, url.length - 2);\n\t\t}\n\n\t\tvar name = a[0].trim();\n\t\tvar localizeName = name.startsWith('@(');\n\t\tvar localizeUrl = url.startsWith('@(');\n\n\t\tif (localizeName)\n\t\t\tname = name.substring(2, name.length - 1).trim();\n\n\t\tif (localizeUrl)\n\t\t\turl = url.substring(2, url.length - 1).trim();\n\n\t\tF.routes.sitemap[key] = { name: name, url: url, parent: a[2] ? a[2].trim() : null, wildcard: wildcard, formatName: name.indexOf('{') !== -1, formatUrl: url.indexOf('{') !== -1, localizeName: localizeName, localizeUrl: localizeUrl };\n\t}\n\n\treturn F;\n};\n\nF.sitemap = function(name, me, language) {\n\n\tif (!F.routes.sitemap)\n\t\treturn me ? null : EMPTYARRAY;\n\n\tif (typeof(me) === 'string') {\n\t\tlanguage = me;\n\t\tme = false;\n\t}\n\n\tvar key = REPOSITORY_SITEMAP + name + '$' + (me ? '1' : '0') + '$' + (language || '');\n\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tvar sitemap;\n\tvar id = name;\n\tvar url;\n\tvar title;\n\n\tif (me === true) {\n\t\tsitemap = F.routes.sitemap[name];\n\t\tvar item = { sitemap: id, id: '', name: '', url: '', last: true, selected: true, index: 0, wildcard: false, formatName: false, formatUrl: false };\n\t\tif (!sitemap)\n\t\t\treturn item;\n\n\t\ttitle = sitemap.name;\n\t\tif (sitemap.localizeName)\n\t\t\ttitle = F.translate(language, title);\n\n\t\turl = sitemap.url;\n\t\tvar wildcard = sitemap.wildcard;\n\n\t\tif (sitemap.localizeUrl) {\n\t\t\tif (sitemap.wildcard) {\n\t\t\t\tif (url[url.length - 1] !== '/')\n\t\t\t\t\turl += '/';\n\t\t\t\turl += '*';\n\t\t\t}\n\n\t\t\turl = F.translate(language, url);\n\n\t\t\tif (url.endsWith('*')) {\n\t\t\t\turl = url.substring(0, url.length - 1);\n\t\t\t\twildcard = true;\n\t\t\t} else\n\t\t\t\twildcard = false;\n\t\t}\n\n\t\titem.sitemap = id;\n\t\titem.id = name;\n\t\titem.formatName = sitemap.formatName;\n\t\titem.formatUrl = sitemap.formatUrl;\n\t\titem.localizeUrl = sitemap.localizeUrl;\n\t\titem.localizeName = sitemap.localizeName;\n\t\titem.name = title;\n\t\titem.url = url;\n\t\titem.wildcard = wildcard;\n\t\tF.temporary.other[key] = item;\n\t\treturn item;\n\t}\n\n\tvar arr = [];\n\tvar index = 0;\n\n\twhile (true) {\n\t\tsitemap = F.routes.sitemap[name];\n\t\tif (!sitemap)\n\t\t\tbreak;\n\n\t\ttitle = sitemap.name;\n\t\turl = sitemap.url;\n\n\t\tvar wildcard = sitemap.wildcard;\n\n\t\tif (sitemap.localizeName)\n\t\t\ttitle = F.translate(language, sitemap.name);\n\n\t\tif (sitemap.localizeUrl) {\n\t\t\tif (sitemap.wildcard) {\n\t\t\t\tif (url[url.length - 1] !== '/')\n\t\t\t\t\turl += '/';\n\t\t\t\turl += '*';\n\t\t\t}\n\t\t\turl = F.translate(language, url);\n\n\t\t\tif (url.endsWith('*')) {\n\t\t\t\turl = url.substring(0, url.length - 1);\n\t\t\t\twildcard = true;\n\t\t\t} else\n\t\t\t\twildcard = false;\n\t\t}\n\n\t\tarr.push({ sitemap: id, id: name, name: title, url: url, last: index === 0, first: sitemap.parent ? false : true, selected: index === 0, index: index, wildcard: wildcard, formatName: sitemap.formatName, formatUrl: sitemap.formatUrl, localizeName: sitemap.localizeName, localizeUrl: sitemap.localizeUrl });\n\t\tindex++;\n\t\tname = sitemap.parent;\n\t\tif (!name)\n\t\t\tbreak;\n\t}\n\n\tarr.reverse();\n\tF.temporary.other[key] = arr;\n\treturn arr;\n};\n\n/**\n * Gets a list of all items in sitemap\n * @param {String} parent\n * @param {String} language Optional, language\n * @return {Array}\n */\nF.sitemap_navigation = function(parent, language) {\n\n\tvar key = REPOSITORY_SITEMAP + '_n_' + (parent || '') + '$' + (language || '');\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tvar keys = Object.keys(F.routes.sitemap);\n\tvar arr = [];\n\tvar index = 0;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar item = F.routes.sitemap[keys[i]];\n\t\tif ((parent && item.parent !== parent) || (!parent && item.parent))\n\t\t\tcontinue;\n\n\t\tvar title = item.name;\n\t\tvar url = item.url;\n\n\t\tif (item.localizeName)\n\t\t\ttitle = F.translate(language, title);\n\n\t\tif (item.localizeUrl)\n\t\t\turl = F.translate(language, url);\n\n\t\tarr.push({ id: parent || '', name: title, url: url, last: index === 0, first: item.parent ? false : true, selected: index === 0, index: index, wildcard: item.wildcard, formatName: item.formatName, formatUrl: item.formatUrl });\n\t\tindex++;\n\t}\n\n\tarr.quicksort('name');\n\tF.temporary.other[key] = arr;\n\treturn arr;\n};\n\n/**\n * Adds an item(s) to sitemap\n * @param {String|Array} obj - 'ID : Title ---> URL --> [Parent]' parent is optional\n * @return {framework}\n */\nF.sitemap_add = function (obj) {\n\tF.$configure_sitemap(obj instanceof Array ? obj : [obj]);\n\treturn F;\n};\n\nF.$configure_dependencies = function(arr, callback) {\n\n\tif (!arr || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'dependencies');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr)\n\t\treturn F;\n\n\tvar type;\n\tvar options;\n\tvar interval;\n\tvar dependencies = [];\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(' :');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar url = str.substring(index + 2).trim();\n\t\tvar priority = 0;\n\n\t\toptions = undefined;\n\t\tinterval = undefined;\n\n\t\tindex = key.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tinterval = key.substring(index, key.indexOf(')', index)).replace(/\\(|\\)/g, '').trim();\n\t\t\tkey = key.substring(0, index).trim();\n\t\t}\n\n\t\tindex = url.indexOf('-->');\n\t\tif (index !== -1) {\n\t\t\tvar opt = url.substring(index + 3).trim();\n\t\t\tif (opt.isJSON())\n\t\t\t\toptions = opt.parseJSON(true);\n\t\t\turl = url.substring(0, index).trim();\n\t\t}\n\n\t\tswitch (key) {\n\t\t\tcase 'package':\n\t\t\tcase 'packages':\n\t\t\tcase 'pkg':\n\t\t\t\ttype = 'package';\n\t\t\t\tpriority = 9;\n\t\t\t\tbreak;\n\t\t\tcase 'module':\n\t\t\tcase 'modules':\n\t\t\t\ttype = 'module';\n\t\t\t\tpriority = 10;\n\t\t\t\tbreak;\n\t\t\tcase 'model':\n\t\t\tcase 'models':\n\t\t\t\ttype = 'model';\n\t\t\t\tpriority = 8;\n\t\t\t\tbreak;\n\t\t\tcase 'source':\n\t\t\tcase 'sources':\n\t\t\t\ttype = 'source';\n\t\t\t\tpriority = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'controller':\n\t\t\tcase 'controllers':\n\t\t\t\ttype = 'controller';\n\t\t\t\tpriority = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'view':\n\t\t\tcase 'views':\n\t\t\t\tpriority = 3;\n\t\t\t\ttype = 'view';\n\t\t\t\tbreak;\n\t\t\tcase 'version':\n\t\t\tcase 'versions':\n\t\t\t\tpriority = 3;\n\t\t\t\ttype = 'version';\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\tcase 'configuration':\n\t\t\t\tpriority = 11;\n\t\t\t\ttype = 'config';\n\t\t\t\tbreak;\n\t\t\tcase 'isomorphic':\n\t\t\tcase 'isomorphics':\n\t\t\t\tpriority = 6;\n\t\t\t\ttype = 'isomorphic';\n\t\t\t\tbreak;\n\t\t\tcase 'definition':\n\t\t\tcase 'definitions':\n\t\t\t\tpriority = 5;\n\t\t\t\ttype = 'definition';\n\t\t\t\tbreak;\n\t\t\tcase 'middleware':\n\t\t\tcase 'middlewares':\n\t\t\t\ttype = 'middleware';\n\t\t\t\tpriority = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'component':\n\t\t\tcase 'components':\n\t\t\t\tpriority = 7;\n\t\t\t\ttype = 'component';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (type) {\n\t\t\t(function(type, url, options, interval) {\n\t\t\t\tif (interval)\n\t\t\t\t\tdependencies.push({ priority: priority, fn: next => F.uptodate(type, url, options, interval, next) });\n\t\t\t\telse\n\t\t\t\t\tdependencies.push({ priority: priority, fn: next => F.install(type, url, options, undefined, undefined, undefined, undefined, undefined, undefined, next) });\n\t\t\t})(type, url, options, interval);\n\t\t}\n\t}\n\n\tdependencies.quicksort('priority', false);\n\tdependencies.wait(function(item, next) {\n\t\titem.fn(next);\n\t}, callback);\n\treturn F;\n};\n\nF.$configure_workflows = function(arr, clean) {\n\n\tif (arr === undefined || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'workflows');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (clean)\n\t\tF.workflows = {};\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tarr.forEach(function(line) {\n\t\tline = line.trim();\n\t\tif (line.startsWith('//'))\n\t\t\treturn;\n\t\tvar index = line.indexOf(':');\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tvar key = line.substring(0, index).trim();\n\t\tvar response = -1;\n\t\tvar builder = [];\n\n\t\t// sub-type\n\t\tvar subindex = key.indexOf('(');\n\t\tif (subindex !== -1) {\n\t\t\tvar type = key.substring(subindex + 1, key.indexOf(')', subindex + 1)).trim();\n\t\t\tkey = key.substring(0, subindex).trim();\n\t\t\ttype = type.replace(/^default\\//gi, '');\n\t\t\tkey = type + '#' + key;\n\t\t}\n\n\t\tline.substring(index + 1).split('-->').forEach(function(operation, index) {\n\n\t\t\tvar options = 'options||EMPTYOBJECT';\n\t\t\toperation = operation.trim().replace(/\"/g, '\\'');\n\n\t\t\tvar oindex = operation.indexOf('{');\n\t\t\tif (oindex !== -1) {\n\t\t\t\toptions = operation.substring(oindex, operation.lastIndexOf('}') + 1);\n\t\t\t\toperation = operation.replace(options, '').trim();\n\t\t\t\toptions = 'options||' + options;\n\t\t\t}\n\n\t\t\tif (operation.endsWith('(response)')) {\n\t\t\t\tresponse = index;\n\t\t\t\toperation = operation.replace('(response)', '').trim();\n\t\t\t}\n\n\t\t\tvar what = operation.split(':');\n\t\t\tif (what.length === 2)\n\t\t\t\tbuilder.push('$' + what[0].trim() + '(' + what[1].trim() + ', {0})'.format(options));\n\t\t\telse\n\t\t\t\tbuilder.push('$' + what[0] + '({0})'.format(options));\n\n\t\t});\n\n\t\tF.workflows[key] = new Function('model', 'options', 'callback', 'return model.$async(callback' + (response === -1 ? '' : ', ' + response) + ').' + builder.join('.') + ';');\n\t});\n\n\treturn F;\n};\n\nF.$configure_versions = function(arr, clean) {\n\n\tif (arr === undefined || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'versions');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr) {\n\t\tif (clean)\n\t\t\tF.versions = null;\n\t\treturn F;\n\t}\n\n\tif (!clean)\n\t\tF.versions = {};\n\n\tif (!F.versions)\n\t\tF.versions = {};\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tif (str[0] !== '/')\n\t\t\tstr = '/' + str;\n\n\t\tvar index = str.indexOf(' :');\n\t\tvar ismap = false;\n\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1) {\n\t\t\t\tindex = str.indexOf('-->');\n\t\t\t\tif (index === -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tismap = true;\n\t\t\t}\n\t\t}\n\n\t\tvar len = ismap ? 3 : 2;\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar filename = str.substring(index + len).trim();\n\n\t\tif (filename === 'auto') {\n\n\t\t\tif (ismap)\n\t\t\t\tthrow new Error('/versions: \"auto\" value can\\'t be used with mapping');\n\n\t\t\tF.versions[key] = filename;\n\n\t\t\t(function(key, filename) {\n\t\t\t\tON('ready', function() {\n\t\t\t\t\tF.consoledebug('\"versions\" is getting checksum of ' + key);\n\t\t\t\t\tmakehash(key, function(hash) {\n\t\t\t\t\t\tF.consoledebug('\"versions\" is getting checksum of ' + key + ' (done)');\n\t\t\t\t\t\tif (hash) {\n\t\t\t\t\t\t\tvar index = key.lastIndexOf('.');\n\t\t\t\t\t\t\tfilename = key.substring(0, index) + '-' + hash + key.substring(index);\n\n\t\t\t\t\t\t\tF.versions[key] = filename;\n\n\t\t\t\t\t\t\tif (!F.routes.merge[key] && !F.temporary.other['merge_' + key]) {\n\t\t\t\t\t\t\t\tvar index = key.indexOf('/', 1);\n\t\t\t\t\t\t\t\tvar theme = index === -1 ? null : key.substring(1, index);\n\t\t\t\t\t\t\t\tif (theme) {\n\t\t\t\t\t\t\t\t\tif (F.themes[theme])\n\t\t\t\t\t\t\t\t\t\tkey = F.themes[theme] + 'public' + key.substring(index);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tkey = F.path.public(key);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tkey = F.path.public(key);\n\t\t\t\t\t\t\t\tF.map(filename, key);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tF.temporary.views = {};\n\t\t\t\t\t\t\tF.temporary.other = {};\n\t\t\t\t\t\t\tglobal.$VIEWCACHE = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})(key, filename);\n\n\t\t} else {\n\t\t\tF.versions[key] = filename;\n\t\t\tismap && F.map(filename, F.path.public(key));\n\t\t}\n\t}\n\n\treturn F;\n};\n\nfunction makehash(url, callback, count) {\n\tvar target = 'http://' + (F.ip === 'auto' ? '0.0.0.0' : F.ip) + ':' + F.port + url;\n\tU.download(target, ['get'], function(err, stream, status) {\n\n\t\t// Maybe F.wait()\n\t\tif (status === 503) {\n\t\t\t// Unhandled problem\n\t\t\tif (count > 60)\n\t\t\t\tcallback('');\n\t\t\telse\n\t\t\t\tsetTimeout((url, callback, count) => makehash(url, callback, (count || 1) + 1), 1000, url, callback, count);\n\t\t\treturn;\n\t\t}\n\n\t\tif (status !== 200) {\n\t\t\tcallback('');\n\t\t\treturn;\n\t\t}\n\n\t\tvar hash = Crypto.createHash('md5');\n\t\thash.setEncoding('hex');\n\t\tstream.pipe(hash);\n\t\tstream.on('end', function() {\n\t\t\thash.end();\n\t\t\tcallback(hash.read().crc32(true));\n\t\t});\n\n\t\tstream.on('error', () => callback(''));\n\t});\n}\n\nF.$configure_configs = function(arr, rewrite) {\n\n\tvar type = typeof(arr);\n\tif (type === 'string') {\n\t\tvar filename = prepare_filename(arr);\n\t\tif (!existsSync(filename, true))\n\t\t\treturn F;\n\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t}\n\n\tif (!arr) {\n\n\t\tvar filenameA = U.combine('/', 'config');\n\t\tvar filenameB = U.combine('/', 'config-' + (DEBUG ? 'debug' : 'release'));\n\n\t\tarr = [];\n\n\t\t// read all files from \"configs\" directory\n\t\tvar configs = F.path.configs();\n\t\tif (existsSync(configs)) {\n\t\t\tvar tmp = Fs.readdirSync(configs);\n\t\t\tfor (var i = 0, length = tmp.length; i < length; i++) {\n\t\t\t\tvar skip = tmp[i].match(/-(debug|release|test)$/i);\n\t\t\t\tif (skip) {\n\t\t\t\t\tskip = skip[0].toString().toLowerCase();\n\t\t\t\t\tif (skip === '-debug' && !F.isDebug)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (skip === '-release' && F.isDebug)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (skip === '-test' && !F.isTest)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tarr = arr.concat(Fs.readFileSync(configs + tmp[i]).toString(ENCODING).split('\\n'));\n\t\t\t}\n\t\t}\n\n\t\tif (existsSync(filenameA) && Fs.lstatSync(filenameA).isFile())\n\t\t\tarr = arr.concat(Fs.readFileSync(filenameA).toString(ENCODING).split('\\n'));\n\n\t\tif (existsSync(filenameB) && Fs.lstatSync(filenameB).isFile())\n\t\t\tarr = arr.concat(Fs.readFileSync(filenameB).toString(ENCODING).split('\\n'));\n\t}\n\n\tvar done = function() {\n\t\tprocess.title = 'total: ' + CONF.name.removeDiacritics().toLowerCase().replace(REG_EMPTY, '-').substring(0, 8);\n\t\tF.isVirtualDirectory = existsSync(U.combine(CONF.directory_public_virtual));\n\t};\n\n\tif (!(arr instanceof Array) || !arr.length) {\n\t\tdone();\n\t\treturn F;\n\t}\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tvar obj = {};\n\tvar accepts = null;\n\tvar length = arr.length;\n\tvar tmp;\n\tvar subtype;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || (str[0] === '/' || str[1] === '/'))\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(':');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar name = str.substring(0, index).trim();\n\t\tif (name === 'debug' || name === 'resources')\n\t\t\tcontinue;\n\n\t\tvalue = str.substring(index + 1).trim();\n\t\tindex = name.indexOf('(');\n\n\t\tif (value.substring(0, 7) === 'base64 ' && value.length > 8)\n\t\t\tvalue = U.createBuffer(value.substring(7).trim(), 'base64').toString('utf8');\n\t\telse if (value.substring(0, 4) === 'hex ' && value.length > 6)\n\t\t\tvalue = U.createBuffer(value.substring(4).trim(), 'hex').toString('utf8');\n\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (name) {\n\t\t\tcase 'secret':\n\t\t\tcase 'secret-uid':\n\t\t\tcase 'secret_uid':\n\t\t\t\tname = name.replace(REG_OLDCONF, '_');\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'default-request-length':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_request_maxlength\"');\n\t\t\t\tobj.default_request_maxlength = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-websocket-request-length':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_websocket_maxlength\"');\n\t\t\t\tobj.default_websocket_maxlength = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-maximum-file-descriptors':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_maxopenfiles\"');\n\t\t\t\tobj.default_maxopenfiles = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-cors-maxage': // old\n\t\t\tcase 'default-request-timeout': // old\n\t\t\tcase 'default-request-maxlength': // old\n\t\t\tcase 'default-request-maxkeys': // old\n\t\t\tcase 'default-websocket-maxlength': // old\n\t\t\tcase 'default-interval-clear-cache': // old\n\t\t\tcase 'default-interval-clear-resources': // old\n\t\t\tcase 'default-interval-precompile-views': // old\n\t\t\tcase 'default-interval-uptodate': // old\n\t\t\tcase 'default-interval-websocket-ping': // old\n\t\t\tcase 'default-interval-clear-dnscache': // old\n\t\t\tcase 'default-dependency-timeout': // old\n\t\t\tcase 'default-restbuilder-timeout': // old\n\t\t\tcase 'nosql-cleaner': // old\n\t\t\tcase 'default-errorbuilder-status': // old\n\t\t\tcase 'default-maxopenfiles': // old\n\t\t\tcase 'default_maxopenfiles':\n\t\t\tcase 'default_errorbuilder_status':\n\t\t\tcase 'default_cors_maxage':\n\t\t\tcase 'default_request_timeout':\n\t\t\tcase 'default_request_maxlength':\n\t\t\tcase 'default_request_maxkeys':\n\t\t\tcase 'default_websocket_maxlength':\n\t\t\tcase 'default_interval_clear_cache':\n\t\t\tcase 'default_interval_clear_resources':\n\t\t\tcase 'default_interval_precompile_views':\n\t\t\tcase 'default_interval_uptodate':\n\t\t\tcase 'default_interval_websocket_ping':\n\t\t\tcase 'default_interval_clear_dnscache':\n\t\t\tcase 'default_dependency_timeout':\n\t\t\tcase 'default_restbuilder_timeout':\n\t\t\tcase 'nosql_cleaner':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-image-consumption': // old\n\t\t\tcase 'default-image-quality': // old\n\t\t\tcase 'default_image_consumption':\n\t\t\tcase 'default_image_quality':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = U.parseInt(value.replace(/%|\\s/g, ''));\n\t\t\t\tbreak;\n\n\t\t\tcase 'static-accepts-custom': // old\n\t\t\tcase 'static_accepts_custom':\n\t\t\t\taccepts = value.replace(REG_ACCEPTCLEANER, '').split(',');\n\t\t\t\tbreak;\n\n\t\t\tcase 'default-root': // old\n\t\t\tcase 'default_root':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tif (value)\n\t\t\t\t\tobj[name] = U.path(value);\n\t\t\t\tbreak;\n\n\t\t\tcase 'static-accepts': // old\n\t\t\tcase 'static_accepts':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = {};\n\t\t\t\ttmp = value.replace(REG_ACCEPTCLEANER, '').split(',');\n\t\t\t\tfor (var j = 0; j < tmp.length; j++)\n\t\t\t\t\tobj[name][tmp[j]] = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'mail.smtp':\n\t\t\tcase 'mail.smtp.options':\n\t\t\tcase 'mail.address.from':\n\t\t\tcase 'mail.address.copy':\n\t\t\tcase 'mail.address.bcc':\n\t\t\tcase 'mail.address.reply':\n\n\t\t\t\tif (name === 'mail.address.bcc')\n\t\t\t\t\ttmp = 'mail_address_copy';\n\t\t\t\telse\n\t\t\t\t\ttmp = name.replace(/\\./g, '-');\n\n\t\t\t\tOBSOLETE(name, 'is renamed to \"' + tmp + '\"');\n\t\t\t\tobj[tmp] = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'default-cors': // old\n\t\t\tcase 'default_cors':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tvalue = value.replace(/,/g, ' ').split(' ');\n\t\t\t\ttmp = [];\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar co = (value[j] || '').trim();\n\t\t\t\t\tif (co) {\n\t\t\t\t\t\tco = co.toLowerCase();\n\t\t\t\t\t\tif (co.substring(0, 2) === '//') {\n\t\t\t\t\t\t\ttmp.push(co);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\ttmp.push(co.substring(co.indexOf('/') + 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobj[name] = tmp.length ? tmp : null;\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-handle-static-files':\n\t\t\t\tOBSOLETE('config[\"allow-handle-static-files\"]', 'The key has been renamed to \"allow_static_files\"');\n\t\t\t\tobj.allow_static_files = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'disable-clear-temporary-directory':\n\t\t\t\tOBSOLETE('disable-clear-temporary-directory', 'You need to use \"allow_clear_temp : true|false\"');\n\t\t\t\tobj.allow_clear_temp = !(value.toLowerCase() === 'true' || value === '1' || value === 'on');\n\t\t\t\tbreak;\n\n\t\t\tcase 'disable-strict-server-certificate-validation':\n\t\t\t\tOBSOLETE('disable-strict-server-certificate-validation', 'You need to use \"allow_ssc_validation : true|false\"');\n\t\t\t\tobj.allow_ssc_validation = !(value.toLowerCase() === 'true' || value === '1' || value === 'on');\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-compile': // old\n\t\t\tcase 'allow-compile-html': // old\n\t\t\tcase 'allow-compile-script': // old\n\t\t\tcase 'allow-compile-style': // old\n\t\t\tcase 'allow-ssc-validation': // old\n\t\t\tcase 'allow-debug': // old\n\t\t\tcase 'allow-gzip': // old\n\t\t\tcase 'allow-head': // old\n\t\t\tcase 'allow-performance': // old\n\t\t\tcase 'allow-static-files': // old\n\t\t\tcase 'allow-websocket': // old\n\t\t\tcase 'allow-websocket-compression': // old\n\t\t\tcase 'allow-clear-temp': // old\n\t\t\tcase 'allow-cache-snapshot': // old\n\t\t\tcase 'allow-cache-cluster': // old\n\t\t\tcase 'allow-custom-titles': // old\n\t\t\tcase 'nosql-worker': // old\n\t\t\tcase 'nosql-logger': // old\n\t\t\tcase 'allow-filter-errors': // old\n\t\t\tcase 'default-websocket-encodedecode': // old\n\t\t\tcase 'allow_compile':\n\t\t\tcase 'allow_compile_html':\n\t\t\tcase 'allow_compile_script':\n\t\t\tcase 'allow_compile_style':\n\t\t\tcase 'allow_ssc_validation':\n\t\t\tcase 'allow_debug':\n\t\t\tcase 'allow_gzip':\n\t\t\tcase 'allow_head':\n\t\t\tcase 'allow_performance':\n\t\t\tcase 'allow_static_files':\n\t\t\tcase 'allow_websocket':\n\t\t\tcase 'allow_websocket_compression':\n\t\t\tcase 'allow_clear_temp':\n\t\t\tcase 'allow_cache_snapshot':\n\t\t\tcase 'allow_cache_cluster':\n\t\t\tcase 'allow_filter_errors':\n\t\t\tcase 'allow_custom_titles':\n\t\t\tcase 'trace':\n\t\t\tcase 'nosql_worker':\n\t\t\tcase 'nosql_logger':\n\t\t\tcase 'default_websocket_encodedecode':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = value.toLowerCase() === 'true' || value === '1' || value === 'on';\n\t\t\t\tbreak;\n\n\t\t\tcase 'nosql-inmemory': // old\n\t\t\tcase 'nosql_inmemory':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = typeof(value) === 'string' ? value.split(',').trim() : value instanceof Array ? value : null;\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-compress-html':\n\t\t\t\tobj.allow_compile_html = value.toLowerCase() === 'true' || value === '1' || value === 'on';\n\t\t\t\tbreak;\n\n\t\t\tcase 'version':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'security.txt':\n\t\t\t\tobj[name] = value ? value.split(',').trim().join('\\n') : '';\n\t\t\t\tbreak;\n\n\t\t\t// backward compatibility\n\t\t\tcase 'mail-smtp': // old\n\t\t\tcase 'mail-smtp-options': // old\n\t\t\tcase 'mail-address-from': // old\n\t\t\tcase 'mail-address-copy': // old\n\t\t\tcase 'mail-address-bcc': // old\n\t\t\tcase 'mail-address-reply': // old\n\t\t\tcase 'default-image-converter': // old\n\t\t\tcase 'static-url': // old\n\t\t\tcase 'static-url-script': // old\n\t\t\tcase 'static-url-style': // old\n\t\t\tcase 'static-url-image': // old\n\t\t\tcase 'static-url-video': // old\n\t\t\tcase 'static-url-font': // old\n\t\t\tcase 'static-url-download': // old\n\t\t\tcase 'static-url-components': // old\n\t\t\tcase 'default-xpoweredby': // old\n\t\t\tcase 'default-layout': // old\n\t\t\tcase 'default-theme': // old\n\t\t\tcase 'default-proxy': // old\n\t\t\tcase 'default-timezone': // old\n\t\t\tcase 'default-response-maxage': // old\n\t\t\tcase 'default-errorbuilder-resource-name': // old\n\t\t\tcase 'default-errorbuilder-resource-prefix': // old\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif (subtype === 'string')\n\t\t\t\t\tobj[name] = value;\n\t\t\t\telse if (subtype === 'number' || subtype === 'currency' || subtype === 'float' || subtype === 'double')\n\t\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\telse if (subtype === 'boolean' || subtype === 'bool')\n\t\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\telse if (subtype === 'eval' || subtype === 'object' || subtype === 'array') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tF.error(e, 'F.configure(' + name + ')');\n\t\t\t\t\t}\n\t\t\t\t} else if (subtype === 'json')\n\t\t\t\t\tobj[name] = value.parseJSON();\n\t\t\t\telse if (subtype === 'date' || subtype === 'datetime' || subtype === 'time')\n\t\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\telse if (subtype === 'env' || subtype === 'environment')\n\t\t\t\t\tobj[name] = process.env[value];\n\t\t\t\telse {\n\t\t\t\t\tif (value.isNumber()) {\n\t\t\t\t\t\tobj[name] = value[0] !== '0' ? U.parseInt(value) : value;\n\t\t\t\t\t} else if (value.isNumber(true))\n\t\t\t\t\t\tobj[name] = value.indexOf(',') === -1 && !(/^0{2,}/).test(value) ? U.parseFloat(value) : value;\n\t\t\t\t\telse\n\t\t\t\t\t\tobj[name] = value.isBoolean() ? value.toLowerCase() === 'true' : value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tU.extend(CONF, obj, rewrite);\n\n\tif (!CONF.secret_uid)\n\t\tCONF.secret_uid = (CONF.name).crc32(true).toString();\n\n\tvar tmp = CONF.mail_smtp_options;\n\tif (typeof(tmp) === 'string' && tmp) {\n\t\ttmp = new Function('return ' + tmp)();\n\t\tCONF.mail_smtp_options = tmp;\n\t}\n\n\tprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = CONF.allow_ssc_validation === false ? '0' : '1';\n\n\tif (!CONF.directory_temp)\n\t\tCONF.directory_temp = '~' + U.path(Path.join(Os.tmpdir(), 'totaljs' + F.directory.hash()));\n\n\tif (!CONF.etag_version)\n\t\tCONF.etag_version = CONF.version.replace(/\\.|\\s/g, '');\n\n\tif (CONF.default_timezone)\n\t\tprocess.env.TZ = CONF.default_timezone;\n\n\tCONF.nosql_worker && framework_nosql.worker();\n\tCONF.nosql_inmemory && CONF.nosql_inmemory.forEach(n => framework_nosql.inmemory(n));\n\taccepts && accepts.length && accepts.forEach(accept => CONF.static_accepts[accept] = true);\n\n\tif (CONF.allow_performance)\n\t\thttp.globalAgent.maxSockets = 9999;\n\n\tQUERYPARSEROPTIONS.maxKeys = CONF.default_request_maxkeys || 33;\n\n\tvar xpowered = CONF.default_xpoweredby;\n\n\tObject.keys(HEADERS).forEach(function(key) {\n\t\tObject.keys(HEADERS[key]).forEach(function(subkey) {\n\t\t\tif (RELEASE && subkey === 'Cache-Control')\n\t\t\t\tHEADERS[key][subkey] = HEADERS[key][subkey].replace(/max-age=\\d+/, 'max-age=' + CONF.default_response_maxage);\n\t\t\tif (subkey === 'X-Powered-By') {\n\t\t\t\tif (xpowered)\n\t\t\t\t\tHEADERS[key][subkey] = xpowered;\n\t\t\t\telse\n\t\t\t\t\tdelete HEADERS[key][subkey];\n\t\t\t}\n\t\t});\n\t});\n\n\tIMAGEMAGICK = CONF.default_image_converter === 'im';\n\tdone();\n\tEMIT('configure', CONF);\n\treturn F;\n};\n\nfunction obsolete_config(name) {\n\tif (name.indexOf('-') === -1)\n\t\treturn name;\n\tvar n = name.replace(REG_OLDCONF, '_');\n\tOBSOLETE('config[\\'' + name + '\\']', 'Replace key \"{0}\" to \"{1}\" in your config file'.format(name, n));\n\treturn n;\n}\n\n/**\n * Create URL: JavaScript (according to config['static-url-script'])\n * @param {String} name\n * @return {String}\n */\nF.routeScript = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_script, theme);\n};\n\n/**\n * Create URL: CSS (according to config['static-url-style'])\n * @param {String} name\n * @return {String}\n */\nF.routeStyle = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_style, theme);\n};\n\nF.routeImage = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_image, theme);\n};\n\nF.routeVideo = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_video, theme);\n};\n\nF.routeFont = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_font, theme);\n};\n\nF.routeDownload = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url_download, theme);\n};\n\nF.routeStatic = function(name, theme) {\n\treturn F.$routeStatic(name, CONF.static_url, theme);\n};\n\nF.$routeStatic = function(name, directory, theme) {\n\tvar key = name + directory + '$' + theme;\n\tvar val = F.temporary.other[key];\n\tif (RELEASE && val)\n\t\treturn val;\n\n\n\tif (name[0] === '~') {\n\t\tname = name.substring(name[1] === '~' ? 2 : 1);\n\t\ttheme = '';\n\t} else if (name[0] === '=') {\n\t\t// theme\n\t\tvar index = name.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\ttheme = name.substring(1, index);\n\t\t\tif (theme === '?') {\n\t\t\t\ttheme = CONF.default_theme;\n\t\t\t\tname = name.substring(index);\n\t\t\t} else\n\t\t\t\tname = name.substring(index + 1);\n\t\t}\n\t}\n\n\tvar filename;\n\n\tif (REG_ROUTESTATIC.test(name))\n\t\tfilename = name;\n\telse if (name[0] === '/')\n\t\tfilename = U.join(theme, F.$version(name, true));\n\telse {\n\t\tfilename = U.join(theme, directory, F.$version(name, true));\n\t\tif (REG_HTTPHTTPS.test(filename) && filename[0] === '/')\n\t\t\tfilename = filename.substring(1);\n\t}\n\n\treturn F.temporary.other[key] = framework_internal.preparePath(F.$version(filename, true));\n};\n\nF.$version = function(name, def) {\n\tvar tmp;\n\tif (F.versions)\n\t\ttmp = F.versions[name] || name;\n\tif (F.onVersion)\n\t\ttmp = F.onVersion(name) || name;\n\treturn tmp === 'auto' && def ? name : (tmp || name);\n};\n\nF.$versionprepare = function(html) {\n\tvar match = html.match(REG_VERSIONS);\n\tif (!match)\n\t\treturn html;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\n\t\tvar src = match[i].toString();\n\t\tvar end = 5;\n\n\t\t// href\n\t\tif (src[0] === 'h')\n\t\t\tend = 6;\n\n\t\tvar name = src.substring(end, src.length - 1);\n\t\thtml = html.replace(match[i], src.substring(0, end) + F.$version(name, true) + '\"');\n\t}\n\n\treturn html;\n};\n\n/**\n * Lookup for the route\n * @param {HttpRequest} req\n * @param {String} url URL address.\n * @param {String Array} flags\n * @param {Boolean} membertype Not defined = 0, Authorized = 1, Unauthorized = 2\n * @return {Object}\n */\nF.lookup = function(req, url, flags, membertype) {\n\n\tvar isSystem = url[0] === '#';\n\tvar subdomain = F._length_subdomain_web && req.subdomain ? req.subdomain.join('.') : null;\n\n\tif (isSystem)\n\t\treturn F.routes.system[url];\n\n\tif (isSystem)\n\t\treq.path = [url];\n\n\tvar key;\n\n\t// helper for 401 http status\n\treq.$isAuthorized = true;\n\n\tif (!isSystem) {\n\t\tkey = '1' + url + '$' + membertype + req.$flags + (subdomain ? '$' + subdomain : '') + (req.$roles ? 'R' : '');\n\t\tif (F.temporary.other[key])\n\t\t\treturn F.temporary.other[key];\n\t}\n\n\tvar length = F.routes.web.length;\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.web[i];\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req, flags))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (F._length_subdomain_web && !framework_internal.routeCompareSubdomain(subdomain, route.subdomain))\n\t\t\t\tcontinue;\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (isSystem) {\n\t\t\tif (route.isSYSTEM)\n\t\t\t\treturn route;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags2(req, route, membertype);\n\t\t\tif (result === -1)\n\t\t\t\treq.$isAuthorized = false; // request is not authorized\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (key && route.isCACHE && (req.$isAuthorized || membertype === 1))\n\t\t\tF.temporary.other[key] = route;\n\n\t\treturn route;\n\t}\n\n\treturn null;\n};\n\nF.lookup_websocket = function(req, url, membertype) {\n\n\tvar subdomain = F._length_subdomain_websocket && req.subdomain ? req.subdomain.join('.') : null;\n\tvar length = F.routes.websockets.length;\n\n\treq.$isAuthorized = true;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.websockets[i];\n\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req))\n\t\t\t\tcontinue;\n\t\t} else {\n\n\t\t\tif (F._length_subdomain_websocket && !framework_internal.routeCompareSubdomain(subdomain, route.subdomain))\n\t\t\t\tcontinue;\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, false, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, false))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags2(req, route, membertype);\n\t\t\tif (result === -1)\n\t\t\t\treq.$isAuthorized = false;\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn route;\n\t}\n\n\treturn null;\n};\n\n/**\n * Accept file type\n * @param {String} extension\n * @param {String} contentType Content-Type for file extension, optional.\n * @return {Framework}\n */\nF.accept = function(extension, contentType) {\n\tif (extension[0] === '.')\n\t\textension = extension.substring(1);\n\tCONF.static_accepts[extension] = true;\n\tcontentType && U.setContentType(extension, contentType);\n\treturn F;\n};\n\n// A temporary variable for generating Worker ID\n// It's faster than Date.now()\nvar WORKERID = 0;\n\n/**\n * Run worker\n * @param {String} name\n * @param {String} id Worker id, optional.\n * @param {Number} timeout Timeout, optional.\n * @param {Array} args Additional arguments, optional.\n * @return {ChildProcess}\n */\nglobal.WORKER = F.worker = function(name, id, timeout, args) {\n\n\tvar fork = null;\n\tvar type = typeof(id);\n\n\tif (type === 'number' && timeout === undefined) {\n\t\ttimeout = id;\n\t\tid = null;\n\t\ttype = 'undefined';\n\t}\n\n\tif (type === 'string')\n\t\tfork = F.workers[id];\n\n\tif (id instanceof Array) {\n\t\targs = id;\n\t\tid = null;\n\t\ttimeout = undefined;\n\t}\n\n\tif (timeout instanceof Array) {\n\t\targs = timeout;\n\t\ttimeout = undefined;\n\t}\n\n\tif (fork)\n\t\treturn fork;\n\n\tvar filename = name[0] === '@' ? F.path.package(name.substring(1)) : U.combine(CONF.directory_workers, name);\n\n\tif (!args)\n\t\targs = [];\n\n\tfork = Child.fork(filename[filename.length - 3] === '.' ? filename : filename + '.js', args, HEADERS.workers);\n\n\tif (!id)\n\t\tid = name + '_' + (WORKERID++);\n\n\tfork.__id = id;\n\tF.workers[id] = fork;\n\n\tfork.on('exit', function() {\n\t\tvar self = this;\n\t\tself.__timeout && clearTimeout(self.__timeout);\n\t\tdelete F.workers[self.__id];\n\t\tif (fork) {\n\t\t\tfork.removeAllListeners();\n\t\t\tfork = null;\n\t\t}\n\t});\n\n\tif (typeof(timeout) !== 'number')\n\t\treturn fork;\n\n\tfork.__timeout = setTimeout(function() {\n\t\tfork && fork.kill('SIGKILL');\n\t}, timeout);\n\n\treturn fork;\n};\n\nglobal.WORKER2 = F.worker2 = function(name, args, callback, timeout) {\n\n\tif (typeof(args) === 'function') {\n\t\ttimeout = callback;\n\t\tcallback = args;\n\t\targs = undefined;\n\t} else if (typeof(callback) === 'number') {\n\t\tvar tmp = timeout;\n\t\ttimeout = callback;\n\t\tcallback = tmp;\n\t}\n\n\tif (args && !(args instanceof Array))\n\t\targs = [args];\n\n\tvar fork = F.worker(name, 'worker' + (WORKERID++), timeout, args);\n\tif (fork.__worker2)\n\t\treturn fork;\n\n\tvar output = U.createBufferSize(0);\n\n\tfork.__worker2 = true;\n\tfork.on('error', function(e) {\n\t\tcallback && callback(e, output);\n\t\tcallback = null;\n\t});\n\n\tfork.stdout.on('data', function(data) {\n\t\tCONCAT[0] = output;\n\t\tCONCAT[1] = data;\n\t\toutput = Buffer.concat(CONCAT);\n\t});\n\n\tfork.on('exit', function() {\n\t\tcallback && callback(null, output);\n\t\tcallback = null;\n\t});\n\n\treturn fork;\n};\n\n/**\n * This method suspends\n * @param {String} name Operation name.\n * @param {Boolean} enable Enable waiting (optional, default: by the current state).\n * @return {Boolean}\n */\nF.wait = function(name, enable) {\n\n\tif (!F.waits)\n\t\tF.waits = {};\n\n\tif (enable !== undefined) {\n\t\tif (enable)\n\t\t\tF.waits[name] = true;\n\t\telse\n\t\t\tdelete F.waits[name];\n\t\tF._length_wait = Object.keys(F.waits).length;\n\t\treturn enable;\n\t}\n\n\tif (F.waits[name])\n\t\tdelete F.waits[name];\n\telse {\n\t\tF.waits[name] = true;\n\t\tenable = true;\n\t}\n\n\tF._length_wait = Object.keys(F.waits).length;\n\treturn enable === true;\n};\n\n// =================================================================================\n// Framework route\n// =================================================================================\n\nfunction FrameworkRoute() {\n\tthis.route = {};\n}\n\nFrameworkRoute.prototype = {\n\tget id() {\n\t\treturn this.route.id;\n\t},\n\tset id(value) {\n\t\tthis.route.id = value;\n\t},\n\tget description() {\n\t\treturn this.route.description;\n\t},\n\tset description(value) {\n\t\tthis.route.description = value;\n\t},\n\tget maxlength() {\n\t\treturn this.route.length;\n\t},\n\tset maxlength(value) {\n\t\tthis.route.length = value;\n\t},\n\tget options() {\n\t\treturn this.route.options;\n\t},\n\tset options(value) {\n\t\tthis.route.options = value;\n\t},\n\tget url() {\n\t\treturn this.route.urlraw;\n\t},\n\tget flags() {\n\t\treturn this.route.flags || EMPTYARRAY;\n\t},\n\tset groups(value) {\n\t\tthis.route.groups = value;\n\t},\n\tget groups() {\n\t\treturn this.route.groups;\n\t}\n};\n\nFrameworkRoute.prototype.make = function(fn) {\n\tfn && fn.call(this, this);\n\treturn this;\n};\n\nFrameworkRoute.prototype.setId = function(value) {\n\tthis.route.id = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setDecription = function(value) {\n\tthis.route.description = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setTimeout = function(value) {\n\tthis.route.timeout = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setMaxLength = function(value) {\n\tthis.route.length = value;\n\treturn this;\n};\n\nFrameworkRoute.prototype.setOptions = function(value) {\n\tthis.route.options = value;\n\treturn this;\n};\n\n// =================================================================================\n// Framework path\n// =================================================================================\n\nfunction FrameworkPath() {}\n\nFrameworkPath.prototype.verify = function(name) {\n\tvar prop = '$directory-' + name;\n\tif (F.temporary.path[prop])\n\t\treturn F;\n\tvar directory = CONF['directory_' + name] || name;\n\tvar dir = U.combine(directory);\n\t!existsSync(dir) && Fs.mkdirSync(dir);\n\tF.temporary.path[prop] = true;\n\treturn F;\n};\n\nFrameworkPath.prototype.mkdir = function(p, cache) {\n\n\tvar key = '$directory-' + p;\n\n\tif (cache && F.temporary.path[key])\n\t\treturn F;\n\n\tF.temporary.path[key] = true;\n\n\tvar is = F.isWindows;\n\tvar s = '';\n\n\tif (p[0] === '/') {\n\t\ts = is ? '\\\\' : '/';\n\t\tp = p.substring(1);\n\t}\n\n\tvar l = p.length - 1;\n\tvar beg = 0;\n\n\tif (is) {\n\t\tif (p[l] === '\\\\')\n\t\t\tp = p.substring(0, l);\n\n\t\tif (p[1] === ':')\n\t\t\tbeg = 1;\n\n\t} else {\n\t\tif (p[l] === '/')\n\t\t\tp = p.substring(0, l);\n\t}\n\n\tif (existsSync(p))\n\t\treturn F;\n\n\tvar arr = is ? p.replace(/\\//g, '\\\\').split('\\\\') : p.split('/');\n\tvar directory = s;\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar name = arr[i];\n\t\tif (is)\n\t\t\tdirectory += (i && directory ? '\\\\' : '') + name;\n\t\telse\n\t\t\tdirectory += (i && directory ? '/' : '') + name;\n\n\t\tif (i >= beg && !existsSync(directory))\n\t\t\tFs.mkdirSync(directory);\n\t}\n\n\treturn F;\n};\n\nFrameworkPath.prototype.exists = function(path, callback) {\n\tFs.lstat(path, (err, stats) => callback(err ? false : true, stats ? stats.size : 0, stats ? stats.isFile() : false));\n\treturn F;\n};\n\nFrameworkPath.prototype.public = function(filename) {\n\treturn U.combine(CONF.directory_public, filename);\n};\n\nFrameworkPath.prototype.public_cache = function(filename) {\n\tvar key = 'public_' + filename;\n\tvar item = F.temporary.other[key];\n\treturn item ? item : F.temporary.other[key] = U.combine(CONF.directory_public, filename);\n};\n\nFrameworkPath.prototype.private = function(filename) {\n\treturn U.combine(CONF.directory_private, filename);\n};\n\nFrameworkPath.prototype.isomorphic = function(filename) {\n\treturn U.combine(CONF.directory_isomorphic, filename);\n};\n\nFrameworkPath.prototype.configs = function(filename) {\n\treturn U.combine(CONF.directory_configs, filename);\n};\n\nFrameworkPath.prototype.virtual = function(filename) {\n\treturn U.combine(CONF.directory_public_virtual, filename);\n};\n\nFrameworkPath.prototype.logs = function(filename) {\n\tthis.verify('logs');\n\treturn U.combine(CONF.directory_logs, filename);\n};\n\nFrameworkPath.prototype.models = function(filename) {\n\treturn U.combine(CONF.directory_models, filename);\n};\n\nFrameworkPath.prototype.temp = function(filename) {\n\tthis.verify('temp');\n\treturn U.combine(CONF.directory_temp, filename);\n};\n\nFrameworkPath.prototype.temporary = function(filename) {\n\treturn this.temp(filename);\n};\n\nFrameworkPath.prototype.views = function(filename) {\n\treturn U.combine(CONF.directory_views, filename);\n};\n\nFrameworkPath.prototype.workers = function(filename) {\n\treturn U.combine(CONF.directory_workers, filename);\n};\n\nFrameworkPath.prototype.databases = function(filename) {\n\tthis.verify('databases');\n\treturn U.combine(CONF.directory_databases, filename);\n};\n\nFrameworkPath.prototype.modules = function(filename) {\n\treturn U.combine(CONF.directory_modules, filename);\n};\n\nFrameworkPath.prototype.controllers = function(filename) {\n\treturn U.combine(CONF.directory_controllers, filename);\n};\n\nFrameworkPath.prototype.definitions = function(filename) {\n\treturn U.combine(CONF.directory_definitions, filename);\n};\n\nFrameworkPath.prototype.tests = function(filename) {\n\treturn U.combine(CONF.directory_tests, filename);\n};\n\nFrameworkPath.prototype.resources = function(filename) {\n\treturn U.combine(CONF.directory_resources, filename);\n};\n\nFrameworkPath.prototype.services = function(filename) {\n\treturn U.combine(CONF.directory_services, filename);\n};\n\nFrameworkPath.prototype.packages = function(filename) {\n\treturn U.combine(CONF.directory_packages, filename);\n};\n\nFrameworkPath.prototype.themes = function(filename) {\n\treturn U.combine(CONF.directory_themes, filename);\n};\n\nFrameworkPath.prototype.components = function(filename) {\n\treturn U.combine(CONF.directory_components, filename);\n};\n\nFrameworkPath.prototype.root = function(filename) {\n\tvar p = Path.join(directory, filename || '');\n\treturn F.isWindows ? p.replace(/\\\\/g, '/') : p;\n};\n\nFrameworkPath.prototype.package = function(name, filename) {\n\n\tif (filename === undefined) {\n\t\tvar index = name.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\tfilename = name.substring(index + 1);\n\t\t\tname = name.substring(0, index);\n\t\t}\n\t}\n\n\tvar tmp = CONF.directory_temp;\n\tvar p = tmp[0] === '~' ? Path.join(tmp.substring(1), name + '.package', filename || '') : Path.join(directory, tmp, name + '.package', filename || '');\n\treturn F.isWindows ? p.replace(REG_WINDOWSPATH, '/') : p;\n};\n\n// =================================================================================\n// Cache declaration\n// =================================================================================\n\nfunction FrameworkCache() {\n\tthis.items = {};\n\tthis.count = 1;\n\tthis.interval;\n}\n\nFrameworkCache.prototype.init = function() {\n\tvar self = this;\n\tclearInterval(self.interval);\n\tself.interval = setInterval(() => F.cache.recycle(), 1000 * 60);\n\tif (CONF.allow_cache_snapshot)\n\t\tself.load(() => self.loadpersistent());\n\telse\n\t\tself.loadpersistent();\n\treturn self;\n};\n\nFrameworkCache.prototype.save = function() {\n\tFs.writeFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachesnapshot.jsoncache'), JSON.stringify(this.items), NOOP);\n\treturn this;\n};\n\nFrameworkCache.prototype.load = function(callback) {\n\tvar self = this;\n\tFs.readFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachesnapshot.jsoncache'), function(err, data) {\n\t\tif (!err) {\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(data.toString('utf8'), (key, value) => typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value);\n\t\t\t\tself.items = data;\n\t\t\t} catch (e) {}\n\t\t}\n\t\tcallback && callback();\n\t});\n\treturn self;\n};\n\nFrameworkCache.prototype.savePersist = function() {\n\tsetTimeout2('framework_cachepersist', function(self) {\n\t\tvar keys = Object.keys(self.items);\n\t\tvar obj = {};\n\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tvar item = self.items[key];\n\t\t\tif (item && item.persist)\n\t\t\t\tobj[key] = item;\n\t\t}\n\n\t\tFs.writeFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachepersist.jsoncache'), JSON.stringify(obj), NOOP);\n\t}, 1000, 50, this);\n\treturn this;\n};\n\nFrameworkCache.prototype.loadpersistent = function(callback) {\n\tvar self = this;\n\tFs.readFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachepersist.jsoncache'), function(err, data) {\n\t\tif (!err) {\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(data.toString('utf8'), (key, value) => typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value);\n\t\t\t\tvar keys = Object.keys(data);\n\t\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\tvar item = data[key];\n\t\t\t\t\tif (item.expire >= NOW)\n\t\t\t\t\t\tself.items[key] = item;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\tcallback && callback();\n\t});\n\treturn self;\n};\n\nFrameworkCache.prototype.stop = function() {\n\tclearInterval(this.interval);\n\treturn this;\n};\n\nFrameworkCache.prototype.clear = function(sync) {\n\tthis.items = {};\n\tF.isCluster && sync !== false && CONF.allow_cache_cluster && process.send(CLUSTER_CACHE_CLEAR);\n\tthis.savePersist();\n\treturn this;\n};\n\nFrameworkCache.prototype.recycle = function() {\n\n\tvar items = this.items;\n\tvar isPersist = false;\n\n\tNOW = new Date();\n\n\tthis.count++;\n\n\tfor (var o in items) {\n\t\tvar value = items[o];\n\t\tif (!value)\n\t\t\tdelete items[o];\n\t\telse if (value.expire < NOW) {\n\t\t\tif (value.persist)\n\t\t\t\tisPersist = true;\n\t\t\tEMIT('cache-expire', o, value.value);\n\t\t\tdelete items[o];\n\t\t}\n\t}\n\n\tisPersist && this.savePersist();\n\tCONF.allow_cache_snapshot && this.save();\n\tF.service(this.count);\n\treturn this;\n};\n\nFrameworkCache.prototype.set2 = function(name, value, expire, sync) {\n\treturn this.set(name, value, expire, sync, true);\n};\n\nFrameworkCache.prototype.set = FrameworkCache.prototype.add = function(name, value, expire, sync, persist) {\n\tvar type = typeof(expire);\n\n\tif (F.isCluster && sync !== false && CONF.allow_cache_cluster) {\n\t\tCLUSTER_CACHE_SET.key = name;\n\t\tCLUSTER_CACHE_SET.value = value;\n\t\tCLUSTER_CACHE_SET.expire = expire;\n\t\tprocess.send(CLUSTER_CACHE_SET);\n\t}\n\n\tswitch (type) {\n\t\tcase 'string':\n\t\t\texpire = expire.parseDateExpiration();\n\t\t\tbreak;\n\t\tcase 'undefined':\n\t\t\texpire = NOW.add('m', 5);\n\t\t\tbreak;\n\t}\n\n\tvar obj = { value: value, expire: expire };\n\n\tif (persist) {\n\t\tobj.persist = true;\n\t\tthis.savePersist();\n\t}\n\n\tthis.items[name] = obj;\n\tF.$events['cache-set'] && EMIT('cache-set', name, value, expire, sync !== false);\n\treturn value;\n};\n\nFrameworkCache.prototype.read = FrameworkCache.prototype.get = function(key, def) {\n\n\tvar value = this.items[key];\n\tif (!value)\n\t\treturn def;\n\n\tNOW = new Date();\n\n\tif (value.expire < NOW) {\n\t\tthis.items[key] = undefined;\n\t\tF.$events['cache-expire'] && EMIT('cache-expire', key, value.value);\n\t\treturn def;\n\t}\n\n\treturn value.value;\n};\n\nFrameworkCache.prototype.read2 = FrameworkCache.prototype.get2 = function(key, def) {\n\tvar value = this.items[key];\n\n\tif (!value)\n\t\treturn def;\n\n\tif (value.expire < NOW) {\n\t\tthis.items[key] = undefined;\n\t\tF.$events['cache-expire'] && EMIT('cache-expire', key, value.value);\n\t\treturn def;\n\t}\n\n\treturn value.value;\n};\n\nFrameworkCache.prototype.setExpire = function(name, expire) {\n\tvar obj = this.items[name];\n\tif (obj)\n\t\tobj.expire = typeof(expire) === 'string' ? expire.parseDateExpiration() : expire;\n\treturn this;\n};\n\nFrameworkCache.prototype.remove = function(name, sync) {\n\tvar value = this.items[name];\n\n\tif (value) {\n\t\tthis.items[name].persist && this.savePersist();\n\t\tthis.items[name] = undefined;\n\t}\n\n\tif (F.isCluster && sync !== false && CONF.allow_cache_cluster) {\n\t\tCLUSTER_CACHE_REMOVE.key = name;\n\t\tprocess.send(CLUSTER_CACHE_REMOVE);\n\t}\n\n\treturn value;\n};\n\nFrameworkCache.prototype.removeAll = function(search, sync) {\n\tvar count = 0;\n\tvar isReg = U.isRegExp(search);\n\n\tfor (var key in this.items) {\n\n\t\tif (isReg) {\n\t\t\tif (!search.test(key))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (key.indexOf(search) === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tthis.remove(key);\n\t\tcount++;\n\t}\n\n\tif (F.isCluster && sync !== false && CONF.allow_cache_cluster) {\n\t\tCLUSTER_CACHE_REMOVEALL.key = search;\n\t\tprocess.send(CLUSTER_CACHE_REMOVEALL);\n\t}\n\n\treturn count;\n};\n\nFrameworkCache.prototype.fn = function(name, fnCache, fnCallback) {\n\n\tvar self = this;\n\tvar value = self.read2(name);\n\n\tif (value) {\n\t\tfnCallback && fnCallback(value, true);\n\t\treturn self;\n\t}\n\n\tfnCache(function(value, expire) {\n\t\tself.add(name, value, expire);\n\t\tfnCallback && fnCallback(value, false);\n\t});\n\n\treturn self;\n};\n\nfunction subscribe_timeout(req) {\n\treq.controller && req.controller.precache && req.controller.precache(null, null, null);\n\treq.$total_cancel();\n}\n\nfunction subscribe_timeout_middleware(req) {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\treq.$total_execute2();\n}\n\nfunction subscribe_validate_callback(req, code) {\n\treq.$total_execute(code);\n}\n\n/**\n * FrameworkController\n * @class\n * @param {String} name Controller name.\n * @param {Request} req\n * @param {Response} res\n * @param {FrameworkSubscribe} subscribe\n */\nfunction Controller(name, req, res, currentView) {\n\n\tthis.name = name;\n\t// this.exception;\n\n\t// Sets the default language\n\tif (req) {\n\t\tthis.language = req.$language;\n\t\tthis.req = req;\n\t\tthis.route = req.$total_route;\n\t} else\n\t\tthis.req = EMPTYREQUEST;\n\n\t// controller.type === 0 - classic\n\t// controller.type === 1 - server sent events\n\t// this.type = 0;\n\n\t// this.layoutName =CONF.default_layout;\n\t// this.themeName =CONF.default_theme;\n\t// this.status = 200;\n\n\t// this.isLayout = false;\n\t// this.isCanceled = false;\n\t// this.isTimeout = false;\n\t// this.isTransfer = false;\n\n\tthis.isConnected = true;\n\tthis.isController = true;\n\n\t// render output\n\t// this.output = null;\n\t// this.outputPartial = null;\n\t// this.$model = null;\n\n\tthis._currentView = currentView;\n\n\tif (res) {\n\t\tthis.res = res;\n\t\tthis.req.controller = this.res.controller = this;\n\t} else\n\t\tthis.res = EMPTYOBJECT;\n}\n\nController.prototype = {\n\n\tget repository() {\n\t\tif (this.$repository)\n\t\t\treturn this.$repository;\n\t\telse\n\t\t\treturn this.$repository ? this.$repository : (this.$repository = {});\n\t},\n\n\tset repository(val) {\n\t\tthis.$repository = val;\n\t},\n\n\tget schema() {\n\t\treturn this.route.schema[0] === 'default' ? this.route.schema[1] : this.route.schema.join('/');\n\t},\n\n\tget workflow() {\n\t\treturn this.route.schema_workflow;\n\t},\n\n\tget sseID() {\n\t\treturn this.req.headers['last-event-id'] || null;\n\t},\n\n\tget options() {\n\t\treturn this.route.options;\n\t},\n\n\tget split() {\n\t\treturn this.req.split;\n\t},\n\n\tget flags() {\n\t\treturn this.route.flags;\n\t},\n\n\tget path() {\n\t\tOBSOLETE('controller.path', 'Use: PATH');\n\t\treturn F.path;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget subdomain() {\n\t\treturn this.req.subdomain;\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget xhr() {\n\t\treturn this.req.xhr;\n\t},\n\n\tget url() {\n\t\treturn U.path(this.req.uri.pathname);\n\t},\n\n\tget uri() {\n\t\treturn this.req.uri;\n\t},\n\n\tget cache() {\n\t\tOBSOLETE('controller.cache', 'Use: F.cache or CACHE()');\n\t\treturn F.cache;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn CONF;\n\t},\n\n\tget controllers() {\n\t\treturn F.controllers;\n\t},\n\n\tget isTest() {\n\t\treturn this.req.headers['x-assertion-testing'] === '1';\n\t},\n\n\tget isSecure() {\n\t\tOBSOLETE('controller.isSecure', 'Use: controller.secured');\n\t\treturn this.req.isSecure;\n\t},\n\n\tget secured() {\n\t\treturn this.req.secured;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tset session(value) {\n\t\tthis.req.session = value;\n\t},\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tget referrer() {\n\t\treturn this.req.headers['referer'] || '';\n\t},\n\n\tset user(value) {\n\t\tthis.req.user = value;\n\t},\n\n\tget mobile() {\n\t\treturn this.req.mobile;\n\t},\n\n\tget robot() {\n\t\treturn this.req.robot;\n\t},\n\n\tget viewname() {\n\t\tvar name = this.req.path[this.req.path.length - 1];\n\t\treturn !name || name === '/' ? 'index' : name;\n\t},\n\n\tget sitemapid() {\n\t\treturn this.$sitemapid || this.route.sitemap;\n\t},\n\n\tget params() {\n\t\tif (this.$params)\n\t\t\treturn this.$params;\n\t\tvar route = this.route;\n\t\tvar names = route.paramnames;\n\t\tif (names) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < names.length; i++)\n\t\t\t\tobj[names[i]] = this.req.split[route.param[i]];\n\t\t\tthis.$params = obj;\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tthis.$params = EMPTYOBJECT;\n\t\t\treturn EMPTYOBJECT;\n\t\t}\n\t}\n};\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\n// Schema operations\n\nController.prototype.$get = Controller.prototype.$read = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tthis.getSchema().get(helper, callback, this);\n\treturn this;\n};\n\nController.prototype.$query = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tthis.getSchema().query(helper, callback, this);\n\treturn this;\n};\n\nController.prototype.$save = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$save(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$save(helper, callback);\n\t}\n\treturn self;\n};\n\nController.prototype.$insert = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$insert(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$insert(helper, callback);\n\t}\n\treturn self;\n};\n\nController.prototype.$update = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$update(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$update(helper, callback);\n\t}\n\treturn self;\n};\n\nController.prototype.$remove = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tself.getSchema().remove(helper, callback, self);\n\treturn this;\n};\n\nController.prototype.$workflow = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$workflow(name, helper, callback);\n\t} else\n\t\tself.getSchema().workflow2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$workflow2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tself.getSchema().workflow2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$hook = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$hook(name, helper, callback);\n\t} else\n\t\tself.getSchema().hook2(name, helper, callback, self);\n\n\treturn self;\n};\n\nController.prototype.$hook2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().hook2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$transform = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$transform(name, helper, callback);\n\t} else\n\t\tself.getSchema().transform2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$transform2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().transform2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$operation = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$operation(name, helper, callback);\n\t} else\n\t\tself.getSchema().operation2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.operation = function(name, value, callback, options) {\n\tOPERATION(name, value, callback, options, this);\n\treturn this;\n};\n\nController.prototype.tasks = function() {\n\tvar tb = new TaskBuilder(this);\n\t// tb.callback(this.callback());\n\treturn tb;\n};\n\nController.prototype.$operation2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().operation2(name, helper, callback, self);\n\treturn self;\n};\n\nController.prototype.$exec = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tif (callback == null)\n\t\tcallback = self.callback();\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$exec(name, helper, callback);\n\t\treturn self;\n\t}\n\n\tvar tmp = self.getSchema().create();\n\ttmp.$$controller = self;\n\ttmp.$exec(name, helper, callback);\n\treturn self;\n};\n\nController.prototype.$async = function(callback, index) {\n\tvar self = this;\n\n\tif (framework_builders.isSchema(self.body)) {\n\t\tself.body.$$controller = self;\n\t\treturn self.body.$async(callback, index);\n\t}\n\n\tvar model = self.getSchema().default();\n\tmodel.$$controller = self;\n\treturn model.$async(callback, index);\n};\n\nController.prototype.getSchema = function() {\n\tvar route = this.route;\n\tif (!route.schema || !route.schema[1])\n\t\tthrow new Error('The controller\\'s route does not define any schema.');\n\tvar schema = route.isDYNAMICSCHEMA ? framework_builders.findschema(route.schema[0] + '/' + this.params[route.schema[1]]) : GETSCHEMA(route.schema[0], route.schema[1]);\n\tif (schema)\n\t\treturn schema;\n\tthrow new Error('Schema \"{0}\" does not exist.'.format(route.schema[1]));\n};\n\n/**\n * Renders component\n * @param {String} name A component name\n * @param {Object} settings Optional, settings.\n * @model {Object} settings Optional, model for the component.\n * @return {String}\n */\nController.prototype.component = function(name, settings, model) {\n\tvar filename = F.components.views[name];\n\tif (filename) {\n\t\tvar self = this;\n\t\tvar generator = framework_internal.viewEngine(name, filename, self, true);\n\t\tif (generator) {\n\t\t\tif (generator.components.length) {\n\t\t\t\tif (!self.repository[REPOSITORY_COMPONENTS])\n\t\t\t\t\tself.repository[REPOSITORY_COMPONENTS] = {};\n\t\t\t\tfor (var i = 0; i < generator.components.length; i++)\n\t\t\t\t\tself.repository[REPOSITORY_COMPONENTS][generator.components[i]] = 1;\n\t\t\t}\n\t\t\treturn generator.call(self, self, self.repository, model || self.$model, self.session, self.query, self.body, self.url, F.global, F.helpers, self.user, CONF, F.functions, 0, self.outputPartial, self.req.files, self.req.mobile, settings || EMPTYOBJECT);\n\t\t}\n\t}\n\treturn '';\n};\n\nController.prototype.$components = function(group, settings) {\n\n\tif (group) {\n\t\tvar keys = Object.keys(F.components.instances);\n\t\tvar output = [];\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar component = F.components.instances[keys[i]];\n\t\t\tif (component.group === group) {\n\t\t\t\tif (component.render) {\n\t\t\t\t\t!this.$viewasync && (this.$viewasync = []);\n\t\t\t\t\t$VIEWASYNC++;\n\t\t\t\t\tvar name = '@{-' + $VIEWASYNC + '-}';\n\t\t\t\t\tthis.$viewasync.push({ replace: name, name: component.name, settings: settings });\n\t\t\t\t\toutput.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tvar tmp = this.component(keys[i], settings);\n\t\t\t\t\ttmp && output.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output.join('\\n');\n\t}\n\n\treturn '';\n};\n\n/**\n * Reads / Writes cookie\n * @param {String} name\n * @param {String} value\n * @param {String/Date} expires\n * @param {Object} options\n * @return {String/Controller}\n */\nController.prototype.cookie = function(name, value, expires, options) {\n\tvar self = this;\n\tif (value === undefined)\n\t\treturn self.req.cookie(name);\n\tself.res.cookie(name, value, expires, options);\n\treturn self;\n};\n\n/**\n * Clears uploaded files\n * @return {Controller}\n */\nController.prototype.clear = function() {\n\tvar self = this;\n\tself.req.clear();\n\treturn self;\n};\n\n/**\n * Translates text\n * @param {String} text\n * @return {String}\n */\nController.prototype.translate = function(language, text) {\n\n\tif (!text) {\n\t\ttext = language;\n\t\tlanguage = this.language;\n\t}\n\n\treturn F.translate(language, text);\n};\n\n/**\n * Exec middleware\n * @param {String Array} names Middleware name.\n * @param {Object} options Custom options for middleware.\n * @param {Function} callback\n * @return {Controller}\n */\nController.prototype.middleware = function(names, options, callback) {\n\n\tif (typeof(names) === 'string')\n\t\tnames = [names];\n\n\tif (typeof(options) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = options;\n\t\toptions = tmp;\n\t}\n\n\tif (!options)\n\t\toptions = EMPTYOBJECT;\n\n\tvar self = this;\n\n\tif (self.req.$total_middleware)\n\t\tself.req.$total_middleware = null;\n\n\tasync_middleware(0, self.req, self.res, names, () => callback && callback(), options, self);\n\treturn self;\n};\n\n/**\n * Creates a pipe between the current request and target URL\n * @param {String} url\n * @param {Object} headers Optional, custom headers.\n * @param {Function(err)} callback Optional.\n * @return {Controller}\n */\nController.prototype.pipe = function(url, headers, callback) {\n\tthis.res.proxy(url, headers, null, callback);\n\treturn this;\n};\n\nController.prototype.encrypt = function() {\n\treturn F.encrypt.apply(framework, arguments);\n};\n\nController.prototype.decrypt = function() {\n\treturn F.decrypt.apply(framework, arguments);\n};\n\n/**\n * Creates a hash (alias for F.hash())\n * @return {Controller}\n */\nController.prototype.hash = function() {\n\treturn F.hash.apply(framework, arguments);\n};\n\n/**\n * Sets a response header\n * @param {String} name\n * @param {String} value\n * @return {Controller}\n */\nController.prototype.header = function(name, value) {\n\tthis.res.setHeader(name, value);\n\treturn this;\n};\n\n/**\n * Gets a hostname\n * @param {String} path\n * @return {Controller}\n */\nController.prototype.host = function(path) {\n\treturn this.req.hostname(path);\n};\n\nController.prototype.hostname = function(path) {\n\treturn this.req.hostname(path);\n};\n\nController.prototype.resource = function(name, key) {\n\treturn F.resource(name, key);\n};\n\n/**\n * Error caller\n * @param {Error/String} err\n * @return {Controller/Function}\n */\nController.prototype.error = function(err) {\n\tvar self = this;\n\n\t// Custom errors\n\tif (err instanceof ErrorBuilder) {\n\t\tself.content(err);\n\t\treturn self;\n\t}\n\n\tvar result = F.error(typeof(err) === 'string' ? new Error(err) : err, self.name, self.uri);\n\tif (err === undefined)\n\t\treturn result;\n\n\tself.req.$total_exception = err;\n\tself.exception = err;\n\treturn self;\n};\n\nController.prototype.invalid = function(status) {\n\n\tvar self = this;\n\n\tif (status instanceof ErrorBuilder) {\n\t\tsetImmediate(next_controller_invalid, self, status);\n\t\treturn status;\n\t}\n\n\tvar type = typeof(status);\n\n\tif (type === 'number')\n\t\tself.status = status;\n\n\tvar builder = new ErrorBuilder();\n\n\tif (type === 'string')\n\t\tbuilder.push(status);\n\n\tsetImmediate(next_controller_invalid, self, builder);\n\treturn builder;\n};\n\nfunction next_controller_invalid(self, builder) {\n\tself.content(builder);\n}\n\n/**\n * Registers a new problem\n * @param {String} message\n * @return {Controller}\n */\nController.prototype.wtf = Controller.prototype.problem = function(message) {\n\tF.problem(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Registers a new change\n * @param {String} message\n * @return {Controller}\n */\nController.prototype.change = function(message) {\n\tF.change(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Trace\n * @param {String} message\n * @return {Controller}\n */\nController.prototype.trace = function(message) {\n\tF.trace(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Transfer to new route\n * @param {String} url Relative URL.\n * @param {String Array} flags Route flags (optional).\n * @return {Boolean}\n */\nController.prototype.transfer = function(url, flags) {\n\n\tvar self = this;\n\tvar length = F.routes.web.length;\n\tvar path = framework_internal.routeSplit(url.trim());\n\n\tvar isSystem = url[0] === '#';\n\tvar noFlag = !flags || flags.length === 0 ? true : false;\n\tvar selected = null;\n\n\tself.req.$isAuthorized = true;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.web[i];\n\n\t\tif (route.isWILDCARD) {\n\t\t\tif (!framework_internal.routeCompare(path, route.url, isSystem, true))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!framework_internal.routeCompare(path, route.url, isSystem))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (noFlag) {\n\t\t\tselected = route;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags(route.flags, flags, true);\n\t\t\tif (result === -1)\n\t\t\t\tself.req.$isAuthorized = false;\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tselected = route;\n\t\tbreak;\n\t}\n\n\n\tif (!selected)\n\t\treturn false;\n\n\tself.cancel();\n\tself.req.path = EMPTYARRAY;\n\tself.req.$total_transfer = true;\n\tself.req.$total_success();\n\n\t// Because of dynamic params\n\t// Hidden variable\n\tself.req.$path = framework_internal.routeSplit(url, true);\n\n\tself.route = self.req.$total_route = selected;\n\tself.req.$total_execute(404);\n\treturn true;\n};\n\nController.prototype.cancel = function() {\n\tthis.isCanceled = true;\n\treturn this;\n};\n\nController.prototype.log = function() {\n\tF.log.apply(F, arguments);\n\treturn this;\n};\n\nController.prototype.logger = function() {\n\tF.logger.apply(F, arguments);\n\treturn this;\n};\n\nController.prototype.meta = function() {\n\tvar self = this;\n\n\tif (arguments[0])\n\t\tself.repository[REPOSITORY_META_TITLE] = arguments[0];\n\n\tif (arguments[1])\n\t\tself.repository[REPOSITORY_META_DESCRIPTION] = arguments[1];\n\n\tif (arguments[2] && arguments[2].length)\n\t\tself.repository[REPOSITORY_META_KEYWORDS] = arguments[2] instanceof Array ? arguments[2].join(', ') : arguments[2];\n\n\tif (arguments[3])\n\t\tself.repository[REPOSITORY_META_IMAGE] = arguments[3];\n\n\treturn self;\n};\n\nController.prototype.$dns = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"dns-prefetch\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nController.prototype.$prefetch = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"prefetch\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nController.prototype.$prerender = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"prerender\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nController.prototype.$next = function(value) {\n\tthis.head('<link rel=\"next\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nController.prototype.$prev = function(value) {\n\tthis.head('<link rel=\"prev\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nController.prototype.$canonical = function(value) {\n\tthis.head('<link rel=\"canonical\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nController.prototype.$meta = function() {\n\tvar self = this;\n\n\tif (arguments.length) {\n\t\tself.meta.apply(self, arguments);\n\t\treturn '';\n\t}\n\n\tF.$events['controller-render-meta'] && EMIT('controller-render-meta', self);\n\tvar repository = self.repository;\n\treturn F.onMeta.call(self, repository[REPOSITORY_META_TITLE], repository[REPOSITORY_META_DESCRIPTION], repository[REPOSITORY_META_KEYWORDS], repository[REPOSITORY_META_IMAGE]);\n};\n\nController.prototype.title = function(value) {\n\tthis.$title(value);\n\treturn this;\n};\n\nController.prototype.description = function(value) {\n\tthis.$description(value);\n\treturn this;\n};\n\nController.prototype.keywords = function(value) {\n\tthis.$keywords(value);\n\treturn this;\n};\n\nController.prototype.author = function(value) {\n\tthis.$author(value);\n\treturn this;\n};\n\nController.prototype.$title = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_TITLE] = value;\n\treturn '';\n};\n\nController.prototype.$title2 = function(value) {\n\tvar current = this.repository[REPOSITORY_META_TITLE];\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_TITLE] = (current ? current : '') + value;\n\treturn '';\n};\n\nController.prototype.$description = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_DESCRIPTION] = value;\n\treturn '';\n};\n\nController.prototype.$keywords = function(value) {\n\tif (value && value.length)\n\t\tthis.repository[REPOSITORY_META_KEYWORDS] = value instanceof Array ? value.join(', ') : value;\n\treturn '';\n};\n\nController.prototype.$author = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_AUTHOR] = value;\n\treturn '';\n};\n\nController.prototype.sitemap_navigation = function(name, language) {\n\treturn F.sitemap_navigation(name || this.sitemapid, language || this.language);\n};\n\nController.prototype.sitemap_url = function(name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, this.language);\n\treturn item ? item.url.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_name = function(name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, this.language);\n\treturn item ? item.name.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_url2 = function(language, name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, language);\n\treturn item ? item.url.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_name2 = function(language, name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, language);\n\treturn item ? item.name.format(a, b, c, d, e, f) : '';\n};\n\nController.prototype.sitemap_add = function(parent, name, url) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tvar index = sitemap.findIndex('id', parent);\n\tif (index === -1)\n\t\treturn sitemap;\n\n\tvar obj = { sitemap: '', id: '', name: name, url: url, last: false, first: false, index: index, wildcard: false, formatName: false, formatUrl: false, localizeName: false, localizeUrl: false };\n\n\tsitemap.splice(index + 1, 0, obj);\n\n\tif (index) {\n\t\tvar tmp = index;\n\t\tfor (var i = index + 1; i > -1; i--)\n\t\t\tsitemap[i].index = tmp++;\n\t}\n\n\treturn sitemap;\n};\n\nController.prototype.sitemap_change = function(name, type, a, b, c, d, e, f) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tif (!sitemap.$cloned) {\n\t\tsitemap = U.clone(sitemap);\n\t\tsitemap.$cloned = true;\n\t\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\t}\n\n\tvar isFn = typeof(a) === 'function';\n\n\tfor (var i = 0, length = sitemap.length; i < length; i++) {\n\n\t\tvar item = sitemap[i];\n\t\tif (item.id !== name)\n\t\t\tcontinue;\n\n\t\tvar tmp = item[type];\n\n\t\tif (isFn)\n\t\t\titem[type] = a(item[type]);\n\t\telse if (type === 'name')\n\t\t\titem[type] = item.formatName ? item[type].format(a, b, c, d, e, f) : a;\n\t\telse if (type === 'url')\n\t\t\titem[type] = item.formatUrl ? item[type].format(a, b, c, d, e, f) : a;\n\t\telse\n\t\t\titem[type] = a;\n\n\t\tif (type === 'name' && self.repository[REPOSITORY_META_TITLE] === tmp)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = item[type];\n\n\t\treturn sitemap;\n\t}\n\n\treturn sitemap;\n};\n\nController.prototype.sitemap_replace = function(name, title, url) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tif (!sitemap.$cloned) {\n\t\tsitemap = U.clone(sitemap);\n\t\tsitemap.$cloned = true;\n\t\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\t}\n\n\tfor (var i = 0, length = sitemap.length; i < length; i++) {\n\t\tvar item = sitemap[i];\n\t\tif (item.id !== name)\n\t\t\tcontinue;\n\n\t\tvar is = self.repository[REPOSITORY_META_TITLE] === item.name;\n\n\t\tif (title)\n\t\t\titem.name = typeof(title) === 'function' ? title(item.name) : item.formatName ? item.name.format(title) : title;\n\n\t\tif (url)\n\t\t\titem.url = typeof(url) === 'function' ? url(item.url) : item.formatUrl ? item.url.format(url) : url;\n\n\t\tif (is)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = item.name;\n\n\t\treturn sitemap;\n\t}\n\n\treturn sitemap;\n};\n\n// Arguments: parent, name, url\nController.prototype.$sitemap_add = function(parent, name, url) {\n\tthis.sitemap_add(parent, name, url);\n\treturn '';\n};\n\n// Arguments: name, type, value, format\nController.prototype.$sitemap_change = function(a, b, c, d, e, f, g, h) {\n\tthis.sitemap_change(a, b, c, d, e, f, g, h);\n\treturn '';\n};\n\n// Arguments: name, title, url\nController.prototype.$sitemap_replace =function(a, b, c) {\n\tthis.sitemap_replace(a, b, c);\n\treturn '';\n};\n\nController.prototype.sitemap = function(name) {\n\tvar self = this;\n\tvar sitemap;\n\n\tif (!name) {\n\t\tsitemap = self.repository[REPOSITORY_SITEMAP];\n\t\tif (!sitemap && (self.$sitemapid || self.route.sitemap))\n\t\t\treturn self.sitemap(self.$sitemapid || self.route.sitemap);\n\t\treturn sitemap ? sitemap : self.repository.sitemap || EMPTYARRAY;\n\t}\n\n\tif (name instanceof Array) {\n\t\tself.repository[REPOSITORY_SITEMAP] = name;\n\t\treturn self;\n\t}\n\n\tself.$sitemapid = name;\n\tsitemap = U.clone(F.sitemap(name, false, self.language));\n\tsitemap.$cloned = true;\n\n\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\n\tif (!self.repository[REPOSITORY_META_TITLE]) {\n\t\tsitemap = sitemap.last();\n\t\tif (sitemap)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = sitemap.name;\n\t}\n\n\treturn self.repository[REPOSITORY_SITEMAP];\n};\n\n// Arguments: name\nController.prototype.$sitemap = function(name) {\n\tvar self = this;\n\tself.sitemap(name);\n\treturn '';\n};\n\nController.prototype.module = function(name) {\n\treturn F.module(name);\n};\n\nController.prototype.layout = function(name) {\n\tvar self = this;\n\tself.layoutName = name;\n\treturn self;\n};\n\nController.prototype.theme = function(name) {\n\tvar self = this;\n\tself.themeName = name;\n\treturn self;\n};\n\n/**\n * Layout setter for views\n * @param {String} name Layout name\n * @return {String}\n */\nController.prototype.$layout = function(name) {\n\tvar self = this;\n\tself.layoutName = name;\n\treturn '';\n};\n\nController.prototype.model = function(name) {\n\treturn F.model(name);\n};\n\n/**\n * Send e-mail\n * @param {String or Array} address E-mail address.\n * @param {String} subject E-mail subject.\n * @param {String} view View name.\n * @param {Object} model Optional.\n * @param {Function(err)} callback Optional.\n * @return {MailMessage}\n */\nController.prototype.mail = function(address, subject, view, model, callback) {\n\n\tif (typeof(model) === 'function') {\n\t\tcallback = model;\n\t\tmodel = null;\n\t}\n\n\tvar self = this;\n\n\tif (typeof(self.language) === 'string')\n\t\tsubject = subject.indexOf('@(') === -1 ? F.translate(self.language, subject) : F.translator(self.language, subject);\n\n\t// Backup layout\n\tvar layoutName = self.layoutName;\n\tvar body = self.view(view, model, true);\n\n\tvar message;\n\n\tif (body instanceof Function) {\n\t\tmessage = F.onMail(address, subject, '');\n\t\tmessage.manually();\n\t\tbody(function(err, body) {\n\t\t\tmessage.body = body;\n\t\t\tmessage.send2(callback);\n\t\t});\n\t} else {\n\t\tmessage = F.onMail(address, subject, body, callback);\n\t\tself.layoutName = layoutName;\n\t}\n\n\treturn message;\n};\n\nController.prototype.$template = function(name, model, expire, key) {\n\treturn this.$viewToggle(true, name, model, expire, key);\n};\n\nController.prototype.$templateToggle = function(visible, name, model, expire, key) {\n\treturn this.$viewToggle(visible, name, model, expire, key);\n};\n\nController.prototype.$view = function(name, model, expire, key) {\n\n\tvar self = this;\n\tvar cache;\n\n\tif (expire) {\n\t\tcache = '$view.' + name + '.' + (key || '');\n\t\tvar output = F.cache.read2(cache);\n\t\tif (output)\n\t\t\treturn output.body;\n\t}\n\n\tvar value = self.view(name, model, null, true, true, cache);\n\n\tif (!value)\n\t\treturn '';\n\n\texpire && F.cache.add(cache, { components: value instanceof Function, body: value instanceof Function ? '' : value }, expire, false);\n\treturn value;\n};\n\nController.prototype.$viewCompile = function(body, model, key) {\n\tvar self = this;\n\tvar layout = self.layoutName;\n\tself.layoutName = '';\n\tvar value = self.viewCompile(body, model, null, true, key);\n\tself.layoutName = layout;\n\treturn value || '';\n};\n\nController.prototype.$viewToggle = function(visible, name, model, expire, key, async) {\n\treturn visible ? this.$view(name, model, expire, key, async) : '';\n};\n\n/**\n * Adds a place into the places.\n * @param {String} name A place name.\n * @param {String} arg1 A content 1, optional\n * @param {String} arg2 A content 2, optional\n * @param {String} argN A content 2, optional\n * @return {String/Controller} String is returned when the method contains only `name` argument\n */\nController.prototype.place = function(name) {\n\n\tvar key = REPOSITORY_PLACE + '_' + name;\n\tvar length = arguments.length;\n\n\tif (length === 1)\n\t\treturn this.repository[key] || '';\n\n\tvar output = '';\n\tfor (var i = 1; i < length; i++) {\n\t\tvar val = arguments[i];\n\n\t\tif (val)\n\t\t\tval = val.toString();\n\t\telse\n\t\t\tval = '';\n\n\t\tswitch (U.getExtension(val)) {\n\t\t\tcase 'js':\n\t\t\t\tval = '<script src=\"' + val + '\"></script>';\n\t\t\t\tbreak;\n\t\t\tcase 'css':\n\t\t\t\tval = '<link rel=\"stylesheet\" href=\"' + val + '\" />';\n\t\t\t\tbreak;\n\t\t}\n\n\t\toutput += val;\n\t}\n\n\tthis.repository[key] = (this.repository[key] || '') + output;\n\treturn this;\n};\n\n/**\n * Adds a content into the section\n * @param {String} name A section name.\n * @param {String} value A content.\n * @param {Boolean} replace Optional, default `false` otherwise concats contents.\n * @return {String/Controller} String is returned when the method contains only `name` argument\n */\nController.prototype.section = function(name, value, replace) {\n\n\tvar key = '$section_' + name;\n\n\tif (value === undefined)\n\t\treturn this.repository[key];\n\n\tif (replace) {\n\t\tthis.repository[key] = value;\n\t\treturn this;\n\t}\n\n\tif (this.repository[key])\n\t\tthis.repository[key] += value;\n\telse\n\t\tthis.repository[key] = value;\n\n\treturn this;\n};\n\nController.prototype.$place = function() {\n\tvar self = this;\n\tif (arguments.length === 1)\n\t\treturn self.place.apply(self, arguments);\n\tself.place.apply(self, arguments);\n\treturn '';\n};\n\nController.prototype.$url = function(host) {\n\treturn host ? this.req.hostname(this.url) : this.url;\n};\n\n// Argument: name\nController.prototype.$helper = function() {\n\treturn this.helper.apply(this, arguments);\n};\n\nfunction querystring_encode(value, def, key) {\n\n\tif (value instanceof Array) {\n\t\tvar tmp = '';\n\t\tfor (var i = 1; i < value.length; i++)\n\t\t\ttmp += (tmp ? '&' : '') + key + '=' + querystring_encode(value[i], def);\n\t\treturn querystring_encode(value[0], def) + (tmp ? tmp : '');\n\t}\n\n\treturn value != null ? value instanceof Date ? encodeURIComponent(value.format()) : typeof(value) === 'string' ? encodeURIComponent(value) : value.toString() : def || '';\n}\n\n// @{href({ key1: 1, key2: 2 })}\n// @{href('key', 'value')}\nController.prototype.href = function(key, value) {\n\tvar self = this;\n\n\tif (!arguments.length) {\n\t\tvar val = Qs.stringify(self.query);\n\t\treturn val ? '?' + val : '';\n\t}\n\n\tvar type = typeof(key);\n\tvar obj;\n\n\tif (type === 'string') {\n\n\t\tvar cachekey = '$href' + key;\n\t\tvar str = self[cachekey] || '';\n\n\t\tif (!str) {\n\n\t\t\tobj = U.copy(self.query);\n\n\t\t\tfor (var i = 2; i < arguments.length; i++)\n\t\t\t\tobj[arguments[i]] = undefined;\n\n\t\t\tobj[key] = '\\0';\n\n\t\t\tvar arr = Object.keys(obj);\n\t\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\t\tvar val = obj[arr[i]];\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tif (val instanceof Array) {\n\t\t\t\t\t\tfor (var j = 0; j < val.length; j++)\n\t\t\t\t\t\t\tstr += (str ? '&' : '') + arr[i] + '=' + (key === arr[i] ? '\\0' : querystring_encode(val[j]));\n\t\t\t\t\t} else\n\t\t\t\t\t\tstr += (str ? '&' : '') + arr[i] + '=' + (key === arr[i] ? '\\0' : querystring_encode(val));\n\t\t\t\t}\n\t\t\t}\n\t\t\tself[cachekey] = str;\n\t\t}\n\n\t\tstr = str.replace('\\0', querystring_encode(value, self.query[key], key));\n\n\t\tfor (var i = 2; i < arguments.length; i++) {\n\t\t\tvar beg = str.indexOf(arguments[i] + '=');\n\t\t\tif (beg === -1)\n\t\t\t\tcontinue;\n\t\t\tvar end = str.indexOf('&', beg);\n\t\t\tstr = str.substring(0, beg) + str.substring(end === -1 ? str.length : end + 1);\n\t\t}\n\n\t\treturn str ? '?' + str : '';\n\t}\n\n\tif (value) {\n\t\tobj = U.copy(self.query);\n\t\tU.extend(obj, value);\n\t}\n\n\tif (value != null)\n\t\tobj[key] = value;\n\n\tobj = Qs.stringify(obj);\n\n\tif (value === undefined && type === 'string')\n\t\tobj += (obj ? '&' : '') + key;\n\n\treturn self.url + (obj ? '?' + obj : '');\n};\n\nController.prototype.$checked = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'checked=\"checked\"');\n};\n\nController.prototype.$disabled = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'disabled=\"disabled\"');\n};\n\nController.prototype.$selected = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'selected=\"selected\"');\n};\n\n/**\n * Fake function for assign value\n * @private\n * @param {Object} value Value to eval.\n * return {String} Returns empty string.\n */\n// Argument: value\nController.prototype.$set = function() {\n\treturn '';\n};\n\nController.prototype.$readonly = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'readonly=\"readonly\"');\n};\n\nController.prototype.$header = function(name, value) {\n\tthis.header(name, value);\n\treturn '';\n};\n\nController.prototype.$text = function(model, name, attr) {\n\treturn this.$input(model, 'text', name, attr);\n};\n\nController.prototype.$password = function(model, name, attr) {\n\treturn this.$input(model, 'password', name, attr);\n};\n\nController.prototype.$hidden = function(model, name, attr) {\n\treturn this.$input(model, 'hidden', name, attr);\n};\n\nController.prototype.$radio = function(model, name, value, attr) {\n\n\tif (typeof(attr) === 'string') {\n\t\tvar label = attr;\n\t\tattr = SINGLETON('!$radio');\n\t\tattr.label = label;\n\t}\n\n\tattr.value = value;\n\treturn this.$input(model, 'radio', name, attr);\n};\n\nController.prototype.$checkbox = function(model, name, attr) {\n\n\tif (typeof(attr) === 'string') {\n\t\tvar label = attr;\n\t\tattr = SINGLETON('!$checkbox');\n\t\tattr.label = label;\n\t}\n\n\treturn this.$input(model, 'checkbox', name, attr);\n};\n\nController.prototype.$textarea = function(model, name, attr) {\n\n\tvar builder = '<textarea';\n\n\tif (typeof(attr) !== 'object')\n\t\tattr = EMPTYOBJECT;\n\n\tbuilder += ' name=\"' + name + '\" id=\"' + (attr.id || name) + ATTR_END;\n\n\tfor (var key in attr) {\n\t\tswitch (key) {\n\t\t\tcase 'name':\n\t\t\tcase 'id':\n\t\t\t\tbreak;\n\t\t\tcase 'required':\n\t\t\tcase 'disabled':\n\t\t\tcase 'readonly':\n\t\t\tcase 'value':\n\t\t\t\tbuilder += ' ' + key + '=\"' + key + ATTR_END;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += ' ' + key + '=\"' + attr[key].toString().encode() + ATTR_END;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (model === undefined)\n\t\treturn builder + '></textarea>';\n\n\treturn builder + '>' + ((model[name] || attr.value) || '') + '</textarea>';\n};\n\nController.prototype.$input = function(model, type, name, attr) {\n\n\tvar builder = ['<input'];\n\n\tif (typeof(attr) !== 'object')\n\t\tattr = EMPTYOBJECT;\n\n\tvar val = attr.value || '';\n\n\tbuilder += ' type=\"' + type + ATTR_END;\n\n\tif (type === 'radio')\n\t\tbuilder += ' name=\"' + name + ATTR_END;\n\telse\n\t\tbuilder += ' name=\"' + name + '\" id=\"' + (attr.id || name) + ATTR_END;\n\n\tif (attr.autocomplete) {\n\t\tif (attr.autocomplete === true || attr.autocomplete === 'on')\n\t\t\tbuilder += ' autocomplete=\"on\"';\n\t\telse\n\t\t\tbuilder += ' autocomplete=\"off\"';\n\t}\n\n\tfor (var key in attr) {\n\t\tswitch (key) {\n\t\t\tcase 'name':\n\t\t\tcase 'id':\n\t\t\tcase 'type':\n\t\t\tcase 'autocomplete':\n\t\t\tcase 'checked':\n\t\t\tcase 'value':\n\t\t\tcase 'label':\n\t\t\t\tbreak;\n\t\t\tcase 'required':\n\t\t\tcase 'disabled':\n\t\t\tcase 'readonly':\n\t\t\tcase 'autofocus':\n\t\t\t\tbuilder += ' ' + key + '=\"' + key + ATTR_END;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += ' ' + key + '=\"' + attr[key].toString().encode() + ATTR_END;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar value = '';\n\n\tif (model !== undefined) {\n\t\tvalue = model[name];\n\n\t\tif (type === 'checkbox') {\n\t\t\tif (value == '1' || value === 'true' || value === true || value === 'on')\n\t\t\t\tbuilder += ' checked=\"checked\"';\n\t\t\tvalue = val || '1';\n\t\t}\n\n\t\tif (type === 'radio') {\n\n\t\t\tval = (val || '').toString();\n\n\t\t\tif (value.toString() === val)\n\t\t\t\tbuilder += ' checked=\"checked\"';\n\n\t\t\tvalue = val || '';\n\t\t}\n\t}\n\n\tif (value === undefined)\n\t\tbuilder += ' value=\"' + (attr.value || '').toString().encode() + ATTR_END;\n\telse\n\t\tbuilder += ' value=\"' + (value || '').toString().encode() + ATTR_END;\n\n\tbuilder += ' />';\n\treturn attr.label ? ('<label>' + builder + ' <span>' + attr.label + '</span></label>') : builder;\n};\n\nController.prototype._preparehostname = function(value) {\n\tif (!value)\n\t\treturn value;\n\tvar tmp = value.substring(0, 5);\n\treturn tmp !== 'http:' && tmp !== 'https' && (tmp[0] !== '/' || tmp[1] !== '/') ? this.host(value) : value;\n};\n\nController.prototype.head = function() {\n\n\tvar self = this;\n\n\tif (!arguments.length) {\n\t\tvar author = self.repository[REPOSITORY_META_AUTHOR] || CONF.author;\n\t\tvar plus = '';\n\t\tvar components = self.repository[REPOSITORY_COMPONENTS];\n\t\tif (components) {\n\t\t\tvar keys = Object.keys(components);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar com = F.components.groups[keys[i]];\n\t\t\t\tif (com)\n\t\t\t\t\tplus += com.links;\n\t\t\t}\n\t\t}\n\t\treturn (author ? '<meta name=\"author\" content=\"' + author + '\" />' : '') + (self.repository[REPOSITORY_HEAD] || '') + plus;\n\t}\n\n\tvar header = (self.repository[REPOSITORY_HEAD] || '');\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\tvar val = arguments[i];\n\t\tvar key = '$head-' + val;\n\n\t\tif (self.repository[key])\n\t\t\tcontinue;\n\n\t\tself.repository[key] = true;\n\n\t\tif (val[0] === '<') {\n\t\t\theader += val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar tmp = val.substring(0, 7);\n\t\tvar is = (tmp[0] !== '/' && tmp[1] !== '/') && tmp !== 'http://' && tmp !== 'https:/';\n\t\tvar ext = U.getExtension(val);\n\t\tif (ext === 'css')\n\t\t\theader += '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + (is ? self.routeStyle(val) : val) + '\" />';\n\t\telse if (ext === 'js')\n\t\t\theader += '<script src=\"' + (is ? self.routeScript(val) : val) + '\"></script>';\n\t}\n\n\tself.repository[REPOSITORY_HEAD] = header;\n\treturn self;\n};\n\nController.prototype.$head = function() {\n\tthis.head.apply(this, arguments);\n\treturn '';\n};\n\nController.prototype.$isValue = function(bool, charBeg, charEnd, value) {\n\tif (!bool)\n\t\treturn '';\n\tcharBeg = charBeg || ' ';\n\tcharEnd = charEnd || '';\n\treturn charBeg + value + charEnd;\n};\n\nController.prototype.$options = function(arr, selected, name, value, disabled) {\n\n\tvar type = typeof(arr);\n\tif (!arr)\n\t\treturn '';\n\n\tvar isObject = false;\n\tvar tmp = null;\n\n\tif (!(arr instanceof Array) && type === 'object') {\n\t\tisObject = true;\n\t\ttmp = arr;\n\t\tarr = Object.keys(arr);\n\t}\n\n\tif (!(arr instanceof Array))\n\t\tarr = [arr];\n\n\tselected = selected || '';\n\n\tvar options = '';\n\n\tif (!isObject) {\n\t\tif (value == null)\n\t\t\tvalue = value || name || 'value';\n\t\tif (name == null)\n\t\t\tname = 'name';\n\t\tif (disabled == null)\n\t\t\tdisabled = 'disabled';\n\t}\n\n\tvar isSelected = false;\n\tvar length = 0;\n\n\tlength = arr.length;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar o = arr[i];\n\t\tvar type = typeof(o);\n\t\tvar text = '';\n\t\tvar val = '';\n\t\tvar sel = false;\n\t\tvar dis = false;\n\n\t\tif (isObject) {\n\t\t\tif (name === true) {\n\t\t\t\tval = tmp[o];\n\t\t\t\ttext = o;\n\t\t\t\tif (!value)\n\t\t\t\t\tvalue = '';\n\t\t\t} else {\n\t\t\t\tval = o;\n\t\t\t\ttext = tmp[o];\n\t\t\t\tif (!text)\n\t\t\t\t\ttext = '';\n\t\t\t}\n\n\t\t} else if (type === 'object') {\n\n\t\t\ttext = (o[name] || '');\n\t\t\tval = (o[value] || '');\n\n\t\t\tif (typeof(text) === 'function')\n\t\t\t\ttext = text(i);\n\n\t\t\tif (typeof(val) === 'function')\n\t\t\t\tval = val(i, text);\n\n\t\t\tdis = o[disabled];\n\n\t\t\tif (typeof(disabled) === 'function')\n\t\t\t\tdis = disabled(i, val, text);\n\t\t\telse\n\t\t\t\tdis = dis ? true : false;\n\n\t\t} else {\n\t\t\ttext = o;\n\t\t\tval = o;\n\t\t}\n\n\t\tif (!isSelected) {\n\t\t\tsel = val == selected;\n\t\t\tisSelected = sel;\n\t\t}\n\n\t\toptions += '<option value=\"' + val.toString().encode() + '\"' + (sel ? ' selected=\"selected\"' : '') + (dis ? ' disabled=\"disabled\"' : '') + '>' + text.toString().encode() + '</option>';\n\t}\n\n\treturn options;\n};\n\n/**\n * Append <script> TAG\n * @private\n * @return {String}\n */\nController.prototype.$script = function() {\n\treturn arguments.length === 1 ? this.$js(arguments[0]) : this.$js.apply(this, arguments);\n};\n\n/**\n * Append <script> TAG\n * @private\n * @return {String}\n */\nController.prototype.$js = function() {\n\tvar self = this;\n\tvar builder = '';\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tbuilder += self.routeScript(arguments[i], true);\n\treturn builder;\n};\n\n/**\n * Append <script> or <style> TAG\n * @private\n * @return {String}\n */\nController.prototype.$absolute = function(files, base) {\n\n\tvar self = this;\n\tvar builder;\n\tvar ftype;\n\n\tif (!base)\n\t\tbase = self.hostname();\n\n\tif (files instanceof Array) {\n\n\t\tftype = U.getExtension(files[0]);\n\t\tbuilder = '';\n\n\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\tswitch (ftype) {\n\t\t\t\tcase 'js':\n\t\t\t\t\tbuilder += self.routeScript(files[i], true, base);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'css':\n\t\t\t\t\tbuilder += self.routeStyle(files[i], true, base);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuilder += self.routeStatic(files[i], base);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn builder;\n\t}\n\n\tftype = U.getExtension(files);\n\n\tswitch (ftype) {\n\t\tcase 'js':\n\t\t\treturn self.routeScript(files, true, base);\n\t\tcase 'css':\n\t\t\treturn self.routeStyle(files, true, base);\n\t}\n\n\treturn self.routeStatic(files, base);\n};\n\nController.prototype.$import = function() {\n\n\tvar self = this;\n\tvar builder = '';\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar filename = arguments[i];\n\n\t\tif (filename === 'head') {\n\t\t\tbuilder += self.head();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'meta') {\n\t\t\tbuilder += self.$meta();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'components' && F.components.has) {\n\t\t\t// Generated in controller.head()\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'manifest' || filename === 'manifest.json') {\n\t\t\tbuilder += '<link rel=\"manifest\" href=\"' + F.$version('/manifest.json') + '\">';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'favicon.ico' || filename === 'favicon.png') {\n\t\t\tbuilder += self.$favicon(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename[0] === 'l' && filename[9] === 'd' && filename.substring(0, 10) === 'livereload') {\n\t\t\tif (DEBUG) {\n\t\t\t\tvar url = filename.substring(11).trim();\n\t\t\t\tbuilder += '<script src=\"//cdn.totaljs.com/livereload.js\"' + (url ? (' data-url=\"' + url + '\"') : '') + '></script>';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar extension = filename.substring(filename.lastIndexOf('.'));\n\t\tvar tag = filename[0] !== '!';\n\t\tif (!tag)\n\t\t\tfilename = filename.substring(1);\n\n\t\tif (filename[0] === '#')\n\t\t\textension = '.js';\n\n\t\tswitch (extension) {\n\t\t\tcase '.js':\n\t\t\t\tbuilder += self.routeScript(filename, tag);\n\t\t\t\tbreak;\n\t\t\tcase '.css':\n\t\t\t\tbuilder += self.routeStyle(filename, tag);\n\t\t\t\tbreak;\n\t\t\tcase '.ico':\n\t\t\t\tbuilder += self.$favicon(filename);\n\t\t\t\tbreak;\n\t\t\tcase '.jpg':\n\t\t\tcase '.gif':\n\t\t\tcase '.svg':\n\t\t\tcase '.png':\n\t\t\tcase '.jpeg':\n\t\t\tcase '.heif':\n\t\t\tcase '.webp':\n\t\t\tcase '.heic':\n\t\t\tcase '.apng':\n\t\t\t\tbuilder += self.routeImage(filename);\n\t\t\t\tbreak;\n\t\t\tcase '.mp4':\n\t\t\tcase '.avi':\n\t\t\tcase '.ogv':\n\t\t\tcase '.webm':\n\t\t\tcase '.mov':\n\t\t\tcase '.mpg':\n\t\t\tcase '.mpe':\n\t\t\tcase '.mpeg':\n\t\t\tcase '.m4v':\n\t\t\t\tbuilder += self.routeVideo(filename);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += self.routeStatic(filename);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder;\n};\n\n/**\n * Append <link> TAG\n * @private\n * @return {String}\n */\nController.prototype.$css = function() {\n\n\tvar self = this;\n\tvar builder = '';\n\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tbuilder += self.routeStyle(arguments[i], true);\n\n\treturn builder;\n};\n\nController.prototype.$image = function(name, width, height, alt, className) {\n\n\tvar style = '';\n\n\tif (typeof(width) === 'object') {\n\t\theight = width.height;\n\t\talt = width.alt;\n\t\tclassName = width.class;\n\t\tstyle = width.style;\n\t\twidth = width.width;\n\t}\n\n\tvar builder = '<img src=\"' + this.routeImage(name) + ATTR_END;\n\n\tif (width > 0)\n\t\tbuilder += ' width=\"' + width + ATTR_END;\n\n\tif (height > 0)\n\t\tbuilder += ' height=\"' + height + ATTR_END;\n\n\tif (alt)\n\t\tbuilder += ' alt=\"' + alt.encode() + ATTR_END;\n\n\tif (className)\n\t\tbuilder += ' class=\"' + className + ATTR_END;\n\n\tif (style)\n\t\tbuilder += ' style=\"' + style + ATTR_END;\n\n\treturn builder + ' border=\"0\" />';\n};\n\n/**\n * Create URL: DOWNLOAD (<a href=\"...\" download=\"...\")\n * @private\n * @param {String} filename\n * @param {String} innerHTML\n * @param {String} downloadName Optional.\n * @param {String} className Optional.\n * @return {String}\n */\nController.prototype.$download = function(filename, innerHTML, downloadName, className) {\n\tvar builder = '<a href=\"' + F.routeDownload(filename) + ATTR_END;\n\n\tif (downloadName)\n\t\tbuilder += ' download=\"' + downloadName + ATTR_END;\n\n\tif (className)\n\t\tbuilder += ' class=\"' + className + ATTR_END;\n\n\treturn builder + '>' + (innerHTML || filename) + '</a>';\n};\n\n/**\n * Serialize object into the JSON\n * @private\n * @param {Object} obj\n * @param {String} id Optional.\n * @param {Boolean} beautify Optional.\n * @return {String}\n */\nController.prototype.$json = function(obj, id, beautify, replacer) {\n\n\tif (typeof(id) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = id;\n\t\tid = null;\n\t}\n\n\tif (typeof(beautify) === 'function') {\n\t\treplacer = beautify;\n\t\tbeautify = false;\n\t}\n\n\tif (framework_builders.isSchema(obj))\n\t\tobj = obj.$clean();\n\n\tvar value = beautify ? JSON.stringify(obj, replacer, 4) : JSON.stringify(obj, replacer);\n\treturn id ? ('<script type=\"application/json\" id=\"' + id + '\">' + value + '</script>') : value;\n};\n\n/**\n * Append FAVICON tag\n * @private\n * @param {String} name\n * @return {String}\n */\nController.prototype.$favicon = function(name) {\n\n\tvar contentType = 'image/x-icon';\n\n\tif (!name)\n\t\tname = 'favicon.ico';\n\n\tvar key = 'favicon#' + name;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (name.lastIndexOf('.png') !== -1)\n\t\tcontentType = 'image/png';\n\telse if (name.lastIndexOf('.gif') !== -1)\n\t\tcontentType = 'image/gif';\n\n\treturn F.temporary.other[key] = '<link rel=\"icon\" href=\"' + F.routeStatic('/' + name) + '\" type=\"' + contentType + '\" />';\n};\n\n/**\n * Route static file helper\n * @private\n * @param {String} current\n * @param {String} name\n * @param {Function} fn\n * @return {String}\n */\nController.prototype._routeHelper = function(name, fn) {\n\treturn fn.call(framework, prepare_staticurl(name, false), this.themeName);\n};\n\n/**\n * Create URL: JavaScript\n * @param {String} name\n * @param {Boolean} tag Optional, default \"false\"\n * @param {String} path Optional, default undefined\n * @return {String}\n */\nController.prototype.routeScript = function(name, tag, path) {\n\n\tif (name === undefined)\n\t\tname = 'default.js';\n\n\tvar async = false;\n\tvar url;\n\n\t// Checks \"async \"\n\tif (tag && name[0] === 'a' && name[5] === ' ') {\n\t\tasync = true;\n\t\tname = name.substring(6);\n\t}\n\n\t// Isomorphic\n\tif (name[0] === '#') {\n\t\tvar tmp = F.isomorphic[name.substring(1)];\n\t\tif (tmp)\n\t\t\turl = tmp.url;\n\t\telse {\n\t\t\tF.error('Isomorphic library {0} doesn\\'t exist.'.format(name.substring(1)));\n\t\t\treturn '';\n\t\t}\n\t} else {\n\t\turl = this._routeHelper(name, F.routeScript);\n\t\tif (path && U.isRelative(url))\n\t\t\turl = F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\t}\n\n\treturn tag ? ('<script src=\"' + url + '\"' + (async ? ' async' : '') + '></script>') : url;\n};\n\n/**\n * Create URL: CSS\n * @param {String} name\n * @param {Boolean} tag Append tag?\n * @return {String}\n */\nController.prototype.routeStyle = function(name, tag, path) {\n\tvar self = this;\n\n\tif (name === undefined)\n\t\tname = 'default.css';\n\n\tvar url = self._routeHelper(name, F.routeStyle);\n\tif (path && U.isRelative(url))\n\t\turl = F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\n\treturn tag ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + url + '\" />' : url;\n};\n\n/**\n * Create URL: IMG\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeImage = function(name) {\n\treturn this._routeHelper(name, F.routeImage);\n};\n\n/**\n * Create URL: VIDEO\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeVideo = function(name) {\n\treturn this._routeHelper(name, F.routeVideo);\n};\n\n/**\n * Create URL: FONT\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeFont = function(name) {\n\treturn F.routeFont(name);\n};\n\n/**\n * Create URL: DOWNLOAD\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeDownload = function(name) {\n\treturn this._routeHelper(name, F.routeDownload);\n};\n\n/**\n * Create URL: static files (by the config['static-url'])\n * @param {String} name\n * @return {String}\n */\nController.prototype.routeStatic = function(name, path) {\n\tvar url = this._routeHelper(name, F.routeStatic);\n\tif (path && U.isRelative(url))\n\t\treturn F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\treturn url;\n};\n\n/**\n * Creates a string from the view\n * @param {String} name A view name without `.html` extension.\n * @param {Object} model A model, optional.\n * @return {String}\n */\nController.prototype.template = function(name, model) {\n\treturn this.view(name, model, true);\n};\n\n/**\n * Renders a custom helper to a string\n * @param {String} name A helper name.\n * @return {String}\n */\nController.prototype.helper = function(name) {\n\tvar helper = F.helpers[name];\n\tif (!helper)\n\t\treturn '';\n\n\tvar params = [];\n\tfor (var i = 1; i < arguments.length; i++)\n\t\tparams.push(arguments[i]);\n\n\treturn helper.apply(this, params);\n};\n\n/**\n * Response JSON\n * @param {Object} obj\n * @param {Object} headers Custom headers, optional.\n * @param {Boolean} beautify Beautify JSON.\n * @param {Function(key, value)} replacer JSON replacer.\n * @return {Controller}\n */\nController.prototype.json = function(obj, headers, beautify, replacer) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = headers;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.type = CT_JSON;\n\tres.options.headers = headers;\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.options.type = CT_JSON;\n\t\tres.$text();\n\t\tF.stats.response.json++;\n\t\treturn self;\n\t}\n\n\tif (obj instanceof framework_builders.ErrorBuilder) {\n\t\tself.req.$language && !obj.isResourceCustom && obj.setResource(self.req.$language);\n\n\t\tvar json = obj.output(true);\n\n\t\tif (obj.contentType)\n\t\t\tres.options.type = obj.contentType;\n\t\telse\n\t\t\tres.options.type = CT_JSON;\n\n\t\tif (obj.status !== 200)\n\t\t\tres.options.code = obj.status;\n\n\t\tobj = json;\n\t\tF.stats.response.errorBuilder++;\n\t} else {\n\n\t\tif (framework_builders.isSchema(obj))\n\t\t\tobj = obj.$clean();\n\n\t\tif (beautify)\n\t\t\tobj = JSON.stringify(obj, replacer, 4);\n\t\telse\n\t\t\tobj = JSON.stringify(obj, replacer);\n\t}\n\n\tF.stats.response.json++;\n\tres.options.body = obj;\n\tres.$text();\n\tself.precache && self.precache(obj, res.options.type, headers);\n\treturn self;\n};\n\nController.prototype.success = function(is, value) {\n\treturn this.json(SUCCESS(is === undefined ? true : is, value));\n};\n\n/**\n * Responds with JSONP\n * @param {String} name A method name.\n * @param {Object} obj Object to serialize.\n * @param {Object} headers A custom headers.\n * @param {Boolean} beautify Should be the JSON prettified? Optional, default `false`\n * @param {Function} replacer Optional, the JSON replacer.\n * @return {Controller}\n */\nController.prototype.jsonp = function(name, obj, headers, beautify, replacer) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = headers;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.type = 'application/x-javascript';\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.$text();\n\t\tF.stats.response.json++;\n\t\treturn self;\n\t}\n\n\t!name && (name = 'callback');\n\n\tif (obj instanceof framework_builders.ErrorBuilder) {\n\t\tself.req.$language && !obj.isResourceCustom && obj.setResource(self.req.$language);\n\t\tobj = obj.json(beautify);\n\t\tif (obj.status !== 200)\n\t\t\tres.options.code = obj.status;\n\t\tF.stats.response.errorBuilder++;\n\t} else {\n\n\t\tif (framework_builders.isSchema(obj))\n\t\t\tobj = obj.$clean();\n\n\t\tif (beautify)\n\t\t\tobj = JSON.stringify(obj, replacer, 4);\n\t\telse\n\t\t\tobj = JSON.stringify(obj, replacer);\n\t}\n\n\tres.options.body = name + '(' + obj + ')';\n\tres.$text();\n\n\tF.stats.response.json++;\n\tself.precache && self.precache(name + '(' + obj + ')', res.options.type, headers);\n\treturn self;\n};\n\n/**\n * Creates View or JSON callback\n * @param {String} view Optional, undefined or null returns JSON.\n * @return {Function}\n */\nController.prototype.callback = function(view) {\n\tvar self = this;\n\treturn function(err, data) {\n\n\t\tCONF.logger && self.req.$logger && F.ilogger(null, self.req);\n\n\t\tif (self.res && self.res.success)\n\t\t\treturn;\n\n\t\tvar is = err instanceof framework_builders.ErrorBuilder;\n\n\t\t// NoSQL embedded database\n\t\tif (data === undefined && !U.isError(err) && !is) {\n\t\t\tdata = err;\n\t\t\terr = null;\n\t\t}\n\n\t\tif (err) {\n\t\t\tif (is && !view) {\n\t\t\t\tself.req.$language && !err.isResourceCustom && err.setResource(self.req.$language);\n\t\t\t\treturn self.content(err);\n\t\t\t}\n\t\t\treturn is && err.unexpected ? self.view500(err) : self.view404(err);\n\t\t}\n\n\t\t// Hack for schemas\n\t\tif (data instanceof F.callback_redirect)\n\t\t\treturn self.redirect(data.url);\n\n\t\tif (typeof(view) === 'string')\n\t\t\tself.view(view, data);\n\t\telse\n\t\t\tself.json(data);\n\t};\n};\n\nController.prototype.custom = function() {\n\tif (this.res.success)\n\t\treturn false;\n\tthis.res.$custom();\n\treturn true;\n};\n\n/**\n * Prevents cleaning uploaded files (need to call `controller.clear()` manually).\n * @param {Boolean} enable Optional, default `true`.\n * @return {Controller}\n */\nController.prototype.noClear = function(enable) {\n\tOBSOLETE('controller.noClear()', 'You need to use controller.autoclear(false)');\n\tthis.req._manual = enable === undefined ? true : enable;\n\treturn this;\n};\n\nController.prototype.autoclear = function(enable) {\n\tthis.req._manual = enable === false;\n\treturn this;\n};\n\nController.prototype.html = function(body, headers) {\n\treturn this.content(body, 'text/html', headers);\n};\n\nController.prototype.content = function(body, type, headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tres.options.headers = headers;\n\tres.options.code = self.status || 200;\n\n\tif (body instanceof ErrorBuilder) {\n\n\t\tif (self.language && !body.resourceName)\n\t\t\tbody.resourceName = self.language;\n\n\t\tvar tmp = body.output(true);\n\t\tif (body.contentType)\n\t\t\tres.options.type = body.contentType;\n\t\telse\n\t\t\tres.options.type = CT_JSON;\n\n\t\tif (body.status !== 200)\n\t\t\tres.options.code = body.status;\n\n\t\tbody = tmp;\n\t\tF.stats.response.errorBuilder++;\n\t} else\n\t\tres.options.type = type || CT_TEXT;\n\n\tres.options.body = body;\n\tres.$text();\n\n\tif (self.precache && (!self.status || self.status === 200)) {\n\t\tself.layout('');\n\t\tself.precache(body, res.options.type, headers, true);\n\t}\n\n\treturn self;\n};\n\n/**\n * Responds with plain/text body\n * @param {String} body A response body (object is serialized into the JSON automatically).\n * @param {Boolean} headers A custom headers.\n * @return {Controller}\n */\nController.prototype.plain = function(body, headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.type = CT_TEXT;\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.$text();\n\t\tF.stats.response.plain++;\n\t\treturn self;\n\t}\n\n\tvar type = typeof(body);\n\n\tif (body == null)\n\t\tbody = '';\n\telse if (type === 'object') {\n\t\tif (framework_builders.isSchema(body))\n\t\t\tbody = body.$clean();\n\t\tbody = body ? JSON.stringify(body, null, 4) : '';\n\t} else\n\t\tbody = body ? body.toString() : '';\n\n\tres.options.body = body;\n\tres.$text();\n\tF.stats.response.plain++;\n\tself.precache && self.precache(body, res.options.type, headers);\n\treturn self;\n};\n\n/**\n * Creates an empty response\n * @param {Object/Number} headers A custom headers or a custom HTTP status.\n * @return {Controller}\n */\nController.prototype.empty = function(headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'number') {\n\t\tself.status = headers;\n\t\theaders = null;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.body = EMPTYBUFFER;\n\tres.options.type = CT_TEXT;\n\tres.options.compress = false;\n\tres.$text();\n\tF.stats.response.empty++;\n\treturn self;\n};\n\n/**\n * Destroys a request (closes it)\n * @param {String} problem Optional.\n * @return {Controller}\n */\nController.prototype.destroy = function(problem) {\n\tvar self = this;\n\n\tproblem && self.problem(problem);\n\tif (self.res.success || self.res.headersSent || !self.isConnected)\n\t\treturn self;\n\n\tself.req.$total_success();\n\tself.req.connection && self.req.connection.destroy();\n\tF.stats.response.destroy++;\n\treturn self;\n};\n\n/**\n * Responds with a file\n * @param {String} filename\n * @param {String} download Optional, a download name.\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optinoal, callback.\n * @return {Controller}\n */\nController.prototype.file = function(filename, download, headers, done) {\n\n\tif (filename[0] === '~')\n\t\tfilename = filename.substring(1);\n\telse\n\t\tfilename = F.path.public_cache(filename);\n\n\tvar res = this.res;\n\tres.options.filename = filename;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\tres.$file();\n\treturn this;\n};\n\n/**\n * Responds with an image\n * @param {String or Stream} filename\n * @param {Function(image)} fnProcess\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optional, callback.\n * @return {Controller}\n */\nController.prototype.image = function(filename, make, headers, done) {\n\n\tvar res = this.res;\n\n\tif (typeof(filename) === 'string') {\n\t\tif (filename[0] === '~')\n\t\t\tfilename = filename.substring(1);\n\t\telse\n\t\t\tfilename = F.path.public_cache(filename);\n\n\t\tres.options.filename = filename;\n\t} else\n\t\tres.options.stream = filename;\n\n\tres.options.make = make;\n\theaders && (res.options.headers = headers);\n\tdone && (res.options.callback = done);\n\tres.$image();\n\treturn this;\n};\n\n/**\n * Responds with a stream\n * @param {String} contentType\n * @param {Stream} stream\n * @param {String} download Optional, a download name.\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optinoal, callback.\n * @return {Controller}\n */\nController.prototype.stream = function(type, stream, download, headers, done, nocompress) {\n\tvar res = this.res;\n\tres.options.type = type;\n\tres.options.stream = stream;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.done = done;\n\tres.options.compress = nocompress ? false : true;\n\tres.$stream();\n\treturn this;\n};\n\n/**\n * Throw 400 - Bad request.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw400 = Controller.prototype.view400 = function(problem) {\n\treturn controller_error_status(this, 400, problem);\n};\n\n/**\n * Throw 401 - Unauthorized.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw401 = Controller.prototype.view401 = function(problem) {\n\treturn controller_error_status(this, 401, problem);\n};\n\n/**\n * Throw 403 - Forbidden.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw403 = Controller.prototype.view403 = function(problem) {\n\treturn controller_error_status(this, 403, problem);\n};\n\n/**\n * Throw 404 - Not found.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw404 = Controller.prototype.view404 = function(problem) {\n\treturn controller_error_status(this, 404, problem);\n};\n\n/**\n * Throw 409 - Conflict.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nController.prototype.throw409 = Controller.prototype.view409 = function(problem) {\n\treturn controller_error_status(this, 409, problem);\n};\n\n/**\n * Throw 500 - Internal Server Error.\n * @param {Error} error\n * @return {Controller}\n */\nController.prototype.throw500 = Controller.prototype.view500 = function(error) {\n\tvar self = this;\n\tF.error(error instanceof Error ? error : new Error((error || '').toString()), self.name, self.req.uri);\n\treturn controller_error_status(self, 500, error);\n};\n\n/**\n * Throw 501 - Not implemented\n * @param  {String} problem Description of the problem (optional)\n * @return {Controller}\n */\nController.prototype.throw501 = Controller.prototype.view501 = function(problem) {\n\treturn controller_error_status(this, 501, problem);\n};\n\n/**\n * Throw 503 - Service unavailable\n * @param  {String} problem Description of the problem (optional)\n * @return {Controller}\n */\nController.prototype.throw503 = Controller.prototype.view503 = function(problem) {\n\treturn controller_error_status(this, 503, problem);\n};\n\n/**\n * Creates a redirect\n * @param {String} url\n * @param {Boolean} permanent Is permanent? Default: `false`\n * @return {Controller}\n */\nController.prototype.redirect = function(url, permanent) {\n\tthis.precache && this.precache(null, null, null);\n\tvar res = this.res;\n\tres.options.url = url;\n\tres.options.permanent = permanent;\n\tres.$redirect();\n\treturn this;\n};\n\n/**\n * A binary response\n * @param {Buffer} buffer\n * @param {String} type\n * @param {String} encoding Transformation type: `binary`, `utf8`, `ascii`.\n * @param {String} download Optional, download name.\n * @param {Object} headers Optional, additional headers.\n * @return {Controller}\n */\nController.prototype.binary = function(buffer, type, encoding, download, headers) {\n\n\tvar res = this.res;\n\n\tif (typeof(encoding) === 'object') {\n\t\tvar tmp = encoding;\n\t\tencoding = download;\n\t\tdownload = headers;\n\t\theaders = tmp;\n\t}\n\n\tif (typeof(download) === 'object') {\n\t\theaders = download;\n\t\tdownload = headers;\n\t}\n\n\tres.options.body = buffer;\n\tres.options.type = type;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.encoding = encoding;\n\tres.$binary();\n\treturn this;\n};\n\n/**\n * Basic access authentication (baa)\n * @param {String} label\n * @return {Object}\n */\nController.prototype.baa = function(label) {\n\n\tvar self = this;\n\tself.precache && self.precache(null, null, null);\n\n\tif (label === undefined)\n\t\treturn self.req.authorization();\n\n\tvar res = self.res;\n\tvar headers = SINGLETON('!controller.baa');\n\n\theaders['WWW-Authenticate'] = 'Basic realm=\"' + (label || 'Administration') + '\"';\n\n\tres.options.code = 401;\n\tres.options.body = '401: NOT AUTHORIZED';\n\tres.options.compress = false;\n\tres.options.headers = headers;\n\tres.options.type = CT_TEXT;\n\tres.$text();\n\tself.cancel();\n\treturn null;\n};\n\n/**\n * Sends server-sent event message\n * @param {String/Object} data\n * @param {String} eventname Optional, an event name.\n * @param {String} id Optional, a custom ID.\n * @param {Number} retry A reconnection timeout in milliseconds when is an unexpected problem.\n * @return {Controller}\n */\nController.prototype.sse = function(data, eventname, id, retry) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (!self.isConnected)\n\t\treturn self;\n\n\tif (!self.type && res.success)\n\t\tthrow new Error('Response was sent.');\n\n\tif (self.type > 0 && self.type !== 1)\n\t\tthrow new Error('Response was used.');\n\n\tif (!self.type) {\n\n\t\tself.type = 1;\n\n\t\tif (retry === undefined)\n\t\t\tretry = self.route.timeout;\n\n\t\tself.req.$total_success();\n\t\tself.req.on('close', () => self.close());\n\t\tres.success = true;\n\t\tres.writeHead(self.status || 200, HEADERS.sse);\n\t}\n\n\tif (typeof(data) === 'object')\n\t\tdata = JSON.stringify(data);\n\telse\n\t\tdata = data.replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n\n\tvar newline = '\\n';\n\tvar builder = '';\n\n\tif (eventname)\n\t\tbuilder = 'event: ' + eventname + newline;\n\n\tbuilder += 'data: ' + data + newline;\n\n\tif (id)\n\t\tbuilder += 'id: ' + id + newline;\n\n\tif (retry > 0)\n\t\tbuilder += 'retry: ' + retry + newline;\n\n\tbuilder += newline;\n\tres.write(builder);\n\tF.stats.response.sse++;\n\treturn self;\n};\n\n/**\n * Close a response\n * @param {Boolean} end\n * @return {Controller}\n */\nController.prototype.close = function(end) {\n\tvar self = this;\n\n\tif (end === undefined)\n\t\tend = true;\n\n\tif (!self.isConnected)\n\t\treturn self;\n\n\tif (self.type) {\n\t\tself.isConnected = false;\n\t\tself.res.success = true;\n\t\tF.reqstats(false, false);\n\t\tF.$events['request-end'] && EMIT('request-end', self.req, self.res);\n\t\tself.type = 0;\n\t\tend && self.res.end();\n\t\tself.req.clear(true);\n\t\treturn self;\n\t}\n\n\tself.isConnected = false;\n\n\tif (self.res.success)\n\t\treturn self;\n\n\tself.res.success = true;\n\tF.reqstats(false, false);\n\tF.$events['request-end'] && EMIT('request-end', self.req, self.res);\n\tend && self.res.end();\n\tself.req.clear(true);\n\treturn self;\n};\n\n/**\n * Creates a proxy between current request and new URL\n * @param {String} url\n * @param {Function(err, response, headers)} callback Optional.\n * @param {Object} headers Optional, additional headers.\n * @param {Number} timeout Optional, timeout (default: 10000)\n * @return {EventEmitter}\n */\nController.prototype.proxy = Controller.prototype.proxy2 = function(url, callback, headers, timeout) {\n\n\tif (typeof(callback) === 'object') {\n\t\ttimeout = headers;\n\t\theaders = callback;\n\t\tcallback = undefined;\n\t}\n\n\tvar self = this;\n\tvar flags = [];\n\tvar req = self.req;\n\tvar type = req.headers['content-type'];\n\tvar h = {};\n\n\tflags.push(req.method);\n\tflags.push('dnscache');\n\n\tif ((/\\/json/i).test(type))\n\t\tflags.push('json');\n\n\tvar tmp;\n\n\tif (url.indexOf('?') === -1) {\n\t\ttmp = Qs.stringify(self.query);\n\t\tif (tmp)\n\t\t\turl += '?' + tmp;\n\t}\n\n\tvar keys = Object.keys(req.headers);\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tswitch (keys[i]) {\n\t\t\tcase 'x-forwarded-for':\n\t\t\tcase 'x-forwarded-protocol':\n\t\t\tcase 'x-nginx-proxy':\n\t\t\tcase 'connection':\n\t\t\tcase 'content-type':\n\t\t\tcase 'host':\n\t\t\tcase 'accept-encoding':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\th[keys[i]] = req.headers[keys[i]];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (headers) {\n\t\tkeys = Object.keys(headers);\n\t\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\t\th[keys[i]] = headers[keys[i]];\n\t}\n\n\treturn U.request(url, flags, self.body, function(err, data, code, headers) {\n\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t\tself.invalid().push(err);\n\t\t} else {\n\t\t\tself.status = code;\n\t\t\tcallback && callback(err, data, code, headers);\n\t\t\tvar ct = (headers['content-type'] || 'text/plain').replace(REG_ENCODINGCLEANER, '');\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tself.binary(data, ct);\n\t\t\telse\n\t\t\t\tself.content(data, ct);\n\t\t}\n\n\t}, null, h, ENCODING, timeout || 10000);\n};\n\n/**\n * Renders view to response\n * @param {String} name View name without `.html` extension.\n * @param {Object} model A model, optional default: `undefined`.\n * @param {Object} headers A custom headers, optional.\n * @param {Boolean} isPartial When is `true` the method returns rendered HTML as `String`\n * @return {Controller/String}\n */\nController.prototype.view = function(name, model, headers, partial, noasync, cachekey) {\n\n\tvar self = this;\n\n\tif (typeof(name) !== 'string') {\n\t\tpartial = headers;\n\t\theaders = model;\n\t\tmodel = name;\n\t\tname = self.viewname;\n\t} else if (partial === undefined && typeof(headers) === 'boolean') {\n\t\tpartial = headers;\n\t\theaders = null;\n\t}\n\n\tif (!partial && self.res && self.res.success)\n\t\treturn self;\n\n\tif (self.layoutName === undefined)\n\t\tself.layoutName = CONF.default_layout;\n\tif (self.themeName === undefined)\n\t\tself.themeName = CONF.default_theme;\n\n\t// theme root `~some_view`\n\t// views root `~~some_view`\n\t// package    `@some_view`\n\t// theme      `=theme/view`\n\n\tvar key = 'view#=' + this.themeName + '/' + self._currentView + '/' + name;\n\tvar filename = F.temporary.other[key];\n\tvar isLayout = self.isLayout;\n\n\tself.isLayout = false;\n\n\t// A small cache\n\tif (!filename) {\n\n\t\t// ~   --> routed into the root of views (if the controller uses a theme then is routed into the root views of the theme)\n\t\t// ~~  --> routed into the root of views (if the controller contains theme)\n\t\t// /   --> routed into the views (skipped)\n\t\t// @   --> routed into the packages\n\t\t// .   --> routed into the opened path\n\t\t// =   --> routed into the theme\n\n\t\tvar c = name[0];\n\t\tvar skip = c === '/' ? 1 : c === '~' && name[1] === '~' ? 4 : c === '~' ? 2 : c === '@' ? 3 : c === '.' ? 5 : c === '=' ? 6 : 0;\n\t\tvar isTheme = false;\n\n\t\tif (REG_HTTPHTTPS.test(name))\n\t\t\tskip = 7;\n\n\t\tfilename = name;\n\n\t\tif (self.themeName && skip < 3) {\n\t\t\tfilename = '.' + F.path.themes(self.themeName + '/views/' + (isLayout || skip ? '' : self._currentView.substring(1)) + (skip ? name.substring(1) : name)).replace(REG_SANITIZE_BACKSLASH, '/');\n\t\t\tisTheme = true;\n\t\t}\n\n\t\tif (skip === 4) {\n\t\t\tfilename = filename.substring(1);\n\t\t\tname = name.substring(1);\n\t\t\tskip = 2;\n\t\t}\n\n\t\tif (!isTheme && !isLayout && !skip)\n\t\t\tfilename = self._currentView + name;\n\n\t\tif (!isTheme && (skip === 2 || skip === 3))\n\t\t\tfilename = name.substring(1);\n\n\t\tif (skip === 3)\n\t\t\tfilename = '.' + F.path.package(filename);\n\n\t\tif (skip === 6) {\n\t\t\tc = U.parseTheme(filename);\n\t\t\tname = name.substring(name.indexOf('/') + 1);\n\t\t\tfilename = '.' + F.path.themes(c + '/views/' + name).replace(REG_SANITIZE_BACKSLASH, '/');\n\t\t}\n\n\t\tif (skip === 7) {\n\n\t\t\tif (F.temporary.other[key] === 0) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tself.view(name, model, headers, partial);\n\t\t\t\t}, 100, self);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfilename = F.path.temp('view' + name.hash() + '.html');\n\t\t\tF.temporary.other[key] = 0;\n\n\t\t\tvar done = { callback: NOOP };\n\n\t\t\tF.download(name, filename, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tF.temporary.other[key] = undefined;\n\t\t\t\t\tif (done.callback === NOOP)\n\t\t\t\t\t\tF.throw500(err);\n\t\t\t\t\telse\n\t\t\t\t\t\tdone.callback(err);\n\t\t\t\t} else {\n\t\t\t\t\tF.temporary.other[key] = '.' + filename.substring(0, filename.length - 5);\n\t\t\t\t\tdone.callback(null, self.view(name, model, headers, partial));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn function(cb) {\n\t\t\t\tdone.callback = cb;\n\t\t\t};\n\t\t}\n\t}\n\n\treturn self.$viewrender(filename, framework_internal.viewEngine(name, filename, self), model, headers, partial, isLayout, noasync, cachekey);\n};\n\nController.prototype.viewCompile = function(body, model, headers, partial, key) {\n\n\tif (headers === true) {\n\t\tkey = partial;\n\t\tpartial = true;\n\t\theaders = undefined;\n\t} else if (typeof(headers) === 'string') {\n\t\tkey = headers;\n\t\theaders = undefined;\n\t} else if (typeof(partial) === 'string') {\n\t\tkey = partial;\n\t\tpartial = undefined;\n\t}\n\n\treturn this.$viewrender('[dynamic view]', framework_internal.viewEngineCompile(body, this.language, this, key), model, headers, partial);\n};\n\nController.prototype.$viewrender = function(filename, generator, model, headers, partial, isLayout, noasync, cachekey) {\n\n\tvar self = this;\n\tvar err;\n\n\tif (!generator) {\n\n\t\terr = new Error('View \"' + filename + '\" not found.');\n\n\t\tif (partial) {\n\t\t\tF.error(err, self.name, self.uri);\n\t\t\treturn self.outputPartial;\n\t\t}\n\n\t\tif (isLayout) {\n\t\t\tself.res.throw500(err);\n\t\t\treturn self;\n\t\t}\n\n\t\tself.view500(err);\n\t\treturn self;\n\t}\n\n\tvar value = '';\n\tself.$model = model;\n\n\tif (isLayout)\n\t\tself._currentView = self._defaultView || '';\n\n\tvar helpers = F.helpers;\n\n\ttry {\n\n\t\tif (generator.components.length) {\n\t\t\tif (!self.repository[REPOSITORY_COMPONENTS])\n\t\t\t\tself.repository[REPOSITORY_COMPONENTS] = {};\n\t\t\tfor (var i = 0; i < generator.components.length; i++)\n\t\t\t\tself.repository[REPOSITORY_COMPONENTS][generator.components[i]] = 1;\n\t\t}\n\n\t\tvalue = generator.call(self, self, self.repository, model, self.session, self.query, self.body, self.url, F.global, helpers, self.user, CONF, F.functions, 0, partial ? self.outputPartial : self.output, self.req.files, self.req.mobile, EMPTYOBJECT);\n\n\t} catch (ex) {\n\n\t\terr = new Error('View \"' + filename + '\": ' + ex.message);\n\n\t\tif (!partial) {\n\t\t\tself.view500(err);\n\t\t\treturn self;\n\t\t}\n\n\t\tself.error(err);\n\n\t\tif (self.partial)\n\t\t\tself.outputPartial = '';\n\t\telse\n\t\t\tself.output = '';\n\n\t\tisLayout = false;\n\t\treturn value;\n\t}\n\n\t// noasync = true --> rendered inline view in view\n\n\tif (self.$viewasync && self.$viewasync.length) {\n\n\t\tvar can = ((isLayout || !self.layoutName) && noasync !== true) || !!cachekey;\n\t\tif (can) {\n\t\t\tvar done = {};\n\t\t\tvar obj = {};\n\n\t\t\tobj.repository = self.repository;\n\t\t\tobj.model = self.$model;\n\t\t\tobj.user = self.user;\n\t\t\tobj.session = self.session;\n\t\t\tobj.controller = self;\n\t\t\tobj.query = self.query;\n\t\t\tobj.body = self.body;\n\t\t\tobj.files = self.files;\n\n\t\t\tself.$viewasync.waitFor(function(item, next) {\n\n\t\t\t\tif (item.value) {\n\t\t\t\t\tvalue = value.replace(item.replace, item.value);\n\t\t\t\t\tif (isLayout && self.precache)\n\t\t\t\t\t\tself.output = self.output.replace(item.replace, item.value);\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tobj.options = obj.settings = item.settings;\n\t\t\t\tobj.next = obj.callback = function(model) {\n\t\t\t\t\tif (arguments.length > 1)\n\t\t\t\t\t\tmodel = arguments[1];\n\t\t\t\t\titem.value = self.component(item.name, item.settings, model);\n\t\t\t\t\tvalue = value.replace(item.replace, item.value);\n\t\t\t\t\tif (isLayout && self.precache)\n\t\t\t\t\t\tself.output = self.output.replace(item.replace, item.value);\n\t\t\t\t\tnext();\n\t\t\t\t};\n\n\t\t\t\tF.components.instances[item.name].render(obj);\n\n\t\t\t}, function() {\n\n\t\t\t\tif (cachekey && F.cache.items[cachekey]) {\n\t\t\t\t\tvar cache = F.cache.items[cachekey].value;\n\t\t\t\t\tcache.body = value;\n\t\t\t\t\tcache.components = true;\n\t\t\t\t}\n\n\t\t\t\tif (isLayout && self.precache && (!self.status || self.status === 200) && !partial)\n\t\t\t\t\tself.precache(self.output, CT_HTML, headers, true);\n\n\t\t\t\tif (isLayout || !self.layoutName) {\n\n\t\t\t\t\tself.outputPartial = '';\n\t\t\t\t\tself.output = '';\n\t\t\t\t\tisLayout = false;\n\n\t\t\t\t\tif (partial) {\n\t\t\t\t\t\tdone.callback && done.callback(null, value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tself.req.$total_success();\n\n\t\t\t\t\tif (!self.isConnected)\n\t\t\t\t\t\treturn self;\n\n\t\t\t\t\tvar res = self.res;\n\t\t\t\t\tres.options.body = value;\n\t\t\t\t\tres.options.code = self.status || 200;\n\t\t\t\t\tres.options.type = CT_HTML;\n\t\t\t\t\tres.options.headers = headers;\n\t\t\t\t\tres.$text();\n\t\t\t\t\tF.stats.response.view++;\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\n\t\t\t\tif (partial)\n\t\t\t\t\tself.outputPartial = value;\n\t\t\t\telse\n\t\t\t\t\tself.output = value;\n\n\t\t\t\tif (!cachekey && !noasync) {\n\t\t\t\t\tself.isLayout = true;\n\t\t\t\t\tvalue = self.view(self.layoutName, self.$model, headers, partial);\n\t\t\t\t}\n\n\t\t\t\t// Async\n\t\t\t\tif (partial) {\n\t\t\t\t\tself.outputPartial = '';\n\t\t\t\t\tself.isLayout = false;\n\t\t\t\t\tdone.callback && done.callback(null, value);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\treturn cachekey ? value : (partial ? (fn => done.callback = fn) : self);\n\t\t}\n\t}\n\n\tif (!isLayout && self.precache && (!self.status || self.status === 200) && !partial && !self.$viewasync)\n\t\tself.precache(value, CT_HTML, headers, true);\n\n\tif (isLayout || !self.layoutName) {\n\n\t\tself.outputPartial = '';\n\t\tself.output = '';\n\t\tisLayout = false;\n\n\t\tif (partial)\n\t\t\treturn value;\n\n\t\tself.req.$total_success();\n\n\t\tif (!self.isConnected)\n\t\t\treturn self;\n\n\t\tvar res = self.res;\n\t\tres.options.body = value;\n\t\tres.options.code = self.status || 200;\n\t\tres.options.type = CT_HTML;\n\t\tres.options.headers = headers;\n\t\tres.$text();\n\t\tF.stats.response.view++;\n\t\treturn self;\n\t}\n\n\tif (partial)\n\t\tself.outputPartial = value;\n\telse\n\t\tself.output = value;\n\n\tif (!cachekey && !noasync) {\n\t\tself.isLayout = true;\n\t\tvalue = self.view(self.layoutName, self.$model, headers, partial);\n\t}\n\n\t// Async\n\tif (partial) {\n\t\tself.outputPartial = '';\n\t\tself.isLayout = false;\n\t\treturn value;\n\t}\n\n\treturn self;\n};\n\n/**\n * Creates a cache for the response without caching layout\n * @param {String} key\n * @param {String} expires Expiration, e.g. `1 minute`\n * @param {Boolean} disabled Disables a caching, optinoal (e.g. for debug mode you can disable a cache), default: `false`\n * @param {Function()} fnTo This method is executed when the content is prepared for the cache.\n * @param {Function()} fnFrom This method is executed when the content is readed from the cache.\n * @return {Controller}\n */\nController.prototype.memorize = function(key, expires, disabled, fnTo, fnFrom) {\n\n\tvar self = this;\n\n\tif (disabled === true) {\n\t\tfnTo.call(self);\n\t\treturn self;\n\t}\n\n\tself.themeName && (key += '#' + self.themeName);\n\n\tvar output = F.cache.read2(key);\n\tif (!output)\n\t\treturn self.$memorize_prepare(key, expires, disabled, fnTo, fnFrom);\n\n\tif (typeof(disabled) === 'function') {\n\t\tvar tmp = fnTo;\n\t\tfnTo = disabled;\n\t\tfnFrom = tmp;\n\t}\n\n\tself.layoutName = output.layout;\n\tself.themeName = output.theme;\n\n\tvar res = self.res;\n\n\tres.options.code = self.status || 200;\n\tres.options.type = output.type;\n\tres.options.headers = output.headers;\n\tres.options.body = output.content;\n\n\tif (output.type !== CT_HTML) {\n\t\tfnFrom && fnFrom.call(self);\n\t\tres.$text();\n\t\treturn;\n\t}\n\n\tswitch (output.type) {\n\t\tcase CT_TEXT:\n\t\t\tF.stats.response.plain++;\n\t\t\treturn self;\n\t\tcase CT_JSON:\n\t\t\tF.stats.response.json++;\n\t\t\treturn self;\n\t\tcase CT_HTML:\n\t\t\tF.stats.response.view++;\n\t\t\tbreak;\n\t}\n\n\tvar length = output.repository.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = output.repository[i].key;\n\t\tif (self.repository[key] === undefined)\n\t\t\tself.repository[key] = output.repository[i].value;\n\t}\n\n\tfnFrom && fnFrom.call(self);\n\n\tif (self.layoutName) {\n\t\tself.output = U.createBuffer(output.content);\n\t\tself.isLayout = true;\n\t\tself.view(self.layoutName, null);\n\t} else {\n\t\tself.req.$total_success();\n\t\tres.$text();\n\t}\n\n\treturn self;\n};\n\nController.prototype.$memorize_prepare = function(key, expires, disabled, fnTo, fnFrom) {\n\n\tvar self = this;\n\tvar pk = '$memorize' + key;\n\n\tif (F.temporary.processing[pk]) {\n\t\tsetTimeout(function() {\n\t\t\t!self.req.$total_canceled && self.memorize(key, expires, disabled, fnTo, fnFrom);\n\t\t}, 500);\n\t\treturn self;\n\t}\n\n\tself.precache = function(value, contentType, headers, isView) {\n\n\t\tif (!value && !contentType && !headers) {\n\t\t\tdelete F.temporary.processing[pk];\n\t\t\tself.precache = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar options = { content: value, type: contentType || CT_TEXT, layout: self.layoutName, theme: self.themeName };\n\t\tif (headers)\n\t\t\toptions.headers = headers;\n\n\t\tif (isView) {\n\t\t\toptions.repository = [];\n\t\t\tfor (var name in self.repository) {\n\t\t\t\tvar value = self.repository[name];\n\t\t\t\tvalue !== undefined && options.repository.push({ key: name, value: value });\n\t\t\t}\n\t\t}\n\n\t\tF.cache.add(key, options, expires, false);\n\t\tself.precache = null;\n\t\tdelete F.temporary.processing[pk];\n\t};\n\n\tif (typeof(disabled) === 'function')\n\t\tfnTo = disabled;\n\n\tF.temporary.processing[pk] = true;\n\tfnTo.call(self);\n\treturn self;\n};\n\n// *********************************************************************************\n// =================================================================================\n// F.WebSocket\n// =================================================================================\n// *********************************************************************************\n\nconst NEWLINE = '\\r\\n';\nconst SOCKET_RESPONSE = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_COMPRESS = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Extensions: permessage-deflate\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_PROTOCOL = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Protocol: {1}\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_PROTOCOL_COMPRESS = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Protocol: {1}\\r\\nSec-WebSocket-Extensions: permessage-deflate\\r\\n\\r\\n';\nconst SOCKET_HASH = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst SOCKET_ALLOW_VERSION = [13];\n\nfunction WebSocket(path, name, id) {\n\tthis._keys = [];\n\tthis.id = id;\n\tthis.online = 0;\n\tthis.connections = {};\n\tthis.name = name;\n\tthis.isController = true;\n\tthis.url = U.path(path);\n\tthis.route = null;\n\tthis.$events = {};\n\n\t// on('open', function(client) {});\n\t// on('close', function(client) {});\n\t// on('message', function(client, message) {});\n\t// on('error', function(error, client) {});\n\t// Events.EventEmitter.call(this);\n}\n\nWebSocket.prototype = {\n\n\tget repository() {\n\t\tif (this.$repository)\n\t\t\treturn this.$repository;\n\t\telse\n\t\t\treturn this.$repository ? this.$repository : (this.$repository = {});\n\t},\n\n\tget global() {\n\t\tOBSOLETE('controller.global', 'Use: G');\n\t\treturn F.global;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn CONF;\n\t},\n\n\tget cache() {\n\t\tOBSOLETE('controller.cache', 'Use: F.cache or CACHE()');\n\t\treturn F.cache;\n\t},\n\n\tget isDebug() {\n\t\tOBSOLETE('controller.isDebug', 'Use: DEBUG');\n\t\treturn DEBUG;\n\t},\n\n\tget path() {\n\t\tOBSOLETE('controller.path', 'Use: PATH');\n\t\treturn F.path;\n\t},\n\n\tget isSecure() {\n\t\tOBSOLETE('controller.isSecure', 'Use: controller.secured');\n\t\treturn this.req.isSecure;\n\t},\n\n\tget secured() {\n\t\treturn this.req.secured;\n\t},\n\n\tget params() {\n\t\tif (this.$params)\n\t\t\treturn this.$params;\n\t\tvar split = framework_internal.routeSplit(this.url, true);\n\t\tvar names = this.route.paramnames;\n\t\tif (names) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < names.length; i++)\n\t\t\t\tobj[names[i]] = split[this.route.param[i]];\n\t\t\tthis.$params = obj;\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tthis.$params = EMPTYOBJECT;\n\t\t\treturn EMPTYOBJECT;\n\t\t}\n\t}\n};\n\nWebSocket.prototype.operation = function(name, value, callback, options) {\n\tOPERATION(name, value, callback, options, this);\n\treturn this;\n};\n\nWebSocket.prototype.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nWebSocket.prototype.on = function(name, fn) {\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nWebSocket.prototype.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nWebSocket.prototype.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nWebSocket.prototype.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\n/**\n * Sends a message\n * @param {String} message\n * @param {String Array or Function(id, client)} id (optional)\n * @param {String Array or Function(id, client)} blacklist (optional)\n * @param {Function(key, value)} replacer for JSON (optional)\n * @return {WebSocket}\n */\nWebSocket.prototype.send = function(message, id, blacklist, replacer) {\n\n\tvar self = this;\n\tvar keys = self._keys;\n\n\tif (!keys || !keys.length || message === undefined)\n\t\treturn self;\n\n\tvar data;\n\tvar raw = false;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar conn = self.connections[keys[i]];\n\n\t\tif (id) {\n\t\t\tif (id instanceof Array) {\n\t\t\t\tif (!websocket_valid_array(conn.id, id))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (id instanceof Function) {\n\t\t\t\tif (!websocket_valid_fn(conn.id, conn, id, message))\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tthrow new Error('Invalid \"id\" argument.');\n\t\t}\n\n\t\tif (blacklist) {\n\t\t\tif (blacklist instanceof Array) {\n\t\t\t\tif (websocket_valid_array(conn.id, blacklist))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (blacklist instanceof Function) {\n\t\t\t\tif (websocket_valid_fn(conn.id, conn, blacklist, message))\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tthrow new Error('Invalid \"blacklist\" argument.');\n\t\t}\n\n\t\tif (data === undefined) {\n\t\t\tif (conn.type === 3) {\n\t\t\t\traw = true;\n\t\t\t\tdata = JSON.stringify(message, replacer);\n\t\t\t} else\n\t\t\t\tdata = message;\n\t\t}\n\n\t\tconn.send(data, raw);\n\t\tF.stats.response.websocket++;\n\t}\n\n\treturn self;\n};\n\nWebSocket.prototype.send2 = function(message, comparer, replacer) {\n\n\tvar self = this;\n\tvar keys = self._keys;\n\tif (!keys || !keys.length || message === undefined)\n\t\treturn self;\n\n\tvar data;\n\tvar raw = false;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar conn = self.connections[keys[i]];\n\n\t\tif (data === undefined) {\n\t\t\tif (conn.type === 3) {\n\t\t\t\traw = true;\n\t\t\t\tdata = JSON.stringify(message, replacer);\n\t\t\t} else\n\t\t\t\tdata = message;\n\t\t}\n\n\t\tif (comparer && !comparer(conn, message))\n\t\t\tcontinue;\n\n\t\tconn.send(data, raw);\n\t\tF.stats.response.websocket++;\n\t}\n\n\treturn self;\n};\n\nfunction websocket_valid_array(id, arr) {\n\treturn arr.indexOf(id) !== -1;\n}\n\nfunction websocket_valid_fn(id, client, fn, msg) {\n\treturn fn && fn(id, client, msg) ? true : false;\n}\n\n/**\n * Sends a ping message\n * @return {WebSocket}\n */\nWebSocket.prototype.ping = function() {\n\n\tvar keys = this._keys;\n\tif (!keys)\n\t\treturn this;\n\n\tvar length = keys.length;\n\tif (length) {\n\t\tthis.$ping = true;\n\t\tF.stats.other.websocketPing++;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tthis.connections[keys[i]].ping();\n\t}\n\n\treturn this;\n};\n\n/**\n * Closes a connection\n * @param {String Array} id Client id, optional, default `null`.\n * @param {String} message A message for the browser.\n * @param {Number} code Optional default 1000.\n * @return {Websocket}\n */\nWebSocket.prototype.close = function(id, message, code) {\n\n\tvar keys = this._keys;\n\n\tif (!keys)\n\t\treturn this;\n\n\tif (typeof(id) === 'string') {\n\t\tcode = message;\n\t\tmessage = id;\n\t\tid = null;\n\t}\n\n\tvar length = keys.length;\n\tif (!length)\n\t\treturn this;\n\n\tif (!id || !id.length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar _id = keys[i];\n\t\t\tthis.connections[_id].close(message, code);\n\t\t\tthis.$remove(_id);\n\t\t}\n\t\tthis.$refresh();\n\t\treturn this;\n\t}\n\n\tvar is = id instanceof Array;\n\tvar fn = typeof(id) === 'function' ? id : null;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar _id = keys[i];\n\t\tif (is && id.indexOf(_id) === -1)\n\t\t\tcontinue;\n\n\t\tvar conn = this.connections[_id];\n\t\tif (fn && !fn.call(this, _id, conn))\n\t\t\tcontinue;\n\n\t\tconn.close(message, code);\n\t\tthis.$remove(_id);\n\t}\n\n\tthis.$refresh();\n\treturn this;\n};\n\n/**\n * Error caller\n * @param {Error/String} err\n * @return {WebSocket/Function}\n */\nWebSocket.prototype.error = function(err) {\n\tvar result = F.error(typeof(err) === 'string' ? new Error(err) : err, this.name, this.path);\n\treturn err ? this : result;\n};\n\n/**\n * Creates a problem\n * @param {String} message\n * @return {WebSocket}\n */\nWebSocket.prototype.wtf = WebSocket.prototype.problem = function(message) {\n\tF.problem(message, this.name, this.uri);\n\treturn this;\n};\n\n/**\n * Creates a change\n * @param {String} message\n * @return {WebSocket}\n */\nWebSocket.prototype.change = function(message) {\n\tF.change(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * The method executes a provided function once per client.\n * @param {Function(connection, index)} fn\n * @return {WebSocket}\n */\nWebSocket.prototype.all = function(fn) {\n\tvar arr = fn == null || fn == true ? [] : null;\n\tvar self = this;\n\tif (self._keys) {\n\t\tfor (var i = 0, length = self._keys.length; i < length; i++) {\n\t\t\tif (arr)\n\t\t\t\tarr.push(self.connections[self._keys[i]]);\n\t\t\telse\n\t\t\t\tfn(self.connections[self._keys[i]], i);\n\t\t}\n\t}\n\treturn arr ? arr : self;\n};\n\n/**\n * Finds a connection\n * @param {String} id\n * @return {WebSocketClient}\n */\nWebSocket.prototype.find = function(id) {\n\tvar self = this;\n\n\tif (!self._keys)\n\t\treturn self;\n\n\tvar length = self._keys.length;\n\tvar isFn = typeof(id) === 'function';\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar connection = self.connections[self._keys[i]];\n\t\tif (isFn) {\n\t\t\tif (id(connection, connection.id))\n\t\t\t\treturn connection;\n\t\t} else if (connection.id === id)\n\t\t\treturn connection;\n\t}\n\treturn null;\n};\n\n/**\n * Destroys a WebSocket controller\n * @param {String} problem Optional.\n * @return {WebSocket}\n */\nWebSocket.prototype.destroy = function(problem) {\n\tvar self = this;\n\n\tproblem && self.problem(problem);\n\tif (!self.connections && !self._keys)\n\t\treturn self;\n\n\tself.close();\n\tself.$events.destroy && self.emit('destroy');\n\n\tsetTimeout(function() {\n\n\t\tself._keys.forEach(function(key) {\n\t\t\tvar conn = self.connections[key];\n\t\t\tif (conn) {\n\t\t\t\tconn._isClosed = true;\n\t\t\t\tconn.socket.removeAllListeners();\n\t\t\t}\n\t\t});\n\n\t\tself.connections = null;\n\t\tself._keys = null;\n\t\tself.route = null;\n\t\tself.buffer = null;\n\t\tdelete F.connections[self.id];\n\t\tself.removeAllListeners();\n\t}, 1000);\n\n\treturn self;\n};\n\n/**\n * Enables auto-destroy websocket controller when any user is not online\n * @param {Function} callback\n * @return {WebSocket]\n */\nWebSocket.prototype.autodestroy = function(callback) {\n\tvar self = this;\n\tvar key = 'websocket:' + self.id;\n\tself.on('open', () => clearTimeout2(key));\n\tself.on('close', function() {\n\t\t!self.online && setTimeout2(key, function() {\n\t\t\tcallback && callback.call(self);\n\t\t\tself.destroy();\n\t\t}, 5000);\n\t});\n\treturn self;\n};\n\n/**\n * Internal function\n * @return {WebSocket}\n */\nWebSocket.prototype.$refresh = function() {\n\tif (this.connections) {\n\t\tthis._keys = Object.keys(this.connections);\n\t\tthis.online = this._keys.length;\n\t} else\n\t\tthis.online = 0;\n\treturn this;\n};\n\n/**\n * Internal function\n * @param {String} id\n * @return {WebSocket}\n */\nWebSocket.prototype.$remove = function(id) {\n\tif (this.connections)\n\t\tdelete this.connections[id];\n\treturn this;\n};\n\n/**\n * Internal function\n * @param {WebSocketClient} client\n * @return {WebSocket}\n */\nWebSocket.prototype.$add = function(client) {\n\tthis.connections[client._id] = client;\n\treturn this;\n};\n\n/**\n * A resource header\n * @param {String} name A resource name.\n * @param {String} key A resource key.\n * @return {String}\n */\nWebSocket.prototype.resource = function(name, key) {\n\treturn F.resource(name, key);\n};\n\nWebSocket.prototype.log = function() {\n\tF.log.apply(framework, arguments);\n\treturn this;\n};\n\nWebSocket.prototype.logger = function() {\n\tF.logger.apply(framework, arguments);\n\treturn this;\n};\n\nWebSocket.prototype.check = function() {\n\tthis.$ping && this.all(websocketcheck_ping);\n\treturn this;\n};\n\nfunction websocketcheck_ping(client) {\n\tif (!client.$ping) {\n\t\tclient.close();\n\t\tF.stats.other.websocketCleaner++;\n\t}\n}\n\n/**\n * WebSocket controller\n * @param {Request} req\n * @param {Socket} socket\n */\nfunction WebSocketClient(req, socket) {\n\tthis.$ping = true;\n\tthis.container;\n\tthis._id;\n\tthis.id = '';\n\tthis.socket = socket;\n\tthis.req = req;\n\n\t// this.isClosed = false;\n\tthis.errors = 0;\n\tthis.length = 0;\n\tthis.current = {};\n\n\t// 1 = raw - not implemented\n\t// 2 = plain\n\t// 3 = JSON\n\n\tthis.type = 2;\n\t// this._isClosed = false;\n}\n\nWebSocketClient.prototype = {\n\n\tget protocol() {\n\t\treturn (this.req.headers['sec-websocket-protocol'] || '').replace(REG_EMPTY, '').split(',');\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget get() {\n\t\treturn this.req.query;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tget uri() {\n\t\treturn this.req.uri;\n\t},\n\n\tget config() {\n\t\treturn this.container.config;\n\t},\n\n\tget global() {\n\t\treturn this.container.global;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tset session(value) {\n\t\tthis.req.session = value;\n\t},\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tset user(value) {\n\t\tthis.req.user = value;\n\t},\n\n\tget mobile() {\n\t\treturn this.req.mobile;\n\t}\n};\n\nWebSocketClient.prototype.isWebSocket = true;\n\nWebSocketClient.prototype.cookie = function(name) {\n\treturn this.req.cookie(name);\n};\n\nWebSocketClient.prototype.$close = function(code, message) {\n\n\tvar self = this;\n\n\tif ((self.req.headers['user-agent'] || '').indexOf('Total.js') !== -1) {\n\t\tself.close();\n\t\treturn;\n\t}\n\n\tvar header = SOCKET_RESPONSE.format(self.$websocket_key(self.req));\n\tself.socket.write(U.createBuffer(header, 'binary'));\n\tself.ready = true;\n\tself.close(message, code);\n\n\tsetTimeout(function(self) {\n\t\tself.req = null;\n\t\tself.socket = null;\n\t}, 1000, self);\n\n\treturn self;\n};\n\nWebSocketClient.prototype.prepare = function(flags, protocols, allow, length) {\n\n\tflags = flags || EMPTYARRAY;\n\tprotocols = protocols || EMPTYARRAY;\n\tallow = allow || EMPTYARRAY;\n\n\tvar self = this;\n\n\tif (SOCKET_ALLOW_VERSION.indexOf(U.parseInt(self.req.headers['sec-websocket-version'])) === -1)\n\t\treturn false;\n\n\tself.length = length;\n\n\tvar origin = self.req.headers.origin || '';\n\tvar length = allow.length;\n\n\tif (length && allow.indexOf('*') === -1) {\n\t\tvar is = false;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (origin.indexOf(allow[i]) !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\treturn false;\n\t}\n\n\tlength = protocols.length;\n\tif (length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (self.protocol.indexOf(protocols[i]) === -1)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tvar compress = (CONF.allow_websocket_compression && self.req.headers['sec-websocket-extensions'] || '').indexOf('permessage-deflate') !== -1;\n\tvar header = protocols.length ? (compress ? SOCKET_RESPONSE_PROTOCOL_COMPRESS : SOCKET_RESPONSE_PROTOCOL).format(self.$websocket_key(self.req), protocols.join(', ')) : (compress ? SOCKET_RESPONSE_COMPRESS : SOCKET_RESPONSE).format(self.$websocket_key(self.req));\n\n\tself.socket.write(U.createBuffer(header, 'binary'));\n\tself.ready = true;\n\n\tif (compress) {\n\t\tself.inflatepending = [];\n\t\tself.inflatelock = false;\n\t\tself.inflate = Zlib.createInflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\tself.inflate.$websocket = self;\n\t\tself.inflate.on('error', function() {\n\t\t\tif (!self.$uerror) {\n\t\t\t\tself.$uerror = true;\n\t\t\t\tself.close('Invalid data', 1003);\n\t\t\t}\n\t\t});\n\t\tself.inflate.on('data', websocket_inflate);\n\n\t\tself.deflatepending = [];\n\t\tself.deflatelock = false;\n\t\tself.deflate = Zlib.createDeflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\tself.deflate.$websocket = self;\n\t\tself.deflate.on('error', function() {\n\t\t\tif (!self.$uerror) {\n\t\t\t\tself.$uerror = true;\n\t\t\t\tself.close('Invalid data', 1003);\n\t\t\t}\n\t\t});\n\t\tself.deflate.on('data', websocket_deflate);\n\t}\n\n\tself._id = Date.now() + U.GUID(5);\n\tself.id = self._id;\n\treturn true;\n};\n\nfunction websocket_inflate(data) {\n\tthis.$websocket.inflatechunks.push(data);\n\tthis.$websocket.inflatechunkslength += data.length;\n}\n\nfunction websocket_deflate(data) {\n\tthis.$websocket.deflatechunks.push(data);\n\tthis.$websocket.deflatechunkslength += data.length;\n}\n\n/**\n * Add a container to client\n * @param {WebSocket} container\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.upgrade = function(container) {\n\tvar self = this;\n\tself.req.on('error', websocket_onerror);\n\tself.container = container;\n\tself.socket.$websocket = this;\n\tself.socket.on('data', websocket_ondata);\n\tself.socket.on('error', websocket_onerror);\n\tself.socket.on('close', websocket_close);\n\tself.socket.on('end', websocket_close);\n\tself.container.$add(self);\n\tself.container.$refresh();\n\tF.$events['websocket-begin'] && EMIT('websocket-begin', self.container, self);\n\tself.container.$events.open && self.container.emit('open', self);\n\treturn self;\n};\n\nfunction websocket_ondata(chunk) {\n\tthis.$websocket.$ondata(chunk);\n}\n\nfunction websocket_onerror(e) {\n\tthis.destroy && this.destroy();\n\tthis.$websocket.$onerror(e);\n}\n\nfunction websocket_close() {\n\tthis.destroy && this.destroy();\n\tthis.$websocket.$onclose();\n}\n\nWebSocketClient.prototype.$ondata = function(data) {\n\n\tif (this.isClosed)\n\t\treturn;\n\n\tvar current = this.current;\n\n\tif (data) {\n\t\tif (current.buffer) {\n\t\t\tCONCAT[0] = current.buffer;\n\t\t\tCONCAT[1] = data;\n\t\t\tcurrent.buffer = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tcurrent.buffer = data;\n\t}\n\n\tif (!this.$parse())\n\t\treturn;\n\n\tif (!current.final && current.type !== 0x00)\n\t\tcurrent.type2 = current.type;\n\n\tvar tmp;\n\n\tswitch (current.type === 0x00 ? current.type2 : current.type) {\n\t\tcase 0x01:\n\n\t\t\t// text\n\t\t\tif (this.inflate) {\n\t\t\t\tcurrent.final && this.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = this.$readbody();\n\t\t\t\tif (current.body)\n\t\t\t\t\tcurrent.body += tmp;\n\t\t\t\telse\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && this.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\n\t\t\t// binary\n\t\t\tif (this.inflate) {\n\t\t\t\tcurrent.final && this.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = this.$readbody();\n\t\t\t\tif (current.body) {\n\t\t\t\t\tCONCAT[0] = current.body;\n\t\t\t\t\tCONCAT[1] = tmp;\n\t\t\t\t\tcurrent.body = Buffer.concat(CONCAT);\n\t\t\t\t} else\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && this.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\t// close\n\t\t\tthis.closemessage = current.buffer.slice(4).toString('utf8');\n\t\t\tthis.closecode = current.buffer[2] << 8 | current.buffer[3];\n\n\t\t\tif (this.closemessage && CONF.default_websocket_encodedecode)\n\t\t\t\tthis.closemessage = $decodeURIComponent(this.closemessage);\n\n\t\t\tthis.close();\n\t\t\tbreak;\n\n\t\tcase 0x09:\n\t\t\t// ping, response pong\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, 'PONG', 0x0A));\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tthis.$ping = true;\n\t\t\tbreak;\n\n\t\tcase 0x0a:\n\t\t\t// pong\n\t\t\tthis.$ping = true;\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tbreak;\n\t}\n\n\tif (current.buffer) {\n\t\tcurrent.buffer = current.buffer.slice(current.length, current.buffer.length);\n\t\tcurrent.buffer.length && this.$ondata();\n\t}\n};\n\nfunction buffer_concat(buffers, length) {\n\tvar buffer = U.createBufferSize(length);\n\tvar offset = 0;\n\tfor (var i = 0, n = buffers.length; i < n; i++) {\n\t\tbuffers[i].copy(buffer, offset);\n\t\toffset += buffers[i].length;\n\t}\n\treturn buffer;\n}\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nWebSocketClient.prototype.$parse = function() {\n\n\tvar self = this;\n\tvar current = self.current;\n\n\t// check end message\n\tif (!current.buffer || current.buffer.length <= 2 || ((current.buffer[0] & 0x80) >> 7) !== 1)\n\t\treturn;\n\n\t// webSocked - Opcode\n\tcurrent.type = current.buffer[0] & 0x0f;\n\n\t// is final message?\n\tcurrent.final = ((current.buffer[0] & 0x80) >> 7) === 0x01;\n\n\t// does frame contain mask?\n\tcurrent.isMask = ((current.buffer[1] & 0xfe) >> 7) === 0x01;\n\n\t// data length\n\tvar length = U.getMessageLength(current.buffer, F.isLE);\n\t// index for data\n\n\tvar index = current.buffer[1] & 0x7f;\n\tindex = ((index === 126) ? 4 : (index === 127 ? 10 : 2)) + (current.isMask ? 4 : 0);\n\n\t// total message length (data + header)\n\tvar mlength = index + length;\n\n\tif (mlength > this.length) {\n\t\tthis.close('Frame is too large', 1009);\n\t\treturn;\n\t}\n\n\t// Check length of data\n\tif (current.buffer.length < mlength)\n\t\treturn;\n\n\tcurrent.length = mlength;\n\n\t// Not Ping & Pong\n\tif (current.type !== 0x09 && current.type !== 0x0A) {\n\n\t\t// does frame contain mask?\n\t\tif (current.isMask) {\n\t\t\tcurrent.mask = U.createBufferSize(4);\n\t\t\tcurrent.buffer.copy(current.mask, 0, index - 4, index);\n\t\t}\n\n\t\tif (this.inflate) {\n\n\t\t\tvar buf = U.createBufferSize(length);\n\t\t\tcurrent.buffer.copy(buf, 0, index, mlength);\n\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask) {\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t\tbuf[i] = buf[i] ^ current.mask[i % 4];\n\t\t\t}\n\n\t\t\t// Does the buffer continue?\n\t\t\tbuf.$continue = current.final === false;\n\t\t\tthis.inflatepending.push(buf);\n\t\t} else {\n\t\t\tcurrent.data = U.createBufferSize(length);\n\t\t\tcurrent.buffer.copy(current.data, 0, index, mlength);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nWebSocketClient.prototype.$readbody = function() {\n\n\tvar current = this.current;\n\tvar length = current.data.length;\n\tvar buf;\n\n\tif (current.type === 1) {\n\n\t\tbuf = U.createBufferSize(length);\n\t\tfor (var i = 0; i < length; i++)  {\n\t\t\tif (current.isMask)\n\t\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\t\telse\n\t\t\t\tbuf[i] = current.data[i];\n\t\t}\n\n\t\treturn buf.toString('utf8');\n\n\t} else {\n\n\t\tbuf = U.createBufferSize(length);\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask)\n\t\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\t\telse\n\t\t\t\tbuf[i] = current.data[i];\n\t\t}\n\t\treturn buf;\n\t}\n};\n\nWebSocketClient.prototype.$decode = function() {\n\tvar data = this.current.body;\n\n\tswitch (this.type) {\n\n\t\tcase 1: // BINARY\n\t\t\tthis.container.emit('message', this, new Uint8Array(data).buffer);\n\t\t\tbreak;\n\n\t\tcase 3: // JSON\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tCONF.default_websocket_encodedecode === true && (data = $decodeURIComponent(data));\n\t\t\tif (data.isJSON()) {\n\t\t\t\tvar tmp = F.onParseJSON(data, this.req);\n\t\t\t\tif (tmp !== undefined)\n\t\t\t\t\tthis.container.emit('message', this, tmp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: // TEXT\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tthis.container.emit('message', this, CONF.default_websocket_encodedecode === true ? $decodeURIComponent(data) : data);\n\t\t\tbreak;\n\t}\n\n\tthis.current.body = null;\n};\n\nWebSocketClient.prototype.parseInflate = function() {\n\tvar self = this;\n\n\tif (self.inflatelock)\n\t\treturn;\n\n\tvar buf = self.inflatepending.shift();\n\tif (buf) {\n\t\tself.inflatechunks = [];\n\t\tself.inflatechunkslength = 0;\n\t\tself.inflatelock = true;\n\t\tself.inflate.write(buf);\n\t\t!buf.$continue && self.inflate.write(U.createBuffer(WEBSOCKET_COMPRESS));\n\t\tself.inflate.flush(function() {\n\n\t\t\tif (!self.inflatechunks)\n\t\t\t\treturn;\n\n\t\t\tvar data = buffer_concat(self.inflatechunks, self.inflatechunkslength);\n\n\t\t\tself.inflatechunks = null;\n\t\t\tself.inflatelock = false;\n\n\t\t\tif (data.length > self.length) {\n\t\t\t\tself.close('Frame is too large', 1009);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (self.current.body) {\n\t\t\t\tCONCAT[0] = self.current.body;\n\t\t\t\tCONCAT[1] = data;\n\t\t\t\tself.current.body = Buffer.concat(CONCAT);\n\t\t\t} else\n\t\t\t\tself.current.body = data;\n\n\t\t\t!buf.$continue && self.$decode();\n\t\t\tself.parseInflate();\n\t\t});\n\t}\n};\n\nWebSocketClient.prototype.$onerror = function(err) {\n\n\tif (this.isClosed)\n\t\treturn;\n\n\tif (REG_WEBSOCKET_ERROR.test(err.stack)) {\n\t\tthis.isClosed = true;\n\t\tthis.$onclose();\n\t} else\n\t\tthis.container.$events.error && this.container.emit('error', err, this);\n};\n\nWebSocketClient.prototype.$onclose = function() {\n\tif (this._isClosed)\n\t\treturn;\n\n\tthis.isClosed = true;\n\tthis._isClosed = true;\n\n\tif (this.inflate) {\n\t\tthis.inflate.removeAllListeners();\n\t\tthis.inflate = null;\n\t\tthis.inflatechunks = null;\n\t}\n\n\tif (this.deflate) {\n\t\tthis.deflate.removeAllListeners();\n\t\tthis.deflate = null;\n\t\tthis.deflatechunks = null;\n\t}\n\n\tthis.container.$remove(this._id);\n\tthis.container.$refresh();\n\tthis.container.$events.close && this.container.emit('close', this, this.closecode, this.closemessage);\n\tthis.socket.removeAllListeners();\n\tF.$events['websocket-end'] && EMIT('websocket-end', this.container, this);\n};\n\n/**\n * Sends a message\n * @param {String/Object} message\n * @param {Boolean} raw The message won't be converted e.g. to JSON.\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.send = function(message, raw, replacer) {\n\n\tvar self = this;\n\n\tif (self.isClosed)\n\t\treturn self;\n\n\tif (self.type !== 1) {\n\t\tvar data = self.type === 3 ? (raw ? message : JSON.stringify(message, replacer)) : typeof(message) === 'object' ? JSON.stringify(message, replacer) : message.toString();\n\t\tif (CONF.default_websocket_encodedecode === true && data)\n\t\t\tdata = encodeURIComponent(data);\n\t\tif (self.deflate) {\n\t\t\tself.deflatepending.push(U.createBuffer(data));\n\t\t\tself.sendDeflate();\n\t\t} else\n\t\t\tself.socket.write(U.getWebSocketFrame(0, data, 0x01));\n\t} else if (message) {\n\t\tif (self.deflate) {\n\t\t\tself.deflatepending.push(U.createBuffer(message));\n\t\t\tself.sendDeflate();\n\t\t} else\n\t\t\tself.socket.write(U.getWebSocketFrame(0, new Int8Array(message), 0x02));\n\t}\n\n\treturn self;\n};\n\nWebSocketClient.prototype.sendDeflate = function() {\n\tvar self = this;\n\n\tif (self.deflatelock)\n\t\treturn;\n\n\tvar buf = self.deflatepending.shift();\n\tif (buf) {\n\t\tself.deflatechunks = [];\n\t\tself.deflatechunkslength = 0;\n\t\tself.deflatelock = true;\n\t\tself.deflate.write(buf);\n\t\tself.deflate.flush(function() {\n\t\t\tif (self.deflatechunks) {\n\t\t\t\tvar data = buffer_concat(self.deflatechunks, self.deflatechunkslength);\n\t\t\t\tdata = data.slice(0, data.length - 4);\n\t\t\t\tself.deflatelock = false;\n\t\t\t\tself.deflatechunks = null;\n\t\t\t\tself.socket.write(U.getWebSocketFrame(0, data, self.type === 1 ? 0x02 : 0x01, true));\n\t\t\t\tself.sendDeflate();\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Ping message\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.ping = function() {\n\tif (!this.isClosed) {\n\t\tthis.socket.write(U.getWebSocketFrame(0, 'PING', 0x09));\n\t\tthis.$ping = false;\n\t}\n\treturn this;\n};\n\n/**\n * Close connection\n * @param {String} message Message.\n * @param {Number} code WebSocket code.\n * @return {WebSocketClient}\n */\nWebSocketClient.prototype.close = function(message, code) {\n\tvar self = this;\n\tif (!self.isClosed) {\n\t\tself.isClosed = true;\n\t\tif (self.ready)\n\t\t\tself.socket.end(U.getWebSocketFrame(code || 1000, message ? (CONF.default_websocket_encodedecode ? encodeURIComponent(message) : message) : '', 0x08));\n\t\telse\n\t\t\tself.socket.end();\n\t\tself.req.connection.destroy();\n\t}\n\treturn self;\n};\n\n/**\n * Create a signature for the WebSocket\n * @param {Request} req\n * @return {String}\n */\nWebSocketClient.prototype.$websocket_key = function(req) {\n\tvar sha1 = Crypto.createHash('sha1');\n\tsha1.update((req.headers['sec-websocket-key'] || '') + SOCKET_HASH);\n\treturn sha1.digest('base64');\n};\n\n// *********************************************************************************\n// =================================================================================\n// Prototypes\n// =================================================================================\n// *********************************************************************************\n\nfunction extend_request(PROTO) {\n\n\tPROTOREQ = PROTO;\n\n\tObject.defineProperty(PROTO, 'ip', {\n\t\tget: function() {\n\t\t\tif (this._ip)\n\t\t\t\treturn this._ip;\n\n\t\t\t//  x-forwarded-for: client, proxy1, proxy2, ...\n\t\t\tvar proxy = this.headers['x-forwarded-for'];\n\t\t\tif (proxy)\n\t\t\t\tthis._ip = proxy.split(',', 1)[0] || this.connection.remoteAddress;\n\t\t\telse if (!this._ip)\n\t\t\t\tthis._ip = this.connection.remoteAddress;\n\n\t\t\treturn this._ip;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'query', {\n\t\tget: function() {\n\t\t\t!this._querydata && F.$onParseQueryUrl(this);\n\t\t\treturn this._querydata;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis._querydata = value;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'subdomain', {\n\t\tget: function() {\n\t\t\tif (this._subdomain)\n\t\t\t\treturn this._subdomain;\n\t\t\tvar subdomain = this.uri.hostname.toLowerCase().replace(REG_WWW, '').split('.');\n\t\t\tif (subdomain.length > 2) // example: [subdomain].domain.com\n\t\t\t\tthis._subdomain = subdomain.slice(0, subdomain.length - 2);\n\t\t\telse if (subdomain.length > 1 && subdomain[subdomain.length - 1] === 'localhost') // example: [subdomain].localhost\n\t\t\t\tthis._subdomain = subdomain.slice(0, subdomain.length - 1);\n\t\t\telse\n\t\t\t\tthis._subdomain = null;\n\t\t\treturn this._subdomain;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'host', {\n\t\tget: function() {\n\t\t\treturn this.headers['host'];\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'split', {\n\t\tget: function() {\n\t\t\treturn this.$path ? this.$path : this.$path = framework_internal.routeSplit(this.uri.pathname, true);\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'secured', {\n\t\tget: function() {\n\t\t\treturn this.uri.protocol === 'https:' || this.uri.protocol === 'wss:';\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'language', {\n\t\tget: function() {\n\t\t\tif (!this.$language)\n\t\t\t\tthis.$language = (((this.headers['accept-language'] || '').split(';')[0] || '').split(',')[0] || '').toLowerCase();\n\t\t\treturn this.$language;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.$language = value;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'mobile', {\n\t\tget: function() {\n\t\t\tif (this.$mobile === undefined)\n\t\t\t\tthis.$mobile = REG_MOBILE.test(this.headers['user-agent']);\n\t\t\treturn this.$mobile;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'robot', {\n\t\tget: function() {\n\t\t\tif (this.$robot === undefined)\n\t\t\t\tthis.$robot = REG_ROBOT.test(this.headers['user-agent']);\n\t\t\treturn this.$robot;\n\t\t}\n\t});\n\n\t/**\n\t * Signature request (user-agent + ip + referer + current URL + custom key)\n\t * @param {String} key Custom key.\n\t * @return {Request}\n\t */\n\tPROTO.signature = function(key) {\n\t\treturn F.encrypt((this.headers['user-agent'] || '') + '#' + this.ip + '#' + this.url + '#' + (key || ''), 'request-signature', false);\n\t};\n\n\tPROTO.localize = function() {\n\t\tF.onLocale && (this.$language = F.onLocale(this, this.res, this.isStaticFile));\n\t\treturn this.$language;\n\t};\n\n\t/**\n\t * Disable HTTP cache for current request\n\t * @return {Request}\n\t */\n\tPROTO.noCache = function() {\n\t\tthis.res && this.res.noCache();\n\t\treturn this;\n\t};\n\n\t/**\n\t * Read a cookie from current request\n\t * @param {String} name Cookie name.\n\t * @return {String} Cookie value (default: '')\n\t */\n\tPROTO.cookie = function(name) {\n\n\t\tif (this.cookies)\n\t\t\treturn $decodeURIComponent(this.cookies[name] || '');\n\n\t\tvar cookie = this.headers['cookie'];\n\t\tif (!cookie)\n\t\t\treturn '';\n\n\t\tthis.cookies = {};\n\n\t\tvar arr = cookie.split(';');\n\n\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\tvar line = arr[i].trim();\n\t\t\tvar index = line.indexOf('=');\n\t\t\tif (index !== -1)\n\t\t\t\tthis.cookies[line.substring(0, index)] = line.substring(index + 1);\n\t\t}\n\n\t\treturn $decodeURIComponent(this.cookies[name] || '');\n\t};\n\n\t/**\n\t * Read authorization header\n\t * @return {Object}\n\t */\n\tPROTO.authorization = function() {\n\n\t\tvar authorization = this.headers['authorization'];\n\t\tif (!authorization)\n\t\t\treturn HEADERS.authorization;\n\n\t\tvar result = { user: '', password: '', empty: true };\n\n\t\ttry {\n\t\t\tvar arr = U.createBuffer(authorization.replace('Basic ', '').trim(), 'base64').toString(ENCODING).split(':');\n\t\t\tresult.user = arr[0] || '';\n\t\t\tresult.password = arr[1] || '';\n\t\t\tresult.empty = !result.user || !result.password;\n\t\t} catch (e) {}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Authorization for custom delegates\n\t * @param  {Function(err, userprofile, isAuthorized)} callback\n\t * @return {Request}\n\t */\n\tPROTO.authorize = function(callback) {\n\n\t\tvar auth = F.onAuthorize;\n\n\t\tif (!auth) {\n\t\t\tcallback(null, null, false);\n\t\t\treturn this;\n\t\t}\n\n\t\tvar req = this;\n\n\t\tauth(req, req.res, req.flags || [], function(isAuthorized, user) {\n\t\t\tif (typeof(isAuthorized) !== 'boolean') {\n\t\t\t\tuser = isAuthorized;\n\t\t\t\tisAuthorized = !user;\n\t\t\t}\n\t\t\treq.isAuthorized = isAuthorized;\n\t\t\tcallback(null, user, isAuthorized);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Clear all uplaoded files\n\t * @private\n\t * @param {Boolean} isAuto\n\t * @return {Request}\n\t */\n\tPROTO.clear = function(isAuto) {\n\n\t\tvar self = this;\n\t\tvar files = self.files;\n\n\t\tif (!files || (isAuto && self._manual))\n\t\t\treturn self;\n\n\t\tself.body = null;\n\t\tself.query = null;\n\t\tself.cookies = null;\n\n\t\tvar length = files.length;\n\t\tif (!length)\n\t\t\treturn self;\n\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tfiles[i].rem && arr.push(files[i].path);\n\n\t\tF.unlink(arr);\n\t\tself.files = null;\n\t\treturn self;\n\t};\n\n\t/**\n\t * Get host name from URL\n\t * @param {String} path Additional path.\n\t * @return {String}\n\t */\n\tPROTO.hostname = function(path) {\n\n\t\tvar self = this;\n\t\tvar uri = self.uri;\n\n\t\tif (path && path[0] !== '/')\n\t\t\tpath = '/' + path;\n\n\t\treturn uri.protocol + '//' + uri.hostname + (uri.port && uri.port !== 80 ? ':' + uri.port : '') + (path || '');\n\t};\n\n\tPROTO.$total_success = function() {\n\t\tthis.$total_timeout && clearTimeout(this.$total_timeout);\n\t\tthis.$total_canceled = true;\n\t\tif (this.controller) {\n\t\t\tthis.controller.res.controller = null;\n\t\t\tthis.controller = null;\n\t\t}\n\t};\n\n\tPROTO.$total_file = function() {\n\t\tvar h = this.method[0];\n\t\tif (h === 'G' || h === 'H')\n\t\t\tthis.$total_endfile();\n\t\telse\n\t\t\tthis.on('end', this.$total_endfile);\n\t};\n\n\tPROTO.$total_multipart = function(header) {\n\t\tF.stats.request.upload++;\n\t\tthis.$total_route = F.lookup(this, this.uri.pathname, this.flags, 0);\n\t\tthis.$total_header = header;\n\t\tif (this.$total_route) {\n\t\t\tF.path.verify('temp');\n\t\t\tframework_internal.parseMULTIPART(this, header, this.$total_route, CONF.directory_temp);\n\t\t} else\n\t\t\tthis.$total_status(404);\n\t};\n\n\tPROTO.$total_urlencoded = function() {\n\t\tthis.$total_route = F.lookup(this, this.uri.pathname, this.flags, 0);\n\t\tif (this.$total_route) {\n\t\t\tthis.buffer_has = true;\n\t\t\tthis.buffer_exceeded = false;\n\t\t\tthis.on('data', this.$total_parsebody);\n\t\t\tthis.$total_end();\n\t\t} else\n\t\t\tthis.$total_status(404);\n\t};\n\n\tPROTO.$total_status = function(status) {\n\n\t\tif (status == null)\n\t\t\tF.stats.request.blocked++;\n\t\telse\n\t\t\tF.stats.request['error' + status]++;\n\n\t\tF.reqstats(false, false);\n\t\tthis.res.writeHead(status);\n\t\tthis.res.end(U.httpStatus(status));\n\t\tF.$events['request-end'] && EMIT('request-end', this, this.res);\n\t\tthis.clear(true);\n\t};\n\n\tPROTO.$total_end = function() {\n\t\tvar h = this.method[0];\n\t\tif (h === 'G' || h === 'H' || h === 'O') {\n\t\t\tif (this.$total_route && this.$total_route.schema)\n\t\t\t\tthis.$total_schema = true;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t} else\n\t\t\tthis.on('end', this.$total_end2);\n\t};\n\n\tPROTO.$total_execute = function(status, isError) {\n\n\t\tvar route = this.$total_route;\n\t\tvar res = this.res;\n\n\t\tif (isError || !route) {\n\t\t\tF.stats.response['error' + status]++;\n\t\t\tstatus !== 500 && F.$events['error'] && EMIT('error' + status, this, res, this.$total_exception);\n\t\t}\n\n\t\tif (!route) {\n\t\t\tif (status === 400 && this.$total_exception instanceof framework_builders.ErrorBuilder) {\n\t\t\t\tF.stats.response.errorBuilder++;\n\t\t\t\tthis.$language && this.$total_exception.setResource(this.$language);\n\t\t\t\tres.options.body = this.$total_exception.output(true);\n\t\t\t\tres.options.code = this.$total_exception.status;\n\t\t\t\tres.options.type = this.$total_exception.contentType;\n\t\t\t\tres.$text();\n\t\t\t} else {\n\n\t\t\t\tMODELERROR.code = status;\n\t\t\t\tMODELERROR.status = U.httpStatus(status, false);\n\t\t\t\tMODELERROR.error = this.$total_exception ? prepare_error(this.$total_exception) : null;\n\n\t\t\t\tres.options.body = F.view('.' + PATHMODULES + 'error', MODELERROR);\n\t\t\t\tres.options.type = CT_HTML;\n\t\t\t\tres.options.code = status || 404;\n\t\t\t\tres.$text();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar name = route.controller;\n\n\t\tif (route.isMOBILE_VARY)\n\t\t\tthis.$mobile = true;\n\n\t\tif (route.currentViewDirectory === undefined)\n\t\t\troute.currentViewDirectory = name && name[0] !== '#' && name !== 'default' && name !== 'unknown' ? '/' + name + '/' : '';\n\n\t\tvar controller = new Controller(name, this, res, route.currentViewDirectory);\n\n\t\tcontroller.isTransfer = this.$total_transfer;\n\t\tcontroller.exception = this.$total_exception;\n\t\tthis.controller = controller;\n\n\t\tif (!this.$total_canceled && route.timeout) {\n\t\t\tthis.$total_timeout && clearTimeout(this.$total_timeout);\n\t\t\tthis.$total_timeout = setTimeout(subscribe_timeout, route.timeout, this);\n\t\t}\n\n\t\troute.isDELAY && res.writeContinue();\n\n\t\tif (this.$total_schema)\n\t\t\tthis.body.$$controller = controller;\n\n\t\tif (route.middleware)\n\t\t\tasync_middleware(0, this, res, route.middleware, subscribe_timeout_middleware, route.options, controller);\n\t\telse\n\t\t\tthis.$total_execute2();\n\t};\n\n\tPROTO.$total_execute2 = function() {\n\n\t\tvar name = this.$total_route.controller;\n\t\tvar controller = this.controller;\n\n\t\ttry {\n\n\t\t\tif (F.onTheme)\n\t\t\t\tcontroller.themeName = F.onTheme(controller);\n\n\t\t\tif (controller.isCanceled)\n\t\t\t\treturn;\n\n\t\t\tvar ctrlname = '@' + name;\n\t\t\tF.$events.controller && EMIT('controller', controller, name, this.$total_route.options);\n\t\t\tF.$events[ctrlname] && EMIT(ctrlname, controller, name, this.$total_route.options);\n\n\t\t\tif (controller.isCanceled)\n\t\t\t\treturn;\n\n\t\t\tif (this.$total_route.isCACHE && !F.temporary.other[this.uri.pathname])\n\t\t\t\tF.temporary.other[this.uri.pathname] = this.path;\n\n\t\t\tif (this.$total_route.isGENERATOR)\n\t\t\t\tasync.call(controller, this.$total_route.execute, true)(controller, framework_internal.routeParam(this.$total_route.param.length ? this.split : this.path, this.$total_route));\n\t\t\telse {\n\t\t\t\tif (this.$total_route.param.length)\n\t\t\t\t\tthis.$total_route.execute.apply(controller, framework_internal.routeParam(this.split, this.$total_route));\n\t\t\t\telse\n\t\t\t\t\tthis.$total_route.execute.call(controller);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tF.error(err, name, this.uri);\n\t\t\tthis.$total_exception = err;\n\t\t\tthis.$total_route = F.lookup(this, '#500', EMPTYARRAY, 0);\n\t\t\tthis.$total_execute(500, true);\n\t\t}\n\t};\n\n\tPROTO.$total_parsebody = function(chunk) {\n\n\t\tif (this.buffer_exceeded)\n\t\t\treturn;\n\n\t\tif (!this.buffer_exceeded) {\n\t\t\tCONCAT[0] = this.buffer_data;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tthis.buffer_data = Buffer.concat(CONCAT);\n\t\t}\n\n\t\tif ((this.buffer_data.length / 1024) < this.$total_route.length)\n\t\t\treturn;\n\n\t\tthis.buffer_exceeded = true;\n\t\tthis.buffer_data = U.createBuffer();\n\t};\n\n\tPROTO.$total_cancel = function() {\n\t\tF.stats.response.timeout++;\n\t\tclearTimeout(this.$total_timeout);\n\t\tif (!this.controller)\n\t\t\treturn;\n\t\tthis.controller.isTimeout = true;\n\t\tthis.controller.isCanceled = true;\n\t\tthis.$total_route = F.lookup(this, '#408', EMPTYARRAY, 0);\n\t\tthis.$total_execute(408, true);\n\t};\n\n\tPROTO.$total_validate = function(route, next, code) {\n\n\t\tvar self = this;\n\t\tself.$total_schema = false;\n\n\t\tif (!self.$total_route.schema || self.method === 'DELETE')\n\t\t\treturn next(self, code);\n\n\t\tif (!self.$total_route.schema[1]) {\n\t\t\tF.stats.request.operation++;\n\t\t\treturn next(self, code);\n\t\t}\n\n\t\tF.onSchema(self, self.$total_route, function(err, body) {\n\t\t\tif (err) {\n\t\t\t\tif (self.$total_route.isDYNAMICSCHEMA)\n\t\t\t\t\tself.$total_404(err);\n\t\t\t\telse\n\t\t\t\t\tself.$total_400(err);\n\t\t\t\tnext = null;\n\t\t\t} else {\n\t\t\t\tF.stats.request.schema++;\n\t\t\t\tself.body = body;\n\t\t\t\tself.$total_schema = true;\n\t\t\t\tnext(self, code);\n\t\t\t}\n\t\t});\n\t};\n\n\tPROTO.$total_authorize = function(isLogged, user, roles) {\n\n\t\tvar membertype = isLogged ? 1 : 2;\n\t\tvar code = this.buffer_exceeded ? 431 : 401;\n\n\t\tthis.$flags += membertype;\n\t\tuser && (this.user = user);\n\n\t\tif (this.$total_route && this.$total_route.isUNIQUE && !roles && (!this.$total_route.MEMBER || this.$total_route.MEMBER === membertype)) {\n\t\t\tif (code === 401 && this.$total_schema)\n\t\t\t\tthis.$total_validate(this.$total_route, subscribe_validate_callback, code);\n\t\t\telse\n\t\t\t\tthis.$total_execute(code, true);\n\t\t} else {\n\t\t\tvar route = F.lookup(this, this.buffer_exceeded ? '#431' : this.uri.pathname, this.flags, this.buffer_exceeded ? 0 : membertype);\n\t\t\tvar status = this.$isAuthorized ? 404 : 401;\n\t\t\tvar code = this.buffer_exceeded ? 431 : status;\n\t\t\t!route && (route = F.lookup(this, '#' + status, EMPTYARRAY, 0));\n\n\t\t\tthis.$total_route = route;\n\n\t\t\tif (this.$total_route && this.$total_schema)\n\t\t\t\tthis.$total_validate(this.$total_route, subscribe_validate_callback, code);\n\t\t\telse\n\t\t\t\tthis.$total_execute(code);\n\t\t}\n\t};\n\n\tPROTO.$total_end2 = function() {\n\n\t\tvar route = this.$total_route;\n\n\t\tif (this.buffer_exceeded) {\n\t\t\troute = F.lookup(this, '#431', EMPTYARRAY, 0);\n\t\t\tthis.buffer_data = null;\n\t\t\tif (route) {\n\t\t\t\tthis.$total_route = route;\n\t\t\t\tthis.$total_execute(431, true);\n\t\t\t} else\n\t\t\t\tthis.res.throw431();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.buffer_data && (!route || !route.isBINARY))\n\t\t\tthis.buffer_data = this.buffer_data.toString(ENCODING);\n\n\t\tif (!this.buffer_data) {\n\t\t\tif (route && route.schema)\n\t\t\t\tthis.$total_schema = true;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t\treturn;\n\t\t}\n\n\t\tif (route.isXML) {\n\n\t\t\tif (this.$type !== 2) {\n\t\t\t\tthis.$total_400('Invalid \"Content-Type\".');\n\t\t\t\tthis.buffer_data = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tF.$onParseXML(this);\n\t\t\t\tthis.buffer_data = null;\n\t\t\t\tthis.$total_prepare();\n\t\t\t} catch (err) {\n\t\t\t\tF.error(err, null, this.uri);\n\t\t\t\tthis.$total_500(err);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (route.isRAW) {\n\t\t\tthis.body = this.buffer_data;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.$type) {\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_400('Invalid \"Content-Type\".');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.$type === 1) {\n\t\t\ttry {\n\t\t\t\tF.$onParseJSON(this);\n\t\t\t\tthis.buffer_data = null;\n\t\t\t} catch (e) {\n\t\t\t\tthis.$total_400('Invalid JSON data.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tF.$onParseQueryBody(this);\n\n\t\troute.schema && (this.$total_schema = true);\n\t\tthis.buffer_data = null;\n\t\tthis.$total_prepare();\n\t};\n\n\tPROTO.$total_endfile = function() {\n\n\t\tvar req = this;\n\t\tvar res = this.res;\n\n\t\tif (!F._length_files)\n\t\t\treturn res.continue();\n\n\t\tfor (var i = 0; i < F._length_files; i++) {\n\n\t\t\tvar file = F.routes.files[i];\n\t\t\t// try {\n\n\t\t\tif (file.extensions && !file.extensions[req.extension])\n\t\t\t\tcontinue;\n\n\t\t\tif (file.url) {\n\t\t\t\tvar skip = false;\n\t\t\t\tvar length = file.url.length;\n\n\t\t\t\tif (!file.wildcard && !file.fixedfile && length !== req.path.length - 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tif (file.url[j] === req.path[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t} else if (file.onValidate && !file.onValidate(req, res, true))\n\t\t\t\tcontinue;\n\n\t\t\tif (file.middleware)\n\t\t\t\treq.$total_endfilemiddleware(file);\n\t\t\telse\n\t\t\t\tfile.execute(req, res, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tres.continue();\n\t};\n\n\tPROTO.$total_endfilemiddleware = function(file) {\n\t\tthis.$total_filemiddleware = file;\n\t\tasync_middleware(0, this, this.res, file.middleware, total_endmiddleware, file.options);\n\t};\n\n\tPROTO.$total_400 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#400', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(400, true);\n\t};\n\n\tPROTO.$total_404 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#404', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(404, true);\n\t};\n\n\tPROTO.$total_500 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#500', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(500, true);\n\t};\n\n\tPROTO.$total_prepare = function() {\n\t\tvar req = this;\n\t\tvar length = req.flags.length;\n\t\tif (F.onAuthorize) {\n\t\t\tF.onAuthorize(req, req.res, req.flags, function(isAuthorized, user) {\n\t\t\t\tvar hasRoles = length !== req.flags.length;\n\n\t\t\t\tif (hasRoles) {\n\t\t\t\t\treq.$flags += req.flags.slice(length).join('');\n\t\t\t\t\treq.$roles = true;\n\t\t\t\t}\n\n\t\t\t\tif (typeof(isAuthorized) !== 'boolean') {\n\t\t\t\t\tuser = isAuthorized;\n\t\t\t\t\tisAuthorized = !user;\n\t\t\t\t}\n\t\t\t\treq.isAuthorized = isAuthorized;\n\t\t\t\treq.$total_authorize(isAuthorized, user, hasRoles);\n\t\t\t});\n\t\t} else {\n\t\t\tif (!req.$total_route)\n\t\t\t\treq.$total_route = F.lookup(req, req.buffer_exceeded ? '#431' : req.uri.pathname, req.flags, 0);\n\t\t\tif (!req.$total_route)\n\t\t\t\treq.$total_route = F.lookup(req, '#404', EMPTYARRAY, 0);\n\t\t\tvar code = req.buffer_exceeded ? 431 : 404;\n\t\t\tif (!req.$total_schema || !req.$total_route)\n\t\t\t\treq.$total_execute(code);\n\t\t\telse\n\t\t\t\treq.$total_validate(req.$total_route, subscribe_validate_callback, code);\n\t\t}\n\t};\n}\n\nfunction total_endmiddleware(req) {\n\n\tif (req.total_middleware)\n\t\treq.total_middleware = null;\n\n\ttry {\n\t\treq.$total_filemiddleware.execute(req, req.res, false);\n\t} catch (err) {\n\t\tF.error(err, req.$total_filemiddleware.controller + ' :: ' + req.$total_filemiddleware.name, req.uri);\n\t\treq.res.throw500();\n\t}\n}\n\nfunction extend_response(PROTO) {\n\n\tPROTORES = PROTO;\n\n\t/**\n\t * Add a cookie into the response\n\t * @param {String} name\n\t * @param {Object} value\n\t * @param {Date/String} expires\n\t * @param {Object} options Additional options.\n\t * @return {Response}\n\t */\n\tPROTO.cookie = function(name, value, expires, options) {\n\n\t\tvar self = this;\n\n\t\tif (self.headersSent || self.success)\n\t\t\treturn;\n\n\t\tvar cookiename = name + '=';\n\t\tvar builder = [cookiename + value];\n\t\tvar type = typeof(expires);\n\n\t\tif (expires && !U.isDate(expires) && type === 'object') {\n\t\t\toptions = expires;\n\t\t\texpires = options.expires || options.expire || null;\n\t\t}\n\n\t\tif (type === 'string')\n\t\t\texpires = expires.parseDateExpiration();\n\n\t\tif (!options)\n\t\t\toptions = {};\n\n\t\toptions.path = options.path || '/';\n\t\texpires && builder.push('Expires=' + expires.toUTCString());\n\t\toptions.domain && builder.push('Domain=' + options.domain);\n\t\toptions.path && builder.push('Path=' + options.path);\n\t\toptions.secure && builder.push('Secure');\n\n\t\tif (options.httpOnly || options.httponly || options.HttpOnly)\n\t\t\tbuilder.push('HttpOnly');\n\n\t\tvar same = options.security || options.samesite || options.sameSite;\n\t\tif (same) {\n\t\t\tswitch (same) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsame = 'lax';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsame = 'strict';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuilder.push('SameSite=' + same);\n\t\t}\n\n\t\tvar arr = self.getHeader('set-cookie') || [];\n\n\t\t// Cookie, already, can be in array, resulting in duplicate 'set-cookie' header\n\t\tif (arr.length) {\n\t\t\tvar l = cookiename.length;\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tif (arr[i].substring(0, l) === cookiename) {\n\t\t\t\t\tarr.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tarr.push(builder.join('; '));\n\t\tself.setHeader('Set-Cookie', arr);\n\t\treturn self;\n\t};\n\n\t/**\n\t * Disable HTTP cache for current response\n\t * @return {Response}\n\t */\n\tPROTO.noCache = function() {\n\t\tvar self = this;\n\n\t\tif (self.$nocache)\n\t\t\treturn self;\n\n\t\tif (self.req) {\n\t\t\tdelete self.req.headers['if-none-match'];\n\t\t\tdelete self.req.headers['if-modified-since'];\n\t\t}\n\n\t\tif (self.getHeader(HEADER_CACHE)) {\n\t\t\tself.removeHeader(HEADER_CACHE);\n\t\t\tself.removeHeader('Expires');\n\t\t\tself.removeHeader('Etag');\n\t\t\tself.removeHeader('Last-Modified');\n\t\t\tself.setHeader(HEADER_CACHE, 'private, no-cache, no-store, max-age=0');\n\t\t\tself.setHeader('Expires', -1);\n\t\t}\n\n\t\tself.$nocache = true;\n\t\treturn self;\n\t};\n\n\t// For express middleware\n\tPROTO.status = function(code) {\n\t\tthis.options.code = code;\n\t\treturn this;\n\t};\n\n\t// For express middleware\n\tPROTO.send = function(code, body, type) {\n\n\t\tif (this.headersSent)\n\t\t\treturn this;\n\n\t\tthis.controller && this.req.$total_success();\n\n\t\tif (code instanceof Buffer) {\n\t\t\t// express.js static file\n\t\t\tif (!body && !type) {\n\t\t\t\tthis.end(code);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\tvar res = this;\n\t\tvar req = this.req;\n\t\tvar contentType = type;\n\t\tvar isHEAD = req.method === 'HEAD';\n\n\t\tif (body === undefined) {\n\t\t\tbody = code;\n\t\t\tcode = res.$statuscode || 200;\n\t\t}\n\n\t\tswitch (typeof(body)) {\n\t\t\tcase 'string':\n\t\t\t\tif (!contentType)\n\t\t\t\t\tcontentType = 'text/html';\n\t\t\t\tbreak;\n\n\t\t\tcase 'number':\n\t\t\t\tif (!contentType)\n\t\t\t\t\tcontentType = 'text/plain';\n\t\t\t\tbody = U.httpStatus(body);\n\t\t\t\tbreak;\n\n\t\t\tcase 'boolean':\n\t\t\tcase 'object':\n\t\t\t\tif (!isHEAD) {\n\t\t\t\t\tif (body instanceof framework_builders.ErrorBuilder) {\n\t\t\t\t\t\tvar json = body.output(true);\n\t\t\t\t\t\tif (body.status !== 200)\n\t\t\t\t\t\t\tres.options.code = body.status;\n\t\t\t\t\t\tif (body.contentType)\n\t\t\t\t\t\t\tcontentType = body.contentType;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontentType = CT_JSON;\n\t\t\t\t\t\tbody = json;\n\t\t\t\t\t\tF.stats.response.errorBuilder++;\n\t\t\t\t\t} else\n\t\t\t\t\t\tbody = JSON.stringify(body);\n\t\t\t\t\t!contentType && (contentType = CT_JSON);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\tvar headers = {};\n\n\t\theaders[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\n\t\theaders['Vary'] = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif ((/text|application/).test(contentType))\n\t\t\tcontentType += '; charset=utf-8';\n\n\t\theaders[HEADER_TYPE] = contentType;\n\t\tres.$custom();\n\n\t\tif (!accept && isGZIP(req))\n\t\t\taccept = 'gzip';\n\n\t\tvar compress = CONF.allow_gzip && accept.indexOf('gzip') !== -1;\n\t\tif (isHEAD) {\n\t\t\tcompress && (headers['Content-Encoding'] = 'gzip');\n\t\t\tres.writeHead(200, headers);\n\t\t\tres.end();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!compress) {\n\t\t\tres.writeHead(code, headers);\n\t\t\tres.end(body, ENCODING);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar buffer = U.createBuffer(body);\n\t\tZlib.gzip(buffer, function(err, data) {\n\n\t\t\tif (err) {\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.end(body, ENCODING);\n\t\t\t} else {\n\t\t\t\theaders['Content-Encoding'] = 'gzip';\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.end(data, ENCODING);\n\t\t\t}\n\t\t});\n\n\t\treturn res;\n\t};\n\n\t/**\n\t * Response a custom content\n\t * @param {Number} code\n\t * @param {String} body\n\t * @param {String} type\n\t * @param {Boolean} compress Disallows GZIP compression. Optional, default: true.\n\t * @param {Object} headers Optional, additional headers.\n\t * @return {Response}\n\t */\n\tPROTO.content = function(code, body, type, compress, headers) {\n\n\t\tif (typeof(compress) === 'object') {\n\t\t\tvar tmp = headers;\n\t\t\theaders = compress;\n\t\t\tcompress = tmp;\n\t\t}\n\n\t\tvar res = this;\n\t\tres.options.code = code;\n\t\tres.options.compress = compress === undefined || compress === true;\n\t\tres.options.body = body;\n\t\tres.options.type = type;\n\t\theaders && (res.options.headers = headers);\n\t\tres.$text();\n\t\treturn res;\n\t};\n\n\t/**\n\t * Response redirect\n\t * @param {String} url\n\t * @param {Boolean} permanent Optional, default: false.\n\t * @return {Framework}\n\t */\n\tPROTO.redirect = function(url, permanent) {\n\t\tthis.options.url = url;\n\t\tpermanent && (this.options.permanent = permanent);\n\t\tthis.$redirect();\n\t\treturn this;\n\t};\n\n\t/**\n\t * Responds with a file\n\t * @param {String} filename\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.file = function(filename, download, headers, callback) {\n\t\tthis.options.filename = filename;\n\t\theaders && (this.options.headers = headers);\n\t\tcallback && (this.options.callback = callback);\n\t\tdownload && (this.options.download = download);\n\t\treturn this.$file();\n\t};\n\n\t/**\n\t * Responds with a file from FileStorage\n\t * @param {String} name A name of FileStorage\n\t * @param {String/Number} id\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.filefs = function(name, id, download, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.download = download;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tFILESTORAGE(name).res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.filenosql = function(name, id, download, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.download = download;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tNOSQL(name).binary.res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.imagefs = function(name, id, make, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.image = true;\n\t\toptions.make = make;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tFILESTORAGE(name).res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.imagenosql = function(name, id, make, headers, callback) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.image = true;\n\t\toptions.make = make;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tNOSQL(name).binary.res(self, options, $file_notmodified);\n\t\treturn self;\n\t};\n\n\t/**\n\t * Responds with a stream\n\t * @param {String} contentType\n\t * @param {Stream} stream\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.stream = function(type, stream, download, headers, callback, nocompress) {\n\t\tvar res = this;\n\t\tres.options.type = type;\n\t\tres.options.stream = stream;\n\t\tdownload && (res.options.download = download);\n\t\theaders && (res.options.headers = headers);\n\t\tcallback && (res.options.callback = callback);\n\t\tres.options.compress = nocompress ? false : true;\n\t\tres.$stream();\n\t\treturn res;\n\t};\n\n\tPROTO.binary = function(body, type, encoding, download, headers) {\n\n\t\tif (typeof(encoding) === 'object') {\n\t\t\tvar tmp = encoding;\n\t\t\tencoding = download;\n\t\t\tdownload = headers;\n\t\t\theaders = tmp;\n\t\t}\n\n\t\tif (typeof(download) === 'object') {\n\t\t\theaders = download;\n\t\t\tdownload = headers;\n\t\t}\n\n\t\tthis.options.type = type;\n\t\tthis.options.body = body;\n\t\tthis.options.encoding = encoding;\n\t\tdownload && (this.options.download = download);\n\t\theaders && (this.options.headers = headers);\n\t\tthis.$binary();\n\t\treturn this;\n\t};\n\n\tPROTO.proxy = function(url, headers, timeout, callback) {\n\n\t\tOBSOLETE('res.proxy()', 'You need to use controller.proxy()');\n\n\t\tvar res = this;\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tcallback && (res.options.callback = callback);\n\t\theaders && (res.options.headers = headers);\n\t\ttimeout && (res.options.timeout = timeout);\n\n\t\tU.resolve(url, function(err, uri) {\n\n\t\t\tvar headers = {};\n\n\t\t\theaders[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\n\t\t\tres.options.headers && U.extend_headers2(headers, res.options.headers);\n\n\t\t\tvar options = { protocol: uri.protocol, auth: uri.auth, method: 'GET', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: headers };\n\t\t\tvar connection = options.protocol === 'https:' ? require('https') : http;\n\t\t\tvar gzip = CONF.allow_gzip && (res.req.headers['accept-encoding'] || '').lastIndexOf('gzip') !== -1;\n\n\t\t\tvar client = connection.get(options, function(response) {\n\n\t\t\t\tif (res.success || res.headersSent)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar contentType = response.headers['content-type'];\n\t\t\t\tvar isGZIP = (response.headers['content-encoding'] || '').lastIndexOf('gzip') !== -1;\n\t\t\t\tvar compress = !isGZIP && gzip && (contentType.indexOf('text/') !== -1 || contentType.lastIndexOf('javascript') !== -1 || contentType.lastIndexOf('json') !== -1);\n\t\t\t\tvar attachment = response.headers['content-disposition'] || '';\n\n\t\t\t\tattachment && res.setHeader('Content-Disposition', attachment);\n\t\t\t\tres.setHeader(HEADER_TYPE, contentType);\n\t\t\t\tres.setHeader('Vary', 'Accept-Encoding' + (res.req.$mobile ? ', User-Agent' : ''));\n\n\t\t\t\tres.on('error', function() {\n\t\t\t\t\tresponse.close();\n\t\t\t\t\tresponse_end(res);\n\t\t\t\t});\n\n\t\t\t\tif (compress) {\n\t\t\t\t\tres.setHeader('Content-Encoding', 'gzip');\n\t\t\t\t\tresponse.pipe(Zlib.createGzip(GZIPSTREAM)).pipe(res);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isGZIP && !gzip)\n\t\t\t\t\tresponse.pipe(Zlib.createGunzip()).pipe(res);\n\t\t\t\telse\n\t\t\t\t\tresponse.pipe(res);\n\t\t\t});\n\n\t\t\ttimeout && client.setTimeout(timeout, function() {\n\t\t\t\tres.throw408();\n\t\t\t});\n\n\t\t\tclient.on('close', function() {\n\t\t\t\tif (!res.success) {\n\t\t\t\t\tF.stats.response.pipe++;\n\t\t\t\t\tresponse_end(res);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn res;\n\t};\n\n\t/**\n\t * Responds with an image\n\t * @param {String or Stream} filename\n\t * @param {String} make\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} callback Optional.\n\t * @return {Framework}\n\t */\n\tPROTO.image = function(filename, make, headers, callback) {\n\n\t\tvar res = this;\n\n\t\tres.options.make = make;\n\n\t\theaders && (res.options.headers = headers);\n\t\tcallback && (res.options.callback = callback);\n\n\t\tif (typeof(filename) === 'object')\n\t\t\tres.options.stream = filename;\n\t\telse\n\t\t\tres.options.filename = filename;\n\n\t\tres.$image();\n\t\treturn res;\n\t};\n\n\tPROTO.image_nocache = function(filename, make, headers, callback) {\n\t\tthis.options.cache = false;\n\t\treturn this.image(filename, make, headers, callback);\n\t};\n\n\t/**\n\t * Response JSON\n\t * @param {Object} obj\n\t * @return {Response}\n\t */\n\tPROTO.json = function(obj) {\n\t\tvar res = this;\n\t\tF.stats.response.json++;\n\t\tif (framework_builders.isSchema(obj))\n\t\t\tobj = obj.$clean();\n\t\tres.options.body = JSON.stringify(obj);\n\t\tres.options.type = CT_JSON;\n\t\treturn res.$text();\n\t};\n\n\tconst SECURITYTXT = { '/security.txt': 1, '/.well-known/security.txt': 1 };\n\n\tPROTO.continue = function(callback) {\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\n\t\tcallback && (res.options.callback = callback);\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tif (!CONF.static_accepts[req.extension]) {\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (SECURITYTXT[req.url] && CONF['security.txt']) {\n\t\t\tres.send(200, CONF['security.txt'], 'text/plain');\n\t\t\treturn;\n\t\t}\n\n\t\treq.$key = createTemporaryKey(req);\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar canresize = false;\n\t\tvar filename = null;\n\t\tvar name = req.uri.pathname;\n\n\t\tif (IMAGES[req.extension]) {\n\t\t\tvar index = name.lastIndexOf('/');\n\t\t\tvar resizer = F.routes.resize[name.substring(0, index + 1)];\n\t\t\tif (resizer) {\n\t\t\t\tname = name.substring(index + 1);\n\t\t\t\tcanresize = resizer.extension['*'] || resizer.extension[req.extension];\n\t\t\t\tif (canresize) {\n\t\t\t\t\tname = resizer.path + $decodeURIComponent(name);\n\t\t\t\t\tfilename = F.onMapping(name, name, false, false);\n\t\t\t\t} else\n\t\t\t\t\tfilename = F.onMapping(name, name, true, true);\n\t\t\t} else\n\t\t\t\tfilename = F.onMapping(name, name, true, true);\n\t\t} else\n\t\t\tfilename = F.onMapping(name, name, true, true);\n\n\t\tif (!filename) {\n\t\t\tres.throw404();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!canresize) {\n\n\t\t\tif (F.components.has && F.components[req.extension] && req.uri.pathname === CONF.static_url_components + req.extension) {\n\t\t\t\tres.noCompress = true;\n\t\t\t\tres.options.components = true;\n\t\t\t\tvar g = req.query.group ? req.query.group.substring(0, req.query.group.length - 6) : '';\n\t\t\t\tfilename = F.path.temp('components' + (g ? '_g' + g : '') + '.' + req.extension);\n\t\t\t\tif (g)\n\t\t\t\t\treq.$key = 'components_' + g + '.' + req.extension;\n\t\t\t\telse\n\t\t\t\t\treq.$key = 'components.' + req.extension;\n\t\t\t}\n\n\t\t\tres.options.filename = filename;\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!resizer.ishttp) {\n\t\t\tres.options.cache = resizer.cache;\n\t\t\tres.options.make = resizer.fn;\n\t\t\tres.options.filename = filename;\n\t\t\tres.$image();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (F.temporary.processing[req.uri.pathname]) {\n\t\t\tsetTimeout($continue_timeout, 500, res);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar tmp = F.path.temp(req.$key);\n\t\tif (F.temporary.path[req.$key]) {\n\t\t\tres.options.filename = req.uri.pathname;\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tF.temporary.processing[req.uri.pathname] = true;\n\n\t\tU.download(name, FLAGS_DOWNLOAD, function(err, response) {\n\t\t\tvar writer = Fs.createWriteStream(tmp);\n\t\t\tresponse.pipe(writer);\n\t\t\tCLEANUP(writer, function() {\n\n\t\t\t\tdelete F.temporary.processing[req.uri.pathname];\n\t\t\t\tvar contentType = response.headers['content-type'];\n\n\t\t\t\tif (response.statusCode !== 200 || !contentType || !contentType.startsWith('image/')) {\n\t\t\t\t\tres.throw404();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tres.options.cache = resizer.cache;\n\t\t\t\tres.options.filename = tmp;\n\t\t\t\tres.options.maker = resizer.fn;\n\t\t\t\tres.$image();\n\t\t\t});\n\t\t});\n\n\t\treturn res;\n\t};\n\n\tPROTO.$file = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.code\n\t\t// res.options.callback\n\t\t// res.options.headers\n\t\t// res.options.download\n\n\t\tvar res = this;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = this.req;\n\n\t\t!req.$key && (req.$key = createTemporaryKey(req));\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\t// Is package?\n\t\tif (options.filename && options.filename[0] === '@')\n\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\tvar name = F.temporary.path[req.$key];\n\t\tvar index;\n\n\t\tif (!req.extension) {\n\t\t\treq.$key && (req.extension = U.getExtension(req.$key));\n\t\t\tif (!req.extension && name) {\n\t\t\t\treq.extension = U.getExtension(name);\n\t\t\t\tindex = req.extension.lastIndexOf(';');\n\t\t\t\tindex !== -1 && (req.extension = req.extension.substring(0, index));\n\t\t\t}\n\t\t\t!req.extension && options.filename && (req.extension = U.getExtension(options.filename));\n\t\t}\n\n\t\tif (name && RELEASE && !res.$nocache && req.headers['if-modified-since'] === name[2]) {\n\t\t\t$file_notmodified(res, name);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (name === undefined) {\n\n\t\t\tif (F.temporary.processing[req.$key]) {\n\t\t\t\tif (req.processing > CONF.default_request_timeout) {\n\t\t\t\t\tres.throw408();\n\t\t\t\t} else {\n\t\t\t\t\treq.processing += 500;\n\t\t\t\t\tsetTimeout($file_processing, 500, res);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\t// waiting\n\t\t\tF.temporary.processing[req.$key] = true;\n\t\t\tcompile_check(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar contentType = U.getContentType(req.extension);\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\tvar headers;\n\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = CONF.allow_gzip && COMPRESSION[contentType] && accept.indexOf('gzip') !== -1 && name.length > 2;\n\t\tvar range = req.headers.range;\n\t\tvar canCache = !res.$nocache && RELEASE && contentType !== 'text/cache-manifest';\n\n\t\tif (canCache) {\n\t\t\tif (compress)\n\t\t\t\theaders = range ? HEADERS.file_release_compress_range : HEADERS.file_release_compress;\n\t\t\telse\n\t\t\t\theaders = range ? HEADERS.file_release_range : HEADERS.file_release;\n\t\t} else {\n\t\t\tif (compress)\n\t\t\t\theaders = range ? HEADERS.file_debug_compress_range : HEADERS.file_debug_compress;\n\t\t\telse\n\t\t\t\theaders = range ? HEADERS.file_debug_range : HEADERS.file_debug;\n\t\t}\n\n\t\tif (req.$mobile)\n\t\t\theaders.Vary = 'Accept-Encoding, User-Agent';\n\t\telse\n\t\t\theaders.Vary = 'Accept-Encoding';\n\n\t\theaders[HEADER_TYPE] = contentType;\n\t\tif (REG_TEXTAPPLICATION.test(contentType))\n\t\t\theaders[HEADER_TYPE] += '; charset=utf-8';\n\n\t\tif (canCache && !res.getHeader('Expires')) {\n\t\t\theaders.Expires = DATE_EXPIRES;\n\t\t} else if (headers.Expires && RELEASE)\n\t\t\tdelete headers.Expires;\n\n\t\tif (res.options.headers)\n\t\t\theaders = U.extend_headers(headers, res.options.headers);\n\n\t\tif (res.options.download) {\n\t\t\tvar encoded = encodeURIComponent(res.options.download);\n\t\t\theaders['Content-Disposition'] = 'attachment; ' + (REG_UTF8.test(res.options.download) ? 'filename*=utf-8\\'\\'' + encoded : ('filename=\"' + encoded + '\"'));\n\t\t} else if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\tif (res.getHeader('Last-Modified'))\n\t\t\tdelete headers['Last-Modified'];\n\t\telse if (!res.options.lastmodified)\n\t\t\theaders['Last-Modified'] = name[2];\n\n\t\theaders.Etag = ETAG + CONF.etag_version;\n\n\t\tif (range) {\n\t\t\t$file_range(name[0], range, headers, res);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!res.options.components && (DEBUG || res.$nocache))\n\t\t\tF.isProcessed(req.$key) && (F.temporary.path[req.$key] = undefined);\n\n\t\tif (name[1] && !compress)\n\t\t\theaders[HEADER_LENGTH] = name[1];\n\t\telse if (compress && name[4])\n\t\t\theaders[HEADER_LENGTH] = name[4];\n\t\telse if (headers[HEADER_LENGTH])\n\t\t\tdelete headers[HEADER_LENGTH];\n\n\t\tF.stats.response.file++;\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t} else if (compress) {\n\n\t\t\tif (name[4])\n\t\t\t\theaders[HEADER_LENGTH] = name[4];\n\t\t\telse\n\t\t\t\tdelete headers[HEADER_LENGTH];\n\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tfsStreamRead(name[3], undefined, $file_nocompress, res);\n\t\t} else {\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tfsStreamRead(name[0], undefined, $file_nocompress, res);\n\t\t}\n\t};\n\n\tPROTO.$redirect = function() {\n\n\t\t// res.options.permanent\n\t\t// res.options.url\n\n\t\tvar res = this;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tHEADERS.redirect.Location = res.options.url;\n\t\tres.writeHead(res.options.permanent ? 301 : 302, HEADERS.redirect);\n\t\tres.end();\n\t\tresponse_end(res);\n\t\tF.stats.response.redirect++;\n\t\treturn res;\n\t};\n\n\tPROTO.$binary = function() {\n\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.encoding\n\t\t// res.options.download\n\t\t// res.options.type\n\t\t// res.options.body\n\t\t// res.options.headers\n\n\t\tvar res = this;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\t/*\n\t\tif (options.type.lastIndexOf('/') === -1)\n\t\t\toptions.type = U.getContentType(options.type);\n\t\t*/\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = CONF.allow_gzip && COMPRESSION[options.type] && accept.indexOf('gzip') !== -1;\n\t\tvar headers = compress ? HEADERS.binary_compress : HEADERS.binary;\n\n\t\theaders['Vary'] = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif (options.download)\n\t\t\theaders['Content-Disposition'] = 'attachment; filename=' + encodeURIComponent(options.download);\n\t\telse if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tF.stats.response.binary++;\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t} else if (compress) {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tZlib.gzip(!options.encoding || options.encoding === 'binary' ? options.body : options.body.toString(options.encoding), (err, buffer) => res.end(buffer));\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end(!options.encoding || options.encoding === 'binary' ? options.body : options.body.toString(options.encoding));\n\t\t\tresponse_end(res);\n\t\t}\n\n\t\treturn res;\n\t};\n\n\tPROTO.$stream = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.options\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.stream\n\t\t// res.options.type\n\t\t// res.options.compress\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\t/*\n\t\tif (options.type.lastIndexOf('/') === -1)\n\t\t\toptions.type = U.getContentType(options.type);\n\t\t*/\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = (options.compress === undefined || options.compress) && CONF.allow_gzip && COMPRESSION[options.type] && accept.indexOf('gzip') !== -1;\n\t\tvar headers;\n\n\t\tif (RELEASE) {\n\t\t\tif (compress)\n\t\t\t\theaders = HEADERS.stream_release_compress;\n\t\t\telse\n\t\t\t\theaders = HEADERS.stream_release;\n\t\t} else {\n\t\t\tif (compress)\n\t\t\t\theaders = HEADERS.stream_debug_compress;\n\t\t\telse\n\t\t\t\theaders = HEADERS.stream_debug;\n\t\t}\n\n\t\theaders.Vary = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif (RELEASE) {\n\t\t\theaders.Expires = DATE_EXPIRES;\n\t\t\theaders['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\n\t\t}\n\n\t\tif (options.download)\n\t\t\theaders['Content-Disposition'] = 'attachment; filename=' + encodeURIComponent(options.download);\n\t\telse if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tF.stats.response.stream++;\n\t\tF.reqstats(false, req.isStaticFile);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (compress) {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.on('error', () => options.stream.close());\n\t\t\toptions.stream.pipe(Zlib.createGzip(GZIPSTREAM)).pipe(res);\n\t\t\tframework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\t\tresponse_end(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tres.writeHead(options.code || 200, headers);\n\t\tframework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\toptions.stream.pipe(res);\n\t\tresponse_end(res);\n\t\treturn res;\n\t};\n\n\tPROTO.$image = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.stream\n\t\t// res.options.options\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.cache\n\t\t// res.options.headers\n\t\t// res.options.make = function(image, res)\n\n\t\tvar res = this;\n\t\tvar options = res.options;\n\n\t\tif (options.cache === false)\n\t\t\treturn $image_nocache(res);\n\n\t\tvar req = this.req;\n\t\t!req.$key && (req.$key = createTemporaryKey(req));\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar key = req.$key || createTemporaryKey(req);\n\t\tif (F.temporary.notfound[key]) {\n\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar name = F.temporary.path[key];\n\n\t\tif (options.filename && options.filename[0] === '@')\n\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\tif (name !== undefined) {\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (F.temporary.processing[req.$key]) {\n\t\t\tif (req.processing > CONF.default_request_timeout) {\n\t\t\t\tres.throw408();\n\t\t\t} else {\n\t\t\t\treq.processing += 500;\n\t\t\t\tsetTimeout($image_processing, 500, res);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\n\t\toptions.name = F.path.temp(plus + key);\n\t\tF.temporary.processing[key] = true;\n\n\t\tif (options.stream)\n\t\t\tfsFileExists(options.name, $image_stream, res);\n\t\telse\n\t\t\tfsFileExists(options.filename, $image_filename, res);\n\n\t\treturn res;\n\t};\n\n\tPROTO.$custom = function() {\n\t\tF.stats.response.custom++;\n\t\tresponse_end(this);\n\t\treturn this;\n\t};\n\n\tPROTO.$text = function() {\n\n\t\t// res.options.type\n\t\t// res.options.body\n\t\t// res.options.code\n\t\t// res.options.headers\n\t\t// res.options.callback\n\t\t// res.options.compress\n\t\t// res.options.encoding\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar gzip = CONF.allow_gzip && (options.compress === undefined || options.compress) ? accept.indexOf('gzip') !== -1 : false;\n\t\tvar headers;\n\n\t\tif (req.$mobile)\n\t\t\theaders = gzip ? HEADERS.content_mobile_release : HEADERS.content_mobile;\n\t\telse\n\t\t\theaders = gzip ? HEADERS.content_compress : HEADERS.content;\n\n\t\tif (REG_TEXTAPPLICATION.test(options.type))\n\t\t\toptions.type += '; charset=utf-8';\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t} else {\n\t\t\tif (gzip) {\n\t\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\t\tZlib.gzip(options.body instanceof Buffer ? options.body : U.createBuffer(options.body), (err, data) => res.end(data, res.options.encoding || ENCODING));\n\t\t\t} else {\n\t\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\t\tres.end(options.body, res.options.encoding || ENCODING);\n\t\t\t}\n\t\t}\n\n\t\tresponse_end(res);\n\t\treturn res;\n\t};\n\n\tPROTO.throw400 = function(problem) {\n\t\tthis.options.code = 400;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw401 = function(problem) {\n\t\tthis.options.code = 401;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw403 = function(problem) {\n\t\tthis.options.code = 403;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw404 = function(problem) {\n\t\tthis.options.code = 404;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw408 = function(problem) {\n\t\tthis.options.code = 408;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw409 = function(problem) {\n\t\tthis.options.code = 409;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw431 = function(problem) {\n\t\tthis.options.code = 431;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw500 = function(error) {\n\t\terror && F.error(error, null, this.req.uri);\n\t\tthis.options.code = 500;\n\t\tthis.options.body = U.httpStatus(500) + error ? prepare_error(error) : '';\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw501 = function(problem) {\n\t\tthis.options.code = 501;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.$throw = function() {\n\n\t\t// res.options.code\n\t\t// res.options.body\n\t\t// res.options.problem\n\n\t\tvar res = this;\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = res.req;\n\t\tvar key = 'error' + res.options.code;\n\n\t\tres.options.problem && F.problem(res.options.problem, 'response' + res.options.code + '()', req.uri, req.ip);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(res.options.code || 501, res.options.headers || HEADERS.responseCode);\n\t\t\tres.end();\n\t\t\tF.stats.response[key]++;\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\treq.$total_route = F.lookup(req, '#' + res.options.code, EMPTYARRAY, 0);\n\t\t\treq.$total_exception = res.options.problem;\n\t\t\treq.$total_execute(res.options.code, true);\n\t\t}\n\n\t\tF.$events[key] && EMIT(key, req, res, res.options.problem);\n\t\treturn res;\n\t};\n}\n\nfunction $continue_timeout(res) {\n\tres.continue();\n}\n\nfunction $file_processing(res) {\n\tres.$file();\n}\n\nfunction $file_notmodified(res, name) {\n\tvar req = res.req;\n\tvar headers = HEADERS.file_lastmodified;\n\n\tif (res.getHeader('Last-Modified'))\n\t\tdelete headers['Last-Modified'];\n\telse\n\t\theaders['Last-Modified'] = name instanceof Array ? name[2] : name;\n\n\tif (res.getHeader('Expires'))\n\t\tdelete headers.Expires;\n\telse\n\t\theaders.Expires = DATE_EXPIRES;\n\n\tif (res.getHeader('ETag'))\n\t\tdelete headers.Etag;\n\telse\n\t\theaders.Etag = ETAG + CONF.etag_version;\n\n\theaders[HEADER_TYPE] = U.getContentType(req.extension);\n\tres.writeHead(304, headers);\n\tres.end();\n\tF.stats.response.notModified++;\n\tresponse_end(res);\n}\n\nfunction $file_nocompress(stream, next, res) {\n\tstream.pipe(res);\n\n\tframework_internal.onFinished(res, function() {\n\t\tnext();\n\t\tframework_internal.destroyStream(stream);\n\t});\n\n\tresponse_end(res);\n}\n\nfunction $file_range(name, range, headers, res) {\n\n\tvar arr = range.replace(REG_RANGE, '').split('-');\n\tvar beg = +arr[0] || 0;\n\tvar end = +arr[1] || 0;\n\tvar total = F.temporary.range[name];\n\n\tif (!total) {\n\t\ttotal = Fs.statSync(name).size;\n\t\tRELEASE && (F.temporary.range[name] = total);\n\t}\n\n\tif (end === 0)\n\t\tend = total - 1;\n\n\tif (beg > end) {\n\t\tbeg = 0;\n\t\tend = total - 1;\n\t}\n\n\tif (end > total)\n\t\tend = total - 1;\n\n\tvar length = (end - beg) + 1;\n\n\theaders[HEADER_LENGTH] = length;\n\theaders['Content-Range'] = 'bytes ' + beg + '-' + end + '/' + total;\n\n\tvar req = res;\n\tF.stats.response.streaming++;\n\n\tif (req.method === 'HEAD') {\n\t\tres.writeHead(206, headers);\n\t\tres.end();\n\t\tresponse_end(res);\n\t\treturn F;\n\t}\n\n\tres.writeHead(206, headers);\n\tRANGE.start = beg;\n\tRANGE.end = end;\n\tfsStreamRead(name, RANGE, $file_range_callback, res);\n\treturn F;\n}\n\nfunction $file_range_callback(stream, next, res) {\n\tframework_internal.onFinished(res, function() {\n\t\tframework_internal.destroyStream(stream);\n\t\tnext();\n\t});\n\tstream.pipe(res);\n\tresponse_end(res);\n}\n\nfunction $image_nocache(res) {\n\n\tvar options = res.options;\n\n\t// STREAM\n\tif (options.stream) {\n\t\tvar image = framework_image.load(options.stream, IMAGEMAGICK);\n\t\toptions.make.call(image, image, res);\n\t\toptions.type = U.getContentType(image.outputType);\n\t\toptions.stream = image;\n\t\tF.stats.response.image++;\n\t\tres.$stream();\n\t\treturn F;\n\t}\n\n\t// FILENAME\n\tfsFileExists(options.filename, function(e) {\n\n\t\tif (e) {\n\t\t\tF.path.verify('temp');\n\t\t\tvar image = framework_image.load(options.filename, IMAGEMAGICK);\n\t\t\toptions.make.call(image, image, res);\n\t\t\tF.stats.response.image++;\n\t\t\toptions.type = U.getContentType(image.outputType);\n\t\t\toptions.stream = image;\n\t\t\tres.$stream();\n\t\t} else {\n\t\t\toptions.headers = null;\n\t\t\tres.throw404();\n\t\t}\n\t});\n}\n\nfunction $image_processing(res) {\n\tres.$image();\n}\n\nfunction $image_stream(exists, size, isFile, stats, res) {\n\n\tvar req = res.req;\n\tvar options = res.options;\n\n\tif (exists) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\tres.options.filename = options.name;\n\t\tres.options.stream = null;\n\t\tres.$file();\n\t\tDEBUG && (F.temporary.path[req.$key] = undefined);\n\t\treturn;\n\t}\n\n\tF.path.verify('temp');\n\n\tvar image = framework_image.load(options.stream, IMAGEMAGICK);\n\toptions.make.call(image, image, res);\n\treq.extension = U.getExtension(options.name);\n\n\tif (req.extension !== image.outputType) {\n\t\tvar index = options.name.lastIndexOf('.' + req.extension);\n\t\tif (index !== -1)\n\t\t\toptions.name = options.name.substring(0, index) + '.' + image.outputType;\n\t\telse\n\t\t\toptions.name += '.' + image.outputType;\n\t}\n\n\tF.stats.response.image++;\n\timage.save(options.name, function(err) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tif (err) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tres.throw500(err);\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t} else {\n\t\t\tvar stats = Fs.statSync(options.name);\n\t\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\t\toptions.filename = options.name;\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction $image_filename(exists, size, isFile, stats, res) {\n\n\tvar req = res.req;\n\tvar options = res.options;\n\n\tif (!exists) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tF.temporary.notfound[req.$key] = true;\n\t\tres.throw404();\n\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\treturn;\n\t}\n\n\tF.path.verify('temp');\n\n\tvar image = framework_image.load(options.filename, IMAGEMAGICK);\n\toptions.make.call(image, image, res);\n\treq.extension = U.getExtension(options.name);\n\n\tif (req.extension !== image.outputType) {\n\t\tvar index = options.name.lastIndexOf('.' + req.extension);\n\t\tif (index === -1)\n\t\t\toptions.name += '.' + image.outputType;\n\t\telse\n\t\t\toptions.name = options.name.substring(0, index) + '.' + image.outputType;\n\t}\n\n\tF.stats.response.image++;\n\timage.save(options.name, function(err) {\n\n\t\tdelete F.temporary.processing[req.$key];\n\n\t\tif (err) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tres.throw500(err);\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t} else {\n\t\t\tvar stats = Fs.statSync(options.name);\n\t\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\t\tres.options.filename = options.name;\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction response_end(res) {\n\tF.reqstats(false, res.req.isStaticFile);\n\tres.success = true;\n\t!res.req.isStaticFile && F.$events['request-end'] && EMIT('request-end', res.req, res);\n\tres.req.clear(true);\n\tres.controller && res.req.$total_success();\n\n\tif (res.options.callback) {\n\t\tres.options.callback();\n\t\tres.options.callback = null;\n\t}\n\n\tif (res.options.done) {\n\t\tres.options.done();\n\t\tres.options.done = null;\n\t}\n\n\t// res.options = EMPTYOBJECT;\n\tres.controller = null;\n}\n\n// Handle errors of decodeURIComponent\nfunction $decodeURIComponent(value) {\n\ttry\n\t{\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\treturn value;\n\t}\n}\n\nglobal.Controller = Controller;\n\nprocess.on('unhandledRejection', function(e) {\n\tF.error(e, '', null);\n});\n\nprocess.on('uncaughtException', function(e) {\n\n\tvar err = e.toString();\n\n\tif (err.indexOf('listen EADDRINUSE') !== -1) {\n\t\tprocess.send && process.send('total:eaddrinuse');\n\t\tconsole.log('\\nThe IP address and the PORT is already in use.\\nYou must change the PORT\\'s number or IP address.\\n');\n\t\tprocess.exit('SIGTERM');\n\t\treturn;\n\t} else if (CONF.allow_filter_errors && REG_SKIPERROR.test(err))\n\t\treturn;\n\n\tF.error(e, '', null);\n});\n\nfunction fsFileRead(filename, callback, a, b, c) {\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tFs.readFile(filename, function(err, result) {\n\t\t\tnext();\n\t\t\tcallback(err, result, a, b, c);\n\t\t});\n\t});\n}\n\nfunction fsFileExists(filename, callback, a, b, c) {\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tFs.lstat(filename, function(err, stats) {\n\t\t\tnext();\n\t\t\tcallback(!err && stats.isFile(), stats ? stats.size : 0, stats ? stats.isFile() : false, stats, a, b, c);\n\t\t});\n\t});\n}\n\nfunction fsStreamRead(filename, options, callback, res) {\n\n\tif (!callback) {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tvar opt;\n\n\tif (options) {\n\n\t\topt = HEADERS.fsStreamReadRange;\n\t\topt.start = options.start;\n\t\topt.end = options.end;\n\n\t\tif (opt.start > opt.end)\n\t\t\tdelete opt.end;\n\n\t} else\n\t\topt = HEADERS.fsStreamRead;\n\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tvar stream = Fs.createReadStream(filename, opt);\n\t\tstream.on('error', NOOP);\n\t\tcallback(stream, next, res);\n\t}, filename);\n}\n\n/**\n * Prepare URL address to temporary key (for caching)\n * @param {ServerRequest or String} req\n * @return {String}\n */\nfunction createTemporaryKey(req) {\n\treturn (req.uri ? req.uri.pathname : req).replace(REG_TEMPORARY, '-').substring(1);\n}\n\nfunction MiddlewareOptions() {}\n\nMiddlewareOptions.prototype = {\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tget language() {\n\t\treturn this.req.$language;\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t}\n};\n\nMiddlewareOptions.prototype.callback = function() {\n\tthis.next();\n\treturn this;\n};\n\nMiddlewareOptions.prototype.cancel = function() {\n\tthis.next(false);\n\treturn this;\n};\n\nprocess.on('SIGTERM', () => F.stop());\nprocess.on('SIGINT', () => F.stop());\nprocess.on('exit', () => F.stop());\n\nprocess.on('message', function(msg, h) {\n\tif (msg === 'total:debug') {\n\t\tU.wait(() => F.isLoaded, function() {\n\t\t\tF.isLoaded = undefined;\n\t\t\tF.console();\n\t\t}, 10000, 500);\n\t} else if (msg === 'reconnect')\n\t\tF.reconnect();\n\telse if (msg === 'reset')\n\t\tF.cache.clear();\n\telse if (msg === 'stop' || msg === 'exit' || msg === 'kill')\n\t\tF.stop();\n\telse if (msg && msg.TYPE && msg.id !== F.id) {\n\t\tmsg.TYPE === 'cache-set' && F.cache.set(msg.key, msg.value, msg.expire, false);\n\t\tmsg.TYPE === 'cache-remove' && F.cache.remove(msg.key, false);\n\t\tmsg.TYPE === 'cache-remove-all' && F.cache.removeAll(msg.key, false);\n\t\tmsg.TYPE === 'cache-clear' && F.cache.clear(false);\n\t\tmsg.TYPE === 'req' && F.cluster.req(msg);\n\t\tmsg.TYPE === 'res' && msg.target === F.id && F.cluster.res(msg);\n\t\tmsg.TYPE === 'emit' && F.$events[msg.name] && EMIT(msg.name, msg.a, msg.b, msg.c, msg.d, msg.e);\n\t\tmsg.TYPE === 'nosql-meta' && NOSQL(msg.name).meta(msg.key, msg.value, true);\n\t\tmsg.TYPE === 'table-meta' && TABLE(msg.name).meta(msg.key, msg.value, true);\n\t}\n\tF.$events.message && EMIT('message', msg, h);\n});\n\nfunction prepare_error(e) {\n\tif (!e)\n\t\treturn '';\n\telse if (e instanceof ErrorBuilder)\n\t\treturn e.plain();\n\telse if (DEBUG)\n\t\treturn e.stack ? e.stack : e.toString();\n}\n\nfunction prepare_filename(name) {\n\treturn name[0] === '@' ? (F.isWindows ? U.combine(CONF.directory_temp, name.substring(1)) : F.path.package(name.substring(1))) : U.combine('/', name);\n}\n\nfunction prepare_staticurl(url, isDirectory) {\n\tif (!url)\n\t\treturn url;\n\tif (url[0] === '~') {\n\t\tif (isDirectory)\n\t\t\treturn U.path(url.substring(1));\n\t} else if (url.substring(0, 2) === '//' || url.substring(0, 6) === 'http:/' || url.substring(0, 7) === 'https:/')\n\t\treturn url;\n\treturn url;\n}\n\nfunction prepare_isomorphic(name, value) {\n\treturn 'if(window[\"isomorphic\"]===undefined)window.isomorphic=window.I={};isomorphic[\"' + name.replace(/\\.js$/i, '') + '\"]=(function(framework,F,U,utils,Utils,is_client,is_server){var module={},exports=module.exports={};' + value + ';return exports;})(null,null,null,null,null,true,false)';\n}\n\nfunction isGZIP(req) {\n\tvar ua = req.headers['user-agent'];\n\treturn ua && ua.lastIndexOf('Firefox') !== -1;\n}\n\nfunction prepare_viewname(value) {\n\t// Cleans theme name\n\treturn value.substring(value.indexOf('/', 2) + 1);\n}\n\nfunction existsSync(filename, file) {\n\ttry {\n\t\tvar val = Fs.statSync(filename);\n\t\treturn val ? (file ? val.isFile() : true) : false;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction getLoggerMiddleware(name) {\n\treturn 'MIDDLEWARE(\"' + name + '\")';\n}\n\nfunction async_middleware(index, req, res, middleware, callback, options, controller) {\n\n\tif (res.success || res.headersSent || res.finished) {\n\t\treq.$total_route && req.$total_success();\n\t\tcallback = null;\n\t\treturn;\n\t}\n\n\tvar name = middleware[index++];\n\tif (!name)\n\t\treturn callback && callback(req, res);\n\n\tvar item = F.routes.middleware[name];\n\tif (!item) {\n\t\tF.error('Middleware not found: ' + name, null, req.uri);\n\t\treturn async_middleware(index, req, res, middleware, callback, options, controller);\n\t}\n\n\tvar output;\n\tvar $now;\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tif (item.$newversion) {\n\t\tvar opt = req.$total_middleware;\n\t\tif (!index || !opt) {\n\t\t\topt = req.$total_middleware = new MiddlewareOptions();\n\t\t\topt.req = req;\n\t\t\topt.res = res;\n\t\t\topt.middleware = middleware;\n\t\t\topt.options = options || EMPTYOBJECT;\n\t\t\topt.controller = controller;\n\t\t\topt.callback2 = callback;\n\t\t\topt.next = function(err) {\n\t\t\t\tCONF.logger && F.ilogger(getLoggerMiddleware(name), req, $now);\n\t\t\t\tvar mid = req.$total_middleware;\n\t\t\t\tif (err === false) {\n\t\t\t\t\treq.$total_route && req.$total_success();\n\t\t\t\t\treq.$total_middleware = null;\n\t\t\t\t\tcallback = null;\n\t\t\t\t} else if (err instanceof Error || err instanceof ErrorBuilder) {\n\t\t\t\t\tres.throw500(err);\n\t\t\t\t\treq.$total_middleware = null;\n\t\t\t\t\tcallback = null;\n\t\t\t\t} else\n\t\t\t\t\tasync_middleware(mid.index, mid.req, mid.res, mid.middleware, mid.callback2, mid.options, mid.controller);\n\t\t\t};\n\t\t}\n\n\t\topt.index = index;\n\t\toutput = item(opt);\n\n\t} else {\n\t\toutput = item.call(framework, req, res, function(err) {\n\t\t\tCONF.logger && F.ilogger(getLoggerMiddleware(name), req, $now);\n\t\t\tif (err === false) {\n\t\t\t\treq.$total_route && req.$total_success();\n\t\t\t\tcallback = null;\n\t\t\t} else if (err instanceof Error || err instanceof ErrorBuilder) {\n\t\t\t\tres.throw500(err);\n\t\t\t\tcallback = null;\n\t\t\t} else\n\t\t\t\tasync_middleware(index, req, res, middleware, callback, options, controller);\n\t\t}, options, controller);\n\t}\n\n\tif (res.headersSent || res.finished) {\n\t\treq.$total_route && req.$total_success();\n\t\tcallback = null;\n\t\treturn;\n\t} else if (output !== false)\n\t\treturn;\n\n\treq.$total_route && req.$total_success();\n\tcallback = null;\n}\n\nglobal.setTimeout2 = function(name, fn, timeout, limit, param) {\n\tvar key = ':' + name;\n\tvar internal = F.temporary.internal;\n\n\tif (limit > 0) {\n\n\t\tvar key2 = key + '_limit';\n\t\tvar key3 = key + '_fn';\n\n\t\tif (internal[key2] >= limit) {\n\t\t\tinternal[key] && clearTimeout(internal[key]);\n\t\t\tinternal[key] = internal[key2] = internal[key3] = undefined;\n\t\t\tfn();\n\t\t\treturn;\n\t\t}\n\n\t\tinternal[key] && clearTimeout(internal[key]);\n\t\tinternal[key2] = (internal[key2] || 0) + 1;\n\n\t\treturn internal[key] = setTimeout(function(param, key) {\n\t\t\tF.temporary.internal[key] = F.temporary.internal[key + '_limit'] = F.temporary.internal[key + '_fn'] = undefined;\n\t\t\tfn && fn(param);\n\t\t}, timeout, param, key);\n\t}\n\n\tif (internal[key]) {\n\t\tclearTimeout(internal[key]);\n\t\tinternal[key] = undefined;\n\t}\n\n\treturn internal[key] = setTimeout(fn, timeout, param);\n};\n\nglobal.clearTimeout2 = function(name) {\n\tvar key = ':' + name;\n\n\tif (F.temporary.internal[key]) {\n\t\tclearTimeout(F.temporary.internal[key]);\n\t\tF.temporary.internal[key] = undefined;\n\t\tF.temporary.internal[key + ':limit'] && (F.temporary.internal[key + ':limit'] = undefined);\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nfunction parseComponent(body, filename) {\n\tvar response = {};\n\n\tresponse.css = '';\n\tresponse.js = '';\n\tresponse.install = '';\n\tresponse.files = {};\n\n\tvar beg = 0;\n\tvar end = 0;\n\tvar comname = U.getName(filename);\n\n\t// Files\n\twhile (true) {\n\t\tbeg = body.indexOf('<file name=\"');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = body.indexOf('</file>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar base64 = body.substring(beg, end);\n\n\t\tbody = body.substring(0, beg) + body.substring(end + 7);\n\n\t\t// Creates directory\n\t\tvar p = F.path.temp() + '~' + comname;\n\t\ttry {\n\t\t\tFs.mkdirSync(p);\n\t\t} catch (e) {}\n\n\t\tvar tmp = base64.indexOf('>');\n\t\tvar name = base64.substring(base64.lastIndexOf('name=\"', tmp), tmp);\n\t\tname = name.substring(6, name.length - 1);\n\t\tbase64 = base64.substring(tmp + 1);\n\t\tF.$bundling && Fs.writeFile(U.join(p, name), base64, 'base64', NOOP);\n\t\tresponse.files[name] = 1;\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<script type=\"text/totaljs\">');\n\t\tif (beg === -1) {\n\t\t\tbeg = body.indexOf('<script total>');\n\t\t\tif (beg === -1)\n\t\t\t\tbeg = body.indexOf('<script totaljs>');\n\t\t\tif (beg === -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tend = body.indexOf('</script>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.install += (response.install ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?script.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 9).trim();\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<style');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = body.indexOf('</style>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.css += (response.css ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?style.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 8).trim();\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<script>');\n\t\tif (beg === -1) {\n\t\t\tbeg = body.indexOf('<script type=\"text/javascript\">');\n\t\t\tif (beg === -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tend = body.indexOf('</script>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.js += (response.js ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?script.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 9).trim();\n\t}\n\n\tif (response.js)\n\t\tresponse.js = framework_internal.compile_javascript(response.js, filename);\n\n\tif (response.css)\n\t\tresponse.css = framework_internal.compile_css(response.css, filename);\n\n\tresponse.body = body;\n\treturn response;\n}\n\nfunction getSchemaName(schema, params) {\n\treturn schema[0] === 'default' ? (params ? params[schema[1]] : schema[1]) : schema[0] + '/' + schema[1];\n}\n\n// Default action for workflow routing\nfunction controller_json_workflow(id) {\n\tvar self = this;\n\tvar w = self.route.workflow;\n\n\tself.id = self.route.paramidindex === -1 ? id : self.req.split[self.route.paramidindex];\n\n\tCONF.logger && (self.req.$logger = []);\n\n\tif (w instanceof Object) {\n\n\t\tif (!w.type) {\n\n\t\t\t// IS IT AN OPERATION?\n\t\t\tif (!self.route.schema.length) {\n\t\t\t\tOPERATION(w.id, self.body, w.view ? self.callback(w.view) : self.callback(), self);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar schema = self.route.isDYNAMICSCHEMA ? framework_builders.findschema(self.req.$schemaname || (self.route.schema[0] + '/' + self.params[self.route.schema[1]])) : GETSCHEMA(self.route.schema[0], self.route.schema[1]);\n\t\t\tif (!schema) {\n\t\t\t\tvar err = 'Schema \"{0}\" not found.'.format(getSchemaName(self.route.schema, self.route.isDYNAMICSCHEMA ? self.params : null));\n\t\t\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\t\t\tself.throw404(err);\n\t\t\t\telse\n\t\t\t\t\tself.throw500(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (schema.meta[w.id] !== undefined) {\n\t\t\t\tw.type = '$' + w.id;\n\t\t\t} else if (schema.meta['workflow#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$workflow';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['workflow#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$transform';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['operation#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$operation';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['hook#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$hook';\n\t\t\t\tw.name = w.id;\n\t\t\t}\n\t\t}\n\n\t\tif (w.name)\n\t\t\tself[w.type](w.name, self.callback());\n\t\telse {\n\t\t\tif (w.type)\n\t\t\t\tself[w.type](self.callback(w.view));\n\t\t\telse\n\t\t\t\tself.throw500('Operation @' + w.id + ' not found.');\n\t\t}\n\n\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\tw.type = '';\n\n\t} else\n\t\tself.$exec(w, null, self.callback());\n}\n\n// Default action for workflow routing\nfunction controller_json_workflow_multiple(id) {\n\n\tvar self = this;\n\tvar w = self.route.workflow;\n\n\tself.id = self.route.paramidindex === -1 ? id : self.req.split[self.route.paramidindex];\n\n\tCONF.logger && (self.req.$logger = []);\n\n\tif (w instanceof Object) {\n\t\tif (!w.type) {\n\n\t\t\t// IS IT AN OPERATION?\n\t\t\tif (!self.route.schema.length) {\n\t\t\t\tRUN(w.id, EMPTYOBJECT, w.view ? self.callback(w.view) : self.callback(), null, self, w.index ? w.id[w.index] : null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar schema = self.route.isDYNAMICSCHEMA ? framework_builders.findschema(self.route.schema[0] + '/' + self.params[self.route.schema[1]]) : GETSCHEMA(self.route.schema[0], self.route.schema[1]);\n\t\t\tif (!schema) {\n\t\t\t\tself.throw500('Schema \"{0}\" not found.'.format(getSchemaName(self.route.schema, self.isDYNAMICSCHEMA ? self.params : null)));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar op = [];\n\t\t\tfor (var i = 0; i < w.id.length; i++) {\n\t\t\t\tvar id = w.id[i];\n\t\t\t\tif (schema.meta[id] !== undefined) {\n\t\t\t\t\top.push({ name: '$' + id });\n\t\t\t\t} else if (schema.meta['workflow#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$workflow', id: id });\n\t\t\t\t} else if (schema.meta['workflow#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$transform', id: id });\n\t\t\t\t} else if (schema.meta['operation#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$operation', id: id });\n\t\t\t\t} else if (schema.meta['hook#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$hook', id: id });\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.async = op;\n\t\t}\n\n\t\tvar async = self.$async(self.callback(w.view), w.index);\n\t\tfor (var i = 0; i < w.async.length; i++) {\n\t\t\tvar a = w.async[i];\n\t\t\tif (a.id)\n\t\t\t\tasync[a.name](a.id);\n\t\t\telse\n\t\t\t\tasync[a.name]();\n\t\t}\n\t} else\n\t\tself.$exec(w, null, self.callback());\n}\n\n// Parses schema group and schema name from string e.g. \"User\" or \"Company/User\"\nfunction parseSchema(name) {\n\tvar schema = F.temporary.internal['$$$' + name];\n\tif (schema)\n\t\treturn schema;\n\n\tschema = name.split('/');\n\n\tif (!schema[1]) {\n\t\tschema[1] = schema[0];\n\t\tschema[0] = 'default';\n\t}\n\n\tF.temporary.internal['$$$' + name] = schema;\n\treturn schema;\n}\n\nfunction ilogger(body) {\n\tF.path.verify('logs');\n\tU.queue('F.ilogger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, 'logger.log'), body, next));\n}\n\nF.ilogger = function(name, req, ts) {\n\n\tif (req && req instanceof Controller)\n\t\treq = req.req;\n\n\tvar isc = CONF.logger === 'console';\n\tvar divider = '';\n\n\tfor (var i = 0; i < (isc ? 64 : 220); i++)\n\t\tdivider += '-';\n\n\tvar msg;\n\n\tif (req && !name && req.$logger && req.$logger.length) {\n\n\t\tmsg = req.method + ' ' + req.url;\n\n\t\treq.$logger.unshift(msg);\n\t\treq.$logger.push(divider);\n\n\t\tif (isc)\n\t\t\tconsole.log(req.$logger.join('\\n'));\n\t\telse {\n\t\t\treq.$logger.push('');\n\t\t\tilogger(req.$logger.join('\\n'));\n\t\t}\n\n\t\treq.$logger = null;\n\t\treturn;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tvar dt = new Date();\n\n\tmsg = dt.format('yyyy-MM-dd HH:mm:ss') + ' | ' + name.padRight(40, ' ') + ' | ' + (((dt.getTime() - ts) / 1000).format(3) + ' sec.').padRight(12) + ' | ' + (req ? (req.method + ' ' + req.url).max(70) : '').padRight(70);\n\n\tif (isc) {\n\t\tif (req && req.$logger)\n\t\t\treq.$logger.push(msg);\n\t\telse\n\t\t\tconsole.log(msg + '\\n' + divider);\n\t} else {\n\t\tmsg = msg + ' | ' + (req ? (req.ip || '') : '').padRight(20) + ' | ' + (req && req.headers ? (req.headers['user-agent'] || '') : '');\n\t\tif (req && req.$logger)\n\t\t\treq.$logger.push(msg);\n\t\telse\n\t\t\tilogger(msg + '\\n' + divider + '\\n');\n\t}\n};\n\n// Because of controller prototypes\n// It's used in F.view() and F.viewCompile()\nconst EMPTYCONTROLLER = new Controller('', null, null, '');\nEMPTYCONTROLLER.isConnected = false;\nEMPTYCONTROLLER.req = {};\nEMPTYCONTROLLER.req.url = '';\nEMPTYCONTROLLER.req.uri = EMPTYOBJECT;\nEMPTYCONTROLLER.req.query = EMPTYOBJECT;\nEMPTYCONTROLLER.req.body = EMPTYOBJECT;\nEMPTYCONTROLLER.req.files = EMPTYARRAY;\nglobal.EMPTYCONTROLLER = EMPTYCONTROLLER;\n", "{\n    \"_from\": \"total.js\",\n    \"author\": {\n        \"name\": \"Peter Sirka\",\n        \"email\": \"petersirka@gmail.com\",\n        \"url\": \"http://www.petersirka.com\"\n    },\n    \"bin\": {\n        \"total\": \"./bin/totaljs\",\n        \"total.js\": \"./bin/totaljs\",\n        \"totaljs\": \"./bin/totaljs\",\n        \"tpm\": \"./bin/tpm\",\n        \"totalpackage\": \"./bin/tpm\"\n    },\n    \"description\": \"Web framework for Node.js\",\n    \"devDependencies\": {},\n    \"directories\": {\n        \"test\": \"test\"\n    },\n    \"engines\": {\n        \"node\": \">=8.0.0\"\n    },\n    \"keywords\": [\"total\", \"iot\", \"framework\", \"web\", \"websocket\", \"mvc\", \"controller\", \"view\", \"angular.js\", \"upload\", \"picture\", \"graphicsmagick\", \"imagemagick\", \"eshop\", \"blog\", \"forum\", \"chat\", \"game\", \"nosql\", \"database\", \"streaming\", \"live\", \"server sent events\", \"sse\", \"multipart\", \"x-mixed-replace\"],\n    \"license\": \"MIT\",\n    \"main\": \"./index.js\",\n    \"name\": \"total.js\",\n    \"readmeFilename\": \"readme.md\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/totaljs/framework.git\"\n    },\n    \"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n    },\n    \"contributors\": [{\n        \"name\": \"Peter \u0160irka\",\n        \"email\": \"petersirka@gmail.com\"\n    }, {\n        \"name\": \"Jozef Gula\",\n        \"email\": \"gula.jozef@gmail.com\"\n    }, {\n        \"name\": \"Mat\u00fa\u0161 Szabo\",\n        \"email\": \"matus.szabo@gmail.com\"\n    }, {\n        \"name\": \"Andrea Sessa\",\n        \"email\": \"andrea.sessa@gmail.com\"\n    }, {\n        \"name\": \"Tom Spaccialbelli\",\n        \"email\": \"tom.spaccialbelli@gmail.com\"\n    }, {\n        \"name\": \"Gera G. G\u00fciles\",\n        \"email\": \"gerardo.gonzalezg@gmail.com\"\n    }, {\n        \"name\": \"Radek / rsmogura\",\n        \"email\": \"\"\n    },{\n        \"name\": \"Liao San-Kai\",\n        \"email\": \"liaosankai@gmail.com\"\n    },{\n        \"name\": \"Marchukov Ivan\",\n        \"email\": \"marchukov.ivan@gmail.com\"\n    },{\n        \"name\": \"Dusan Dragula\",\n        \"email\": \"dusan.dragula@goodrequest.com\"\n    },{\n        \"name\": \"\u0421\u043a\u043e\u0432\u043e\u0440\u043e\u0434\u0430 \u041d\u0438\u043a\u0438\u0442\u0430 \u0410\u043d\u0434\u0440\u0435\u0435\u0432\u0438\u0447\",\n        \"email\": \"chalkerx@gmail.com\"\n    },{\n        \"name\": \"Guy Fraser\",\n        \"email\": \"guy.fraser1@gmail.com\"\n    },{\n        \"name\": \"Martin Smola\",\n        \"email\": \"smola.martin@gmail.com\"\n    },{\n        \"name\": \"Peter \u0160tolc\",\n        \"email\": \"stolcp@gmail.com\"\n    },{\n        \"name\": \"Denis Granec\",\n        \"email\": \"danis1999@gmail.com\"\n    },{\n        \"name\": \"Chao Tang Chang\",\n        \"email\": \"mrgmp2004@hotmail.com\"\n    },{\n        \"name\": \"luoage\",\n        \"email\": \"luoage@msn.cn\"\n    },{\n        \"name\": \"Mato Holly\",\n        \"email\": \"mato.holly@gmail.com\"\n    },{\n        \"name\": \"Tema Smirnov\",\n        \"email\": \"github.tema@smirnov.one\"\n    }, {\n        \"name\": \"Jeroen van Hilst\",\n        \"email\": \"frunjik@gmail.com\"\n    }, {\n        \"name\": \"Pedro Costa\",\n        \"email\": \"pedro@pmcdigital.pt\"\n    }, {\n        \"name\": \"Sarp Aykent\",\n        \"email\": \"shackhers@gmail.com\"\n    }],\n    \"version\": \"3.2.1\",\n    \"homepage\": \"http://www.totaljs.com\",\n    \"bugs\": {\n        \"url\": \"https://github.com/totaljs/framework/issues\",\n        \"email\": \"petersirka@gmail.com\"\n    }\n}\n"], "filenames": ["index.js", "package.json"], "buggy_code_start_loc": [71, 102], "buggy_code_end_loc": [7331, 103], "fixing_code_start_loc": [70, 102], "fixing_code_end_loc": [7342, 103], "type": "CWE-22", "message": "index.js in Total.js Platform before 3.2.3 allows path traversal.", "other": {"cve": {"id": "CVE-2019-8903", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-18T16:29:00.870", "lastModified": "2020-03-18T19:15:17.560", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "index.js in Total.js Platform before 3.2.3 allows path traversal."}, {"lang": "es", "value": "index.js en la plataforma Total.js, en versiones anteriores a la 3.2.3, permite un salto de directorio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:totaljs:total.js:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.2.3", "matchCriteriaId": "A56718D8-2CD3-442D-AA9C-614D556A1811"}]}]}], "references": [{"url": "https://blog.certimetergroup.com/it/articolo/security/total.js-directory-traversal-cve-2019-8903", "source": "cve@mitre.org"}, {"url": "https://github.com/totaljs/framework/commit/c37cafbf3e379a98db71c1125533d1e8d5b5aef7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/totaljs/framework/commit/de16238d13848149f5d1dae51f54e397a525932b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/totaljs/framework/commit/c37cafbf3e379a98db71c1125533d1e8d5b5aef7"}}