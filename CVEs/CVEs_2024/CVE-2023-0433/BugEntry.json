{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * textformat.c: text formatting functions\n */\n\n#include \"vim.h\"\n\nstatic int\tdid_add_space = FALSE;\t// auto_format() added an extra space\n\t\t\t\t\t// under the cursor\n\n#define WHITECHAR(cc) (VIM_ISWHITE(cc) && (!enc_utf8 || !utf_iscomposing(utf_ptr2char(ml_get_cursor() + 1))))\n\n/*\n * Return TRUE if format option 'x' is in effect.\n * Take care of no formatting when 'paste' is set.\n */\n    int\nhas_format_option(int x)\n{\n    if (p_paste)\n\treturn FALSE;\n    return (vim_strchr(curbuf->b_p_fo, x) != NULL);\n}\n\n/*\n * Format text at the current insert position.\n *\n * If the INSCHAR_COM_LIST flag is present, then the value of second_indent\n * will be the comment leader length sent to open_line().\n */\n    void\ninternal_format(\n    int\t\ttextwidth,\n    int\t\tsecond_indent,\n    int\t\tflags,\n    int\t\tformat_only,\n    int\t\tc) // character to be inserted (can be NUL)\n{\n    int\t\tcc;\n    int\t\tskip_pos;\n    int\t\tsave_char = NUL;\n    int\t\thaveto_redraw = FALSE;\n    int\t\tfo_ins_blank = has_format_option(FO_INS_BLANK);\n    int\t\tfo_multibyte = has_format_option(FO_MBYTE_BREAK);\n    int\t\tfo_rigor_tw  = has_format_option(FO_RIGOROUS_TW);\n    int\t\tfo_white_par = has_format_option(FO_WHITE_PAR);\n    int\t\tfirst_line = TRUE;\n    colnr_T\tleader_len;\n    int\t\tno_leader = FALSE;\n    int\t\tdo_comments = (flags & INSCHAR_DO_COM);\n#ifdef FEAT_LINEBREAK\n    int\t\thas_lbr = curwin->w_p_lbr;\n\n    // make sure win_lbr_chartabsize() counts correctly\n    curwin->w_p_lbr = FALSE;\n#endif\n\n    // When 'ai' is off we don't want a space under the cursor to be\n    // deleted.  Replace it with an 'x' temporarily.\n    if (!curbuf->b_p_ai && !(State & VREPLACE_FLAG))\n    {\n\tcc = gchar_cursor();\n\tif (VIM_ISWHITE(cc))\n\t{\n\t    save_char = cc;\n\t    pchar_cursor('x');\n\t}\n    }\n\n    // Repeat breaking lines, until the current line is not too long.\n    while (!got_int)\n    {\n\tint\tstartcol;\t\t// Cursor column at entry\n\tint\twantcol;\t\t// column at textwidth border\n\tint\tfoundcol;\t\t// column for start of spaces\n\tint\tend_foundcol = 0;\t// column for start of word\n\tcolnr_T\tlen;\n\tcolnr_T\tvirtcol;\n\tint\torig_col = 0;\n\tchar_u\t*saved_text = NULL;\n\tcolnr_T\tcol;\n\tcolnr_T\tend_col;\n\tint\twcc;\t\t\t// counter for whitespace chars\n\tint\tdid_do_comment = FALSE;\n\n\tvirtcol = get_nolist_virtcol()\n\t\t\t\t   + char2cells(c != NUL ? c : gchar_cursor());\n\tif (virtcol <= (colnr_T)textwidth)\n\t    break;\n\n\tif (no_leader)\n\t    do_comments = FALSE;\n\telse if (!(flags & INSCHAR_FORMAT)\n\t\t\t\t       && has_format_option(FO_WRAP_COMS))\n\t    do_comments = TRUE;\n\n\t// Don't break until after the comment leader\n\tif (do_comments)\n\t{\n\t    char_u *line = ml_get_curline();\n\n\t    leader_len = get_leader_len(line, NULL, FALSE, TRUE);\n\t    if (leader_len == 0 && curbuf->b_p_cin)\n\t    {\n\t\tint\t\tcomment_start;\n\n\t\t// Check for a line comment after code.\n\t\tcomment_start = check_linecomment(line);\n\t\tif (comment_start != MAXCOL)\n\t\t{\n\t\t    leader_len = get_leader_len(\n\t\t\t\t      line + comment_start, NULL, FALSE, TRUE);\n\t\t    if (leader_len != 0)\n\t\t\tleader_len += comment_start;\n\t\t}\n\t    }\n\t}\n\telse\n\t    leader_len = 0;\n\n\t// If the line doesn't start with a comment leader, then don't\n\t// start one in a following broken line.  Avoids that a %word\n\t// moved to the start of the next line causes all following lines\n\t// to start with %.\n\tif (leader_len == 0)\n\t    no_leader = TRUE;\n\tif (!(flags & INSCHAR_FORMAT)\n\t\t&& leader_len == 0\n\t\t&& !has_format_option(FO_WRAP))\n\n\t    break;\n\tif ((startcol = curwin->w_cursor.col) == 0)\n\t    break;\n\n\t// find column of textwidth border\n\tcoladvance((colnr_T)textwidth);\n\twantcol = curwin->w_cursor.col;\n\n\tcurwin->w_cursor.col = startcol;\n\tfoundcol = 0;\n\tskip_pos = 0;\n\n\t// Find position to break at.\n\t// Stop at first entered white when 'formatoptions' has 'v'\n\twhile ((!fo_ins_blank && !has_format_option(FO_INS_VI))\n\t\t    || (flags & INSCHAR_FORMAT)\n\t\t    || curwin->w_cursor.lnum != Insstart.lnum\n\t\t    || curwin->w_cursor.col >= Insstart.col)\n\t{\n\t    if (curwin->w_cursor.col == startcol && c != NUL)\n\t\tcc = c;\n\t    else\n\t\tcc = gchar_cursor();\n\t    if (WHITECHAR(cc))\n\t    {\n\t\t// remember position of blank just before text\n\t\tend_col = curwin->w_cursor.col;\n\n\t\t// find start of sequence of blanks\n\t\twcc = 0;\n\t\twhile (curwin->w_cursor.col > 0 && WHITECHAR(cc))\n\t\t{\n\t\t    dec_cursor();\n\t\t    cc = gchar_cursor();\n\n\t\t    // Increment count of how many whitespace chars in this\n\t\t    // group; we only need to know if it's more than one.\n\t\t    if (wcc < 2)\n\t\t\twcc++;\n\t\t}\n\t\tif (curwin->w_cursor.col == 0 && WHITECHAR(cc))\n\t\t    break;\t\t// only spaces in front of text\n\n\t\t// Don't break after a period when 'formatoptions' has 'p' and\n\t\t// there are less than two spaces.\n\t\tif (has_format_option(FO_PERIOD_ABBR) && cc == '.' && wcc < 2)\n\t\t    continue;\n\n\t\t// Don't break until after the comment leader\n\t\tif (curwin->w_cursor.col < leader_len)\n\t\t    break;\n\t\tif (has_format_option(FO_ONE_LETTER))\n\t\t{\n\t\t    // do not break after one-letter words\n\t\t    if (curwin->w_cursor.col == 0)\n\t\t\tbreak;\t// one-letter word at begin\n\t\t    // do not break \"#a b\" when 'tw' is 2\n\t\t    if (curwin->w_cursor.col <= leader_len)\n\t\t\tbreak;\n\t\t    col = curwin->w_cursor.col;\n\t\t    dec_cursor();\n\t\t    cc = gchar_cursor();\n\n\t\t    if (WHITECHAR(cc))\n\t\t\tcontinue;\t// one-letter, continue\n\t\t    curwin->w_cursor.col = col;\n\t\t}\n\n\t\tinc_cursor();\n\n\t\tend_foundcol = end_col + 1;\n\t\tfoundcol = curwin->w_cursor.col;\n\t\tif (curwin->w_cursor.col <= (colnr_T)wantcol)\n\t\t    break;\n\t    }\n\t    else if ((cc >= 0x100 || !utf_allow_break_before(cc))\n\t\t\t\t\t\t\t       && fo_multibyte)\n\t    {\n\t\tint ncc;\n\t\tint allow_break;\n\n\t\t// Break after or before a multi-byte character.\n\t\tif (curwin->w_cursor.col != startcol)\n\t\t{\n\t\t    // Don't break until after the comment leader\n\t\t    if (curwin->w_cursor.col < leader_len)\n\t\t\tbreak;\n\t\t    col = curwin->w_cursor.col;\n\t\t    inc_cursor();\n\t\t    ncc = gchar_cursor();\n\n\t\t    allow_break =\n\t\t\t(enc_utf8 && utf_allow_break(cc, ncc))\n\t\t\t|| enc_dbcs;\n\n\t\t    // If we have already checked this position, skip!\n\t\t    if (curwin->w_cursor.col != skip_pos && allow_break)\n\t\t    {\n\t\t\tfoundcol = curwin->w_cursor.col;\n\t\t\tend_foundcol = foundcol;\n\t\t\tif (curwin->w_cursor.col <= (colnr_T)wantcol)\n\t\t\t    break;\n\t\t    }\n\t\t    curwin->w_cursor.col = col;\n\t\t}\n\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\n\t\tncc = cc;\n\t\tcol = curwin->w_cursor.col;\n\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\n\t\tif (WHITECHAR(cc))\n\t\t    continue;\t\t// break with space\n\t\t// Don't break until after the comment leader.\n\t\tif (curwin->w_cursor.col < leader_len)\n\t\t    break;\n\n\t\tcurwin->w_cursor.col = col;\n\t\tskip_pos = curwin->w_cursor.col;\n\n\t\tallow_break =\n\t\t    (enc_utf8 && utf_allow_break(cc, ncc))\n\t\t    || enc_dbcs;\n\n\t\t// Must handle this to respect line break prohibition.\n\t\tif (allow_break)\n\t\t{\n\t\t    foundcol = curwin->w_cursor.col;\n\t\t    end_foundcol = foundcol;\n\t\t}\n\t\tif (curwin->w_cursor.col <= (colnr_T)wantcol)\n\t\t{\n\t\t    int ncc_allow_break =\n\t\t\t (enc_utf8 && utf_allow_break_before(ncc)) || enc_dbcs;\n\n\t\t    if (allow_break)\n\t\t\tbreak;\n\t\t    if (!ncc_allow_break && !fo_rigor_tw)\n\t\t    {\n\t\t\t// Enable at most 1 punct hang outside of textwidth.\n\t\t\tif (curwin->w_cursor.col == startcol)\n\t\t\t{\n\t\t\t    // We are inserting a non-breakable char, postpone\n\t\t\t    // line break check to next insert.\n\t\t\t    end_foundcol = foundcol = 0;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// Neither cc nor ncc is NUL if we are here, so\n\t\t\t// it's safe to inc_cursor.\n\t\t\tcol = curwin->w_cursor.col;\n\n\t\t\tinc_cursor();\n\t\t\tcc  = ncc;\n\t\t\tncc = gchar_cursor();\n\t\t\t// handle insert\n\t\t\tncc = (ncc != NUL) ? ncc : c;\n\n\t\t\tallow_break =\n\t\t\t\t(enc_utf8 && utf_allow_break(cc, ncc))\n\t\t\t\t|| enc_dbcs;\n\n\t\t\tif (allow_break)\n\t\t\t{\n\t\t\t    // Break only when we are not at end of line.\n\t\t\t    end_foundcol = foundcol =\n\t\t\t\t      ncc == NUL? 0 : curwin->w_cursor.col;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcurwin->w_cursor.col = col;\n\t\t    }\n\t\t}\n\t    }\n\t    if (curwin->w_cursor.col == 0)\n\t\tbreak;\n\t    dec_cursor();\n\t}\n\n\tif (foundcol == 0)\t\t// no spaces, cannot break line\n\t{\n\t    curwin->w_cursor.col = startcol;\n\t    break;\n\t}\n\n\t// Going to break the line, remove any \"$\" now.\n\tundisplay_dollar();\n\n\t// Offset between cursor position and line break is used by replace\n\t// stack functions.  MODE_VREPLACE does not use this, and backspaces\n\t// over the text instead.\n\tif (State & VREPLACE_FLAG)\n\t    orig_col = startcol;\t// Will start backspacing from here\n\telse\n\t    replace_offset = startcol - end_foundcol;\n\n\t// adjust startcol for spaces that will be deleted and\n\t// characters that will remain on top line\n\tcurwin->w_cursor.col = foundcol;\n\twhile ((cc = gchar_cursor(), WHITECHAR(cc))\n\t\t    && (!fo_white_par || curwin->w_cursor.col < startcol))\n\t    inc_cursor();\n\tstartcol -= curwin->w_cursor.col;\n\tif (startcol < 0)\n\t    startcol = 0;\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // In MODE_VREPLACE state, we will backspace over the text to be\n\t    // wrapped, so save a copy now to put on the next line.\n\t    saved_text = vim_strsave(ml_get_cursor());\n\t    curwin->w_cursor.col = orig_col;\n\t    if (saved_text == NULL)\n\t\tbreak;\t// Can't do it, out of memory\n\t    saved_text[startcol] = NUL;\n\n\t    // Backspace over characters that will move to the next line\n\t    if (!fo_white_par)\n\t\tbackspace_until_column(foundcol);\n\t}\n\telse\n\t{\n\t    // put cursor after pos. to break line\n\t    if (!fo_white_par)\n\t\tcurwin->w_cursor.col = foundcol;\n\t}\n\n\t// Split the line just before the margin.\n\t// Only insert/delete lines, but don't really redraw the window.\n\topen_line(FORWARD, OPENLINE_DELSPACES + OPENLINE_MARKFIX\n\t\t+ (fo_white_par ? OPENLINE_KEEPTRAIL : 0)\n\t\t+ (do_comments ? OPENLINE_DO_COM : 0)\n\t\t+ OPENLINE_FORMAT\n\t\t+ ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)\n\t\t, ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent),\n\t\t&did_do_comment);\n\tif (!(flags & INSCHAR_COM_LIST))\n\t    old_indent = 0;\n\n\t// If a comment leader was inserted, may also do this on a following\n\t// line.\n\tif (did_do_comment)\n\t    no_leader = FALSE;\n\n\treplace_offset = 0;\n\tif (first_line)\n\t{\n\t    if (!(flags & INSCHAR_COM_LIST))\n\t    {\n\t\t// This section is for auto-wrap of numeric lists.  When not\n\t\t// in insert mode (i.e. format_lines()), the INSCHAR_COM_LIST\n\t\t// flag will be set and open_line() will handle it (as seen\n\t\t// above).  The code here (and in get_number_indent()) will\n\t\t// recognize comments if needed...\n\t\tif (second_indent < 0 && has_format_option(FO_Q_NUMBER))\n\t\t    second_indent =\n\t\t\t\t get_number_indent(curwin->w_cursor.lnum - 1);\n\t\tif (second_indent >= 0)\n\t\t{\n\t\t    if (State & VREPLACE_FLAG)\n\t\t\tchange_indent(INDENT_SET, second_indent,\n\t\t\t\t\t\t\t    FALSE, NUL, TRUE);\n\t\t    else\n\t\t\tif (leader_len > 0 && second_indent - leader_len > 0)\n\t\t    {\n\t\t\tint i;\n\t\t\tint padding = second_indent - leader_len;\n\n\t\t\t// We started at the first_line of a numbered list\n\t\t\t// that has a comment.  the open_line() function has\n\t\t\t// inserted the proper comment leader and positioned\n\t\t\t// the cursor at the end of the split line.  Now we\n\t\t\t// add the additional whitespace needed after the\n\t\t\t// comment leader for the numbered list.\n\t\t\tfor (i = 0; i < padding; i++)\n\t\t\t    ins_str((char_u *)\" \");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t(void)set_indent(second_indent, SIN_CHANGED);\n\t\t    }\n\t\t}\n\t    }\n\t    first_line = FALSE;\n\t}\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // In MODE_VREPLACE state we have backspaced over the text to be\n\t    // moved, now we re-insert it into the new line.\n\t    ins_bytes(saved_text);\n\t    vim_free(saved_text);\n\t}\n\telse\n\t{\n\t    // Check if cursor is not past the NUL off the line, cindent\n\t    // may have added or removed indent.\n\t    curwin->w_cursor.col += startcol;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\n\thaveto_redraw = TRUE;\n\tset_can_cindent(TRUE);\n\t// moved the cursor, don't autoindent or cindent now\n\tdid_ai = FALSE;\n\tdid_si = FALSE;\n\tcan_si = FALSE;\n\tcan_si_back = FALSE;\n\tline_breakcheck();\n    }\n\n    if (save_char != NUL)\t\t// put back space after cursor\n\tpchar_cursor(save_char);\n\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = has_lbr;\n#endif\n    if (!format_only && haveto_redraw)\n    {\n\tupdate_topline();\n\tredraw_curbuf_later(UPD_VALID);\n    }\n}\n\n/*\n * Blank lines, and lines containing only the comment leader, are left\n * untouched by the formatting.  The function returns TRUE in this\n * case.  It also returns TRUE when a line starts with the end of a comment\n * ('e' in comment flags), so that this line is skipped, and not joined to the\n * previous line.  A new paragraph starts after a blank line, or when the\n * comment leader changes -- webb.\n */\n    static int\nfmt_check_par(\n    linenr_T\tlnum,\n    int\t\t*leader_len,\n    char_u\t**leader_flags,\n    int\t\tdo_comments)\n{\n    char_u\t*flags = NULL;\t    // init for GCC\n    char_u\t*ptr;\n\n    ptr = ml_get(lnum);\n    if (do_comments)\n\t*leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);\n    else\n\t*leader_len = 0;\n\n    if (*leader_len > 0)\n    {\n\t// Search for 'e' flag in comment leader flags.\n\tflags = *leader_flags;\n\twhile (*flags && *flags != ':' && *flags != COM_END)\n\t    ++flags;\n    }\n\n    return (*skipwhite(ptr + *leader_len) == NUL\n\t    || (*leader_len > 0 && *flags == COM_END)\n\t    || startPS(lnum, NUL, FALSE));\n}\n\n/*\n * Return TRUE if line \"lnum\" ends in a white character.\n */\n    static int\nends_in_white(linenr_T lnum)\n{\n    char_u\t*s = ml_get(lnum);\n    size_t\tl;\n\n    if (*s == NUL)\n\treturn FALSE;\n    // Don't use STRLEN() inside VIM_ISWHITE(), SAS/C complains: \"macro\n    // invocation may call function multiple times\".\n    l = STRLEN(s) - 1;\n    return VIM_ISWHITE(s[l]);\n}\n\n/*\n * Return TRUE if the two comment leaders given are the same.  \"lnum\" is\n * the first line.  White-space is ignored.  Note that the whole of\n * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb\n */\n    static int\nsame_leader(\n    linenr_T lnum,\n    int\t    leader1_len,\n    char_u  *leader1_flags,\n    int\t    leader2_len,\n    char_u  *leader2_flags)\n{\n    int\t    idx1 = 0, idx2 = 0;\n    char_u  *p;\n    char_u  *line1;\n    char_u  *line2;\n\n    if (leader1_len == 0)\n\treturn (leader2_len == 0);\n\n    // If first leader has 'f' flag, the lines can be joined only if the\n    // second line does not have a leader.\n    // If first leader has 'e' flag, the lines can never be joined.\n    // If first leader has 's' flag, the lines can only be joined if there is\n    // some text after it and the second line has the 'm' flag.\n    if (leader1_flags != NULL)\n    {\n\tfor (p = leader1_flags; *p && *p != ':'; ++p)\n\t{\n\t    if (*p == COM_FIRST)\n\t\treturn (leader2_len == 0);\n\t    if (*p == COM_END)\n\t\treturn FALSE;\n\t    if (*p == COM_START)\n\t    {\n\t\tif (*(ml_get(lnum) + leader1_len) == NUL)\n\t\t    return FALSE;\n\t\tif (leader2_flags == NULL || leader2_len == 0)\n\t\t    return FALSE;\n\t\tfor (p = leader2_flags; *p && *p != ':'; ++p)\n\t\t    if (*p == COM_MIDDLE)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // Get current line and next line, compare the leaders.\n    // The first line has to be saved, only one line can be locked at a time.\n    line1 = vim_strsave(ml_get(lnum));\n    if (line1 != NULL)\n    {\n\tfor (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1)\n\t    ;\n\tline2 = ml_get(lnum + 1);\n\tfor (idx2 = 0; idx2 < leader2_len; ++idx2)\n\t{\n\t    if (!VIM_ISWHITE(line2[idx2]))\n\t    {\n\t\tif (line1[idx1++] != line2[idx2])\n\t\t    break;\n\t    }\n\t    else\n\t\twhile (VIM_ISWHITE(line1[idx1]))\n\t\t    ++idx1;\n\t}\n\tvim_free(line1);\n    }\n    return (idx2 == leader2_len && idx1 == leader1_len);\n}\n\n/*\n * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the\n * previous line is in the same paragraph.  Used for auto-formatting.\n */\n    static int\nparagraph_start(linenr_T lnum)\n{\n    char_u\t*p;\n    int\t\tleader_len = 0;\t\t// leader len of current line\n    char_u\t*leader_flags = NULL;\t// flags for leader of current line\n    int\t\tnext_leader_len;\t// leader len of next line\n    char_u\t*next_leader_flags;\t// flags for leader of next line\n    int\t\tdo_comments;\t\t// format comments\n\n    if (lnum <= 1)\n\treturn TRUE;\t\t// start of the file\n\n    p = ml_get(lnum - 1);\n    if (*p == NUL)\n\treturn TRUE;\t\t// after empty line\n\n    do_comments = has_format_option(FO_Q_COMS);\n    if (fmt_check_par(lnum - 1, &leader_len, &leader_flags, do_comments))\n\treturn TRUE;\t\t// after non-paragraph line\n\n    if (fmt_check_par(lnum, &next_leader_len, &next_leader_flags, do_comments))\n\treturn TRUE;\t\t// \"lnum\" is not a paragraph line\n\n    if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))\n\treturn TRUE;\t\t// missing trailing space in previous line.\n\n    if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))\n\treturn TRUE;\t\t// numbered item starts in \"lnum\".\n\n    if (!same_leader(lnum - 1, leader_len, leader_flags,\n\t\t\t\t\t  next_leader_len, next_leader_flags))\n\treturn TRUE;\t\t// change of comment leader.\n\n    return FALSE;\n}\n\n/*\n * Called after inserting or deleting text: When 'formatoptions' includes the\n * 'a' flag format from the current line until the end of the paragraph.\n * Keep the cursor at the same position relative to the text.\n * The caller must have saved the cursor line for undo, following ones will be\n * saved here.\n */\n    void\nauto_format(\n    int\t\ttrailblank,\t// when TRUE also format with trailing blank\n    int\t\tprev_line)\t// may start in previous line\n{\n    pos_T\tpos;\n    colnr_T\tlen;\n    char_u\t*old;\n    char_u\t*new, *pnew;\n    int\t\twasatend;\n    int\t\tcc;\n\n    if (!has_format_option(FO_AUTO))\n\treturn;\n\n    pos = curwin->w_cursor;\n    old = ml_get_curline();\n\n    // may remove added space\n    check_auto_format(FALSE);\n\n    // Don't format in Insert mode when the cursor is on a trailing blank, the\n    // user might insert normal text next.  Also skip formatting when \"1\" is\n    // in 'formatoptions' and there is a single character before the cursor.\n    // Otherwise the line would be broken and when typing another non-white\n    // next they are not joined back together.\n    wasatend = (pos.col == (colnr_T)STRLEN(old));\n    if (*old != NUL && !trailblank && wasatend)\n    {\n\tdec_cursor();\n\tcc = gchar_cursor();\n\tif (!WHITECHAR(cc) && curwin->w_cursor.col > 0\n\t\t\t\t\t  && has_format_option(FO_ONE_LETTER))\n\t    dec_cursor();\n\tcc = gchar_cursor();\n\tif (WHITECHAR(cc))\n\t{\n\t    curwin->w_cursor = pos;\n\t    return;\n\t}\n\tcurwin->w_cursor = pos;\n    }\n\n    // With the 'c' flag in 'formatoptions' and 't' missing: only format\n    // comments.\n    if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)\n\t\t\t\t&& get_leader_len(old, NULL, FALSE, TRUE) == 0)\n\treturn;\n\n    // May start formatting in a previous line, so that after \"x\" a word is\n    // moved to the previous line if it fits there now.  Only when this is not\n    // the start of a paragraph.\n    if (prev_line && !paragraph_start(curwin->w_cursor.lnum))\n    {\n\t--curwin->w_cursor.lnum;\n\tif (u_save_cursor() == FAIL)\n\t    return;\n    }\n\n    // Do the formatting and restore the cursor position.  \"saved_cursor\" will\n    // be adjusted for the text formatting.\n    saved_cursor = pos;\n    format_lines((linenr_T)-1, FALSE);\n    curwin->w_cursor = saved_cursor;\n    saved_cursor.lnum = 0;\n\n    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n    {\n\t// \"cannot happen\"\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n    else\n\tcheck_cursor_col();\n\n    // Insert mode: If the cursor is now after the end of the line while it\n    // previously wasn't, the line was broken.  Because of the rule above we\n    // need to add a space when 'w' is in 'formatoptions' to keep a paragraph\n    // formatted.\n    if (!wasatend && has_format_option(FO_WHITE_PAR))\n    {\n\tnew = ml_get_curline();\n\tlen = (colnr_T)STRLEN(new);\n\tif (curwin->w_cursor.col == len)\n\t{\n\t    pnew = vim_strnsave(new, len + 2);\n\t    pnew[len] = ' ';\n\t    pnew[len + 1] = NUL;\n\t    ml_replace(curwin->w_cursor.lnum, pnew, FALSE);\n\t    // remove the space later\n\t    did_add_space = TRUE;\n\t}\n\telse\n\t    // may remove added space\n\t    check_auto_format(FALSE);\n    }\n\n    check_cursor();\n}\n\n/*\n * When an extra space was added to continue a paragraph for auto-formatting,\n * delete it now.  The space must be under the cursor, just after the insert\n * position.\n */\n    void\ncheck_auto_format(\n    int\t\tend_insert)\t    // TRUE when ending Insert mode\n{\n    int\t\tc = ' ';\n    int\t\tcc;\n\n    if (did_add_space)\n    {\n\tcc = gchar_cursor();\n\tif (!WHITECHAR(cc))\n\t    // Somehow the space was removed already.\n\t    did_add_space = FALSE;\n\telse\n\t{\n\t    if (!end_insert)\n\t    {\n\t\tinc_cursor();\n\t\tc = gchar_cursor();\n\t\tdec_cursor();\n\t    }\n\t    if (c != NUL)\n\t    {\n\t\t// The space is no longer at the end of the line, delete it.\n\t\tdel_char(FALSE);\n\t\tdid_add_space = FALSE;\n\t    }\n\t}\n    }\n}\n\n/*\n * Find out textwidth to be used for formatting:\n *\tif 'textwidth' option is set, use it\n *\telse if 'wrapmargin' option is set, use curwin->w_width - 'wrapmargin'\n *\tif invalid value, use 0.\n *\tSet default to window width (maximum 79) for \"gq\" operator.\n */\n    int\ncomp_textwidth(\n    int\t\tff)\t// force formatting (for \"gq\" command)\n{\n    int\t\ttextwidth;\n\n    textwidth = curbuf->b_p_tw;\n    if (textwidth == 0 && curbuf->b_p_wm)\n    {\n\t// The width is the window width minus 'wrapmargin' minus all the\n\t// things that add to the margin.\n\ttextwidth = curwin->w_width - curbuf->b_p_wm;\n\tif (cmdwin_type != 0)\n\t    textwidth -= 1;\n#ifdef FEAT_FOLDING\n\ttextwidth -= curwin->w_p_fdc;\n#endif\n#ifdef FEAT_SIGNS\n\tif (signcolumn_on(curwin))\n\t    textwidth -= 1;\n#endif\n\tif (curwin->w_p_nu || curwin->w_p_rnu)\n\t    textwidth -= 8;\n    }\n    if (textwidth < 0)\n\ttextwidth = 0;\n    if (ff && textwidth == 0)\n    {\n\ttextwidth = curwin->w_width - 1;\n\tif (textwidth > 79)\n\t    textwidth = 79;\n    }\n    return textwidth;\n}\n\n/*\n * Implementation of the format operator 'gq'.\n */\n    void\nop_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t// keep cursor on same text char\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n\n    // Place the cursor where the \"gq\" or \"gw\" command was given, so that \"u\"\n    // can put it back there.\n    curwin->w_cursor = oap->cursor_start;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n\n    if (oap->is_VIsual)\n\t// When there is no change: need to remove the Visual selection\n\tredraw_curbuf_later(UPD_INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t// Set '[ mark at the start of the formatted area\n\tcurbuf->b_op_start = oap->start;\n\n    // For \"gw\" remember the cursor position and put it back below (adjusted\n    // for joined and split lines).\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n\n    format_lines(oap->line_count, keep_cursor);\n\n    // Leave the cursor at the first non-blank of the last formatted line.\n    // If the cursor was moved one line back (e.g. with \"Q}\") go to the next\n    // line, so \".\" will do the next lines.\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t// put '] mark on the end of the formatted area\n\tcurbuf->b_op_end = curwin->w_cursor;\n\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n\n\t// formatting may have made the cursor position invalid\n\tcheck_cursor();\n    }\n\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\t// When lines have been inserted or deleted, adjust the end of\n\t\t// the Visual area to be redrawn.\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Implementation of the format operator 'gq' for when using 'formatexpr'.\n */\n    void\nop_formatexpr(oparg_T *oap)\n{\n    if (oap->is_VIsual)\n\t// When there is no change: need to remove the Visual selection\n\tredraw_curbuf_later(UPD_INVERTED);\n\n    if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)\n\t// As documented: when 'formatexpr' returns non-zero fall back to\n\t// internal formatting.\n\top_format(oap, FALSE);\n}\n\n    int\nfex_format(\n    linenr_T\tlnum,\n    long\tcount,\n    int\t\tc)\t// character to be inserted\n{\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"formatexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n    int\t\tr;\n    char_u\t*fex;\n    sctx_T\tsave_sctx = current_sctx;\n\n    // Set v:lnum to the first line number and v:count to the number of lines.\n    // Set v:char to the character to be inserted (can be NUL).\n    set_vim_var_nr(VV_LNUM, lnum);\n    set_vim_var_nr(VV_COUNT, count);\n    set_vim_var_char(c);\n\n    // Make a copy, the option could be changed while calling it.\n    fex = vim_strsave(curbuf->b_p_fex);\n    if (fex == NULL)\n\treturn 0;\n    current_sctx = curbuf->b_p_script_ctx[BV_FEX];\n\n    // Evaluate the function.\n    if (use_sandbox)\n\t++sandbox;\n    r = (int)eval_to_number(fex, TRUE);\n    if (use_sandbox)\n\t--sandbox;\n\n    set_vim_var_string(VV_CHAR, NULL, -1);\n    vim_free(fex);\n    current_sctx = save_sctx;\n\n    return r;\n}\n#endif\n\n/*\n * Format \"line_count\" lines, starting at the cursor position.\n * When \"line_count\" is negative, format until the end of the paragraph.\n * Lines after the cursor line are saved for undo, caller must have saved the\n * first line.\n */\n    void\nformat_lines(\n    linenr_T\tline_count,\n    int\t\tavoid_fex)\t\t// don't use 'formatexpr'\n{\n    int\t\tmax_len;\n    int\t\tis_not_par;\t\t// current line not part of parag.\n    int\t\tnext_is_not_par;\t// next line not part of paragraph\n    int\t\tis_end_par;\t\t// at end of paragraph\n    int\t\tprev_is_end_par = FALSE;// prev. line not part of parag.\n    int\t\tnext_is_start_par = FALSE;\n    int\t\tleader_len = 0;\t\t// leader len of current line\n    int\t\tnext_leader_len;\t// leader len of next line\n    char_u\t*leader_flags = NULL;\t// flags for leader of current line\n    char_u\t*next_leader_flags = NULL; // flags for leader of next line\n    int\t\tdo_comments;\t\t// format comments\n    int\t\tdo_comments_list = 0;\t// format comments with 'n' or '2'\n    int\t\tadvance = TRUE;\n    int\t\tsecond_indent = -1;\t// indent for second line (comment\n\t\t\t\t\t// aware)\n    int\t\tdo_second_indent;\n    int\t\tdo_number_indent;\n    int\t\tdo_trail_white;\n    int\t\tfirst_par_line = TRUE;\n    int\t\tsmd_save;\n    long\tcount;\n    int\t\tneed_set_indent = TRUE;\t// set indent of next paragraph\n    linenr_T\tfirst_line = curwin->w_cursor.lnum;\n    int\t\tforce_format = FALSE;\n    int\t\told_State = State;\n\n    // length of a line to force formatting: 3 * 'tw'\n    max_len = comp_textwidth(TRUE) * 3;\n\n    // check for 'q', '2' and '1' in 'formatoptions'\n    do_comments = has_format_option(FO_Q_COMS);\n    do_second_indent = has_format_option(FO_Q_SECOND);\n    do_number_indent = has_format_option(FO_Q_NUMBER);\n    do_trail_white = has_format_option(FO_WHITE_PAR);\n\n    // Get info about the previous and current line.\n    if (curwin->w_cursor.lnum > 1)\n\tis_not_par = fmt_check_par(curwin->w_cursor.lnum - 1\n\t\t\t\t, &leader_len, &leader_flags, do_comments);\n    else\n\tis_not_par = TRUE;\n    next_is_not_par = fmt_check_par(curwin->w_cursor.lnum\n\t\t\t  , &next_leader_len, &next_leader_flags, do_comments);\n    is_end_par = (is_not_par || next_is_not_par);\n    if (!is_end_par && do_trail_white)\n\tis_end_par = !ends_in_white(curwin->w_cursor.lnum - 1);\n\n    curwin->w_cursor.lnum--;\n    for (count = line_count; count != 0 && !got_int; --count)\n    {\n\t// Advance to next paragraph.\n\tif (advance)\n\t{\n\t    curwin->w_cursor.lnum++;\n\t    prev_is_end_par = is_end_par;\n\t    is_not_par = next_is_not_par;\n\t    leader_len = next_leader_len;\n\t    leader_flags = next_leader_flags;\n\t}\n\n\t// The last line to be formatted.\n\tif (count == 1 || curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    next_is_not_par = TRUE;\n\t    next_leader_len = 0;\n\t    next_leader_flags = NULL;\n\t}\n\telse\n\t{\n\t    next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1\n\t\t\t  , &next_leader_len, &next_leader_flags, do_comments);\n\t    if (do_number_indent)\n\t\tnext_is_start_par =\n\t\t\t   (get_number_indent(curwin->w_cursor.lnum + 1) > 0);\n\t}\n\tadvance = TRUE;\n\tis_end_par = (is_not_par || next_is_not_par || next_is_start_par);\n\tif (!is_end_par && do_trail_white)\n\t    is_end_par = !ends_in_white(curwin->w_cursor.lnum);\n\n\t// Skip lines that are not in a paragraph.\n\tif (is_not_par)\n\t{\n\t    if (line_count < 0)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    // For the first line of a paragraph, check indent of second line.\n\t    // Don't do this for comments and empty lines.\n\t    if (first_par_line\n\t\t    && (do_second_indent || do_number_indent)\n\t\t    && prev_is_end_par\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (do_second_indent && !LINEEMPTY(curwin->w_cursor.lnum + 1))\n\t\t{\n\t\t    if (leader_len == 0 && next_leader_len == 0)\n\t\t    {\n\t\t\t// no comment found\n\t\t\tsecond_indent =\n\t\t\t\t   get_indent_lnum(curwin->w_cursor.lnum + 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsecond_indent = next_leader_len;\n\t\t\tdo_comments_list = 1;\n\t\t    }\n\t\t}\n\t\telse if (do_number_indent)\n\t\t{\n\t\t    if (leader_len == 0 && next_leader_len == 0)\n\t\t    {\n\t\t\t// no comment found\n\t\t\tsecond_indent =\n\t\t\t\t     get_number_indent(curwin->w_cursor.lnum);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// get_number_indent() is now \"comment aware\"...\n\t\t\tsecond_indent =\n\t\t\t\t     get_number_indent(curwin->w_cursor.lnum);\n\t\t\tdo_comments_list = 1;\n\t\t    }\n\t\t}\n\t    }\n\n\t    // When the comment leader changes, it's the end of the paragraph.\n\t    if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count\n\t\t    || !same_leader(curwin->w_cursor.lnum,\n\t\t\t\t\tleader_len, leader_flags,\n\t\t\t\t\t   next_leader_len, next_leader_flags))\n\t    {\n\t\t// Special case: If the next line starts with a line comment\n\t\t// and this line has a line comment after some text, the\n\t\t// paragraph doesn't really end.\n\t\tif (next_leader_flags == NULL\n\t\t\t|| STRNCMP(next_leader_flags, \"://\", 3) != 0\n\t\t\t|| check_linecomment(ml_get_curline()) == MAXCOL)\n\t\tis_end_par = TRUE;\n\t    }\n\n\t    // If we have got to the end of a paragraph, or the line is\n\t    // getting long, format it.\n\t    if (is_end_par || force_format)\n\t    {\n\t\tif (need_set_indent)\n\t\t{\n\t\t    int\t\tindent = 0; // amount of indent needed\n\n\t\t    // Replace indent in first line of a paragraph with minimal\n\t\t    // number of tabs and spaces, according to current options.\n\t\t    // For the very first formatted line keep the current\n\t\t    // indent.\n\t\t    if (curwin->w_cursor.lnum == first_line)\n\t\t\tindent = get_indent();\n\t\t    else if (curbuf->b_p_lisp)\n\t\t\tindent = get_lisp_indent();\n\t\t    else\n\t\t    {\n\t\t\tif (cindent_on())\n\t\t\t{\n\t\t\t    indent =\n# ifdef FEAT_EVAL\n\t\t\t\t *curbuf->b_p_inde != NUL ? get_expr_indent() :\n# endif\n\t\t\t\t get_c_indent();\n\t\t\t}\n\t\t\telse\n\t\t\t    indent = get_indent();\n\t\t    }\n\t\t    (void)set_indent(indent, SIN_CHANGED);\n\t\t}\n\n\t\t// put cursor on last non-space\n\t\tState = MODE_NORMAL;\t// don't go past end-of-line\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\twhile (curwin->w_cursor.col && vim_isspace(gchar_cursor()))\n\t\t    dec_cursor();\n\n\t\t// do the formatting, without 'showmode'\n\t\tState = MODE_INSERT;\t// for open_line()\n\t\tsmd_save = p_smd;\n\t\tp_smd = FALSE;\n\t\tinsertchar(NUL, INSCHAR_FORMAT\n\t\t\t+ (do_comments ? INSCHAR_DO_COM : 0)\n\t\t\t+ (do_comments && do_comments_list\n\t\t\t\t\t\t       ? INSCHAR_COM_LIST : 0)\n\t\t\t+ (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);\n\t\tState = old_State;\n\t\tp_smd = smd_save;\n\t\tsecond_indent = -1;\n\t\t// at end of par.: need to set indent of next par.\n\t\tneed_set_indent = is_end_par;\n\t\tif (is_end_par)\n\t\t{\n\t\t    // When called with a negative line count, break at the\n\t\t    // end of the paragraph.\n\t\t    if (line_count < 0)\n\t\t\tbreak;\n\t\t    first_par_line = TRUE;\n\t\t}\n\t\tforce_format = FALSE;\n\t    }\n\n\t    // When still in same paragraph, join the lines together.  But\n\t    // first delete the leader from the second line.\n\t    if (!is_end_par)\n\t    {\n\t\tadvance = FALSE;\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (line_count < 0 && u_save_cursor() == FAIL)\n\t\t    break;\n\t\tif (next_leader_len > 0)\n\t\t{\n\t\t    (void)del_bytes((long)next_leader_len, FALSE, FALSE);\n\t\t    mark_col_adjust(curwin->w_cursor.lnum, (colnr_T)0, 0L,\n\t\t\t\t\t\t    (long)-next_leader_len, 0);\n\t\t}\n\t\telse if (second_indent > 0)  // the \"leader\" for FO_Q_SECOND\n\t\t{\n\t\t    int indent = getwhitecols_curline();\n\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t(void)del_bytes(indent, FALSE, FALSE);\n\t\t\tmark_col_adjust(curwin->w_cursor.lnum,\n\t\t\t\t\t     (colnr_T)0, 0L, (long)-indent, 0);\n\t\t    }\n\t\t}\n\t\tcurwin->w_cursor.lnum--;\n\t\tif (do_join(2, TRUE, FALSE, FALSE, FALSE) == FAIL)\n\t\t{\n\t\t    beep_flush();\n\t\t    break;\n\t\t}\n\t\tfirst_par_line = FALSE;\n\t\t// If the line is getting long, format it next time\n\t\tif (STRLEN(ml_get_curline()) > (size_t)max_len)\n\t\t    force_format = TRUE;\n\t\telse\n\t\t    force_format = FALSE;\n\t    }\n\t}\n\tline_breakcheck();\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * textformat.c: text formatting functions\n */\n\n#include \"vim.h\"\n\nstatic int\tdid_add_space = FALSE;\t// auto_format() added an extra space\n\t\t\t\t\t// under the cursor\n\n#define WHITECHAR(cc) (VIM_ISWHITE(cc) && (!enc_utf8 || !utf_iscomposing(utf_ptr2char(ml_get_cursor() + 1))))\n\n/*\n * Return TRUE if format option 'x' is in effect.\n * Take care of no formatting when 'paste' is set.\n */\n    int\nhas_format_option(int x)\n{\n    if (p_paste)\n\treturn FALSE;\n    return (vim_strchr(curbuf->b_p_fo, x) != NULL);\n}\n\n/*\n * Format text at the current insert position.\n *\n * If the INSCHAR_COM_LIST flag is present, then the value of second_indent\n * will be the comment leader length sent to open_line().\n */\n    void\ninternal_format(\n    int\t\ttextwidth,\n    int\t\tsecond_indent,\n    int\t\tflags,\n    int\t\tformat_only,\n    int\t\tc) // character to be inserted (can be NUL)\n{\n    int\t\tcc;\n    int\t\tskip_pos;\n    int\t\tsave_char = NUL;\n    int\t\thaveto_redraw = FALSE;\n    int\t\tfo_ins_blank = has_format_option(FO_INS_BLANK);\n    int\t\tfo_multibyte = has_format_option(FO_MBYTE_BREAK);\n    int\t\tfo_rigor_tw  = has_format_option(FO_RIGOROUS_TW);\n    int\t\tfo_white_par = has_format_option(FO_WHITE_PAR);\n    int\t\tfirst_line = TRUE;\n    colnr_T\tleader_len;\n    int\t\tno_leader = FALSE;\n    int\t\tdo_comments = (flags & INSCHAR_DO_COM);\n#ifdef FEAT_LINEBREAK\n    int\t\thas_lbr = curwin->w_p_lbr;\n\n    // make sure win_lbr_chartabsize() counts correctly\n    curwin->w_p_lbr = FALSE;\n#endif\n\n    // When 'ai' is off we don't want a space under the cursor to be\n    // deleted.  Replace it with an 'x' temporarily.\n    if (!curbuf->b_p_ai && !(State & VREPLACE_FLAG))\n    {\n\tcc = gchar_cursor();\n\tif (VIM_ISWHITE(cc))\n\t{\n\t    save_char = cc;\n\t    pchar_cursor('x');\n\t}\n    }\n\n    // Repeat breaking lines, until the current line is not too long.\n    while (!got_int)\n    {\n\tint\tstartcol;\t\t// Cursor column at entry\n\tint\twantcol;\t\t// column at textwidth border\n\tint\tfoundcol;\t\t// column for start of spaces\n\tint\tend_foundcol = 0;\t// column for start of word\n\tcolnr_T\tlen;\n\tcolnr_T\tvirtcol;\n\tint\torig_col = 0;\n\tchar_u\t*saved_text = NULL;\n\tcolnr_T\tcol;\n\tcolnr_T\tend_col;\n\tint\twcc;\t\t\t// counter for whitespace chars\n\tint\tdid_do_comment = FALSE;\n\n\tvirtcol = get_nolist_virtcol()\n\t\t\t\t   + char2cells(c != NUL ? c : gchar_cursor());\n\tif (virtcol <= (colnr_T)textwidth)\n\t    break;\n\n\tif (no_leader)\n\t    do_comments = FALSE;\n\telse if (!(flags & INSCHAR_FORMAT)\n\t\t\t\t       && has_format_option(FO_WRAP_COMS))\n\t    do_comments = TRUE;\n\n\t// Don't break until after the comment leader\n\tif (do_comments)\n\t{\n\t    char_u *line = ml_get_curline();\n\n\t    leader_len = get_leader_len(line, NULL, FALSE, TRUE);\n\t    if (leader_len == 0 && curbuf->b_p_cin)\n\t    {\n\t\tint\t\tcomment_start;\n\n\t\t// Check for a line comment after code.\n\t\tcomment_start = check_linecomment(line);\n\t\tif (comment_start != MAXCOL)\n\t\t{\n\t\t    leader_len = get_leader_len(\n\t\t\t\t      line + comment_start, NULL, FALSE, TRUE);\n\t\t    if (leader_len != 0)\n\t\t\tleader_len += comment_start;\n\t\t}\n\t    }\n\t}\n\telse\n\t    leader_len = 0;\n\n\t// If the line doesn't start with a comment leader, then don't\n\t// start one in a following broken line.  Avoids that a %word\n\t// moved to the start of the next line causes all following lines\n\t// to start with %.\n\tif (leader_len == 0)\n\t    no_leader = TRUE;\n\tif (!(flags & INSCHAR_FORMAT)\n\t\t&& leader_len == 0\n\t\t&& !has_format_option(FO_WRAP))\n\n\t    break;\n\tif ((startcol = curwin->w_cursor.col) == 0)\n\t    break;\n\n\t// find column of textwidth border\n\tcoladvance((colnr_T)textwidth);\n\twantcol = curwin->w_cursor.col;\n\n\tcurwin->w_cursor.col = startcol;\n\tfoundcol = 0;\n\tskip_pos = 0;\n\n\t// Find position to break at.\n\t// Stop at first entered white when 'formatoptions' has 'v'\n\twhile ((!fo_ins_blank && !has_format_option(FO_INS_VI))\n\t\t    || (flags & INSCHAR_FORMAT)\n\t\t    || curwin->w_cursor.lnum != Insstart.lnum\n\t\t    || curwin->w_cursor.col >= Insstart.col)\n\t{\n\t    if (curwin->w_cursor.col == startcol && c != NUL)\n\t\tcc = c;\n\t    else\n\t\tcc = gchar_cursor();\n\t    if (WHITECHAR(cc))\n\t    {\n\t\t// remember position of blank just before text\n\t\tend_col = curwin->w_cursor.col;\n\n\t\t// find start of sequence of blanks\n\t\twcc = 0;\n\t\twhile (curwin->w_cursor.col > 0 && WHITECHAR(cc))\n\t\t{\n\t\t    dec_cursor();\n\t\t    cc = gchar_cursor();\n\n\t\t    // Increment count of how many whitespace chars in this\n\t\t    // group; we only need to know if it's more than one.\n\t\t    if (wcc < 2)\n\t\t\twcc++;\n\t\t}\n\t\tif (curwin->w_cursor.col == 0 && WHITECHAR(cc))\n\t\t    break;\t\t// only spaces in front of text\n\n\t\t// Don't break after a period when 'formatoptions' has 'p' and\n\t\t// there are less than two spaces.\n\t\tif (has_format_option(FO_PERIOD_ABBR) && cc == '.' && wcc < 2)\n\t\t    continue;\n\n\t\t// Don't break until after the comment leader\n\t\tif (curwin->w_cursor.col < leader_len)\n\t\t    break;\n\t\tif (has_format_option(FO_ONE_LETTER))\n\t\t{\n\t\t    // do not break after one-letter words\n\t\t    if (curwin->w_cursor.col == 0)\n\t\t\tbreak;\t// one-letter word at begin\n\t\t    // do not break \"#a b\" when 'tw' is 2\n\t\t    if (curwin->w_cursor.col <= leader_len)\n\t\t\tbreak;\n\t\t    col = curwin->w_cursor.col;\n\t\t    dec_cursor();\n\t\t    cc = gchar_cursor();\n\n\t\t    if (WHITECHAR(cc))\n\t\t\tcontinue;\t// one-letter, continue\n\t\t    curwin->w_cursor.col = col;\n\t\t}\n\n\t\tinc_cursor();\n\n\t\tend_foundcol = end_col + 1;\n\t\tfoundcol = curwin->w_cursor.col;\n\t\tif (curwin->w_cursor.col <= (colnr_T)wantcol)\n\t\t    break;\n\t    }\n\t    else if ((cc >= 0x100 || !utf_allow_break_before(cc))\n\t\t\t\t\t\t\t       && fo_multibyte)\n\t    {\n\t\tint ncc;\n\t\tint allow_break;\n\n\t\t// Break after or before a multi-byte character.\n\t\tif (curwin->w_cursor.col != startcol)\n\t\t{\n\t\t    // Don't break until after the comment leader\n\t\t    if (curwin->w_cursor.col < leader_len)\n\t\t\tbreak;\n\t\t    col = curwin->w_cursor.col;\n\t\t    inc_cursor();\n\t\t    ncc = gchar_cursor();\n\n\t\t    allow_break =\n\t\t\t(enc_utf8 && utf_allow_break(cc, ncc))\n\t\t\t|| enc_dbcs;\n\n\t\t    // If we have already checked this position, skip!\n\t\t    if (curwin->w_cursor.col != skip_pos && allow_break)\n\t\t    {\n\t\t\tfoundcol = curwin->w_cursor.col;\n\t\t\tend_foundcol = foundcol;\n\t\t\tif (curwin->w_cursor.col <= (colnr_T)wantcol)\n\t\t\t    break;\n\t\t    }\n\t\t    curwin->w_cursor.col = col;\n\t\t}\n\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\n\t\tncc = cc;\n\t\tcol = curwin->w_cursor.col;\n\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\n\t\tif (WHITECHAR(cc))\n\t\t    continue;\t\t// break with space\n\t\t// Don't break until after the comment leader.\n\t\tif (curwin->w_cursor.col < leader_len)\n\t\t    break;\n\n\t\tcurwin->w_cursor.col = col;\n\t\tskip_pos = curwin->w_cursor.col;\n\n\t\tallow_break =\n\t\t    (enc_utf8 && utf_allow_break(cc, ncc))\n\t\t    || enc_dbcs;\n\n\t\t// Must handle this to respect line break prohibition.\n\t\tif (allow_break)\n\t\t{\n\t\t    foundcol = curwin->w_cursor.col;\n\t\t    end_foundcol = foundcol;\n\t\t}\n\t\tif (curwin->w_cursor.col <= (colnr_T)wantcol)\n\t\t{\n\t\t    int ncc_allow_break =\n\t\t\t (enc_utf8 && utf_allow_break_before(ncc)) || enc_dbcs;\n\n\t\t    if (allow_break)\n\t\t\tbreak;\n\t\t    if (!ncc_allow_break && !fo_rigor_tw)\n\t\t    {\n\t\t\t// Enable at most 1 punct hang outside of textwidth.\n\t\t\tif (curwin->w_cursor.col == startcol)\n\t\t\t{\n\t\t\t    // We are inserting a non-breakable char, postpone\n\t\t\t    // line break check to next insert.\n\t\t\t    end_foundcol = foundcol = 0;\n\t\t\t    break;\n\t\t\t}\n\n\t\t\t// Neither cc nor ncc is NUL if we are here, so\n\t\t\t// it's safe to inc_cursor.\n\t\t\tcol = curwin->w_cursor.col;\n\n\t\t\tinc_cursor();\n\t\t\tcc  = ncc;\n\t\t\tncc = gchar_cursor();\n\t\t\t// handle insert\n\t\t\tncc = (ncc != NUL) ? ncc : c;\n\n\t\t\tallow_break =\n\t\t\t\t(enc_utf8 && utf_allow_break(cc, ncc))\n\t\t\t\t|| enc_dbcs;\n\n\t\t\tif (allow_break)\n\t\t\t{\n\t\t\t    // Break only when we are not at end of line.\n\t\t\t    end_foundcol = foundcol =\n\t\t\t\t      ncc == NUL? 0 : curwin->w_cursor.col;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcurwin->w_cursor.col = col;\n\t\t    }\n\t\t}\n\t    }\n\t    if (curwin->w_cursor.col == 0)\n\t\tbreak;\n\t    dec_cursor();\n\t}\n\n\tif (foundcol == 0)\t\t// no spaces, cannot break line\n\t{\n\t    curwin->w_cursor.col = startcol;\n\t    break;\n\t}\n\n\t// Going to break the line, remove any \"$\" now.\n\tundisplay_dollar();\n\n\t// Offset between cursor position and line break is used by replace\n\t// stack functions.  MODE_VREPLACE does not use this, and backspaces\n\t// over the text instead.\n\tif (State & VREPLACE_FLAG)\n\t    orig_col = startcol;\t// Will start backspacing from here\n\telse\n\t    replace_offset = startcol - end_foundcol;\n\n\t// adjust startcol for spaces that will be deleted and\n\t// characters that will remain on top line\n\tcurwin->w_cursor.col = foundcol;\n\twhile ((cc = gchar_cursor(), WHITECHAR(cc))\n\t\t    && (!fo_white_par || curwin->w_cursor.col < startcol))\n\t    inc_cursor();\n\tstartcol -= curwin->w_cursor.col;\n\tif (startcol < 0)\n\t    startcol = 0;\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // In MODE_VREPLACE state, we will backspace over the text to be\n\t    // wrapped, so save a copy now to put on the next line.\n\t    saved_text = vim_strsave(ml_get_cursor());\n\t    curwin->w_cursor.col = orig_col;\n\t    if (saved_text == NULL)\n\t\tbreak;\t// Can't do it, out of memory\n\t    saved_text[startcol] = NUL;\n\n\t    // Backspace over characters that will move to the next line\n\t    if (!fo_white_par)\n\t\tbackspace_until_column(foundcol);\n\t}\n\telse\n\t{\n\t    // put cursor after pos. to break line\n\t    if (!fo_white_par)\n\t\tcurwin->w_cursor.col = foundcol;\n\t}\n\n\t// Split the line just before the margin.\n\t// Only insert/delete lines, but don't really redraw the window.\n\topen_line(FORWARD, OPENLINE_DELSPACES + OPENLINE_MARKFIX\n\t\t+ (fo_white_par ? OPENLINE_KEEPTRAIL : 0)\n\t\t+ (do_comments ? OPENLINE_DO_COM : 0)\n\t\t+ OPENLINE_FORMAT\n\t\t+ ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)\n\t\t, ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent),\n\t\t&did_do_comment);\n\tif (!(flags & INSCHAR_COM_LIST))\n\t    old_indent = 0;\n\n\t// If a comment leader was inserted, may also do this on a following\n\t// line.\n\tif (did_do_comment)\n\t    no_leader = FALSE;\n\n\treplace_offset = 0;\n\tif (first_line)\n\t{\n\t    if (!(flags & INSCHAR_COM_LIST))\n\t    {\n\t\t// This section is for auto-wrap of numeric lists.  When not\n\t\t// in insert mode (i.e. format_lines()), the INSCHAR_COM_LIST\n\t\t// flag will be set and open_line() will handle it (as seen\n\t\t// above).  The code here (and in get_number_indent()) will\n\t\t// recognize comments if needed...\n\t\tif (second_indent < 0 && has_format_option(FO_Q_NUMBER))\n\t\t    second_indent =\n\t\t\t\t get_number_indent(curwin->w_cursor.lnum - 1);\n\t\tif (second_indent >= 0)\n\t\t{\n\t\t    if (State & VREPLACE_FLAG)\n\t\t\tchange_indent(INDENT_SET, second_indent,\n\t\t\t\t\t\t\t    FALSE, NUL, TRUE);\n\t\t    else\n\t\t\tif (leader_len > 0 && second_indent - leader_len > 0)\n\t\t    {\n\t\t\tint i;\n\t\t\tint padding = second_indent - leader_len;\n\n\t\t\t// We started at the first_line of a numbered list\n\t\t\t// that has a comment.  the open_line() function has\n\t\t\t// inserted the proper comment leader and positioned\n\t\t\t// the cursor at the end of the split line.  Now we\n\t\t\t// add the additional whitespace needed after the\n\t\t\t// comment leader for the numbered list.\n\t\t\tfor (i = 0; i < padding; i++)\n\t\t\t    ins_str((char_u *)\" \");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t(void)set_indent(second_indent, SIN_CHANGED);\n\t\t    }\n\t\t}\n\t    }\n\t    first_line = FALSE;\n\t}\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // In MODE_VREPLACE state we have backspaced over the text to be\n\t    // moved, now we re-insert it into the new line.\n\t    ins_bytes(saved_text);\n\t    vim_free(saved_text);\n\t}\n\telse\n\t{\n\t    // Check if cursor is not past the NUL off the line, cindent\n\t    // may have added or removed indent.\n\t    curwin->w_cursor.col += startcol;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\n\thaveto_redraw = TRUE;\n\tset_can_cindent(TRUE);\n\t// moved the cursor, don't autoindent or cindent now\n\tdid_ai = FALSE;\n\tdid_si = FALSE;\n\tcan_si = FALSE;\n\tcan_si_back = FALSE;\n\tline_breakcheck();\n    }\n\n    if (save_char != NUL)\t\t// put back space after cursor\n\tpchar_cursor(save_char);\n\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = has_lbr;\n#endif\n    if (!format_only && haveto_redraw)\n    {\n\tupdate_topline();\n\tredraw_curbuf_later(UPD_VALID);\n    }\n}\n\n/*\n * Blank lines, and lines containing only the comment leader, are left\n * untouched by the formatting.  The function returns TRUE in this\n * case.  It also returns TRUE when a line starts with the end of a comment\n * ('e' in comment flags), so that this line is skipped, and not joined to the\n * previous line.  A new paragraph starts after a blank line, or when the\n * comment leader changes -- webb.\n */\n    static int\nfmt_check_par(\n    linenr_T\tlnum,\n    int\t\t*leader_len,\n    char_u\t**leader_flags,\n    int\t\tdo_comments)\n{\n    char_u\t*flags = NULL;\t    // init for GCC\n    char_u\t*ptr;\n\n    ptr = ml_get(lnum);\n    if (do_comments)\n\t*leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);\n    else\n\t*leader_len = 0;\n\n    if (*leader_len > 0)\n    {\n\t// Search for 'e' flag in comment leader flags.\n\tflags = *leader_flags;\n\twhile (*flags && *flags != ':' && *flags != COM_END)\n\t    ++flags;\n    }\n\n    return (*skipwhite(ptr + *leader_len) == NUL\n\t    || (*leader_len > 0 && *flags == COM_END)\n\t    || startPS(lnum, NUL, FALSE));\n}\n\n/*\n * Return TRUE if line \"lnum\" ends in a white character.\n */\n    static int\nends_in_white(linenr_T lnum)\n{\n    char_u\t*s = ml_get(lnum);\n    size_t\tl;\n\n    if (*s == NUL)\n\treturn FALSE;\n    // Don't use STRLEN() inside VIM_ISWHITE(), SAS/C complains: \"macro\n    // invocation may call function multiple times\".\n    l = STRLEN(s) - 1;\n    return VIM_ISWHITE(s[l]);\n}\n\n/*\n * Return TRUE if the two comment leaders given are the same.  \"lnum\" is\n * the first line.  White-space is ignored.  Note that the whole of\n * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb\n */\n    static int\nsame_leader(\n    linenr_T lnum,\n    int\t    leader1_len,\n    char_u  *leader1_flags,\n    int\t    leader2_len,\n    char_u  *leader2_flags)\n{\n    int\t    idx1 = 0, idx2 = 0;\n    char_u  *p;\n    char_u  *line1;\n    char_u  *line2;\n\n    if (leader1_len == 0)\n\treturn (leader2_len == 0);\n\n    char_u  *lnum_line = NULL;\n    int\t    line_len = 0;\n\n    // If first leader has 'f' flag, the lines can be joined only if the\n    // second line does not have a leader.\n    // If first leader has 'e' flag, the lines can never be joined.\n    // If first leader has 's' flag, the lines can only be joined if there is\n    // some text after it and the second line has the 'm' flag.\n    if (leader1_flags != NULL)\n    {\n\tfor (p = leader1_flags; *p && *p != ':'; ++p)\n\t{\n\t    if (*p == COM_FIRST)\n\t\treturn (leader2_len == 0);\n\t    if (*p == COM_END)\n\t\treturn FALSE;\n\t    if (*p == COM_START)\n\t    {\n\t\tif (lnum_line == NULL)\n\t\t{\n\t\t    lnum_line = ml_get(lnum);\n\t\t    line_len = (int)STRLEN(lnum_line);\n\t\t}\n\t\tif (line_len <= leader1_len)\n\t\t    return FALSE;\n\t\tif (leader2_flags == NULL || leader2_len == 0)\n\t\t    return FALSE;\n\t\tfor (p = leader2_flags; *p && *p != ':'; ++p)\n\t\t    if (*p == COM_MIDDLE)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // Get current line and next line, compare the leaders.\n    // The first line has to be saved, only one line can be locked at a time.\n    line1 = vim_strsave(ml_get(lnum));\n    if (line1 != NULL)\n    {\n\tfor (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1)\n\t    ;\n\tline2 = ml_get(lnum + 1);\n\tfor (idx2 = 0; idx2 < leader2_len; ++idx2)\n\t{\n\t    if (!VIM_ISWHITE(line2[idx2]))\n\t    {\n\t\tif (line1[idx1++] != line2[idx2])\n\t\t    break;\n\t    }\n\t    else\n\t\twhile (VIM_ISWHITE(line1[idx1]))\n\t\t    ++idx1;\n\t}\n\tvim_free(line1);\n    }\n    return (idx2 == leader2_len && idx1 == leader1_len);\n}\n\n/*\n * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the\n * previous line is in the same paragraph.  Used for auto-formatting.\n */\n    static int\nparagraph_start(linenr_T lnum)\n{\n    char_u\t*p;\n    int\t\tleader_len = 0;\t\t// leader len of current line\n    char_u\t*leader_flags = NULL;\t// flags for leader of current line\n    int\t\tnext_leader_len;\t// leader len of next line\n    char_u\t*next_leader_flags;\t// flags for leader of next line\n    int\t\tdo_comments;\t\t// format comments\n\n    if (lnum <= 1)\n\treturn TRUE;\t\t// start of the file\n\n    p = ml_get(lnum - 1);\n    if (*p == NUL)\n\treturn TRUE;\t\t// after empty line\n\n    do_comments = has_format_option(FO_Q_COMS);\n    if (fmt_check_par(lnum - 1, &leader_len, &leader_flags, do_comments))\n\treturn TRUE;\t\t// after non-paragraph line\n\n    if (fmt_check_par(lnum, &next_leader_len, &next_leader_flags, do_comments))\n\treturn TRUE;\t\t// \"lnum\" is not a paragraph line\n\n    if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))\n\treturn TRUE;\t\t// missing trailing space in previous line.\n\n    if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))\n\treturn TRUE;\t\t// numbered item starts in \"lnum\".\n\n    if (!same_leader(lnum - 1, leader_len, leader_flags,\n\t\t\t\t\t  next_leader_len, next_leader_flags))\n\treturn TRUE;\t\t// change of comment leader.\n\n    return FALSE;\n}\n\n/*\n * Called after inserting or deleting text: When 'formatoptions' includes the\n * 'a' flag format from the current line until the end of the paragraph.\n * Keep the cursor at the same position relative to the text.\n * The caller must have saved the cursor line for undo, following ones will be\n * saved here.\n */\n    void\nauto_format(\n    int\t\ttrailblank,\t// when TRUE also format with trailing blank\n    int\t\tprev_line)\t// may start in previous line\n{\n    pos_T\tpos;\n    colnr_T\tlen;\n    char_u\t*old;\n    char_u\t*new, *pnew;\n    int\t\twasatend;\n    int\t\tcc;\n\n    if (!has_format_option(FO_AUTO))\n\treturn;\n\n    pos = curwin->w_cursor;\n    old = ml_get_curline();\n\n    // may remove added space\n    check_auto_format(FALSE);\n\n    // Don't format in Insert mode when the cursor is on a trailing blank, the\n    // user might insert normal text next.  Also skip formatting when \"1\" is\n    // in 'formatoptions' and there is a single character before the cursor.\n    // Otherwise the line would be broken and when typing another non-white\n    // next they are not joined back together.\n    wasatend = (pos.col == (colnr_T)STRLEN(old));\n    if (*old != NUL && !trailblank && wasatend)\n    {\n\tdec_cursor();\n\tcc = gchar_cursor();\n\tif (!WHITECHAR(cc) && curwin->w_cursor.col > 0\n\t\t\t\t\t  && has_format_option(FO_ONE_LETTER))\n\t    dec_cursor();\n\tcc = gchar_cursor();\n\tif (WHITECHAR(cc))\n\t{\n\t    curwin->w_cursor = pos;\n\t    return;\n\t}\n\tcurwin->w_cursor = pos;\n    }\n\n    // With the 'c' flag in 'formatoptions' and 't' missing: only format\n    // comments.\n    if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)\n\t\t\t\t&& get_leader_len(old, NULL, FALSE, TRUE) == 0)\n\treturn;\n\n    // May start formatting in a previous line, so that after \"x\" a word is\n    // moved to the previous line if it fits there now.  Only when this is not\n    // the start of a paragraph.\n    if (prev_line && !paragraph_start(curwin->w_cursor.lnum))\n    {\n\t--curwin->w_cursor.lnum;\n\tif (u_save_cursor() == FAIL)\n\t    return;\n    }\n\n    // Do the formatting and restore the cursor position.  \"saved_cursor\" will\n    // be adjusted for the text formatting.\n    saved_cursor = pos;\n    format_lines((linenr_T)-1, FALSE);\n    curwin->w_cursor = saved_cursor;\n    saved_cursor.lnum = 0;\n\n    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n    {\n\t// \"cannot happen\"\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n    else\n\tcheck_cursor_col();\n\n    // Insert mode: If the cursor is now after the end of the line while it\n    // previously wasn't, the line was broken.  Because of the rule above we\n    // need to add a space when 'w' is in 'formatoptions' to keep a paragraph\n    // formatted.\n    if (!wasatend && has_format_option(FO_WHITE_PAR))\n    {\n\tnew = ml_get_curline();\n\tlen = (colnr_T)STRLEN(new);\n\tif (curwin->w_cursor.col == len)\n\t{\n\t    pnew = vim_strnsave(new, len + 2);\n\t    pnew[len] = ' ';\n\t    pnew[len + 1] = NUL;\n\t    ml_replace(curwin->w_cursor.lnum, pnew, FALSE);\n\t    // remove the space later\n\t    did_add_space = TRUE;\n\t}\n\telse\n\t    // may remove added space\n\t    check_auto_format(FALSE);\n    }\n\n    check_cursor();\n}\n\n/*\n * When an extra space was added to continue a paragraph for auto-formatting,\n * delete it now.  The space must be under the cursor, just after the insert\n * position.\n */\n    void\ncheck_auto_format(\n    int\t\tend_insert)\t    // TRUE when ending Insert mode\n{\n    int\t\tc = ' ';\n    int\t\tcc;\n\n    if (did_add_space)\n    {\n\tcc = gchar_cursor();\n\tif (!WHITECHAR(cc))\n\t    // Somehow the space was removed already.\n\t    did_add_space = FALSE;\n\telse\n\t{\n\t    if (!end_insert)\n\t    {\n\t\tinc_cursor();\n\t\tc = gchar_cursor();\n\t\tdec_cursor();\n\t    }\n\t    if (c != NUL)\n\t    {\n\t\t// The space is no longer at the end of the line, delete it.\n\t\tdel_char(FALSE);\n\t\tdid_add_space = FALSE;\n\t    }\n\t}\n    }\n}\n\n/*\n * Find out textwidth to be used for formatting:\n *\tif 'textwidth' option is set, use it\n *\telse if 'wrapmargin' option is set, use curwin->w_width - 'wrapmargin'\n *\tif invalid value, use 0.\n *\tSet default to window width (maximum 79) for \"gq\" operator.\n */\n    int\ncomp_textwidth(\n    int\t\tff)\t// force formatting (for \"gq\" command)\n{\n    int\t\ttextwidth;\n\n    textwidth = curbuf->b_p_tw;\n    if (textwidth == 0 && curbuf->b_p_wm)\n    {\n\t// The width is the window width minus 'wrapmargin' minus all the\n\t// things that add to the margin.\n\ttextwidth = curwin->w_width - curbuf->b_p_wm;\n\tif (cmdwin_type != 0)\n\t    textwidth -= 1;\n#ifdef FEAT_FOLDING\n\ttextwidth -= curwin->w_p_fdc;\n#endif\n#ifdef FEAT_SIGNS\n\tif (signcolumn_on(curwin))\n\t    textwidth -= 1;\n#endif\n\tif (curwin->w_p_nu || curwin->w_p_rnu)\n\t    textwidth -= 8;\n    }\n    if (textwidth < 0)\n\ttextwidth = 0;\n    if (ff && textwidth == 0)\n    {\n\ttextwidth = curwin->w_width - 1;\n\tif (textwidth > 79)\n\t    textwidth = 79;\n    }\n    return textwidth;\n}\n\n/*\n * Implementation of the format operator 'gq'.\n */\n    void\nop_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t// keep cursor on same text char\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n\n    // Place the cursor where the \"gq\" or \"gw\" command was given, so that \"u\"\n    // can put it back there.\n    curwin->w_cursor = oap->cursor_start;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n\n    if (oap->is_VIsual)\n\t// When there is no change: need to remove the Visual selection\n\tredraw_curbuf_later(UPD_INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t// Set '[ mark at the start of the formatted area\n\tcurbuf->b_op_start = oap->start;\n\n    // For \"gw\" remember the cursor position and put it back below (adjusted\n    // for joined and split lines).\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n\n    format_lines(oap->line_count, keep_cursor);\n\n    // Leave the cursor at the first non-blank of the last formatted line.\n    // If the cursor was moved one line back (e.g. with \"Q}\") go to the next\n    // line, so \".\" will do the next lines.\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t// put '] mark on the end of the formatted area\n\tcurbuf->b_op_end = curwin->w_cursor;\n\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n\n\t// formatting may have made the cursor position invalid\n\tcheck_cursor();\n    }\n\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\t// When lines have been inserted or deleted, adjust the end of\n\t\t// the Visual area to be redrawn.\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Implementation of the format operator 'gq' for when using 'formatexpr'.\n */\n    void\nop_formatexpr(oparg_T *oap)\n{\n    if (oap->is_VIsual)\n\t// When there is no change: need to remove the Visual selection\n\tredraw_curbuf_later(UPD_INVERTED);\n\n    if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)\n\t// As documented: when 'formatexpr' returns non-zero fall back to\n\t// internal formatting.\n\top_format(oap, FALSE);\n}\n\n    int\nfex_format(\n    linenr_T\tlnum,\n    long\tcount,\n    int\t\tc)\t// character to be inserted\n{\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"formatexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n    int\t\tr;\n    char_u\t*fex;\n    sctx_T\tsave_sctx = current_sctx;\n\n    // Set v:lnum to the first line number and v:count to the number of lines.\n    // Set v:char to the character to be inserted (can be NUL).\n    set_vim_var_nr(VV_LNUM, lnum);\n    set_vim_var_nr(VV_COUNT, count);\n    set_vim_var_char(c);\n\n    // Make a copy, the option could be changed while calling it.\n    fex = vim_strsave(curbuf->b_p_fex);\n    if (fex == NULL)\n\treturn 0;\n    current_sctx = curbuf->b_p_script_ctx[BV_FEX];\n\n    // Evaluate the function.\n    if (use_sandbox)\n\t++sandbox;\n    r = (int)eval_to_number(fex, TRUE);\n    if (use_sandbox)\n\t--sandbox;\n\n    set_vim_var_string(VV_CHAR, NULL, -1);\n    vim_free(fex);\n    current_sctx = save_sctx;\n\n    return r;\n}\n#endif\n\n/*\n * Format \"line_count\" lines, starting at the cursor position.\n * When \"line_count\" is negative, format until the end of the paragraph.\n * Lines after the cursor line are saved for undo, caller must have saved the\n * first line.\n */\n    void\nformat_lines(\n    linenr_T\tline_count,\n    int\t\tavoid_fex)\t\t// don't use 'formatexpr'\n{\n    int\t\tmax_len;\n    int\t\tis_not_par;\t\t// current line not part of parag.\n    int\t\tnext_is_not_par;\t// next line not part of paragraph\n    int\t\tis_end_par;\t\t// at end of paragraph\n    int\t\tprev_is_end_par = FALSE;// prev. line not part of parag.\n    int\t\tnext_is_start_par = FALSE;\n    int\t\tleader_len = 0;\t\t// leader len of current line\n    int\t\tnext_leader_len;\t// leader len of next line\n    char_u\t*leader_flags = NULL;\t// flags for leader of current line\n    char_u\t*next_leader_flags = NULL; // flags for leader of next line\n    int\t\tdo_comments;\t\t// format comments\n    int\t\tdo_comments_list = 0;\t// format comments with 'n' or '2'\n    int\t\tadvance = TRUE;\n    int\t\tsecond_indent = -1;\t// indent for second line (comment\n\t\t\t\t\t// aware)\n    int\t\tdo_second_indent;\n    int\t\tdo_number_indent;\n    int\t\tdo_trail_white;\n    int\t\tfirst_par_line = TRUE;\n    int\t\tsmd_save;\n    long\tcount;\n    int\t\tneed_set_indent = TRUE;\t// set indent of next paragraph\n    linenr_T\tfirst_line = curwin->w_cursor.lnum;\n    int\t\tforce_format = FALSE;\n    int\t\told_State = State;\n\n    // length of a line to force formatting: 3 * 'tw'\n    max_len = comp_textwidth(TRUE) * 3;\n\n    // check for 'q', '2' and '1' in 'formatoptions'\n    do_comments = has_format_option(FO_Q_COMS);\n    do_second_indent = has_format_option(FO_Q_SECOND);\n    do_number_indent = has_format_option(FO_Q_NUMBER);\n    do_trail_white = has_format_option(FO_WHITE_PAR);\n\n    // Get info about the previous and current line.\n    if (curwin->w_cursor.lnum > 1)\n\tis_not_par = fmt_check_par(curwin->w_cursor.lnum - 1\n\t\t\t\t, &leader_len, &leader_flags, do_comments);\n    else\n\tis_not_par = TRUE;\n    next_is_not_par = fmt_check_par(curwin->w_cursor.lnum\n\t\t\t  , &next_leader_len, &next_leader_flags, do_comments);\n    is_end_par = (is_not_par || next_is_not_par);\n    if (!is_end_par && do_trail_white)\n\tis_end_par = !ends_in_white(curwin->w_cursor.lnum - 1);\n\n    curwin->w_cursor.lnum--;\n    for (count = line_count; count != 0 && !got_int; --count)\n    {\n\t// Advance to next paragraph.\n\tif (advance)\n\t{\n\t    curwin->w_cursor.lnum++;\n\t    prev_is_end_par = is_end_par;\n\t    is_not_par = next_is_not_par;\n\t    leader_len = next_leader_len;\n\t    leader_flags = next_leader_flags;\n\t}\n\n\t// The last line to be formatted.\n\tif (count == 1 || curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    next_is_not_par = TRUE;\n\t    next_leader_len = 0;\n\t    next_leader_flags = NULL;\n\t}\n\telse\n\t{\n\t    next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1\n\t\t\t  , &next_leader_len, &next_leader_flags, do_comments);\n\t    if (do_number_indent)\n\t\tnext_is_start_par =\n\t\t\t   (get_number_indent(curwin->w_cursor.lnum + 1) > 0);\n\t}\n\tadvance = TRUE;\n\tis_end_par = (is_not_par || next_is_not_par || next_is_start_par);\n\tif (!is_end_par && do_trail_white)\n\t    is_end_par = !ends_in_white(curwin->w_cursor.lnum);\n\n\t// Skip lines that are not in a paragraph.\n\tif (is_not_par)\n\t{\n\t    if (line_count < 0)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    // For the first line of a paragraph, check indent of second line.\n\t    // Don't do this for comments and empty lines.\n\t    if (first_par_line\n\t\t    && (do_second_indent || do_number_indent)\n\t\t    && prev_is_end_par\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (do_second_indent && !LINEEMPTY(curwin->w_cursor.lnum + 1))\n\t\t{\n\t\t    if (leader_len == 0 && next_leader_len == 0)\n\t\t    {\n\t\t\t// no comment found\n\t\t\tsecond_indent =\n\t\t\t\t   get_indent_lnum(curwin->w_cursor.lnum + 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsecond_indent = next_leader_len;\n\t\t\tdo_comments_list = 1;\n\t\t    }\n\t\t}\n\t\telse if (do_number_indent)\n\t\t{\n\t\t    if (leader_len == 0 && next_leader_len == 0)\n\t\t    {\n\t\t\t// no comment found\n\t\t\tsecond_indent =\n\t\t\t\t     get_number_indent(curwin->w_cursor.lnum);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// get_number_indent() is now \"comment aware\"...\n\t\t\tsecond_indent =\n\t\t\t\t     get_number_indent(curwin->w_cursor.lnum);\n\t\t\tdo_comments_list = 1;\n\t\t    }\n\t\t}\n\t    }\n\n\t    // When the comment leader changes, it's the end of the paragraph.\n\t    if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count\n\t\t    || !same_leader(curwin->w_cursor.lnum,\n\t\t\t\t\tleader_len, leader_flags,\n\t\t\t\t\t   next_leader_len, next_leader_flags))\n\t    {\n\t\t// Special case: If the next line starts with a line comment\n\t\t// and this line has a line comment after some text, the\n\t\t// paragraph doesn't really end.\n\t\tif (next_leader_flags == NULL\n\t\t\t|| STRNCMP(next_leader_flags, \"://\", 3) != 0\n\t\t\t|| check_linecomment(ml_get_curline()) == MAXCOL)\n\t\tis_end_par = TRUE;\n\t    }\n\n\t    // If we have got to the end of a paragraph, or the line is\n\t    // getting long, format it.\n\t    if (is_end_par || force_format)\n\t    {\n\t\tif (need_set_indent)\n\t\t{\n\t\t    int\t\tindent = 0; // amount of indent needed\n\n\t\t    // Replace indent in first line of a paragraph with minimal\n\t\t    // number of tabs and spaces, according to current options.\n\t\t    // For the very first formatted line keep the current\n\t\t    // indent.\n\t\t    if (curwin->w_cursor.lnum == first_line)\n\t\t\tindent = get_indent();\n\t\t    else if (curbuf->b_p_lisp)\n\t\t\tindent = get_lisp_indent();\n\t\t    else\n\t\t    {\n\t\t\tif (cindent_on())\n\t\t\t{\n\t\t\t    indent =\n# ifdef FEAT_EVAL\n\t\t\t\t *curbuf->b_p_inde != NUL ? get_expr_indent() :\n# endif\n\t\t\t\t get_c_indent();\n\t\t\t}\n\t\t\telse\n\t\t\t    indent = get_indent();\n\t\t    }\n\t\t    (void)set_indent(indent, SIN_CHANGED);\n\t\t}\n\n\t\t// put cursor on last non-space\n\t\tState = MODE_NORMAL;\t// don't go past end-of-line\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\twhile (curwin->w_cursor.col && vim_isspace(gchar_cursor()))\n\t\t    dec_cursor();\n\n\t\t// do the formatting, without 'showmode'\n\t\tState = MODE_INSERT;\t// for open_line()\n\t\tsmd_save = p_smd;\n\t\tp_smd = FALSE;\n\t\tinsertchar(NUL, INSCHAR_FORMAT\n\t\t\t+ (do_comments ? INSCHAR_DO_COM : 0)\n\t\t\t+ (do_comments && do_comments_list\n\t\t\t\t\t\t       ? INSCHAR_COM_LIST : 0)\n\t\t\t+ (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);\n\t\tState = old_State;\n\t\tp_smd = smd_save;\n\t\tsecond_indent = -1;\n\t\t// at end of par.: need to set indent of next par.\n\t\tneed_set_indent = is_end_par;\n\t\tif (is_end_par)\n\t\t{\n\t\t    // When called with a negative line count, break at the\n\t\t    // end of the paragraph.\n\t\t    if (line_count < 0)\n\t\t\tbreak;\n\t\t    first_par_line = TRUE;\n\t\t}\n\t\tforce_format = FALSE;\n\t    }\n\n\t    // When still in same paragraph, join the lines together.  But\n\t    // first delete the leader from the second line.\n\t    if (!is_end_par)\n\t    {\n\t\tadvance = FALSE;\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (line_count < 0 && u_save_cursor() == FAIL)\n\t\t    break;\n\t\tif (next_leader_len > 0)\n\t\t{\n\t\t    (void)del_bytes((long)next_leader_len, FALSE, FALSE);\n\t\t    mark_col_adjust(curwin->w_cursor.lnum, (colnr_T)0, 0L,\n\t\t\t\t\t\t    (long)-next_leader_len, 0);\n\t\t}\n\t\telse if (second_indent > 0)  // the \"leader\" for FO_Q_SECOND\n\t\t{\n\t\t    int indent = getwhitecols_curline();\n\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t(void)del_bytes(indent, FALSE, FALSE);\n\t\t\tmark_col_adjust(curwin->w_cursor.lnum,\n\t\t\t\t\t     (colnr_T)0, 0L, (long)-indent, 0);\n\t\t    }\n\t\t}\n\t\tcurwin->w_cursor.lnum--;\n\t\tif (do_join(2, TRUE, FALSE, FALSE, FALSE) == FAIL)\n\t\t{\n\t\t    beep_flush();\n\t\t    break;\n\t\t}\n\t\tfirst_par_line = FALSE;\n\t\t// If the line is getting long, format it next time\n\t\tif (STRLEN(ml_get_curline()) > (size_t)max_len)\n\t\t    force_format = TRUE;\n\t\telse\n\t\t    force_format = FALSE;\n\t    }\n\t}\n\tline_breakcheck();\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/textformat.c", "src/version.c"], "buggy_code_start_loc": [542, 697], "buggy_code_end_loc": [559, 697], "fixing_code_start_loc": [543, 698], "fixing_code_end_loc": [567, 700], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1225.", "other": {"cve": {"id": "CVE-2023-0433", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-21T15:15:10.153", "lastModified": "2023-03-28T05:15:14.137", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1225."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1225", "matchCriteriaId": "220F342C-2B9D-4371-BD43-BED77B7E99BA"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Mar/17", "source": "security@huntr.dev"}, {"url": "http://seclists.org/fulldisclosure/2023/Mar/18", "source": "security@huntr.dev"}, {"url": "http://seclists.org/fulldisclosure/2023/Mar/21", "source": "security@huntr.dev"}, {"url": "https://github.com/vim/vim/commit/11977f917506d950b7e0cae558bd9189260b253b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ae933869-a1ec-402a-bbea-d51764c6618e", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4EX6N2DB75A73MQGVW3CS4VTNPAYVM2M/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PZWIJBSQX53P7DHV77KRXJIXA4GH7XHC/", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213670", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213675", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213677", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/11977f917506d950b7e0cae558bd9189260b253b"}}