{"buggy_code": ["SRCS = mongoose.c test/unit_test.c test/packed_fs.c\nHDRS = $(wildcard src/*.h)\nDEFS ?= -DMG_MAX_HTTP_HEADERS=7 -DMG_ENABLE_LINES -DMG_ENABLE_PACKED_FS=1\nWARN ?= -W -Wall -Werror -Wshadow -Wdouble-promotion -fno-common -Wconversion -Wundef\nOPTS ?= -O3 -g3\nINCS ?= -Isrc -I.\nCFLAGS ?= $(OPTS) $(WARN) $(INCS) $(DEFS) $(TFLAGS) $(EXTRA)\nSSL ?= MBEDTLS\nCWD ?= $(realpath $(CURDIR))\nDOCKER ?= docker run --rm -e Tmp=. -e WINEDEBUG=-all -v $(CWD):$(CWD) -w $(CWD)\nVCFLAGS = /nologo /W3 /O2 /I. $(DEFS) $(TFLAGS)\nIPV6 ?= 1\nASAN_OPTIONS ?=\nEXAMPLES := $(wildcard examples/*)\nPREFIX ?= /usr/local\nVERSION ?= $(shell cut -d'\"' -f2 src/version.h)\n.PHONY: examples test\n\nifeq \"$(SSL)\" \"MBEDTLS\"\nMBEDTLS ?= /usr\nCFLAGS  += -DMG_ENABLE_MBEDTLS=1 -I$(MBEDTLS)/include -I/usr/include\nLDFLAGS ?= -L$(MBEDTLS)/lib -lmbedtls -lmbedcrypto -lmbedx509\nendif\nifeq \"$(SSL)\" \"OPENSSL\"\nOPENSSL ?= /usr\nCFLAGS  += -DMG_ENABLE_OPENSSL=1 -I$(OPENSSL)/include\nLDFLAGS ?= -L$(OPENSSL)/lib -lssl -lcrypto\nendif\n\nall: mg_prefix unpacked test test++ arm examples vc98 vc2017 mingw mingw++ linux linux++ fuzz\n\nexamples:\n\t@for X in $(EXAMPLES); do $(MAKE) -C $$X example || break; done\n\ntest/packed_fs.c: Makefile src/fs.h src/ssi.h test/fuzz.c test/data/a.txt\n\t$(CC) $(CFLAGS) test/pack.c -o pack\n\t./pack $? > $@\n\n# Check that all external (exported) symbols have \"mg_\" prefix\nmg_prefix: mongoose.c mongoose.h\n\t$(CC) mongoose.c $(CFLAGS) -c -o /tmp/x.o && nm /tmp/x.o | grep ' T' | grep -v 'mg_' ; test $$? = 1\n\n# C++ build\ntest++: CC = g++\ntest++: WARN += -Wno-shadow -Wno-missing-field-initializers -Wno-deprecated\ntest++: test\n\n# Make sure we can build from an unamalgamated sources\nunamalgamated: $(HDRS) Makefile test/packed_fs.c\n\t$(CC) src/*.c test/packed_fs.c test/unit_test.c $(CFLAGS) $(LDFLAGS) -g -o unit_test\n\nunpacked:\n\t$(CC) -I. mongoose.c test/unit_test.c -o unit_test\n\nfuzzer: mongoose.c mongoose.h Makefile test/fuzz.c\n\tclang mongoose.c test/fuzz.c $(WARN) $(INCS) -DMG_ENABLE_LINES -DMG_ENABLE_LOG=0 -fsanitize=fuzzer,signed-integer-overflow,address -g -o $@\n\nfuzz: fuzzer\n\t$(RUN) ./fuzzer\n\n# make CC=/usr/local/opt/llvm\\@8/bin/clang ASAN_OPTIONS=detect_leaks=1\ntest: CFLAGS += -DMG_ENABLE_IPV6=$(IPV6) -fsanitize=address#,undefined\ntest: mongoose.h  Makefile $(SRCS)\n\t$(CC) $(SRCS) $(CFLAGS) -coverage $(LDFLAGS) -g -o unit_test\n\tASAN_OPTIONS=$(ASAN_OPTIONS) $(RUN) ./unit_test\n\ncoverage: test\n\tgcov -l -n *.gcno | sed '/^$$/d' | sed 'N;s/\\n/ /'\n\tgcov mongoose.gcno >/dev/null\n\nupload-coverage: coverage\n\tcurl -s https://codecov.io/bash | /bin/bash\n\ninfer:\n\tinfer run -- cc test/unit_test.c -c -W -Wall -Werror -Isrc -I. -O2 -DMG_ENABLE_MBEDTLS=1 -DMG_ENABLE_LINES -I/usr/local/Cellar/mbedtls/2.23.0/include  -DMG_ENABLE_IPV6=1 -g -o /dev/null\n\narm: mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/armgcc arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb $(SRCS) test/mongoose_custom.c -Itest -DMG_ARCH=MG_ARCH_CUSTOM $(OPTS) $(WARN) $(INCS) $(DEFS) -o unit_test -nostartfiles --specs nosys.specs -e 0\n\nriscv: mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/riscv riscv-none-elf-gcc -march=rv32imc -mabi=ilp32 $(SRCS) test/mongoose_custom.c -Itest -DMG_ARCH=MG_ARCH_CUSTOM $(OPTS) $(WARN) $(INCS) $(DEFS) -o unit_test\n\n#vc98: VCFLAGS += -DMG_ENABLE_IPV6=1\nvc98: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/vc98 wine cl $(SRCS) $(VCFLAGS) ws2_32.lib /Fe$@.exe\n\t$(DOCKER) mdashnet/vc98 wine $@.exe\n\n#vc2017: VCFLAGS += -DMG_ENABLE_IPV6=1\nvc2017: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/vc2017 wine64 cl $(SRCS) $(VCFLAGS) ws2_32.lib /Fe$@.exe\n\t$(DOCKER) mdashnet/vc2017 wine64 $@.exe\n\nmingw: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/mingw i686-w64-mingw32-gcc $(SRCS) -W -Wall -Werror -I. $(DEFS) -lwsock32 -o test.exe\n\t$(DOCKER) mdashnet/vc98 wine test.exe\n\nmingw++: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/mingw i686-w64-mingw32-g++ $(SRCS) -W -Wall -Werror -I. $(DEFS) -lwsock32 -o test.exe\n  # Note: for some reason, a binary built with mingw g++, fails to run\n\n#linux: CFLAGS += -DMG_ENABLE_IPV6=$(IPV6)\nlinux: CFLAGS += -fsanitize=address,undefined\nlinux: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/cc2 gcc $(SRCS) $(CFLAGS) $(LDFLAGS) -o unit_test_gcc\n\t$(DOCKER) mdashnet/cc2 ./unit_test_gcc\n\nlinux++: CC = g++\nlinux++: WARN += -Wno-missing-field-initializers\nlinux++: linux\n\nlinux-libs: CFLAGS += -fPIC\nlinux-libs: mongoose.o\n\t$(CC) mongoose.o $(LDFLAGS) -shared -o libmongoose.so.$(VERSION)\n\t$(AR) rcs libmongoose.a mongoose.o\n\ninstall: linux-libs\n\tinstall -Dm644 libmongoose.a libmongoose.so.$(VERSION) $(DESTDIR)$(PREFIX)/lib\n\tln -s libmongoose.so.$(VERSION) $(DESTDIR)$(PREFIX)/lib/libmongoose.so\n\tinstall -Dm644 mongoose.h $(DESTDIR)$(PREFIX)/include/mongoose.h\n\nuninstall:\n\trm -rf $(DESTDIR)$(PREFIX)/lib/libmongoose.a $(DESTDIR)$(PREFIX)/lib/libmongoose.so.$(VERSION) $(DESTDIR)$(PREFIX)/include/mongoose.h $(DESTDIR)$(PREFIX)/lib/libmongoose.so\n\nmongoose.c: Makefile $(wildcard src/*)\n\t(cat src/license.h; echo; echo '#include \"mongoose.h\"' ; (for F in src/*.c ; do echo; echo '#ifdef MG_ENABLE_LINES'; echo \"#line 1 \\\"$$F\\\"\"; echo '#endif'; cat $$F | sed -e 's,#include \".*,,'; done))> $@\n\nmongoose.h: $(HDRS) Makefile\n\t(cat src/license.h; echo; echo '#ifndef MONGOOSE_H'; echo '#define MONGOOSE_H'; echo; cat src/version.h ; echo; echo '#ifdef __cplusplus'; echo 'extern \"C\" {'; echo '#endif'; cat src/arch.h src/arch_*.h src/config.h src/str.h src/log.h src/timer.h src/util.h src/fs.h src/url.h src/iobuf.h src/base64.h src/md5.h src/sha1.h src/event.h src/net.h src/http.h src/ssi.h src/tls.h src/tls_mbed.h src/tls_openssl.h src/ws.h src/sntp.h src/mqtt.h src/dns.h | sed -e 's,#include \".*,,' -e 's,^#pragma once,,'; echo; echo '#ifdef __cplusplus'; echo '}'; echo '#endif'; echo '#endif  // MONGOOSE_H')> $@\n\nclean:\n\trm -rf $(PROG) *.o *.dSYM unit_test* ut fuzzer *.gcov *.gcno *.gcda *.obj *.exe *.ilk *.pdb slow-unit* _CL_* infer-out data.txt crash-* test/packed_fs.c pack\n\t@for X in $(EXAMPLES); do $(MAKE) -C $$X clean; done\n", "// Copyright (c) 2004-2013 Sergey Lyubka\n// Copyright (c) 2013-2021 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.gnu.org/licenses/\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, as set out in https://www.mongoose.ws/licensing/\n\n#include \"mongoose.h\"\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/base64.c\"\n#endif\n\n#include <string.h>\n\nstatic int mg_b64idx(int c) {\n  if (c < 26) {\n    return c + 'A';\n  } else if (c < 52) {\n    return c - 26 + 'a';\n  } else if (c < 62) {\n    return c - 52 + '0';\n  } else {\n    return c == 62 ? '+' : '/';\n  }\n}\n\nstatic int mg_b64rev(int c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A';\n  } else if (c >= 'a' && c <= 'z') {\n    return c + 26 - 'a';\n  } else if (c >= '0' && c <= '9') {\n    return c + 52 - '0';\n  } else if (c == '+') {\n    return 62;\n  } else if (c == '/') {\n    return 63;\n  } else if (c == '=') {\n    return 64;\n  } else {\n    return -1;\n  }\n}\n\nint mg_base64_update(unsigned char ch, char *to, int n) {\n  int rem = (n & 3) % 3;\n  if (rem == 0) {\n    to[n] = (char) mg_b64idx(ch >> 2);\n    to[++n] = (char) ((ch & 3) << 4);\n  } else if (rem == 1) {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 4));\n    to[++n] = (char) ((ch & 15) << 2);\n  } else {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 6));\n    to[++n] = (char) mg_b64idx(ch & 63);\n    n++;\n  }\n  return n;\n}\n\nint mg_base64_final(char *to, int n) {\n  int saved = n;\n  // printf(\"---[%.*s]\\n\", n, to);\n  if (n & 3) n = mg_base64_update(0, to, n);\n  if ((saved & 3) == 2) n--;\n  // printf(\"    %d[%.*s]\\n\", n, n, to);\n  while (n & 3) to[n++] = '=';\n  to[n] = '\\0';\n  return n;\n}\n\nint mg_base64_encode(const unsigned char *p, int n, char *to) {\n  int i, len = 0;\n  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);\n  len = mg_base64_final(to, len);\n  return len;\n}\n\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src + n;\n  int len = 0;\n  while (src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/dns.c\"\n#endif\n\n\n\n\n\n\n\nstruct dns_data {\n  struct dns_data *next;\n  struct mg_connection *c;\n  int64_t expire;\n  uint16_t txnid;\n};\n\nstatic struct dns_data *s_reqs;  // Active DNS requests\n\nstatic void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,\n                         struct mg_dns *, bool);\n\nstatic void mg_dns_free(struct dns_data *d) {\n  LIST_DELETE(struct dns_data, &s_reqs, d);\n  free(d);\n}\n\nvoid mg_resolve_cancel(struct mg_connection *c) {\n  struct dns_data *tmp, *d;\n  for (d = s_reqs; d != NULL; d = tmp) {\n    tmp = d->next;\n    if (d->c == c) mg_dns_free(d);\n  }\n}\n\nstatic size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,\n                                      char *to, size_t tolen, int depth) {\n  size_t i = 0, j = 0;\n  if (tolen > 0) to[0] = '\\0';\n  if (depth > 5) return 0;\n  while (ofs + i + 1 < len) {\n    size_t n = s[ofs + i];\n    if (n == 0) {\n      i++;\n      break;\n    }\n    if (n & 0xc0) {\n      size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len\n      if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&\n          mg_dns_parse_name_depth(s, len, ptr, to, tolen, depth + 1) == 0)\n        return 0;\n      i += 2;\n      break;\n    }\n    if (ofs + i + n + 1 >= len) return 0;\n    if (j > 0) {\n      if (j < tolen) to[j] = '.';\n      j++;\n    }\n    if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);\n    j += n;\n    i += n + 1;\n    if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk\n  }\n  if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term\n  return i;\n}\n\nstatic size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,\n                                char *dst, size_t dstlen) {\n  return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0);\n}\n\nsize_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,\n                       bool is_question, struct mg_dns_rr *rr) {\n  const uint8_t *s = buf + ofs, *e = &buf[len];\n\n  memset(rr, 0, sizeof(*rr));\n  if (len < sizeof(struct mg_dns_header)) return 0;  // Too small\n  if (len > 512) return 0;  //  Too large, we don't expect that\n  if (s >= e) return 0;     //  Overflow\n\n  if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)\n    return 0;\n  s += rr->nlen + 4;\n  if (s > e) return 0;\n  rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);\n  rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (is_question) return (size_t) (rr->nlen + 4);\n\n  s += 6;\n  if (s > e) return 0;\n  rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (s + rr->alen > e) return 0;\n  return (size_t) (rr->nlen + rr->alen + 10);\n}\n\nbool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {\n  const struct mg_dns_header *h = (struct mg_dns_header *) buf;\n  struct mg_dns_rr rr;\n  size_t i, n, ofs = sizeof(*h);\n  memset(dm, 0, sizeof(*dm));\n\n  if (len < sizeof(*h)) return 0;                // Too small, headers dont fit\n  if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity\n  if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity\n  dm->txnid = mg_ntohs(h->txnid);\n\n  for (i = 0; i < mg_ntohs(h->num_questions); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;\n    // LOG(LL_INFO, (\"Q %zu %zu\", ofs, n));\n    ofs += n;\n  }\n  for (i = 0; i < mg_ntohs(h->num_answers); i++) {\n    // LOG(LL_INFO, (\"A -- %zu %zu %s\", ofs, n, dm->name));\n    if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;\n    mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));\n    ofs += n;\n\n    if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {\n      dm->addr.is_ip6 = false;\n      memcpy(&dm->addr.ip, &buf[ofs - 4], 4);\n      dm->resolved = true;\n      break;  // Return success\n    } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {\n      dm->addr.is_ip6 = true;\n      memcpy(&dm->addr.ip6, &buf[ofs - 16], 16);\n      dm->resolved = true;\n      break;  // Return success\n    }\n  }\n  return true;\n}\n\nstatic void dns_cb(struct mg_connection *c, int ev, void *ev_data,\n                   void *fn_data) {\n  struct dns_data *d, *tmp;\n  if (ev == MG_EV_POLL) {\n    int64_t now = *(int64_t *) ev_data;\n    for (d = s_reqs; d != NULL; d = tmp) {\n      tmp = d->next;\n      // LOG(LL_DEBUG, (\"%lu %lu dns poll\", d->expire, now));\n      if (now > d->expire) mg_error(d->c, \"DNS timeout\");\n    }\n  } else if (ev == MG_EV_READ) {\n    struct mg_dns_message dm;\n    int resolved = 0;\n    if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {\n      char *s = mg_hexdump(c->recv.buf, c->recv.len);\n      LOG(LL_ERROR, (\"Unexpected DNS response:\\n%s\\n\", s));\n      free(s);\n    } else {\n      LOG(LL_VERBOSE_DEBUG, (\"%s %d\", dm.name, dm.resolved));\n      for (d = s_reqs; d != NULL; d = tmp) {\n        tmp = d->next;\n        // LOG(LL_INFO, (\"d %p %hu %hu\", d, d->txnid, dm.txnid));\n        if (dm.txnid != d->txnid) continue;\n        if (d->c->is_resolving) {\n          d->c->is_resolving = 0;\n          if (dm.resolved) {\n#if MG_ENABLE_LOG\n            char buf[100];\n#endif\n            dm.addr.port = d->c->peer.port;  // Save port\n            d->c->peer = dm.addr;            // Copy resolved address\n            LOG(LL_DEBUG, (\"%lu %s resolved to %s\", d->c->id, dm.name,\n                           mg_ntoa(&d->c->peer, buf, sizeof(buf))));\n            mg_connect_resolved(d->c);\n#if MG_ENABLE_IPV6\n          } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0') {\n            struct mg_str x = mg_str(dm.name);\n            mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);\n#endif\n          } else {\n            mg_error(d->c, \"%s DNS lookup failed\", dm.name);\n          }\n        } else {\n          LOG(LL_ERROR, (\"%lu already resolved\", d->c->id));\n        }\n        mg_dns_free(d);\n        resolved = 1;\n      }\n    }\n    if (!resolved) LOG(LL_ERROR, (\"stray DNS reply\"));\n    c->recv.len = 0;\n  } else if (ev == MG_EV_CLOSE) {\n    for (d = s_reqs; d != NULL; d = tmp) {\n      tmp = d->next;\n      mg_error(d->c, \"DNS error\");\n      mg_dns_free(d);\n    }\n  }\n  (void) fn_data;\n}\n\nstatic void mg_dns_send(struct mg_connection *c, const struct mg_str *name,\n                        uint16_t txnid, bool ipv6) {\n  struct {\n    struct mg_dns_header header;\n    uint8_t data[256];\n  } pkt;\n  size_t i, n;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.header.txnid = mg_htons(txnid);\n  pkt.header.flags = mg_htons(0x100);\n  pkt.header.num_questions = mg_htons(1);\n  for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {\n    if (name->ptr[i] == '.' || i >= name->len) {\n      pkt.data[n] = (uint8_t) (i - n);\n      memcpy(&pkt.data[n + 1], name->ptr + n, i - n);\n      n = i + 1;\n    }\n    if (i >= name->len) break;\n  }\n  memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query\n  n += 5;\n  if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query\n  // memcpy(&pkt.data[n], \"\\xc0\\x0c\\x00\\x1c\\x00\\x01\", 6);  // AAAA query\n  // n += 6;\n  mg_send(c, &pkt, sizeof(pkt.header) + n);\n#if 0\n  // Immediately after A query, send AAAA query. Whatever reply comes first,\n  // we'll use it. Note: we cannot send two queries in a single packet.\n  // https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query\n  pkt.data[n - 3] = 0x1c;  // AAAA query\n  mg_send(c, &pkt, sizeof(pkt.header) + n);\n#endif\n}\n\nstatic void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,\n                         struct mg_dns *dnsc, bool ipv6) {\n  struct dns_data *d = NULL;\n  if (dnsc->url == NULL) {\n    mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");\n  } else if (dnsc->c == NULL) {\n    dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);\n    if (dnsc->c != NULL) {\n      dnsc->c->pfn = dns_cb;\n      // snprintf(dnsc->c->label, sizeof(dnsc->c->label), \"%s\", \"DNS\");\n      // dnsc->c->is_hexdumping = 1;\n    }\n  }\n  if (dnsc->c == NULL) {\n    mg_error(c, \"resolver\");\n  } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {\n    mg_error(c, \"resolve OOM\");\n  } else {\n#if MG_ENABLE_LOG\n    char buf[100];\n#endif\n    d->txnid = s_reqs ? (uint16_t) (s_reqs->txnid + 1) : 1;\n    d->next = s_reqs;\n    s_reqs = d;\n    d->expire = mg_millis() + (int64_t) ms;\n    d->c = c;\n    c->is_resolving = 1;\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,\n         name->ptr, mg_ntoa(&dnsc->c->peer, buf, sizeof(buf)), d->txnid));\n    mg_dns_send(dnsc->c, name, d->txnid, ipv6);\n  }\n}\n\nvoid mg_resolve(struct mg_connection *c, const char *url) {\n  struct mg_str host = mg_url_host(url);\n  c->peer.port = mg_htons(mg_url_port(url));\n  if (mg_aton(host, &c->peer)) {\n    // host is an IP address, do not fire name resolution\n    mg_connect_resolved(c);\n  } else {\n    // host is not an IP, send DNS resolution request\n    mg_sendnsreq(c, &host, c->mgr->dnstimeout, &c->mgr->dns4, false);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/event.c\"\n#endif\n\n\n\n\n\nvoid mg_call(struct mg_connection *c, int ev, void *ev_data) {\n  // Run user-defined handler first, in order to give it an ability\n  // to intercept processing (e.g. clean input buffer) before the\n  // protocol handler kicks in\n  if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);\n  if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);\n}\n\nvoid mg_error(struct mg_connection *c, const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  LOG(LL_ERROR, (\"%lu %s\", c->id, buf));\n  c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL\n  mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it\n  if (buf != mem) free(buf);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_packed.c\"\n#endif\n\n\nstruct packed_file {\n  const char *data;\n  size_t size;\n  size_t pos;\n};\n\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime);\nconst char *mg_unlist(size_t no);\n#if MG_ENABLE_PACKED_FS\n#else\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return NULL;\n}\nconst char *mg_unlist(size_t no) {\n  (void) no;\n  return NULL;\n}\n#endif\n\nstatic int is_dir_prefix(const char *prefix, size_t n, const char *path) {\n  return n < strlen(path) && memcmp(prefix, path, n) == 0 && path[n] == '/';\n  //(n == 0 || path[n] == MG_DIRSEP);\n}\n\nstatic int packed_stat(const char *path, size_t *size, time_t *mtime) {\n  const char *p;\n  size_t i, n = strlen(path);\n  if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file\n  // Scan all files. If `path` is a dir prefix for any of them, it's a dir\n  for (i = 0; (p = mg_unlist(i)) != NULL; i++) {\n    if (is_dir_prefix(path, n, p)) return MG_FS_DIR;\n  }\n  return 0;\n}\n\nstatic void packed_list(const char *dir, void (*fn)(const char *, void *),\n                        void *userdata) {\n  char buf[256], tmp[sizeof(buf)];\n  const char *path, *begin, *end;\n  size_t i, n = strlen(dir);\n  tmp[0] = '\\0';  // Previously listed entry\n  for (i = 0; (path = mg_unlist(i)) != NULL; i++) {\n    if (!is_dir_prefix(dir, n, path)) continue;\n    begin = &path[n + 1];\n    end = strchr(begin, '/');\n    if (end == NULL) end = begin + strlen(begin);\n    snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);\n    buf[sizeof(buf) - 1] = '\\0';\n    // If this entry has been already listed, skip\n    // NOTE: we're assuming that file list is sorted alphabetically\n    if (strcmp(buf, tmp) == 0) continue;\n    fn(buf, userdata);  // Not yet listed, call user function\n    strcpy(tmp, buf);   // And save this entry as listed\n  }\n}\n\nstatic struct mg_fd *packed_open(const char *path, int flags) {\n  size_t size = 0;\n  const char *data = mg_unpack(path, &size, NULL);\n  struct packed_file *fp = NULL;\n  struct mg_fd *fd = NULL;\n  if (data == NULL) return NULL;\n  if (flags & MG_FS_WRITE) return NULL;\n  fp = (struct packed_file *) calloc(1, sizeof(*fp));\n  fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  fp->size = size;\n  fp->data = data;\n  fd->fd = fp;\n  fd->fs = &mg_fs_packed;\n  return fd;\n}\n\nstatic void packed_close(struct mg_fd *fd) {\n  if (fd) free(fd->fd), free(fd);\n}\n\nstatic size_t packed_read(void *fd, void *buf, size_t len) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  if (fp->pos + len > fp->size) len = fp->size - fp->pos;\n  memcpy(buf, &fp->data[fp->pos], len);\n  fp->pos += len;\n  return len;\n}\n\nstatic size_t packed_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t packed_seek(void *fd, size_t offset) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  fp->pos = offset;\n  if (fp->pos > fp->size) fp->pos = fp->size;\n  return fp->pos;\n}\n\nstruct mg_fs mg_fs_packed = {packed_stat,  packed_list, packed_open,\n                             packed_close, packed_read, packed_write,\n                             packed_seek};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_posix.c\"\n#endif\n\n\n#if MG_ENABLE_FILE\n\n#ifndef MG_STAT_STRUCT\n#define MG_STAT_STRUCT stat\n#endif\n\n#ifndef MG_STAT_FUNC\n#define MG_STAT_FUNC stat\n#endif\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n#if !defined(S_ISDIR)\n  LOG(LL_ERROR, (\"stat() API is not supported. %p %p %p\", path, size, mtime));\n  return 0;\n#else\n#if defined(_WIN32)\n  struct _stati64 st;\n  wchar_t tmp[PATH_MAX];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));\n  if (_wstati64(tmp, &st) != 0) return 0;\n#else\n  struct MG_STAT_STRUCT st;\n  if (MG_STAT_FUNC(path, &st) != 0) return 0;\n#endif\n  if (size) *size = (size_t) st.st_size;\n  if (mtime) *mtime = st.st_mtime;\n  return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);\n#endif\n}\n\n#ifdef _WIN32\nstruct dirent {\n  char d_name[MAX_PATH];\n};\n\ntypedef struct win32_dir {\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n} DIR;\n\nint gettimeofday(struct timeval *tv, void *tz) {\n  FILETIME ft;\n  unsigned __int64 tmpres = 0;\n\n  if (tv != NULL) {\n    GetSystemTimeAsFileTime(&ft);\n    tmpres |= ft.dwHighDateTime;\n    tmpres <<= 32;\n    tmpres |= ft.dwLowDateTime;\n    tmpres /= 10;  // convert into microseconds\n    tmpres -= (int64_t) 11644473600000000;\n    tv->tv_sec = (long) (tmpres / 1000000UL);\n    tv->tv_usec = (long) (tmpres % 1000000UL);\n  }\n  (void) tz;\n  return 0;\n}\n\nstatic int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n  // Trim trailing slashes. Leave backslash for paths like \"X:\\\"\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  // Convert back to Unicode. If doubly-converted string does not match the\n  // original, something is fishy, reject.\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n  return ret;\n}\n\nDIR *opendir(const char *name) {\n  DIR *d = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      d->handle = FindFirstFileW(wpath, &d->info);\n      d->result.d_name[0] = '\\0';\n    } else {\n      free(d);\n      d = NULL;\n    }\n  }\n  return d;\n}\n\nint closedir(DIR *d) {\n  int result = 0;\n  if (d != NULL) {\n    if (d->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(d->handle) ? 0 : -1;\n    free(d);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct dirent *result = NULL;\n  if (d != NULL) {\n    memset(&d->result, 0, sizeof(d->result));\n    if (d->handle != INVALID_HANDLE_VALUE) {\n      result = &d->result;\n      WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,\n                          sizeof(result->d_name), NULL, NULL);\n      if (!FindNextFileW(d->handle, &d->info)) {\n        FindClose(d->handle);\n        d->handle = INVALID_HANDLE_VALUE;\n      }\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n#endif\n\nstatic void p_list(const char *dir, void (*fn)(const char *, void *),\n                   void *userdata) {\n#if MG_ENABLE_DIRLIST\n  struct dirent *dp;\n  DIR *dirp;\n  if ((dirp = (opendir(dir))) == NULL) return;\n  while ((dp = readdir(dirp)) != NULL) {\n    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;\n    fn(dp->d_name, userdata);\n  }\n  closedir(dirp);\n#else\n  (void) dir, (void) fn, (void) userdata;\n#endif\n}\n\nstatic struct mg_fd *p_open(const char *path, int flags) {\n  const char *mode = flags == (MG_FS_READ | MG_FS_WRITE) ? \"r+b\"\n                     : flags & MG_FS_READ                ? \"rb\"\n                     : flags & MG_FS_WRITE               ? \"wb\"\n                                                         : \"\";\n  void *fp = NULL;\n  struct mg_fd *fd = NULL;\n#ifdef _WIN32\n  wchar_t b1[PATH_MAX], b2[10];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));\n  MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));\n  fp = (void *) _wfopen(b1, b2);\n#else\n  fp = (void *) fopen(path, mode);\n#endif\n  if (fp == NULL) return NULL;\n  fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  fd->fd = fp;\n  fd->fs = &mg_fs_posix;\n  return fd;\n}\n\nstatic void p_close(struct mg_fd *fd) {\n  if (fd != NULL) fclose((FILE *) fd->fd), free(fd);\n}\n\nstatic size_t p_read(void *fp, void *buf, size_t len) {\n  return fread(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_write(void *fp, const void *buf, size_t len) {\n  return fwrite(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_seek(void *fp, size_t offset) {\n#if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\\n    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\\n    (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)\n  fseeko((FILE *) fp, (off_t) offset, SEEK_SET);\n#else\n  fseek((FILE *) fp, (long) offset, SEEK_SET);\n#endif\n  return (size_t) ftell((FILE *) fp);\n}\n\n#else\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return 0;\n}\n\nstatic void p_list(const char *path, void (*fn)(const char *, void *),\n                   void *userdata) {\n  (void) path, (void) fn, (void) userdata;\n}\n\nstatic struct mg_fd *p_open(const char *path, int flags) {\n  (void) path, (void) flags;\n  return NULL;\n}\n\nstatic void p_close(struct mg_fd *fd) {\n  (void) fd;\n}\n\nstatic size_t p_read(void *fd, void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t p_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t p_seek(void *fd, size_t offset) {\n  (void) fd, (void) offset;\n  return (size_t) ~0;\n}\n#endif\n\nstruct mg_fs mg_fs_posix = {p_stat, p_list,  p_open, p_close,\n                            p_read, p_write, p_seek};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/http.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // LOG(LL_INFO, (\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // LOG(LL_INFO, (\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // LOG(LL_INFO, (\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len + 21];\n    memcpy(&buf[-21], \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf, n);\n      }\n    }\n    n = mg_base64_final(buf, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    LOG(LL_ERROR, (\"%lu %s cannot resize iobuf %d->%d \", c->id, c->label,\n                   (int) c->send.size, (int) need));\n  }\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = buf->ptr + buf->len;\n    len = -4;  // Name does not exist\n    dst[0] = '\\0';\n    for (p = buf->ptr; p + name_len < e; p++) {\n      if ((p == buf->ptr || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_ncasecmp(name, p, name_len)) {\n        p += name_len + 1;\n        s = (const char *) memchr(p, '&', (size_t) (e - p));\n        if (s == NULL) s = e;\n        len = mg_url_decode(p, (size_t) (s - p), dst, dst_len, 1);\n        if (len < 0) len = -3;  // Failed to decode\n        break;\n      }\n    }\n  }\n  return len;\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isxdigit(*(const unsigned char *) (src + i + 1)) &&\n          isxdigit(*(const unsigned char *) (src + i + 2))) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128)\n      return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // LOG(LL_INFO, (\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s + req_len, *qs;\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list ap) {\n  char mem[256], *buf = mem;\n  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  mg_printf(c, \"%X\\r\\n\", len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  mg_send(c, \"\\r\\n\", 2);\n  if (buf != mem) free(buf);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lX\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 101: return \"Switching Protocols\";\n    case 102: return \"Processing\";\n    case 200: return \"OK\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 203: return \"Non-authoritative Information\";\n    case 204: return \"No Content\";\n    case 205: return \"Reset Content\";\n    case 206: return \"Partial Content\";\n    case 207: return \"Multi-Status\";\n    case 208: return \"Already Reported\";\n    case 226: return \"IM Used\";\n    case 300: return \"Multiple Choices\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 303: return \"See Other\";\n    case 304: return \"Not Modified\";\n    case 305: return \"Use Proxy\";\n    case 307: return \"Temporary Redirect\";\n    case 308: return \"Permanent Redirect\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 402: return \"Payment Required\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 405: return \"Method Not Allowed\";\n    case 406: return \"Not Acceptable\";\n    case 407: return \"Proxy Authentication Required\";\n    case 408: return \"Request Timeout\";\n    case 409: return \"Conflict\";\n    case 410: return \"Gone\";\n    case 411: return \"Length Required\";\n    case 412: return \"Precondition Failed\";\n    case 413: return \"Payload Too Large\";\n    case 414: return \"Request-URI Too Long\";\n    case 415: return \"Unsupported Media Type\";\n    case 416: return \"Requested Range Not Satisfiable\";\n    case 417: return \"Expectation Failed\";\n    case 418: return \"I'm a teapot\";\n    case 421: return \"Misdirected Request\";\n    case 422: return \"Unprocessable Entity\";\n    case 423: return \"Locked\";\n    case 424: return \"Failed Dependency\";\n    case 426: return \"Upgrade Required\";\n    case 428: return \"Precondition Required\";\n    case 429: return \"Too Many Requests\";\n    case 431: return \"Request Header Fields Too Large\";\n    case 444: return \"Connection Closed Without Response\";\n    case 451: return \"Unavailable For Legal Reasons\";\n    case 499: return \"Client Closed Request\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    case 502: return \"Bad Gateway\";\n    case 503: return \"Service Unavailable\";\n    case 504: return \"Gateway Timeout\";\n    case 505: return \"HTTP Version Not Supported\";\n    case 506: return \"Variant Also Negotiates\";\n    case 507: return \"Insufficient Storage\";\n    case 508: return \"Loop Detected\";\n    case 510: return \"Not Extended\";\n    case 511: return \"Network Authentication Required\";\n    case 599: return \"Network Connect Timeout Error\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length: %d\\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers, len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  if (buf != mem) free(buf);\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  struct mg_fd *fd = (struct mg_fd *) c->pfn_data;\n  if (fd != NULL) fd->fs->close(fd);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,\n           (int64_t) size);\n  return buf;\n}\n\n#if MG_ENABLE_FILE\nint mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}\n#endif\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = 2 * MG_IO_SIZE;\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    n = fd->fs->read(fd->fd, c->send.buf + c->send.len,\n                     c->send.size - c->send.len);\n    if (n > 0) c->send.len += n;\n    if (c->send.len < c->send.size) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  // clang-format off\n  struct mimeentry { struct mg_str extension, value; };\n  #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}\n  // clang-format on\n  const struct mimeentry tab[] = {\n      MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),\n      MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),\n      MIME_ENTRY(\"gif\", \"image/gif\"),\n      MIME_ENTRY(\"png\", \"image/png\"),\n      MIME_ENTRY(\"jpg\", \"image/jpeg\"),\n      MIME_ENTRY(\"jpeg\", \"image/jpeg\"),\n      MIME_ENTRY(\"woff\", \"font/woff\"),\n      MIME_ENTRY(\"ttf\", \"font/ttf\"),\n      MIME_ENTRY(\"svg\", \"image/svg+xml\"),\n      MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),\n      MIME_ENTRY(\"avi\", \"video/x-msvideo\"),\n      MIME_ENTRY(\"csv\", \"text/csv\"),\n      MIME_ENTRY(\"doc\", \"application/msword\"),\n      MIME_ENTRY(\"exe\", \"application/octet-stream\"),\n      MIME_ENTRY(\"gz\", \"application/gzip\"),\n      MIME_ENTRY(\"ico\", \"image/x-icon\"),\n      MIME_ENTRY(\"json\", \"application/json\"),\n      MIME_ENTRY(\"mov\", \"video/quicktime\"),\n      MIME_ENTRY(\"mp3\", \"audio/mpeg\"),\n      MIME_ENTRY(\"mp4\", \"video/mp4\"),\n      MIME_ENTRY(\"mpeg\", \"video/mpeg\"),\n      MIME_ENTRY(\"pdf\", \"application/pdf\"),\n      MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"tgz\", \"application/tar-gz\"),\n      MIME_ENTRY(\"wav\", \"audio/wav\"),\n      MIME_ENTRY(\"webp\", \"image/webp\"),\n      MIME_ENTRY(\"zip\", \"application/zip\"),\n      MIME_ENTRY(\"3gp\", \"video/3gpp\"),\n      {{0, 0}, {0, 0}},\n  };\n  size_t i = 0;\n  struct mg_str k, v, s = mg_str(extra);\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; tab[i].extension.ptr != NULL; i++) {\n    if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  LOG(LL_INFO, (\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path, struct mg_http_serve_opts *opts) {\n  char etag[64];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = fs->open(path, MG_FS_READ);\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n\n  if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {\n    LOG(LL_DEBUG, (\"404 [%s] %p\", path, (void *) fd));\n    mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");\n    fs->close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    fs->close(fd);\n    mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n  } else {\n    int n, status = 200;\n    char range[100] = \"\";\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n    struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT\n                 \"/\" MG_INT64_FMT \"\\r\\n\",\n                 r1, r1 + cl - 1, (int64_t) size);\n        fs->seek(fd->fd, (size_t) r1);\n      }\n    }\n\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      fs->close(fd);\n    } else {\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[64], mod[64];\n  int flags, n = 0;\n\n  // LOG(LL_DEBUG, (\"[%s] [%s]\", d->dir, name));\n  if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {\n    LOG(LL_ERROR, (\"%s truncated\", name));\n  } else if ((flags = fs->stat(path, &size, &t)) == 0) {\n    LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    struct tm tm;\n    if (flags & MG_FS_DIR) {\n      snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else if (size < 1024) {\n      snprintf(sz, sizeof(sz), \"%d\", (int) size);\n    } else if (size < 0x100000) {\n      snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);\n    } else if (size < 0x40000000) {\n      snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);\n    } else {\n      snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);\n    }\n    strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&t, &tm));\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=\" MG_INT64_FMT \">%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_http_serve_opts *opts, char *dir) {\n  static const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  static const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n\n  fs->list(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",\n                        (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 10, tmp, n);  // Set content length\n}\n\nstatic void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n// Resolve requested file into `path` and return its fs->stat() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags = 0, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {\n    mg_http_reply(c, 400, \"\", \"Invalid web root [%.*s]\\n\", (int) dir.len,\n                  dir.ptr);\n  } else {\n    if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n    mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                  path_size - n, 0);\n    path[path_size - 1] = '\\0';  // Double-check\n    remove_double_dots(path);\n    n = strlen(path);\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu %.*s -> %s\", c->id, (int) hm->uri.len, hm->uri.ptr, path));\n    while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n    flags = fs->stat(path, NULL, NULL);                 // Does it exist?\n    if (flags == 0) {\n      mg_http_reply(c, 404, \"\", \"Not found\\n\");  // Does not exist, doh\n    } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n               hm->uri.ptr[hm->uri.len - 1] != '/') {\n      mg_printf(c,\n                \"HTTP/1.1 301 Moved\\r\\n\"\n                \"Location: %.*s/\\r\\n\"\n                \"Content-Length: 0\\r\\n\"\n                \"\\r\\n\",\n                (int) hm->uri.len, hm->uri.ptr);\n      flags = 0;\n    } else if (flags & MG_FS_DIR) {\n      if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0) ||\n           (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0))) {\n        flags = tmp;\n      } else {\n        path[n] = '\\0';  // Remove appended index file name\n      }\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX] = \"\";\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags == 0) return;\n  LOG(LL_VERBOSE_DEBUG,\n      (\"%.*s %s %d\", (int) hm->uri.len, hm->uri.ptr, path, flags));\n  if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (sp != NULL && mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_globmatch(glob, strlen(glob), hm->uri.ptr, hm->uri.len);\n}\n\nstatic size_t get_chunk_length(const char *buf, size_t len, size_t *ll) {\n  size_t i = 0, n;\n  while (i < len && buf[i] != '\\r' && i != '\\n') i++;\n  n = mg_unhexn((char *) buf, i);\n  while (i < len && (buf[i] == '\\r' || i == '\\n')) i++;\n  // LOG(LL_INFO, (\"len %zu i %zu n %zu \", len, i, n));\n  if (ll != NULL) *ll = i + 1;\n  if (i < len && i + n + 2 < len) return i + n + 3;\n  return 0;\n}\n\n// Walk through all chunks in the chunked body. For each chunk, fire\n// an MG_EV_HTTP_CHUNK event.\nstatic void walkchunks(struct mg_connection *c, struct mg_http_message *hm,\n                       size_t reqlen) {\n  size_t off = 0, bl, ll;\n  while (off + reqlen < c->recv.len) {\n    char *buf = (char *) &c->recv.buf[reqlen];\n    size_t memo = c->recv.len;\n    size_t cl = get_chunk_length(&buf[off], memo - reqlen - off, &ll);\n    // LOG(LL_INFO, (\"len %zu off %zu cl %zu ll %zu\", len, off, cl, ll));\n    if (cl == 0) break;\n    hm->chunk = mg_str_n(&buf[off + ll], cl < ll + 2 ? 0 : cl - ll - 2);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    // Increase offset only if user has not deleted this chunk\n    if (memo == c->recv.len) off += cl;\n    if (cl <= 5) {\n      // Zero chunk - last one. Prepare body - cut off chunk lengths\n      off = bl = 0;\n      while (off + reqlen < c->recv.len) {\n        char *buf2 = (char *) &c->recv.buf[reqlen];\n        size_t memo2 = c->recv.len;\n        size_t cl2 = get_chunk_length(&buf2[off], memo2 - reqlen - off, &ll);\n        size_t n = cl2 < ll + 2 ? 0 : cl2 - ll - 2;\n        memmove(buf2 + bl, buf2 + off + ll, n);\n        bl += n;\n        off += cl2;\n        if (cl2 <= 5) break;\n      }\n      // LOG(LL_INFO, (\"BL->%d del %d off %d\", (int) bl, (int) del, (int) off));\n      c->recv.len -= off - bl;\n      // Set message length to indicate we've received\n      // everything, to fire MG_EV_HTTP_MSG\n      hm->message.len = bl + reqlen;\n      hm->body.len = bl;\n      break;\n    }\n  }\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  struct mg_str needle = mg_str_n(\"chunked\", 7);\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_strstr(*te, needle) != NULL;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  struct mg_str ch = hm->chunk;\n  if (mg_is_chunked(hm)) {\n    ch.len += 4;  // \\r\\n before and after the chunk\n    ch.ptr -= 2;\n    while (ch.ptr > hm->body.ptr && *ch.ptr != '\\n') ch.ptr--, ch.len++;\n  }\n  {\n    const char *end = &ch.ptr[ch.len];\n    size_t n = (size_t) (end - (char *) c->recv.buf);\n    if (c->recv.len > n) {\n      memmove((char *) ch.ptr, end, (size_t) (c->recv.len - n));\n    }\n    // LOG(LL_INFO, (\"DELETING CHUNK: %zu %zu %zu\\n%.*s\", c->recv.len, n,\n    // ch.len, (int) ch.len, ch.ptr));\n  }\n  c->recv.len -= ch.len;\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      int n = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      bool is_chunked = n > 0 && mg_is_chunked(&hm);\n      if (ev == MG_EV_CLOSE) {\n        hm.message.len = c->recv.len;\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      } else if (is_chunked && n > 0) {\n        walkchunks(c, &hm, (size_t) n);\n      }\n      // LOG(LL_INFO,\n      //(\"---->%d %d\\n%.*s\", n, is_chunked, (int) c->recv.len, c->recv.buf));\n      if (n < 0 && ev == MG_EV_READ) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      } else if (n > 0 && (size_t) c->recv.len >= hm.message.len) {\n        mg_call(c, MG_EV_HTTP_MSG, &hm);\n        mg_iobuf_del(&c->recv, 0, hm.message.len);\n      } else {\n        if (n > 0 && !is_chunked) {\n          hm.chunk =\n              mg_str_n((char *) &c->recv.buf[n], c->recv.len - (size_t) n);\n          mg_call(c, MG_EV_HTTP_CHUNK, &hm);\n        }\n        break;\n      }\n    }\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/iobuf.c\"\n#endif\n\n\n\n#include <string.h>\n\n// Not using memset for zeroing memory, cause it can be dropped by compiler\n// See https://github.com/cesanta/mongoose/pull/1265\nstatic void zeromem(volatile unsigned char *buf, size_t len) {\n  if (buf != NULL) {\n    while (len--) *buf++ = 0;\n  }\n}\n\nint mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {\n  int ok = 1;\n  if (new_size == 0) {\n    zeromem(io->buf, io->size);\n    free(io->buf);\n    io->buf = NULL;\n    io->len = io->size = 0;\n  } else if (new_size != io->size) {\n    // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the\n    // porting to some obscure platforms like FreeRTOS\n    void *p = calloc(1, new_size);\n    if (p != NULL) {\n      size_t len = new_size < io->len ? new_size : io->len;\n      if (len > 0) memcpy(p, io->buf, len);\n      zeromem(io->buf, io->size);\n      free(io->buf);\n      io->buf = (unsigned char *) p;\n      io->size = new_size;\n    } else {\n      ok = 0;\n      LOG(LL_ERROR,\n          (\"%lu->%lu\", (unsigned long) io->size, (unsigned long) new_size));\n    }\n  }\n  return ok;\n}\n\nint mg_iobuf_init(struct mg_iobuf *io, size_t size) {\n  return mg_iobuf_resize(io, size);\n}\n\nsize_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,\n                    size_t len, size_t chunk_size) {\n  size_t new_size = io->len + len;\n  if (new_size > io->size) {\n    new_size += chunk_size;             // Make sure that io->size\n    new_size -= new_size % chunk_size;  // is aligned by chunk_size boundary\n    mg_iobuf_resize(io, new_size);      // Attempt to realloc\n    if (new_size != io->size) len = 0;  // Realloc failure, append nothing\n  }\n  if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);\n  if (buf != NULL) memmove(io->buf + ofs, buf, len);\n  if (ofs > io->len) io->len += ofs - io->len;\n  io->len += len;\n  return len;\n}\n\nsize_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {\n  if (ofs > io->len) ofs = io->len;\n  if (ofs + len > io->len) len = io->len - ofs;\n  memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);\n  zeromem(io->buf + io->len - len, len);\n  io->len -= len;\n  return len;\n}\n\nvoid mg_iobuf_free(struct mg_iobuf *io) {\n  mg_iobuf_resize(io, 0);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/log.c\"\n#endif\n\n\n\n#if MG_ENABLE_LOG\nstatic void mg_log_stdout(const void *buf, size_t len, void *userdata) {\n  (void) userdata;\n#if MG_ENABLE_FILE\n  fwrite(buf, 1, len, stdout);\n#endif\n}\n\nstatic const char *s_spec = \"2\";\nstatic void (*s_fn)(const void *, size_t, void *) = mg_log_stdout;\nstatic void *s_fn_param = NULL;\n\nvoid mg_log_set(const char *spec) {\n  LOG(LL_DEBUG, (\"Setting log level to %s\", spec));\n  s_spec = spec;\n}\n\nbool mg_log_prefix(int level, const char *file, int line, const char *fname) {\n  // static unsigned long seq;\n  int max = LL_INFO;\n  struct mg_str k, v, s = mg_str(s_spec);\n  const char *p = strrchr(file, '/');\n\n  if (s_fn == NULL) return false;\n\n  if (p == NULL) p = strrchr(file, '\\\\');\n  p = p == NULL ? file : p + 1;\n\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) max = atoi(k.ptr);\n    if (v.len > 0 && strncmp(p, k.ptr, k.len) == 0) max = atoi(v.ptr);\n  }\n\n  if (level <= max) {\n    char timebuf[21], buf[50] = \"\";\n    time_t t = time(NULL);\n    struct tm tmp, *tm = gmtime_r(&t, &tmp);\n    int n;\n    (void) tmp;\n    strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n    n = snprintf(buf, sizeof(buf), \"%s %d %s:%d:%s\", timebuf, level, p, line,\n                 fname);\n    if (n < 0 || n > (int) sizeof(buf) - 2) n = sizeof(buf) - 2;\n    while (n < (int) sizeof(buf) - 1) buf[n++] = ' ';\n    s_fn(buf, sizeof(buf) - 1, s_fn_param);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid mg_log(const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  int len = 0;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  s_fn(buf, len > 0 ? (size_t) len : 0, s_fn_param);\n  s_fn(\"\\n\", 1, s_fn_param);\n  if (buf != mem) free(buf);\n}\n\nvoid mg_log_set_callback(void (*fn)(const void *, size_t, void *), void *fnd) {\n  s_fn = fn;\n  s_fn_param = fnd;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/md5.c\"\n#endif\n#include <string.h>\n\n\n#if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5\n#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)\n#define BYTE_ORDER __BYTE_ORDER\n#ifndef LITTLE_ENDIAN\n#define LITTLE_ENDIAN __LITTLE_ENDIAN\n#endif /* LITTLE_ENDIAN */\n#ifndef BIG_ENDIAN\n#define BIG_ENDIAN __LITTLE_ENDIAN\n#endif /* BIG_ENDIAN */\n#endif /* BYTE_ORDER */\n\nstatic void mg_byte_reverse(unsigned char *buf, unsigned longs) {\n/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */\n#if BYTE_ORDER == BIG_ENDIAN\n  do {\n    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                 ((unsigned) buf[1] << 8 | buf[0]);\n    *(uint32_t *) buf = t;\n    buf += 4;\n  } while (--longs);\n#else\n  (void) buf;\n  (void) longs;\n#endif\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid mg_md5_init(mg_md5_ctx *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {\n  uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  mg_byte_reverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n  mg_byte_reverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/mqtt.c\"\n#endif\n\n\n\n\n\n\n\n\n#define MQTT_CLEAN_SESSION 0x02\n#define MQTT_HAS_WILL 0x04\n#define MQTT_WILL_RETAIN 0x20\n#define MQTT_HAS_PASSWORD 0x40\n#define MQTT_HAS_USER_NAME 0x80\n\nenum { MQTT_OK, MQTT_INCOMPLETE, MQTT_MALFORMED };\n\nvoid mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,\n                         uint32_t len) {\n  uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];\n  buf[0] = (uint8_t) ((cmd << 4) | flags);\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0 && vlen < &buf[sizeof(buf)]);\n  mg_send(c, buf, (size_t) (vlen - buf));\n}\n\nstatic void mg_send_u16(struct mg_connection *c, uint16_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nvoid mg_mqtt_login(struct mg_connection *c, struct mg_mqtt_opts *opts) {\n  char rnd[9], client_id[16];\n  struct mg_str cid = opts->client_id;\n  uint32_t total_len = 7 + 1 + 2 + 2;\n  uint8_t connflag = (uint8_t) ((opts->will_qos & 3) << 3);\n\n  if (cid.len == 0) {\n    mg_random(rnd, sizeof(rnd));\n    mg_base64_encode((unsigned char *) rnd, sizeof(rnd), client_id);\n    client_id[sizeof(client_id) - 1] = '\\0';\n    cid = mg_str(client_id);\n  }\n\n  if (opts->user.len > 0) {\n    total_len += 2 + (uint32_t) opts->user.len;\n    connflag |= MQTT_HAS_USER_NAME;\n  }\n  if (opts->pass.len > 0) {\n    total_len += 2 + (uint32_t) opts->pass.len;\n    connflag |= MQTT_HAS_PASSWORD;\n  }\n  if (opts->will_topic.len > 0 && opts->will_message.len > 0) {\n    total_len +=\n        4 + (uint32_t) opts->will_topic.len + (uint32_t) opts->will_message.len;\n    connflag |= MQTT_HAS_WILL;\n  }\n  if (opts->clean || cid.len == 0) connflag |= MQTT_CLEAN_SESSION;\n  if (opts->will_retain) connflag |= MQTT_WILL_RETAIN;\n  total_len += (uint32_t) cid.len;\n\n  mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, total_len);\n  mg_send(c, \"\\00\\04MQTT\\04\", 7);\n  mg_send(c, &connflag, sizeof(connflag));\n  // keepalive == 0 means \"do not disconnect us!\"\n  mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));\n  mg_send_u16(c, mg_htons((uint16_t) cid.len));\n  mg_send(c, cid.ptr, cid.len);\n  if (connflag & MQTT_HAS_WILL) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->will_topic.len));\n    mg_send(c, opts->will_topic.ptr, opts->will_topic.len);\n    mg_send_u16(c, mg_htons((uint16_t) opts->will_message.len));\n    mg_send(c, opts->will_message.ptr, opts->will_message.len);\n  }\n  if (opts->user.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->user.len));\n    mg_send(c, opts->user.ptr, opts->user.len);\n  }\n  if (opts->pass.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));\n    mg_send(c, opts->pass.ptr, opts->pass.len);\n  }\n}\n\nvoid mg_mqtt_pub(struct mg_connection *c, struct mg_str *topic,\n                 struct mg_str *data, int qos, bool retain) {\n  uint8_t flags = (uint8_t) (((qos & 3) << 1) | (retain ? 1 : 0));\n  uint32_t total_len = 2 + (uint32_t) topic->len + (uint32_t) data->len;\n  LOG(LL_DEBUG, (\"%lu [%.*s] -> [%.*s]\", c->id, (int) topic->len,\n                 (char *) topic->ptr, (int) data->len, (char *) data->ptr));\n  if (qos > 0) total_len += 2;\n  mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, total_len);\n  mg_send_u16(c, mg_htons((uint16_t) topic->len));\n  mg_send(c, topic->ptr, topic->len);\n  if (qos > 0) {\n    static uint16_t s_id;\n    if (++s_id == 0) s_id++;\n    mg_send_u16(c, mg_htons(s_id));\n  }\n  mg_send(c, data->ptr, data->len);\n}\n\nvoid mg_mqtt_sub(struct mg_connection *c, struct mg_str *topic, int qos) {\n  static uint16_t s_id;\n  uint8_t qos_ = qos & 3;\n  uint32_t total_len = 2 + (uint32_t) topic->len + 2 + 1;\n  mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, total_len);\n  if (++s_id == 0) ++s_id;\n  mg_send_u16(c, mg_htons(s_id));\n  mg_send_u16(c, mg_htons((uint16_t) topic->len));\n  mg_send(c, topic->ptr, topic->len);\n  mg_send(c, &qos_, sizeof(qos_));\n}\n\nint mg_mqtt_parse(const uint8_t *buf, size_t len, struct mg_mqtt_message *m) {\n  uint8_t lc = 0, *p, *end;\n  uint32_t n = 0, len_len = 0;\n\n  memset(m, 0, sizeof(*m));\n  m->dgram.ptr = (char *) buf;\n  if (len < 2) return MQTT_INCOMPLETE;\n  m->cmd = (uint8_t) (buf[0] >> 4);\n  m->qos = (buf[0] >> 1) & 3;\n\n  n = len_len = 0;\n  p = (uint8_t *) buf + 1;\n  while ((size_t) (p - buf) < len) {\n    lc = *((uint8_t *) p++);\n    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len >= 4) return MQTT_MALFORMED;\n  }\n  end = p + n;\n  if (lc & 0x80 || end > buf + len) return MQTT_INCOMPLETE;\n  m->dgram.len = (size_t) (end - buf);\n\n  switch (m->cmd) {\n    case MQTT_CMD_CONNACK:\n      if (end - p < 2) return MQTT_MALFORMED;\n      m->ack = p[1];\n      break;\n    case MQTT_CMD_PUBACK:\n    case MQTT_CMD_PUBREC:\n    case MQTT_CMD_PUBREL:\n    case MQTT_CMD_PUBCOMP:\n    case MQTT_CMD_SUBACK:\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      break;\n    case MQTT_CMD_SUBSCRIBE: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      p += 2;\n      break;\n    }\n    case MQTT_CMD_PUBLISH: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      m->topic.ptr = (char *) p + 2;\n      p += 2 + m->topic.len;\n      if (p > end) return MQTT_MALFORMED;\n      if (m->qos > 0) {\n        if (p + 2 > end) return MQTT_MALFORMED;\n        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n        p += 2;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      m->data.ptr = (char *) p;\n      m->data.len = (size_t) (end - p);\n      break;\n    }\n    default:\n      break;\n  }\n  return MQTT_OK;\n}\n\nstatic size_t mg_mqtt_next_topic(struct mg_mqtt_message *msg,\n                                 struct mg_str *topic, uint8_t *qos,\n                                 size_t pos) {\n  unsigned char *buf = (unsigned char *) msg->dgram.ptr + pos;\n  size_t new_pos;\n  if (pos >= msg->dgram.len) return 0;\n\n  topic->len = (size_t) (((unsigned) buf[0]) << 8 | buf[1]);\n  topic->ptr = (char *) buf + 2;\n  new_pos = pos + 2 + topic->len + (qos == NULL ? 0 : 1);\n  if ((size_t) new_pos > msg->dgram.len) return 0;\n  if (qos != NULL) *qos = buf[2 + topic->len];\n  return new_pos;\n}\n\nsize_t mg_mqtt_next_sub(struct mg_mqtt_message *msg, struct mg_str *topic,\n                        uint8_t *qos, size_t pos) {\n  uint8_t tmp;\n  return mg_mqtt_next_topic(msg, topic, qos == NULL ? &tmp : qos, pos);\n}\n\nsize_t mg_mqtt_next_unsub(struct mg_mqtt_message *msg, struct mg_str *topic,\n                          size_t pos) {\n  return mg_mqtt_next_topic(msg, topic, NULL, pos);\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,\n                    void *fn_data) {\n  if (ev == MG_EV_READ) {\n    for (;;) {\n      struct mg_mqtt_message mm;\n      int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, &mm);\n      if (rc == MQTT_MALFORMED) {\n        LOG(LL_ERROR, (\"%lu MQTT malformed message\", c->id));\n        c->is_closing = 1;\n        break;\n      } else if (rc == MQTT_OK) {\n        LOG(LL_VERBOSE_DEBUG,\n            (\"%p MQTT CMD %d len %d [%.*s]\", c->fd, mm.cmd, (int) mm.dgram.len,\n             (int) mm.data.len, mm.data.ptr));\n        switch (mm.cmd) {\n          case MQTT_CMD_CONNACK:\n            mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);\n            if (mm.ack == 0) {\n              LOG(LL_INFO, (\"%lu Connected\", c->id));\n            } else {\n              LOG(LL_ERROR, (\"%lu MQTT auth failed, code %d\", c->id, mm.ack));\n              c->is_closing = 1;\n            }\n            break;\n          case MQTT_CMD_PUBLISH: {\n            LOG(LL_DEBUG, (\"%lu [%.*s] -> [%.*s]\", c->id, (int) mm.topic.len,\n                           mm.topic.ptr, (int) mm.data.len, mm.data.ptr));\n            mg_call(c, MG_EV_MQTT_MSG, &mm);\n            break;\n          }\n        }\n        mg_call(c, MG_EV_MQTT_CMD, &mm);\n        mg_iobuf_del(&c->recv, 0, mm.dgram.len);\n      } else {\n        break;\n      }\n    }\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_DISCONNECT, 0, 0);\n}\n\nstruct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,\n                                      struct mg_mqtt_opts *opts,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    struct mg_mqtt_opts empty;\n    memset(&empty, 0, sizeof(empty));\n    mg_mqtt_login(c, opts == NULL ? &empty : opts);\n    c->pfn = mqtt_cb;\n  }\n  return c;\n}\n\nstruct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/net.c\"\n#endif\n\n\n\n\nint mg_vprintf(struct mg_connection *c, const char *fmt, va_list ap) {\n  char mem[256], *buf = mem;\n  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  len = mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  if (buf != mem) free(buf);\n  return len;\n}\n\nint mg_printf(struct mg_connection *c, const char *fmt, ...) {\n  int len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(c, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\nchar *mg_straddr(struct mg_addr *a, char *buf, size_t len) {\n  char tmp[30];\n  const char *fmt = a->is_ip6 ? \"[%s]:%d\" : \"%s:%d\";\n  mg_ntoa(a, tmp, sizeof(tmp));\n  snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));\n  return buf;\n}\n\nchar *mg_ntoa(const struct mg_addr *addr, char *buf, size_t len) {\n  if (addr->is_ip6) {\n    uint16_t *p = (uint16_t *) addr->ip6;\n    snprintf(buf, len, \"%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx\", mg_htons(p[0]),\n             mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),\n             mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));\n  } else {\n    uint8_t p[4];\n    memcpy(p, &addr->ip, sizeof(p));\n    snprintf(buf, len, \"%d.%d.%d.%d\", (int) p[0], (int) p[1], (int) p[2],\n             (int) p[3]);\n  }\n  return buf;\n}\n\nstatic bool mg_atonl(struct mg_str str, struct mg_addr *addr) {\n  if (mg_vcasecmp(&str, \"localhost\") != 0) return false;\n  addr->ip = mg_htonl(0x7f000001);\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_atone(struct mg_str str, struct mg_addr *addr) {\n  if (str.len > 0) return false;\n  addr->ip = 0;\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_aton4(struct mg_str str, struct mg_addr *addr) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  size_t i, num_dots = 0;\n  for (i = 0; i < str.len; i++) {\n    if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n      int octet = data[num_dots] * 10 + (str.ptr[i] - '0');\n      if (octet > 255) return false;\n      data[num_dots] = (uint8_t) octet;\n    } else if (str.ptr[i] == '.') {\n      if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;\n      num_dots++;\n    } else {\n      return false;\n    }\n  }\n  if (num_dots != 3 || str.ptr[i - 1] == '.') return false;\n  memcpy(&addr->ip, data, sizeof(data));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {\n  int i;\n  if (str.len < 14) return false;\n  if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;\n  for (i = 2; i < 6; i++) {\n    if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;\n  }\n  if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;\n  memset(addr->ip6, 0, sizeof(addr->ip6));\n  addr->ip6[10] = addr->ip6[11] = 255;\n  memcpy(&addr->ip6[12], &addr->ip, 4);\n  addr->is_ip6 = true;\n  return true;\n}\n\nstatic bool mg_aton6(struct mg_str str, struct mg_addr *addr) {\n  size_t i, j = 0, n = 0, dc = 42;\n  if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;\n  if (mg_v4mapped(str, addr)) return true;\n  for (i = 0; i < str.len; i++) {\n    if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||\n        (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||\n        (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {\n      unsigned long val;\n      if (i > j + 3) return false;\n      // LOG(LL_DEBUG, (\"%zu %zu [%.*s]\", i, j, (int) (i - j + 1),\n      // &str.ptr[j]));\n      val = mg_unhexn(&str.ptr[j], i - j + 1);\n      addr->ip6[n] = (uint8_t) ((val >> 8) & 255);\n      addr->ip6[n + 1] = (uint8_t) (val & 255);\n    } else if (str.ptr[i] == ':') {\n      j = i + 1;\n      if (i > 0 && str.ptr[i - 1] == ':') {\n        dc = n;  // Double colon\n        if (i > 1 && str.ptr[i - 2] == ':') return false;\n      } else if (i > 0) {\n        n += 2;\n      }\n      if (n > 14) return false;\n      addr->ip6[n] = addr->ip6[n + 1] = 0;  // For trailing ::\n    } else {\n      return false;\n    }\n  }\n  if (n < 14 && dc == 42) return false;\n  if (n < 14) {\n    memmove(&addr->ip6[dc + (14 - n)], &addr->ip6[dc], n - dc + 2);\n    memset(&addr->ip6[dc], 0, 14 - n);\n  }\n  addr->is_ip6 = true;\n  return true;\n}\n\nbool mg_aton(struct mg_str str, struct mg_addr *addr) {\n  // LOG(LL_INFO, (\"[%.*s]\", (int) str.len, str.ptr));\n  return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||\n         mg_aton6(str, addr);\n}\n\nvoid mg_mgr_free(struct mg_mgr *mgr) {\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;\n  mg_mgr_poll(mgr, 0);\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP\n  FreeRTOS_DeleteSocketSet(mgr->ss);\n#endif\n  LOG(LL_INFO, (\"All connections closed\"));\n}\n\nvoid mg_mgr_init(struct mg_mgr *mgr) {\n  memset(mgr, 0, sizeof(*mgr));\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n  // clang-format off\n  { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }\n  // clang-format on\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP\n  mgr->ss = FreeRTOS_CreateSocketSet();\n#elif defined(__unix) || defined(__unix__) || defined(__APPLE__)\n  // Ignore SIGPIPE signal, so if client cancels the request, it\n  // won't kill the whole process.\n  signal(SIGPIPE, SIG_IGN);\n#endif\n  mgr->dnstimeout = 3000;\n  mgr->dns4.url = \"udp://8.8.8.8:53\";\n  mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n#include <string.h>\n\n/*\n * clang with std=-c99 uses __LITTLE_ENDIAN, by default\n * while for ex, RTOS gcc - LITTLE_ENDIAN, by default\n * it depends on __USE_BSD, but let's have everything\n */\n#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)\n#define BYTE_ORDER __BYTE_ORDER\n#ifndef LITTLE_ENDIAN\n#define LITTLE_ENDIAN __LITTLE_ENDIAN\n#endif /* LITTLE_ENDIAN */\n#ifndef BIG_ENDIAN\n#define BIG_ENDIAN __LITTLE_ENDIAN\n#endif /* BIG_ENDIAN */\n#endif /* BYTE_ORDER */\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n/* Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN */\n#if BYTE_ORDER == LITTLE_ENDIAN\n  block->l[i] =\n      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);\n#endif\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nstatic void mg_sha1_transform(uint32_t state[5], const unsigned char buffer[64]) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid mg_sha1_init(mg_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,\n                    size_t len) {\n  size_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;\n  context->count[1] += (uint32_t)(len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    mg_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      mg_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  mg_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    mg_sha1_update(context, &c, 1);\n  }\n  mg_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\nvoid mg_hmac_sha1(const unsigned char *key, size_t keylen,\n                  const unsigned char *data, size_t datalen,\n                  unsigned char out[20]) {\n  mg_sha1_ctx ctx;\n  unsigned char buf1[64], buf2[64], tmp_key[20], i;\n\n  if (keylen > sizeof(buf1)) {\n    mg_sha1_init(&ctx);\n    mg_sha1_update(&ctx, key, keylen);\n    mg_sha1_final(tmp_key, &ctx);\n    key = tmp_key;\n    keylen = sizeof(tmp_key);\n  }\n\n  memset(buf1, 0, sizeof(buf1));\n  memset(buf2, 0, sizeof(buf2));\n  memcpy(buf1, key, keylen);\n  memcpy(buf2, key, keylen);\n\n  for (i = 0; i < sizeof(buf1); i++) {\n    buf1[i] ^= 0x36;\n    buf2[i] ^= 0x5c;\n  }\n\n  mg_sha1_init(&ctx);\n  mg_sha1_update(&ctx, buf1, sizeof(buf1));\n  mg_sha1_update(&ctx, data, datalen);\n  mg_sha1_final(out, &ctx);\n\n  mg_sha1_init(&ctx);\n  mg_sha1_update(&ctx, buf2, sizeof(buf2));\n  mg_sha1_update(&ctx, out, 20);\n  mg_sha1_final(out, &ctx);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sntp.c\"\n#endif\n\n\n\n\n\n\n#define SNTP_INTERVAL_SEC 3600\n#define SNTP_TIME_OFFSET 2208988800UL\n\nstatic unsigned long s_sntmp_next;\n\nint64_t mg_sntp_parse(const unsigned char *buf, size_t len) {\n  int64_t res = -1;\n  int mode = len > 0 ? buf[0] & 7 : 0;\n  if (len < 48) {\n    LOG(LL_ERROR, (\"%s\", \"corrupt packet\"));\n  } else if ((buf[0] & 0x38) >> 3 != 4) {\n    LOG(LL_ERROR, (\"%s\", \"wrong version\"));\n  } else if (mode != 4 && mode != 5) {\n    LOG(LL_ERROR, (\"%s\", \"not a server reply\"));\n  } else if (buf[1] == 0) {\n    LOG(LL_ERROR, (\"%s\", \"server sent a kiss of death\"));\n  } else {\n    uint32_t *data = (uint32_t *) &buf[40];\n    unsigned long seconds = mg_ntohl(data[0]) - SNTP_TIME_OFFSET;\n    unsigned long useconds = mg_ntohl(data[1]);\n    // LOG(LL_DEBUG, (\"%lu %lu %lu\", time(0), seconds, useconds));\n    res = ((int64_t) seconds) * 1000 + (int64_t) ((useconds / 1000) % 1000);\n    s_sntmp_next = seconds + SNTP_INTERVAL_SEC;\n  }\n  return res;\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ) {\n    int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);\n    if (milliseconds > 0) {\n      mg_call(c, MG_EV_SNTP_TIME, &milliseconds);\n      LOG(LL_DEBUG, (\"%u.%u, next at %lu\", (unsigned) (milliseconds / 1000),\n                     (unsigned) (milliseconds % 1000), s_sntmp_next));\n    }\n    c->recv.len = 0;  // Clear receive buffer\n  } else if (ev == MG_EV_CONNECT) {\n    mg_sntp_send(c, (unsigned long) time(NULL));\n  } else if (ev == MG_EV_CLOSE) {\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nvoid mg_sntp_send(struct mg_connection *c, unsigned long utc) {\n  if (c->is_resolving) {\n    LOG(LL_ERROR, (\"%lu wait until resolved\", c->id));\n  } else if (utc > s_sntmp_next) {\n    uint8_t buf[48] = {0};\n    s_sntmp_next = utc + SNTP_INTERVAL_SEC;\n    buf[0] = (0 << 6) | (4 << 3) | 3;\n    mg_send(c, buf, sizeof(buf));\n    LOG(LL_DEBUG, (\"%lu ct %lu, next at %lu\", c->id, utc, s_sntmp_next));\n  }\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fnd) {\n  struct mg_connection *c = NULL;\n  if (url == NULL) url = \"udp://time.google.com:123\";\n  if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sock.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n#if MG_ENABLE_SOCKET\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n#define MG_SOCK_ERRNO WSAGetLastError()\n#ifndef SO_EXCLUSIVEADDRUSE\n#define SO_EXCLUSIVEADDRUSE ((int) (~SO_REUSEADDR))\n#endif\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP\n#define MG_SOCK_ERRNO errno\ntypedef Socket_t SOCKET;\n#define INVALID_SOCKET FREERTOS_INVALID_SOCKET\n#else\n#define MG_SOCK_ERRNO errno\n#ifndef closesocket\n#define closesocket(x) close(x)\n#endif\n#define INVALID_SOCKET (-1)\ntypedef int SOCKET;\n#endif\n\n#define FD(c_) ((SOCKET) (size_t) (c_)->fd)\n#define S2PTR(s_) ((void *) (size_t) (s_))\n\n#ifndef MSG_NONBLOCKING\n#define MSG_NONBLOCKING 0\n#endif\n\n#ifndef AF_INET6\n#define AF_INET6 10\n#endif\n\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if MG_ENABLE_IPV6\n  struct sockaddr_in6 sin6;\n#endif\n};\n\nstatic socklen_t tousa(struct mg_addr *a, union usa *usa) {\n  socklen_t len = sizeof(usa->sin);\n  memset(usa, 0, sizeof(*usa));\n  usa->sin.sin_family = AF_INET;\n  usa->sin.sin_port = a->port;\n  *(uint32_t *) &usa->sin.sin_addr = a->ip;\n#if MG_ENABLE_IPV6\n  if (a->is_ip6) {\n    usa->sin.sin_family = AF_INET6;\n    usa->sin6.sin6_port = a->port;\n    memcpy(&usa->sin6.sin6_addr, a->ip6, sizeof(a->ip6));\n    len = sizeof(usa->sin6);\n  }\n#endif\n  return len;\n}\n\nstatic void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {\n  a->is_ip6 = is_ip6;\n  a->port = usa->sin.sin_port;\n  memcpy(&a->ip, &usa->sin.sin_addr, sizeof(a->ip));\n#if MG_ENABLE_IPV6\n  if (is_ip6) {\n    memcpy(a->ip6, &usa->sin6.sin6_addr, sizeof(a->ip6));\n    a->port = usa->sin6.sin6_port;\n  }\n#endif\n}\n\nstatic bool mg_sock_would_block(void) {\n  int err = MG_SOCK_ERRNO;\n  return err == EINPROGRESS || err == EWOULDBLOCK\n#ifndef WINCE\n         || err == EAGAIN || err == EINTR\n#endif\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n         || err == WSAEINTR || err == WSAEWOULDBLOCK\n#endif\n      ;\n}\n\nstatic struct mg_connection *alloc_conn(struct mg_mgr *mgr, bool is_client,\n                                        SOCKET fd) {\n  struct mg_connection *c = (struct mg_connection *) calloc(1, sizeof(*c));\n  if (c != NULL) {\n    c->is_client = is_client;\n    c->fd = S2PTR(fd);\n    c->mgr = mgr;\n    c->id = ++mgr->nextid;\n  }\n  return c;\n}\n\nstatic void iolog(struct mg_connection *c, char *buf, long n, bool r) {\n  LOG(n > 0 ? LL_VERBOSE_DEBUG : LL_DEBUG,\n      (\"%-3lu %d%d%d%d%d%d%d%d%d%d%d%d%d%d %d:%d %ld err %d\", c->id,\n       c->is_listening, c->is_client, c->is_accepted, c->is_resolving,\n       c->is_connecting, c->is_tls, c->is_tls_hs, c->is_udp, c->is_websocket,\n       c->is_hexdumping, c->is_draining, c->is_closing, c->is_readable,\n       c->is_writable, (int) c->send.len, (int) c->recv.len, n, MG_SOCK_ERRNO));\n  if (n == 0) {\n    // Do nothing\n  } else if (n < 0) {\n    c->is_closing = 1;  // Error, or normal termination\n  } else if (n > 0) {\n    if (c->is_hexdumping) {\n      union usa usa;\n      char t1[50] = \"\", t2[50] = \"\";\n      socklen_t slen = sizeof(usa.sin);\n      char *s = mg_hexdump(buf, (size_t) n);\n      struct mg_addr a;\n      memset(&usa, 0, sizeof(usa));\n      memset(&a, 0, sizeof(a));\n      getsockname(FD(c), &usa.sa, &slen);\n      tomgaddr(&usa, &a, c->peer.is_ip6);\n      LOG(LL_INFO, (\"\\n-- %lu %s %s %s %s %ld\\n%s\", c->id,\n                    mg_straddr(&a, t1, sizeof(t1)), r ? \"<-\" : \"->\",\n                    mg_straddr(&c->peer, t2, sizeof(t2)), c->label, n, s));\n      free(s);\n      (void) t1, (void) t2;  // Silence warnings for MG_ENABLE_LOG=0\n    }\n    if (r) {\n      struct mg_str evd = mg_str_n(buf, (size_t) n);\n      c->recv.len += (size_t) n;\n      mg_call(c, MG_EV_READ, &evd);\n    } else {\n      mg_iobuf_del(&c->send, 0, (size_t) n);\n      if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);\n      mg_call(c, MG_EV_WRITE, &n);\n    }\n  }\n}\n\nstatic long mg_sock_send(struct mg_connection *c, const void *buf, size_t len) {\n  long n;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->peer, &usa);\n    n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);\n  } else {\n    n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  return n == 0 ? -1 : n < 0 && mg_sock_would_block() ? 0 : n;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  if (c->is_udp) {\n    long n = mg_sock_send(c, buf, len);\n    iolog(c, (char *) buf, n, false);\n    return n > 0;\n  } else {\n    return mg_iobuf_add(&c->send, c->send.len, buf, len, MG_IO_SIZE);\n  }\n}\n\nstatic void mg_set_non_blocking_mode(SOCKET fd) {\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP\n  const BaseType_t off = 0;\n  setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off));\n  setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off));\n#elif MG_ARCH == MG_ARCH_FREERTOS_LWIP\n  lwip_fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n#else\n  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode\n  fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec\n#endif\n}\n\nstatic SOCKET mg_open_listener(const char *url, struct mg_addr *addr) {\n  SOCKET fd = INVALID_SOCKET;\n  int s_err = 0;  // Memoized socket error, in case closesocket() overrides it\n  memset(addr, 0, sizeof(*addr));\n  addr->port = mg_htons(mg_url_port(url));\n  if (!mg_aton(mg_url_host(url), addr)) {\n    LOG(LL_ERROR, (\"invalid listening URL: %s\", url));\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(addr, &usa);\n    int on = 1, af = addr->is_ip6 ? AF_INET6 : AF_INET;\n    int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;\n    int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;\n    (void) on;\n\n    if ((fd = socket(af, type, proto)) != INVALID_SOCKET &&\n#if (!defined(_WIN32) || !defined(SO_EXCLUSIVEADDRUSE)) && \\\n    (!defined(LWIP_SOCKET) || (defined(LWIP_SOCKET) && SO_REUSE == 1))\n        // 1. SO_RESUSEADDR is not enabled on Windows because the semantics of\n        //    SO_REUSEADDR on UNIX and Windows is different. On Windows,\n        //    SO_REUSEADDR allows to bind a socket to a port without error even\n        //    if the port is already open by another program. This is not the\n        //    behavior SO_REUSEADDR was designed for, and leads to hard-to-track\n        //    failure scenarios. Therefore, SO_REUSEADDR was disabled on Windows\n        //    unless SO_EXCLUSIVEADDRUSE is supported and set on a socket.\n        // 2. In case of LWIP, SO_REUSEADDR should be explicitly enabled, by\n        // defining\n        //    SO_REUSE (in lwipopts.h), otherwise the code below will compile\n        //    but won't work! (setsockopt will return EINVAL)\n        !setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on)) &&\n#endif\n#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE) && !defined(WINCE)\n        // \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\"\n        //! setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (char *) &on, sizeof(on))\n        //! &&\n        !setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *) &on,\n                    sizeof(on)) &&\n#endif\n        bind(fd, &usa.sa, slen) == 0 &&\n        // NOTE(lsm): FreeRTOS uses backlog value as a connection limit\n        (type == SOCK_DGRAM || listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE) == 0)) {\n      // In case port was set to 0, get the real port number\n      if (getsockname(fd, &usa.sa, &slen) == 0) {\n        addr->port = usa.sin.sin_port;\n#if MG_ENABLE_IPV6\n        if (addr->is_ip6) addr->port = usa.sin6.sin6_port;\n#endif\n      }\n      mg_set_non_blocking_mode(fd);\n    } else if (fd != INVALID_SOCKET) {\n      s_err = MG_SOCK_ERRNO;\n      closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n  if (fd == INVALID_SOCKET) {\n    if (s_err == 0) s_err = MG_SOCK_ERRNO;\n    LOG(LL_ERROR, (\"Failed to listen on %s, errno %d\", url, s_err));\n  }\n\n  return fd;\n}\n\nstatic long mg_sock_recv(struct mg_connection *c, void *buf, size_t len) {\n  long n = 0;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->peer, &usa);\n    n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);\n    if (n > 0) tomgaddr(&usa, &c->peer, slen != sizeof(usa.sin));\n  } else {\n    n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  return n == 0 ? -1 : n < 0 && mg_sock_would_block() ? 0 : n;\n}\n\n// NOTE(lsm): do only one iteration of reads, cause some systems\n// (e.g. FreeRTOS stack) return 0 instead of -1/EWOULDBLOCK when no data\nstatic long read_conn(struct mg_connection *c) {\n  long n = -1;\n  if (c->recv.len >= MG_MAX_RECV_BUF_SIZE) {\n    mg_error(c, \"max_recv_buf_size reached\");\n  } else if (c->recv.size - c->recv.len < MG_IO_SIZE &&\n             !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {\n    mg_error(c, \"oom\");\n  } else {\n    char *buf = (char *) &c->recv.buf[c->recv.len];\n    size_t len = c->recv.size - c->recv.len;\n    n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_sock_recv(c, buf, len);\n    iolog(c, buf, n, true);\n  }\n  return n;\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  char *buf = (char *) c->send.buf;\n  size_t len = c->send.len;\n  long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_sock_send(c, buf, len);\n  iolog(c, buf, n, false);\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  mg_resolve_cancel(c);  // Close any pending DNS query\n  LIST_DELETE(struct mg_connection, &c->mgr->conns, c);\n  if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;\n  if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;\n  // Order of operations is important. `MG_EV_CLOSE` event must be fired\n  // before we deallocate received data, see #1331\n  mg_call(c, MG_EV_CLOSE, NULL);\n  LOG(LL_DEBUG, (\"%lu closed\", c->id));\n  if (FD(c) != INVALID_SOCKET) {\n    closesocket(FD(c));\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP\n    FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);\n#endif\n    c->fd = S2PTR(INVALID_SOCKET);\n  }\n  mg_tls_free(c);\n  mg_iobuf_free(&c->recv);\n  mg_iobuf_free(&c->send);\n  memset(c, 0, sizeof(*c));\n  free(c);\n}\n\nstatic void setsockopts(struct mg_connection *c) {\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS\n  (void) c;\n#else\n  int on = 1;\n#if !defined(SOL_TCP)\n#define SOL_TCP IPPROTO_TCP\n#endif\n  setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on));\n#if defined(TCP_QUICKACK)\n  setsockopt(FD(c), SOL_TCP, TCP_QUICKACK, (char *) &on, sizeof(on));\n#endif\n  setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on));\n#if (defined(ESP32) && ESP32) || (defined(ESP8266) && ESP8266) || \\\n    defined(__linux__)\n  int idle = 60;\n  setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle));\n#endif\n#if !defined(_WIN32) && !defined(__QNX__)\n  {\n    int cnt = 3, intvl = 20;\n    setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));\n    setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl));\n  }\n#endif\n#endif\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  // char buf[40];\n  int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n  int rc, af = c->peer.is_ip6 ? AF_INET6 : AF_INET;\n  // mg_straddr(&c->peer, buf, sizeof(buf));\n  c->fd = S2PTR(socket(af, type, 0));\n  if (FD(c) == INVALID_SOCKET) {\n    mg_error(c, \"socket(): %d\", MG_SOCK_ERRNO);\n  } else if (c->is_udp) {\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->peer, &usa);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    if ((rc = connect(FD(c), &usa.sa, slen)) == 0) {\n      mg_call(c, MG_EV_CONNECT, NULL);\n    } else if (mg_sock_would_block()) {\n      c->is_connecting = 1;\n    } else {\n      mg_error(c, \"connect: %d\", MG_SOCK_ERRNO);\n    }\n  }\n}\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,\n                                 mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if (url == NULL || url[0] == '\\0') {\n    LOG(LL_ERROR, (\"null url\"));\n  } else if ((c = alloc_conn(mgr, 1, INVALID_SOCKET)) == NULL) {\n    LOG(LL_ERROR, (\"OOM\"));\n  } else {\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_udp = (strncmp(url, \"udp:\", 4) == 0);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    LOG(LL_DEBUG, (\"%lu -> %s\", c->id, url));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_resolve(c, url);\n  }\n  return c;\n}\n\nstatic void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {\n  struct mg_connection *c = NULL;\n  union usa usa;\n  socklen_t sa_len = sizeof(usa);\n  SOCKET fd = accept(FD(lsn), &usa.sa, &sa_len);\n  if (fd == INVALID_SOCKET) {\n#if MG_ARCH == MG_ARCH_AZURERTOS\n    // AzureRTOS, in non-block socket mode can mark listening socket readable\n    // even it is not. See comment for 'select' func implementation in nx_bsd.c\n    // That's not an error, just should try later\n    if (MG_SOCK_ERRNO != EAGAIN)\n#endif\n      LOG(LL_ERROR, (\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERRNO));\n#if (!defined(_WIN32) && (MG_ARCH != MG_ARCH_FREERTOS_TCP))\n  } else if ((long) fd >= FD_SETSIZE) {\n    LOG(LL_ERROR, (\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));\n    closesocket(fd);\n#endif\n  } else if ((c = alloc_conn(mgr, 0, fd)) == NULL) {\n    LOG(LL_ERROR, (\"%lu OOM\", lsn->id));\n    closesocket(fd);\n  } else {\n    char buf[40];\n    tomgaddr(&usa, &c->peer, sa_len != sizeof(usa.sin));\n    mg_straddr(&c->peer, buf, sizeof(buf));\n    LOG(LL_DEBUG, (\"%lu accepted %s\", c->id, buf));\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_accepted = 1;\n    c->is_hexdumping = lsn->is_hexdumping;\n    c->pfn = lsn->pfn;\n    c->pfn_data = lsn->pfn_data;\n    c->fn = lsn->fn;\n    c->fn_data = lsn->fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_call(c, MG_EV_ACCEPT, NULL);\n  }\n}\n\nstatic bool mg_socketpair(SOCKET sp[2], union usa usa[2]) {\n  socklen_t n = sizeof(usa[0].sin);\n  bool result = false;\n\n  (void) memset(&usa[0], 0, sizeof(usa[0]));\n  usa[0].sin.sin_family = AF_INET;\n  *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001);  // 127.0.0.1\n  usa[1] = usa[0];\n\n  if ((sp[0] = socket(AF_INET, SOCK_DGRAM, 0)) != INVALID_SOCKET &&\n      (sp[1] = socket(AF_INET, SOCK_DGRAM, 0)) != INVALID_SOCKET &&\n      bind(sp[0], &usa[0].sa, n) == 0 && bind(sp[1], &usa[1].sa, n) == 0 &&\n      getsockname(sp[0], &usa[0].sa, &n) == 0 &&\n      getsockname(sp[1], &usa[1].sa, &n) == 0 &&\n      connect(sp[0], &usa[1].sa, n) == 0 &&\n      connect(sp[1], &usa[0].sa, n) == 0) {\n    mg_set_non_blocking_mode(sp[1]);  // Set close-on-exec\n    result = true;\n  } else {\n    if (sp[0] != INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != INVALID_SOCKET) closesocket(sp[1]);\n    sp[0] = sp[1] = INVALID_SOCKET;\n  }\n\n  return result;\n}\n\nvoid mg_mgr_wakeup(struct mg_connection *c) {\n  LOG(LL_INFO, (\"skt: %p\", c->pfn_data));\n  send((SOCKET) (size_t) c->pfn_data, \"\\x01\", 1, MSG_NONBLOCKING);\n}\n\nstatic void pf1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_READ) mg_iobuf_free(&c->recv);\n  (void) ev_data, (void) fn_data;\n}\n\nstruct mg_connection *mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn,\n                                void *fn_data) {\n  union usa usa[2];\n  SOCKET sp[2] = {INVALID_SOCKET, INVALID_SOCKET};\n  struct mg_connection *c = NULL;\n  if (!mg_socketpair(sp, usa)) {\n    LOG(LL_ERROR, (\"Cannot create socket pair\"));\n  } else if ((c = alloc_conn(mgr, false, sp[1])) == NULL) {\n    closesocket(sp[0]);\n    closesocket(sp[1]);\n    LOG(LL_ERROR, (\"OOM\"));\n  } else {\n    LOG(LL_INFO, (\"pipe %lu\", (unsigned long) sp[0]));\n    tomgaddr(&usa[0], &c->peer, false);\n    c->is_udp = 1;\n    c->pfn = pf1;\n    c->pfn_data = (void *) (size_t) sp[0];\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n  }\n  return c;\n}\n\nstruct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  bool is_udp = strncmp(url, \"udp:\", 4) == 0;\n  struct mg_addr addr;\n  SOCKET fd = mg_open_listener(url, &addr);\n  if (fd == INVALID_SOCKET) {\n    LOG(LL_ERROR, (\"Failed: %s, errno %d\", url, MG_SOCK_ERRNO));\n  } else if ((c = alloc_conn(mgr, 0, fd)) == NULL) {\n    LOG(LL_ERROR, (\"OOM %s\", url));\n    closesocket(fd);\n  } else {\n    memcpy(&c->peer, &addr, sizeof(struct mg_addr));\n    c->fd = S2PTR(fd);\n    c->is_listening = 1;\n    c->is_udp = is_udp;\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    LOG(LL_DEBUG,\n        (\"%lu accepting on %s (port %u)\", c->id, url, mg_ntohs(c->peer.port)));\n  }\n  return c;\n}\n\nstatic void mg_iotest(struct mg_mgr *mgr, int ms) {\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_closing || c->is_resolving || FD(c) == INVALID_SOCKET) continue;\n    FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);\n    if (c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0))\n      FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);\n  }\n  FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);\n    c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1 : 0;\n    c->is_writable = bits & eSELECT_WRITE ? 1 : 0;\n    FreeRTOS_FD_CLR(c->fd, mgr->ss,\n                    eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);\n  }\n#else\n  struct timeval tv = {ms / 1000, (ms % 1000) * 1000};\n  struct mg_connection *c;\n  fd_set rset, wset;\n  SOCKET maxfd = 0;\n  int rc;\n\n  FD_ZERO(&rset);\n  FD_ZERO(&wset);\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_closing || c->is_resolving || FD(c) == INVALID_SOCKET) continue;\n    FD_SET(FD(c), &rset);\n    if (FD(c) > maxfd) maxfd = FD(c);\n    if (c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0))\n      FD_SET(FD(c), &wset);\n  }\n\n  if ((rc = select((int) maxfd + 1, &rset, &wset, NULL, &tv)) < 0) {\n    LOG(LL_DEBUG, (\"select: %d %d\", rc, MG_SOCK_ERRNO));\n    FD_ZERO(&rset);\n    FD_ZERO(&wset);\n  }\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    // TLS might have stuff buffered, so dig everything\n    c->is_readable = FD(c) != INVALID_SOCKET && FD_ISSET(FD(c), &rset);\n    c->is_writable = FD(c) != INVALID_SOCKET && FD_ISSET(FD(c), &wset);\n  }\n#endif\n}\n\nstatic void connect_conn(struct mg_connection *c) {\n  int rc = 0;\n#if MG_ARCH != MG_ARCH_FREERTOS_TCP\n  socklen_t len = sizeof(rc);\n  if (getsockopt(FD(c), SOL_SOCKET, SO_ERROR, (char *) &rc, &len)) rc = 1;\n#endif\n  if (rc == EAGAIN || rc == EWOULDBLOCK) rc = 0;\n  c->is_connecting = 0;\n  if (rc) {\n    char buf[50];\n    mg_error(c, \"error connecting to %s\",\n             mg_straddr(&c->peer, buf, sizeof(buf)));\n  } else {\n    if (c->is_tls_hs) mg_tls_handshake(c);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  }\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  int64_t now;\n\n  mg_iotest(mgr, ms);\n  now = mg_millis();\n  mg_timer_poll(now);\n\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu %c%c %c%c%c%c%c\", c->id, c->is_readable ? 'r' : '-',\n         c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',\n         c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n         c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_resolving || c->is_closing) {\n      // Do nothing\n    } else if (c->is_listening && c->is_udp == 0) {\n      if (c->is_readable) accept_conn(mgr, c);\n    } else if (c->is_connecting) {\n      if (c->is_readable || c->is_writable) connect_conn(c);\n    } else if (c->is_tls_hs) {\n      if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);\n    } else {\n      if (c->is_readable) read_conn(c);\n      if (c->is_writable) write_conn(c);\n      while (c->is_tls && read_conn(c) > 0) (void) 0;  // Read buffered TLS data\n    }\n\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ssi.c\"\n#endif\n\n\n\n\n#ifndef MG_MAX_SSI_DEPTH\n#define MG_MAX_SSI_DEPTH 5\n#endif\n\n#if MG_ENABLE_SSI\nstatic char *mg_ssi(const char *path, const char *root, int depth) {\n  struct mg_iobuf b = {NULL, 0, 0};\n  FILE *fp = fopen(path, \"rb\");\n  if (fp != NULL) {\n    char buf[BUFSIZ], arg[sizeof(buf)];\n    int ch, intag = 0;\n    size_t len = 0, align = MG_IO_SIZE;\n    while ((ch = fgetc(fp)) != EOF) {\n      if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n        buf[len++] = (char) (ch & 0xff);\n        if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + BUFSIZ + 10],\n              *p = (char *) path + strlen(path), *data;\n          while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;\n          snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data), align);\n            free(data);\n          } else {\n            LOG(LL_ERROR, (\"%s: file=%s error or too deep\", path, arg));\n          }\n        } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + BUFSIZ + 10], *data;\n          snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data), align);\n            free(data);\n          } else {\n            LOG(LL_ERROR, (\"%s: virtual=%s error or too deep\", path, arg));\n          }\n        } else {\n          // Unknown SSI tag\n          LOG(LL_INFO, (\"Unknown SSI tag: %.*s\", (int) len, buf));\n          mg_iobuf_add(&b, b.len, buf, len, align);\n        }\n        intag = 0;\n        len = 0;\n      } else if (ch == '<') {\n        intag = 1;\n        if (len > 0) mg_iobuf_add(&b, b.len, buf, len, align);\n        len = 0;\n        buf[len++] = (char) (ch & 0xff);\n      } else if (intag) {\n        if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {\n          intag = 0;\n        } else if (len >= sizeof(buf) - 2) {\n          LOG(LL_ERROR, (\"%s: SSI tag is too large\", path));\n          len = 0;\n        }\n        buf[len++] = (char) (ch & 0xff);\n      } else {\n        buf[len++] = (char) (ch & 0xff);\n        if (len >= sizeof(buf)) {\n          mg_iobuf_add(&b, b.len, buf, len, align);\n          len = 0;\n        }\n      }\n    }\n    if (len > 0) mg_iobuf_add(&b, b.len, buf, len, align);\n    if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1, align);  // nul-terminate\n    fclose(fp);\n  }\n  (void) depth;\n  (void) root;\n  return (char *) b.buf;\n}\n\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";\n  char *data = mg_ssi(fullpath, root, 0);\n  mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);\n  free(data);\n}\n#else\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  mg_http_reply(c, 501, NULL, \"SSI not enabled\");\n  (void) root, (void) fullpath;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/str.c\"\n#endif\n\n#include <stdlib.h>\n\nstruct mg_str mg_str_s(const char *s) {\n  struct mg_str str = {s, s == NULL ? 0 : strlen(s)};\n  return str;\n}\n\nstruct mg_str mg_str_n(const char *s, size_t n) {\n  struct mg_str str = {s, n};\n  return str;\n}\n\nint mg_lower(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n  if (len > 0) do {\n      diff = mg_lower(s1++) - mg_lower(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_vcmp(const struct mg_str *s1, const char *s2) {\n  size_t n2 = strlen(s2), n1 = s1->len;\n  int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.ptr != NULL) {\n    char *sc = (char *) calloc(1, s.len + 1);\n    if (sc != NULL) {\n      memcpy(sc, s.ptr, s.len);\n      sc[s.len] = '\\0';\n      r.ptr = sc;\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = str1.ptr[i];\n    int c2 = str2.ptr[i];\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nconst char *mg_strstr(const struct mg_str haystack,\n                      const struct mg_str needle) {\n  size_t i;\n  if (needle.len > haystack.len) return NULL;\n  for (i = 0; i <= haystack.len - needle.len; i++) {\n    if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {\n      return haystack.ptr + i;\n    }\n  }\n  return NULL;\n}\n\nstruct mg_str mg_strstrip(struct mg_str s) {\n  while (s.len > 0 && isspace((int) *s.ptr)) s.ptr++, s.len--;\n  while (s.len > 0 && isspace((int) *(s.ptr + s.len - 1))) s.len--;\n  return s;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/timer.c\"\n#endif\n// Copyright (c) Cesanta Software Limited\n// All rights reserved\n\n\n\n\nstruct mg_timer *g_timers;\n\nvoid mg_timer_init(struct mg_timer *t, int64_t ms, unsigned flags,\n                   void (*fn)(void *), void *arg) {\n  struct mg_timer tmp = {ms, 0UL, flags, fn, arg, g_timers};\n  *t = tmp;\n  g_timers = t;\n  if (flags & MG_TIMER_RUN_NOW) fn(arg);\n}\n\nvoid mg_timer_free(struct mg_timer *t) {\n  struct mg_timer **head = &g_timers;\n  while (*head && *head != t) head = &(*head)->next;\n  if (*head) *head = t->next;\n}\n\nvoid mg_timer_poll(int64_t now_ms) {\n  // If time goes back (wrapped around), reset timers\n  struct mg_timer *t, *tmp;\n  static int64_t oldnow;  // Timestamp in a previous invocation\n  if (oldnow > now_ms) {  // If it is wrapped, reset timers\n    for (t = g_timers; t != NULL; t = t->next) t->expire = 0;\n  }\n  oldnow = now_ms;\n\n  for (t = g_timers; t != NULL; t = tmp) {\n    tmp = t->next;\n    if (t->expire == 0) t->expire = now_ms + t->period_ms;\n    if (t->expire > now_ms) continue;\n    t->fn(t->arg);\n    // Try to tick timers with the given period as accurate as possible,\n    // even if this polling function is called with some random period.\n    t->expire = now_ms - t->expire > t->period_ms ? now_ms + t->period_ms\n                                                  : t->expire + t->period_ms;\n    if (!(t->flags & MG_TIMER_REPEAT)) mg_timer_free(t);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_dummy.c\"\n#endif\n\n\n#if !MG_ENABLE_MBEDTLS && !MG_ENABLE_OPENSSL && !MG_ENABLE_CUSTOM_TLS\nvoid mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {\n  (void) opts;\n  mg_error(c, \"TLS is not enabled\");\n}\nvoid mg_tls_handshake(struct mg_connection *c) {\n  (void) c;\n}\nvoid mg_tls_free(struct mg_connection *c) {\n  (void) c;\n}\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_mbed.c\"\n#endif\n\n\n#if MG_ENABLE_MBEDTLS\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc;\n  mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mbedtls_net_send, mbedtls_net_recv, 0);\n  rc = mbedtls_ssl_handshake(&tls->ssl);\n  if (rc == 0) {  // Success\n    LOG(LL_DEBUG, (\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n  } else if (rc == MBEDTLS_ERR_SSL_WANT_READ ||\n             rc == MBEDTLS_ERR_SSL_WANT_WRITE) {  // Still pending\n    LOG(LL_VERBOSE_DEBUG, (\"%lu pending, %d%d %d (-%#x)\", c->id,\n                           c->is_connecting, c->is_tls_hs, rc, -rc));\n  } else {\n    mg_error(c, \"TLS handshake: -%#x\", -rc);  // Error\n  }\n}\n\nstatic int mbed_rng(void *ctx, unsigned char *buf, size_t len) {\n  mg_random(buf, len);\n  (void) ctx;\n  return 0;\n}\n\nstatic void debug_cb(void *c, int lev, const char *s, int n, const char *s2) {\n  n = (int) strlen(s2) - 1;\n  LOG(LL_VERBOSE_DEBUG, (\"%p %.*s\", ((struct mg_connection *) c)->fd, n, s2));\n  (void) s;\n  (void) c;\n  (void) lev;\n}\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\nstatic int rng_get(void *p_rng, unsigned char *buf, size_t len) {\n  (void) p_rng;\n  mg_random(buf, len);\n  return 0;\n}\n#endif\n\nvoid mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  int rc = 0;\n  const char *ca = opts->ca == NULL     ? \"-\"\n                   : opts->ca[0] == '-' ? \"(emb)\"\n                                        : opts->ca;\n  const char *crl = opts->crl == NULL     ? \"-\"\n                    : opts->crl[0] == '-' ? \"(emb)\"\n                                          : opts->crl;\n  const char *cert = opts->cert == NULL     ? \"-\"\n                     : opts->cert[0] == '-' ? \"(emb)\"\n                                            : opts->cert;\n  const char *certkey = opts->certkey == NULL     ? \"-\"\n                        : opts->certkey[0] == '-' ? \"(emb)\"\n                                                  : opts->certkey;\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n  LOG(LL_DEBUG, (\"%lu Setting TLS, CA: %s, CRL: %s, cert: %s, key: %s\", c->id,\n                 ca, crl, cert, certkey));\n  mbedtls_ssl_init(&tls->ssl);\n  mbedtls_ssl_config_init(&tls->conf);\n  mbedtls_x509_crt_init(&tls->ca);\n  mbedtls_x509_crl_init(&tls->crl);\n  mbedtls_x509_crt_init(&tls->cert);\n  mbedtls_pk_init(&tls->pk);\n  mbedtls_ssl_conf_dbg(&tls->conf, debug_cb, c);\n  //#if !defined(ESP_PLATFORM)\n  // mbedtls_debug_set_threshold(5);\n  //#endif\n  if ((rc = mbedtls_ssl_config_defaults(\n           &tls->conf,\n           c->is_client ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,\n           MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {\n    mg_error(c, \"tls defaults %#x\", -rc);\n    goto fail;\n  }\n  mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);\n  if (opts->ca == NULL || strcmp(opts->ca, \"*\") == 0) {\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);\n  }\n  if (opts->ca != NULL && opts->ca[0] != '\\0') {\n    if (opts->crl != NULL && opts->crl[0] != '\\0') {\n      rc = opts->crl[0] == '-'\n               ? mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) opts->crl,\n                                        strlen(opts->crl) + 1)\n               : mbedtls_x509_crl_parse_file(&tls->crl, opts->crl);\n      if (rc != 0) {\n        mg_error(c, \"parse(%s) err %#x\", crl, -rc);\n        goto fail;\n      }\n    }\n#if defined(MBEDTLS_X509_CA_CHAIN_ON_DISK)\n    tls->cafile = strdup(opts->ca);\n    rc = mbedtls_ssl_conf_ca_chain_file(&tls->conf, tls->cafile, &tls->crl);\n    if (rc != 0) {\n      mg_error(c, \"parse on-disk chain(%s) err %#x\", ca, -rc);\n      goto fail;\n    }\n#else\n    rc = opts->ca[0] == '-'\n             ? mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) opts->ca,\n                                      strlen(opts->ca) + 1)\n             : mbedtls_x509_crt_parse_file(&tls->ca, opts->ca);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", ca, -rc);\n      goto fail;\n    }\n    mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, &tls->crl);\n#endif\n    if (opts->srvname.len > 0) {\n      char mem[128], *buf = mem;\n      mg_asprintf(&buf, sizeof(mem), \"%.*s\", (int) opts->srvname.len,\n                  opts->srvname.ptr);\n      mbedtls_ssl_set_hostname(&tls->ssl, buf);\n      if (buf != mem) free(buf);\n    }\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    const char *key = opts->certkey;\n    if (key == NULL) {\n      key = opts->cert;\n      certkey = cert;\n    }\n    rc = opts->cert[0] == '-'\n             ? mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) opts->cert,\n                                      strlen(opts->cert) + 1)\n             : mbedtls_x509_crt_parse_file(&tls->cert, opts->cert);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", cert, -rc);\n      goto fail;\n    }\n    rc = key[0] == '-' ? mbedtls_pk_parse_key(&tls->pk, (uint8_t *) key,\n                                              strlen(key) + 1, NULL, 0 RNG)\n                       : mbedtls_pk_parse_keyfile(&tls->pk, key, NULL RNG);\n    if (rc != 0) {\n      mg_error(c, \"tls key(%s) %#x\", certkey, -rc);\n      goto fail;\n    }\n    rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);\n    if (rc != 0) {\n      mg_error(c, \"own cert %#x\", -rc);\n      goto fail;\n    }\n  }\n  if ((rc = mbedtls_ssl_setup(&tls->ssl, &tls->conf)) != 0) {\n    mg_error(c, \"setup err %#x\", -rc);\n    goto fail;\n  }\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  return;\nfail:\n  c->is_closing = 1;\n  free(tls);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_read(&tls->ssl, (unsigned char *) buf, len);\n  return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_READ ? 0 : n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);\n  return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_WRITE ? 0 : n;\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  free(tls->cafile);\n  mbedtls_ssl_free(&tls->ssl);\n  mbedtls_pk_free(&tls->pk);\n  mbedtls_x509_crt_free(&tls->ca);\n  mbedtls_x509_crl_free(&tls->crl);\n  mbedtls_x509_crt_free(&tls->cert);\n  mbedtls_ssl_config_free(&tls->conf);\n  free(tls);\n  c->tls = NULL;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_openssl.c\"\n#endif\n\n\n#if MG_ENABLE_OPENSSL\nstatic int mg_tls_err(struct mg_tls *tls, int res) {\n  int err = SSL_get_error(tls->ssl, res);\n  // We've just fetched the last error from the queue.\n  // Now we need to clear the error queue. If we do not, then the following\n  // can happen (actually reported):\n  //  - A new connection is accept()-ed with cert error (e.g. self-signed cert)\n  //  - Since all accept()-ed connections share listener's context,\n  //  - *ALL* SSL accepted connection report read error on the next poll cycle.\n  //    Thus a single errored connection can close all the rest, unrelated ones.\n  // Clearing the error keeps the shared SSL_CTX in an OK state.\n\n  if (err != 0) ERR_print_errors_fp(stderr);\n  ERR_clear_error();\n  if (err == SSL_ERROR_WANT_READ) return 0;\n  if (err == SSL_ERROR_WANT_WRITE) return 0;\n  return err;\n}\n\nvoid mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  const char *id = \"mongoose\";\n  static unsigned char s_initialised = 0;\n  int rc;\n\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n\n  if (!s_initialised) {\n    SSL_library_init();\n    s_initialised++;\n  }\n  LOG(LL_DEBUG, (\"%lu Setting TLS, CA: %s, cert: %s, key: %s\", c->id,\n                 opts->ca == NULL ? \"null\" : opts->ca,\n                 opts->cert == NULL ? \"null\" : opts->cert,\n                 opts->certkey == NULL ? \"null\" : opts->certkey));\n  tls->ctx = c->is_client ? SSL_CTX_new(SSLv23_client_method())\n                          : SSL_CTX_new(SSLv23_server_method());\n  if ((tls->ssl = SSL_new(tls->ctx)) == NULL) {\n    mg_error(c, \"SSL_new\");\n    goto fail;\n  }\n  SSL_set_session_id_context(tls->ssl, (const uint8_t *) id,\n                             (unsigned) strlen(id));\n  // Disable deprecated protocols\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv2);\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv3);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1_1);\n#ifdef MG_ENABLE_OPENSSL_NO_COMPRESSION\n  SSL_set_options(tls->ssl, SSL_OP_NO_COMPRESSION);\n#endif\n#ifdef MG_ENABLE_OPENSSL_CIPHER_SERVER_PREFERENCE\n  SSL_set_options(tls->ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n#endif\n\n  if (opts->ca != NULL && opts->ca[0] != '\\0') {\n    SSL_set_verify(tls->ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                   NULL);\n    if ((rc = SSL_CTX_load_verify_locations(tls->ctx, opts->ca, NULL)) != 1) {\n      mg_error(c, \"parse(%s): err %d\", opts->ca, mg_tls_err(tls, rc));\n      goto fail;\n    }\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    const char *key = opts->certkey;\n    if (key == NULL) key = opts->cert;\n    if ((rc = SSL_use_certificate_file(tls->ssl, opts->cert, 1)) != 1) {\n      mg_error(c, \"Invalid SSL cert, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n    } else if ((rc = SSL_use_PrivateKey_file(tls->ssl, key, 1)) != 1) {\n      mg_error(c, \"Invalid SSL key, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n    } else if ((rc = SSL_use_certificate_chain_file(tls->ssl, opts->cert)) !=\n               1) {\n      mg_error(c, \"Invalid CA, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#endif\n    } else {\n      SSL_set_mode(tls->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n      SSL_set_ecdh_auto(tls->ssl, 1);\n#endif\n    }\n  }\n  if (opts->ciphers != NULL) SSL_set_cipher_list(tls->ssl, opts->ciphers);\n  if (opts->srvname.len > 0) {\n    char mem[128], *buf = mem;\n    mg_asprintf(&buf, sizeof(mem), \"%.*s\", (int) opts->srvname.len,\n                opts->srvname.ptr);\n    SSL_set_tlsext_host_name(tls->ssl, buf);\n    if (buf != mem) free(buf);\n  }\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  LOG(LL_DEBUG, (\"%lu SSL %s OK\", c->id, c->is_accepted ? \"accept\" : \"client\"));\n  return;\nfail:\n  c->is_closing = 1;\n  free(tls);\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc;\n  SSL_set_fd(tls->ssl, (int) (size_t) c->fd);\n  rc = c->is_client ? SSL_connect(tls->ssl) : SSL_accept(tls->ssl);\n  if (rc == 1) {\n    LOG(LL_DEBUG, (\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n  } else {\n    int code = mg_tls_err(tls, rc);\n    if (code != 0) mg_error(c, \"tls hs: rc %d, err %d\", rc, code);\n  }\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  SSL_free(tls->ssl);\n  SSL_CTX_free(tls->ctx);\n  free(tls);\n  c->tls = NULL;\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_read(tls->ssl, buf, (int) len);\n  return n == 0 ? -1 : n < 0 && mg_tls_err(tls, n) == 0 ? 0 : n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_write(tls->ssl, buf, (int) len);\n  return n == 0 ? -1 : n < 0 && mg_tls_err(tls, n) == 0 ? 0 : n;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/url.c\"\n#endif\n\n#include <stdlib.h>\n\nstruct url {\n  size_t key, user, pass, host, port, uri, end;\n};\n\nint mg_url_is_ssl(const char *url) {\n  return strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0 ||\n         strncmp(url, \"mqtts:\", 6) == 0 || strncmp(url, \"ssl:\", 4) == 0 ||\n         strncmp(url, \"tls:\", 4) == 0;\n}\n\nstatic struct url urlparse(const char *url) {\n  size_t i;\n  struct url u;\n  memset(&u, 0, sizeof(u));\n  for (i = 0; url[i] != '\\0'; i++) {\n    if (i > 0 && u.host == 0 && url[i - 1] == '/' && url[i] == '/') {\n      u.host = i + 1;\n      u.port = 0;\n    } else if (url[i] == ']') {\n      u.port = 0;  // IPv6 URLs, like http://[::1]/bar\n    } else if (url[i] == ':' && u.port == 0 && u.uri == 0) {\n      u.port = i + 1;\n    } else if (url[i] == '@' && u.user == 0 && u.pass == 0) {\n      u.user = u.host;\n      u.pass = u.port;\n      u.host = i + 1;\n      u.port = 0;\n    } else if (u.host && u.uri == 0 && url[i] == '/') {\n      u.uri = i;\n    }\n  }\n  u.end = i;\n#if 0\n  printf(\"[%s] %d %d %d %d %d\\n\", url, u.user, u.pass, u.host, u.port, u.uri);\n#endif\n  return u;\n}\n\nstruct mg_str mg_url_host(const char *url) {\n  struct url u = urlparse(url);\n  size_t n = u.port  ? u.port - u.host - 1\n             : u.uri ? u.uri - u.host\n                     : u.end - u.host;\n  struct mg_str s = mg_str_n(url + u.host, n);\n  return s;\n}\n\nconst char *mg_url_uri(const char *url) {\n  struct url u = urlparse(url);\n  return u.uri ? url + u.uri : \"/\";\n}\n\nunsigned short mg_url_port(const char *url) {\n  struct url u = urlparse(url);\n  unsigned short port = 0;\n  if (strncmp(url, \"http:\", 5) == 0 || strncmp(url, \"ws:\", 3) == 0) port = 80;\n  if (strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0)\n    port = 443;\n  if (strncmp(url, \"mqtt:\", 5) == 0) port = 1883;\n  if (strncmp(url, \"mqtts:\", 6) == 0) port = 8883;\n  if (u.port) port = (unsigned short) atoi(url + u.port);\n  return port;\n}\n\nstruct mg_str mg_url_user(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str(\"\");\n  if (u.user && (u.pass || u.host)) {\n    size_t n = u.pass ? u.pass - u.user - 1 : u.host - u.user - 1;\n    s = mg_str_n(url + u.user, n);\n  }\n  return s;\n}\n\nstruct mg_str mg_url_pass(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str_n(\"\", 0UL);\n  if (u.pass && u.host) {\n    size_t n = u.host - u.pass - 1;\n    s = mg_str_n(url + u.pass, n);\n  }\n  return s;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/util.c\"\n#endif\n\n\n#if MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)\n#include <mach/mach_time.h>\n#endif\n\n#if MG_ENABLE_FILE\nchar *mg_file_read(const char *path, size_t *sizep) {\n  FILE *fp;\n  char *data = NULL;\n  size_t size = 0;\n  if ((fp = fopen(path, \"rb\")) != NULL) {\n    fseek(fp, 0, SEEK_END);\n    size = (size_t) ftell(fp);\n    rewind(fp);\n    data = (char *) calloc(1, size + 1);\n    if (data != NULL) {\n      if (fread(data, 1, size, fp) != size) {\n        free(data);\n        data = NULL;\n      } else {\n        data[size] = '\\0';\n        if (sizep != NULL) *sizep = size;\n      }\n    }\n    fclose(fp);\n  }\n  return data;\n}\n\nbool mg_file_write(const char *path, const void *buf, size_t len) {\n  bool result = false;\n  FILE *fp;\n  char tmp[MG_PATH_MAX];\n  snprintf(tmp, sizeof(tmp), \"%s.%d\", path, rand());\n  fp = fopen(tmp, \"wb\");\n  if (fp != NULL) {\n    result = fwrite(buf, 1, len, fp) == len;\n    fclose(fp);\n    if (result) {\n      remove(path);\n      rename(tmp, path);\n    } else {\n      remove(tmp);\n    }\n  }\n  return result;\n}\n\nbool mg_file_printf(const char *path, const char *fmt, ...) {\n  char tmp[256], *buf = tmp;\n  bool result;\n  int len;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);\n  va_end(ap);\n  result = mg_file_write(path, buf, len > 0 ? (size_t) len : 0);\n  if (buf != tmp) free(buf);\n  return result;\n}\n#endif\n\n#if MG_ENABLE_CUSTOM_RANDOM\n#else\nvoid mg_random(void *buf, size_t len) {\n  bool done = false;\n  unsigned char *p = (unsigned char *) buf;\n#if MG_ARCH == MG_ARCH_ESP32\n  while (len--) *p++ = (unsigned char) (esp_random() & 255);\n  done = true;\n#elif MG_ARCH == MG_ARCH_WIN32\n#elif MG_ARCH == MG_ARCH_UNIX\n  FILE *fp = fopen(\"/dev/urandom\", \"rb\");\n  if (fp != NULL) {\n    if (fread(buf, 1, len, fp) == len) done = true;\n    fclose(fp);\n  }\n#endif\n  // If everything above did not work, fallback to a pseudo random generator\n  while (!done && len--) *p++ = (unsigned char) (rand() & 255);\n}\n#endif\n\nbool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {\n  size_t i = 0, j = 0, ni = 0, nj = 0;\n  while (i < n1 || j < n2) {\n    if (i < n1 && j < n2 && (s1[i] == '?' || s2[j] == s1[i])) {\n      i++, j++;\n    } else if (i < n1 && (s1[i] == '*' || s1[i] == '#')) {\n      ni = i, nj = j + 1, i++;\n    } else if (nj > 0 && nj <= n2 && (s1[ni] == '#' || s2[j] != '/')) {\n      i = ni, j = nj;\n    } else {\n      // printf(\">>: [%s] [%s] %d %d %d %d\\n\", s1, s2, i, j, ni, nj);\n      return false;\n    }\n  }\n  return true;\n}\n\nstatic size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,\n                     size_t *klen, size_t *voff, size_t *vlen) {\n  size_t kvlen, kl;\n  for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != ',';) kvlen++;\n  for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;\n  if (koff != NULL) *koff = ofs;\n  if (klen != NULL) *klen = kl;\n  if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;\n  if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;\n  ofs += kvlen + 1;\n  return ofs > n ? n : ofs;\n}\n\nbool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {\n  size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;\n  if (s->ptr == NULL || s->len == 0) return 0;\n  off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen);\n  if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);\n  if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);\n  *s = mg_str_n(s->ptr + off, s->len - off);\n  return off > 0;\n}\n\nuint32_t mg_ntohl(uint32_t net) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |\n         (((uint32_t) data[1]) << 16) | (((uint32_t) data[0]) << 24);\n}\n\nuint16_t mg_ntohs(uint16_t net) {\n  uint8_t data[2] = {0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));\n}\n\nchar *mg_hexdump(const void *buf, size_t len) {\n  const unsigned char *p = (const unsigned char *) buf;\n  size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;\n  char ascii[17] = \"\", *dst = (char *) calloc(1, dlen);\n  if (dst == NULL) return dst;\n  for (i = 0; i < len; i++) {\n    idx = i % 16;\n    if (idx == 0) {\n      if (i > 0 && dlen > n)\n        n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);\n      if (dlen > n)\n        n += (size_t) snprintf(dst + n, dlen - n, \"%04x \", (int) (i + ofs));\n    }\n    if (dlen < n) break;\n    n += (size_t) snprintf(dst + n, dlen - n, \" %02x\", p[i]);\n    ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);\n    ascii[idx + 1] = '\\0';\n  }\n  while (i++ % 16) {\n    if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"%s\", \"   \");\n  }\n  if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);\n  if (n > dlen - 1) n = dlen - 1;\n  dst[n] = '\\0';\n  return dst;\n}\n\nchar *mg_hex(const void *buf, size_t len, char *to) {\n  const unsigned char *p = (const unsigned char *) buf;\n  static const char *hex = \"0123456789abcdef\";\n  size_t i = 0;\n  for (; len--; p++) {\n    to[i++] = hex[p[0] >> 4];\n    to[i++] = hex[p[0] & 0x0f];\n  }\n  to[i] = '\\0';\n  return to;\n}\n\nstatic unsigned char mg_unhex_nimble(unsigned char c) {\n  return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')\n         : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')\n                                  : (unsigned char) (c - 'W');\n}\n\nunsigned long mg_unhexn(const char *s, size_t len) {\n  unsigned long i = 0, v = 0;\n  for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);\n  return v;\n}\n\nvoid mg_unhex(const char *buf, size_t len, unsigned char *to) {\n  size_t i;\n  for (i = 0; i < len; i += 2) {\n    to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);\n  }\n}\n\nint mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  va_copy(ap_copy, ap);\n  len = vsnprintf(*buf, size, fmt, ap_copy);\n  va_end(ap_copy);\n\n  if (len < 0) {\n    // eCos and Windows are not standard-compliant and return -1 when\n    // the buffer is too small. Keep allocating larger buffers until we\n    // succeed or out of memory.\n    // LCOV_EXCL_START\n    *buf = NULL;\n    while (len < 0) {\n      free(*buf);\n      if (size == 0) size = 5;\n      size *= 2;\n      if ((*buf = (char *) calloc(1, size)) == NULL) {\n        len = -1;\n        break;\n      }\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, size - 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n    // Microsoft version of vsnprintf() is not always null-terminated, so put\n    // the terminator manually\n    if (*buf != NULL) (*buf)[len] = 0;\n    // LCOV_EXCL_STOP\n  } else if (len >= (int) size) {\n    /// Standard-compliant code path. Allocate a buffer that is large enough\n    if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {\n      len = -1;  // LCOV_EXCL_LINE\n    } else {     // LCOV_EXCL_LINE\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n  }\n\n  return len;\n}\n\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) {\n  int ret;\n  va_list ap;\n  va_start(ap, fmt);\n  ret = mg_vasprintf(buf, size, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\nint64_t mg_to64(struct mg_str str) {\n  int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;\n  size_t i = 0;\n  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;\n  if (i < str.len && str.ptr[i] == '-') neg = -1, i++;\n  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n    if (result > max) return 0;\n    result *= 10;\n    result += (str.ptr[i] - '0');\n    i++;\n  }\n  return result * neg;\n}\n\nuint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {\n  int i;\n  crc = ~crc;\n  while (len--) {\n    crc ^= *(unsigned char *) buf++;\n    for (i = 0; i < 8; i++) crc = crc & 1 ? (crc >> 1) ^ 0xedb88320 : crc >> 1;\n  }\n  return ~crc;\n}\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n       sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&\n      slash < 33) {\n    len = n;\n    *net = ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) |\n           (uint32_t) d;\n    *mask = slash ? (uint32_t) (0xffffffffU << (32 - slash)) : (uint32_t) 0;\n  }\n  return len;\n}\n\nint mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip) {\n  struct mg_str k, v;\n  int allowed = acl.len == 0 ? '+' : '-';  // If any ACL is set, deny by default\n  while (mg_commalist(&acl, &k, &v)) {\n    uint32_t net, mask;\n    if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;\n    if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;\n    if ((remote_ip & mask) == net) allowed = k.ptr[0];\n  }\n  return allowed == '+';\n}\n\nint64_t mg_millis(void) {\n#if MG_ARCH == MG_ARCH_WIN32\n  return GetTickCount();\n#elif MG_ARCH == MG_ARCH_ESP32\n  return esp_timer_get_time() / 1000;\n#elif MG_ARCH == MG_ARCH_ESP8266\n  return xTaskGetTickCount() * portTICK_PERIOD_MS;\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP || MG_ARCH == MG_ARCH_FREERTOS_LWIP\n  return xTaskGetTickCount() * portTICK_PERIOD_MS;\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  return tx_time_get() * (1000 /* MS per SEC */ / TX_TIMER_TICKS_PER_SECOND);\n#elif MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)\n  uint64_t ticks = mach_absolute_time();\n  static mach_timebase_info_data_t timebase;\n  mach_timebase_info(&timebase);\n  double ticks_to_nanos = (double) timebase.numer / timebase.denom;\n  uint64_t uptime_nanos = (uint64_t) (ticks_to_nanos * ticks);\n  return (int64_t) (uptime_nanos / 1000000);\n#elif MG_ARCH == MG_ARCH_UNIX\n  struct timespec ts;\n#ifdef _POSIX_MONOTONIC_CLOCK\n#ifdef CLOCK_MONOTONIC_RAW\n  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n#else\n  clock_gettime(CLOCK_MONOTONIC, &ts);\n#endif\n#else\n  clock_gettime(CLOCK_REALTIME, &ts);\n#endif\n  return ((int64_t) ts.tv_sec * 1000 + (int64_t) ts.tv_nsec / 1000000);\n#else\n  return time(NULL) * 1000;\n#endif\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ws.c\"\n#endif\n\n\n\n\n\n\n\n\n\nstruct ws_msg {\n  uint8_t flags;\n  size_t header_len;\n  size_t data_len;\n};\n\nstatic void ws_handshake(struct mg_connection *c, const struct mg_str *wskey,\n                         const struct mg_str *wsproto, const char *fmt,\n                         va_list ap) {\n  const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  unsigned char sha[20], b64_sha[30];\n  char mem[128], *buf = mem;\n\n  mg_sha1_ctx sha_ctx;\n  mg_sha1_init(&sha_ctx);\n  mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);\n  mg_sha1_update(&sha_ctx, (unsigned char *) magic, 36);\n  mg_sha1_final(sha, &sha_ctx);\n  mg_base64_encode(sha, sizeof(sha), (char *) b64_sha);\n  buf[0] = '\\0';\n  if (fmt != NULL) mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  mg_printf(c,\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: %s\\r\\n\"\n            \"%s\",\n            b64_sha, buf);\n  if (buf != mem) free(buf);\n  if (wsproto != NULL) {\n    mg_printf(c, \"Sec-WebSocket-Protocol: %.*s\\r\\n\", (int) wsproto->len,\n              wsproto->ptr);\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nstatic size_t ws_process(uint8_t *buf, size_t len, struct ws_msg *msg) {\n  size_t i, n = 0, mask_len = 0;\n  memset(msg, 0, sizeof(*msg));\n  if (len >= 2) {\n    n = buf[1] & 0x7f;                // Frame length\n    mask_len = buf[1] & 128 ? 4 : 0;  // last bit is a mask bit\n    msg->flags = buf[0];\n    if (n < 126 && len >= mask_len) {\n      msg->data_len = n;\n      msg->header_len = 2 + mask_len;\n    } else if (n == 126 && len >= 4 + mask_len) {\n      msg->header_len = 4 + mask_len;\n      msg->data_len = mg_ntohs(*(uint16_t *) &buf[2]);\n    } else if (len >= 10 + mask_len) {\n      msg->header_len = 10 + mask_len;\n      msg->data_len =\n          (size_t) (((uint64_t) mg_ntohl(*(uint32_t *) &buf[2])) << 32) +\n          mg_ntohl(*(uint32_t *) &buf[6]);\n    }\n  }\n  // Sanity check, and integer overflow protection for the boundary check below\n  // data_len should not be larger than 1 Gb\n  if (msg->data_len > 1024 * 1024 * 1024) return 0;\n  if (msg->header_len + msg->data_len > len) return 0;\n  if (mask_len > 0) {\n    uint8_t *p = buf + msg->header_len, *m = p - mask_len;\n    for (i = 0; i < msg->data_len; i++) p[i] ^= m[i & 3];\n  }\n  return msg->header_len + msg->data_len;\n}\n\nstatic size_t mkhdr(size_t len, int op, bool is_client, uint8_t *buf) {\n  size_t n = 0;\n  buf[0] = (uint8_t) (op | 128);\n  if (len < 126) {\n    buf[1] = (unsigned char) len;\n    n = 2;\n  } else if (len < 65536) {\n    uint16_t tmp = mg_htons((uint16_t) len);\n    buf[1] = 126;\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    n = 4;\n  } else {\n    uint32_t tmp;\n    buf[1] = 127;\n    tmp = mg_htonl((uint32_t) ((uint64_t) len >> 32));\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    tmp = mg_htonl((uint32_t) (len & 0xffffffff));\n    memcpy(&buf[6], &tmp, sizeof(tmp));\n    n = 10;\n  }\n  if (is_client) {\n    buf[1] |= 1 << 7;  // Set masking flag\n    mg_random(&buf[n], 4);\n    n += 4;\n  }\n  return n;\n}\n\nstatic void mg_ws_mask(struct mg_connection *c, size_t len) {\n  if (c->is_client && c->send.buf != NULL) {\n    size_t i;\n    uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;\n    for (i = 0; i < len; i++) p[i] ^= mask[i & 3];\n  }\n}\n\nsize_t mg_ws_send(struct mg_connection *c, const char *buf, size_t len,\n                  int op) {\n  uint8_t header[14];\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n  mg_send(c, header, header_len);\n  LOG(LL_VERBOSE_DEBUG, (\"WS out: %d [%.*s]\", (int) len, (int) len, buf));\n  mg_send(c, buf, len);\n  mg_ws_mask(c, len);\n  return header_len + len;\n}\n\nstatic void mg_ws_cb(struct mg_connection *c, int ev, void *ev_data,\n                     void *fn_data) {\n  struct ws_msg msg;\n  size_t ofs = (size_t) c->pfn_data;\n\n  // assert(ofs < c->recv.len);\n  if (ev == MG_EV_READ) {\n    if (!c->is_websocket && c->is_client) {\n      int n = mg_http_get_request_len(c->recv.buf, c->recv.len);\n      if (n < 0) {\n        c->is_closing = 1;  // Some just, not an HTTP request\n      } else if (n > 0) {\n        if (n < 15 || memcmp(c->recv.buf + 9, \"101\", 3) != 0) {\n          LOG(LL_ERROR,\n              (\"%lu WS handshake error: %.*s\", c->id, 15, c->recv.buf));\n          c->is_closing = 1;\n        } else {\n          struct mg_http_message hm;\n          mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n          c->is_websocket = 1;\n          mg_call(c, MG_EV_WS_OPEN, &hm);\n        }\n        mg_iobuf_del(&c->recv, 0, (size_t) n);\n      } else {\n        return;  // A request is not yet received\n      }\n    }\n\n    while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {\n      char *s = (char *) c->recv.buf + ofs + msg.header_len;\n      struct mg_ws_message m = {{s, msg.data_len}, msg.flags};\n      size_t len = msg.header_len + msg.data_len;\n      uint8_t final = msg.flags & 128, op = msg.flags & 15;\n      // LOG(LL_VERBOSE_DEBUG, (\"fin %d op %d len %d [%.*s]\", final, op,\n      //                       (int) m.data.len, (int) m.data.len, m.data.ptr));\n      switch (op) {\n        case WEBSOCKET_OP_CONTINUE:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PING:\n          LOG(LL_DEBUG, (\"%s\", \"WS PONG\"));\n          mg_ws_send(c, s, msg.data_len, WEBSOCKET_OP_PONG);\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PONG:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_TEXT:\n        case WEBSOCKET_OP_BINARY:\n          if (final) mg_call(c, MG_EV_WS_MSG, &m);\n          break;\n        case WEBSOCKET_OP_CLOSE:\n          LOG(LL_DEBUG, (\"%lu Got WS CLOSE\", c->id));\n          mg_call(c, MG_EV_WS_CTL, &m);\n          c->is_closing = 1;\n          break;\n        default:\n          // Per RFC6455, close conn when an unknown op is recvd\n          mg_error(c, \"unknown WS op %d\", op);\n          break;\n      }\n\n      // Handle fragmented frames: strip header, keep in c->recv\n      if (final == 0 || op == 0) {\n        if (op) ofs++, len--, msg.header_len--;       // First frame\n        mg_iobuf_del(&c->recv, ofs, msg.header_len);  // Strip header\n        len -= msg.header_len;\n        ofs += len;\n        c->pfn_data = (void *) ofs;\n        // LOG(LL_INFO, (\"FRAG %d [%.*s]\", (int) ofs, (int) ofs, c->recv.buf));\n      }\n      // Remove non-fragmented frame\n      if (final && op) mg_iobuf_del(&c->recv, ofs, len);\n      // Last chunk of the fragmented frame\n      if (final && !op) {\n        m.flags = c->recv.buf[0];\n        m.data = mg_str_n((char *) &c->recv.buf[1], (size_t) (ofs - 1));\n        mg_call(c, MG_EV_WS_MSG, &m);\n        mg_iobuf_del(&c->recv, 0, ofs);\n        ofs = 0;\n        c->pfn_data = NULL;\n      }\n    }\n  }\n  (void) fn_data;\n  (void) ev_data;\n}\n\nstruct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url,\n                                    mg_event_handler_t fn, void *fn_data,\n                                    const char *fmt, ...) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    char nonce[16], key[30], mem1[128], mem2[256], *buf1 = mem1, *buf2 = mem2;\n    struct mg_str host = mg_url_host(url);\n    int n1 = 0, n2 = 0;\n    if (fmt != NULL) {\n      va_list ap;\n      va_start(ap, fmt);\n      n1 = mg_vasprintf(&buf1, sizeof(mem1), fmt, ap);\n      va_end(ap);\n    }\n    // Send handshake request\n    // mg_url_host(url, host, sizeof(host));\n    mg_random(nonce, sizeof(nonce));\n    mg_base64_encode((unsigned char *) nonce, sizeof(nonce), key);\n    // LOG(LL_DEBUG, \"%p [%s]\", uri, uri == NULL ? \"???\" : uri);\n    n2 = mg_asprintf(&buf2, sizeof(mem2),\n                     \"GET %s HTTP/1.1\\r\\n\"\n                     \"Upgrade: websocket\\r\\n\"\n                     \"Host: %.*s\\r\\n\"\n                     \"Connection: Upgrade\\r\\n\"\n                     \"%.*s\"\n                     \"Sec-WebSocket-Version: 13\\r\\n\"\n                     \"Sec-WebSocket-Key: %s\\r\\n\"\n                     \"\\r\\n\",\n                     mg_url_uri(url), (int) host.len, host.ptr, n1, buf1, key);\n    mg_send(c, buf2, n2 > 0 ? (size_t) n2 : 0);\n    if (buf1 != mem1) free(buf1);\n    if (buf2 != mem2) free(buf2);\n    c->pfn = mg_ws_cb;\n    c->pfn_data = NULL;\n  }\n  return c;\n}\n\nvoid mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *fmt, ...) {\n  struct mg_str *wskey = mg_http_get_header(hm, \"Sec-WebSocket-Key\");\n  c->pfn = mg_ws_cb;\n  c->pfn_data = NULL;\n  if (wskey == NULL) {\n    mg_http_reply(c, 426, \"\", \"WS upgrade expected\\n\");\n    c->is_draining = 1;\n  } else {\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    va_list ap;\n    va_start(ap, fmt);\n    ws_handshake(c, wskey, wsproto, fmt, ap);\n    va_end(ap);\n    c->is_websocket = 1;\n    mg_call(c, MG_EV_WS_OPEN, hm);\n  }\n}\n\nsize_t mg_ws_wrap(struct mg_connection *c, size_t len, int op) {\n  uint8_t header[14], *p;\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n\n  // NOTE: order of operations is important!\n  mg_iobuf_add(&c->send, c->send.len, NULL, header_len, MG_IO_SIZE);\n  p = &c->send.buf[c->send.len - len];         // p points to data\n  memmove(p, p - header_len, len);             // Shift data\n  memcpy(p - header_len, header, header_len);  // Prepend header\n  mg_ws_mask(c, len);                          // Mask data\n\n  return c->send.len;\n}\n", "#include \"http.h\"\n#include \"arch.h\"\n#include \"base64.h\"\n#include \"log.h\"\n#include \"net.h\"\n#include \"ssi.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include \"ws.h\"\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // LOG(LL_INFO, (\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // LOG(LL_INFO, (\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // LOG(LL_INFO, (\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len + 21];\n    memcpy(&buf[-21], \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf, n);\n      }\n    }\n    n = mg_base64_final(buf, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    LOG(LL_ERROR, (\"%lu %s cannot resize iobuf %d->%d \", c->id, c->label,\n                   (int) c->send.size, (int) need));\n  }\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = buf->ptr + buf->len;\n    len = -4;  // Name does not exist\n    dst[0] = '\\0';\n    for (p = buf->ptr; p + name_len < e; p++) {\n      if ((p == buf->ptr || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_ncasecmp(name, p, name_len)) {\n        p += name_len + 1;\n        s = (const char *) memchr(p, '&', (size_t) (e - p));\n        if (s == NULL) s = e;\n        len = mg_url_decode(p, (size_t) (s - p), dst, dst_len, 1);\n        if (len < 0) len = -3;  // Failed to decode\n        break;\n      }\n    }\n  }\n  return len;\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isxdigit(*(const unsigned char *) (src + i + 1)) &&\n          isxdigit(*(const unsigned char *) (src + i + 2))) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128)\n      return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // LOG(LL_INFO, (\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s + req_len, *qs;\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list ap) {\n  char mem[256], *buf = mem;\n  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  mg_printf(c, \"%X\\r\\n\", len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  mg_send(c, \"\\r\\n\", 2);\n  if (buf != mem) free(buf);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lX\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 101: return \"Switching Protocols\";\n    case 102: return \"Processing\";\n    case 200: return \"OK\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 203: return \"Non-authoritative Information\";\n    case 204: return \"No Content\";\n    case 205: return \"Reset Content\";\n    case 206: return \"Partial Content\";\n    case 207: return \"Multi-Status\";\n    case 208: return \"Already Reported\";\n    case 226: return \"IM Used\";\n    case 300: return \"Multiple Choices\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 303: return \"See Other\";\n    case 304: return \"Not Modified\";\n    case 305: return \"Use Proxy\";\n    case 307: return \"Temporary Redirect\";\n    case 308: return \"Permanent Redirect\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 402: return \"Payment Required\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 405: return \"Method Not Allowed\";\n    case 406: return \"Not Acceptable\";\n    case 407: return \"Proxy Authentication Required\";\n    case 408: return \"Request Timeout\";\n    case 409: return \"Conflict\";\n    case 410: return \"Gone\";\n    case 411: return \"Length Required\";\n    case 412: return \"Precondition Failed\";\n    case 413: return \"Payload Too Large\";\n    case 414: return \"Request-URI Too Long\";\n    case 415: return \"Unsupported Media Type\";\n    case 416: return \"Requested Range Not Satisfiable\";\n    case 417: return \"Expectation Failed\";\n    case 418: return \"I'm a teapot\";\n    case 421: return \"Misdirected Request\";\n    case 422: return \"Unprocessable Entity\";\n    case 423: return \"Locked\";\n    case 424: return \"Failed Dependency\";\n    case 426: return \"Upgrade Required\";\n    case 428: return \"Precondition Required\";\n    case 429: return \"Too Many Requests\";\n    case 431: return \"Request Header Fields Too Large\";\n    case 444: return \"Connection Closed Without Response\";\n    case 451: return \"Unavailable For Legal Reasons\";\n    case 499: return \"Client Closed Request\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    case 502: return \"Bad Gateway\";\n    case 503: return \"Service Unavailable\";\n    case 504: return \"Gateway Timeout\";\n    case 505: return \"HTTP Version Not Supported\";\n    case 506: return \"Variant Also Negotiates\";\n    case 507: return \"Insufficient Storage\";\n    case 508: return \"Loop Detected\";\n    case 510: return \"Not Extended\";\n    case 511: return \"Network Authentication Required\";\n    case 599: return \"Network Connect Timeout Error\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length: %d\\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers, len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  if (buf != mem) free(buf);\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  struct mg_fd *fd = (struct mg_fd *) c->pfn_data;\n  if (fd != NULL) fd->fs->close(fd);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,\n           (int64_t) size);\n  return buf;\n}\n\n#if MG_ENABLE_FILE\nint mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}\n#endif\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = 2 * MG_IO_SIZE;\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    n = fd->fs->read(fd->fd, c->send.buf + c->send.len,\n                     c->send.size - c->send.len);\n    if (n > 0) c->send.len += n;\n    if (c->send.len < c->send.size) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  // clang-format off\n  struct mimeentry { struct mg_str extension, value; };\n  #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}\n  // clang-format on\n  const struct mimeentry tab[] = {\n      MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),\n      MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),\n      MIME_ENTRY(\"gif\", \"image/gif\"),\n      MIME_ENTRY(\"png\", \"image/png\"),\n      MIME_ENTRY(\"jpg\", \"image/jpeg\"),\n      MIME_ENTRY(\"jpeg\", \"image/jpeg\"),\n      MIME_ENTRY(\"woff\", \"font/woff\"),\n      MIME_ENTRY(\"ttf\", \"font/ttf\"),\n      MIME_ENTRY(\"svg\", \"image/svg+xml\"),\n      MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),\n      MIME_ENTRY(\"avi\", \"video/x-msvideo\"),\n      MIME_ENTRY(\"csv\", \"text/csv\"),\n      MIME_ENTRY(\"doc\", \"application/msword\"),\n      MIME_ENTRY(\"exe\", \"application/octet-stream\"),\n      MIME_ENTRY(\"gz\", \"application/gzip\"),\n      MIME_ENTRY(\"ico\", \"image/x-icon\"),\n      MIME_ENTRY(\"json\", \"application/json\"),\n      MIME_ENTRY(\"mov\", \"video/quicktime\"),\n      MIME_ENTRY(\"mp3\", \"audio/mpeg\"),\n      MIME_ENTRY(\"mp4\", \"video/mp4\"),\n      MIME_ENTRY(\"mpeg\", \"video/mpeg\"),\n      MIME_ENTRY(\"pdf\", \"application/pdf\"),\n      MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"tgz\", \"application/tar-gz\"),\n      MIME_ENTRY(\"wav\", \"audio/wav\"),\n      MIME_ENTRY(\"webp\", \"image/webp\"),\n      MIME_ENTRY(\"zip\", \"application/zip\"),\n      MIME_ENTRY(\"3gp\", \"video/3gpp\"),\n      {{0, 0}, {0, 0}},\n  };\n  size_t i = 0;\n  struct mg_str k, v, s = mg_str(extra);\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; tab[i].extension.ptr != NULL; i++) {\n    if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  LOG(LL_INFO, (\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path, struct mg_http_serve_opts *opts) {\n  char etag[64];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = fs->open(path, MG_FS_READ);\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n\n  if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {\n    LOG(LL_DEBUG, (\"404 [%s] %p\", path, (void *) fd));\n    mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");\n    fs->close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    fs->close(fd);\n    mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n  } else {\n    int n, status = 200;\n    char range[100] = \"\";\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n    struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT\n                 \"/\" MG_INT64_FMT \"\\r\\n\",\n                 r1, r1 + cl - 1, (int64_t) size);\n        fs->seek(fd->fd, (size_t) r1);\n      }\n    }\n\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      fs->close(fd);\n    } else {\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[64], mod[64];\n  int flags, n = 0;\n\n  // LOG(LL_DEBUG, (\"[%s] [%s]\", d->dir, name));\n  if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {\n    LOG(LL_ERROR, (\"%s truncated\", name));\n  } else if ((flags = fs->stat(path, &size, &t)) == 0) {\n    LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    struct tm tm;\n    if (flags & MG_FS_DIR) {\n      snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else if (size < 1024) {\n      snprintf(sz, sizeof(sz), \"%d\", (int) size);\n    } else if (size < 0x100000) {\n      snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);\n    } else if (size < 0x40000000) {\n      snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);\n    } else {\n      snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);\n    }\n    strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&t, &tm));\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=\" MG_INT64_FMT \">%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_http_serve_opts *opts, char *dir) {\n  static const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  static const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n\n  fs->list(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",\n                        (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 10, tmp, n);  // Set content length\n}\n\nstatic void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n// Resolve requested file into `path` and return its fs->stat() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags = 0, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {\n    mg_http_reply(c, 400, \"\", \"Invalid web root [%.*s]\\n\", (int) dir.len,\n                  dir.ptr);\n  } else {\n    if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n    mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                  path_size - n, 0);\n    path[path_size - 1] = '\\0';  // Double-check\n    remove_double_dots(path);\n    n = strlen(path);\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu %.*s -> %s\", c->id, (int) hm->uri.len, hm->uri.ptr, path));\n    while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n    flags = fs->stat(path, NULL, NULL);                 // Does it exist?\n    if (flags == 0) {\n      mg_http_reply(c, 404, \"\", \"Not found\\n\");  // Does not exist, doh\n    } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n               hm->uri.ptr[hm->uri.len - 1] != '/') {\n      mg_printf(c,\n                \"HTTP/1.1 301 Moved\\r\\n\"\n                \"Location: %.*s/\\r\\n\"\n                \"Content-Length: 0\\r\\n\"\n                \"\\r\\n\",\n                (int) hm->uri.len, hm->uri.ptr);\n      flags = 0;\n    } else if (flags & MG_FS_DIR) {\n      if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0) ||\n           (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0))) {\n        flags = tmp;\n      } else {\n        path[n] = '\\0';  // Remove appended index file name\n      }\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX] = \"\";\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags == 0) return;\n  LOG(LL_VERBOSE_DEBUG,\n      (\"%.*s %s %d\", (int) hm->uri.len, hm->uri.ptr, path, flags));\n  if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (sp != NULL && mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_globmatch(glob, strlen(glob), hm->uri.ptr, hm->uri.len);\n}\n\nstatic size_t get_chunk_length(const char *buf, size_t len, size_t *ll) {\n  size_t i = 0, n;\n  while (i < len && buf[i] != '\\r' && i != '\\n') i++;\n  n = mg_unhexn((char *) buf, i);\n  while (i < len && (buf[i] == '\\r' || i == '\\n')) i++;\n  // LOG(LL_INFO, (\"len %zu i %zu n %zu \", len, i, n));\n  if (ll != NULL) *ll = i + 1;\n  if (i < len && i + n + 2 < len) return i + n + 3;\n  return 0;\n}\n\n// Walk through all chunks in the chunked body. For each chunk, fire\n// an MG_EV_HTTP_CHUNK event.\nstatic void walkchunks(struct mg_connection *c, struct mg_http_message *hm,\n                       size_t reqlen) {\n  size_t off = 0, bl, ll;\n  while (off + reqlen < c->recv.len) {\n    char *buf = (char *) &c->recv.buf[reqlen];\n    size_t memo = c->recv.len;\n    size_t cl = get_chunk_length(&buf[off], memo - reqlen - off, &ll);\n    // LOG(LL_INFO, (\"len %zu off %zu cl %zu ll %zu\", len, off, cl, ll));\n    if (cl == 0) break;\n    hm->chunk = mg_str_n(&buf[off + ll], cl < ll + 2 ? 0 : cl - ll - 2);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    // Increase offset only if user has not deleted this chunk\n    if (memo == c->recv.len) off += cl;\n    if (cl <= 5) {\n      // Zero chunk - last one. Prepare body - cut off chunk lengths\n      off = bl = 0;\n      while (off + reqlen < c->recv.len) {\n        char *buf2 = (char *) &c->recv.buf[reqlen];\n        size_t memo2 = c->recv.len;\n        size_t cl2 = get_chunk_length(&buf2[off], memo2 - reqlen - off, &ll);\n        size_t n = cl2 < ll + 2 ? 0 : cl2 - ll - 2;\n        memmove(buf2 + bl, buf2 + off + ll, n);\n        bl += n;\n        off += cl2;\n        if (cl2 <= 5) break;\n      }\n      // LOG(LL_INFO, (\"BL->%d del %d off %d\", (int) bl, (int) del, (int) off));\n      c->recv.len -= off - bl;\n      // Set message length to indicate we've received\n      // everything, to fire MG_EV_HTTP_MSG\n      hm->message.len = bl + reqlen;\n      hm->body.len = bl;\n      break;\n    }\n  }\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  struct mg_str needle = mg_str_n(\"chunked\", 7);\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_strstr(*te, needle) != NULL;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  struct mg_str ch = hm->chunk;\n  if (mg_is_chunked(hm)) {\n    ch.len += 4;  // \\r\\n before and after the chunk\n    ch.ptr -= 2;\n    while (ch.ptr > hm->body.ptr && *ch.ptr != '\\n') ch.ptr--, ch.len++;\n  }\n  {\n    const char *end = &ch.ptr[ch.len];\n    size_t n = (size_t) (end - (char *) c->recv.buf);\n    if (c->recv.len > n) {\n      memmove((char *) ch.ptr, end, (size_t) (c->recv.len - n));\n    }\n    // LOG(LL_INFO, (\"DELETING CHUNK: %zu %zu %zu\\n%.*s\", c->recv.len, n,\n    // ch.len, (int) ch.len, ch.ptr));\n  }\n  c->recv.len -= ch.len;\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      int n = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      bool is_chunked = n > 0 && mg_is_chunked(&hm);\n      if (ev == MG_EV_CLOSE) {\n        hm.message.len = c->recv.len;\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      } else if (is_chunked && n > 0) {\n        walkchunks(c, &hm, (size_t) n);\n      }\n      // LOG(LL_INFO,\n      //(\"---->%d %d\\n%.*s\", n, is_chunked, (int) c->recv.len, c->recv.buf));\n      if (n < 0 && ev == MG_EV_READ) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      } else if (n > 0 && (size_t) c->recv.len >= hm.message.len) {\n        mg_call(c, MG_EV_HTTP_MSG, &hm);\n        mg_iobuf_del(&c->recv, 0, hm.message.len);\n      } else {\n        if (n > 0 && !is_chunked) {\n          hm.chunk =\n              mg_str_n((char *) &c->recv.buf[n], c->recv.len - (size_t) n);\n          mg_call(c, MG_EV_HTTP_CHUNK, &hm);\n        }\n        break;\n      }\n    }\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n", "#include \"mongoose.h\"\n\nstatic int s_num_tests = 0;\n\n#define ASSERT(expr)                                            \\\n  do {                                                          \\\n    s_num_tests++;                                              \\\n    if (!(expr)) {                                              \\\n      printf(\"FAILURE %s:%d: %s\\n\", __FILE__, __LINE__, #expr); \\\n      exit(EXIT_FAILURE);                                       \\\n    }                                                           \\\n  } while (0)\n\n#define FETCH_BUF_SIZE (256 * 1024)\n\n// Important: we use different port numbers for the Windows bug workaround. See\n// https://support.microsoft.com/en-ae/help/3039044/error-10013-wsaeacces-is-returned-when-a-second-bind-to-a-excluded-por\n\nstatic void test_globmatch(void) {\n  ASSERT(mg_globmatch(\"\", 0, \"\", 0) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"a\", 1) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"ab\", 2) == 1);\n  ASSERT(mg_globmatch(\"\", 0, \"a\", 1) == 0);\n  ASSERT(mg_globmatch(\"/\", 1, \"/foo\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/bar\", 6) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foo\", 6) == 1);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foox\", 7) == 0);\n  ASSERT(mg_globmatch(\"/*/foo*\", 7, \"/x/foox\", 7) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/abc\", 4) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/ab/\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/\", 1) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2\", 4) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2/foo\", 8) == 0);\n  ASSERT(mg_globmatch(\"/x/*/*\", 6, \"/x/2/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"#\", 1, \"///\", 3) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/log/static\", 15) == 0);\n  ASSERT(mg_globmatch(\"/api/#\", 6, \"/api/log/static\", 15) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"/ssi/index.shtml\", 16) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \".c\", 2) == 1);\n  ASSERT(mg_globmatch(\"abc\", 3, \"ab\", 2) == 0);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"a.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"..c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"/.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"//a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"x/a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"./a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"./ssi/index.shtml\", 17) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabba\", 6) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabxa\", 6) == 0);\n}\n\nstatic void test_commalist(void) {\n  struct mg_str k, v, s1 = mg_str(\"\"), s2 = mg_str(\"a\"), s3 = mg_str(\"a,b\");\n  struct mg_str s4 = mg_str(\"a=123\"), s5 = mg_str(\"a,b=123\");\n  ASSERT(mg_commalist(&s1, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s2, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s2, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"b\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s4, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"a\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"b\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n}\n\nstatic void test_http_get_var(void) {\n  char buf[256];\n  struct mg_str body;\n  body = mg_str(\"key1=value1&key2=value2&key3=value%203&key4=value+4\");\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"KEY1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key2\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value2\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key3\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 3\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key4\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 4\") == 0);\n\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -4);\n  ASSERT(mg_http_get_var(&body, \"key1\", NULL, sizeof(buf)) == -2);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 0) == -2);\n  ASSERT(mg_http_get_var(&body, NULL, buf, sizeof(buf)) == -1);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 1) == -3);\n\n  body = mg_str(\"key=broken%2\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n\n  body = mg_str(\"key=broken%2x\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  ASSERT(mg_http_get_var(&body, \"inexistent\", buf, sizeof(buf)) == -4);\n  body = mg_str(\"key=%\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  body = mg_str(\"&&&kEy=%\");\n  ASSERT(mg_http_get_var(&body, \"kEy\", buf, sizeof(buf)) == -3);\n}\n\nstatic int vcmp(struct mg_str s1, const char *s2) {\n  // LOG(LL_INFO, (\"->%.*s<->%s<- %d %d %d\", (int) s1.len, s1.ptr, s2,\n  //(int) s1.len, strncmp(s1.ptr, s2, s1.len), mg_vcmp(&s1, s2)));\n  return mg_vcmp(&s1, s2) == 0;\n}\n\nstatic void test_url(void) {\n  // Host\n  ASSERT(vcmp(mg_url_host(\"foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"//foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\":1234\"), \"\"));\n  ASSERT(vcmp(mg_url_host(\"//foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo//x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[::1]:1234/a\"), \"[::1]\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[1:2::3]:1234/a\"), \"[1:2::3]\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x:y/z\"), \"foo\"));\n\n  // Port\n  ASSERT(mg_url_port(\"foo:1234\") == 1234);\n  ASSERT(mg_url_port(\":1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/xx\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a:b\") == 1234);\n  ASSERT(mg_url_port(\"http://bar\") == 80);\n  ASSERT(mg_url_port(\"http://localhost:1234\") == 1234);\n  ASSERT(mg_url_port(\"https://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/abc\") == 123);\n  ASSERT(mg_url_port(\"http://u:p@[::1]/abc\") == 80);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc\") == 2121);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc/cd:ef\") == 2121);\n\n  // User / pass\n  ASSERT(vcmp(mg_url_user(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:p@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:p@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo//a@b\"), \"p\"));\n\n  // URI\n  ASSERT(strcmp(mg_url_uri(\"p://foo\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/abc\"), \"/abc\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[ab::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n}\n\nstatic void test_base64(void) {\n  char buf[128];\n\n  ASSERT(mg_base64_encode((uint8_t *) \"\", 0, buf) == 0);\n  ASSERT(strcmp(buf, \"\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"x\", 1, buf) == 4);\n  ASSERT(strcmp(buf, \"eA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xyz\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHl6\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcdef\", 6, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGVm\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"\u044b\", 2, buf) == 4);\n  ASSERT(strcmp(buf, \"0Ys=\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xy\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHkA\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"test\", 4, buf) == 8);\n  ASSERT(strcmp(buf, \"dGVzdA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcde\", 5, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGU=\") == 0);\n\n  ASSERT(mg_base64_decode(\"\u043a\u044e\", 4, buf) == 0);\n  ASSERT(mg_base64_decode(\"A\", 1, buf) == 0);\n  ASSERT(mg_base64_decode(\"A=\", 2, buf) == 0);\n  ASSERT(mg_base64_decode(\"AA=\", 3, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAA=\", 4, buf) == 2);\n  ASSERT(mg_base64_decode(\"AAAA====\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAAA----\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"Q2VzYW50YQ==\", 12, buf) == 7);\n  ASSERT(strcmp(buf, \"Cesanta\") == 0);\n}\n\nstatic void test_iobuf(void) {\n  struct mg_iobuf io = {0, 0, 0};\n  ASSERT(io.buf == NULL && io.size == 0 && io.len == 0);\n  mg_iobuf_resize(&io, 1);\n  ASSERT(io.buf != NULL && io.size == 1 && io.len == 0);\n  ASSERT(memcmp(io.buf, \"\\x00\", 1) == 0);\n  mg_iobuf_add(&io, 3, \"hi\", 2, 10);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 5);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi\", 5) == 0);\n  mg_iobuf_add(&io, io.len, \"!\", 1, 10);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 6);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi!\", 6) == 0);\n  mg_iobuf_add(&io, 0, \"x\", 1, 10);\n  ASSERT(memcmp(io.buf, \"x\\x00\\x00\\x00hi!\", 7) == 0);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 7);\n  mg_iobuf_del(&io, 1, 3);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  mg_iobuf_del(&io, 10, 100);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  free(io.buf);\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_SNTP_TIME) {\n    *(int64_t *) fnd = *(int64_t *) evd;\n  }\n  (void) c;\n}\n\nstatic void test_sntp(void) {\n  int64_t ms = 0;\n  struct mg_mgr mgr;\n  struct mg_connection *c = NULL;\n  int i;\n\n  mg_mgr_init(&mgr);\n  c = mg_sntp_connect(&mgr, NULL, sntp_cb, &ms);\n  ASSERT(c != NULL);\n  ASSERT(c->is_udp == 1);\n  mg_sntp_send(c, (unsigned long) time(NULL));\n  for (i = 0; i < 300 && ms == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ms > 0);\n  mg_mgr_free(&mgr);\n\n  {\n    const unsigned char sntp_good[] =\n        \"\\x24\\x02\\x00\\xeb\\x00\\x00\\x00\\x1e\\x00\\x00\\x07\\xb6\\x3e\"\n        \"\\xc9\\xd6\\xa2\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\"\n        \"\\xed\\x98\\x00\\x00\\x00\\xde\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\"\n        \"\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";\n    const unsigned char bad_good[] =\n        \"\\x55\\x02\\x00\\xeb\\x00\\x00\\x00\\x1e\\x00\\x00\\x07\\xb6\\x3e\"\n        \"\\xc9\\xd6\\xa2\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\"\n        \"\\xed\\x98\\x00\\x00\\x00\\xde\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\"\n        \"\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";\n    struct tm tm;\n    time_t t;\n    ASSERT((ms = mg_sntp_parse(sntp_good, sizeof(sntp_good))) > 0);\n    t = (time_t) (ms / 1000);\n    gmtime_r(&t, &tm);\n    ASSERT(tm.tm_year == 116);\n    ASSERT(tm.tm_mon == 10);\n    ASSERT(tm.tm_mday == 22);\n    ASSERT(tm.tm_hour == 16);\n    ASSERT(tm.tm_min == 15);\n    ASSERT(tm.tm_sec == 21);\n    ASSERT(mg_sntp_parse(bad_good, sizeof(bad_good)) < 0);\n  }\n\n  ASSERT(mg_sntp_parse(NULL, 0) == -1);\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  char *buf = (char *) fnd;\n  if (ev == MG_EV_MQTT_OPEN) {\n    buf[0] = *(int *) evd == 0 ? 'X' : 'Y';\n  } else if (ev == MG_EV_MQTT_MSG) {\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) evd;\n    sprintf(buf + 1, \"%.*s/%.*s\", (int) mm->topic.len, mm->topic.ptr,\n            (int) mm->data.len, mm->data.ptr);\n  }\n  (void) c;\n}\n\nstatic void test_mqtt(void) {\n  char buf[50] = {0};\n  struct mg_mgr mgr;\n  struct mg_str topic = mg_str(\"x/f12\"), data = mg_str(\"hi\");\n  struct mg_connection *c;\n  struct mg_mqtt_opts opts;\n  // const char *url = \"mqtt://mqtt.eclipse.org:1883\";\n  const char *url = \"mqtt://broker.hivemq.com:1883\";\n  int i;\n  mg_mgr_init(&mgr);\n\n  {\n    uint8_t bad[] = \" \\xff\\xff\\xff\\xff \";\n    struct mg_mqtt_message mm;\n    mg_mqtt_parse(bad, sizeof(bad), &mm);\n  }\n\n  // Connect with empty client ID\n  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, buf);\n  for (i = 0; i < 200 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(buf[0] == 'X');\n  mg_mqtt_sub(c, &topic, 1);\n  mg_mqtt_pub(c, &topic, &data, 1, false);\n  for (i = 0; i < 300 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  // LOG(LL_INFO, (\"[%s]\", buf));\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  // Set params\n  memset(buf, 0, sizeof(buf));\n  memset(&opts, 0, sizeof(opts));\n  opts.clean = true;\n  opts.will_qos = 1;\n  opts.will_retain = true;\n  opts.keepalive = 20;\n  opts.client_id = mg_str(\"mg_client\");\n  opts.will_topic = mg_str(\"mg_will_topic\");\n  opts.will_message = mg_str(\"mg_will_messsage\");\n  c = mg_mqtt_connect(&mgr, url, &opts, mqtt_cb, buf);\n  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(buf[0] == 'X');\n  mg_mqtt_sub(c, &topic, 1);\n  mg_mqtt_pub(c, &topic, &data, 1, false);\n  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_tls_opts *topts = (struct mg_tls_opts *) fn_data;\n  if (ev == MG_EV_ACCEPT && topts != NULL) mg_tls_init(c, topts);\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    LOG(LL_INFO,\n        (\"[%.*s %.*s] message len %d\", (int) hm->method.len, hm->method.ptr,\n         (int) hm->uri.len, hm->uri.ptr, (int) hm->message.len));\n    if (mg_http_match_uri(hm, \"/foo/*\")) {\n      mg_http_reply(c, 200, \"\", \"uri: %.*s\", hm->uri.len - 5, hm->uri.ptr + 5);\n    } else if (mg_http_match_uri(hm, \"/ws\")) {\n      mg_ws_upgrade(c, hm, NULL);\n    } else if (mg_http_match_uri(hm, \"/body\")) {\n      mg_http_reply(c, 200, \"\", \"%.*s\", (int) hm->body.len, hm->body.ptr);\n    } else if (mg_http_match_uri(hm, \"/bar\")) {\n      mg_http_reply(c, 404, \"\", \"not found\");\n    } else if (mg_http_match_uri(hm, \"/no_reason\")) {\n      mg_printf(c, \"%s\", \"HTTP/1.0 200\\r\\nContent-Length: 2\\r\\n\\r\\nok\");\n    } else if (mg_http_match_uri(hm, \"/badroot\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"/BAAADDD!\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/creds\")) {\n      char user[100], pass[100];\n      mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass));\n      mg_http_reply(c, 200, \"\", \"[%s]:[%s]\", user, pass);\n    } else if (mg_http_match_uri(hm, \"/upload\")) {\n      mg_http_upload(c, hm, \".\");\n    } else if (mg_http_match_uri(hm, \"/test/\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \".\";\n      sopts.extra_headers = \"A: B\\r\\nC: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/servefile\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.mime_types = \"foo=a/b,txt=c/d\";\n      mg_http_serve_file(c, hm, \"test/data/a.txt\", &sopts);\n    } else {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"./test/data\";\n      sopts.ssi_pattern = \"#.shtml\";\n      sopts.extra_headers = \"C: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    }\n  } else if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->uri, mg_str(\"/ws\")) == 0);\n    mg_ws_send(c, \"opened\", 6, WEBSOCKET_OP_BINARY);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    mg_ws_send(c, wm->data.ptr, wm->data.len, WEBSOCKET_OP_BINARY);\n  }\n}\n\nstruct fetch_data {\n  char *buf;\n  int code, closed;\n};\n\nstatic void fcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct fetch_data *fd = (struct fetch_data *) fn_data;\n    snprintf(fd->buf, FETCH_BUF_SIZE, \"%.*s\", (int) hm->message.len,\n             hm->message.ptr);\n    fd->code = atoi(hm->uri.ptr);\n    fd->closed = 1;\n    c->is_closing = 1;\n    (void) c;\n  }\n}\n\nstatic int fetch(struct mg_mgr *mgr, char *buf, const char *url,\n                 const char *fmt, ...) {\n  struct fetch_data fd = {buf, 0, 0};\n  int i;\n  struct mg_connection *c = mg_http_connect(mgr, url, fcb, &fd);\n  va_list ap;\n  ASSERT(c != NULL);\n  if (mg_url_is_ssl(url)) {\n    struct mg_tls_opts opts;\n    struct mg_str host = mg_url_host(url);\n    memset(&opts, 0, sizeof(opts));\n    opts.ca = \"./test/data/ca.pem\";\n    if (strstr(url, \"127.0.0.1\") != NULL) {\n      // Local connection, use self-signed certificates\n      opts.ca = \"./test/data/ss_ca.pem\";\n      opts.cert = \"./test/data/ss_client.pem\";\n    } else {\n      opts.srvname = host;\n    }\n    mg_tls_init(c, &opts);\n    // c->is_hexdumping = 1;\n  }\n  va_start(ap, fmt);\n  mg_vprintf(c, fmt, ap);\n  va_end(ap);\n  buf[0] = '\\0';\n  for (i = 0; i < 250 && buf[0] == '\\0'; i++) mg_mgr_poll(mgr, 1);\n  if (!fd.closed) c->is_closing = 1;\n  mg_mgr_poll(mgr, 1);\n  return fd.code;\n}\n\nstatic int cmpbody(const char *buf, const char *str) {\n  struct mg_http_message hm;\n  struct mg_str s = mg_str(str);\n  size_t len = strlen(buf);\n  mg_http_parse(buf, len, &hm);\n  if (hm.body.len > len) hm.body.len = len - (size_t) (hm.body.ptr - buf);\n  return mg_strcmp(hm.body, s);\n}\n\nstatic bool cmpheader(const char *buf, const char *name, const char *value) {\n  struct mg_http_message hm;\n  struct mg_str *h;\n  size_t len = strlen(buf);\n  mg_http_parse(buf, len, &hm);\n  h = mg_http_get_header(&hm, name);\n  return h != NULL && mg_strcmp(*h, mg_str(value)) == 0;\n}\n\nstatic void wcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    ASSERT(wsproto != NULL);\n    mg_ws_send(c, \"boo\", 3, WEBSOCKET_OP_BINARY);\n    mg_ws_send(c, \"\", 0, WEBSOCKET_OP_PING);\n    ((int *) fn_data)[0] += 100;\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    if (mg_strstr(wm->data, mg_str(\"boo\")))\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    ((int *) fn_data)[0]++;\n  } else if (ev == MG_EV_CLOSE) {\n    ((int *) fn_data)[0] += 10;\n  }\n}\n\nstatic void test_ws(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"ws://LOCALHOST:12343/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, eh1, NULL) != NULL);\n  mg_ws_connect(&mgr, url, wcb, &done, \"%s\", \"Sec-WebSocket-Protocol: meh\\r\\n\");\n  for (i = 0; i < 30; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"--> %d\", done));\n  ASSERT(done == 112);\n\n  // Test that non-WS requests fail\n  ASSERT(fetch(&mgr, buf, url, \"GET /ws HTTP/1.0\\r\\n\\n\") == 426);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh9(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR) {\n    ASSERT(!strcmp((char *) ev_data, \"error connecting to 127.0.0.1:55117\"));\n    *(int *) fn_data = 7;\n  }\n  (void) c;\n}\n\nstatic void test_http_server(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12346\";\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh1, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /%%61.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  // Responses with missing reason phrase must also work\n  ASSERT(fetch(&mgr, buf, url, \"GET /no_reason HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"ok\") == 0);\n\n  // Fetch file with unicode chars in filename\n  ASSERT(fetch(&mgr, buf, url, \"GET /\u043a\u0438\u0457\u0432.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"\u0454\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /../fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e/fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e%%2ffuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2f%%20fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2ffuzz.c%%20 HTTP/1.0\\n\\n\") == 404);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir HTTP/1.0\\n\\n\") == 301);\n  ASSERT(cmpheader(buf, \"Location\", \"/dredir/\"));\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  {\n    extern char *mg_http_etag(char *, size_t, size_t, time_t);\n    char etag[100];\n    size_t size = 0;\n    time_t mtime = 0;\n    ASSERT(mg_fs_posix.stat(\"./test/data/a.txt\", &size, &mtime) != 0);\n    ASSERT(mg_http_etag(etag, sizeof(etag), size, mtime) == etag);\n    ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\nIf-None-Match: %s\\n\\n\",\n                 etag) == 304);\n  }\n\n  // Text mime type override\n  ASSERT(fetch(&mgr, buf, url, \"GET /servefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"), mg_str(\"c/d\")) ==\n           0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/1 HTTP/1.0\\r\\n\\n\") == 200);\n  // LOG(LL_INFO, (\"%d %.*s\", (int) hm.len, (int) hm.len, hm.buf));\n  ASSERT(cmpbody(buf, \"uri: 1\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"%s\",\n               \"POST /body HTTP/1.1\\r\\n\"\n               \"Content-Length: 4\\r\\n\\r\\nkuku\") == 200);\n  ASSERT(cmpbody(buf, \"kuku\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi HTTP/1.1\\r\\n\\r\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi/ HTTP/1.1\\r\\n\\r\\n\") == 200);\n  ASSERT(cmpbody(buf,\n                 \"this is index\\n\"\n                 \"this is nested\\n\\n\"\n                 \"this is f1\\n\\n\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Length\") != NULL);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/html; charset=utf-8\")) == 0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /badroot HTTP/1.0\\r\\n\\n\") == 400);\n  ASSERT(cmpbody(buf, \"Invalid web root [/BAAADDD!]\\n\") == 0);\n\n  {\n    char *data = mg_file_read(\"./test/data/ca.pem\", NULL);\n    ASSERT(fetch(&mgr, buf, url, \"GET /ca.pem HTTP/1.0\\r\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, data) == 0);\n    free(data);\n  }\n\n  {\n    // Test mime type\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"GET /empty.js HTTP/1.0\\r\\n\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/javascript; charset=utf-8\")) == 0);\n  }\n\n  {\n    // Test connection refused\n    int i, errored = 0;\n    mg_connect(&mgr, \"tcp://127.0.0.1:55117\", eh9, &errored);\n    for (i = 0; i < 10 && errored == 0; i++) mg_mgr_poll(&mgr, 1);\n    ASSERT(errored == 7);\n  }\n\n  // Directory listing\n  fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\");\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">Index of /test/<\")) != NULL);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">fuzz.c<\")) != NULL);\n\n  {\n    // Credentials\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds?access_token=x HTTP/1.0\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Bearer x\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[foo]:[bar]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Cookie: blah; access_token=hello\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[hello]\")) == 0);\n  }\n\n  {\n    // Test upload\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);\n\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload HTTP/1.0\\n\"\n                 \"Content-Length: 1\\n\\nx\") == 400);\n\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt&offset=5 HTTP/1.0\\r\\n\"\n                 \"Content-Length: 6\\r\\n\"\n                 \"\\r\\n\\nworld\") == 200);\n    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\\nworld\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  // HEAD request\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);\n\n#if MG_ENABLE_IPV6\n  {\n    const char *url6 = \"http://[::1]:12346\";\n    ASSERT(mg_http_listen(&mgr, url6, eh1, NULL) != NULL);\n    ASSERT(fetch(&mgr, buf, url6, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  }\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_tls(void) {\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  struct mg_tls_opts opts = {.ca = \"./test/data/ss_ca.pem\",\n                             .cert = \"./test/data/ss_server.pem\",\n                             .certkey = \"./test/data/ss_server.pem\"};\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  const char *url = \"https://127.0.0.1:12347\";\n  char buf[FETCH_BUF_SIZE];\n  mg_mgr_init(&mgr);\n  c = mg_http_listen(&mgr, url, eh1, (void *) &opts);\n  ASSERT(c != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  // LOG(LL_INFO, (\"%s\", buf));\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n#endif\n}\n\nstatic void f3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int *ok = (int *) fn_data;\n  // LOG(LL_INFO, (\"%d\", ev));\n  if (ev == MG_EV_CONNECT) {\n    // c->is_hexdumping = 1;\n    mg_printf(c, \"GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\",\n              c->peer.is_ip6 ? \"ipv6.google.com\" : \"cesanta.com\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    // LOG(LL_INFO, (\"-->[%.*s]\", (int) hm->message.len, hm->message.ptr));\n    // ASSERT(mg_vcmp(&hm->method, \"HTTP/1.1\") == 0);\n    // ASSERT(mg_vcmp(&hm->uri, \"301\") == 0);\n    *ok = atoi(hm->uri.ptr);\n  } else if (ev == MG_EV_CLOSE) {\n    if (*ok == 0) *ok = 888;\n  } else if (ev == MG_EV_ERROR) {\n    if (*ok == 0) *ok = 777;\n  }\n}\n\nstatic void test_http_client(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  c = mg_http_connect(&mgr, \"http://cesanta.com\", f3, &ok);\n  ASSERT(c != NULL);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 301);\n  c->is_closing = 1;\n  mg_mgr_poll(&mgr, 0);\n  ok = 0;\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  {\n    struct mg_tls_opts opts = {.ca = \"./test/data/ca.pem\"};\n    c = mg_http_connect(&mgr, \"https://cesanta.com\", f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n    ASSERT(ok == 200);\n  }\n#endif\n\n#if MG_ENABLE_IPV6\n  ok = 0;\n  // ipv6.google.com does not have IPv4 address, only IPv6, therefore\n  // it is guaranteed to hit IPv6 resolution path.\n  c = mg_http_connect(&mgr, \"http://ipv6.google.com\", f3, &ok);\n  ASSERT(c != NULL);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 200);\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_printf(c, \"HTTP/1.0 200 OK\\n\\n%.*s/%s\", (int) hm->uri.len, hm->uri.ptr,\n              fn_data);\n    c->is_draining = 1;\n  }\n}\n\nstatic void test_http_no_content_length(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12348\";\n  char buf[FETCH_BUF_SIZE];\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f4, (void *) \"baz\");\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/bar HTTP/1.0\\r\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"/foo/bar/baz\") == 0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_printf(c, \"HTTP/1.0 200 OK\\n\\n%.*s\", (int) hm->uri.len, hm->uri.ptr);\n    (*(int *) fn_data)++;\n  }\n}\n\nstatic void test_http_pipeline(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12377\";\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f5, (void *) &ok);\n  c = mg_http_connect(&mgr, url, NULL, NULL);\n  mg_printf(c, \"POST / HTTP/1.0\\nContent-Length: 5\\n\\n12345GET / HTTP/1.0\\n\\n\");\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"-----> [%d]\", ok));\n  ASSERT(ok == 2);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_http_parse(void) {\n  struct mg_str *v;\n  struct mg_http_message req;\n\n  {\n    const char *s = \"GET / HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(\"\\b23\", 3, &req) == -1);\n    ASSERT(mg_http_parse(\"get\\n\\n\", 5, &req) == -1);\n    ASSERT(mg_http_parse(s, strlen(s) - 1, &req) == 0);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.message.len == strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"GET /blah HTTP/1.0\\r\\nFoo:  bar  \\r\\n\\r\\n\";\n    size_t idx, len = strlen(s);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) len);\n    ASSERT(mg_vcmp(&req.headers[0].name, \"Foo\") == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"bar\") == 0);\n    ASSERT(req.headers[1].name.len == 0);\n    ASSERT(req.headers[1].name.ptr == NULL);\n    ASSERT(req.query.len == 0);\n    ASSERT(req.message.len == len);\n    ASSERT(req.body.len == 0);\n    for (idx = 0; idx < len; idx++) ASSERT(mg_http_parse(s, idx, &req) == 0);\n  }\n\n  {\n    static const char *s = \"get b c\\nz :  k \\nb: t\\nvvv\\n\\n xx\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.headers[2].name.len == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"k\") == 0);\n    ASSERT(mg_vcmp(&req.headers[1].value, \"t\") == 0);\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"a b c\\r\\nContent-Length: 21 \\r\\nb: t\\r\\nvvv\\r\\n\\r\\nabc\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.body.len == 21);\n    ASSERT(req.message.len == 21 - 3 + strlen(s));\n    ASSERT(mg_http_get_header(&req, \"foo\") == NULL);\n    ASSERT((v = mg_http_get_header(&req, \"contENT-Length\")) != NULL);\n    ASSERT(mg_vcmp(v, \"21\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"B\")) != NULL);\n    ASSERT(mg_vcmp(v, \"t\") == 0);\n  }\n\n  {\n    const char *s = \"GET /foo?a=b&c=d HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.uri, \"/foo\") == 0);\n    ASSERT(mg_vcmp(&req.query, \"a=b&c=d\") == 0);\n  }\n\n  {\n    const char *s = \"POST /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    const char *s = \"WOHOO /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"HTTP/1.0 200 OK\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.method, \"HTTP/1.0\") == 0);\n    ASSERT(mg_vcmp(&req.uri, \"200\") == 0);\n    ASSERT(mg_vcmp(&req.proto, \"OK\") == 0);\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    static const char *s = \"HTTP/1.0 999 OMGWTFBBQ\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n  }\n\n  {\n    const char *s =\n        \"GET / HTTP/1.0\\r\\nhost:127.0.0.1:18888\\r\\nCookie:\\r\\nX-PlayID: \"\n        \"45455\\r\\nRange:  0-1 \\r\\n\\r\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"Host\")) != NULL);\n    ASSERT(mg_vcmp(v, \"127.0.0.1:18888\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Cookie\")) != NULL);\n    ASSERT(v->len == 0);\n    ASSERT((v = mg_http_get_header(&req, \"X-PlayID\")) != NULL);\n    ASSERT(mg_vcmp(v, \"45455\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Range\")) != NULL);\n    ASSERT(mg_vcmp(v, \"0-1\") == 0);\n  }\n\n  {\n    static const char *s = \"a b c\\na:1\\nb:2\\nc:3\\nd:4\\ne:5\\nf:6\\ng:7\\nh:8\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"e\")) != NULL);\n    ASSERT(mg_vcmp(v, \"5\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"h\")) == NULL);\n  }\n\n  {\n    struct mg_connection c;\n    struct mg_str s,\n        res = mg_str(\"GET /\\r\\nAuthorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\");\n    memset(&c, 0, sizeof(c));\n    mg_printf(&c, \"%s\", \"GET /\\r\\n\");\n    mg_http_bauth(&c, \"foo\", \"bar\");\n    mg_printf(&c, \"%s\", \"\\r\\n\");\n    s = mg_str_n((char *) c.send.buf, c.send.len);\n    ASSERT(mg_strcmp(s, res) == 0);\n    mg_iobuf_free(&c.send);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"GET /foo?bar=baz HTTP/1.0\\n\\n \";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s) - 1);\n    ASSERT(mg_strcmp(hm.uri, mg_str(\"/foo\")) == 0);\n    ASSERT(mg_strcmp(hm.query, mg_str(\"bar=baz\")) == 0);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"a b c\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a b\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a\\nb\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) < 0);\n  }\n}\n\nstatic void ehr(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_range(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12349\";\n  struct mg_http_message hm;\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, ehr, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /range.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(hm.body.len == 312);\n\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=5-10\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.proto, mg_str(\"Partial Content\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\" of co\")) == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes 5-10/312\")) == 0);\n\n  // Fetch till EOF\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=300-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\"is disease.\\n\")) == 0);\n  // LOG(LL_INFO, (\"----%d\\n[%s]\", (int) hm.body.len, buf));\n\n  // Fetch past EOF, must trigger 416 response\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=999-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n  ASSERT(hm.body.len == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes */312\")) == 0);\n\n  fetch(&mgr, buf, url, \"%s\",\n        \"GET /range.txt HTTP/1.0\\nRange: bytes=0-312\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f1(void *arg) {\n  (*(int *) arg)++;\n}\n\nstatic void test_timer(void) {\n  int v1 = 0, v2 = 0, v3 = 0;\n  struct mg_timer t1, t2, t3;\n\n  LOG(LL_INFO, (\"g_timers: %p\", g_timers));\n  ASSERT(g_timers == NULL);\n\n  mg_timer_init(&t1, 5, MG_TIMER_REPEAT, f1, &v1);\n  mg_timer_init(&t2, 15, 0, f1, &v2);\n  mg_timer_init(&t3, 10, MG_TIMER_REPEAT | MG_TIMER_RUN_NOW, f1, &v3);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t2);\n\n  mg_timer_poll(0);\n  mg_timer_poll(1);\n  ASSERT(v1 == 0);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  mg_timer_poll(5);\n  ASSERT(v1 == 1);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t2);\n\n  // Simulate long delay - timers must invalidate expiration times\n  mg_timer_poll(100);\n  ASSERT(v1 == 2);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t1);  // t2 should be removed\n  ASSERT(g_timers->next->next == NULL);\n\n  mg_timer_poll(107);\n  ASSERT(v1 == 3);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  mg_timer_poll(114);\n  ASSERT(v1 == 4);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_poll(115);\n  ASSERT(v1 == 5);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_init(&t2, 3, 0, f1, &v2);\n  ASSERT(g_timers == &t2);\n  ASSERT(g_timers->next == &t3);\n  ASSERT(g_timers->next->next == &t1);\n  ASSERT(g_timers->next->next->next == NULL);\n\n  mg_timer_poll(120);\n  ASSERT(v1 == 6);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(125);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  // Test millisecond counter wrap - when time goes back.\n  mg_timer_poll(0);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t1);\n  ASSERT(g_timers->next->next == NULL);\n\n  mg_timer_poll(7);\n  ASSERT(v1 == 8);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(11);\n  ASSERT(v1 == 9);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 5);\n\n  mg_timer_free(&t1);\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == NULL);\n\n  mg_timer_free(&t2);\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == NULL);\n\n  mg_timer_free(&t3);\n  ASSERT(g_timers == NULL);\n}\n\nstatic void test_str(void) {\n  struct mg_str s = mg_strdup(mg_str(\"a\"));\n  ASSERT(mg_strcmp(s, mg_str(\"a\")) == 0);\n  free((void *) s.ptr);\n  ASSERT(mg_strcmp(mg_str(\"\"), mg_str(NULL)) == 0);\n  ASSERT(mg_strcmp(mg_str(\"a\"), mg_str(\"b\")) < 0);\n  ASSERT(mg_strcmp(mg_str(\"b\"), mg_str(\"a\")) > 0);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"d\")) == NULL);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"b\")) != NULL);\n  ASSERT(mg_strcmp(mg_str(\"hi\"), mg_strstrip(mg_str(\" \\thi\\r\\n\"))) == 0);\n}\n\nstatic void fn1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR) sprintf((char *) fn_data, \"%s\", (char *) ev_data);\n  (void) c;\n}\n\nstatic void test_dns_timeout(const char *dns_server_url, const char *errstr) {\n  // Test timeout\n  struct mg_mgr mgr;\n  char buf[100] = \"\";\n  int i;\n  mg_mgr_init(&mgr);\n  mgr.dns4.url = dns_server_url;\n  mgr.dnstimeout = 10;\n  LOG(LL_DEBUG, (\"opening dummy DNS listener...\"));\n  mg_listen(&mgr, mgr.dns4.url, NULL, NULL);  // Just discard our queries\n  mg_http_connect(&mgr, \"http://google.com\", fn1, buf);\n  for (i = 0; i < 50 && buf[0] == '\\0'; i++) mg_mgr_poll(&mgr, 1);\n  mg_mgr_free(&mgr);\n  LOG(LL_DEBUG, (\"buf: [%s]\", buf));\n  ASSERT(strcmp(buf, errstr) == 0);\n}\n\nstatic void test_dns(void) {\n  struct mg_dns_message dm;\n  //       txid  flags numQ  numA  numAP numOP\n  // 0000  00 01 81 80 00 01 00 01 00 00 00 00 07 63 65 73  .............ces\n  // 0010  61 6e 74 61 03 63 6f 6d 00 00 01 00 01 c0 0c 00  anta.com........\n  // 0020  01 00 01 00 00 02 57 00 04 94 fb 36 ec           ......W....6.\n  uint8_t data[] = {0,    1,    0x81, 0x80, 0,    1,    0,    1,    0,\n                    0,    0,    0,    7,    0x63, 0x65, 0x73, 0x61, 0x6e,\n                    0x74, 0x61, 0x03, 0x63, 0x6f, 0x6d, 0,    0,    1,\n                    0,    1,    0xc0, 0x0c, 0,    1,    0,    1,    0,\n                    0,    2,    0x57, 0,    4,    0x94, 0xfb, 0x36, 0xec};\n  ASSERT(mg_dns_parse(NULL, 0, &dm) == 0);\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"cesanta.com\") == 0);\n  data[30] = 29;  // Point a pointer to itself\n  memset(&dm, 0, sizeof(dm));\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"\") == 0);\n\n  test_dns_timeout(\"udp://127.0.0.1:12345\", \"DNS timeout\");\n  test_dns_timeout(\"\", \"resolver\");\n  test_dns_timeout(\"tcp://0.0.0.0:0\", \"DNS error\");\n}\n\nstatic void test_util(void) {\n  char buf[100], *s = mg_hexdump(\"abc\", 3), *p;\n  struct mg_addr a;\n  ASSERT(s != NULL);\n  free(s);\n  memset(&a, 0, sizeof(a));\n  ASSERT(mg_file_printf(\"data.txt\", \"%s\", \"hi\") == true);\n  ASSERT((p = mg_file_read(\"data.txt\", NULL)) != NULL);\n  ASSERT(strcmp(p, \"hi\") == 0);\n  free(p);\n  remove(\"data.txt\");\n  ASSERT(mg_aton(mg_str(\"0\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.256\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.-1\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"127.0.0.1\"), &a) == true);\n  ASSERT(a.is_ip6 == false);\n  ASSERT(a.ip == 0x100007f);\n  ASSERT(strcmp(mg_ntoa(&a, buf, sizeof(buf)), \"127.0.0.1\") == 0);\n\n  ASSERT(mg_aton(mg_str(\"1:2:3:4:5:6:7:8\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00\\x07\\x00\\x08\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::fFff:1.2.3.4\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(memcmp(a.ip6,\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                \"\\x00\\x00\\xff\\xff\\x01\\x02\\x03\\x04\",\n                sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"2001:4860:4860::8888\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x20\\x01\\x48\\x60\\x48\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x88\\x88\",\n             sizeof(a.ip6)) == 0);\n\n  ASSERT(strcmp(mg_hex(\"abc\", 3, buf), \"616263\") == 0);\n  ASSERT(mg_url_decode(\"a=%\", 3, buf, sizeof(buf), 0) < 0);\n  ASSERT(mg_url_decode(\"&&&a=%\", 6, buf, sizeof(buf), 0) < 0);\n\n  {\n    size_t n;\n    ASSERT((n = mg_url_encode(\"\", 0, buf, sizeof(buf))) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, 0)) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, sizeof(buf))) == 1);\n    ASSERT(strncmp(buf, \"a\", n) == 0);\n    ASSERT((n = mg_url_encode(\"._-~\", 4, buf, sizeof(buf))) == 4);\n    ASSERT(strncmp(buf, \"._-~\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@%>\", 4, buf, sizeof(buf))) == 10);\n    ASSERT(strncmp(buf, \"a%40%25%3e\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@b.c\", 5, buf, sizeof(buf))) == 7);\n    ASSERT(strncmp(buf, \"a%40b.c\", n) == 0);\n  }\n\n  {\n    s = buf;\n    mg_asprintf(&s, sizeof(buf), \"%s\", \"%3d\", 123);\n    ASSERT(s == buf);\n    ASSERT(strcmp(buf, \"%3d\") == 0);\n    mg_asprintf(&s, sizeof(buf), \"%.*s\", 7, \"a%40b.c\");\n    ASSERT(s == buf);\n    ASSERT(strcmp(buf, \"a%40b.c\") == 0);\n  }\n\n  ASSERT(mg_to64(mg_str(\"-9223372036854775809\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775800\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775700\")) > 0);\n}\n\nstatic void test_crc32(void) {\n  //  echo -n aaa | cksum -o3\n  ASSERT(mg_crc32(0, 0, 0) == 0);\n  ASSERT(mg_crc32(0, \"a\", 1) == 3904355907);\n  ASSERT(mg_crc32(0, \"abc\", 3) == 891568578);\n  ASSERT(mg_crc32(mg_crc32(0, \"ab\", 2), \"c\", 1) == 891568578);\n}\n\n#define LONG_CHUNK \"chunk with length taking up more than two hex digits\"\n\n// Streaming server event handler.\n// Send one chunk immediately, then drain, then send two chunks in one go\nstatic void eh2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_printf(c, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    mg_http_printf_chunk(c, LONG_CHUNK);\n    c->label[0] = 1;\n  } else if (ev == MG_EV_POLL) {\n    if (c->label[0] > 0 && c->send.len == 0) c->label[0]++;\n    if (c->label[0] > 10 && c->label[0] != 'x') {\n      mg_http_printf_chunk(c, \"chunk 1\");\n      mg_http_printf_chunk(c, \"chunk 2\");\n      mg_http_printf_chunk(c, \"\");\n      c->label[0] = 'x';\n    }\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\n// Non-streaming client event handler. Make sure we've got full body\nstatic void eh3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET / HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    // LOG(LL_INFO, (\"----> [%.*s]\", (int) hm->body.len, hm->body.ptr));\n    c->is_closing = 1;\n    *(uint32_t *) fn_data = mg_crc32(0, hm->body.ptr, hm->body.len);\n  }\n}\n\n// Streaming client event handler. Make sure we've got all chunks\nstatic void eh4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) c->label;\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET / HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->body.ptr, hm->body.len);\n    // LOG(LL_INFO, (\"MSG [%.*s]\", (int) hm->body.len, hm->body.ptr));\n    c->is_closing = 1;\n    *(uint32_t *) fn_data = *crc;\n  }\n  (void) ev_data;\n}\n\n// Streaming client event handler. Delete chunks as they arrive\nstatic void eh5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) c->label;\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET / HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    // LOG(LL_INFO, (\"CHUNK [%.*s]\", (int) hm->chunk.len, hm->chunk.ptr));\n    mg_http_delete_chunk(c, hm);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    c->is_closing = 1;\n    *(uint32_t *) fn_data = *crc;\n    // LOG(LL_INFO, (\"MSG [%.*s]\", (int) hm->body.len, hm->body.ptr));\n  }\n  (void) ev_data;\n}\n\nstatic void test_http_chunked(void) {\n  struct mg_mgr mgr;\n  const char *data, *url = \"http://127.0.0.1:12344\";\n  uint32_t i, done = 0;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh2, NULL);\n\n  mg_http_connect(&mgr, url, eh3, &done);\n  for (i = 0; i < 50 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(i < 50);\n  data = LONG_CHUNK \"chunk 1chunk 2\";\n  ASSERT(done == mg_crc32(0, data, strlen(data)));\n\n  done = 0;\n  mg_http_connect(&mgr, url, eh4, &done);\n  for (i = 0; i < 50 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  data = LONG_CHUNK LONG_CHUNK \"chunk 1chunk 2\" LONG_CHUNK \"chunk 1chunk 2\";\n  ASSERT(done == mg_crc32(0, data, strlen(data)));\n\n  done = 0;\n  mg_http_connect(&mgr, url, eh5, &done);\n  for (i = 0; i < 50 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  data = LONG_CHUNK \"chunk 1chunk 2\";\n  ASSERT(done == mg_crc32(0, data, strlen(data)));\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\n#undef LONG_CHUNK\n\nstatic void test_multipart(void) {\n  struct mg_http_part part;\n  size_t ofs;\n  const char *s =\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"val\\\"\\r\\n\"\n      \"\\r\\n\"\n      \"abc\\r\\ndef\\r\\n\"\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"foo\\\"; filename=\\\"a b.txt\\\"\\r\\n\"\n      \"Content-Type: text/plain\\r\\n\"\n      \"\\r\\n\"\n      \"hello world\\r\\n\"\n      \"\\r\\n\"\n      \"--xyz--\\r\\n\";\n  ASSERT(mg_http_next_multipart(mg_str(\"\"), 0, NULL) == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), 0, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"val\")) == 0);\n  // LOG(LL_INFO, (\"--> [%.*s]\", (int) part.body.len, part.body.ptr));\n  ASSERT(mg_strcmp(part.body, mg_str(\"abc\\r\\ndef\")) == 0);\n  ASSERT(part.filename.len == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), ofs, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"foo\")) == 0);\n  // LOG(LL_INFO, (\"--> [%.*s]\", (int) part.filename.len, part.filename.ptr));\n  ASSERT(mg_strcmp(part.filename, mg_str(\"a b.txt\")) == 0);\n  ASSERT(mg_strcmp(part.body, mg_str(\"hello world\\r\\n\")) == 0);\n  ASSERT(mg_http_next_multipart(mg_str(s), ofs, &part) == 0);\n}\n\nstatic void eh7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts sopts;\n    memset(&sopts, 0, sizeof(sopts));\n    sopts.root_dir = \"\";\n    sopts.fs = &mg_fs_packed;\n    mg_http_serve_dir(c, hm, &sopts);\n  }\n  (void) ev_data, (void) fn_data;\n}\n\nstatic void test_packed(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12351\";\n  char buf[FETCH_BUF_SIZE] = \"\", *data = mg_file_read(\"Makefile\", NULL);\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh7, NULL);\n\n  // Load top level file directly\n  ASSERT(fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // Load file deeper in the FS tree directly\n  data = mg_file_read(\"src/ssi.h\", NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /src/ssi.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // List root dir\n  ASSERT(fetch(&mgr, buf, url, \"GET / HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  // List nested dir\n  ASSERT(fetch(&mgr, buf, url, \"GET /test HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh6(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_READ) *(int *) fn_data = 1;\n  (void) c, (void) ev_data;\n}\n\nstatic void test_pipe(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  int i, done = 0;\n  mg_mgr_init(&mgr);\n  ASSERT((c = mg_mkpipe(&mgr, eh6, (void *) &done)) != NULL);\n  mg_mgr_wakeup(c);\n  for (i = 0; i < 10 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(done == 1);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void u1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    ((int *) fn_data)[0] += 1;\n    mg_send(c, \"hi\", 2);\n  } else if (ev == MG_EV_WRITE) {\n    ((int *) fn_data)[0] += 100;\n  } else if (ev == MG_EV_READ) {\n    ((int *) fn_data)[0] += 10;\n    mg_iobuf_free(&c->recv);\n  }\n  (void) ev_data;\n}\n\nstatic void test_udp(void) {\n  struct mg_mgr mgr;\n  const char *url = \"udp://127.0.0.1:12353\";\n  int i, done = 0;\n  mg_mgr_init(&mgr);\n  mg_listen(&mgr, url, u1, (void *) &done);\n  mg_connect(&mgr, url, u1, (void *) &done);\n  for (i = 0; i < 5; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"%d\", done));\n  ASSERT(done == 111);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_check_ip_acl(void) {\n  uint32_t ip = 0x01020304;\n  ASSERT(mg_check_ip_acl(mg_str(NULL), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"invalid\"), ip) == -1);\n  ASSERT(mg_check_ip_acl(mg_str(\"+hi\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"+//\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0\"), ip) == 0);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/8\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.2.3.4\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/16\"), ip) == 0);\n}\n\nstatic void w3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  LOG(LL_INFO, (\"ev %d\", ev));\n  if (ev == MG_EV_WS_OPEN) {\n    mg_ws_send(c, \"hi there!\", 9, WEBSOCKET_OP_TEXT);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    ASSERT(mg_strcmp(wm->data, mg_str(\"lebowski\")) == 0);\n    ((int *) fn_data)[0]++;\n  } else if (ev == MG_EV_CLOSE) {\n    ((int *) fn_data)[0] += 10;\n  }\n}\n\nstatic void w2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_str msg = mg_str_n(\"lebowski\", 8);\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_ws_upgrade(c, (struct mg_http_message *) ev_data, NULL);\n  } else if (ev == MG_EV_WS_OPEN) {\n    mg_ws_send(c, \"x\", 1, WEBSOCKET_OP_PONG);\n  } else if (ev == MG_EV_POLL && c->is_websocket) {\n    size_t ofs, n = (size_t) fn_data;\n    if (n < msg.len) {\n      // Send \"msg\" char by char using fragmented frames\n      // mg_ws_send() sets the FIN flag in the WS header. Clean it\n      // to send fragmented packet. Insert PONG messages between frames\n      uint8_t op = n == 0 ? WEBSOCKET_OP_TEXT : WEBSOCKET_OP_CONTINUE;\n      mg_ws_send(c, \":->\", 3, WEBSOCKET_OP_PING);\n      ofs = c->send.len;\n      mg_ws_send(c, &msg.ptr[n], 1, op);\n      if (n < msg.len - 1) c->send.buf[ofs] = op;  // Clear FIN flag\n      c->fn_data = (void *) (n + 1);               // Point to the next char\n    } else {\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    }\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    ASSERT(mg_strcmp(wm->data, mg_str(\"hi there!\")) == 0);\n  }\n}\n\nstatic void test_ws_fragmentation(void) {\n  const char *url = \"ws://localhost:12357/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, w2, NULL) != NULL);\n  mg_ws_connect(&mgr, url, w3, &done, \"%s\", \"Sec-WebSocket-Protocol: echo\\r\\n\");\n  for (i = 0; i < 25; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"--> %d\", done));\n  ASSERT(done == 11);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void h7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data,/foo=./src\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_rewrites(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"http://LOCALHOST:12358\";\n  const char *expected = \"#define MG_VERSION \\\"\" MG_VERSION \"\\\"\\n\";\n  struct mg_mgr mgr;\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, h7, NULL) != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/version.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, expected) == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"-->[%s]\\n\", buf);\n  // exit(0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_get_header_var(void) {\n  struct mg_str empty = mg_str(\"\"), bar = mg_str(\"bar\"), baz = mg_str(\"baz\");\n  struct mg_str header = mg_str(\"Digest foo=\\\"bar\\\", blah,boo=baz, x=\\\"yy\\\"\");\n  struct mg_str yy = mg_str(\"yy\");\n  // struct mg_str x = mg_http_get_header_var(header, mg_str(\"x\"));\n  // LOG(LL_INFO, (\"--> [%d] [%d]\", (int) x.len, yy.len));\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(empty, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fooo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"blah\"))) == 0);\n  ASSERT(mg_strcmp(bar, mg_http_get_header_var(header, mg_str(\"foo\"))) == 0);\n  ASSERT(mg_strcmp(baz, mg_http_get_header_var(header, mg_str(\"boo\"))) == 0);\n  ASSERT(mg_strcmp(yy, mg_http_get_header_var(header, mg_str(\"x\"))) == 0);\n}\n\nint main(void) {\n  mg_log_set(\"3\");\n  test_get_header_var();\n  test_rewrites();\n  test_check_ip_acl();\n  test_udp();\n  test_pipe();\n  test_packed();\n  test_crc32();\n  test_multipart();\n  test_http_chunked();\n  test_http_parse();\n  test_util();\n  test_sntp();\n  test_dns();\n  test_str();\n  test_timer();\n  test_url();\n  test_iobuf();\n  test_commalist();\n  test_base64();\n  test_globmatch();\n  test_http_get_var();\n  test_tls();\n  test_ws();\n  test_ws_fragmentation();\n  test_http_server();\n  test_http_client();\n  test_http_no_content_length();\n  test_http_pipeline();\n  test_http_range();\n  test_mqtt();\n  printf(\"SUCCESS. Total tests: %d\\n\", s_num_tests);\n  return EXIT_SUCCESS;\n}\n"], "fixing_code": ["SRCS = mongoose.c test/unit_test.c test/packed_fs.c\nHDRS = $(wildcard src/*.h)\nDEFS ?= -DMG_MAX_HTTP_HEADERS=7 -DMG_ENABLE_LINES -DMG_ENABLE_PACKED_FS=1\nWARN ?= -W -Wall -Werror -Wshadow -Wdouble-promotion -fno-common -Wconversion -Wundef\nOPTS ?= -O3 -g3\nINCS ?= -Isrc -I.\nCFLAGS ?= $(OPTS) $(WARN) $(INCS) $(DEFS) $(TFLAGS) $(EXTRA)\nSSL ?= MBEDTLS\nCWD ?= $(realpath $(CURDIR))\nDOCKER ?= docker run --rm -e Tmp=. -e WINEDEBUG=-all -v $(CWD):$(CWD) -w $(CWD)\nVCFLAGS = /nologo /W3 /O2 /I. $(DEFS) $(TFLAGS)\nIPV6 ?= 1\nASAN_OPTIONS ?=\nEXAMPLES := $(wildcard examples/*)\nPREFIX ?= /usr/local\nVERSION ?= $(shell cut -d'\"' -f2 src/version.h)\n.PHONY: examples test\n\nifeq \"$(SSL)\" \"MBEDTLS\"\nMBEDTLS ?= /usr\nCFLAGS  += -DMG_ENABLE_MBEDTLS=1 -I$(MBEDTLS)/include -I/usr/include\nLDFLAGS ?= -L$(MBEDTLS)/lib -lmbedtls -lmbedcrypto -lmbedx509\nendif\nifeq \"$(SSL)\" \"OPENSSL\"\nOPENSSL ?= /usr\nCFLAGS  += -DMG_ENABLE_OPENSSL=1 -I$(OPENSSL)/include\nLDFLAGS ?= -L$(OPENSSL)/lib -lssl -lcrypto\nendif\n\nall: mg_prefix unpacked test test++ arm examples vc98 vc2017 mingw mingw++ linux linux++ fuzz\n\nexamples:\n\t@for X in $(EXAMPLES); do $(MAKE) -C $$X example || break; done\n\ntest/packed_fs.c: Makefile src/fs.h src/ssi.h test/fuzz.c test/data/a.txt\n\t$(CC) $(CFLAGS) test/pack.c -o pack\n\t./pack $? > $@\n\n# Check that all external (exported) symbols have \"mg_\" prefix\nmg_prefix: mongoose.c mongoose.h\n\t$(CC) mongoose.c $(CFLAGS) -c -o /tmp/x.o && nm /tmp/x.o | grep ' T' | grep -v 'mg_' ; test $$? = 1\n\n# C++ build\ntest++: CC = g++\ntest++: WARN += -Wno-shadow -Wno-missing-field-initializers -Wno-deprecated\ntest++: test\n\n# Make sure we can build from an unamalgamated sources\nunamalgamated: $(HDRS) Makefile test/packed_fs.c\n\t$(CC) src/*.c test/packed_fs.c test/unit_test.c $(CFLAGS) $(LDFLAGS) -g -o unit_test\n\nunpacked:\n\t$(CC) -I. mongoose.c test/unit_test.c -o unit_test\n\nfuzzer: mongoose.c mongoose.h Makefile test/fuzz.c\n\tclang mongoose.c test/fuzz.c $(WARN) $(INCS) -DMG_ENABLE_LINES -DMG_ENABLE_LOG=0 -fsanitize=fuzzer,signed-integer-overflow,address -g -o $@\n\nfuzz: fuzzer\n\t$(RUN) ./fuzzer\n\n# make CC=/usr/local/opt/llvm\\@8/bin/clang ASAN_OPTIONS=detect_leaks=1\ntest: CFLAGS += -DMG_ENABLE_IPV6=$(IPV6) -fsanitize=address,undefined\ntest: mongoose.h  Makefile $(SRCS)\n\t$(CC) $(SRCS) $(CFLAGS) -coverage $(LDFLAGS) -g -o unit_test\n\tASAN_OPTIONS=$(ASAN_OPTIONS) $(RUN) ./unit_test\n\ncoverage: test\n\tgcov -l -n *.gcno | sed '/^$$/d' | sed 'N;s/\\n/ /'\n\tgcov mongoose.gcno >/dev/null\n\nupload-coverage: coverage\n\tcurl -s https://codecov.io/bash | /bin/bash\n\ninfer:\n\tinfer run -- cc test/unit_test.c -c -W -Wall -Werror -Isrc -I. -O2 -DMG_ENABLE_MBEDTLS=1 -DMG_ENABLE_LINES -I/usr/local/Cellar/mbedtls/2.23.0/include  -DMG_ENABLE_IPV6=1 -g -o /dev/null\n\narm: mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/armgcc arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb $(SRCS) test/mongoose_custom.c -Itest -DMG_ARCH=MG_ARCH_CUSTOM $(OPTS) $(WARN) $(INCS) $(DEFS) -o unit_test -nostartfiles --specs nosys.specs -e 0\n\nriscv: mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/riscv riscv-none-elf-gcc -march=rv32imc -mabi=ilp32 $(SRCS) test/mongoose_custom.c -Itest -DMG_ARCH=MG_ARCH_CUSTOM $(OPTS) $(WARN) $(INCS) $(DEFS) -o unit_test\n\n#vc98: VCFLAGS += -DMG_ENABLE_IPV6=1\nvc98: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/vc98 wine cl $(SRCS) $(VCFLAGS) ws2_32.lib /Fe$@.exe\n\t$(DOCKER) mdashnet/vc98 wine $@.exe\n\n#vc2017: VCFLAGS += -DMG_ENABLE_IPV6=1\nvc2017: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/vc2017 wine64 cl $(SRCS) $(VCFLAGS) ws2_32.lib /Fe$@.exe\n\t$(DOCKER) mdashnet/vc2017 wine64 $@.exe\n\nmingw: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/mingw i686-w64-mingw32-gcc $(SRCS) -W -Wall -Werror -I. $(DEFS) -lwsock32 -o test.exe\n\t$(DOCKER) mdashnet/vc98 wine test.exe\n\nmingw++: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/mingw i686-w64-mingw32-g++ $(SRCS) -W -Wall -Werror -I. $(DEFS) -lwsock32 -o test.exe\n  # Note: for some reason, a binary built with mingw g++, fails to run\n\n#linux: CFLAGS += -DMG_ENABLE_IPV6=$(IPV6)\nlinux: CFLAGS += -fsanitize=address,undefined\nlinux: Makefile mongoose.h $(SRCS)\n\t$(DOCKER) mdashnet/cc2 gcc $(SRCS) $(CFLAGS) $(LDFLAGS) -o unit_test_gcc\n\t$(DOCKER) mdashnet/cc2 ./unit_test_gcc\n\nlinux++: CC = g++\nlinux++: WARN += -Wno-missing-field-initializers\nlinux++: linux\n\nlinux-libs: CFLAGS += -fPIC\nlinux-libs: mongoose.o\n\t$(CC) mongoose.o $(LDFLAGS) -shared -o libmongoose.so.$(VERSION)\n\t$(AR) rcs libmongoose.a mongoose.o\n\ninstall: linux-libs\n\tinstall -Dm644 libmongoose.a libmongoose.so.$(VERSION) $(DESTDIR)$(PREFIX)/lib\n\tln -s libmongoose.so.$(VERSION) $(DESTDIR)$(PREFIX)/lib/libmongoose.so\n\tinstall -Dm644 mongoose.h $(DESTDIR)$(PREFIX)/include/mongoose.h\n\nuninstall:\n\trm -rf $(DESTDIR)$(PREFIX)/lib/libmongoose.a $(DESTDIR)$(PREFIX)/lib/libmongoose.so.$(VERSION) $(DESTDIR)$(PREFIX)/include/mongoose.h $(DESTDIR)$(PREFIX)/lib/libmongoose.so\n\nmongoose.c: Makefile $(wildcard src/*)\n\t(cat src/license.h; echo; echo '#include \"mongoose.h\"' ; (for F in src/*.c ; do echo; echo '#ifdef MG_ENABLE_LINES'; echo \"#line 1 \\\"$$F\\\"\"; echo '#endif'; cat $$F | sed -e 's,#include \".*,,'; done))> $@\n\nmongoose.h: $(HDRS) Makefile\n\t(cat src/license.h; echo; echo '#ifndef MONGOOSE_H'; echo '#define MONGOOSE_H'; echo; cat src/version.h ; echo; echo '#ifdef __cplusplus'; echo 'extern \"C\" {'; echo '#endif'; cat src/arch.h src/arch_*.h src/config.h src/str.h src/log.h src/timer.h src/util.h src/fs.h src/url.h src/iobuf.h src/base64.h src/md5.h src/sha1.h src/event.h src/net.h src/http.h src/ssi.h src/tls.h src/tls_mbed.h src/tls_openssl.h src/ws.h src/sntp.h src/mqtt.h src/dns.h | sed -e 's,#include \".*,,' -e 's,^#pragma once,,'; echo; echo '#ifdef __cplusplus'; echo '}'; echo '#endif'; echo '#endif  // MONGOOSE_H')> $@\n\nclean:\n\trm -rf $(PROG) *.o *.dSYM unit_test* ut fuzzer *.gcov *.gcno *.gcda *.obj *.exe *.ilk *.pdb slow-unit* _CL_* infer-out data.txt crash-* test/packed_fs.c pack\n\t@for X in $(EXAMPLES); do $(MAKE) -C $$X clean; done\n", "// Copyright (c) 2004-2013 Sergey Lyubka\n// Copyright (c) 2013-2021 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.gnu.org/licenses/\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, as set out in https://www.mongoose.ws/licensing/\n\n#include \"mongoose.h\"\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/base64.c\"\n#endif\n\n#include <string.h>\n\nstatic int mg_b64idx(int c) {\n  if (c < 26) {\n    return c + 'A';\n  } else if (c < 52) {\n    return c - 26 + 'a';\n  } else if (c < 62) {\n    return c - 52 + '0';\n  } else {\n    return c == 62 ? '+' : '/';\n  }\n}\n\nstatic int mg_b64rev(int c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A';\n  } else if (c >= 'a' && c <= 'z') {\n    return c + 26 - 'a';\n  } else if (c >= '0' && c <= '9') {\n    return c + 52 - '0';\n  } else if (c == '+') {\n    return 62;\n  } else if (c == '/') {\n    return 63;\n  } else if (c == '=') {\n    return 64;\n  } else {\n    return -1;\n  }\n}\n\nint mg_base64_update(unsigned char ch, char *to, int n) {\n  int rem = (n & 3) % 3;\n  if (rem == 0) {\n    to[n] = (char) mg_b64idx(ch >> 2);\n    to[++n] = (char) ((ch & 3) << 4);\n  } else if (rem == 1) {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 4));\n    to[++n] = (char) ((ch & 15) << 2);\n  } else {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 6));\n    to[++n] = (char) mg_b64idx(ch & 63);\n    n++;\n  }\n  return n;\n}\n\nint mg_base64_final(char *to, int n) {\n  int saved = n;\n  // printf(\"---[%.*s]\\n\", n, to);\n  if (n & 3) n = mg_base64_update(0, to, n);\n  if ((saved & 3) == 2) n--;\n  // printf(\"    %d[%.*s]\\n\", n, n, to);\n  while (n & 3) to[n++] = '=';\n  to[n] = '\\0';\n  return n;\n}\n\nint mg_base64_encode(const unsigned char *p, int n, char *to) {\n  int i, len = 0;\n  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);\n  len = mg_base64_final(to, len);\n  return len;\n}\n\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src + n;\n  int len = 0;\n  while (src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/dns.c\"\n#endif\n\n\n\n\n\n\n\nstruct dns_data {\n  struct dns_data *next;\n  struct mg_connection *c;\n  int64_t expire;\n  uint16_t txnid;\n};\n\nstatic struct dns_data *s_reqs;  // Active DNS requests\n\nstatic void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,\n                         struct mg_dns *, bool);\n\nstatic void mg_dns_free(struct dns_data *d) {\n  LIST_DELETE(struct dns_data, &s_reqs, d);\n  free(d);\n}\n\nvoid mg_resolve_cancel(struct mg_connection *c) {\n  struct dns_data *tmp, *d;\n  for (d = s_reqs; d != NULL; d = tmp) {\n    tmp = d->next;\n    if (d->c == c) mg_dns_free(d);\n  }\n}\n\nstatic size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,\n                                      char *to, size_t tolen, int depth) {\n  size_t i = 0, j = 0;\n  if (tolen > 0) to[0] = '\\0';\n  if (depth > 5) return 0;\n  while (ofs + i + 1 < len) {\n    size_t n = s[ofs + i];\n    if (n == 0) {\n      i++;\n      break;\n    }\n    if (n & 0xc0) {\n      size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len\n      if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&\n          mg_dns_parse_name_depth(s, len, ptr, to, tolen, depth + 1) == 0)\n        return 0;\n      i += 2;\n      break;\n    }\n    if (ofs + i + n + 1 >= len) return 0;\n    if (j > 0) {\n      if (j < tolen) to[j] = '.';\n      j++;\n    }\n    if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);\n    j += n;\n    i += n + 1;\n    if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk\n  }\n  if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term\n  return i;\n}\n\nstatic size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,\n                                char *dst, size_t dstlen) {\n  return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0);\n}\n\nsize_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,\n                       bool is_question, struct mg_dns_rr *rr) {\n  const uint8_t *s = buf + ofs, *e = &buf[len];\n\n  memset(rr, 0, sizeof(*rr));\n  if (len < sizeof(struct mg_dns_header)) return 0;  // Too small\n  if (len > 512) return 0;  //  Too large, we don't expect that\n  if (s >= e) return 0;     //  Overflow\n\n  if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)\n    return 0;\n  s += rr->nlen + 4;\n  if (s > e) return 0;\n  rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);\n  rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (is_question) return (size_t) (rr->nlen + 4);\n\n  s += 6;\n  if (s > e) return 0;\n  rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (s + rr->alen > e) return 0;\n  return (size_t) (rr->nlen + rr->alen + 10);\n}\n\nbool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {\n  const struct mg_dns_header *h = (struct mg_dns_header *) buf;\n  struct mg_dns_rr rr;\n  size_t i, n, ofs = sizeof(*h);\n  memset(dm, 0, sizeof(*dm));\n\n  if (len < sizeof(*h)) return 0;                // Too small, headers dont fit\n  if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity\n  if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity\n  dm->txnid = mg_ntohs(h->txnid);\n\n  for (i = 0; i < mg_ntohs(h->num_questions); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;\n    // LOG(LL_INFO, (\"Q %zu %zu\", ofs, n));\n    ofs += n;\n  }\n  for (i = 0; i < mg_ntohs(h->num_answers); i++) {\n    // LOG(LL_INFO, (\"A -- %zu %zu %s\", ofs, n, dm->name));\n    if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;\n    mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));\n    ofs += n;\n\n    if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {\n      dm->addr.is_ip6 = false;\n      memcpy(&dm->addr.ip, &buf[ofs - 4], 4);\n      dm->resolved = true;\n      break;  // Return success\n    } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {\n      dm->addr.is_ip6 = true;\n      memcpy(&dm->addr.ip6, &buf[ofs - 16], 16);\n      dm->resolved = true;\n      break;  // Return success\n    }\n  }\n  return true;\n}\n\nstatic void dns_cb(struct mg_connection *c, int ev, void *ev_data,\n                   void *fn_data) {\n  struct dns_data *d, *tmp;\n  if (ev == MG_EV_POLL) {\n    int64_t now = *(int64_t *) ev_data;\n    for (d = s_reqs; d != NULL; d = tmp) {\n      tmp = d->next;\n      // LOG(LL_DEBUG, (\"%lu %lu dns poll\", d->expire, now));\n      if (now > d->expire) mg_error(d->c, \"DNS timeout\");\n    }\n  } else if (ev == MG_EV_READ) {\n    struct mg_dns_message dm;\n    int resolved = 0;\n    if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {\n      char *s = mg_hexdump(c->recv.buf, c->recv.len);\n      LOG(LL_ERROR, (\"Unexpected DNS response:\\n%s\\n\", s));\n      free(s);\n    } else {\n      LOG(LL_VERBOSE_DEBUG, (\"%s %d\", dm.name, dm.resolved));\n      for (d = s_reqs; d != NULL; d = tmp) {\n        tmp = d->next;\n        // LOG(LL_INFO, (\"d %p %hu %hu\", d, d->txnid, dm.txnid));\n        if (dm.txnid != d->txnid) continue;\n        if (d->c->is_resolving) {\n          d->c->is_resolving = 0;\n          if (dm.resolved) {\n#if MG_ENABLE_LOG\n            char buf[100];\n#endif\n            dm.addr.port = d->c->peer.port;  // Save port\n            d->c->peer = dm.addr;            // Copy resolved address\n            LOG(LL_DEBUG, (\"%lu %s resolved to %s\", d->c->id, dm.name,\n                           mg_ntoa(&d->c->peer, buf, sizeof(buf))));\n            mg_connect_resolved(d->c);\n#if MG_ENABLE_IPV6\n          } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0') {\n            struct mg_str x = mg_str(dm.name);\n            mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);\n#endif\n          } else {\n            mg_error(d->c, \"%s DNS lookup failed\", dm.name);\n          }\n        } else {\n          LOG(LL_ERROR, (\"%lu already resolved\", d->c->id));\n        }\n        mg_dns_free(d);\n        resolved = 1;\n      }\n    }\n    if (!resolved) LOG(LL_ERROR, (\"stray DNS reply\"));\n    c->recv.len = 0;\n  } else if (ev == MG_EV_CLOSE) {\n    for (d = s_reqs; d != NULL; d = tmp) {\n      tmp = d->next;\n      mg_error(d->c, \"DNS error\");\n      mg_dns_free(d);\n    }\n  }\n  (void) fn_data;\n}\n\nstatic void mg_dns_send(struct mg_connection *c, const struct mg_str *name,\n                        uint16_t txnid, bool ipv6) {\n  struct {\n    struct mg_dns_header header;\n    uint8_t data[256];\n  } pkt;\n  size_t i, n;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.header.txnid = mg_htons(txnid);\n  pkt.header.flags = mg_htons(0x100);\n  pkt.header.num_questions = mg_htons(1);\n  for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {\n    if (name->ptr[i] == '.' || i >= name->len) {\n      pkt.data[n] = (uint8_t) (i - n);\n      memcpy(&pkt.data[n + 1], name->ptr + n, i - n);\n      n = i + 1;\n    }\n    if (i >= name->len) break;\n  }\n  memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query\n  n += 5;\n  if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query\n  // memcpy(&pkt.data[n], \"\\xc0\\x0c\\x00\\x1c\\x00\\x01\", 6);  // AAAA query\n  // n += 6;\n  mg_send(c, &pkt, sizeof(pkt.header) + n);\n#if 0\n  // Immediately after A query, send AAAA query. Whatever reply comes first,\n  // we'll use it. Note: we cannot send two queries in a single packet.\n  // https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query\n  pkt.data[n - 3] = 0x1c;  // AAAA query\n  mg_send(c, &pkt, sizeof(pkt.header) + n);\n#endif\n}\n\nstatic void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,\n                         struct mg_dns *dnsc, bool ipv6) {\n  struct dns_data *d = NULL;\n  if (dnsc->url == NULL) {\n    mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");\n  } else if (dnsc->c == NULL) {\n    dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);\n    if (dnsc->c != NULL) {\n      dnsc->c->pfn = dns_cb;\n      // snprintf(dnsc->c->label, sizeof(dnsc->c->label), \"%s\", \"DNS\");\n      // dnsc->c->is_hexdumping = 1;\n    }\n  }\n  if (dnsc->c == NULL) {\n    mg_error(c, \"resolver\");\n  } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {\n    mg_error(c, \"resolve OOM\");\n  } else {\n#if MG_ENABLE_LOG\n    char buf[100];\n#endif\n    d->txnid = s_reqs ? (uint16_t) (s_reqs->txnid + 1) : 1;\n    d->next = s_reqs;\n    s_reqs = d;\n    d->expire = mg_millis() + (int64_t) ms;\n    d->c = c;\n    c->is_resolving = 1;\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,\n         name->ptr, mg_ntoa(&dnsc->c->peer, buf, sizeof(buf)), d->txnid));\n    mg_dns_send(dnsc->c, name, d->txnid, ipv6);\n  }\n}\n\nvoid mg_resolve(struct mg_connection *c, const char *url) {\n  struct mg_str host = mg_url_host(url);\n  c->peer.port = mg_htons(mg_url_port(url));\n  if (mg_aton(host, &c->peer)) {\n    // host is an IP address, do not fire name resolution\n    mg_connect_resolved(c);\n  } else {\n    // host is not an IP, send DNS resolution request\n    mg_sendnsreq(c, &host, c->mgr->dnstimeout, &c->mgr->dns4, false);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/event.c\"\n#endif\n\n\n\n\n\nvoid mg_call(struct mg_connection *c, int ev, void *ev_data) {\n  // Run user-defined handler first, in order to give it an ability\n  // to intercept processing (e.g. clean input buffer) before the\n  // protocol handler kicks in\n  if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);\n  if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);\n}\n\nvoid mg_error(struct mg_connection *c, const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  LOG(LL_ERROR, (\"%lu %s\", c->id, buf));\n  c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL\n  mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it\n  if (buf != mem) free(buf);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_packed.c\"\n#endif\n\n\nstruct packed_file {\n  const char *data;\n  size_t size;\n  size_t pos;\n};\n\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime);\nconst char *mg_unlist(size_t no);\n#if MG_ENABLE_PACKED_FS\n#else\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return NULL;\n}\nconst char *mg_unlist(size_t no) {\n  (void) no;\n  return NULL;\n}\n#endif\n\nstatic int is_dir_prefix(const char *prefix, size_t n, const char *path) {\n  return n < strlen(path) && memcmp(prefix, path, n) == 0 && path[n] == '/';\n  //(n == 0 || path[n] == MG_DIRSEP);\n}\n\nstatic int packed_stat(const char *path, size_t *size, time_t *mtime) {\n  const char *p;\n  size_t i, n = strlen(path);\n  if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file\n  // Scan all files. If `path` is a dir prefix for any of them, it's a dir\n  for (i = 0; (p = mg_unlist(i)) != NULL; i++) {\n    if (is_dir_prefix(path, n, p)) return MG_FS_DIR;\n  }\n  return 0;\n}\n\nstatic void packed_list(const char *dir, void (*fn)(const char *, void *),\n                        void *userdata) {\n  char buf[256], tmp[sizeof(buf)];\n  const char *path, *begin, *end;\n  size_t i, n = strlen(dir);\n  tmp[0] = '\\0';  // Previously listed entry\n  for (i = 0; (path = mg_unlist(i)) != NULL; i++) {\n    if (!is_dir_prefix(dir, n, path)) continue;\n    begin = &path[n + 1];\n    end = strchr(begin, '/');\n    if (end == NULL) end = begin + strlen(begin);\n    snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);\n    buf[sizeof(buf) - 1] = '\\0';\n    // If this entry has been already listed, skip\n    // NOTE: we're assuming that file list is sorted alphabetically\n    if (strcmp(buf, tmp) == 0) continue;\n    fn(buf, userdata);  // Not yet listed, call user function\n    strcpy(tmp, buf);   // And save this entry as listed\n  }\n}\n\nstatic struct mg_fd *packed_open(const char *path, int flags) {\n  size_t size = 0;\n  const char *data = mg_unpack(path, &size, NULL);\n  struct packed_file *fp = NULL;\n  struct mg_fd *fd = NULL;\n  if (data == NULL) return NULL;\n  if (flags & MG_FS_WRITE) return NULL;\n  fp = (struct packed_file *) calloc(1, sizeof(*fp));\n  fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  fp->size = size;\n  fp->data = data;\n  fd->fd = fp;\n  fd->fs = &mg_fs_packed;\n  return fd;\n}\n\nstatic void packed_close(struct mg_fd *fd) {\n  if (fd) free(fd->fd), free(fd);\n}\n\nstatic size_t packed_read(void *fd, void *buf, size_t len) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  if (fp->pos + len > fp->size) len = fp->size - fp->pos;\n  memcpy(buf, &fp->data[fp->pos], len);\n  fp->pos += len;\n  return len;\n}\n\nstatic size_t packed_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t packed_seek(void *fd, size_t offset) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  fp->pos = offset;\n  if (fp->pos > fp->size) fp->pos = fp->size;\n  return fp->pos;\n}\n\nstruct mg_fs mg_fs_packed = {packed_stat,  packed_list, packed_open,\n                             packed_close, packed_read, packed_write,\n                             packed_seek};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_posix.c\"\n#endif\n\n\n#if MG_ENABLE_FILE\n\n#ifndef MG_STAT_STRUCT\n#define MG_STAT_STRUCT stat\n#endif\n\n#ifndef MG_STAT_FUNC\n#define MG_STAT_FUNC stat\n#endif\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n#if !defined(S_ISDIR)\n  LOG(LL_ERROR, (\"stat() API is not supported. %p %p %p\", path, size, mtime));\n  return 0;\n#else\n#if defined(_WIN32)\n  struct _stati64 st;\n  wchar_t tmp[PATH_MAX];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));\n  if (_wstati64(tmp, &st) != 0) return 0;\n#else\n  struct MG_STAT_STRUCT st;\n  if (MG_STAT_FUNC(path, &st) != 0) return 0;\n#endif\n  if (size) *size = (size_t) st.st_size;\n  if (mtime) *mtime = st.st_mtime;\n  return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);\n#endif\n}\n\n#ifdef _WIN32\nstruct dirent {\n  char d_name[MAX_PATH];\n};\n\ntypedef struct win32_dir {\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n} DIR;\n\nint gettimeofday(struct timeval *tv, void *tz) {\n  FILETIME ft;\n  unsigned __int64 tmpres = 0;\n\n  if (tv != NULL) {\n    GetSystemTimeAsFileTime(&ft);\n    tmpres |= ft.dwHighDateTime;\n    tmpres <<= 32;\n    tmpres |= ft.dwLowDateTime;\n    tmpres /= 10;  // convert into microseconds\n    tmpres -= (int64_t) 11644473600000000;\n    tv->tv_sec = (long) (tmpres / 1000000UL);\n    tv->tv_usec = (long) (tmpres % 1000000UL);\n  }\n  (void) tz;\n  return 0;\n}\n\nstatic int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n  // Trim trailing slashes. Leave backslash for paths like \"X:\\\"\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  // Convert back to Unicode. If doubly-converted string does not match the\n  // original, something is fishy, reject.\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n  return ret;\n}\n\nDIR *opendir(const char *name) {\n  DIR *d = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      d->handle = FindFirstFileW(wpath, &d->info);\n      d->result.d_name[0] = '\\0';\n    } else {\n      free(d);\n      d = NULL;\n    }\n  }\n  return d;\n}\n\nint closedir(DIR *d) {\n  int result = 0;\n  if (d != NULL) {\n    if (d->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(d->handle) ? 0 : -1;\n    free(d);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct dirent *result = NULL;\n  if (d != NULL) {\n    memset(&d->result, 0, sizeof(d->result));\n    if (d->handle != INVALID_HANDLE_VALUE) {\n      result = &d->result;\n      WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,\n                          sizeof(result->d_name), NULL, NULL);\n      if (!FindNextFileW(d->handle, &d->info)) {\n        FindClose(d->handle);\n        d->handle = INVALID_HANDLE_VALUE;\n      }\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n#endif\n\nstatic void p_list(const char *dir, void (*fn)(const char *, void *),\n                   void *userdata) {\n#if MG_ENABLE_DIRLIST\n  struct dirent *dp;\n  DIR *dirp;\n  if ((dirp = (opendir(dir))) == NULL) return;\n  while ((dp = readdir(dirp)) != NULL) {\n    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;\n    fn(dp->d_name, userdata);\n  }\n  closedir(dirp);\n#else\n  (void) dir, (void) fn, (void) userdata;\n#endif\n}\n\nstatic struct mg_fd *p_open(const char *path, int flags) {\n  const char *mode = flags == (MG_FS_READ | MG_FS_WRITE) ? \"r+b\"\n                     : flags & MG_FS_READ                ? \"rb\"\n                     : flags & MG_FS_WRITE               ? \"wb\"\n                                                         : \"\";\n  void *fp = NULL;\n  struct mg_fd *fd = NULL;\n#ifdef _WIN32\n  wchar_t b1[PATH_MAX], b2[10];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));\n  MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));\n  fp = (void *) _wfopen(b1, b2);\n#else\n  fp = (void *) fopen(path, mode);\n#endif\n  if (fp == NULL) return NULL;\n  fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  fd->fd = fp;\n  fd->fs = &mg_fs_posix;\n  return fd;\n}\n\nstatic void p_close(struct mg_fd *fd) {\n  if (fd != NULL) fclose((FILE *) fd->fd), free(fd);\n}\n\nstatic size_t p_read(void *fp, void *buf, size_t len) {\n  return fread(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_write(void *fp, const void *buf, size_t len) {\n  return fwrite(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_seek(void *fp, size_t offset) {\n#if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\\n    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\\n    (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)\n  fseeko((FILE *) fp, (off_t) offset, SEEK_SET);\n#else\n  fseek((FILE *) fp, (long) offset, SEEK_SET);\n#endif\n  return (size_t) ftell((FILE *) fp);\n}\n\n#else\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return 0;\n}\n\nstatic void p_list(const char *path, void (*fn)(const char *, void *),\n                   void *userdata) {\n  (void) path, (void) fn, (void) userdata;\n}\n\nstatic struct mg_fd *p_open(const char *path, int flags) {\n  (void) path, (void) flags;\n  return NULL;\n}\n\nstatic void p_close(struct mg_fd *fd) {\n  (void) fd;\n}\n\nstatic size_t p_read(void *fd, void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t p_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t p_seek(void *fd, size_t offset) {\n  (void) fd, (void) offset;\n  return (size_t) ~0;\n}\n#endif\n\nstruct mg_fs mg_fs_posix = {p_stat, p_list,  p_open, p_close,\n                            p_read, p_write, p_seek};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/http.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // LOG(LL_INFO, (\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // LOG(LL_INFO, (\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // LOG(LL_INFO, (\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len + 21];\n    memcpy(&buf[-21], \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf, n);\n      }\n    }\n    n = mg_base64_final(buf, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    LOG(LL_ERROR, (\"%lu %s cannot resize iobuf %d->%d \", c->id, c->label,\n                   (int) c->send.size, (int) need));\n  }\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = buf->ptr + buf->len;\n    len = -4;  // Name does not exist\n    dst[0] = '\\0';\n    for (p = buf->ptr; p + name_len < e; p++) {\n      if ((p == buf->ptr || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_ncasecmp(name, p, name_len)) {\n        p += name_len + 1;\n        s = (const char *) memchr(p, '&', (size_t) (e - p));\n        if (s == NULL) s = e;\n        len = mg_url_decode(p, (size_t) (s - p), dst, dst_len, 1);\n        if (len < 0) len = -3;  // Failed to decode\n        break;\n      }\n    }\n  }\n  return len;\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isxdigit(*(const unsigned char *) (src + i + 1)) &&\n          isxdigit(*(const unsigned char *) (src + i + 2))) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128)\n      return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // LOG(LL_INFO, (\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s + req_len, *qs;\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list ap) {\n  char mem[256], *buf = mem;\n  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  mg_printf(c, \"%X\\r\\n\", len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  mg_send(c, \"\\r\\n\", 2);\n  if (buf != mem) free(buf);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lX\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 101: return \"Switching Protocols\";\n    case 102: return \"Processing\";\n    case 200: return \"OK\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 203: return \"Non-authoritative Information\";\n    case 204: return \"No Content\";\n    case 205: return \"Reset Content\";\n    case 206: return \"Partial Content\";\n    case 207: return \"Multi-Status\";\n    case 208: return \"Already Reported\";\n    case 226: return \"IM Used\";\n    case 300: return \"Multiple Choices\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 303: return \"See Other\";\n    case 304: return \"Not Modified\";\n    case 305: return \"Use Proxy\";\n    case 307: return \"Temporary Redirect\";\n    case 308: return \"Permanent Redirect\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 402: return \"Payment Required\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 405: return \"Method Not Allowed\";\n    case 406: return \"Not Acceptable\";\n    case 407: return \"Proxy Authentication Required\";\n    case 408: return \"Request Timeout\";\n    case 409: return \"Conflict\";\n    case 410: return \"Gone\";\n    case 411: return \"Length Required\";\n    case 412: return \"Precondition Failed\";\n    case 413: return \"Payload Too Large\";\n    case 414: return \"Request-URI Too Long\";\n    case 415: return \"Unsupported Media Type\";\n    case 416: return \"Requested Range Not Satisfiable\";\n    case 417: return \"Expectation Failed\";\n    case 418: return \"I'm a teapot\";\n    case 421: return \"Misdirected Request\";\n    case 422: return \"Unprocessable Entity\";\n    case 423: return \"Locked\";\n    case 424: return \"Failed Dependency\";\n    case 426: return \"Upgrade Required\";\n    case 428: return \"Precondition Required\";\n    case 429: return \"Too Many Requests\";\n    case 431: return \"Request Header Fields Too Large\";\n    case 444: return \"Connection Closed Without Response\";\n    case 451: return \"Unavailable For Legal Reasons\";\n    case 499: return \"Client Closed Request\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    case 502: return \"Bad Gateway\";\n    case 503: return \"Service Unavailable\";\n    case 504: return \"Gateway Timeout\";\n    case 505: return \"HTTP Version Not Supported\";\n    case 506: return \"Variant Also Negotiates\";\n    case 507: return \"Insufficient Storage\";\n    case 508: return \"Loop Detected\";\n    case 510: return \"Not Extended\";\n    case 511: return \"Network Authentication Required\";\n    case 599: return \"Network Connect Timeout Error\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length: %d\\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers, len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  if (buf != mem) free(buf);\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  struct mg_fd *fd = (struct mg_fd *) c->pfn_data;\n  if (fd != NULL) fd->fs->close(fd);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,\n           (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = 2 * MG_IO_SIZE;\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    n = fd->fs->read(fd->fd, c->send.buf + c->send.len,\n                     c->send.size - c->send.len);\n    if (n > 0) c->send.len += n;\n    if (c->send.len < c->send.size) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  // clang-format off\n  struct mimeentry { struct mg_str extension, value; };\n  #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}\n  // clang-format on\n  const struct mimeentry tab[] = {\n      MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),\n      MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),\n      MIME_ENTRY(\"gif\", \"image/gif\"),\n      MIME_ENTRY(\"png\", \"image/png\"),\n      MIME_ENTRY(\"jpg\", \"image/jpeg\"),\n      MIME_ENTRY(\"jpeg\", \"image/jpeg\"),\n      MIME_ENTRY(\"woff\", \"font/woff\"),\n      MIME_ENTRY(\"ttf\", \"font/ttf\"),\n      MIME_ENTRY(\"svg\", \"image/svg+xml\"),\n      MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),\n      MIME_ENTRY(\"avi\", \"video/x-msvideo\"),\n      MIME_ENTRY(\"csv\", \"text/csv\"),\n      MIME_ENTRY(\"doc\", \"application/msword\"),\n      MIME_ENTRY(\"exe\", \"application/octet-stream\"),\n      MIME_ENTRY(\"gz\", \"application/gzip\"),\n      MIME_ENTRY(\"ico\", \"image/x-icon\"),\n      MIME_ENTRY(\"json\", \"application/json\"),\n      MIME_ENTRY(\"mov\", \"video/quicktime\"),\n      MIME_ENTRY(\"mp3\", \"audio/mpeg\"),\n      MIME_ENTRY(\"mp4\", \"video/mp4\"),\n      MIME_ENTRY(\"mpeg\", \"video/mpeg\"),\n      MIME_ENTRY(\"pdf\", \"application/pdf\"),\n      MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"tgz\", \"application/tar-gz\"),\n      MIME_ENTRY(\"wav\", \"audio/wav\"),\n      MIME_ENTRY(\"webp\", \"image/webp\"),\n      MIME_ENTRY(\"zip\", \"application/zip\"),\n      MIME_ENTRY(\"3gp\", \"video/3gpp\"),\n      {{0, 0}, {0, 0}},\n  };\n  size_t i = 0;\n  struct mg_str k, v, s = mg_str(extra);\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; tab[i].extension.ptr != NULL; i++) {\n    if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  LOG(LL_INFO, (\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path, struct mg_http_serve_opts *opts) {\n  char etag[64];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = fs->open(path, MG_FS_READ);\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n\n  if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {\n    LOG(LL_DEBUG, (\"404 [%s] %p\", path, (void *) fd));\n    mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");\n    fs->close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    fs->close(fd);\n    mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n  } else {\n    int n, status = 200;\n    char range[100] = \"\";\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n    struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT\n                 \"/\" MG_INT64_FMT \"\\r\\n\",\n                 r1, r1 + cl - 1, (int64_t) size);\n        fs->seek(fd->fd, (size_t) r1);\n      }\n    }\n\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      fs->close(fd);\n    } else {\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[64], mod[64];\n  int flags, n = 0;\n\n  // LOG(LL_DEBUG, (\"[%s] [%s]\", d->dir, name));\n  if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {\n    LOG(LL_ERROR, (\"%s truncated\", name));\n  } else if ((flags = fs->stat(path, &size, &t)) == 0) {\n    LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    struct tm tm;\n    if (flags & MG_FS_DIR) {\n      snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else if (size < 1024) {\n      snprintf(sz, sizeof(sz), \"%d\", (int) size);\n    } else if (size < 0x100000) {\n      snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);\n    } else if (size < 0x40000000) {\n      snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);\n    } else {\n      snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);\n    }\n    strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&t, &tm));\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=\" MG_INT64_FMT \">%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_http_serve_opts *opts, char *dir) {\n  static const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  static const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n\n  fs->list(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",\n                        (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 10, tmp, n);  // Set content length\n}\n\nstatic void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n// Resolve requested file into `path` and return its fs->stat() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags = 0, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {\n    mg_http_reply(c, 400, \"\", \"Invalid web root [%.*s]\\n\", (int) dir.len,\n                  dir.ptr);\n  } else {\n    if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n    mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                  path_size - n, 0);\n    path[path_size - 1] = '\\0';  // Double-check\n    remove_double_dots(path);\n    n = strlen(path);\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu %.*s -> %s\", c->id, (int) hm->uri.len, hm->uri.ptr, path));\n    while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n    flags = fs->stat(path, NULL, NULL);                 // Does it exist?\n    if (flags == 0) {\n      mg_http_reply(c, 404, \"\", \"Not found\\n\");  // Does not exist, doh\n    } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n               hm->uri.ptr[hm->uri.len - 1] != '/') {\n      mg_printf(c,\n                \"HTTP/1.1 301 Moved\\r\\n\"\n                \"Location: %.*s/\\r\\n\"\n                \"Content-Length: 0\\r\\n\"\n                \"\\r\\n\",\n                (int) hm->uri.len, hm->uri.ptr);\n      flags = 0;\n    } else if (flags & MG_FS_DIR) {\n      if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0) ||\n           (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0))) {\n        flags = tmp;\n      } else {\n        path[n] = '\\0';  // Remove appended index file name\n      }\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX] = \"\";\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags == 0) return;\n  LOG(LL_VERBOSE_DEBUG,\n      (\"%.*s %s %d\", (int) hm->uri.len, hm->uri.ptr, path, flags));\n  if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (sp != NULL && mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_globmatch(glob, strlen(glob), hm->uri.ptr, hm->uri.len);\n}\n\nstatic size_t get_chunk_length(const char *buf, size_t len, size_t *ll) {\n  size_t i = 0, n;\n  while (i < len && buf[i] != '\\r' && i != '\\n') i++;\n  n = mg_unhexn((char *) buf, i);\n  while (i < len && (buf[i] == '\\r' || i == '\\n')) i++;\n  // LOG(LL_INFO, (\"len %zu i %zu n %zu \", len, i, n));\n  if (ll != NULL) *ll = i + 1;\n  if (i < len && i + n + 2 < len) return i + n + 3;\n  return 0;\n}\n\n// Walk through all chunks in the chunked body. For each chunk, fire\n// an MG_EV_HTTP_CHUNK event.\nstatic void walkchunks(struct mg_connection *c, struct mg_http_message *hm,\n                       size_t reqlen) {\n  size_t off = 0, bl, ll;\n  while (off + reqlen < c->recv.len) {\n    char *buf = (char *) &c->recv.buf[reqlen];\n    size_t memo = c->recv.len;\n    size_t cl = get_chunk_length(&buf[off], memo - reqlen - off, &ll);\n    // LOG(LL_INFO, (\"len %zu off %zu cl %zu ll %zu\", len, off, cl, ll));\n    if (cl == 0) break;\n    hm->chunk = mg_str_n(&buf[off + ll], cl < ll + 2 ? 0 : cl - ll - 2);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    // Increase offset only if user has not deleted this chunk\n    if (memo == c->recv.len) off += cl;\n    if (cl <= 5) {\n      // Zero chunk - last one. Prepare body - cut off chunk lengths\n      off = bl = 0;\n      while (off + reqlen < c->recv.len) {\n        char *buf2 = (char *) &c->recv.buf[reqlen];\n        size_t memo2 = c->recv.len;\n        size_t cl2 = get_chunk_length(&buf2[off], memo2 - reqlen - off, &ll);\n        size_t n = cl2 < ll + 2 ? 0 : cl2 - ll - 2;\n        memmove(buf2 + bl, buf2 + off + ll, n);\n        bl += n;\n        off += cl2;\n        if (cl2 <= 5) break;\n      }\n      // LOG(LL_INFO, (\"BL->%d del %d off %d\", (int) bl, (int) del, (int) off));\n      c->recv.len -= off - bl;\n      // Set message length to indicate we've received\n      // everything, to fire MG_EV_HTTP_MSG\n      hm->message.len = bl + reqlen;\n      hm->body.len = bl;\n      break;\n    }\n  }\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  struct mg_str needle = mg_str_n(\"chunked\", 7);\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_strstr(*te, needle) != NULL;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  struct mg_str ch = hm->chunk;\n  if (mg_is_chunked(hm)) {\n    ch.len += 4;  // \\r\\n before and after the chunk\n    ch.ptr -= 2;\n    while (ch.ptr > hm->body.ptr && *ch.ptr != '\\n') ch.ptr--, ch.len++;\n  }\n  {\n    const char *end = &ch.ptr[ch.len];\n    size_t n = (size_t) (end - (char *) c->recv.buf);\n    if (c->recv.len > n) {\n      memmove((char *) ch.ptr, end, (size_t) (c->recv.len - n));\n    }\n    // LOG(LL_INFO, (\"DELETING CHUNK: %zu %zu %zu\\n%.*s\", c->recv.len, n,\n    // ch.len, (int) ch.len, ch.ptr));\n  }\n  c->recv.len -= ch.len;\n}\n\n#if MG_ENABLE_FILE\nint mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}\n#endif\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      int n = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      bool is_chunked = n > 0 && mg_is_chunked(&hm);\n      if (ev == MG_EV_CLOSE) {\n        hm.message.len = c->recv.len;\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      } else if (is_chunked && n > 0) {\n        walkchunks(c, &hm, (size_t) n);\n      }\n      // LOG(LL_INFO,\n      //(\"---->%d %d\\n%.*s\", n, is_chunked, (int) c->recv.len, c->recv.buf));\n      if (n < 0 && ev == MG_EV_READ) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      } else if (n > 0 && (size_t) c->recv.len >= hm.message.len) {\n        mg_call(c, MG_EV_HTTP_MSG, &hm);\n        mg_iobuf_del(&c->recv, 0, hm.message.len);\n      } else {\n        if (n > 0 && !is_chunked) {\n          hm.chunk =\n              mg_str_n((char *) &c->recv.buf[n], c->recv.len - (size_t) n);\n          mg_call(c, MG_EV_HTTP_CHUNK, &hm);\n        }\n        break;\n      }\n    }\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/iobuf.c\"\n#endif\n\n\n\n#include <string.h>\n\n// Not using memset for zeroing memory, cause it can be dropped by compiler\n// See https://github.com/cesanta/mongoose/pull/1265\nstatic void zeromem(volatile unsigned char *buf, size_t len) {\n  if (buf != NULL) {\n    while (len--) *buf++ = 0;\n  }\n}\n\nint mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {\n  int ok = 1;\n  if (new_size == 0) {\n    zeromem(io->buf, io->size);\n    free(io->buf);\n    io->buf = NULL;\n    io->len = io->size = 0;\n  } else if (new_size != io->size) {\n    // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the\n    // porting to some obscure platforms like FreeRTOS\n    void *p = calloc(1, new_size);\n    if (p != NULL) {\n      size_t len = new_size < io->len ? new_size : io->len;\n      if (len > 0) memcpy(p, io->buf, len);\n      zeromem(io->buf, io->size);\n      free(io->buf);\n      io->buf = (unsigned char *) p;\n      io->size = new_size;\n    } else {\n      ok = 0;\n      LOG(LL_ERROR,\n          (\"%lu->%lu\", (unsigned long) io->size, (unsigned long) new_size));\n    }\n  }\n  return ok;\n}\n\nint mg_iobuf_init(struct mg_iobuf *io, size_t size) {\n  return mg_iobuf_resize(io, size);\n}\n\nsize_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,\n                    size_t len, size_t chunk_size) {\n  size_t new_size = io->len + len;\n  if (new_size > io->size) {\n    new_size += chunk_size;             // Make sure that io->size\n    new_size -= new_size % chunk_size;  // is aligned by chunk_size boundary\n    mg_iobuf_resize(io, new_size);      // Attempt to realloc\n    if (new_size != io->size) len = 0;  // Realloc failure, append nothing\n  }\n  if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);\n  if (buf != NULL) memmove(io->buf + ofs, buf, len);\n  if (ofs > io->len) io->len += ofs - io->len;\n  io->len += len;\n  return len;\n}\n\nsize_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {\n  if (ofs > io->len) ofs = io->len;\n  if (ofs + len > io->len) len = io->len - ofs;\n  memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);\n  zeromem(io->buf + io->len - len, len);\n  io->len -= len;\n  return len;\n}\n\nvoid mg_iobuf_free(struct mg_iobuf *io) {\n  mg_iobuf_resize(io, 0);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/log.c\"\n#endif\n\n\n\n#if MG_ENABLE_LOG\nstatic void mg_log_stdout(const void *buf, size_t len, void *userdata) {\n  (void) userdata;\n#if MG_ENABLE_FILE\n  fwrite(buf, 1, len, stdout);\n#endif\n}\n\nstatic const char *s_spec = \"2\";\nstatic void (*s_fn)(const void *, size_t, void *) = mg_log_stdout;\nstatic void *s_fn_param = NULL;\n\nvoid mg_log_set(const char *spec) {\n  LOG(LL_DEBUG, (\"Setting log level to %s\", spec));\n  s_spec = spec;\n}\n\nbool mg_log_prefix(int level, const char *file, int line, const char *fname) {\n  // static unsigned long seq;\n  int max = LL_INFO;\n  struct mg_str k, v, s = mg_str(s_spec);\n  const char *p = strrchr(file, '/');\n\n  if (s_fn == NULL) return false;\n\n  if (p == NULL) p = strrchr(file, '\\\\');\n  p = p == NULL ? file : p + 1;\n\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) max = atoi(k.ptr);\n    if (v.len > 0 && strncmp(p, k.ptr, k.len) == 0) max = atoi(v.ptr);\n  }\n\n  if (level <= max) {\n    char timebuf[21], buf[50] = \"\";\n    time_t t = time(NULL);\n    struct tm tmp, *tm = gmtime_r(&t, &tmp);\n    int n;\n    (void) tmp;\n    strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);\n    n = snprintf(buf, sizeof(buf), \"%s %d %s:%d:%s\", timebuf, level, p, line,\n                 fname);\n    if (n < 0 || n > (int) sizeof(buf) - 2) n = sizeof(buf) - 2;\n    while (n < (int) sizeof(buf) - 1) buf[n++] = ' ';\n    s_fn(buf, sizeof(buf) - 1, s_fn_param);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid mg_log(const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  int len = 0;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  s_fn(buf, len > 0 ? (size_t) len : 0, s_fn_param);\n  s_fn(\"\\n\", 1, s_fn_param);\n  if (buf != mem) free(buf);\n}\n\nvoid mg_log_set_callback(void (*fn)(const void *, size_t, void *), void *fnd) {\n  s_fn = fn;\n  s_fn_param = fnd;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/md5.c\"\n#endif\n#include <string.h>\n\n\n#if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5\n#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)\n#define BYTE_ORDER __BYTE_ORDER\n#ifndef LITTLE_ENDIAN\n#define LITTLE_ENDIAN __LITTLE_ENDIAN\n#endif /* LITTLE_ENDIAN */\n#ifndef BIG_ENDIAN\n#define BIG_ENDIAN __LITTLE_ENDIAN\n#endif /* BIG_ENDIAN */\n#endif /* BYTE_ORDER */\n\nstatic void mg_byte_reverse(unsigned char *buf, unsigned longs) {\n/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */\n#if BYTE_ORDER == BIG_ENDIAN\n  do {\n    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                 ((unsigned) buf[1] << 8 | buf[0]);\n    *(uint32_t *) buf = t;\n    buf += 4;\n  } while (--longs);\n#else\n  (void) buf;\n  (void) longs;\n#endif\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid mg_md5_init(mg_md5_ctx *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {\n  uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  mg_byte_reverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n  mg_byte_reverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/mqtt.c\"\n#endif\n\n\n\n\n\n\n\n\n#define MQTT_CLEAN_SESSION 0x02\n#define MQTT_HAS_WILL 0x04\n#define MQTT_WILL_RETAIN 0x20\n#define MQTT_HAS_PASSWORD 0x40\n#define MQTT_HAS_USER_NAME 0x80\n\nenum { MQTT_OK, MQTT_INCOMPLETE, MQTT_MALFORMED };\n\nvoid mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,\n                         uint32_t len) {\n  uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];\n  buf[0] = (uint8_t) ((cmd << 4) | flags);\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0 && vlen < &buf[sizeof(buf)]);\n  mg_send(c, buf, (size_t) (vlen - buf));\n}\n\nstatic void mg_send_u16(struct mg_connection *c, uint16_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nvoid mg_mqtt_login(struct mg_connection *c, struct mg_mqtt_opts *opts) {\n  char rnd[9], client_id[16];\n  struct mg_str cid = opts->client_id;\n  uint32_t total_len = 7 + 1 + 2 + 2;\n  uint8_t connflag = (uint8_t) ((opts->will_qos & 3) << 3);\n\n  if (cid.len == 0) {\n    mg_random(rnd, sizeof(rnd));\n    mg_base64_encode((unsigned char *) rnd, sizeof(rnd), client_id);\n    client_id[sizeof(client_id) - 1] = '\\0';\n    cid = mg_str(client_id);\n  }\n\n  if (opts->user.len > 0) {\n    total_len += 2 + (uint32_t) opts->user.len;\n    connflag |= MQTT_HAS_USER_NAME;\n  }\n  if (opts->pass.len > 0) {\n    total_len += 2 + (uint32_t) opts->pass.len;\n    connflag |= MQTT_HAS_PASSWORD;\n  }\n  if (opts->will_topic.len > 0 && opts->will_message.len > 0) {\n    total_len +=\n        4 + (uint32_t) opts->will_topic.len + (uint32_t) opts->will_message.len;\n    connflag |= MQTT_HAS_WILL;\n  }\n  if (opts->clean || cid.len == 0) connflag |= MQTT_CLEAN_SESSION;\n  if (opts->will_retain) connflag |= MQTT_WILL_RETAIN;\n  total_len += (uint32_t) cid.len;\n\n  mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, total_len);\n  mg_send(c, \"\\00\\04MQTT\\04\", 7);\n  mg_send(c, &connflag, sizeof(connflag));\n  // keepalive == 0 means \"do not disconnect us!\"\n  mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));\n  mg_send_u16(c, mg_htons((uint16_t) cid.len));\n  mg_send(c, cid.ptr, cid.len);\n  if (connflag & MQTT_HAS_WILL) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->will_topic.len));\n    mg_send(c, opts->will_topic.ptr, opts->will_topic.len);\n    mg_send_u16(c, mg_htons((uint16_t) opts->will_message.len));\n    mg_send(c, opts->will_message.ptr, opts->will_message.len);\n  }\n  if (opts->user.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->user.len));\n    mg_send(c, opts->user.ptr, opts->user.len);\n  }\n  if (opts->pass.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));\n    mg_send(c, opts->pass.ptr, opts->pass.len);\n  }\n}\n\nvoid mg_mqtt_pub(struct mg_connection *c, struct mg_str *topic,\n                 struct mg_str *data, int qos, bool retain) {\n  uint8_t flags = (uint8_t) (((qos & 3) << 1) | (retain ? 1 : 0));\n  uint32_t total_len = 2 + (uint32_t) topic->len + (uint32_t) data->len;\n  LOG(LL_DEBUG, (\"%lu [%.*s] -> [%.*s]\", c->id, (int) topic->len,\n                 (char *) topic->ptr, (int) data->len, (char *) data->ptr));\n  if (qos > 0) total_len += 2;\n  mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, total_len);\n  mg_send_u16(c, mg_htons((uint16_t) topic->len));\n  mg_send(c, topic->ptr, topic->len);\n  if (qos > 0) {\n    static uint16_t s_id;\n    if (++s_id == 0) s_id++;\n    mg_send_u16(c, mg_htons(s_id));\n  }\n  mg_send(c, data->ptr, data->len);\n}\n\nvoid mg_mqtt_sub(struct mg_connection *c, struct mg_str *topic, int qos) {\n  static uint16_t s_id;\n  uint8_t qos_ = qos & 3;\n  uint32_t total_len = 2 + (uint32_t) topic->len + 2 + 1;\n  mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, total_len);\n  if (++s_id == 0) ++s_id;\n  mg_send_u16(c, mg_htons(s_id));\n  mg_send_u16(c, mg_htons((uint16_t) topic->len));\n  mg_send(c, topic->ptr, topic->len);\n  mg_send(c, &qos_, sizeof(qos_));\n}\n\nint mg_mqtt_parse(const uint8_t *buf, size_t len, struct mg_mqtt_message *m) {\n  uint8_t lc = 0, *p, *end;\n  uint32_t n = 0, len_len = 0;\n\n  memset(m, 0, sizeof(*m));\n  m->dgram.ptr = (char *) buf;\n  if (len < 2) return MQTT_INCOMPLETE;\n  m->cmd = (uint8_t) (buf[0] >> 4);\n  m->qos = (buf[0] >> 1) & 3;\n\n  n = len_len = 0;\n  p = (uint8_t *) buf + 1;\n  while ((size_t) (p - buf) < len) {\n    lc = *((uint8_t *) p++);\n    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len >= 4) return MQTT_MALFORMED;\n  }\n  end = p + n;\n  if (lc & 0x80 || end > buf + len) return MQTT_INCOMPLETE;\n  m->dgram.len = (size_t) (end - buf);\n\n  switch (m->cmd) {\n    case MQTT_CMD_CONNACK:\n      if (end - p < 2) return MQTT_MALFORMED;\n      m->ack = p[1];\n      break;\n    case MQTT_CMD_PUBACK:\n    case MQTT_CMD_PUBREC:\n    case MQTT_CMD_PUBREL:\n    case MQTT_CMD_PUBCOMP:\n    case MQTT_CMD_SUBACK:\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      break;\n    case MQTT_CMD_SUBSCRIBE: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      p += 2;\n      break;\n    }\n    case MQTT_CMD_PUBLISH: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      m->topic.ptr = (char *) p + 2;\n      p += 2 + m->topic.len;\n      if (p > end) return MQTT_MALFORMED;\n      if (m->qos > 0) {\n        if (p + 2 > end) return MQTT_MALFORMED;\n        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n        p += 2;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      m->data.ptr = (char *) p;\n      m->data.len = (size_t) (end - p);\n      break;\n    }\n    default:\n      break;\n  }\n  return MQTT_OK;\n}\n\nstatic size_t mg_mqtt_next_topic(struct mg_mqtt_message *msg,\n                                 struct mg_str *topic, uint8_t *qos,\n                                 size_t pos) {\n  unsigned char *buf = (unsigned char *) msg->dgram.ptr + pos;\n  size_t new_pos;\n  if (pos >= msg->dgram.len) return 0;\n\n  topic->len = (size_t) (((unsigned) buf[0]) << 8 | buf[1]);\n  topic->ptr = (char *) buf + 2;\n  new_pos = pos + 2 + topic->len + (qos == NULL ? 0 : 1);\n  if ((size_t) new_pos > msg->dgram.len) return 0;\n  if (qos != NULL) *qos = buf[2 + topic->len];\n  return new_pos;\n}\n\nsize_t mg_mqtt_next_sub(struct mg_mqtt_message *msg, struct mg_str *topic,\n                        uint8_t *qos, size_t pos) {\n  uint8_t tmp;\n  return mg_mqtt_next_topic(msg, topic, qos == NULL ? &tmp : qos, pos);\n}\n\nsize_t mg_mqtt_next_unsub(struct mg_mqtt_message *msg, struct mg_str *topic,\n                          size_t pos) {\n  return mg_mqtt_next_topic(msg, topic, NULL, pos);\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,\n                    void *fn_data) {\n  if (ev == MG_EV_READ) {\n    for (;;) {\n      struct mg_mqtt_message mm;\n      int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, &mm);\n      if (rc == MQTT_MALFORMED) {\n        LOG(LL_ERROR, (\"%lu MQTT malformed message\", c->id));\n        c->is_closing = 1;\n        break;\n      } else if (rc == MQTT_OK) {\n        LOG(LL_VERBOSE_DEBUG,\n            (\"%p MQTT CMD %d len %d [%.*s]\", c->fd, mm.cmd, (int) mm.dgram.len,\n             (int) mm.data.len, mm.data.ptr));\n        switch (mm.cmd) {\n          case MQTT_CMD_CONNACK:\n            mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);\n            if (mm.ack == 0) {\n              LOG(LL_INFO, (\"%lu Connected\", c->id));\n            } else {\n              LOG(LL_ERROR, (\"%lu MQTT auth failed, code %d\", c->id, mm.ack));\n              c->is_closing = 1;\n            }\n            break;\n          case MQTT_CMD_PUBLISH: {\n            LOG(LL_DEBUG, (\"%lu [%.*s] -> [%.*s]\", c->id, (int) mm.topic.len,\n                           mm.topic.ptr, (int) mm.data.len, mm.data.ptr));\n            mg_call(c, MG_EV_MQTT_MSG, &mm);\n            break;\n          }\n        }\n        mg_call(c, MG_EV_MQTT_CMD, &mm);\n        mg_iobuf_del(&c->recv, 0, mm.dgram.len);\n      } else {\n        break;\n      }\n    }\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_DISCONNECT, 0, 0);\n}\n\nstruct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,\n                                      struct mg_mqtt_opts *opts,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    struct mg_mqtt_opts empty;\n    memset(&empty, 0, sizeof(empty));\n    mg_mqtt_login(c, opts == NULL ? &empty : opts);\n    c->pfn = mqtt_cb;\n  }\n  return c;\n}\n\nstruct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/net.c\"\n#endif\n\n\n\n\nint mg_vprintf(struct mg_connection *c, const char *fmt, va_list ap) {\n  char mem[256], *buf = mem;\n  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  len = mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  if (buf != mem) free(buf);\n  return len;\n}\n\nint mg_printf(struct mg_connection *c, const char *fmt, ...) {\n  int len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(c, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\nchar *mg_straddr(struct mg_addr *a, char *buf, size_t len) {\n  char tmp[30];\n  const char *fmt = a->is_ip6 ? \"[%s]:%d\" : \"%s:%d\";\n  mg_ntoa(a, tmp, sizeof(tmp));\n  snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));\n  return buf;\n}\n\nchar *mg_ntoa(const struct mg_addr *addr, char *buf, size_t len) {\n  if (addr->is_ip6) {\n    uint16_t *p = (uint16_t *) addr->ip6;\n    snprintf(buf, len, \"%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx\", mg_htons(p[0]),\n             mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),\n             mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));\n  } else {\n    uint8_t p[4];\n    memcpy(p, &addr->ip, sizeof(p));\n    snprintf(buf, len, \"%d.%d.%d.%d\", (int) p[0], (int) p[1], (int) p[2],\n             (int) p[3]);\n  }\n  return buf;\n}\n\nstatic bool mg_atonl(struct mg_str str, struct mg_addr *addr) {\n  if (mg_vcasecmp(&str, \"localhost\") != 0) return false;\n  addr->ip = mg_htonl(0x7f000001);\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_atone(struct mg_str str, struct mg_addr *addr) {\n  if (str.len > 0) return false;\n  addr->ip = 0;\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_aton4(struct mg_str str, struct mg_addr *addr) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  size_t i, num_dots = 0;\n  for (i = 0; i < str.len; i++) {\n    if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n      int octet = data[num_dots] * 10 + (str.ptr[i] - '0');\n      if (octet > 255) return false;\n      data[num_dots] = (uint8_t) octet;\n    } else if (str.ptr[i] == '.') {\n      if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;\n      num_dots++;\n    } else {\n      return false;\n    }\n  }\n  if (num_dots != 3 || str.ptr[i - 1] == '.') return false;\n  memcpy(&addr->ip, data, sizeof(data));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {\n  int i;\n  if (str.len < 14) return false;\n  if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;\n  for (i = 2; i < 6; i++) {\n    if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;\n  }\n  if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;\n  memset(addr->ip6, 0, sizeof(addr->ip6));\n  addr->ip6[10] = addr->ip6[11] = 255;\n  memcpy(&addr->ip6[12], &addr->ip, 4);\n  addr->is_ip6 = true;\n  return true;\n}\n\nstatic bool mg_aton6(struct mg_str str, struct mg_addr *addr) {\n  size_t i, j = 0, n = 0, dc = 42;\n  if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;\n  if (mg_v4mapped(str, addr)) return true;\n  for (i = 0; i < str.len; i++) {\n    if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||\n        (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||\n        (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {\n      unsigned long val;\n      if (i > j + 3) return false;\n      // LOG(LL_DEBUG, (\"%zu %zu [%.*s]\", i, j, (int) (i - j + 1),\n      // &str.ptr[j]));\n      val = mg_unhexn(&str.ptr[j], i - j + 1);\n      addr->ip6[n] = (uint8_t) ((val >> 8) & 255);\n      addr->ip6[n + 1] = (uint8_t) (val & 255);\n    } else if (str.ptr[i] == ':') {\n      j = i + 1;\n      if (i > 0 && str.ptr[i - 1] == ':') {\n        dc = n;  // Double colon\n        if (i > 1 && str.ptr[i - 2] == ':') return false;\n      } else if (i > 0) {\n        n += 2;\n      }\n      if (n > 14) return false;\n      addr->ip6[n] = addr->ip6[n + 1] = 0;  // For trailing ::\n    } else {\n      return false;\n    }\n  }\n  if (n < 14 && dc == 42) return false;\n  if (n < 14) {\n    memmove(&addr->ip6[dc + (14 - n)], &addr->ip6[dc], n - dc + 2);\n    memset(&addr->ip6[dc], 0, 14 - n);\n  }\n  addr->is_ip6 = true;\n  return true;\n}\n\nbool mg_aton(struct mg_str str, struct mg_addr *addr) {\n  // LOG(LL_INFO, (\"[%.*s]\", (int) str.len, str.ptr));\n  return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||\n         mg_aton6(str, addr);\n}\n\nvoid mg_mgr_free(struct mg_mgr *mgr) {\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;\n  mg_mgr_poll(mgr, 0);\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP\n  FreeRTOS_DeleteSocketSet(mgr->ss);\n#endif\n  LOG(LL_INFO, (\"All connections closed\"));\n}\n\nvoid mg_mgr_init(struct mg_mgr *mgr) {\n  memset(mgr, 0, sizeof(*mgr));\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n  // clang-format off\n  { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }\n  // clang-format on\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP\n  mgr->ss = FreeRTOS_CreateSocketSet();\n#elif defined(__unix) || defined(__unix__) || defined(__APPLE__)\n  // Ignore SIGPIPE signal, so if client cancels the request, it\n  // won't kill the whole process.\n  signal(SIGPIPE, SIG_IGN);\n#endif\n  mgr->dnstimeout = 3000;\n  mgr->dns4.url = \"udp://8.8.8.8:53\";\n  mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n#include <string.h>\n\n/*\n * clang with std=-c99 uses __LITTLE_ENDIAN, by default\n * while for ex, RTOS gcc - LITTLE_ENDIAN, by default\n * it depends on __USE_BSD, but let's have everything\n */\n#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)\n#define BYTE_ORDER __BYTE_ORDER\n#ifndef LITTLE_ENDIAN\n#define LITTLE_ENDIAN __LITTLE_ENDIAN\n#endif /* LITTLE_ENDIAN */\n#ifndef BIG_ENDIAN\n#define BIG_ENDIAN __LITTLE_ENDIAN\n#endif /* BIG_ENDIAN */\n#endif /* BYTE_ORDER */\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n/* Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN */\n#if BYTE_ORDER == LITTLE_ENDIAN\n  block->l[i] =\n      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);\n#endif\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nstatic void mg_sha1_transform(uint32_t state[5], const unsigned char buffer[64]) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid mg_sha1_init(mg_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,\n                    size_t len) {\n  size_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;\n  context->count[1] += (uint32_t)(len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    mg_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      mg_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  mg_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    mg_sha1_update(context, &c, 1);\n  }\n  mg_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\nvoid mg_hmac_sha1(const unsigned char *key, size_t keylen,\n                  const unsigned char *data, size_t datalen,\n                  unsigned char out[20]) {\n  mg_sha1_ctx ctx;\n  unsigned char buf1[64], buf2[64], tmp_key[20], i;\n\n  if (keylen > sizeof(buf1)) {\n    mg_sha1_init(&ctx);\n    mg_sha1_update(&ctx, key, keylen);\n    mg_sha1_final(tmp_key, &ctx);\n    key = tmp_key;\n    keylen = sizeof(tmp_key);\n  }\n\n  memset(buf1, 0, sizeof(buf1));\n  memset(buf2, 0, sizeof(buf2));\n  memcpy(buf1, key, keylen);\n  memcpy(buf2, key, keylen);\n\n  for (i = 0; i < sizeof(buf1); i++) {\n    buf1[i] ^= 0x36;\n    buf2[i] ^= 0x5c;\n  }\n\n  mg_sha1_init(&ctx);\n  mg_sha1_update(&ctx, buf1, sizeof(buf1));\n  mg_sha1_update(&ctx, data, datalen);\n  mg_sha1_final(out, &ctx);\n\n  mg_sha1_init(&ctx);\n  mg_sha1_update(&ctx, buf2, sizeof(buf2));\n  mg_sha1_update(&ctx, out, 20);\n  mg_sha1_final(out, &ctx);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sntp.c\"\n#endif\n\n\n\n\n\n\n#define SNTP_INTERVAL_SEC 3600\n#define SNTP_TIME_OFFSET 2208988800UL\n\nstatic unsigned long s_sntmp_next;\n\nint64_t mg_sntp_parse(const unsigned char *buf, size_t len) {\n  int64_t res = -1;\n  int mode = len > 0 ? buf[0] & 7 : 0;\n  if (len < 48) {\n    LOG(LL_ERROR, (\"%s\", \"corrupt packet\"));\n  } else if ((buf[0] & 0x38) >> 3 != 4) {\n    LOG(LL_ERROR, (\"%s\", \"wrong version\"));\n  } else if (mode != 4 && mode != 5) {\n    LOG(LL_ERROR, (\"%s\", \"not a server reply\"));\n  } else if (buf[1] == 0) {\n    LOG(LL_ERROR, (\"%s\", \"server sent a kiss of death\"));\n  } else {\n    uint32_t *data = (uint32_t *) &buf[40];\n    unsigned long seconds = mg_ntohl(data[0]) - SNTP_TIME_OFFSET;\n    unsigned long useconds = mg_ntohl(data[1]);\n    // LOG(LL_DEBUG, (\"%lu %lu %lu\", time(0), seconds, useconds));\n    res = ((int64_t) seconds) * 1000 + (int64_t) ((useconds / 1000) % 1000);\n    s_sntmp_next = seconds + SNTP_INTERVAL_SEC;\n  }\n  return res;\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ) {\n    int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);\n    if (milliseconds > 0) {\n      mg_call(c, MG_EV_SNTP_TIME, &milliseconds);\n      LOG(LL_DEBUG, (\"%u.%u, next at %lu\", (unsigned) (milliseconds / 1000),\n                     (unsigned) (milliseconds % 1000), s_sntmp_next));\n    }\n    c->recv.len = 0;  // Clear receive buffer\n  } else if (ev == MG_EV_CONNECT) {\n    mg_sntp_send(c, (unsigned long) time(NULL));\n  } else if (ev == MG_EV_CLOSE) {\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nvoid mg_sntp_send(struct mg_connection *c, unsigned long utc) {\n  if (c->is_resolving) {\n    LOG(LL_ERROR, (\"%lu wait until resolved\", c->id));\n  } else if (utc > s_sntmp_next) {\n    uint8_t buf[48] = {0};\n    s_sntmp_next = utc + SNTP_INTERVAL_SEC;\n    buf[0] = (0 << 6) | (4 << 3) | 3;\n    mg_send(c, buf, sizeof(buf));\n    LOG(LL_DEBUG, (\"%lu ct %lu, next at %lu\", c->id, utc, s_sntmp_next));\n  }\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fnd) {\n  struct mg_connection *c = NULL;\n  if (url == NULL) url = \"udp://time.google.com:123\";\n  if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sock.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n#if MG_ENABLE_SOCKET\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n#define MG_SOCK_ERRNO WSAGetLastError()\n#ifndef SO_EXCLUSIVEADDRUSE\n#define SO_EXCLUSIVEADDRUSE ((int) (~SO_REUSEADDR))\n#endif\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP\n#define MG_SOCK_ERRNO errno\ntypedef Socket_t SOCKET;\n#define INVALID_SOCKET FREERTOS_INVALID_SOCKET\n#else\n#define MG_SOCK_ERRNO errno\n#ifndef closesocket\n#define closesocket(x) close(x)\n#endif\n#define INVALID_SOCKET (-1)\ntypedef int SOCKET;\n#endif\n\n#define FD(c_) ((SOCKET) (size_t) (c_)->fd)\n#define S2PTR(s_) ((void *) (size_t) (s_))\n\n#ifndef MSG_NONBLOCKING\n#define MSG_NONBLOCKING 0\n#endif\n\n#ifndef AF_INET6\n#define AF_INET6 10\n#endif\n\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if MG_ENABLE_IPV6\n  struct sockaddr_in6 sin6;\n#endif\n};\n\nstatic socklen_t tousa(struct mg_addr *a, union usa *usa) {\n  socklen_t len = sizeof(usa->sin);\n  memset(usa, 0, sizeof(*usa));\n  usa->sin.sin_family = AF_INET;\n  usa->sin.sin_port = a->port;\n  *(uint32_t *) &usa->sin.sin_addr = a->ip;\n#if MG_ENABLE_IPV6\n  if (a->is_ip6) {\n    usa->sin.sin_family = AF_INET6;\n    usa->sin6.sin6_port = a->port;\n    memcpy(&usa->sin6.sin6_addr, a->ip6, sizeof(a->ip6));\n    len = sizeof(usa->sin6);\n  }\n#endif\n  return len;\n}\n\nstatic void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {\n  a->is_ip6 = is_ip6;\n  a->port = usa->sin.sin_port;\n  memcpy(&a->ip, &usa->sin.sin_addr, sizeof(a->ip));\n#if MG_ENABLE_IPV6\n  if (is_ip6) {\n    memcpy(a->ip6, &usa->sin6.sin6_addr, sizeof(a->ip6));\n    a->port = usa->sin6.sin6_port;\n  }\n#endif\n}\n\nstatic bool mg_sock_would_block(void) {\n  int err = MG_SOCK_ERRNO;\n  return err == EINPROGRESS || err == EWOULDBLOCK\n#ifndef WINCE\n         || err == EAGAIN || err == EINTR\n#endif\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n         || err == WSAEINTR || err == WSAEWOULDBLOCK\n#endif\n      ;\n}\n\nstatic struct mg_connection *alloc_conn(struct mg_mgr *mgr, bool is_client,\n                                        SOCKET fd) {\n  struct mg_connection *c = (struct mg_connection *) calloc(1, sizeof(*c));\n  if (c != NULL) {\n    c->is_client = is_client;\n    c->fd = S2PTR(fd);\n    c->mgr = mgr;\n    c->id = ++mgr->nextid;\n  }\n  return c;\n}\n\nstatic void iolog(struct mg_connection *c, char *buf, long n, bool r) {\n  LOG(n > 0 ? LL_VERBOSE_DEBUG : LL_DEBUG,\n      (\"%-3lu %d%d%d%d%d%d%d%d%d%d%d%d%d%d %d:%d %ld err %d\", c->id,\n       c->is_listening, c->is_client, c->is_accepted, c->is_resolving,\n       c->is_connecting, c->is_tls, c->is_tls_hs, c->is_udp, c->is_websocket,\n       c->is_hexdumping, c->is_draining, c->is_closing, c->is_readable,\n       c->is_writable, (int) c->send.len, (int) c->recv.len, n, MG_SOCK_ERRNO));\n  if (n == 0) {\n    // Do nothing\n  } else if (n < 0) {\n    c->is_closing = 1;  // Error, or normal termination\n  } else if (n > 0) {\n    if (c->is_hexdumping) {\n      union usa usa;\n      char t1[50] = \"\", t2[50] = \"\";\n      socklen_t slen = sizeof(usa.sin);\n      char *s = mg_hexdump(buf, (size_t) n);\n      struct mg_addr a;\n      memset(&usa, 0, sizeof(usa));\n      memset(&a, 0, sizeof(a));\n      getsockname(FD(c), &usa.sa, &slen);\n      tomgaddr(&usa, &a, c->peer.is_ip6);\n      LOG(LL_INFO, (\"\\n-- %lu %s %s %s %s %ld\\n%s\", c->id,\n                    mg_straddr(&a, t1, sizeof(t1)), r ? \"<-\" : \"->\",\n                    mg_straddr(&c->peer, t2, sizeof(t2)), c->label, n, s));\n      free(s);\n      (void) t1, (void) t2;  // Silence warnings for MG_ENABLE_LOG=0\n    }\n    if (r) {\n      struct mg_str evd = mg_str_n(buf, (size_t) n);\n      c->recv.len += (size_t) n;\n      mg_call(c, MG_EV_READ, &evd);\n    } else {\n      mg_iobuf_del(&c->send, 0, (size_t) n);\n      if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);\n      mg_call(c, MG_EV_WRITE, &n);\n    }\n  }\n}\n\nstatic long mg_sock_send(struct mg_connection *c, const void *buf, size_t len) {\n  long n;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->peer, &usa);\n    n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);\n  } else {\n    n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  return n == 0 ? -1 : n < 0 && mg_sock_would_block() ? 0 : n;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  if (c->is_udp) {\n    long n = mg_sock_send(c, buf, len);\n    iolog(c, (char *) buf, n, false);\n    return n > 0;\n  } else {\n    return mg_iobuf_add(&c->send, c->send.len, buf, len, MG_IO_SIZE);\n  }\n}\n\nstatic void mg_set_non_blocking_mode(SOCKET fd) {\n#if defined(_WIN32) && MG_ENABLE_WINSOCK\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP\n  const BaseType_t off = 0;\n  setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off));\n  setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off));\n#elif MG_ARCH == MG_ARCH_FREERTOS_LWIP\n  lwip_fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n#else\n  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode\n  fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec\n#endif\n}\n\nstatic SOCKET mg_open_listener(const char *url, struct mg_addr *addr) {\n  SOCKET fd = INVALID_SOCKET;\n  int s_err = 0;  // Memoized socket error, in case closesocket() overrides it\n  memset(addr, 0, sizeof(*addr));\n  addr->port = mg_htons(mg_url_port(url));\n  if (!mg_aton(mg_url_host(url), addr)) {\n    LOG(LL_ERROR, (\"invalid listening URL: %s\", url));\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(addr, &usa);\n    int on = 1, af = addr->is_ip6 ? AF_INET6 : AF_INET;\n    int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;\n    int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;\n    (void) on;\n\n    if ((fd = socket(af, type, proto)) != INVALID_SOCKET &&\n#if (!defined(_WIN32) || !defined(SO_EXCLUSIVEADDRUSE)) && \\\n    (!defined(LWIP_SOCKET) || (defined(LWIP_SOCKET) && SO_REUSE == 1))\n        // 1. SO_RESUSEADDR is not enabled on Windows because the semantics of\n        //    SO_REUSEADDR on UNIX and Windows is different. On Windows,\n        //    SO_REUSEADDR allows to bind a socket to a port without error even\n        //    if the port is already open by another program. This is not the\n        //    behavior SO_REUSEADDR was designed for, and leads to hard-to-track\n        //    failure scenarios. Therefore, SO_REUSEADDR was disabled on Windows\n        //    unless SO_EXCLUSIVEADDRUSE is supported and set on a socket.\n        // 2. In case of LWIP, SO_REUSEADDR should be explicitly enabled, by\n        // defining\n        //    SO_REUSE (in lwipopts.h), otherwise the code below will compile\n        //    but won't work! (setsockopt will return EINVAL)\n        !setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on)) &&\n#endif\n#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE) && !defined(WINCE)\n        // \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\"\n        //! setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (char *) &on, sizeof(on))\n        //! &&\n        !setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *) &on,\n                    sizeof(on)) &&\n#endif\n        bind(fd, &usa.sa, slen) == 0 &&\n        // NOTE(lsm): FreeRTOS uses backlog value as a connection limit\n        (type == SOCK_DGRAM || listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE) == 0)) {\n      // In case port was set to 0, get the real port number\n      if (getsockname(fd, &usa.sa, &slen) == 0) {\n        addr->port = usa.sin.sin_port;\n#if MG_ENABLE_IPV6\n        if (addr->is_ip6) addr->port = usa.sin6.sin6_port;\n#endif\n      }\n      mg_set_non_blocking_mode(fd);\n    } else if (fd != INVALID_SOCKET) {\n      s_err = MG_SOCK_ERRNO;\n      closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n  if (fd == INVALID_SOCKET) {\n    if (s_err == 0) s_err = MG_SOCK_ERRNO;\n    LOG(LL_ERROR, (\"Failed to listen on %s, errno %d\", url, s_err));\n  }\n\n  return fd;\n}\n\nstatic long mg_sock_recv(struct mg_connection *c, void *buf, size_t len) {\n  long n = 0;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->peer, &usa);\n    n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);\n    if (n > 0) tomgaddr(&usa, &c->peer, slen != sizeof(usa.sin));\n  } else {\n    n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  return n == 0 ? -1 : n < 0 && mg_sock_would_block() ? 0 : n;\n}\n\n// NOTE(lsm): do only one iteration of reads, cause some systems\n// (e.g. FreeRTOS stack) return 0 instead of -1/EWOULDBLOCK when no data\nstatic long read_conn(struct mg_connection *c) {\n  long n = -1;\n  if (c->recv.len >= MG_MAX_RECV_BUF_SIZE) {\n    mg_error(c, \"max_recv_buf_size reached\");\n  } else if (c->recv.size - c->recv.len < MG_IO_SIZE &&\n             !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {\n    mg_error(c, \"oom\");\n  } else {\n    char *buf = (char *) &c->recv.buf[c->recv.len];\n    size_t len = c->recv.size - c->recv.len;\n    n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_sock_recv(c, buf, len);\n    iolog(c, buf, n, true);\n  }\n  return n;\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  char *buf = (char *) c->send.buf;\n  size_t len = c->send.len;\n  long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_sock_send(c, buf, len);\n  iolog(c, buf, n, false);\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  mg_resolve_cancel(c);  // Close any pending DNS query\n  LIST_DELETE(struct mg_connection, &c->mgr->conns, c);\n  if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;\n  if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;\n  // Order of operations is important. `MG_EV_CLOSE` event must be fired\n  // before we deallocate received data, see #1331\n  mg_call(c, MG_EV_CLOSE, NULL);\n  LOG(LL_DEBUG, (\"%lu closed\", c->id));\n  if (FD(c) != INVALID_SOCKET) {\n    closesocket(FD(c));\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP\n    FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);\n#endif\n    c->fd = S2PTR(INVALID_SOCKET);\n  }\n  mg_tls_free(c);\n  mg_iobuf_free(&c->recv);\n  mg_iobuf_free(&c->send);\n  memset(c, 0, sizeof(*c));\n  free(c);\n}\n\nstatic void setsockopts(struct mg_connection *c) {\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS\n  (void) c;\n#else\n  int on = 1;\n#if !defined(SOL_TCP)\n#define SOL_TCP IPPROTO_TCP\n#endif\n  setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on));\n#if defined(TCP_QUICKACK)\n  setsockopt(FD(c), SOL_TCP, TCP_QUICKACK, (char *) &on, sizeof(on));\n#endif\n  setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on));\n#if (defined(ESP32) && ESP32) || (defined(ESP8266) && ESP8266) || \\\n    defined(__linux__)\n  int idle = 60;\n  setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle));\n#endif\n#if !defined(_WIN32) && !defined(__QNX__)\n  {\n    int cnt = 3, intvl = 20;\n    setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));\n    setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl));\n  }\n#endif\n#endif\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  // char buf[40];\n  int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n  int rc, af = c->peer.is_ip6 ? AF_INET6 : AF_INET;\n  // mg_straddr(&c->peer, buf, sizeof(buf));\n  c->fd = S2PTR(socket(af, type, 0));\n  if (FD(c) == INVALID_SOCKET) {\n    mg_error(c, \"socket(): %d\", MG_SOCK_ERRNO);\n  } else if (c->is_udp) {\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->peer, &usa);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    if ((rc = connect(FD(c), &usa.sa, slen)) == 0) {\n      mg_call(c, MG_EV_CONNECT, NULL);\n    } else if (mg_sock_would_block()) {\n      c->is_connecting = 1;\n    } else {\n      mg_error(c, \"connect: %d\", MG_SOCK_ERRNO);\n    }\n  }\n}\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,\n                                 mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if (url == NULL || url[0] == '\\0') {\n    LOG(LL_ERROR, (\"null url\"));\n  } else if ((c = alloc_conn(mgr, 1, INVALID_SOCKET)) == NULL) {\n    LOG(LL_ERROR, (\"OOM\"));\n  } else {\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_udp = (strncmp(url, \"udp:\", 4) == 0);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    LOG(LL_DEBUG, (\"%lu -> %s\", c->id, url));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_resolve(c, url);\n  }\n  return c;\n}\n\nstatic void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {\n  struct mg_connection *c = NULL;\n  union usa usa;\n  socklen_t sa_len = sizeof(usa);\n  SOCKET fd = accept(FD(lsn), &usa.sa, &sa_len);\n  if (fd == INVALID_SOCKET) {\n#if MG_ARCH == MG_ARCH_AZURERTOS\n    // AzureRTOS, in non-block socket mode can mark listening socket readable\n    // even it is not. See comment for 'select' func implementation in nx_bsd.c\n    // That's not an error, just should try later\n    if (MG_SOCK_ERRNO != EAGAIN)\n#endif\n      LOG(LL_ERROR, (\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERRNO));\n#if (!defined(_WIN32) && (MG_ARCH != MG_ARCH_FREERTOS_TCP))\n  } else if ((long) fd >= FD_SETSIZE) {\n    LOG(LL_ERROR, (\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));\n    closesocket(fd);\n#endif\n  } else if ((c = alloc_conn(mgr, 0, fd)) == NULL) {\n    LOG(LL_ERROR, (\"%lu OOM\", lsn->id));\n    closesocket(fd);\n  } else {\n    char buf[40];\n    tomgaddr(&usa, &c->peer, sa_len != sizeof(usa.sin));\n    mg_straddr(&c->peer, buf, sizeof(buf));\n    LOG(LL_DEBUG, (\"%lu accepted %s\", c->id, buf));\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_accepted = 1;\n    c->is_hexdumping = lsn->is_hexdumping;\n    c->pfn = lsn->pfn;\n    c->pfn_data = lsn->pfn_data;\n    c->fn = lsn->fn;\n    c->fn_data = lsn->fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_call(c, MG_EV_ACCEPT, NULL);\n  }\n}\n\nstatic bool mg_socketpair(SOCKET sp[2], union usa usa[2]) {\n  socklen_t n = sizeof(usa[0].sin);\n  bool result = false;\n\n  (void) memset(&usa[0], 0, sizeof(usa[0]));\n  usa[0].sin.sin_family = AF_INET;\n  *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001);  // 127.0.0.1\n  usa[1] = usa[0];\n\n  if ((sp[0] = socket(AF_INET, SOCK_DGRAM, 0)) != INVALID_SOCKET &&\n      (sp[1] = socket(AF_INET, SOCK_DGRAM, 0)) != INVALID_SOCKET &&\n      bind(sp[0], &usa[0].sa, n) == 0 && bind(sp[1], &usa[1].sa, n) == 0 &&\n      getsockname(sp[0], &usa[0].sa, &n) == 0 &&\n      getsockname(sp[1], &usa[1].sa, &n) == 0 &&\n      connect(sp[0], &usa[1].sa, n) == 0 &&\n      connect(sp[1], &usa[0].sa, n) == 0) {\n    mg_set_non_blocking_mode(sp[1]);  // Set close-on-exec\n    result = true;\n  } else {\n    if (sp[0] != INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != INVALID_SOCKET) closesocket(sp[1]);\n    sp[0] = sp[1] = INVALID_SOCKET;\n  }\n\n  return result;\n}\n\nvoid mg_mgr_wakeup(struct mg_connection *c) {\n  LOG(LL_INFO, (\"skt: %p\", c->pfn_data));\n  send((SOCKET) (size_t) c->pfn_data, \"\\x01\", 1, MSG_NONBLOCKING);\n}\n\nstatic void pf1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_READ) mg_iobuf_free(&c->recv);\n  (void) ev_data, (void) fn_data;\n}\n\nstruct mg_connection *mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn,\n                                void *fn_data) {\n  union usa usa[2];\n  SOCKET sp[2] = {INVALID_SOCKET, INVALID_SOCKET};\n  struct mg_connection *c = NULL;\n  if (!mg_socketpair(sp, usa)) {\n    LOG(LL_ERROR, (\"Cannot create socket pair\"));\n  } else if ((c = alloc_conn(mgr, false, sp[1])) == NULL) {\n    closesocket(sp[0]);\n    closesocket(sp[1]);\n    LOG(LL_ERROR, (\"OOM\"));\n  } else {\n    LOG(LL_INFO, (\"pipe %lu\", (unsigned long) sp[0]));\n    tomgaddr(&usa[0], &c->peer, false);\n    c->is_udp = 1;\n    c->pfn = pf1;\n    c->pfn_data = (void *) (size_t) sp[0];\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n  }\n  return c;\n}\n\nstruct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  bool is_udp = strncmp(url, \"udp:\", 4) == 0;\n  struct mg_addr addr;\n  SOCKET fd = mg_open_listener(url, &addr);\n  if (fd == INVALID_SOCKET) {\n    LOG(LL_ERROR, (\"Failed: %s, errno %d\", url, MG_SOCK_ERRNO));\n  } else if ((c = alloc_conn(mgr, 0, fd)) == NULL) {\n    LOG(LL_ERROR, (\"OOM %s\", url));\n    closesocket(fd);\n  } else {\n    memcpy(&c->peer, &addr, sizeof(struct mg_addr));\n    c->fd = S2PTR(fd);\n    c->is_listening = 1;\n    c->is_udp = is_udp;\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    LOG(LL_DEBUG,\n        (\"%lu accepting on %s (port %u)\", c->id, url, mg_ntohs(c->peer.port)));\n  }\n  return c;\n}\n\nstatic void mg_iotest(struct mg_mgr *mgr, int ms) {\n#if MG_ARCH == MG_ARCH_FREERTOS_TCP\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_closing || c->is_resolving || FD(c) == INVALID_SOCKET) continue;\n    FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);\n    if (c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0))\n      FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);\n  }\n  FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);\n    c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1 : 0;\n    c->is_writable = bits & eSELECT_WRITE ? 1 : 0;\n    FreeRTOS_FD_CLR(c->fd, mgr->ss,\n                    eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);\n  }\n#else\n  struct timeval tv = {ms / 1000, (ms % 1000) * 1000};\n  struct mg_connection *c;\n  fd_set rset, wset;\n  SOCKET maxfd = 0;\n  int rc;\n\n  FD_ZERO(&rset);\n  FD_ZERO(&wset);\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_closing || c->is_resolving || FD(c) == INVALID_SOCKET) continue;\n    FD_SET(FD(c), &rset);\n    if (FD(c) > maxfd) maxfd = FD(c);\n    if (c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0))\n      FD_SET(FD(c), &wset);\n  }\n\n  if ((rc = select((int) maxfd + 1, &rset, &wset, NULL, &tv)) < 0) {\n    LOG(LL_DEBUG, (\"select: %d %d\", rc, MG_SOCK_ERRNO));\n    FD_ZERO(&rset);\n    FD_ZERO(&wset);\n  }\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    // TLS might have stuff buffered, so dig everything\n    c->is_readable = FD(c) != INVALID_SOCKET && FD_ISSET(FD(c), &rset);\n    c->is_writable = FD(c) != INVALID_SOCKET && FD_ISSET(FD(c), &wset);\n  }\n#endif\n}\n\nstatic void connect_conn(struct mg_connection *c) {\n  int rc = 0;\n#if MG_ARCH != MG_ARCH_FREERTOS_TCP\n  socklen_t len = sizeof(rc);\n  if (getsockopt(FD(c), SOL_SOCKET, SO_ERROR, (char *) &rc, &len)) rc = 1;\n#endif\n  if (rc == EAGAIN || rc == EWOULDBLOCK) rc = 0;\n  c->is_connecting = 0;\n  if (rc) {\n    char buf[50];\n    mg_error(c, \"error connecting to %s\",\n             mg_straddr(&c->peer, buf, sizeof(buf)));\n  } else {\n    if (c->is_tls_hs) mg_tls_handshake(c);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  }\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  int64_t now;\n\n  mg_iotest(mgr, ms);\n  now = mg_millis();\n  mg_timer_poll(now);\n\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu %c%c %c%c%c%c%c\", c->id, c->is_readable ? 'r' : '-',\n         c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',\n         c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n         c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_resolving || c->is_closing) {\n      // Do nothing\n    } else if (c->is_listening && c->is_udp == 0) {\n      if (c->is_readable) accept_conn(mgr, c);\n    } else if (c->is_connecting) {\n      if (c->is_readable || c->is_writable) connect_conn(c);\n    } else if (c->is_tls_hs) {\n      if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);\n    } else {\n      if (c->is_readable) read_conn(c);\n      if (c->is_writable) write_conn(c);\n      while (c->is_tls && read_conn(c) > 0) (void) 0;  // Read buffered TLS data\n    }\n\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ssi.c\"\n#endif\n\n\n\n\n#ifndef MG_MAX_SSI_DEPTH\n#define MG_MAX_SSI_DEPTH 5\n#endif\n\n#if MG_ENABLE_SSI\nstatic char *mg_ssi(const char *path, const char *root, int depth) {\n  struct mg_iobuf b = {NULL, 0, 0};\n  FILE *fp = fopen(path, \"rb\");\n  if (fp != NULL) {\n    char buf[BUFSIZ], arg[sizeof(buf)];\n    int ch, intag = 0;\n    size_t len = 0, align = MG_IO_SIZE;\n    while ((ch = fgetc(fp)) != EOF) {\n      if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n        buf[len++] = (char) (ch & 0xff);\n        if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + BUFSIZ + 10],\n              *p = (char *) path + strlen(path), *data;\n          while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;\n          snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data), align);\n            free(data);\n          } else {\n            LOG(LL_ERROR, (\"%s: file=%s error or too deep\", path, arg));\n          }\n        } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + BUFSIZ + 10], *data;\n          snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data), align);\n            free(data);\n          } else {\n            LOG(LL_ERROR, (\"%s: virtual=%s error or too deep\", path, arg));\n          }\n        } else {\n          // Unknown SSI tag\n          LOG(LL_INFO, (\"Unknown SSI tag: %.*s\", (int) len, buf));\n          mg_iobuf_add(&b, b.len, buf, len, align);\n        }\n        intag = 0;\n        len = 0;\n      } else if (ch == '<') {\n        intag = 1;\n        if (len > 0) mg_iobuf_add(&b, b.len, buf, len, align);\n        len = 0;\n        buf[len++] = (char) (ch & 0xff);\n      } else if (intag) {\n        if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {\n          intag = 0;\n        } else if (len >= sizeof(buf) - 2) {\n          LOG(LL_ERROR, (\"%s: SSI tag is too large\", path));\n          len = 0;\n        }\n        buf[len++] = (char) (ch & 0xff);\n      } else {\n        buf[len++] = (char) (ch & 0xff);\n        if (len >= sizeof(buf)) {\n          mg_iobuf_add(&b, b.len, buf, len, align);\n          len = 0;\n        }\n      }\n    }\n    if (len > 0) mg_iobuf_add(&b, b.len, buf, len, align);\n    if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1, align);  // nul-terminate\n    fclose(fp);\n  }\n  (void) depth;\n  (void) root;\n  return (char *) b.buf;\n}\n\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";\n  char *data = mg_ssi(fullpath, root, 0);\n  mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);\n  free(data);\n}\n#else\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  mg_http_reply(c, 501, NULL, \"SSI not enabled\");\n  (void) root, (void) fullpath;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/str.c\"\n#endif\n\n#include <stdlib.h>\n\nstruct mg_str mg_str_s(const char *s) {\n  struct mg_str str = {s, s == NULL ? 0 : strlen(s)};\n  return str;\n}\n\nstruct mg_str mg_str_n(const char *s, size_t n) {\n  struct mg_str str = {s, n};\n  return str;\n}\n\nint mg_lower(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n  if (len > 0) do {\n      diff = mg_lower(s1++) - mg_lower(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_vcmp(const struct mg_str *s1, const char *s2) {\n  size_t n2 = strlen(s2), n1 = s1->len;\n  int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.ptr != NULL) {\n    char *sc = (char *) calloc(1, s.len + 1);\n    if (sc != NULL) {\n      memcpy(sc, s.ptr, s.len);\n      sc[s.len] = '\\0';\n      r.ptr = sc;\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = str1.ptr[i];\n    int c2 = str2.ptr[i];\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nconst char *mg_strstr(const struct mg_str haystack,\n                      const struct mg_str needle) {\n  size_t i;\n  if (needle.len > haystack.len) return NULL;\n  for (i = 0; i <= haystack.len - needle.len; i++) {\n    if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {\n      return haystack.ptr + i;\n    }\n  }\n  return NULL;\n}\n\nstruct mg_str mg_strstrip(struct mg_str s) {\n  while (s.len > 0 && isspace((int) *s.ptr)) s.ptr++, s.len--;\n  while (s.len > 0 && isspace((int) *(s.ptr + s.len - 1))) s.len--;\n  return s;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/timer.c\"\n#endif\n// Copyright (c) Cesanta Software Limited\n// All rights reserved\n\n\n\n\nstruct mg_timer *g_timers;\n\nvoid mg_timer_init(struct mg_timer *t, int64_t ms, unsigned flags,\n                   void (*fn)(void *), void *arg) {\n  struct mg_timer tmp = {ms, 0UL, flags, fn, arg, g_timers};\n  *t = tmp;\n  g_timers = t;\n  if (flags & MG_TIMER_RUN_NOW) fn(arg);\n}\n\nvoid mg_timer_free(struct mg_timer *t) {\n  struct mg_timer **head = &g_timers;\n  while (*head && *head != t) head = &(*head)->next;\n  if (*head) *head = t->next;\n}\n\nvoid mg_timer_poll(int64_t now_ms) {\n  // If time goes back (wrapped around), reset timers\n  struct mg_timer *t, *tmp;\n  static int64_t oldnow;  // Timestamp in a previous invocation\n  if (oldnow > now_ms) {  // If it is wrapped, reset timers\n    for (t = g_timers; t != NULL; t = t->next) t->expire = 0;\n  }\n  oldnow = now_ms;\n\n  for (t = g_timers; t != NULL; t = tmp) {\n    tmp = t->next;\n    if (t->expire == 0) t->expire = now_ms + t->period_ms;\n    if (t->expire > now_ms) continue;\n    t->fn(t->arg);\n    // Try to tick timers with the given period as accurate as possible,\n    // even if this polling function is called with some random period.\n    t->expire = now_ms - t->expire > t->period_ms ? now_ms + t->period_ms\n                                                  : t->expire + t->period_ms;\n    if (!(t->flags & MG_TIMER_REPEAT)) mg_timer_free(t);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_dummy.c\"\n#endif\n\n\n#if !MG_ENABLE_MBEDTLS && !MG_ENABLE_OPENSSL && !MG_ENABLE_CUSTOM_TLS\nvoid mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {\n  (void) opts;\n  mg_error(c, \"TLS is not enabled\");\n}\nvoid mg_tls_handshake(struct mg_connection *c) {\n  (void) c;\n}\nvoid mg_tls_free(struct mg_connection *c) {\n  (void) c;\n}\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_mbed.c\"\n#endif\n\n\n#if MG_ENABLE_MBEDTLS\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc;\n  mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mbedtls_net_send, mbedtls_net_recv, 0);\n  rc = mbedtls_ssl_handshake(&tls->ssl);\n  if (rc == 0) {  // Success\n    LOG(LL_DEBUG, (\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n  } else if (rc == MBEDTLS_ERR_SSL_WANT_READ ||\n             rc == MBEDTLS_ERR_SSL_WANT_WRITE) {  // Still pending\n    LOG(LL_VERBOSE_DEBUG, (\"%lu pending, %d%d %d (-%#x)\", c->id,\n                           c->is_connecting, c->is_tls_hs, rc, -rc));\n  } else {\n    mg_error(c, \"TLS handshake: -%#x\", -rc);  // Error\n  }\n}\n\nstatic int mbed_rng(void *ctx, unsigned char *buf, size_t len) {\n  mg_random(buf, len);\n  (void) ctx;\n  return 0;\n}\n\nstatic void debug_cb(void *c, int lev, const char *s, int n, const char *s2) {\n  n = (int) strlen(s2) - 1;\n  LOG(LL_VERBOSE_DEBUG, (\"%p %.*s\", ((struct mg_connection *) c)->fd, n, s2));\n  (void) s;\n  (void) c;\n  (void) lev;\n}\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\nstatic int rng_get(void *p_rng, unsigned char *buf, size_t len) {\n  (void) p_rng;\n  mg_random(buf, len);\n  return 0;\n}\n#endif\n\nvoid mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  int rc = 0;\n  const char *ca = opts->ca == NULL     ? \"-\"\n                   : opts->ca[0] == '-' ? \"(emb)\"\n                                        : opts->ca;\n  const char *crl = opts->crl == NULL     ? \"-\"\n                    : opts->crl[0] == '-' ? \"(emb)\"\n                                          : opts->crl;\n  const char *cert = opts->cert == NULL     ? \"-\"\n                     : opts->cert[0] == '-' ? \"(emb)\"\n                                            : opts->cert;\n  const char *certkey = opts->certkey == NULL     ? \"-\"\n                        : opts->certkey[0] == '-' ? \"(emb)\"\n                                                  : opts->certkey;\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n  LOG(LL_DEBUG, (\"%lu Setting TLS, CA: %s, CRL: %s, cert: %s, key: %s\", c->id,\n                 ca, crl, cert, certkey));\n  mbedtls_ssl_init(&tls->ssl);\n  mbedtls_ssl_config_init(&tls->conf);\n  mbedtls_x509_crt_init(&tls->ca);\n  mbedtls_x509_crl_init(&tls->crl);\n  mbedtls_x509_crt_init(&tls->cert);\n  mbedtls_pk_init(&tls->pk);\n  mbedtls_ssl_conf_dbg(&tls->conf, debug_cb, c);\n  //#if !defined(ESP_PLATFORM)\n  // mbedtls_debug_set_threshold(5);\n  //#endif\n  if ((rc = mbedtls_ssl_config_defaults(\n           &tls->conf,\n           c->is_client ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,\n           MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {\n    mg_error(c, \"tls defaults %#x\", -rc);\n    goto fail;\n  }\n  mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);\n  if (opts->ca == NULL || strcmp(opts->ca, \"*\") == 0) {\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);\n  }\n  if (opts->ca != NULL && opts->ca[0] != '\\0') {\n    if (opts->crl != NULL && opts->crl[0] != '\\0') {\n      rc = opts->crl[0] == '-'\n               ? mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) opts->crl,\n                                        strlen(opts->crl) + 1)\n               : mbedtls_x509_crl_parse_file(&tls->crl, opts->crl);\n      if (rc != 0) {\n        mg_error(c, \"parse(%s) err %#x\", crl, -rc);\n        goto fail;\n      }\n    }\n#if defined(MBEDTLS_X509_CA_CHAIN_ON_DISK)\n    tls->cafile = strdup(opts->ca);\n    rc = mbedtls_ssl_conf_ca_chain_file(&tls->conf, tls->cafile, &tls->crl);\n    if (rc != 0) {\n      mg_error(c, \"parse on-disk chain(%s) err %#x\", ca, -rc);\n      goto fail;\n    }\n#else\n    rc = opts->ca[0] == '-'\n             ? mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) opts->ca,\n                                      strlen(opts->ca) + 1)\n             : mbedtls_x509_crt_parse_file(&tls->ca, opts->ca);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", ca, -rc);\n      goto fail;\n    }\n    mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, &tls->crl);\n#endif\n    if (opts->srvname.len > 0) {\n      char mem[128], *buf = mem;\n      mg_asprintf(&buf, sizeof(mem), \"%.*s\", (int) opts->srvname.len,\n                  opts->srvname.ptr);\n      mbedtls_ssl_set_hostname(&tls->ssl, buf);\n      if (buf != mem) free(buf);\n    }\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    const char *key = opts->certkey;\n    if (key == NULL) {\n      key = opts->cert;\n      certkey = cert;\n    }\n    rc = opts->cert[0] == '-'\n             ? mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) opts->cert,\n                                      strlen(opts->cert) + 1)\n             : mbedtls_x509_crt_parse_file(&tls->cert, opts->cert);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", cert, -rc);\n      goto fail;\n    }\n    rc = key[0] == '-' ? mbedtls_pk_parse_key(&tls->pk, (uint8_t *) key,\n                                              strlen(key) + 1, NULL, 0 RNG)\n                       : mbedtls_pk_parse_keyfile(&tls->pk, key, NULL RNG);\n    if (rc != 0) {\n      mg_error(c, \"tls key(%s) %#x\", certkey, -rc);\n      goto fail;\n    }\n    rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);\n    if (rc != 0) {\n      mg_error(c, \"own cert %#x\", -rc);\n      goto fail;\n    }\n  }\n  if ((rc = mbedtls_ssl_setup(&tls->ssl, &tls->conf)) != 0) {\n    mg_error(c, \"setup err %#x\", -rc);\n    goto fail;\n  }\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  return;\nfail:\n  c->is_closing = 1;\n  free(tls);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_read(&tls->ssl, (unsigned char *) buf, len);\n  return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_READ ? 0 : n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);\n  return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_WRITE ? 0 : n;\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  free(tls->cafile);\n  mbedtls_ssl_free(&tls->ssl);\n  mbedtls_pk_free(&tls->pk);\n  mbedtls_x509_crt_free(&tls->ca);\n  mbedtls_x509_crl_free(&tls->crl);\n  mbedtls_x509_crt_free(&tls->cert);\n  mbedtls_ssl_config_free(&tls->conf);\n  free(tls);\n  c->tls = NULL;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_openssl.c\"\n#endif\n\n\n#if MG_ENABLE_OPENSSL\nstatic int mg_tls_err(struct mg_tls *tls, int res) {\n  int err = SSL_get_error(tls->ssl, res);\n  // We've just fetched the last error from the queue.\n  // Now we need to clear the error queue. If we do not, then the following\n  // can happen (actually reported):\n  //  - A new connection is accept()-ed with cert error (e.g. self-signed cert)\n  //  - Since all accept()-ed connections share listener's context,\n  //  - *ALL* SSL accepted connection report read error on the next poll cycle.\n  //    Thus a single errored connection can close all the rest, unrelated ones.\n  // Clearing the error keeps the shared SSL_CTX in an OK state.\n\n  if (err != 0) ERR_print_errors_fp(stderr);\n  ERR_clear_error();\n  if (err == SSL_ERROR_WANT_READ) return 0;\n  if (err == SSL_ERROR_WANT_WRITE) return 0;\n  return err;\n}\n\nvoid mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  const char *id = \"mongoose\";\n  static unsigned char s_initialised = 0;\n  int rc;\n\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n\n  if (!s_initialised) {\n    SSL_library_init();\n    s_initialised++;\n  }\n  LOG(LL_DEBUG, (\"%lu Setting TLS, CA: %s, cert: %s, key: %s\", c->id,\n                 opts->ca == NULL ? \"null\" : opts->ca,\n                 opts->cert == NULL ? \"null\" : opts->cert,\n                 opts->certkey == NULL ? \"null\" : opts->certkey));\n  tls->ctx = c->is_client ? SSL_CTX_new(SSLv23_client_method())\n                          : SSL_CTX_new(SSLv23_server_method());\n  if ((tls->ssl = SSL_new(tls->ctx)) == NULL) {\n    mg_error(c, \"SSL_new\");\n    goto fail;\n  }\n  SSL_set_session_id_context(tls->ssl, (const uint8_t *) id,\n                             (unsigned) strlen(id));\n  // Disable deprecated protocols\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv2);\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv3);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1_1);\n#ifdef MG_ENABLE_OPENSSL_NO_COMPRESSION\n  SSL_set_options(tls->ssl, SSL_OP_NO_COMPRESSION);\n#endif\n#ifdef MG_ENABLE_OPENSSL_CIPHER_SERVER_PREFERENCE\n  SSL_set_options(tls->ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n#endif\n\n  if (opts->ca != NULL && opts->ca[0] != '\\0') {\n    SSL_set_verify(tls->ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                   NULL);\n    if ((rc = SSL_CTX_load_verify_locations(tls->ctx, opts->ca, NULL)) != 1) {\n      mg_error(c, \"parse(%s): err %d\", opts->ca, mg_tls_err(tls, rc));\n      goto fail;\n    }\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    const char *key = opts->certkey;\n    if (key == NULL) key = opts->cert;\n    if ((rc = SSL_use_certificate_file(tls->ssl, opts->cert, 1)) != 1) {\n      mg_error(c, \"Invalid SSL cert, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n    } else if ((rc = SSL_use_PrivateKey_file(tls->ssl, key, 1)) != 1) {\n      mg_error(c, \"Invalid SSL key, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n    } else if ((rc = SSL_use_certificate_chain_file(tls->ssl, opts->cert)) !=\n               1) {\n      mg_error(c, \"Invalid CA, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#endif\n    } else {\n      SSL_set_mode(tls->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n      SSL_set_ecdh_auto(tls->ssl, 1);\n#endif\n    }\n  }\n  if (opts->ciphers != NULL) SSL_set_cipher_list(tls->ssl, opts->ciphers);\n  if (opts->srvname.len > 0) {\n    char mem[128], *buf = mem;\n    mg_asprintf(&buf, sizeof(mem), \"%.*s\", (int) opts->srvname.len,\n                opts->srvname.ptr);\n    SSL_set_tlsext_host_name(tls->ssl, buf);\n    if (buf != mem) free(buf);\n  }\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  LOG(LL_DEBUG, (\"%lu SSL %s OK\", c->id, c->is_accepted ? \"accept\" : \"client\"));\n  return;\nfail:\n  c->is_closing = 1;\n  free(tls);\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc;\n  SSL_set_fd(tls->ssl, (int) (size_t) c->fd);\n  rc = c->is_client ? SSL_connect(tls->ssl) : SSL_accept(tls->ssl);\n  if (rc == 1) {\n    LOG(LL_DEBUG, (\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n  } else {\n    int code = mg_tls_err(tls, rc);\n    if (code != 0) mg_error(c, \"tls hs: rc %d, err %d\", rc, code);\n  }\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  SSL_free(tls->ssl);\n  SSL_CTX_free(tls->ctx);\n  free(tls);\n  c->tls = NULL;\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_read(tls->ssl, buf, (int) len);\n  return n == 0 ? -1 : n < 0 && mg_tls_err(tls, n) == 0 ? 0 : n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_write(tls->ssl, buf, (int) len);\n  return n == 0 ? -1 : n < 0 && mg_tls_err(tls, n) == 0 ? 0 : n;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/url.c\"\n#endif\n\n#include <stdlib.h>\n\nstruct url {\n  size_t key, user, pass, host, port, uri, end;\n};\n\nint mg_url_is_ssl(const char *url) {\n  return strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0 ||\n         strncmp(url, \"mqtts:\", 6) == 0 || strncmp(url, \"ssl:\", 4) == 0 ||\n         strncmp(url, \"tls:\", 4) == 0;\n}\n\nstatic struct url urlparse(const char *url) {\n  size_t i;\n  struct url u;\n  memset(&u, 0, sizeof(u));\n  for (i = 0; url[i] != '\\0'; i++) {\n    if (i > 0 && u.host == 0 && url[i - 1] == '/' && url[i] == '/') {\n      u.host = i + 1;\n      u.port = 0;\n    } else if (url[i] == ']') {\n      u.port = 0;  // IPv6 URLs, like http://[::1]/bar\n    } else if (url[i] == ':' && u.port == 0 && u.uri == 0) {\n      u.port = i + 1;\n    } else if (url[i] == '@' && u.user == 0 && u.pass == 0) {\n      u.user = u.host;\n      u.pass = u.port;\n      u.host = i + 1;\n      u.port = 0;\n    } else if (u.host && u.uri == 0 && url[i] == '/') {\n      u.uri = i;\n    }\n  }\n  u.end = i;\n#if 0\n  printf(\"[%s] %d %d %d %d %d\\n\", url, u.user, u.pass, u.host, u.port, u.uri);\n#endif\n  return u;\n}\n\nstruct mg_str mg_url_host(const char *url) {\n  struct url u = urlparse(url);\n  size_t n = u.port  ? u.port - u.host - 1\n             : u.uri ? u.uri - u.host\n                     : u.end - u.host;\n  struct mg_str s = mg_str_n(url + u.host, n);\n  return s;\n}\n\nconst char *mg_url_uri(const char *url) {\n  struct url u = urlparse(url);\n  return u.uri ? url + u.uri : \"/\";\n}\n\nunsigned short mg_url_port(const char *url) {\n  struct url u = urlparse(url);\n  unsigned short port = 0;\n  if (strncmp(url, \"http:\", 5) == 0 || strncmp(url, \"ws:\", 3) == 0) port = 80;\n  if (strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0)\n    port = 443;\n  if (strncmp(url, \"mqtt:\", 5) == 0) port = 1883;\n  if (strncmp(url, \"mqtts:\", 6) == 0) port = 8883;\n  if (u.port) port = (unsigned short) atoi(url + u.port);\n  return port;\n}\n\nstruct mg_str mg_url_user(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str(\"\");\n  if (u.user && (u.pass || u.host)) {\n    size_t n = u.pass ? u.pass - u.user - 1 : u.host - u.user - 1;\n    s = mg_str_n(url + u.user, n);\n  }\n  return s;\n}\n\nstruct mg_str mg_url_pass(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str_n(\"\", 0UL);\n  if (u.pass && u.host) {\n    size_t n = u.host - u.pass - 1;\n    s = mg_str_n(url + u.pass, n);\n  }\n  return s;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/util.c\"\n#endif\n\n\n#if MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)\n#include <mach/mach_time.h>\n#endif\n\n#if MG_ENABLE_FILE\nchar *mg_file_read(const char *path, size_t *sizep) {\n  FILE *fp;\n  char *data = NULL;\n  size_t size = 0;\n  if ((fp = fopen(path, \"rb\")) != NULL) {\n    fseek(fp, 0, SEEK_END);\n    size = (size_t) ftell(fp);\n    rewind(fp);\n    data = (char *) calloc(1, size + 1);\n    if (data != NULL) {\n      if (fread(data, 1, size, fp) != size) {\n        free(data);\n        data = NULL;\n      } else {\n        data[size] = '\\0';\n        if (sizep != NULL) *sizep = size;\n      }\n    }\n    fclose(fp);\n  }\n  return data;\n}\n\nbool mg_file_write(const char *path, const void *buf, size_t len) {\n  bool result = false;\n  FILE *fp;\n  char tmp[MG_PATH_MAX];\n  snprintf(tmp, sizeof(tmp), \"%s.%d\", path, rand());\n  fp = fopen(tmp, \"wb\");\n  if (fp != NULL) {\n    result = fwrite(buf, 1, len, fp) == len;\n    fclose(fp);\n    if (result) {\n      remove(path);\n      rename(tmp, path);\n    } else {\n      remove(tmp);\n    }\n  }\n  return result;\n}\n\nbool mg_file_printf(const char *path, const char *fmt, ...) {\n  char tmp[256], *buf = tmp;\n  bool result;\n  int len;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);\n  va_end(ap);\n  result = mg_file_write(path, buf, len > 0 ? (size_t) len : 0);\n  if (buf != tmp) free(buf);\n  return result;\n}\n#endif\n\n#if MG_ENABLE_CUSTOM_RANDOM\n#else\nvoid mg_random(void *buf, size_t len) {\n  bool done = false;\n  unsigned char *p = (unsigned char *) buf;\n#if MG_ARCH == MG_ARCH_ESP32\n  while (len--) *p++ = (unsigned char) (esp_random() & 255);\n  done = true;\n#elif MG_ARCH == MG_ARCH_WIN32\n#elif MG_ARCH == MG_ARCH_UNIX\n  FILE *fp = fopen(\"/dev/urandom\", \"rb\");\n  if (fp != NULL) {\n    if (fread(buf, 1, len, fp) == len) done = true;\n    fclose(fp);\n  }\n#endif\n  // If everything above did not work, fallback to a pseudo random generator\n  while (!done && len--) *p++ = (unsigned char) (rand() & 255);\n}\n#endif\n\nbool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {\n  size_t i = 0, j = 0, ni = 0, nj = 0;\n  while (i < n1 || j < n2) {\n    if (i < n1 && j < n2 && (s1[i] == '?' || s2[j] == s1[i])) {\n      i++, j++;\n    } else if (i < n1 && (s1[i] == '*' || s1[i] == '#')) {\n      ni = i, nj = j + 1, i++;\n    } else if (nj > 0 && nj <= n2 && (s1[ni] == '#' || s2[j] != '/')) {\n      i = ni, j = nj;\n    } else {\n      // printf(\">>: [%s] [%s] %d %d %d %d\\n\", s1, s2, i, j, ni, nj);\n      return false;\n    }\n  }\n  return true;\n}\n\nstatic size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,\n                     size_t *klen, size_t *voff, size_t *vlen) {\n  size_t kvlen, kl;\n  for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != ',';) kvlen++;\n  for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;\n  if (koff != NULL) *koff = ofs;\n  if (klen != NULL) *klen = kl;\n  if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;\n  if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;\n  ofs += kvlen + 1;\n  return ofs > n ? n : ofs;\n}\n\nbool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {\n  size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;\n  if (s->ptr == NULL || s->len == 0) return 0;\n  off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen);\n  if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);\n  if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);\n  *s = mg_str_n(s->ptr + off, s->len - off);\n  return off > 0;\n}\n\nuint32_t mg_ntohl(uint32_t net) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |\n         (((uint32_t) data[1]) << 16) | (((uint32_t) data[0]) << 24);\n}\n\nuint16_t mg_ntohs(uint16_t net) {\n  uint8_t data[2] = {0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));\n}\n\nchar *mg_hexdump(const void *buf, size_t len) {\n  const unsigned char *p = (const unsigned char *) buf;\n  size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;\n  char ascii[17] = \"\", *dst = (char *) calloc(1, dlen);\n  if (dst == NULL) return dst;\n  for (i = 0; i < len; i++) {\n    idx = i % 16;\n    if (idx == 0) {\n      if (i > 0 && dlen > n)\n        n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);\n      if (dlen > n)\n        n += (size_t) snprintf(dst + n, dlen - n, \"%04x \", (int) (i + ofs));\n    }\n    if (dlen < n) break;\n    n += (size_t) snprintf(dst + n, dlen - n, \" %02x\", p[i]);\n    ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);\n    ascii[idx + 1] = '\\0';\n  }\n  while (i++ % 16) {\n    if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"%s\", \"   \");\n  }\n  if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);\n  if (n > dlen - 1) n = dlen - 1;\n  dst[n] = '\\0';\n  return dst;\n}\n\nchar *mg_hex(const void *buf, size_t len, char *to) {\n  const unsigned char *p = (const unsigned char *) buf;\n  static const char *hex = \"0123456789abcdef\";\n  size_t i = 0;\n  for (; len--; p++) {\n    to[i++] = hex[p[0] >> 4];\n    to[i++] = hex[p[0] & 0x0f];\n  }\n  to[i] = '\\0';\n  return to;\n}\n\nstatic unsigned char mg_unhex_nimble(unsigned char c) {\n  return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')\n         : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')\n                                  : (unsigned char) (c - 'W');\n}\n\nunsigned long mg_unhexn(const char *s, size_t len) {\n  unsigned long i = 0, v = 0;\n  for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);\n  return v;\n}\n\nvoid mg_unhex(const char *buf, size_t len, unsigned char *to) {\n  size_t i;\n  for (i = 0; i < len; i += 2) {\n    to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);\n  }\n}\n\nint mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  va_copy(ap_copy, ap);\n  len = vsnprintf(*buf, size, fmt, ap_copy);\n  va_end(ap_copy);\n\n  if (len < 0) {\n    // eCos and Windows are not standard-compliant and return -1 when\n    // the buffer is too small. Keep allocating larger buffers until we\n    // succeed or out of memory.\n    // LCOV_EXCL_START\n    *buf = NULL;\n    while (len < 0) {\n      free(*buf);\n      if (size == 0) size = 5;\n      size *= 2;\n      if ((*buf = (char *) calloc(1, size)) == NULL) {\n        len = -1;\n        break;\n      }\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, size - 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n    // Microsoft version of vsnprintf() is not always null-terminated, so put\n    // the terminator manually\n    if (*buf != NULL) (*buf)[len] = 0;\n    // LCOV_EXCL_STOP\n  } else if (len >= (int) size) {\n    /// Standard-compliant code path. Allocate a buffer that is large enough\n    if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {\n      len = -1;  // LCOV_EXCL_LINE\n    } else {     // LCOV_EXCL_LINE\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n  }\n\n  return len;\n}\n\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) {\n  int ret;\n  va_list ap;\n  va_start(ap, fmt);\n  ret = mg_vasprintf(buf, size, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\nint64_t mg_to64(struct mg_str str) {\n  int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;\n  size_t i = 0;\n  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;\n  if (i < str.len && str.ptr[i] == '-') neg = -1, i++;\n  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n    if (result > max) return 0;\n    result *= 10;\n    result += (str.ptr[i] - '0');\n    i++;\n  }\n  return result * neg;\n}\n\nuint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {\n  int i;\n  crc = ~crc;\n  while (len--) {\n    crc ^= *(unsigned char *) buf++;\n    for (i = 0; i < 8; i++) crc = crc & 1 ? (crc >> 1) ^ 0xedb88320 : crc >> 1;\n  }\n  return ~crc;\n}\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n       sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&\n      slash < 33) {\n    len = n;\n    *net = ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) |\n           (uint32_t) d;\n    *mask = slash ? (uint32_t) (0xffffffffU << (32 - slash)) : (uint32_t) 0;\n  }\n  return len;\n}\n\nint mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip) {\n  struct mg_str k, v;\n  int allowed = acl.len == 0 ? '+' : '-';  // If any ACL is set, deny by default\n  while (mg_commalist(&acl, &k, &v)) {\n    uint32_t net, mask;\n    if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;\n    if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;\n    if ((remote_ip & mask) == net) allowed = k.ptr[0];\n  }\n  return allowed == '+';\n}\n\nint64_t mg_millis(void) {\n#if MG_ARCH == MG_ARCH_WIN32\n  return GetTickCount();\n#elif MG_ARCH == MG_ARCH_ESP32\n  return esp_timer_get_time() / 1000;\n#elif MG_ARCH == MG_ARCH_ESP8266\n  return xTaskGetTickCount() * portTICK_PERIOD_MS;\n#elif MG_ARCH == MG_ARCH_FREERTOS_TCP || MG_ARCH == MG_ARCH_FREERTOS_LWIP\n  return xTaskGetTickCount() * portTICK_PERIOD_MS;\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  return tx_time_get() * (1000 /* MS per SEC */ / TX_TIMER_TICKS_PER_SECOND);\n#elif MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)\n  uint64_t ticks = mach_absolute_time();\n  static mach_timebase_info_data_t timebase;\n  mach_timebase_info(&timebase);\n  double ticks_to_nanos = (double) timebase.numer / timebase.denom;\n  uint64_t uptime_nanos = (uint64_t) (ticks_to_nanos * ticks);\n  return (int64_t) (uptime_nanos / 1000000);\n#elif MG_ARCH == MG_ARCH_UNIX\n  struct timespec ts;\n#ifdef _POSIX_MONOTONIC_CLOCK\n#ifdef CLOCK_MONOTONIC_RAW\n  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n#else\n  clock_gettime(CLOCK_MONOTONIC, &ts);\n#endif\n#else\n  clock_gettime(CLOCK_REALTIME, &ts);\n#endif\n  return ((int64_t) ts.tv_sec * 1000 + (int64_t) ts.tv_nsec / 1000000);\n#else\n  return time(NULL) * 1000;\n#endif\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ws.c\"\n#endif\n\n\n\n\n\n\n\n\n\nstruct ws_msg {\n  uint8_t flags;\n  size_t header_len;\n  size_t data_len;\n};\n\nstatic void ws_handshake(struct mg_connection *c, const struct mg_str *wskey,\n                         const struct mg_str *wsproto, const char *fmt,\n                         va_list ap) {\n  const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  unsigned char sha[20], b64_sha[30];\n  char mem[128], *buf = mem;\n\n  mg_sha1_ctx sha_ctx;\n  mg_sha1_init(&sha_ctx);\n  mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);\n  mg_sha1_update(&sha_ctx, (unsigned char *) magic, 36);\n  mg_sha1_final(sha, &sha_ctx);\n  mg_base64_encode(sha, sizeof(sha), (char *) b64_sha);\n  buf[0] = '\\0';\n  if (fmt != NULL) mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  mg_printf(c,\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: %s\\r\\n\"\n            \"%s\",\n            b64_sha, buf);\n  if (buf != mem) free(buf);\n  if (wsproto != NULL) {\n    mg_printf(c, \"Sec-WebSocket-Protocol: %.*s\\r\\n\", (int) wsproto->len,\n              wsproto->ptr);\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nstatic size_t ws_process(uint8_t *buf, size_t len, struct ws_msg *msg) {\n  size_t i, n = 0, mask_len = 0;\n  memset(msg, 0, sizeof(*msg));\n  if (len >= 2) {\n    n = buf[1] & 0x7f;                // Frame length\n    mask_len = buf[1] & 128 ? 4 : 0;  // last bit is a mask bit\n    msg->flags = buf[0];\n    if (n < 126 && len >= mask_len) {\n      msg->data_len = n;\n      msg->header_len = 2 + mask_len;\n    } else if (n == 126 && len >= 4 + mask_len) {\n      msg->header_len = 4 + mask_len;\n      msg->data_len = mg_ntohs(*(uint16_t *) &buf[2]);\n    } else if (len >= 10 + mask_len) {\n      msg->header_len = 10 + mask_len;\n      msg->data_len =\n          (size_t) (((uint64_t) mg_ntohl(*(uint32_t *) &buf[2])) << 32) +\n          mg_ntohl(*(uint32_t *) &buf[6]);\n    }\n  }\n  // Sanity check, and integer overflow protection for the boundary check below\n  // data_len should not be larger than 1 Gb\n  if (msg->data_len > 1024 * 1024 * 1024) return 0;\n  if (msg->header_len + msg->data_len > len) return 0;\n  if (mask_len > 0) {\n    uint8_t *p = buf + msg->header_len, *m = p - mask_len;\n    for (i = 0; i < msg->data_len; i++) p[i] ^= m[i & 3];\n  }\n  return msg->header_len + msg->data_len;\n}\n\nstatic size_t mkhdr(size_t len, int op, bool is_client, uint8_t *buf) {\n  size_t n = 0;\n  buf[0] = (uint8_t) (op | 128);\n  if (len < 126) {\n    buf[1] = (unsigned char) len;\n    n = 2;\n  } else if (len < 65536) {\n    uint16_t tmp = mg_htons((uint16_t) len);\n    buf[1] = 126;\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    n = 4;\n  } else {\n    uint32_t tmp;\n    buf[1] = 127;\n    tmp = mg_htonl((uint32_t) ((uint64_t) len >> 32));\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    tmp = mg_htonl((uint32_t) (len & 0xffffffff));\n    memcpy(&buf[6], &tmp, sizeof(tmp));\n    n = 10;\n  }\n  if (is_client) {\n    buf[1] |= 1 << 7;  // Set masking flag\n    mg_random(&buf[n], 4);\n    n += 4;\n  }\n  return n;\n}\n\nstatic void mg_ws_mask(struct mg_connection *c, size_t len) {\n  if (c->is_client && c->send.buf != NULL) {\n    size_t i;\n    uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;\n    for (i = 0; i < len; i++) p[i] ^= mask[i & 3];\n  }\n}\n\nsize_t mg_ws_send(struct mg_connection *c, const char *buf, size_t len,\n                  int op) {\n  uint8_t header[14];\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n  mg_send(c, header, header_len);\n  LOG(LL_VERBOSE_DEBUG, (\"WS out: %d [%.*s]\", (int) len, (int) len, buf));\n  mg_send(c, buf, len);\n  mg_ws_mask(c, len);\n  return header_len + len;\n}\n\nstatic void mg_ws_cb(struct mg_connection *c, int ev, void *ev_data,\n                     void *fn_data) {\n  struct ws_msg msg;\n  size_t ofs = (size_t) c->pfn_data;\n\n  // assert(ofs < c->recv.len);\n  if (ev == MG_EV_READ) {\n    if (!c->is_websocket && c->is_client) {\n      int n = mg_http_get_request_len(c->recv.buf, c->recv.len);\n      if (n < 0) {\n        c->is_closing = 1;  // Some just, not an HTTP request\n      } else if (n > 0) {\n        if (n < 15 || memcmp(c->recv.buf + 9, \"101\", 3) != 0) {\n          LOG(LL_ERROR,\n              (\"%lu WS handshake error: %.*s\", c->id, 15, c->recv.buf));\n          c->is_closing = 1;\n        } else {\n          struct mg_http_message hm;\n          mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n          c->is_websocket = 1;\n          mg_call(c, MG_EV_WS_OPEN, &hm);\n        }\n        mg_iobuf_del(&c->recv, 0, (size_t) n);\n      } else {\n        return;  // A request is not yet received\n      }\n    }\n\n    while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {\n      char *s = (char *) c->recv.buf + ofs + msg.header_len;\n      struct mg_ws_message m = {{s, msg.data_len}, msg.flags};\n      size_t len = msg.header_len + msg.data_len;\n      uint8_t final = msg.flags & 128, op = msg.flags & 15;\n      // LOG(LL_VERBOSE_DEBUG, (\"fin %d op %d len %d [%.*s]\", final, op,\n      //                       (int) m.data.len, (int) m.data.len, m.data.ptr));\n      switch (op) {\n        case WEBSOCKET_OP_CONTINUE:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PING:\n          LOG(LL_DEBUG, (\"%s\", \"WS PONG\"));\n          mg_ws_send(c, s, msg.data_len, WEBSOCKET_OP_PONG);\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PONG:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_TEXT:\n        case WEBSOCKET_OP_BINARY:\n          if (final) mg_call(c, MG_EV_WS_MSG, &m);\n          break;\n        case WEBSOCKET_OP_CLOSE:\n          LOG(LL_DEBUG, (\"%lu Got WS CLOSE\", c->id));\n          mg_call(c, MG_EV_WS_CTL, &m);\n          c->is_closing = 1;\n          break;\n        default:\n          // Per RFC6455, close conn when an unknown op is recvd\n          mg_error(c, \"unknown WS op %d\", op);\n          break;\n      }\n\n      // Handle fragmented frames: strip header, keep in c->recv\n      if (final == 0 || op == 0) {\n        if (op) ofs++, len--, msg.header_len--;       // First frame\n        mg_iobuf_del(&c->recv, ofs, msg.header_len);  // Strip header\n        len -= msg.header_len;\n        ofs += len;\n        c->pfn_data = (void *) ofs;\n        // LOG(LL_INFO, (\"FRAG %d [%.*s]\", (int) ofs, (int) ofs, c->recv.buf));\n      }\n      // Remove non-fragmented frame\n      if (final && op) mg_iobuf_del(&c->recv, ofs, len);\n      // Last chunk of the fragmented frame\n      if (final && !op) {\n        m.flags = c->recv.buf[0];\n        m.data = mg_str_n((char *) &c->recv.buf[1], (size_t) (ofs - 1));\n        mg_call(c, MG_EV_WS_MSG, &m);\n        mg_iobuf_del(&c->recv, 0, ofs);\n        ofs = 0;\n        c->pfn_data = NULL;\n      }\n    }\n  }\n  (void) fn_data;\n  (void) ev_data;\n}\n\nstruct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url,\n                                    mg_event_handler_t fn, void *fn_data,\n                                    const char *fmt, ...) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    char nonce[16], key[30], mem1[128], mem2[256], *buf1 = mem1, *buf2 = mem2;\n    struct mg_str host = mg_url_host(url);\n    int n1 = 0, n2 = 0;\n    if (fmt != NULL) {\n      va_list ap;\n      va_start(ap, fmt);\n      n1 = mg_vasprintf(&buf1, sizeof(mem1), fmt, ap);\n      va_end(ap);\n    }\n    // Send handshake request\n    // mg_url_host(url, host, sizeof(host));\n    mg_random(nonce, sizeof(nonce));\n    mg_base64_encode((unsigned char *) nonce, sizeof(nonce), key);\n    // LOG(LL_DEBUG, \"%p [%s]\", uri, uri == NULL ? \"???\" : uri);\n    n2 = mg_asprintf(&buf2, sizeof(mem2),\n                     \"GET %s HTTP/1.1\\r\\n\"\n                     \"Upgrade: websocket\\r\\n\"\n                     \"Host: %.*s\\r\\n\"\n                     \"Connection: Upgrade\\r\\n\"\n                     \"%.*s\"\n                     \"Sec-WebSocket-Version: 13\\r\\n\"\n                     \"Sec-WebSocket-Key: %s\\r\\n\"\n                     \"\\r\\n\",\n                     mg_url_uri(url), (int) host.len, host.ptr, n1, buf1, key);\n    mg_send(c, buf2, n2 > 0 ? (size_t) n2 : 0);\n    if (buf1 != mem1) free(buf1);\n    if (buf2 != mem2) free(buf2);\n    c->pfn = mg_ws_cb;\n    c->pfn_data = NULL;\n  }\n  return c;\n}\n\nvoid mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *fmt, ...) {\n  struct mg_str *wskey = mg_http_get_header(hm, \"Sec-WebSocket-Key\");\n  c->pfn = mg_ws_cb;\n  c->pfn_data = NULL;\n  if (wskey == NULL) {\n    mg_http_reply(c, 426, \"\", \"WS upgrade expected\\n\");\n    c->is_draining = 1;\n  } else {\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    va_list ap;\n    va_start(ap, fmt);\n    ws_handshake(c, wskey, wsproto, fmt, ap);\n    va_end(ap);\n    c->is_websocket = 1;\n    mg_call(c, MG_EV_WS_OPEN, hm);\n  }\n}\n\nsize_t mg_ws_wrap(struct mg_connection *c, size_t len, int op) {\n  uint8_t header[14], *p;\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n\n  // NOTE: order of operations is important!\n  mg_iobuf_add(&c->send, c->send.len, NULL, header_len, MG_IO_SIZE);\n  p = &c->send.buf[c->send.len - len];         // p points to data\n  memmove(p, p - header_len, len);             // Shift data\n  memcpy(p - header_len, header, header_len);  // Prepend header\n  mg_ws_mask(c, len);                          // Mask data\n\n  return c->send.len;\n}\n", "#include \"http.h\"\n#include \"arch.h\"\n#include \"base64.h\"\n#include \"log.h\"\n#include \"net.h\"\n#include \"ssi.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include \"ws.h\"\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // LOG(LL_INFO, (\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // LOG(LL_INFO, (\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // LOG(LL_INFO, (\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len + 21];\n    memcpy(&buf[-21], \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf, n);\n      }\n    }\n    n = mg_base64_final(buf, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    LOG(LL_ERROR, (\"%lu %s cannot resize iobuf %d->%d \", c->id, c->label,\n                   (int) c->send.size, (int) need));\n  }\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = buf->ptr + buf->len;\n    len = -4;  // Name does not exist\n    dst[0] = '\\0';\n    for (p = buf->ptr; p + name_len < e; p++) {\n      if ((p == buf->ptr || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_ncasecmp(name, p, name_len)) {\n        p += name_len + 1;\n        s = (const char *) memchr(p, '&', (size_t) (e - p));\n        if (s == NULL) s = e;\n        len = mg_url_decode(p, (size_t) (s - p), dst, dst_len, 1);\n        if (len < 0) len = -3;  // Failed to decode\n        break;\n      }\n    }\n  }\n  return len;\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isxdigit(*(const unsigned char *) (src + i + 1)) &&\n          isxdigit(*(const unsigned char *) (src + i + 2))) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128)\n      return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // LOG(LL_INFO, (\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s + req_len, *qs;\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list ap) {\n  char mem[256], *buf = mem;\n  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  mg_printf(c, \"%X\\r\\n\", len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  mg_send(c, \"\\r\\n\", 2);\n  if (buf != mem) free(buf);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lX\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 101: return \"Switching Protocols\";\n    case 102: return \"Processing\";\n    case 200: return \"OK\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 203: return \"Non-authoritative Information\";\n    case 204: return \"No Content\";\n    case 205: return \"Reset Content\";\n    case 206: return \"Partial Content\";\n    case 207: return \"Multi-Status\";\n    case 208: return \"Already Reported\";\n    case 226: return \"IM Used\";\n    case 300: return \"Multiple Choices\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 303: return \"See Other\";\n    case 304: return \"Not Modified\";\n    case 305: return \"Use Proxy\";\n    case 307: return \"Temporary Redirect\";\n    case 308: return \"Permanent Redirect\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 402: return \"Payment Required\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 405: return \"Method Not Allowed\";\n    case 406: return \"Not Acceptable\";\n    case 407: return \"Proxy Authentication Required\";\n    case 408: return \"Request Timeout\";\n    case 409: return \"Conflict\";\n    case 410: return \"Gone\";\n    case 411: return \"Length Required\";\n    case 412: return \"Precondition Failed\";\n    case 413: return \"Payload Too Large\";\n    case 414: return \"Request-URI Too Long\";\n    case 415: return \"Unsupported Media Type\";\n    case 416: return \"Requested Range Not Satisfiable\";\n    case 417: return \"Expectation Failed\";\n    case 418: return \"I'm a teapot\";\n    case 421: return \"Misdirected Request\";\n    case 422: return \"Unprocessable Entity\";\n    case 423: return \"Locked\";\n    case 424: return \"Failed Dependency\";\n    case 426: return \"Upgrade Required\";\n    case 428: return \"Precondition Required\";\n    case 429: return \"Too Many Requests\";\n    case 431: return \"Request Header Fields Too Large\";\n    case 444: return \"Connection Closed Without Response\";\n    case 451: return \"Unavailable For Legal Reasons\";\n    case 499: return \"Client Closed Request\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    case 502: return \"Bad Gateway\";\n    case 503: return \"Service Unavailable\";\n    case 504: return \"Gateway Timeout\";\n    case 505: return \"HTTP Version Not Supported\";\n    case 506: return \"Variant Also Negotiates\";\n    case 507: return \"Insufficient Storage\";\n    case 508: return \"Loop Detected\";\n    case 510: return \"Not Extended\";\n    case 511: return \"Network Authentication Required\";\n    case 599: return \"Network Connect Timeout Error\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  char mem[256], *buf = mem;\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length: %d\\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers, len);\n  mg_send(c, buf, len > 0 ? (size_t) len : 0);\n  if (buf != mem) free(buf);\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  struct mg_fd *fd = (struct mg_fd *) c->pfn_data;\n  if (fd != NULL) fd->fs->close(fd);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,\n           (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = 2 * MG_IO_SIZE;\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    n = fd->fs->read(fd->fd, c->send.buf + c->send.len,\n                     c->send.size - c->send.len);\n    if (n > 0) c->send.len += n;\n    if (c->send.len < c->send.size) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  // clang-format off\n  struct mimeentry { struct mg_str extension, value; };\n  #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}\n  // clang-format on\n  const struct mimeentry tab[] = {\n      MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"css\", \"text/css; charset=utf-8\"),\n      MIME_ENTRY(\"js\", \"text/javascript; charset=utf-8\"),\n      MIME_ENTRY(\"gif\", \"image/gif\"),\n      MIME_ENTRY(\"png\", \"image/png\"),\n      MIME_ENTRY(\"jpg\", \"image/jpeg\"),\n      MIME_ENTRY(\"jpeg\", \"image/jpeg\"),\n      MIME_ENTRY(\"woff\", \"font/woff\"),\n      MIME_ENTRY(\"ttf\", \"font/ttf\"),\n      MIME_ENTRY(\"svg\", \"image/svg+xml\"),\n      MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),\n      MIME_ENTRY(\"avi\", \"video/x-msvideo\"),\n      MIME_ENTRY(\"csv\", \"text/csv\"),\n      MIME_ENTRY(\"doc\", \"application/msword\"),\n      MIME_ENTRY(\"exe\", \"application/octet-stream\"),\n      MIME_ENTRY(\"gz\", \"application/gzip\"),\n      MIME_ENTRY(\"ico\", \"image/x-icon\"),\n      MIME_ENTRY(\"json\", \"application/json\"),\n      MIME_ENTRY(\"mov\", \"video/quicktime\"),\n      MIME_ENTRY(\"mp3\", \"audio/mpeg\"),\n      MIME_ENTRY(\"mp4\", \"video/mp4\"),\n      MIME_ENTRY(\"mpeg\", \"video/mpeg\"),\n      MIME_ENTRY(\"pdf\", \"application/pdf\"),\n      MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),\n      MIME_ENTRY(\"tgz\", \"application/tar-gz\"),\n      MIME_ENTRY(\"wav\", \"audio/wav\"),\n      MIME_ENTRY(\"webp\", \"image/webp\"),\n      MIME_ENTRY(\"zip\", \"application/zip\"),\n      MIME_ENTRY(\"3gp\", \"video/3gpp\"),\n      {{0, 0}, {0, 0}},\n  };\n  size_t i = 0;\n  struct mg_str k, v, s = mg_str(extra);\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; tab[i].extension.ptr != NULL; i++) {\n    if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  LOG(LL_INFO, (\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // LOG(LL_INFO, (\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path, struct mg_http_serve_opts *opts) {\n  char etag[64];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = fs->open(path, MG_FS_READ);\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n\n  if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {\n    LOG(LL_DEBUG, (\"404 [%s] %p\", path, (void *) fd));\n    mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");\n    fs->close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    fs->close(fd);\n    mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n  } else {\n    int n, status = 200;\n    char range[100] = \"\";\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n    struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT\n                 \"/\" MG_INT64_FMT \"\\r\\n\",\n                 r1, r1 + cl - 1, (int64_t) size);\n        fs->seek(fd->fd, (size_t) r1);\n      }\n    }\n\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      fs->close(fd);\n    } else {\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[64], mod[64];\n  int flags, n = 0;\n\n  // LOG(LL_DEBUG, (\"[%s] [%s]\", d->dir, name));\n  if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {\n    LOG(LL_ERROR, (\"%s truncated\", name));\n  } else if ((flags = fs->stat(path, &size, &t)) == 0) {\n    LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    struct tm tm;\n    if (flags & MG_FS_DIR) {\n      snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else if (size < 1024) {\n      snprintf(sz, sizeof(sz), \"%d\", (int) size);\n    } else if (size < 0x100000) {\n      snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);\n    } else if (size < 0x40000000) {\n      snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);\n    } else {\n      snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);\n    }\n    strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&t, &tm));\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=\" MG_INT64_FMT \">%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_http_serve_opts *opts, char *dir) {\n  static const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  static const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n\n  fs->list(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",\n                        (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 10, tmp, n);  // Set content length\n}\n\nstatic void remove_double_dots(char *s) {\n  char *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\n// Resolve requested file into `path` and return its fs->stat() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags = 0, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {\n    mg_http_reply(c, 400, \"\", \"Invalid web root [%.*s]\\n\", (int) dir.len,\n                  dir.ptr);\n  } else {\n    if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n    mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                  path_size - n, 0);\n    path[path_size - 1] = '\\0';  // Double-check\n    remove_double_dots(path);\n    n = strlen(path);\n    LOG(LL_VERBOSE_DEBUG,\n        (\"%lu %.*s -> %s\", c->id, (int) hm->uri.len, hm->uri.ptr, path));\n    while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n    flags = fs->stat(path, NULL, NULL);                 // Does it exist?\n    if (flags == 0) {\n      mg_http_reply(c, 404, \"\", \"Not found\\n\");  // Does not exist, doh\n    } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n               hm->uri.ptr[hm->uri.len - 1] != '/') {\n      mg_printf(c,\n                \"HTTP/1.1 301 Moved\\r\\n\"\n                \"Location: %.*s/\\r\\n\"\n                \"Content-Length: 0\\r\\n\"\n                \"\\r\\n\",\n                (int) hm->uri.len, hm->uri.ptr);\n      flags = 0;\n    } else if (flags & MG_FS_DIR) {\n      if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0) ||\n           (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n            (tmp = fs->stat(path, NULL, NULL)) != 0))) {\n        flags = tmp;\n      } else {\n        path[n] = '\\0';  // Remove appended index file name\n      }\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX] = \"\";\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags == 0) return;\n  LOG(LL_VERBOSE_DEBUG,\n      (\"%.*s %s %d\", (int) hm->uri.len, hm->uri.ptr, path, flags));\n  if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (sp != NULL && mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // LOG(LL_INFO, (\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_globmatch(glob, strlen(glob), hm->uri.ptr, hm->uri.len);\n}\n\nstatic size_t get_chunk_length(const char *buf, size_t len, size_t *ll) {\n  size_t i = 0, n;\n  while (i < len && buf[i] != '\\r' && i != '\\n') i++;\n  n = mg_unhexn((char *) buf, i);\n  while (i < len && (buf[i] == '\\r' || i == '\\n')) i++;\n  // LOG(LL_INFO, (\"len %zu i %zu n %zu \", len, i, n));\n  if (ll != NULL) *ll = i + 1;\n  if (i < len && i + n + 2 < len) return i + n + 3;\n  return 0;\n}\n\n// Walk through all chunks in the chunked body. For each chunk, fire\n// an MG_EV_HTTP_CHUNK event.\nstatic void walkchunks(struct mg_connection *c, struct mg_http_message *hm,\n                       size_t reqlen) {\n  size_t off = 0, bl, ll;\n  while (off + reqlen < c->recv.len) {\n    char *buf = (char *) &c->recv.buf[reqlen];\n    size_t memo = c->recv.len;\n    size_t cl = get_chunk_length(&buf[off], memo - reqlen - off, &ll);\n    // LOG(LL_INFO, (\"len %zu off %zu cl %zu ll %zu\", len, off, cl, ll));\n    if (cl == 0) break;\n    hm->chunk = mg_str_n(&buf[off + ll], cl < ll + 2 ? 0 : cl - ll - 2);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    // Increase offset only if user has not deleted this chunk\n    if (memo == c->recv.len) off += cl;\n    if (cl <= 5) {\n      // Zero chunk - last one. Prepare body - cut off chunk lengths\n      off = bl = 0;\n      while (off + reqlen < c->recv.len) {\n        char *buf2 = (char *) &c->recv.buf[reqlen];\n        size_t memo2 = c->recv.len;\n        size_t cl2 = get_chunk_length(&buf2[off], memo2 - reqlen - off, &ll);\n        size_t n = cl2 < ll + 2 ? 0 : cl2 - ll - 2;\n        memmove(buf2 + bl, buf2 + off + ll, n);\n        bl += n;\n        off += cl2;\n        if (cl2 <= 5) break;\n      }\n      // LOG(LL_INFO, (\"BL->%d del %d off %d\", (int) bl, (int) del, (int) off));\n      c->recv.len -= off - bl;\n      // Set message length to indicate we've received\n      // everything, to fire MG_EV_HTTP_MSG\n      hm->message.len = bl + reqlen;\n      hm->body.len = bl;\n      break;\n    }\n  }\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  struct mg_str needle = mg_str_n(\"chunked\", 7);\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_strstr(*te, needle) != NULL;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  struct mg_str ch = hm->chunk;\n  if (mg_is_chunked(hm)) {\n    ch.len += 4;  // \\r\\n before and after the chunk\n    ch.ptr -= 2;\n    while (ch.ptr > hm->body.ptr && *ch.ptr != '\\n') ch.ptr--, ch.len++;\n  }\n  {\n    const char *end = &ch.ptr[ch.len];\n    size_t n = (size_t) (end - (char *) c->recv.buf);\n    if (c->recv.len > n) {\n      memmove((char *) ch.ptr, end, (size_t) (c->recv.len - n));\n    }\n    // LOG(LL_INFO, (\"DELETING CHUNK: %zu %zu %zu\\n%.*s\", c->recv.len, n,\n    // ch.len, (int) ch.len, ch.ptr));\n  }\n  c->recv.len -= ch.len;\n}\n\n#if MG_ENABLE_FILE\nint mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}\n#endif\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      int n = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      bool is_chunked = n > 0 && mg_is_chunked(&hm);\n      if (ev == MG_EV_CLOSE) {\n        hm.message.len = c->recv.len;\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      } else if (is_chunked && n > 0) {\n        walkchunks(c, &hm, (size_t) n);\n      }\n      // LOG(LL_INFO,\n      //(\"---->%d %d\\n%.*s\", n, is_chunked, (int) c->recv.len, c->recv.buf));\n      if (n < 0 && ev == MG_EV_READ) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      } else if (n > 0 && (size_t) c->recv.len >= hm.message.len) {\n        mg_call(c, MG_EV_HTTP_MSG, &hm);\n        mg_iobuf_del(&c->recv, 0, hm.message.len);\n      } else {\n        if (n > 0 && !is_chunked) {\n          hm.chunk =\n              mg_str_n((char *) &c->recv.buf[n], c->recv.len - (size_t) n);\n          mg_call(c, MG_EV_HTTP_CHUNK, &hm);\n        }\n        break;\n      }\n    }\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n", "#include \"mongoose.h\"\n\nstatic int s_num_tests = 0;\n\n#define ASSERT(expr)                                            \\\n  do {                                                          \\\n    s_num_tests++;                                              \\\n    if (!(expr)) {                                              \\\n      printf(\"FAILURE %s:%d: %s\\n\", __FILE__, __LINE__, #expr); \\\n      exit(EXIT_FAILURE);                                       \\\n    }                                                           \\\n  } while (0)\n\n#define FETCH_BUF_SIZE (256 * 1024)\n\n// Important: we use different port numbers for the Windows bug workaround. See\n// https://support.microsoft.com/en-ae/help/3039044/error-10013-wsaeacces-is-returned-when-a-second-bind-to-a-excluded-por\n\nstatic void test_globmatch(void) {\n  ASSERT(mg_globmatch(\"\", 0, \"\", 0) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"a\", 1) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"ab\", 2) == 1);\n  ASSERT(mg_globmatch(\"\", 0, \"a\", 1) == 0);\n  ASSERT(mg_globmatch(\"/\", 1, \"/foo\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/bar\", 6) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foo\", 6) == 1);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foox\", 7) == 0);\n  ASSERT(mg_globmatch(\"/*/foo*\", 7, \"/x/foox\", 7) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/abc\", 4) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/ab/\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/\", 1) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2\", 4) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2/foo\", 8) == 0);\n  ASSERT(mg_globmatch(\"/x/*/*\", 6, \"/x/2/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"#\", 1, \"///\", 3) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/log/static\", 15) == 0);\n  ASSERT(mg_globmatch(\"/api/#\", 6, \"/api/log/static\", 15) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"/ssi/index.shtml\", 16) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \".c\", 2) == 1);\n  ASSERT(mg_globmatch(\"abc\", 3, \"ab\", 2) == 0);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"a.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"..c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"/.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"//a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"x/a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"./a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"./ssi/index.shtml\", 17) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabba\", 6) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabxa\", 6) == 0);\n}\n\nstatic void test_commalist(void) {\n  struct mg_str k, v, s1 = mg_str(\"\"), s2 = mg_str(\"a\"), s3 = mg_str(\"a,b\");\n  struct mg_str s4 = mg_str(\"a=123\"), s5 = mg_str(\"a,b=123\");\n  ASSERT(mg_commalist(&s1, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s2, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s2, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"b\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s4, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"a\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"b\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n}\n\nstatic void test_http_get_var(void) {\n  char buf[256];\n  struct mg_str body;\n  body = mg_str(\"key1=value1&key2=value2&key3=value%203&key4=value+4\");\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"KEY1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key2\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value2\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key3\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 3\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key4\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 4\") == 0);\n\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -4);\n  ASSERT(mg_http_get_var(&body, \"key1\", NULL, sizeof(buf)) == -2);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 0) == -2);\n  ASSERT(mg_http_get_var(&body, NULL, buf, sizeof(buf)) == -1);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 1) == -3);\n\n  body = mg_str(\"key=broken%2\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n\n  body = mg_str(\"key=broken%2x\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  ASSERT(mg_http_get_var(&body, \"inexistent\", buf, sizeof(buf)) == -4);\n  body = mg_str(\"key=%\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  body = mg_str(\"&&&kEy=%\");\n  ASSERT(mg_http_get_var(&body, \"kEy\", buf, sizeof(buf)) == -3);\n}\n\nstatic int vcmp(struct mg_str s1, const char *s2) {\n  // LOG(LL_INFO, (\"->%.*s<->%s<- %d %d %d\", (int) s1.len, s1.ptr, s2,\n  //(int) s1.len, strncmp(s1.ptr, s2, s1.len), mg_vcmp(&s1, s2)));\n  return mg_vcmp(&s1, s2) == 0;\n}\n\nstatic void test_url(void) {\n  // Host\n  ASSERT(vcmp(mg_url_host(\"foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"//foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\":1234\"), \"\"));\n  ASSERT(vcmp(mg_url_host(\"//foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo//x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[::1]:1234/a\"), \"[::1]\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[1:2::3]:1234/a\"), \"[1:2::3]\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x:y/z\"), \"foo\"));\n\n  // Port\n  ASSERT(mg_url_port(\"foo:1234\") == 1234);\n  ASSERT(mg_url_port(\":1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/xx\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a:b\") == 1234);\n  ASSERT(mg_url_port(\"http://bar\") == 80);\n  ASSERT(mg_url_port(\"http://localhost:1234\") == 1234);\n  ASSERT(mg_url_port(\"https://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/abc\") == 123);\n  ASSERT(mg_url_port(\"http://u:p@[::1]/abc\") == 80);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc\") == 2121);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc/cd:ef\") == 2121);\n\n  // User / pass\n  ASSERT(vcmp(mg_url_user(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:p@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:p@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo//a@b\"), \"p\"));\n\n  // URI\n  ASSERT(strcmp(mg_url_uri(\"p://foo\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/abc\"), \"/abc\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[ab::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n}\n\nstatic void test_base64(void) {\n  char buf[128];\n\n  ASSERT(mg_base64_encode((uint8_t *) \"\", 0, buf) == 0);\n  ASSERT(strcmp(buf, \"\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"x\", 1, buf) == 4);\n  ASSERT(strcmp(buf, \"eA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xyz\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHl6\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcdef\", 6, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGVm\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"\u044b\", 2, buf) == 4);\n  ASSERT(strcmp(buf, \"0Ys=\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xy\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHkA\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"test\", 4, buf) == 8);\n  ASSERT(strcmp(buf, \"dGVzdA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcde\", 5, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGU=\") == 0);\n\n  ASSERT(mg_base64_decode(\"\u043a\u044e\", 4, buf) == 0);\n  ASSERT(mg_base64_decode(\"A\", 1, buf) == 0);\n  ASSERT(mg_base64_decode(\"A=\", 2, buf) == 0);\n  ASSERT(mg_base64_decode(\"AA=\", 3, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAA=\", 4, buf) == 2);\n  ASSERT(mg_base64_decode(\"AAAA====\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAAA----\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"Q2VzYW50YQ==\", 12, buf) == 7);\n  ASSERT(strcmp(buf, \"Cesanta\") == 0);\n}\n\nstatic void test_iobuf(void) {\n  struct mg_iobuf io = {0, 0, 0};\n  ASSERT(io.buf == NULL && io.size == 0 && io.len == 0);\n  mg_iobuf_resize(&io, 1);\n  ASSERT(io.buf != NULL && io.size == 1 && io.len == 0);\n  ASSERT(memcmp(io.buf, \"\\x00\", 1) == 0);\n  mg_iobuf_add(&io, 3, \"hi\", 2, 10);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 5);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi\", 5) == 0);\n  mg_iobuf_add(&io, io.len, \"!\", 1, 10);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 6);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi!\", 6) == 0);\n  mg_iobuf_add(&io, 0, \"x\", 1, 10);\n  ASSERT(memcmp(io.buf, \"x\\x00\\x00\\x00hi!\", 7) == 0);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 7);\n  mg_iobuf_del(&io, 1, 3);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  mg_iobuf_del(&io, 10, 100);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  free(io.buf);\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_SNTP_TIME) {\n    *(int64_t *) fnd = *(int64_t *) evd;\n  }\n  (void) c;\n}\n\nstatic void test_sntp(void) {\n  int64_t ms = 0;\n  struct mg_mgr mgr;\n  struct mg_connection *c = NULL;\n  int i;\n\n  mg_mgr_init(&mgr);\n  c = mg_sntp_connect(&mgr, NULL, sntp_cb, &ms);\n  ASSERT(c != NULL);\n  ASSERT(c->is_udp == 1);\n  mg_sntp_send(c, (unsigned long) time(NULL));\n  for (i = 0; i < 300 && ms == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ms > 0);\n  mg_mgr_free(&mgr);\n\n  {\n    const unsigned char sntp_good[] =\n        \"\\x24\\x02\\x00\\xeb\\x00\\x00\\x00\\x1e\\x00\\x00\\x07\\xb6\\x3e\"\n        \"\\xc9\\xd6\\xa2\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\"\n        \"\\xed\\x98\\x00\\x00\\x00\\xde\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\"\n        \"\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";\n    const unsigned char bad_good[] =\n        \"\\x55\\x02\\x00\\xeb\\x00\\x00\\x00\\x1e\\x00\\x00\\x07\\xb6\\x3e\"\n        \"\\xc9\\xd6\\xa2\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\"\n        \"\\xed\\x98\\x00\\x00\\x00\\xde\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\"\n        \"\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";\n    struct tm tm;\n    time_t t;\n    ASSERT((ms = mg_sntp_parse(sntp_good, sizeof(sntp_good))) > 0);\n    t = (time_t) (ms / 1000);\n    gmtime_r(&t, &tm);\n    ASSERT(tm.tm_year == 116);\n    ASSERT(tm.tm_mon == 10);\n    ASSERT(tm.tm_mday == 22);\n    ASSERT(tm.tm_hour == 16);\n    ASSERT(tm.tm_min == 15);\n    ASSERT(tm.tm_sec == 21);\n    ASSERT(mg_sntp_parse(bad_good, sizeof(bad_good)) < 0);\n  }\n\n  ASSERT(mg_sntp_parse(NULL, 0) == -1);\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  char *buf = (char *) fnd;\n  if (ev == MG_EV_MQTT_OPEN) {\n    buf[0] = *(int *) evd == 0 ? 'X' : 'Y';\n  } else if (ev == MG_EV_MQTT_MSG) {\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) evd;\n    sprintf(buf + 1, \"%.*s/%.*s\", (int) mm->topic.len, mm->topic.ptr,\n            (int) mm->data.len, mm->data.ptr);\n  }\n  (void) c;\n}\n\nstatic void test_mqtt(void) {\n  char buf[50] = {0};\n  struct mg_mgr mgr;\n  struct mg_str topic = mg_str(\"x/f12\"), data = mg_str(\"hi\");\n  struct mg_connection *c;\n  struct mg_mqtt_opts opts;\n  // const char *url = \"mqtt://mqtt.eclipse.org:1883\";\n  const char *url = \"mqtt://broker.hivemq.com:1883\";\n  int i;\n  mg_mgr_init(&mgr);\n\n  {\n    uint8_t bad[] = \" \\xff\\xff\\xff\\xff \";\n    struct mg_mqtt_message mm;\n    mg_mqtt_parse(bad, sizeof(bad), &mm);\n  }\n\n  // Connect with empty client ID\n  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, buf);\n  for (i = 0; i < 200 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(buf[0] == 'X');\n  mg_mqtt_sub(c, &topic, 1);\n  mg_mqtt_pub(c, &topic, &data, 1, false);\n  for (i = 0; i < 300 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  // LOG(LL_INFO, (\"[%s]\", buf));\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  // Set params\n  memset(buf, 0, sizeof(buf));\n  memset(&opts, 0, sizeof(opts));\n  opts.clean = true;\n  opts.will_qos = 1;\n  opts.will_retain = true;\n  opts.keepalive = 20;\n  opts.client_id = mg_str(\"mg_client\");\n  opts.will_topic = mg_str(\"mg_will_topic\");\n  opts.will_message = mg_str(\"mg_will_messsage\");\n  c = mg_mqtt_connect(&mgr, url, &opts, mqtt_cb, buf);\n  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(buf[0] == 'X');\n  mg_mqtt_sub(c, &topic, 1);\n  mg_mqtt_pub(c, &topic, &data, 1, false);\n  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_tls_opts *topts = (struct mg_tls_opts *) fn_data;\n  if (ev == MG_EV_ACCEPT && topts != NULL) mg_tls_init(c, topts);\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    LOG(LL_INFO,\n        (\"[%.*s %.*s] message len %d\", (int) hm->method.len, hm->method.ptr,\n         (int) hm->uri.len, hm->uri.ptr, (int) hm->message.len));\n    if (mg_http_match_uri(hm, \"/foo/*\")) {\n      mg_http_reply(c, 200, \"\", \"uri: %.*s\", hm->uri.len - 5, hm->uri.ptr + 5);\n    } else if (mg_http_match_uri(hm, \"/ws\")) {\n      mg_ws_upgrade(c, hm, NULL);\n    } else if (mg_http_match_uri(hm, \"/body\")) {\n      mg_http_reply(c, 200, \"\", \"%.*s\", (int) hm->body.len, hm->body.ptr);\n    } else if (mg_http_match_uri(hm, \"/bar\")) {\n      mg_http_reply(c, 404, \"\", \"not found\");\n    } else if (mg_http_match_uri(hm, \"/no_reason\")) {\n      mg_printf(c, \"%s\", \"HTTP/1.0 200\\r\\nContent-Length: 2\\r\\n\\r\\nok\");\n    } else if (mg_http_match_uri(hm, \"/badroot\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"/BAAADDD!\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/creds\")) {\n      char user[100], pass[100];\n      mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass));\n      mg_http_reply(c, 200, \"\", \"[%s]:[%s]\", user, pass);\n    } else if (mg_http_match_uri(hm, \"/upload\")) {\n      mg_http_upload(c, hm, \".\");\n    } else if (mg_http_match_uri(hm, \"/test/\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \".\";\n      sopts.extra_headers = \"A: B\\r\\nC: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/servefile\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.mime_types = \"foo=a/b,txt=c/d\";\n      mg_http_serve_file(c, hm, \"test/data/a.txt\", &sopts);\n    } else {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"./test/data\";\n      sopts.ssi_pattern = \"#.shtml\";\n      sopts.extra_headers = \"C: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    }\n  } else if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->uri, mg_str(\"/ws\")) == 0);\n    mg_ws_send(c, \"opened\", 6, WEBSOCKET_OP_BINARY);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    mg_ws_send(c, wm->data.ptr, wm->data.len, WEBSOCKET_OP_BINARY);\n  }\n}\n\nstruct fetch_data {\n  char *buf;\n  int code, closed;\n};\n\nstatic void fcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct fetch_data *fd = (struct fetch_data *) fn_data;\n    snprintf(fd->buf, FETCH_BUF_SIZE, \"%.*s\", (int) hm->message.len,\n             hm->message.ptr);\n    fd->code = atoi(hm->uri.ptr);\n    fd->closed = 1;\n    c->is_closing = 1;\n    (void) c;\n  }\n}\n\nstatic int fetch(struct mg_mgr *mgr, char *buf, const char *url,\n                 const char *fmt, ...) {\n  struct fetch_data fd = {buf, 0, 0};\n  int i;\n  struct mg_connection *c = mg_http_connect(mgr, url, fcb, &fd);\n  va_list ap;\n  ASSERT(c != NULL);\n  if (mg_url_is_ssl(url)) {\n    struct mg_tls_opts opts;\n    struct mg_str host = mg_url_host(url);\n    memset(&opts, 0, sizeof(opts));\n    opts.ca = \"./test/data/ca.pem\";\n    if (strstr(url, \"127.0.0.1\") != NULL) {\n      // Local connection, use self-signed certificates\n      opts.ca = \"./test/data/ss_ca.pem\";\n      opts.cert = \"./test/data/ss_client.pem\";\n    } else {\n      opts.srvname = host;\n    }\n    mg_tls_init(c, &opts);\n    // c->is_hexdumping = 1;\n  }\n  va_start(ap, fmt);\n  mg_vprintf(c, fmt, ap);\n  va_end(ap);\n  buf[0] = '\\0';\n  for (i = 0; i < 250 && buf[0] == '\\0'; i++) mg_mgr_poll(mgr, 1);\n  if (!fd.closed) c->is_closing = 1;\n  mg_mgr_poll(mgr, 1);\n  return fd.code;\n}\n\nstatic int cmpbody(const char *buf, const char *str) {\n  struct mg_http_message hm;\n  struct mg_str s = mg_str(str);\n  size_t len = strlen(buf);\n  mg_http_parse(buf, len, &hm);\n  if (hm.body.len > len) hm.body.len = len - (size_t) (hm.body.ptr - buf);\n  return mg_strcmp(hm.body, s);\n}\n\nstatic bool cmpheader(const char *buf, const char *name, const char *value) {\n  struct mg_http_message hm;\n  struct mg_str *h;\n  size_t len = strlen(buf);\n  mg_http_parse(buf, len, &hm);\n  h = mg_http_get_header(&hm, name);\n  return h != NULL && mg_strcmp(*h, mg_str(value)) == 0;\n}\n\nstatic void wcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    ASSERT(wsproto != NULL);\n    mg_ws_send(c, \"boo\", 3, WEBSOCKET_OP_BINARY);\n    mg_ws_send(c, \"\", 0, WEBSOCKET_OP_PING);\n    ((int *) fn_data)[0] += 100;\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    if (mg_strstr(wm->data, mg_str(\"boo\")))\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    ((int *) fn_data)[0]++;\n  } else if (ev == MG_EV_CLOSE) {\n    ((int *) fn_data)[0] += 10;\n  }\n}\n\nstatic void test_ws(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"ws://LOCALHOST:12343/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, eh1, NULL) != NULL);\n  mg_ws_connect(&mgr, url, wcb, &done, \"%s\", \"Sec-WebSocket-Protocol: meh\\r\\n\");\n  for (i = 0; i < 30; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"--> %d\", done));\n  ASSERT(done == 112);\n\n  // Test that non-WS requests fail\n  ASSERT(fetch(&mgr, buf, url, \"GET /ws HTTP/1.0\\r\\n\\n\") == 426);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh9(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR) {\n    ASSERT(!strcmp((char *) ev_data, \"error connecting to 127.0.0.1:55117\"));\n    *(int *) fn_data = 7;\n  }\n  (void) c;\n}\n\nstatic void test_http_server(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12346\";\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh1, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /%%61.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  // Responses with missing reason phrase must also work\n  ASSERT(fetch(&mgr, buf, url, \"GET /no_reason HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"ok\") == 0);\n\n  // Fetch file with unicode chars in filename\n  ASSERT(fetch(&mgr, buf, url, \"GET /\u043a\u0438\u0457\u0432.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"\u0454\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /../fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e/fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e%%2ffuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2f%%20fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2ffuzz.c%%20 HTTP/1.0\\n\\n\") == 404);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir HTTP/1.0\\n\\n\") == 301);\n  ASSERT(cmpheader(buf, \"Location\", \"/dredir/\"));\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  {\n    extern char *mg_http_etag(char *, size_t, size_t, time_t);\n    char etag[100];\n    size_t size = 0;\n    time_t mtime = 0;\n    ASSERT(mg_fs_posix.stat(\"./test/data/a.txt\", &size, &mtime) != 0);\n    ASSERT(mg_http_etag(etag, sizeof(etag), size, mtime) == etag);\n    ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\nIf-None-Match: %s\\n\\n\",\n                 etag) == 304);\n  }\n\n  // Text mime type override\n  ASSERT(fetch(&mgr, buf, url, \"GET /servefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"), mg_str(\"c/d\")) ==\n           0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/1 HTTP/1.0\\r\\n\\n\") == 200);\n  // LOG(LL_INFO, (\"%d %.*s\", (int) hm.len, (int) hm.len, hm.buf));\n  ASSERT(cmpbody(buf, \"uri: 1\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"%s\",\n               \"POST /body HTTP/1.1\\r\\n\"\n               \"Content-Length: 4\\r\\n\\r\\nkuku\") == 200);\n  ASSERT(cmpbody(buf, \"kuku\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi HTTP/1.1\\r\\n\\r\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi/ HTTP/1.1\\r\\n\\r\\n\") == 200);\n  ASSERT(cmpbody(buf,\n                 \"this is index\\n\"\n                 \"this is nested\\n\\n\"\n                 \"this is f1\\n\\n\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Length\") != NULL);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/html; charset=utf-8\")) == 0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /badroot HTTP/1.0\\r\\n\\n\") == 400);\n  ASSERT(cmpbody(buf, \"Invalid web root [/BAAADDD!]\\n\") == 0);\n\n  {\n    char *data = mg_file_read(\"./test/data/ca.pem\", NULL);\n    ASSERT(fetch(&mgr, buf, url, \"GET /ca.pem HTTP/1.0\\r\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, data) == 0);\n    free(data);\n  }\n\n  {\n    // Test mime type\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"GET /empty.js HTTP/1.0\\r\\n\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/javascript; charset=utf-8\")) == 0);\n  }\n\n  {\n    // Test connection refused\n    int i, errored = 0;\n    mg_connect(&mgr, \"tcp://127.0.0.1:55117\", eh9, &errored);\n    for (i = 0; i < 10 && errored == 0; i++) mg_mgr_poll(&mgr, 1);\n    ASSERT(errored == 7);\n  }\n\n  // Directory listing\n  fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\");\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">Index of /test/<\")) != NULL);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">fuzz.c<\")) != NULL);\n\n  {\n    // Credentials\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds?access_token=x HTTP/1.0\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Bearer x\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[foo]:[bar]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Cookie: blah; access_token=hello\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[hello]\")) == 0);\n  }\n\n  {\n    // Test upload\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload HTTP/1.0\\n\"\n                 \"Content-Length: 1\\n\\nx\") == 400);\n\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt&offset=5 HTTP/1.0\\r\\n\"\n                 \"Content-Length: 6\\r\\n\"\n                 \"\\r\\n\\nworld\") == 200);\n    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\\nworld\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  {\n    // Test upload directory traversal\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  // HEAD request\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);\n\n#if MG_ENABLE_IPV6\n  {\n    const char *url6 = \"http://[::1]:12346\";\n    ASSERT(mg_http_listen(&mgr, url6, eh1, NULL) != NULL);\n    ASSERT(fetch(&mgr, buf, url6, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  }\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_tls(void) {\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  struct mg_tls_opts opts = {.ca = \"./test/data/ss_ca.pem\",\n                             .cert = \"./test/data/ss_server.pem\",\n                             .certkey = \"./test/data/ss_server.pem\"};\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  const char *url = \"https://127.0.0.1:12347\";\n  char buf[FETCH_BUF_SIZE];\n  mg_mgr_init(&mgr);\n  c = mg_http_listen(&mgr, url, eh1, (void *) &opts);\n  ASSERT(c != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  // LOG(LL_INFO, (\"%s\", buf));\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n#endif\n}\n\nstatic void f3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int *ok = (int *) fn_data;\n  // LOG(LL_INFO, (\"%d\", ev));\n  if (ev == MG_EV_CONNECT) {\n    // c->is_hexdumping = 1;\n    mg_printf(c, \"GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\",\n              c->peer.is_ip6 ? \"ipv6.google.com\" : \"cesanta.com\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    // LOG(LL_INFO, (\"-->[%.*s]\", (int) hm->message.len, hm->message.ptr));\n    // ASSERT(mg_vcmp(&hm->method, \"HTTP/1.1\") == 0);\n    // ASSERT(mg_vcmp(&hm->uri, \"301\") == 0);\n    *ok = atoi(hm->uri.ptr);\n  } else if (ev == MG_EV_CLOSE) {\n    if (*ok == 0) *ok = 888;\n  } else if (ev == MG_EV_ERROR) {\n    if (*ok == 0) *ok = 777;\n  }\n}\n\nstatic void test_http_client(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  c = mg_http_connect(&mgr, \"http://cesanta.com\", f3, &ok);\n  ASSERT(c != NULL);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 301);\n  c->is_closing = 1;\n  mg_mgr_poll(&mgr, 0);\n  ok = 0;\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  {\n    struct mg_tls_opts opts = {.ca = \"./test/data/ca.pem\"};\n    c = mg_http_connect(&mgr, \"https://cesanta.com\", f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n    ASSERT(ok == 200);\n  }\n#endif\n\n#if MG_ENABLE_IPV6\n  ok = 0;\n  // ipv6.google.com does not have IPv4 address, only IPv6, therefore\n  // it is guaranteed to hit IPv6 resolution path.\n  c = mg_http_connect(&mgr, \"http://ipv6.google.com\", f3, &ok);\n  ASSERT(c != NULL);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 200);\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_printf(c, \"HTTP/1.0 200 OK\\n\\n%.*s/%s\", (int) hm->uri.len, hm->uri.ptr,\n              fn_data);\n    c->is_draining = 1;\n  }\n}\n\nstatic void test_http_no_content_length(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12348\";\n  char buf[FETCH_BUF_SIZE];\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f4, (void *) \"baz\");\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/bar HTTP/1.0\\r\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"/foo/bar/baz\") == 0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_printf(c, \"HTTP/1.0 200 OK\\n\\n%.*s\", (int) hm->uri.len, hm->uri.ptr);\n    (*(int *) fn_data)++;\n  }\n}\n\nstatic void test_http_pipeline(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12377\";\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f5, (void *) &ok);\n  c = mg_http_connect(&mgr, url, NULL, NULL);\n  mg_printf(c, \"POST / HTTP/1.0\\nContent-Length: 5\\n\\n12345GET / HTTP/1.0\\n\\n\");\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"-----> [%d]\", ok));\n  ASSERT(ok == 2);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_http_parse(void) {\n  struct mg_str *v;\n  struct mg_http_message req;\n\n  {\n    const char *s = \"GET / HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(\"\\b23\", 3, &req) == -1);\n    ASSERT(mg_http_parse(\"get\\n\\n\", 5, &req) == -1);\n    ASSERT(mg_http_parse(s, strlen(s) - 1, &req) == 0);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.message.len == strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"GET /blah HTTP/1.0\\r\\nFoo:  bar  \\r\\n\\r\\n\";\n    size_t idx, len = strlen(s);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) len);\n    ASSERT(mg_vcmp(&req.headers[0].name, \"Foo\") == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"bar\") == 0);\n    ASSERT(req.headers[1].name.len == 0);\n    ASSERT(req.headers[1].name.ptr == NULL);\n    ASSERT(req.query.len == 0);\n    ASSERT(req.message.len == len);\n    ASSERT(req.body.len == 0);\n    for (idx = 0; idx < len; idx++) ASSERT(mg_http_parse(s, idx, &req) == 0);\n  }\n\n  {\n    static const char *s = \"get b c\\nz :  k \\nb: t\\nvvv\\n\\n xx\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.headers[2].name.len == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"k\") == 0);\n    ASSERT(mg_vcmp(&req.headers[1].value, \"t\") == 0);\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"a b c\\r\\nContent-Length: 21 \\r\\nb: t\\r\\nvvv\\r\\n\\r\\nabc\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.body.len == 21);\n    ASSERT(req.message.len == 21 - 3 + strlen(s));\n    ASSERT(mg_http_get_header(&req, \"foo\") == NULL);\n    ASSERT((v = mg_http_get_header(&req, \"contENT-Length\")) != NULL);\n    ASSERT(mg_vcmp(v, \"21\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"B\")) != NULL);\n    ASSERT(mg_vcmp(v, \"t\") == 0);\n  }\n\n  {\n    const char *s = \"GET /foo?a=b&c=d HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.uri, \"/foo\") == 0);\n    ASSERT(mg_vcmp(&req.query, \"a=b&c=d\") == 0);\n  }\n\n  {\n    const char *s = \"POST /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    const char *s = \"WOHOO /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"HTTP/1.0 200 OK\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.method, \"HTTP/1.0\") == 0);\n    ASSERT(mg_vcmp(&req.uri, \"200\") == 0);\n    ASSERT(mg_vcmp(&req.proto, \"OK\") == 0);\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    static const char *s = \"HTTP/1.0 999 OMGWTFBBQ\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n  }\n\n  {\n    const char *s =\n        \"GET / HTTP/1.0\\r\\nhost:127.0.0.1:18888\\r\\nCookie:\\r\\nX-PlayID: \"\n        \"45455\\r\\nRange:  0-1 \\r\\n\\r\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"Host\")) != NULL);\n    ASSERT(mg_vcmp(v, \"127.0.0.1:18888\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Cookie\")) != NULL);\n    ASSERT(v->len == 0);\n    ASSERT((v = mg_http_get_header(&req, \"X-PlayID\")) != NULL);\n    ASSERT(mg_vcmp(v, \"45455\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Range\")) != NULL);\n    ASSERT(mg_vcmp(v, \"0-1\") == 0);\n  }\n\n  {\n    static const char *s = \"a b c\\na:1\\nb:2\\nc:3\\nd:4\\ne:5\\nf:6\\ng:7\\nh:8\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"e\")) != NULL);\n    ASSERT(mg_vcmp(v, \"5\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"h\")) == NULL);\n  }\n\n  {\n    struct mg_connection c;\n    struct mg_str s,\n        res = mg_str(\"GET /\\r\\nAuthorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\");\n    memset(&c, 0, sizeof(c));\n    mg_printf(&c, \"%s\", \"GET /\\r\\n\");\n    mg_http_bauth(&c, \"foo\", \"bar\");\n    mg_printf(&c, \"%s\", \"\\r\\n\");\n    s = mg_str_n((char *) c.send.buf, c.send.len);\n    ASSERT(mg_strcmp(s, res) == 0);\n    mg_iobuf_free(&c.send);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"GET /foo?bar=baz HTTP/1.0\\n\\n \";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s) - 1);\n    ASSERT(mg_strcmp(hm.uri, mg_str(\"/foo\")) == 0);\n    ASSERT(mg_strcmp(hm.query, mg_str(\"bar=baz\")) == 0);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"a b c\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a b\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a\\nb\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) < 0);\n  }\n}\n\nstatic void ehr(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_range(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12349\";\n  struct mg_http_message hm;\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, ehr, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /range.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(hm.body.len == 312);\n\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=5-10\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.proto, mg_str(\"Partial Content\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\" of co\")) == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes 5-10/312\")) == 0);\n\n  // Fetch till EOF\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=300-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\"is disease.\\n\")) == 0);\n  // LOG(LL_INFO, (\"----%d\\n[%s]\", (int) hm.body.len, buf));\n\n  // Fetch past EOF, must trigger 416 response\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=999-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n  ASSERT(hm.body.len == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes */312\")) == 0);\n\n  fetch(&mgr, buf, url, \"%s\",\n        \"GET /range.txt HTTP/1.0\\nRange: bytes=0-312\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f1(void *arg) {\n  (*(int *) arg)++;\n}\n\nstatic void test_timer(void) {\n  int v1 = 0, v2 = 0, v3 = 0;\n  struct mg_timer t1, t2, t3;\n\n  LOG(LL_INFO, (\"g_timers: %p\", g_timers));\n  ASSERT(g_timers == NULL);\n\n  mg_timer_init(&t1, 5, MG_TIMER_REPEAT, f1, &v1);\n  mg_timer_init(&t2, 15, 0, f1, &v2);\n  mg_timer_init(&t3, 10, MG_TIMER_REPEAT | MG_TIMER_RUN_NOW, f1, &v3);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t2);\n\n  mg_timer_poll(0);\n  mg_timer_poll(1);\n  ASSERT(v1 == 0);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  mg_timer_poll(5);\n  ASSERT(v1 == 1);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t2);\n\n  // Simulate long delay - timers must invalidate expiration times\n  mg_timer_poll(100);\n  ASSERT(v1 == 2);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t1);  // t2 should be removed\n  ASSERT(g_timers->next->next == NULL);\n\n  mg_timer_poll(107);\n  ASSERT(v1 == 3);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  mg_timer_poll(114);\n  ASSERT(v1 == 4);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_poll(115);\n  ASSERT(v1 == 5);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_init(&t2, 3, 0, f1, &v2);\n  ASSERT(g_timers == &t2);\n  ASSERT(g_timers->next == &t3);\n  ASSERT(g_timers->next->next == &t1);\n  ASSERT(g_timers->next->next->next == NULL);\n\n  mg_timer_poll(120);\n  ASSERT(v1 == 6);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(125);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  // Test millisecond counter wrap - when time goes back.\n  mg_timer_poll(0);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == &t1);\n  ASSERT(g_timers->next->next == NULL);\n\n  mg_timer_poll(7);\n  ASSERT(v1 == 8);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(11);\n  ASSERT(v1 == 9);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 5);\n\n  mg_timer_free(&t1);\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == NULL);\n\n  mg_timer_free(&t2);\n  ASSERT(g_timers == &t3);\n  ASSERT(g_timers->next == NULL);\n\n  mg_timer_free(&t3);\n  ASSERT(g_timers == NULL);\n}\n\nstatic void test_str(void) {\n  struct mg_str s = mg_strdup(mg_str(\"a\"));\n  ASSERT(mg_strcmp(s, mg_str(\"a\")) == 0);\n  free((void *) s.ptr);\n  ASSERT(mg_strcmp(mg_str(\"\"), mg_str(NULL)) == 0);\n  ASSERT(mg_strcmp(mg_str(\"a\"), mg_str(\"b\")) < 0);\n  ASSERT(mg_strcmp(mg_str(\"b\"), mg_str(\"a\")) > 0);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"d\")) == NULL);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"b\")) != NULL);\n  ASSERT(mg_strcmp(mg_str(\"hi\"), mg_strstrip(mg_str(\" \\thi\\r\\n\"))) == 0);\n}\n\nstatic void fn1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR) sprintf((char *) fn_data, \"%s\", (char *) ev_data);\n  (void) c;\n}\n\nstatic void test_dns_timeout(const char *dns_server_url, const char *errstr) {\n  // Test timeout\n  struct mg_mgr mgr;\n  char buf[100] = \"\";\n  int i;\n  mg_mgr_init(&mgr);\n  mgr.dns4.url = dns_server_url;\n  mgr.dnstimeout = 10;\n  LOG(LL_DEBUG, (\"opening dummy DNS listener...\"));\n  mg_listen(&mgr, mgr.dns4.url, NULL, NULL);  // Just discard our queries\n  mg_http_connect(&mgr, \"http://google.com\", fn1, buf);\n  for (i = 0; i < 50 && buf[0] == '\\0'; i++) mg_mgr_poll(&mgr, 1);\n  mg_mgr_free(&mgr);\n  LOG(LL_DEBUG, (\"buf: [%s]\", buf));\n  ASSERT(strcmp(buf, errstr) == 0);\n}\n\nstatic void test_dns(void) {\n  struct mg_dns_message dm;\n  //       txid  flags numQ  numA  numAP numOP\n  // 0000  00 01 81 80 00 01 00 01 00 00 00 00 07 63 65 73  .............ces\n  // 0010  61 6e 74 61 03 63 6f 6d 00 00 01 00 01 c0 0c 00  anta.com........\n  // 0020  01 00 01 00 00 02 57 00 04 94 fb 36 ec           ......W....6.\n  uint8_t data[] = {0,    1,    0x81, 0x80, 0,    1,    0,    1,    0,\n                    0,    0,    0,    7,    0x63, 0x65, 0x73, 0x61, 0x6e,\n                    0x74, 0x61, 0x03, 0x63, 0x6f, 0x6d, 0,    0,    1,\n                    0,    1,    0xc0, 0x0c, 0,    1,    0,    1,    0,\n                    0,    2,    0x57, 0,    4,    0x94, 0xfb, 0x36, 0xec};\n  ASSERT(mg_dns_parse(NULL, 0, &dm) == 0);\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"cesanta.com\") == 0);\n  data[30] = 29;  // Point a pointer to itself\n  memset(&dm, 0, sizeof(dm));\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"\") == 0);\n\n  test_dns_timeout(\"udp://127.0.0.1:12345\", \"DNS timeout\");\n  test_dns_timeout(\"\", \"resolver\");\n  test_dns_timeout(\"tcp://0.0.0.0:0\", \"DNS error\");\n}\n\nstatic void test_util(void) {\n  char buf[100], *s = mg_hexdump(\"abc\", 3), *p;\n  struct mg_addr a;\n  ASSERT(s != NULL);\n  free(s);\n  memset(&a, 0, sizeof(a));\n  ASSERT(mg_file_printf(\"data.txt\", \"%s\", \"hi\") == true);\n  ASSERT((p = mg_file_read(\"data.txt\", NULL)) != NULL);\n  ASSERT(strcmp(p, \"hi\") == 0);\n  free(p);\n  remove(\"data.txt\");\n  ASSERT(mg_aton(mg_str(\"0\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.256\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.-1\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"127.0.0.1\"), &a) == true);\n  ASSERT(a.is_ip6 == false);\n  ASSERT(a.ip == 0x100007f);\n  ASSERT(strcmp(mg_ntoa(&a, buf, sizeof(buf)), \"127.0.0.1\") == 0);\n\n  ASSERT(mg_aton(mg_str(\"1:2:3:4:5:6:7:8\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00\\x07\\x00\\x08\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::fFff:1.2.3.4\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(memcmp(a.ip6,\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                \"\\x00\\x00\\xff\\xff\\x01\\x02\\x03\\x04\",\n                sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"2001:4860:4860::8888\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x20\\x01\\x48\\x60\\x48\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x88\\x88\",\n             sizeof(a.ip6)) == 0);\n\n  ASSERT(strcmp(mg_hex(\"abc\", 3, buf), \"616263\") == 0);\n  ASSERT(mg_url_decode(\"a=%\", 3, buf, sizeof(buf), 0) < 0);\n  ASSERT(mg_url_decode(\"&&&a=%\", 6, buf, sizeof(buf), 0) < 0);\n\n  {\n    size_t n;\n    ASSERT((n = mg_url_encode(\"\", 0, buf, sizeof(buf))) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, 0)) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, sizeof(buf))) == 1);\n    ASSERT(strncmp(buf, \"a\", n) == 0);\n    ASSERT((n = mg_url_encode(\"._-~\", 4, buf, sizeof(buf))) == 4);\n    ASSERT(strncmp(buf, \"._-~\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@%>\", 4, buf, sizeof(buf))) == 10);\n    ASSERT(strncmp(buf, \"a%40%25%3e\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@b.c\", 5, buf, sizeof(buf))) == 7);\n    ASSERT(strncmp(buf, \"a%40b.c\", n) == 0);\n  }\n\n  {\n    s = buf;\n    mg_asprintf(&s, sizeof(buf), \"%s\", \"%3d\", 123);\n    ASSERT(s == buf);\n    ASSERT(strcmp(buf, \"%3d\") == 0);\n    mg_asprintf(&s, sizeof(buf), \"%.*s\", 7, \"a%40b.c\");\n    ASSERT(s == buf);\n    ASSERT(strcmp(buf, \"a%40b.c\") == 0);\n  }\n\n  ASSERT(mg_to64(mg_str(\"-9223372036854775809\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775800\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775700\")) > 0);\n}\n\nstatic void test_crc32(void) {\n  //  echo -n aaa | cksum -o3\n  ASSERT(mg_crc32(0, 0, 0) == 0);\n  ASSERT(mg_crc32(0, \"a\", 1) == 3904355907);\n  ASSERT(mg_crc32(0, \"abc\", 3) == 891568578);\n  ASSERT(mg_crc32(mg_crc32(0, \"ab\", 2), \"c\", 1) == 891568578);\n}\n\n#define LONG_CHUNK \"chunk with length taking up more than two hex digits\"\n\n// Streaming server event handler.\n// Send one chunk immediately, then drain, then send two chunks in one go\nstatic void eh2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_printf(c, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    mg_http_printf_chunk(c, LONG_CHUNK);\n    c->label[0] = 1;\n  } else if (ev == MG_EV_POLL) {\n    if (c->label[0] > 0 && c->send.len == 0) c->label[0]++;\n    if (c->label[0] > 10 && c->label[0] != 'x') {\n      mg_http_printf_chunk(c, \"chunk 1\");\n      mg_http_printf_chunk(c, \"chunk 2\");\n      mg_http_printf_chunk(c, \"\");\n      c->label[0] = 'x';\n    }\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\n// Non-streaming client event handler. Make sure we've got full body\nstatic void eh3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET / HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    // LOG(LL_INFO, (\"----> [%.*s]\", (int) hm->body.len, hm->body.ptr));\n    c->is_closing = 1;\n    *(uint32_t *) fn_data = mg_crc32(0, hm->body.ptr, hm->body.len);\n  }\n}\n\n// Streaming client event handler. Make sure we've got all chunks\nstatic void eh4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) c->label;\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET / HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->body.ptr, hm->body.len);\n    // LOG(LL_INFO, (\"MSG [%.*s]\", (int) hm->body.len, hm->body.ptr));\n    c->is_closing = 1;\n    *(uint32_t *) fn_data = *crc;\n  }\n  (void) ev_data;\n}\n\n// Streaming client event handler. Delete chunks as they arrive\nstatic void eh5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) c->label;\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET / HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    // LOG(LL_INFO, (\"CHUNK [%.*s]\", (int) hm->chunk.len, hm->chunk.ptr));\n    mg_http_delete_chunk(c, hm);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    c->is_closing = 1;\n    *(uint32_t *) fn_data = *crc;\n    // LOG(LL_INFO, (\"MSG [%.*s]\", (int) hm->body.len, hm->body.ptr));\n  }\n  (void) ev_data;\n}\n\nstatic void test_http_chunked(void) {\n  struct mg_mgr mgr;\n  const char *data, *url = \"http://127.0.0.1:12344\";\n  uint32_t i, done = 0;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh2, NULL);\n\n  mg_http_connect(&mgr, url, eh3, &done);\n  for (i = 0; i < 50 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(i < 50);\n  data = LONG_CHUNK \"chunk 1chunk 2\";\n  ASSERT(done == mg_crc32(0, data, strlen(data)));\n\n  done = 0;\n  mg_http_connect(&mgr, url, eh4, &done);\n  for (i = 0; i < 50 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  data = LONG_CHUNK LONG_CHUNK \"chunk 1chunk 2\" LONG_CHUNK \"chunk 1chunk 2\";\n  ASSERT(done == mg_crc32(0, data, strlen(data)));\n\n  done = 0;\n  mg_http_connect(&mgr, url, eh5, &done);\n  for (i = 0; i < 50 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  data = LONG_CHUNK \"chunk 1chunk 2\";\n  ASSERT(done == mg_crc32(0, data, strlen(data)));\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\n#undef LONG_CHUNK\n\nstatic void test_multipart(void) {\n  struct mg_http_part part;\n  size_t ofs;\n  const char *s =\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"val\\\"\\r\\n\"\n      \"\\r\\n\"\n      \"abc\\r\\ndef\\r\\n\"\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"foo\\\"; filename=\\\"a b.txt\\\"\\r\\n\"\n      \"Content-Type: text/plain\\r\\n\"\n      \"\\r\\n\"\n      \"hello world\\r\\n\"\n      \"\\r\\n\"\n      \"--xyz--\\r\\n\";\n  ASSERT(mg_http_next_multipart(mg_str(\"\"), 0, NULL) == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), 0, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"val\")) == 0);\n  // LOG(LL_INFO, (\"--> [%.*s]\", (int) part.body.len, part.body.ptr));\n  ASSERT(mg_strcmp(part.body, mg_str(\"abc\\r\\ndef\")) == 0);\n  ASSERT(part.filename.len == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), ofs, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"foo\")) == 0);\n  // LOG(LL_INFO, (\"--> [%.*s]\", (int) part.filename.len, part.filename.ptr));\n  ASSERT(mg_strcmp(part.filename, mg_str(\"a b.txt\")) == 0);\n  ASSERT(mg_strcmp(part.body, mg_str(\"hello world\\r\\n\")) == 0);\n  ASSERT(mg_http_next_multipart(mg_str(s), ofs, &part) == 0);\n}\n\nstatic void eh7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts sopts;\n    memset(&sopts, 0, sizeof(sopts));\n    sopts.root_dir = \"\";\n    sopts.fs = &mg_fs_packed;\n    mg_http_serve_dir(c, hm, &sopts);\n  }\n  (void) ev_data, (void) fn_data;\n}\n\nstatic void test_packed(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12351\";\n  char buf[FETCH_BUF_SIZE] = \"\", *data = mg_file_read(\"Makefile\", NULL);\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh7, NULL);\n\n  // Load top level file directly\n  ASSERT(fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // Load file deeper in the FS tree directly\n  data = mg_file_read(\"src/ssi.h\", NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /src/ssi.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // List root dir\n  ASSERT(fetch(&mgr, buf, url, \"GET / HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  // List nested dir\n  ASSERT(fetch(&mgr, buf, url, \"GET /test HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh6(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_READ) *(int *) fn_data = 1;\n  (void) c, (void) ev_data;\n}\n\nstatic void test_pipe(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  int i, done = 0;\n  mg_mgr_init(&mgr);\n  ASSERT((c = mg_mkpipe(&mgr, eh6, (void *) &done)) != NULL);\n  mg_mgr_wakeup(c);\n  for (i = 0; i < 10 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(done == 1);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void u1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    ((int *) fn_data)[0] += 1;\n    mg_send(c, \"hi\", 2);\n  } else if (ev == MG_EV_WRITE) {\n    ((int *) fn_data)[0] += 100;\n  } else if (ev == MG_EV_READ) {\n    ((int *) fn_data)[0] += 10;\n    mg_iobuf_free(&c->recv);\n  }\n  (void) ev_data;\n}\n\nstatic void test_udp(void) {\n  struct mg_mgr mgr;\n  const char *url = \"udp://127.0.0.1:12353\";\n  int i, done = 0;\n  mg_mgr_init(&mgr);\n  mg_listen(&mgr, url, u1, (void *) &done);\n  mg_connect(&mgr, url, u1, (void *) &done);\n  for (i = 0; i < 5; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"%d\", done));\n  ASSERT(done == 111);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_check_ip_acl(void) {\n  uint32_t ip = 0x01020304;\n  ASSERT(mg_check_ip_acl(mg_str(NULL), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"invalid\"), ip) == -1);\n  ASSERT(mg_check_ip_acl(mg_str(\"+hi\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"+//\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0\"), ip) == 0);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/8\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.2.3.4\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/16\"), ip) == 0);\n}\n\nstatic void w3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  LOG(LL_INFO, (\"ev %d\", ev));\n  if (ev == MG_EV_WS_OPEN) {\n    mg_ws_send(c, \"hi there!\", 9, WEBSOCKET_OP_TEXT);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    ASSERT(mg_strcmp(wm->data, mg_str(\"lebowski\")) == 0);\n    ((int *) fn_data)[0]++;\n  } else if (ev == MG_EV_CLOSE) {\n    ((int *) fn_data)[0] += 10;\n  }\n}\n\nstatic void w2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_str msg = mg_str_n(\"lebowski\", 8);\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_ws_upgrade(c, (struct mg_http_message *) ev_data, NULL);\n  } else if (ev == MG_EV_WS_OPEN) {\n    mg_ws_send(c, \"x\", 1, WEBSOCKET_OP_PONG);\n  } else if (ev == MG_EV_POLL && c->is_websocket) {\n    size_t ofs, n = (size_t) fn_data;\n    if (n < msg.len) {\n      // Send \"msg\" char by char using fragmented frames\n      // mg_ws_send() sets the FIN flag in the WS header. Clean it\n      // to send fragmented packet. Insert PONG messages between frames\n      uint8_t op = n == 0 ? WEBSOCKET_OP_TEXT : WEBSOCKET_OP_CONTINUE;\n      mg_ws_send(c, \":->\", 3, WEBSOCKET_OP_PING);\n      ofs = c->send.len;\n      mg_ws_send(c, &msg.ptr[n], 1, op);\n      if (n < msg.len - 1) c->send.buf[ofs] = op;  // Clear FIN flag\n      c->fn_data = (void *) (n + 1);               // Point to the next char\n    } else {\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    }\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    ASSERT(mg_strcmp(wm->data, mg_str(\"hi there!\")) == 0);\n  }\n}\n\nstatic void test_ws_fragmentation(void) {\n  const char *url = \"ws://localhost:12357/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, w2, NULL) != NULL);\n  mg_ws_connect(&mgr, url, w3, &done, \"%s\", \"Sec-WebSocket-Protocol: echo\\r\\n\");\n  for (i = 0; i < 25; i++) mg_mgr_poll(&mgr, 1);\n  // LOG(LL_INFO, (\"--> %d\", done));\n  ASSERT(done == 11);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void h7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data,/foo=./src\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_rewrites(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"http://LOCALHOST:12358\";\n  const char *expected = \"#define MG_VERSION \\\"\" MG_VERSION \"\\\"\\n\";\n  struct mg_mgr mgr;\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, h7, NULL) != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/version.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, expected) == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"-->[%s]\\n\", buf);\n  // exit(0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_get_header_var(void) {\n  struct mg_str empty = mg_str(\"\"), bar = mg_str(\"bar\"), baz = mg_str(\"baz\");\n  struct mg_str header = mg_str(\"Digest foo=\\\"bar\\\", blah,boo=baz, x=\\\"yy\\\"\");\n  struct mg_str yy = mg_str(\"yy\");\n  // struct mg_str x = mg_http_get_header_var(header, mg_str(\"x\"));\n  // LOG(LL_INFO, (\"--> [%d] [%d]\", (int) x.len, yy.len));\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(empty, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fooo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"blah\"))) == 0);\n  ASSERT(mg_strcmp(bar, mg_http_get_header_var(header, mg_str(\"foo\"))) == 0);\n  ASSERT(mg_strcmp(baz, mg_http_get_header_var(header, mg_str(\"boo\"))) == 0);\n  ASSERT(mg_strcmp(yy, mg_http_get_header_var(header, mg_str(\"x\"))) == 0);\n}\n\nint main(void) {\n  mg_log_set(\"3\");\n  test_get_header_var();\n  test_rewrites();\n  test_check_ip_acl();\n  test_udp();\n  test_pipe();\n  test_packed();\n  test_crc32();\n  test_multipart();\n  test_http_chunked();\n  test_http_parse();\n  test_util();\n  test_sntp();\n  test_dns();\n  test_str();\n  test_timer();\n  test_url();\n  test_iobuf();\n  test_commalist();\n  test_base64();\n  test_globmatch();\n  test_http_get_var();\n  test_tls();\n  test_ws();\n  test_ws_fragmentation();\n  test_http_server();\n  test_http_client();\n  test_http_no_content_length();\n  test_http_pipeline();\n  test_http_range();\n  test_mqtt();\n  printf(\"SUCCESS. Total tests: %d\\n\", s_num_tests);\n  return EXIT_SUCCESS;\n}\n"], "filenames": ["Makefile", "mongoose.c", "src/http.c", "test/unit_test.c"], "buggy_code_start_loc": [62, 1145, 381, 682], "buggy_code_end_loc": [63, 1681, 918, 696], "fixing_code_start_loc": [62, 1144, 380, 681], "fixing_code_end_loc": [63, 1682, 919, 711], "type": "CWE-552", "message": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.", "other": {"cve": {"id": "CVE-2022-25299", "sourceIdentifier": "report@snyk.io", "published": "2022-02-18T13:15:08.383", "lastModified": "2022-02-28T17:10:42.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder."}, {"lang": "es", "value": "Esto afecta al paquete cesanta/mongoose versiones anteriores a 7.6. Un manejo no seguro de los nombres de archivo durante la carga usando el m\u00e9todo mg_http_upload() puede permitir a atacantes escribir archivos en ubicaciones arbitrarias fuera de la carpeta de destino designada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesanta:mongoose:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.6", "matchCriteriaId": "9FF45156-8AFC-4999-A0C2-73DA71958ED8"}]}]}], "references": [{"url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-UNMANAGED-CESANTAMONGOOSE-2404180", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945"}}