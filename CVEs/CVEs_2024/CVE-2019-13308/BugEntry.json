{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF   OOO   U   U  RRRR   IIIII  EEEEE  RRRR                %\n%               F      O   O  U   U  R   R    I    E      R   R               %\n%               FFF    O   O  U   U  RRRR     I    EEE    RRRR                %\n%               F      O   O  U   U  R R      I    E      R R                 %\n%               F       OOO    UUU   R  R   IIIII  EEEEE  R  R                %\n%                                                                             %\n%                                                                             %\n%                MagickCore Discrete Fourier Transform Methods                %\n%                                                                             %\n%                              Software Design                                %\n%                                Sean Burke                                   %\n%                               Fred Weinhaus                                 %\n%                                   Cristy                                    %\n%                                 July 2009                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/fourier.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n#include <complex.h>\n#endif\n#include <fftw3.h>\n#if !defined(MAGICKCORE_HAVE_CABS)\n#define cabs(z)  (sqrt(z[0]*z[0]+z[1]*z[1]))\n#endif\n#if !defined(MAGICKCORE_HAVE_CARG)\n#define carg(z)  (atan2(cimag(z),creal(z)))\n#endif\n#if !defined(MAGICKCORE_HAVE_CIMAG)\n#define cimag(z)  (z[1])\n#endif\n#if !defined(MAGICKCORE_HAVE_CREAL)\n#define creal(z)  (z[0])\n#endif\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _FourierInfo\n{\n  PixelChannel\n    channel;\n\n  MagickBooleanType\n    modulus;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    center;\n} FourierInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o m p l e x I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ComplexImages() performs complex mathematics on an image sequence.\n%\n%  The format of the ComplexImages method is:\n%\n%      MagickBooleanType ComplexImages(Image *images,const ComplexOperator op,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A complex operator.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(images,complex_images,images->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) images->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) images->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(images); i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal(Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*(Ar[i]*Br[i]+Ai[i]*Bi[i]);\n            Ci[i]=gamma*(Ai[i]*Br[i]-Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt(Ar[i]*Ar[i]+Ai[i]*Ai[i]);\n            Ci[i]=atan2(Ai[i],Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*(Ar[i]*Br[i]-Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*(Ai[i]*Br[i]+Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F o r w a r d F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ForwardFourierTransformImage() implements the discrete Fourier transform\n%  (DFT) of the image either as a magnitude / phase or real / imaginary image\n%  pair.\n%\n%  The format of the ForwadFourierTransformImage method is:\n%\n%      Image *ForwardFourierTransformImage(const Image *image,\n%        const MagickBooleanType modulus,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o modulus: if true, return as transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n\nstatic MagickBooleanType RollFourier(const size_t width,const size_t height,\n  const ssize_t x_offset,const ssize_t y_offset,double *roll_pixels)\n{\n  double\n    *source_pixels;\n\n  MemoryInfo\n    *source_info;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Move zero frequency (DC, average color) from (0,0) to (width/2,height/2).\n  */\n  source_info=AcquireVirtualMemory(width,height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    return(MagickFalse);\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  i=0L;\n  for (y=0L; y < (ssize_t) height; y++)\n  {\n    if (y_offset < 0L)\n      v=((y+y_offset) < 0L) ? y+y_offset+(ssize_t) height : y+y_offset;\n    else\n      v=((y+y_offset) > ((ssize_t) height-1L)) ? y+y_offset-(ssize_t) height :\n        y+y_offset;\n    for (x=0L; x < (ssize_t) width; x++)\n    {\n      if (x_offset < 0L)\n        u=((x+x_offset) < 0L) ? x+x_offset+(ssize_t) width : x+x_offset;\n      else\n        u=((x+x_offset) > ((ssize_t) width-1L)) ? x+x_offset-(ssize_t) width :\n          x+x_offset;\n      source_pixels[v*width+u]=roll_pixels[i++];\n    }\n  }\n  (void) memcpy(roll_pixels,source_pixels,height*width*\n    sizeof(*source_pixels));\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}\n\nstatic void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}\n\nstatic MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,\n  Image *image,double *magnitude,double *phase,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  Image\n    *magnitude_image,\n    *phase_image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y;\n\n  magnitude_image=GetFirstImageInList(image);\n  phase_image=GetNextImageInList(image);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  /*\n    Create \"Fourier Transform\" image from constituent arrays.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  (void) memset(magnitude_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  (void) memset(phase_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*phase_pixels));\n  status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude,magnitude_pixels);\n  if (status != MagickFalse)\n    status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,phase,\n      phase_pixels);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]/=(2.0*MagickPI);\n          phase_pixels[i]+=0.5;\n          i++;\n        }\n    }\n  magnitude_view=AcquireAuthenticCacheView(magnitude_image,exception);\n  i=0L;\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(magnitude_image);\n    }\n    status=SyncCacheViewAuthenticPixels(magnitude_view,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  i=0L;\n  phase_view=AcquireAuthenticCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(phase_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(phase_image);\n    }\n    status=SyncCacheViewAuthenticPixels(phase_view,exception);\n    if (status == MagickFalse)\n      break;\n   }\n  phase_view=DestroyCacheView(phase_view);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n\nstatic MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,\n  const Image *image,double *magnitude_pixels,double *phase_pixels,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_complex\n    *forward_pixels;\n\n  fftw_plan\n    fftw_r2c_plan;\n\n  MemoryInfo\n    *forward_info,\n    *source_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Generate the forward Fourier transform.\n  */\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  memset(source_pixels,0,fourier_info->width*fourier_info->height*\n    sizeof(*source_pixels));\n  i=0L;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          source_pixels[i]=QuantumScale*GetPixelRed(image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelGreen(image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlue(image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlack(image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelAlpha(image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  forward_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*forward_pixels));\n  if (forward_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n      return(MagickFalse);\n    }\n  forward_pixels=(fftw_complex *) GetVirtualMemoryBlob(forward_info);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_ForwardFourierTransform)\n#endif\n  fftw_r2c_plan=fftw_plan_dft_r2c_2d(fourier_info->width,fourier_info->height,\n    source_pixels,forward_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_r2c(fftw_r2c_plan,source_pixels,forward_pixels);\n  fftw_destroy_plan(fftw_r2c_plan);\n  source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if ((value == (const char *) NULL) || (LocaleCompare(value,\"forward\") == 0))\n    {\n      double\n        gamma;\n\n      /*\n        Normalize fourier transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          forward_pixels[i]*=gamma;\n#else\n          forward_pixels[i][0]*=gamma;\n          forward_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n  /*\n    Generate magnitude and phase (or real and imaginary).\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=cabs(forward_pixels[i]);\n        phase_pixels[i]=carg(forward_pixels[i]);\n        i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=creal(forward_pixels[i]);\n        phase_pixels[i]=cimag(forward_pixels[i]);\n        i++;\n      }\n  forward_info=(MemoryInfo *) RelinquishVirtualMemory(forward_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardFourierTransformChannel(const Image *image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  fourier_info.width=image->columns;\n  fourier_info.height=image->rows;\n  if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n      ((image->rows % 2) != 0))\n    {\n      size_t extent=image->columns < image->rows ? image->rows : image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info == (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  status=ForwardFourierTransform(&fourier_info,image,magnitude_pixels,\n    phase_pixels,exception);\n  if (status != MagickFalse)\n    status=ForwardFourier(&fourier_info,fourier_image,magnitude_pixels,\n      phase_pixels,exception);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *ForwardFourierTransformImage(const Image *image,\n  const MagickBooleanType modulus,ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  fourier_image=NewImageList();\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    image->filename);\n#else\n  {\n    Image\n      *magnitude_image;\n\n    size_t\n      height,\n      width;\n\n    width=image->columns;\n    height=image->rows;\n    if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n        ((image->rows % 2) != 0))\n      {\n        size_t extent=image->columns < image->rows ? image->rows :\n          image->columns;\n        width=(extent & 0x01) == 1 ? extent+1UL : extent;\n      }\n    height=width;\n    magnitude_image=CloneImage(image,width,height,MagickTrue,exception);\n    if (magnitude_image != (Image *) NULL)\n      {\n        Image\n          *phase_image;\n\n        magnitude_image->storage_class=DirectClass;\n        magnitude_image->depth=32UL;\n        phase_image=CloneImage(image,width,height,MagickTrue,exception);\n        if (phase_image == (Image *) NULL)\n          magnitude_image=DestroyImage(magnitude_image);\n        else\n          {\n            MagickBooleanType\n              is_gray,\n              status;\n\n            phase_image->storage_class=DirectClass;\n            phase_image->depth=32UL;\n            AppendImageToList(&fourier_image,magnitude_image);\n            AppendImageToList(&fourier_image,phase_image);\n            status=MagickTrue;\n            is_gray=IsImageGray(image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel sections\n#endif\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                if (is_gray != MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GrayPixelChannel,modulus,fourier_image,exception);\n                else\n                  thread_status=ForwardFourierTransformChannel(image,\n                    RedPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GreenPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BluePixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->colorspace == CMYKColorspace)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BlackPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    AlphaPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n            }\n            if (status == MagickFalse)\n              fourier_image=DestroyImageList(fourier_image);\n            fftw_cleanup();\n          }\n      }\n  }\n#endif\n  return(fourier_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I n v e r s e F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InverseFourierTransformImage() implements the inverse discrete Fourier\n%  transform (DFT) of the image either as a magnitude / phase or real /\n%  imaginary image pair.\n%\n%  The format of the InverseFourierTransformImage method is:\n%\n%      Image *InverseFourierTransformImage(const Image *magnitude_image,\n%        const Image *phase_image,const MagickBooleanType modulus,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o magnitude_image: the magnitude or real image.\n%\n%    o phase_image: the phase or imaginary image.\n%\n%    o modulus: if true, return transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\nstatic MagickBooleanType InverseQuadrantSwap(const size_t width,\n  const size_t height,const double *source,double *destination)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  for (y=1L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L+1L); x++)\n      destination[(height-y)*center-x+width/2L]=source[y*width+x];\n  for (y=0L; y < (ssize_t) height; y++)\n    destination[y*center]=source[y*width+width/2L];\n  for (x=0L; x < center; x++)\n    destination[x]=source[center-x-1L];\n  return(RollFourier(center,height,0L,(ssize_t) height/-2L,destination));\n}\n\nstatic MagickBooleanType InverseFourier(FourierInfo *fourier_info,\n  const Image *magnitude_image,const Image *phase_image,\n  fftw_complex *fourier_pixels,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *inverse_pixels,\n    *magnitude_pixels,\n    *phase_pixels;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info,\n    *magnitude_info,\n    *phase_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Inverse fourier - read image and break down into a double array.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*inverse_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL) ||\n      (inverse_info == (MemoryInfo *) NULL))\n    {\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (inverse_info != (MemoryInfo *) NULL)\n        inverse_info=RelinquishVirtualMemory(inverse_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  inverse_pixels=(double *) GetVirtualMemoryBlob(inverse_info);\n  i=0L;\n  magnitude_view=AcquireVirtualCacheView(magnitude_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelRed(magnitude_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelGreen(magnitude_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlue(magnitude_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlack(magnitude_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelAlpha(magnitude_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(magnitude_image);\n    }\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude_pixels,inverse_pixels);\n  (void) memcpy(magnitude_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*magnitude_pixels));\n  i=0L;\n  phase_view=AcquireVirtualCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(phase_view,0,y,fourier_info->width,1,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelRed(phase_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelGreen(phase_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlue(phase_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlack(phase_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelAlpha(phase_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(phase_image);\n    }\n  }\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]-=0.5;\n          phase_pixels[i]*=(2.0*MagickPI);\n          i++;\n        }\n    }\n  phase_view=DestroyCacheView(phase_view);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (status != MagickFalse)\n    status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n      phase_pixels,inverse_pixels);\n  (void) memcpy(phase_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*phase_pixels));\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  /*\n    Merge two sets.\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n       for (x=0L; x < (ssize_t) fourier_info->center; x++)\n       {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n         fourier_pixels[i]=magnitude_pixels[i]*cos(phase_pixels[i])+I*\n           magnitude_pixels[i]*sin(phase_pixels[i]);\n#else\n         fourier_pixels[i][0]=magnitude_pixels[i]*cos(phase_pixels[i]);\n         fourier_pixels[i][1]=magnitude_pixels[i]*sin(phase_pixels[i]);\n#endif\n         i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n        fourier_pixels[i]=magnitude_pixels[i]+I*phase_pixels[i];\n#else\n        fourier_pixels[i][0]=magnitude_pixels[i];\n        fourier_pixels[i][1]=phase_pixels[i];\n#endif\n        i++;\n      }\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  return(status);\n}\n\nstatic MagickBooleanType InverseFourierTransform(FourierInfo *fourier_info,\n  fftw_complex *fourier_pixels,Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_plan\n    fftw_c2r_plan;\n\n  MemoryInfo\n    *source_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if (LocaleCompare(value,\"inverse\") == 0)\n    {\n      double\n        gamma;\n\n      /*\n        Normalize inverse transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          fourier_pixels[i]*=gamma;\n#else\n          fourier_pixels[i][0]*=gamma;\n          fourier_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_InverseFourierTransform)\n#endif\n  fftw_c2r_plan=fftw_plan_dft_c2r_2d(fourier_info->width,fourier_info->height,\n    fourier_pixels,source_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_c2r(fftw_c2r_plan,fourier_pixels,source_pixels);\n  fftw_destroy_plan(fftw_c2r_plan);\n  i=0L;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    if (y >= (ssize_t) image->rows)\n      break;\n    q=GetCacheViewAuthenticPixels(image_view,0L,y,fourier_info->width >\n      image->columns ? image->columns : fourier_info->width,1UL,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        switch (fourier_info->channel)\n        {\n          case RedPixelChannel:\n          default:\n          {\n            SetPixelRed(image,ClampToQuantum(QuantumRange*source_pixels[i]),q);\n            break;\n          }\n          case GreenPixelChannel:\n          {\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BluePixelChannel:\n          {\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BlackPixelChannel:\n          {\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case AlphaPixelChannel:\n          {\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n        }\n      i++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *InverseFourierTransformImage(const Image *magnitude_image,\n  const Image *phase_image,const MagickBooleanType modulus,\n  ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  assert(magnitude_image != (Image *) NULL);\n  assert(magnitude_image->signature == MagickCoreSignature);\n  if (magnitude_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      magnitude_image->filename);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",magnitude_image->filename);\n      return((Image *) NULL);\n    }\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  fourier_image=(Image *) NULL;\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    magnitude_image->filename);\n#else\n  {\n    fourier_image=CloneImage(magnitude_image,magnitude_image->columns,\n      magnitude_image->rows,MagickTrue,exception);\n    if (fourier_image != (Image *) NULL)\n      {\n        MagickBooleanType\n          is_gray,\n          status;\n\n        status=MagickTrue;\n        is_gray=IsImageGray(magnitude_image);\n        if (is_gray != MagickFalse)\n          is_gray=IsImageGray(phase_image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp parallel sections\n#endif\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            if (is_gray != MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GrayPixelChannel,modulus,fourier_image,exception);\n            else\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,RedPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GreenPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BluePixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->colorspace == CMYKColorspace)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BlackPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->alpha_trait != UndefinedPixelTrait)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,AlphaPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n        }\n        if (status == MagickFalse)\n          fourier_image=DestroyImage(fourier_image);\n      }\n    fftw_cleanup();\n  }\n#endif\n  return(fourier_image);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             GGGG  IIIII  FFFFF                              %\n%                            G        I    F                                  %\n%                            G  GG    I    FFF                                %\n%                            G   G    I    F                                  %\n%                             GGG   IIIII  F                                  %\n%                                                                             %\n%                                                                             %\n%            Read/Write Compuserv Graphics Interchange Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Define declarations.\n*/\n#define MaximumLZWBits  12\n#define MaximumLZWCode  (1UL << MaximumLZWBits)\n\f\n/*\n  Typdef declarations.\n*/\ntypedef struct _LZWCodeInfo\n{\n  unsigned char\n    buffer[280];\n\n  size_t\n    count,\n    bit;\n\n  MagickBooleanType\n    eof;\n} LZWCodeInfo;\n\ntypedef struct _LZWStack\n{\n  size_t\n    *codes,\n    *index,\n    *top;\n} LZWStack;\n\ntypedef struct _LZWInfo\n{\n  Image\n    *image;\n\n  LZWStack\n    *stack;\n\n  MagickBooleanType\n    genesis;\n\n  size_t\n    data_size,\n    maximum_data_value,\n    clear_code,\n    end_code,\n    bits,\n    first_code,\n    last_code,\n    maximum_code,\n    slot,\n    *table[2];\n\n  LZWCodeInfo\n    code_info;\n} LZWInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic inline int\n  GetNextLZWCode(LZWInfo *,const size_t);\n\nstatic MagickBooleanType\n  WriteGIFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic ssize_t\n  ReadBlobBlock(Image *,unsigned char *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage uncompresses an image via GIF-coding.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,const ssize_t opacity)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o opacity:  The colormap index associated with the transparent color.\n%\n*/\n\nstatic LZWInfo *RelinquishLZWInfo(LZWInfo *lzw_info)\n{\n  if (lzw_info->table[0] != (size_t *) NULL)\n    lzw_info->table[0]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[0]);\n  if (lzw_info->table[1] != (size_t *) NULL)\n    lzw_info->table[1]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[1]);\n  if (lzw_info->stack != (LZWStack *) NULL)\n    {\n      if (lzw_info->stack->codes != (size_t *) NULL)\n        lzw_info->stack->codes=(size_t *) RelinquishMagickMemory(\n          lzw_info->stack->codes);\n      lzw_info->stack=(LZWStack *) RelinquishMagickMemory(lzw_info->stack);\n    }\n  lzw_info=(LZWInfo *) RelinquishMagickMemory(lzw_info);\n  return((LZWInfo *) NULL);\n}\n\nstatic inline void ResetLZWInfo(LZWInfo *lzw_info)\n{\n  size_t\n    one;\n\n  lzw_info->bits=lzw_info->data_size+1;\n  one=1;\n  lzw_info->maximum_code=one << lzw_info->bits;\n  lzw_info->slot=lzw_info->maximum_data_value+3;\n  lzw_info->genesis=MagickTrue;\n}\n\nstatic LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)\n{\n  LZWInfo\n    *lzw_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  lzw_info=(LZWInfo *) AcquireMagickMemory(sizeof(*lzw_info));\n  if (lzw_info == (LZWInfo *) NULL)\n    return((LZWInfo *) NULL);\n  (void) memset(lzw_info,0,sizeof(*lzw_info));\n  lzw_info->image=image;\n  lzw_info->data_size=data_size;\n  one=1;\n  lzw_info->maximum_data_value=(one << data_size)-1;\n  lzw_info->clear_code=lzw_info->maximum_data_value+1;\n  lzw_info->end_code=lzw_info->maximum_data_value+2;\n  lzw_info->table[0]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  lzw_info->table[1]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  if ((lzw_info->table[0] == (size_t *) NULL) ||\n      (lzw_info->table[1] == (size_t *) NULL))\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  (void) memset(lzw_info->table[0],0,MaximumLZWCode*\n    sizeof(**lzw_info->table));\n  (void) memset(lzw_info->table[1],0,MaximumLZWCode*\n    sizeof(**lzw_info->table));\n  for (i=0; i <= (ssize_t) lzw_info->maximum_data_value; i++)\n  {\n    lzw_info->table[0][i]=0;\n    lzw_info->table[1][i]=(size_t) i;\n  }\n  ResetLZWInfo(lzw_info);\n  lzw_info->code_info.buffer[0]='\\0';\n  lzw_info->code_info.buffer[1]='\\0';\n  lzw_info->code_info.count=2;\n  lzw_info->code_info.bit=8*lzw_info->code_info.count;\n  lzw_info->code_info.eof=MagickFalse;\n  lzw_info->genesis=MagickTrue;\n  lzw_info->stack=(LZWStack *) AcquireMagickMemory(sizeof(*lzw_info->stack));\n  if (lzw_info->stack == (LZWStack *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->codes=(size_t *) AcquireQuantumMemory(2UL*\n    MaximumLZWCode,sizeof(*lzw_info->stack->codes));\n  if (lzw_info->stack->codes == (size_t *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->index=lzw_info->stack->codes;\n  lzw_info->stack->top=lzw_info->stack->codes+2*MaximumLZWCode;\n  return(lzw_info);\n}\n\nstatic inline int GetNextLZWCode(LZWInfo *lzw_info,const size_t bits)\n{\n  int\n    code;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  while (((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count)) &&\n         (lzw_info->code_info.eof == MagickFalse))\n  {\n    ssize_t\n      count;\n\n    lzw_info->code_info.buffer[0]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-2];\n    lzw_info->code_info.buffer[1]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-1];\n    lzw_info->code_info.bit-=8*(lzw_info->code_info.count-2);\n    lzw_info->code_info.count=2;\n    count=ReadBlobBlock(lzw_info->image,&lzw_info->code_info.buffer[\n      lzw_info->code_info.count]);\n    if (count > 0)\n      lzw_info->code_info.count+=count;\n    else\n      lzw_info->code_info.eof=MagickTrue;\n  }\n  if ((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count))\n    return(-1);\n  code=0;\n  one=1;\n  for (i=0; i < (ssize_t) bits; i++)\n  {\n    code|=((lzw_info->code_info.buffer[lzw_info->code_info.bit/8] &\n      (one << (lzw_info->code_info.bit % 8))) != 0) << i;\n    lzw_info->code_info.bit++;\n  }\n  return(code);\n}\n\nstatic inline int PopLZWStack(LZWStack *stack_info)\n{\n  if (stack_info->index <= stack_info->codes)\n    return(-1);\n  stack_info->index--;\n  return((int) *stack_info->index);\n}\n\nstatic inline void PushLZWStack(LZWStack *stack_info,const size_t value)\n{\n  if (stack_info->index >= stack_info->top)\n    return;\n  *stack_info->index=value;\n  stack_info->index++;\n}\n\nstatic int ReadBlobLZWByte(LZWInfo *lzw_info)\n{\n  int\n    code;\n\n  size_t\n    one,\n    value;\n\n  ssize_t\n    count;\n\n  if (lzw_info->stack->index != lzw_info->stack->codes)\n    return(PopLZWStack(lzw_info->stack));\n  if (lzw_info->genesis != MagickFalse)\n    {\n      lzw_info->genesis=MagickFalse;\n      do\n      {\n        lzw_info->first_code=(size_t) GetNextLZWCode(lzw_info,lzw_info->bits);\n        lzw_info->last_code=lzw_info->first_code;\n      } while (lzw_info->first_code == lzw_info->clear_code);\n      return((int) lzw_info->first_code);\n    }\n  code=GetNextLZWCode(lzw_info,lzw_info->bits);\n  if (code < 0)\n    return(code);\n  if ((size_t) code == lzw_info->clear_code)\n    {\n      ResetLZWInfo(lzw_info);\n      return(ReadBlobLZWByte(lzw_info));\n    }\n  if ((size_t) code == lzw_info->end_code)\n    return(-1);\n  if ((size_t) code < lzw_info->slot)\n    value=(size_t) code;\n  else\n    {\n      PushLZWStack(lzw_info->stack,lzw_info->first_code);\n      value=lzw_info->last_code;\n    }\n  count=0;\n  while (value > lzw_info->maximum_data_value)\n  {\n    if ((size_t) count > MaximumLZWCode)\n      return(-1);\n    count++;\n    if ((size_t) value > MaximumLZWCode)\n      return(-1);\n    PushLZWStack(lzw_info->stack,lzw_info->table[1][value]);\n    value=lzw_info->table[0][value];\n  }\n  lzw_info->first_code=lzw_info->table[1][value];\n  PushLZWStack(lzw_info->stack,lzw_info->first_code);\n  one=1;\n  if (lzw_info->slot < MaximumLZWCode)\n    {\n      lzw_info->table[0][lzw_info->slot]=lzw_info->last_code;\n      lzw_info->table[1][lzw_info->slot]=lzw_info->first_code;\n      lzw_info->slot++;\n      if ((lzw_info->slot >= lzw_info->maximum_code) &&\n          (lzw_info->bits < MaximumLZWBits))\n        {\n          lzw_info->bits++;\n          lzw_info->maximum_code=one << lzw_info->bits;\n        }\n    }\n  lzw_info->last_code=(size_t) code;\n  return(PopLZWStack(lzw_info->stack));\n}\n\nstatic MagickBooleanType DecodeImage(Image *image,const ssize_t opacity,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  LZWInfo\n    *lzw_info;\n\n  size_t\n    pass;\n\n  ssize_t\n    index,\n    offset,\n    y;\n\n  unsigned char\n    data_size;\n\n  /*\n    Allocate decoder tables.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  data_size=(unsigned char) ReadBlobByte(image);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  lzw_info=AcquireLZWInfo(image,data_size);\n  if (lzw_info == (LZWInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  pass=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; )\n    {\n      c=ReadBlobLZWByte(lzw_info);\n      if (c < 0)\n        break;\n      index=ConstrainColormapIndex(image,(ssize_t) c,exception);\n      SetPixelIndex(image,(Quantum) index,q);\n      SetPixelViaPixelInfo(image,image->colormap+index,q);\n      SetPixelAlpha(image,index == opacity ? TransparentAlpha : OpaqueAlpha,q);\n      x++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (x < (ssize_t) image->columns)\n      break;\n    if (image->interlace == NoInterlace)\n      offset++;\n    else\n      {\n        switch (pass)\n        {\n          case 0:\n          default:\n          {\n            offset+=8;\n            break;\n          }\n          case 1:\n          {\n            offset+=8;\n            break;\n          }\n          case 2:\n          {\n            offset+=4;\n            break;\n          }\n          case 3:\n          {\n            offset+=2;\n            break;\n          }\n        }\n      if ((pass == 0) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=4;\n        }\n      if ((pass == 1) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=2;\n        }\n      if ((pass == 2) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=1;\n        }\n    }\n  }\n  lzw_info=RelinquishLZWInfo(lzw_info);\n  if (y < (ssize_t) image->rows)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses an image via GIF-coding.\n%\n%  The format of the EncodeImage method is:\n%\n%      MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n%        const size_t data_size)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the address of a structure of type Image.\n%\n%    o data_size:  The number of bits in the compressed packet.\n%\n*/\nstatic MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n  const size_t data_size,ExceptionInfo *exception)\n{\n#define MaxCode(number_bits)  ((one << (number_bits))-1)\n#define MaxHashTable  5003\n#define MaxGIFBits  12UL\n#define MaxGIFTable  (1UL << MaxGIFBits)\n#define GIFOutputCode(code) \\\n{ \\\n  /*  \\\n    Emit a code. \\\n  */ \\\n  if (bits > 0) \\\n    datum|=(size_t) (code) << bits; \\\n  else \\\n    datum=(size_t) (code); \\\n  bits+=number_bits; \\\n  while (bits >= 8) \\\n  { \\\n    /*  \\\n      Add a character to current packet. \\\n    */ \\\n    packet[length++]=(unsigned char) (datum & 0xff); \\\n    if (length >= 254) \\\n      { \\\n        (void) WriteBlobByte(image,(unsigned char) length); \\\n        (void) WriteBlob(image,length,packet); \\\n        length=0; \\\n      } \\\n    datum>>=8; \\\n    bits-=8; \\\n  } \\\n  if (free_code > max_code)  \\\n    { \\\n      number_bits++; \\\n      if (number_bits == MaxGIFBits) \\\n        max_code=MaxGIFTable; \\\n      else \\\n        max_code=MaxCode(number_bits); \\\n    } \\\n}\n\n  Quantum\n    index;\n\n  short\n    *hash_code,\n    *hash_prefix,\n    waiting_code;\n\n  size_t\n    bits,\n    clear_code,\n    datum,\n    end_of_information_code,\n    free_code,\n    length,\n    max_code,\n    next_pixel,\n    number_bits,\n    one,\n    pass;\n\n  ssize_t\n    displacement,\n    offset,\n    k,\n    y;\n\n  unsigned char\n    *packet,\n    *hash_suffix;\n\n  /*\n    Allocate encoder tables.\n  */\n  assert(image != (Image *) NULL);\n  one=1;\n  packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));\n  hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));\n  hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));\n  hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,\n    sizeof(*hash_suffix));\n  if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||\n      (hash_prefix == (short *) NULL) ||\n      (hash_suffix == (unsigned char *) NULL))\n    {\n      if (packet != (unsigned char *) NULL)\n        packet=(unsigned char *) RelinquishMagickMemory(packet);\n      if (hash_code != (short *) NULL)\n        hash_code=(short *) RelinquishMagickMemory(hash_code);\n      if (hash_prefix != (short *) NULL)\n        hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n      if (hash_suffix != (unsigned char *) NULL)\n        hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n      return(MagickFalse);\n    }\n  /*\n    Initialize GIF encoder.\n  */\n  (void) memset(packet,0,256*sizeof(*packet));\n  (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));\n  (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));\n  (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));\n  number_bits=data_size;\n  max_code=MaxCode(number_bits);\n  clear_code=((short) one << (data_size-1));\n  end_of_information_code=clear_code+1;\n  free_code=clear_code+2;\n  length=0;\n  datum=0;\n  bits=0;\n  GIFOutputCode(clear_code);\n  /*\n    Encode pixels.\n  */\n  offset=0;\n  pass=0;\n  waiting_code=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,offset,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (y == 0)\n      {\n        waiting_code=(short) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n    for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Probe hash table.\n      */\n      index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);\n      p+=GetPixelChannels(image);\n      k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n      if (k >= MaxHashTable)\n        k-=MaxHashTable;\n      next_pixel=MagickFalse;\n      displacement=1;\n      if (hash_code[k] > 0)\n        {\n          if ((hash_prefix[k] == waiting_code) &&\n              (hash_suffix[k] == (unsigned char) index))\n            {\n              waiting_code=hash_code[k];\n              continue;\n            }\n          if (k != 0)\n            displacement=MaxHashTable-k;\n          for ( ; ; )\n          {\n            k-=displacement;\n            if (k < 0)\n              k+=MaxHashTable;\n            if (hash_code[k] == 0)\n              break;\n            if ((hash_prefix[k] == waiting_code) &&\n                (hash_suffix[k] == (unsigned char) index))\n              {\n                waiting_code=hash_code[k];\n                next_pixel=MagickTrue;\n                break;\n              }\n          }\n          if (next_pixel != MagickFalse)\n            continue;\n        }\n      GIFOutputCode(waiting_code);\n      if (free_code < MaxGIFTable)\n        {\n          hash_code[k]=(short) free_code++;\n          hash_prefix[k]=waiting_code;\n          hash_suffix[k]=(unsigned char) index;\n        }\n      else\n        {\n          /*\n            Fill the hash table with empty entries.\n          */\n          for (k=0; k < MaxHashTable; k++)\n            hash_code[k]=0;\n          /*\n            Reset compressor and issue a clear code.\n          */\n          free_code=clear_code+2;\n          GIFOutputCode(clear_code);\n          number_bits=data_size;\n          max_code=MaxCode(number_bits);\n        }\n      waiting_code=(short) index;\n    }\n    if (image_info->interlace == NoInterlace)\n      offset++;\n    else\n      switch (pass)\n      {\n        case 0:\n        default:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=4;\n            }\n          break;\n        }\n        case 1:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=2;\n            }\n          break;\n        }\n        case 2:\n        {\n          offset+=4;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=1;\n            }\n          break;\n        }\n        case 3:\n        {\n          offset+=2;\n          break;\n        }\n      }\n  }\n  /*\n    Flush out the buffered code.\n  */\n  GIFOutputCode(waiting_code);\n  GIFOutputCode(end_of_information_code);\n  if (bits > 0)\n    {\n      /*\n        Add a character to current packet.\n      */\n      packet[length++]=(unsigned char) (datum & 0xff);\n      if (length >= 254)\n        {\n          (void) WriteBlobByte(image,(unsigned char) length);\n          (void) WriteBlob(image,length,packet);\n          length=0;\n        }\n    }\n  /*\n    Flush accumulated data.\n  */\n  if (length > 0)\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      (void) WriteBlob(image,length,packet);\n    }\n  /*\n    Free encoder memory.\n  */\n  hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n  hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n  hash_code=(short *) RelinquishMagickMemory(hash_code);\n  packet=(unsigned char *) RelinquishMagickMemory(packet);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s G I F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsGIF() returns MagickTrue if the image format type, identified by the\n%  magick string, is GIF.\n%\n%  The format of the IsGIF method is:\n%\n%      MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"GIF8\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b B l o c k                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobBlock() reads data from the image file and returns it.  The\n%  amount of data is determined by first reading a count byte.  The number\n%  of bytes read is returned.\n%\n%  The format of the ReadBlobBlock method is:\n%\n%      ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o data:  Specifies an area to place the information requested from\n%      the file.\n%\n*/\nstatic ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n{\n  ssize_t\n    count;\n\n  unsigned char\n    block_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(data != (unsigned char *) NULL);\n  count=ReadBlob(image,1,&block_count);\n  if (count != 1)\n    return(0);\n  count=ReadBlob(image,(size_t) block_count,data);\n  if (count != (ssize_t) block_count)\n    return(0);\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G I F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGIFImage() reads a Compuserve Graphics image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGIFImage method is:\n%\n%      Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void *DestroyGIFProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic MagickBooleanType PingGIFImage(Image *image,ExceptionInfo *exception)\n{\n  unsigned char\n    buffer[256],\n    length,\n    data_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (ReadBlob(image,1,&data_size) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (ReadBlob(image,1,&length) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  while (length != 0)\n  {\n    if (ReadBlob(image,length,buffer) != (ssize_t) length)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n    if (ReadBlob(image,1,&length) != 1)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  }\n  return(MagickTrue);\n}\n\nstatic Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))\n#define LSBFirstOrder(x,y)  (((y) << 8) | (x))\n#define ThrowGIFException(exception,message) \\\n{ \\\n  if (profiles != (LinkedListInfo *) NULL) \\\n    profiles=DestroyLinkedList(profiles,DestroyGIFProfile); \\\n  if (global_colormap != (unsigned char *) NULL) \\\n    global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap); \\\n  if (meta_image != (Image *) NULL) \\\n    meta_image=DestroyImage(meta_image); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  Image\n    *image,\n    *meta_image;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    duration,\n    global_colors,\n    image_count,\n    local_colors,\n    one;\n\n  ssize_t\n    count,\n    opacity;\n\n  unsigned char\n    background,\n    buffer[257],\n    c,\n    flag,\n    *global_colormap;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a GIF file.\n  */\n  count=ReadBlob(image,6,buffer);\n  if ((count != 6) || ((LocaleNCompare((char *) buffer,\"GIF87\",5) != 0) &&\n      (LocaleNCompare((char *) buffer,\"GIF89\",5) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) memset(buffer,0,sizeof(buffer));\n  meta_image=AcquireImage(image_info,exception);  /* metadata container */\n  meta_image->page.width=ReadBlobLSBShort(image);\n  meta_image->page.height=ReadBlobLSBShort(image);\n  meta_image->iterations=1;\n  flag=(unsigned char) ReadBlobByte(image);\n  profiles=(LinkedListInfo *) NULL;\n  background=(unsigned char) ReadBlobByte(image);\n  c=(unsigned char) ReadBlobByte(image);  /* reserved */\n  one=1;\n  global_colors=one << (((size_t) flag & 0x07)+1);\n  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n    MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n  if (global_colormap == (unsigned char *) NULL)\n    ThrowGIFException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(global_colormap,0,3*MagickMax(global_colors,256)*\n    sizeof(*global_colormap));\n  if (BitSet((int) flag,0x80) != 0)\n    {\n      count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);\n      if (count != (ssize_t) (3*global_colors))\n        ThrowGIFException(CorruptImageError,\"InsufficientImageDataInFile\");\n    }\n  duration=0;\n  opacity=(-1);\n  image_count=0;\n  for ( ; ; )\n  {\n    count=ReadBlob(image,1,&c);\n    if (count != 1)\n      break;\n    if (c == (unsigned char) ';')\n      break;  /* terminator */\n    if (c == (unsigned char) '!')\n      {\n        /*\n          GIF Extension block.\n        */\n        (void) memset(buffer,0,sizeof(buffer));\n        count=ReadBlob(image,1,&c);\n        if (count != 1)\n          ThrowGIFException(CorruptImageError,\"UnableToReadExtensionBlock\");\n        switch (c)\n        {\n          case 0xf9:\n          {\n            /*\n              Read graphics control extension.\n            */\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            meta_image->dispose=(DisposeType) ((buffer[0] >> 2) & 0x07);\n            meta_image->delay=((size_t) buffer[2] << 8) | buffer[1];\n            if ((ssize_t) (buffer[0] & 0x01) == 0x01)\n              opacity=(ssize_t) buffer[3];\n            break;\n          }\n          case 0xfe:\n          {\n            char\n              *comments;\n\n            size_t\n              extent,\n              offset;\n\n            comments=AcquireString((char *) NULL);\n            extent=MagickPathExtent;\n            for (offset=0; ; offset+=count)\n            {\n              count=ReadBlobBlock(image,buffer);\n              if (count == 0)\n                break;\n              buffer[count]='\\0';\n              if ((ssize_t) (count+offset+MagickPathExtent) >= (ssize_t) extent)\n                {\n                  extent<<=1;\n                  comments=(char *) ResizeQuantumMemory(comments,extent+\n                    MagickPathExtent,sizeof(*comments));\n                  if (comments == (char *) NULL)\n                    ThrowGIFException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n              (void) CopyMagickString(&comments[offset],(char *) buffer,extent-\n                offset);\n            }\n            (void) SetImageProperty(meta_image,\"comment\",comments,exception);\n            comments=DestroyString(comments);\n            break;\n          }\n          case 0xff:\n          {\n            MagickBooleanType\n              loop;\n\n            /*\n              Read Netscape Loop extension.\n            */\n            loop=MagickFalse;\n            if (ReadBlobBlock(image,buffer) != 0)\n              loop=LocaleNCompare((char *) buffer,\"NETSCAPE2.0\",11) == 0 ?\n                MagickTrue : MagickFalse;\n            if (loop != MagickFalse)\n              while (ReadBlobBlock(image,buffer) != 0)\n              {\n                meta_image->iterations=((size_t) buffer[2] << 8) | buffer[1];\n                if (meta_image->iterations != 0)\n                  meta_image->iterations++;\n              }\n            else\n              {\n                char\n                  name[MagickPathExtent];\n\n                int\n                  block_length,\n                  info_length,\n                  reserved_length;\n\n                MagickBooleanType\n                  i8bim,\n                  icc,\n                  iptc,\n                  magick;\n\n                StringInfo\n                  *profile;\n\n                unsigned char\n                  *info;\n\n                /*\n                  Store GIF application extension as a generic profile.\n                */\n                icc=LocaleNCompare((char *) buffer,\"ICCRGBG1012\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                magick=LocaleNCompare((char *) buffer,\"ImageMagick\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                i8bim=LocaleNCompare((char *) buffer,\"MGK8BIM0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                iptc=LocaleNCompare((char *) buffer,\"MGKIPTC0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Reading GIF application extension\");\n                info=(unsigned char *) AcquireQuantumMemory(255UL,\n                  sizeof(*info));\n                if (info == (unsigned char *) NULL)\n                  ThrowGIFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                (void) memset(info,0,255UL*sizeof(*info));\n                reserved_length=255;\n                for (info_length=0; ; )\n                {\n                  block_length=(int) ReadBlobBlock(image,&info[info_length]);\n                  if (block_length == 0)\n                    break;\n                  info_length+=block_length;\n                  if (info_length > (reserved_length-255))\n                    {\n                      reserved_length+=4096;\n                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)\n                        reserved_length,sizeof(*info));\n                      if (info == (unsigned char *) NULL)\n                        {\n                          info=(unsigned char *) RelinquishMagickMemory(info);\n                          ThrowGIFException(ResourceLimitError,\n                            \"MemoryAllocationFailed\");\n                        }\n                    }\n                }\n                profile=BlobToStringInfo(info,(size_t) info_length);\n                if (profile == (StringInfo *) NULL)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowGIFException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if (i8bim != MagickFalse)\n                  (void) CopyMagickString(name,\"8bim\",sizeof(name));\n                else if (icc != MagickFalse)\n                  (void) CopyMagickString(name,\"icc\",sizeof(name));\n                else if (iptc != MagickFalse)\n                  (void) CopyMagickString(name,\"iptc\",sizeof(name));\n                else if (magick != MagickFalse)\n                  {\n                    (void) CopyMagickString(name,\"magick\",sizeof(name));\n                    meta_image->gamma=StringToDouble((char *) info+6,\n                      (char **) NULL);\n                  }\n                else\n                  (void) FormatLocaleString(name,sizeof(name),\"gif:%.11s\",\n                    buffer);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      profile name=%s\",name);\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                if (magick != MagickFalse)\n                  profile=DestroyStringInfo(profile);\n                else\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    SetStringInfoName(profile,name);\n                    (void) AppendValueToLinkedList(profiles,profile);\n                  }\n              }\n            break;\n          }\n          default:\n          {\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            break;\n          }\n        }\n      }\n    if (c != (unsigned char) ',')\n      continue;\n    image_count++;\n    if (image_count != 1)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n      }\n    /*\n      Read image attributes.\n    */\n    meta_image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    meta_image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    meta_image->scene=image->scene;\n    (void) CloneImageProperties(image,meta_image);\n    DestroyImageProperties(meta_image);\n    image->storage_class=PseudoClass;\n    image->compression=LZWCompression;\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    image->depth=8;\n    flag=(unsigned char) ReadBlobByte(image);\n    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;\n    local_colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<\n      ((size_t) (flag & 0x07)+1);\n    image->colors=local_colors;\n    if (opacity >= (ssize_t) image->colors)\n      {\n        image->colors++;\n        opacity=(-1);\n      }\n    image->ticks_per_second=100;\n    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowGIFException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    /*\n      Inititialize colormap.\n    */\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      ThrowGIFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (BitSet((int) flag,0x80) == 0)\n      {\n        /*\n          Use global colormap.\n        */\n        p=global_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            {\n              image->colormap[i].alpha=(double) TransparentAlpha;\n              image->transparent_color=image->colormap[opacity];\n            }\n        }\n        image->background_color=image->colormap[MagickMin((ssize_t) background,\n          (ssize_t) image->colors-1)];\n      }\n    else\n      {\n        unsigned char\n          *colormap;\n\n        /*\n          Read local colormap.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          MagickMax(local_colors,256),3UL*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowGIFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(colormap,0,3*MagickMax(local_colors,256)*\n          sizeof(*colormap));\n        count=ReadBlob(image,(3*local_colors)*sizeof(*colormap),colormap);\n        if (count != (ssize_t) (3*local_colors))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            ThrowGIFException(CorruptImageError,\"InsufficientImageDataInFile\");\n          }\n        p=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            image->colormap[i].alpha=(double) TransparentAlpha;\n        }\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    if (image->gamma == 1.0)\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)\n            break;\n        (void) SetImageColorspace(image,i == (ssize_t) image->colors ?\n          GRAYColorspace : RGBColorspace,exception);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if (profiles != (LinkedListInfo *) NULL)\n          profiles=DestroyLinkedList(profiles,DestroyGIFProfile);\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        return(DestroyImageList(image));\n      }\n    /*\n      Decode image.\n    */\n    if (image_info->ping != MagickFalse)\n      status=PingGIFImage(image,exception);\n    else\n      status=DecodeImage(image,opacity,exception);\n    if ((image_info->ping == MagickFalse) && (status == MagickFalse))\n      ThrowGIFException(CorruptImageError,\"CorruptImage\");\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        StringInfo\n          *profile;\n\n        /*\n          Set image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        profile=(StringInfo *) GetNextValueInLinkedList(profiles);\n        while (profile != (StringInfo *) NULL)\n        {\n          (void) SetImageProfile(image,GetStringInfoName(profile),profile,\n            exception);\n          profile=(StringInfo *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,DestroyGIFProfile);\n      }\n    duration+=image->delay*image->iterations;\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    opacity=(-1);\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n      image->scene-1,image->scene);\n    if (status == MagickFalse)\n      break;\n  }\n  image->duration=duration;\n  if (profiles != (LinkedListInfo *) NULL)\n    profiles=DestroyLinkedList(profiles,DestroyGIFProfile);\n  meta_image=DestroyImage(meta_image);\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r G I F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterGIFImage() adds properties for the GIF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterGIFImage method is:\n%\n%      size_t RegisterGIFImage(void)\n%\n*/\nModuleExport size_t RegisterGIFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"GIF\",\"GIF\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"GIF\",\"GIF87\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->flags^=CoderAdjoinFlag;\n  entry->version=ConstantString(\"version 87a\");\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r G I F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterGIFImage() removes format registrations made by the\n%  GIF module from the list of supported formats.\n%\n%  The format of the UnregisterGIFImage method is:\n%\n%      UnregisterGIFImage(void)\n%\n*/\nModuleExport void UnregisterGIFImage(void)\n{\n  (void) UnregisterMagickInfo(\"GIF\");\n  (void) UnregisterMagickInfo(\"GIF87\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G I F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGIFImage() writes an image to a file in the Compuserve Graphics\n%  image format.\n%\n%  The format of the WriteGIFImage method is:\n%\n%      MagickBooleanType WriteGIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGIFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    delay,\n    imageListLength,\n    length,\n    one;\n\n  ssize_t\n    j,\n    opacity;\n\n  unsigned char\n    *colormap,\n    *global_colormap;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate colormap.\n  */\n  global_colormap=(unsigned char *) AcquireQuantumMemory(768UL,\n    sizeof(*global_colormap));\n  colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n  if ((global_colormap == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (global_colormap != (unsigned char *) NULL)\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i=0; i < 768; i++)\n    colormap[i]=(unsigned char) 0;\n  /*\n    Write GIF header.\n  */\n  write_info=CloneImageInfo(image_info);\n  if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n    (void) WriteBlob(image,6,(unsigned char *) \"GIF89a\");\n  else\n    {\n      (void) WriteBlob(image,6,(unsigned char *) \"GIF87a\");\n      write_info->adjoin=MagickFalse;\n    }\n  /*\n    Determine image bounding box.\n  */\n  page.width=image->columns;\n  if (image->page.width > page.width)\n    page.width=image->page.width;\n  page.height=image->rows;\n  if (image->page.height > page.height)\n    page.height=image->page.height;\n  page.x=image->page.x;\n  page.y=image->page.y;\n  (void) WriteBlobLSBShort(image,(unsigned short) page.width);\n  (void) WriteBlobLSBShort(image,(unsigned short) page.height);\n  /*\n    Write images to file.\n  */\n  if ((write_info->adjoin != MagickFalse) &&\n      (GetNextImageInList(image) != (Image *) NULL))\n    write_info->interlace=NoInterlace;\n  scene=0;\n  one=1;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    opacity=(-1);\n    if (IsImageOpaque(image,exception) != MagickFalse)\n      {\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteType,exception);\n      }\n    else\n      {\n        double\n          alpha,\n          beta;\n\n        /*\n          Identify transparent colormap index.\n        */\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (image->colormap[i].alpha != OpaqueAlpha)\n            {\n              if (opacity < 0)\n                {\n                  opacity=i;\n                  continue;\n                }\n              alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n              beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n              if (alpha < beta)\n                opacity=i;\n            }\n        if (opacity == -1)\n          {\n            (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n            for (i=0; i < (ssize_t) image->colors; i++)\n              if (image->colormap[i].alpha != OpaqueAlpha)\n                {\n                  if (opacity < 0)\n                    {\n                      opacity=i;\n                      continue;\n                    }\n                  alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n                  beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n                  if (alpha < beta)\n                    opacity=i;\n                }\n          }\n        if (opacity >= 0)\n          {\n            image->colormap[opacity].red=image->transparent_color.red;\n            image->colormap[opacity].green=image->transparent_color.green;\n            image->colormap[opacity].blue=image->transparent_color.blue;\n          }\n      }\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (bits_per_pixel=1; bits_per_pixel < 8; bits_per_pixel++)\n      if ((one << bits_per_pixel) >= image->colors)\n        break;\n    q=colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n    }\n    for ( ; i < (ssize_t) (one << bits_per_pixel); i++)\n    {\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n    }\n    if ((GetPreviousImageInList(image) == (Image *) NULL) ||\n        (write_info->adjoin == MagickFalse))\n      {\n        /*\n          Write global colormap.\n        */\n        c=0x80;\n        c|=(8-1) << 4;  /* color resolution */\n        c|=(bits_per_pixel-1);   /* size of global colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        for (j=0; j < (ssize_t) image->colors; j++)\n          if (IsPixelInfoEquivalent(&image->background_color,image->colormap+j))\n            break;\n        (void) WriteBlobByte(image,(unsigned char)\n          (j == (ssize_t) image->colors ? 0 : j));  /* background color */\n        (void) WriteBlobByte(image,(unsigned char) 0x00);  /* reserved */\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n        for (j=0; j < 768; j++)\n          global_colormap[j]=colormap[j];\n      }\n    if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n      {\n        const char\n          *value;\n\n        /*\n          Write graphics control extension.\n        */\n        (void) WriteBlobByte(image,(unsigned char) 0x21);\n        (void) WriteBlobByte(image,(unsigned char) 0xf9);\n        (void) WriteBlobByte(image,(unsigned char) 0x04);\n        c=image->dispose << 2;\n        if (opacity >= 0)\n          c|=0x01;\n        (void) WriteBlobByte(image,(unsigned char) c);\n        delay=(size_t) (100*image->delay/MagickMax((size_t)\n          image->ticks_per_second,1));\n        (void) WriteBlobLSBShort(image,(unsigned short) delay);\n        (void) WriteBlobByte(image,(unsigned char) (opacity >= 0 ? opacity :\n          0));\n        (void) WriteBlobByte(image,(unsigned char) 0x00);\n        value=GetImageProperty(image,\"comment\",exception);\n        if (value != (const char *) NULL)\n          {\n            register const char\n              *p;\n\n            size_t\n              count;\n\n            /*\n              Write comment extension.\n            */\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xfe);\n            for (p=value; *p != '\\0'; )\n            {\n              count=MagickMin(strlen(p),255);\n              (void) WriteBlobByte(image,(unsigned char) count);\n              for (i=0; i < (ssize_t) count; i++)\n                (void) WriteBlobByte(image,(unsigned char) *p++);\n            }\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n            (GetNextImageInList(image) != (Image *) NULL) &&\n            (image->iterations != 1))\n          {\n            /*\n              Write Netscape Loop extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x03);\n            (void) WriteBlobByte(image,(unsigned char) 0x01);\n            (void) WriteBlobLSBShort(image,(unsigned short) (image->iterations ?\n              image->iterations-1 : 0));\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((image->gamma != 1.0f/2.2f))\n          {\n            char\n              attributes[MagickPathExtent];\n\n            ssize_t\n              count;\n\n            /*\n              Write ImageMagick extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"ImageMagick\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"ImageMagick\");\n            count=FormatLocaleString(attributes,MagickPathExtent,\"gamma=%g\",\n              image->gamma);\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlob(image,(size_t) count,(unsigned char *) attributes);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        ResetImageProfileIterator(image);\n        for ( ; ; )\n        {\n          char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          name=GetNextImageProfile(image);\n          if (name == (const char *) NULL)\n            break;\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0) ||\n                (LocaleCompare(name,\"IPTC\") == 0) ||\n                (LocaleCompare(name,\"8BIM\") == 0) ||\n                (LocaleNCompare(name,\"gif:\",4) == 0))\n            {\n               ssize_t\n                 offset;\n\n               unsigned char\n                 *datum;\n\n               datum=GetStringInfoDatum(profile);\n               length=GetStringInfoLength(profile);\n               (void) WriteBlobByte(image,(unsigned char) 0x21);\n               (void) WriteBlobByte(image,(unsigned char) 0xff);\n               (void) WriteBlobByte(image,(unsigned char) 0x0b);\n               if ((LocaleCompare(name,\"ICC\") == 0) ||\n                   (LocaleCompare(name,\"ICM\") == 0))\n                 {\n                   /*\n                     Write ICC extension.\n                   */\n                   (void) WriteBlob(image,11,(unsigned char *) \"ICCRGBG1012\");\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Writing GIF Extension %s\",\"ICCRGBG1012\");\n                 }\n               else\n                 if ((LocaleCompare(name,\"IPTC\") == 0))\n                   {\n                     /*\n                       Write IPTC extension.\n                     */\n                     (void) WriteBlob(image,11,(unsigned char *) \"MGKIPTC0000\");\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  Writing GIF Extension %s\",\"MGKIPTC0000\");\n                   }\n                 else\n                   if ((LocaleCompare(name,\"8BIM\") == 0))\n                     {\n                       /*\n                         Write 8BIM extension.\n                       */\n                        (void) WriteBlob(image,11,(unsigned char *)\n                          \"MGK8BIM0000\");\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing GIF Extension %s\",\"MGK8BIM0000\");\n                     }\n                   else\n                     {\n                       char\n                         extension[MagickPathExtent];\n\n                       /*\n                         Write generic extension.\n                       */\n                       (void) CopyMagickString(extension,name+4,\n                         sizeof(extension));\n                       (void) WriteBlob(image,11,(unsigned char *) extension);\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"  Writing GIF Extension %s\",name);\n                     }\n               offset=0;\n               while ((ssize_t) length > offset)\n               {\n                 size_t\n                   block_length;\n\n                 if ((length-offset) < 255)\n                   block_length=length-offset;\n                 else\n                   block_length=255;\n                 (void) WriteBlobByte(image,(unsigned char) block_length);\n                 (void) WriteBlob(image,(size_t) block_length,datum+offset);\n                 offset+=(ssize_t) block_length;\n               }\n               (void) WriteBlobByte(image,(unsigned char) 0x00);\n            }\n          }\n        }\n      }\n    (void) WriteBlobByte(image,',');  /* image separator */\n    /*\n      Write the image header.\n    */\n    page.x=image->page.x;\n    page.y=image->page.y;\n    if ((image->page.width != 0) && (image->page.height != 0))\n      page=image->page;\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.x < 0 ? 0 : page.x));\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.y < 0 ? 0 : page.y));\n    (void) WriteBlobLSBShort(image,(unsigned short) image->columns);\n    (void) WriteBlobLSBShort(image,(unsigned short) image->rows);\n    c=0x00;\n    if (write_info->interlace != NoInterlace)\n      c|=0x40;  /* pixel data is interlaced */\n    for (j=0; j < (ssize_t) (3*image->colors); j++)\n      if (colormap[j] != global_colormap[j])\n        break;\n    if (j == (ssize_t) (3*image->colors))\n      (void) WriteBlobByte(image,(unsigned char) c);\n    else\n      {\n        c|=0x80;\n        c|=(bits_per_pixel-1);   /* size of local colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n      }\n    /*\n      Write the image data.\n    */\n    c=(int) MagickMax(bits_per_pixel,2);\n    (void) WriteBlobByte(image,(unsigned char) c);\n    status=EncodeImage(write_info,image,(size_t) MagickMax(bits_per_pixel,2)+1,\n      exception);\n    if (status == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n        write_info=DestroyImageInfo(write_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) WriteBlobByte(image,(unsigned char) 0x00);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    scene++;\n    status=SetImageProgress(image,SaveImagesTag,scene,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  (void) WriteBlobByte(image,';'); /* terminator */\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF   OOO   U   U  RRRR   IIIII  EEEEE  RRRR                %\n%               F      O   O  U   U  R   R    I    E      R   R               %\n%               FFF    O   O  U   U  RRRR     I    EEE    RRRR                %\n%               F      O   O  U   U  R R      I    E      R R                 %\n%               F       OOO    UUU   R  R   IIIII  EEEEE  R  R                %\n%                                                                             %\n%                                                                             %\n%                MagickCore Discrete Fourier Transform Methods                %\n%                                                                             %\n%                              Software Design                                %\n%                                Sean Burke                                   %\n%                               Fred Weinhaus                                 %\n%                                   Cristy                                    %\n%                                 July 2009                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/fourier.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n#include <complex.h>\n#endif\n#include <fftw3.h>\n#if !defined(MAGICKCORE_HAVE_CABS)\n#define cabs(z)  (sqrt(z[0]*z[0]+z[1]*z[1]))\n#endif\n#if !defined(MAGICKCORE_HAVE_CARG)\n#define carg(z)  (atan2(cimag(z),creal(z)))\n#endif\n#if !defined(MAGICKCORE_HAVE_CIMAG)\n#define cimag(z)  (z[1])\n#endif\n#if !defined(MAGICKCORE_HAVE_CREAL)\n#define creal(z)  (z[0])\n#endif\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _FourierInfo\n{\n  PixelChannel\n    channel;\n\n  MagickBooleanType\n    modulus;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    center;\n} FourierInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o m p l e x I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ComplexImages() performs complex mathematics on an image sequence.\n%\n%  The format of the ComplexImages method is:\n%\n%      MagickBooleanType ComplexImages(Image *images,const ComplexOperator op,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A complex operator.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);\n            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);\n            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F o r w a r d F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ForwardFourierTransformImage() implements the discrete Fourier transform\n%  (DFT) of the image either as a magnitude / phase or real / imaginary image\n%  pair.\n%\n%  The format of the ForwadFourierTransformImage method is:\n%\n%      Image *ForwardFourierTransformImage(const Image *image,\n%        const MagickBooleanType modulus,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o modulus: if true, return as transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n\nstatic MagickBooleanType RollFourier(const size_t width,const size_t height,\n  const ssize_t x_offset,const ssize_t y_offset,double *roll_pixels)\n{\n  double\n    *source_pixels;\n\n  MemoryInfo\n    *source_info;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Move zero frequency (DC, average color) from (0,0) to (width/2,height/2).\n  */\n  source_info=AcquireVirtualMemory(width,height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    return(MagickFalse);\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  i=0L;\n  for (y=0L; y < (ssize_t) height; y++)\n  {\n    if (y_offset < 0L)\n      v=((y+y_offset) < 0L) ? y+y_offset+(ssize_t) height : y+y_offset;\n    else\n      v=((y+y_offset) > ((ssize_t) height-1L)) ? y+y_offset-(ssize_t) height :\n        y+y_offset;\n    for (x=0L; x < (ssize_t) width; x++)\n    {\n      if (x_offset < 0L)\n        u=((x+x_offset) < 0L) ? x+x_offset+(ssize_t) width : x+x_offset;\n      else\n        u=((x+x_offset) > ((ssize_t) width-1L)) ? x+x_offset-(ssize_t) width :\n          x+x_offset;\n      source_pixels[v*width+u]=roll_pixels[i++];\n    }\n  }\n  (void) memcpy(roll_pixels,source_pixels,height*width*\n    sizeof(*source_pixels));\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}\n\nstatic void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}\n\nstatic MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,\n  Image *image,double *magnitude,double *phase,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  Image\n    *magnitude_image,\n    *phase_image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y;\n\n  magnitude_image=GetFirstImageInList(image);\n  phase_image=GetNextImageInList(image);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  /*\n    Create \"Fourier Transform\" image from constituent arrays.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  (void) memset(magnitude_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  (void) memset(phase_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*phase_pixels));\n  status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude,magnitude_pixels);\n  if (status != MagickFalse)\n    status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,phase,\n      phase_pixels);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]/=(2.0*MagickPI);\n          phase_pixels[i]+=0.5;\n          i++;\n        }\n    }\n  magnitude_view=AcquireAuthenticCacheView(magnitude_image,exception);\n  i=0L;\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(magnitude_image);\n    }\n    status=SyncCacheViewAuthenticPixels(magnitude_view,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  i=0L;\n  phase_view=AcquireAuthenticCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(phase_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(phase_image);\n    }\n    status=SyncCacheViewAuthenticPixels(phase_view,exception);\n    if (status == MagickFalse)\n      break;\n   }\n  phase_view=DestroyCacheView(phase_view);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n\nstatic MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,\n  const Image *image,double *magnitude_pixels,double *phase_pixels,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_complex\n    *forward_pixels;\n\n  fftw_plan\n    fftw_r2c_plan;\n\n  MemoryInfo\n    *forward_info,\n    *source_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Generate the forward Fourier transform.\n  */\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  memset(source_pixels,0,fourier_info->width*fourier_info->height*\n    sizeof(*source_pixels));\n  i=0L;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          source_pixels[i]=QuantumScale*GetPixelRed(image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelGreen(image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlue(image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlack(image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelAlpha(image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  forward_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*forward_pixels));\n  if (forward_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n      return(MagickFalse);\n    }\n  forward_pixels=(fftw_complex *) GetVirtualMemoryBlob(forward_info);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_ForwardFourierTransform)\n#endif\n  fftw_r2c_plan=fftw_plan_dft_r2c_2d(fourier_info->width,fourier_info->height,\n    source_pixels,forward_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_r2c(fftw_r2c_plan,source_pixels,forward_pixels);\n  fftw_destroy_plan(fftw_r2c_plan);\n  source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if ((value == (const char *) NULL) || (LocaleCompare(value,\"forward\") == 0))\n    {\n      double\n        gamma;\n\n      /*\n        Normalize fourier transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          forward_pixels[i]*=gamma;\n#else\n          forward_pixels[i][0]*=gamma;\n          forward_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n  /*\n    Generate magnitude and phase (or real and imaginary).\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=cabs(forward_pixels[i]);\n        phase_pixels[i]=carg(forward_pixels[i]);\n        i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=creal(forward_pixels[i]);\n        phase_pixels[i]=cimag(forward_pixels[i]);\n        i++;\n      }\n  forward_info=(MemoryInfo *) RelinquishVirtualMemory(forward_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardFourierTransformChannel(const Image *image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  fourier_info.width=image->columns;\n  fourier_info.height=image->rows;\n  if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n      ((image->rows % 2) != 0))\n    {\n      size_t extent=image->columns < image->rows ? image->rows : image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info == (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  status=ForwardFourierTransform(&fourier_info,image,magnitude_pixels,\n    phase_pixels,exception);\n  if (status != MagickFalse)\n    status=ForwardFourier(&fourier_info,fourier_image,magnitude_pixels,\n      phase_pixels,exception);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *ForwardFourierTransformImage(const Image *image,\n  const MagickBooleanType modulus,ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  fourier_image=NewImageList();\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    image->filename);\n#else\n  {\n    Image\n      *magnitude_image;\n\n    size_t\n      height,\n      width;\n\n    width=image->columns;\n    height=image->rows;\n    if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n        ((image->rows % 2) != 0))\n      {\n        size_t extent=image->columns < image->rows ? image->rows :\n          image->columns;\n        width=(extent & 0x01) == 1 ? extent+1UL : extent;\n      }\n    height=width;\n    magnitude_image=CloneImage(image,width,height,MagickTrue,exception);\n    if (magnitude_image != (Image *) NULL)\n      {\n        Image\n          *phase_image;\n\n        magnitude_image->storage_class=DirectClass;\n        magnitude_image->depth=32UL;\n        phase_image=CloneImage(image,width,height,MagickTrue,exception);\n        if (phase_image == (Image *) NULL)\n          magnitude_image=DestroyImage(magnitude_image);\n        else\n          {\n            MagickBooleanType\n              is_gray,\n              status;\n\n            phase_image->storage_class=DirectClass;\n            phase_image->depth=32UL;\n            AppendImageToList(&fourier_image,magnitude_image);\n            AppendImageToList(&fourier_image,phase_image);\n            status=MagickTrue;\n            is_gray=IsImageGray(image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel sections\n#endif\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                if (is_gray != MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GrayPixelChannel,modulus,fourier_image,exception);\n                else\n                  thread_status=ForwardFourierTransformChannel(image,\n                    RedPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GreenPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BluePixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->colorspace == CMYKColorspace)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BlackPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    AlphaPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n            }\n            if (status == MagickFalse)\n              fourier_image=DestroyImageList(fourier_image);\n            fftw_cleanup();\n          }\n      }\n  }\n#endif\n  return(fourier_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I n v e r s e F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InverseFourierTransformImage() implements the inverse discrete Fourier\n%  transform (DFT) of the image either as a magnitude / phase or real /\n%  imaginary image pair.\n%\n%  The format of the InverseFourierTransformImage method is:\n%\n%      Image *InverseFourierTransformImage(const Image *magnitude_image,\n%        const Image *phase_image,const MagickBooleanType modulus,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o magnitude_image: the magnitude or real image.\n%\n%    o phase_image: the phase or imaginary image.\n%\n%    o modulus: if true, return transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\nstatic MagickBooleanType InverseQuadrantSwap(const size_t width,\n  const size_t height,const double *source,double *destination)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  for (y=1L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L+1L); x++)\n      destination[(height-y)*center-x+width/2L]=source[y*width+x];\n  for (y=0L; y < (ssize_t) height; y++)\n    destination[y*center]=source[y*width+width/2L];\n  for (x=0L; x < center; x++)\n    destination[x]=source[center-x-1L];\n  return(RollFourier(center,height,0L,(ssize_t) height/-2L,destination));\n}\n\nstatic MagickBooleanType InverseFourier(FourierInfo *fourier_info,\n  const Image *magnitude_image,const Image *phase_image,\n  fftw_complex *fourier_pixels,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *inverse_pixels,\n    *magnitude_pixels,\n    *phase_pixels;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info,\n    *magnitude_info,\n    *phase_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Inverse fourier - read image and break down into a double array.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*inverse_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL) ||\n      (inverse_info == (MemoryInfo *) NULL))\n    {\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (inverse_info != (MemoryInfo *) NULL)\n        inverse_info=RelinquishVirtualMemory(inverse_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  inverse_pixels=(double *) GetVirtualMemoryBlob(inverse_info);\n  i=0L;\n  magnitude_view=AcquireVirtualCacheView(magnitude_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelRed(magnitude_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelGreen(magnitude_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlue(magnitude_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlack(magnitude_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelAlpha(magnitude_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(magnitude_image);\n    }\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude_pixels,inverse_pixels);\n  (void) memcpy(magnitude_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*magnitude_pixels));\n  i=0L;\n  phase_view=AcquireVirtualCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(phase_view,0,y,fourier_info->width,1,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelRed(phase_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelGreen(phase_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlue(phase_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlack(phase_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelAlpha(phase_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(phase_image);\n    }\n  }\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]-=0.5;\n          phase_pixels[i]*=(2.0*MagickPI);\n          i++;\n        }\n    }\n  phase_view=DestroyCacheView(phase_view);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (status != MagickFalse)\n    status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n      phase_pixels,inverse_pixels);\n  (void) memcpy(phase_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*phase_pixels));\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  /*\n    Merge two sets.\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n       for (x=0L; x < (ssize_t) fourier_info->center; x++)\n       {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n         fourier_pixels[i]=magnitude_pixels[i]*cos(phase_pixels[i])+I*\n           magnitude_pixels[i]*sin(phase_pixels[i]);\n#else\n         fourier_pixels[i][0]=magnitude_pixels[i]*cos(phase_pixels[i]);\n         fourier_pixels[i][1]=magnitude_pixels[i]*sin(phase_pixels[i]);\n#endif\n         i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n        fourier_pixels[i]=magnitude_pixels[i]+I*phase_pixels[i];\n#else\n        fourier_pixels[i][0]=magnitude_pixels[i];\n        fourier_pixels[i][1]=phase_pixels[i];\n#endif\n        i++;\n      }\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  return(status);\n}\n\nstatic MagickBooleanType InverseFourierTransform(FourierInfo *fourier_info,\n  fftw_complex *fourier_pixels,Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_plan\n    fftw_c2r_plan;\n\n  MemoryInfo\n    *source_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if (LocaleCompare(value,\"inverse\") == 0)\n    {\n      double\n        gamma;\n\n      /*\n        Normalize inverse transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          fourier_pixels[i]*=gamma;\n#else\n          fourier_pixels[i][0]*=gamma;\n          fourier_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_InverseFourierTransform)\n#endif\n  fftw_c2r_plan=fftw_plan_dft_c2r_2d(fourier_info->width,fourier_info->height,\n    fourier_pixels,source_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_c2r(fftw_c2r_plan,fourier_pixels,source_pixels);\n  fftw_destroy_plan(fftw_c2r_plan);\n  i=0L;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    if (y >= (ssize_t) image->rows)\n      break;\n    q=GetCacheViewAuthenticPixels(image_view,0L,y,fourier_info->width >\n      image->columns ? image->columns : fourier_info->width,1UL,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        switch (fourier_info->channel)\n        {\n          case RedPixelChannel:\n          default:\n          {\n            SetPixelRed(image,ClampToQuantum(QuantumRange*source_pixels[i]),q);\n            break;\n          }\n          case GreenPixelChannel:\n          {\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BluePixelChannel:\n          {\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BlackPixelChannel:\n          {\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case AlphaPixelChannel:\n          {\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n        }\n      i++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *InverseFourierTransformImage(const Image *magnitude_image,\n  const Image *phase_image,const MagickBooleanType modulus,\n  ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  assert(magnitude_image != (Image *) NULL);\n  assert(magnitude_image->signature == MagickCoreSignature);\n  if (magnitude_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      magnitude_image->filename);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",magnitude_image->filename);\n      return((Image *) NULL);\n    }\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  fourier_image=(Image *) NULL;\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    magnitude_image->filename);\n#else\n  {\n    fourier_image=CloneImage(magnitude_image,magnitude_image->columns,\n      magnitude_image->rows,MagickTrue,exception);\n    if (fourier_image != (Image *) NULL)\n      {\n        MagickBooleanType\n          is_gray,\n          status;\n\n        status=MagickTrue;\n        is_gray=IsImageGray(magnitude_image);\n        if (is_gray != MagickFalse)\n          is_gray=IsImageGray(phase_image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp parallel sections\n#endif\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            if (is_gray != MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GrayPixelChannel,modulus,fourier_image,exception);\n            else\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,RedPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GreenPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BluePixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->colorspace == CMYKColorspace)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BlackPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->alpha_trait != UndefinedPixelTrait)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,AlphaPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n        }\n        if (status == MagickFalse)\n          fourier_image=DestroyImage(fourier_image);\n      }\n    fftw_cleanup();\n  }\n#endif\n  return(fourier_image);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             GGGG  IIIII  FFFFF                              %\n%                            G        I    F                                  %\n%                            G  GG    I    FFF                                %\n%                            G   G    I    F                                  %\n%                             GGG   IIIII  F                                  %\n%                                                                             %\n%                                                                             %\n%            Read/Write Compuserv Graphics Interchange Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Define declarations.\n*/\n#define MaximumLZWBits  12\n#define MaximumLZWCode  (1UL << MaximumLZWBits)\n\f\n/*\n  Typdef declarations.\n*/\ntypedef struct _LZWCodeInfo\n{\n  unsigned char\n    buffer[280];\n\n  size_t\n    count,\n    bit;\n\n  MagickBooleanType\n    eof;\n} LZWCodeInfo;\n\ntypedef struct _LZWStack\n{\n  size_t\n    *codes,\n    *index,\n    *top;\n} LZWStack;\n\ntypedef struct _LZWInfo\n{\n  Image\n    *image;\n\n  LZWStack\n    *stack;\n\n  MagickBooleanType\n    genesis;\n\n  size_t\n    data_size,\n    maximum_data_value,\n    clear_code,\n    end_code,\n    bits,\n    first_code,\n    last_code,\n    maximum_code,\n    slot,\n    *table[2];\n\n  LZWCodeInfo\n    code_info;\n} LZWInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic inline int\n  GetNextLZWCode(LZWInfo *,const size_t);\n\nstatic MagickBooleanType\n  WriteGIFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic ssize_t\n  ReadBlobBlock(Image *,unsigned char *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage uncompresses an image via GIF-coding.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,const ssize_t opacity)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o opacity:  The colormap index associated with the transparent color.\n%\n*/\n\nstatic LZWInfo *RelinquishLZWInfo(LZWInfo *lzw_info)\n{\n  if (lzw_info->table[0] != (size_t *) NULL)\n    lzw_info->table[0]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[0]);\n  if (lzw_info->table[1] != (size_t *) NULL)\n    lzw_info->table[1]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[1]);\n  if (lzw_info->stack != (LZWStack *) NULL)\n    {\n      if (lzw_info->stack->codes != (size_t *) NULL)\n        lzw_info->stack->codes=(size_t *) RelinquishMagickMemory(\n          lzw_info->stack->codes);\n      lzw_info->stack=(LZWStack *) RelinquishMagickMemory(lzw_info->stack);\n    }\n  lzw_info=(LZWInfo *) RelinquishMagickMemory(lzw_info);\n  return((LZWInfo *) NULL);\n}\n\nstatic inline void ResetLZWInfo(LZWInfo *lzw_info)\n{\n  size_t\n    one;\n\n  lzw_info->bits=lzw_info->data_size+1;\n  one=1;\n  lzw_info->maximum_code=one << lzw_info->bits;\n  lzw_info->slot=lzw_info->maximum_data_value+3;\n  lzw_info->genesis=MagickTrue;\n}\n\nstatic LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)\n{\n  LZWInfo\n    *lzw_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  lzw_info=(LZWInfo *) AcquireMagickMemory(sizeof(*lzw_info));\n  if (lzw_info == (LZWInfo *) NULL)\n    return((LZWInfo *) NULL);\n  (void) memset(lzw_info,0,sizeof(*lzw_info));\n  lzw_info->image=image;\n  lzw_info->data_size=data_size;\n  one=1;\n  lzw_info->maximum_data_value=(one << data_size)-1;\n  lzw_info->clear_code=lzw_info->maximum_data_value+1;\n  lzw_info->end_code=lzw_info->maximum_data_value+2;\n  lzw_info->table[0]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  lzw_info->table[1]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  if ((lzw_info->table[0] == (size_t *) NULL) ||\n      (lzw_info->table[1] == (size_t *) NULL))\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  (void) memset(lzw_info->table[0],0,MaximumLZWCode*\n    sizeof(**lzw_info->table));\n  (void) memset(lzw_info->table[1],0,MaximumLZWCode*\n    sizeof(**lzw_info->table));\n  for (i=0; i <= (ssize_t) lzw_info->maximum_data_value; i++)\n  {\n    lzw_info->table[0][i]=0;\n    lzw_info->table[1][i]=(size_t) i;\n  }\n  ResetLZWInfo(lzw_info);\n  lzw_info->code_info.buffer[0]='\\0';\n  lzw_info->code_info.buffer[1]='\\0';\n  lzw_info->code_info.count=2;\n  lzw_info->code_info.bit=8*lzw_info->code_info.count;\n  lzw_info->code_info.eof=MagickFalse;\n  lzw_info->genesis=MagickTrue;\n  lzw_info->stack=(LZWStack *) AcquireMagickMemory(sizeof(*lzw_info->stack));\n  if (lzw_info->stack == (LZWStack *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->codes=(size_t *) AcquireQuantumMemory(2UL*\n    MaximumLZWCode,sizeof(*lzw_info->stack->codes));\n  if (lzw_info->stack->codes == (size_t *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->index=lzw_info->stack->codes;\n  lzw_info->stack->top=lzw_info->stack->codes+2*MaximumLZWCode;\n  return(lzw_info);\n}\n\nstatic inline int GetNextLZWCode(LZWInfo *lzw_info,const size_t bits)\n{\n  int\n    code;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  while (((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count)) &&\n         (lzw_info->code_info.eof == MagickFalse))\n  {\n    ssize_t\n      count;\n\n    lzw_info->code_info.buffer[0]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-2];\n    lzw_info->code_info.buffer[1]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-1];\n    lzw_info->code_info.bit-=8*(lzw_info->code_info.count-2);\n    lzw_info->code_info.count=2;\n    count=ReadBlobBlock(lzw_info->image,&lzw_info->code_info.buffer[\n      lzw_info->code_info.count]);\n    if (count > 0)\n      lzw_info->code_info.count+=count;\n    else\n      lzw_info->code_info.eof=MagickTrue;\n  }\n  if ((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count))\n    return(-1);\n  code=0;\n  one=1;\n  for (i=0; i < (ssize_t) bits; i++)\n  {\n    code|=((lzw_info->code_info.buffer[lzw_info->code_info.bit/8] &\n      (one << (lzw_info->code_info.bit % 8))) != 0) << i;\n    lzw_info->code_info.bit++;\n  }\n  return(code);\n}\n\nstatic inline int PopLZWStack(LZWStack *stack_info)\n{\n  if (stack_info->index <= stack_info->codes)\n    return(-1);\n  stack_info->index--;\n  return((int) *stack_info->index);\n}\n\nstatic inline void PushLZWStack(LZWStack *stack_info,const size_t value)\n{\n  if (stack_info->index >= stack_info->top)\n    return;\n  *stack_info->index=value;\n  stack_info->index++;\n}\n\nstatic int ReadBlobLZWByte(LZWInfo *lzw_info)\n{\n  int\n    code;\n\n  size_t\n    one,\n    value;\n\n  ssize_t\n    count;\n\n  if (lzw_info->stack->index != lzw_info->stack->codes)\n    return(PopLZWStack(lzw_info->stack));\n  if (lzw_info->genesis != MagickFalse)\n    {\n      lzw_info->genesis=MagickFalse;\n      do\n      {\n        lzw_info->first_code=(size_t) GetNextLZWCode(lzw_info,lzw_info->bits);\n        lzw_info->last_code=lzw_info->first_code;\n      } while (lzw_info->first_code == lzw_info->clear_code);\n      return((int) lzw_info->first_code);\n    }\n  code=GetNextLZWCode(lzw_info,lzw_info->bits);\n  if (code < 0)\n    return(code);\n  if ((size_t) code == lzw_info->clear_code)\n    {\n      ResetLZWInfo(lzw_info);\n      return(ReadBlobLZWByte(lzw_info));\n    }\n  if ((size_t) code == lzw_info->end_code)\n    return(-1);\n  if ((size_t) code < lzw_info->slot)\n    value=(size_t) code;\n  else\n    {\n      PushLZWStack(lzw_info->stack,lzw_info->first_code);\n      value=lzw_info->last_code;\n    }\n  count=0;\n  while (value > lzw_info->maximum_data_value)\n  {\n    if ((size_t) count > MaximumLZWCode)\n      return(-1);\n    count++;\n    if ((size_t) value > MaximumLZWCode)\n      return(-1);\n    PushLZWStack(lzw_info->stack,lzw_info->table[1][value]);\n    value=lzw_info->table[0][value];\n  }\n  lzw_info->first_code=lzw_info->table[1][value];\n  PushLZWStack(lzw_info->stack,lzw_info->first_code);\n  one=1;\n  if (lzw_info->slot < MaximumLZWCode)\n    {\n      lzw_info->table[0][lzw_info->slot]=lzw_info->last_code;\n      lzw_info->table[1][lzw_info->slot]=lzw_info->first_code;\n      lzw_info->slot++;\n      if ((lzw_info->slot >= lzw_info->maximum_code) &&\n          (lzw_info->bits < MaximumLZWBits))\n        {\n          lzw_info->bits++;\n          lzw_info->maximum_code=one << lzw_info->bits;\n        }\n    }\n  lzw_info->last_code=(size_t) code;\n  return(PopLZWStack(lzw_info->stack));\n}\n\nstatic MagickBooleanType DecodeImage(Image *image,const ssize_t opacity,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  LZWInfo\n    *lzw_info;\n\n  size_t\n    pass;\n\n  ssize_t\n    index,\n    offset,\n    y;\n\n  unsigned char\n    data_size;\n\n  /*\n    Allocate decoder tables.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  data_size=(unsigned char) ReadBlobByte(image);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  lzw_info=AcquireLZWInfo(image,data_size);\n  if (lzw_info == (LZWInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  pass=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; )\n    {\n      c=ReadBlobLZWByte(lzw_info);\n      if (c < 0)\n        break;\n      index=ConstrainColormapIndex(image,(ssize_t) c,exception);\n      SetPixelIndex(image,(Quantum) index,q);\n      SetPixelViaPixelInfo(image,image->colormap+index,q);\n      SetPixelAlpha(image,index == opacity ? TransparentAlpha : OpaqueAlpha,q);\n      x++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (x < (ssize_t) image->columns)\n      break;\n    if (image->interlace == NoInterlace)\n      offset++;\n    else\n      {\n        switch (pass)\n        {\n          case 0:\n          default:\n          {\n            offset+=8;\n            break;\n          }\n          case 1:\n          {\n            offset+=8;\n            break;\n          }\n          case 2:\n          {\n            offset+=4;\n            break;\n          }\n          case 3:\n          {\n            offset+=2;\n            break;\n          }\n        }\n      if ((pass == 0) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=4;\n        }\n      if ((pass == 1) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=2;\n        }\n      if ((pass == 2) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=1;\n        }\n    }\n  }\n  lzw_info=RelinquishLZWInfo(lzw_info);\n  if (y < (ssize_t) image->rows)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses an image via GIF-coding.\n%\n%  The format of the EncodeImage method is:\n%\n%      MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n%        const size_t data_size)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the address of a structure of type Image.\n%\n%    o data_size:  The number of bits in the compressed packet.\n%\n*/\nstatic MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n  const size_t data_size,ExceptionInfo *exception)\n{\n#define MaxCode(number_bits)  ((one << (number_bits))-1)\n#define MaxHashTable  5003\n#define MaxGIFBits  12UL\n#define MaxGIFTable  (1UL << MaxGIFBits)\n#define GIFOutputCode(code) \\\n{ \\\n  /*  \\\n    Emit a code. \\\n  */ \\\n  if (bits > 0) \\\n    datum|=(size_t) (code) << bits; \\\n  else \\\n    datum=(size_t) (code); \\\n  bits+=number_bits; \\\n  while (bits >= 8) \\\n  { \\\n    /*  \\\n      Add a character to current packet. \\\n    */ \\\n    packet[length++]=(unsigned char) (datum & 0xff); \\\n    if (length >= 254) \\\n      { \\\n        (void) WriteBlobByte(image,(unsigned char) length); \\\n        (void) WriteBlob(image,length,packet); \\\n        length=0; \\\n      } \\\n    datum>>=8; \\\n    bits-=8; \\\n  } \\\n  if (free_code > max_code)  \\\n    { \\\n      number_bits++; \\\n      if (number_bits == MaxGIFBits) \\\n        max_code=MaxGIFTable; \\\n      else \\\n        max_code=MaxCode(number_bits); \\\n    } \\\n}\n\n  Quantum\n    index;\n\n  short\n    *hash_code,\n    *hash_prefix,\n    waiting_code;\n\n  size_t\n    bits,\n    clear_code,\n    datum,\n    end_of_information_code,\n    free_code,\n    length,\n    max_code,\n    next_pixel,\n    number_bits,\n    one,\n    pass;\n\n  ssize_t\n    displacement,\n    offset,\n    k,\n    y;\n\n  unsigned char\n    *packet,\n    *hash_suffix;\n\n  /*\n    Allocate encoder tables.\n  */\n  assert(image != (Image *) NULL);\n  one=1;\n  packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));\n  hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));\n  hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));\n  hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,\n    sizeof(*hash_suffix));\n  if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||\n      (hash_prefix == (short *) NULL) ||\n      (hash_suffix == (unsigned char *) NULL))\n    {\n      if (packet != (unsigned char *) NULL)\n        packet=(unsigned char *) RelinquishMagickMemory(packet);\n      if (hash_code != (short *) NULL)\n        hash_code=(short *) RelinquishMagickMemory(hash_code);\n      if (hash_prefix != (short *) NULL)\n        hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n      if (hash_suffix != (unsigned char *) NULL)\n        hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n      return(MagickFalse);\n    }\n  /*\n    Initialize GIF encoder.\n  */\n  (void) memset(packet,0,256*sizeof(*packet));\n  (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));\n  (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));\n  (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));\n  number_bits=data_size;\n  max_code=MaxCode(number_bits);\n  clear_code=((short) one << (data_size-1));\n  end_of_information_code=clear_code+1;\n  free_code=clear_code+2;\n  length=0;\n  datum=0;\n  bits=0;\n  GIFOutputCode(clear_code);\n  /*\n    Encode pixels.\n  */\n  offset=0;\n  pass=0;\n  waiting_code=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,offset,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (y == 0)\n      {\n        waiting_code=(short) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n    for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Probe hash table.\n      */\n      next_pixel=MagickFalse;\n      displacement=1;\n      index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);\n      p+=GetPixelChannels(image);\n      k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n      if (k >= MaxHashTable)\n        k-=MaxHashTable;\n      if (k < 0)\n        continue;\n      if (hash_code[k] > 0)\n        {\n          if ((hash_prefix[k] == waiting_code) &&\n              (hash_suffix[k] == (unsigned char) index))\n            {\n              waiting_code=hash_code[k];\n              continue;\n            }\n          if (k != 0)\n            displacement=MaxHashTable-k;\n          for ( ; ; )\n          {\n            k-=displacement;\n            if (k < 0)\n              k+=MaxHashTable;\n            if (hash_code[k] == 0)\n              break;\n            if ((hash_prefix[k] == waiting_code) &&\n                (hash_suffix[k] == (unsigned char) index))\n              {\n                waiting_code=hash_code[k];\n                next_pixel=MagickTrue;\n                break;\n              }\n          }\n          if (next_pixel != MagickFalse)\n            continue;\n        }\n      GIFOutputCode(waiting_code);\n      if (free_code < MaxGIFTable)\n        {\n          hash_code[k]=(short) free_code++;\n          hash_prefix[k]=waiting_code;\n          hash_suffix[k]=(unsigned char) index;\n        }\n      else\n        {\n          /*\n            Fill the hash table with empty entries.\n          */\n          for (k=0; k < MaxHashTable; k++)\n            hash_code[k]=0;\n          /*\n            Reset compressor and issue a clear code.\n          */\n          free_code=clear_code+2;\n          GIFOutputCode(clear_code);\n          number_bits=data_size;\n          max_code=MaxCode(number_bits);\n        }\n      waiting_code=(short) index;\n    }\n    if (image_info->interlace == NoInterlace)\n      offset++;\n    else\n      switch (pass)\n      {\n        case 0:\n        default:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=4;\n            }\n          break;\n        }\n        case 1:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=2;\n            }\n          break;\n        }\n        case 2:\n        {\n          offset+=4;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=1;\n            }\n          break;\n        }\n        case 3:\n        {\n          offset+=2;\n          break;\n        }\n      }\n  }\n  /*\n    Flush out the buffered code.\n  */\n  GIFOutputCode(waiting_code);\n  GIFOutputCode(end_of_information_code);\n  if (bits > 0)\n    {\n      /*\n        Add a character to current packet.\n      */\n      packet[length++]=(unsigned char) (datum & 0xff);\n      if (length >= 254)\n        {\n          (void) WriteBlobByte(image,(unsigned char) length);\n          (void) WriteBlob(image,length,packet);\n          length=0;\n        }\n    }\n  /*\n    Flush accumulated data.\n  */\n  if (length > 0)\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      (void) WriteBlob(image,length,packet);\n    }\n  /*\n    Free encoder memory.\n  */\n  hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n  hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n  hash_code=(short *) RelinquishMagickMemory(hash_code);\n  packet=(unsigned char *) RelinquishMagickMemory(packet);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s G I F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsGIF() returns MagickTrue if the image format type, identified by the\n%  magick string, is GIF.\n%\n%  The format of the IsGIF method is:\n%\n%      MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"GIF8\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b B l o c k                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobBlock() reads data from the image file and returns it.  The\n%  amount of data is determined by first reading a count byte.  The number\n%  of bytes read is returned.\n%\n%  The format of the ReadBlobBlock method is:\n%\n%      ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o data:  Specifies an area to place the information requested from\n%      the file.\n%\n*/\nstatic ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n{\n  ssize_t\n    count;\n\n  unsigned char\n    block_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(data != (unsigned char *) NULL);\n  count=ReadBlob(image,1,&block_count);\n  if (count != 1)\n    return(0);\n  count=ReadBlob(image,(size_t) block_count,data);\n  if (count != (ssize_t) block_count)\n    return(0);\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G I F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGIFImage() reads a Compuserve Graphics image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGIFImage method is:\n%\n%      Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void *DestroyGIFProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic MagickBooleanType PingGIFImage(Image *image,ExceptionInfo *exception)\n{\n  unsigned char\n    buffer[256],\n    length,\n    data_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (ReadBlob(image,1,&data_size) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (ReadBlob(image,1,&length) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  while (length != 0)\n  {\n    if (ReadBlob(image,length,buffer) != (ssize_t) length)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n    if (ReadBlob(image,1,&length) != 1)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  }\n  return(MagickTrue);\n}\n\nstatic Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))\n#define LSBFirstOrder(x,y)  (((y) << 8) | (x))\n#define ThrowGIFException(exception,message) \\\n{ \\\n  if (profiles != (LinkedListInfo *) NULL) \\\n    profiles=DestroyLinkedList(profiles,DestroyGIFProfile); \\\n  if (global_colormap != (unsigned char *) NULL) \\\n    global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap); \\\n  if (meta_image != (Image *) NULL) \\\n    meta_image=DestroyImage(meta_image); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  Image\n    *image,\n    *meta_image;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    duration,\n    global_colors,\n    image_count,\n    local_colors,\n    one;\n\n  ssize_t\n    count,\n    opacity;\n\n  unsigned char\n    background,\n    buffer[257],\n    c,\n    flag,\n    *global_colormap;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a GIF file.\n  */\n  count=ReadBlob(image,6,buffer);\n  if ((count != 6) || ((LocaleNCompare((char *) buffer,\"GIF87\",5) != 0) &&\n      (LocaleNCompare((char *) buffer,\"GIF89\",5) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) memset(buffer,0,sizeof(buffer));\n  meta_image=AcquireImage(image_info,exception);  /* metadata container */\n  meta_image->page.width=ReadBlobLSBShort(image);\n  meta_image->page.height=ReadBlobLSBShort(image);\n  meta_image->iterations=1;\n  flag=(unsigned char) ReadBlobByte(image);\n  profiles=(LinkedListInfo *) NULL;\n  background=(unsigned char) ReadBlobByte(image);\n  c=(unsigned char) ReadBlobByte(image);  /* reserved */\n  one=1;\n  global_colors=one << (((size_t) flag & 0x07)+1);\n  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n    MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n  if (global_colormap == (unsigned char *) NULL)\n    ThrowGIFException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(global_colormap,0,3*MagickMax(global_colors,256)*\n    sizeof(*global_colormap));\n  if (BitSet((int) flag,0x80) != 0)\n    {\n      count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);\n      if (count != (ssize_t) (3*global_colors))\n        ThrowGIFException(CorruptImageError,\"InsufficientImageDataInFile\");\n    }\n  duration=0;\n  opacity=(-1);\n  image_count=0;\n  for ( ; ; )\n  {\n    count=ReadBlob(image,1,&c);\n    if (count != 1)\n      break;\n    if (c == (unsigned char) ';')\n      break;  /* terminator */\n    if (c == (unsigned char) '!')\n      {\n        /*\n          GIF Extension block.\n        */\n        (void) memset(buffer,0,sizeof(buffer));\n        count=ReadBlob(image,1,&c);\n        if (count != 1)\n          ThrowGIFException(CorruptImageError,\"UnableToReadExtensionBlock\");\n        switch (c)\n        {\n          case 0xf9:\n          {\n            /*\n              Read graphics control extension.\n            */\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            meta_image->dispose=(DisposeType) ((buffer[0] >> 2) & 0x07);\n            meta_image->delay=((size_t) buffer[2] << 8) | buffer[1];\n            if ((ssize_t) (buffer[0] & 0x01) == 0x01)\n              opacity=(ssize_t) buffer[3];\n            break;\n          }\n          case 0xfe:\n          {\n            char\n              *comments;\n\n            size_t\n              extent,\n              offset;\n\n            comments=AcquireString((char *) NULL);\n            extent=MagickPathExtent;\n            for (offset=0; ; offset+=count)\n            {\n              count=ReadBlobBlock(image,buffer);\n              if (count == 0)\n                break;\n              buffer[count]='\\0';\n              if ((ssize_t) (count+offset+MagickPathExtent) >= (ssize_t) extent)\n                {\n                  extent<<=1;\n                  comments=(char *) ResizeQuantumMemory(comments,extent+\n                    MagickPathExtent,sizeof(*comments));\n                  if (comments == (char *) NULL)\n                    ThrowGIFException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n              (void) CopyMagickString(&comments[offset],(char *) buffer,extent-\n                offset);\n            }\n            (void) SetImageProperty(meta_image,\"comment\",comments,exception);\n            comments=DestroyString(comments);\n            break;\n          }\n          case 0xff:\n          {\n            MagickBooleanType\n              loop;\n\n            /*\n              Read Netscape Loop extension.\n            */\n            loop=MagickFalse;\n            if (ReadBlobBlock(image,buffer) != 0)\n              loop=LocaleNCompare((char *) buffer,\"NETSCAPE2.0\",11) == 0 ?\n                MagickTrue : MagickFalse;\n            if (loop != MagickFalse)\n              while (ReadBlobBlock(image,buffer) != 0)\n              {\n                meta_image->iterations=((size_t) buffer[2] << 8) | buffer[1];\n                if (meta_image->iterations != 0)\n                  meta_image->iterations++;\n              }\n            else\n              {\n                char\n                  name[MagickPathExtent];\n\n                int\n                  block_length,\n                  info_length,\n                  reserved_length;\n\n                MagickBooleanType\n                  i8bim,\n                  icc,\n                  iptc,\n                  magick;\n\n                StringInfo\n                  *profile;\n\n                unsigned char\n                  *info;\n\n                /*\n                  Store GIF application extension as a generic profile.\n                */\n                icc=LocaleNCompare((char *) buffer,\"ICCRGBG1012\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                magick=LocaleNCompare((char *) buffer,\"ImageMagick\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                i8bim=LocaleNCompare((char *) buffer,\"MGK8BIM0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                iptc=LocaleNCompare((char *) buffer,\"MGKIPTC0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Reading GIF application extension\");\n                info=(unsigned char *) AcquireQuantumMemory(255UL,\n                  sizeof(*info));\n                if (info == (unsigned char *) NULL)\n                  ThrowGIFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                (void) memset(info,0,255UL*sizeof(*info));\n                reserved_length=255;\n                for (info_length=0; ; )\n                {\n                  block_length=(int) ReadBlobBlock(image,&info[info_length]);\n                  if (block_length == 0)\n                    break;\n                  info_length+=block_length;\n                  if (info_length > (reserved_length-255))\n                    {\n                      reserved_length+=4096;\n                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)\n                        reserved_length,sizeof(*info));\n                      if (info == (unsigned char *) NULL)\n                        {\n                          info=(unsigned char *) RelinquishMagickMemory(info);\n                          ThrowGIFException(ResourceLimitError,\n                            \"MemoryAllocationFailed\");\n                        }\n                    }\n                }\n                profile=BlobToStringInfo(info,(size_t) info_length);\n                if (profile == (StringInfo *) NULL)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowGIFException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if (i8bim != MagickFalse)\n                  (void) CopyMagickString(name,\"8bim\",sizeof(name));\n                else if (icc != MagickFalse)\n                  (void) CopyMagickString(name,\"icc\",sizeof(name));\n                else if (iptc != MagickFalse)\n                  (void) CopyMagickString(name,\"iptc\",sizeof(name));\n                else if (magick != MagickFalse)\n                  {\n                    (void) CopyMagickString(name,\"magick\",sizeof(name));\n                    meta_image->gamma=StringToDouble((char *) info+6,\n                      (char **) NULL);\n                  }\n                else\n                  (void) FormatLocaleString(name,sizeof(name),\"gif:%.11s\",\n                    buffer);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      profile name=%s\",name);\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                if (magick != MagickFalse)\n                  profile=DestroyStringInfo(profile);\n                else\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    SetStringInfoName(profile,name);\n                    (void) AppendValueToLinkedList(profiles,profile);\n                  }\n              }\n            break;\n          }\n          default:\n          {\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            break;\n          }\n        }\n      }\n    if (c != (unsigned char) ',')\n      continue;\n    image_count++;\n    if (image_count != 1)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n      }\n    /*\n      Read image attributes.\n    */\n    meta_image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    meta_image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    meta_image->scene=image->scene;\n    (void) CloneImageProperties(image,meta_image);\n    DestroyImageProperties(meta_image);\n    image->storage_class=PseudoClass;\n    image->compression=LZWCompression;\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    image->depth=8;\n    flag=(unsigned char) ReadBlobByte(image);\n    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;\n    local_colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<\n      ((size_t) (flag & 0x07)+1);\n    image->colors=local_colors;\n    if (opacity >= (ssize_t) image->colors)\n      {\n        image->colors++;\n        opacity=(-1);\n      }\n    image->ticks_per_second=100;\n    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowGIFException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    /*\n      Inititialize colormap.\n    */\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      ThrowGIFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (BitSet((int) flag,0x80) == 0)\n      {\n        /*\n          Use global colormap.\n        */\n        p=global_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            {\n              image->colormap[i].alpha=(double) TransparentAlpha;\n              image->transparent_color=image->colormap[opacity];\n            }\n        }\n        image->background_color=image->colormap[MagickMin((ssize_t) background,\n          (ssize_t) image->colors-1)];\n      }\n    else\n      {\n        unsigned char\n          *colormap;\n\n        /*\n          Read local colormap.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          MagickMax(local_colors,256),3UL*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowGIFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(colormap,0,3*MagickMax(local_colors,256)*\n          sizeof(*colormap));\n        count=ReadBlob(image,(3*local_colors)*sizeof(*colormap),colormap);\n        if (count != (ssize_t) (3*local_colors))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            ThrowGIFException(CorruptImageError,\"InsufficientImageDataInFile\");\n          }\n        p=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            image->colormap[i].alpha=(double) TransparentAlpha;\n        }\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    if (image->gamma == 1.0)\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)\n            break;\n        (void) SetImageColorspace(image,i == (ssize_t) image->colors ?\n          GRAYColorspace : RGBColorspace,exception);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if (profiles != (LinkedListInfo *) NULL)\n          profiles=DestroyLinkedList(profiles,DestroyGIFProfile);\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        return(DestroyImageList(image));\n      }\n    /*\n      Decode image.\n    */\n    if (image_info->ping != MagickFalse)\n      status=PingGIFImage(image,exception);\n    else\n      status=DecodeImage(image,opacity,exception);\n    if ((image_info->ping == MagickFalse) && (status == MagickFalse))\n      ThrowGIFException(CorruptImageError,\"CorruptImage\");\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        StringInfo\n          *profile;\n\n        /*\n          Set image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        profile=(StringInfo *) GetNextValueInLinkedList(profiles);\n        while (profile != (StringInfo *) NULL)\n        {\n          (void) SetImageProfile(image,GetStringInfoName(profile),profile,\n            exception);\n          profile=(StringInfo *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,DestroyGIFProfile);\n      }\n    duration+=image->delay*image->iterations;\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    opacity=(-1);\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n      image->scene-1,image->scene);\n    if (status == MagickFalse)\n      break;\n  }\n  image->duration=duration;\n  if (profiles != (LinkedListInfo *) NULL)\n    profiles=DestroyLinkedList(profiles,DestroyGIFProfile);\n  meta_image=DestroyImage(meta_image);\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r G I F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterGIFImage() adds properties for the GIF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterGIFImage method is:\n%\n%      size_t RegisterGIFImage(void)\n%\n*/\nModuleExport size_t RegisterGIFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"GIF\",\"GIF\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"GIF\",\"GIF87\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->flags^=CoderAdjoinFlag;\n  entry->version=ConstantString(\"version 87a\");\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r G I F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterGIFImage() removes format registrations made by the\n%  GIF module from the list of supported formats.\n%\n%  The format of the UnregisterGIFImage method is:\n%\n%      UnregisterGIFImage(void)\n%\n*/\nModuleExport void UnregisterGIFImage(void)\n{\n  (void) UnregisterMagickInfo(\"GIF\");\n  (void) UnregisterMagickInfo(\"GIF87\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G I F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGIFImage() writes an image to a file in the Compuserve Graphics\n%  image format.\n%\n%  The format of the WriteGIFImage method is:\n%\n%      MagickBooleanType WriteGIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGIFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    delay,\n    imageListLength,\n    length,\n    one;\n\n  ssize_t\n    j,\n    opacity;\n\n  unsigned char\n    *colormap,\n    *global_colormap;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate colormap.\n  */\n  global_colormap=(unsigned char *) AcquireQuantumMemory(768UL,\n    sizeof(*global_colormap));\n  colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n  if ((global_colormap == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (global_colormap != (unsigned char *) NULL)\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i=0; i < 768; i++)\n    colormap[i]=(unsigned char) 0;\n  /*\n    Write GIF header.\n  */\n  write_info=CloneImageInfo(image_info);\n  if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n    (void) WriteBlob(image,6,(unsigned char *) \"GIF89a\");\n  else\n    {\n      (void) WriteBlob(image,6,(unsigned char *) \"GIF87a\");\n      write_info->adjoin=MagickFalse;\n    }\n  /*\n    Determine image bounding box.\n  */\n  page.width=image->columns;\n  if (image->page.width > page.width)\n    page.width=image->page.width;\n  page.height=image->rows;\n  if (image->page.height > page.height)\n    page.height=image->page.height;\n  page.x=image->page.x;\n  page.y=image->page.y;\n  (void) WriteBlobLSBShort(image,(unsigned short) page.width);\n  (void) WriteBlobLSBShort(image,(unsigned short) page.height);\n  /*\n    Write images to file.\n  */\n  if ((write_info->adjoin != MagickFalse) &&\n      (GetNextImageInList(image) != (Image *) NULL))\n    write_info->interlace=NoInterlace;\n  scene=0;\n  one=1;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    opacity=(-1);\n    if (IsImageOpaque(image,exception) != MagickFalse)\n      {\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteType,exception);\n      }\n    else\n      {\n        double\n          alpha,\n          beta;\n\n        /*\n          Identify transparent colormap index.\n        */\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (image->colormap[i].alpha != OpaqueAlpha)\n            {\n              if (opacity < 0)\n                {\n                  opacity=i;\n                  continue;\n                }\n              alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n              beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n              if (alpha < beta)\n                opacity=i;\n            }\n        if (opacity == -1)\n          {\n            (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n            for (i=0; i < (ssize_t) image->colors; i++)\n              if (image->colormap[i].alpha != OpaqueAlpha)\n                {\n                  if (opacity < 0)\n                    {\n                      opacity=i;\n                      continue;\n                    }\n                  alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n                  beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n                  if (alpha < beta)\n                    opacity=i;\n                }\n          }\n        if (opacity >= 0)\n          {\n            image->colormap[opacity].red=image->transparent_color.red;\n            image->colormap[opacity].green=image->transparent_color.green;\n            image->colormap[opacity].blue=image->transparent_color.blue;\n          }\n      }\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (bits_per_pixel=1; bits_per_pixel < 8; bits_per_pixel++)\n      if ((one << bits_per_pixel) >= image->colors)\n        break;\n    q=colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n    }\n    for ( ; i < (ssize_t) (one << bits_per_pixel); i++)\n    {\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n    }\n    if ((GetPreviousImageInList(image) == (Image *) NULL) ||\n        (write_info->adjoin == MagickFalse))\n      {\n        /*\n          Write global colormap.\n        */\n        c=0x80;\n        c|=(8-1) << 4;  /* color resolution */\n        c|=(bits_per_pixel-1);   /* size of global colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        for (j=0; j < (ssize_t) image->colors; j++)\n          if (IsPixelInfoEquivalent(&image->background_color,image->colormap+j))\n            break;\n        (void) WriteBlobByte(image,(unsigned char)\n          (j == (ssize_t) image->colors ? 0 : j));  /* background color */\n        (void) WriteBlobByte(image,(unsigned char) 0x00);  /* reserved */\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n        for (j=0; j < 768; j++)\n          global_colormap[j]=colormap[j];\n      }\n    if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n      {\n        const char\n          *value;\n\n        /*\n          Write graphics control extension.\n        */\n        (void) WriteBlobByte(image,(unsigned char) 0x21);\n        (void) WriteBlobByte(image,(unsigned char) 0xf9);\n        (void) WriteBlobByte(image,(unsigned char) 0x04);\n        c=image->dispose << 2;\n        if (opacity >= 0)\n          c|=0x01;\n        (void) WriteBlobByte(image,(unsigned char) c);\n        delay=(size_t) (100*image->delay/MagickMax((size_t)\n          image->ticks_per_second,1));\n        (void) WriteBlobLSBShort(image,(unsigned short) delay);\n        (void) WriteBlobByte(image,(unsigned char) (opacity >= 0 ? opacity :\n          0));\n        (void) WriteBlobByte(image,(unsigned char) 0x00);\n        value=GetImageProperty(image,\"comment\",exception);\n        if (value != (const char *) NULL)\n          {\n            register const char\n              *p;\n\n            size_t\n              count;\n\n            /*\n              Write comment extension.\n            */\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xfe);\n            for (p=value; *p != '\\0'; )\n            {\n              count=MagickMin(strlen(p),255);\n              (void) WriteBlobByte(image,(unsigned char) count);\n              for (i=0; i < (ssize_t) count; i++)\n                (void) WriteBlobByte(image,(unsigned char) *p++);\n            }\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n            (GetNextImageInList(image) != (Image *) NULL) &&\n            (image->iterations != 1))\n          {\n            /*\n              Write Netscape Loop extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x03);\n            (void) WriteBlobByte(image,(unsigned char) 0x01);\n            (void) WriteBlobLSBShort(image,(unsigned short) (image->iterations ?\n              image->iterations-1 : 0));\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((image->gamma != 1.0f/2.2f))\n          {\n            char\n              attributes[MagickPathExtent];\n\n            ssize_t\n              count;\n\n            /*\n              Write ImageMagick extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"ImageMagick\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"ImageMagick\");\n            count=FormatLocaleString(attributes,MagickPathExtent,\"gamma=%g\",\n              image->gamma);\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlob(image,(size_t) count,(unsigned char *) attributes);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        ResetImageProfileIterator(image);\n        for ( ; ; )\n        {\n          char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          name=GetNextImageProfile(image);\n          if (name == (const char *) NULL)\n            break;\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0) ||\n                (LocaleCompare(name,\"IPTC\") == 0) ||\n                (LocaleCompare(name,\"8BIM\") == 0) ||\n                (LocaleNCompare(name,\"gif:\",4) == 0))\n            {\n               ssize_t\n                 offset;\n\n               unsigned char\n                 *datum;\n\n               datum=GetStringInfoDatum(profile);\n               length=GetStringInfoLength(profile);\n               (void) WriteBlobByte(image,(unsigned char) 0x21);\n               (void) WriteBlobByte(image,(unsigned char) 0xff);\n               (void) WriteBlobByte(image,(unsigned char) 0x0b);\n               if ((LocaleCompare(name,\"ICC\") == 0) ||\n                   (LocaleCompare(name,\"ICM\") == 0))\n                 {\n                   /*\n                     Write ICC extension.\n                   */\n                   (void) WriteBlob(image,11,(unsigned char *) \"ICCRGBG1012\");\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Writing GIF Extension %s\",\"ICCRGBG1012\");\n                 }\n               else\n                 if ((LocaleCompare(name,\"IPTC\") == 0))\n                   {\n                     /*\n                       Write IPTC extension.\n                     */\n                     (void) WriteBlob(image,11,(unsigned char *) \"MGKIPTC0000\");\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  Writing GIF Extension %s\",\"MGKIPTC0000\");\n                   }\n                 else\n                   if ((LocaleCompare(name,\"8BIM\") == 0))\n                     {\n                       /*\n                         Write 8BIM extension.\n                       */\n                        (void) WriteBlob(image,11,(unsigned char *)\n                          \"MGK8BIM0000\");\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing GIF Extension %s\",\"MGK8BIM0000\");\n                     }\n                   else\n                     {\n                       char\n                         extension[MagickPathExtent];\n\n                       /*\n                         Write generic extension.\n                       */\n                       (void) CopyMagickString(extension,name+4,\n                         sizeof(extension));\n                       (void) WriteBlob(image,11,(unsigned char *) extension);\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"  Writing GIF Extension %s\",name);\n                     }\n               offset=0;\n               while ((ssize_t) length > offset)\n               {\n                 size_t\n                   block_length;\n\n                 if ((length-offset) < 255)\n                   block_length=length-offset;\n                 else\n                   block_length=255;\n                 (void) WriteBlobByte(image,(unsigned char) block_length);\n                 (void) WriteBlob(image,(size_t) block_length,datum+offset);\n                 offset+=(ssize_t) block_length;\n               }\n               (void) WriteBlobByte(image,(unsigned char) 0x00);\n            }\n          }\n        }\n      }\n    (void) WriteBlobByte(image,',');  /* image separator */\n    /*\n      Write the image header.\n    */\n    page.x=image->page.x;\n    page.y=image->page.y;\n    if ((image->page.width != 0) && (image->page.height != 0))\n      page=image->page;\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.x < 0 ? 0 : page.x));\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.y < 0 ? 0 : page.y));\n    (void) WriteBlobLSBShort(image,(unsigned short) image->columns);\n    (void) WriteBlobLSBShort(image,(unsigned short) image->rows);\n    c=0x00;\n    if (write_info->interlace != NoInterlace)\n      c|=0x40;  /* pixel data is interlaced */\n    for (j=0; j < (ssize_t) (3*image->colors); j++)\n      if (colormap[j] != global_colormap[j])\n        break;\n    if (j == (ssize_t) (3*image->colors))\n      (void) WriteBlobByte(image,(unsigned char) c);\n    else\n      {\n        c|=0x80;\n        c|=(bits_per_pixel-1);   /* size of local colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n      }\n    /*\n      Write the image data.\n    */\n    c=(int) MagickMax(bits_per_pixel,2);\n    (void) WriteBlobByte(image,(unsigned char) c);\n    status=EncodeImage(write_info,image,(size_t) MagickMax(bits_per_pixel,2)+1,\n      exception);\n    if (status == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n        write_info=DestroyImageInfo(write_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) WriteBlobByte(image,(unsigned char) 0x00);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    scene++;\n    status=SetImageProgress(image,SaveImagesTag,scene,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  (void) WriteBlobByte(image,';'); /* terminator */\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["MagickCore/fourier.c", "coders/gif.c"], "buggy_code_start_loc": [232, 681], "buggy_code_end_loc": [310, 689], "fixing_code_start_loc": [232, 682], "fixing_code_end_loc": [306, 691], "type": "CWE-787", "message": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow in MagickCore/fourier.c in ComplexImage.", "other": {"cve": {"id": "CVE-2019-13308", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.750", "lastModified": "2023-03-02T15:56:47.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow in MagickCore/fourier.c in ComplexImage."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 presenta una vulnerabilidad de desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en MagickCore/fourier.c en ComplexImage."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/61135001a625364e29bdce83832f043eebde7b5a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1595", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/61135001a625364e29bdce83832f043eebde7b5a"}}