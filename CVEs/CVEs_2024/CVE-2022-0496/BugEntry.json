{"buggy_code": ["/*\n *  OpenSCAD (www.openscad.org)\n *  Copyright (C) 2009-2011 Clifford Wolf <clifford@clifford.at> and\n *                          Marius Kintel <marius@kintel.net>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  As a special exception, you have permission to link this program\n *  with the CGAL library and distribute executables, as long as you\n *  follow the requirements of the GNU GPL in regard to all of the\n *  software in the executable aside from CGAL.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n\n#include \"dxfdata.h\"\n#include \"grid.h\"\n#include \"printutils.h\"\n#include \"calc.h\"\n\n#include <fstream>\n#include <assert.h>\n#include <unordered_map>\n#include <boost/lexical_cast.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/filesystem.hpp>\n#include <algorithm>\n#include <sstream>\n#include <map>\n\n#include \"value.h\"\n#include \"boost-utils.h\"\n#include \"Polygon2d.h\"\n#include \"printutils.h\"\n#include \"degree_trig.h\"\n\n\nnamespace fs = boost::filesystem;\n\n/*! \\class DxfData\n\n\tThe DxfData class fulfils multiple tasks, partially for historical reasons.\n\tFIXME: It's a bit messy and is a prime target for refactoring.\n\n\t1) Read DXF file from disk\n\t2) Store contents of DXF files as points, paths and dims\n\t3) Store 2D polygons, both from the polygon() module and from 2D CSG operations.\n\t   Used for tesselation into triangles\n  4) Store 2D polygons before exporting to DXF\n\t\n\n */\n\nstruct Line {\n\tint idx[2]; // indices into DxfData::points\n\tbool disabled;\n\tLine(int i1 = -1, int i2 = -1) : idx{i1, i2}, disabled(false) { }\n};\n\nDxfData::DxfData()\n{\n}\n\n/*!\n\tReads a layer from the given file, or all layers if layername.empty()\n */\nDxfData::DxfData(double fn, double fs, double fa, \n\t\t\t\t\t\t\t\t const std::string &filename, const std::string &layername, \n\t\t\t\t\t\t\t\t double xorigin, double yorigin, double scale)\n{\n\tstd::ifstream stream(filename.c_str());\n\tif (!stream.good()) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Can't open DXF file '%1$s'.\",filename);\n\t\treturn;\n\t}\n\n\tGrid2d<std::vector<int>> grid(GRID_COARSE);\n\tstd::vector<Line> lines;                       // Global lines\n\tstd::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks\n\n\tauto in_entities_section = false;\n\tauto in_blocks_section = false;\n\tstd::string current_block;\n\n#define ADD_LINE(_x1, _y1, _x2, _y2) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tdouble _p1x = _x1, _p1y = _y1, _p2x = _x2, _p2y = _y2;  \\\n\t\tif (!in_entities_section && !in_blocks_section)         \\\n\t\t\tbreak;                                                \\\n\t\tif (in_entities_section &&                              \\\n\t\t\t\t!(layername.empty() || layername == layer))         \\\n\t\t\tbreak;                                                \\\n\t\tgrid.align(_p1x, _p1y);                                 \\\n\t\tgrid.align(_p2x, _p2y);                                 \\\n\t\tgrid.data(_p1x, _p1y).push_back(lines.size());          \\\n\t\tgrid.data(_p2x, _p2y).push_back(lines.size());          \\\n\t\tif (in_entities_section)                                \\\n\t\t\tlines.emplace_back(                                   \\\n\t\t\t  addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \\\n\t\tif (in_blocks_section && !current_block.empty())        \\\n\t\t\tblockdata[current_block].emplace_back(\t              \\\n\t\t\t\taddPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \t\\\n\t} while (0)\n\n\tstd::string mode, layer, name, iddata;\n\tint dimtype = 0;\n\tdouble coords[7][2]; // Used by DIMENSION entities\n\tstd::vector<double> xverts;\n\tstd::vector<double> yverts;\n\tdouble radius = 0;\n\tdouble arc_start_angle = 0, arc_stop_angle = 0;\n\tdouble ellipse_start_angle = 0, ellipse_stop_angle = 0;\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tcoords[i][j] = 0;\n\t\t}\n\t}\n\n\ttypedef std::unordered_map<std::string, int> EntityList;\n\tEntityList unsupported_entities_list;\n\n\t//\n\t// Parse DXF file. Will populate this->points, this->dims, lines and blockdata\n\t//\n\twhile (!stream.eof())\t{\n\t\tstd::string id_str, data;\n\t\tstd::getline(stream, id_str);\n\t\tboost::trim(id_str);\n\t\tstd::getline(stream, data);\n\t\tboost::trim(data);\n\n\t\tint id;\n    try {\n\t\t  id = boost::lexical_cast<int>(id_str);\n    }\n    catch (const boost::bad_lexical_cast &blc) {\n\t\t\tif (!stream.eof()) {\n\t\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal ID '%1$s' in `%2$s'\",id_str,filename);\n\t\t\t}\n\t\t\tbreak;\n  \t}\n    try {\n\t\tif (id >= 10 && id <= 16) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 11 || id == 12 || id == 16) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tif (id >= 20 && id <= 26) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 21 || id == 22 || id == 26) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase 0:\n\t\t\tif (mode == \"SECTION\") {\n\t\t\t\tin_entities_section = iddata == \"ENTITIES\";\n\t\t\t\tin_blocks_section = iddata == \"BLOCKS\";\n\t\t\t}\n\t\t\telse if (mode == \"LINE\") {\n\t\t\t\tADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));\n\t\t\t}\n\t\t\telse if (mode == \"LWPOLYLINE\") {\n\t\t\t\t// assert(xverts.size() == yverts.size());\n\t\t\t\t// Get maximum to enforce managed exception if xverts.size() != yverts.size()\n\t\t\t\tint numverts = std::max(xverts.size(), yverts.size());\n\t\t\t\tfor (int i=1; i<numverts; ++i) {\n\t\t\t\t\tADD_LINE(xverts.at(i-1), yverts.at(i-1), xverts.at(i%numverts), yverts.at(i%numverts));\n\t\t\t\t}\n\t\t\t\t// polyline flag is stored in 'dimtype'\n\t\t\t\tif (dimtype & 0x01) { // closed polyline\n\t\t\t\t\tADD_LINE(xverts.at(numverts-1), yverts.at(numverts-1), xverts.at(0), yverts.at(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"CIRCLE\") {\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = (360.0 * i) / n;\n\t\t\t\t\tdouble a2 = (360.0 *(i + 1)) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ARC\") {\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\twhile (arc_start_angle > arc_stop_angle) {\n\t\t\t\t\tarc_stop_angle += 360.0;\n\t\t\t\t}\n\t\t\t\tdouble arc_angle = arc_stop_angle - arc_start_angle;\n\t\t\t\tn = static_cast<int>(ceil(n * arc_angle / 360));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = arc_start_angle + arc_angle * i / n;\n\t\t\t\t\tdouble a2 = arc_start_angle + arc_angle * (i + 1) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ELLIPSE\") {\n\t\t\t\t// Commented code is meant as documentation of vector math\n\t\t\t\twhile (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;\n//\t\t\t\tVector2d center(xverts[0], yverts[0]);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n//\t\t\t\tVector2d ce(xverts[1], yverts[1]);\n\t\t\t\tVector2d ce(xverts.at(1), yverts.at(1));\n//\t\t\t\tdouble r_major = ce.length();\n\t\t\t\tdouble r_major = sqrt(ce[0]*ce[0] + ce[1]*ce[1]);\n//\t\t\t\tdouble rot_angle = ce.angle();\n\t\t\t\tdouble rot_angle;\n\t\t\t\t{\n//\t\t\t\t\tdouble dot = ce.dot(Vector2d(1.0, 0.0));\n\t\t\t\t\tdouble dot = ce[0];\n\t\t\t\t\tdouble cosval = dot / r_major;\n\t\t\t\t\tif (cosval > 1.0) cosval = 1.0;\n\t\t\t\t\tif (cosval < -1.0) cosval = -1.0;\n\t\t\t\t\trot_angle = acos(cosval);\n\t\t\t\t\tif (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;\n\t\t\t\t}\n\n\t\t\t\t// the ratio stored in 'radius; due to the parser code not checking entity type\n\t\t\t\tdouble r_minor = r_major * radius;\n\t\t\t\tdouble sweep_angle = ellipse_stop_angle-ellipse_start_angle;\n\t\t\t\tint n = Calc::get_fragments_from_r(r_major, fn, fs, fa);\n\t\t\t\tn = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));\n//\t\t\t\tVector2d p1;\n\t\t\t\tVector2d p1{0.0, 0.0};\n\t\t\t\tfor (int i=0; i<=n; ++i) {\n\t\t\t\t\tdouble a = (ellipse_start_angle + sweep_angle*i/n);\n//\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n//\t\t\t\t\tp2.rotate(rot_angle);\n\t\t\t\t\tVector2d p2_rot(cos(rot_angle)*p2[0] - sin(rot_angle)*p2[1],\n\t\t\t\t\t                sin(rot_angle)*p2[0] + cos(rot_angle)*p2[1]);\n//\t\t\t\t\tp2 += center;\n\t\t\t\t\tp2_rot[0] += center[0];\n\t\t\t\t\tp2_rot[1] += center[1];\n\t\t\t\t\tif (i > 0) {\n// \t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2[0], p2[1]);\n\t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);\n\t\t\t\t\t}\n//\t\t\t\t\tp1 = p2;\n\t\t\t\t\tp1[0] = p2_rot[0];\n\t\t\t\t\tp1[1] = p2_rot[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"INSERT\") {\n\t\t\t\t// scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;\n\t\t\t\t// due to the parser code not checking entity type\n\t\t\t\tint n = blockdata[iddata].size();\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a = arc_start_angle;\n\t\t\t\t\tdouble lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble px1 = (cos_degrees(a)*lx1 - sin_degrees(a)*ly1) * scale + xverts.at(0);\n\t\t\t\t\tdouble py1 = (sin_degrees(a)*lx1 + cos_degrees(a)*ly1) * scale + yverts.at(0);\n\t\t\t\t\tdouble px2 = (cos_degrees(a)*lx2 - sin_degrees(a)*ly2) * scale + xverts.at(0);\n\t\t\t\t\tdouble py2 = (sin_degrees(a)*lx2 + cos_degrees(a)*ly2) * scale + yverts.at(0);\n\t\t\t\t\tADD_LINE(px1, py1, px2, py2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"DIMENSION\" &&\n\t\t\t\t\t\t\t (layername.empty() || layername == layer)) {\n\t\t\t\tthis->dims.push_back(Dim());\n\t\t\t\tthis->dims.back().type = dimtype;\n\t\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\tthis->dims.back().coords[i][j] = coords[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis->dims.back().angle = arc_start_angle;\n\t\t\t\tthis->dims.back().length = radius;\n\t\t\t\tthis->dims.back().name = name;\n\t\t\t}\n\t\t\telse if (mode == \"BLOCK\") {\n\t\t\t\tcurrent_block = iddata;\n\t\t\t}\n\t\t\telse if (mode == \"ENDBLK\") {\n\t\t\t\tcurrent_block.erase();\n\t\t\t}\n\t\t\telse if (mode == \"ENDSEC\") {\n\t\t\t}\n\t\t\telse if (in_blocks_section || (in_entities_section &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (layername.empty() || layername == layer))) {\n\t\t\t\tunsupported_entities_list[mode]++;\n\t\t\t}\n\t\t\tmode = data;\n\t\t\tlayer.erase();\n\t\t\tname.erase();\n\t\t\tiddata.erase();\n\t\t\tdimtype = 0;\n\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tcoords[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\txverts.clear();\n\t\t\tyverts.clear();\n\t\t\tradius = arc_start_angle = arc_stop_angle = 0;\n\t\t\tellipse_start_angle = ellipse_stop_angle = 0;\n\t\t\tif (mode == \"INSERT\") {\n\t\t\t\tellipse_start_angle = ellipse_stop_angle = 1.0; // scale\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tname = data;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tiddata = data;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tlayer = data;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\t// CIRCLE, ARC: radius\n\t\t\t// ELLIPSE: minor to major ratio\n\t\t\t// DIMENSION (radial, diameter): Leader length\n\t\t\tradius = boost::lexical_cast<double>(data);\n\t\t\tif (!in_blocks_section) radius *= scale;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\t// ELLIPSE: start_angle\n\t\t\t// INSERT: X scale\n\t\t\tellipse_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\t// ARC: start_angle\n\t\t\t// INSERT: rot angle\n      // DIMENSION: linear and rotated: angle\n\t\t\tarc_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\t// ELLIPSE: stop_angle\n\t\t\t// INSERT: Y scale\n\t\t\tellipse_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 51: // ARC\n\t\t\tarc_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t// LWPOLYLINE: polyline flag\n\t\t\t// DIMENSION: dimension type\n\t\t\tdimtype = boost::lexical_cast<int>(data);\n\t\t\tbreak;\n\t\t}\n    }\n    catch (boost::bad_lexical_cast &blc) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal value '%1$s'in `%2$s'\",data,filename);\n  \t}\n    catch (const std::out_of_range& oor) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Not enough input values for %1$s. in '%2$s'\",data,filename);\n  \t}\n\t}\n\n\tfor (const auto &i : unsupported_entities_list) {\n\t\tif (layername.empty()) {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in %3$s.\",i.first,i.second,QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n\t\t} else {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s\",i.first,i.second,layername,boostfs_uncomplete(filename, fs::current_path()).generic_string());\n\t\t}\n\t}\n\n\t// Extract paths from parsed data\n\n\ttypedef std::map<int, int> LineMap;\n\tLineMap enabled_lines;\n\tfor (size_t i = 0; i < lines.size(); ++i) {\n\t\tenabled_lines[i] = i;\n\t}\n\n\t// extract all open paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line, current_point;\n\n\t\tfor (const auto &l : enabled_lines) {\n\t\t\tint idx = l.second;\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tauto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);\n\t\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\t\tint k = lv.at(ki);\n\t\t\t\t\tif (k == idx || lines[k].disabled) continue;\n\t\t\t\t\tgoto next_open_path_j;\n\t\t\t\t}\n\t\t\t\tcurrent_line = idx;\n\t\t\t\tcurrent_point = j;\n\t\t\t\tgoto create_open_path;\n\t\t\tnext_open_path_j:;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcreate_open_path:\n\t\tthis->paths.push_back(Path());\n\t\tPath *this_path = &this->paths.back();\n\n\t\tthis_path->indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path->indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n\t\t\t\tif (lines[k].disabled) continue;\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_open_path:;\n\t\t}\n\t}\n\n\t// extract all closed paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line = enabled_lines.begin()->second;\n\t\tint current_point = 0;\n\n\t\tthis->paths.push_back(Path());\n\t\tauto& this_path = this->paths.back();\n\t\tthis_path.is_closed = true;\n\t\t\n\t\tthis_path.indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path.indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n\t\t\t\tif (lines[k].disabled) continue;\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_closed_path:;\n\t\t}\n\t}\n\n\tfixup_path_direction();\n\n#if 0\n\tprintf(\"----- DXF Data -----\\n\");\n\tfor (int i = 0; i < this->paths.size(); ++i) {\n\t\tprintf(\"Path %d (%s):\\n\", i, this->paths[i].is_closed ? \"closed\" : \"open\");\n\t\tfor (int j = 0; j < this->paths[i].points.size(); ++j)\n\t\t\tprintf(\"  %f %f\\n\", (*this->paths[i].points[j])[0], (*this->paths[i].points[j])[1]);\n\t}\n\tprintf(\"--------------------\\n\");\n\tfflush(stdout);\n#endif\n}\n\n/*!\n\tEnsures that all paths have the same vertex ordering.\n\tFIXME: CW or CCW?\n*/\nvoid DxfData::fixup_path_direction()\n{\n\tfor (size_t i = 0; i < this->paths.size(); ++i) {\n\t\tif (!this->paths[i].is_closed) break;\n\t\tthis->paths[i].is_inner = true;\n\t\tdouble min_x = this->points[this->paths[i].indices[0]][0];\n\t\tsize_t min_x_point = 0;\n\t\tfor (size_t j = 1; j < this->paths[i].indices.size(); ++j) {\n\t\t\tif (this->points[this->paths[i].indices[j]][0] < min_x) {\n\t\t\t\tmin_x = this->points[this->paths[i].indices[j]][0];\n\t\t\t\tmin_x_point = j;\n\t\t\t}\n\t\t}\n\t\t// rotate points if the path is in non-standard rotation\n\t\tsize_t b = min_x_point;\n\t\tsize_t a = b == 0 ? this->paths[i].indices.size() - 2 : b - 1;\n\t\tsize_t c = b == this->paths[i].indices.size() - 1 ? 1 : b + 1;\n\t\tdouble ax = this->points[this->paths[i].indices[a]][0] - this->points[this->paths[i].indices[b]][0];\n\t\tdouble ay = this->points[this->paths[i].indices[a]][1] - this->points[this->paths[i].indices[b]][1];\n\t\tdouble cx = this->points[this->paths[i].indices[c]][0] - this->points[this->paths[i].indices[b]][0];\n\t\tdouble cy = this->points[this->paths[i].indices[c]][1] - this->points[this->paths[i].indices[b]][1];\n#if 0\n\t\tprintf(\"Rotate check:\\n\");\n\t\tprintf(\"  a/b/c indices = %d %d %d\\n\", a, b, c);\n\t\tprintf(\"  b->a vector = %f %f (%f)\\n\", ax, ay, atan2(ax, ay));\n\t\tprintf(\"  b->c vector = %f %f (%f)\\n\", cx, cy, atan2(cx, cy));\n#endif\n\t\t// FIXME: atan2() usually takes y,x. This variant probably makes the path clockwise..\n\t\tif (atan2(ax, ay) < atan2(cx, cy)) {\n\t\t\tstd::reverse(this->paths[i].indices.begin(), this->paths[i].indices.end());\n\t\t}\n\t}\n}\n\n/*!\n\tAdds a vertex and returns the index into DxfData::points\n */\nint DxfData::addPoint(double x, double y)\n{\n\tthis->points.emplace_back(x, y);\n\treturn this->points.size() - 1;\n}\n\nstd::string DxfData::dump() const\n{\n\tstd::ostringstream out;\n\tout << \"DxfData\"\n\t  << \"\\n num points: \" << points.size()\n\t  << \"\\n num paths: \" << paths.size()\n\t  << \"\\n num dims: \" << dims.size()\n\t  << \"\\n points: \";\n\tfor (size_t k = 0; k < points.size(); ++k ) {\n\t\tout << \"\\n  x y: \" << points[k].transpose();\n\t}\n\tout << \"\\n paths: \";\n\tfor (size_t i = 0; i < paths.size(); ++i) {\n\t\tout << \"\\n  path:\" << i\n\t\t  << \"\\n  is_closed: \" << paths[i].is_closed\n\t\t  << \"\\n  is_inner: \" << paths[i].is_inner ;\n\t\tDxfData::Path path = paths[i];\n\t\tfor (size_t j = 0; j < path.indices.size(); ++j) {\n\t\t\tout << \"\\n  index[\" << j << \"]==\" << path.indices[j];\n\t\t}\n\t}\n\tout << \"\\nDxfData end\";\n\treturn out.str();\n}\n\n/*\n    May return an empty polygon, but will not return nullptr\n */\nPolygon2d *DxfData::toPolygon2d() const\n{\n\tauto poly = new Polygon2d();\n\tfor (size_t i = 0; i < this->paths.size(); ++i) {\n\t\tconst auto &path = this->paths[i];\n\t\tOutline2d outline;\n\t\tsize_t endidx = path.indices.size();\n\t\t// We don't support open paths; closing them to be compatible with existing behavior\n\t\tif (!path.is_closed) endidx++;\n\t\tfor (size_t j = 1; j < endidx; ++j) {\n\t\t\toutline.vertices.push_back(this->points[path.indices[path.indices.size()-j]]);\n\t\t}\n\t\tpoly->addOutline(outline);\n\t}\n\treturn poly;\n}\n"], "fixing_code": ["/*\n *  OpenSCAD (www.openscad.org)\n *  Copyright (C) 2009-2011 Clifford Wolf <clifford@clifford.at> and\n *                          Marius Kintel <marius@kintel.net>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  As a special exception, you have permission to link this program\n *  with the CGAL library and distribute executables, as long as you\n *  follow the requirements of the GNU GPL in regard to all of the\n *  software in the executable aside from CGAL.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n\n#include \"dxfdata.h\"\n#include \"grid.h\"\n#include \"printutils.h\"\n#include \"calc.h\"\n\n#include <fstream>\n#include <assert.h>\n#include <unordered_map>\n#include <boost/lexical_cast.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/filesystem.hpp>\n#include <algorithm>\n#include <sstream>\n#include <map>\n\n#include \"value.h\"\n#include \"boost-utils.h\"\n#include \"Polygon2d.h\"\n#include \"printutils.h\"\n#include \"degree_trig.h\"\n\n\nnamespace fs = boost::filesystem;\n\n/*! \\class DxfData\n\n\tThe DxfData class fulfils multiple tasks, partially for historical reasons.\n\tFIXME: It's a bit messy and is a prime target for refactoring.\n\n\t1) Read DXF file from disk\n\t2) Store contents of DXF files as points, paths and dims\n\t3) Store 2D polygons, both from the polygon() module and from 2D CSG operations.\n\t   Used for tesselation into triangles\n  4) Store 2D polygons before exporting to DXF\n\t\n\n */\n\nstruct Line {\n\tint idx[2]; // indices into DxfData::points\n\tbool disabled;\n\tLine(int i1 = -1, int i2 = -1) : idx{i1, i2}, disabled(false) { }\n};\n\nDxfData::DxfData()\n{\n}\n\n/*!\n\tReads a layer from the given file, or all layers if layername.empty()\n */\nDxfData::DxfData(double fn, double fs, double fa, \n\t\t\t\t\t\t\t\t const std::string &filename, const std::string &layername, \n\t\t\t\t\t\t\t\t double xorigin, double yorigin, double scale)\n{\n\tstd::ifstream stream(filename.c_str());\n\tif (!stream.good()) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Can't open DXF file '%1$s'.\",filename);\n\t\treturn;\n\t}\n\n\tGrid2d<std::vector<int>> grid(GRID_COARSE);\n\tstd::vector<Line> lines;                       // Global lines\n\tstd::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks\n\n\tauto in_entities_section = false;\n\tauto in_blocks_section = false;\n\tstd::string current_block;\n\n#define ADD_LINE(_x1, _y1, _x2, _y2) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tdouble _p1x = _x1, _p1y = _y1, _p2x = _x2, _p2y = _y2;  \\\n\t\tif (!in_entities_section && !in_blocks_section)         \\\n\t\t\tbreak;                                                \\\n\t\tif (in_entities_section &&                              \\\n\t\t\t\t!(layername.empty() || layername == layer))         \\\n\t\t\tbreak;                                                \\\n\t\tgrid.align(_p1x, _p1y);                                 \\\n\t\tgrid.align(_p2x, _p2y);                                 \\\n\t\tgrid.data(_p1x, _p1y).push_back(lines.size());          \\\n\t\tgrid.data(_p2x, _p2y).push_back(lines.size());          \\\n\t\tif (in_entities_section)                                \\\n\t\t\tlines.emplace_back(                                   \\\n\t\t\t  addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \\\n\t\tif (in_blocks_section && !current_block.empty())        \\\n\t\t\tblockdata[current_block].emplace_back(\t              \\\n\t\t\t\taddPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \t\\\n\t} while (0)\n\n\tstd::string mode, layer, name, iddata;\n\tint dimtype = 0;\n\tdouble coords[7][2]; // Used by DIMENSION entities\n\tstd::vector<double> xverts;\n\tstd::vector<double> yverts;\n\tdouble radius = 0;\n\tdouble arc_start_angle = 0, arc_stop_angle = 0;\n\tdouble ellipse_start_angle = 0, ellipse_stop_angle = 0;\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tcoords[i][j] = 0;\n\t\t}\n\t}\n\n\ttypedef std::unordered_map<std::string, int> EntityList;\n\tEntityList unsupported_entities_list;\n\n\t//\n\t// Parse DXF file. Will populate this->points, this->dims, lines and blockdata\n\t//\n\twhile (!stream.eof())\t{\n\t\tstd::string id_str, data;\n\t\tstd::getline(stream, id_str);\n\t\tboost::trim(id_str);\n\t\tstd::getline(stream, data);\n\t\tboost::trim(data);\n\n\t\tint id;\n    try {\n\t\t  id = boost::lexical_cast<int>(id_str);\n    }\n    catch (const boost::bad_lexical_cast &blc) {\n\t\t\tif (!stream.eof()) {\n\t\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal ID '%1$s' in `%2$s'\",id_str,filename);\n\t\t\t}\n\t\t\tbreak;\n  \t}\n    try {\n\t\tif (id >= 10 && id <= 16) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 11 || id == 12 || id == 16) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tif (id >= 20 && id <= 26) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 21 || id == 22 || id == 26) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase 0:\n\t\t\tif (mode == \"SECTION\") {\n\t\t\t\tin_entities_section = iddata == \"ENTITIES\";\n\t\t\t\tin_blocks_section = iddata == \"BLOCKS\";\n\t\t\t}\n\t\t\telse if (mode == \"LINE\") {\n\t\t\t\tADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));\n\t\t\t}\n\t\t\telse if (mode == \"LWPOLYLINE\") {\n\t\t\t\t// assert(xverts.size() == yverts.size());\n\t\t\t\t// Get maximum to enforce managed exception if xverts.size() != yverts.size()\n\t\t\t\tint numverts = std::max(xverts.size(), yverts.size());\n\t\t\t\tfor (int i=1; i<numverts; ++i) {\n\t\t\t\t\tADD_LINE(xverts.at(i-1), yverts.at(i-1), xverts.at(i%numverts), yverts.at(i%numverts));\n\t\t\t\t}\n\t\t\t\t// polyline flag is stored in 'dimtype'\n\t\t\t\tif (dimtype & 0x01) { // closed polyline\n\t\t\t\t\tADD_LINE(xverts.at(numverts-1), yverts.at(numverts-1), xverts.at(0), yverts.at(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"CIRCLE\") {\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = (360.0 * i) / n;\n\t\t\t\t\tdouble a2 = (360.0 *(i + 1)) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ARC\") {\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\twhile (arc_start_angle > arc_stop_angle) {\n\t\t\t\t\tarc_stop_angle += 360.0;\n\t\t\t\t}\n\t\t\t\tdouble arc_angle = arc_stop_angle - arc_start_angle;\n\t\t\t\tn = static_cast<int>(ceil(n * arc_angle / 360));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = arc_start_angle + arc_angle * i / n;\n\t\t\t\t\tdouble a2 = arc_start_angle + arc_angle * (i + 1) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ELLIPSE\") {\n\t\t\t\t// Commented code is meant as documentation of vector math\n\t\t\t\twhile (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;\n//\t\t\t\tVector2d center(xverts[0], yverts[0]);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n//\t\t\t\tVector2d ce(xverts[1], yverts[1]);\n\t\t\t\tVector2d ce(xverts.at(1), yverts.at(1));\n//\t\t\t\tdouble r_major = ce.length();\n\t\t\t\tdouble r_major = sqrt(ce[0]*ce[0] + ce[1]*ce[1]);\n//\t\t\t\tdouble rot_angle = ce.angle();\n\t\t\t\tdouble rot_angle;\n\t\t\t\t{\n//\t\t\t\t\tdouble dot = ce.dot(Vector2d(1.0, 0.0));\n\t\t\t\t\tdouble dot = ce[0];\n\t\t\t\t\tdouble cosval = dot / r_major;\n\t\t\t\t\tif (cosval > 1.0) cosval = 1.0;\n\t\t\t\t\tif (cosval < -1.0) cosval = -1.0;\n\t\t\t\t\trot_angle = acos(cosval);\n\t\t\t\t\tif (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;\n\t\t\t\t}\n\n\t\t\t\t// the ratio stored in 'radius; due to the parser code not checking entity type\n\t\t\t\tdouble r_minor = r_major * radius;\n\t\t\t\tdouble sweep_angle = ellipse_stop_angle-ellipse_start_angle;\n\t\t\t\tint n = Calc::get_fragments_from_r(r_major, fn, fs, fa);\n\t\t\t\tn = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));\n//\t\t\t\tVector2d p1;\n\t\t\t\tVector2d p1{0.0, 0.0};\n\t\t\t\tfor (int i=0; i<=n; ++i) {\n\t\t\t\t\tdouble a = (ellipse_start_angle + sweep_angle*i/n);\n//\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n//\t\t\t\t\tp2.rotate(rot_angle);\n\t\t\t\t\tVector2d p2_rot(cos(rot_angle)*p2[0] - sin(rot_angle)*p2[1],\n\t\t\t\t\t                sin(rot_angle)*p2[0] + cos(rot_angle)*p2[1]);\n//\t\t\t\t\tp2 += center;\n\t\t\t\t\tp2_rot[0] += center[0];\n\t\t\t\t\tp2_rot[1] += center[1];\n\t\t\t\t\tif (i > 0) {\n// \t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2[0], p2[1]);\n\t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);\n\t\t\t\t\t}\n//\t\t\t\t\tp1 = p2;\n\t\t\t\t\tp1[0] = p2_rot[0];\n\t\t\t\t\tp1[1] = p2_rot[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"INSERT\") {\n\t\t\t\t// scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;\n\t\t\t\t// due to the parser code not checking entity type\n\t\t\t\tint n = blockdata[iddata].size();\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a = arc_start_angle;\n\t\t\t\t\tdouble lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble px1 = (cos_degrees(a)*lx1 - sin_degrees(a)*ly1) * scale + xverts.at(0);\n\t\t\t\t\tdouble py1 = (sin_degrees(a)*lx1 + cos_degrees(a)*ly1) * scale + yverts.at(0);\n\t\t\t\t\tdouble px2 = (cos_degrees(a)*lx2 - sin_degrees(a)*ly2) * scale + xverts.at(0);\n\t\t\t\t\tdouble py2 = (sin_degrees(a)*lx2 + cos_degrees(a)*ly2) * scale + yverts.at(0);\n\t\t\t\t\tADD_LINE(px1, py1, px2, py2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"DIMENSION\" &&\n\t\t\t\t\t\t\t (layername.empty() || layername == layer)) {\n\t\t\t\tthis->dims.push_back(Dim());\n\t\t\t\tthis->dims.back().type = dimtype;\n\t\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\tthis->dims.back().coords[i][j] = coords[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis->dims.back().angle = arc_start_angle;\n\t\t\t\tthis->dims.back().length = radius;\n\t\t\t\tthis->dims.back().name = name;\n\t\t\t}\n\t\t\telse if (mode == \"BLOCK\") {\n\t\t\t\tcurrent_block = iddata;\n\t\t\t}\n\t\t\telse if (mode == \"ENDBLK\") {\n\t\t\t\tcurrent_block.erase();\n\t\t\t}\n\t\t\telse if (mode == \"ENDSEC\") {\n\t\t\t}\n\t\t\telse if (in_blocks_section || (in_entities_section &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (layername.empty() || layername == layer))) {\n\t\t\t\tunsupported_entities_list[mode]++;\n\t\t\t}\n\t\t\tmode = data;\n\t\t\tlayer.erase();\n\t\t\tname.erase();\n\t\t\tiddata.erase();\n\t\t\tdimtype = 0;\n\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tcoords[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\txverts.clear();\n\t\t\tyverts.clear();\n\t\t\tradius = arc_start_angle = arc_stop_angle = 0;\n\t\t\tellipse_start_angle = ellipse_stop_angle = 0;\n\t\t\tif (mode == \"INSERT\") {\n\t\t\t\tellipse_start_angle = ellipse_stop_angle = 1.0; // scale\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tname = data;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tiddata = data;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tlayer = data;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\t// CIRCLE, ARC: radius\n\t\t\t// ELLIPSE: minor to major ratio\n\t\t\t// DIMENSION (radial, diameter): Leader length\n\t\t\tradius = boost::lexical_cast<double>(data);\n\t\t\tif (!in_blocks_section) radius *= scale;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\t// ELLIPSE: start_angle\n\t\t\t// INSERT: X scale\n\t\t\tellipse_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\t// ARC: start_angle\n\t\t\t// INSERT: rot angle\n      // DIMENSION: linear and rotated: angle\n\t\t\tarc_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\t// ELLIPSE: stop_angle\n\t\t\t// INSERT: Y scale\n\t\t\tellipse_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 51: // ARC\n\t\t\tarc_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t// LWPOLYLINE: polyline flag\n\t\t\t// DIMENSION: dimension type\n\t\t\tdimtype = boost::lexical_cast<int>(data);\n\t\t\tbreak;\n\t\t}\n    }\n    catch (boost::bad_lexical_cast &blc) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal value '%1$s'in `%2$s'\",data,filename);\n  \t}\n    catch (const std::out_of_range& oor) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Not enough input values for %1$s. in '%2$s'\",data,filename);\n  \t}\n\t}\n\n\tfor (const auto &i : unsupported_entities_list) {\n\t\tif (layername.empty()) {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in %3$s.\",i.first,i.second,QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n\t\t} else {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s\",i.first,i.second,layername,boostfs_uncomplete(filename, fs::current_path()).generic_string());\n\t\t}\n\t}\n\n\t// Extract paths from parsed data\n\n\ttypedef std::map<int, int> LineMap;\n\tLineMap enabled_lines;\n\tfor (size_t i = 0; i < lines.size(); ++i) {\n\t\tenabled_lines[i] = i;\n\t}\n\n\t// extract all open paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line, current_point;\n\n\t\tfor (const auto &l : enabled_lines) {\n\t\t\tint idx = l.second;\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tauto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);\n\t\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\t\tint k = lv.at(ki);\n                    if (k < 0 || k >= lines.size()) {\n                        LOG(message_group::Warning,Location::NONE,\"\",\n                            \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n                        continue;\n                    }\n\t\t\t\t\tif (k == idx || lines[k].disabled) continue;\n\t\t\t\t\tgoto next_open_path_j;\n\t\t\t\t}\n\t\t\t\tcurrent_line = idx;\n\t\t\t\tcurrent_point = j;\n\t\t\t\tgoto create_open_path;\n\t\t\tnext_open_path_j:;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcreate_open_path:\n\t\tthis->paths.push_back(Path());\n\t\tPath *this_path = &this->paths.back();\n\n\t\tthis_path->indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path->indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n                if (k < 0 || k >= lines.size()) {\n                    LOG(message_group::Warning,Location::NONE,\"\",\n                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n                    continue;\n                }\n\t\t\t\tif (lines[k].disabled) continue;\n                auto idk0 = lines[k].idx[0];    // make it easier to read and debug\n                auto idk1 = lines[k].idx[1];\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_open_path:;\n\t\t}\n\t}\n\n\t// extract all closed paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line = enabled_lines.begin()->second;\n\t\tint current_point = 0;\n\n\t\tthis->paths.push_back(Path());\n\t\tauto& this_path = this->paths.back();\n\t\tthis_path.is_closed = true;\n\t\t\n\t\tthis_path.indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path.indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n                if (k < 0 || k >= lines.size()) {\n                    LOG(message_group::Warning,Location::NONE,\"\",\n                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n                    continue;\n                }\n\t\t\t\tif (lines[k].disabled) continue;\n                auto idk0 = lines[k].idx[0];    // make it easier to read and debug\n                auto idk1 = lines[k].idx[1];\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n                if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_closed_path:;\n\t\t}\n\t}\n\n\tfixup_path_direction();\n\n#if 0\n\tprintf(\"----- DXF Data -----\\n\");\n\tfor (int i = 0; i < this->paths.size(); ++i) {\n\t\tprintf(\"Path %d (%s):\\n\", i, this->paths[i].is_closed ? \"closed\" : \"open\");\n\t\tfor (int j = 0; j < this->paths[i].points.size(); ++j)\n\t\t\tprintf(\"  %f %f\\n\", (*this->paths[i].points[j])[0], (*this->paths[i].points[j])[1]);\n\t}\n\tprintf(\"--------------------\\n\");\n\tfflush(stdout);\n#endif\n}\n\n/*!\n\tEnsures that all paths have the same vertex ordering.\n\tFIXME: CW or CCW?\n*/\nvoid DxfData::fixup_path_direction()\n{\n\tfor (size_t i = 0; i < this->paths.size(); ++i) {\n\t\tif (!this->paths[i].is_closed) break;\n\t\tthis->paths[i].is_inner = true;\n\t\tdouble min_x = this->points[this->paths[i].indices[0]][0];\n\t\tsize_t min_x_point = 0;\n\t\tfor (size_t j = 1; j < this->paths[i].indices.size(); ++j) {\n\t\t\tif (this->points[this->paths[i].indices[j]][0] < min_x) {\n\t\t\t\tmin_x = this->points[this->paths[i].indices[j]][0];\n\t\t\t\tmin_x_point = j;\n\t\t\t}\n\t\t}\n\t\t// rotate points if the path is in non-standard rotation\n\t\tsize_t b = min_x_point;\n\t\tsize_t a = b == 0 ? this->paths[i].indices.size() - 2 : b - 1;\n\t\tsize_t c = b == this->paths[i].indices.size() - 1 ? 1 : b + 1;\n\t\tdouble ax = this->points[this->paths[i].indices[a]][0] - this->points[this->paths[i].indices[b]][0];\n\t\tdouble ay = this->points[this->paths[i].indices[a]][1] - this->points[this->paths[i].indices[b]][1];\n\t\tdouble cx = this->points[this->paths[i].indices[c]][0] - this->points[this->paths[i].indices[b]][0];\n\t\tdouble cy = this->points[this->paths[i].indices[c]][1] - this->points[this->paths[i].indices[b]][1];\n#if 0\n\t\tprintf(\"Rotate check:\\n\");\n\t\tprintf(\"  a/b/c indices = %d %d %d\\n\", a, b, c);\n\t\tprintf(\"  b->a vector = %f %f (%f)\\n\", ax, ay, atan2(ax, ay));\n\t\tprintf(\"  b->c vector = %f %f (%f)\\n\", cx, cy, atan2(cx, cy));\n#endif\n\t\t// FIXME: atan2() usually takes y,x. This variant probably makes the path clockwise..\n\t\tif (atan2(ax, ay) < atan2(cx, cy)) {\n\t\t\tstd::reverse(this->paths[i].indices.begin(), this->paths[i].indices.end());\n\t\t}\n\t}\n}\n\n/*!\n\tAdds a vertex and returns the index into DxfData::points\n */\nint DxfData::addPoint(double x, double y)\n{\n\tthis->points.emplace_back(x, y);\n\treturn this->points.size() - 1;\n}\n\nstd::string DxfData::dump() const\n{\n\tstd::ostringstream out;\n\tout << \"DxfData\"\n\t  << \"\\n num points: \" << points.size()\n\t  << \"\\n num paths: \" << paths.size()\n\t  << \"\\n num dims: \" << dims.size()\n\t  << \"\\n points: \";\n\tfor (size_t k = 0; k < points.size(); ++k ) {\n\t\tout << \"\\n  x y: \" << points[k].transpose();\n\t}\n\tout << \"\\n paths: \";\n\tfor (size_t i = 0; i < paths.size(); ++i) {\n\t\tout << \"\\n  path:\" << i\n\t\t  << \"\\n  is_closed: \" << paths[i].is_closed\n\t\t  << \"\\n  is_inner: \" << paths[i].is_inner ;\n\t\tDxfData::Path path = paths[i];\n\t\tfor (size_t j = 0; j < path.indices.size(); ++j) {\n\t\t\tout << \"\\n  index[\" << j << \"]==\" << path.indices[j];\n\t\t}\n\t}\n\tout << \"\\nDxfData end\";\n\treturn out.str();\n}\n\n/*\n    May return an empty polygon, but will not return nullptr\n */\nPolygon2d *DxfData::toPolygon2d() const\n{\n\tauto poly = new Polygon2d();\n\tfor (size_t i = 0; i < this->paths.size(); ++i) {\n\t\tconst auto &path = this->paths[i];\n\t\tOutline2d outline;\n\t\tsize_t endidx = path.indices.size();\n\t\t// We don't support open paths; closing them to be compatible with existing behavior\n\t\tif (!path.is_closed) endidx++;\n\t\tfor (size_t j = 1; j < endidx; ++j) {\n\t\t\toutline.vertices.push_back(this->points[path.indices[path.indices.size()-j]]);\n\t\t}\n\t\tpoly->addOutline(outline);\n\t}\n\treturn poly;\n}\n"], "filenames": ["src/dxfdata.cc"], "buggy_code_start_loc": [443], "buggy_code_end_loc": [511], "fixing_code_start_loc": [444], "fixing_code_end_loc": [530], "type": "CWE-125", "message": "A vulnerbiility was found in Openscad, where a DXF-format drawing with particular (not necessarily malformed!) properties may cause an out-of-bounds memory access when imported using import().", "other": {"cve": {"id": "CVE-2022-0496", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-29T15:15:09.597", "lastModified": "2022-09-01T20:33:20.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerbiility was found in Openscad, where a DXF-format drawing with particular (not necessarily malformed!) properties may cause an out-of-bounds memory access when imported using import()."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad en Openscad, donde un dibujo en formato DXF con propiedades particulares (\u00a1no necesariamente malformadas!) puede causar un acceso a memoria fuera de l\u00edmites cuando se importa usando import()"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openscad:openscad:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-02-04", "matchCriteriaId": "B1CAB560-2A16-496D-8216-1EC6B102BB0A"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2050695", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/openscad/openscad/commit/00a4692989c4e2f191525f73f24ad8727bacdf41", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openscad/openscad/commit/770e3234cbfe66edbc0333f796b46d36a74aa652", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openscad/openscad/issues/4037", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openscad/openscad/commit/00a4692989c4e2f191525f73f24ad8727bacdf41"}}