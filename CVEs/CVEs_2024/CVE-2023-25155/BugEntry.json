{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h>\n\n/*-----------------------------------------------------------------------------\n * Hash type API\n *----------------------------------------------------------------------------*/\n\n/* Check the length of a number of objects to see if we need to convert a\n * listpack to a real hash. Note that we only check string encoded objects\n * as their string length can be queried in constant time. */\nvoid hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    size_t sum = 0;\n\n    if (o->encoding != OBJ_ENCODING_LISTPACK) return;\n\n    for (i = start; i <= end; i++) {\n        if (!sdsEncodedObject(argv[i]))\n            continue;\n        size_t len = sdslen(argv[i]->ptr);\n        if (len > server.hash_max_listpack_value) {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            return;\n        }\n        sum += len;\n    }\n    if (!lpSafeToAdd(o->ptr, sum))\n        hashTypeConvert(o, OBJ_ENCODING_HT);\n}\n\n/* Get the value from a listpack encoded hash, identified by field.\n * Returns -1 when the field cannot be found. */\nint hashTypeGetFromListpack(robj *o, sds field,\n                            unsigned char **vstr,\n                            unsigned int *vlen,\n                            long long *vll)\n{\n    unsigned char *zl, *fptr = NULL, *vptr = NULL;\n\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    zl = o->ptr;\n    fptr = lpFirst(zl);\n    if (fptr != NULL) {\n        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n        if (fptr != NULL) {\n            /* Grab pointer to the value (fptr points to the field) */\n            vptr = lpNext(zl, fptr);\n            serverAssert(vptr != NULL);\n        }\n    }\n\n    if (vptr != NULL) {\n        *vstr = lpGetValue(vptr, vlen, vll);\n        return 0;\n    }\n\n    return -1;\n}\n\n/* Get the value from a hash table encoded hash, identified by field.\n * Returns NULL when the field cannot be found, otherwise the SDS value\n * is returned. */\nsds hashTypeGetFromHashTable(robj *o, sds field) {\n    dictEntry *de;\n\n    serverAssert(o->encoding == OBJ_ENCODING_HT);\n\n    de = dictFind(o->ptr, field);\n    if (de == NULL) return NULL;\n    return dictGetVal(de);\n}\n\n/* Higher level function of hashTypeGet*() that returns the hash value\n * associated with the specified field. If the field is found C_OK\n * is returned, otherwise C_ERR. The returned object is returned by\n * reference in either *vstr and *vlen if it's returned in string form,\n * or stored in *vll if it's returned as a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * for C_OK and checking if vll (or vstr) is NULL. */\nint hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)\n            return C_OK;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        sds value;\n        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {\n            *vstr = (unsigned char*) value;\n            *vlen = sdslen(value);\n            return C_OK;\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_ERR;\n}\n\n/* Like hashTypeGetValue() but returns a Redis object, which is useful for\n * interaction with the hash type outside t_hash.c.\n * The function returns NULL if the field is not found in the hash. Otherwise\n * a newly allocated string object with the value is returned. */\nrobj *hashTypeGetValueObject(robj *o, sds field) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;\n    if (vstr) return createStringObject((char*)vstr,vlen);\n    else return createStringObjectFromLongLong(vll);\n}\n\n/* Higher level function using hashTypeGet*() to return the length of the\n * object associated with the requested field, or 0 if the field does not\n * exist. */\nsize_t hashTypeGetValueLength(robj *o, sds field) {\n    size_t len = 0;\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)\n        len = vstr ? vlen : sdigits10(vll);\n\n    return len;\n}\n\n/* Test if the specified field exists in the given hash. Returns 1 if the field\n * exists, and 0 when it doesn't. */\nint hashTypeExists(robj *o, sds field) {\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;\n}\n\n/* Add a new field, overwrite the old with the new value if it already exists.\n * Return 0 on insert and 1 on update.\n *\n * By default, the key and value SDS strings are copied if needed, so the\n * caller retains ownership of the strings passed. However this behavior\n * can be effected by passing appropriate flags (possibly bitwise OR-ed):\n *\n * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.\n * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.\n *\n * When the flags are used the caller does not need to release the passed\n * SDS string(s). It's up to the function to use the string to create a new\n * entry or to free the SDS string before returning to the caller.\n *\n * HASH_SET_COPY corresponds to no flags passed, and means the default\n * semantics of copying the values if needed.\n *\n */\n#define HASH_SET_TAKE_FIELD (1<<0)\n#define HASH_SET_TAKE_VALUE (1<<1)\n#define HASH_SET_COPY 0\nint hashTypeSet(robj *o, sds field, sds value, int flags) {\n    int update = 0;\n\n    /* Check if the field is too long for listpack, and convert before adding the item.\n     * This is needed for HINCRBY* case since in other commands this is handled early by\n     * hashTypeTryConversion, so this check will be a NOP. */\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    }\n    \n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr, *vptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Grab pointer to the value (fptr points to the field) */\n                vptr = lpNext(zl, fptr);\n                serverAssert(vptr != NULL);\n                update = 1;\n\n                /* Replace value */\n                zl = lpReplace(zl, &vptr, (unsigned char*)value, sdslen(value));\n            }\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the listpack */\n            zl = lpAppend(zl, (unsigned char*)field, sdslen(field));\n            zl = lpAppend(zl, (unsigned char*)value, sdslen(value));\n        }\n        o->ptr = zl;\n\n        /* Check if the listpack needs to be converted to a hash table */\n        if (hashTypeLength(o) > server.hash_max_listpack_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictFind(o->ptr,field);\n        if (de) {\n            sdsfree(dictGetVal(de));\n            if (flags & HASH_SET_TAKE_VALUE) {\n                dictGetVal(de) = value;\n                value = NULL;\n            } else {\n                dictGetVal(de) = sdsdup(value);\n            }\n            update = 1;\n        } else {\n            sds f,v;\n            if (flags & HASH_SET_TAKE_FIELD) {\n                f = field;\n                field = NULL;\n            } else {\n                f = sdsdup(field);\n            }\n            if (flags & HASH_SET_TAKE_VALUE) {\n                v = value;\n                value = NULL;\n            } else {\n                v = sdsdup(value);\n            }\n            dictAdd(o->ptr,f,v);\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n\n    /* Free SDS strings we did not referenced elsewhere if the flags\n     * want this function to be responsible. */\n    if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);\n    if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);\n    return update;\n}\n\n/* Delete an element from a hash.\n * Return 1 on deleted and 0 on not found. */\nint hashTypeDelete(robj *o, sds field) {\n    int deleted = 0;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Delete both of the key and the value. */\n                zl = lpDeleteRangeWithEntry(zl,&fptr,2);\n                o->ptr = zl;\n                deleted = 1;\n            }\n        }\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete((dict*)o->ptr, field) == C_OK) {\n            deleted = 1;\n\n            /* Always check if the dictionary needs a resize after a delete. */\n            if (htNeedsResize(o->ptr)) dictResize(o->ptr);\n        }\n\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return deleted;\n}\n\n/* Return the number of elements in a hash. */\nunsigned long hashTypeLength(const robj *o) {\n    unsigned long length = ULONG_MAX;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        length = lpLength(o->ptr) / 2;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        length = dictSize((const dict*)o->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return length;\n}\n\nhashTypeIterator *hashTypeInitIterator(robj *subject) {\n    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));\n    hi->subject = subject;\n    hi->encoding = subject->encoding;\n\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        hi->fptr = NULL;\n        hi->vptr = NULL;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        hi->di = dictGetIterator(subject->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hi;\n}\n\nvoid hashTypeReleaseIterator(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(hi->di);\n    zfree(hi);\n}\n\n/* Move to the next entry in the hash. Return C_OK when the next entry\n * could be found and C_ERR when the iterator reaches the end. */\nint hashTypeNext(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl;\n        unsigned char *fptr, *vptr;\n\n        zl = hi->subject->ptr;\n        fptr = hi->fptr;\n        vptr = hi->vptr;\n\n        if (fptr == NULL) {\n            /* Initialize cursor */\n            serverAssert(vptr == NULL);\n            fptr = lpFirst(zl);\n        } else {\n            /* Advance cursor */\n            serverAssert(vptr != NULL);\n            fptr = lpNext(zl, vptr);\n        }\n        if (fptr == NULL) return C_ERR;\n\n        /* Grab pointer to the value (fptr points to the field) */\n        vptr = lpNext(zl, fptr);\n        serverAssert(vptr != NULL);\n\n        /* fptr, vptr now point to the first or next pair */\n        hi->fptr = fptr;\n        hi->vptr = vptr;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_OK;\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a listpack. Prototype is similar to `hashTypeGetFromListpack`. */\nvoid hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,\n                                 unsigned char **vstr,\n                                 unsigned int *vlen,\n                                 long long *vll)\n{\n    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (what & OBJ_HASH_KEY) {\n        *vstr = lpGetValue(hi->fptr, vlen, vll);\n    } else {\n        *vstr = lpGetValue(hi->vptr, vlen, vll);\n    }\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a hash table. Prototype is similar to\n * `hashTypeGetFromHashTable`. */\nsds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {\n    serverAssert(hi->encoding == OBJ_ENCODING_HT);\n\n    if (what & OBJ_HASH_KEY) {\n        return dictGetKey(hi->de);\n    } else {\n        return dictGetVal(hi->de);\n    }\n}\n\n/* Higher level function of hashTypeCurrent*() that returns the hash value\n * at current iterator position.\n *\n * The returned element is returned by reference in either *vstr and *vlen if\n * it's returned in string form, or stored in *vll if it's returned as\n * a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * type checking if vstr == NULL. */\nvoid hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        hashTypeCurrentFromListpack(hi, what, vstr, vlen, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds ele = hashTypeCurrentFromHashTable(hi, what);\n        *vstr = (unsigned char*) ele;\n        *vlen = sdslen(ele);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* Return the key or value at the current iterator position as a new\n * SDS string. */\nsds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);\n    if (vstr) return sdsnewlen(vstr,vlen);\n    return sdsfromlonglong(vll);\n}\n\nrobj *hashTypeLookupWriteOrCreate(client *c, robj *key) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (checkType(c,o,OBJ_HASH)) return NULL;\n\n    if (o == NULL) {\n        o = createHashObject();\n        dbAdd(c->db,key,o);\n    }\n    return o;\n}\n\n\nvoid hashTypeConvertListpack(robj *o, int enc) {\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (enc == OBJ_ENCODING_LISTPACK) {\n        /* Nothing to do... */\n\n    } else if (enc == OBJ_ENCODING_HT) {\n        hashTypeIterator *hi;\n        dict *dict;\n        int ret;\n\n        hi = hashTypeInitIterator(o);\n        dict = dictCreate(&hashDictType);\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(dict,hashTypeLength(o));\n\n        while (hashTypeNext(hi) != C_ERR) {\n            sds key, value;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(dict, key, value);\n            if (ret != DICT_OK) {\n                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */\n                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */\n                serverLogHexDump(LL_WARNING,\"listpack with dup elements dump\",\n                    o->ptr,lpBytes(o->ptr));\n                serverPanic(\"Listpack corruption detected\");\n            }\n        }\n        hashTypeReleaseIterator(hi);\n        zfree(o->ptr);\n        o->encoding = OBJ_ENCODING_HT;\n        o->ptr = dict;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid hashTypeConvert(robj *o, int enc) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        hashTypeConvertListpack(o, enc);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        serverPanic(\"Not implemented\");\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a hash object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *hashTypeDup(robj *o) {\n    robj *hobj;\n    hashTypeIterator *hi;\n\n    serverAssert(o->type == OBJ_HASH);\n\n    if(o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = o->ptr;\n        size_t sz = lpBytes(zl);\n        unsigned char *new_zl = zmalloc(sz);\n        memcpy(new_zl, zl, sz);\n        hobj = createObject(OBJ_HASH, new_zl);\n        hobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else if(o->encoding == OBJ_ENCODING_HT){\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, dictSize((const dict*)o->ptr));\n\n        hi = hashTypeInitIterator(o);\n        while (hashTypeNext(hi) != C_ERR) {\n            sds field, value;\n            sds newfield, newvalue;\n            /* Extract a field-value pair from an original hash object.*/\n            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);\n            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);\n            newfield = sdsdup(field);\n            newvalue = sdsdup(value);\n\n            /* Add a field-value pair to a new hash object. */\n            dictAdd(d,newfield,newvalue);\n        }\n        hashTypeReleaseIterator(hi);\n\n        hobj = createObject(OBJ_HASH, d);\n        hobj->encoding = OBJ_ENCODING_HT;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hobj;\n}\n\n/* Create a new sds string from the listpack entry. */\nsds hashSdsFromListpackEntry(listpackEntry *e) {\n    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);\n}\n\n/* Reply with bulk string from the listpack entry. */\nvoid hashReplyFromListpackEntry(client *c, listpackEntry *e) {\n    if (e->sval)\n        addReplyBulkCBuffer(c, e->sval, e->slen);\n    else\n        addReplyBulkLongLong(c, e->lval);\n}\n\n/* Return random element from a non empty hash.\n * 'key' and 'val' will be set to hold the element.\n * The memory in them is not to be freed or modified by the caller.\n * 'val' can be NULL in which case it's not extracted. */\nvoid hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {\n    if (hashobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);\n        sds s = dictGetKey(de);\n        key->sval = (unsigned char*)s;\n        key->slen = sdslen(s);\n        if (val) {\n            sds s = dictGetVal(de);\n            val->sval = (unsigned char*)s;\n            val->slen = sdslen(s);\n        }\n    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {\n        lpRandomPair(hashobj->ptr, hashsize, key, val);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n\n/*-----------------------------------------------------------------------------\n * Hash type commands\n *----------------------------------------------------------------------------*/\n\nvoid hsetnxCommand(client *c) {\n    robj *o;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n\n    if (hashTypeExists(o, c->argv[2]->ptr)) {\n        addReply(c, shared.czero);\n    } else {\n        hashTypeTryConversion(o,c->argv,2,3);\n        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);\n        addReply(c, shared.cone);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid hsetCommand(client *c) {\n    int i, created = 0;\n    robj *o;\n\n    if ((c->argc % 2) == 1) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,c->argc-1);\n\n    for (i = 2; i < c->argc; i += 2)\n        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);\n\n    /* HMSET (deprecated) and HSET return value is different. */\n    char *cmdname = c->argv[0]->ptr;\n    if (cmdname[1] == 's' || cmdname[1] == 'S') {\n        /* HSET */\n        addReplyLongLong(c, created);\n    } else {\n        /* HMSET */\n        addReply(c, shared.ok);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n    server.dirty += (c->argc - 2)/2;\n}\n\nvoid hincrbyCommand(client *c) {\n    long long value, incr, oldvalue;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {\n        if (vstr) {\n            if (string2ll((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not an integer\");\n                return;\n            }\n        } /* Else hashTypeGetValue() already stored it into &value */\n    } else {\n        value = 0;\n    }\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n    new = sdsfromlonglong(value);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyLongLong(c,value);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrby\",c->argv[1],c->db->id);\n    server.dirty++;\n}\n\nvoid hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n\nstatic void addHashFieldToReply(client *c, robj *o, sds field) {\n    if (o == NULL) {\n        addReplyNull(c);\n        return;\n    }\n\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {\n        if (vstr) {\n            addReplyBulkCBuffer(c, vstr, vlen);\n        } else {\n            addReplyBulkLongLong(c, vll);\n        }\n    } else {\n        addReplyNull(c);\n    }\n}\n\nvoid hgetCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addHashFieldToReply(c, o, c->argv[2]->ptr);\n}\n\nvoid hmgetCommand(client *c) {\n    robj *o;\n    int i;\n\n    /* Don't abort when the key cannot be found. Non-existing keys are empty\n     * hashes, where HMGET should respond with a series of null bulks. */\n    o = lookupKeyRead(c->db, c->argv[1]);\n    if (checkType(c,o,OBJ_HASH)) return;\n\n    addReplyArrayLen(c, c->argc-2);\n    for (i = 2; i < c->argc; i++) {\n        addHashFieldToReply(c, o, c->argv[i]->ptr);\n    }\n}\n\nvoid hdelCommand(client *c) {\n    robj *o;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (hashTypeDelete(o,c->argv[j]->ptr)) {\n            deleted++;\n            if (hashTypeLength(o) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hdel\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid hlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReplyLongLong(c,hashTypeLength(o));\n}\n\nvoid hstrlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));\n}\n\nstatic void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *vstr = NULL;\n        unsigned int vlen = UINT_MAX;\n        long long vll = LLONG_MAX;\n\n        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);\n        if (vstr)\n            addReplyBulkCBuffer(c, vstr, vlen);\n        else\n            addReplyBulkLongLong(c, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds value = hashTypeCurrentFromHashTable(hi, what);\n        addReplyBulkCBuffer(c, value, sdslen(value));\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid genericHgetallCommand(client *c, int flags) {\n    robj *o;\n    hashTypeIterator *hi;\n    int length, count = 0;\n\n    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?\n        shared.emptymap[c->resp] : shared.emptyarray;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))\n        == NULL || checkType(c,o,OBJ_HASH)) return;\n\n    /* We return a map if the user requested keys and values, like in the\n     * HGETALL case. Otherwise to use a flat array makes more sense. */\n    length = hashTypeLength(o);\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {\n        addReplyMapLen(c, length);\n    } else {\n        addReplyArrayLen(c, length);\n    }\n\n    hi = hashTypeInitIterator(o);\n    while (hashTypeNext(hi) != C_ERR) {\n        if (flags & OBJ_HASH_KEY) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            count++;\n        }\n        if (flags & OBJ_HASH_VALUE) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n            count++;\n        }\n    }\n\n    hashTypeReleaseIterator(hi);\n\n    /* Make sure we returned the right number of elements. */\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) count /= 2;\n    serverAssert(count == length);\n}\n\nvoid hkeysCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY);\n}\n\nvoid hvalsCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_VALUE);\n}\n\nvoid hgetallCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);\n}\n\nvoid hexistsCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);\n}\n\nvoid hscanCommand(client *c) {\n    robj *o;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    scanGenericCommand(c,o,cursor);\n}\n\nstatic void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {\n    for (unsigned long i = 0; i < count; i++) {\n        if (vals && c->resp > 2)\n            addReplyArrayLen(c,2);\n        if (keys[i].sval)\n            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);\n        else\n            addReplyBulkLongLong(c, keys[i].lval);\n        if (vals) {\n            if (vals[i].sval)\n                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);\n            else\n                addReplyBulkLongLong(c, vals[i].lval);\n        }\n    }\n}\n\n/* How many times bigger should be the hash compared to the requested size\n * for us to not use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define HRANDFIELD_SUB_STRATEGY_MUL 3\n\n/* If client is trying to ask for a very large number of random elements,\n * queuing may consume an unlimited amount of memory, so we want to limit\n * the number of randoms per time. */\n#define HRANDFIELD_RANDOM_SAMPLE_LIMIT 1000\n\nvoid hrandfieldWithCountCommand(client *c, long l, int withvalues) {\n    unsigned long count, size;\n    int uniq = 1;\n    robj *hash;\n\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,hash,OBJ_HASH)) return;\n    size = hashTypeLength(hash);\n\n    if(l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        count = -l;\n        uniq = 0;\n    }\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        if (withvalues && c->resp == 2)\n            addReplyArrayLen(c, count*2);\n        else\n            addReplyArrayLen(c, count);\n        if (hash->encoding == OBJ_ENCODING_HT) {\n            sds key, value;\n            while (count--) {\n                dictEntry *de = dictGetFairRandomKey(hash->ptr);\n                key = dictGetKey(de);\n                value = dictGetVal(de);\n                if (withvalues && c->resp > 2)\n                    addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c, key, sdslen(key));\n                if (withvalues)\n                    addReplyBulkCBuffer(c, value, sdslen(value));\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n        } else if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            listpackEntry *keys, *vals = NULL;\n            unsigned long limit, sample_count;\n\n            limit = count > HRANDFIELD_RANDOM_SAMPLE_LIMIT ? HRANDFIELD_RANDOM_SAMPLE_LIMIT : count;\n            keys = zmalloc(sizeof(listpackEntry)*limit);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*limit);\n            while (count) {\n                sample_count = count > limit ? limit : count;\n                count -= sample_count;\n                lpRandomPairs(hash->ptr, sample_count, keys, vals);\n                hrandfieldReplyWithListpack(c, sample_count, keys, vals);\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n            zfree(keys);\n            zfree(vals);\n        }\n        return;\n    }\n\n    /* Initiate reply count, RESP3 responds with nested array, RESP2 with flat one. */\n    long reply_size = count < size ? count : size;\n    if (withvalues && c->resp == 2)\n        addReplyArrayLen(c, reply_size*2);\n    else\n        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the hash: simply return the whole hash. */\n    if(count >= size) {\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n        while (hashTypeNext(hi) != C_ERR) {\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            if (withvalues)\n                addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n        }\n        hashTypeReleaseIterator(hi);\n        return;\n    }\n\n    /* CASE 3:\n     * The number of elements inside the hash is not greater than\n     * HRANDFIELD_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a hash from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the hash, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*HRANDFIELD_SUB_STRATEGY_MUL > size) {\n        dict *d = dictCreate(&sdsReplyDictType);\n        dictExpand(d, size);\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n\n        /* Add all the elements into the temporary dictionary. */\n        while ((hashTypeNext(hi)) != C_ERR) {\n            int ret = DICT_ERR;\n            sds key, value = NULL;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            if (withvalues)\n                value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(d, key, value);\n\n            serverAssert(ret == DICT_OK);\n        }\n        serverAssert(dictSize(d) == size);\n        hashTypeReleaseIterator(hi);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            sdsfree(dictGetVal(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n\n        /* Reply with what's in the dict and release memory */\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(d);\n        while ((de = dictNext(di)) != NULL) {\n            sds key = dictGetKey(de);\n            sds value = dictGetVal(de);\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, key);\n            if (withvalues)\n                addReplyBulkSds(c, value);\n        }\n\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n\n    /* CASE 4: We have a big hash compared to the requested number of elements.\n     * In this case we can simply get random elements from the hash and add\n     * to the temporary hash, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            /* it is inefficient to repeatedly pick one random element from a\n             * listpack. so we use this instead: */\n            listpackEntry *keys, *vals = NULL;\n            keys = zmalloc(sizeof(listpackEntry)*count);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*count);\n            serverAssert(lpRandomPairsUnique(hash->ptr, count, keys, vals) == count);\n            hrandfieldReplyWithListpack(c, count, keys, vals);\n            zfree(keys);\n            zfree(vals);\n            return;\n        }\n\n        /* Hashtable encoding (generic implementation) */\n        unsigned long added = 0;\n        listpackEntry key, value;\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, count);\n        while(added < count) {\n            hashTypeRandomElement(hash, size, &key, withvalues? &value : NULL);\n\n            /* Try to add the object to the dictionary. If it already exists\n            * free it, otherwise increment the number of objects we have\n            * in the result dictionary. */\n            sds skey = hashSdsFromListpackEntry(&key);\n            if (dictAdd(d,skey,NULL) != DICT_OK) {\n                sdsfree(skey);\n                continue;\n            }\n            added++;\n\n            /* We can reply right away, so that we don't need to store the value in the dict. */\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            hashReplyFromListpackEntry(c, &key);\n            if (withvalues)\n                hashReplyFromListpackEntry(c, &value);\n        }\n\n        /* Release memory */\n        dictRelease(d);\n    }\n}\n\n/* HRANDFIELD key [<count> [WITHVALUES]] */\nvoid hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n\n/*-----------------------------------------------------------------------------\n * Set Commands\n *----------------------------------------------------------------------------*/\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op);\n\n/* Factory method to return a set that *can* hold \"value\". When the object has\n * an integer-encodable value, an intset will be returned. Otherwise a regular\n * hash table. */\nrobj *setTypeCreate(sds value) {\n    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)\n        return createIntsetObject();\n    return createSetObject();\n}\n\n/* Add the specified value into a set.\n *\n * If the value was already member of the set, nothing is done and 0 is\n * returned, otherwise the new element is added and 1 is returned. */\nint setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                size_t max_entries = server.set_max_intset_entries;\n                /* limit to 1G entries due to intset internals. */\n                if (max_entries >= 1<<30) max_entries = 1<<30;\n                if (intsetLen(subject->ptr) > max_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeRemove(robj *setobj, sds value) {\n    long long llval;\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete(setobj->ptr,value) == DICT_OK) {\n            if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);\n            return 1;\n        }\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            int success;\n            setobj->ptr = intsetRemove(setobj->ptr,llval,&success);\n            if (success) return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeIsMember(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictFind((dict*)subject->ptr,value) != NULL;\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            return intsetFind((intset*)subject->ptr,llval);\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nsetTypeIterator *setTypeInitIterator(robj *subject) {\n    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));\n    si->subject = subject;\n    si->encoding = subject->encoding;\n    if (si->encoding == OBJ_ENCODING_HT) {\n        si->di = dictGetIterator(subject->ptr);\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        si->ii = 0;\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return si;\n}\n\nvoid setTypeReleaseIterator(setTypeIterator *si) {\n    if (si->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(si->di);\n    zfree(si);\n}\n\n/* Move to the next entry in the set. Returns the object at the current\n * position.\n *\n * Since set elements can be internally be stored as SDS strings or\n * simple arrays of integers, setTypeNext returns the encoding of the\n * set object you are iterating, and will populate the appropriate pointer\n * (sdsele) or (llele) accordingly.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused.\n *\n * When there are no longer elements -1 is returned. */\nint setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {\n    if (si->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictNext(si->di);\n        if (de == NULL) return -1;\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        if (!intsetGet(si->subject->ptr,si->ii++,llele))\n            return -1;\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Wrong set encoding in setTypeNext\");\n    }\n    return si->encoding;\n}\n\n/* The not copy on write friendly version but easy to use version\n * of setTypeNext() is setTypeNextObject(), returning new SDS\n * strings. So if you don't retain a pointer to this object you should call\n * sdsfree() against it.\n *\n * This function is the way to go for write operations where COW is not\n * an issue. */\nsds setTypeNextObject(setTypeIterator *si) {\n    int64_t intele;\n    sds sdsele;\n    int encoding;\n\n    encoding = setTypeNext(si,&sdsele,&intele);\n    switch(encoding) {\n        case -1:    return NULL;\n        case OBJ_ENCODING_INTSET:\n            return sdsfromlonglong(intele);\n        case OBJ_ENCODING_HT:\n            return sdsdup(sdsele);\n        default:\n            serverPanic(\"Unsupported encoding\");\n    }\n    return NULL; /* just to suppress warnings */\n}\n\n/* Return random element from a non empty set.\n * The returned element can be an int64_t value if the set is encoded\n * as an \"intset\" blob of integers, or an SDS string if the set\n * is a regular set.\n *\n * The caller provides both pointers to be populated with the right\n * object. The return value of the function is the object->encoding\n * field of the object and is used by the caller to check if the\n * int64_t pointer or the sds pointer was populated.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused. */\nint setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(setobj->ptr);\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        *llele = intsetRandom(setobj->ptr);\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return setobj->encoding;\n}\n\nunsigned long setTypeSize(const robj *subject) {\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictSize((const dict*)subject->ptr);\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        return intsetLen((const intset*)subject->ptr);\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n}\n\n/* Convert the set to specified encoding. The resulting dict (when converting\n * to a hash table) is presized to hold the number of elements in the original\n * set. */\nvoid setTypeConvert(robj *setobj, int enc) {\n    setTypeIterator *si;\n    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&\n                             setobj->encoding == OBJ_ENCODING_INTSET);\n\n    if (enc == OBJ_ENCODING_HT) {\n        int64_t intele;\n        dict *d = dictCreate(&setDictType);\n        sds element;\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(d,intsetLen(setobj->ptr));\n\n        /* To add the elements we extract integers and create redis objects */\n        si = setTypeInitIterator(setobj);\n        while (setTypeNext(si,&element,&intele) != -1) {\n            element = sdsfromlonglong(intele);\n            serverAssert(dictAdd(d,element,NULL) == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n\n        setobj->encoding = OBJ_ENCODING_HT;\n        zfree(setobj->ptr);\n        setobj->ptr = d;\n    } else {\n        serverPanic(\"Unsupported set conversion\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a set object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *setTypeDup(robj *o) {\n    robj *set;\n    setTypeIterator *si;\n    sds elesds;\n    int64_t intobj;\n\n    serverAssert(o->type == OBJ_SET);\n\n    /* Create a new set object that have the same encoding as the original object's encoding */\n    if (o->encoding == OBJ_ENCODING_INTSET) {\n        intset *is = o->ptr;\n        size_t size = intsetBlobLen(is);\n        intset *newis = zmalloc(size);\n        memcpy(newis,is,size);\n        set = createObject(OBJ_SET, newis);\n        set->encoding = OBJ_ENCODING_INTSET;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        set = createSetObject();\n        dict *d = o->ptr;\n        dictExpand(set->ptr, dictSize(d));\n        si = setTypeInitIterator(o);\n        while (setTypeNext(si, &elesds, &intobj) != -1) {\n            setTypeAdd(set, elesds);\n        }\n        setTypeReleaseIterator(si);\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return set;\n}\n\nvoid saddCommand(client *c) {\n    robj *set;\n    int j, added = 0;\n\n    set = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,set,OBJ_SET)) return;\n    \n    if (set == NULL) {\n        set = setTypeCreate(c->argv[2]->ptr);\n        dbAdd(c->db,c->argv[1],set);\n    }\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeAdd(set,c->argv[j]->ptr)) added++;\n    }\n    if (added) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[1],c->db->id);\n    }\n    server.dirty += added;\n    addReplyLongLong(c,added);\n}\n\nvoid sremCommand(client *c) {\n    robj *set;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeRemove(set,c->argv[j]->ptr)) {\n            deleted++;\n            if (setTypeSize(set) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid smoveCommand(client *c) {\n    robj *srcset, *dstset, *ele;\n    srcset = lookupKeyWrite(c->db,c->argv[1]);\n    dstset = lookupKeyWrite(c->db,c->argv[2]);\n    ele = c->argv[3];\n\n    /* If the source key does not exist return 0 */\n    if (srcset == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    /* If the source key has the wrong type, or the destination key\n     * is set and has the wrong type, return with an error. */\n    if (checkType(c,srcset,OBJ_SET) ||\n        checkType(c,dstset,OBJ_SET)) return;\n\n    /* If srcset and dstset are equal, SMOVE is a no-op */\n    if (srcset == dstset) {\n        addReply(c,setTypeIsMember(srcset,ele->ptr) ?\n            shared.cone : shared.czero);\n        return;\n    }\n\n    /* If the element cannot be removed from the src set, return 0. */\n    if (!setTypeRemove(srcset,ele->ptr)) {\n        addReply(c,shared.czero);\n        return;\n    }\n    notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n\n    /* Remove the src set from the database when empty */\n    if (setTypeSize(srcset) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Create the destination set when it doesn't exist */\n    if (!dstset) {\n        dstset = setTypeCreate(ele->ptr);\n        dbAdd(c->db,c->argv[2],dstset);\n    }\n\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n\n    /* An extra key has changed when ele was successfully added to dstset */\n    if (setTypeAdd(dstset,ele->ptr)) {\n        server.dirty++;\n        signalModifiedKey(c,c->db,c->argv[2]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[2],c->db->id);\n    }\n    addReply(c,shared.cone);\n}\n\nvoid sismemberCommand(client *c) {\n    robj *set;\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    if (setTypeIsMember(set,c->argv[2]->ptr))\n        addReply(c,shared.cone);\n    else\n        addReply(c,shared.czero);\n}\n\nvoid smismemberCommand(client *c) {\n    robj *set;\n    int j;\n\n    /* Don't abort when the key cannot be found. Non-existing keys are empty\n     * sets, where SMISMEMBER should respond with a series of zeros. */\n    set = lookupKeyRead(c->db,c->argv[1]);\n    if (set && checkType(c,set,OBJ_SET)) return;\n\n    addReplyArrayLen(c,c->argc - 2);\n\n    for (j = 2; j < c->argc; j++) {\n        if (set && setTypeIsMember(set,c->argv[j]->ptr))\n            addReply(c,shared.cone);\n        else\n            addReply(c,shared.czero);\n    }\n}\n\nvoid scardCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_SET)) return;\n\n    addReplyLongLong(c,setTypeSize(o));\n}\n\n/* Handle the \"SPOP key <count>\" variant. The normal version of the\n * command is handled by the spopCommand() function itself. */\n\n/* How many times bigger should be the set compared to the remaining size\n * for us to use the \"create new set\" strategy? Read later in the\n * implementation for more info. */\n#define SPOP_MOVE_STRATEGY_MUL 5\n\nvoid spopWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    robj *set;\n\n    /* Get the count argument */\n    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    count = (unsigned long) l;\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set. Otherwise, return nil */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* If count is zero, serve an empty set ASAP to avoid special\n     * cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyset[c->resp]);\n        return;\n    }\n\n    size = setTypeSize(set);\n\n    /* Generate an SPOP keyspace notification */\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n    server.dirty += (count >= size) ? size : count;\n\n    /* CASE 1:\n     * The number of requested elements is greater than or equal to\n     * the number of elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        /* We just return the entire set */\n        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);\n\n        /* Delete the set as it is now empty */\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n\n        /* Propagate this command as a DEL operation */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        return;\n    }\n\n    /* Case 2 and 3 require to replicate SPOP as a set of SREM commands.\n     * Prepare our replication argument vector. Also send the array length\n     * which is common to both the code paths. */\n    robj *propargv[3];\n    propargv[0] = shared.srem;\n    propargv[1] = c->argv[1];\n    addReplySetLen(c,count);\n\n    /* Common iteration vars. */\n    sds sdsele;\n    robj *objele;\n    int encoding;\n    int64_t llele;\n    unsigned long remaining = size-count; /* Elements left after SPOP. */\n\n    /* If we are here, the number of requested elements is less than the\n     * number of elements inside the set. Also we are sure that count < size.\n     * Use two different strategies.\n     *\n     * CASE 2: The number of elements to return is small compared to the\n     * set size. We can just extract random elements and return them to\n     * the set. */\n    if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {\n        while(count--) {\n            /* Emit and remove. */\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n                set->ptr = intsetRemove(set->ptr,llele,NULL);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n                setTypeRemove(set,sdsele);\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(c->db->id,propargv,3,PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n    } else {\n    /* CASE 3: The number of elements to return is very big, approaching\n     * the size of the set itself. After some time extracting random elements\n     * from such a set becomes computationally expensive, so we use\n     * a different strategy, we extract random elements that we don't\n     * want to return (the elements that will remain part of the set),\n     * creating a new set as we do this (that will be stored as the original\n     * set). Then we return the elements left in the original set and\n     * release it. */\n        robj *newset = NULL;\n\n        /* Create a new set with just the remaining elements. */\n        while(remaining--) {\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(sdsele);\n            }\n            if (!newset) newset = setTypeCreate(sdsele);\n            setTypeAdd(newset,sdsele);\n            setTypeRemove(set,sdsele);\n            sdsfree(sdsele);\n        }\n\n        /* Transfer the old set to the client. */\n        setTypeIterator *si;\n        si = setTypeInitIterator(set);\n        while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(c->db->id,propargv,3,PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n        setTypeReleaseIterator(si);\n\n        /* Assign the new set as the key value. */\n        dbOverwrite(c->db,c->argv[1],newset);\n    }\n\n    /* Don't propagate the command itself even if we incremented the\n     * dirty counter. We don't want to propagate an SPOP command since\n     * we propagated the command as a set of SREMs operations using\n     * the alsoPropagate() API. */\n    preventCommandPropagation(c);\n    signalModifiedKey(c,c->db,c->argv[1]);\n}\n\nvoid spopCommand(client *c) {\n    robj *set, *ele;\n    sds sdsele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        spopWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))\n         == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* Get a random element from the set */\n    encoding = setTypeRandomElement(set,&sdsele,&llele);\n\n    /* Remove the element from the set */\n    if (encoding == OBJ_ENCODING_INTSET) {\n        ele = createStringObjectFromLongLong(llele);\n        set->ptr = intsetRemove(set->ptr,llele,NULL);\n    } else {\n        ele = createStringObject(sdsele,sdslen(sdsele));\n        setTypeRemove(set,ele->ptr);\n    }\n\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n\n    /* Replicate/AOF this command as an SREM operation */\n    rewriteClientCommandVector(c,3,shared.srem,c->argv[1],ele);\n\n    /* Add the element to the reply */\n    addReplyBulk(c,ele);\n    decrRefCount(ele);\n\n    /* Delete the set if it's empty */\n    if (setTypeSize(set) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Set has been modified */\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n}\n\n/* handle the \"SRANDMEMBER key <count>\" variant. The normal version of the\n * command is handled by the srandmemberCommand() function itself. */\n\n/* How many times bigger should be the set compared to the requested size\n * for us to don't use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define SRANDMEMBER_SUB_STRATEGY_MUL 3\n\nvoid srandmemberWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    int uniq = 1;\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    dict *d;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        /* A negative count means: return the same elements multiple times\n         * (i.e. don't remove the extracted element after every extraction). */\n        count = -l;\n        uniq = 0;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n    size = setTypeSize(set);\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        addReplyArrayLen(c,count);\n        while(count--) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            if (c->flags & CLIENT_CLOSE_ASAP)\n                break;\n        }\n        return;\n    }\n\n    /* CASE 2:\n     * The number of requested elements is greater than the number of\n     * elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        setTypeIterator *si;\n        addReplyArrayLen(c,size);\n        si = setTypeInitIterator(set);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            size--;\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(size==0);\n        return;\n    }\n\n    /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */\n    d = dictCreate(&sdsReplyDictType);\n\n    /* CASE 3:\n     * The number of elements inside the set is not greater than\n     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a set from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        setTypeIterator *si;\n\n        /* Add all the elements into the temporary dictionary. */\n        si = setTypeInitIterator(set);\n        dictExpand(d, size);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            int retval = DICT_ERR;\n\n            if (encoding == OBJ_ENCODING_INTSET) {\n                retval = dictAdd(d,sdsfromlonglong(llele),NULL);\n            } else {\n                retval = dictAdd(d,sdsdup(ele),NULL);\n            }\n            serverAssert(retval == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n    }\n\n    /* CASE 4: We have a big set compared to the requested number of elements.\n     * In this case we can simply get random elements from the set and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        unsigned long added = 0;\n        sds sdsele;\n\n        dictExpand(d, count);\n        while (added < count) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(ele);\n            }\n            /* Try to add the object to the dictionary. If it already exists\n             * free it, otherwise increment the number of objects we have\n             * in the result dictionary. */\n            if (dictAdd(d,sdsele,NULL) == DICT_OK)\n                added++;\n            else\n                sdsfree(sdsele);\n        }\n    }\n\n    /* CASE 3 & 4: send the result to the user. */\n    {\n        dictIterator *di;\n        dictEntry *de;\n\n        addReplyArrayLen(c,count);\n        di = dictGetIterator(d);\n        while((de = dictNext(di)) != NULL)\n            addReplyBulkSds(c,dictGetKey(de));\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n}\n\n/* SRANDMEMBER <key> [<count>] */\nvoid srandmemberCommand(client *c) {\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        srandmemberWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    encoding = setTypeRandomElement(set,&ele,&llele);\n    if (encoding == OBJ_ENCODING_INTSET) {\n        addReplyBulkLongLong(c,llele);\n    } else {\n        addReplyBulkCBuffer(c,ele,sdslen(ele));\n    }\n}\n\nint qsortCompareSetsByCardinality(const void *s1, const void *s2) {\n    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;\n    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;\n    return 0;\n}\n\n/* This is used by SDIFF and in this case we can receive NULL that should\n * be handled as empty sets. */\nint qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {\n    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;\n    unsigned long first = o1 ? setTypeSize(o1) : 0;\n    unsigned long second = o2 ? setTypeSize(o2) : 0;\n\n    if (first < second) return 1;\n    if (first > second) return -1;\n    return 0;\n}\n\n/* SINTER / SMEMBERS / SINTERSTORE / SINTERCARD\n *\n * 'cardinality_only' work for SINTERCARD, only return the cardinality\n * with minimum processing and memory overheads.\n *\n * 'limit' work for SINTERCARD, stop searching after reaching the limit.\n * Passing a 0 means unlimited.\n */\nvoid sinterGenericCommand(client *c, robj **setkeys,\n                          unsigned long setnum, robj *dstkey,\n                          int cardinality_only, unsigned long limit) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds elesds;\n    int64_t intobj;\n    void *replylen = NULL;\n    unsigned long j, cardinality = 0;\n    int encoding, empty = 0;\n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = lookupKeyRead(c->db, setkeys[j]);\n        if (!setobj) {\n            /* A NULL is considered an empty set */\n            empty += 1;\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n    }\n\n    /* Set intersection with an empty set always results in an empty set.\n     * Return ASAP if there is an empty set. */\n    if (empty > 0) {\n        zfree(sets);\n        if (dstkey) {\n            if (dbDelete(c->db,dstkey)) {\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n                server.dirty++;\n            }\n            addReply(c,shared.czero);\n        } else if (cardinality_only) {\n            addReplyLongLong(c,cardinality);\n        } else {\n            addReply(c,shared.emptyset[c->resp]);\n        }\n        return;\n    }\n\n    /* Sort sets from the smallest to largest, this will improve our\n     * algorithm's performance */\n    qsort(sets,setnum,sizeof(robj*),qsortCompareSetsByCardinality);\n\n    /* The first thing we should output is the total number of elements...\n     * since this is a multi-bulk write, but at this stage we don't know\n     * the intersection set size, so we use a trick, append an empty object\n     * to the output list and save the pointer to later modify it with the\n     * right length */\n    if (dstkey) {\n        /* If we have a target key where to store the resulting set\n         * create this key with an empty set inside */\n        dstset = createIntsetObject();\n    } else if (!cardinality_only) {\n        replylen = addReplyDeferredLen(c);\n    }\n\n    /* Iterate all the elements of the first (smallest) set, and test\n     * the element against all the other sets, if at least one set does\n     * not include the element it is discarded */\n    si = setTypeInitIterator(sets[0]);\n    while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {\n        for (j = 1; j < setnum; j++) {\n            if (sets[j] == sets[0]) continue;\n            if (encoding == OBJ_ENCODING_INTSET) {\n                /* intset with intset is simple... and fast */\n                if (sets[j]->encoding == OBJ_ENCODING_INTSET &&\n                    !intsetFind((intset*)sets[j]->ptr,intobj))\n                {\n                    break;\n                /* in order to compare an integer with an object we\n                 * have to use the generic function, creating an object\n                 * for this */\n                } else if (sets[j]->encoding == OBJ_ENCODING_HT) {\n                    elesds = sdsfromlonglong(intobj);\n                    if (!setTypeIsMember(sets[j],elesds)) {\n                        sdsfree(elesds);\n                        break;\n                    }\n                    sdsfree(elesds);\n                }\n            } else if (encoding == OBJ_ENCODING_HT) {\n                if (!setTypeIsMember(sets[j],elesds)) {\n                    break;\n                }\n            }\n        }\n\n        /* Only take action when all sets contain the member */\n        if (j == setnum) {\n            if (cardinality_only) {\n                cardinality++;\n\n                /* We stop the searching after reaching the limit. */\n                if (limit && cardinality >= limit)\n                    break;\n            } else if (!dstkey) {\n                if (encoding == OBJ_ENCODING_HT)\n                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));\n                else\n                    addReplyBulkLongLong(c,intobj);\n                cardinality++;\n            } else {\n                if (encoding == OBJ_ENCODING_INTSET) {\n                    elesds = sdsfromlonglong(intobj);\n                    setTypeAdd(dstset,elesds);\n                    sdsfree(elesds);\n                } else {\n                    setTypeAdd(dstset,elesds);\n                }\n            }\n        }\n    }\n    setTypeReleaseIterator(si);\n\n    if (cardinality_only) {\n        addReplyLongLong(c,cardinality);\n    } else if (dstkey) {\n        /* Store the resulting set into the target, if the intersection\n         * is not an empty set. */\n        if (setTypeSize(dstset) > 0) {\n            setKey(c,c->db,dstkey,dstset,0);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\"sinterstore\",\n                dstkey,c->db->id);\n            server.dirty++;\n        } else {\n            addReply(c,shared.czero);\n            if (dbDelete(c->db,dstkey)) {\n                server.dirty++;\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n            }\n        }\n        decrRefCount(dstset);\n    } else {\n        setDeferredSetLen(c,replylen,cardinality);\n    }\n    zfree(sets);\n}\n\n/* SINTER key [key ...] */\nvoid sinterCommand(client *c) {\n    sinterGenericCommand(c, c->argv+1,  c->argc-1, NULL, 0, 0);\n}\n\n/* SINTERCARD numkeys key [key ...] [LIMIT limit] */\nvoid sinterCardCommand(client *c) {\n    long j;\n    long numkeys = 0; /* Number of keys. */\n    long limit = 0;   /* 0 means not limit. */\n\n    if (getRangeLongFromObjectOrReply(c, c->argv[1], 1, LONG_MAX,\n                                      &numkeys, \"numkeys should be greater than 0\") != C_OK)\n        return;\n    if (numkeys > (c->argc - 2)) {\n        addReplyError(c, \"Number of keys can't be greater than number of args\");\n        return;\n    }\n\n    for (j = 2 + numkeys; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc - 1) - j;\n\n        if (!strcasecmp(opt, \"LIMIT\") && moreargs) {\n            j++;\n            if (getPositiveLongFromObjectOrReply(c, c->argv[j], &limit,\n                                                 \"LIMIT can't be negative\") != C_OK)\n                return;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n\n    sinterGenericCommand(c, c->argv+2, numkeys, NULL, 1, limit);\n}\n\n/* SINTERSTORE destination key [key ...] */\nvoid sinterstoreCommand(client *c) {\n    sinterGenericCommand(c, c->argv+2, c->argc-2, c->argv[1], 0, 0);\n}\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds ele;\n    int j, cardinality = 0;\n    int diff_algo = 1;\n    int sameset = 0; \n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = lookupKeyRead(c->db, setkeys[j]);\n        if (!setobj) {\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n        if (j > 0 && sets[0] == sets[j]) {\n            sameset = 1; \n        }\n    }\n\n    /* Select what DIFF algorithm to use.\n     *\n     * Algorithm 1 is O(N*M) where N is the size of the element first set\n     * and M the total number of sets.\n     *\n     * Algorithm 2 is O(N) where N is the total number of elements in all\n     * the sets.\n     *\n     * We compute what is the best bet with the current input here. */\n    if (op == SET_OP_DIFF && sets[0] && !sameset) {\n        long long algo_one_work = 0, algo_two_work = 0;\n\n        for (j = 0; j < setnum; j++) {\n            if (sets[j] == NULL) continue;\n\n            algo_one_work += setTypeSize(sets[0]);\n            algo_two_work += setTypeSize(sets[j]);\n        }\n\n        /* Algorithm 1 has better constant times and performs less operations\n         * if there are elements in common. Give it some advantage. */\n        algo_one_work /= 2;\n        diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;\n\n        if (diff_algo == 1 && setnum > 1) {\n            /* With algorithm 1 it is better to order the sets to subtract\n             * by decreasing size, so that we are more likely to find\n             * duplicated elements ASAP. */\n            qsort(sets+1,setnum-1,sizeof(robj*),\n                qsortCompareSetsByRevCardinality);\n        }\n    }\n\n    /* We need a temp set object to store our union. If the dstkey\n     * is not NULL (that is, we are inside an SUNIONSTORE operation) then\n     * this set object will be the resulting object to set into the target key*/\n    dstset = createIntsetObject();\n\n    if (op == SET_OP_UNION) {\n        /* Union is trivial, just add every element of every set to the\n         * temporary set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (setTypeAdd(dstset,ele)) cardinality++;\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n        }\n    } else if (op == SET_OP_DIFF && sameset) {\n        /* At least one of the sets is the same one (same key) as the first one, result must be empty. */\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {\n        /* DIFF Algorithm 1:\n         *\n         * We perform the diff by iterating all the elements of the first set,\n         * and only adding it to the target set if the element does not exist\n         * into all the other sets.\n         *\n         * This way we perform at max N*M operations, where N is the size of\n         * the first set, and M the number of sets. */\n        si = setTypeInitIterator(sets[0]);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            for (j = 1; j < setnum; j++) {\n                if (!sets[j]) continue; /* no key is an empty set. */\n                if (sets[j] == sets[0]) break; /* same set! */\n                if (setTypeIsMember(sets[j],ele)) break;\n            }\n            if (j == setnum) {\n                /* There is no other set with this element. Add it. */\n                setTypeAdd(dstset,ele);\n                cardinality++;\n            }\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {\n        /* DIFF Algorithm 2:\n         *\n         * Add all the elements of the first set to the auxiliary set.\n         * Then remove all the elements of all the next sets from it.\n         *\n         * This is O(N) where N is the sum of all the elements in every\n         * set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (j == 0) {\n                    if (setTypeAdd(dstset,ele)) cardinality++;\n                } else {\n                    if (setTypeRemove(dstset,ele)) cardinality--;\n                }\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n\n            /* Exit if result set is empty as any additional removal\n             * of elements will have no effect. */\n            if (cardinality == 0) break;\n        }\n    }\n\n    /* Output the content of the resulting set, if not in STORE mode */\n    if (!dstkey) {\n        addReplySetLen(c,cardinality);\n        si = setTypeInitIterator(dstset);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            addReplyBulkCBuffer(c,ele,sdslen(ele));\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n        server.lazyfree_lazy_server_del ? freeObjAsync(NULL, dstset, -1) :\n                                          decrRefCount(dstset);\n    } else {\n        /* If we have a target key where to store the resulting set\n         * create this key with the result set inside */\n        if (setTypeSize(dstset) > 0) {\n            setKey(c,c->db,dstkey,dstset,0);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\n                op == SET_OP_UNION ? \"sunionstore\" : \"sdiffstore\",\n                dstkey,c->db->id);\n            server.dirty++;\n        } else {\n            addReply(c,shared.czero);\n            if (dbDelete(c->db,dstkey)) {\n                server.dirty++;\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n            }\n        }\n        decrRefCount(dstset);\n    }\n    zfree(sets);\n}\n\n/* SUNION key [key ...] */\nvoid sunionCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);\n}\n\n/* SUNIONSTORE destination key [key ...] */\nvoid sunionstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);\n}\n\n/* SDIFF key [key ...] */\nvoid sdiffCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);\n}\n\n/* SDIFFSTORE destination key [key ...] */\nvoid sdiffstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);\n}\n\nvoid sscanCommand(client *c) {\n    robj *set;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n    scanGenericCommand(c,set,cursor);\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*-----------------------------------------------------------------------------\n * Sorted set API\n *----------------------------------------------------------------------------*/\n\n/* ZSETs are ordered sets using two data structures to hold the same elements\n * in order to get O(log(N)) INSERT and REMOVE operations into a sorted\n * data structure.\n *\n * The elements are added to a hash table mapping Redis objects to scores.\n * At the same time the elements are added to a skip list mapping scores\n * to Redis objects (so objects are sorted by scores in this \"view\").\n *\n * Note that the SDS string representing the element is the same in both\n * the hash table and skiplist in order to save memory. What we do in order\n * to manage the shared SDS string more easily is to free the SDS string\n * only in zslFreeNode(). The dictionary has no value free method set.\n * So we should always remove an element from the dictionary, and later from\n * the skiplist.\n *\n * This skiplist implementation is almost a C translation of the original\n * algorithm described by William Pugh in \"Skip Lists: A Probabilistic\n * Alternative to Balanced Trees\", modified in three ways:\n * a) this implementation allows for repeated scores.\n * b) the comparison is not just by key (our 'score') but by satellite data.\n * c) there is a back pointer, so it's a doubly linked list with the back\n * pointers being only at \"level 1\". This allows to traverse the list\n * from tail to head, useful for ZREVRANGE. */\n\n#include \"server.h\"\n#include <math.h>\n\n/*-----------------------------------------------------------------------------\n * Skiplist implementation of the low level API\n *----------------------------------------------------------------------------*/\n\nint zslLexValueGteMin(sds value, zlexrangespec *spec);\nint zslLexValueLteMax(sds value, zlexrangespec *spec);\n\n/* Create a skiplist node with the specified number of levels.\n * The SDS string 'ele' is referenced by the node after the call. */\nzskiplistNode *zslCreateNode(int level, double score, sds ele) {\n    zskiplistNode *zn =\n        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));\n    zn->score = score;\n    zn->ele = ele;\n    return zn;\n}\n\n/* Create a new skiplist. */\nzskiplist *zslCreate(void) {\n    int j;\n    zskiplist *zsl;\n\n    zsl = zmalloc(sizeof(*zsl));\n    zsl->level = 1;\n    zsl->length = 0;\n    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);\n    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {\n        zsl->header->level[j].forward = NULL;\n        zsl->header->level[j].span = 0;\n    }\n    zsl->header->backward = NULL;\n    zsl->tail = NULL;\n    return zsl;\n}\n\n/* Free the specified skiplist node. The referenced SDS string representation\n * of the element is freed too, unless node->ele is set to NULL before calling\n * this function. */\nvoid zslFreeNode(zskiplistNode *node) {\n    sdsfree(node->ele);\n    zfree(node);\n}\n\n/* Free a whole skiplist. */\nvoid zslFree(zskiplist *zsl) {\n    zskiplistNode *node = zsl->header->level[0].forward, *next;\n\n    zfree(zsl->header);\n    while(node) {\n        next = node->level[0].forward;\n        zslFreeNode(node);\n        node = next;\n    }\n    zfree(zsl);\n}\n\n/* Returns a random level for the new skiplist node we are going to create.\n * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL\n * (both inclusive), with a powerlaw-alike distribution where higher\n * levels are less likely to be returned. */\nint zslRandomLevel(void) {\n    static const int threshold = ZSKIPLIST_P*RAND_MAX;\n    int level = 1;\n    while (random() < threshold)\n        level += 1;\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\n}\n\n/* Insert a new node in the skiplist. Assumes the element does not already\n * exist (up to the caller to enforce that). The skiplist takes ownership\n * of the passed SDS string 'ele'. */\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long rank[ZSKIPLIST_MAXLEVEL];\n    int i, level;\n\n    serverAssert(!isnan(score));\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            rank[i] += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    /* we assume the element is not already inside, since we allow duplicated\n     * scores, reinserting the same element should never happen since the\n     * caller of zslInsert() should test in the hash table if the element is\n     * already inside or not. */\n    level = zslRandomLevel();\n    if (level > zsl->level) {\n        for (i = zsl->level; i < level; i++) {\n            rank[i] = 0;\n            update[i] = zsl->header;\n            update[i]->level[i].span = zsl->length;\n        }\n        zsl->level = level;\n    }\n    x = zslCreateNode(level,score,ele);\n    for (i = 0; i < level; i++) {\n        x->level[i].forward = update[i]->level[i].forward;\n        update[i]->level[i].forward = x;\n\n        /* update span covered by update[i] as x is inserted here */\n        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);\n        update[i]->level[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    /* increment span for untouched levels */\n    for (i = level; i < zsl->level; i++) {\n        update[i]->level[i].span++;\n    }\n\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\n    if (x->level[0].forward)\n        x->level[0].forward->backward = x;\n    else\n        zsl->tail = x;\n    zsl->length++;\n    return x;\n}\n\n/* Internal function used by zslDelete, zslDeleteRangeByScore and\n * zslDeleteRangeByRank. */\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {\n    int i;\n    for (i = 0; i < zsl->level; i++) {\n        if (update[i]->level[i].forward == x) {\n            update[i]->level[i].span += x->level[i].span - 1;\n            update[i]->level[i].forward = x->level[i].forward;\n        } else {\n            update[i]->level[i].span -= 1;\n        }\n    }\n    if (x->level[0].forward) {\n        x->level[0].forward->backward = x->backward;\n    } else {\n        zsl->tail = x->backward;\n    }\n    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)\n        zsl->level--;\n    zsl->length--;\n}\n\n/* Delete an element with matching score/element from the skiplist.\n * The function returns 1 if the node was found and deleted, otherwise\n * 0 is returned.\n *\n * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise\n * it is not freed (but just unlinked) and *node is set to the node pointer,\n * so that it is possible for the caller to reuse the node (including the\n * referenced SDS string at node->ele). */\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                     sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    /* We may have multiple elements with the same score, what we need\n     * is to find the element with both the right score and object. */\n    x = x->level[0].forward;\n    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {\n        zslDeleteNode(zsl, x, update);\n        if (!node)\n            zslFreeNode(x);\n        else\n            *node = x;\n        return 1;\n    }\n    return 0; /* not found */\n}\n\n/* Update the score of an element inside the sorted set skiplist.\n * Note that the element must exist and must match 'score'.\n * This function does not update the score in the hash table side, the\n * caller should take care of it.\n *\n * Note that this function attempts to just update the node, in case after\n * the score update, the node would be exactly at the same position.\n * Otherwise the skiplist is modified by removing and re-adding a new\n * element, which is more costly.\n *\n * The function returns the updated element skiplist node pointer. */\nzskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    /* We need to seek to element to update to start: this is useful anyway,\n     * we'll have to update or remove it. */\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < curscore ||\n                    (x->level[i].forward->score == curscore &&\n                     sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n\n    /* Jump to our element: note that this function assumes that the\n     * element with the matching score exists. */\n    x = x->level[0].forward;\n    serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);\n\n    /* If the node, after the score update, would be still exactly\n     * at the same position, we can just update the score without\n     * actually removing and re-inserting the element in the skiplist. */\n    if ((x->backward == NULL || x->backward->score < newscore) &&\n        (x->level[0].forward == NULL || x->level[0].forward->score > newscore))\n    {\n        x->score = newscore;\n        return x;\n    }\n\n    /* No way to reuse the old node: we need to remove and insert a new\n     * one at a different place. */\n    zslDeleteNode(zsl, x, update);\n    zskiplistNode *newnode = zslInsert(zsl,newscore,x->ele);\n    /* We reused the old node x->ele SDS string, free the node now\n     * since zslInsert created a new one. */\n    x->ele = NULL;\n    zslFreeNode(x);\n    return newnode;\n}\n\nint zslValueGteMin(double value, zrangespec *spec) {\n    return spec->minex ? (value > spec->min) : (value >= spec->min);\n}\n\nint zslValueLteMax(double value, zrangespec *spec) {\n    return spec->maxex ? (value < spec->max) : (value <= spec->max);\n}\n\n/* Returns if there is a part of the zset is in range. */\nint zslIsInRange(zskiplist *zsl, zrangespec *range) {\n    zskiplistNode *x;\n\n    /* Test for ranges that will always be empty. */\n    if (range->min > range->max ||\n            (range->min == range->max && (range->minex || range->maxex)))\n        return 0;\n    x = zsl->tail;\n    if (x == NULL || !zslValueGteMin(x->score,range))\n        return 0;\n    x = zsl->header->level[0].forward;\n    if (x == NULL || !zslValueLteMax(x->score,range))\n        return 0;\n    return 1;\n}\n\n/* Find the first node that is contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *OUT* of range. */\n        while (x->level[i].forward &&\n            !zslValueGteMin(x->level[i].forward->score,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so the next node cannot be NULL. */\n    x = x->level[0].forward;\n    serverAssert(x != NULL);\n\n    /* Check if score <= max. */\n    if (!zslValueLteMax(x->score,range)) return NULL;\n    return x;\n}\n\n/* Find the last node that is contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *IN* range. */\n        while (x->level[i].forward &&\n            zslValueLteMax(x->level[i].forward->score,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so this node cannot be NULL. */\n    serverAssert(x != NULL);\n\n    /* Check if score >= min. */\n    if (!zslValueGteMin(x->score,range)) return NULL;\n    return x;\n}\n\n/* Delete all the elements with score between min and max from the skiplist.\n * Both min and max can be inclusive or exclusive (see range->minex and\n * range->maxex). When inclusive a score >= min && score <= max is deleted.\n * Note that this function takes the reference to the hash table view of the\n * sorted set, in order to remove the elements from the hash table too. */\nunsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long removed = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            !zslValueGteMin(x->level[i].forward->score, range))\n                x = x->level[i].forward;\n        update[i] = x;\n    }\n\n    /* Current node is the last with score < or <= min. */\n    x = x->level[0].forward;\n\n    /* Delete nodes while in range. */\n    while (x && zslValueLteMax(x->score, range)) {\n        zskiplistNode *next = x->level[0].forward;\n        zslDeleteNode(zsl,x,update);\n        dictDelete(dict,x->ele);\n        zslFreeNode(x); /* Here is where x->ele is actually released. */\n        removed++;\n        x = next;\n    }\n    return removed;\n}\n\nunsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long removed = 0;\n    int i;\n\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            !zslLexValueGteMin(x->level[i].forward->ele,range))\n                x = x->level[i].forward;\n        update[i] = x;\n    }\n\n    /* Current node is the last with score < or <= min. */\n    x = x->level[0].forward;\n\n    /* Delete nodes while in range. */\n    while (x && zslLexValueLteMax(x->ele,range)) {\n        zskiplistNode *next = x->level[0].forward;\n        zslDeleteNode(zsl,x,update);\n        dictDelete(dict,x->ele);\n        zslFreeNode(x); /* Here is where x->ele is actually released. */\n        removed++;\n        x = next;\n    }\n    return removed;\n}\n\n/* Delete all the elements with rank between start and end from the skiplist.\n * Start and end are inclusive. Note that start and end need to be 1-based */\nunsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long traversed = 0, removed = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward && (traversed + x->level[i].span) < start) {\n            traversed += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n\n    traversed++;\n    x = x->level[0].forward;\n    while (x && traversed <= end) {\n        zskiplistNode *next = x->level[0].forward;\n        zslDeleteNode(zsl,x,update);\n        dictDelete(dict,x->ele);\n        zslFreeNode(x);\n        removed++;\n        traversed++;\n        x = next;\n    }\n    return removed;\n}\n\n/* Find the rank for an element by both score and key.\n * Returns 0 when the element cannot be found, rank otherwise.\n * Note that the rank is 1-based due to the span of zsl->header to the\n * first element. */\nunsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *x;\n    unsigned long rank = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            (x->level[i].forward->score < score ||\n                (x->level[i].forward->score == score &&\n                sdscmp(x->level[i].forward->ele,ele) <= 0))) {\n            rank += x->level[i].span;\n            x = x->level[i].forward;\n        }\n\n        /* x might be equal to zsl->header, so test if obj is non-NULL */\n        if (x->ele && x->score == score && sdscmp(x->ele,ele) == 0) {\n            return rank;\n        }\n    }\n    return 0;\n}\n\n/* Finds an element by its rank. The rank argument needs to be 1-based. */\nzskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {\n    zskiplistNode *x;\n    unsigned long traversed = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward && (traversed + x->level[i].span) <= rank)\n        {\n            traversed += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        if (traversed == rank) {\n            return x;\n        }\n    }\n    return NULL;\n}\n\n/* Populate the rangespec according to the objects min and max. */\nstatic int zslParseRange(robj *min, robj *max, zrangespec *spec) {\n    char *eptr;\n    spec->minex = spec->maxex = 0;\n\n    /* Parse the min-max interval. If one of the values is prefixed\n     * by the \"(\" character, it's considered \"open\". For instance\n     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max\n     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */\n    if (min->encoding == OBJ_ENCODING_INT) {\n        spec->min = (long)min->ptr;\n    } else {\n        if (((char*)min->ptr)[0] == '(') {\n            spec->min = strtod((char*)min->ptr+1,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->min)) return C_ERR;\n            spec->minex = 1;\n        } else {\n            spec->min = strtod((char*)min->ptr,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->min)) return C_ERR;\n        }\n    }\n    if (max->encoding == OBJ_ENCODING_INT) {\n        spec->max = (long)max->ptr;\n    } else {\n        if (((char*)max->ptr)[0] == '(') {\n            spec->max = strtod((char*)max->ptr+1,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->max)) return C_ERR;\n            spec->maxex = 1;\n        } else {\n            spec->max = strtod((char*)max->ptr,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->max)) return C_ERR;\n        }\n    }\n\n    return C_OK;\n}\n\n/* ------------------------ Lexicographic ranges ---------------------------- */\n\n/* Parse max or min argument of ZRANGEBYLEX.\n  * (foo means foo (open interval)\n  * [foo means foo (closed interval)\n  * - means the min string possible\n  * + means the max string possible\n  *\n  * If the string is valid the *dest pointer is set to the redis object\n  * that will be used for the comparison, and ex will be set to 0 or 1\n  * respectively if the item is exclusive or inclusive. C_OK will be\n  * returned.\n  *\n  * If the string is not a valid range C_ERR is returned, and the value\n  * of *dest and *ex is undefined. */\nint zslParseLexRangeItem(robj *item, sds *dest, int *ex) {\n    char *c = item->ptr;\n\n    switch(c[0]) {\n    case '+':\n        if (c[1] != '\\0') return C_ERR;\n        *ex = 1;\n        *dest = shared.maxstring;\n        return C_OK;\n    case '-':\n        if (c[1] != '\\0') return C_ERR;\n        *ex = 1;\n        *dest = shared.minstring;\n        return C_OK;\n    case '(':\n        *ex = 1;\n        *dest = sdsnewlen(c+1,sdslen(c)-1);\n        return C_OK;\n    case '[':\n        *ex = 0;\n        *dest = sdsnewlen(c+1,sdslen(c)-1);\n        return C_OK;\n    default:\n        return C_ERR;\n    }\n}\n\n/* Free a lex range structure, must be called only after zslParseLexRange()\n * populated the structure with success (C_OK returned). */\nvoid zslFreeLexRange(zlexrangespec *spec) {\n    if (spec->min != shared.minstring &&\n        spec->min != shared.maxstring) sdsfree(spec->min);\n    if (spec->max != shared.minstring &&\n        spec->max != shared.maxstring) sdsfree(spec->max);\n}\n\n/* Populate the lex rangespec according to the objects min and max.\n *\n * Return C_OK on success. On error C_ERR is returned.\n * When OK is returned the structure must be freed with zslFreeLexRange(),\n * otherwise no release is needed. */\nint zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {\n    /* The range can't be valid if objects are integer encoded.\n     * Every item must start with ( or [. */\n    if (min->encoding == OBJ_ENCODING_INT ||\n        max->encoding == OBJ_ENCODING_INT) return C_ERR;\n\n    spec->min = spec->max = NULL;\n    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||\n        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {\n        zslFreeLexRange(spec);\n        return C_ERR;\n    } else {\n        return C_OK;\n    }\n}\n\n/* This is just a wrapper to sdscmp() that is able to\n * handle shared.minstring and shared.maxstring as the equivalent of\n * -inf and +inf for strings */\nint sdscmplex(sds a, sds b) {\n    if (a == b) return 0;\n    if (a == shared.minstring || b == shared.maxstring) return -1;\n    if (a == shared.maxstring || b == shared.minstring) return 1;\n    return sdscmp(a,b);\n}\n\nint zslLexValueGteMin(sds value, zlexrangespec *spec) {\n    return spec->minex ?\n        (sdscmplex(value,spec->min) > 0) :\n        (sdscmplex(value,spec->min) >= 0);\n}\n\nint zslLexValueLteMax(sds value, zlexrangespec *spec) {\n    return spec->maxex ?\n        (sdscmplex(value,spec->max) < 0) :\n        (sdscmplex(value,spec->max) <= 0);\n}\n\n/* Returns if there is a part of the zset is in the lex range. */\nint zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {\n    zskiplistNode *x;\n\n    /* Test for ranges that will always be empty. */\n    int cmp = sdscmplex(range->min,range->max);\n    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))\n        return 0;\n    x = zsl->tail;\n    if (x == NULL || !zslLexValueGteMin(x->ele,range))\n        return 0;\n    x = zsl->header->level[0].forward;\n    if (x == NULL || !zslLexValueLteMax(x->ele,range))\n        return 0;\n    return 1;\n}\n\n/* Find the first node that is contained in the specified lex range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInLexRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *OUT* of range. */\n        while (x->level[i].forward &&\n            !zslLexValueGteMin(x->level[i].forward->ele,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so the next node cannot be NULL. */\n    x = x->level[0].forward;\n    serverAssert(x != NULL);\n\n    /* Check if score <= max. */\n    if (!zslLexValueLteMax(x->ele,range)) return NULL;\n    return x;\n}\n\n/* Find the last node that is contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInLexRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *IN* range. */\n        while (x->level[i].forward &&\n            zslLexValueLteMax(x->level[i].forward->ele,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so this node cannot be NULL. */\n    serverAssert(x != NULL);\n\n    /* Check if score >= min. */\n    if (!zslLexValueGteMin(x->ele,range)) return NULL;\n    return x;\n}\n\n/*-----------------------------------------------------------------------------\n * Listpack-backed sorted set API\n *----------------------------------------------------------------------------*/\n\ndouble zzlStrtod(unsigned char *vstr, unsigned int vlen) {\n    char buf[128];\n    if (vlen > sizeof(buf) - 1)\n        vlen = sizeof(buf) - 1;\n    memcpy(buf,vstr,vlen);\n    buf[vlen] = '\\0';\n    return strtod(buf,NULL);\n }\n\ndouble zzlGetScore(unsigned char *sptr) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n    double score;\n\n    serverAssert(sptr != NULL);\n    vstr = lpGetValue(sptr,&vlen,&vlong);\n\n    if (vstr) {\n        score = zzlStrtod(vstr,vlen);\n    } else {\n        score = vlong;\n    }\n\n    return score;\n}\n\n/* Return a listpack element as an SDS string. */\nsds lpGetObject(unsigned char *sptr) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n\n    serverAssert(sptr != NULL);\n    vstr = lpGetValue(sptr,&vlen,&vlong);\n\n    if (vstr) {\n        return sdsnewlen((char*)vstr,vlen);\n    } else {\n        return sdsfromlonglong(vlong);\n    }\n}\n\n/* Compare element in sorted set with given element. */\nint zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n    unsigned char vbuf[32];\n    int minlen, cmp;\n\n    vstr = lpGetValue(eptr,&vlen,&vlong);\n    if (vstr == NULL) {\n        /* Store string representation of long long in buf. */\n        vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);\n        vstr = vbuf;\n    }\n\n    minlen = (vlen < clen) ? vlen : clen;\n    cmp = memcmp(vstr,cstr,minlen);\n    if (cmp == 0) return vlen-clen;\n    return cmp;\n}\n\nunsigned int zzlLength(unsigned char *zl) {\n    return lpLength(zl)/2;\n}\n\n/* Move to next entry based on the values in eptr and sptr. Both are set to\n * NULL when there is no next entry. */\nvoid zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {\n    unsigned char *_eptr, *_sptr;\n    serverAssert(*eptr != NULL && *sptr != NULL);\n\n    _eptr = lpNext(zl,*sptr);\n    if (_eptr != NULL) {\n        _sptr = lpNext(zl,_eptr);\n        serverAssert(_sptr != NULL);\n    } else {\n        /* No next entry. */\n        _sptr = NULL;\n    }\n\n    *eptr = _eptr;\n    *sptr = _sptr;\n}\n\n/* Move to the previous entry based on the values in eptr and sptr. Both are\n * set to NULL when there is no prev entry. */\nvoid zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {\n    unsigned char *_eptr, *_sptr;\n    serverAssert(*eptr != NULL && *sptr != NULL);\n\n    _sptr = lpPrev(zl,*eptr);\n    if (_sptr != NULL) {\n        _eptr = lpPrev(zl,_sptr);\n        serverAssert(_eptr != NULL);\n    } else {\n        /* No previous entry. */\n        _eptr = NULL;\n    }\n\n    *eptr = _eptr;\n    *sptr = _sptr;\n}\n\n/* Returns if there is a part of the zset is in range. Should only be used\n * internally by zzlFirstInRange and zzlLastInRange. */\nint zzlIsInRange(unsigned char *zl, zrangespec *range) {\n    unsigned char *p;\n    double score;\n\n    /* Test for ranges that will always be empty. */\n    if (range->min > range->max ||\n            (range->min == range->max && (range->minex || range->maxex)))\n        return 0;\n\n    p = lpSeek(zl,-1); /* Last score. */\n    if (p == NULL) return 0; /* Empty sorted set */\n    score = zzlGetScore(p);\n    if (!zslValueGteMin(score,range))\n        return 0;\n\n    p = lpSeek(zl,1); /* First score. */\n    serverAssert(p != NULL);\n    score = zzlGetScore(p);\n    if (!zslValueLteMax(score,range))\n        return 0;\n\n    return 1;\n}\n\n/* Find pointer to the first element contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,0), *sptr;\n    double score;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        score = zzlGetScore(sptr);\n        if (zslValueGteMin(score,range)) {\n            /* Check if score <= max. */\n            if (zslValueLteMax(score,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to next element. */\n        eptr = lpNext(zl,sptr);\n    }\n\n    return NULL;\n}\n\n/* Find pointer to the last element contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,-2), *sptr;\n    double score;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        score = zzlGetScore(sptr);\n        if (zslValueLteMax(score,range)) {\n            /* Check if score >= min. */\n            if (zslValueGteMin(score,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to previous element by moving to the score of previous element.\n         * When this returns NULL, we know there also is no element. */\n        sptr = lpPrev(zl,eptr);\n        if (sptr != NULL)\n            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);\n        else\n            eptr = NULL;\n    }\n\n    return NULL;\n}\n\nint zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {\n    sds value = lpGetObject(p);\n    int res = zslLexValueGteMin(value,spec);\n    sdsfree(value);\n    return res;\n}\n\nint zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {\n    sds value = lpGetObject(p);\n    int res = zslLexValueLteMax(value,spec);\n    sdsfree(value);\n    return res;\n}\n\n/* Returns if there is a part of the zset is in range. Should only be used\n * internally by zzlFirstInLexRange and zzlLastInLexRange. */\nint zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {\n    unsigned char *p;\n\n    /* Test for ranges that will always be empty. */\n    int cmp = sdscmplex(range->min,range->max);\n    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))\n        return 0;\n\n    p = lpSeek(zl,-2); /* Last element. */\n    if (p == NULL) return 0;\n    if (!zzlLexValueGteMin(p,range))\n        return 0;\n\n    p = lpSeek(zl,0); /* First element. */\n    serverAssert(p != NULL);\n    if (!zzlLexValueLteMax(p,range))\n        return 0;\n\n    return 1;\n}\n\n/* Find pointer to the first element contained in the specified lex range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,0), *sptr;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInLexRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        if (zzlLexValueGteMin(eptr,range)) {\n            /* Check if score <= max. */\n            if (zzlLexValueLteMax(eptr,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to next element. */\n        sptr = lpNext(zl,eptr); /* This element score. Skip it. */\n        serverAssert(sptr != NULL);\n        eptr = lpNext(zl,sptr); /* Next element. */\n    }\n\n    return NULL;\n}\n\n/* Find pointer to the last element contained in the specified lex range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,-2), *sptr;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInLexRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        if (zzlLexValueLteMax(eptr,range)) {\n            /* Check if score >= min. */\n            if (zzlLexValueGteMin(eptr,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to previous element by moving to the score of previous element.\n         * When this returns NULL, we know there also is no element. */\n        sptr = lpPrev(zl,eptr);\n        if (sptr != NULL)\n            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);\n        else\n            eptr = NULL;\n    }\n\n    return NULL;\n}\n\nunsigned char *zzlFind(unsigned char *lp, sds ele, double *score) {\n    unsigned char *eptr, *sptr;\n\n    if ((eptr = lpFirst(lp)) == NULL) return NULL;\n    eptr = lpFind(lp, eptr, (unsigned char*)ele, sdslen(ele), 1);\n    if (eptr) {\n        sptr = lpNext(lp,eptr);\n        serverAssert(sptr != NULL);\n\n        /* Matching element, pull out score. */\n        if (score != NULL) *score = zzlGetScore(sptr);\n        return eptr;\n    }\n\n    return NULL;\n}\n\n/* Delete (element,score) pair from listpack. Use local copy of eptr because we\n * don't want to modify the one given as argument. */\nunsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {\n    return lpDeleteRangeWithEntry(zl,&eptr,2);\n}\n\nunsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {\n    unsigned char *sptr;\n    char scorebuf[MAX_D2STRING_CHARS];\n    int scorelen;\n    long long lscore;\n    int score_is_long = double2ll(score, &lscore);\n    if (!score_is_long)\n        scorelen = d2string(scorebuf,sizeof(scorebuf),score);\n    if (eptr == NULL) {\n        zl = lpAppend(zl,(unsigned char*)ele,sdslen(ele));\n        if (score_is_long)\n            zl = lpAppendInteger(zl,lscore);\n        else\n            zl = lpAppend(zl,(unsigned char*)scorebuf,scorelen);\n    } else {\n        /* Insert member before the element 'eptr'. */\n        zl = lpInsertString(zl,(unsigned char*)ele,sdslen(ele),eptr,LP_BEFORE,&sptr);\n\n        /* Insert score after the member. */\n        if (score_is_long)\n            zl = lpInsertInteger(zl,lscore,sptr,LP_AFTER,NULL);\n        else\n            zl = lpInsertString(zl,(unsigned char*)scorebuf,scorelen,sptr,LP_AFTER,NULL);\n    }\n    return zl;\n}\n\n/* Insert (element,score) pair in listpack. This function assumes the element is\n * not yet present in the list. */\nunsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {\n    unsigned char *eptr = lpSeek(zl,0), *sptr;\n    double s;\n\n    while (eptr != NULL) {\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n        s = zzlGetScore(sptr);\n\n        if (s > score) {\n            /* First element with score larger than score for element to be\n             * inserted. This means we should take its spot in the list to\n             * maintain ordering. */\n            zl = zzlInsertAt(zl,eptr,ele,score);\n            break;\n        } else if (s == score) {\n            /* Ensure lexicographical ordering for elements. */\n            if (zzlCompareElements(eptr,(unsigned char*)ele,sdslen(ele)) > 0) {\n                zl = zzlInsertAt(zl,eptr,ele,score);\n                break;\n            }\n        }\n\n        /* Move to next element. */\n        eptr = lpNext(zl,sptr);\n    }\n\n    /* Push on tail of list when it was not yet inserted. */\n    if (eptr == NULL)\n        zl = zzlInsertAt(zl,NULL,ele,score);\n    return zl;\n}\n\nunsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {\n    unsigned char *eptr, *sptr;\n    double score;\n    unsigned long num = 0;\n\n    if (deleted != NULL) *deleted = 0;\n\n    eptr = zzlFirstInRange(zl,range);\n    if (eptr == NULL) return zl;\n\n    /* When the tail of the listpack is deleted, eptr will be NULL. */\n    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {\n        score = zzlGetScore(sptr);\n        if (zslValueLteMax(score,range)) {\n            /* Delete both the element and the score. */\n            zl = lpDeleteRangeWithEntry(zl,&eptr,2);\n            num++;\n        } else {\n            /* No longer in range. */\n            break;\n        }\n    }\n\n    if (deleted != NULL) *deleted = num;\n    return zl;\n}\n\nunsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {\n    unsigned char *eptr, *sptr;\n    unsigned long num = 0;\n\n    if (deleted != NULL) *deleted = 0;\n\n    eptr = zzlFirstInLexRange(zl,range);\n    if (eptr == NULL) return zl;\n\n    /* When the tail of the listpack is deleted, eptr will be NULL. */\n    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {\n        if (zzlLexValueLteMax(eptr,range)) {\n            /* Delete both the element and the score. */\n            zl = lpDeleteRangeWithEntry(zl,&eptr,2);\n            num++;\n        } else {\n            /* No longer in range. */\n            break;\n        }\n    }\n\n    if (deleted != NULL) *deleted = num;\n    return zl;\n}\n\n/* Delete all the elements with rank between start and end from the skiplist.\n * Start and end are inclusive. Note that start and end need to be 1-based */\nunsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {\n    unsigned int num = (end-start)+1;\n    if (deleted) *deleted = num;\n    zl = lpDeleteRange(zl,2*(start-1),2*num);\n    return zl;\n}\n\n/*-----------------------------------------------------------------------------\n * Common sorted set API\n *----------------------------------------------------------------------------*/\n\nunsigned long zsetLength(const robj *zobj) {\n    unsigned long length = 0;\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        length = zzlLength(zobj->ptr);\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        length = ((const zset*)zobj->ptr)->zsl->length;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return length;\n}\n\nvoid zsetConvert(robj *zobj, int encoding) {\n    zset *zs;\n    zskiplistNode *node, *next;\n    sds ele;\n    double score;\n\n    if (zobj->encoding == encoding) return;\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        if (encoding != OBJ_ENCODING_SKIPLIST)\n            serverPanic(\"Unknown target encoding\");\n\n        zs = zmalloc(sizeof(*zs));\n        zs->dict = dictCreate(&zsetDictType);\n        zs->zsl = zslCreate();\n\n        eptr = lpSeek(zl,0);\n        if (eptr != NULL) {\n            sptr = lpNext(zl,eptr);\n            serverAssertWithInfo(NULL,zobj,sptr != NULL);\n        }\n\n        while (eptr != NULL) {\n            score = zzlGetScore(sptr);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            if (vstr == NULL)\n                ele = sdsfromlonglong(vlong);\n            else\n                ele = sdsnewlen((char*)vstr,vlen);\n\n            node = zslInsert(zs->zsl,score,ele);\n            serverAssert(dictAdd(zs->dict,ele,&node->score) == DICT_OK);\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        zfree(zobj->ptr);\n        zobj->ptr = zs;\n        zobj->encoding = OBJ_ENCODING_SKIPLIST;\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        unsigned char *zl = lpNew(0);\n\n        if (encoding != OBJ_ENCODING_LISTPACK)\n            serverPanic(\"Unknown target encoding\");\n\n        /* Approach similar to zslFree(), since we want to free the skiplist at\n         * the same time as creating the listpack. */\n        zs = zobj->ptr;\n        dictRelease(zs->dict);\n        node = zs->zsl->header->level[0].forward;\n        zfree(zs->zsl->header);\n        zfree(zs->zsl);\n\n        while (node) {\n            zl = zzlInsertAt(zl,NULL,node->ele,node->score);\n            next = node->level[0].forward;\n            zslFreeNode(node);\n            node = next;\n        }\n\n        zfree(zs);\n        zobj->ptr = zl;\n        zobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}\n\n/* Convert the sorted set object into a listpack if it is not already a listpack\n * and if the number of elements and the maximum element size and total elements size\n * are within the expected ranges. */\nvoid zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;\n    zset *zset = zobj->ptr;\n\n    if (zset->zsl->length <= server.zset_max_listpack_entries &&\n        maxelelen <= server.zset_max_listpack_value &&\n        lpSafeToAdd(NULL, totelelen))\n    {\n        zsetConvert(zobj,OBJ_ENCODING_LISTPACK);\n    }\n}\n\n/* Return (by reference) the score of the specified member of the sorted set\n * storing it into *score. If the element does not exist C_ERR is returned\n * otherwise C_OK is returned and *score is correctly populated.\n * If 'zobj' or 'member' is NULL, C_ERR is returned. */\nint zsetScore(robj *zobj, sds member, double *score) {\n    if (!zobj || !member) return C_ERR;\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        dictEntry *de = dictFind(zs->dict, member);\n        if (de == NULL) return C_ERR;\n        *score = *(double*)dictGetVal(de);\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return C_OK;\n}\n\n/* Add a new element or update the score of an existing element in a sorted\n * set, regardless of its encoding.\n *\n * The set of flags change the command behavior. \n *\n * The input flags are the following:\n *\n * ZADD_INCR: Increment the current element score by 'score' instead of updating\n *            the current element score. If the element does not exist, we\n *            assume 0 as previous score.\n * ZADD_NX:   Perform the operation only if the element does not exist.\n * ZADD_XX:   Perform the operation only if the element already exist.\n * ZADD_GT:   Perform the operation on existing elements only if the new score is \n *            greater than the current score.\n * ZADD_LT:   Perform the operation on existing elements only if the new score is \n *            less than the current score.\n *\n * When ZADD_INCR is used, the new score of the element is stored in\n * '*newscore' if 'newscore' is not NULL.\n *\n * The returned flags are the following:\n *\n * ZADD_NAN:     The resulting score is not a number.\n * ZADD_ADDED:   The element was added (not present before the call).\n * ZADD_UPDATED: The element score was updated.\n * ZADD_NOP:     No operation was performed because of NX or XX.\n *\n * Return value:\n *\n * The function returns 1 on success, and sets the appropriate flags\n * ADDED or UPDATED to signal what happened during the operation (note that\n * none could be set if we re-added an element using the same score it used\n * to have, or in the case a zero increment is used).\n *\n * The function returns 0 on error, currently only when the increment\n * produces a NAN condition, or when the 'score' value is NAN since the\n * start.\n *\n * The command as a side effect of adding a new element may convert the sorted\n * set internal encoding from listpack to hashtable+skiplist.\n *\n * Memory management of 'ele':\n *\n * The function does not take ownership of the 'ele' SDS string, but copies\n * it if needed. */\nint zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {\n    /* Turn options into simple to check vars. */\n    int incr = (in_flags & ZADD_IN_INCR) != 0;\n    int nx = (in_flags & ZADD_IN_NX) != 0;\n    int xx = (in_flags & ZADD_IN_XX) != 0;\n    int gt = (in_flags & ZADD_IN_GT) != 0;\n    int lt = (in_flags & ZADD_IN_LT) != 0;\n    *out_flags = 0; /* We'll return our response flags. */\n    double curscore;\n\n    /* NaN as input is an error regardless of all the other parameters. */\n    if (isnan(score)) {\n        *out_flags = ZADD_OUT_NAN;\n        return 0;\n    }\n\n    /* Update the sorted set according to its encoding. */\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *eptr;\n\n        if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {\n            /* NX? Return, same element already exists. */\n            if (nx) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            /* Prepare the score for the increment if needed. */\n            if (incr) {\n                score += curscore;\n                if (isnan(score)) {\n                    *out_flags |= ZADD_OUT_NAN;\n                    return 0;\n                }\n            }\n\n            /* GT/LT? Only update if score is greater/less than current. */\n            if ((lt && score >= curscore) || (gt && score <= curscore)) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            if (newscore) *newscore = score;\n\n            /* Remove and re-insert when score changed. */\n            if (score != curscore) {\n                zobj->ptr = zzlDelete(zobj->ptr,eptr);\n                zobj->ptr = zzlInsert(zobj->ptr,ele,score);\n                *out_flags |= ZADD_OUT_UPDATED;\n            }\n            return 1;\n        } else if (!xx) {\n            /* check if the element is too large or the list\n             * becomes too long *before* executing zzlInsert. */\n            if (zzlLength(zobj->ptr)+1 > server.zset_max_listpack_entries ||\n                sdslen(ele) > server.zset_max_listpack_value ||\n                !lpSafeToAdd(zobj->ptr, sdslen(ele)))\n            {\n                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);\n            } else {\n                zobj->ptr = zzlInsert(zobj->ptr,ele,score);\n                if (newscore) *newscore = score;\n                *out_flags |= ZADD_OUT_ADDED;\n                return 1;\n            }\n        } else {\n            *out_flags |= ZADD_OUT_NOP;\n            return 1;\n        }\n    }\n\n    /* Note that the above block handling listpack would have either returned or\n     * converted the key to skiplist. */\n    if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplistNode *znode;\n        dictEntry *de;\n\n        de = dictFind(zs->dict,ele);\n        if (de != NULL) {\n            /* NX? Return, same element already exists. */\n            if (nx) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            curscore = *(double*)dictGetVal(de);\n\n            /* Prepare the score for the increment if needed. */\n            if (incr) {\n                score += curscore;\n                if (isnan(score)) {\n                    *out_flags |= ZADD_OUT_NAN;\n                    return 0;\n                }\n            }\n\n            /* GT/LT? Only update if score is greater/less than current. */\n            if ((lt && score >= curscore) || (gt && score <= curscore)) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            if (newscore) *newscore = score;\n\n            /* Remove and re-insert when score changes. */\n            if (score != curscore) {\n                znode = zslUpdateScore(zs->zsl,curscore,ele,score);\n                /* Note that we did not removed the original element from\n                 * the hash table representing the sorted set, so we just\n                 * update the score. */\n                dictGetVal(de) = &znode->score; /* Update score ptr. */\n                *out_flags |= ZADD_OUT_UPDATED;\n            }\n            return 1;\n        } else if (!xx) {\n            ele = sdsdup(ele);\n            znode = zslInsert(zs->zsl,score,ele);\n            serverAssert(dictAdd(zs->dict,ele,&znode->score) == DICT_OK);\n            *out_flags |= ZADD_OUT_ADDED;\n            if (newscore) *newscore = score;\n            return 1;\n        } else {\n            *out_flags |= ZADD_OUT_NOP;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return 0; /* Never reached. */\n}\n\n/* Deletes the element 'ele' from the sorted set encoded as a skiplist+dict,\n * returning 1 if the element existed and was deleted, 0 otherwise (the\n * element was not there). It does not resize the dict after deleting the\n * element. */\nstatic int zsetRemoveFromSkiplist(zset *zs, sds ele) {\n    dictEntry *de;\n    double score;\n\n    de = dictUnlink(zs->dict,ele);\n    if (de != NULL) {\n        /* Get the score in order to delete from the skiplist later. */\n        score = *(double*)dictGetVal(de);\n\n        /* Delete from the hash table and later from the skiplist.\n         * Note that the order is important: deleting from the skiplist\n         * actually releases the SDS string representing the element,\n         * which is shared between the skiplist and the hash table, so\n         * we need to delete from the skiplist as the final step. */\n        dictFreeUnlinkedEntry(zs->dict,de);\n\n        /* Delete from skiplist. */\n        int retval = zslDelete(zs->zsl,score,ele,NULL);\n        serverAssert(retval);\n\n        return 1;\n    }\n\n    return 0;\n}\n\n/* Delete the element 'ele' from the sorted set, returning 1 if the element\n * existed and was deleted, 0 otherwise (the element was not there). */\nint zsetDel(robj *zobj, sds ele) {\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *eptr;\n\n        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {\n            zobj->ptr = zzlDelete(zobj->ptr,eptr);\n            return 1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        if (zsetRemoveFromSkiplist(zs, ele)) {\n            if (htNeedsResize(zs->dict)) dictResize(zs->dict);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return 0; /* No such element found. */\n}\n\n/* Given a sorted set object returns the 0-based rank of the object or\n * -1 if the object does not exist.\n *\n * For rank we mean the position of the element in the sorted collection\n * of elements. So the first element has rank 0, the second rank 1, and so\n * forth up to length-1 elements.\n *\n * If 'reverse' is false, the rank is returned considering as first element\n * the one with the lowest score. Otherwise if 'reverse' is non-zero\n * the rank is computed considering as element with rank 0 the one with\n * the highest score. */\nlong zsetRank(robj *zobj, sds ele, int reverse) {\n    unsigned long llen;\n    unsigned long rank;\n\n    llen = zsetLength(zobj);\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n\n        eptr = lpSeek(zl,0);\n        serverAssert(eptr != NULL);\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        rank = 1;\n        while(eptr != NULL) {\n            if (lpCompare(eptr,(unsigned char*)ele,sdslen(ele)))\n                break;\n            rank++;\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        if (eptr != NULL) {\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        dictEntry *de;\n        double score;\n\n        de = dictFind(zs->dict,ele);\n        if (de != NULL) {\n            score = *(double*)dictGetVal(de);\n            rank = zslGetRank(zsl,score,ele);\n            /* Existing elements always have a rank. */\n            serverAssert(rank != 0);\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a sorted set object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *zsetDup(robj *o) {\n    robj *zobj;\n    zset *zs;\n    zset *new_zs;\n\n    serverAssert(o->type == OBJ_ZSET);\n\n    /* Create a new sorted set object that have the same encoding as the original object's encoding */\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = o->ptr;\n        size_t sz = lpBytes(zl);\n        unsigned char *new_zl = zmalloc(sz);\n        memcpy(new_zl, zl, sz);\n        zobj = createObject(OBJ_ZSET, new_zl);\n        zobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {\n        zobj = createZsetObject();\n        zs = o->ptr;\n        new_zs = zobj->ptr;\n        dictExpand(new_zs->dict,dictSize(zs->dict));\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds ele;\n        long llen = zsetLength(o);\n\n        /* We copy the skiplist elements from the greatest to the\n         * smallest (that's trivial since the elements are already ordered in\n         * the skiplist): this improves the load process, since the next loaded\n         * element will always be the smaller, so adding to the skiplist\n         * will always immediately stop at the head, making the insertion\n         * O(1) instead of O(log(N)). */\n        ln = zsl->tail;\n        while (llen--) {\n            ele = ln->ele;\n            sds new_ele = sdsdup(ele);\n            zskiplistNode *znode = zslInsert(new_zs->zsl,ln->score,new_ele);\n            dictAdd(new_zs->dict,new_ele,&znode->score);\n            ln = ln->backward;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return zobj;\n}\n\n/* Create a new sds string from the listpack entry. */\nsds zsetSdsFromListpackEntry(listpackEntry *e) {\n    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);\n}\n\n/* Reply with bulk string from the listpack entry. */\nvoid zsetReplyFromListpackEntry(client *c, listpackEntry *e) {\n    if (e->sval)\n        addReplyBulkCBuffer(c, e->sval, e->slen);\n    else\n        addReplyBulkLongLong(c, e->lval);\n}\n\n\n/* Return random element from a non empty zset.\n * 'key' and 'val' will be set to hold the element.\n * The memory in `key` is not to be freed or modified by the caller.\n * 'score' can be NULL in which case it's not extracted. */\nvoid zsetTypeRandomElement(robj *zsetobj, unsigned long zsetsize, listpackEntry *key, double *score) {\n    if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zsetobj->ptr;\n        dictEntry *de = dictGetFairRandomKey(zs->dict);\n        sds s = dictGetKey(de);\n        key->sval = (unsigned char*)s;\n        key->slen = sdslen(s);\n        if (score)\n            *score = *(double*)dictGetVal(de);\n    } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {\n        listpackEntry val;\n        lpRandomPair(zsetobj->ptr, zsetsize, key, &val);\n        if (score) {\n            if (val.sval) {\n                *score = zzlStrtod(val.sval,val.slen);\n            } else {\n                *score = (double)val.lval;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown zset encoding\");\n    }\n}\n\n/*-----------------------------------------------------------------------------\n * Sorted set commands\n *----------------------------------------------------------------------------*/\n\n/* This generic command implements both ZADD and ZINCRBY. */\nvoid zaddGenericCommand(client *c, int flags) {\n    static char *nanerr = \"resulting score is not a number (NaN)\";\n    robj *key = c->argv[1];\n    robj *zobj;\n    sds ele;\n    double score = 0, *scores = NULL;\n    int j, elements, ch = 0;\n    int scoreidx = 0;\n    /* The following vars are used in order to track what the command actually\n     * did during the execution, to reply to the client and to trigger the\n     * notification of keyspace change. */\n    int added = 0;      /* Number of new elements added. */\n    int updated = 0;    /* Number of elements with updated score. */\n    int processed = 0;  /* Number of elements processed, may remain zero with\n                           options like XX. */\n\n    /* Parse options. At the end 'scoreidx' is set to the argument position\n     * of the score of the first score-element pair. */\n    scoreidx = 2;\n    while(scoreidx < c->argc) {\n        char *opt = c->argv[scoreidx]->ptr;\n        if (!strcasecmp(opt,\"nx\")) flags |= ZADD_IN_NX;\n        else if (!strcasecmp(opt,\"xx\")) flags |= ZADD_IN_XX;\n        else if (!strcasecmp(opt,\"ch\")) ch = 1; /* Return num of elements added or updated. */\n        else if (!strcasecmp(opt,\"incr\")) flags |= ZADD_IN_INCR;\n        else if (!strcasecmp(opt,\"gt\")) flags |= ZADD_IN_GT;\n        else if (!strcasecmp(opt,\"lt\")) flags |= ZADD_IN_LT;\n        else break;\n        scoreidx++;\n    }\n\n    /* Turn options into simple to check vars. */\n    int incr = (flags & ZADD_IN_INCR) != 0;\n    int nx = (flags & ZADD_IN_NX) != 0;\n    int xx = (flags & ZADD_IN_XX) != 0;\n    int gt = (flags & ZADD_IN_GT) != 0;\n    int lt = (flags & ZADD_IN_LT) != 0;\n\n    /* After the options, we expect to have an even number of args, since\n     * we expect any number of score-element pairs. */\n    elements = c->argc-scoreidx;\n    if (elements % 2 || !elements) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n    elements /= 2; /* Now this holds the number of score-element pairs. */\n\n    /* Check for incompatible options. */\n    if (nx && xx) {\n        addReplyError(c,\n            \"XX and NX options at the same time are not compatible\");\n        return;\n    }\n    \n    if ((gt && nx) || (lt && nx) || (gt && lt)) {\n        addReplyError(c,\n            \"GT, LT, and/or NX options at the same time are not compatible\");\n        return;\n    }\n    /* Note that XX is compatible with either GT or LT */\n\n    if (incr && elements > 1) {\n        addReplyError(c,\n            \"INCR option supports a single increment-element pair\");\n        return;\n    }\n\n    /* Start parsing all the scores, we need to emit any syntax error\n     * before executing additions to the sorted set, as the command should\n     * either execute fully or nothing at all. */\n    scores = zmalloc(sizeof(double)*elements);\n    for (j = 0; j < elements; j++) {\n        if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)\n            != C_OK) goto cleanup;\n    }\n\n    /* Lookup the key and create the sorted set if does not exist. */\n    zobj = lookupKeyWrite(c->db,key);\n    if (checkType(c,zobj,OBJ_ZSET)) goto cleanup;\n    if (zobj == NULL) {\n        if (xx) goto reply_to_client; /* No key + XX option: nothing to do. */\n        if (server.zset_max_listpack_entries == 0 ||\n            server.zset_max_listpack_value < sdslen(c->argv[scoreidx+1]->ptr))\n        {\n            zobj = createZsetObject();\n        } else {\n            zobj = createZsetListpackObject();\n        }\n        dbAdd(c->db,key,zobj);\n    }\n\n    for (j = 0; j < elements; j++) {\n        double newscore;\n        score = scores[j];\n        int retflags = 0;\n\n        ele = c->argv[scoreidx+1+j*2]->ptr;\n        int retval = zsetAdd(zobj, score, ele, flags, &retflags, &newscore);\n        if (retval == 0) {\n            addReplyError(c,nanerr);\n            goto cleanup;\n        }\n        if (retflags & ZADD_OUT_ADDED) added++;\n        if (retflags & ZADD_OUT_UPDATED) updated++;\n        if (!(retflags & ZADD_OUT_NOP)) processed++;\n        score = newscore;\n    }\n    server.dirty += (added+updated);\n\nreply_to_client:\n    if (incr) { /* ZINCRBY or INCR option. */\n        if (processed)\n            addReplyDouble(c,score);\n        else\n            addReplyNull(c);\n    } else { /* ZADD. */\n        addReplyLongLong(c,ch ? added+updated : added);\n    }\n\ncleanup:\n    zfree(scores);\n    if (added || updated) {\n        signalModifiedKey(c,c->db,key);\n        notifyKeyspaceEvent(NOTIFY_ZSET,\n            incr ? \"zincr\" : \"zadd\", key, c->db->id);\n    }\n}\n\nvoid zaddCommand(client *c) {\n    zaddGenericCommand(c,ZADD_IN_NONE);\n}\n\nvoid zincrbyCommand(client *c) {\n    zaddGenericCommand(c,ZADD_IN_INCR);\n}\n\nvoid zremCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    int deleted = 0, keyremoved = 0, j;\n\n    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;\n        if (zsetLength(zobj) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n            break;\n        }\n    }\n\n    if (deleted) {\n        notifyKeyspaceEvent(NOTIFY_ZSET,\"zrem\",key,c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n        signalModifiedKey(c,c->db,key);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\ntypedef enum {\n    ZRANGE_AUTO = 0,\n    ZRANGE_RANK,\n    ZRANGE_SCORE,\n    ZRANGE_LEX,\n} zrange_type;\n\n/* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */\nvoid zremrangeGenericCommand(client *c, zrange_type rangetype) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    int keyremoved = 0;\n    unsigned long deleted = 0;\n    zrangespec range;\n    zlexrangespec lexrange;\n    long start, end, llen;\n    char *notify_type = NULL;\n\n    /* Step 1: Parse the range. */\n    if (rangetype == ZRANGE_RANK) {\n        notify_type = \"zremrangebyrank\";\n        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||\n            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))\n            return;\n    } else if (rangetype == ZRANGE_SCORE) {\n        notify_type = \"zremrangebyscore\";\n        if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {\n            addReplyError(c,\"min or max is not a float\");\n            return;\n        }\n    } else if (rangetype == ZRANGE_LEX) {\n        notify_type = \"zremrangebylex\";\n        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {\n            addReplyError(c,\"min or max not valid string range item\");\n            return;\n        }\n    } else {\n        serverPanic(\"unknown rangetype %d\", (int)rangetype);\n    }\n\n    /* Step 2: Lookup & range sanity checks if needed. */\n    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) goto cleanup;\n\n    if (rangetype == ZRANGE_RANK) {\n        /* Sanitize indexes. */\n        llen = zsetLength(zobj);\n        if (start < 0) start = llen+start;\n        if (end < 0) end = llen+end;\n        if (start < 0) start = 0;\n\n        /* Invariant: start >= 0, so this test will be true when end < 0.\n         * The range is empty when start > end or start >= length. */\n        if (start > end || start >= llen) {\n            addReply(c,shared.czero);\n            goto cleanup;\n        }\n        if (end >= llen) end = llen-1;\n    }\n\n    /* Step 3: Perform the range deletion operation. */\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        switch(rangetype) {\n        case ZRANGE_AUTO:\n        case ZRANGE_RANK:\n            zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,start+1,end+1,&deleted);\n            break;\n        case ZRANGE_SCORE:\n            zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,&range,&deleted);\n            break;\n        case ZRANGE_LEX:\n            zobj->ptr = zzlDeleteRangeByLex(zobj->ptr,&lexrange,&deleted);\n            break;\n        }\n        if (zzlLength(zobj->ptr) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        switch(rangetype) {\n        case ZRANGE_AUTO:\n        case ZRANGE_RANK:\n            deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);\n            break;\n        case ZRANGE_SCORE:\n            deleted = zslDeleteRangeByScore(zs->zsl,&range,zs->dict);\n            break;\n        case ZRANGE_LEX:\n            deleted = zslDeleteRangeByLex(zs->zsl,&lexrange,zs->dict);\n            break;\n        }\n        if (htNeedsResize(zs->dict)) dictResize(zs->dict);\n        if (dictSize(zs->dict) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    /* Step 4: Notifications and reply. */\n    if (deleted) {\n        signalModifiedKey(c,c->db,key);\n        notifyKeyspaceEvent(NOTIFY_ZSET,notify_type,key,c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n    }\n    server.dirty += deleted;\n    addReplyLongLong(c,deleted);\n\ncleanup:\n    if (rangetype == ZRANGE_LEX) zslFreeLexRange(&lexrange);\n}\n\nvoid zremrangebyrankCommand(client *c) {\n    zremrangeGenericCommand(c,ZRANGE_RANK);\n}\n\nvoid zremrangebyscoreCommand(client *c) {\n    zremrangeGenericCommand(c,ZRANGE_SCORE);\n}\n\nvoid zremrangebylexCommand(client *c) {\n    zremrangeGenericCommand(c,ZRANGE_LEX);\n}\n\ntypedef struct {\n    robj *subject;\n    int type; /* Set, sorted set */\n    int encoding;\n    double weight;\n\n    union {\n        /* Set iterators. */\n        union _iterset {\n            struct {\n                intset *is;\n                int ii;\n            } is;\n            struct {\n                dict *dict;\n                dictIterator *di;\n                dictEntry *de;\n            } ht;\n        } set;\n\n        /* Sorted set iterators. */\n        union _iterzset {\n            struct {\n                unsigned char *zl;\n                unsigned char *eptr, *sptr;\n            } zl;\n            struct {\n                zset *zs;\n                zskiplistNode *node;\n            } sl;\n        } zset;\n    } iter;\n} zsetopsrc;\n\n\n/* Use dirty flags for pointers that need to be cleaned up in the next\n * iteration over the zsetopval. The dirty flag for the long long value is\n * special, since long long values don't need cleanup. Instead, it means that\n * we already checked that \"ell\" holds a long long, or tried to convert another\n * representation into a long long value. When this was successful,\n * OPVAL_VALID_LL is set as well. */\n#define OPVAL_DIRTY_SDS 1\n#define OPVAL_DIRTY_LL 2\n#define OPVAL_VALID_LL 4\n\n/* Store value retrieved from the iterator. */\ntypedef struct {\n    int flags;\n    unsigned char _buf[32]; /* Private buffer. */\n    sds ele;\n    unsigned char *estr;\n    unsigned int elen;\n    long long ell;\n    double score;\n} zsetopval;\n\ntypedef union _iterset iterset;\ntypedef union _iterzset iterzset;\n\nvoid zuiInitIterator(zsetopsrc *op) {\n    if (op->subject == NULL)\n        return;\n\n    if (op->type == OBJ_SET) {\n        iterset *it = &op->iter.set;\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            it->is.is = op->subject->ptr;\n            it->is.ii = 0;\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            it->ht.dict = op->subject->ptr;\n            it->ht.di = dictGetIterator(op->subject->ptr);\n            it->ht.de = dictNext(it->ht.di);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        /* Sorted sets are traversed in reverse order to optimize for\n         * the insertion of the elements in a new list as in\n         * ZDIFF/ZINTER/ZUNION */\n        iterzset *it = &op->iter.zset;\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            it->zl.zl = op->subject->ptr;\n            it->zl.eptr = lpSeek(it->zl.zl,-2);\n            if (it->zl.eptr != NULL) {\n                it->zl.sptr = lpNext(it->zl.zl,it->zl.eptr);\n                serverAssert(it->zl.sptr != NULL);\n            }\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            it->sl.zs = op->subject->ptr;\n            it->sl.node = it->sl.zs->zsl->tail;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\nvoid zuiClearIterator(zsetopsrc *op) {\n    if (op->subject == NULL)\n        return;\n\n    if (op->type == OBJ_SET) {\n        iterset *it = &op->iter.set;\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            UNUSED(it); /* skip */\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            dictReleaseIterator(it->ht.di);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        iterzset *it = &op->iter.zset;\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            UNUSED(it); /* skip */\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            UNUSED(it); /* skip */\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\nvoid zuiDiscardDirtyValue(zsetopval *val) {\n    if (val->flags & OPVAL_DIRTY_SDS) {\n        sdsfree(val->ele);\n        val->ele = NULL;\n        val->flags &= ~OPVAL_DIRTY_SDS;\n    }\n}\n\nunsigned long zuiLength(zsetopsrc *op) {\n    if (op->subject == NULL)\n        return 0;\n\n    if (op->type == OBJ_SET) {\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            return intsetLen(op->subject->ptr);\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            dict *ht = op->subject->ptr;\n            return dictSize(ht);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            return zzlLength(op->subject->ptr);\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = op->subject->ptr;\n            return zs->zsl->length;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\n/* Check if the current value is valid. If so, store it in the passed structure\n * and move to the next element. If not valid, this means we have reached the\n * end of the structure and can abort. */\nint zuiNext(zsetopsrc *op, zsetopval *val) {\n    if (op->subject == NULL)\n        return 0;\n\n    zuiDiscardDirtyValue(val);\n\n    memset(val,0,sizeof(zsetopval));\n\n    if (op->type == OBJ_SET) {\n        iterset *it = &op->iter.set;\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            int64_t ell;\n\n            if (!intsetGet(it->is.is,it->is.ii,&ell))\n                return 0;\n            val->ell = ell;\n            val->score = 1.0;\n\n            /* Move to next element. */\n            it->is.ii++;\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            if (it->ht.de == NULL)\n                return 0;\n            val->ele = dictGetKey(it->ht.de);\n            val->score = 1.0;\n\n            /* Move to next element. */\n            it->ht.de = dictNext(it->ht.di);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        iterzset *it = &op->iter.zset;\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            /* No need to check both, but better be explicit. */\n            if (it->zl.eptr == NULL || it->zl.sptr == NULL)\n                return 0;\n            val->estr = lpGetValue(it->zl.eptr,&val->elen,&val->ell);\n            val->score = zzlGetScore(it->zl.sptr);\n\n            /* Move to next element (going backwards, see zuiInitIterator). */\n            zzlPrev(it->zl.zl,&it->zl.eptr,&it->zl.sptr);\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            if (it->sl.node == NULL)\n                return 0;\n            val->ele = it->sl.node->ele;\n            val->score = it->sl.node->score;\n\n            /* Move to next element. (going backwards, see zuiInitIterator) */\n            it->sl.node = it->sl.node->backward;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n    return 1;\n}\n\nint zuiLongLongFromValue(zsetopval *val) {\n    if (!(val->flags & OPVAL_DIRTY_LL)) {\n        val->flags |= OPVAL_DIRTY_LL;\n\n        if (val->ele != NULL) {\n            if (string2ll(val->ele,sdslen(val->ele),&val->ell))\n                val->flags |= OPVAL_VALID_LL;\n        } else if (val->estr != NULL) {\n            if (string2ll((char*)val->estr,val->elen,&val->ell))\n                val->flags |= OPVAL_VALID_LL;\n        } else {\n            /* The long long was already set, flag as valid. */\n            val->flags |= OPVAL_VALID_LL;\n        }\n    }\n    return val->flags & OPVAL_VALID_LL;\n}\n\nsds zuiSdsFromValue(zsetopval *val) {\n    if (val->ele == NULL) {\n        if (val->estr != NULL) {\n            val->ele = sdsnewlen((char*)val->estr,val->elen);\n        } else {\n            val->ele = sdsfromlonglong(val->ell);\n        }\n        val->flags |= OPVAL_DIRTY_SDS;\n    }\n    return val->ele;\n}\n\n/* This is different from zuiSdsFromValue since returns a new SDS string\n * which is up to the caller to free. */\nsds zuiNewSdsFromValue(zsetopval *val) {\n    if (val->flags & OPVAL_DIRTY_SDS) {\n        /* We have already one to return! */\n        sds ele = val->ele;\n        val->flags &= ~OPVAL_DIRTY_SDS;\n        val->ele = NULL;\n        return ele;\n    } else if (val->ele) {\n        return sdsdup(val->ele);\n    } else if (val->estr) {\n        return sdsnewlen((char*)val->estr,val->elen);\n    } else {\n        return sdsfromlonglong(val->ell);\n    }\n}\n\nint zuiBufferFromValue(zsetopval *val) {\n    if (val->estr == NULL) {\n        if (val->ele != NULL) {\n            val->elen = sdslen(val->ele);\n            val->estr = (unsigned char*)val->ele;\n        } else {\n            val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);\n            val->estr = val->_buf;\n        }\n    }\n    return 1;\n}\n\n/* Find value pointed to by val in the source pointer to by op. When found,\n * return 1 and store its score in target. Return 0 otherwise. */\nint zuiFind(zsetopsrc *op, zsetopval *val, double *score) {\n    if (op->subject == NULL)\n        return 0;\n\n    if (op->type == OBJ_SET) {\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            if (zuiLongLongFromValue(val) &&\n                intsetFind(op->subject->ptr,val->ell))\n            {\n                *score = 1.0;\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            dict *ht = op->subject->ptr;\n            zuiSdsFromValue(val);\n            if (dictFind(ht,val->ele) != NULL) {\n                *score = 1.0;\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        zuiSdsFromValue(val);\n\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {\n                /* Score is already set by zzlFind. */\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = op->subject->ptr;\n            dictEntry *de;\n            if ((de = dictFind(zs->dict,val->ele)) != NULL) {\n                *score = *(double*)dictGetVal(de);\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\nint zuiCompareByCardinality(const void *s1, const void *s2) {\n    unsigned long first = zuiLength((zsetopsrc*)s1);\n    unsigned long second = zuiLength((zsetopsrc*)s2);\n    if (first > second) return 1;\n    if (first < second) return -1;\n    return 0;\n}\n\nstatic int zuiCompareByRevCardinality(const void *s1, const void *s2) {\n    return zuiCompareByCardinality(s1, s2) * -1;\n}\n\n#define REDIS_AGGR_SUM 1\n#define REDIS_AGGR_MIN 2\n#define REDIS_AGGR_MAX 3\n#define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))\n\ninline static void zunionInterAggregate(double *target, double val, int aggregate) {\n    if (aggregate == REDIS_AGGR_SUM) {\n        *target = *target + val;\n        /* The result of adding two doubles is NaN when one variable\n         * is +inf and the other is -inf. When these numbers are added,\n         * we maintain the convention of the result being 0.0. */\n        if (isnan(*target)) *target = 0.0;\n    } else if (aggregate == REDIS_AGGR_MIN) {\n        *target = val < *target ? val : *target;\n    } else if (aggregate == REDIS_AGGR_MAX) {\n        *target = val > *target ? val : *target;\n    } else {\n        /* safety net */\n        serverPanic(\"Unknown ZUNION/INTER aggregate type\");\n    }\n}\n\nstatic size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {\n    dictIterator *di;\n    dictEntry *de;\n    size_t maxelelen = 0;\n\n    di = dictGetIterator(d);\n\n    while((de = dictNext(di)) != NULL) {\n        sds ele = dictGetKey(de);\n        if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);\n        if (totallen)\n            (*totallen) += sdslen(ele);\n    }\n\n    dictReleaseIterator(di);\n\n    return maxelelen;\n}\n\nstatic void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n    /* DIFF Algorithm 1:\n     *\n     * We perform the diff by iterating all the elements of the first set,\n     * and only adding it to the target set if the element does not exist\n     * into all the other sets.\n     *\n     * This way we perform at max N*M operations, where N is the size of\n     * the first set, and M the number of sets.\n     *\n     * There is also a O(K*log(K)) cost for adding the resulting elements\n     * to the target set, where K is the final size of the target set.\n     *\n     * The final complexity of this algorithm is O(N*M + K*log(K)). */\n    int j;\n    zsetopval zval;\n    zskiplistNode *znode;\n    sds tmp;\n\n    /* With algorithm 1 it is better to order the sets to subtract\n     * by decreasing size, so that we are more likely to find\n     * duplicated elements ASAP. */\n    qsort(src+1,setnum-1,sizeof(zsetopsrc),zuiCompareByRevCardinality);\n\n    memset(&zval, 0, sizeof(zval));\n    zuiInitIterator(&src[0]);\n    while (zuiNext(&src[0],&zval)) {\n        double value;\n        int exists = 0;\n\n        for (j = 1; j < setnum; j++) {\n            /* It is not safe to access the zset we are\n             * iterating, so explicitly check for equal object.\n             * This check isn't really needed anymore since we already\n             * check for a duplicate set in the zsetChooseDiffAlgorithm\n             * function, but we're leaving it for future-proofing. */\n            if (src[j].subject == src[0].subject ||\n                zuiFind(&src[j],&zval,&value)) {\n                exists = 1;\n                break;\n            }\n        }\n\n        if (!exists) {\n            tmp = zuiNewSdsFromValue(&zval);\n            znode = zslInsert(dstzset->zsl,zval.score,tmp);\n            dictAdd(dstzset->dict,tmp,&znode->score);\n            if (sdslen(tmp) > *maxelelen) *maxelelen = sdslen(tmp);\n            (*totelelen) += sdslen(tmp);\n        }\n    }\n    zuiClearIterator(&src[0]);\n}\n\n\nstatic void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n    /* DIFF Algorithm 2:\n     *\n     * Add all the elements of the first set to the auxiliary set.\n     * Then remove all the elements of all the next sets from it.\n     *\n\n     * This is O(L + (N-K)log(N)) where L is the sum of all the elements in every\n     * set, N is the size of the first set, and K is the size of the result set.\n     *\n     * Note that from the (L-N) dict searches, (N-K) got to the zsetRemoveFromSkiplist\n     * which costs log(N)\n     *\n     * There is also a O(K) cost at the end for finding the largest element\n     * size, but this doesn't change the algorithm complexity since K < L, and\n     * O(2L) is the same as O(L). */\n    int j;\n    int cardinality = 0;\n    zsetopval zval;\n    zskiplistNode *znode;\n    sds tmp;\n\n    for (j = 0; j < setnum; j++) {\n        if (zuiLength(&src[j]) == 0) continue;\n\n        memset(&zval, 0, sizeof(zval));\n        zuiInitIterator(&src[j]);\n        while (zuiNext(&src[j],&zval)) {\n            if (j == 0) {\n                tmp = zuiNewSdsFromValue(&zval);\n                znode = zslInsert(dstzset->zsl,zval.score,tmp);\n                dictAdd(dstzset->dict,tmp,&znode->score);\n                cardinality++;\n            } else {\n                tmp = zuiSdsFromValue(&zval);\n                if (zsetRemoveFromSkiplist(dstzset, tmp)) {\n                    cardinality--;\n                }\n            }\n\n            /* Exit if result set is empty as any additional removal\n                * of elements will have no effect. */\n            if (cardinality == 0) break;\n        }\n        zuiClearIterator(&src[j]);\n\n        if (cardinality == 0) break;\n    }\n\n    /* Resize dict if needed after removing multiple elements */\n    if (htNeedsResize(dstzset->dict)) dictResize(dstzset->dict);\n\n    /* Using this algorithm, we can't calculate the max element as we go,\n     * we have to iterate through all elements to find the max one after. */\n    *maxelelen = zsetDictGetMaxElementLength(dstzset->dict, totelelen);\n}\n\nstatic int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {\n    int j;\n\n    /* Select what DIFF algorithm to use.\n     *\n     * Algorithm 1 is O(N*M + K*log(K)) where N is the size of the\n     * first set, M the total number of sets, and K is the size of the\n     * result set.\n     *\n     * Algorithm 2 is O(L + (N-K)log(N)) where L is the total number of elements\n     * in all the sets, N is the size of the first set, and K is the size of the\n     * result set.\n     *\n     * We compute what is the best bet with the current input here. */\n    long long algo_one_work = 0;\n    long long algo_two_work = 0;\n\n    for (j = 0; j < setnum; j++) {\n        /* If any other set is equal to the first set, there is nothing to be\n         * done, since we would remove all elements anyway. */\n        if (j > 0 && src[0].subject == src[j].subject) {\n            return 0;\n        }\n\n        algo_one_work += zuiLength(&src[0]);\n        algo_two_work += zuiLength(&src[j]);\n    }\n\n    /* Algorithm 1 has better constant times and performs less operations\n     * if there are elements in common. Give it some advantage. */\n    algo_one_work /= 2;\n    return (algo_one_work <= algo_two_work) ? 1 : 2;\n}\n\nstatic void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n    /* Skip everything if the smallest input is empty. */\n    if (zuiLength(&src[0]) > 0) {\n        int diff_algo = zsetChooseDiffAlgorithm(src, setnum);\n        if (diff_algo == 1) {\n            zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);\n        } else if (diff_algo == 2) {\n            zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);\n        } else if (diff_algo != 0) {\n            serverPanic(\"Unknown algorithm\");\n        }\n    }\n}\n\ndictType setAccumulatorDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* key destructor */\n    NULL,                      /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* The zunionInterDiffGenericCommand() function is called in order to implement the\n * following commands: ZUNION, ZINTER, ZDIFF, ZUNIONSTORE, ZINTERSTORE, ZDIFFSTORE,\n * ZINTERCARD.\n *\n * 'numkeysIndex' parameter position of key number. for ZUNION/ZINTER/ZDIFF command,\n * this value is 1, for ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE command, this value is 2.\n *\n * 'op' SET_OP_INTER, SET_OP_UNION or SET_OP_DIFF.\n *\n * 'cardinality_only' is currently only applicable when 'op' is SET_OP_INTER.\n * Work for SINTERCARD, only return the cardinality with minimum processing and memory overheads.\n */\nvoid zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op,\n                                   int cardinality_only) {\n    int i, j;\n    long setnum;\n    int aggregate = REDIS_AGGR_SUM;\n    zsetopsrc *src;\n    zsetopval zval;\n    sds tmp;\n    size_t maxelelen = 0, totelelen = 0;\n    robj *dstobj;\n    zset *dstzset;\n    zskiplistNode *znode;\n    int withscores = 0;\n    unsigned long cardinality = 0;\n    long limit = 0; /* Stop searching after reaching the limit. 0 means unlimited. */\n\n    /* expect setnum input keys to be given */\n    if ((getLongFromObjectOrReply(c, c->argv[numkeysIndex], &setnum, NULL) != C_OK))\n        return;\n\n    if (setnum < 1) {\n        addReplyErrorFormat(c,\n            \"at least 1 input key is needed for '%s' command\", c->cmd->fullname);\n        return;\n    }\n\n    /* test if the expected number of keys would overflow */\n    if (setnum > (c->argc-(numkeysIndex+1))) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* read keys to be used for input */\n    src = zcalloc(sizeof(zsetopsrc) * setnum);\n    for (i = 0, j = numkeysIndex+1; i < setnum; i++, j++) {\n        robj *obj = lookupKeyRead(c->db, c->argv[j]);\n        if (obj != NULL) {\n            if (obj->type != OBJ_ZSET && obj->type != OBJ_SET) {\n                zfree(src);\n                addReplyErrorObject(c,shared.wrongtypeerr);\n                return;\n            }\n\n            src[i].subject = obj;\n            src[i].type = obj->type;\n            src[i].encoding = obj->encoding;\n        } else {\n            src[i].subject = NULL;\n        }\n\n        /* Default all weights to 1. */\n        src[i].weight = 1.0;\n    }\n\n    /* parse optional extra arguments */\n    if (j < c->argc) {\n        int remaining = c->argc - j;\n\n        while (remaining) {\n            if (op != SET_OP_DIFF && !cardinality_only &&\n                remaining >= (setnum + 1) &&\n                !strcasecmp(c->argv[j]->ptr,\"weights\"))\n            {\n                j++; remaining--;\n                for (i = 0; i < setnum; i++, j++, remaining--) {\n                    if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,\n                            \"weight value is not a float\") != C_OK)\n                    {\n                        zfree(src);\n                        return;\n                    }\n                }\n            } else if (op != SET_OP_DIFF && !cardinality_only &&\n                       remaining >= 2 &&\n                       !strcasecmp(c->argv[j]->ptr,\"aggregate\"))\n            {\n                j++; remaining--;\n                if (!strcasecmp(c->argv[j]->ptr,\"sum\")) {\n                    aggregate = REDIS_AGGR_SUM;\n                } else if (!strcasecmp(c->argv[j]->ptr,\"min\")) {\n                    aggregate = REDIS_AGGR_MIN;\n                } else if (!strcasecmp(c->argv[j]->ptr,\"max\")) {\n                    aggregate = REDIS_AGGR_MAX;\n                } else {\n                    zfree(src);\n                    addReplyErrorObject(c,shared.syntaxerr);\n                    return;\n                }\n                j++; remaining--;\n            } else if (remaining >= 1 &&\n                       !dstkey && !cardinality_only &&\n                       !strcasecmp(c->argv[j]->ptr,\"withscores\"))\n            {\n                j++; remaining--;\n                withscores = 1;\n            } else if (cardinality_only && remaining >= 2 &&\n                       !strcasecmp(c->argv[j]->ptr, \"limit\"))\n            {\n                j++; remaining--;\n                if (getPositiveLongFromObjectOrReply(c, c->argv[j], &limit,\n                                                     \"LIMIT can't be negative\") != C_OK)\n                {\n                    zfree(src);\n                    return;\n                }\n                j++; remaining--;\n            } else {\n                zfree(src);\n                addReplyErrorObject(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    if (op != SET_OP_DIFF) {\n        /* sort sets from the smallest to largest, this will improve our\n        * algorithm's performance */\n        qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);\n    }\n\n    dstobj = createZsetObject();\n    dstzset = dstobj->ptr;\n    memset(&zval, 0, sizeof(zval));\n\n    if (op == SET_OP_INTER) {\n        /* Skip everything if the smallest input is empty. */\n        if (zuiLength(&src[0]) > 0) {\n            /* Precondition: as src[0] is non-empty and the inputs are ordered\n             * by size, all src[i > 0] are non-empty too. */\n            zuiInitIterator(&src[0]);\n            while (zuiNext(&src[0],&zval)) {\n                double score, value;\n\n                score = src[0].weight * zval.score;\n                if (isnan(score)) score = 0;\n\n                for (j = 1; j < setnum; j++) {\n                    /* It is not safe to access the zset we are\n                     * iterating, so explicitly check for equal object. */\n                    if (src[j].subject == src[0].subject) {\n                        value = zval.score*src[j].weight;\n                        zunionInterAggregate(&score,value,aggregate);\n                    } else if (zuiFind(&src[j],&zval,&value)) {\n                        value *= src[j].weight;\n                        zunionInterAggregate(&score,value,aggregate);\n                    } else {\n                        break;\n                    }\n                }\n\n                /* Only continue when present in every input. */\n                if (j == setnum && cardinality_only) {\n                    cardinality++;\n\n                    /* We stop the searching after reaching the limit. */\n                    if (limit && cardinality >= (unsigned long)limit) {\n                        /* Cleanup before we break the zuiNext loop. */\n                        zuiDiscardDirtyValue(&zval);\n                        break;\n                    }\n                } else if (j == setnum) {\n                    tmp = zuiNewSdsFromValue(&zval);\n                    znode = zslInsert(dstzset->zsl,score,tmp);\n                    dictAdd(dstzset->dict,tmp,&znode->score);\n                    totelelen += sdslen(tmp);\n                    if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);\n                }\n            }\n            zuiClearIterator(&src[0]);\n        }\n    } else if (op == SET_OP_UNION) {\n        dict *accumulator = dictCreate(&setAccumulatorDictType);\n        dictIterator *di;\n        dictEntry *de, *existing;\n        double score;\n\n        if (setnum) {\n            /* Our union is at least as large as the largest set.\n             * Resize the dictionary ASAP to avoid useless rehashing. */\n            dictExpand(accumulator,zuiLength(&src[setnum-1]));\n        }\n\n        /* Step 1: Create a dictionary of elements -> aggregated-scores\n         * by iterating one sorted set after the other. */\n        for (i = 0; i < setnum; i++) {\n            if (zuiLength(&src[i]) == 0) continue;\n\n            zuiInitIterator(&src[i]);\n            while (zuiNext(&src[i],&zval)) {\n                /* Initialize value */\n                score = src[i].weight * zval.score;\n                if (isnan(score)) score = 0;\n\n                /* Search for this element in the accumulating dictionary. */\n                de = dictAddRaw(accumulator,zuiSdsFromValue(&zval),&existing);\n                /* If we don't have it, we need to create a new entry. */\n                if (!existing) {\n                    tmp = zuiNewSdsFromValue(&zval);\n                    /* Remember the longest single element encountered,\n                     * to understand if it's possible to convert to listpack\n                     * at the end. */\n                     totelelen += sdslen(tmp);\n                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);\n                    /* Update the element with its initial score. */\n                    dictSetKey(accumulator, de, tmp);\n                    dictSetDoubleVal(de,score);\n                } else {\n                    /* Update the score with the score of the new instance\n                     * of the element found in the current sorted set.\n                     *\n                     * Here we access directly the dictEntry double\n                     * value inside the union as it is a big speedup\n                     * compared to using the getDouble/setDouble API. */\n                    zunionInterAggregate(&existing->v.d,score,aggregate);\n                }\n            }\n            zuiClearIterator(&src[i]);\n        }\n\n        /* Step 2: convert the dictionary into the final sorted set. */\n        di = dictGetIterator(accumulator);\n\n        /* We now are aware of the final size of the resulting sorted set,\n         * let's resize the dictionary embedded inside the sorted set to the\n         * right size, in order to save rehashing time. */\n        dictExpand(dstzset->dict,dictSize(accumulator));\n\n        while((de = dictNext(di)) != NULL) {\n            sds ele = dictGetKey(de);\n            score = dictGetDoubleVal(de);\n            znode = zslInsert(dstzset->zsl,score,ele);\n            dictAdd(dstzset->dict,ele,&znode->score);\n        }\n        dictReleaseIterator(di);\n        dictRelease(accumulator);\n    } else if (op == SET_OP_DIFF) {\n        zdiff(src, setnum, dstzset, &maxelelen, &totelelen);\n    } else {\n        serverPanic(\"Unknown operator\");\n    }\n\n    if (dstkey) {\n        if (dstzset->zsl->length) {\n            zsetConvertToListpackIfNeeded(dstobj, maxelelen, totelelen);\n            setKey(c, c->db, dstkey, dstobj, 0);\n            addReplyLongLong(c, zsetLength(dstobj));\n            notifyKeyspaceEvent(NOTIFY_ZSET,\n                                (op == SET_OP_UNION) ? \"zunionstore\" :\n                                    (op == SET_OP_INTER ? \"zinterstore\" : \"zdiffstore\"),\n                                dstkey, c->db->id);\n            server.dirty++;\n        } else {\n            addReply(c, shared.czero);\n            if (dbDelete(c->db, dstkey)) {\n                signalModifiedKey(c, c->db, dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", dstkey, c->db->id);\n                server.dirty++;\n            }\n        }\n    } else if (cardinality_only) {\n        addReplyLongLong(c, cardinality);\n    } else {\n        unsigned long length = dstzset->zsl->length;\n        zskiplist *zsl = dstzset->zsl;\n        zskiplistNode *zn = zsl->header->level[0].forward;\n        /* In case of WITHSCORES, respond with a single array in RESP2, and\n         * nested arrays in RESP3. We can't use a map response type since the\n         * client library needs to know to respect the order. */\n        if (withscores && c->resp == 2)\n            addReplyArrayLen(c, length*2);\n        else\n            addReplyArrayLen(c, length);\n\n        while (zn != NULL) {\n            if (withscores && c->resp > 2) addReplyArrayLen(c,2);\n            addReplyBulkCBuffer(c,zn->ele,sdslen(zn->ele));\n            if (withscores) addReplyDouble(c,zn->score);\n            zn = zn->level[0].forward;\n        }\n    }\n    decrRefCount(dstobj);\n    zfree(src);\n}\n\n/* ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] */\nvoid zunionstoreCommand(client *c) {\n    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_UNION, 0);\n}\n\n/* ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] */\nvoid zinterstoreCommand(client *c) {\n    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_INTER, 0);\n}\n\n/* ZDIFFSTORE destination numkeys key [key ...] */\nvoid zdiffstoreCommand(client *c) {\n    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_DIFF, 0);\n}\n\n/* ZUNION numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] */\nvoid zunionCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_UNION, 0);\n}\n\n/* ZINTER numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] */\nvoid zinterCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 0);\n}\n\n/* ZINTERCARD numkeys key [key ...] [LIMIT limit] */\nvoid zinterCardCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 1);\n}\n\n/* ZDIFF numkeys key [key ...] [WITHSCORES] */\nvoid zdiffCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_DIFF, 0);\n}\n\ntypedef enum {\n    ZRANGE_DIRECTION_AUTO = 0,\n    ZRANGE_DIRECTION_FORWARD,\n    ZRANGE_DIRECTION_REVERSE\n} zrange_direction;\n\ntypedef enum {\n    ZRANGE_CONSUMER_TYPE_CLIENT = 0,\n    ZRANGE_CONSUMER_TYPE_INTERNAL\n} zrange_consumer_type;\n\ntypedef struct zrange_result_handler zrange_result_handler;\n\ntypedef void (*zrangeResultBeginFunction)(zrange_result_handler *c, long length);\ntypedef void (*zrangeResultFinalizeFunction)(\n    zrange_result_handler *c, size_t result_count);\ntypedef void (*zrangeResultEmitCBufferFunction)(\n    zrange_result_handler *c, const void *p, size_t len, double score);\ntypedef void (*zrangeResultEmitLongLongFunction)(\n    zrange_result_handler *c, long long ll, double score);\n\nvoid zrangeGenericCommand (zrange_result_handler *handler, int argc_start, int store,\n                           zrange_type rangetype, zrange_direction direction);\n\n/* Interface struct for ZRANGE/ZRANGESTORE generic implementation.\n * There is one implementation of this interface that sends a RESP reply to clients.\n * and one implementation that stores the range result into a zset object. */\nstruct zrange_result_handler {\n    zrange_consumer_type                 type;\n    client                              *client;\n    robj                                *dstkey;\n    robj                                *dstobj;\n    void                                *userdata;\n    int                                  withscores;\n    int                                  should_emit_array_length;\n    zrangeResultBeginFunction            beginResultEmission;\n    zrangeResultFinalizeFunction         finalizeResultEmission;\n    zrangeResultEmitCBufferFunction      emitResultFromCBuffer;\n    zrangeResultEmitLongLongFunction     emitResultFromLongLong;\n};\n\n/* Result handler methods for responding the ZRANGE to clients.\n * length can be used to provide the result length in advance (avoids deferred reply overhead).\n * length can be set to -1 if the result length is not know in advance.\n */\nstatic void zrangeResultBeginClient(zrange_result_handler *handler, long length) {\n    if (length > 0) {\n        /* In case of WITHSCORES, respond with a single array in RESP2, and\n        * nested arrays in RESP3. We can't use a map response type since the\n        * client library needs to know to respect the order. */\n        if (handler->withscores && (handler->client->resp == 2)) {\n            length *= 2;\n        }\n        addReplyArrayLen(handler->client, length);\n        handler->userdata = NULL;\n        return;\n    }\n    handler->userdata = addReplyDeferredLen(handler->client);\n}\n\nstatic void zrangeResultEmitCBufferToClient(zrange_result_handler *handler,\n    const void *value, size_t value_length_in_bytes, double score)\n{\n    if (handler->should_emit_array_length) {\n        addReplyArrayLen(handler->client, 2);\n    }\n\n    addReplyBulkCBuffer(handler->client, value, value_length_in_bytes);\n\n    if (handler->withscores) {\n        addReplyDouble(handler->client, score);\n    }\n}\n\nstatic void zrangeResultEmitLongLongToClient(zrange_result_handler *handler,\n    long long value, double score)\n{\n    if (handler->should_emit_array_length) {\n        addReplyArrayLen(handler->client, 2);\n    }\n\n    addReplyBulkLongLong(handler->client, value);\n\n    if (handler->withscores) {\n        addReplyDouble(handler->client, score);\n    }\n}\n\nstatic void zrangeResultFinalizeClient(zrange_result_handler *handler,\n    size_t result_count)\n{\n    /* If the reply size was know at start there's nothing left to do */\n    if (!handler->userdata)\n        return;\n    /* In case of WITHSCORES, respond with a single array in RESP2, and\n     * nested arrays in RESP3. We can't use a map response type since the\n     * client library needs to know to respect the order. */\n    if (handler->withscores && (handler->client->resp == 2)) {\n        result_count *= 2;\n    }\n\n    setDeferredArrayLen(handler->client, handler->userdata, result_count);\n}\n\n/* Result handler methods for storing the ZRANGESTORE to a zset. */\nstatic void zrangeResultBeginStore(zrange_result_handler *handler, long length)\n{\n    if (length > (long)server.zset_max_listpack_entries)\n        handler->dstobj = createZsetObject();\n    else\n        handler->dstobj = createZsetListpackObject();\n}\n\nstatic void zrangeResultEmitCBufferForStore(zrange_result_handler *handler,\n    const void *value, size_t value_length_in_bytes, double score)\n{\n    double newscore;\n    int retflags = 0;\n    sds ele = sdsnewlen(value, value_length_in_bytes);\n    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);\n    sdsfree(ele);\n    serverAssert(retval);\n}\n\nstatic void zrangeResultEmitLongLongForStore(zrange_result_handler *handler,\n    long long value, double score)\n{\n    double newscore;\n    int retflags = 0;\n    sds ele = sdsfromlonglong(value);\n    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);\n    sdsfree(ele);\n    serverAssert(retval);\n}\n\nstatic void zrangeResultFinalizeStore(zrange_result_handler *handler, size_t result_count)\n{\n    if (result_count) {\n        setKey(handler->client, handler->client->db, handler->dstkey, handler->dstobj, 0);\n        addReplyLongLong(handler->client, result_count);\n        notifyKeyspaceEvent(NOTIFY_ZSET, \"zrangestore\", handler->dstkey, handler->client->db->id);\n        server.dirty++;\n    } else {\n        addReply(handler->client, shared.czero);\n        if (dbDelete(handler->client->db, handler->dstkey)) {\n            signalModifiedKey(handler->client, handler->client->db, handler->dstkey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", handler->dstkey, handler->client->db->id);\n            server.dirty++;\n        }\n    }\n    decrRefCount(handler->dstobj);\n}\n\n/* Initialize the consumer interface type with the requested type. */\nstatic void zrangeResultHandlerInit(zrange_result_handler *handler,\n    client *client, zrange_consumer_type type)\n{\n    memset(handler, 0, sizeof(*handler));\n\n    handler->client = client;\n\n    switch (type) {\n    case ZRANGE_CONSUMER_TYPE_CLIENT:\n        handler->beginResultEmission = zrangeResultBeginClient;\n        handler->finalizeResultEmission = zrangeResultFinalizeClient;\n        handler->emitResultFromCBuffer = zrangeResultEmitCBufferToClient;\n        handler->emitResultFromLongLong = zrangeResultEmitLongLongToClient;\n        break;\n\n    case ZRANGE_CONSUMER_TYPE_INTERNAL:\n        handler->beginResultEmission = zrangeResultBeginStore;\n        handler->finalizeResultEmission = zrangeResultFinalizeStore;\n        handler->emitResultFromCBuffer = zrangeResultEmitCBufferForStore;\n        handler->emitResultFromLongLong = zrangeResultEmitLongLongForStore;\n        break;\n    }\n}\n\nstatic void zrangeResultHandlerScoreEmissionEnable(zrange_result_handler *handler) {\n    handler->withscores = 1;\n    handler->should_emit_array_length = (handler->client->resp > 2);\n}\n\nstatic void zrangeResultHandlerDestinationKeySet (zrange_result_handler *handler,\n    robj *dstkey)\n{\n    handler->dstkey = dstkey;\n}\n\n/* This command implements ZRANGE, ZREVRANGE. */\nvoid genericZrangebyrankCommand(zrange_result_handler *handler,\n    robj *zobj, long start, long end, int withscores, int reverse) {\n\n    client *c = handler->client;\n    long llen;\n    long rangelen;\n    size_t result_cardinality;\n\n    /* Sanitize indexes. */\n    llen = zsetLength(zobj);\n    if (start < 0) start = llen+start;\n    if (end < 0) end = llen+end;\n    if (start < 0) start = 0;\n\n\n    /* Invariant: start >= 0, so this test will be true when end < 0.\n     * The range is empty when start > end or start >= length. */\n    if (start > end || start >= llen) {\n        handler->beginResultEmission(handler, 0);\n        handler->finalizeResultEmission(handler, 0);\n        return;\n    }\n    if (end >= llen) end = llen-1;\n    rangelen = (end-start)+1;\n    result_cardinality = rangelen;\n\n    handler->beginResultEmission(handler, rangelen);\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n        double score = 0.0;\n\n        if (reverse)\n            eptr = lpSeek(zl,-2-(2*start));\n        else\n            eptr = lpSeek(zl,2*start);\n\n        serverAssertWithInfo(c,zobj,eptr != NULL);\n        sptr = lpNext(zl,eptr);\n\n        while (rangelen--) {\n            serverAssertWithInfo(c,zobj,eptr != NULL && sptr != NULL);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n\n            if (withscores) /* don't bother to extract the score if it's gonna be ignored. */\n                score = zzlGetScore(sptr);\n\n            if (vstr == NULL) {\n                handler->emitResultFromLongLong(handler, vlong, score);\n            } else {\n                handler->emitResultFromCBuffer(handler, vstr, vlen, score);\n            }\n\n            if (reverse)\n                zzlPrev(zl,&eptr,&sptr);\n            else\n                zzlNext(zl,&eptr,&sptr);\n        }\n\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (reverse) {\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,llen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,zobj,ln != NULL);\n            sds ele = ln->ele;\n            handler->emitResultFromCBuffer(handler, ele, sdslen(ele), ln->score);\n            ln = reverse ? ln->backward : ln->level[0].forward;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    handler->finalizeResultEmission(handler, result_cardinality);\n}\n\n/* ZRANGESTORE <dst> <src> <min> <max> [BYSCORE | BYLEX] [REV] [LIMIT offset count] */\nvoid zrangestoreCommand (client *c) {\n    robj *dstkey = c->argv[1];\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_INTERNAL);\n    zrangeResultHandlerDestinationKeySet(&handler, dstkey);\n    zrangeGenericCommand(&handler, 2, 1, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);\n}\n\n/* ZRANGE <key> <min> <max> [BYSCORE | BYLEX] [REV] [WITHSCORES] [LIMIT offset count] */\nvoid zrangeCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);\n}\n\n/* ZREVRANGE <key> <start> <stop> [WITHSCORES] */\nvoid zrevrangeCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_RANK, ZRANGE_DIRECTION_REVERSE);\n}\n\n/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */\nvoid genericZrangebyscoreCommand(zrange_result_handler *handler,\n    zrangespec *range, robj *zobj, long offset, long limit, \n    int reverse) {\n    unsigned long rangelen = 0;\n\n    handler->beginResultEmission(handler, -1);\n\n    /* For invalid offset, return directly. */\n    if (offset > 0 && offset >= (long)zsetLength(zobj)) {\n        handler->finalizeResultEmission(handler, 0);\n        return;\n    }\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            eptr = zzlLastInRange(zl,range);\n        } else {\n            eptr = zzlFirstInRange(zl,range);\n        }\n\n        /* Get score pointer for the first element. */\n        if (eptr)\n            sptr = lpNext(zl,eptr);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (eptr && offset--) {\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n\n        while (eptr && limit--) {\n            double score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslValueGteMin(score,range)) break;\n            } else {\n                if (!zslValueLteMax(score,range)) break;\n            }\n\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            rangelen++;\n            if (vstr == NULL) {\n                handler->emitResultFromLongLong(handler, vlong, score);\n            } else {\n                handler->emitResultFromCBuffer(handler, vstr, vlen, score);\n            }\n\n            /* Move to next node */\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            ln = zslLastInRange(zsl,range);\n        } else {\n            ln = zslFirstInRange(zsl,range);\n        }\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (ln && offset--) {\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n\n        while (ln && limit--) {\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslValueGteMin(ln->score,range)) break;\n            } else {\n                if (!zslValueLteMax(ln->score,range)) break;\n            }\n\n            rangelen++;\n            handler->emitResultFromCBuffer(handler, ln->ele, sdslen(ln->ele), ln->score);\n\n            /* Move to next node */\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    handler->finalizeResultEmission(handler, rangelen);\n}\n\n/* ZRANGEBYSCORE <key> <min> <max> [WITHSCORES] [LIMIT offset count] */\nvoid zrangebyscoreCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_FORWARD);\n}\n\n/* ZREVRANGEBYSCORE <key> <max> <min> [WITHSCORES] [LIMIT offset count] */\nvoid zrevrangebyscoreCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_REVERSE);\n}\n\nvoid zcountCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    zrangespec range;\n    unsigned long count = 0;\n\n    /* Parse the range arguments */\n    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {\n        addReplyError(c,\"min or max is not a float\");\n        return;\n    }\n\n    /* Lookup the sorted set */\n    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||\n        checkType(c, zobj, OBJ_ZSET)) return;\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        double score;\n\n        /* Use the first element in range as the starting point */\n        eptr = zzlFirstInRange(zl,&range);\n\n        /* No \"first\" element */\n        if (eptr == NULL) {\n            addReply(c, shared.czero);\n            return;\n        }\n\n        /* First element is in range */\n        sptr = lpNext(zl,eptr);\n        score = zzlGetScore(sptr);\n        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));\n\n        /* Iterate over elements in range */\n        while (eptr) {\n            score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (!zslValueLteMax(score,&range)) {\n                break;\n            } else {\n                count++;\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *zn;\n        unsigned long rank;\n\n        /* Find first element in range */\n        zn = zslFirstInRange(zsl, &range);\n\n        /* Use rank of first element, if any, to determine preliminary count */\n        if (zn != NULL) {\n            rank = zslGetRank(zsl, zn->score, zn->ele);\n            count = (zsl->length - (rank - 1));\n\n            /* Find last element in range */\n            zn = zslLastInRange(zsl, &range);\n\n            /* Use rank of last element, if any, to determine the actual count */\n            if (zn != NULL) {\n                rank = zslGetRank(zsl, zn->score, zn->ele);\n                count -= (zsl->length - rank);\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    addReplyLongLong(c, count);\n}\n\nvoid zlexcountCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    zlexrangespec range;\n    unsigned long count = 0;\n\n    /* Parse the range arguments */\n    if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {\n        addReplyError(c,\"min or max not valid string range item\");\n        return;\n    }\n\n    /* Lookup the sorted set */\n    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||\n        checkType(c, zobj, OBJ_ZSET))\n    {\n        zslFreeLexRange(&range);\n        return;\n    }\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n\n        /* Use the first element in range as the starting point */\n        eptr = zzlFirstInLexRange(zl,&range);\n\n        /* No \"first\" element */\n        if (eptr == NULL) {\n            zslFreeLexRange(&range);\n            addReply(c, shared.czero);\n            return;\n        }\n\n        /* First element is in range */\n        sptr = lpNext(zl,eptr);\n        serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&range));\n\n        /* Iterate over elements in range */\n        while (eptr) {\n            /* Abort when the node is no longer in range. */\n            if (!zzlLexValueLteMax(eptr,&range)) {\n                break;\n            } else {\n                count++;\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *zn;\n        unsigned long rank;\n\n        /* Find first element in range */\n        zn = zslFirstInLexRange(zsl, &range);\n\n        /* Use rank of first element, if any, to determine preliminary count */\n        if (zn != NULL) {\n            rank = zslGetRank(zsl, zn->score, zn->ele);\n            count = (zsl->length - (rank - 1));\n\n            /* Find last element in range */\n            zn = zslLastInLexRange(zsl, &range);\n\n            /* Use rank of last element, if any, to determine the actual count */\n            if (zn != NULL) {\n                rank = zslGetRank(zsl, zn->score, zn->ele);\n                count -= (zsl->length - rank);\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    zslFreeLexRange(&range);\n    addReplyLongLong(c, count);\n}\n\n/* This command implements ZRANGEBYLEX, ZREVRANGEBYLEX. */\nvoid genericZrangebylexCommand(zrange_result_handler *handler,\n    zlexrangespec *range, robj *zobj, int withscores, long offset, long limit,\n    int reverse)\n{\n    unsigned long rangelen = 0;\n\n    handler->beginResultEmission(handler, -1);\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            eptr = zzlLastInLexRange(zl,range);\n        } else {\n            eptr = zzlFirstInLexRange(zl,range);\n        }\n\n        /* Get score pointer for the first element. */\n        if (eptr)\n            sptr = lpNext(zl,eptr);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (eptr && offset--) {\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n\n        while (eptr && limit--) {\n            double score = 0;\n            if (withscores) /* don't bother to extract the score if it's gonna be ignored. */\n                score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zzlLexValueGteMin(eptr,range)) break;\n            } else {\n                if (!zzlLexValueLteMax(eptr,range)) break;\n            }\n\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            rangelen++;\n            if (vstr == NULL) {\n                handler->emitResultFromLongLong(handler, vlong, score);\n            } else {\n                handler->emitResultFromCBuffer(handler, vstr, vlen, score);\n            }\n\n            /* Move to next node */\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            ln = zslLastInLexRange(zsl,range);\n        } else {\n            ln = zslFirstInLexRange(zsl,range);\n        }\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (ln && offset--) {\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n\n        while (ln && limit--) {\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslLexValueGteMin(ln->ele,range)) break;\n            } else {\n                if (!zslLexValueLteMax(ln->ele,range)) break;\n            }\n\n            rangelen++;\n            handler->emitResultFromCBuffer(handler, ln->ele, sdslen(ln->ele), ln->score);\n\n            /* Move to next node */\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    handler->finalizeResultEmission(handler, rangelen);\n}\n\n/* ZRANGEBYLEX <key> <min> <max> [LIMIT offset count] */\nvoid zrangebylexCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_FORWARD);\n}\n\n/* ZREVRANGEBYLEX <key> <max> <min> [LIMIT offset count] */\nvoid zrevrangebylexCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_REVERSE);\n}\n\n/**\n * This function handles ZRANGE and ZRANGESTORE, and also the deprecated\n * Z[REV]RANGE[BYPOS|BYLEX] commands.\n *\n * The simple ZRANGE and ZRANGESTORE can take _AUTO in rangetype and direction,\n * other command pass explicit value.\n *\n * The argc_start points to the src key argument, so following syntax is like:\n * <src> <min> <max> [BYSCORE | BYLEX] [REV] [WITHSCORES] [LIMIT offset count]\n */\nvoid zrangeGenericCommand(zrange_result_handler *handler, int argc_start, int store,\n                          zrange_type rangetype, zrange_direction direction)\n{\n    client *c = handler->client;\n    robj *key = c->argv[argc_start];\n    robj *zobj;\n    zrangespec range;\n    zlexrangespec lexrange;\n    int minidx = argc_start + 1;\n    int maxidx = argc_start + 2;\n\n    /* Options common to all */\n    long opt_start = 0;\n    long opt_end = 0;\n    int opt_withscores = 0;\n    long opt_offset = 0;\n    long opt_limit = -1;\n\n    /* Step 1: Skip the <src> <min> <max> args and parse remaining optional arguments. */\n    for (int j=argc_start + 3; j < c->argc; j++) {\n        int leftargs = c->argc-j-1;\n        if (!store && !strcasecmp(c->argv[j]->ptr,\"withscores\")) {\n            opt_withscores = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"limit\") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &opt_offset, NULL) != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &opt_limit, NULL) != C_OK))\n            {\n                return;\n            }\n            j += 2;\n        } else if (direction == ZRANGE_DIRECTION_AUTO &&\n                   !strcasecmp(c->argv[j]->ptr,\"rev\"))\n        {\n            direction = ZRANGE_DIRECTION_REVERSE;\n        } else if (rangetype == ZRANGE_AUTO &&\n                   !strcasecmp(c->argv[j]->ptr,\"bylex\"))\n        {\n            rangetype = ZRANGE_LEX;\n        } else if (rangetype == ZRANGE_AUTO &&\n                   !strcasecmp(c->argv[j]->ptr,\"byscore\"))\n        {\n            rangetype = ZRANGE_SCORE;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* Use defaults if not overridden by arguments. */\n    if (direction == ZRANGE_DIRECTION_AUTO)\n        direction = ZRANGE_DIRECTION_FORWARD;\n    if (rangetype == ZRANGE_AUTO)\n        rangetype = ZRANGE_RANK;\n\n    /* Check for conflicting arguments. */\n    if (opt_limit != -1 && rangetype == ZRANGE_RANK) {\n        addReplyError(c,\"syntax error, LIMIT is only supported in combination with either BYSCORE or BYLEX\");\n        return;\n    }\n    if (opt_withscores && rangetype == ZRANGE_LEX) {\n        addReplyError(c,\"syntax error, WITHSCORES not supported in combination with BYLEX\");\n        return;\n    }\n\n    if (direction == ZRANGE_DIRECTION_REVERSE &&\n        ((ZRANGE_SCORE == rangetype) || (ZRANGE_LEX == rangetype)))\n    {\n        /* Range is given as [max,min] */\n        int tmp = maxidx;\n        maxidx = minidx;\n        minidx = tmp;\n    }\n\n    /* Step 2: Parse the range. */\n    switch (rangetype) {\n    case ZRANGE_AUTO:\n    case ZRANGE_RANK:\n        /* Z[REV]RANGE, ZRANGESTORE [REV]RANGE */\n        if ((getLongFromObjectOrReply(c, c->argv[minidx], &opt_start,NULL) != C_OK) ||\n            (getLongFromObjectOrReply(c, c->argv[maxidx], &opt_end,NULL) != C_OK))\n        {\n            return;\n        }\n        break;\n\n    case ZRANGE_SCORE:\n        /* Z[REV]RANGEBYSCORE, ZRANGESTORE [REV]RANGEBYSCORE */\n        if (zslParseRange(c->argv[minidx], c->argv[maxidx], &range) != C_OK) {\n            addReplyError(c, \"min or max is not a float\");\n            return;\n        }\n        break;\n\n    case ZRANGE_LEX:\n        /* Z[REV]RANGEBYLEX, ZRANGESTORE [REV]RANGEBYLEX */\n        if (zslParseLexRange(c->argv[minidx], c->argv[maxidx], &lexrange) != C_OK) {\n            addReplyError(c, \"min or max not valid string range item\");\n            return;\n        }\n        break;\n    }\n\n    if (opt_withscores || store) {\n        zrangeResultHandlerScoreEmissionEnable(handler);\n    }\n\n    /* Step 3: Lookup the key and get the range. */\n    zobj = lookupKeyRead(c->db, key);\n    if (zobj == NULL) {\n        if (store) {\n            handler->beginResultEmission(handler, -1);\n            handler->finalizeResultEmission(handler, 0);\n        } else {\n            addReply(c, shared.emptyarray);\n        }\n        goto cleanup;\n    }\n\n    if (checkType(c,zobj,OBJ_ZSET)) goto cleanup;\n\n    /* Step 4: Pass this to the command-specific handler. */\n    switch (rangetype) {\n    case ZRANGE_AUTO:\n    case ZRANGE_RANK:\n        genericZrangebyrankCommand(handler, zobj, opt_start, opt_end,\n            opt_withscores || store, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n\n    case ZRANGE_SCORE:\n        genericZrangebyscoreCommand(handler, &range, zobj, opt_offset,\n            opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n\n    case ZRANGE_LEX:\n        genericZrangebylexCommand(handler, &lexrange, zobj, opt_withscores || store,\n            opt_offset, opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n    }\n\n    /* Instead of returning here, we'll just fall-through the clean-up. */\n\ncleanup:\n\n    if (rangetype == ZRANGE_LEX) {\n        zslFreeLexRange(&lexrange);\n    }\n}\n\nvoid zcardCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    addReplyLongLong(c,zsetLength(zobj));\n}\n\nvoid zscoreCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    double score;\n\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.null[c->resp])) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {\n        addReplyNull(c);\n    } else {\n        addReplyDouble(c,score);\n    }\n}\n\nvoid zmscoreCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    double score;\n    zobj = lookupKeyRead(c->db,key);\n    if (checkType(c,zobj,OBJ_ZSET)) return;\n\n    addReplyArrayLen(c,c->argc - 2);\n    for (int j = 2; j < c->argc; j++) {\n        /* Treat a missing set the same way as an empty set */\n        if (zobj == NULL || zsetScore(zobj,c->argv[j]->ptr,&score) == C_ERR) {\n            addReplyNull(c);\n        } else {\n            addReplyDouble(c,score);\n        }\n    }\n}\n\nvoid zrankGenericCommand(client *c, int reverse) {\n    robj *key = c->argv[1];\n    robj *ele = c->argv[2];\n    robj *zobj;\n    long rank;\n\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.null[c->resp])) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));\n    rank = zsetRank(zobj,ele->ptr,reverse);\n    if (rank >= 0) {\n        addReplyLongLong(c,rank);\n    } else {\n        addReplyNull(c);\n    }\n}\n\nvoid zrankCommand(client *c) {\n    zrankGenericCommand(c, 0);\n}\n\nvoid zrevrankCommand(client *c) {\n    zrankGenericCommand(c, 1);\n}\n\nvoid zscanCommand(client *c) {\n    robj *o;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,o,OBJ_ZSET)) return;\n    scanGenericCommand(c,o,cursor);\n}\n\n/* This command implements the generic zpop operation, used by:\n * ZPOPMIN, ZPOPMAX, BZPOPMIN, BZPOPMAX and ZMPOP. This function is also used\n * inside blocked.c in the unblocking stage of BZPOPMIN, BZPOPMAX and BZMPOP.\n *\n * If 'emitkey' is true also the key name is emitted, useful for the blocking\n * behavior of BZPOP[MIN|MAX], since we can block into multiple keys.\n * Or in ZMPOP/BZMPOP, because we also can take multiple keys.\n *\n * 'count' is the number of elements requested to pop, or -1 for plain single pop.\n *\n * 'use_nested_array' when false it generates a flat array (with or without key name).\n * When true, it generates a nested 2 level array of field + score pairs, or 3 level when emitkey is set.\n *\n * 'reply_nil_when_empty' when true we reply a NIL if we are not able to pop up any elements.\n * Like in ZMPOP/BZMPOP we reply with a structured nested array containing key name\n * and member + score pairs. In these commands, we reply with null when we have no result.\n * Otherwise in ZPOPMIN/ZPOPMAX we reply an empty array by default.\n *\n * 'deleted' is an optional output argument to get an indication\n * if the key got deleted by this function.\n * */\nvoid genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey,\n                        long count, int use_nested_array, int reply_nil_when_empty, int *deleted) {\n    int idx;\n    robj *key = NULL;\n    robj *zobj = NULL;\n    sds ele;\n    double score;\n\n    if (deleted) *deleted = 0;\n\n    /* Check type and break on the first error, otherwise identify candidate. */\n    idx = 0;\n    while (idx < keyc) {\n        key = keyv[idx++];\n        zobj = lookupKeyWrite(c->db,key);\n        if (!zobj) continue;\n        if (checkType(c,zobj,OBJ_ZSET)) return;\n        break;\n    }\n\n    /* No candidate for zpopping, return empty. */\n    if (!zobj) {\n        if (reply_nil_when_empty) {\n            addReplyNullArray(c);\n        } else {\n            addReply(c,shared.emptyarray);\n        }\n        return;\n    }\n\n    if (count == 0) {\n        /* ZPOPMIN/ZPOPMAX with count 0. */\n        addReply(c, shared.emptyarray);\n        return;\n    }\n\n    long result_count = 0;\n\n    /* When count is -1, we need to correct it to 1 for plain single pop. */\n    if (count == -1) count = 1;\n\n    long llen = zsetLength(zobj);\n    long rangelen = (count > llen) ? llen : count;\n\n    if (!use_nested_array && !emitkey) {\n        /* ZPOPMIN/ZPOPMAX with or without COUNT option in RESP2. */\n        addReplyArrayLen(c, rangelen * 2);\n    } else if (use_nested_array && !emitkey) {\n        /* ZPOPMIN/ZPOPMAX with COUNT option in RESP3. */\n        addReplyArrayLen(c, rangelen);\n    } else if (!use_nested_array && emitkey) {\n        /* BZPOPMIN/BZPOPMAX in RESP2 and RESP3. */\n        addReplyArrayLen(c, rangelen * 2 + 1);\n        addReplyBulk(c, key);\n    } else if (use_nested_array && emitkey) {\n        /* ZMPOP/BZMPOP in RESP2 and RESP3. */\n        addReplyArrayLen(c, 2);\n        addReplyBulk(c, key);\n        addReplyArrayLen(c, rangelen);\n    }\n\n    /* Remove the element. */\n    do {\n        if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n            unsigned char *zl = zobj->ptr;\n            unsigned char *eptr, *sptr;\n            unsigned char *vstr;\n            unsigned int vlen;\n            long long vlong;\n\n            /* Get the first or last element in the sorted set. */\n            eptr = lpSeek(zl,where == ZSET_MAX ? -2 : 0);\n            serverAssertWithInfo(c,zobj,eptr != NULL);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            if (vstr == NULL)\n                ele = sdsfromlonglong(vlong);\n            else\n                ele = sdsnewlen(vstr,vlen);\n\n            /* Get the score. */\n            sptr = lpNext(zl,eptr);\n            serverAssertWithInfo(c,zobj,sptr != NULL);\n            score = zzlGetScore(sptr);\n        } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = zobj->ptr;\n            zskiplist *zsl = zs->zsl;\n            zskiplistNode *zln;\n\n            /* Get the first or last element in the sorted set. */\n            zln = (where == ZSET_MAX ? zsl->tail :\n                                       zsl->header->level[0].forward);\n\n            /* There must be an element in the sorted set. */\n            serverAssertWithInfo(c,zobj,zln != NULL);\n            ele = sdsdup(zln->ele);\n            score = zln->score;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n\n        serverAssertWithInfo(c,zobj,zsetDel(zobj,ele));\n        server.dirty++;\n\n        if (result_count == 0) { /* Do this only for the first iteration. */\n            char *events[2] = {\"zpopmin\",\"zpopmax\"};\n            notifyKeyspaceEvent(NOTIFY_ZSET,events[where],key,c->db->id);\n            signalModifiedKey(c,c->db,key);\n        }\n\n        if (use_nested_array) {\n            addReplyArrayLen(c,2);\n        }\n        addReplyBulkCBuffer(c,ele,sdslen(ele));\n        addReplyDouble(c,score);\n        sdsfree(ele);\n        ++result_count;\n    } while(--rangelen);\n\n    /* Remove the key, if indeed needed. */\n    if (zsetLength(zobj) == 0) {\n        if (deleted) *deleted = 1;\n\n        dbDelete(c->db,key);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n    }\n\n    if (c->cmd->proc == zmpopCommand) {\n        /* Always replicate it as ZPOP[MIN|MAX] with COUNT option instead of ZMPOP. */\n        robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);\n        rewriteClientCommandVector(c, 3,\n                                   (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,\n                                   key, count_obj);\n        decrRefCount(count_obj);\n    }\n}\n\n/* ZPOPMIN/ZPOPMAX key [<count>] */\nvoid zpopMinMaxCommand(client *c, int where) {\n    if (c->argc > 3) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    long count = -1; /* -1 for plain single pop. */\n    if (c->argc == 3 && getPositiveLongFromObjectOrReply(c, c->argv[2], &count, NULL) != C_OK)\n        return;\n\n    /* Respond with a single (flat) array in RESP2 or if count is -1\n     * (returning a single element). In RESP3, when count > 0 use nested array. */\n    int use_nested_array = (c->resp > 2 && count != -1);\n\n    genericZpopCommand(c, &c->argv[1], 1, where, 0, count, use_nested_array, 0, NULL);\n}\n\n/* ZPOPMIN key [<count>] */\nvoid zpopminCommand(client *c) {\n    zpopMinMaxCommand(c, ZSET_MIN);\n}\n\n/* ZPOPMAX key [<count>] */\nvoid zpopmaxCommand(client *c) {\n    zpopMinMaxCommand(c, ZSET_MAX);\n}\n\n/* BZPOPMIN, BZPOPMAX, BZMPOP actual implementation.\n *\n * 'numkeys' is the number of keys.\n *\n * 'timeout_idx' parameter position of block timeout.\n *\n * 'where' ZSET_MIN or ZSET_MAX.\n *\n * 'count' is the number of elements requested to pop, or -1 for plain single pop.\n *\n * 'use_nested_array' when false it generates a flat array (with or without key name).\n * When true, it generates a nested 3 level array of keyname, field + score pairs.\n * */\nvoid blockingGenericZpopCommand(client *c, robj **keys, int numkeys, int where,\n                                int timeout_idx, long count, int use_nested_array, int reply_nil_when_empty) {\n    robj *o;\n    robj *key;\n    mstime_t timeout;\n    int j;\n\n    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)\n        != C_OK) return;\n\n    for (j = 0; j < numkeys; j++) {\n        key = keys[j];\n        o = lookupKeyWrite(c->db,key);\n        /* Non-existing key, move to next key. */\n        if (o == NULL) continue;\n\n        if (checkType(c,o,OBJ_ZSET)) return;\n\n        long llen = zsetLength(o);\n        /* Empty zset, move to next key. */\n        if (llen == 0) continue;\n\n        /* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */\n        genericZpopCommand(c, &key, 1, where, 1, count, use_nested_array, reply_nil_when_empty, NULL);\n\n        if (count == -1) {\n            /* Replicate it as ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */\n            rewriteClientCommandVector(c,2,\n                                       (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,\n                                       key);\n        } else {\n            /* Replicate it as ZPOP[MIN|MAX] with COUNT option. */\n            robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);\n            rewriteClientCommandVector(c, 3,\n                                       (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,\n                                       key, count_obj);\n            decrRefCount(count_obj);\n        }\n\n        return;\n    }\n\n    /* If we are not allowed to block the client and the zset is empty the only thing\n     * we can do is treating it as a timeout (even with timeout 0). */\n    if (c->flags & CLIENT_DENY_BLOCKING) {\n        addReplyNullArray(c);\n        return;\n    }\n\n    /* If the keys do not exist we must block */\n    struct blockPos pos = {where};\n    blockForKeys(c,BLOCKED_ZSET,keys,numkeys,count,timeout,NULL,&pos,NULL);\n}\n\n// BZPOPMIN key [key ...] timeout\nvoid bzpopminCommand(client *c) {\n    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MIN, c->argc-1, -1, 0, 0);\n}\n\n// BZPOPMAX key [key ...] timeout\nvoid bzpopmaxCommand(client *c) {\n    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MAX, c->argc-1, -1, 0, 0);\n}\n\nstatic void zrandmemberReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {\n    for (unsigned long i = 0; i < count; i++) {\n        if (vals && c->resp > 2)\n            addReplyArrayLen(c,2);\n        if (keys[i].sval)\n            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);\n        else\n            addReplyBulkLongLong(c, keys[i].lval);\n        if (vals) {\n            if (vals[i].sval) {\n                addReplyDouble(c, zzlStrtod(vals[i].sval,vals[i].slen));\n            } else\n                addReplyDouble(c, vals[i].lval);\n        }\n    }\n}\n\n/* How many times bigger should be the zset compared to the requested size\n * for us to not use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define ZRANDMEMBER_SUB_STRATEGY_MUL 3\n\n/* If client is trying to ask for a very large number of random elements,\n * queuing may consume an unlimited amount of memory, so we want to limit\n * the number of randoms per time. */\n#define ZRANDMEMBER_RANDOM_SAMPLE_LIMIT 1000\n\nvoid zrandmemberWithCountCommand(client *c, long l, int withscores) {\n    unsigned long count, size;\n    int uniq = 1;\n    robj *zsetobj;\n\n    if ((zsetobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptyarray))\n        == NULL || checkType(c, zsetobj, OBJ_ZSET)) return;\n    size = zsetLength(zsetobj);\n\n    if(l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        count = -l;\n        uniq = 0;\n    }\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        if (withscores && c->resp == 2)\n            addReplyArrayLen(c, count*2);\n        else\n            addReplyArrayLen(c, count);\n        if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = zsetobj->ptr;\n            while (count--) {\n                dictEntry *de = dictGetFairRandomKey(zs->dict);\n                sds key = dictGetKey(de);\n                if (withscores && c->resp > 2)\n                    addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c, key, sdslen(key));\n                if (withscores)\n                    addReplyDouble(c, *(double*)dictGetVal(de));\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n        } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {\n            listpackEntry *keys, *vals = NULL;\n            unsigned long limit, sample_count;\n            limit = count > ZRANDMEMBER_RANDOM_SAMPLE_LIMIT ? ZRANDMEMBER_RANDOM_SAMPLE_LIMIT : count;\n            keys = zmalloc(sizeof(listpackEntry)*limit);\n            if (withscores)\n                vals = zmalloc(sizeof(listpackEntry)*limit);\n            while (count) {\n                sample_count = count > limit ? limit : count;\n                count -= sample_count;\n                lpRandomPairs(zsetobj->ptr, sample_count, keys, vals);\n                zrandmemberReplyWithListpack(c, sample_count, keys, vals);\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n            zfree(keys);\n            zfree(vals);\n        }\n        return;\n    }\n\n    zsetopsrc src;\n    zsetopval zval;\n    src.subject = zsetobj;\n    src.type = zsetobj->type;\n    src.encoding = zsetobj->encoding;\n    zuiInitIterator(&src);\n    memset(&zval, 0, sizeof(zval));\n\n    /* Initiate reply count, RESP3 responds with nested array, RESP2 with flat one. */\n    long reply_size = count < size ? count : size;\n    if (withscores && c->resp == 2)\n        addReplyArrayLen(c, reply_size*2);\n    else\n        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the zset: simply return the whole zset. */\n    if (count >= size) {\n        while (zuiNext(&src, &zval)) {\n            if (withscores && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, zuiNewSdsFromValue(&zval));\n            if (withscores)\n                addReplyDouble(c, zval.score);\n        }\n        zuiClearIterator(&src);\n        return;\n    }\n\n    /* CASE 3:\n     * The number of elements inside the zset is not greater than\n     * ZRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a dict from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*ZRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        dict *d = dictCreate(&sdsReplyDictType);\n        dictExpand(d, size);\n        /* Add all the elements into the temporary dictionary. */\n        while (zuiNext(&src, &zval)) {\n            sds key = zuiNewSdsFromValue(&zval);\n            dictEntry *de = dictAddRaw(d, key, NULL);\n            serverAssert(de);\n            if (withscores)\n                dictSetDoubleVal(de, zval.score);\n        }\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n\n        /* Reply with what's in the dict and release memory */\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(d);\n        while ((de = dictNext(di)) != NULL) {\n            if (withscores && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, dictGetKey(de));\n            if (withscores)\n                addReplyDouble(c, dictGetDoubleVal(de));\n        }\n\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n\n    /* CASE 4: We have a big zset compared to the requested number of elements.\n     * In this case we can simply get random elements from the zset and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {\n            /* it is inefficient to repeatedly pick one random element from a\n             * listpack. so we use this instead: */\n            listpackEntry *keys, *vals = NULL;\n            keys = zmalloc(sizeof(listpackEntry)*count);\n            if (withscores)\n                vals = zmalloc(sizeof(listpackEntry)*count);\n            serverAssert(lpRandomPairsUnique(zsetobj->ptr, count, keys, vals) == count);\n            zrandmemberReplyWithListpack(c, count, keys, vals);\n            zfree(keys);\n            zfree(vals);\n            zuiClearIterator(&src);\n            return;\n        }\n\n        /* Hashtable encoding (generic implementation) */\n        unsigned long added = 0;\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, count);\n\n        while (added < count) {\n            listpackEntry key;\n            double score;\n            zsetTypeRandomElement(zsetobj, size, &key, withscores ? &score: NULL);\n\n            /* Try to add the object to the dictionary. If it already exists\n            * free it, otherwise increment the number of objects we have\n            * in the result dictionary. */\n            sds skey = zsetSdsFromListpackEntry(&key);\n            if (dictAdd(d,skey,NULL) != DICT_OK) {\n                sdsfree(skey);\n                continue;\n            }\n            added++;\n\n            if (withscores && c->resp > 2)\n                addReplyArrayLen(c,2);\n            zsetReplyFromListpackEntry(c, &key);\n            if (withscores)\n                addReplyDouble(c, score);\n        }\n\n        /* Release memory */\n        dictRelease(d);\n    }\n    zuiClearIterator(&src);\n}\n\n/* ZRANDMEMBER key [<count> [WITHSCORES]] */\nvoid zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withscores = 1;\n            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}\n\n/* ZMPOP/BZMPOP\n *\n * 'numkeys_idx' parameter position of key number.\n * 'is_block' this indicates whether it is a blocking variant. */\nvoid zmpopGenericCommand(client *c, int numkeys_idx, int is_block) {\n    long j;\n    long numkeys = 0;      /* Number of keys. */\n    int where = 0;         /* ZSET_MIN or ZSET_MAX. */\n    long count = -1;       /* Reply will consist of up to count elements, depending on the zset's length. */\n\n    /* Parse the numkeys. */\n    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,\n                                      &numkeys, \"numkeys should be greater than 0\") != C_OK)\n        return;\n\n    /* Parse the where. where_idx: the index of where in the c->argv. */\n    long where_idx = numkeys_idx + numkeys + 1;\n    if (where_idx >= c->argc) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    if (!strcasecmp(c->argv[where_idx]->ptr, \"MIN\")) {\n        where = ZSET_MIN;\n    } else if (!strcasecmp(c->argv[where_idx]->ptr, \"MAX\")) {\n        where = ZSET_MAX;\n    } else {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n\n    /* Parse the optional arguments. */\n    for (j = where_idx + 1; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc - 1) - j;\n\n        if (count == -1 && !strcasecmp(opt, \"COUNT\") && moreargs) {\n            j++;\n            if (getRangeLongFromObjectOrReply(c, c->argv[j], 1, LONG_MAX,\n                                              &count,\"count should be greater than 0\") != C_OK)\n                return;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n\n    if (count == -1) count = 1;\n\n    if (is_block) {\n        /* BLOCK. We will handle CLIENT_DENY_BLOCKING flag in blockingGenericZpopCommand. */\n        blockingGenericZpopCommand(c, c->argv+numkeys_idx+1, numkeys, where, 1, count, 1, 1);\n    } else {\n        /* NON-BLOCK */\n        genericZpopCommand(c, c->argv+numkeys_idx+1, numkeys, where, 1, count, 1, 1, NULL);\n    }\n}\n\n/* ZMPOP numkeys key [<key> ...] MIN|MAX [COUNT count] */\nvoid zmpopCommand(client *c) {\n    zmpopGenericCommand(c, 1, 0);\n}\n\n/* BZMPOP timeout numkeys key [<key> ...] MIN|MAX [COUNT count] */\nvoid bzmpopCommand(client *c) {\n    zmpopGenericCommand(c, 2, 1);\n}\n", "start_server {tags {\"hash\"}} {\n    test {HSET/HLEN - Small hash creation} {\n        array set smallhash {}\n        for {set i 0} {$i < 8} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists smallhash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset smallhash $key $val\n            set smallhash($key) $val\n        }\n        list [r hlen smallhash]\n    } {8}\n\n    test {Is the small hash encoded with a listpack?} {\n        assert_encoding listpack smallhash\n    }\n\n    proc create_hash {key entries} {\n        r del $key\n        foreach entry $entries {\n            r hset $key [lindex $entry 0] [lindex $entry 1]\n        }\n    }\n\n    proc get_keys {l} {\n        set res {}\n        foreach entry $l {\n            set key [lindex $entry 0]\n            lappend res $key\n        }\n        return $res\n    }\n\n    foreach {type contents} \"listpack {{a 1} {b 2} {c 3}} hashtable {{a 1} {b 2} {[randstring 70 90 alpha] 3}}\" {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-ziplist-value 10\n        create_hash myhash $contents\n        assert_encoding $type myhash\n\n        # coverage for objectComputeSize\n        assert_morethan [memory_usage myhash] 0\n\n        test \"HRANDFIELD - $type\" {\n            unset -nocomplain myhash\n            array set myhash {}\n            for {set i 0} {$i < 100} {incr i} {\n                set key [r hrandfield myhash]\n                set myhash($key) 1\n            }\n            assert_equal [lsort [get_keys $contents]] [lsort [array names myhash]]\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n    test \"HRANDFIELD with RESP3\" {\n        r hello 3\n        set res [r hrandfield myhash 3 withvalues]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 2\n\n        set res [r hrandfield myhash 3]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 1\n        r hello 2\n    }\n\n    test \"HRANDFIELD count of 0 is handled correctly\" {\n        r hrandfield myhash 0\n    } {}\n\n    test \"HRANDFIELD count overflow\" {\n        r hmset myhash a 1\n        assert_error {*value is out of range*} {r hrandfield myhash -9223372036854770000 withvalues}\n    } {}\n\n    test \"HRANDFIELD with <count> against non existing key\" {\n        r hrandfield nonexisting_key 100\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"HRANDFIELD count of 0 is handled correctly - emptyarray\" {\n        r hrandfield myhash 0\n    } {*0}\n\n    test \"HRANDFIELD with <count> against non existing key - emptyarray\" {\n        r hrandfield nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} \"\n        hashtable {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {[randstring 70 90 alpha] 10}}\n        listpack {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {10 j}} \" {\n        test \"HRANDFIELD with <count> - $type\" {\n            set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n            r config set hash-max-ziplist-value 10\n            create_hash myhash $contents\n            assert_encoding $type myhash\n\n            # create a dict for easy lookup\n            set mydict [dict create {*}[r hgetall myhash]]\n\n            # We'll stress different parts of the code, see the implementation\n            # of HRANDFIELD for more information, but basically there are\n            # four different code paths.\n\n            # PATH 1: Use negative count.\n\n            # 1) Check that it returns repeated elements with and without values.\n            set res [r hrandfield myhash -20]\n            assert_equal [llength $res] 20\n            set res [r hrandfield myhash -1001]\n            assert_equal [llength $res] 1001\n            # again with WITHVALUES\n            set res [r hrandfield myhash -20 withvalues]\n            assert_equal [llength $res] 40\n            set res [r hrandfield myhash -1001 withvalues]\n            assert_equal [llength $res] 2002\n\n            # Test random uniform distribution\n            # df = 9, 40 means 0.00001 probability\n            set res [r hrandfield myhash -1000]\n            assert_lessthan [chi_square_value $res] 40\n\n            # 2) Check that all the elements actually belong to the original hash.\n            foreach {key val} $res {\n                assert {[dict exists $mydict $key]}\n            }\n\n            # 3) Check that eventually all the elements are returned.\n            #    Use both WITHVALUES and without\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                if {[expr {$iterations % 2}] == 0} {\n                    set res [r hrandfield myhash -3 withvalues]\n                    foreach {key val} $res {\n                        dict append auxset $key $val\n                    }\n                } else {\n                    set res [r hrandfield myhash -3]\n                    foreach key $res {\n                        dict append auxset $key $val\n                    }\n                }\n                if {[lsort [dict keys $mydict]] eq\n                    [lsort [dict keys $auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {10 20} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] 10\n                assert_equal [lsort $res] [lsort [dict keys $mydict]]\n\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] 20\n                assert_equal [lsort $res] [lsort $mydict]\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n            foreach size {8 2} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] $size\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] [expr {$size * 2}]\n\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                foreach ele [dict keys $res] {\n                    assert {[dict exists $mydict $ele]}\n                }\n\n                # 2) Check that eventually all the elements are returned.\n                #    Use both WITHVALUES and without\n                unset -nocomplain auxset\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                set all_ele_return false\n                while {$iterations != 0} {\n                    incr iterations -1\n                    if {[expr {$iterations % 2}] == 0} {\n                        set res [r hrandfield myhash $size withvalues]\n                        foreach {key value} $res {\n                            dict append auxset $key $value\n                            lappend allkey $key\n                        }\n                    } else {\n                        set res [r hrandfield myhash $size]\n                        foreach key $res {\n                            dict append auxset $key\n                            lappend allkey $key\n                        }\n                    }\n                    if {[lsort [dict keys $mydict]] eq\n                        [lsort [dict keys $auxset]]} {\n                        set all_ele_return true\n                    }\n                }\n                assert_equal $all_ele_return true\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n\n    test {HSET/HLEN - Big hash creation} {\n        array set bighash {}\n        for {set i 0} {$i < 1024} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists bighash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset bighash $key $val\n            set bighash($key) $val\n        }\n        list [r hlen bighash]\n    } {1024}\n\n    test {Is the big hash encoded with an hash table?} {\n        assert_encoding hashtable bighash\n    }\n\n    test {HGET against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {$smallhash($k) ne [r hget smallhash $k]} {\n                set err \"$smallhash($k) != [r hget smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {$bighash($k) ne [r hget bighash $k]} {\n                set err \"$bighash($k) != [r hget bighash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against non existing key} {\n        set rv {}\n        lappend rv [r hget smallhash __123123123__]\n        lappend rv [r hget bighash __123123123__]\n        set _ $rv\n    } {{} {}}\n\n    test {HSET in update and insert mode} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hset smallhash $k newval1]\n        set smallhash($k) newval1\n        lappend rv [r hget smallhash $k]\n        lappend rv [r hset smallhash __foobar123__ newval]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hset bighash $k newval2]\n        set bighash($k) newval2\n        lappend rv [r hget bighash $k]\n        lappend rv [r hset bighash __foobar123__ newval]\n        lappend rv [r hdel smallhash __foobar123__]\n        lappend rv [r hdel bighash __foobar123__]\n        set _ $rv\n    } {0 newval1 1 0 newval2 1 1 1}\n\n    test {HSETNX target key missing - small hash} {\n        r hsetnx smallhash __123123123__ foo\n        r hget smallhash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - small hash} {\n        r hsetnx smallhash __123123123__ bar\n        set result [r hget smallhash __123123123__]\n        r hdel smallhash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSETNX target key missing - big hash} {\n        r hsetnx bighash __123123123__ foo\n        r hget bighash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - big hash} {\n        r hsetnx bighash __123123123__ bar\n        set result [r hget bighash __123123123__]\n        r hdel bighash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSET/HMSET wrong number of args} {\n        assert_error {*wrong number of arguments for 'hset' command} {r hset smallhash key1 val1 key2}\n        assert_error {*wrong number of arguments for 'hmset' command} {r hmset smallhash key1 val1 key2}\n    }\n\n    test {HMSET - small hash} {\n        set args {}\n        foreach {k v} [array get smallhash] {\n            set newval [randstring 0 8 alpha]\n            set smallhash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset smallhash {*}$args\n    } {OK}\n\n    test {HMSET - big hash} {\n        set args {}\n        foreach {k v} [array get bighash] {\n            set newval [randstring 0 8 alpha]\n            set bighash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset bighash {*}$args\n    } {OK}\n\n    test {HMGET against non existing key and fields} {\n        set rv {}\n        lappend rv [r hmget doesntexist __123123123__ __456456456__]\n        lappend rv [r hmget smallhash __123123123__ __456456456__]\n        lappend rv [r hmget bighash __123123123__ __456456456__]\n        set _ $rv\n    } {{{} {}} {{} {}} {{} {}}}\n\n    test {HMGET against wrong type} {\n        r set wrongtype somevalue\n        assert_error \"*wrong*\" {r hmget wrongtype field1 field2}\n    }\n\n    test {HMGET - small hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget smallhash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HMGET - big hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget bighash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HKEYS - small hash} {\n        lsort [r hkeys smallhash]\n    } [lsort [array names smallhash *]]\n\n    test {HKEYS - big hash} {\n        lsort [r hkeys bighash]\n    } [lsort [array names bighash *]]\n\n    test {HVALS - small hash} {\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals smallhash]]\n\n    test {HVALS - big hash} {\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals bighash]]\n\n    test {HGETALL - small hash} {\n        lsort [r hgetall smallhash]\n    } [lsort [array get smallhash]]\n\n    test {HGETALL - big hash} {\n        lsort [r hgetall bighash]\n    } [lsort [array get bighash]]\n\n    test {HDEL and return value} {\n        set rv {}\n        lappend rv [r hdel smallhash nokey]\n        lappend rv [r hdel bighash nokey]\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hget smallhash $k]\n        unset smallhash($k)\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hget bighash $k]\n        unset bighash($k)\n        set _ $rv\n    } {0 0 1 0 {} 1 0 {}}\n\n    test {HDEL - more than a single value} {\n        set rv {}\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 0 [r hdel myhash x y]\n        assert_equal 2 [r hdel myhash a c f]\n        r hgetall myhash\n    } {b 2}\n\n    test {HDEL - hash becomes empty before deleting all specified fields} {\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 3 [r hdel myhash a b c d e]\n        assert_equal 0 [r exists myhash]\n    }\n\n    test {HEXISTS} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hexists smallhash $k]\n        lappend rv [r hexists smallhash nokey]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hexists bighash $k]\n        lappend rv [r hexists bighash nokey]\n    } {1 0 1 0}\n\n    test {Is a ziplist encoded Hash promoted on big payload?} {\n        r hset smallhash foo [string repeat a 1024]\n        r debug object smallhash\n    } {*hashtable*} {needs:debug}\n\n    test {HINCRBY against non existing database key} {\n        r del htest\n        list [r hincrby htest foo 2]\n    } {2}\n\n    test {HINCRBY against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [r hincrby smallhash tmp 2]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 2]\n        lappend rv [r hget bighash tmp]\n    } {2 2 2 2}\n\n    test {HINCRBY against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [r hincrby smallhash tmp 3]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 3]\n        lappend rv [r hget bighash tmp]\n    } {5 5 5 5}\n\n    test {HINCRBY against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [r hincrby smallhash tmp 2] [r hincrby bighash tmp 2]\n    } {102 102}\n\n    test {HINCRBY over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 1] [r hincrby bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBY over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 17179869184] [r hincrby bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBY fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY can detect overflows} {\n        set e {}\n        r hset hash n -9223372036854775484\n        assert {[r hincrby hash n -1] == -9223372036854775485}\n        catch {r hincrby hash n -10000} e\n        set e\n    } {*overflow*}\n\n    test {HINCRBYFLOAT against non existing database key} {\n        r del htest\n        list [r hincrbyfloat htest foo 2.5]\n    } {2.5}\n\n    test {HINCRBYFLOAT against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 2.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {2.5 2.5 2.5 2.5}\n\n    test {HINCRBYFLOAT against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 3.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 3.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {6 6 6 6}\n\n    test {HINCRBYFLOAT against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [roundFloat [r hincrbyfloat smallhash tmp 2.5]] \\\n             [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n    } {102.5 102.5}\n\n    test {HINCRBYFLOAT over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 1] \\\n             [r hincrbyfloat bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBYFLOAT over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 17179869184] \\\n             [r hincrbyfloat bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle} {\n        r hset h f \"1\\x002\"\n        catch {r hincrbyfloat h f 1} err\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $err]\n    } {1}\n\n    test {HSTRLEN against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {[string length $smallhash($k)] ne [r hstrlen smallhash $k]} {\n                set err \"[string length $smallhash($k)] != [r hstrlen smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {[string length $bighash($k)] ne [r hstrlen bighash $k]} {\n                set err \"[string length $bighash($k)] != [r hstrlen bighash $k]\"\n                puts \"HSTRLEN and logical length mismatch:\"\n                puts \"key: $k\"\n                puts \"Logical content: $bighash($k)\"\n                puts \"Server  content: [r hget bighash $k]\"\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against non existing field} {\n        set rv {}\n        lappend rv [r hstrlen smallhash __123123123__]\n        lappend rv [r hstrlen bighash __123123123__]\n        set _ $rv\n    } {0 0}\n\n    test {HSTRLEN corner cases} {\n        set vals {\n            -9223372036854775808 9223372036854775807 9223372036854775808\n            {} 0 -1 x\n        }\n        foreach v $vals {\n            r hmset smallhash field $v\n            r hmset bighash field $v\n            set len1 [string length $v]\n            set len2 [r hstrlen smallhash field]\n            set len3 [r hstrlen bighash field]\n            assert {$len1 == $len2}\n            assert {$len2 == $len3}\n        }\n    }\n\n    test {HINCRBYFLOAT over hash-max-listpack-value encoded with a listpack} {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-listpack-value 8\n        \n        # hash's value exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hset smallhash tmp 0\n        r hset bighash tmp 0\n        r hincrbyfloat smallhash tmp 0.000005\n        r hincrbyfloat bighash tmp 0.0000005\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        # hash's field exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hincrbyfloat smallhash abcdefgh 1\n        r hincrbyfloat bighash abcdefghi 1\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        r config set hash-max-listpack-value $original_max_value\n    }\n\n    test {Hash ziplist regression test for large keys} {\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk a\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk b\n        r hget hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\n    } {b}\n\n    foreach size {10 512} {\n        test \"Hash fuzzing #1 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    set field [randomValue]\n                    set value [randomValue]\n                    r hset hash $field $value\n                    set hash($field) $value\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n\n        test \"Hash fuzzing #2 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    randpath {\n                        set field [randomValue]\n                        set value [randomValue]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        set field [randomSignedInt 512]\n                        set value [randomSignedInt 512]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        randpath {\n                            set field [randomValue]\n                        } {\n                            set field [randomSignedInt 512]\n                        }\n                        r hdel hash $field\n                        unset -nocomplain hash($field)\n                    }\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n    }\n\n    test {Stress test the hash ziplist -> hashtable encoding conversion} {\n        r config set hash-max-ziplist-entries 32\n        for {set j 0} {$j < 100} {incr j} {\n            r del myhash\n            for {set i 0} {$i < 64} {incr i} {\n                r hset myhash [randomValue] [randomValue]\n            }\n            assert_encoding hashtable myhash\n        }\n    }\n\n    # The following test can only be executed if we don't use Valgrind, and if\n    # we are using x86_64 architecture, because:\n    #\n    # 1) Valgrind has floating point limitations, no support for 80 bits math.\n    # 2) Other archs may have the same limits.\n    #\n    # 1.23 cannot be represented correctly with 64 bit doubles, so we skip\n    # the test, since we are only testing pretty printing here and is not\n    # a bug if the program outputs things like 1.299999...\n    if {!$::valgrind && [string match *x86_64* [exec uname -a]]} {\n        test {Test HINCRBYFLOAT for correct float representation (issue #2846)} {\n            r del myhash\n            assert {[r hincrbyfloat myhash float 1.23] eq {1.23}}\n            assert {[r hincrbyfloat myhash float 0.77] eq {2}}\n            assert {[r hincrbyfloat myhash float -0.1] eq {1.9}}\n        }\n    }\n\n    test {Hash ziplist of various encodings} {\n        r del k\n        config_set hash-max-ziplist-entries 1000000000\n        config_set hash-max-ziplist-value 1000000000\n        r hset k ZIP_INT_8B 127\n        r hset k ZIP_INT_16B 32767\n        r hset k ZIP_INT_32B 2147483647\n        r hset k ZIP_INT_64B 9223372036854775808\n        r hset k ZIP_INT_IMM_MIN 0\n        r hset k ZIP_INT_IMM_MAX 12\n        r hset k ZIP_STR_06B [string repeat x 31]\n        r hset k ZIP_STR_14B [string repeat x 8191]\n        r hset k ZIP_STR_32B [string repeat x 65535]\n        set k [r hgetall k]\n        set dump [r dump k]\n\n        # will be converted to dict at RESTORE\n        config_set hash-max-ziplist-entries 2\n        config_set sanitize-dump-payload no mayfail\n        r restore kk 0 $dump\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n    test {Hash ziplist of various encodings - sanitize dump} {\n        config_set sanitize-dump-payload yes mayfail\n        r restore kk 0 $dump replace\n        set k [r hgetall k]\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n}\n", "start_server {\n    tags {\"set\"}\n    overrides {\n        \"set-max-intset-entries\" 512\n    }\n} {\n    proc create_set {key entries} {\n        r del $key\n        foreach entry $entries { r sadd $key $entry }\n    }\n\n    test {SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - regular set} {\n        create_set myset {foo}\n        assert_encoding hashtable myset\n        assert_equal 1 [r sadd myset bar]\n        assert_equal 0 [r sadd myset bar]\n        assert_equal 2 [r scard myset]\n        assert_equal 1 [r sismember myset foo]\n        assert_equal 1 [r sismember myset bar]\n        assert_equal 0 [r sismember myset bla]\n        assert_equal {1} [r smismember myset foo]\n        assert_equal {1 1} [r smismember myset foo bar]\n        assert_equal {1 0} [r smismember myset foo bla]\n        assert_equal {0 1} [r smismember myset bla foo]\n        assert_equal {0} [r smismember myset bla]\n        assert_equal {bar foo} [lsort [r smembers myset]]\n    }\n\n    test {SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - intset} {\n        create_set myset {17}\n        assert_encoding intset myset\n        assert_equal 1 [r sadd myset 16]\n        assert_equal 0 [r sadd myset 16]\n        assert_equal 2 [r scard myset]\n        assert_equal 1 [r sismember myset 16]\n        assert_equal 1 [r sismember myset 17]\n        assert_equal 0 [r sismember myset 18]\n        assert_equal {1} [r smismember myset 16]\n        assert_equal {1 1} [r smismember myset 16 17]\n        assert_equal {1 0} [r smismember myset 16 18]\n        assert_equal {0 1} [r smismember myset 18 16]\n        assert_equal {0} [r smismember myset 18]\n        assert_equal {16 17} [lsort [r smembers myset]]\n    }\n\n    test {SMISMEMBER against non set} {\n        r lpush mylist foo\n        assert_error WRONGTYPE* {r smismember mylist bar}\n    }\n\n    test {SMISMEMBER non existing key} {\n        assert_equal {0} [r smismember myset1 foo]\n        assert_equal {0 0} [r smismember myset1 foo bar]\n    }\n\n    test {SMISMEMBER requires one or more members} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n        \n        catch {r smismember zmscoretest} e\n        assert_match {*ERR*wrong*number*arg*} $e\n    }\n\n    test {SADD against non set} {\n        r lpush mylist foo\n        assert_error WRONGTYPE* {r sadd mylist bar}\n    }\n\n    test \"SADD a non-integer against an intset\" {\n        create_set myset {1 2 3}\n        assert_encoding intset myset\n        assert_equal 1 [r sadd myset a]\n        assert_encoding hashtable myset\n    }\n\n    test \"SADD an integer larger than 64 bits\" {\n        create_set myset {213244124402402314402033402}\n        assert_encoding hashtable myset\n        assert_equal 1 [r sismember myset 213244124402402314402033402]\n        assert_equal {1} [r smismember myset 213244124402402314402033402]\n    }\n\n    test \"SADD overflows the maximum allowed integers in an intset\" {\n        r del myset\n        for {set i 0} {$i < 512} {incr i} { r sadd myset $i }\n        assert_encoding intset myset\n        assert_equal 1 [r sadd myset 512]\n        assert_encoding hashtable myset\n    }\n\n    test {Variadic SADD} {\n        r del myset\n        assert_equal 3 [r sadd myset a b c]\n        assert_equal 2 [r sadd myset A a b c B]\n        assert_equal [lsort {A a b c B}] [lsort [r smembers myset]]\n    }\n\n    test \"Set encoding after DEBUG RELOAD\" {\n        r del myintset\n        r del myhashset\n        r del mylargeintset\n        for {set i 0} {$i <  100} {incr i} { r sadd myintset $i }\n        for {set i 0} {$i < 1280} {incr i} { r sadd mylargeintset $i }\n        for {set i 0} {$i <  256} {incr i} { r sadd myhashset [format \"i%03d\" $i] }\n        assert_encoding intset myintset\n        assert_encoding hashtable mylargeintset\n        assert_encoding hashtable myhashset\n\n        r debug reload\n        assert_encoding intset myintset\n        assert_encoding hashtable mylargeintset\n        assert_encoding hashtable myhashset\n    } {} {needs:debug}\n\n    test {SREM basics - regular set} {\n        create_set myset {foo bar ciao}\n        assert_encoding hashtable myset\n        assert_equal 0 [r srem myset qux]\n        assert_equal 1 [r srem myset foo]\n        assert_equal {bar ciao} [lsort [r smembers myset]]\n    }\n\n    test {SREM basics - intset} {\n        create_set myset {3 4 5}\n        assert_encoding intset myset\n        assert_equal 0 [r srem myset 6]\n        assert_equal 1 [r srem myset 4]\n        assert_equal {3 5} [lsort [r smembers myset]]\n    }\n\n    test {SREM with multiple arguments} {\n        r del myset\n        r sadd myset a b c d\n        assert_equal 0 [r srem myset k k k]\n        assert_equal 2 [r srem myset b d x y]\n        lsort [r smembers myset]\n    } {a c}\n\n    test {SREM variadic version with more args needed to destroy the key} {\n        r del myset\n        r sadd myset 1 2 3\n        r srem myset 1 2 3 4 5 6 7 8\n    } {3}\n\n    test \"SINTERCARD with illegal arguments\" {\n        assert_error \"ERR wrong number of arguments for 'sintercard' command\" {r sintercard}\n        assert_error \"ERR wrong number of arguments for 'sintercard' command\" {r sintercard 1}\n\n        assert_error \"ERR numkeys*\" {r sintercard 0 myset{t}}\n        assert_error \"ERR numkeys*\" {r sintercard a myset{t}}\n\n        assert_error \"ERR Number of keys*\" {r sintercard 2 myset{t}}\n        assert_error \"ERR Number of keys*\" {r sintercard 3 myset{t} myset2{t}}\n\n        assert_error \"ERR syntax error*\" {r sintercard 1 myset{t} myset2{t}}\n        assert_error \"ERR syntax error*\" {r sintercard 1 myset{t} bar_arg}\n        assert_error \"ERR syntax error*\" {r sintercard 1 myset{t} LIMIT}\n\n        assert_error \"ERR LIMIT*\" {r sintercard 1 myset{t} LIMIT -1}\n        assert_error \"ERR LIMIT*\" {r sintercard 1 myset{t} LIMIT a}\n    }\n\n    test \"SINTERCARD against non-set should throw error\" {\n        r del set{t}\n        r sadd set{t} a b c\n        r set key1{t} x\n\n        assert_error \"WRONGTYPE*\" {r sintercard 1 key1{t}}\n        assert_error \"WRONGTYPE*\" {r sintercard 2 set{t} key1{t}}\n        assert_error \"WRONGTYPE*\" {r sintercard 2 key1{t} noset{t}}\n    }\n\n    test \"SINTERCARD against non-existing key\" {\n        assert_equal 0 [r sintercard 1 non-existing-key]\n        assert_equal 0 [r sintercard 1 non-existing-key limit 0]\n        assert_equal 0 [r sintercard 1 non-existing-key limit 10]\n    }\n\n    foreach {type} {hashtable intset} {\n        for {set i 1} {$i <= 5} {incr i} {\n            r del [format \"set%d{t}\" $i]\n        }\n        for {set i 0} {$i < 200} {incr i} {\n            r sadd set1{t} $i\n            r sadd set2{t} [expr $i+195]\n        }\n        foreach i {199 195 1000 2000} {\n            r sadd set3{t} $i\n        }\n        for {set i 5} {$i < 200} {incr i} {\n            r sadd set4{t} $i\n        }\n        r sadd set5{t} 0\n\n        # To make sure the sets are encoded as the type we are testing -- also\n        # when the VM is enabled and the values may be swapped in and out\n        # while the tests are running -- an extra element is added to every\n        # set that determines its encoding.\n        set large 200\n        if {$type eq \"hashtable\"} {\n            set large foo\n        }\n\n        for {set i 1} {$i <= 5} {incr i} {\n            r sadd [format \"set%d{t}\" $i] $large\n        }\n\n        test \"Generated sets must be encoded as $type\" {\n            for {set i 1} {$i <= 5} {incr i} {\n                assert_encoding $type [format \"set%d{t}\" $i]\n            }\n        }\n\n        test \"SINTER with two sets - $type\" {\n            assert_equal [list 195 196 197 198 199 $large] [lsort [r sinter set1{t} set2{t}]]\n        }\n\n        test \"SINTERCARD with two sets - $type\" {\n            assert_equal 6 [r sintercard 2 set1{t} set2{t}]\n            assert_equal 6 [r sintercard 2 set1{t} set2{t} limit 0]\n            assert_equal 3 [r sintercard 2 set1{t} set2{t} limit 3]\n            assert_equal 6 [r sintercard 2 set1{t} set2{t} limit 10]\n        }\n\n        test \"SINTERSTORE with two sets - $type\" {\n            r sinterstore setres{t} set1{t} set2{t}\n            assert_encoding $type setres{t}\n            assert_equal [list 195 196 197 198 199 $large] [lsort [r smembers setres{t}]]\n        }\n\n        test \"SINTERSTORE with two sets, after a DEBUG RELOAD - $type\" {\n            r debug reload\n            r sinterstore setres{t} set1{t} set2{t}\n            assert_encoding $type setres{t}\n            assert_equal [list 195 196 197 198 199 $large] [lsort [r smembers setres{t}]]\n        } {} {needs:debug}\n\n        test \"SUNION with two sets - $type\" {\n            set expected [lsort -uniq \"[r smembers set1{t}] [r smembers set2{t}]\"]\n            assert_equal $expected [lsort [r sunion set1{t} set2{t}]]\n        }\n\n        test \"SUNIONSTORE with two sets - $type\" {\n            r sunionstore setres{t} set1{t} set2{t}\n            assert_encoding $type setres{t}\n            set expected [lsort -uniq \"[r smembers set1{t}] [r smembers set2{t}]\"]\n            assert_equal $expected [lsort [r smembers setres{t}]]\n        }\n\n        test \"SINTER against three sets - $type\" {\n            assert_equal [list 195 199 $large] [lsort [r sinter set1{t} set2{t} set3{t}]]\n        }\n\n        test \"SINTERCARD against three sets - $type\" {\n            assert_equal 3 [r sintercard 3 set1{t} set2{t} set3{t}]\n            assert_equal 3 [r sintercard 3 set1{t} set2{t} set3{t} limit 0]\n            assert_equal 2 [r sintercard 3 set1{t} set2{t} set3{t} limit 2]\n            assert_equal 3 [r sintercard 3 set1{t} set2{t} set3{t} limit 10]\n        }\n\n        test \"SINTERSTORE with three sets - $type\" {\n            r sinterstore setres{t} set1{t} set2{t} set3{t}\n            assert_equal [list 195 199 $large] [lsort [r smembers setres{t}]]\n        }\n\n        test \"SUNION with non existing keys - $type\" {\n            set expected [lsort -uniq \"[r smembers set1{t}] [r smembers set2{t}]\"]\n            assert_equal $expected [lsort [r sunion nokey1{t} set1{t} set2{t} nokey2{t}]]\n        }\n\n        test \"SDIFF with two sets - $type\" {\n            assert_equal {0 1 2 3 4} [lsort [r sdiff set1{t} set4{t}]]\n        }\n\n        test \"SDIFF with three sets - $type\" {\n            assert_equal {1 2 3 4} [lsort [r sdiff set1{t} set4{t} set5{t}]]\n        }\n\n        test \"SDIFFSTORE with three sets - $type\" {\n            r sdiffstore setres{t} set1{t} set4{t} set5{t}\n            # When we start with intsets, we should always end with intsets.\n            if {$type eq {intset}} {\n                assert_encoding intset setres{t}\n            }\n            assert_equal {1 2 3 4} [lsort [r smembers setres{t}]]\n        }\n\n        test \"SINTER/SUNION/SDIFF with three same sets - $type\" {\n            set expected [lsort \"[r smembers set1{t}]\"]\n            assert_equal $expected [lsort [r sinter set1{t} set1{t} set1{t}]]\n            assert_equal $expected [lsort [r sunion set1{t} set1{t} set1{t}]]\n            assert_equal {} [lsort [r sdiff set1{t} set1{t} set1{t}]]\n        }\n    }\n\n    test \"SDIFF with first set empty\" {\n        r del set1{t} set2{t} set3{t}\n        r sadd set2{t} 1 2 3 4\n        r sadd set3{t} a b c d\n        r sdiff set1{t} set2{t} set3{t}\n    } {}\n\n    test \"SDIFF with same set two times\" {\n        r del set1\n        r sadd set1 a b c 1 2 3 4 5 6\n        r sdiff set1 set1\n    } {}\n\n    test \"SDIFF fuzzing\" {\n        for {set j 0} {$j < 100} {incr j} {\n            unset -nocomplain s\n            array set s {}\n            set args {}\n            set num_sets [expr {[randomInt 10]+1}]\n            for {set i 0} {$i < $num_sets} {incr i} {\n                set num_elements [randomInt 100]\n                r del set_$i{t}\n                lappend args set_$i{t}\n                while {$num_elements} {\n                    set ele [randomValue]\n                    r sadd set_$i{t} $ele\n                    if {$i == 0} {\n                        set s($ele) x\n                    } else {\n                        unset -nocomplain s($ele)\n                    }\n                    incr num_elements -1\n                }\n            }\n            set result [lsort [r sdiff {*}$args]]\n            assert_equal $result [lsort [array names s]]\n        }\n    }\n\n    test \"SDIFF against non-set should throw error\" {\n        # with an empty set\n        r set key1{t} x\n        assert_error \"WRONGTYPE*\" {r sdiff key1{t} noset{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sdiff noset{t} key1{t}}\n\n        # with a legal set\n        r del set1{t}\n        r sadd set1{t} a b c\n        assert_error \"WRONGTYPE*\" {r sdiff key1{t} set1{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sdiff set1{t} key1{t}}\n    }\n\n    test \"SDIFF should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        assert_equal {a} [lsort [r sdiff set1{t} set2{t} set3{t}]]\n        assert_equal {} [lsort [r sdiff set3{t} set2{t} set1{t}]]\n    }\n\n    test \"SDIFFSTORE against non-set should throw error\" {\n        r del set1{t} set2{t} set3{t} key1{t}\n        r set key1{t} x\n\n        # with en empty dstkey\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} key1{t} noset{t}}\n        assert_equal 0 [r exists set3{t}]\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} noset{t} key1{t}}\n        assert_equal 0 [r exists set3{t}]\n\n        # with a legal dstkey\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sadd set3{t} e\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} key1{t} set1{t} noset{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} set1{t} key1{t} set2{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SDIFFSTORE should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r set setres{t} xxx\n        assert_equal 0 [r sdiffstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n\n        # with a legal dstkey, should delete dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sdiffstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        r sadd set1{t} a b c\n        assert_equal 3 [r sdiffstore set3{t} set1{t} set2{t}]\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {a b c} [lsort [r smembers set3{t}]]\n\n        # with a legal dstkey and empty set2, should delete the dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sdiffstore set3{t} set2{t} set1{t}]\n        assert_equal 0 [r exists set3{t}]\n    }\n\n    test \"SINTER against non-set should throw error\" {\n        r set key1{t} x\n        assert_error \"WRONGTYPE*\" {r sinter key1{t} noset{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sinter noset{t} key1{t}}\n\n        r sadd set1{t} a b c\n        assert_error \"WRONGTYPE*\" {r sinter key1{t} set1{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sinter set1{t} key1{t}}\n    }\n\n    test \"SINTER should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sinter set1{t} set2{t} set3{t}\n    } {}\n\n    test \"SINTER with same integer elements but different encoding\" {\n        r del set1{t} set2{t}\n        r sadd set1{t} 1 2 3\n        r sadd set2{t} 1 2 3 a\n        r srem set2{t} a\n        assert_encoding intset set1{t}\n        assert_encoding hashtable set2{t}\n        lsort [r sinter set1{t} set2{t}]\n    } {1 2 3}\n\n    test \"SINTERSTORE against non-set should throw error\" {\n        r del set1{t} set2{t} set3{t} key1{t}\n        r set key1{t} x\n\n        # with en empty dstkey\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} key1{t} noset{t}}\n        assert_equal 0 [r exists set3{t}]\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} noset{t} key1{t}}\n        assert_equal 0 [r exists set3{t}]\n\n        # with a legal dstkey\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sadd set3{t} e\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} key1{t} set2{t} noset{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} noset{t} key1{t} set2{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SINTERSTORE against non existing keys should delete dstkey\" {\n        r del set1{t} set2{t} set3{t}\n\n        r set setres{t} xxx\n        assert_equal 0 [r sinterstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n\n        # with a legal dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sinterstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        r sadd set1{t} a b c\n        assert_equal 0 [r sinterstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        assert_equal 0 [r sinterstore set3{t} set2{t} set1{t}]\n        assert_equal 0 [r exists set3{t}]\n    }\n\n    test \"SUNION against non-set should throw error\" {\n        r set key1{t} x\n        assert_error \"WRONGTYPE*\" {r sunion key1{t} noset{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sunion noset{t} key1{t}}\n\n        r del set1{t}\n        r sadd set1{t} a b c\n        assert_error \"WRONGTYPE*\" {r sunion key1{t} set1{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sunion set1{t} key1{t}}\n    }\n\n    test \"SUNION should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        assert_equal {a b c d} [lsort [r sunion set1{t} set2{t} set3{t}]]\n    }\n\n    test \"SUNIONSTORE against non-set should throw error\" {\n        r del set1{t} set2{t} set3{t} key1{t}\n        r set key1{t} x\n\n        # with en empty dstkey\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} key1{t} noset{t}}\n        assert_equal 0 [r exists set3{t}]\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} noset{t} key1{t}}\n        assert_equal 0 [r exists set3{t}]\n\n        # with a legal dstkey\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sadd set3{t} e\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} key1{t} key2{t} noset{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} noset{t} key1{t} key2{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SUNIONSTORE should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r set setres{t} xxx\n        assert_equal 0 [r sunionstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n\n        # set1 set2 both empty, should delete the dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sunionstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        r sadd set1{t} a b c\n        r sadd set3{t} e f\n        assert_equal 3 [r sunionstore set3{t} set1{t} set2{t}]\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {a b c} [lsort [r smembers set3{t}]]\n\n        r sadd set3{t} d\n        assert_equal 3 [r sunionstore set3{t} set2{t} set1{t}]\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {a b c} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SUNIONSTORE against non existing keys should delete dstkey\" {\n        r set setres{t} xxx\n        assert_equal 0 [r sunionstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n    }\n\n    foreach {type contents} {hashtable {a b c} intset {1 2 3}} {\n        test \"SPOP basics - $type\" {\n            create_set myset $contents\n            assert_encoding $type myset\n            assert_equal $contents [lsort [list [r spop myset] [r spop myset] [r spop myset]]]\n            assert_equal 0 [r scard myset]\n        }\n\n        test \"SPOP with <count>=1 - $type\" {\n            create_set myset $contents\n            assert_encoding $type myset\n            assert_equal $contents [lsort [list [r spop myset 1] [r spop myset 1] [r spop myset 1]]]\n            assert_equal 0 [r scard myset]\n        }\n\n        test \"SRANDMEMBER - $type\" {\n            create_set myset $contents\n            unset -nocomplain myset\n            array set myset {}\n            for {set i 0} {$i < 100} {incr i} {\n                set myset([r srandmember myset]) 1\n            }\n            assert_equal $contents [lsort [array names myset]]\n        }\n    }\n\n    foreach {type contents} {\n        hashtable {a b c d e f g h i j k l m n o p q r s t u v w x y z} \n        intset {1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 26 3 4 5 6 7 8 9}\n    } {\n        test \"SPOP with <count>\" {\n            create_set myset $contents\n            assert_encoding $type myset\n            assert_equal $contents [lsort [concat [r spop myset 11] [r spop myset 9] [r spop myset 0] [r spop myset 4] [r spop myset 1] [r spop myset 0] [r spop myset 1] [r spop myset 0]]]\n            assert_equal 0 [r scard myset]\n        }\n    }\n\n    # As seen in intsetRandomMembers\n    test \"SPOP using integers, testing Knuth's and Floyd's algorithm\" {\n        create_set myset {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        assert_encoding intset myset\n        assert_equal 20 [r scard myset]\n        r spop myset 1\n        assert_equal 19 [r scard myset]\n        r spop myset 2\n        assert_equal 17 [r scard myset]\n        r spop myset 3\n        assert_equal 14 [r scard myset]\n        r spop myset 10\n        assert_equal 4 [r scard myset]\n        r spop myset 10\n        assert_equal 0 [r scard myset]\n        r spop myset 1\n        assert_equal 0 [r scard myset]\n    } {}\n\n    test \"SPOP using integers with Knuth's algorithm\" {\n        r spop nonexisting_key 100\n    } {}\n\n    test \"SPOP new implementation: code path #1\" {\n        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        create_set myset $content\n        set res [r spop myset 30]\n        assert {[lsort $content] eq [lsort $res]}\n    }\n\n    test \"SPOP new implementation: code path #2\" {\n        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        create_set myset $content\n        set res [r spop myset 2]\n        assert {[llength $res] == 2}\n        assert {[r scard myset] == 18}\n        set union [concat [r smembers myset] $res]\n        assert {[lsort $union] eq [lsort $content]}\n    }\n\n    test \"SPOP new implementation: code path #3\" {\n        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        create_set myset $content\n        set res [r spop myset 18]\n        assert {[llength $res] == 18}\n        assert {[r scard myset] == 2}\n        set union [concat [r smembers myset] $res]\n        assert {[lsort $union] eq [lsort $content]}\n    }\n\n    test \"SRANDMEMBER count of 0 is handled correctly\" {\n        r srandmember myset 0\n    } {}\n\n    test \"SRANDMEMBER with <count> against non existing key\" {\n        r srandmember nonexisting_key 100\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"SRANDMEMBER count of 0 is handled correctly - emptyarray\" {\n        r srandmember myset 0\n    } {*0}\n\n    test \"SRANDMEMBER with <count> against non existing key - emptyarray\" {\n        r srandmember nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} {\n        hashtable {\n            1 5 10 50 125 50000 33959417 4775547 65434162\n            12098459 427716 483706 2726473884 72615637475\n            MARY PATRICIA LINDA BARBARA ELIZABETH JENNIFER MARIA\n            SUSAN MARGARET DOROTHY LISA NANCY KAREN BETTY HELEN\n            SANDRA DONNA CAROL RUTH SHARON MICHELLE LAURA SARAH\n            KIMBERLY DEBORAH JESSICA SHIRLEY CYNTHIA ANGELA MELISSA\n            BRENDA AMY ANNA REBECCA VIRGINIA KATHLEEN\n        }\n        intset {\n            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n            20 21 22 23 24 25 26 27 28 29\n            30 31 32 33 34 35 36 37 38 39\n            40 41 42 43 44 45 46 47 48 49\n        }\n    } {\n        test \"SRANDMEMBER with <count> - $type\" {\n            create_set myset $contents\n            unset -nocomplain myset\n            array set myset {}\n            foreach ele [r smembers myset] {\n                set myset($ele) 1\n            }\n            assert_equal [lsort $contents] [lsort [array names myset]]\n\n            # Make sure that a count of 0 is handled correctly.\n            assert_equal [r srandmember myset 0] {}\n\n            # We'll stress different parts of the code, see the implementation\n            # of SRANDMEMBER for more information, but basically there are\n            # four different code paths.\n            #\n            # PATH 1: Use negative count.\n            #\n            # 1) Check that it returns repeated elements.\n            set res [r srandmember myset -100]\n            assert_equal [llength $res] 100\n\n            # 2) Check that all the elements actually belong to the\n            # original set.\n            foreach ele $res {\n                assert {[info exists myset($ele)]}\n            }\n\n            # 3) Check that eventually all the elements are returned.\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                set res [r srandmember myset -10]\n                foreach ele $res {\n                    set auxset($ele) 1\n                }\n                if {[lsort [array names myset]] eq\n                    [lsort [array names auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {50 100} {\n                set res [r srandmember myset $size]\n                assert_equal [llength $res] 50\n                assert_equal [lsort $res] [lsort [array names myset]]\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n\n            foreach size {45 5} {\n                set res [r srandmember myset $size]\n                assert_equal [llength $res] $size\n\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                foreach ele $res {\n                    assert {[info exists myset($ele)]}\n                }\n\n                # 2) Check that eventually all the elements are returned.\n                unset -nocomplain auxset\n                set iterations 1000\n                while {$iterations != 0} {\n                    incr iterations -1\n                    set res [r srandmember myset $size]\n                    foreach ele $res {\n                        set auxset($ele) 1\n                    }\n                    if {[lsort [array names myset]] eq\n                        [lsort [array names auxset]]} {\n                        break;\n                    }\n                }\n                assert {$iterations != 0}\n            }\n        }\n    }\n\n    foreach {type contents} {\n        hashtable {\n            1 5 10 50 125\n            MARY PATRICIA LINDA BARBARA ELIZABETH\n        }\n        intset {\n            0 1 2 3 4 5 6 7 8 9\n        }\n    } {\n        test \"SRANDMEMBER histogram distribution - $type\" {\n            create_set myset $contents\n            unset -nocomplain myset\n            array set myset {}\n            foreach ele [r smembers myset] {\n                set myset($ele) 1\n            }\n\n            # Use negative count (PATH 1).\n            # df = 9, 40 means 0.00001 probability\n            set res [r srandmember myset -1000]\n            assert_lessthan [chi_square_value $res] 40\n\n            # Use positive count (both PATH 3 and PATH 4).\n            foreach size {8 2} {\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                while {$iterations != 0} {\n                    incr iterations -1\n                    set res [r srandmember myset $size]\n                    foreach ele $res {\n                        lappend allkey $ele\n                    }\n                }\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n    }\n\n    proc setup_move {} {\n        r del myset3{t} myset4{t}\n        create_set myset1{t} {1 a b}\n        create_set myset2{t} {2 3 4}\n        assert_encoding hashtable myset1{t}\n        assert_encoding intset myset2{t}\n    }\n\n    test \"SMOVE basics - from regular set to intset\" {\n        # move a non-integer element to an intset should convert encoding\n        setup_move\n        assert_equal 1 [r smove myset1{t} myset2{t} a]\n        assert_equal {1 b} [lsort [r smembers myset1{t}]]\n        assert_equal {2 3 4 a} [lsort [r smembers myset2{t}]]\n        assert_encoding hashtable myset2{t}\n\n        # move an integer element should not convert the encoding\n        setup_move\n        assert_equal 1 [r smove myset1{t} myset2{t} 1]\n        assert_equal {a b} [lsort [r smembers myset1{t}]]\n        assert_equal {1 2 3 4} [lsort [r smembers myset2{t}]]\n        assert_encoding intset myset2{t}\n    }\n\n    test \"SMOVE basics - from intset to regular set\" {\n        setup_move\n        assert_equal 1 [r smove myset2{t} myset1{t} 2]\n        assert_equal {1 2 a b} [lsort [r smembers myset1{t}]]\n        assert_equal {3 4} [lsort [r smembers myset2{t}]]\n    }\n\n    test \"SMOVE non existing key\" {\n        setup_move\n        assert_equal 0 [r smove myset1{t} myset2{t} foo]\n        assert_equal 0 [r smove myset1{t} myset1{t} foo]\n        assert_equal {1 a b} [lsort [r smembers myset1{t}]]\n        assert_equal {2 3 4} [lsort [r smembers myset2{t}]]\n    }\n\n    test \"SMOVE non existing src set\" {\n        setup_move\n        assert_equal 0 [r smove noset{t} myset2{t} foo]\n        assert_equal {2 3 4} [lsort [r smembers myset2{t}]]\n    }\n\n    test \"SMOVE from regular set to non existing destination set\" {\n        setup_move\n        assert_equal 1 [r smove myset1{t} myset3{t} a]\n        assert_equal {1 b} [lsort [r smembers myset1{t}]]\n        assert_equal {a} [lsort [r smembers myset3{t}]]\n        assert_encoding hashtable myset3{t}\n    }\n\n    test \"SMOVE from intset to non existing destination set\" {\n        setup_move\n        assert_equal 1 [r smove myset2{t} myset3{t} 2]\n        assert_equal {3 4} [lsort [r smembers myset2{t}]]\n        assert_equal {2} [lsort [r smembers myset3{t}]]\n        assert_encoding intset myset3{t}\n    }\n\n    test \"SMOVE wrong src key type\" {\n        r set x{t} 10\n        assert_error \"WRONGTYPE*\" {r smove x{t} myset2{t} foo}\n    }\n\n    test \"SMOVE wrong dst key type\" {\n        r set x{t} 10\n        assert_error \"WRONGTYPE*\" {r smove myset2{t} x{t} foo}\n    }\n\n    test \"SMOVE with identical source and destination\" {\n        r del set{t}\n        r sadd set{t} a b c\n        r smove set{t} set{t} b\n        lsort [r smembers set{t}]\n    } {a b c}\n\n    test \"SMOVE only notify dstset when the addition is successful\" {\n        r del srcset{t}\n        r del dstset{t}\n\n        r sadd srcset{t} a b\n        r sadd dstset{t} a\n\n        r watch dstset{t}\n\n        r multi\n        r sadd dstset{t} c\n\n        set r2 [redis_client]\n        $r2 smove srcset{t} dstset{t} a\n\n        # The dstset is actually unchanged, multi should success\n        r exec\n        set res [r scard dstset{t}]\n        assert_equal $res 2\n        $r2 close\n    }\n\n    tags {slow} {\n        test {intsets implementation stress testing} {\n            for {set j 0} {$j < 20} {incr j} {\n                unset -nocomplain s\n                array set s {}\n                r del s\n                set len [randomInt 1024]\n                for {set i 0} {$i < $len} {incr i} {\n                    randpath {\n                        set data [randomInt 65536]\n                    } {\n                        set data [randomInt 4294967296]\n                    } {\n                        set data [randomInt 18446744073709551616]\n                    }\n                    set s($data) {}\n                    r sadd s $data\n                }\n                assert_equal [lsort [r smembers s]] [lsort [array names s]]\n                set len [array size s]\n                for {set i 0} {$i < $len} {incr i} {\n                    set e [r spop s]\n                    if {![info exists s($e)]} {\n                        puts \"Can't find '$e' on local array\"\n                        puts \"Local array: [lsort [r smembers s]]\"\n                        puts \"Remote array: [lsort [array names s]]\"\n                        error \"exception\"\n                    }\n                    array unset s $e\n                }\n                assert_equal [r scard s] 0\n                assert_equal [array size s] 0\n            }\n        }\n    }\n}\n\nrun_solo {set-large-memory} {\nstart_server [list overrides [list save \"\"] ] {\n\n# test if the server supports such large configs (avoid 32 bit builds)\ncatch {\n    r config set proto-max-bulk-len 10000000000 ;#10gb\n    r config set client-query-buffer-limit 10000000000 ;#10gb\n}\nif {[lindex [r config get proto-max-bulk-len] 1] == 10000000000} {\n\n    set str_length 4400000000 ;#~4.4GB\n\n    test {SADD, SCARD, SISMEMBER - large data} {\n        r flushdb\n        r write \"*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"aaa\"]\n        r write \"*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"bbb\"]\n        r write \"*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 0 [write_big_bulk $str_length \"aaa\"]\n        assert_encoding hashtable myset\n        set s0 [s used_memory]\n        assert {$s0 > [expr $str_length * 2]}\n        assert_equal 2 [r scard myset]\n\n        r write \"*3\\r\\n\\$9\\r\\nSISMEMBER\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"aaa\"]\n        r write \"*3\\r\\n\\$9\\r\\nSISMEMBER\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 0 [write_big_bulk $str_length \"ccc\"]\n        r write \"*3\\r\\n\\$4\\r\\nSREM\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"bbb\"]\n        assert_equal [read_big_bulk {r spop myset} yes \"aaa\"] $str_length\n    } {} {large-memory}\n} ;# skip 32bit builds\n}\n} ;# run_solo\n", "start_server {tags {\"zset\"}} {\n    proc create_zset {key items} {\n        r del $key\n        foreach {score entry} $items {\n            r zadd $key $score $entry\n        }\n    }\n\n    # A helper function to verify either ZPOP* or ZMPOP* response.\n    proc verify_pop_response {pop res zpop_expected_response zmpop_expected_response} {\n        if {[string match \"*ZM*\" $pop]} {\n            assert_equal $res $zmpop_expected_response\n        } else {\n            assert_equal $res $zpop_expected_response\n        }\n    }\n\n    # A helper function to verify either ZPOP* or ZMPOP* response when given one input key.\n    proc verify_zpop_response {rd pop key count zpop_expected_response zmpop_expected_response} {\n        if {[string match \"ZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n\n            if {$count == 0} {\n                set res [$rd $pop 1 $key $where]\n            } else {\n                set res [$rd $pop 1 $key $where COUNT $count]\n            }\n        } else {\n            if {$count == 0} {\n                set res [$rd $pop $key]\n            } else {\n                set res [$rd $pop $key $count]\n            }\n        }\n        verify_pop_response $pop $res $zpop_expected_response $zmpop_expected_response\n    }\n\n    # A helper function to verify either BZPOP* or BZMPOP* response when given one input key.\n    proc verify_bzpop_response {rd pop key timeout count bzpop_expected_response bzmpop_expected_response} {\n        if {[string match \"BZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n\n            if {$count == 0} {\n                $rd $pop $timeout 1 $key $where\n            } else {\n                $rd $pop $timeout 1 $key $where COUNT $count\n            }\n        } else {\n            $rd $pop $key $timeout\n        }\n        verify_pop_response $pop [$rd read] $bzpop_expected_response $bzmpop_expected_response\n    }\n\n    # A helper function to verify either ZPOP* or ZMPOP* response when given two input keys.\n    proc verify_bzpop_two_key_response {rd pop key key2 timeout count bzpop_expected_response bzmpop_expected_response} {\n        if {[string match \"BZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n\n            if {$count == 0} {\n                $rd $pop $timeout 2 $key $key2 $where\n            } else {\n                $rd $pop $timeout 2 $key $key2 $where COUNT $count\n            }\n        } else {\n            $rd $pop $key $key2 $timeout\n        }\n        verify_pop_response $pop [$rd read] $bzpop_expected_response $bzmpop_expected_response\n    }\n\n    # A helper function to execute either BZPOP* or BZMPOP* with one input key.\n    proc bzpop_command {rd pop key timeout} {\n        if {[string match \"BZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n            $rd $pop $timeout 1 $key $where COUNT 1\n        } else {\n            $rd $pop $key $timeout\n        }\n    }\n\n    # A helper function to verify nil response in readraw base on RESP version.\n    proc verify_nil_response {resp nil_response} {\n        if {$resp == 2} {\n            assert_equal $nil_response {*-1}\n        } elseif {$resp == 3} {\n            assert_equal $nil_response {_}\n        }\n    }\n\n    # A helper function to verify zset score response in readraw base on RESP version.\n    proc verify_score_response {rd resp score} {\n        if {$resp == 2} {\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] $score\n        } elseif {$resp == 3} {\n            assert_equal [$rd read] \",$score\"\n        }\n    }\n\n    proc basics {encoding} {\n        set original_max_entries [lindex [r config get zset-max-ziplist-entries] 1]\n        set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n        if {$encoding == \"listpack\"} {\n            r config set zset-max-ziplist-entries 128\n            r config set zset-max-ziplist-value 64\n        } elseif {$encoding == \"skiplist\"} {\n            r config set zset-max-ziplist-entries 0\n            r config set zset-max-ziplist-value 0\n        } else {\n            puts \"Unknown sorted set encoding\"\n            exit\n        }\n\n        test \"Check encoding - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            assert_encoding $encoding ztmp\n        }\n\n        test \"ZSET basic ZADD and score update - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            r zadd ztmp 20 y\n            r zadd ztmp 30 z\n            assert_equal {x y z} [r zrange ztmp 0 -1]\n\n            r zadd ztmp 1 y\n            assert_equal {y x z} [r zrange ztmp 0 -1]\n        }\n\n        test \"ZSET element can't be set to NaN with ZADD - $encoding\" {\n            assert_error \"*not*float*\" {r zadd myzset nan abc}\n        }\n\n        test \"ZSET element can't be set to NaN with ZINCRBY - $encoding\" {\n            assert_error \"*not*float*\" {r zadd myzset nan abc}\n        }\n\n        test \"ZADD with options syntax error with incomplete pair - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp xx 10 x 20} err\n            set err\n        } {ERR*}\n\n        test \"ZADD XX option without key - $encoding\" {\n            r del ztmp\n            assert {[r zadd ztmp xx 10 x] == 0}\n            assert {[r type ztmp] eq {none}}\n        }\n\n        test \"ZADD XX existing key - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            assert {[r zadd ztmp xx 20 y] == 0}\n            assert {[r zcard ztmp] == 1}\n        }\n\n        test \"ZADD XX returns the number of elements actually added - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            set retval [r zadd ztmp 10 x 20 y 30 z]\n            assert {$retval == 2}\n        }\n\n        test \"ZADD XX updates existing elements score - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            r zadd ztmp xx 5 foo 11 x 21 y 40 zap\n            assert {[r zcard ztmp] == 3}\n            assert {[r zscore ztmp x] == 11}\n            assert {[r zscore ztmp y] == 21}\n        }\n\n        test \"ZADD GT updates existing elements when new scores are greater - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp gt ch 5 foo 11 x 21 y 29 z] == 3}\n            assert {[r zcard ztmp] == 4}\n            assert {[r zscore ztmp x] == 11}\n            assert {[r zscore ztmp y] == 21}\n            assert {[r zscore ztmp z] == 30}\n        }\n\n        test \"ZADD LT updates existing elements when new scores are lower - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp lt ch 5 foo 11 x 21 y 29 z] == 2}\n            assert {[r zcard ztmp] == 4}\n            assert {[r zscore ztmp x] == 10}\n            assert {[r zscore ztmp y] == 20}\n            assert {[r zscore ztmp z] == 29}\n        }\n\n        test \"ZADD GT XX updates existing elements when new scores are greater and skips new elements - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp gt xx ch 5 foo 11 x 21 y 29 z] == 2}\n            assert {[r zcard ztmp] == 3}\n            assert {[r zscore ztmp x] == 11}\n            assert {[r zscore ztmp y] == 21}\n            assert {[r zscore ztmp z] == 30}\n        }\n\n        test \"ZADD LT XX updates existing elements when new scores are lower and skips new elements - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp lt xx ch 5 foo 11 x 21 y 29 z] == 1}\n            assert {[r zcard ztmp] == 3}\n            assert {[r zscore ztmp x] == 10}\n            assert {[r zscore ztmp y] == 20}\n            assert {[r zscore ztmp z] == 29}\n        }\n\n        test \"ZADD XX and NX are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp xx nx 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD NX with non existing key - $encoding\" {\n            r del ztmp\n            r zadd ztmp nx 10 x 20 y 30 z\n            assert {[r zcard ztmp] == 3}\n        }\n\n        test \"ZADD NX only add new elements without updating old ones - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp nx 11 x 21 y 100 a 200 b] == 2}\n            assert {[r zscore ztmp x] == 10}\n            assert {[r zscore ztmp y] == 20}\n            assert {[r zscore ztmp a] == 100}\n            assert {[r zscore ztmp b] == 200}\n        }\n\n        test \"ZADD GT and NX are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp gt nx 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD LT and NX are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp lt nx 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD LT and GT are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp lt gt 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD INCR LT/GT replies with nill if score not updated - $encoding\" {\n            r del ztmp\n            r zadd ztmp 28 x\n            assert {[r zadd ztmp lt incr 1 x] eq {}}\n            assert {[r zscore ztmp x] == 28}\n            assert {[r zadd ztmp gt incr -1 x] eq {}}\n            assert {[r zscore ztmp x] == 28}\n        }\n\n        test \"ZADD INCR LT/GT with inf - $encoding\" {\n            r del ztmp\n            r zadd ztmp +inf x -inf y\n\n            assert {[r zadd ztmp lt incr 1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n            assert {[r zadd ztmp gt incr -1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n            assert {[r zadd ztmp lt incr -1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n            assert {[r zadd ztmp gt incr 1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n\n            assert {[r zadd ztmp lt incr 1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n            assert {[r zadd ztmp gt incr -1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n            assert {[r zadd ztmp lt incr -1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n            assert {[r zadd ztmp gt incr 1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n        }\n\n        test \"ZADD INCR works like ZINCRBY - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            r zadd ztmp INCR 15 x\n            assert {[r zscore ztmp x] == 25}\n        }\n\n        test \"ZADD INCR works with a single score-elemenet pair - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            catch {r zadd ztmp INCR 15 x 10 y} err\n            set err\n        } {ERR*}\n\n        test \"ZADD CH option changes return value to all changed elements - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp 11 x 21 y 30 z] == 0}\n            assert {[r zadd ztmp ch 12 x 22 y 30 z] == 2}\n        }\n\n        test \"ZINCRBY calls leading to NaN result in error - $encoding\" {\n            r zincrby myzset +inf abc\n            assert_error \"*NaN*\" {r zincrby myzset -inf abc}\n        }\n\n        test {ZADD - Variadic version base case - $encoding} {\n            r del myzset\n            list [r zadd myzset 10 a 20 b 30 c] [r zrange myzset 0 -1 withscores]\n        } {3 {a 10 b 20 c 30}}\n\n        test {ZADD - Return value is the number of actually added items - $encoding} {\n            list [r zadd myzset 5 x 20 b 30 c] [r zrange myzset 0 -1 withscores]\n        } {1 {x 5 a 10 b 20 c 30}}\n\n        test {ZADD - Variadic version does not add nothing on single parsing err - $encoding} {\n            r del myzset\n            catch {r zadd myzset 10 a 20 b 30.badscore c} e\n            assert_match {*ERR*not*float*} $e\n            r exists myzset\n        } {0}\n\n        test {ZADD - Variadic version will raise error on missing arg - $encoding} {\n            r del myzset\n            catch {r zadd myzset 10 a 20 b 30 c 40} e\n            assert_match {*ERR*syntax*} $e\n        }\n\n        test {ZINCRBY does not work variadic even if shares ZADD implementation - $encoding} {\n            r del myzset\n            catch {r zincrby myzset 10 a 20 b 30 c} e\n            assert_match {*ERR*wrong*number*arg*} $e\n        }\n\n        test \"ZCARD basics - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 a 20 b 30 c\n            assert_equal 3 [r zcard ztmp]\n            assert_equal 0 [r zcard zdoesntexist]\n        }\n\n        test \"ZREM removes key after last element is removed - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            r zadd ztmp 20 y\n\n            assert_equal 1 [r exists ztmp]\n            assert_equal 0 [r zrem ztmp z]\n            assert_equal 1 [r zrem ztmp y]\n            assert_equal 1 [r zrem ztmp x]\n            assert_equal 0 [r exists ztmp]\n        }\n\n        test \"ZREM variadic version - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 a 20 b 30 c\n            assert_equal 2 [r zrem ztmp x y a b k]\n            assert_equal 0 [r zrem ztmp foo bar]\n            assert_equal 1 [r zrem ztmp c]\n            r exists ztmp\n        } {0}\n\n        test \"ZREM variadic version -- remove elements after key deletion - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 a 20 b 30 c\n            r zrem ztmp a b c d e f g\n        } {3}\n\n        test \"ZRANGE basics - $encoding\" {\n            r del ztmp\n            r zadd ztmp 1 a\n            r zadd ztmp 2 b\n            r zadd ztmp 3 c\n            r zadd ztmp 4 d\n\n            assert_equal {a b c d} [r zrange ztmp 0 -1]\n            assert_equal {a b c} [r zrange ztmp 0 -2]\n            assert_equal {b c d} [r zrange ztmp 1 -1]\n            assert_equal {b c} [r zrange ztmp 1 -2]\n            assert_equal {c d} [r zrange ztmp -2 -1]\n            assert_equal {c} [r zrange ztmp -2 -2]\n\n            # out of range start index\n            assert_equal {a b c} [r zrange ztmp -5 2]\n            assert_equal {a b} [r zrange ztmp -5 1]\n            assert_equal {} [r zrange ztmp 5 -1]\n            assert_equal {} [r zrange ztmp 5 -2]\n\n            # out of range end index\n            assert_equal {a b c d} [r zrange ztmp 0 5]\n            assert_equal {b c d} [r zrange ztmp 1 5]\n            assert_equal {} [r zrange ztmp 0 -5]\n            assert_equal {} [r zrange ztmp 1 -5]\n\n            # withscores\n            assert_equal {a 1 b 2 c 3 d 4} [r zrange ztmp 0 -1 withscores]\n        }\n\n        test \"ZREVRANGE basics - $encoding\" {\n            r del ztmp\n            r zadd ztmp 1 a\n            r zadd ztmp 2 b\n            r zadd ztmp 3 c\n            r zadd ztmp 4 d\n\n            assert_equal {d c b a} [r zrevrange ztmp 0 -1]\n            assert_equal {d c b} [r zrevrange ztmp 0 -2]\n            assert_equal {c b a} [r zrevrange ztmp 1 -1]\n            assert_equal {c b} [r zrevrange ztmp 1 -2]\n            assert_equal {b a} [r zrevrange ztmp -2 -1]\n            assert_equal {b} [r zrevrange ztmp -2 -2]\n\n            # out of range start index\n            assert_equal {d c b} [r zrevrange ztmp -5 2]\n            assert_equal {d c} [r zrevrange ztmp -5 1]\n            assert_equal {} [r zrevrange ztmp 5 -1]\n            assert_equal {} [r zrevrange ztmp 5 -2]\n\n            # out of range end index\n            assert_equal {d c b a} [r zrevrange ztmp 0 5]\n            assert_equal {c b a} [r zrevrange ztmp 1 5]\n            assert_equal {} [r zrevrange ztmp 0 -5]\n            assert_equal {} [r zrevrange ztmp 1 -5]\n\n            # withscores\n            assert_equal {d 4 c 3 b 2 a 1} [r zrevrange ztmp 0 -1 withscores]\n        }\n\n        test \"ZRANK/ZREVRANK basics - $encoding\" {\n            r del zranktmp\n            r zadd zranktmp 10 x\n            r zadd zranktmp 20 y\n            r zadd zranktmp 30 z\n            assert_equal 0 [r zrank zranktmp x]\n            assert_equal 1 [r zrank zranktmp y]\n            assert_equal 2 [r zrank zranktmp z]\n            assert_equal \"\" [r zrank zranktmp foo]\n            assert_equal 2 [r zrevrank zranktmp x]\n            assert_equal 1 [r zrevrank zranktmp y]\n            assert_equal 0 [r zrevrank zranktmp z]\n            assert_equal \"\" [r zrevrank zranktmp foo]\n        }\n\n        test \"ZRANK - after deletion - $encoding\" {\n            r zrem zranktmp y\n            assert_equal 0 [r zrank zranktmp x]\n            assert_equal 1 [r zrank zranktmp z]\n        }\n\n        test \"ZINCRBY - can create a new sorted set - $encoding\" {\n            r del zset\n            r zincrby zset 1 foo\n            assert_equal {foo} [r zrange zset 0 -1]\n            assert_equal 1 [r zscore zset foo]\n        }\n\n        test \"ZINCRBY - increment and decrement - $encoding\" {\n            r zincrby zset 2 foo\n            r zincrby zset 1 bar\n            assert_equal {bar foo} [r zrange zset 0 -1]\n\n            r zincrby zset 10 bar\n            r zincrby zset -5 foo\n            r zincrby zset -5 bar\n            assert_equal {foo bar} [r zrange zset 0 -1]\n\n            assert_equal -2 [r zscore zset foo]\n            assert_equal  6 [r zscore zset bar]\n        }\n\n        test \"ZINCRBY return value - $encoding\" {\n            r del ztmp\n            set retval [r zincrby ztmp 1.0 x]\n            assert {$retval == 1.0}\n        }\n\n        proc create_default_zset {} {\n            create_zset zset {-inf a 1 b 2 c 3 d 4 e 5 f +inf g}\n        }\n\n        test \"ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - $encoding\" {\n            create_default_zset\n\n            # inclusive range\n            assert_equal {a b c} [r zrangebyscore zset -inf 2]\n            assert_equal {b c d} [r zrangebyscore zset 0 3]\n            assert_equal {d e f} [r zrangebyscore zset 3 6]\n            assert_equal {e f g} [r zrangebyscore zset 4 +inf]\n            assert_equal {c b a} [r zrevrangebyscore zset 2 -inf]\n            assert_equal {d c b} [r zrevrangebyscore zset 3 0]\n            assert_equal {f e d} [r zrevrangebyscore zset 6 3]\n            assert_equal {g f e} [r zrevrangebyscore zset +inf 4]\n            assert_equal 3 [r zcount zset 0 3]\n\n            # exclusive range\n            assert_equal {b}   [r zrangebyscore zset (-inf (2]\n            assert_equal {b c} [r zrangebyscore zset (0 (3]\n            assert_equal {e f} [r zrangebyscore zset (3 (6]\n            assert_equal {f}   [r zrangebyscore zset (4 (+inf]\n            assert_equal {b}   [r zrevrangebyscore zset (2 (-inf]\n            assert_equal {c b} [r zrevrangebyscore zset (3 (0]\n            assert_equal {f e} [r zrevrangebyscore zset (6 (3]\n            assert_equal {f}   [r zrevrangebyscore zset (+inf (4]\n            assert_equal 2 [r zcount zset (0 (3]\n\n            # test empty ranges\n            r zrem zset a\n            r zrem zset g\n\n            # inclusive\n            assert_equal {} [r zrangebyscore zset 4 2]\n            assert_equal {} [r zrangebyscore zset 6 +inf]\n            assert_equal {} [r zrangebyscore zset -inf -6]\n            assert_equal {} [r zrevrangebyscore zset +inf 6]\n            assert_equal {} [r zrevrangebyscore zset -6 -inf]\n\n            # exclusive\n            assert_equal {} [r zrangebyscore zset (4 (2]\n            assert_equal {} [r zrangebyscore zset 2 (2]\n            assert_equal {} [r zrangebyscore zset (2 2]\n            assert_equal {} [r zrangebyscore zset (6 (+inf]\n            assert_equal {} [r zrangebyscore zset (-inf (-6]\n            assert_equal {} [r zrevrangebyscore zset (+inf (6]\n            assert_equal {} [r zrevrangebyscore zset (-6 (-inf]\n\n            # empty inner range\n            assert_equal {} [r zrangebyscore zset 2.4 2.6]\n            assert_equal {} [r zrangebyscore zset (2.4 2.6]\n            assert_equal {} [r zrangebyscore zset 2.4 (2.6]\n            assert_equal {} [r zrangebyscore zset (2.4 (2.6]\n        }\n\n        test \"ZRANGEBYSCORE with WITHSCORES - $encoding\" {\n            create_default_zset\n            assert_equal {b 1 c 2 d 3} [r zrangebyscore zset 0 3 withscores]\n            assert_equal {d 3 c 2 b 1} [r zrevrangebyscore zset 3 0 withscores]\n        }\n\n        test \"ZRANGEBYSCORE with LIMIT - $encoding\" {\n            create_default_zset\n            assert_equal {b c}   [r zrangebyscore zset 0 10 LIMIT 0 2]\n            assert_equal {d e f} [r zrangebyscore zset 0 10 LIMIT 2 3]\n            assert_equal {d e f} [r zrangebyscore zset 0 10 LIMIT 2 10]\n            assert_equal {}      [r zrangebyscore zset 0 10 LIMIT 20 10]\n            assert_equal {f e}   [r zrevrangebyscore zset 10 0 LIMIT 0 2]\n            assert_equal {d c b} [r zrevrangebyscore zset 10 0 LIMIT 2 3]\n            assert_equal {d c b} [r zrevrangebyscore zset 10 0 LIMIT 2 10]\n            assert_equal {}      [r zrevrangebyscore zset 10 0 LIMIT 20 10]\n        }\n\n        test \"ZRANGEBYSCORE with LIMIT and WITHSCORES - $encoding\" {\n            create_default_zset\n            assert_equal {e 4 f 5} [r zrangebyscore zset 2 5 LIMIT 2 3 WITHSCORES]\n            assert_equal {d 3 c 2} [r zrevrangebyscore zset 5 2 LIMIT 2 3 WITHSCORES]\n            assert_equal {} [r zrangebyscore zset 2 5 LIMIT 12 13 WITHSCORES]\n        }\n\n        test \"ZRANGEBYSCORE with non-value min or max - $encoding\" {\n            assert_error \"*not*float*\" {r zrangebyscore fooz str 1}\n            assert_error \"*not*float*\" {r zrangebyscore fooz 1 str}\n            assert_error \"*not*float*\" {r zrangebyscore fooz 1 NaN}\n        }\n\n        proc create_default_lex_zset {} {\n            create_zset zset {0 alpha 0 bar 0 cool 0 down\n                              0 elephant 0 foo 0 great 0 hill\n                              0 omega}\n        }\n\n        test \"ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - $encoding\" {\n            create_default_lex_zset\n\n            # inclusive range\n            assert_equal {alpha bar cool} [r zrangebylex zset - \\[cool]\n            assert_equal {bar cool down} [r zrangebylex zset \\[bar \\[down]\n            assert_equal {great hill omega} [r zrangebylex zset \\[g +]\n            assert_equal {cool bar alpha} [r zrevrangebylex zset \\[cool -]\n            assert_equal {down cool bar} [r zrevrangebylex zset \\[down \\[bar]\n            assert_equal {omega hill great foo elephant down} [r zrevrangebylex zset + \\[d]\n            assert_equal 3 [r zlexcount zset \\[ele \\[h]\n\n            # exclusive range\n            assert_equal {alpha bar} [r zrangebylex zset - (cool]\n            assert_equal {cool} [r zrangebylex zset (bar (down]\n            assert_equal {hill omega} [r zrangebylex zset (great +]\n            assert_equal {bar alpha} [r zrevrangebylex zset (cool -]\n            assert_equal {cool} [r zrevrangebylex zset (down (bar]\n            assert_equal {omega hill} [r zrevrangebylex zset + (great]\n            assert_equal 2 [r zlexcount zset (ele (great]\n\n            # inclusive and exclusive\n            assert_equal {} [r zrangebylex zset (az (b]\n            assert_equal {} [r zrangebylex zset (z +]\n            assert_equal {} [r zrangebylex zset - \\[aaaa]\n            assert_equal {} [r zrevrangebylex zset \\[elez \\[elex]\n            assert_equal {} [r zrevrangebylex zset (hill (omega]\n        }\n\n        test \"ZLEXCOUNT advanced - $encoding\" {\n            create_default_lex_zset\n\n            assert_equal 9 [r zlexcount zset - +]\n            assert_equal 0 [r zlexcount zset + -]\n            assert_equal 0 [r zlexcount zset + \\[c]\n            assert_equal 0 [r zlexcount zset \\[c -]\n            assert_equal 8 [r zlexcount zset \\[bar +]\n            assert_equal 5 [r zlexcount zset \\[bar \\[foo]\n            assert_equal 4 [r zlexcount zset \\[bar (foo]\n            assert_equal 4 [r zlexcount zset (bar \\[foo]\n            assert_equal 3 [r zlexcount zset (bar (foo]\n            assert_equal 5 [r zlexcount zset - (foo]\n            assert_equal 1 [r zlexcount zset (maxstring +]\n        }\n\n        test \"ZRANGEBYSLEX with LIMIT - $encoding\" {\n            create_default_lex_zset\n            assert_equal {alpha bar} [r zrangebylex zset - \\[cool LIMIT 0 2]\n            assert_equal {bar cool} [r zrangebylex zset - \\[cool LIMIT 1 2]\n            assert_equal {} [r zrangebylex zset \\[bar \\[down LIMIT 0 0]\n            assert_equal {} [r zrangebylex zset \\[bar \\[down LIMIT 2 0]\n            assert_equal {bar} [r zrangebylex zset \\[bar \\[down LIMIT 0 1]\n            assert_equal {cool} [r zrangebylex zset \\[bar \\[down LIMIT 1 1]\n            assert_equal {bar cool down} [r zrangebylex zset \\[bar \\[down LIMIT 0 100]\n            assert_equal {omega hill great foo elephant} [r zrevrangebylex zset + \\[d LIMIT 0 5]\n            assert_equal {omega hill great foo} [r zrevrangebylex zset + \\[d LIMIT 0 4]\n        }\n\n        test \"ZRANGEBYLEX with invalid lex range specifiers - $encoding\" {\n            assert_error \"*not*string*\" {r zrangebylex fooz foo bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz \\[foo bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz foo \\[bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz +x \\[bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz -x \\[bar}\n        }\n\n        test \"ZREMRANGEBYSCORE basics - $encoding\" {\n            proc remrangebyscore {min max} {\n                create_zset zset {1 a 2 b 3 c 4 d 5 e}\n                assert_equal 1 [r exists zset]\n                r zremrangebyscore zset $min $max\n            }\n\n            # inner range\n            assert_equal 3 [remrangebyscore 2 4]\n            assert_equal {a e} [r zrange zset 0 -1]\n\n            # start underflow\n            assert_equal 1 [remrangebyscore -10 1]\n            assert_equal {b c d e} [r zrange zset 0 -1]\n\n            # end overflow\n            assert_equal 1 [remrangebyscore 5 10]\n            assert_equal {a b c d} [r zrange zset 0 -1]\n\n            # switch min and max\n            assert_equal 0 [remrangebyscore 4 2]\n            assert_equal {a b c d e} [r zrange zset 0 -1]\n\n            # -inf to mid\n            assert_equal 3 [remrangebyscore -inf 3]\n            assert_equal {d e} [r zrange zset 0 -1]\n\n            # mid to +inf\n            assert_equal 3 [remrangebyscore 3 +inf]\n            assert_equal {a b} [r zrange zset 0 -1]\n\n            # -inf to +inf\n            assert_equal 5 [remrangebyscore -inf +inf]\n            assert_equal {} [r zrange zset 0 -1]\n\n            # exclusive min\n            assert_equal 4 [remrangebyscore (1 5]\n            assert_equal {a} [r zrange zset 0 -1]\n            assert_equal 3 [remrangebyscore (2 5]\n            assert_equal {a b} [r zrange zset 0 -1]\n\n            # exclusive max\n            assert_equal 4 [remrangebyscore 1 (5]\n            assert_equal {e} [r zrange zset 0 -1]\n            assert_equal 3 [remrangebyscore 1 (4]\n            assert_equal {d e} [r zrange zset 0 -1]\n\n            # exclusive min and max\n            assert_equal 3 [remrangebyscore (1 (5]\n            assert_equal {a e} [r zrange zset 0 -1]\n\n            # destroy when empty\n            assert_equal 5 [remrangebyscore 1 5]\n            assert_equal 0 [r exists zset]\n        }\n\n        test \"ZREMRANGEBYSCORE with non-value min or max - $encoding\" {\n            assert_error \"*not*float*\" {r zremrangebyscore fooz str 1}\n            assert_error \"*not*float*\" {r zremrangebyscore fooz 1 str}\n            assert_error \"*not*float*\" {r zremrangebyscore fooz 1 NaN}\n        }\n\n        test \"ZREMRANGEBYRANK basics - $encoding\" {\n            proc remrangebyrank {min max} {\n                create_zset zset {1 a 2 b 3 c 4 d 5 e}\n                assert_equal 1 [r exists zset]\n                r zremrangebyrank zset $min $max\n            }\n\n            # inner range\n            assert_equal 3 [remrangebyrank 1 3]\n            assert_equal {a e} [r zrange zset 0 -1]\n\n            # start underflow\n            assert_equal 1 [remrangebyrank -10 0]\n            assert_equal {b c d e} [r zrange zset 0 -1]\n\n            # start overflow\n            assert_equal 0 [remrangebyrank 10 -1]\n            assert_equal {a b c d e} [r zrange zset 0 -1]\n\n            # end underflow\n            assert_equal 0 [remrangebyrank 0 -10]\n            assert_equal {a b c d e} [r zrange zset 0 -1]\n\n            # end overflow\n            assert_equal 5 [remrangebyrank 0 10]\n            assert_equal {} [r zrange zset 0 -1]\n\n            # destroy when empty\n            assert_equal 5 [remrangebyrank 0 4]\n            assert_equal 0 [r exists zset]\n        }\n\n        test \"ZUNIONSTORE against non-existing key doesn't set destination - $encoding\" {\n            r del zseta{t}\n            assert_equal 0 [r zunionstore dst_key{t} 1 zseta{t}]\n            assert_equal 0 [r exists dst_key{t}]\n        }\n\n        test \"ZUNION/ZINTER/ZINTERCARD/ZDIFF against non-existing key - $encoding\" {\n            r del zseta\n            assert_equal {} [r zunion 1 zseta]\n            assert_equal {} [r zinter 1 zseta]\n            assert_equal 0 [r zintercard 1 zseta]\n            assert_equal 0 [r zintercard 1 zseta limit 0]\n            assert_equal {} [r zdiff 1 zseta]\n        }\n\n        test \"ZUNIONSTORE with empty set - $encoding\" {\n            r del zseta{t} zsetb{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zunionstore zsetc{t} 2 zseta{t} zsetb{t}\n            r zrange zsetc{t} 0 -1 withscores\n        } {a 1 b 2}\n\n        test \"ZUNION/ZINTER/ZINTERCARD/ZDIFF with empty set - $encoding\" {\n            r del zseta{t} zsetb{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            assert_equal {a 1 b 2} [r zunion 2 zseta{t} zsetb{t} withscores]\n            assert_equal {} [r zinter 2 zseta{t} zsetb{t} withscores]\n            assert_equal 0 [r zintercard 2 zseta{t} zsetb{t}]\n            assert_equal 0 [r zintercard 2 zseta{t} zsetb{t} limit 0]\n            assert_equal {a 1 b 2} [r zdiff 2 zseta{t} zsetb{t} withscores]\n        }\n\n        test \"ZUNIONSTORE basics - $encoding\" {\n            r del zseta{t} zsetb{t} zsetc{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zadd zseta{t} 3 c\n            r zadd zsetb{t} 1 b\n            r zadd zsetb{t} 2 c\n            r zadd zsetb{t} 3 d\n\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {a 1 b 3 d 3 c 5} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION/ZINTER/ZINTERCARD/ZDIFF with integer members - $encoding\" {\n            r del zsetd{t} zsetf{t}\n            r zadd zsetd{t} 1 1\n            r zadd zsetd{t} 2 2\n            r zadd zsetd{t} 3 3\n            r zadd zsetf{t} 1 1\n            r zadd zsetf{t} 3 3\n            r zadd zsetf{t} 4 4\n\n            assert_equal {1 2 2 2 4 4 3 6} [r zunion 2 zsetd{t} zsetf{t} withscores]\n            assert_equal {1 2 3 6} [r zinter 2 zsetd{t} zsetf{t} withscores]\n            assert_equal 2 [r zintercard 2 zsetd{t} zsetf{t}]\n            assert_equal 2 [r zintercard 2 zsetd{t} zsetf{t} limit 0]\n            assert_equal {2 2} [r zdiff 2 zsetd{t} zsetf{t} withscores]\n        }\n\n        test \"ZUNIONSTORE with weights - $encoding\" {\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t} weights 2 3]\n            assert_equal {a 2 b 7 d 9 c 12} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION with weights - $encoding\" {\n            assert_equal {a 2 b 7 d 9 c 12} [r zunion 2 zseta{t} zsetb{t} weights 2 3 withscores]\n            assert_equal {b 7 c 12} [r zinter 2 zseta{t} zsetb{t} weights 2 3 withscores]\n        }\n\n        test \"ZUNIONSTORE with a regular set and weights - $encoding\" {\n            r del seta{t}\n            r sadd seta{t} a\n            r sadd seta{t} b\n            r sadd seta{t} c\n\n            assert_equal 4 [r zunionstore zsetc{t} 2 seta{t} zsetb{t} weights 2 3]\n            assert_equal {a 2 b 5 c 8 d 9} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNIONSTORE with AGGREGATE MIN - $encoding\" {\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t} aggregate min]\n            assert_equal {a 1 b 1 c 2 d 3} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION/ZINTER with AGGREGATE MIN - $encoding\" {\n            assert_equal {a 1 b 1 c 2 d 3} [r zunion 2 zseta{t} zsetb{t} aggregate min withscores]\n            assert_equal {b 1 c 2} [r zinter 2 zseta{t} zsetb{t} aggregate min withscores]\n        }\n\n        test \"ZUNIONSTORE with AGGREGATE MAX - $encoding\" {\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t} aggregate max]\n            assert_equal {a 1 b 2 c 3 d 3} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION/ZINTER with AGGREGATE MAX - $encoding\" {\n            assert_equal {a 1 b 2 c 3 d 3} [r zunion 2 zseta{t} zsetb{t} aggregate max withscores]\n            assert_equal {b 2 c 3} [r zinter 2 zseta{t} zsetb{t} aggregate max withscores]\n        }\n\n        test \"ZINTERSTORE basics - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {b 3 c 5} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTER basics - $encoding\" {\n            assert_equal {b 3 c 5} [r zinter 2 zseta{t} zsetb{t} withscores]\n        }\n\n        test \"ZINTERCARD with illegal arguments\" {\n            assert_error \"ERR syntax error*\" {r zintercard 1 zseta{t} zseta{t}}\n            assert_error \"ERR syntax error*\" {r zintercard 1 zseta{t} bar_arg}\n            assert_error \"ERR syntax error*\" {r zintercard 1 zseta{t} LIMIT}\n\n            assert_error \"ERR LIMIT*\" {r zintercard 1 myset{t} LIMIT -1}\n            assert_error \"ERR LIMIT*\" {r zintercard 1 myset{t} LIMIT a}\n        }\n\n        test \"ZINTERCARD basics - $encoding\" {\n            assert_equal 2 [r zintercard 2 zseta{t} zsetb{t}]\n            assert_equal 2 [r zintercard 2 zseta{t} zsetb{t} limit 0]\n            assert_equal 1 [r zintercard 2 zseta{t} zsetb{t} limit 1]\n            assert_equal 2 [r zintercard 2 zseta{t} zsetb{t} limit 10]\n        }\n\n        test \"ZINTER RESP3 - $encoding\" {\n            r hello 3\n            assert_equal {{b 3.0} {c 5.0}} [r zinter 2 zseta{t} zsetb{t} withscores]\n            r hello 2\n        }\n\n        test \"ZINTERSTORE with weights - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t} weights 2 3]\n            assert_equal {b 7 c 12} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTER with weights - $encoding\" {\n            assert_equal {b 7 c 12} [r zinter 2 zseta{t} zsetb{t} weights 2 3 withscores]\n        }\n\n        test \"ZINTERSTORE with a regular set and weights - $encoding\" {\n            r del seta{t}\n            r sadd seta{t} a\n            r sadd seta{t} b\n            r sadd seta{t} c\n            assert_equal 2 [r zinterstore zsetc{t} 2 seta{t} zsetb{t} weights 2 3]\n            assert_equal {b 5 c 8} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTERSTORE with AGGREGATE MIN - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t} aggregate min]\n            assert_equal {b 1 c 2} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTERSTORE with AGGREGATE MAX - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t} aggregate max]\n            assert_equal {b 2 c 3} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        foreach cmd {ZUNIONSTORE ZINTERSTORE} {\n            test \"$cmd with +inf/-inf scores - $encoding\" {\n                r del zsetinf1{t} zsetinf2{t}\n\n                r zadd zsetinf1{t} +inf key\n                r zadd zsetinf2{t} +inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal inf [r zscore zsetinf3{t} key]\n\n                r zadd zsetinf1{t} -inf key\n                r zadd zsetinf2{t} +inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal 0 [r zscore zsetinf3{t} key]\n\n                r zadd zsetinf1{t} +inf key\n                r zadd zsetinf2{t} -inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal 0 [r zscore zsetinf3{t} key]\n\n                r zadd zsetinf1{t} -inf key\n                r zadd zsetinf2{t} -inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal -inf [r zscore zsetinf3{t} key]\n            }\n\n            test \"$cmd with NaN weights - $encoding\" {\n                r del zsetinf1{t} zsetinf2{t}\n\n                r zadd zsetinf1{t} 1.0 key\n                r zadd zsetinf2{t} 1.0 key\n                assert_error \"*weight*not*float*\" {\n                    r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t} weights nan nan\n                }\n            }\n        }\n\n        test \"ZDIFFSTORE basics - $encoding\" {\n            assert_equal 1 [r zdiffstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {a 1} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF basics - $encoding\" {\n            assert_equal {a 1} [r zdiff 2 zseta{t} zsetb{t} withscores]\n        }\n\n        test \"ZDIFFSTORE with a regular set - $encoding\" {\n            r del seta{t}\n            r sadd seta{t} a\n            r sadd seta{t} b\n            r sadd seta{t} c\n            assert_equal 1 [r zdiffstore zsetc{t} 2 seta{t} zsetb{t}]\n            assert_equal {a 1} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF subtracting set from itself - $encoding\" {\n            assert_equal 0 [r zdiffstore zsetc{t} 2 zseta{t} zseta{t}]\n            assert_equal {} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF algorithm 1 - $encoding\" {\n            r del zseta{t} zsetb{t} zsetc{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zadd zseta{t} 3 c\n            r zadd zsetb{t} 1 b\n            r zadd zsetb{t} 2 c\n            r zadd zsetb{t} 3 d\n            assert_equal 1 [r zdiffstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {a 1} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF algorithm 2 - $encoding\" {\n            r del zseta{t} zsetb{t} zsetc{t} zsetd{t} zsete{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zadd zseta{t} 3 c\n            r zadd zseta{t} 5 e\n            r zadd zsetb{t} 1 b\n            r zadd zsetc{t} 1 c\n            r zadd zsetd{t} 1 d\n            assert_equal 2 [r zdiffstore zsete{t} 4 zseta{t} zsetb{t} zsetc{t} zsetd{t}]\n            assert_equal {a 1 e 5} [r zrange zsete{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF fuzzing - $encoding\" {\n            for {set j 0} {$j < 100} {incr j} {\n                unset -nocomplain s\n                array set s {}\n                set args {}\n                set num_sets [expr {[randomInt 10]+1}]\n                for {set i 0} {$i < $num_sets} {incr i} {\n                    set num_elements [randomInt 100]\n                    r del zset_$i{t}\n                    lappend args zset_$i{t}\n                    while {$num_elements} {\n                        set ele [randomValue]\n                        r zadd zset_$i{t} [randomInt 100] $ele\n                        if {$i == 0} {\n                            set s($ele) x\n                        } else {\n                            unset -nocomplain s($ele)\n                        }\n                        incr num_elements -1\n                    }\n                }\n                set result [lsort [r zdiff [llength $args] {*}$args]]\n                assert_equal $result [lsort [array names s]]\n            }\n        }\n\n        foreach {pop} {ZPOPMIN ZPOPMAX} {\n            test \"$pop with the count 0 returns an empty array\" {\n                r del zset\n                r zadd zset 1 a 2 b 3 c\n                assert_equal {} [r $pop zset 0]\n\n                # Make sure we can distinguish between an empty array and a null response\n                r readraw 1\n                assert_equal {*0} [r $pop zset 0]\n                r readraw 0\n\n                assert_equal 3 [r zcard zset]\n            }\n\n            test \"$pop with negative count\" {\n                r set zset foo\n                assert_error \"ERR *must be positive\" {r $pop zset -1}\n\n                r del zset\n                assert_error \"ERR *must be positive\" {r $pop zset -2}\n\n                r zadd zset 1 a 2 b 3 c\n                assert_error \"ERR *must be positive\" {r $pop zset -3}\n            }\n        }\n\n    foreach {popmin popmax} {ZPOPMIN ZPOPMAX ZMPOP_MIN ZMPOP_MAX} {\n        test \"Basic $popmin/$popmax with a single key - $encoding\" {\n            r del zset\n            verify_zpop_response r $popmin zset 0 {} {}\n\n            create_zset zset {-1 a 1 b 2 c 3 d 4 e}\n            verify_zpop_response r $popmin zset 0 {a -1} {zset {{a -1}}}\n            verify_zpop_response r $popmin zset 0 {b 1} {zset {{b 1}}}\n            verify_zpop_response r $popmax zset 0 {e 4} {zset {{e 4}}}\n            verify_zpop_response r $popmax zset 0 {d 3} {zset {{d 3}}}\n            verify_zpop_response r $popmin zset 0 {c 2} {zset {{c 2}}}\n            assert_equal 0 [r exists zset]\n        }\n\n        test \"$popmin/$popmax with count - $encoding\" {\n            r del z1\n            verify_zpop_response r $popmin z1 2 {} {}\n\n            create_zset z1 {0 a 1 b 2 c 3 d}\n            verify_zpop_response r $popmin z1 2 {a 0 b 1} {z1 {{a 0} {b 1}}}\n            verify_zpop_response r $popmax z1 2 {d 3 c 2} {z1 {{d 3} {c 2}}}\n        }\n    }\n\n    foreach {popmin popmax} {BZPOPMIN BZPOPMAX BZMPOP_MIN BZMPOP_MAX} {\n        test \"$popmin/$popmax with a single existing sorted set - $encoding\" {\n            set rd [redis_deferring_client]\n            create_zset zset {0 a 1 b 2 c 3 d}\n\n            verify_bzpop_response $rd $popmin zset 5 0 {zset a 0} {zset {{a 0}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset d 3} {zset {{d 3}}}\n            verify_bzpop_response $rd $popmin zset 5 0 {zset b 1} {zset {{b 1}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset c 2} {zset {{c 2}}}\n            assert_equal 0 [r exists zset]\n            $rd close\n        }\n\n        test \"$popmin/$popmax with multiple existing sorted sets - $encoding\" {\n            set rd [redis_deferring_client]\n            create_zset z1{t} {0 a 1 b 2 c}\n            create_zset z2{t} {3 d 4 e 5 f}\n\n            verify_bzpop_two_key_response $rd $popmin z1{t} z2{t} 5 0 {z1{t} a 0} {z1{t} {{a 0}}}\n            verify_bzpop_two_key_response $rd $popmax z1{t} z2{t} 5 0 {z1{t} c 2} {z1{t} {{c 2}}}\n            assert_equal 1 [r zcard z1{t}]\n            assert_equal 3 [r zcard z2{t}]\n\n            verify_bzpop_two_key_response $rd $popmax z2{t} z1{t} 5 0 {z2{t} f 5} {z2{t} {{f 5}}}\n            verify_bzpop_two_key_response $rd $popmin z2{t} z1{t} 5 0 {z2{t} d 3} {z2{t} {{d 3}}}\n            assert_equal 1 [r zcard z1{t}]\n            assert_equal 1 [r zcard z2{t}]\n            $rd close\n        }\n\n        test \"$popmin/$popmax second sorted set has members - $encoding\" {\n            set rd [redis_deferring_client]\n            r del z1{t}\n            create_zset z2{t} {3 d 4 e 5 f}\n\n            verify_bzpop_two_key_response $rd $popmax z1{t} z2{t} 5 0 {z2{t} f 5} {z2{t} {{f 5}}}\n            verify_bzpop_two_key_response $rd $popmin z1{t} z2{t} 5 0 {z2{t} d 3} {z2{t} {{d 3}}}\n            assert_equal 0 [r zcard z1{t}]\n            assert_equal 1 [r zcard z2{t}]\n            $rd close\n        }\n    }\n\n    foreach {popmin popmax} {ZPOPMIN ZPOPMAX ZMPOP_MIN ZMPOP_MAX} {\n        test \"Basic $popmin/$popmax - $encoding RESP3\" {\n            r hello 3\n            create_zset z1 {0 a 1 b 2 c 3 d}\n            verify_zpop_response r $popmin z1 0 {a 0.0} {z1 {{a 0.0}}}\n            verify_zpop_response r $popmax z1 0 {d 3.0} {z1 {{d 3.0}}}\n            r hello 2\n        }\n\n        test \"$popmin/$popmax with count - $encoding RESP3\" {\n            r hello 3\n            create_zset z1 {0 a 1 b 2 c 3 d}\n            verify_zpop_response r $popmin z1 2 {{a 0.0} {b 1.0}} {z1 {{a 0.0} {b 1.0}}}\n            verify_zpop_response r $popmax z1 2 {{d 3.0} {c 2.0}} {z1 {{d 3.0} {c 2.0}}}\n            r hello 2\n        }\n    }\n\n    foreach {popmin popmax} {BZPOPMIN BZPOPMAX BZMPOP_MIN BZMPOP_MAX} {\n        test \"$popmin/$popmax - $encoding RESP3\" {\n            r hello 3\n            set rd [redis_deferring_client]\n            create_zset zset {0 a 1 b 2 c 3 d}\n\n            verify_bzpop_response $rd $popmin zset 5 0 {zset a 0} {zset {{a 0}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset d 3} {zset {{d 3}}}\n            verify_bzpop_response $rd $popmin zset 5 0 {zset b 1} {zset {{b 1}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset c 2} {zset {{c 2}}}\n\n            assert_equal 0 [r exists zset]\n            r hello 2\n            $rd close\n        }\n    }\n\n        r config set zset-max-ziplist-entries $original_max_entries\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    basics listpack\n    basics skiplist\n\n    test \"ZPOP/ZMPOP against wrong type\" {\n        r set foo{t} bar\n        assert_error \"*WRONGTYPE*\" {r zpopmin foo{t}}\n        assert_error \"*WRONGTYPE*\" {r zpopmin foo{t} 0}\n        assert_error \"*WRONGTYPE*\" {r zpopmax foo{t}}\n        assert_error \"*WRONGTYPE*\" {r zpopmax foo{t} 0}\n        assert_error \"*WRONGTYPE*\" {r zpopmin foo{t} 2}\n\n        assert_error \"*WRONGTYPE*\" {r zmpop 1 foo{t} min}\n        assert_error \"*WRONGTYPE*\" {r zmpop 1 foo{t} max}\n        assert_error \"*WRONGTYPE*\" {r zmpop 1 foo{t} max count 200}\n\n        r del foo{t}\n        r set foo2{t} bar\n        assert_error \"*WRONGTYPE*\" {r zmpop 2 foo{t} foo2{t} min}\n        assert_error \"*WRONGTYPE*\" {r zmpop 2 foo2{t} foo1{t} max count 1}\n    }\n\n    test \"ZMPOP with illegal argument\" {\n        assert_error \"ERR wrong number of arguments for 'zmpop' command\" {r zmpop}\n        assert_error \"ERR wrong number of arguments for 'zmpop' command\" {r zmpop 1}\n        assert_error \"ERR wrong number of arguments for 'zmpop' command\" {r zmpop 1 myzset{t}}\n\n        assert_error \"ERR numkeys*\" {r zmpop 0 myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r zmpop a myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r zmpop -1 myzset{t} MAX}\n\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} bad_where}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} MIN bar_arg}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} MAX MIN}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} COUNT}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} MAX COUNT 1 COUNT 2}\n        assert_error \"ERR syntax error*\" {r zmpop 2 myzset{t} myzset2{t} bad_arg}\n\n        assert_error \"ERR count*\" {r zmpop 1 myzset{t} MIN COUNT 0}\n        assert_error \"ERR count*\" {r zmpop 1 myzset{t} MAX COUNT a}\n        assert_error \"ERR count*\" {r zmpop 1 myzset{t} MIN COUNT -1}\n        assert_error \"ERR count*\" {r zmpop 2 myzset{t} myzset2{t} MAX COUNT -1}\n    }\n\n    test \"ZMPOP propagate as pop with count command to replica\" {\n        set repl [attach_to_replication_stream]\n\n        # ZMPOP min/max propagate as ZPOPMIN/ZPOPMAX with count\n        r zadd myzset{t} 1 one 2 two 3 three\n\n        # Pop elements from one zset.\n        r zmpop 1 myzset{t} min\n        r zmpop 1 myzset{t} max count 1\n\n        # Now the zset have only one element\n        r zmpop 2 myzset{t} myzset2{t} min count 10\n\n        # No elements so we don't propagate.\n        r zmpop 2 myzset{t} myzset2{t} max count 10\n\n        # Pop elements from the second zset.\n        r zadd myzset2{t} 1 one 2 two 3 three\n        r zmpop 2 myzset{t} myzset2{t} min count 2\n        r zmpop 2 myzset{t} myzset2{t} max count 1\n\n        # Pop all elements.\n        r zadd myzset{t} 1 one 2 two 3 three\n        r zadd myzset2{t} 4 four 5 five 6 six\n        r zmpop 2 myzset{t} myzset2{t} min count 10\n        r zmpop 2 myzset{t} myzset2{t} max count 10\n\n        assert_replication_stream $repl {\n            {select *}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zpopmin myzset{t} 1}\n            {zpopmax myzset{t} 1}\n            {zpopmin myzset{t} 1}\n            {zadd myzset2{t} 1 one 2 two 3 three}\n            {zpopmin myzset2{t} 2}\n            {zpopmax myzset2{t} 1}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zadd myzset2{t} 4 four 5 five 6 six}\n            {zpopmin myzset{t} 3}\n            {zpopmax myzset2{t} 3}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    foreach resp {3 2} {\n        set rd [redis_deferring_client]\n\n        if {[lsearch $::denytags \"resp3\"] >= 0} {\n            if {$resp == 3} {continue}\n        } else {\n            r hello $resp\n            $rd hello $resp\n            $rd read\n        }\n\n        test \"ZPOPMIN/ZPOPMAX readraw in RESP$resp\" {\n            r del zset{t}\n            create_zset zset2{t} {1 a 2 b 3 c 4 d 5 e}\n\n            r readraw 1\n\n            # ZPOP against non existing key.\n            assert_equal {*0} [r zpopmin zset{t}]\n            assert_equal {*0} [r zpopmin zset{t} 1]\n\n            # ZPOP without COUNT option.\n            assert_equal {*2} [r zpopmin zset2{t}]\n            assert_equal [r read] {$1}\n            assert_equal [r read] {a}\n            verify_score_response r $resp 1\n\n            # ZPOP with COUNT option.\n            if {$resp == 2} {\n                assert_equal {*2} [r zpopmax zset2{t} 1]\n                assert_equal [r read] {$1}\n                assert_equal [r read] {e}\n            } elseif {$resp == 3} {\n                assert_equal {*1} [r zpopmax zset2{t} 1]\n                assert_equal [r read] {*2}\n                assert_equal [r read] {$1}\n                assert_equal [r read] {e}\n            }\n            verify_score_response r $resp 5\n\n            r readraw 0\n        }\n\n        test \"BZPOPMIN/BZPOPMAX readraw in RESP$resp\" {\n            r del zset{t}\n            create_zset zset2{t} {1 a 2 b 3 c 4 d 5 e}\n\n            $rd readraw 1\n\n            # BZPOP released on timeout.\n            $rd bzpopmin zset{t} 0.01\n            verify_nil_response $resp [$rd read]\n            $rd bzpopmax zset{t} 0.01\n            verify_nil_response $resp [$rd read]\n\n            # BZPOP non-blocking path.\n            $rd bzpopmin zset1{t} zset2{t} 0.1\n            assert_equal [$rd read] {*3}\n            assert_equal [$rd read] {$8}\n            assert_equal [$rd read] {zset2{t}}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {a}\n            verify_score_response $rd $resp 1\n\n            # BZPOP blocking path.\n            $rd bzpopmin zset{t} 5\n            wait_for_blocked_client\n            r zadd zset{t} 1 a\n            assert_equal [$rd read] {*3}\n            assert_equal [$rd read] {$7}\n            assert_equal [$rd read] {zset{t}}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {a}\n            verify_score_response $rd $resp 1\n\n            $rd readraw 0\n        }\n\n        test \"ZMPOP readraw in RESP$resp\" {\n            r del zset{t} zset2{t}\n            create_zset zset3{t} {1 a}\n            create_zset zset4{t} {1 a 2 b 3 c 4 d 5 e}\n\n            r readraw 1\n\n            # ZMPOP against non existing key.\n            verify_nil_response $resp [r zmpop 1 zset{t} min]\n            verify_nil_response $resp [r zmpop 1 zset{t} max count 1]\n            verify_nil_response $resp [r zmpop 2 zset{t} zset2{t} min]\n            verify_nil_response $resp [r zmpop 2 zset{t} zset2{t} max count 1]\n\n            # ZMPOP with one input key.\n            assert_equal {*2} [r zmpop 1 zset3{t} max]\n            assert_equal [r read] {$8}\n            assert_equal [r read] {zset3{t}}\n            assert_equal [r read] {*1}\n            assert_equal [r read] {*2}\n            assert_equal [r read] {$1}\n            assert_equal [r read] {a}\n            verify_score_response r $resp 1\n\n            # ZMPOP with COUNT option.\n            assert_equal {*2} [r zmpop 2 zset3{t} zset4{t} min count 2]\n            assert_equal [r read] {$8}\n            assert_equal [r read] {zset4{t}}\n            assert_equal [r read] {*2}\n            assert_equal [r read] {*2}\n            assert_equal [r read] {$1}\n            assert_equal [r read] {a}\n            verify_score_response r $resp 1\n            assert_equal [r read] {*2}\n            assert_equal [r read] {$1}\n            assert_equal [r read] {b}\n            verify_score_response r $resp 2\n\n            r readraw 0\n        }\n\n        test \"BZMPOP readraw in RESP$resp\" {\n            r del zset{t} zset2{t}\n            create_zset zset3{t} {1 a 2 b 3 c 4 d 5 e}\n\n            $rd readraw 1\n\n            # BZMPOP released on timeout.\n            $rd bzmpop 0.01 1 zset{t} min\n            verify_nil_response $resp [$rd read]\n            $rd bzmpop 0.01 2 zset{t} zset2{t} max\n            verify_nil_response $resp [$rd read]\n\n            # BZMPOP non-blocking path.\n            $rd bzmpop 0.1 2 zset3{t} zset4{t} min\n\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$8}\n            assert_equal [$rd read] {zset3{t}}\n            assert_equal [$rd read] {*1}\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {a}\n            verify_score_response $rd $resp 1\n\n            # BZMPOP blocking path with COUNT option.\n            $rd bzmpop 5 2 zset{t} zset2{t} max count 2\n            wait_for_blocked_client\n            r zadd zset2{t} 1 a 2 b 3 c\n\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$8}\n            assert_equal [$rd read] {zset2{t}}\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {c}\n            verify_score_response $rd $resp 3\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {b}\n            verify_score_response $rd $resp 2\n\n        }\n\n        $rd close\n    }\n\n    test {ZINTERSTORE regression with two sets, intset+hashtable} {\n        r del seta{t} setb{t} setc{t}\n        r sadd set1{t} a\n        r sadd set2{t} 10\n        r zinterstore set3{t} 2 set1{t} set2{t}\n    } {0}\n\n    test {ZUNIONSTORE regression, should not create NaN in scores} {\n        r zadd z{t} -inf neginf\n        r zunionstore out{t} 1 z{t} weights 0\n        r zrange out{t} 0 -1 withscores\n    } {neginf 0}\n\n    test {ZINTERSTORE #516 regression, mixed sets and ziplist zsets} {\n        r sadd one{t} 100 101 102 103\n        r sadd two{t} 100 200 201 202\n        r zadd three{t} 1 500 1 501 1 502 1 503 1 100\n        r zinterstore to_here{t} 3 one{t} two{t} three{t} WEIGHTS 0 0 1\n        r zrange to_here{t} 0 -1\n    } {100}\n\n    test {ZUNIONSTORE result is sorted} {\n        # Create two sets with common and not common elements, perform\n        # the UNION, check that elements are still sorted.\n        r del one{t} two{t} dest{t}\n        set cmd1 [list r zadd one{t}]\n        set cmd2 [list r zadd two{t}]\n        for {set j 0} {$j < 1000} {incr j} {\n            lappend cmd1 [expr rand()] [randomInt 1000]\n            lappend cmd2 [expr rand()] [randomInt 1000]\n        }\n        {*}$cmd1\n        {*}$cmd2\n        assert {[r zcard one{t}] > 100}\n        assert {[r zcard two{t}] > 100}\n        r zunionstore dest{t} 2 one{t} two{t}\n        set oldscore 0\n        foreach {ele score} [r zrange dest{t} 0 -1 withscores] {\n            assert {$score >= $oldscore}\n            set oldscore $score\n        }\n    }\n\n    test \"ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE error if using WITHSCORES \" {\n        assert_error \"*ERR*syntax*\" {r zunionstore foo{t} 2 zsetd{t} zsetf{t} withscores}\n        assert_error \"*ERR*syntax*\" {r zinterstore foo{t} 2 zsetd{t} zsetf{t} withscores}\n        assert_error \"*ERR*syntax*\" {r zdiffstore foo{t} 2 zsetd{t} zsetf{t} withscores}\n    }\n\n    test {ZMSCORE retrieve} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n\n        r zmscore zmscoretest x y\n    } {10 20}\n\n    test {ZMSCORE retrieve from empty set} {\n        r del zmscoretest\n\n        r zmscore zmscoretest x y\n    } {{} {}}\n\n    test {ZMSCORE retrieve with missing member} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n\n        r zmscore zmscoretest x y\n    } {10 {}}\n\n    test {ZMSCORE retrieve single member} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n\n        r zmscore zmscoretest x\n    } {10}\n\n    test {ZMSCORE retrieve requires one or more members} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n\n        catch {r zmscore zmscoretest} e\n        assert_match {*ERR*wrong*number*arg*} $e\n    }\n\n    test \"ZSET commands don't accept the empty strings as valid score\" {\n        assert_error \"*not*float*\" {r zadd myzset \"\" abc}\n    }\n\n    test \"zunionInterDiffGenericCommand at least 1 input key\" {\n        assert_error {*at least 1 input key * 'zunion' command} {r zunion 0 key{t}}\n        assert_error {*at least 1 input key * 'zunionstore' command} {r zunionstore dst_key{t} 0 key{t}}\n        assert_error {*at least 1 input key * 'zinter' command} {r zinter 0 key{t}}\n        assert_error {*at least 1 input key * 'zinterstore' command} {r zinterstore dst_key{t} 0 key{t}}\n        assert_error {*at least 1 input key * 'zdiff' command} {r zdiff 0 key{t}}\n        assert_error {*at least 1 input key * 'zdiffstore' command} {r zdiffstore dst_key{t} 0 key{t}}\n        assert_error {*at least 1 input key * 'zintercard' command} {r zintercard 0 key{t}}\n    }\n\n    proc stressers {encoding} {\n        set original_max_entries [lindex [r config get zset-max-ziplist-entries] 1]\n        set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n        if {$encoding == \"listpack\"} {\n            # Little extra to allow proper fuzzing in the sorting stresser\n            r config set zset-max-ziplist-entries 256\n            r config set zset-max-ziplist-value 64\n            set elements 128\n        } elseif {$encoding == \"skiplist\"} {\n            r config set zset-max-ziplist-entries 0\n            r config set zset-max-ziplist-value 0\n            if {$::accurate} {set elements 1000} else {set elements 100}\n        } else {\n            puts \"Unknown sorted set encoding\"\n            exit\n        }\n\n        test \"ZSCORE - $encoding\" {\n            r del zscoretest\n            set aux {}\n            for {set i 0} {$i < $elements} {incr i} {\n                set score [expr rand()]\n                lappend aux $score\n                r zadd zscoretest $score $i\n            }\n\n            assert_encoding $encoding zscoretest\n            for {set i 0} {$i < $elements} {incr i} {\n                assert_equal [lindex $aux $i] [r zscore zscoretest $i]\n            }\n        }\n\n        test \"ZMSCORE - $encoding\" {\n            r del zscoretest\n            set aux {}\n            for {set i 0} {$i < $elements} {incr i} {\n                set score [expr rand()]\n                lappend aux $score\n                r zadd zscoretest $score $i\n            }\n\n            assert_encoding $encoding zscoretest\n            for {set i 0} {$i < $elements} {incr i} {\n                assert_equal [lindex $aux $i] [r zmscore zscoretest $i]\n            }\n        }\n\n        test \"ZSCORE after a DEBUG RELOAD - $encoding\" {\n            r del zscoretest\n            set aux {}\n            for {set i 0} {$i < $elements} {incr i} {\n                set score [expr rand()]\n                lappend aux $score\n                r zadd zscoretest $score $i\n            }\n\n            r debug reload\n            assert_encoding $encoding zscoretest\n            for {set i 0} {$i < $elements} {incr i} {\n                assert_equal [lindex $aux $i] [r zscore zscoretest $i]\n            }\n        } {} {needs:debug}\n\n        test \"ZSET sorting stresser - $encoding\" {\n            set delta 0\n            for {set test 0} {$test < 2} {incr test} {\n                unset -nocomplain auxarray\n                array set auxarray {}\n                set auxlist {}\n                r del myzset\n                for {set i 0} {$i < $elements} {incr i} {\n                    if {$test == 0} {\n                        set score [expr rand()]\n                    } else {\n                        set score [expr int(rand()*10)]\n                    }\n                    set auxarray($i) $score\n                    r zadd myzset $score $i\n                    # Random update\n                    if {[expr rand()] < .2} {\n                        set j [expr int(rand()*1000)]\n                        if {$test == 0} {\n                            set score [expr rand()]\n                        } else {\n                            set score [expr int(rand()*10)]\n                        }\n                        set auxarray($j) $score\n                        r zadd myzset $score $j\n                    }\n                }\n                foreach {item score} [array get auxarray] {\n                    lappend auxlist [list $score $item]\n                }\n                set sorted [lsort -command zlistAlikeSort $auxlist]\n                set auxlist {}\n                foreach x $sorted {\n                    lappend auxlist [lindex $x 1]\n                }\n\n                assert_encoding $encoding myzset\n                set fromredis [r zrange myzset 0 -1]\n                set delta 0\n                for {set i 0} {$i < [llength $fromredis]} {incr i} {\n                    if {[lindex $fromredis $i] != [lindex $auxlist $i]} {\n                        incr delta\n                    }\n                }\n            }\n            assert_equal 0 $delta\n        }\n\n        test \"ZRANGEBYSCORE fuzzy test, 100 ranges in $elements element sorted set - $encoding\" {\n            set err {}\n            r del zset\n            for {set i 0} {$i < $elements} {incr i} {\n                r zadd zset [expr rand()] $i\n            }\n\n            assert_encoding $encoding zset\n            for {set i 0} {$i < 100} {incr i} {\n                set min [expr rand()]\n                set max [expr rand()]\n                if {$min > $max} {\n                    set aux $min\n                    set min $max\n                    set max $aux\n                }\n                set low [r zrangebyscore zset -inf $min]\n                set ok [r zrangebyscore zset $min $max]\n                set high [r zrangebyscore zset $max +inf]\n                set lowx [r zrangebyscore zset -inf ($min]\n                set okx [r zrangebyscore zset ($min ($max]\n                set highx [r zrangebyscore zset ($max +inf]\n\n                if {[r zcount zset -inf $min] != [llength $low]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset $min $max] != [llength $ok]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset $max +inf] != [llength $high]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset -inf ($min] != [llength $lowx]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset ($min ($max] != [llength $okx]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset ($max +inf] != [llength $highx]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n\n                foreach x $low {\n                    set score [r zscore zset $x]\n                    if {$score > $min} {\n                        append err \"Error, score for $x is $score > $min\\n\"\n                    }\n                }\n                foreach x $lowx {\n                    set score [r zscore zset $x]\n                    if {$score >= $min} {\n                        append err \"Error, score for $x is $score >= $min\\n\"\n                    }\n                }\n                foreach x $ok {\n                    set score [r zscore zset $x]\n                    if {$score < $min || $score > $max} {\n                        append err \"Error, score for $x is $score outside $min-$max range\\n\"\n                    }\n                }\n                foreach x $okx {\n                    set score [r zscore zset $x]\n                    if {$score <= $min || $score >= $max} {\n                        append err \"Error, score for $x is $score outside $min-$max open range\\n\"\n                    }\n                }\n                foreach x $high {\n                    set score [r zscore zset $x]\n                    if {$score < $max} {\n                        append err \"Error, score for $x is $score < $max\\n\"\n                    }\n                }\n                foreach x $highx {\n                    set score [r zscore zset $x]\n                    if {$score <= $max} {\n                        append err \"Error, score for $x is $score <= $max\\n\"\n                    }\n                }\n            }\n            assert_equal {} $err\n        }\n\n        test \"ZRANGEBYLEX fuzzy test, 100 ranges in $elements element sorted set - $encoding\" {\n            set lexset {}\n            r del zset\n            for {set j 0} {$j < $elements} {incr j} {\n                set e [randstring 0 30 alpha]\n                lappend lexset $e\n                r zadd zset 0 $e\n            }\n            set lexset [lsort -unique $lexset]\n            for {set j 0} {$j < 100} {incr j} {\n                set min [randstring 0 30 alpha]\n                set max [randstring 0 30 alpha]\n                set mininc [randomInt 2]\n                set maxinc [randomInt 2]\n                if {$mininc} {set cmin \"\\[$min\"} else {set cmin \"($min\"}\n                if {$maxinc} {set cmax \"\\[$max\"} else {set cmax \"($max\"}\n                set rev [randomInt 2]\n                if {$rev} {\n                    set cmd zrevrangebylex\n                } else {\n                    set cmd zrangebylex\n                }\n\n                # Make sure data is the same in both sides\n                assert {[r zrange zset 0 -1] eq $lexset}\n\n                # Get the Redis output\n                set output [r $cmd zset $cmin $cmax]\n                if {$rev} {\n                    set outlen [r zlexcount zset $cmax $cmin]\n                } else {\n                    set outlen [r zlexcount zset $cmin $cmax]\n                }\n\n                # Compute the same output via Tcl\n                set o {}\n                set copy $lexset\n                if {(!$rev && [string compare $min $max] > 0) ||\n                    ($rev && [string compare $max $min] > 0)} {\n                    # Empty output when ranges are inverted.\n                } else {\n                    if {$rev} {\n                        # Invert the Tcl array using Redis itself.\n                        set copy [r zrevrange zset 0 -1]\n                        # Invert min / max as well\n                        lassign [list $min $max $mininc $maxinc] \\\n                            max min maxinc mininc\n                    }\n                    foreach e $copy {\n                        set mincmp [string compare $e $min]\n                        set maxcmp [string compare $e $max]\n                        if {\n                             ($mininc && $mincmp >= 0 || !$mininc && $mincmp > 0)\n                             &&\n                             ($maxinc && $maxcmp <= 0 || !$maxinc && $maxcmp < 0)\n                        } {\n                            lappend o $e\n                        }\n                    }\n                }\n                assert {$o eq $output}\n                assert {$outlen eq [llength $output]}\n            }\n        }\n\n        test \"ZREMRANGEBYLEX fuzzy test, 100 ranges in $elements element sorted set - $encoding\" {\n            set lexset {}\n            r del zset{t} zsetcopy{t}\n            for {set j 0} {$j < $elements} {incr j} {\n                set e [randstring 0 30 alpha]\n                lappend lexset $e\n                r zadd zset{t} 0 $e\n            }\n            set lexset [lsort -unique $lexset]\n            for {set j 0} {$j < 100} {incr j} {\n                # Copy...\n                r zunionstore zsetcopy{t} 1 zset{t}\n                set lexsetcopy $lexset\n\n                set min [randstring 0 30 alpha]\n                set max [randstring 0 30 alpha]\n                set mininc [randomInt 2]\n                set maxinc [randomInt 2]\n                if {$mininc} {set cmin \"\\[$min\"} else {set cmin \"($min\"}\n                if {$maxinc} {set cmax \"\\[$max\"} else {set cmax \"($max\"}\n\n                # Make sure data is the same in both sides\n                assert {[r zrange zset{t} 0 -1] eq $lexset}\n\n                # Get the range we are going to remove\n                set torem [r zrangebylex zset{t} $cmin $cmax]\n                set toremlen [r zlexcount zset{t} $cmin $cmax]\n                r zremrangebylex zsetcopy{t} $cmin $cmax\n                set output [r zrange zsetcopy{t} 0 -1]\n\n                # Remove the range with Tcl from the original list\n                if {$toremlen} {\n                    set first [lsearch -exact $lexsetcopy [lindex $torem 0]]\n                    set last [expr {$first+$toremlen-1}]\n                    set lexsetcopy [lreplace $lexsetcopy $first $last]\n                }\n                assert {$lexsetcopy eq $output}\n            }\n        }\n\n        test \"ZSETs skiplist implementation backlink consistency test - $encoding\" {\n            set diff 0\n            for {set j 0} {$j < $elements} {incr j} {\n                r zadd myzset [expr rand()] \"Element-$j\"\n                r zrem myzset \"Element-[expr int(rand()*$elements)]\"\n            }\n\n            assert_encoding $encoding myzset\n            set l1 [r zrange myzset 0 -1]\n            set l2 [r zrevrange myzset 0 -1]\n            for {set j 0} {$j < [llength $l1]} {incr j} {\n                if {[lindex $l1 $j] ne [lindex $l2 end-$j]} {\n                    incr diff\n                }\n            }\n            assert_equal 0 $diff\n        }\n\n        test \"ZSETs ZRANK augmented skip list stress testing - $encoding\" {\n            set err {}\n            r del myzset\n            for {set k 0} {$k < 2000} {incr k} {\n                set i [expr {$k % $elements}]\n                if {[expr rand()] < .2} {\n                    r zrem myzset $i\n                } else {\n                    set score [expr rand()]\n                    r zadd myzset $score $i\n                    assert_encoding $encoding myzset\n                }\n\n                set card [r zcard myzset]\n                if {$card > 0} {\n                    set index [randomInt $card]\n                    set ele [lindex [r zrange myzset $index $index] 0]\n                    set rank [r zrank myzset $ele]\n                    if {$rank != $index} {\n                        set err \"$ele RANK is wrong! ($rank != $index)\"\n                        break\n                    }\n                }\n            }\n            assert_equal {} $err\n        }\n\n    foreach {pop} {BZPOPMIN BZMPOP_MIN} {\n        test \"$pop, ZADD + DEL should not awake blocked client\" {\n            set rd [redis_deferring_client]\n            r del zset\n\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n\n            r multi\n            r zadd zset 0 foo\n            r del zset\n            r exec\n            r del zset\n            r zadd zset 1 bar\n\n            verify_pop_response $pop [$rd read] {zset bar 1} {zset {{bar 1}}}\n            $rd close\n        }\n\n        test \"$pop, ZADD + DEL + SET should not awake blocked client\" {\n            set rd [redis_deferring_client]\n            r del zset\n\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n\n            r multi\n            r zadd zset 0 foo\n            r del zset\n            r set zset foo\n            r exec\n            r del zset\n            r zadd zset 1 bar\n\n            verify_pop_response $pop [$rd read] {zset bar 1} {zset {{bar 1}}}\n            $rd close\n        }\n    }\n\n        test \"BZPOPMIN with same key multiple times should work\" {\n            set rd [redis_deferring_client]\n            r del z1{t} z2{t}\n\n            # Data arriving after the BZPOPMIN.\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            wait_for_blocked_client\n            r zadd z1{t} 0 a\n            assert_equal [$rd read] {z1{t} a 0}\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            wait_for_blocked_client\n            r zadd z2{t} 1 b\n            assert_equal [$rd read] {z2{t} b 1}\n\n            # Data already there.\n            r zadd z1{t} 0 a\n            r zadd z2{t} 1 b\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            assert_equal [$rd read] {z1{t} a 0}\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            assert_equal [$rd read] {z2{t} b 1}\n            $rd close\n        }\n\n    foreach {pop} {BZPOPMIN BZMPOP_MIN} {\n        test \"MULTI/EXEC is isolated from the point of view of $pop\" {\n            set rd [redis_deferring_client]\n            r del zset\n\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n\n            r multi\n            r zadd zset 0 a\n            r zadd zset 1 b\n            r zadd zset 2 c\n            r exec\n\n            verify_pop_response $pop [$rd read] {zset a 0} {zset {{a 0}}}\n            $rd close\n        }\n\n        test \"$pop with variadic ZADD\" {\n            set rd [redis_deferring_client]\n            r del zset\n            if {$::valgrind} {after 100}\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n            if {$::valgrind} {after 100}\n            assert_equal 2 [r zadd zset -1 foo 1 bar]\n            if {$::valgrind} {after 100}\n            verify_pop_response $pop [$rd read] {zset foo -1} {zset {{foo -1}}}\n            assert_equal {bar} [r zrange zset 0 -1]\n            $rd close\n        }\n\n        test \"$pop with zero timeout should block indefinitely\" {\n            set rd [redis_deferring_client]\n            r del zset\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n            after 1000\n            r zadd zset 0 foo\n            verify_pop_response $pop [$rd read] {zset foo 0} {zset {{foo 0}}}\n            $rd close\n        }\n    }\n\n        r config set zset-max-ziplist-entries $original_max_entries\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    tags {\"slow\"} {\n        stressers listpack\n        stressers skiplist\n    }\n\n    test \"BZPOP/BZMPOP against wrong type\" {\n        r set foo{t} bar\n        assert_error \"*WRONGTYPE*\" {r bzpopmin foo{t} 1}\n        assert_error \"*WRONGTYPE*\" {r bzpopmax foo{t} 1}\n\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 1 foo{t} min}\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 1 foo{t} max}\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 1 foo{t} min count 10}\n\n        r del foo{t}\n        r set foo2{t} bar\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 2 foo{t} foo2{t} min}\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 2 foo2{t} foo{t} max count 1}\n    }\n\n    test \"BZMPOP with illegal argument\" {\n        assert_error \"ERR wrong number of arguments for 'bzmpop' command\" {r bzmpop}\n        assert_error \"ERR wrong number of arguments for 'bzmpop' command\" {r bzmpop 0 1}\n        assert_error \"ERR wrong number of arguments for 'bzmpop' command\" {r bzmpop 0 1 myzset{t}}\n\n        assert_error \"ERR numkeys*\" {r bzmpop 1 0 myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r bzmpop 1 a myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r bzmpop 1 -1 myzset{t} MAX}\n\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} bad_where}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} MIN bar_arg}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} MAX MIN}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} COUNT}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} MIN COUNT 1 COUNT 2}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 2 myzset{t} myzset2{t} bad_arg}\n\n        assert_error \"ERR count*\" {r bzmpop 1 1 myzset{t} MIN COUNT 0}\n        assert_error \"ERR count*\" {r bzmpop 1 1 myzset{t} MAX COUNT a}\n        assert_error \"ERR count*\" {r bzmpop 1 1 myzset{t} MIN COUNT -1}\n        assert_error \"ERR count*\" {r bzmpop 1 2 myzset{t} myzset2{t} MAX COUNT -1}\n    }\n\n    test \"BZMPOP with multiple blocked clients\" {\n        set rd1 [redis_deferring_client]\n        set rd2 [redis_deferring_client]\n        set rd3 [redis_deferring_client]\n        set rd4 [redis_deferring_client]\n        r del myzset{t} myzset2{t}\n\n        $rd1 bzmpop 0 2 myzset{t} myzset2{t} min count 1\n        wait_for_blocked_clients_count 1\n        $rd2 bzmpop 0 2 myzset{t} myzset2{t} max count 10\n        wait_for_blocked_clients_count 2\n        $rd3 bzmpop 0 2 myzset{t} myzset2{t} min count 10\n        wait_for_blocked_clients_count 3\n        $rd4 bzmpop 0 2 myzset{t} myzset2{t} max count 1\n        wait_for_blocked_clients_count 4\n\n        r multi\n        r zadd myzset{t} 1 a 2 b 3 c 4 d 5 e\n        r zadd myzset2{t} 1 a 2 b 3 c 4 d 5 e\n        r exec\n\n        assert_equal {myzset{t} {{a 1}}} [$rd1 read]\n        assert_equal {myzset{t} {{e 5} {d 4} {c 3} {b 2}}} [$rd2 read]\n        assert_equal {myzset2{t} {{a 1} {b 2} {c 3} {d 4} {e 5}}} [$rd3 read]\n\n        r zadd myzset2{t} 1 a 2 b 3 c\n        assert_equal {myzset2{t} {{c 3}}} [$rd4 read]\n\n        r del myzset{t} myzset2{t}\n        $rd1 close\n        $rd2 close\n        $rd3 close\n        $rd4 close\n    }\n\n    test \"BZMPOP propagate as pop with count command to replica\" {\n        set rd [redis_deferring_client]\n        set repl [attach_to_replication_stream]\n\n        # BZMPOP without being blocked.\n        r zadd myzset{t} 1 one 2 two 3 three\n        r zadd myzset2{t} 4 four 5 five 6 six\n        r bzmpop 0 1 myzset{t} min\n        r bzmpop 0 2 myzset{t} myzset2{t} max count 10\n        r bzmpop 0 2 myzset{t} myzset2{t} max count 10\n\n        # BZMPOP that gets blocked.\n        $rd bzmpop 0 1 myzset{t} min count 1\n        wait_for_blocked_client\n        r zadd myzset{t} 1 one\n        $rd bzmpop 0 2 myzset{t} myzset2{t} min count 5\n        wait_for_blocked_client\n        r zadd myzset{t} 1 one 2 two 3 three\n        $rd bzmpop 0 2 myzset{t} myzset2{t} max count 10\n        wait_for_blocked_client\n        r zadd myzset2{t} 4 four 5 five 6 six\n\n        # Released on timeout.\n        assert_equal {} [r bzmpop 0.01 1 myzset{t} max count 10]\n        r set foo{t} bar ;# something else to propagate after, so we can make sure the above pop didn't.\n\n        $rd close\n\n        assert_replication_stream $repl {\n            {select *}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zadd myzset2{t} 4 four 5 five 6 six}\n            {zpopmin myzset{t} 1}\n            {zpopmax myzset{t} 2}\n            {zpopmax myzset2{t} 3}\n            {zadd myzset{t} 1 one}\n            {zpopmin myzset{t} 1}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zpopmin myzset{t} 3}\n            {zadd myzset2{t} 4 four 5 five 6 six}\n            {zpopmax myzset2{t} 3}\n            {set foo{t} bar}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test \"BZMPOP should not blocks on non key arguments - #10762\" {\n        set rd1 [redis_deferring_client]\n        set rd2 [redis_deferring_client]\n        r del myzset myzset2 myzset3\n\n        $rd1 bzmpop 0 1 myzset min count 10\n        wait_for_blocked_clients_count 1\n        $rd2 bzmpop 0 2 myzset2 myzset3 max count 10\n        wait_for_blocked_clients_count 2\n\n        # These non-key keys will not unblock the clients.\n        r zadd 0 100 timeout_value\n        r zadd 1 200 numkeys_value\n        r zadd min 300 min_token\n        r zadd max 400 max_token\n        r zadd count 500 count_token\n        r zadd 10 600 count_value\n\n        r zadd myzset 1 zset\n        r zadd myzset3 1 zset3\n        assert_equal {myzset {{zset 1}}} [$rd1 read]\n        assert_equal {myzset3 {{zset3 1}}} [$rd2 read]\n\n        $rd1 close\n        $rd2 close\n    } {0} {cluster:skip}\n\n    test {ZSET skiplist order consistency when elements are moved} {\n        set original_max [lindex [r config get zset-max-ziplist-entries] 1]\n        r config set zset-max-ziplist-entries 0\n        for {set times 0} {$times < 10} {incr times} {\n            r del zset\n            for {set j 0} {$j < 1000} {incr j} {\n                r zadd zset [randomInt 50] ele-[randomInt 10]\n            }\n\n            # Make sure that element ordering is correct\n            set prev_element {}\n            set prev_score -1\n            foreach {element score} [r zrange zset 0 -1 WITHSCORES] {\n                # Assert that elements are in increasing ordering\n                assert {\n                    $prev_score < $score ||\n                    ($prev_score == $score &&\n                     [string compare $prev_element $element] == -1)\n                }\n                set prev_element $element\n                set prev_score $score\n            }\n        }\n        r config set zset-max-ziplist-entries $original_max\n    }\n\n    test {ZRANGESTORE basic} {\n        r flushall\n        r zadd z1{t} 1 a 2 b 3 c 4 d\n        set res [r zrangestore z2{t} z1{t} 0 -1]\n        assert_equal $res 4\n        r zrange z2{t} 0 -1 withscores\n    } {a 1 b 2 c 3 d 4}\n\n    test {ZRANGESTORE RESP3} {\n        r hello 3\n        assert_equal [r zrange z2{t} 0 -1 withscores] {{a 1.0} {b 2.0} {c 3.0} {d 4.0}}\n        r hello 2\n    } \n\n    test {ZRANGESTORE range} {\n        set res [r zrangestore z2{t} z1{t} 1 2]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {b 2 c 3}\n\n    test {ZRANGESTORE BYLEX} {\n        set res [r zrangestore z2{t} z1{t} \\[b \\[c BYLEX]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {b 2 c 3}\n\n    test {ZRANGESTORE BYSCORE} {\n        set res [r zrangestore z2{t} z1{t} 1 2 BYSCORE]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {a 1 b 2}\n\n    test {ZRANGESTORE BYSCORE LIMIT} {\n        set res [r zrangestore z2{t} z1{t} 0 5 BYSCORE LIMIT 0 2]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {a 1 b 2}\n\n    test {ZRANGESTORE BYSCORE REV LIMIT} {\n        set res [r zrangestore z2{t} z1{t} 5 0 BYSCORE REV LIMIT 0 2]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {c 3 d 4}\n\n    test {ZRANGE BYSCORE REV LIMIT} {\n        r zrange z1{t} 5 0 BYSCORE REV LIMIT 0 2 WITHSCORES\n    } {d 4 c 3}\n\n    test {ZRANGESTORE - src key missing} {\n        set res [r zrangestore z2{t} missing{t} 0 -1]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGESTORE - src key wrong type} {\n        r zadd z2{t} 1 a\n        r set foo{t} bar\n        assert_error \"*WRONGTYPE*\" {r zrangestore z2{t} foo{t} 0 -1}\n        r zrange z2{t} 0 -1\n    } {a}\n\n    test {ZRANGESTORE - empty range} {\n        set res [r zrangestore z2{t} z1{t} 5 6]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGESTORE BYLEX - empty range} {\n        set res [r zrangestore z2{t} z1{t} \\[f \\[g BYLEX]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGESTORE BYSCORE - empty range} {\n        set res [r zrangestore z2{t} z1{t} 5 6 BYSCORE]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGE BYLEX} {\n        r zrange z1{t} \\[b \\[c BYLEX\n    } {b c}\n\n    test {ZRANGESTORE invalid syntax} {\n        catch {r zrangestore z2{t} z1{t} 0 -1 limit 1 2} err\n        assert_match \"*syntax*\" $err\n        catch {r zrangestore z2{t} z1{t} 0 -1 WITHSCORES} err\n        assert_match \"*syntax*\" $err\n    }\n\n    test {ZRANGESTORE with zset-max-listpack-entries 0 #10767 case} {\n        set original_max [lindex [r config get zset-max-listpack-entries] 1]\n        r config set zset-max-listpack-entries 0\n        r del z1{t} z2{t}\n        r zadd z1{t} 1 a\n        assert_equal 1 [r zrangestore z2{t} z1{t} 0 -1]\n        r config set zset-max-listpack-entries $original_max\n    }\n\n    test {ZRANGESTORE with zset-max-listpack-entries 1 dst key should use skiplist encoding} {\n        set original_max [lindex [r config get zset-max-listpack-entries] 1]\n        r config set zset-max-listpack-entries 1\n        r del z1{t} z2{t} z3{t}\n        r zadd z1{t} 1 a 2 b\n        assert_equal 1 [r zrangestore z2{t} z1{t} 0 0]\n        assert_encoding listpack z2{t}\n        assert_equal 2 [r zrangestore z3{t} z1{t} 0 1]\n        assert_encoding skiplist z3{t}\n        r config set zset-max-listpack-entries $original_max\n    }\n\n    test {ZRANGE invalid syntax} {\n        catch {r zrange z1{t} 0 -1 limit 1 2} err\n        assert_match \"*syntax*\" $err\n        catch {r zrange z1{t} 0 -1 BYLEX WITHSCORES} err\n        assert_match \"*syntax*\" $err\n        catch {r zrevrange z1{t} 0 -1 BYSCORE} err\n        assert_match \"*syntax*\" $err\n        catch {r zrangebyscore z1{t} 0 -1 REV} err\n        assert_match \"*syntax*\" $err\n    }\n\n    proc get_keys {l} {\n        set res {}\n        foreach {score key} $l {\n            lappend res $key\n        }\n        return $res\n    }\n\n    # Check whether the zset members belong to the zset\n    proc check_member {mydict res} {\n        foreach ele $res {\n            assert {[dict exists $mydict $ele]}\n        }\n    }\n\n    # Check whether the zset members and score belong to the zset\n    proc check_member_and_score {mydict res} {\n       foreach {key val} $res {\n            assert_equal $val [dict get $mydict $key]\n        }\n    }\n\n    foreach {type contents} \"listpack {1 a 2 b 3 c} skiplist {1 a 2 b 3 [randstring 70 90 alpha]}\" {\n        set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n        r config set zset-max-ziplist-value 10\n        create_zset myzset $contents\n        assert_encoding $type myzset\n\n        test \"ZRANDMEMBER - $type\" {\n            unset -nocomplain myzset\n            array set myzset {}\n            for {set i 0} {$i < 100} {incr i} {\n                set key [r zrandmember myzset]\n                set myzset($key) 1\n            }\n            assert_equal [lsort [get_keys $contents]] [lsort [array names myzset]]\n        }\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    test \"ZRANDMEMBER with RESP3\" {\n        r hello 3\n        set res [r zrandmember myzset 3 withscores]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 2\n\n        set res [r zrandmember myzset 3]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 1\n        r hello 2\n    }\n\n    test \"ZRANDMEMBER count of 0 is handled correctly\" {\n        r zrandmember myzset 0\n    } {}\n\n    test \"ZRANDMEMBER with <count> against non existing key\" {\n        r zrandmember nonexisting_key 100\n    } {}\n\n    test \"ZRANDMEMBER count overflow\" {\n        r zadd myzset 0 a\n        assert_error {*value is out of range*} {r zrandmember myzset -9223372036854770000 withscores}\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"ZRANDMEMBER count of 0 is handled correctly - emptyarray\" {\n        r zrandmember myzset 0\n    } {*0}\n\n    test \"ZRANDMEMBER with <count> against non existing key - emptyarray\" {\n        r zrandmember nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} \"\n        skiplist {1 a 2 b 3 c 4 d 5 e 6 f 7 g 7 h 9 i 10 [randstring 70 90 alpha]}\n        listpack {1 a 2 b 3 c 4 d 5 e 6 f 7 g 7 h 9 i 10 j} \" {\n        test \"ZRANDMEMBER with <count> - $type\" {\n            set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n            r config set zset-max-ziplist-value 10\n            create_zset myzset $contents\n            assert_encoding $type myzset\n\n            # create a dict for easy lookup\n            set mydict [dict create {*}[r zrange myzset 0 -1 withscores]]\n\n            # We'll stress different parts of the code, see the implementation\n            # of ZRANDMEMBER for more information, but basically there are\n            # four different code paths.\n\n            # PATH 1: Use negative count.\n\n            # 1) Check that it returns repeated elements with and without values.\n            # 2) Check that all the elements actually belong to the original zset.\n            set res [r zrandmember myzset -20]\n            assert_equal [llength $res] 20\n            check_member $mydict $res\n\n            set res [r zrandmember myzset -1001]\n            assert_equal [llength $res] 1001\n            check_member $mydict $res\n\n            # again with WITHSCORES\n            set res [r zrandmember myzset -20 withscores]\n            assert_equal [llength $res] 40\n            check_member_and_score $mydict $res\n\n            set res [r zrandmember myzset -1001 withscores]\n            assert_equal [llength $res] 2002\n            check_member_and_score $mydict $res\n\n            # Test random uniform distribution\n            # df = 9, 40 means 0.00001 probability\n            set res [r zrandmember myzset -1000]\n            assert_lessthan [chi_square_value $res] 40\n            check_member $mydict $res\n\n            # 3) Check that eventually all the elements are returned.\n            #    Use both WITHSCORES and without\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                if {[expr {$iterations % 2}] == 0} {\n                    set res [r zrandmember myzset -3 withscores]\n                    foreach {key val} $res {\n                        dict append auxset $key $val\n                    }\n                } else {\n                    set res [r zrandmember myzset -3]\n                    foreach key $res {\n                        dict append auxset $key\n                    }\n                }\n                if {[lsort [dict keys $mydict]] eq\n                    [lsort [dict keys $auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {10 20} {\n                set res [r zrandmember myzset $size]\n                assert_equal [llength $res] 10\n                assert_equal [lsort $res] [lsort [dict keys $mydict]]\n                check_member $mydict $res\n\n                # again with WITHSCORES\n                set res [r zrandmember myzset $size withscores]\n                assert_equal [llength $res] 20\n                assert_equal [lsort $res] [lsort $mydict]\n                check_member_and_score $mydict $res\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n            foreach size {1 2 8} {\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                set res [r zrandmember myzset $size]\n                assert_equal [llength $res] $size\n                check_member $mydict $res\n\n                # again with WITHSCORES\n                set res [r zrandmember myzset $size withscores]\n                assert_equal [llength $res] [expr {$size * 2}]\n                check_member_and_score $mydict $res\n\n                # 2) Check that eventually all the elements are returned.\n                #    Use both WITHSCORES and without\n                unset -nocomplain auxset\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                set all_ele_return false\n                while {$iterations != 0} {\n                    incr iterations -1\n                    if {[expr {$iterations % 2}] == 0} {\n                        set res [r zrandmember myzset $size withscores]\n                        foreach {key value} $res {\n                            dict append auxset $key $value\n                            lappend allkey $key\n                        }\n                    } else {\n                        set res [r zrandmember myzset $size]\n                        foreach key $res {\n                            dict append auxset $key\n                            lappend allkey $key\n                        }\n                    }\n                    if {[lsort [dict keys $mydict]] eq\n                        [lsort [dict keys $auxset]]} {\n                        set all_ele_return true\n                    }\n                }\n                assert_equal $all_ele_return true\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    test {zset score double range} {\n        set dblmax 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000000000000\n        r del zz\n        r zadd zz $dblmax dblmax\n        assert_encoding listpack zz\n        r zscore zz dblmax\n    } {1.7976931348623157e+308}\n\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h>\n\n/*-----------------------------------------------------------------------------\n * Hash type API\n *----------------------------------------------------------------------------*/\n\n/* Check the length of a number of objects to see if we need to convert a\n * listpack to a real hash. Note that we only check string encoded objects\n * as their string length can be queried in constant time. */\nvoid hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    size_t sum = 0;\n\n    if (o->encoding != OBJ_ENCODING_LISTPACK) return;\n\n    for (i = start; i <= end; i++) {\n        if (!sdsEncodedObject(argv[i]))\n            continue;\n        size_t len = sdslen(argv[i]->ptr);\n        if (len > server.hash_max_listpack_value) {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            return;\n        }\n        sum += len;\n    }\n    if (!lpSafeToAdd(o->ptr, sum))\n        hashTypeConvert(o, OBJ_ENCODING_HT);\n}\n\n/* Get the value from a listpack encoded hash, identified by field.\n * Returns -1 when the field cannot be found. */\nint hashTypeGetFromListpack(robj *o, sds field,\n                            unsigned char **vstr,\n                            unsigned int *vlen,\n                            long long *vll)\n{\n    unsigned char *zl, *fptr = NULL, *vptr = NULL;\n\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    zl = o->ptr;\n    fptr = lpFirst(zl);\n    if (fptr != NULL) {\n        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n        if (fptr != NULL) {\n            /* Grab pointer to the value (fptr points to the field) */\n            vptr = lpNext(zl, fptr);\n            serverAssert(vptr != NULL);\n        }\n    }\n\n    if (vptr != NULL) {\n        *vstr = lpGetValue(vptr, vlen, vll);\n        return 0;\n    }\n\n    return -1;\n}\n\n/* Get the value from a hash table encoded hash, identified by field.\n * Returns NULL when the field cannot be found, otherwise the SDS value\n * is returned. */\nsds hashTypeGetFromHashTable(robj *o, sds field) {\n    dictEntry *de;\n\n    serverAssert(o->encoding == OBJ_ENCODING_HT);\n\n    de = dictFind(o->ptr, field);\n    if (de == NULL) return NULL;\n    return dictGetVal(de);\n}\n\n/* Higher level function of hashTypeGet*() that returns the hash value\n * associated with the specified field. If the field is found C_OK\n * is returned, otherwise C_ERR. The returned object is returned by\n * reference in either *vstr and *vlen if it's returned in string form,\n * or stored in *vll if it's returned as a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * for C_OK and checking if vll (or vstr) is NULL. */\nint hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)\n            return C_OK;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        sds value;\n        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {\n            *vstr = (unsigned char*) value;\n            *vlen = sdslen(value);\n            return C_OK;\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_ERR;\n}\n\n/* Like hashTypeGetValue() but returns a Redis object, which is useful for\n * interaction with the hash type outside t_hash.c.\n * The function returns NULL if the field is not found in the hash. Otherwise\n * a newly allocated string object with the value is returned. */\nrobj *hashTypeGetValueObject(robj *o, sds field) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;\n    if (vstr) return createStringObject((char*)vstr,vlen);\n    else return createStringObjectFromLongLong(vll);\n}\n\n/* Higher level function using hashTypeGet*() to return the length of the\n * object associated with the requested field, or 0 if the field does not\n * exist. */\nsize_t hashTypeGetValueLength(robj *o, sds field) {\n    size_t len = 0;\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)\n        len = vstr ? vlen : sdigits10(vll);\n\n    return len;\n}\n\n/* Test if the specified field exists in the given hash. Returns 1 if the field\n * exists, and 0 when it doesn't. */\nint hashTypeExists(robj *o, sds field) {\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;\n}\n\n/* Add a new field, overwrite the old with the new value if it already exists.\n * Return 0 on insert and 1 on update.\n *\n * By default, the key and value SDS strings are copied if needed, so the\n * caller retains ownership of the strings passed. However this behavior\n * can be effected by passing appropriate flags (possibly bitwise OR-ed):\n *\n * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.\n * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.\n *\n * When the flags are used the caller does not need to release the passed\n * SDS string(s). It's up to the function to use the string to create a new\n * entry or to free the SDS string before returning to the caller.\n *\n * HASH_SET_COPY corresponds to no flags passed, and means the default\n * semantics of copying the values if needed.\n *\n */\n#define HASH_SET_TAKE_FIELD (1<<0)\n#define HASH_SET_TAKE_VALUE (1<<1)\n#define HASH_SET_COPY 0\nint hashTypeSet(robj *o, sds field, sds value, int flags) {\n    int update = 0;\n\n    /* Check if the field is too long for listpack, and convert before adding the item.\n     * This is needed for HINCRBY* case since in other commands this is handled early by\n     * hashTypeTryConversion, so this check will be a NOP. */\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    }\n    \n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr, *vptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Grab pointer to the value (fptr points to the field) */\n                vptr = lpNext(zl, fptr);\n                serverAssert(vptr != NULL);\n                update = 1;\n\n                /* Replace value */\n                zl = lpReplace(zl, &vptr, (unsigned char*)value, sdslen(value));\n            }\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the listpack */\n            zl = lpAppend(zl, (unsigned char*)field, sdslen(field));\n            zl = lpAppend(zl, (unsigned char*)value, sdslen(value));\n        }\n        o->ptr = zl;\n\n        /* Check if the listpack needs to be converted to a hash table */\n        if (hashTypeLength(o) > server.hash_max_listpack_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictFind(o->ptr,field);\n        if (de) {\n            sdsfree(dictGetVal(de));\n            if (flags & HASH_SET_TAKE_VALUE) {\n                dictGetVal(de) = value;\n                value = NULL;\n            } else {\n                dictGetVal(de) = sdsdup(value);\n            }\n            update = 1;\n        } else {\n            sds f,v;\n            if (flags & HASH_SET_TAKE_FIELD) {\n                f = field;\n                field = NULL;\n            } else {\n                f = sdsdup(field);\n            }\n            if (flags & HASH_SET_TAKE_VALUE) {\n                v = value;\n                value = NULL;\n            } else {\n                v = sdsdup(value);\n            }\n            dictAdd(o->ptr,f,v);\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n\n    /* Free SDS strings we did not referenced elsewhere if the flags\n     * want this function to be responsible. */\n    if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);\n    if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);\n    return update;\n}\n\n/* Delete an element from a hash.\n * Return 1 on deleted and 0 on not found. */\nint hashTypeDelete(robj *o, sds field) {\n    int deleted = 0;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Delete both of the key and the value. */\n                zl = lpDeleteRangeWithEntry(zl,&fptr,2);\n                o->ptr = zl;\n                deleted = 1;\n            }\n        }\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete((dict*)o->ptr, field) == C_OK) {\n            deleted = 1;\n\n            /* Always check if the dictionary needs a resize after a delete. */\n            if (htNeedsResize(o->ptr)) dictResize(o->ptr);\n        }\n\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return deleted;\n}\n\n/* Return the number of elements in a hash. */\nunsigned long hashTypeLength(const robj *o) {\n    unsigned long length = ULONG_MAX;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        length = lpLength(o->ptr) / 2;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        length = dictSize((const dict*)o->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return length;\n}\n\nhashTypeIterator *hashTypeInitIterator(robj *subject) {\n    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));\n    hi->subject = subject;\n    hi->encoding = subject->encoding;\n\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        hi->fptr = NULL;\n        hi->vptr = NULL;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        hi->di = dictGetIterator(subject->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hi;\n}\n\nvoid hashTypeReleaseIterator(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(hi->di);\n    zfree(hi);\n}\n\n/* Move to the next entry in the hash. Return C_OK when the next entry\n * could be found and C_ERR when the iterator reaches the end. */\nint hashTypeNext(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl;\n        unsigned char *fptr, *vptr;\n\n        zl = hi->subject->ptr;\n        fptr = hi->fptr;\n        vptr = hi->vptr;\n\n        if (fptr == NULL) {\n            /* Initialize cursor */\n            serverAssert(vptr == NULL);\n            fptr = lpFirst(zl);\n        } else {\n            /* Advance cursor */\n            serverAssert(vptr != NULL);\n            fptr = lpNext(zl, vptr);\n        }\n        if (fptr == NULL) return C_ERR;\n\n        /* Grab pointer to the value (fptr points to the field) */\n        vptr = lpNext(zl, fptr);\n        serverAssert(vptr != NULL);\n\n        /* fptr, vptr now point to the first or next pair */\n        hi->fptr = fptr;\n        hi->vptr = vptr;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_OK;\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a listpack. Prototype is similar to `hashTypeGetFromListpack`. */\nvoid hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,\n                                 unsigned char **vstr,\n                                 unsigned int *vlen,\n                                 long long *vll)\n{\n    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (what & OBJ_HASH_KEY) {\n        *vstr = lpGetValue(hi->fptr, vlen, vll);\n    } else {\n        *vstr = lpGetValue(hi->vptr, vlen, vll);\n    }\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a hash table. Prototype is similar to\n * `hashTypeGetFromHashTable`. */\nsds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {\n    serverAssert(hi->encoding == OBJ_ENCODING_HT);\n\n    if (what & OBJ_HASH_KEY) {\n        return dictGetKey(hi->de);\n    } else {\n        return dictGetVal(hi->de);\n    }\n}\n\n/* Higher level function of hashTypeCurrent*() that returns the hash value\n * at current iterator position.\n *\n * The returned element is returned by reference in either *vstr and *vlen if\n * it's returned in string form, or stored in *vll if it's returned as\n * a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * type checking if vstr == NULL. */\nvoid hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        hashTypeCurrentFromListpack(hi, what, vstr, vlen, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds ele = hashTypeCurrentFromHashTable(hi, what);\n        *vstr = (unsigned char*) ele;\n        *vlen = sdslen(ele);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* Return the key or value at the current iterator position as a new\n * SDS string. */\nsds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);\n    if (vstr) return sdsnewlen(vstr,vlen);\n    return sdsfromlonglong(vll);\n}\n\nrobj *hashTypeLookupWriteOrCreate(client *c, robj *key) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (checkType(c,o,OBJ_HASH)) return NULL;\n\n    if (o == NULL) {\n        o = createHashObject();\n        dbAdd(c->db,key,o);\n    }\n    return o;\n}\n\n\nvoid hashTypeConvertListpack(robj *o, int enc) {\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (enc == OBJ_ENCODING_LISTPACK) {\n        /* Nothing to do... */\n\n    } else if (enc == OBJ_ENCODING_HT) {\n        hashTypeIterator *hi;\n        dict *dict;\n        int ret;\n\n        hi = hashTypeInitIterator(o);\n        dict = dictCreate(&hashDictType);\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(dict,hashTypeLength(o));\n\n        while (hashTypeNext(hi) != C_ERR) {\n            sds key, value;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(dict, key, value);\n            if (ret != DICT_OK) {\n                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */\n                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */\n                serverLogHexDump(LL_WARNING,\"listpack with dup elements dump\",\n                    o->ptr,lpBytes(o->ptr));\n                serverPanic(\"Listpack corruption detected\");\n            }\n        }\n        hashTypeReleaseIterator(hi);\n        zfree(o->ptr);\n        o->encoding = OBJ_ENCODING_HT;\n        o->ptr = dict;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid hashTypeConvert(robj *o, int enc) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        hashTypeConvertListpack(o, enc);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        serverPanic(\"Not implemented\");\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a hash object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *hashTypeDup(robj *o) {\n    robj *hobj;\n    hashTypeIterator *hi;\n\n    serverAssert(o->type == OBJ_HASH);\n\n    if(o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = o->ptr;\n        size_t sz = lpBytes(zl);\n        unsigned char *new_zl = zmalloc(sz);\n        memcpy(new_zl, zl, sz);\n        hobj = createObject(OBJ_HASH, new_zl);\n        hobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else if(o->encoding == OBJ_ENCODING_HT){\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, dictSize((const dict*)o->ptr));\n\n        hi = hashTypeInitIterator(o);\n        while (hashTypeNext(hi) != C_ERR) {\n            sds field, value;\n            sds newfield, newvalue;\n            /* Extract a field-value pair from an original hash object.*/\n            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);\n            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);\n            newfield = sdsdup(field);\n            newvalue = sdsdup(value);\n\n            /* Add a field-value pair to a new hash object. */\n            dictAdd(d,newfield,newvalue);\n        }\n        hashTypeReleaseIterator(hi);\n\n        hobj = createObject(OBJ_HASH, d);\n        hobj->encoding = OBJ_ENCODING_HT;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hobj;\n}\n\n/* Create a new sds string from the listpack entry. */\nsds hashSdsFromListpackEntry(listpackEntry *e) {\n    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);\n}\n\n/* Reply with bulk string from the listpack entry. */\nvoid hashReplyFromListpackEntry(client *c, listpackEntry *e) {\n    if (e->sval)\n        addReplyBulkCBuffer(c, e->sval, e->slen);\n    else\n        addReplyBulkLongLong(c, e->lval);\n}\n\n/* Return random element from a non empty hash.\n * 'key' and 'val' will be set to hold the element.\n * The memory in them is not to be freed or modified by the caller.\n * 'val' can be NULL in which case it's not extracted. */\nvoid hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {\n    if (hashobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);\n        sds s = dictGetKey(de);\n        key->sval = (unsigned char*)s;\n        key->slen = sdslen(s);\n        if (val) {\n            sds s = dictGetVal(de);\n            val->sval = (unsigned char*)s;\n            val->slen = sdslen(s);\n        }\n    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {\n        lpRandomPair(hashobj->ptr, hashsize, key, val);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n\n/*-----------------------------------------------------------------------------\n * Hash type commands\n *----------------------------------------------------------------------------*/\n\nvoid hsetnxCommand(client *c) {\n    robj *o;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n\n    if (hashTypeExists(o, c->argv[2]->ptr)) {\n        addReply(c, shared.czero);\n    } else {\n        hashTypeTryConversion(o,c->argv,2,3);\n        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);\n        addReply(c, shared.cone);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid hsetCommand(client *c) {\n    int i, created = 0;\n    robj *o;\n\n    if ((c->argc % 2) == 1) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,c->argc-1);\n\n    for (i = 2; i < c->argc; i += 2)\n        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);\n\n    /* HMSET (deprecated) and HSET return value is different. */\n    char *cmdname = c->argv[0]->ptr;\n    if (cmdname[1] == 's' || cmdname[1] == 'S') {\n        /* HSET */\n        addReplyLongLong(c, created);\n    } else {\n        /* HMSET */\n        addReply(c, shared.ok);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n    server.dirty += (c->argc - 2)/2;\n}\n\nvoid hincrbyCommand(client *c) {\n    long long value, incr, oldvalue;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {\n        if (vstr) {\n            if (string2ll((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not an integer\");\n                return;\n            }\n        } /* Else hashTypeGetValue() already stored it into &value */\n    } else {\n        value = 0;\n    }\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n    new = sdsfromlonglong(value);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyLongLong(c,value);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrby\",c->argv[1],c->db->id);\n    server.dirty++;\n}\n\nvoid hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n\nstatic void addHashFieldToReply(client *c, robj *o, sds field) {\n    if (o == NULL) {\n        addReplyNull(c);\n        return;\n    }\n\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {\n        if (vstr) {\n            addReplyBulkCBuffer(c, vstr, vlen);\n        } else {\n            addReplyBulkLongLong(c, vll);\n        }\n    } else {\n        addReplyNull(c);\n    }\n}\n\nvoid hgetCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addHashFieldToReply(c, o, c->argv[2]->ptr);\n}\n\nvoid hmgetCommand(client *c) {\n    robj *o;\n    int i;\n\n    /* Don't abort when the key cannot be found. Non-existing keys are empty\n     * hashes, where HMGET should respond with a series of null bulks. */\n    o = lookupKeyRead(c->db, c->argv[1]);\n    if (checkType(c,o,OBJ_HASH)) return;\n\n    addReplyArrayLen(c, c->argc-2);\n    for (i = 2; i < c->argc; i++) {\n        addHashFieldToReply(c, o, c->argv[i]->ptr);\n    }\n}\n\nvoid hdelCommand(client *c) {\n    robj *o;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (hashTypeDelete(o,c->argv[j]->ptr)) {\n            deleted++;\n            if (hashTypeLength(o) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hdel\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid hlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReplyLongLong(c,hashTypeLength(o));\n}\n\nvoid hstrlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));\n}\n\nstatic void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *vstr = NULL;\n        unsigned int vlen = UINT_MAX;\n        long long vll = LLONG_MAX;\n\n        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);\n        if (vstr)\n            addReplyBulkCBuffer(c, vstr, vlen);\n        else\n            addReplyBulkLongLong(c, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds value = hashTypeCurrentFromHashTable(hi, what);\n        addReplyBulkCBuffer(c, value, sdslen(value));\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid genericHgetallCommand(client *c, int flags) {\n    robj *o;\n    hashTypeIterator *hi;\n    int length, count = 0;\n\n    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?\n        shared.emptymap[c->resp] : shared.emptyarray;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))\n        == NULL || checkType(c,o,OBJ_HASH)) return;\n\n    /* We return a map if the user requested keys and values, like in the\n     * HGETALL case. Otherwise to use a flat array makes more sense. */\n    length = hashTypeLength(o);\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {\n        addReplyMapLen(c, length);\n    } else {\n        addReplyArrayLen(c, length);\n    }\n\n    hi = hashTypeInitIterator(o);\n    while (hashTypeNext(hi) != C_ERR) {\n        if (flags & OBJ_HASH_KEY) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            count++;\n        }\n        if (flags & OBJ_HASH_VALUE) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n            count++;\n        }\n    }\n\n    hashTypeReleaseIterator(hi);\n\n    /* Make sure we returned the right number of elements. */\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) count /= 2;\n    serverAssert(count == length);\n}\n\nvoid hkeysCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY);\n}\n\nvoid hvalsCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_VALUE);\n}\n\nvoid hgetallCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);\n}\n\nvoid hexistsCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);\n}\n\nvoid hscanCommand(client *c) {\n    robj *o;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    scanGenericCommand(c,o,cursor);\n}\n\nstatic void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {\n    for (unsigned long i = 0; i < count; i++) {\n        if (vals && c->resp > 2)\n            addReplyArrayLen(c,2);\n        if (keys[i].sval)\n            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);\n        else\n            addReplyBulkLongLong(c, keys[i].lval);\n        if (vals) {\n            if (vals[i].sval)\n                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);\n            else\n                addReplyBulkLongLong(c, vals[i].lval);\n        }\n    }\n}\n\n/* How many times bigger should be the hash compared to the requested size\n * for us to not use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define HRANDFIELD_SUB_STRATEGY_MUL 3\n\n/* If client is trying to ask for a very large number of random elements,\n * queuing may consume an unlimited amount of memory, so we want to limit\n * the number of randoms per time. */\n#define HRANDFIELD_RANDOM_SAMPLE_LIMIT 1000\n\nvoid hrandfieldWithCountCommand(client *c, long l, int withvalues) {\n    unsigned long count, size;\n    int uniq = 1;\n    robj *hash;\n\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,hash,OBJ_HASH)) return;\n    size = hashTypeLength(hash);\n\n    if(l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        count = -l;\n        uniq = 0;\n    }\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        if (withvalues && c->resp == 2)\n            addReplyArrayLen(c, count*2);\n        else\n            addReplyArrayLen(c, count);\n        if (hash->encoding == OBJ_ENCODING_HT) {\n            sds key, value;\n            while (count--) {\n                dictEntry *de = dictGetFairRandomKey(hash->ptr);\n                key = dictGetKey(de);\n                value = dictGetVal(de);\n                if (withvalues && c->resp > 2)\n                    addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c, key, sdslen(key));\n                if (withvalues)\n                    addReplyBulkCBuffer(c, value, sdslen(value));\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n        } else if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            listpackEntry *keys, *vals = NULL;\n            unsigned long limit, sample_count;\n\n            limit = count > HRANDFIELD_RANDOM_SAMPLE_LIMIT ? HRANDFIELD_RANDOM_SAMPLE_LIMIT : count;\n            keys = zmalloc(sizeof(listpackEntry)*limit);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*limit);\n            while (count) {\n                sample_count = count > limit ? limit : count;\n                count -= sample_count;\n                lpRandomPairs(hash->ptr, sample_count, keys, vals);\n                hrandfieldReplyWithListpack(c, sample_count, keys, vals);\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n            zfree(keys);\n            zfree(vals);\n        }\n        return;\n    }\n\n    /* Initiate reply count, RESP3 responds with nested array, RESP2 with flat one. */\n    long reply_size = count < size ? count : size;\n    if (withvalues && c->resp == 2)\n        addReplyArrayLen(c, reply_size*2);\n    else\n        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the hash: simply return the whole hash. */\n    if(count >= size) {\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n        while (hashTypeNext(hi) != C_ERR) {\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            if (withvalues)\n                addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n        }\n        hashTypeReleaseIterator(hi);\n        return;\n    }\n\n    /* CASE 3:\n     * The number of elements inside the hash is not greater than\n     * HRANDFIELD_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a hash from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the hash, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*HRANDFIELD_SUB_STRATEGY_MUL > size) {\n        dict *d = dictCreate(&sdsReplyDictType);\n        dictExpand(d, size);\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n\n        /* Add all the elements into the temporary dictionary. */\n        while ((hashTypeNext(hi)) != C_ERR) {\n            int ret = DICT_ERR;\n            sds key, value = NULL;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            if (withvalues)\n                value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(d, key, value);\n\n            serverAssert(ret == DICT_OK);\n        }\n        serverAssert(dictSize(d) == size);\n        hashTypeReleaseIterator(hi);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            sdsfree(dictGetVal(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n\n        /* Reply with what's in the dict and release memory */\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(d);\n        while ((de = dictNext(di)) != NULL) {\n            sds key = dictGetKey(de);\n            sds value = dictGetVal(de);\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, key);\n            if (withvalues)\n                addReplyBulkSds(c, value);\n        }\n\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n\n    /* CASE 4: We have a big hash compared to the requested number of elements.\n     * In this case we can simply get random elements from the hash and add\n     * to the temporary hash, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            /* it is inefficient to repeatedly pick one random element from a\n             * listpack. so we use this instead: */\n            listpackEntry *keys, *vals = NULL;\n            keys = zmalloc(sizeof(listpackEntry)*count);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*count);\n            serverAssert(lpRandomPairsUnique(hash->ptr, count, keys, vals) == count);\n            hrandfieldReplyWithListpack(c, count, keys, vals);\n            zfree(keys);\n            zfree(vals);\n            return;\n        }\n\n        /* Hashtable encoding (generic implementation) */\n        unsigned long added = 0;\n        listpackEntry key, value;\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, count);\n        while(added < count) {\n            hashTypeRandomElement(hash, size, &key, withvalues? &value : NULL);\n\n            /* Try to add the object to the dictionary. If it already exists\n            * free it, otherwise increment the number of objects we have\n            * in the result dictionary. */\n            sds skey = hashSdsFromListpackEntry(&key);\n            if (dictAdd(d,skey,NULL) != DICT_OK) {\n                sdsfree(skey);\n                continue;\n            }\n            added++;\n\n            /* We can reply right away, so that we don't need to store the value in the dict. */\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            hashReplyFromListpackEntry(c, &key);\n            if (withvalues)\n                hashReplyFromListpackEntry(c, &value);\n        }\n\n        /* Release memory */\n        dictRelease(d);\n    }\n}\n\n/* HRANDFIELD key [<count> [WITHVALUES]] */\nvoid hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n\n/*-----------------------------------------------------------------------------\n * Set Commands\n *----------------------------------------------------------------------------*/\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op);\n\n/* Factory method to return a set that *can* hold \"value\". When the object has\n * an integer-encodable value, an intset will be returned. Otherwise a regular\n * hash table. */\nrobj *setTypeCreate(sds value) {\n    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)\n        return createIntsetObject();\n    return createSetObject();\n}\n\n/* Add the specified value into a set.\n *\n * If the value was already member of the set, nothing is done and 0 is\n * returned, otherwise the new element is added and 1 is returned. */\nint setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                size_t max_entries = server.set_max_intset_entries;\n                /* limit to 1G entries due to intset internals. */\n                if (max_entries >= 1<<30) max_entries = 1<<30;\n                if (intsetLen(subject->ptr) > max_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeRemove(robj *setobj, sds value) {\n    long long llval;\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete(setobj->ptr,value) == DICT_OK) {\n            if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);\n            return 1;\n        }\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            int success;\n            setobj->ptr = intsetRemove(setobj->ptr,llval,&success);\n            if (success) return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nint setTypeIsMember(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictFind((dict*)subject->ptr,value) != NULL;\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            return intsetFind((intset*)subject->ptr,llval);\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}\n\nsetTypeIterator *setTypeInitIterator(robj *subject) {\n    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));\n    si->subject = subject;\n    si->encoding = subject->encoding;\n    if (si->encoding == OBJ_ENCODING_HT) {\n        si->di = dictGetIterator(subject->ptr);\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        si->ii = 0;\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return si;\n}\n\nvoid setTypeReleaseIterator(setTypeIterator *si) {\n    if (si->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(si->di);\n    zfree(si);\n}\n\n/* Move to the next entry in the set. Returns the object at the current\n * position.\n *\n * Since set elements can be internally be stored as SDS strings or\n * simple arrays of integers, setTypeNext returns the encoding of the\n * set object you are iterating, and will populate the appropriate pointer\n * (sdsele) or (llele) accordingly.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused.\n *\n * When there are no longer elements -1 is returned. */\nint setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {\n    if (si->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictNext(si->di);\n        if (de == NULL) return -1;\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (si->encoding == OBJ_ENCODING_INTSET) {\n        if (!intsetGet(si->subject->ptr,si->ii++,llele))\n            return -1;\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Wrong set encoding in setTypeNext\");\n    }\n    return si->encoding;\n}\n\n/* The not copy on write friendly version but easy to use version\n * of setTypeNext() is setTypeNextObject(), returning new SDS\n * strings. So if you don't retain a pointer to this object you should call\n * sdsfree() against it.\n *\n * This function is the way to go for write operations where COW is not\n * an issue. */\nsds setTypeNextObject(setTypeIterator *si) {\n    int64_t intele;\n    sds sdsele;\n    int encoding;\n\n    encoding = setTypeNext(si,&sdsele,&intele);\n    switch(encoding) {\n        case -1:    return NULL;\n        case OBJ_ENCODING_INTSET:\n            return sdsfromlonglong(intele);\n        case OBJ_ENCODING_HT:\n            return sdsdup(sdsele);\n        default:\n            serverPanic(\"Unsupported encoding\");\n    }\n    return NULL; /* just to suppress warnings */\n}\n\n/* Return random element from a non empty set.\n * The returned element can be an int64_t value if the set is encoded\n * as an \"intset\" blob of integers, or an SDS string if the set\n * is a regular set.\n *\n * The caller provides both pointers to be populated with the right\n * object. The return value of the function is the object->encoding\n * field of the object and is used by the caller to check if the\n * int64_t pointer or the sds pointer was populated.\n *\n * Note that both the sdsele and llele pointers should be passed and cannot\n * be NULL since the function will try to defensively populate the non\n * used field with values which are easy to trap if misused. */\nint setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {\n    if (setobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(setobj->ptr);\n        *sdsele = dictGetKey(de);\n        *llele = -123456789; /* Not needed. Defensive. */\n    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {\n        *llele = intsetRandom(setobj->ptr);\n        *sdsele = NULL; /* Not needed. Defensive. */\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return setobj->encoding;\n}\n\nunsigned long setTypeSize(const robj *subject) {\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        return dictSize((const dict*)subject->ptr);\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        return intsetLen((const intset*)subject->ptr);\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n}\n\n/* Convert the set to specified encoding. The resulting dict (when converting\n * to a hash table) is presized to hold the number of elements in the original\n * set. */\nvoid setTypeConvert(robj *setobj, int enc) {\n    setTypeIterator *si;\n    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&\n                             setobj->encoding == OBJ_ENCODING_INTSET);\n\n    if (enc == OBJ_ENCODING_HT) {\n        int64_t intele;\n        dict *d = dictCreate(&setDictType);\n        sds element;\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(d,intsetLen(setobj->ptr));\n\n        /* To add the elements we extract integers and create redis objects */\n        si = setTypeInitIterator(setobj);\n        while (setTypeNext(si,&element,&intele) != -1) {\n            element = sdsfromlonglong(intele);\n            serverAssert(dictAdd(d,element,NULL) == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n\n        setobj->encoding = OBJ_ENCODING_HT;\n        zfree(setobj->ptr);\n        setobj->ptr = d;\n    } else {\n        serverPanic(\"Unsupported set conversion\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a set object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *setTypeDup(robj *o) {\n    robj *set;\n    setTypeIterator *si;\n    sds elesds;\n    int64_t intobj;\n\n    serverAssert(o->type == OBJ_SET);\n\n    /* Create a new set object that have the same encoding as the original object's encoding */\n    if (o->encoding == OBJ_ENCODING_INTSET) {\n        intset *is = o->ptr;\n        size_t size = intsetBlobLen(is);\n        intset *newis = zmalloc(size);\n        memcpy(newis,is,size);\n        set = createObject(OBJ_SET, newis);\n        set->encoding = OBJ_ENCODING_INTSET;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        set = createSetObject();\n        dict *d = o->ptr;\n        dictExpand(set->ptr, dictSize(d));\n        si = setTypeInitIterator(o);\n        while (setTypeNext(si, &elesds, &intobj) != -1) {\n            setTypeAdd(set, elesds);\n        }\n        setTypeReleaseIterator(si);\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return set;\n}\n\nvoid saddCommand(client *c) {\n    robj *set;\n    int j, added = 0;\n\n    set = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,set,OBJ_SET)) return;\n    \n    if (set == NULL) {\n        set = setTypeCreate(c->argv[2]->ptr);\n        dbAdd(c->db,c->argv[1],set);\n    }\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeAdd(set,c->argv[j]->ptr)) added++;\n    }\n    if (added) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[1],c->db->id);\n    }\n    server.dirty += added;\n    addReplyLongLong(c,added);\n}\n\nvoid sremCommand(client *c) {\n    robj *set;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeRemove(set,c->argv[j]->ptr)) {\n            deleted++;\n            if (setTypeSize(set) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid smoveCommand(client *c) {\n    robj *srcset, *dstset, *ele;\n    srcset = lookupKeyWrite(c->db,c->argv[1]);\n    dstset = lookupKeyWrite(c->db,c->argv[2]);\n    ele = c->argv[3];\n\n    /* If the source key does not exist return 0 */\n    if (srcset == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    /* If the source key has the wrong type, or the destination key\n     * is set and has the wrong type, return with an error. */\n    if (checkType(c,srcset,OBJ_SET) ||\n        checkType(c,dstset,OBJ_SET)) return;\n\n    /* If srcset and dstset are equal, SMOVE is a no-op */\n    if (srcset == dstset) {\n        addReply(c,setTypeIsMember(srcset,ele->ptr) ?\n            shared.cone : shared.czero);\n        return;\n    }\n\n    /* If the element cannot be removed from the src set, return 0. */\n    if (!setTypeRemove(srcset,ele->ptr)) {\n        addReply(c,shared.czero);\n        return;\n    }\n    notifyKeyspaceEvent(NOTIFY_SET,\"srem\",c->argv[1],c->db->id);\n\n    /* Remove the src set from the database when empty */\n    if (setTypeSize(srcset) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Create the destination set when it doesn't exist */\n    if (!dstset) {\n        dstset = setTypeCreate(ele->ptr);\n        dbAdd(c->db,c->argv[2],dstset);\n    }\n\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n\n    /* An extra key has changed when ele was successfully added to dstset */\n    if (setTypeAdd(dstset,ele->ptr)) {\n        server.dirty++;\n        signalModifiedKey(c,c->db,c->argv[2]);\n        notifyKeyspaceEvent(NOTIFY_SET,\"sadd\",c->argv[2],c->db->id);\n    }\n    addReply(c,shared.cone);\n}\n\nvoid sismemberCommand(client *c) {\n    robj *set;\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n\n    if (setTypeIsMember(set,c->argv[2]->ptr))\n        addReply(c,shared.cone);\n    else\n        addReply(c,shared.czero);\n}\n\nvoid smismemberCommand(client *c) {\n    robj *set;\n    int j;\n\n    /* Don't abort when the key cannot be found. Non-existing keys are empty\n     * sets, where SMISMEMBER should respond with a series of zeros. */\n    set = lookupKeyRead(c->db,c->argv[1]);\n    if (set && checkType(c,set,OBJ_SET)) return;\n\n    addReplyArrayLen(c,c->argc - 2);\n\n    for (j = 2; j < c->argc; j++) {\n        if (set && setTypeIsMember(set,c->argv[j]->ptr))\n            addReply(c,shared.cone);\n        else\n            addReply(c,shared.czero);\n    }\n}\n\nvoid scardCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_SET)) return;\n\n    addReplyLongLong(c,setTypeSize(o));\n}\n\n/* Handle the \"SPOP key <count>\" variant. The normal version of the\n * command is handled by the spopCommand() function itself. */\n\n/* How many times bigger should be the set compared to the remaining size\n * for us to use the \"create new set\" strategy? Read later in the\n * implementation for more info. */\n#define SPOP_MOVE_STRATEGY_MUL 5\n\nvoid spopWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    robj *set;\n\n    /* Get the count argument */\n    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    count = (unsigned long) l;\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set. Otherwise, return nil */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* If count is zero, serve an empty set ASAP to avoid special\n     * cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyset[c->resp]);\n        return;\n    }\n\n    size = setTypeSize(set);\n\n    /* Generate an SPOP keyspace notification */\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n    server.dirty += (count >= size) ? size : count;\n\n    /* CASE 1:\n     * The number of requested elements is greater than or equal to\n     * the number of elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        /* We just return the entire set */\n        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);\n\n        /* Delete the set as it is now empty */\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n\n        /* Propagate this command as a DEL operation */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        return;\n    }\n\n    /* Case 2 and 3 require to replicate SPOP as a set of SREM commands.\n     * Prepare our replication argument vector. Also send the array length\n     * which is common to both the code paths. */\n    robj *propargv[3];\n    propargv[0] = shared.srem;\n    propargv[1] = c->argv[1];\n    addReplySetLen(c,count);\n\n    /* Common iteration vars. */\n    sds sdsele;\n    robj *objele;\n    int encoding;\n    int64_t llele;\n    unsigned long remaining = size-count; /* Elements left after SPOP. */\n\n    /* If we are here, the number of requested elements is less than the\n     * number of elements inside the set. Also we are sure that count < size.\n     * Use two different strategies.\n     *\n     * CASE 2: The number of elements to return is small compared to the\n     * set size. We can just extract random elements and return them to\n     * the set. */\n    if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {\n        while(count--) {\n            /* Emit and remove. */\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n                set->ptr = intsetRemove(set->ptr,llele,NULL);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n                setTypeRemove(set,sdsele);\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(c->db->id,propargv,3,PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n    } else {\n    /* CASE 3: The number of elements to return is very big, approaching\n     * the size of the set itself. After some time extracting random elements\n     * from such a set becomes computationally expensive, so we use\n     * a different strategy, we extract random elements that we don't\n     * want to return (the elements that will remain part of the set),\n     * creating a new set as we do this (that will be stored as the original\n     * set). Then we return the elements left in the original set and\n     * release it. */\n        robj *newset = NULL;\n\n        /* Create a new set with just the remaining elements. */\n        while(remaining--) {\n            encoding = setTypeRandomElement(set,&sdsele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(sdsele);\n            }\n            if (!newset) newset = setTypeCreate(sdsele);\n            setTypeAdd(newset,sdsele);\n            setTypeRemove(set,sdsele);\n            sdsfree(sdsele);\n        }\n\n        /* Transfer the old set to the client. */\n        setTypeIterator *si;\n        si = setTypeInitIterator(set);\n        while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n                objele = createStringObjectFromLongLong(llele);\n            } else {\n                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));\n                objele = createStringObject(sdsele,sdslen(sdsele));\n            }\n\n            /* Replicate/AOF this command as an SREM operation */\n            propargv[2] = objele;\n            alsoPropagate(c->db->id,propargv,3,PROPAGATE_AOF|PROPAGATE_REPL);\n            decrRefCount(objele);\n        }\n        setTypeReleaseIterator(si);\n\n        /* Assign the new set as the key value. */\n        dbOverwrite(c->db,c->argv[1],newset);\n    }\n\n    /* Don't propagate the command itself even if we incremented the\n     * dirty counter. We don't want to propagate an SPOP command since\n     * we propagated the command as a set of SREMs operations using\n     * the alsoPropagate() API. */\n    preventCommandPropagation(c);\n    signalModifiedKey(c,c->db,c->argv[1]);\n}\n\nvoid spopCommand(client *c) {\n    robj *set, *ele;\n    sds sdsele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        spopWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Make sure a key with the name inputted exists, and that it's type is\n     * indeed a set */\n    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))\n         == NULL || checkType(c,set,OBJ_SET)) return;\n\n    /* Get a random element from the set */\n    encoding = setTypeRandomElement(set,&sdsele,&llele);\n\n    /* Remove the element from the set */\n    if (encoding == OBJ_ENCODING_INTSET) {\n        ele = createStringObjectFromLongLong(llele);\n        set->ptr = intsetRemove(set->ptr,llele,NULL);\n    } else {\n        ele = createStringObject(sdsele,sdslen(sdsele));\n        setTypeRemove(set,ele->ptr);\n    }\n\n    notifyKeyspaceEvent(NOTIFY_SET,\"spop\",c->argv[1],c->db->id);\n\n    /* Replicate/AOF this command as an SREM operation */\n    rewriteClientCommandVector(c,3,shared.srem,c->argv[1],ele);\n\n    /* Add the element to the reply */\n    addReplyBulk(c,ele);\n    decrRefCount(ele);\n\n    /* Delete the set if it's empty */\n    if (setTypeSize(set) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n\n    /* Set has been modified */\n    signalModifiedKey(c,c->db,c->argv[1]);\n    server.dirty++;\n}\n\n/* handle the \"SRANDMEMBER key <count>\" variant. The normal version of the\n * command is handled by the srandmemberCommand() function itself. */\n\n/* How many times bigger should be the set compared to the requested size\n * for us to don't use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define SRANDMEMBER_SUB_STRATEGY_MUL 3\n\nvoid srandmemberWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    int uniq = 1;\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    dict *d;\n\n    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        /* A negative count means: return the same elements multiple times\n         * (i.e. don't remove the extracted element after every extraction). */\n        count = -l;\n        uniq = 0;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n    size = setTypeSize(set);\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        addReplyArrayLen(c,count);\n        while(count--) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            if (c->flags & CLIENT_CLOSE_ASAP)\n                break;\n        }\n        return;\n    }\n\n    /* CASE 2:\n     * The number of requested elements is greater than the number of\n     * elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        setTypeIterator *si;\n        addReplyArrayLen(c,size);\n        si = setTypeInitIterator(set);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            size--;\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(size==0);\n        return;\n    }\n\n    /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */\n    d = dictCreate(&sdsReplyDictType);\n\n    /* CASE 3:\n     * The number of elements inside the set is not greater than\n     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a set from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        setTypeIterator *si;\n\n        /* Add all the elements into the temporary dictionary. */\n        si = setTypeInitIterator(set);\n        dictExpand(d, size);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            int retval = DICT_ERR;\n\n            if (encoding == OBJ_ENCODING_INTSET) {\n                retval = dictAdd(d,sdsfromlonglong(llele),NULL);\n            } else {\n                retval = dictAdd(d,sdsdup(ele),NULL);\n            }\n            serverAssert(retval == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n    }\n\n    /* CASE 4: We have a big set compared to the requested number of elements.\n     * In this case we can simply get random elements from the set and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        unsigned long added = 0;\n        sds sdsele;\n\n        dictExpand(d, count);\n        while (added < count) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(ele);\n            }\n            /* Try to add the object to the dictionary. If it already exists\n             * free it, otherwise increment the number of objects we have\n             * in the result dictionary. */\n            if (dictAdd(d,sdsele,NULL) == DICT_OK)\n                added++;\n            else\n                sdsfree(sdsele);\n        }\n    }\n\n    /* CASE 3 & 4: send the result to the user. */\n    {\n        dictIterator *di;\n        dictEntry *de;\n\n        addReplyArrayLen(c,count);\n        di = dictGetIterator(d);\n        while((de = dictNext(di)) != NULL)\n            addReplyBulkSds(c,dictGetKey(de));\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n}\n\n/* SRANDMEMBER <key> [<count>] */\nvoid srandmemberCommand(client *c) {\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    if (c->argc == 3) {\n        srandmemberWithCountCommand(c);\n        return;\n    } else if (c->argc > 3) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n\n    encoding = setTypeRandomElement(set,&ele,&llele);\n    if (encoding == OBJ_ENCODING_INTSET) {\n        addReplyBulkLongLong(c,llele);\n    } else {\n        addReplyBulkCBuffer(c,ele,sdslen(ele));\n    }\n}\n\nint qsortCompareSetsByCardinality(const void *s1, const void *s2) {\n    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;\n    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;\n    return 0;\n}\n\n/* This is used by SDIFF and in this case we can receive NULL that should\n * be handled as empty sets. */\nint qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {\n    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;\n    unsigned long first = o1 ? setTypeSize(o1) : 0;\n    unsigned long second = o2 ? setTypeSize(o2) : 0;\n\n    if (first < second) return 1;\n    if (first > second) return -1;\n    return 0;\n}\n\n/* SINTER / SMEMBERS / SINTERSTORE / SINTERCARD\n *\n * 'cardinality_only' work for SINTERCARD, only return the cardinality\n * with minimum processing and memory overheads.\n *\n * 'limit' work for SINTERCARD, stop searching after reaching the limit.\n * Passing a 0 means unlimited.\n */\nvoid sinterGenericCommand(client *c, robj **setkeys,\n                          unsigned long setnum, robj *dstkey,\n                          int cardinality_only, unsigned long limit) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds elesds;\n    int64_t intobj;\n    void *replylen = NULL;\n    unsigned long j, cardinality = 0;\n    int encoding, empty = 0;\n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = lookupKeyRead(c->db, setkeys[j]);\n        if (!setobj) {\n            /* A NULL is considered an empty set */\n            empty += 1;\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n    }\n\n    /* Set intersection with an empty set always results in an empty set.\n     * Return ASAP if there is an empty set. */\n    if (empty > 0) {\n        zfree(sets);\n        if (dstkey) {\n            if (dbDelete(c->db,dstkey)) {\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n                server.dirty++;\n            }\n            addReply(c,shared.czero);\n        } else if (cardinality_only) {\n            addReplyLongLong(c,cardinality);\n        } else {\n            addReply(c,shared.emptyset[c->resp]);\n        }\n        return;\n    }\n\n    /* Sort sets from the smallest to largest, this will improve our\n     * algorithm's performance */\n    qsort(sets,setnum,sizeof(robj*),qsortCompareSetsByCardinality);\n\n    /* The first thing we should output is the total number of elements...\n     * since this is a multi-bulk write, but at this stage we don't know\n     * the intersection set size, so we use a trick, append an empty object\n     * to the output list and save the pointer to later modify it with the\n     * right length */\n    if (dstkey) {\n        /* If we have a target key where to store the resulting set\n         * create this key with an empty set inside */\n        dstset = createIntsetObject();\n    } else if (!cardinality_only) {\n        replylen = addReplyDeferredLen(c);\n    }\n\n    /* Iterate all the elements of the first (smallest) set, and test\n     * the element against all the other sets, if at least one set does\n     * not include the element it is discarded */\n    si = setTypeInitIterator(sets[0]);\n    while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {\n        for (j = 1; j < setnum; j++) {\n            if (sets[j] == sets[0]) continue;\n            if (encoding == OBJ_ENCODING_INTSET) {\n                /* intset with intset is simple... and fast */\n                if (sets[j]->encoding == OBJ_ENCODING_INTSET &&\n                    !intsetFind((intset*)sets[j]->ptr,intobj))\n                {\n                    break;\n                /* in order to compare an integer with an object we\n                 * have to use the generic function, creating an object\n                 * for this */\n                } else if (sets[j]->encoding == OBJ_ENCODING_HT) {\n                    elesds = sdsfromlonglong(intobj);\n                    if (!setTypeIsMember(sets[j],elesds)) {\n                        sdsfree(elesds);\n                        break;\n                    }\n                    sdsfree(elesds);\n                }\n            } else if (encoding == OBJ_ENCODING_HT) {\n                if (!setTypeIsMember(sets[j],elesds)) {\n                    break;\n                }\n            }\n        }\n\n        /* Only take action when all sets contain the member */\n        if (j == setnum) {\n            if (cardinality_only) {\n                cardinality++;\n\n                /* We stop the searching after reaching the limit. */\n                if (limit && cardinality >= limit)\n                    break;\n            } else if (!dstkey) {\n                if (encoding == OBJ_ENCODING_HT)\n                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));\n                else\n                    addReplyBulkLongLong(c,intobj);\n                cardinality++;\n            } else {\n                if (encoding == OBJ_ENCODING_INTSET) {\n                    elesds = sdsfromlonglong(intobj);\n                    setTypeAdd(dstset,elesds);\n                    sdsfree(elesds);\n                } else {\n                    setTypeAdd(dstset,elesds);\n                }\n            }\n        }\n    }\n    setTypeReleaseIterator(si);\n\n    if (cardinality_only) {\n        addReplyLongLong(c,cardinality);\n    } else if (dstkey) {\n        /* Store the resulting set into the target, if the intersection\n         * is not an empty set. */\n        if (setTypeSize(dstset) > 0) {\n            setKey(c,c->db,dstkey,dstset,0);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\"sinterstore\",\n                dstkey,c->db->id);\n            server.dirty++;\n        } else {\n            addReply(c,shared.czero);\n            if (dbDelete(c->db,dstkey)) {\n                server.dirty++;\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n            }\n        }\n        decrRefCount(dstset);\n    } else {\n        setDeferredSetLen(c,replylen,cardinality);\n    }\n    zfree(sets);\n}\n\n/* SINTER key [key ...] */\nvoid sinterCommand(client *c) {\n    sinterGenericCommand(c, c->argv+1,  c->argc-1, NULL, 0, 0);\n}\n\n/* SINTERCARD numkeys key [key ...] [LIMIT limit] */\nvoid sinterCardCommand(client *c) {\n    long j;\n    long numkeys = 0; /* Number of keys. */\n    long limit = 0;   /* 0 means not limit. */\n\n    if (getRangeLongFromObjectOrReply(c, c->argv[1], 1, LONG_MAX,\n                                      &numkeys, \"numkeys should be greater than 0\") != C_OK)\n        return;\n    if (numkeys > (c->argc - 2)) {\n        addReplyError(c, \"Number of keys can't be greater than number of args\");\n        return;\n    }\n\n    for (j = 2 + numkeys; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc - 1) - j;\n\n        if (!strcasecmp(opt, \"LIMIT\") && moreargs) {\n            j++;\n            if (getPositiveLongFromObjectOrReply(c, c->argv[j], &limit,\n                                                 \"LIMIT can't be negative\") != C_OK)\n                return;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n\n    sinterGenericCommand(c, c->argv+2, numkeys, NULL, 1, limit);\n}\n\n/* SINTERSTORE destination key [key ...] */\nvoid sinterstoreCommand(client *c) {\n    sinterGenericCommand(c, c->argv+2, c->argc-2, c->argv[1], 0, 0);\n}\n\nvoid sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,\n                              robj *dstkey, int op) {\n    robj **sets = zmalloc(sizeof(robj*)*setnum);\n    setTypeIterator *si;\n    robj *dstset = NULL;\n    sds ele;\n    int j, cardinality = 0;\n    int diff_algo = 1;\n    int sameset = 0; \n\n    for (j = 0; j < setnum; j++) {\n        robj *setobj = lookupKeyRead(c->db, setkeys[j]);\n        if (!setobj) {\n            sets[j] = NULL;\n            continue;\n        }\n        if (checkType(c,setobj,OBJ_SET)) {\n            zfree(sets);\n            return;\n        }\n        sets[j] = setobj;\n        if (j > 0 && sets[0] == sets[j]) {\n            sameset = 1; \n        }\n    }\n\n    /* Select what DIFF algorithm to use.\n     *\n     * Algorithm 1 is O(N*M) where N is the size of the element first set\n     * and M the total number of sets.\n     *\n     * Algorithm 2 is O(N) where N is the total number of elements in all\n     * the sets.\n     *\n     * We compute what is the best bet with the current input here. */\n    if (op == SET_OP_DIFF && sets[0] && !sameset) {\n        long long algo_one_work = 0, algo_two_work = 0;\n\n        for (j = 0; j < setnum; j++) {\n            if (sets[j] == NULL) continue;\n\n            algo_one_work += setTypeSize(sets[0]);\n            algo_two_work += setTypeSize(sets[j]);\n        }\n\n        /* Algorithm 1 has better constant times and performs less operations\n         * if there are elements in common. Give it some advantage. */\n        algo_one_work /= 2;\n        diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;\n\n        if (diff_algo == 1 && setnum > 1) {\n            /* With algorithm 1 it is better to order the sets to subtract\n             * by decreasing size, so that we are more likely to find\n             * duplicated elements ASAP. */\n            qsort(sets+1,setnum-1,sizeof(robj*),\n                qsortCompareSetsByRevCardinality);\n        }\n    }\n\n    /* We need a temp set object to store our union. If the dstkey\n     * is not NULL (that is, we are inside an SUNIONSTORE operation) then\n     * this set object will be the resulting object to set into the target key*/\n    dstset = createIntsetObject();\n\n    if (op == SET_OP_UNION) {\n        /* Union is trivial, just add every element of every set to the\n         * temporary set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (setTypeAdd(dstset,ele)) cardinality++;\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n        }\n    } else if (op == SET_OP_DIFF && sameset) {\n        /* At least one of the sets is the same one (same key) as the first one, result must be empty. */\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {\n        /* DIFF Algorithm 1:\n         *\n         * We perform the diff by iterating all the elements of the first set,\n         * and only adding it to the target set if the element does not exist\n         * into all the other sets.\n         *\n         * This way we perform at max N*M operations, where N is the size of\n         * the first set, and M the number of sets. */\n        si = setTypeInitIterator(sets[0]);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            for (j = 1; j < setnum; j++) {\n                if (!sets[j]) continue; /* no key is an empty set. */\n                if (sets[j] == sets[0]) break; /* same set! */\n                if (setTypeIsMember(sets[j],ele)) break;\n            }\n            if (j == setnum) {\n                /* There is no other set with this element. Add it. */\n                setTypeAdd(dstset,ele);\n                cardinality++;\n            }\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {\n        /* DIFF Algorithm 2:\n         *\n         * Add all the elements of the first set to the auxiliary set.\n         * Then remove all the elements of all the next sets from it.\n         *\n         * This is O(N) where N is the sum of all the elements in every\n         * set. */\n        for (j = 0; j < setnum; j++) {\n            if (!sets[j]) continue; /* non existing keys are like empty sets */\n\n            si = setTypeInitIterator(sets[j]);\n            while((ele = setTypeNextObject(si)) != NULL) {\n                if (j == 0) {\n                    if (setTypeAdd(dstset,ele)) cardinality++;\n                } else {\n                    if (setTypeRemove(dstset,ele)) cardinality--;\n                }\n                sdsfree(ele);\n            }\n            setTypeReleaseIterator(si);\n\n            /* Exit if result set is empty as any additional removal\n             * of elements will have no effect. */\n            if (cardinality == 0) break;\n        }\n    }\n\n    /* Output the content of the resulting set, if not in STORE mode */\n    if (!dstkey) {\n        addReplySetLen(c,cardinality);\n        si = setTypeInitIterator(dstset);\n        while((ele = setTypeNextObject(si)) != NULL) {\n            addReplyBulkCBuffer(c,ele,sdslen(ele));\n            sdsfree(ele);\n        }\n        setTypeReleaseIterator(si);\n        server.lazyfree_lazy_server_del ? freeObjAsync(NULL, dstset, -1) :\n                                          decrRefCount(dstset);\n    } else {\n        /* If we have a target key where to store the resulting set\n         * create this key with the result set inside */\n        if (setTypeSize(dstset) > 0) {\n            setKey(c,c->db,dstkey,dstset,0);\n            addReplyLongLong(c,setTypeSize(dstset));\n            notifyKeyspaceEvent(NOTIFY_SET,\n                op == SET_OP_UNION ? \"sunionstore\" : \"sdiffstore\",\n                dstkey,c->db->id);\n            server.dirty++;\n        } else {\n            addReply(c,shared.czero);\n            if (dbDelete(c->db,dstkey)) {\n                server.dirty++;\n                signalModifiedKey(c,c->db,dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",dstkey,c->db->id);\n            }\n        }\n        decrRefCount(dstset);\n    }\n    zfree(sets);\n}\n\n/* SUNION key [key ...] */\nvoid sunionCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);\n}\n\n/* SUNIONSTORE destination key [key ...] */\nvoid sunionstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);\n}\n\n/* SDIFF key [key ...] */\nvoid sdiffCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);\n}\n\n/* SDIFFSTORE destination key [key ...] */\nvoid sdiffstoreCommand(client *c) {\n    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);\n}\n\nvoid sscanCommand(client *c) {\n    robj *set;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,set,OBJ_SET)) return;\n    scanGenericCommand(c,set,cursor);\n}\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*-----------------------------------------------------------------------------\n * Sorted set API\n *----------------------------------------------------------------------------*/\n\n/* ZSETs are ordered sets using two data structures to hold the same elements\n * in order to get O(log(N)) INSERT and REMOVE operations into a sorted\n * data structure.\n *\n * The elements are added to a hash table mapping Redis objects to scores.\n * At the same time the elements are added to a skip list mapping scores\n * to Redis objects (so objects are sorted by scores in this \"view\").\n *\n * Note that the SDS string representing the element is the same in both\n * the hash table and skiplist in order to save memory. What we do in order\n * to manage the shared SDS string more easily is to free the SDS string\n * only in zslFreeNode(). The dictionary has no value free method set.\n * So we should always remove an element from the dictionary, and later from\n * the skiplist.\n *\n * This skiplist implementation is almost a C translation of the original\n * algorithm described by William Pugh in \"Skip Lists: A Probabilistic\n * Alternative to Balanced Trees\", modified in three ways:\n * a) this implementation allows for repeated scores.\n * b) the comparison is not just by key (our 'score') but by satellite data.\n * c) there is a back pointer, so it's a doubly linked list with the back\n * pointers being only at \"level 1\". This allows to traverse the list\n * from tail to head, useful for ZREVRANGE. */\n\n#include \"server.h\"\n#include <math.h>\n\n/*-----------------------------------------------------------------------------\n * Skiplist implementation of the low level API\n *----------------------------------------------------------------------------*/\n\nint zslLexValueGteMin(sds value, zlexrangespec *spec);\nint zslLexValueLteMax(sds value, zlexrangespec *spec);\n\n/* Create a skiplist node with the specified number of levels.\n * The SDS string 'ele' is referenced by the node after the call. */\nzskiplistNode *zslCreateNode(int level, double score, sds ele) {\n    zskiplistNode *zn =\n        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));\n    zn->score = score;\n    zn->ele = ele;\n    return zn;\n}\n\n/* Create a new skiplist. */\nzskiplist *zslCreate(void) {\n    int j;\n    zskiplist *zsl;\n\n    zsl = zmalloc(sizeof(*zsl));\n    zsl->level = 1;\n    zsl->length = 0;\n    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);\n    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {\n        zsl->header->level[j].forward = NULL;\n        zsl->header->level[j].span = 0;\n    }\n    zsl->header->backward = NULL;\n    zsl->tail = NULL;\n    return zsl;\n}\n\n/* Free the specified skiplist node. The referenced SDS string representation\n * of the element is freed too, unless node->ele is set to NULL before calling\n * this function. */\nvoid zslFreeNode(zskiplistNode *node) {\n    sdsfree(node->ele);\n    zfree(node);\n}\n\n/* Free a whole skiplist. */\nvoid zslFree(zskiplist *zsl) {\n    zskiplistNode *node = zsl->header->level[0].forward, *next;\n\n    zfree(zsl->header);\n    while(node) {\n        next = node->level[0].forward;\n        zslFreeNode(node);\n        node = next;\n    }\n    zfree(zsl);\n}\n\n/* Returns a random level for the new skiplist node we are going to create.\n * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL\n * (both inclusive), with a powerlaw-alike distribution where higher\n * levels are less likely to be returned. */\nint zslRandomLevel(void) {\n    static const int threshold = ZSKIPLIST_P*RAND_MAX;\n    int level = 1;\n    while (random() < threshold)\n        level += 1;\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\n}\n\n/* Insert a new node in the skiplist. Assumes the element does not already\n * exist (up to the caller to enforce that). The skiplist takes ownership\n * of the passed SDS string 'ele'. */\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long rank[ZSKIPLIST_MAXLEVEL];\n    int i, level;\n\n    serverAssert(!isnan(score));\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            rank[i] += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    /* we assume the element is not already inside, since we allow duplicated\n     * scores, reinserting the same element should never happen since the\n     * caller of zslInsert() should test in the hash table if the element is\n     * already inside or not. */\n    level = zslRandomLevel();\n    if (level > zsl->level) {\n        for (i = zsl->level; i < level; i++) {\n            rank[i] = 0;\n            update[i] = zsl->header;\n            update[i]->level[i].span = zsl->length;\n        }\n        zsl->level = level;\n    }\n    x = zslCreateNode(level,score,ele);\n    for (i = 0; i < level; i++) {\n        x->level[i].forward = update[i]->level[i].forward;\n        update[i]->level[i].forward = x;\n\n        /* update span covered by update[i] as x is inserted here */\n        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);\n        update[i]->level[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    /* increment span for untouched levels */\n    for (i = level; i < zsl->level; i++) {\n        update[i]->level[i].span++;\n    }\n\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\n    if (x->level[0].forward)\n        x->level[0].forward->backward = x;\n    else\n        zsl->tail = x;\n    zsl->length++;\n    return x;\n}\n\n/* Internal function used by zslDelete, zslDeleteRangeByScore and\n * zslDeleteRangeByRank. */\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {\n    int i;\n    for (i = 0; i < zsl->level; i++) {\n        if (update[i]->level[i].forward == x) {\n            update[i]->level[i].span += x->level[i].span - 1;\n            update[i]->level[i].forward = x->level[i].forward;\n        } else {\n            update[i]->level[i].span -= 1;\n        }\n    }\n    if (x->level[0].forward) {\n        x->level[0].forward->backward = x->backward;\n    } else {\n        zsl->tail = x->backward;\n    }\n    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)\n        zsl->level--;\n    zsl->length--;\n}\n\n/* Delete an element with matching score/element from the skiplist.\n * The function returns 1 if the node was found and deleted, otherwise\n * 0 is returned.\n *\n * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise\n * it is not freed (but just unlinked) and *node is set to the node pointer,\n * so that it is possible for the caller to reuse the node (including the\n * referenced SDS string at node->ele). */\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                     sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    /* We may have multiple elements with the same score, what we need\n     * is to find the element with both the right score and object. */\n    x = x->level[0].forward;\n    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {\n        zslDeleteNode(zsl, x, update);\n        if (!node)\n            zslFreeNode(x);\n        else\n            *node = x;\n        return 1;\n    }\n    return 0; /* not found */\n}\n\n/* Update the score of an element inside the sorted set skiplist.\n * Note that the element must exist and must match 'score'.\n * This function does not update the score in the hash table side, the\n * caller should take care of it.\n *\n * Note that this function attempts to just update the node, in case after\n * the score update, the node would be exactly at the same position.\n * Otherwise the skiplist is modified by removing and re-adding a new\n * element, which is more costly.\n *\n * The function returns the updated element skiplist node pointer. */\nzskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    /* We need to seek to element to update to start: this is useful anyway,\n     * we'll have to update or remove it. */\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < curscore ||\n                    (x->level[i].forward->score == curscore &&\n                     sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n\n    /* Jump to our element: note that this function assumes that the\n     * element with the matching score exists. */\n    x = x->level[0].forward;\n    serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);\n\n    /* If the node, after the score update, would be still exactly\n     * at the same position, we can just update the score without\n     * actually removing and re-inserting the element in the skiplist. */\n    if ((x->backward == NULL || x->backward->score < newscore) &&\n        (x->level[0].forward == NULL || x->level[0].forward->score > newscore))\n    {\n        x->score = newscore;\n        return x;\n    }\n\n    /* No way to reuse the old node: we need to remove and insert a new\n     * one at a different place. */\n    zslDeleteNode(zsl, x, update);\n    zskiplistNode *newnode = zslInsert(zsl,newscore,x->ele);\n    /* We reused the old node x->ele SDS string, free the node now\n     * since zslInsert created a new one. */\n    x->ele = NULL;\n    zslFreeNode(x);\n    return newnode;\n}\n\nint zslValueGteMin(double value, zrangespec *spec) {\n    return spec->minex ? (value > spec->min) : (value >= spec->min);\n}\n\nint zslValueLteMax(double value, zrangespec *spec) {\n    return spec->maxex ? (value < spec->max) : (value <= spec->max);\n}\n\n/* Returns if there is a part of the zset is in range. */\nint zslIsInRange(zskiplist *zsl, zrangespec *range) {\n    zskiplistNode *x;\n\n    /* Test for ranges that will always be empty. */\n    if (range->min > range->max ||\n            (range->min == range->max && (range->minex || range->maxex)))\n        return 0;\n    x = zsl->tail;\n    if (x == NULL || !zslValueGteMin(x->score,range))\n        return 0;\n    x = zsl->header->level[0].forward;\n    if (x == NULL || !zslValueLteMax(x->score,range))\n        return 0;\n    return 1;\n}\n\n/* Find the first node that is contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *OUT* of range. */\n        while (x->level[i].forward &&\n            !zslValueGteMin(x->level[i].forward->score,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so the next node cannot be NULL. */\n    x = x->level[0].forward;\n    serverAssert(x != NULL);\n\n    /* Check if score <= max. */\n    if (!zslValueLteMax(x->score,range)) return NULL;\n    return x;\n}\n\n/* Find the last node that is contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *IN* range. */\n        while (x->level[i].forward &&\n            zslValueLteMax(x->level[i].forward->score,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so this node cannot be NULL. */\n    serverAssert(x != NULL);\n\n    /* Check if score >= min. */\n    if (!zslValueGteMin(x->score,range)) return NULL;\n    return x;\n}\n\n/* Delete all the elements with score between min and max from the skiplist.\n * Both min and max can be inclusive or exclusive (see range->minex and\n * range->maxex). When inclusive a score >= min && score <= max is deleted.\n * Note that this function takes the reference to the hash table view of the\n * sorted set, in order to remove the elements from the hash table too. */\nunsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long removed = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            !zslValueGteMin(x->level[i].forward->score, range))\n                x = x->level[i].forward;\n        update[i] = x;\n    }\n\n    /* Current node is the last with score < or <= min. */\n    x = x->level[0].forward;\n\n    /* Delete nodes while in range. */\n    while (x && zslValueLteMax(x->score, range)) {\n        zskiplistNode *next = x->level[0].forward;\n        zslDeleteNode(zsl,x,update);\n        dictDelete(dict,x->ele);\n        zslFreeNode(x); /* Here is where x->ele is actually released. */\n        removed++;\n        x = next;\n    }\n    return removed;\n}\n\nunsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long removed = 0;\n    int i;\n\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            !zslLexValueGteMin(x->level[i].forward->ele,range))\n                x = x->level[i].forward;\n        update[i] = x;\n    }\n\n    /* Current node is the last with score < or <= min. */\n    x = x->level[0].forward;\n\n    /* Delete nodes while in range. */\n    while (x && zslLexValueLteMax(x->ele,range)) {\n        zskiplistNode *next = x->level[0].forward;\n        zslDeleteNode(zsl,x,update);\n        dictDelete(dict,x->ele);\n        zslFreeNode(x); /* Here is where x->ele is actually released. */\n        removed++;\n        x = next;\n    }\n    return removed;\n}\n\n/* Delete all the elements with rank between start and end from the skiplist.\n * Start and end are inclusive. Note that start and end need to be 1-based */\nunsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long traversed = 0, removed = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward && (traversed + x->level[i].span) < start) {\n            traversed += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n\n    traversed++;\n    x = x->level[0].forward;\n    while (x && traversed <= end) {\n        zskiplistNode *next = x->level[0].forward;\n        zslDeleteNode(zsl,x,update);\n        dictDelete(dict,x->ele);\n        zslFreeNode(x);\n        removed++;\n        traversed++;\n        x = next;\n    }\n    return removed;\n}\n\n/* Find the rank for an element by both score and key.\n * Returns 0 when the element cannot be found, rank otherwise.\n * Note that the rank is 1-based due to the span of zsl->header to the\n * first element. */\nunsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *x;\n    unsigned long rank = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            (x->level[i].forward->score < score ||\n                (x->level[i].forward->score == score &&\n                sdscmp(x->level[i].forward->ele,ele) <= 0))) {\n            rank += x->level[i].span;\n            x = x->level[i].forward;\n        }\n\n        /* x might be equal to zsl->header, so test if obj is non-NULL */\n        if (x->ele && x->score == score && sdscmp(x->ele,ele) == 0) {\n            return rank;\n        }\n    }\n    return 0;\n}\n\n/* Finds an element by its rank. The rank argument needs to be 1-based. */\nzskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {\n    zskiplistNode *x;\n    unsigned long traversed = 0;\n    int i;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward && (traversed + x->level[i].span) <= rank)\n        {\n            traversed += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        if (traversed == rank) {\n            return x;\n        }\n    }\n    return NULL;\n}\n\n/* Populate the rangespec according to the objects min and max. */\nstatic int zslParseRange(robj *min, robj *max, zrangespec *spec) {\n    char *eptr;\n    spec->minex = spec->maxex = 0;\n\n    /* Parse the min-max interval. If one of the values is prefixed\n     * by the \"(\" character, it's considered \"open\". For instance\n     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max\n     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */\n    if (min->encoding == OBJ_ENCODING_INT) {\n        spec->min = (long)min->ptr;\n    } else {\n        if (((char*)min->ptr)[0] == '(') {\n            spec->min = strtod((char*)min->ptr+1,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->min)) return C_ERR;\n            spec->minex = 1;\n        } else {\n            spec->min = strtod((char*)min->ptr,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->min)) return C_ERR;\n        }\n    }\n    if (max->encoding == OBJ_ENCODING_INT) {\n        spec->max = (long)max->ptr;\n    } else {\n        if (((char*)max->ptr)[0] == '(') {\n            spec->max = strtod((char*)max->ptr+1,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->max)) return C_ERR;\n            spec->maxex = 1;\n        } else {\n            spec->max = strtod((char*)max->ptr,&eptr);\n            if (eptr[0] != '\\0' || isnan(spec->max)) return C_ERR;\n        }\n    }\n\n    return C_OK;\n}\n\n/* ------------------------ Lexicographic ranges ---------------------------- */\n\n/* Parse max or min argument of ZRANGEBYLEX.\n  * (foo means foo (open interval)\n  * [foo means foo (closed interval)\n  * - means the min string possible\n  * + means the max string possible\n  *\n  * If the string is valid the *dest pointer is set to the redis object\n  * that will be used for the comparison, and ex will be set to 0 or 1\n  * respectively if the item is exclusive or inclusive. C_OK will be\n  * returned.\n  *\n  * If the string is not a valid range C_ERR is returned, and the value\n  * of *dest and *ex is undefined. */\nint zslParseLexRangeItem(robj *item, sds *dest, int *ex) {\n    char *c = item->ptr;\n\n    switch(c[0]) {\n    case '+':\n        if (c[1] != '\\0') return C_ERR;\n        *ex = 1;\n        *dest = shared.maxstring;\n        return C_OK;\n    case '-':\n        if (c[1] != '\\0') return C_ERR;\n        *ex = 1;\n        *dest = shared.minstring;\n        return C_OK;\n    case '(':\n        *ex = 1;\n        *dest = sdsnewlen(c+1,sdslen(c)-1);\n        return C_OK;\n    case '[':\n        *ex = 0;\n        *dest = sdsnewlen(c+1,sdslen(c)-1);\n        return C_OK;\n    default:\n        return C_ERR;\n    }\n}\n\n/* Free a lex range structure, must be called only after zslParseLexRange()\n * populated the structure with success (C_OK returned). */\nvoid zslFreeLexRange(zlexrangespec *spec) {\n    if (spec->min != shared.minstring &&\n        spec->min != shared.maxstring) sdsfree(spec->min);\n    if (spec->max != shared.minstring &&\n        spec->max != shared.maxstring) sdsfree(spec->max);\n}\n\n/* Populate the lex rangespec according to the objects min and max.\n *\n * Return C_OK on success. On error C_ERR is returned.\n * When OK is returned the structure must be freed with zslFreeLexRange(),\n * otherwise no release is needed. */\nint zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {\n    /* The range can't be valid if objects are integer encoded.\n     * Every item must start with ( or [. */\n    if (min->encoding == OBJ_ENCODING_INT ||\n        max->encoding == OBJ_ENCODING_INT) return C_ERR;\n\n    spec->min = spec->max = NULL;\n    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||\n        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {\n        zslFreeLexRange(spec);\n        return C_ERR;\n    } else {\n        return C_OK;\n    }\n}\n\n/* This is just a wrapper to sdscmp() that is able to\n * handle shared.minstring and shared.maxstring as the equivalent of\n * -inf and +inf for strings */\nint sdscmplex(sds a, sds b) {\n    if (a == b) return 0;\n    if (a == shared.minstring || b == shared.maxstring) return -1;\n    if (a == shared.maxstring || b == shared.minstring) return 1;\n    return sdscmp(a,b);\n}\n\nint zslLexValueGteMin(sds value, zlexrangespec *spec) {\n    return spec->minex ?\n        (sdscmplex(value,spec->min) > 0) :\n        (sdscmplex(value,spec->min) >= 0);\n}\n\nint zslLexValueLteMax(sds value, zlexrangespec *spec) {\n    return spec->maxex ?\n        (sdscmplex(value,spec->max) < 0) :\n        (sdscmplex(value,spec->max) <= 0);\n}\n\n/* Returns if there is a part of the zset is in the lex range. */\nint zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {\n    zskiplistNode *x;\n\n    /* Test for ranges that will always be empty. */\n    int cmp = sdscmplex(range->min,range->max);\n    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))\n        return 0;\n    x = zsl->tail;\n    if (x == NULL || !zslLexValueGteMin(x->ele,range))\n        return 0;\n    x = zsl->header->level[0].forward;\n    if (x == NULL || !zslLexValueLteMax(x->ele,range))\n        return 0;\n    return 1;\n}\n\n/* Find the first node that is contained in the specified lex range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInLexRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *OUT* of range. */\n        while (x->level[i].forward &&\n            !zslLexValueGteMin(x->level[i].forward->ele,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so the next node cannot be NULL. */\n    x = x->level[0].forward;\n    serverAssert(x != NULL);\n\n    /* Check if score <= max. */\n    if (!zslLexValueLteMax(x->ele,range)) return NULL;\n    return x;\n}\n\n/* Find the last node that is contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nzskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {\n    zskiplistNode *x;\n    int i;\n\n    /* If everything is out of range, return early. */\n    if (!zslIsInLexRange(zsl,range)) return NULL;\n\n    x = zsl->header;\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* Go forward while *IN* range. */\n        while (x->level[i].forward &&\n            zslLexValueLteMax(x->level[i].forward->ele,range))\n                x = x->level[i].forward;\n    }\n\n    /* This is an inner range, so this node cannot be NULL. */\n    serverAssert(x != NULL);\n\n    /* Check if score >= min. */\n    if (!zslLexValueGteMin(x->ele,range)) return NULL;\n    return x;\n}\n\n/*-----------------------------------------------------------------------------\n * Listpack-backed sorted set API\n *----------------------------------------------------------------------------*/\n\ndouble zzlStrtod(unsigned char *vstr, unsigned int vlen) {\n    char buf[128];\n    if (vlen > sizeof(buf) - 1)\n        vlen = sizeof(buf) - 1;\n    memcpy(buf,vstr,vlen);\n    buf[vlen] = '\\0';\n    return strtod(buf,NULL);\n }\n\ndouble zzlGetScore(unsigned char *sptr) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n    double score;\n\n    serverAssert(sptr != NULL);\n    vstr = lpGetValue(sptr,&vlen,&vlong);\n\n    if (vstr) {\n        score = zzlStrtod(vstr,vlen);\n    } else {\n        score = vlong;\n    }\n\n    return score;\n}\n\n/* Return a listpack element as an SDS string. */\nsds lpGetObject(unsigned char *sptr) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n\n    serverAssert(sptr != NULL);\n    vstr = lpGetValue(sptr,&vlen,&vlong);\n\n    if (vstr) {\n        return sdsnewlen((char*)vstr,vlen);\n    } else {\n        return sdsfromlonglong(vlong);\n    }\n}\n\n/* Compare element in sorted set with given element. */\nint zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vlong;\n    unsigned char vbuf[32];\n    int minlen, cmp;\n\n    vstr = lpGetValue(eptr,&vlen,&vlong);\n    if (vstr == NULL) {\n        /* Store string representation of long long in buf. */\n        vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);\n        vstr = vbuf;\n    }\n\n    minlen = (vlen < clen) ? vlen : clen;\n    cmp = memcmp(vstr,cstr,minlen);\n    if (cmp == 0) return vlen-clen;\n    return cmp;\n}\n\nunsigned int zzlLength(unsigned char *zl) {\n    return lpLength(zl)/2;\n}\n\n/* Move to next entry based on the values in eptr and sptr. Both are set to\n * NULL when there is no next entry. */\nvoid zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {\n    unsigned char *_eptr, *_sptr;\n    serverAssert(*eptr != NULL && *sptr != NULL);\n\n    _eptr = lpNext(zl,*sptr);\n    if (_eptr != NULL) {\n        _sptr = lpNext(zl,_eptr);\n        serverAssert(_sptr != NULL);\n    } else {\n        /* No next entry. */\n        _sptr = NULL;\n    }\n\n    *eptr = _eptr;\n    *sptr = _sptr;\n}\n\n/* Move to the previous entry based on the values in eptr and sptr. Both are\n * set to NULL when there is no prev entry. */\nvoid zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {\n    unsigned char *_eptr, *_sptr;\n    serverAssert(*eptr != NULL && *sptr != NULL);\n\n    _sptr = lpPrev(zl,*eptr);\n    if (_sptr != NULL) {\n        _eptr = lpPrev(zl,_sptr);\n        serverAssert(_eptr != NULL);\n    } else {\n        /* No previous entry. */\n        _eptr = NULL;\n    }\n\n    *eptr = _eptr;\n    *sptr = _sptr;\n}\n\n/* Returns if there is a part of the zset is in range. Should only be used\n * internally by zzlFirstInRange and zzlLastInRange. */\nint zzlIsInRange(unsigned char *zl, zrangespec *range) {\n    unsigned char *p;\n    double score;\n\n    /* Test for ranges that will always be empty. */\n    if (range->min > range->max ||\n            (range->min == range->max && (range->minex || range->maxex)))\n        return 0;\n\n    p = lpSeek(zl,-1); /* Last score. */\n    if (p == NULL) return 0; /* Empty sorted set */\n    score = zzlGetScore(p);\n    if (!zslValueGteMin(score,range))\n        return 0;\n\n    p = lpSeek(zl,1); /* First score. */\n    serverAssert(p != NULL);\n    score = zzlGetScore(p);\n    if (!zslValueLteMax(score,range))\n        return 0;\n\n    return 1;\n}\n\n/* Find pointer to the first element contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,0), *sptr;\n    double score;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        score = zzlGetScore(sptr);\n        if (zslValueGteMin(score,range)) {\n            /* Check if score <= max. */\n            if (zslValueLteMax(score,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to next element. */\n        eptr = lpNext(zl,sptr);\n    }\n\n    return NULL;\n}\n\n/* Find pointer to the last element contained in the specified range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,-2), *sptr;\n    double score;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        score = zzlGetScore(sptr);\n        if (zslValueLteMax(score,range)) {\n            /* Check if score >= min. */\n            if (zslValueGteMin(score,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to previous element by moving to the score of previous element.\n         * When this returns NULL, we know there also is no element. */\n        sptr = lpPrev(zl,eptr);\n        if (sptr != NULL)\n            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);\n        else\n            eptr = NULL;\n    }\n\n    return NULL;\n}\n\nint zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {\n    sds value = lpGetObject(p);\n    int res = zslLexValueGteMin(value,spec);\n    sdsfree(value);\n    return res;\n}\n\nint zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {\n    sds value = lpGetObject(p);\n    int res = zslLexValueLteMax(value,spec);\n    sdsfree(value);\n    return res;\n}\n\n/* Returns if there is a part of the zset is in range. Should only be used\n * internally by zzlFirstInLexRange and zzlLastInLexRange. */\nint zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {\n    unsigned char *p;\n\n    /* Test for ranges that will always be empty. */\n    int cmp = sdscmplex(range->min,range->max);\n    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))\n        return 0;\n\n    p = lpSeek(zl,-2); /* Last element. */\n    if (p == NULL) return 0;\n    if (!zzlLexValueGteMin(p,range))\n        return 0;\n\n    p = lpSeek(zl,0); /* First element. */\n    serverAssert(p != NULL);\n    if (!zzlLexValueLteMax(p,range))\n        return 0;\n\n    return 1;\n}\n\n/* Find pointer to the first element contained in the specified lex range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,0), *sptr;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInLexRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        if (zzlLexValueGteMin(eptr,range)) {\n            /* Check if score <= max. */\n            if (zzlLexValueLteMax(eptr,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to next element. */\n        sptr = lpNext(zl,eptr); /* This element score. Skip it. */\n        serverAssert(sptr != NULL);\n        eptr = lpNext(zl,sptr); /* Next element. */\n    }\n\n    return NULL;\n}\n\n/* Find pointer to the last element contained in the specified lex range.\n * Returns NULL when no element is contained in the range. */\nunsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {\n    unsigned char *eptr = lpSeek(zl,-2), *sptr;\n\n    /* If everything is out of range, return early. */\n    if (!zzlIsInLexRange(zl,range)) return NULL;\n\n    while (eptr != NULL) {\n        if (zzlLexValueLteMax(eptr,range)) {\n            /* Check if score >= min. */\n            if (zzlLexValueGteMin(eptr,range))\n                return eptr;\n            return NULL;\n        }\n\n        /* Move to previous element by moving to the score of previous element.\n         * When this returns NULL, we know there also is no element. */\n        sptr = lpPrev(zl,eptr);\n        if (sptr != NULL)\n            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);\n        else\n            eptr = NULL;\n    }\n\n    return NULL;\n}\n\nunsigned char *zzlFind(unsigned char *lp, sds ele, double *score) {\n    unsigned char *eptr, *sptr;\n\n    if ((eptr = lpFirst(lp)) == NULL) return NULL;\n    eptr = lpFind(lp, eptr, (unsigned char*)ele, sdslen(ele), 1);\n    if (eptr) {\n        sptr = lpNext(lp,eptr);\n        serverAssert(sptr != NULL);\n\n        /* Matching element, pull out score. */\n        if (score != NULL) *score = zzlGetScore(sptr);\n        return eptr;\n    }\n\n    return NULL;\n}\n\n/* Delete (element,score) pair from listpack. Use local copy of eptr because we\n * don't want to modify the one given as argument. */\nunsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {\n    return lpDeleteRangeWithEntry(zl,&eptr,2);\n}\n\nunsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {\n    unsigned char *sptr;\n    char scorebuf[MAX_D2STRING_CHARS];\n    int scorelen;\n    long long lscore;\n    int score_is_long = double2ll(score, &lscore);\n    if (!score_is_long)\n        scorelen = d2string(scorebuf,sizeof(scorebuf),score);\n    if (eptr == NULL) {\n        zl = lpAppend(zl,(unsigned char*)ele,sdslen(ele));\n        if (score_is_long)\n            zl = lpAppendInteger(zl,lscore);\n        else\n            zl = lpAppend(zl,(unsigned char*)scorebuf,scorelen);\n    } else {\n        /* Insert member before the element 'eptr'. */\n        zl = lpInsertString(zl,(unsigned char*)ele,sdslen(ele),eptr,LP_BEFORE,&sptr);\n\n        /* Insert score after the member. */\n        if (score_is_long)\n            zl = lpInsertInteger(zl,lscore,sptr,LP_AFTER,NULL);\n        else\n            zl = lpInsertString(zl,(unsigned char*)scorebuf,scorelen,sptr,LP_AFTER,NULL);\n    }\n    return zl;\n}\n\n/* Insert (element,score) pair in listpack. This function assumes the element is\n * not yet present in the list. */\nunsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {\n    unsigned char *eptr = lpSeek(zl,0), *sptr;\n    double s;\n\n    while (eptr != NULL) {\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n        s = zzlGetScore(sptr);\n\n        if (s > score) {\n            /* First element with score larger than score for element to be\n             * inserted. This means we should take its spot in the list to\n             * maintain ordering. */\n            zl = zzlInsertAt(zl,eptr,ele,score);\n            break;\n        } else if (s == score) {\n            /* Ensure lexicographical ordering for elements. */\n            if (zzlCompareElements(eptr,(unsigned char*)ele,sdslen(ele)) > 0) {\n                zl = zzlInsertAt(zl,eptr,ele,score);\n                break;\n            }\n        }\n\n        /* Move to next element. */\n        eptr = lpNext(zl,sptr);\n    }\n\n    /* Push on tail of list when it was not yet inserted. */\n    if (eptr == NULL)\n        zl = zzlInsertAt(zl,NULL,ele,score);\n    return zl;\n}\n\nunsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {\n    unsigned char *eptr, *sptr;\n    double score;\n    unsigned long num = 0;\n\n    if (deleted != NULL) *deleted = 0;\n\n    eptr = zzlFirstInRange(zl,range);\n    if (eptr == NULL) return zl;\n\n    /* When the tail of the listpack is deleted, eptr will be NULL. */\n    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {\n        score = zzlGetScore(sptr);\n        if (zslValueLteMax(score,range)) {\n            /* Delete both the element and the score. */\n            zl = lpDeleteRangeWithEntry(zl,&eptr,2);\n            num++;\n        } else {\n            /* No longer in range. */\n            break;\n        }\n    }\n\n    if (deleted != NULL) *deleted = num;\n    return zl;\n}\n\nunsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {\n    unsigned char *eptr, *sptr;\n    unsigned long num = 0;\n\n    if (deleted != NULL) *deleted = 0;\n\n    eptr = zzlFirstInLexRange(zl,range);\n    if (eptr == NULL) return zl;\n\n    /* When the tail of the listpack is deleted, eptr will be NULL. */\n    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {\n        if (zzlLexValueLteMax(eptr,range)) {\n            /* Delete both the element and the score. */\n            zl = lpDeleteRangeWithEntry(zl,&eptr,2);\n            num++;\n        } else {\n            /* No longer in range. */\n            break;\n        }\n    }\n\n    if (deleted != NULL) *deleted = num;\n    return zl;\n}\n\n/* Delete all the elements with rank between start and end from the skiplist.\n * Start and end are inclusive. Note that start and end need to be 1-based */\nunsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {\n    unsigned int num = (end-start)+1;\n    if (deleted) *deleted = num;\n    zl = lpDeleteRange(zl,2*(start-1),2*num);\n    return zl;\n}\n\n/*-----------------------------------------------------------------------------\n * Common sorted set API\n *----------------------------------------------------------------------------*/\n\nunsigned long zsetLength(const robj *zobj) {\n    unsigned long length = 0;\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        length = zzlLength(zobj->ptr);\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        length = ((const zset*)zobj->ptr)->zsl->length;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return length;\n}\n\nvoid zsetConvert(robj *zobj, int encoding) {\n    zset *zs;\n    zskiplistNode *node, *next;\n    sds ele;\n    double score;\n\n    if (zobj->encoding == encoding) return;\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        if (encoding != OBJ_ENCODING_SKIPLIST)\n            serverPanic(\"Unknown target encoding\");\n\n        zs = zmalloc(sizeof(*zs));\n        zs->dict = dictCreate(&zsetDictType);\n        zs->zsl = zslCreate();\n\n        eptr = lpSeek(zl,0);\n        if (eptr != NULL) {\n            sptr = lpNext(zl,eptr);\n            serverAssertWithInfo(NULL,zobj,sptr != NULL);\n        }\n\n        while (eptr != NULL) {\n            score = zzlGetScore(sptr);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            if (vstr == NULL)\n                ele = sdsfromlonglong(vlong);\n            else\n                ele = sdsnewlen((char*)vstr,vlen);\n\n            node = zslInsert(zs->zsl,score,ele);\n            serverAssert(dictAdd(zs->dict,ele,&node->score) == DICT_OK);\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        zfree(zobj->ptr);\n        zobj->ptr = zs;\n        zobj->encoding = OBJ_ENCODING_SKIPLIST;\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        unsigned char *zl = lpNew(0);\n\n        if (encoding != OBJ_ENCODING_LISTPACK)\n            serverPanic(\"Unknown target encoding\");\n\n        /* Approach similar to zslFree(), since we want to free the skiplist at\n         * the same time as creating the listpack. */\n        zs = zobj->ptr;\n        dictRelease(zs->dict);\n        node = zs->zsl->header->level[0].forward;\n        zfree(zs->zsl->header);\n        zfree(zs->zsl);\n\n        while (node) {\n            zl = zzlInsertAt(zl,NULL,node->ele,node->score);\n            next = node->level[0].forward;\n            zslFreeNode(node);\n            node = next;\n        }\n\n        zfree(zs);\n        zobj->ptr = zl;\n        zobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}\n\n/* Convert the sorted set object into a listpack if it is not already a listpack\n * and if the number of elements and the maximum element size and total elements size\n * are within the expected ranges. */\nvoid zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;\n    zset *zset = zobj->ptr;\n\n    if (zset->zsl->length <= server.zset_max_listpack_entries &&\n        maxelelen <= server.zset_max_listpack_value &&\n        lpSafeToAdd(NULL, totelelen))\n    {\n        zsetConvert(zobj,OBJ_ENCODING_LISTPACK);\n    }\n}\n\n/* Return (by reference) the score of the specified member of the sorted set\n * storing it into *score. If the element does not exist C_ERR is returned\n * otherwise C_OK is returned and *score is correctly populated.\n * If 'zobj' or 'member' is NULL, C_ERR is returned. */\nint zsetScore(robj *zobj, sds member, double *score) {\n    if (!zobj || !member) return C_ERR;\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        dictEntry *de = dictFind(zs->dict, member);\n        if (de == NULL) return C_ERR;\n        *score = *(double*)dictGetVal(de);\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return C_OK;\n}\n\n/* Add a new element or update the score of an existing element in a sorted\n * set, regardless of its encoding.\n *\n * The set of flags change the command behavior. \n *\n * The input flags are the following:\n *\n * ZADD_INCR: Increment the current element score by 'score' instead of updating\n *            the current element score. If the element does not exist, we\n *            assume 0 as previous score.\n * ZADD_NX:   Perform the operation only if the element does not exist.\n * ZADD_XX:   Perform the operation only if the element already exist.\n * ZADD_GT:   Perform the operation on existing elements only if the new score is \n *            greater than the current score.\n * ZADD_LT:   Perform the operation on existing elements only if the new score is \n *            less than the current score.\n *\n * When ZADD_INCR is used, the new score of the element is stored in\n * '*newscore' if 'newscore' is not NULL.\n *\n * The returned flags are the following:\n *\n * ZADD_NAN:     The resulting score is not a number.\n * ZADD_ADDED:   The element was added (not present before the call).\n * ZADD_UPDATED: The element score was updated.\n * ZADD_NOP:     No operation was performed because of NX or XX.\n *\n * Return value:\n *\n * The function returns 1 on success, and sets the appropriate flags\n * ADDED or UPDATED to signal what happened during the operation (note that\n * none could be set if we re-added an element using the same score it used\n * to have, or in the case a zero increment is used).\n *\n * The function returns 0 on error, currently only when the increment\n * produces a NAN condition, or when the 'score' value is NAN since the\n * start.\n *\n * The command as a side effect of adding a new element may convert the sorted\n * set internal encoding from listpack to hashtable+skiplist.\n *\n * Memory management of 'ele':\n *\n * The function does not take ownership of the 'ele' SDS string, but copies\n * it if needed. */\nint zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {\n    /* Turn options into simple to check vars. */\n    int incr = (in_flags & ZADD_IN_INCR) != 0;\n    int nx = (in_flags & ZADD_IN_NX) != 0;\n    int xx = (in_flags & ZADD_IN_XX) != 0;\n    int gt = (in_flags & ZADD_IN_GT) != 0;\n    int lt = (in_flags & ZADD_IN_LT) != 0;\n    *out_flags = 0; /* We'll return our response flags. */\n    double curscore;\n\n    /* NaN as input is an error regardless of all the other parameters. */\n    if (isnan(score)) {\n        *out_flags = ZADD_OUT_NAN;\n        return 0;\n    }\n\n    /* Update the sorted set according to its encoding. */\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *eptr;\n\n        if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {\n            /* NX? Return, same element already exists. */\n            if (nx) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            /* Prepare the score for the increment if needed. */\n            if (incr) {\n                score += curscore;\n                if (isnan(score)) {\n                    *out_flags |= ZADD_OUT_NAN;\n                    return 0;\n                }\n            }\n\n            /* GT/LT? Only update if score is greater/less than current. */\n            if ((lt && score >= curscore) || (gt && score <= curscore)) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            if (newscore) *newscore = score;\n\n            /* Remove and re-insert when score changed. */\n            if (score != curscore) {\n                zobj->ptr = zzlDelete(zobj->ptr,eptr);\n                zobj->ptr = zzlInsert(zobj->ptr,ele,score);\n                *out_flags |= ZADD_OUT_UPDATED;\n            }\n            return 1;\n        } else if (!xx) {\n            /* check if the element is too large or the list\n             * becomes too long *before* executing zzlInsert. */\n            if (zzlLength(zobj->ptr)+1 > server.zset_max_listpack_entries ||\n                sdslen(ele) > server.zset_max_listpack_value ||\n                !lpSafeToAdd(zobj->ptr, sdslen(ele)))\n            {\n                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);\n            } else {\n                zobj->ptr = zzlInsert(zobj->ptr,ele,score);\n                if (newscore) *newscore = score;\n                *out_flags |= ZADD_OUT_ADDED;\n                return 1;\n            }\n        } else {\n            *out_flags |= ZADD_OUT_NOP;\n            return 1;\n        }\n    }\n\n    /* Note that the above block handling listpack would have either returned or\n     * converted the key to skiplist. */\n    if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplistNode *znode;\n        dictEntry *de;\n\n        de = dictFind(zs->dict,ele);\n        if (de != NULL) {\n            /* NX? Return, same element already exists. */\n            if (nx) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            curscore = *(double*)dictGetVal(de);\n\n            /* Prepare the score for the increment if needed. */\n            if (incr) {\n                score += curscore;\n                if (isnan(score)) {\n                    *out_flags |= ZADD_OUT_NAN;\n                    return 0;\n                }\n            }\n\n            /* GT/LT? Only update if score is greater/less than current. */\n            if ((lt && score >= curscore) || (gt && score <= curscore)) {\n                *out_flags |= ZADD_OUT_NOP;\n                return 1;\n            }\n\n            if (newscore) *newscore = score;\n\n            /* Remove and re-insert when score changes. */\n            if (score != curscore) {\n                znode = zslUpdateScore(zs->zsl,curscore,ele,score);\n                /* Note that we did not removed the original element from\n                 * the hash table representing the sorted set, so we just\n                 * update the score. */\n                dictGetVal(de) = &znode->score; /* Update score ptr. */\n                *out_flags |= ZADD_OUT_UPDATED;\n            }\n            return 1;\n        } else if (!xx) {\n            ele = sdsdup(ele);\n            znode = zslInsert(zs->zsl,score,ele);\n            serverAssert(dictAdd(zs->dict,ele,&znode->score) == DICT_OK);\n            *out_flags |= ZADD_OUT_ADDED;\n            if (newscore) *newscore = score;\n            return 1;\n        } else {\n            *out_flags |= ZADD_OUT_NOP;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return 0; /* Never reached. */\n}\n\n/* Deletes the element 'ele' from the sorted set encoded as a skiplist+dict,\n * returning 1 if the element existed and was deleted, 0 otherwise (the\n * element was not there). It does not resize the dict after deleting the\n * element. */\nstatic int zsetRemoveFromSkiplist(zset *zs, sds ele) {\n    dictEntry *de;\n    double score;\n\n    de = dictUnlink(zs->dict,ele);\n    if (de != NULL) {\n        /* Get the score in order to delete from the skiplist later. */\n        score = *(double*)dictGetVal(de);\n\n        /* Delete from the hash table and later from the skiplist.\n         * Note that the order is important: deleting from the skiplist\n         * actually releases the SDS string representing the element,\n         * which is shared between the skiplist and the hash table, so\n         * we need to delete from the skiplist as the final step. */\n        dictFreeUnlinkedEntry(zs->dict,de);\n\n        /* Delete from skiplist. */\n        int retval = zslDelete(zs->zsl,score,ele,NULL);\n        serverAssert(retval);\n\n        return 1;\n    }\n\n    return 0;\n}\n\n/* Delete the element 'ele' from the sorted set, returning 1 if the element\n * existed and was deleted, 0 otherwise (the element was not there). */\nint zsetDel(robj *zobj, sds ele) {\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *eptr;\n\n        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {\n            zobj->ptr = zzlDelete(zobj->ptr,eptr);\n            return 1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        if (zsetRemoveFromSkiplist(zs, ele)) {\n            if (htNeedsResize(zs->dict)) dictResize(zs->dict);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return 0; /* No such element found. */\n}\n\n/* Given a sorted set object returns the 0-based rank of the object or\n * -1 if the object does not exist.\n *\n * For rank we mean the position of the element in the sorted collection\n * of elements. So the first element has rank 0, the second rank 1, and so\n * forth up to length-1 elements.\n *\n * If 'reverse' is false, the rank is returned considering as first element\n * the one with the lowest score. Otherwise if 'reverse' is non-zero\n * the rank is computed considering as element with rank 0 the one with\n * the highest score. */\nlong zsetRank(robj *zobj, sds ele, int reverse) {\n    unsigned long llen;\n    unsigned long rank;\n\n    llen = zsetLength(zobj);\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n\n        eptr = lpSeek(zl,0);\n        serverAssert(eptr != NULL);\n        sptr = lpNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        rank = 1;\n        while(eptr != NULL) {\n            if (lpCompare(eptr,(unsigned char*)ele,sdslen(ele)))\n                break;\n            rank++;\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        if (eptr != NULL) {\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        dictEntry *de;\n        double score;\n\n        de = dictFind(zs->dict,ele);\n        if (de != NULL) {\n            score = *(double*)dictGetVal(de);\n            rank = zslGetRank(zsl,score,ele);\n            /* Existing elements always have a rank. */\n            serverAssert(rank != 0);\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a sorted set object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *zsetDup(robj *o) {\n    robj *zobj;\n    zset *zs;\n    zset *new_zs;\n\n    serverAssert(o->type == OBJ_ZSET);\n\n    /* Create a new sorted set object that have the same encoding as the original object's encoding */\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = o->ptr;\n        size_t sz = lpBytes(zl);\n        unsigned char *new_zl = zmalloc(sz);\n        memcpy(new_zl, zl, sz);\n        zobj = createObject(OBJ_ZSET, new_zl);\n        zobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {\n        zobj = createZsetObject();\n        zs = o->ptr;\n        new_zs = zobj->ptr;\n        dictExpand(new_zs->dict,dictSize(zs->dict));\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds ele;\n        long llen = zsetLength(o);\n\n        /* We copy the skiplist elements from the greatest to the\n         * smallest (that's trivial since the elements are already ordered in\n         * the skiplist): this improves the load process, since the next loaded\n         * element will always be the smaller, so adding to the skiplist\n         * will always immediately stop at the head, making the insertion\n         * O(1) instead of O(log(N)). */\n        ln = zsl->tail;\n        while (llen--) {\n            ele = ln->ele;\n            sds new_ele = sdsdup(ele);\n            zskiplistNode *znode = zslInsert(new_zs->zsl,ln->score,new_ele);\n            dictAdd(new_zs->dict,new_ele,&znode->score);\n            ln = ln->backward;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return zobj;\n}\n\n/* Create a new sds string from the listpack entry. */\nsds zsetSdsFromListpackEntry(listpackEntry *e) {\n    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);\n}\n\n/* Reply with bulk string from the listpack entry. */\nvoid zsetReplyFromListpackEntry(client *c, listpackEntry *e) {\n    if (e->sval)\n        addReplyBulkCBuffer(c, e->sval, e->slen);\n    else\n        addReplyBulkLongLong(c, e->lval);\n}\n\n\n/* Return random element from a non empty zset.\n * 'key' and 'val' will be set to hold the element.\n * The memory in `key` is not to be freed or modified by the caller.\n * 'score' can be NULL in which case it's not extracted. */\nvoid zsetTypeRandomElement(robj *zsetobj, unsigned long zsetsize, listpackEntry *key, double *score) {\n    if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zsetobj->ptr;\n        dictEntry *de = dictGetFairRandomKey(zs->dict);\n        sds s = dictGetKey(de);\n        key->sval = (unsigned char*)s;\n        key->slen = sdslen(s);\n        if (score)\n            *score = *(double*)dictGetVal(de);\n    } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {\n        listpackEntry val;\n        lpRandomPair(zsetobj->ptr, zsetsize, key, &val);\n        if (score) {\n            if (val.sval) {\n                *score = zzlStrtod(val.sval,val.slen);\n            } else {\n                *score = (double)val.lval;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown zset encoding\");\n    }\n}\n\n/*-----------------------------------------------------------------------------\n * Sorted set commands\n *----------------------------------------------------------------------------*/\n\n/* This generic command implements both ZADD and ZINCRBY. */\nvoid zaddGenericCommand(client *c, int flags) {\n    static char *nanerr = \"resulting score is not a number (NaN)\";\n    robj *key = c->argv[1];\n    robj *zobj;\n    sds ele;\n    double score = 0, *scores = NULL;\n    int j, elements, ch = 0;\n    int scoreidx = 0;\n    /* The following vars are used in order to track what the command actually\n     * did during the execution, to reply to the client and to trigger the\n     * notification of keyspace change. */\n    int added = 0;      /* Number of new elements added. */\n    int updated = 0;    /* Number of elements with updated score. */\n    int processed = 0;  /* Number of elements processed, may remain zero with\n                           options like XX. */\n\n    /* Parse options. At the end 'scoreidx' is set to the argument position\n     * of the score of the first score-element pair. */\n    scoreidx = 2;\n    while(scoreidx < c->argc) {\n        char *opt = c->argv[scoreidx]->ptr;\n        if (!strcasecmp(opt,\"nx\")) flags |= ZADD_IN_NX;\n        else if (!strcasecmp(opt,\"xx\")) flags |= ZADD_IN_XX;\n        else if (!strcasecmp(opt,\"ch\")) ch = 1; /* Return num of elements added or updated. */\n        else if (!strcasecmp(opt,\"incr\")) flags |= ZADD_IN_INCR;\n        else if (!strcasecmp(opt,\"gt\")) flags |= ZADD_IN_GT;\n        else if (!strcasecmp(opt,\"lt\")) flags |= ZADD_IN_LT;\n        else break;\n        scoreidx++;\n    }\n\n    /* Turn options into simple to check vars. */\n    int incr = (flags & ZADD_IN_INCR) != 0;\n    int nx = (flags & ZADD_IN_NX) != 0;\n    int xx = (flags & ZADD_IN_XX) != 0;\n    int gt = (flags & ZADD_IN_GT) != 0;\n    int lt = (flags & ZADD_IN_LT) != 0;\n\n    /* After the options, we expect to have an even number of args, since\n     * we expect any number of score-element pairs. */\n    elements = c->argc-scoreidx;\n    if (elements % 2 || !elements) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n    elements /= 2; /* Now this holds the number of score-element pairs. */\n\n    /* Check for incompatible options. */\n    if (nx && xx) {\n        addReplyError(c,\n            \"XX and NX options at the same time are not compatible\");\n        return;\n    }\n    \n    if ((gt && nx) || (lt && nx) || (gt && lt)) {\n        addReplyError(c,\n            \"GT, LT, and/or NX options at the same time are not compatible\");\n        return;\n    }\n    /* Note that XX is compatible with either GT or LT */\n\n    if (incr && elements > 1) {\n        addReplyError(c,\n            \"INCR option supports a single increment-element pair\");\n        return;\n    }\n\n    /* Start parsing all the scores, we need to emit any syntax error\n     * before executing additions to the sorted set, as the command should\n     * either execute fully or nothing at all. */\n    scores = zmalloc(sizeof(double)*elements);\n    for (j = 0; j < elements; j++) {\n        if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)\n            != C_OK) goto cleanup;\n    }\n\n    /* Lookup the key and create the sorted set if does not exist. */\n    zobj = lookupKeyWrite(c->db,key);\n    if (checkType(c,zobj,OBJ_ZSET)) goto cleanup;\n    if (zobj == NULL) {\n        if (xx) goto reply_to_client; /* No key + XX option: nothing to do. */\n        if (server.zset_max_listpack_entries == 0 ||\n            server.zset_max_listpack_value < sdslen(c->argv[scoreidx+1]->ptr))\n        {\n            zobj = createZsetObject();\n        } else {\n            zobj = createZsetListpackObject();\n        }\n        dbAdd(c->db,key,zobj);\n    }\n\n    for (j = 0; j < elements; j++) {\n        double newscore;\n        score = scores[j];\n        int retflags = 0;\n\n        ele = c->argv[scoreidx+1+j*2]->ptr;\n        int retval = zsetAdd(zobj, score, ele, flags, &retflags, &newscore);\n        if (retval == 0) {\n            addReplyError(c,nanerr);\n            goto cleanup;\n        }\n        if (retflags & ZADD_OUT_ADDED) added++;\n        if (retflags & ZADD_OUT_UPDATED) updated++;\n        if (!(retflags & ZADD_OUT_NOP)) processed++;\n        score = newscore;\n    }\n    server.dirty += (added+updated);\n\nreply_to_client:\n    if (incr) { /* ZINCRBY or INCR option. */\n        if (processed)\n            addReplyDouble(c,score);\n        else\n            addReplyNull(c);\n    } else { /* ZADD. */\n        addReplyLongLong(c,ch ? added+updated : added);\n    }\n\ncleanup:\n    zfree(scores);\n    if (added || updated) {\n        signalModifiedKey(c,c->db,key);\n        notifyKeyspaceEvent(NOTIFY_ZSET,\n            incr ? \"zincr\" : \"zadd\", key, c->db->id);\n    }\n}\n\nvoid zaddCommand(client *c) {\n    zaddGenericCommand(c,ZADD_IN_NONE);\n}\n\nvoid zincrbyCommand(client *c) {\n    zaddGenericCommand(c,ZADD_IN_INCR);\n}\n\nvoid zremCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    int deleted = 0, keyremoved = 0, j;\n\n    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;\n        if (zsetLength(zobj) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n            break;\n        }\n    }\n\n    if (deleted) {\n        notifyKeyspaceEvent(NOTIFY_ZSET,\"zrem\",key,c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n        signalModifiedKey(c,c->db,key);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\ntypedef enum {\n    ZRANGE_AUTO = 0,\n    ZRANGE_RANK,\n    ZRANGE_SCORE,\n    ZRANGE_LEX,\n} zrange_type;\n\n/* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */\nvoid zremrangeGenericCommand(client *c, zrange_type rangetype) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    int keyremoved = 0;\n    unsigned long deleted = 0;\n    zrangespec range;\n    zlexrangespec lexrange;\n    long start, end, llen;\n    char *notify_type = NULL;\n\n    /* Step 1: Parse the range. */\n    if (rangetype == ZRANGE_RANK) {\n        notify_type = \"zremrangebyrank\";\n        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||\n            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))\n            return;\n    } else if (rangetype == ZRANGE_SCORE) {\n        notify_type = \"zremrangebyscore\";\n        if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {\n            addReplyError(c,\"min or max is not a float\");\n            return;\n        }\n    } else if (rangetype == ZRANGE_LEX) {\n        notify_type = \"zremrangebylex\";\n        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {\n            addReplyError(c,\"min or max not valid string range item\");\n            return;\n        }\n    } else {\n        serverPanic(\"unknown rangetype %d\", (int)rangetype);\n    }\n\n    /* Step 2: Lookup & range sanity checks if needed. */\n    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) goto cleanup;\n\n    if (rangetype == ZRANGE_RANK) {\n        /* Sanitize indexes. */\n        llen = zsetLength(zobj);\n        if (start < 0) start = llen+start;\n        if (end < 0) end = llen+end;\n        if (start < 0) start = 0;\n\n        /* Invariant: start >= 0, so this test will be true when end < 0.\n         * The range is empty when start > end or start >= length. */\n        if (start > end || start >= llen) {\n            addReply(c,shared.czero);\n            goto cleanup;\n        }\n        if (end >= llen) end = llen-1;\n    }\n\n    /* Step 3: Perform the range deletion operation. */\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        switch(rangetype) {\n        case ZRANGE_AUTO:\n        case ZRANGE_RANK:\n            zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,start+1,end+1,&deleted);\n            break;\n        case ZRANGE_SCORE:\n            zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,&range,&deleted);\n            break;\n        case ZRANGE_LEX:\n            zobj->ptr = zzlDeleteRangeByLex(zobj->ptr,&lexrange,&deleted);\n            break;\n        }\n        if (zzlLength(zobj->ptr) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        switch(rangetype) {\n        case ZRANGE_AUTO:\n        case ZRANGE_RANK:\n            deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);\n            break;\n        case ZRANGE_SCORE:\n            deleted = zslDeleteRangeByScore(zs->zsl,&range,zs->dict);\n            break;\n        case ZRANGE_LEX:\n            deleted = zslDeleteRangeByLex(zs->zsl,&lexrange,zs->dict);\n            break;\n        }\n        if (htNeedsResize(zs->dict)) dictResize(zs->dict);\n        if (dictSize(zs->dict) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    /* Step 4: Notifications and reply. */\n    if (deleted) {\n        signalModifiedKey(c,c->db,key);\n        notifyKeyspaceEvent(NOTIFY_ZSET,notify_type,key,c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n    }\n    server.dirty += deleted;\n    addReplyLongLong(c,deleted);\n\ncleanup:\n    if (rangetype == ZRANGE_LEX) zslFreeLexRange(&lexrange);\n}\n\nvoid zremrangebyrankCommand(client *c) {\n    zremrangeGenericCommand(c,ZRANGE_RANK);\n}\n\nvoid zremrangebyscoreCommand(client *c) {\n    zremrangeGenericCommand(c,ZRANGE_SCORE);\n}\n\nvoid zremrangebylexCommand(client *c) {\n    zremrangeGenericCommand(c,ZRANGE_LEX);\n}\n\ntypedef struct {\n    robj *subject;\n    int type; /* Set, sorted set */\n    int encoding;\n    double weight;\n\n    union {\n        /* Set iterators. */\n        union _iterset {\n            struct {\n                intset *is;\n                int ii;\n            } is;\n            struct {\n                dict *dict;\n                dictIterator *di;\n                dictEntry *de;\n            } ht;\n        } set;\n\n        /* Sorted set iterators. */\n        union _iterzset {\n            struct {\n                unsigned char *zl;\n                unsigned char *eptr, *sptr;\n            } zl;\n            struct {\n                zset *zs;\n                zskiplistNode *node;\n            } sl;\n        } zset;\n    } iter;\n} zsetopsrc;\n\n\n/* Use dirty flags for pointers that need to be cleaned up in the next\n * iteration over the zsetopval. The dirty flag for the long long value is\n * special, since long long values don't need cleanup. Instead, it means that\n * we already checked that \"ell\" holds a long long, or tried to convert another\n * representation into a long long value. When this was successful,\n * OPVAL_VALID_LL is set as well. */\n#define OPVAL_DIRTY_SDS 1\n#define OPVAL_DIRTY_LL 2\n#define OPVAL_VALID_LL 4\n\n/* Store value retrieved from the iterator. */\ntypedef struct {\n    int flags;\n    unsigned char _buf[32]; /* Private buffer. */\n    sds ele;\n    unsigned char *estr;\n    unsigned int elen;\n    long long ell;\n    double score;\n} zsetopval;\n\ntypedef union _iterset iterset;\ntypedef union _iterzset iterzset;\n\nvoid zuiInitIterator(zsetopsrc *op) {\n    if (op->subject == NULL)\n        return;\n\n    if (op->type == OBJ_SET) {\n        iterset *it = &op->iter.set;\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            it->is.is = op->subject->ptr;\n            it->is.ii = 0;\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            it->ht.dict = op->subject->ptr;\n            it->ht.di = dictGetIterator(op->subject->ptr);\n            it->ht.de = dictNext(it->ht.di);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        /* Sorted sets are traversed in reverse order to optimize for\n         * the insertion of the elements in a new list as in\n         * ZDIFF/ZINTER/ZUNION */\n        iterzset *it = &op->iter.zset;\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            it->zl.zl = op->subject->ptr;\n            it->zl.eptr = lpSeek(it->zl.zl,-2);\n            if (it->zl.eptr != NULL) {\n                it->zl.sptr = lpNext(it->zl.zl,it->zl.eptr);\n                serverAssert(it->zl.sptr != NULL);\n            }\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            it->sl.zs = op->subject->ptr;\n            it->sl.node = it->sl.zs->zsl->tail;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\nvoid zuiClearIterator(zsetopsrc *op) {\n    if (op->subject == NULL)\n        return;\n\n    if (op->type == OBJ_SET) {\n        iterset *it = &op->iter.set;\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            UNUSED(it); /* skip */\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            dictReleaseIterator(it->ht.di);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        iterzset *it = &op->iter.zset;\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            UNUSED(it); /* skip */\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            UNUSED(it); /* skip */\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\nvoid zuiDiscardDirtyValue(zsetopval *val) {\n    if (val->flags & OPVAL_DIRTY_SDS) {\n        sdsfree(val->ele);\n        val->ele = NULL;\n        val->flags &= ~OPVAL_DIRTY_SDS;\n    }\n}\n\nunsigned long zuiLength(zsetopsrc *op) {\n    if (op->subject == NULL)\n        return 0;\n\n    if (op->type == OBJ_SET) {\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            return intsetLen(op->subject->ptr);\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            dict *ht = op->subject->ptr;\n            return dictSize(ht);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            return zzlLength(op->subject->ptr);\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = op->subject->ptr;\n            return zs->zsl->length;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\n/* Check if the current value is valid. If so, store it in the passed structure\n * and move to the next element. If not valid, this means we have reached the\n * end of the structure and can abort. */\nint zuiNext(zsetopsrc *op, zsetopval *val) {\n    if (op->subject == NULL)\n        return 0;\n\n    zuiDiscardDirtyValue(val);\n\n    memset(val,0,sizeof(zsetopval));\n\n    if (op->type == OBJ_SET) {\n        iterset *it = &op->iter.set;\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            int64_t ell;\n\n            if (!intsetGet(it->is.is,it->is.ii,&ell))\n                return 0;\n            val->ell = ell;\n            val->score = 1.0;\n\n            /* Move to next element. */\n            it->is.ii++;\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            if (it->ht.de == NULL)\n                return 0;\n            val->ele = dictGetKey(it->ht.de);\n            val->score = 1.0;\n\n            /* Move to next element. */\n            it->ht.de = dictNext(it->ht.di);\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        iterzset *it = &op->iter.zset;\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            /* No need to check both, but better be explicit. */\n            if (it->zl.eptr == NULL || it->zl.sptr == NULL)\n                return 0;\n            val->estr = lpGetValue(it->zl.eptr,&val->elen,&val->ell);\n            val->score = zzlGetScore(it->zl.sptr);\n\n            /* Move to next element (going backwards, see zuiInitIterator). */\n            zzlPrev(it->zl.zl,&it->zl.eptr,&it->zl.sptr);\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            if (it->sl.node == NULL)\n                return 0;\n            val->ele = it->sl.node->ele;\n            val->score = it->sl.node->score;\n\n            /* Move to next element. (going backwards, see zuiInitIterator) */\n            it->sl.node = it->sl.node->backward;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n    return 1;\n}\n\nint zuiLongLongFromValue(zsetopval *val) {\n    if (!(val->flags & OPVAL_DIRTY_LL)) {\n        val->flags |= OPVAL_DIRTY_LL;\n\n        if (val->ele != NULL) {\n            if (string2ll(val->ele,sdslen(val->ele),&val->ell))\n                val->flags |= OPVAL_VALID_LL;\n        } else if (val->estr != NULL) {\n            if (string2ll((char*)val->estr,val->elen,&val->ell))\n                val->flags |= OPVAL_VALID_LL;\n        } else {\n            /* The long long was already set, flag as valid. */\n            val->flags |= OPVAL_VALID_LL;\n        }\n    }\n    return val->flags & OPVAL_VALID_LL;\n}\n\nsds zuiSdsFromValue(zsetopval *val) {\n    if (val->ele == NULL) {\n        if (val->estr != NULL) {\n            val->ele = sdsnewlen((char*)val->estr,val->elen);\n        } else {\n            val->ele = sdsfromlonglong(val->ell);\n        }\n        val->flags |= OPVAL_DIRTY_SDS;\n    }\n    return val->ele;\n}\n\n/* This is different from zuiSdsFromValue since returns a new SDS string\n * which is up to the caller to free. */\nsds zuiNewSdsFromValue(zsetopval *val) {\n    if (val->flags & OPVAL_DIRTY_SDS) {\n        /* We have already one to return! */\n        sds ele = val->ele;\n        val->flags &= ~OPVAL_DIRTY_SDS;\n        val->ele = NULL;\n        return ele;\n    } else if (val->ele) {\n        return sdsdup(val->ele);\n    } else if (val->estr) {\n        return sdsnewlen((char*)val->estr,val->elen);\n    } else {\n        return sdsfromlonglong(val->ell);\n    }\n}\n\nint zuiBufferFromValue(zsetopval *val) {\n    if (val->estr == NULL) {\n        if (val->ele != NULL) {\n            val->elen = sdslen(val->ele);\n            val->estr = (unsigned char*)val->ele;\n        } else {\n            val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);\n            val->estr = val->_buf;\n        }\n    }\n    return 1;\n}\n\n/* Find value pointed to by val in the source pointer to by op. When found,\n * return 1 and store its score in target. Return 0 otherwise. */\nint zuiFind(zsetopsrc *op, zsetopval *val, double *score) {\n    if (op->subject == NULL)\n        return 0;\n\n    if (op->type == OBJ_SET) {\n        if (op->encoding == OBJ_ENCODING_INTSET) {\n            if (zuiLongLongFromValue(val) &&\n                intsetFind(op->subject->ptr,val->ell))\n            {\n                *score = 1.0;\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (op->encoding == OBJ_ENCODING_HT) {\n            dict *ht = op->subject->ptr;\n            zuiSdsFromValue(val);\n            if (dictFind(ht,val->ele) != NULL) {\n                *score = 1.0;\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            serverPanic(\"Unknown set encoding\");\n        }\n    } else if (op->type == OBJ_ZSET) {\n        zuiSdsFromValue(val);\n\n        if (op->encoding == OBJ_ENCODING_LISTPACK) {\n            if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {\n                /* Score is already set by zzlFind. */\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = op->subject->ptr;\n            dictEntry *de;\n            if ((de = dictFind(zs->dict,val->ele)) != NULL) {\n                *score = *(double*)dictGetVal(de);\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else {\n        serverPanic(\"Unsupported type\");\n    }\n}\n\nint zuiCompareByCardinality(const void *s1, const void *s2) {\n    unsigned long first = zuiLength((zsetopsrc*)s1);\n    unsigned long second = zuiLength((zsetopsrc*)s2);\n    if (first > second) return 1;\n    if (first < second) return -1;\n    return 0;\n}\n\nstatic int zuiCompareByRevCardinality(const void *s1, const void *s2) {\n    return zuiCompareByCardinality(s1, s2) * -1;\n}\n\n#define REDIS_AGGR_SUM 1\n#define REDIS_AGGR_MIN 2\n#define REDIS_AGGR_MAX 3\n#define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))\n\ninline static void zunionInterAggregate(double *target, double val, int aggregate) {\n    if (aggregate == REDIS_AGGR_SUM) {\n        *target = *target + val;\n        /* The result of adding two doubles is NaN when one variable\n         * is +inf and the other is -inf. When these numbers are added,\n         * we maintain the convention of the result being 0.0. */\n        if (isnan(*target)) *target = 0.0;\n    } else if (aggregate == REDIS_AGGR_MIN) {\n        *target = val < *target ? val : *target;\n    } else if (aggregate == REDIS_AGGR_MAX) {\n        *target = val > *target ? val : *target;\n    } else {\n        /* safety net */\n        serverPanic(\"Unknown ZUNION/INTER aggregate type\");\n    }\n}\n\nstatic size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {\n    dictIterator *di;\n    dictEntry *de;\n    size_t maxelelen = 0;\n\n    di = dictGetIterator(d);\n\n    while((de = dictNext(di)) != NULL) {\n        sds ele = dictGetKey(de);\n        if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);\n        if (totallen)\n            (*totallen) += sdslen(ele);\n    }\n\n    dictReleaseIterator(di);\n\n    return maxelelen;\n}\n\nstatic void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n    /* DIFF Algorithm 1:\n     *\n     * We perform the diff by iterating all the elements of the first set,\n     * and only adding it to the target set if the element does not exist\n     * into all the other sets.\n     *\n     * This way we perform at max N*M operations, where N is the size of\n     * the first set, and M the number of sets.\n     *\n     * There is also a O(K*log(K)) cost for adding the resulting elements\n     * to the target set, where K is the final size of the target set.\n     *\n     * The final complexity of this algorithm is O(N*M + K*log(K)). */\n    int j;\n    zsetopval zval;\n    zskiplistNode *znode;\n    sds tmp;\n\n    /* With algorithm 1 it is better to order the sets to subtract\n     * by decreasing size, so that we are more likely to find\n     * duplicated elements ASAP. */\n    qsort(src+1,setnum-1,sizeof(zsetopsrc),zuiCompareByRevCardinality);\n\n    memset(&zval, 0, sizeof(zval));\n    zuiInitIterator(&src[0]);\n    while (zuiNext(&src[0],&zval)) {\n        double value;\n        int exists = 0;\n\n        for (j = 1; j < setnum; j++) {\n            /* It is not safe to access the zset we are\n             * iterating, so explicitly check for equal object.\n             * This check isn't really needed anymore since we already\n             * check for a duplicate set in the zsetChooseDiffAlgorithm\n             * function, but we're leaving it for future-proofing. */\n            if (src[j].subject == src[0].subject ||\n                zuiFind(&src[j],&zval,&value)) {\n                exists = 1;\n                break;\n            }\n        }\n\n        if (!exists) {\n            tmp = zuiNewSdsFromValue(&zval);\n            znode = zslInsert(dstzset->zsl,zval.score,tmp);\n            dictAdd(dstzset->dict,tmp,&znode->score);\n            if (sdslen(tmp) > *maxelelen) *maxelelen = sdslen(tmp);\n            (*totelelen) += sdslen(tmp);\n        }\n    }\n    zuiClearIterator(&src[0]);\n}\n\n\nstatic void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n    /* DIFF Algorithm 2:\n     *\n     * Add all the elements of the first set to the auxiliary set.\n     * Then remove all the elements of all the next sets from it.\n     *\n\n     * This is O(L + (N-K)log(N)) where L is the sum of all the elements in every\n     * set, N is the size of the first set, and K is the size of the result set.\n     *\n     * Note that from the (L-N) dict searches, (N-K) got to the zsetRemoveFromSkiplist\n     * which costs log(N)\n     *\n     * There is also a O(K) cost at the end for finding the largest element\n     * size, but this doesn't change the algorithm complexity since K < L, and\n     * O(2L) is the same as O(L). */\n    int j;\n    int cardinality = 0;\n    zsetopval zval;\n    zskiplistNode *znode;\n    sds tmp;\n\n    for (j = 0; j < setnum; j++) {\n        if (zuiLength(&src[j]) == 0) continue;\n\n        memset(&zval, 0, sizeof(zval));\n        zuiInitIterator(&src[j]);\n        while (zuiNext(&src[j],&zval)) {\n            if (j == 0) {\n                tmp = zuiNewSdsFromValue(&zval);\n                znode = zslInsert(dstzset->zsl,zval.score,tmp);\n                dictAdd(dstzset->dict,tmp,&znode->score);\n                cardinality++;\n            } else {\n                tmp = zuiSdsFromValue(&zval);\n                if (zsetRemoveFromSkiplist(dstzset, tmp)) {\n                    cardinality--;\n                }\n            }\n\n            /* Exit if result set is empty as any additional removal\n                * of elements will have no effect. */\n            if (cardinality == 0) break;\n        }\n        zuiClearIterator(&src[j]);\n\n        if (cardinality == 0) break;\n    }\n\n    /* Resize dict if needed after removing multiple elements */\n    if (htNeedsResize(dstzset->dict)) dictResize(dstzset->dict);\n\n    /* Using this algorithm, we can't calculate the max element as we go,\n     * we have to iterate through all elements to find the max one after. */\n    *maxelelen = zsetDictGetMaxElementLength(dstzset->dict, totelelen);\n}\n\nstatic int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {\n    int j;\n\n    /* Select what DIFF algorithm to use.\n     *\n     * Algorithm 1 is O(N*M + K*log(K)) where N is the size of the\n     * first set, M the total number of sets, and K is the size of the\n     * result set.\n     *\n     * Algorithm 2 is O(L + (N-K)log(N)) where L is the total number of elements\n     * in all the sets, N is the size of the first set, and K is the size of the\n     * result set.\n     *\n     * We compute what is the best bet with the current input here. */\n    long long algo_one_work = 0;\n    long long algo_two_work = 0;\n\n    for (j = 0; j < setnum; j++) {\n        /* If any other set is equal to the first set, there is nothing to be\n         * done, since we would remove all elements anyway. */\n        if (j > 0 && src[0].subject == src[j].subject) {\n            return 0;\n        }\n\n        algo_one_work += zuiLength(&src[0]);\n        algo_two_work += zuiLength(&src[j]);\n    }\n\n    /* Algorithm 1 has better constant times and performs less operations\n     * if there are elements in common. Give it some advantage. */\n    algo_one_work /= 2;\n    return (algo_one_work <= algo_two_work) ? 1 : 2;\n}\n\nstatic void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n    /* Skip everything if the smallest input is empty. */\n    if (zuiLength(&src[0]) > 0) {\n        int diff_algo = zsetChooseDiffAlgorithm(src, setnum);\n        if (diff_algo == 1) {\n            zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);\n        } else if (diff_algo == 2) {\n            zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);\n        } else if (diff_algo != 0) {\n            serverPanic(\"Unknown algorithm\");\n        }\n    }\n}\n\ndictType setAccumulatorDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* key destructor */\n    NULL,                      /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* The zunionInterDiffGenericCommand() function is called in order to implement the\n * following commands: ZUNION, ZINTER, ZDIFF, ZUNIONSTORE, ZINTERSTORE, ZDIFFSTORE,\n * ZINTERCARD.\n *\n * 'numkeysIndex' parameter position of key number. for ZUNION/ZINTER/ZDIFF command,\n * this value is 1, for ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE command, this value is 2.\n *\n * 'op' SET_OP_INTER, SET_OP_UNION or SET_OP_DIFF.\n *\n * 'cardinality_only' is currently only applicable when 'op' is SET_OP_INTER.\n * Work for SINTERCARD, only return the cardinality with minimum processing and memory overheads.\n */\nvoid zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op,\n                                   int cardinality_only) {\n    int i, j;\n    long setnum;\n    int aggregate = REDIS_AGGR_SUM;\n    zsetopsrc *src;\n    zsetopval zval;\n    sds tmp;\n    size_t maxelelen = 0, totelelen = 0;\n    robj *dstobj;\n    zset *dstzset;\n    zskiplistNode *znode;\n    int withscores = 0;\n    unsigned long cardinality = 0;\n    long limit = 0; /* Stop searching after reaching the limit. 0 means unlimited. */\n\n    /* expect setnum input keys to be given */\n    if ((getLongFromObjectOrReply(c, c->argv[numkeysIndex], &setnum, NULL) != C_OK))\n        return;\n\n    if (setnum < 1) {\n        addReplyErrorFormat(c,\n            \"at least 1 input key is needed for '%s' command\", c->cmd->fullname);\n        return;\n    }\n\n    /* test if the expected number of keys would overflow */\n    if (setnum > (c->argc-(numkeysIndex+1))) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* read keys to be used for input */\n    src = zcalloc(sizeof(zsetopsrc) * setnum);\n    for (i = 0, j = numkeysIndex+1; i < setnum; i++, j++) {\n        robj *obj = lookupKeyRead(c->db, c->argv[j]);\n        if (obj != NULL) {\n            if (obj->type != OBJ_ZSET && obj->type != OBJ_SET) {\n                zfree(src);\n                addReplyErrorObject(c,shared.wrongtypeerr);\n                return;\n            }\n\n            src[i].subject = obj;\n            src[i].type = obj->type;\n            src[i].encoding = obj->encoding;\n        } else {\n            src[i].subject = NULL;\n        }\n\n        /* Default all weights to 1. */\n        src[i].weight = 1.0;\n    }\n\n    /* parse optional extra arguments */\n    if (j < c->argc) {\n        int remaining = c->argc - j;\n\n        while (remaining) {\n            if (op != SET_OP_DIFF && !cardinality_only &&\n                remaining >= (setnum + 1) &&\n                !strcasecmp(c->argv[j]->ptr,\"weights\"))\n            {\n                j++; remaining--;\n                for (i = 0; i < setnum; i++, j++, remaining--) {\n                    if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,\n                            \"weight value is not a float\") != C_OK)\n                    {\n                        zfree(src);\n                        return;\n                    }\n                }\n            } else if (op != SET_OP_DIFF && !cardinality_only &&\n                       remaining >= 2 &&\n                       !strcasecmp(c->argv[j]->ptr,\"aggregate\"))\n            {\n                j++; remaining--;\n                if (!strcasecmp(c->argv[j]->ptr,\"sum\")) {\n                    aggregate = REDIS_AGGR_SUM;\n                } else if (!strcasecmp(c->argv[j]->ptr,\"min\")) {\n                    aggregate = REDIS_AGGR_MIN;\n                } else if (!strcasecmp(c->argv[j]->ptr,\"max\")) {\n                    aggregate = REDIS_AGGR_MAX;\n                } else {\n                    zfree(src);\n                    addReplyErrorObject(c,shared.syntaxerr);\n                    return;\n                }\n                j++; remaining--;\n            } else if (remaining >= 1 &&\n                       !dstkey && !cardinality_only &&\n                       !strcasecmp(c->argv[j]->ptr,\"withscores\"))\n            {\n                j++; remaining--;\n                withscores = 1;\n            } else if (cardinality_only && remaining >= 2 &&\n                       !strcasecmp(c->argv[j]->ptr, \"limit\"))\n            {\n                j++; remaining--;\n                if (getPositiveLongFromObjectOrReply(c, c->argv[j], &limit,\n                                                     \"LIMIT can't be negative\") != C_OK)\n                {\n                    zfree(src);\n                    return;\n                }\n                j++; remaining--;\n            } else {\n                zfree(src);\n                addReplyErrorObject(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    if (op != SET_OP_DIFF) {\n        /* sort sets from the smallest to largest, this will improve our\n        * algorithm's performance */\n        qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);\n    }\n\n    dstobj = createZsetObject();\n    dstzset = dstobj->ptr;\n    memset(&zval, 0, sizeof(zval));\n\n    if (op == SET_OP_INTER) {\n        /* Skip everything if the smallest input is empty. */\n        if (zuiLength(&src[0]) > 0) {\n            /* Precondition: as src[0] is non-empty and the inputs are ordered\n             * by size, all src[i > 0] are non-empty too. */\n            zuiInitIterator(&src[0]);\n            while (zuiNext(&src[0],&zval)) {\n                double score, value;\n\n                score = src[0].weight * zval.score;\n                if (isnan(score)) score = 0;\n\n                for (j = 1; j < setnum; j++) {\n                    /* It is not safe to access the zset we are\n                     * iterating, so explicitly check for equal object. */\n                    if (src[j].subject == src[0].subject) {\n                        value = zval.score*src[j].weight;\n                        zunionInterAggregate(&score,value,aggregate);\n                    } else if (zuiFind(&src[j],&zval,&value)) {\n                        value *= src[j].weight;\n                        zunionInterAggregate(&score,value,aggregate);\n                    } else {\n                        break;\n                    }\n                }\n\n                /* Only continue when present in every input. */\n                if (j == setnum && cardinality_only) {\n                    cardinality++;\n\n                    /* We stop the searching after reaching the limit. */\n                    if (limit && cardinality >= (unsigned long)limit) {\n                        /* Cleanup before we break the zuiNext loop. */\n                        zuiDiscardDirtyValue(&zval);\n                        break;\n                    }\n                } else if (j == setnum) {\n                    tmp = zuiNewSdsFromValue(&zval);\n                    znode = zslInsert(dstzset->zsl,score,tmp);\n                    dictAdd(dstzset->dict,tmp,&znode->score);\n                    totelelen += sdslen(tmp);\n                    if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);\n                }\n            }\n            zuiClearIterator(&src[0]);\n        }\n    } else if (op == SET_OP_UNION) {\n        dict *accumulator = dictCreate(&setAccumulatorDictType);\n        dictIterator *di;\n        dictEntry *de, *existing;\n        double score;\n\n        if (setnum) {\n            /* Our union is at least as large as the largest set.\n             * Resize the dictionary ASAP to avoid useless rehashing. */\n            dictExpand(accumulator,zuiLength(&src[setnum-1]));\n        }\n\n        /* Step 1: Create a dictionary of elements -> aggregated-scores\n         * by iterating one sorted set after the other. */\n        for (i = 0; i < setnum; i++) {\n            if (zuiLength(&src[i]) == 0) continue;\n\n            zuiInitIterator(&src[i]);\n            while (zuiNext(&src[i],&zval)) {\n                /* Initialize value */\n                score = src[i].weight * zval.score;\n                if (isnan(score)) score = 0;\n\n                /* Search for this element in the accumulating dictionary. */\n                de = dictAddRaw(accumulator,zuiSdsFromValue(&zval),&existing);\n                /* If we don't have it, we need to create a new entry. */\n                if (!existing) {\n                    tmp = zuiNewSdsFromValue(&zval);\n                    /* Remember the longest single element encountered,\n                     * to understand if it's possible to convert to listpack\n                     * at the end. */\n                     totelelen += sdslen(tmp);\n                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);\n                    /* Update the element with its initial score. */\n                    dictSetKey(accumulator, de, tmp);\n                    dictSetDoubleVal(de,score);\n                } else {\n                    /* Update the score with the score of the new instance\n                     * of the element found in the current sorted set.\n                     *\n                     * Here we access directly the dictEntry double\n                     * value inside the union as it is a big speedup\n                     * compared to using the getDouble/setDouble API. */\n                    zunionInterAggregate(&existing->v.d,score,aggregate);\n                }\n            }\n            zuiClearIterator(&src[i]);\n        }\n\n        /* Step 2: convert the dictionary into the final sorted set. */\n        di = dictGetIterator(accumulator);\n\n        /* We now are aware of the final size of the resulting sorted set,\n         * let's resize the dictionary embedded inside the sorted set to the\n         * right size, in order to save rehashing time. */\n        dictExpand(dstzset->dict,dictSize(accumulator));\n\n        while((de = dictNext(di)) != NULL) {\n            sds ele = dictGetKey(de);\n            score = dictGetDoubleVal(de);\n            znode = zslInsert(dstzset->zsl,score,ele);\n            dictAdd(dstzset->dict,ele,&znode->score);\n        }\n        dictReleaseIterator(di);\n        dictRelease(accumulator);\n    } else if (op == SET_OP_DIFF) {\n        zdiff(src, setnum, dstzset, &maxelelen, &totelelen);\n    } else {\n        serverPanic(\"Unknown operator\");\n    }\n\n    if (dstkey) {\n        if (dstzset->zsl->length) {\n            zsetConvertToListpackIfNeeded(dstobj, maxelelen, totelelen);\n            setKey(c, c->db, dstkey, dstobj, 0);\n            addReplyLongLong(c, zsetLength(dstobj));\n            notifyKeyspaceEvent(NOTIFY_ZSET,\n                                (op == SET_OP_UNION) ? \"zunionstore\" :\n                                    (op == SET_OP_INTER ? \"zinterstore\" : \"zdiffstore\"),\n                                dstkey, c->db->id);\n            server.dirty++;\n        } else {\n            addReply(c, shared.czero);\n            if (dbDelete(c->db, dstkey)) {\n                signalModifiedKey(c, c->db, dstkey);\n                notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", dstkey, c->db->id);\n                server.dirty++;\n            }\n        }\n    } else if (cardinality_only) {\n        addReplyLongLong(c, cardinality);\n    } else {\n        unsigned long length = dstzset->zsl->length;\n        zskiplist *zsl = dstzset->zsl;\n        zskiplistNode *zn = zsl->header->level[0].forward;\n        /* In case of WITHSCORES, respond with a single array in RESP2, and\n         * nested arrays in RESP3. We can't use a map response type since the\n         * client library needs to know to respect the order. */\n        if (withscores && c->resp == 2)\n            addReplyArrayLen(c, length*2);\n        else\n            addReplyArrayLen(c, length);\n\n        while (zn != NULL) {\n            if (withscores && c->resp > 2) addReplyArrayLen(c,2);\n            addReplyBulkCBuffer(c,zn->ele,sdslen(zn->ele));\n            if (withscores) addReplyDouble(c,zn->score);\n            zn = zn->level[0].forward;\n        }\n    }\n    decrRefCount(dstobj);\n    zfree(src);\n}\n\n/* ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] */\nvoid zunionstoreCommand(client *c) {\n    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_UNION, 0);\n}\n\n/* ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] */\nvoid zinterstoreCommand(client *c) {\n    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_INTER, 0);\n}\n\n/* ZDIFFSTORE destination numkeys key [key ...] */\nvoid zdiffstoreCommand(client *c) {\n    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_DIFF, 0);\n}\n\n/* ZUNION numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] */\nvoid zunionCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_UNION, 0);\n}\n\n/* ZINTER numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] */\nvoid zinterCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 0);\n}\n\n/* ZINTERCARD numkeys key [key ...] [LIMIT limit] */\nvoid zinterCardCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 1);\n}\n\n/* ZDIFF numkeys key [key ...] [WITHSCORES] */\nvoid zdiffCommand(client *c) {\n    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_DIFF, 0);\n}\n\ntypedef enum {\n    ZRANGE_DIRECTION_AUTO = 0,\n    ZRANGE_DIRECTION_FORWARD,\n    ZRANGE_DIRECTION_REVERSE\n} zrange_direction;\n\ntypedef enum {\n    ZRANGE_CONSUMER_TYPE_CLIENT = 0,\n    ZRANGE_CONSUMER_TYPE_INTERNAL\n} zrange_consumer_type;\n\ntypedef struct zrange_result_handler zrange_result_handler;\n\ntypedef void (*zrangeResultBeginFunction)(zrange_result_handler *c, long length);\ntypedef void (*zrangeResultFinalizeFunction)(\n    zrange_result_handler *c, size_t result_count);\ntypedef void (*zrangeResultEmitCBufferFunction)(\n    zrange_result_handler *c, const void *p, size_t len, double score);\ntypedef void (*zrangeResultEmitLongLongFunction)(\n    zrange_result_handler *c, long long ll, double score);\n\nvoid zrangeGenericCommand (zrange_result_handler *handler, int argc_start, int store,\n                           zrange_type rangetype, zrange_direction direction);\n\n/* Interface struct for ZRANGE/ZRANGESTORE generic implementation.\n * There is one implementation of this interface that sends a RESP reply to clients.\n * and one implementation that stores the range result into a zset object. */\nstruct zrange_result_handler {\n    zrange_consumer_type                 type;\n    client                              *client;\n    robj                                *dstkey;\n    robj                                *dstobj;\n    void                                *userdata;\n    int                                  withscores;\n    int                                  should_emit_array_length;\n    zrangeResultBeginFunction            beginResultEmission;\n    zrangeResultFinalizeFunction         finalizeResultEmission;\n    zrangeResultEmitCBufferFunction      emitResultFromCBuffer;\n    zrangeResultEmitLongLongFunction     emitResultFromLongLong;\n};\n\n/* Result handler methods for responding the ZRANGE to clients.\n * length can be used to provide the result length in advance (avoids deferred reply overhead).\n * length can be set to -1 if the result length is not know in advance.\n */\nstatic void zrangeResultBeginClient(zrange_result_handler *handler, long length) {\n    if (length > 0) {\n        /* In case of WITHSCORES, respond with a single array in RESP2, and\n        * nested arrays in RESP3. We can't use a map response type since the\n        * client library needs to know to respect the order. */\n        if (handler->withscores && (handler->client->resp == 2)) {\n            length *= 2;\n        }\n        addReplyArrayLen(handler->client, length);\n        handler->userdata = NULL;\n        return;\n    }\n    handler->userdata = addReplyDeferredLen(handler->client);\n}\n\nstatic void zrangeResultEmitCBufferToClient(zrange_result_handler *handler,\n    const void *value, size_t value_length_in_bytes, double score)\n{\n    if (handler->should_emit_array_length) {\n        addReplyArrayLen(handler->client, 2);\n    }\n\n    addReplyBulkCBuffer(handler->client, value, value_length_in_bytes);\n\n    if (handler->withscores) {\n        addReplyDouble(handler->client, score);\n    }\n}\n\nstatic void zrangeResultEmitLongLongToClient(zrange_result_handler *handler,\n    long long value, double score)\n{\n    if (handler->should_emit_array_length) {\n        addReplyArrayLen(handler->client, 2);\n    }\n\n    addReplyBulkLongLong(handler->client, value);\n\n    if (handler->withscores) {\n        addReplyDouble(handler->client, score);\n    }\n}\n\nstatic void zrangeResultFinalizeClient(zrange_result_handler *handler,\n    size_t result_count)\n{\n    /* If the reply size was know at start there's nothing left to do */\n    if (!handler->userdata)\n        return;\n    /* In case of WITHSCORES, respond with a single array in RESP2, and\n     * nested arrays in RESP3. We can't use a map response type since the\n     * client library needs to know to respect the order. */\n    if (handler->withscores && (handler->client->resp == 2)) {\n        result_count *= 2;\n    }\n\n    setDeferredArrayLen(handler->client, handler->userdata, result_count);\n}\n\n/* Result handler methods for storing the ZRANGESTORE to a zset. */\nstatic void zrangeResultBeginStore(zrange_result_handler *handler, long length)\n{\n    if (length > (long)server.zset_max_listpack_entries)\n        handler->dstobj = createZsetObject();\n    else\n        handler->dstobj = createZsetListpackObject();\n}\n\nstatic void zrangeResultEmitCBufferForStore(zrange_result_handler *handler,\n    const void *value, size_t value_length_in_bytes, double score)\n{\n    double newscore;\n    int retflags = 0;\n    sds ele = sdsnewlen(value, value_length_in_bytes);\n    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);\n    sdsfree(ele);\n    serverAssert(retval);\n}\n\nstatic void zrangeResultEmitLongLongForStore(zrange_result_handler *handler,\n    long long value, double score)\n{\n    double newscore;\n    int retflags = 0;\n    sds ele = sdsfromlonglong(value);\n    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);\n    sdsfree(ele);\n    serverAssert(retval);\n}\n\nstatic void zrangeResultFinalizeStore(zrange_result_handler *handler, size_t result_count)\n{\n    if (result_count) {\n        setKey(handler->client, handler->client->db, handler->dstkey, handler->dstobj, 0);\n        addReplyLongLong(handler->client, result_count);\n        notifyKeyspaceEvent(NOTIFY_ZSET, \"zrangestore\", handler->dstkey, handler->client->db->id);\n        server.dirty++;\n    } else {\n        addReply(handler->client, shared.czero);\n        if (dbDelete(handler->client->db, handler->dstkey)) {\n            signalModifiedKey(handler->client, handler->client->db, handler->dstkey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", handler->dstkey, handler->client->db->id);\n            server.dirty++;\n        }\n    }\n    decrRefCount(handler->dstobj);\n}\n\n/* Initialize the consumer interface type with the requested type. */\nstatic void zrangeResultHandlerInit(zrange_result_handler *handler,\n    client *client, zrange_consumer_type type)\n{\n    memset(handler, 0, sizeof(*handler));\n\n    handler->client = client;\n\n    switch (type) {\n    case ZRANGE_CONSUMER_TYPE_CLIENT:\n        handler->beginResultEmission = zrangeResultBeginClient;\n        handler->finalizeResultEmission = zrangeResultFinalizeClient;\n        handler->emitResultFromCBuffer = zrangeResultEmitCBufferToClient;\n        handler->emitResultFromLongLong = zrangeResultEmitLongLongToClient;\n        break;\n\n    case ZRANGE_CONSUMER_TYPE_INTERNAL:\n        handler->beginResultEmission = zrangeResultBeginStore;\n        handler->finalizeResultEmission = zrangeResultFinalizeStore;\n        handler->emitResultFromCBuffer = zrangeResultEmitCBufferForStore;\n        handler->emitResultFromLongLong = zrangeResultEmitLongLongForStore;\n        break;\n    }\n}\n\nstatic void zrangeResultHandlerScoreEmissionEnable(zrange_result_handler *handler) {\n    handler->withscores = 1;\n    handler->should_emit_array_length = (handler->client->resp > 2);\n}\n\nstatic void zrangeResultHandlerDestinationKeySet (zrange_result_handler *handler,\n    robj *dstkey)\n{\n    handler->dstkey = dstkey;\n}\n\n/* This command implements ZRANGE, ZREVRANGE. */\nvoid genericZrangebyrankCommand(zrange_result_handler *handler,\n    robj *zobj, long start, long end, int withscores, int reverse) {\n\n    client *c = handler->client;\n    long llen;\n    long rangelen;\n    size_t result_cardinality;\n\n    /* Sanitize indexes. */\n    llen = zsetLength(zobj);\n    if (start < 0) start = llen+start;\n    if (end < 0) end = llen+end;\n    if (start < 0) start = 0;\n\n\n    /* Invariant: start >= 0, so this test will be true when end < 0.\n     * The range is empty when start > end or start >= length. */\n    if (start > end || start >= llen) {\n        handler->beginResultEmission(handler, 0);\n        handler->finalizeResultEmission(handler, 0);\n        return;\n    }\n    if (end >= llen) end = llen-1;\n    rangelen = (end-start)+1;\n    result_cardinality = rangelen;\n\n    handler->beginResultEmission(handler, rangelen);\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n        double score = 0.0;\n\n        if (reverse)\n            eptr = lpSeek(zl,-2-(2*start));\n        else\n            eptr = lpSeek(zl,2*start);\n\n        serverAssertWithInfo(c,zobj,eptr != NULL);\n        sptr = lpNext(zl,eptr);\n\n        while (rangelen--) {\n            serverAssertWithInfo(c,zobj,eptr != NULL && sptr != NULL);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n\n            if (withscores) /* don't bother to extract the score if it's gonna be ignored. */\n                score = zzlGetScore(sptr);\n\n            if (vstr == NULL) {\n                handler->emitResultFromLongLong(handler, vlong, score);\n            } else {\n                handler->emitResultFromCBuffer(handler, vstr, vlen, score);\n            }\n\n            if (reverse)\n                zzlPrev(zl,&eptr,&sptr);\n            else\n                zzlNext(zl,&eptr,&sptr);\n        }\n\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (reverse) {\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,llen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,zobj,ln != NULL);\n            sds ele = ln->ele;\n            handler->emitResultFromCBuffer(handler, ele, sdslen(ele), ln->score);\n            ln = reverse ? ln->backward : ln->level[0].forward;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    handler->finalizeResultEmission(handler, result_cardinality);\n}\n\n/* ZRANGESTORE <dst> <src> <min> <max> [BYSCORE | BYLEX] [REV] [LIMIT offset count] */\nvoid zrangestoreCommand (client *c) {\n    robj *dstkey = c->argv[1];\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_INTERNAL);\n    zrangeResultHandlerDestinationKeySet(&handler, dstkey);\n    zrangeGenericCommand(&handler, 2, 1, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);\n}\n\n/* ZRANGE <key> <min> <max> [BYSCORE | BYLEX] [REV] [WITHSCORES] [LIMIT offset count] */\nvoid zrangeCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);\n}\n\n/* ZREVRANGE <key> <start> <stop> [WITHSCORES] */\nvoid zrevrangeCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_RANK, ZRANGE_DIRECTION_REVERSE);\n}\n\n/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */\nvoid genericZrangebyscoreCommand(zrange_result_handler *handler,\n    zrangespec *range, robj *zobj, long offset, long limit, \n    int reverse) {\n    unsigned long rangelen = 0;\n\n    handler->beginResultEmission(handler, -1);\n\n    /* For invalid offset, return directly. */\n    if (offset > 0 && offset >= (long)zsetLength(zobj)) {\n        handler->finalizeResultEmission(handler, 0);\n        return;\n    }\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            eptr = zzlLastInRange(zl,range);\n        } else {\n            eptr = zzlFirstInRange(zl,range);\n        }\n\n        /* Get score pointer for the first element. */\n        if (eptr)\n            sptr = lpNext(zl,eptr);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (eptr && offset--) {\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n\n        while (eptr && limit--) {\n            double score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslValueGteMin(score,range)) break;\n            } else {\n                if (!zslValueLteMax(score,range)) break;\n            }\n\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            rangelen++;\n            if (vstr == NULL) {\n                handler->emitResultFromLongLong(handler, vlong, score);\n            } else {\n                handler->emitResultFromCBuffer(handler, vstr, vlen, score);\n            }\n\n            /* Move to next node */\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            ln = zslLastInRange(zsl,range);\n        } else {\n            ln = zslFirstInRange(zsl,range);\n        }\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (ln && offset--) {\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n\n        while (ln && limit--) {\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslValueGteMin(ln->score,range)) break;\n            } else {\n                if (!zslValueLteMax(ln->score,range)) break;\n            }\n\n            rangelen++;\n            handler->emitResultFromCBuffer(handler, ln->ele, sdslen(ln->ele), ln->score);\n\n            /* Move to next node */\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    handler->finalizeResultEmission(handler, rangelen);\n}\n\n/* ZRANGEBYSCORE <key> <min> <max> [WITHSCORES] [LIMIT offset count] */\nvoid zrangebyscoreCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_FORWARD);\n}\n\n/* ZREVRANGEBYSCORE <key> <max> <min> [WITHSCORES] [LIMIT offset count] */\nvoid zrevrangebyscoreCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_REVERSE);\n}\n\nvoid zcountCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    zrangespec range;\n    unsigned long count = 0;\n\n    /* Parse the range arguments */\n    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {\n        addReplyError(c,\"min or max is not a float\");\n        return;\n    }\n\n    /* Lookup the sorted set */\n    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||\n        checkType(c, zobj, OBJ_ZSET)) return;\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        double score;\n\n        /* Use the first element in range as the starting point */\n        eptr = zzlFirstInRange(zl,&range);\n\n        /* No \"first\" element */\n        if (eptr == NULL) {\n            addReply(c, shared.czero);\n            return;\n        }\n\n        /* First element is in range */\n        sptr = lpNext(zl,eptr);\n        score = zzlGetScore(sptr);\n        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));\n\n        /* Iterate over elements in range */\n        while (eptr) {\n            score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (!zslValueLteMax(score,&range)) {\n                break;\n            } else {\n                count++;\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *zn;\n        unsigned long rank;\n\n        /* Find first element in range */\n        zn = zslFirstInRange(zsl, &range);\n\n        /* Use rank of first element, if any, to determine preliminary count */\n        if (zn != NULL) {\n            rank = zslGetRank(zsl, zn->score, zn->ele);\n            count = (zsl->length - (rank - 1));\n\n            /* Find last element in range */\n            zn = zslLastInRange(zsl, &range);\n\n            /* Use rank of last element, if any, to determine the actual count */\n            if (zn != NULL) {\n                rank = zslGetRank(zsl, zn->score, zn->ele);\n                count -= (zsl->length - rank);\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    addReplyLongLong(c, count);\n}\n\nvoid zlexcountCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    zlexrangespec range;\n    unsigned long count = 0;\n\n    /* Parse the range arguments */\n    if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {\n        addReplyError(c,\"min or max not valid string range item\");\n        return;\n    }\n\n    /* Lookup the sorted set */\n    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||\n        checkType(c, zobj, OBJ_ZSET))\n    {\n        zslFreeLexRange(&range);\n        return;\n    }\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n\n        /* Use the first element in range as the starting point */\n        eptr = zzlFirstInLexRange(zl,&range);\n\n        /* No \"first\" element */\n        if (eptr == NULL) {\n            zslFreeLexRange(&range);\n            addReply(c, shared.czero);\n            return;\n        }\n\n        /* First element is in range */\n        sptr = lpNext(zl,eptr);\n        serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&range));\n\n        /* Iterate over elements in range */\n        while (eptr) {\n            /* Abort when the node is no longer in range. */\n            if (!zzlLexValueLteMax(eptr,&range)) {\n                break;\n            } else {\n                count++;\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *zn;\n        unsigned long rank;\n\n        /* Find first element in range */\n        zn = zslFirstInLexRange(zsl, &range);\n\n        /* Use rank of first element, if any, to determine preliminary count */\n        if (zn != NULL) {\n            rank = zslGetRank(zsl, zn->score, zn->ele);\n            count = (zsl->length - (rank - 1));\n\n            /* Find last element in range */\n            zn = zslLastInLexRange(zsl, &range);\n\n            /* Use rank of last element, if any, to determine the actual count */\n            if (zn != NULL) {\n                rank = zslGetRank(zsl, zn->score, zn->ele);\n                count -= (zsl->length - rank);\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    zslFreeLexRange(&range);\n    addReplyLongLong(c, count);\n}\n\n/* This command implements ZRANGEBYLEX, ZREVRANGEBYLEX. */\nvoid genericZrangebylexCommand(zrange_result_handler *handler,\n    zlexrangespec *range, robj *zobj, int withscores, long offset, long limit,\n    int reverse)\n{\n    unsigned long rangelen = 0;\n\n    handler->beginResultEmission(handler, -1);\n\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            eptr = zzlLastInLexRange(zl,range);\n        } else {\n            eptr = zzlFirstInLexRange(zl,range);\n        }\n\n        /* Get score pointer for the first element. */\n        if (eptr)\n            sptr = lpNext(zl,eptr);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (eptr && offset--) {\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n\n        while (eptr && limit--) {\n            double score = 0;\n            if (withscores) /* don't bother to extract the score if it's gonna be ignored. */\n                score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zzlLexValueGteMin(eptr,range)) break;\n            } else {\n                if (!zzlLexValueLteMax(eptr,range)) break;\n            }\n\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            rangelen++;\n            if (vstr == NULL) {\n                handler->emitResultFromLongLong(handler, vlong, score);\n            } else {\n                handler->emitResultFromCBuffer(handler, vstr, vlen, score);\n            }\n\n            /* Move to next node */\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            ln = zslLastInLexRange(zsl,range);\n        } else {\n            ln = zslFirstInLexRange(zsl,range);\n        }\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        while (ln && offset--) {\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n\n        while (ln && limit--) {\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslLexValueGteMin(ln->ele,range)) break;\n            } else {\n                if (!zslLexValueLteMax(ln->ele,range)) break;\n            }\n\n            rangelen++;\n            handler->emitResultFromCBuffer(handler, ln->ele, sdslen(ln->ele), ln->score);\n\n            /* Move to next node */\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n\n    handler->finalizeResultEmission(handler, rangelen);\n}\n\n/* ZRANGEBYLEX <key> <min> <max> [LIMIT offset count] */\nvoid zrangebylexCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_FORWARD);\n}\n\n/* ZREVRANGEBYLEX <key> <max> <min> [LIMIT offset count] */\nvoid zrevrangebylexCommand(client *c) {\n    zrange_result_handler handler;\n    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);\n    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_REVERSE);\n}\n\n/**\n * This function handles ZRANGE and ZRANGESTORE, and also the deprecated\n * Z[REV]RANGE[BYPOS|BYLEX] commands.\n *\n * The simple ZRANGE and ZRANGESTORE can take _AUTO in rangetype and direction,\n * other command pass explicit value.\n *\n * The argc_start points to the src key argument, so following syntax is like:\n * <src> <min> <max> [BYSCORE | BYLEX] [REV] [WITHSCORES] [LIMIT offset count]\n */\nvoid zrangeGenericCommand(zrange_result_handler *handler, int argc_start, int store,\n                          zrange_type rangetype, zrange_direction direction)\n{\n    client *c = handler->client;\n    robj *key = c->argv[argc_start];\n    robj *zobj;\n    zrangespec range;\n    zlexrangespec lexrange;\n    int minidx = argc_start + 1;\n    int maxidx = argc_start + 2;\n\n    /* Options common to all */\n    long opt_start = 0;\n    long opt_end = 0;\n    int opt_withscores = 0;\n    long opt_offset = 0;\n    long opt_limit = -1;\n\n    /* Step 1: Skip the <src> <min> <max> args and parse remaining optional arguments. */\n    for (int j=argc_start + 3; j < c->argc; j++) {\n        int leftargs = c->argc-j-1;\n        if (!store && !strcasecmp(c->argv[j]->ptr,\"withscores\")) {\n            opt_withscores = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"limit\") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &opt_offset, NULL) != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &opt_limit, NULL) != C_OK))\n            {\n                return;\n            }\n            j += 2;\n        } else if (direction == ZRANGE_DIRECTION_AUTO &&\n                   !strcasecmp(c->argv[j]->ptr,\"rev\"))\n        {\n            direction = ZRANGE_DIRECTION_REVERSE;\n        } else if (rangetype == ZRANGE_AUTO &&\n                   !strcasecmp(c->argv[j]->ptr,\"bylex\"))\n        {\n            rangetype = ZRANGE_LEX;\n        } else if (rangetype == ZRANGE_AUTO &&\n                   !strcasecmp(c->argv[j]->ptr,\"byscore\"))\n        {\n            rangetype = ZRANGE_SCORE;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* Use defaults if not overridden by arguments. */\n    if (direction == ZRANGE_DIRECTION_AUTO)\n        direction = ZRANGE_DIRECTION_FORWARD;\n    if (rangetype == ZRANGE_AUTO)\n        rangetype = ZRANGE_RANK;\n\n    /* Check for conflicting arguments. */\n    if (opt_limit != -1 && rangetype == ZRANGE_RANK) {\n        addReplyError(c,\"syntax error, LIMIT is only supported in combination with either BYSCORE or BYLEX\");\n        return;\n    }\n    if (opt_withscores && rangetype == ZRANGE_LEX) {\n        addReplyError(c,\"syntax error, WITHSCORES not supported in combination with BYLEX\");\n        return;\n    }\n\n    if (direction == ZRANGE_DIRECTION_REVERSE &&\n        ((ZRANGE_SCORE == rangetype) || (ZRANGE_LEX == rangetype)))\n    {\n        /* Range is given as [max,min] */\n        int tmp = maxidx;\n        maxidx = minidx;\n        minidx = tmp;\n    }\n\n    /* Step 2: Parse the range. */\n    switch (rangetype) {\n    case ZRANGE_AUTO:\n    case ZRANGE_RANK:\n        /* Z[REV]RANGE, ZRANGESTORE [REV]RANGE */\n        if ((getLongFromObjectOrReply(c, c->argv[minidx], &opt_start,NULL) != C_OK) ||\n            (getLongFromObjectOrReply(c, c->argv[maxidx], &opt_end,NULL) != C_OK))\n        {\n            return;\n        }\n        break;\n\n    case ZRANGE_SCORE:\n        /* Z[REV]RANGEBYSCORE, ZRANGESTORE [REV]RANGEBYSCORE */\n        if (zslParseRange(c->argv[minidx], c->argv[maxidx], &range) != C_OK) {\n            addReplyError(c, \"min or max is not a float\");\n            return;\n        }\n        break;\n\n    case ZRANGE_LEX:\n        /* Z[REV]RANGEBYLEX, ZRANGESTORE [REV]RANGEBYLEX */\n        if (zslParseLexRange(c->argv[minidx], c->argv[maxidx], &lexrange) != C_OK) {\n            addReplyError(c, \"min or max not valid string range item\");\n            return;\n        }\n        break;\n    }\n\n    if (opt_withscores || store) {\n        zrangeResultHandlerScoreEmissionEnable(handler);\n    }\n\n    /* Step 3: Lookup the key and get the range. */\n    zobj = lookupKeyRead(c->db, key);\n    if (zobj == NULL) {\n        if (store) {\n            handler->beginResultEmission(handler, -1);\n            handler->finalizeResultEmission(handler, 0);\n        } else {\n            addReply(c, shared.emptyarray);\n        }\n        goto cleanup;\n    }\n\n    if (checkType(c,zobj,OBJ_ZSET)) goto cleanup;\n\n    /* Step 4: Pass this to the command-specific handler. */\n    switch (rangetype) {\n    case ZRANGE_AUTO:\n    case ZRANGE_RANK:\n        genericZrangebyrankCommand(handler, zobj, opt_start, opt_end,\n            opt_withscores || store, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n\n    case ZRANGE_SCORE:\n        genericZrangebyscoreCommand(handler, &range, zobj, opt_offset,\n            opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n\n    case ZRANGE_LEX:\n        genericZrangebylexCommand(handler, &lexrange, zobj, opt_withscores || store,\n            opt_offset, opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n    }\n\n    /* Instead of returning here, we'll just fall-through the clean-up. */\n\ncleanup:\n\n    if (rangetype == ZRANGE_LEX) {\n        zslFreeLexRange(&lexrange);\n    }\n}\n\nvoid zcardCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    addReplyLongLong(c,zsetLength(zobj));\n}\n\nvoid zscoreCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    double score;\n\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.null[c->resp])) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {\n        addReplyNull(c);\n    } else {\n        addReplyDouble(c,score);\n    }\n}\n\nvoid zmscoreCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    double score;\n    zobj = lookupKeyRead(c->db,key);\n    if (checkType(c,zobj,OBJ_ZSET)) return;\n\n    addReplyArrayLen(c,c->argc - 2);\n    for (int j = 2; j < c->argc; j++) {\n        /* Treat a missing set the same way as an empty set */\n        if (zobj == NULL || zsetScore(zobj,c->argv[j]->ptr,&score) == C_ERR) {\n            addReplyNull(c);\n        } else {\n            addReplyDouble(c,score);\n        }\n    }\n}\n\nvoid zrankGenericCommand(client *c, int reverse) {\n    robj *key = c->argv[1];\n    robj *ele = c->argv[2];\n    robj *zobj;\n    long rank;\n\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.null[c->resp])) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));\n    rank = zsetRank(zobj,ele->ptr,reverse);\n    if (rank >= 0) {\n        addReplyLongLong(c,rank);\n    } else {\n        addReplyNull(c);\n    }\n}\n\nvoid zrankCommand(client *c) {\n    zrankGenericCommand(c, 0);\n}\n\nvoid zrevrankCommand(client *c) {\n    zrankGenericCommand(c, 1);\n}\n\nvoid zscanCommand(client *c) {\n    robj *o;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,o,OBJ_ZSET)) return;\n    scanGenericCommand(c,o,cursor);\n}\n\n/* This command implements the generic zpop operation, used by:\n * ZPOPMIN, ZPOPMAX, BZPOPMIN, BZPOPMAX and ZMPOP. This function is also used\n * inside blocked.c in the unblocking stage of BZPOPMIN, BZPOPMAX and BZMPOP.\n *\n * If 'emitkey' is true also the key name is emitted, useful for the blocking\n * behavior of BZPOP[MIN|MAX], since we can block into multiple keys.\n * Or in ZMPOP/BZMPOP, because we also can take multiple keys.\n *\n * 'count' is the number of elements requested to pop, or -1 for plain single pop.\n *\n * 'use_nested_array' when false it generates a flat array (with or without key name).\n * When true, it generates a nested 2 level array of field + score pairs, or 3 level when emitkey is set.\n *\n * 'reply_nil_when_empty' when true we reply a NIL if we are not able to pop up any elements.\n * Like in ZMPOP/BZMPOP we reply with a structured nested array containing key name\n * and member + score pairs. In these commands, we reply with null when we have no result.\n * Otherwise in ZPOPMIN/ZPOPMAX we reply an empty array by default.\n *\n * 'deleted' is an optional output argument to get an indication\n * if the key got deleted by this function.\n * */\nvoid genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey,\n                        long count, int use_nested_array, int reply_nil_when_empty, int *deleted) {\n    int idx;\n    robj *key = NULL;\n    robj *zobj = NULL;\n    sds ele;\n    double score;\n\n    if (deleted) *deleted = 0;\n\n    /* Check type and break on the first error, otherwise identify candidate. */\n    idx = 0;\n    while (idx < keyc) {\n        key = keyv[idx++];\n        zobj = lookupKeyWrite(c->db,key);\n        if (!zobj) continue;\n        if (checkType(c,zobj,OBJ_ZSET)) return;\n        break;\n    }\n\n    /* No candidate for zpopping, return empty. */\n    if (!zobj) {\n        if (reply_nil_when_empty) {\n            addReplyNullArray(c);\n        } else {\n            addReply(c,shared.emptyarray);\n        }\n        return;\n    }\n\n    if (count == 0) {\n        /* ZPOPMIN/ZPOPMAX with count 0. */\n        addReply(c, shared.emptyarray);\n        return;\n    }\n\n    long result_count = 0;\n\n    /* When count is -1, we need to correct it to 1 for plain single pop. */\n    if (count == -1) count = 1;\n\n    long llen = zsetLength(zobj);\n    long rangelen = (count > llen) ? llen : count;\n\n    if (!use_nested_array && !emitkey) {\n        /* ZPOPMIN/ZPOPMAX with or without COUNT option in RESP2. */\n        addReplyArrayLen(c, rangelen * 2);\n    } else if (use_nested_array && !emitkey) {\n        /* ZPOPMIN/ZPOPMAX with COUNT option in RESP3. */\n        addReplyArrayLen(c, rangelen);\n    } else if (!use_nested_array && emitkey) {\n        /* BZPOPMIN/BZPOPMAX in RESP2 and RESP3. */\n        addReplyArrayLen(c, rangelen * 2 + 1);\n        addReplyBulk(c, key);\n    } else if (use_nested_array && emitkey) {\n        /* ZMPOP/BZMPOP in RESP2 and RESP3. */\n        addReplyArrayLen(c, 2);\n        addReplyBulk(c, key);\n        addReplyArrayLen(c, rangelen);\n    }\n\n    /* Remove the element. */\n    do {\n        if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n            unsigned char *zl = zobj->ptr;\n            unsigned char *eptr, *sptr;\n            unsigned char *vstr;\n            unsigned int vlen;\n            long long vlong;\n\n            /* Get the first or last element in the sorted set. */\n            eptr = lpSeek(zl,where == ZSET_MAX ? -2 : 0);\n            serverAssertWithInfo(c,zobj,eptr != NULL);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            if (vstr == NULL)\n                ele = sdsfromlonglong(vlong);\n            else\n                ele = sdsnewlen(vstr,vlen);\n\n            /* Get the score. */\n            sptr = lpNext(zl,eptr);\n            serverAssertWithInfo(c,zobj,sptr != NULL);\n            score = zzlGetScore(sptr);\n        } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = zobj->ptr;\n            zskiplist *zsl = zs->zsl;\n            zskiplistNode *zln;\n\n            /* Get the first or last element in the sorted set. */\n            zln = (where == ZSET_MAX ? zsl->tail :\n                                       zsl->header->level[0].forward);\n\n            /* There must be an element in the sorted set. */\n            serverAssertWithInfo(c,zobj,zln != NULL);\n            ele = sdsdup(zln->ele);\n            score = zln->score;\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n\n        serverAssertWithInfo(c,zobj,zsetDel(zobj,ele));\n        server.dirty++;\n\n        if (result_count == 0) { /* Do this only for the first iteration. */\n            char *events[2] = {\"zpopmin\",\"zpopmax\"};\n            notifyKeyspaceEvent(NOTIFY_ZSET,events[where],key,c->db->id);\n            signalModifiedKey(c,c->db,key);\n        }\n\n        if (use_nested_array) {\n            addReplyArrayLen(c,2);\n        }\n        addReplyBulkCBuffer(c,ele,sdslen(ele));\n        addReplyDouble(c,score);\n        sdsfree(ele);\n        ++result_count;\n    } while(--rangelen);\n\n    /* Remove the key, if indeed needed. */\n    if (zsetLength(zobj) == 0) {\n        if (deleted) *deleted = 1;\n\n        dbDelete(c->db,key);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n    }\n\n    if (c->cmd->proc == zmpopCommand) {\n        /* Always replicate it as ZPOP[MIN|MAX] with COUNT option instead of ZMPOP. */\n        robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);\n        rewriteClientCommandVector(c, 3,\n                                   (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,\n                                   key, count_obj);\n        decrRefCount(count_obj);\n    }\n}\n\n/* ZPOPMIN/ZPOPMAX key [<count>] */\nvoid zpopMinMaxCommand(client *c, int where) {\n    if (c->argc > 3) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    long count = -1; /* -1 for plain single pop. */\n    if (c->argc == 3 && getPositiveLongFromObjectOrReply(c, c->argv[2], &count, NULL) != C_OK)\n        return;\n\n    /* Respond with a single (flat) array in RESP2 or if count is -1\n     * (returning a single element). In RESP3, when count > 0 use nested array. */\n    int use_nested_array = (c->resp > 2 && count != -1);\n\n    genericZpopCommand(c, &c->argv[1], 1, where, 0, count, use_nested_array, 0, NULL);\n}\n\n/* ZPOPMIN key [<count>] */\nvoid zpopminCommand(client *c) {\n    zpopMinMaxCommand(c, ZSET_MIN);\n}\n\n/* ZPOPMAX key [<count>] */\nvoid zpopmaxCommand(client *c) {\n    zpopMinMaxCommand(c, ZSET_MAX);\n}\n\n/* BZPOPMIN, BZPOPMAX, BZMPOP actual implementation.\n *\n * 'numkeys' is the number of keys.\n *\n * 'timeout_idx' parameter position of block timeout.\n *\n * 'where' ZSET_MIN or ZSET_MAX.\n *\n * 'count' is the number of elements requested to pop, or -1 for plain single pop.\n *\n * 'use_nested_array' when false it generates a flat array (with or without key name).\n * When true, it generates a nested 3 level array of keyname, field + score pairs.\n * */\nvoid blockingGenericZpopCommand(client *c, robj **keys, int numkeys, int where,\n                                int timeout_idx, long count, int use_nested_array, int reply_nil_when_empty) {\n    robj *o;\n    robj *key;\n    mstime_t timeout;\n    int j;\n\n    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)\n        != C_OK) return;\n\n    for (j = 0; j < numkeys; j++) {\n        key = keys[j];\n        o = lookupKeyWrite(c->db,key);\n        /* Non-existing key, move to next key. */\n        if (o == NULL) continue;\n\n        if (checkType(c,o,OBJ_ZSET)) return;\n\n        long llen = zsetLength(o);\n        /* Empty zset, move to next key. */\n        if (llen == 0) continue;\n\n        /* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */\n        genericZpopCommand(c, &key, 1, where, 1, count, use_nested_array, reply_nil_when_empty, NULL);\n\n        if (count == -1) {\n            /* Replicate it as ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */\n            rewriteClientCommandVector(c,2,\n                                       (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,\n                                       key);\n        } else {\n            /* Replicate it as ZPOP[MIN|MAX] with COUNT option. */\n            robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);\n            rewriteClientCommandVector(c, 3,\n                                       (where == ZSET_MAX) ? shared.zpopmax : shared.zpopmin,\n                                       key, count_obj);\n            decrRefCount(count_obj);\n        }\n\n        return;\n    }\n\n    /* If we are not allowed to block the client and the zset is empty the only thing\n     * we can do is treating it as a timeout (even with timeout 0). */\n    if (c->flags & CLIENT_DENY_BLOCKING) {\n        addReplyNullArray(c);\n        return;\n    }\n\n    /* If the keys do not exist we must block */\n    struct blockPos pos = {where};\n    blockForKeys(c,BLOCKED_ZSET,keys,numkeys,count,timeout,NULL,&pos,NULL);\n}\n\n// BZPOPMIN key [key ...] timeout\nvoid bzpopminCommand(client *c) {\n    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MIN, c->argc-1, -1, 0, 0);\n}\n\n// BZPOPMAX key [key ...] timeout\nvoid bzpopmaxCommand(client *c) {\n    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MAX, c->argc-1, -1, 0, 0);\n}\n\nstatic void zrandmemberReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {\n    for (unsigned long i = 0; i < count; i++) {\n        if (vals && c->resp > 2)\n            addReplyArrayLen(c,2);\n        if (keys[i].sval)\n            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);\n        else\n            addReplyBulkLongLong(c, keys[i].lval);\n        if (vals) {\n            if (vals[i].sval) {\n                addReplyDouble(c, zzlStrtod(vals[i].sval,vals[i].slen));\n            } else\n                addReplyDouble(c, vals[i].lval);\n        }\n    }\n}\n\n/* How many times bigger should be the zset compared to the requested size\n * for us to not use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define ZRANDMEMBER_SUB_STRATEGY_MUL 3\n\n/* If client is trying to ask for a very large number of random elements,\n * queuing may consume an unlimited amount of memory, so we want to limit\n * the number of randoms per time. */\n#define ZRANDMEMBER_RANDOM_SAMPLE_LIMIT 1000\n\nvoid zrandmemberWithCountCommand(client *c, long l, int withscores) {\n    unsigned long count, size;\n    int uniq = 1;\n    robj *zsetobj;\n\n    if ((zsetobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptyarray))\n        == NULL || checkType(c, zsetobj, OBJ_ZSET)) return;\n    size = zsetLength(zsetobj);\n\n    if(l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        count = -l;\n        uniq = 0;\n    }\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        if (withscores && c->resp == 2)\n            addReplyArrayLen(c, count*2);\n        else\n            addReplyArrayLen(c, count);\n        if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = zsetobj->ptr;\n            while (count--) {\n                dictEntry *de = dictGetFairRandomKey(zs->dict);\n                sds key = dictGetKey(de);\n                if (withscores && c->resp > 2)\n                    addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c, key, sdslen(key));\n                if (withscores)\n                    addReplyDouble(c, *(double*)dictGetVal(de));\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n        } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {\n            listpackEntry *keys, *vals = NULL;\n            unsigned long limit, sample_count;\n            limit = count > ZRANDMEMBER_RANDOM_SAMPLE_LIMIT ? ZRANDMEMBER_RANDOM_SAMPLE_LIMIT : count;\n            keys = zmalloc(sizeof(listpackEntry)*limit);\n            if (withscores)\n                vals = zmalloc(sizeof(listpackEntry)*limit);\n            while (count) {\n                sample_count = count > limit ? limit : count;\n                count -= sample_count;\n                lpRandomPairs(zsetobj->ptr, sample_count, keys, vals);\n                zrandmemberReplyWithListpack(c, sample_count, keys, vals);\n                if (c->flags & CLIENT_CLOSE_ASAP)\n                    break;\n            }\n            zfree(keys);\n            zfree(vals);\n        }\n        return;\n    }\n\n    zsetopsrc src;\n    zsetopval zval;\n    src.subject = zsetobj;\n    src.type = zsetobj->type;\n    src.encoding = zsetobj->encoding;\n    zuiInitIterator(&src);\n    memset(&zval, 0, sizeof(zval));\n\n    /* Initiate reply count, RESP3 responds with nested array, RESP2 with flat one. */\n    long reply_size = count < size ? count : size;\n    if (withscores && c->resp == 2)\n        addReplyArrayLen(c, reply_size*2);\n    else\n        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the zset: simply return the whole zset. */\n    if (count >= size) {\n        while (zuiNext(&src, &zval)) {\n            if (withscores && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, zuiNewSdsFromValue(&zval));\n            if (withscores)\n                addReplyDouble(c, zval.score);\n        }\n        zuiClearIterator(&src);\n        return;\n    }\n\n    /* CASE 3:\n     * The number of elements inside the zset is not greater than\n     * ZRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a dict from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*ZRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        dict *d = dictCreate(&sdsReplyDictType);\n        dictExpand(d, size);\n        /* Add all the elements into the temporary dictionary. */\n        while (zuiNext(&src, &zval)) {\n            sds key = zuiNewSdsFromValue(&zval);\n            dictEntry *de = dictAddRaw(d, key, NULL);\n            serverAssert(de);\n            if (withscores)\n                dictSetDoubleVal(de, zval.score);\n        }\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n\n        /* Reply with what's in the dict and release memory */\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(d);\n        while ((de = dictNext(di)) != NULL) {\n            if (withscores && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, dictGetKey(de));\n            if (withscores)\n                addReplyDouble(c, dictGetDoubleVal(de));\n        }\n\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n\n    /* CASE 4: We have a big zset compared to the requested number of elements.\n     * In this case we can simply get random elements from the zset and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {\n            /* it is inefficient to repeatedly pick one random element from a\n             * listpack. so we use this instead: */\n            listpackEntry *keys, *vals = NULL;\n            keys = zmalloc(sizeof(listpackEntry)*count);\n            if (withscores)\n                vals = zmalloc(sizeof(listpackEntry)*count);\n            serverAssert(lpRandomPairsUnique(zsetobj->ptr, count, keys, vals) == count);\n            zrandmemberReplyWithListpack(c, count, keys, vals);\n            zfree(keys);\n            zfree(vals);\n            zuiClearIterator(&src);\n            return;\n        }\n\n        /* Hashtable encoding (generic implementation) */\n        unsigned long added = 0;\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, count);\n\n        while (added < count) {\n            listpackEntry key;\n            double score;\n            zsetTypeRandomElement(zsetobj, size, &key, withscores ? &score: NULL);\n\n            /* Try to add the object to the dictionary. If it already exists\n            * free it, otherwise increment the number of objects we have\n            * in the result dictionary. */\n            sds skey = zsetSdsFromListpackEntry(&key);\n            if (dictAdd(d,skey,NULL) != DICT_OK) {\n                sdsfree(skey);\n                continue;\n            }\n            added++;\n\n            if (withscores && c->resp > 2)\n                addReplyArrayLen(c,2);\n            zsetReplyFromListpackEntry(c, &key);\n            if (withscores)\n                addReplyDouble(c, score);\n        }\n\n        /* Release memory */\n        dictRelease(d);\n    }\n    zuiClearIterator(&src);\n}\n\n/* ZRANDMEMBER key [<count> [WITHSCORES]] */\nvoid zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withscores = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}\n\n/* ZMPOP/BZMPOP\n *\n * 'numkeys_idx' parameter position of key number.\n * 'is_block' this indicates whether it is a blocking variant. */\nvoid zmpopGenericCommand(client *c, int numkeys_idx, int is_block) {\n    long j;\n    long numkeys = 0;      /* Number of keys. */\n    int where = 0;         /* ZSET_MIN or ZSET_MAX. */\n    long count = -1;       /* Reply will consist of up to count elements, depending on the zset's length. */\n\n    /* Parse the numkeys. */\n    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,\n                                      &numkeys, \"numkeys should be greater than 0\") != C_OK)\n        return;\n\n    /* Parse the where. where_idx: the index of where in the c->argv. */\n    long where_idx = numkeys_idx + numkeys + 1;\n    if (where_idx >= c->argc) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    if (!strcasecmp(c->argv[where_idx]->ptr, \"MIN\")) {\n        where = ZSET_MIN;\n    } else if (!strcasecmp(c->argv[where_idx]->ptr, \"MAX\")) {\n        where = ZSET_MAX;\n    } else {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n\n    /* Parse the optional arguments. */\n    for (j = where_idx + 1; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc - 1) - j;\n\n        if (count == -1 && !strcasecmp(opt, \"COUNT\") && moreargs) {\n            j++;\n            if (getRangeLongFromObjectOrReply(c, c->argv[j], 1, LONG_MAX,\n                                              &count,\"count should be greater than 0\") != C_OK)\n                return;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n\n    if (count == -1) count = 1;\n\n    if (is_block) {\n        /* BLOCK. We will handle CLIENT_DENY_BLOCKING flag in blockingGenericZpopCommand. */\n        blockingGenericZpopCommand(c, c->argv+numkeys_idx+1, numkeys, where, 1, count, 1, 1);\n    } else {\n        /* NON-BLOCK */\n        genericZpopCommand(c, c->argv+numkeys_idx+1, numkeys, where, 1, count, 1, 1, NULL);\n    }\n}\n\n/* ZMPOP numkeys key [<key> ...] MIN|MAX [COUNT count] */\nvoid zmpopCommand(client *c) {\n    zmpopGenericCommand(c, 1, 0);\n}\n\n/* BZMPOP timeout numkeys key [<key> ...] MIN|MAX [COUNT count] */\nvoid bzmpopCommand(client *c) {\n    zmpopGenericCommand(c, 2, 1);\n}\n", "start_server {tags {\"hash\"}} {\n    test {HSET/HLEN - Small hash creation} {\n        array set smallhash {}\n        for {set i 0} {$i < 8} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists smallhash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset smallhash $key $val\n            set smallhash($key) $val\n        }\n        list [r hlen smallhash]\n    } {8}\n\n    test {Is the small hash encoded with a listpack?} {\n        assert_encoding listpack smallhash\n    }\n\n    proc create_hash {key entries} {\n        r del $key\n        foreach entry $entries {\n            r hset $key [lindex $entry 0] [lindex $entry 1]\n        }\n    }\n\n    proc get_keys {l} {\n        set res {}\n        foreach entry $l {\n            set key [lindex $entry 0]\n            lappend res $key\n        }\n        return $res\n    }\n\n    foreach {type contents} \"listpack {{a 1} {b 2} {c 3}} hashtable {{a 1} {b 2} {[randstring 70 90 alpha] 3}}\" {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-ziplist-value 10\n        create_hash myhash $contents\n        assert_encoding $type myhash\n\n        # coverage for objectComputeSize\n        assert_morethan [memory_usage myhash] 0\n\n        test \"HRANDFIELD - $type\" {\n            unset -nocomplain myhash\n            array set myhash {}\n            for {set i 0} {$i < 100} {incr i} {\n                set key [r hrandfield myhash]\n                set myhash($key) 1\n            }\n            assert_equal [lsort [get_keys $contents]] [lsort [array names myhash]]\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n    test \"HRANDFIELD with RESP3\" {\n        r hello 3\n        set res [r hrandfield myhash 3 withvalues]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 2\n\n        set res [r hrandfield myhash 3]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 1\n        r hello 2\n    }\n\n    test \"HRANDFIELD count of 0 is handled correctly\" {\n        r hrandfield myhash 0\n    } {}\n\n    test \"HRANDFIELD count overflow\" {\n        r hmset myhash a 1\n        assert_error {*value is out of range*} {r hrandfield myhash -9223372036854770000 withvalues}\n        assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808 withvalues}\n        assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808}\n    } {}\n\n    test \"HRANDFIELD with <count> against non existing key\" {\n        r hrandfield nonexisting_key 100\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"HRANDFIELD count of 0 is handled correctly - emptyarray\" {\n        r hrandfield myhash 0\n    } {*0}\n\n    test \"HRANDFIELD with <count> against non existing key - emptyarray\" {\n        r hrandfield nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} \"\n        hashtable {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {[randstring 70 90 alpha] 10}}\n        listpack {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {10 j}} \" {\n        test \"HRANDFIELD with <count> - $type\" {\n            set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n            r config set hash-max-ziplist-value 10\n            create_hash myhash $contents\n            assert_encoding $type myhash\n\n            # create a dict for easy lookup\n            set mydict [dict create {*}[r hgetall myhash]]\n\n            # We'll stress different parts of the code, see the implementation\n            # of HRANDFIELD for more information, but basically there are\n            # four different code paths.\n\n            # PATH 1: Use negative count.\n\n            # 1) Check that it returns repeated elements with and without values.\n            set res [r hrandfield myhash -20]\n            assert_equal [llength $res] 20\n            set res [r hrandfield myhash -1001]\n            assert_equal [llength $res] 1001\n            # again with WITHVALUES\n            set res [r hrandfield myhash -20 withvalues]\n            assert_equal [llength $res] 40\n            set res [r hrandfield myhash -1001 withvalues]\n            assert_equal [llength $res] 2002\n\n            # Test random uniform distribution\n            # df = 9, 40 means 0.00001 probability\n            set res [r hrandfield myhash -1000]\n            assert_lessthan [chi_square_value $res] 40\n\n            # 2) Check that all the elements actually belong to the original hash.\n            foreach {key val} $res {\n                assert {[dict exists $mydict $key]}\n            }\n\n            # 3) Check that eventually all the elements are returned.\n            #    Use both WITHVALUES and without\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                if {[expr {$iterations % 2}] == 0} {\n                    set res [r hrandfield myhash -3 withvalues]\n                    foreach {key val} $res {\n                        dict append auxset $key $val\n                    }\n                } else {\n                    set res [r hrandfield myhash -3]\n                    foreach key $res {\n                        dict append auxset $key $val\n                    }\n                }\n                if {[lsort [dict keys $mydict]] eq\n                    [lsort [dict keys $auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {10 20} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] 10\n                assert_equal [lsort $res] [lsort [dict keys $mydict]]\n\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] 20\n                assert_equal [lsort $res] [lsort $mydict]\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n            foreach size {8 2} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] $size\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] [expr {$size * 2}]\n\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                foreach ele [dict keys $res] {\n                    assert {[dict exists $mydict $ele]}\n                }\n\n                # 2) Check that eventually all the elements are returned.\n                #    Use both WITHVALUES and without\n                unset -nocomplain auxset\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                set all_ele_return false\n                while {$iterations != 0} {\n                    incr iterations -1\n                    if {[expr {$iterations % 2}] == 0} {\n                        set res [r hrandfield myhash $size withvalues]\n                        foreach {key value} $res {\n                            dict append auxset $key $value\n                            lappend allkey $key\n                        }\n                    } else {\n                        set res [r hrandfield myhash $size]\n                        foreach key $res {\n                            dict append auxset $key\n                            lappend allkey $key\n                        }\n                    }\n                    if {[lsort [dict keys $mydict]] eq\n                        [lsort [dict keys $auxset]]} {\n                        set all_ele_return true\n                    }\n                }\n                assert_equal $all_ele_return true\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n\n    test {HSET/HLEN - Big hash creation} {\n        array set bighash {}\n        for {set i 0} {$i < 1024} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists bighash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset bighash $key $val\n            set bighash($key) $val\n        }\n        list [r hlen bighash]\n    } {1024}\n\n    test {Is the big hash encoded with an hash table?} {\n        assert_encoding hashtable bighash\n    }\n\n    test {HGET against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {$smallhash($k) ne [r hget smallhash $k]} {\n                set err \"$smallhash($k) != [r hget smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {$bighash($k) ne [r hget bighash $k]} {\n                set err \"$bighash($k) != [r hget bighash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against non existing key} {\n        set rv {}\n        lappend rv [r hget smallhash __123123123__]\n        lappend rv [r hget bighash __123123123__]\n        set _ $rv\n    } {{} {}}\n\n    test {HSET in update and insert mode} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hset smallhash $k newval1]\n        set smallhash($k) newval1\n        lappend rv [r hget smallhash $k]\n        lappend rv [r hset smallhash __foobar123__ newval]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hset bighash $k newval2]\n        set bighash($k) newval2\n        lappend rv [r hget bighash $k]\n        lappend rv [r hset bighash __foobar123__ newval]\n        lappend rv [r hdel smallhash __foobar123__]\n        lappend rv [r hdel bighash __foobar123__]\n        set _ $rv\n    } {0 newval1 1 0 newval2 1 1 1}\n\n    test {HSETNX target key missing - small hash} {\n        r hsetnx smallhash __123123123__ foo\n        r hget smallhash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - small hash} {\n        r hsetnx smallhash __123123123__ bar\n        set result [r hget smallhash __123123123__]\n        r hdel smallhash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSETNX target key missing - big hash} {\n        r hsetnx bighash __123123123__ foo\n        r hget bighash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - big hash} {\n        r hsetnx bighash __123123123__ bar\n        set result [r hget bighash __123123123__]\n        r hdel bighash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSET/HMSET wrong number of args} {\n        assert_error {*wrong number of arguments for 'hset' command} {r hset smallhash key1 val1 key2}\n        assert_error {*wrong number of arguments for 'hmset' command} {r hmset smallhash key1 val1 key2}\n    }\n\n    test {HMSET - small hash} {\n        set args {}\n        foreach {k v} [array get smallhash] {\n            set newval [randstring 0 8 alpha]\n            set smallhash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset smallhash {*}$args\n    } {OK}\n\n    test {HMSET - big hash} {\n        set args {}\n        foreach {k v} [array get bighash] {\n            set newval [randstring 0 8 alpha]\n            set bighash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset bighash {*}$args\n    } {OK}\n\n    test {HMGET against non existing key and fields} {\n        set rv {}\n        lappend rv [r hmget doesntexist __123123123__ __456456456__]\n        lappend rv [r hmget smallhash __123123123__ __456456456__]\n        lappend rv [r hmget bighash __123123123__ __456456456__]\n        set _ $rv\n    } {{{} {}} {{} {}} {{} {}}}\n\n    test {HMGET against wrong type} {\n        r set wrongtype somevalue\n        assert_error \"*wrong*\" {r hmget wrongtype field1 field2}\n    }\n\n    test {HMGET - small hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget smallhash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HMGET - big hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget bighash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HKEYS - small hash} {\n        lsort [r hkeys smallhash]\n    } [lsort [array names smallhash *]]\n\n    test {HKEYS - big hash} {\n        lsort [r hkeys bighash]\n    } [lsort [array names bighash *]]\n\n    test {HVALS - small hash} {\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals smallhash]]\n\n    test {HVALS - big hash} {\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals bighash]]\n\n    test {HGETALL - small hash} {\n        lsort [r hgetall smallhash]\n    } [lsort [array get smallhash]]\n\n    test {HGETALL - big hash} {\n        lsort [r hgetall bighash]\n    } [lsort [array get bighash]]\n\n    test {HDEL and return value} {\n        set rv {}\n        lappend rv [r hdel smallhash nokey]\n        lappend rv [r hdel bighash nokey]\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hget smallhash $k]\n        unset smallhash($k)\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hget bighash $k]\n        unset bighash($k)\n        set _ $rv\n    } {0 0 1 0 {} 1 0 {}}\n\n    test {HDEL - more than a single value} {\n        set rv {}\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 0 [r hdel myhash x y]\n        assert_equal 2 [r hdel myhash a c f]\n        r hgetall myhash\n    } {b 2}\n\n    test {HDEL - hash becomes empty before deleting all specified fields} {\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 3 [r hdel myhash a b c d e]\n        assert_equal 0 [r exists myhash]\n    }\n\n    test {HEXISTS} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hexists smallhash $k]\n        lappend rv [r hexists smallhash nokey]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hexists bighash $k]\n        lappend rv [r hexists bighash nokey]\n    } {1 0 1 0}\n\n    test {Is a ziplist encoded Hash promoted on big payload?} {\n        r hset smallhash foo [string repeat a 1024]\n        r debug object smallhash\n    } {*hashtable*} {needs:debug}\n\n    test {HINCRBY against non existing database key} {\n        r del htest\n        list [r hincrby htest foo 2]\n    } {2}\n\n    test {HINCRBY against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [r hincrby smallhash tmp 2]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 2]\n        lappend rv [r hget bighash tmp]\n    } {2 2 2 2}\n\n    test {HINCRBY against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [r hincrby smallhash tmp 3]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 3]\n        lappend rv [r hget bighash tmp]\n    } {5 5 5 5}\n\n    test {HINCRBY against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [r hincrby smallhash tmp 2] [r hincrby bighash tmp 2]\n    } {102 102}\n\n    test {HINCRBY over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 1] [r hincrby bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBY over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 17179869184] [r hincrby bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBY fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY can detect overflows} {\n        set e {}\n        r hset hash n -9223372036854775484\n        assert {[r hincrby hash n -1] == -9223372036854775485}\n        catch {r hincrby hash n -10000} e\n        set e\n    } {*overflow*}\n\n    test {HINCRBYFLOAT against non existing database key} {\n        r del htest\n        list [r hincrbyfloat htest foo 2.5]\n    } {2.5}\n\n    test {HINCRBYFLOAT against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 2.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {2.5 2.5 2.5 2.5}\n\n    test {HINCRBYFLOAT against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 3.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 3.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {6 6 6 6}\n\n    test {HINCRBYFLOAT against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [roundFloat [r hincrbyfloat smallhash tmp 2.5]] \\\n             [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n    } {102.5 102.5}\n\n    test {HINCRBYFLOAT over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 1] \\\n             [r hincrbyfloat bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBYFLOAT over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 17179869184] \\\n             [r hincrbyfloat bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle} {\n        r hset h f \"1\\x002\"\n        catch {r hincrbyfloat h f 1} err\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $err]\n    } {1}\n\n    test {HSTRLEN against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {[string length $smallhash($k)] ne [r hstrlen smallhash $k]} {\n                set err \"[string length $smallhash($k)] != [r hstrlen smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {[string length $bighash($k)] ne [r hstrlen bighash $k]} {\n                set err \"[string length $bighash($k)] != [r hstrlen bighash $k]\"\n                puts \"HSTRLEN and logical length mismatch:\"\n                puts \"key: $k\"\n                puts \"Logical content: $bighash($k)\"\n                puts \"Server  content: [r hget bighash $k]\"\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against non existing field} {\n        set rv {}\n        lappend rv [r hstrlen smallhash __123123123__]\n        lappend rv [r hstrlen bighash __123123123__]\n        set _ $rv\n    } {0 0}\n\n    test {HSTRLEN corner cases} {\n        set vals {\n            -9223372036854775808 9223372036854775807 9223372036854775808\n            {} 0 -1 x\n        }\n        foreach v $vals {\n            r hmset smallhash field $v\n            r hmset bighash field $v\n            set len1 [string length $v]\n            set len2 [r hstrlen smallhash field]\n            set len3 [r hstrlen bighash field]\n            assert {$len1 == $len2}\n            assert {$len2 == $len3}\n        }\n    }\n\n    test {HINCRBYFLOAT over hash-max-listpack-value encoded with a listpack} {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-listpack-value 8\n        \n        # hash's value exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hset smallhash tmp 0\n        r hset bighash tmp 0\n        r hincrbyfloat smallhash tmp 0.000005\n        r hincrbyfloat bighash tmp 0.0000005\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        # hash's field exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hincrbyfloat smallhash abcdefgh 1\n        r hincrbyfloat bighash abcdefghi 1\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        r config set hash-max-listpack-value $original_max_value\n    }\n\n    test {Hash ziplist regression test for large keys} {\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk a\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk b\n        r hget hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\n    } {b}\n\n    foreach size {10 512} {\n        test \"Hash fuzzing #1 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    set field [randomValue]\n                    set value [randomValue]\n                    r hset hash $field $value\n                    set hash($field) $value\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n\n        test \"Hash fuzzing #2 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    randpath {\n                        set field [randomValue]\n                        set value [randomValue]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        set field [randomSignedInt 512]\n                        set value [randomSignedInt 512]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        randpath {\n                            set field [randomValue]\n                        } {\n                            set field [randomSignedInt 512]\n                        }\n                        r hdel hash $field\n                        unset -nocomplain hash($field)\n                    }\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n    }\n\n    test {Stress test the hash ziplist -> hashtable encoding conversion} {\n        r config set hash-max-ziplist-entries 32\n        for {set j 0} {$j < 100} {incr j} {\n            r del myhash\n            for {set i 0} {$i < 64} {incr i} {\n                r hset myhash [randomValue] [randomValue]\n            }\n            assert_encoding hashtable myhash\n        }\n    }\n\n    # The following test can only be executed if we don't use Valgrind, and if\n    # we are using x86_64 architecture, because:\n    #\n    # 1) Valgrind has floating point limitations, no support for 80 bits math.\n    # 2) Other archs may have the same limits.\n    #\n    # 1.23 cannot be represented correctly with 64 bit doubles, so we skip\n    # the test, since we are only testing pretty printing here and is not\n    # a bug if the program outputs things like 1.299999...\n    if {!$::valgrind && [string match *x86_64* [exec uname -a]]} {\n        test {Test HINCRBYFLOAT for correct float representation (issue #2846)} {\n            r del myhash\n            assert {[r hincrbyfloat myhash float 1.23] eq {1.23}}\n            assert {[r hincrbyfloat myhash float 0.77] eq {2}}\n            assert {[r hincrbyfloat myhash float -0.1] eq {1.9}}\n        }\n    }\n\n    test {Hash ziplist of various encodings} {\n        r del k\n        config_set hash-max-ziplist-entries 1000000000\n        config_set hash-max-ziplist-value 1000000000\n        r hset k ZIP_INT_8B 127\n        r hset k ZIP_INT_16B 32767\n        r hset k ZIP_INT_32B 2147483647\n        r hset k ZIP_INT_64B 9223372036854775808\n        r hset k ZIP_INT_IMM_MIN 0\n        r hset k ZIP_INT_IMM_MAX 12\n        r hset k ZIP_STR_06B [string repeat x 31]\n        r hset k ZIP_STR_14B [string repeat x 8191]\n        r hset k ZIP_STR_32B [string repeat x 65535]\n        set k [r hgetall k]\n        set dump [r dump k]\n\n        # will be converted to dict at RESTORE\n        config_set hash-max-ziplist-entries 2\n        config_set sanitize-dump-payload no mayfail\n        r restore kk 0 $dump\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n    test {Hash ziplist of various encodings - sanitize dump} {\n        config_set sanitize-dump-payload yes mayfail\n        r restore kk 0 $dump replace\n        set k [r hgetall k]\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n}\n", "start_server {\n    tags {\"set\"}\n    overrides {\n        \"set-max-intset-entries\" 512\n    }\n} {\n    proc create_set {key entries} {\n        r del $key\n        foreach entry $entries { r sadd $key $entry }\n    }\n\n    test {SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - regular set} {\n        create_set myset {foo}\n        assert_encoding hashtable myset\n        assert_equal 1 [r sadd myset bar]\n        assert_equal 0 [r sadd myset bar]\n        assert_equal 2 [r scard myset]\n        assert_equal 1 [r sismember myset foo]\n        assert_equal 1 [r sismember myset bar]\n        assert_equal 0 [r sismember myset bla]\n        assert_equal {1} [r smismember myset foo]\n        assert_equal {1 1} [r smismember myset foo bar]\n        assert_equal {1 0} [r smismember myset foo bla]\n        assert_equal {0 1} [r smismember myset bla foo]\n        assert_equal {0} [r smismember myset bla]\n        assert_equal {bar foo} [lsort [r smembers myset]]\n    }\n\n    test {SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - intset} {\n        create_set myset {17}\n        assert_encoding intset myset\n        assert_equal 1 [r sadd myset 16]\n        assert_equal 0 [r sadd myset 16]\n        assert_equal 2 [r scard myset]\n        assert_equal 1 [r sismember myset 16]\n        assert_equal 1 [r sismember myset 17]\n        assert_equal 0 [r sismember myset 18]\n        assert_equal {1} [r smismember myset 16]\n        assert_equal {1 1} [r smismember myset 16 17]\n        assert_equal {1 0} [r smismember myset 16 18]\n        assert_equal {0 1} [r smismember myset 18 16]\n        assert_equal {0} [r smismember myset 18]\n        assert_equal {16 17} [lsort [r smembers myset]]\n    }\n\n    test {SMISMEMBER against non set} {\n        r lpush mylist foo\n        assert_error WRONGTYPE* {r smismember mylist bar}\n    }\n\n    test {SMISMEMBER non existing key} {\n        assert_equal {0} [r smismember myset1 foo]\n        assert_equal {0 0} [r smismember myset1 foo bar]\n    }\n\n    test {SMISMEMBER requires one or more members} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n        \n        catch {r smismember zmscoretest} e\n        assert_match {*ERR*wrong*number*arg*} $e\n    }\n\n    test {SADD against non set} {\n        r lpush mylist foo\n        assert_error WRONGTYPE* {r sadd mylist bar}\n    }\n\n    test \"SADD a non-integer against an intset\" {\n        create_set myset {1 2 3}\n        assert_encoding intset myset\n        assert_equal 1 [r sadd myset a]\n        assert_encoding hashtable myset\n    }\n\n    test \"SADD an integer larger than 64 bits\" {\n        create_set myset {213244124402402314402033402}\n        assert_encoding hashtable myset\n        assert_equal 1 [r sismember myset 213244124402402314402033402]\n        assert_equal {1} [r smismember myset 213244124402402314402033402]\n    }\n\n    test \"SADD overflows the maximum allowed integers in an intset\" {\n        r del myset\n        for {set i 0} {$i < 512} {incr i} { r sadd myset $i }\n        assert_encoding intset myset\n        assert_equal 1 [r sadd myset 512]\n        assert_encoding hashtable myset\n    }\n\n    test {Variadic SADD} {\n        r del myset\n        assert_equal 3 [r sadd myset a b c]\n        assert_equal 2 [r sadd myset A a b c B]\n        assert_equal [lsort {A a b c B}] [lsort [r smembers myset]]\n    }\n\n    test \"Set encoding after DEBUG RELOAD\" {\n        r del myintset\n        r del myhashset\n        r del mylargeintset\n        for {set i 0} {$i <  100} {incr i} { r sadd myintset $i }\n        for {set i 0} {$i < 1280} {incr i} { r sadd mylargeintset $i }\n        for {set i 0} {$i <  256} {incr i} { r sadd myhashset [format \"i%03d\" $i] }\n        assert_encoding intset myintset\n        assert_encoding hashtable mylargeintset\n        assert_encoding hashtable myhashset\n\n        r debug reload\n        assert_encoding intset myintset\n        assert_encoding hashtable mylargeintset\n        assert_encoding hashtable myhashset\n    } {} {needs:debug}\n\n    test {SREM basics - regular set} {\n        create_set myset {foo bar ciao}\n        assert_encoding hashtable myset\n        assert_equal 0 [r srem myset qux]\n        assert_equal 1 [r srem myset foo]\n        assert_equal {bar ciao} [lsort [r smembers myset]]\n    }\n\n    test {SREM basics - intset} {\n        create_set myset {3 4 5}\n        assert_encoding intset myset\n        assert_equal 0 [r srem myset 6]\n        assert_equal 1 [r srem myset 4]\n        assert_equal {3 5} [lsort [r smembers myset]]\n    }\n\n    test {SREM with multiple arguments} {\n        r del myset\n        r sadd myset a b c d\n        assert_equal 0 [r srem myset k k k]\n        assert_equal 2 [r srem myset b d x y]\n        lsort [r smembers myset]\n    } {a c}\n\n    test {SREM variadic version with more args needed to destroy the key} {\n        r del myset\n        r sadd myset 1 2 3\n        r srem myset 1 2 3 4 5 6 7 8\n    } {3}\n\n    test \"SINTERCARD with illegal arguments\" {\n        assert_error \"ERR wrong number of arguments for 'sintercard' command\" {r sintercard}\n        assert_error \"ERR wrong number of arguments for 'sintercard' command\" {r sintercard 1}\n\n        assert_error \"ERR numkeys*\" {r sintercard 0 myset{t}}\n        assert_error \"ERR numkeys*\" {r sintercard a myset{t}}\n\n        assert_error \"ERR Number of keys*\" {r sintercard 2 myset{t}}\n        assert_error \"ERR Number of keys*\" {r sintercard 3 myset{t} myset2{t}}\n\n        assert_error \"ERR syntax error*\" {r sintercard 1 myset{t} myset2{t}}\n        assert_error \"ERR syntax error*\" {r sintercard 1 myset{t} bar_arg}\n        assert_error \"ERR syntax error*\" {r sintercard 1 myset{t} LIMIT}\n\n        assert_error \"ERR LIMIT*\" {r sintercard 1 myset{t} LIMIT -1}\n        assert_error \"ERR LIMIT*\" {r sintercard 1 myset{t} LIMIT a}\n    }\n\n    test \"SINTERCARD against non-set should throw error\" {\n        r del set{t}\n        r sadd set{t} a b c\n        r set key1{t} x\n\n        assert_error \"WRONGTYPE*\" {r sintercard 1 key1{t}}\n        assert_error \"WRONGTYPE*\" {r sintercard 2 set{t} key1{t}}\n        assert_error \"WRONGTYPE*\" {r sintercard 2 key1{t} noset{t}}\n    }\n\n    test \"SINTERCARD against non-existing key\" {\n        assert_equal 0 [r sintercard 1 non-existing-key]\n        assert_equal 0 [r sintercard 1 non-existing-key limit 0]\n        assert_equal 0 [r sintercard 1 non-existing-key limit 10]\n    }\n\n    foreach {type} {hashtable intset} {\n        for {set i 1} {$i <= 5} {incr i} {\n            r del [format \"set%d{t}\" $i]\n        }\n        for {set i 0} {$i < 200} {incr i} {\n            r sadd set1{t} $i\n            r sadd set2{t} [expr $i+195]\n        }\n        foreach i {199 195 1000 2000} {\n            r sadd set3{t} $i\n        }\n        for {set i 5} {$i < 200} {incr i} {\n            r sadd set4{t} $i\n        }\n        r sadd set5{t} 0\n\n        # To make sure the sets are encoded as the type we are testing -- also\n        # when the VM is enabled and the values may be swapped in and out\n        # while the tests are running -- an extra element is added to every\n        # set that determines its encoding.\n        set large 200\n        if {$type eq \"hashtable\"} {\n            set large foo\n        }\n\n        for {set i 1} {$i <= 5} {incr i} {\n            r sadd [format \"set%d{t}\" $i] $large\n        }\n\n        test \"Generated sets must be encoded as $type\" {\n            for {set i 1} {$i <= 5} {incr i} {\n                assert_encoding $type [format \"set%d{t}\" $i]\n            }\n        }\n\n        test \"SINTER with two sets - $type\" {\n            assert_equal [list 195 196 197 198 199 $large] [lsort [r sinter set1{t} set2{t}]]\n        }\n\n        test \"SINTERCARD with two sets - $type\" {\n            assert_equal 6 [r sintercard 2 set1{t} set2{t}]\n            assert_equal 6 [r sintercard 2 set1{t} set2{t} limit 0]\n            assert_equal 3 [r sintercard 2 set1{t} set2{t} limit 3]\n            assert_equal 6 [r sintercard 2 set1{t} set2{t} limit 10]\n        }\n\n        test \"SINTERSTORE with two sets - $type\" {\n            r sinterstore setres{t} set1{t} set2{t}\n            assert_encoding $type setres{t}\n            assert_equal [list 195 196 197 198 199 $large] [lsort [r smembers setres{t}]]\n        }\n\n        test \"SINTERSTORE with two sets, after a DEBUG RELOAD - $type\" {\n            r debug reload\n            r sinterstore setres{t} set1{t} set2{t}\n            assert_encoding $type setres{t}\n            assert_equal [list 195 196 197 198 199 $large] [lsort [r smembers setres{t}]]\n        } {} {needs:debug}\n\n        test \"SUNION with two sets - $type\" {\n            set expected [lsort -uniq \"[r smembers set1{t}] [r smembers set2{t}]\"]\n            assert_equal $expected [lsort [r sunion set1{t} set2{t}]]\n        }\n\n        test \"SUNIONSTORE with two sets - $type\" {\n            r sunionstore setres{t} set1{t} set2{t}\n            assert_encoding $type setres{t}\n            set expected [lsort -uniq \"[r smembers set1{t}] [r smembers set2{t}]\"]\n            assert_equal $expected [lsort [r smembers setres{t}]]\n        }\n\n        test \"SINTER against three sets - $type\" {\n            assert_equal [list 195 199 $large] [lsort [r sinter set1{t} set2{t} set3{t}]]\n        }\n\n        test \"SINTERCARD against three sets - $type\" {\n            assert_equal 3 [r sintercard 3 set1{t} set2{t} set3{t}]\n            assert_equal 3 [r sintercard 3 set1{t} set2{t} set3{t} limit 0]\n            assert_equal 2 [r sintercard 3 set1{t} set2{t} set3{t} limit 2]\n            assert_equal 3 [r sintercard 3 set1{t} set2{t} set3{t} limit 10]\n        }\n\n        test \"SINTERSTORE with three sets - $type\" {\n            r sinterstore setres{t} set1{t} set2{t} set3{t}\n            assert_equal [list 195 199 $large] [lsort [r smembers setres{t}]]\n        }\n\n        test \"SUNION with non existing keys - $type\" {\n            set expected [lsort -uniq \"[r smembers set1{t}] [r smembers set2{t}]\"]\n            assert_equal $expected [lsort [r sunion nokey1{t} set1{t} set2{t} nokey2{t}]]\n        }\n\n        test \"SDIFF with two sets - $type\" {\n            assert_equal {0 1 2 3 4} [lsort [r sdiff set1{t} set4{t}]]\n        }\n\n        test \"SDIFF with three sets - $type\" {\n            assert_equal {1 2 3 4} [lsort [r sdiff set1{t} set4{t} set5{t}]]\n        }\n\n        test \"SDIFFSTORE with three sets - $type\" {\n            r sdiffstore setres{t} set1{t} set4{t} set5{t}\n            # When we start with intsets, we should always end with intsets.\n            if {$type eq {intset}} {\n                assert_encoding intset setres{t}\n            }\n            assert_equal {1 2 3 4} [lsort [r smembers setres{t}]]\n        }\n\n        test \"SINTER/SUNION/SDIFF with three same sets - $type\" {\n            set expected [lsort \"[r smembers set1{t}]\"]\n            assert_equal $expected [lsort [r sinter set1{t} set1{t} set1{t}]]\n            assert_equal $expected [lsort [r sunion set1{t} set1{t} set1{t}]]\n            assert_equal {} [lsort [r sdiff set1{t} set1{t} set1{t}]]\n        }\n    }\n\n    test \"SDIFF with first set empty\" {\n        r del set1{t} set2{t} set3{t}\n        r sadd set2{t} 1 2 3 4\n        r sadd set3{t} a b c d\n        r sdiff set1{t} set2{t} set3{t}\n    } {}\n\n    test \"SDIFF with same set two times\" {\n        r del set1\n        r sadd set1 a b c 1 2 3 4 5 6\n        r sdiff set1 set1\n    } {}\n\n    test \"SDIFF fuzzing\" {\n        for {set j 0} {$j < 100} {incr j} {\n            unset -nocomplain s\n            array set s {}\n            set args {}\n            set num_sets [expr {[randomInt 10]+1}]\n            for {set i 0} {$i < $num_sets} {incr i} {\n                set num_elements [randomInt 100]\n                r del set_$i{t}\n                lappend args set_$i{t}\n                while {$num_elements} {\n                    set ele [randomValue]\n                    r sadd set_$i{t} $ele\n                    if {$i == 0} {\n                        set s($ele) x\n                    } else {\n                        unset -nocomplain s($ele)\n                    }\n                    incr num_elements -1\n                }\n            }\n            set result [lsort [r sdiff {*}$args]]\n            assert_equal $result [lsort [array names s]]\n        }\n    }\n\n    test \"SDIFF against non-set should throw error\" {\n        # with an empty set\n        r set key1{t} x\n        assert_error \"WRONGTYPE*\" {r sdiff key1{t} noset{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sdiff noset{t} key1{t}}\n\n        # with a legal set\n        r del set1{t}\n        r sadd set1{t} a b c\n        assert_error \"WRONGTYPE*\" {r sdiff key1{t} set1{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sdiff set1{t} key1{t}}\n    }\n\n    test \"SDIFF should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        assert_equal {a} [lsort [r sdiff set1{t} set2{t} set3{t}]]\n        assert_equal {} [lsort [r sdiff set3{t} set2{t} set1{t}]]\n    }\n\n    test \"SDIFFSTORE against non-set should throw error\" {\n        r del set1{t} set2{t} set3{t} key1{t}\n        r set key1{t} x\n\n        # with en empty dstkey\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} key1{t} noset{t}}\n        assert_equal 0 [r exists set3{t}]\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} noset{t} key1{t}}\n        assert_equal 0 [r exists set3{t}]\n\n        # with a legal dstkey\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sadd set3{t} e\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} key1{t} set1{t} noset{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n\n        assert_error \"WRONGTYPE*\" {r SDIFFSTORE set3{t} set1{t} key1{t} set2{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SDIFFSTORE should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r set setres{t} xxx\n        assert_equal 0 [r sdiffstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n\n        # with a legal dstkey, should delete dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sdiffstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        r sadd set1{t} a b c\n        assert_equal 3 [r sdiffstore set3{t} set1{t} set2{t}]\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {a b c} [lsort [r smembers set3{t}]]\n\n        # with a legal dstkey and empty set2, should delete the dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sdiffstore set3{t} set2{t} set1{t}]\n        assert_equal 0 [r exists set3{t}]\n    }\n\n    test \"SINTER against non-set should throw error\" {\n        r set key1{t} x\n        assert_error \"WRONGTYPE*\" {r sinter key1{t} noset{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sinter noset{t} key1{t}}\n\n        r sadd set1{t} a b c\n        assert_error \"WRONGTYPE*\" {r sinter key1{t} set1{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sinter set1{t} key1{t}}\n    }\n\n    test \"SINTER should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sinter set1{t} set2{t} set3{t}\n    } {}\n\n    test \"SINTER with same integer elements but different encoding\" {\n        r del set1{t} set2{t}\n        r sadd set1{t} 1 2 3\n        r sadd set2{t} 1 2 3 a\n        r srem set2{t} a\n        assert_encoding intset set1{t}\n        assert_encoding hashtable set2{t}\n        lsort [r sinter set1{t} set2{t}]\n    } {1 2 3}\n\n    test \"SINTERSTORE against non-set should throw error\" {\n        r del set1{t} set2{t} set3{t} key1{t}\n        r set key1{t} x\n\n        # with en empty dstkey\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} key1{t} noset{t}}\n        assert_equal 0 [r exists set3{t}]\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} noset{t} key1{t}}\n        assert_equal 0 [r exists set3{t}]\n\n        # with a legal dstkey\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sadd set3{t} e\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} key1{t} set2{t} noset{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n\n        assert_error \"WRONGTYPE*\" {r sinterstore set3{t} noset{t} key1{t} set2{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SINTERSTORE against non existing keys should delete dstkey\" {\n        r del set1{t} set2{t} set3{t}\n\n        r set setres{t} xxx\n        assert_equal 0 [r sinterstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n\n        # with a legal dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sinterstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        r sadd set1{t} a b c\n        assert_equal 0 [r sinterstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        assert_equal 0 [r sinterstore set3{t} set2{t} set1{t}]\n        assert_equal 0 [r exists set3{t}]\n    }\n\n    test \"SUNION against non-set should throw error\" {\n        r set key1{t} x\n        assert_error \"WRONGTYPE*\" {r sunion key1{t} noset{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sunion noset{t} key1{t}}\n\n        r del set1{t}\n        r sadd set1{t} a b c\n        assert_error \"WRONGTYPE*\" {r sunion key1{t} set1{t}}\n        # different order\n        assert_error \"WRONGTYPE*\" {r sunion set1{t} key1{t}}\n    }\n\n    test \"SUNION should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        assert_equal {a b c d} [lsort [r sunion set1{t} set2{t} set3{t}]]\n    }\n\n    test \"SUNIONSTORE against non-set should throw error\" {\n        r del set1{t} set2{t} set3{t} key1{t}\n        r set key1{t} x\n\n        # with en empty dstkey\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} key1{t} noset{t}}\n        assert_equal 0 [r exists set3{t}]\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} noset{t} key1{t}}\n        assert_equal 0 [r exists set3{t}]\n\n        # with a legal dstkey\n        r sadd set1{t} a b c\n        r sadd set2{t} b c d\n        r sadd set3{t} e\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} key1{t} key2{t} noset{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n\n        assert_error \"WRONGTYPE*\" {r sunionstore set3{t} noset{t} key1{t} key2{t}}\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {e} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SUNIONSTORE should handle non existing key as empty\" {\n        r del set1{t} set2{t} set3{t}\n\n        r set setres{t} xxx\n        assert_equal 0 [r sunionstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n\n        # set1 set2 both empty, should delete the dstkey\n        r sadd set3{t} a b c\n        assert_equal 0 [r sunionstore set3{t} set1{t} set2{t}]\n        assert_equal 0 [r exists set3{t}]\n\n        r sadd set1{t} a b c\n        r sadd set3{t} e f\n        assert_equal 3 [r sunionstore set3{t} set1{t} set2{t}]\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {a b c} [lsort [r smembers set3{t}]]\n\n        r sadd set3{t} d\n        assert_equal 3 [r sunionstore set3{t} set2{t} set1{t}]\n        assert_equal 1 [r exists set3{t}]\n        assert_equal {a b c} [lsort [r smembers set3{t}]]\n    }\n\n    test \"SUNIONSTORE against non existing keys should delete dstkey\" {\n        r set setres{t} xxx\n        assert_equal 0 [r sunionstore setres{t} foo111{t} bar222{t}]\n        assert_equal 0 [r exists setres{t}]\n    }\n\n    foreach {type contents} {hashtable {a b c} intset {1 2 3}} {\n        test \"SPOP basics - $type\" {\n            create_set myset $contents\n            assert_encoding $type myset\n            assert_equal $contents [lsort [list [r spop myset] [r spop myset] [r spop myset]]]\n            assert_equal 0 [r scard myset]\n        }\n\n        test \"SPOP with <count>=1 - $type\" {\n            create_set myset $contents\n            assert_encoding $type myset\n            assert_equal $contents [lsort [list [r spop myset 1] [r spop myset 1] [r spop myset 1]]]\n            assert_equal 0 [r scard myset]\n        }\n\n        test \"SRANDMEMBER - $type\" {\n            create_set myset $contents\n            unset -nocomplain myset\n            array set myset {}\n            for {set i 0} {$i < 100} {incr i} {\n                set myset([r srandmember myset]) 1\n            }\n            assert_equal $contents [lsort [array names myset]]\n        }\n    }\n\n    foreach {type contents} {\n        hashtable {a b c d e f g h i j k l m n o p q r s t u v w x y z} \n        intset {1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 26 3 4 5 6 7 8 9}\n    } {\n        test \"SPOP with <count>\" {\n            create_set myset $contents\n            assert_encoding $type myset\n            assert_equal $contents [lsort [concat [r spop myset 11] [r spop myset 9] [r spop myset 0] [r spop myset 4] [r spop myset 1] [r spop myset 0] [r spop myset 1] [r spop myset 0]]]\n            assert_equal 0 [r scard myset]\n        }\n    }\n\n    # As seen in intsetRandomMembers\n    test \"SPOP using integers, testing Knuth's and Floyd's algorithm\" {\n        create_set myset {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        assert_encoding intset myset\n        assert_equal 20 [r scard myset]\n        r spop myset 1\n        assert_equal 19 [r scard myset]\n        r spop myset 2\n        assert_equal 17 [r scard myset]\n        r spop myset 3\n        assert_equal 14 [r scard myset]\n        r spop myset 10\n        assert_equal 4 [r scard myset]\n        r spop myset 10\n        assert_equal 0 [r scard myset]\n        r spop myset 1\n        assert_equal 0 [r scard myset]\n    } {}\n\n    test \"SPOP using integers with Knuth's algorithm\" {\n        r spop nonexisting_key 100\n    } {}\n\n    test \"SPOP new implementation: code path #1\" {\n        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        create_set myset $content\n        set res [r spop myset 30]\n        assert {[lsort $content] eq [lsort $res]}\n    }\n\n    test \"SPOP new implementation: code path #2\" {\n        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        create_set myset $content\n        set res [r spop myset 2]\n        assert {[llength $res] == 2}\n        assert {[r scard myset] == 18}\n        set union [concat [r smembers myset] $res]\n        assert {[lsort $union] eq [lsort $content]}\n    }\n\n    test \"SPOP new implementation: code path #3\" {\n        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n        create_set myset $content\n        set res [r spop myset 18]\n        assert {[llength $res] == 18}\n        assert {[r scard myset] == 2}\n        set union [concat [r smembers myset] $res]\n        assert {[lsort $union] eq [lsort $content]}\n    }\n\n    test \"SRANDMEMBER count of 0 is handled correctly\" {\n        r srandmember myset 0\n    } {}\n\n    test \"SRANDMEMBER with <count> against non existing key\" {\n        r srandmember nonexisting_key 100\n    } {}\n\n    test \"SRANDMEMBER count overflow\" {\n        r sadd myset a\n        assert_error {*value is out of range*} {r srandmember myset -9223372036854775808}\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"SRANDMEMBER count of 0 is handled correctly - emptyarray\" {\n        r srandmember myset 0\n    } {*0}\n\n    test \"SRANDMEMBER with <count> against non existing key - emptyarray\" {\n        r srandmember nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} {\n        hashtable {\n            1 5 10 50 125 50000 33959417 4775547 65434162\n            12098459 427716 483706 2726473884 72615637475\n            MARY PATRICIA LINDA BARBARA ELIZABETH JENNIFER MARIA\n            SUSAN MARGARET DOROTHY LISA NANCY KAREN BETTY HELEN\n            SANDRA DONNA CAROL RUTH SHARON MICHELLE LAURA SARAH\n            KIMBERLY DEBORAH JESSICA SHIRLEY CYNTHIA ANGELA MELISSA\n            BRENDA AMY ANNA REBECCA VIRGINIA KATHLEEN\n        }\n        intset {\n            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n            20 21 22 23 24 25 26 27 28 29\n            30 31 32 33 34 35 36 37 38 39\n            40 41 42 43 44 45 46 47 48 49\n        }\n    } {\n        test \"SRANDMEMBER with <count> - $type\" {\n            create_set myset $contents\n            unset -nocomplain myset\n            array set myset {}\n            foreach ele [r smembers myset] {\n                set myset($ele) 1\n            }\n            assert_equal [lsort $contents] [lsort [array names myset]]\n\n            # Make sure that a count of 0 is handled correctly.\n            assert_equal [r srandmember myset 0] {}\n\n            # We'll stress different parts of the code, see the implementation\n            # of SRANDMEMBER for more information, but basically there are\n            # four different code paths.\n            #\n            # PATH 1: Use negative count.\n            #\n            # 1) Check that it returns repeated elements.\n            set res [r srandmember myset -100]\n            assert_equal [llength $res] 100\n\n            # 2) Check that all the elements actually belong to the\n            # original set.\n            foreach ele $res {\n                assert {[info exists myset($ele)]}\n            }\n\n            # 3) Check that eventually all the elements are returned.\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                set res [r srandmember myset -10]\n                foreach ele $res {\n                    set auxset($ele) 1\n                }\n                if {[lsort [array names myset]] eq\n                    [lsort [array names auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {50 100} {\n                set res [r srandmember myset $size]\n                assert_equal [llength $res] 50\n                assert_equal [lsort $res] [lsort [array names myset]]\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n\n            foreach size {45 5} {\n                set res [r srandmember myset $size]\n                assert_equal [llength $res] $size\n\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                foreach ele $res {\n                    assert {[info exists myset($ele)]}\n                }\n\n                # 2) Check that eventually all the elements are returned.\n                unset -nocomplain auxset\n                set iterations 1000\n                while {$iterations != 0} {\n                    incr iterations -1\n                    set res [r srandmember myset $size]\n                    foreach ele $res {\n                        set auxset($ele) 1\n                    }\n                    if {[lsort [array names myset]] eq\n                        [lsort [array names auxset]]} {\n                        break;\n                    }\n                }\n                assert {$iterations != 0}\n            }\n        }\n    }\n\n    foreach {type contents} {\n        hashtable {\n            1 5 10 50 125\n            MARY PATRICIA LINDA BARBARA ELIZABETH\n        }\n        intset {\n            0 1 2 3 4 5 6 7 8 9\n        }\n    } {\n        test \"SRANDMEMBER histogram distribution - $type\" {\n            create_set myset $contents\n            unset -nocomplain myset\n            array set myset {}\n            foreach ele [r smembers myset] {\n                set myset($ele) 1\n            }\n\n            # Use negative count (PATH 1).\n            # df = 9, 40 means 0.00001 probability\n            set res [r srandmember myset -1000]\n            assert_lessthan [chi_square_value $res] 40\n\n            # Use positive count (both PATH 3 and PATH 4).\n            foreach size {8 2} {\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                while {$iterations != 0} {\n                    incr iterations -1\n                    set res [r srandmember myset $size]\n                    foreach ele $res {\n                        lappend allkey $ele\n                    }\n                }\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n    }\n\n    proc setup_move {} {\n        r del myset3{t} myset4{t}\n        create_set myset1{t} {1 a b}\n        create_set myset2{t} {2 3 4}\n        assert_encoding hashtable myset1{t}\n        assert_encoding intset myset2{t}\n    }\n\n    test \"SMOVE basics - from regular set to intset\" {\n        # move a non-integer element to an intset should convert encoding\n        setup_move\n        assert_equal 1 [r smove myset1{t} myset2{t} a]\n        assert_equal {1 b} [lsort [r smembers myset1{t}]]\n        assert_equal {2 3 4 a} [lsort [r smembers myset2{t}]]\n        assert_encoding hashtable myset2{t}\n\n        # move an integer element should not convert the encoding\n        setup_move\n        assert_equal 1 [r smove myset1{t} myset2{t} 1]\n        assert_equal {a b} [lsort [r smembers myset1{t}]]\n        assert_equal {1 2 3 4} [lsort [r smembers myset2{t}]]\n        assert_encoding intset myset2{t}\n    }\n\n    test \"SMOVE basics - from intset to regular set\" {\n        setup_move\n        assert_equal 1 [r smove myset2{t} myset1{t} 2]\n        assert_equal {1 2 a b} [lsort [r smembers myset1{t}]]\n        assert_equal {3 4} [lsort [r smembers myset2{t}]]\n    }\n\n    test \"SMOVE non existing key\" {\n        setup_move\n        assert_equal 0 [r smove myset1{t} myset2{t} foo]\n        assert_equal 0 [r smove myset1{t} myset1{t} foo]\n        assert_equal {1 a b} [lsort [r smembers myset1{t}]]\n        assert_equal {2 3 4} [lsort [r smembers myset2{t}]]\n    }\n\n    test \"SMOVE non existing src set\" {\n        setup_move\n        assert_equal 0 [r smove noset{t} myset2{t} foo]\n        assert_equal {2 3 4} [lsort [r smembers myset2{t}]]\n    }\n\n    test \"SMOVE from regular set to non existing destination set\" {\n        setup_move\n        assert_equal 1 [r smove myset1{t} myset3{t} a]\n        assert_equal {1 b} [lsort [r smembers myset1{t}]]\n        assert_equal {a} [lsort [r smembers myset3{t}]]\n        assert_encoding hashtable myset3{t}\n    }\n\n    test \"SMOVE from intset to non existing destination set\" {\n        setup_move\n        assert_equal 1 [r smove myset2{t} myset3{t} 2]\n        assert_equal {3 4} [lsort [r smembers myset2{t}]]\n        assert_equal {2} [lsort [r smembers myset3{t}]]\n        assert_encoding intset myset3{t}\n    }\n\n    test \"SMOVE wrong src key type\" {\n        r set x{t} 10\n        assert_error \"WRONGTYPE*\" {r smove x{t} myset2{t} foo}\n    }\n\n    test \"SMOVE wrong dst key type\" {\n        r set x{t} 10\n        assert_error \"WRONGTYPE*\" {r smove myset2{t} x{t} foo}\n    }\n\n    test \"SMOVE with identical source and destination\" {\n        r del set{t}\n        r sadd set{t} a b c\n        r smove set{t} set{t} b\n        lsort [r smembers set{t}]\n    } {a b c}\n\n    test \"SMOVE only notify dstset when the addition is successful\" {\n        r del srcset{t}\n        r del dstset{t}\n\n        r sadd srcset{t} a b\n        r sadd dstset{t} a\n\n        r watch dstset{t}\n\n        r multi\n        r sadd dstset{t} c\n\n        set r2 [redis_client]\n        $r2 smove srcset{t} dstset{t} a\n\n        # The dstset is actually unchanged, multi should success\n        r exec\n        set res [r scard dstset{t}]\n        assert_equal $res 2\n        $r2 close\n    }\n\n    tags {slow} {\n        test {intsets implementation stress testing} {\n            for {set j 0} {$j < 20} {incr j} {\n                unset -nocomplain s\n                array set s {}\n                r del s\n                set len [randomInt 1024]\n                for {set i 0} {$i < $len} {incr i} {\n                    randpath {\n                        set data [randomInt 65536]\n                    } {\n                        set data [randomInt 4294967296]\n                    } {\n                        set data [randomInt 18446744073709551616]\n                    }\n                    set s($data) {}\n                    r sadd s $data\n                }\n                assert_equal [lsort [r smembers s]] [lsort [array names s]]\n                set len [array size s]\n                for {set i 0} {$i < $len} {incr i} {\n                    set e [r spop s]\n                    if {![info exists s($e)]} {\n                        puts \"Can't find '$e' on local array\"\n                        puts \"Local array: [lsort [r smembers s]]\"\n                        puts \"Remote array: [lsort [array names s]]\"\n                        error \"exception\"\n                    }\n                    array unset s $e\n                }\n                assert_equal [r scard s] 0\n                assert_equal [array size s] 0\n            }\n        }\n    }\n}\n\nrun_solo {set-large-memory} {\nstart_server [list overrides [list save \"\"] ] {\n\n# test if the server supports such large configs (avoid 32 bit builds)\ncatch {\n    r config set proto-max-bulk-len 10000000000 ;#10gb\n    r config set client-query-buffer-limit 10000000000 ;#10gb\n}\nif {[lindex [r config get proto-max-bulk-len] 1] == 10000000000} {\n\n    set str_length 4400000000 ;#~4.4GB\n\n    test {SADD, SCARD, SISMEMBER - large data} {\n        r flushdb\n        r write \"*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"aaa\"]\n        r write \"*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"bbb\"]\n        r write \"*3\\r\\n\\$4\\r\\nSADD\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 0 [write_big_bulk $str_length \"aaa\"]\n        assert_encoding hashtable myset\n        set s0 [s used_memory]\n        assert {$s0 > [expr $str_length * 2]}\n        assert_equal 2 [r scard myset]\n\n        r write \"*3\\r\\n\\$9\\r\\nSISMEMBER\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"aaa\"]\n        r write \"*3\\r\\n\\$9\\r\\nSISMEMBER\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 0 [write_big_bulk $str_length \"ccc\"]\n        r write \"*3\\r\\n\\$4\\r\\nSREM\\r\\n\\$5\\r\\nmyset\\r\\n\"\n        assert_equal 1 [write_big_bulk $str_length \"bbb\"]\n        assert_equal [read_big_bulk {r spop myset} yes \"aaa\"] $str_length\n    } {} {large-memory}\n} ;# skip 32bit builds\n}\n} ;# run_solo\n", "start_server {tags {\"zset\"}} {\n    proc create_zset {key items} {\n        r del $key\n        foreach {score entry} $items {\n            r zadd $key $score $entry\n        }\n    }\n\n    # A helper function to verify either ZPOP* or ZMPOP* response.\n    proc verify_pop_response {pop res zpop_expected_response zmpop_expected_response} {\n        if {[string match \"*ZM*\" $pop]} {\n            assert_equal $res $zmpop_expected_response\n        } else {\n            assert_equal $res $zpop_expected_response\n        }\n    }\n\n    # A helper function to verify either ZPOP* or ZMPOP* response when given one input key.\n    proc verify_zpop_response {rd pop key count zpop_expected_response zmpop_expected_response} {\n        if {[string match \"ZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n\n            if {$count == 0} {\n                set res [$rd $pop 1 $key $where]\n            } else {\n                set res [$rd $pop 1 $key $where COUNT $count]\n            }\n        } else {\n            if {$count == 0} {\n                set res [$rd $pop $key]\n            } else {\n                set res [$rd $pop $key $count]\n            }\n        }\n        verify_pop_response $pop $res $zpop_expected_response $zmpop_expected_response\n    }\n\n    # A helper function to verify either BZPOP* or BZMPOP* response when given one input key.\n    proc verify_bzpop_response {rd pop key timeout count bzpop_expected_response bzmpop_expected_response} {\n        if {[string match \"BZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n\n            if {$count == 0} {\n                $rd $pop $timeout 1 $key $where\n            } else {\n                $rd $pop $timeout 1 $key $where COUNT $count\n            }\n        } else {\n            $rd $pop $key $timeout\n        }\n        verify_pop_response $pop [$rd read] $bzpop_expected_response $bzmpop_expected_response\n    }\n\n    # A helper function to verify either ZPOP* or ZMPOP* response when given two input keys.\n    proc verify_bzpop_two_key_response {rd pop key key2 timeout count bzpop_expected_response bzmpop_expected_response} {\n        if {[string match \"BZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n\n            if {$count == 0} {\n                $rd $pop $timeout 2 $key $key2 $where\n            } else {\n                $rd $pop $timeout 2 $key $key2 $where COUNT $count\n            }\n        } else {\n            $rd $pop $key $key2 $timeout\n        }\n        verify_pop_response $pop [$rd read] $bzpop_expected_response $bzmpop_expected_response\n    }\n\n    # A helper function to execute either BZPOP* or BZMPOP* with one input key.\n    proc bzpop_command {rd pop key timeout} {\n        if {[string match \"BZM*\" $pop]} {\n            lassign [split $pop \"_\"] pop where\n            $rd $pop $timeout 1 $key $where COUNT 1\n        } else {\n            $rd $pop $key $timeout\n        }\n    }\n\n    # A helper function to verify nil response in readraw base on RESP version.\n    proc verify_nil_response {resp nil_response} {\n        if {$resp == 2} {\n            assert_equal $nil_response {*-1}\n        } elseif {$resp == 3} {\n            assert_equal $nil_response {_}\n        }\n    }\n\n    # A helper function to verify zset score response in readraw base on RESP version.\n    proc verify_score_response {rd resp score} {\n        if {$resp == 2} {\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] $score\n        } elseif {$resp == 3} {\n            assert_equal [$rd read] \",$score\"\n        }\n    }\n\n    proc basics {encoding} {\n        set original_max_entries [lindex [r config get zset-max-ziplist-entries] 1]\n        set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n        if {$encoding == \"listpack\"} {\n            r config set zset-max-ziplist-entries 128\n            r config set zset-max-ziplist-value 64\n        } elseif {$encoding == \"skiplist\"} {\n            r config set zset-max-ziplist-entries 0\n            r config set zset-max-ziplist-value 0\n        } else {\n            puts \"Unknown sorted set encoding\"\n            exit\n        }\n\n        test \"Check encoding - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            assert_encoding $encoding ztmp\n        }\n\n        test \"ZSET basic ZADD and score update - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            r zadd ztmp 20 y\n            r zadd ztmp 30 z\n            assert_equal {x y z} [r zrange ztmp 0 -1]\n\n            r zadd ztmp 1 y\n            assert_equal {y x z} [r zrange ztmp 0 -1]\n        }\n\n        test \"ZSET element can't be set to NaN with ZADD - $encoding\" {\n            assert_error \"*not*float*\" {r zadd myzset nan abc}\n        }\n\n        test \"ZSET element can't be set to NaN with ZINCRBY - $encoding\" {\n            assert_error \"*not*float*\" {r zadd myzset nan abc}\n        }\n\n        test \"ZADD with options syntax error with incomplete pair - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp xx 10 x 20} err\n            set err\n        } {ERR*}\n\n        test \"ZADD XX option without key - $encoding\" {\n            r del ztmp\n            assert {[r zadd ztmp xx 10 x] == 0}\n            assert {[r type ztmp] eq {none}}\n        }\n\n        test \"ZADD XX existing key - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            assert {[r zadd ztmp xx 20 y] == 0}\n            assert {[r zcard ztmp] == 1}\n        }\n\n        test \"ZADD XX returns the number of elements actually added - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            set retval [r zadd ztmp 10 x 20 y 30 z]\n            assert {$retval == 2}\n        }\n\n        test \"ZADD XX updates existing elements score - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            r zadd ztmp xx 5 foo 11 x 21 y 40 zap\n            assert {[r zcard ztmp] == 3}\n            assert {[r zscore ztmp x] == 11}\n            assert {[r zscore ztmp y] == 21}\n        }\n\n        test \"ZADD GT updates existing elements when new scores are greater - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp gt ch 5 foo 11 x 21 y 29 z] == 3}\n            assert {[r zcard ztmp] == 4}\n            assert {[r zscore ztmp x] == 11}\n            assert {[r zscore ztmp y] == 21}\n            assert {[r zscore ztmp z] == 30}\n        }\n\n        test \"ZADD LT updates existing elements when new scores are lower - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp lt ch 5 foo 11 x 21 y 29 z] == 2}\n            assert {[r zcard ztmp] == 4}\n            assert {[r zscore ztmp x] == 10}\n            assert {[r zscore ztmp y] == 20}\n            assert {[r zscore ztmp z] == 29}\n        }\n\n        test \"ZADD GT XX updates existing elements when new scores are greater and skips new elements - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp gt xx ch 5 foo 11 x 21 y 29 z] == 2}\n            assert {[r zcard ztmp] == 3}\n            assert {[r zscore ztmp x] == 11}\n            assert {[r zscore ztmp y] == 21}\n            assert {[r zscore ztmp z] == 30}\n        }\n\n        test \"ZADD LT XX updates existing elements when new scores are lower and skips new elements - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp lt xx ch 5 foo 11 x 21 y 29 z] == 1}\n            assert {[r zcard ztmp] == 3}\n            assert {[r zscore ztmp x] == 10}\n            assert {[r zscore ztmp y] == 20}\n            assert {[r zscore ztmp z] == 29}\n        }\n\n        test \"ZADD XX and NX are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp xx nx 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD NX with non existing key - $encoding\" {\n            r del ztmp\n            r zadd ztmp nx 10 x 20 y 30 z\n            assert {[r zcard ztmp] == 3}\n        }\n\n        test \"ZADD NX only add new elements without updating old ones - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp nx 11 x 21 y 100 a 200 b] == 2}\n            assert {[r zscore ztmp x] == 10}\n            assert {[r zscore ztmp y] == 20}\n            assert {[r zscore ztmp a] == 100}\n            assert {[r zscore ztmp b] == 200}\n        }\n\n        test \"ZADD GT and NX are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp gt nx 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD LT and NX are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp lt nx 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD LT and GT are not compatible - $encoding\" {\n            r del ztmp\n            catch {r zadd ztmp lt gt 10 x} err\n            set err\n        } {ERR*}\n\n        test \"ZADD INCR LT/GT replies with nill if score not updated - $encoding\" {\n            r del ztmp\n            r zadd ztmp 28 x\n            assert {[r zadd ztmp lt incr 1 x] eq {}}\n            assert {[r zscore ztmp x] == 28}\n            assert {[r zadd ztmp gt incr -1 x] eq {}}\n            assert {[r zscore ztmp x] == 28}\n        }\n\n        test \"ZADD INCR LT/GT with inf - $encoding\" {\n            r del ztmp\n            r zadd ztmp +inf x -inf y\n\n            assert {[r zadd ztmp lt incr 1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n            assert {[r zadd ztmp gt incr -1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n            assert {[r zadd ztmp lt incr -1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n            assert {[r zadd ztmp gt incr 1 x] eq {}}\n            assert {[r zscore ztmp x] == inf}\n\n            assert {[r zadd ztmp lt incr 1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n            assert {[r zadd ztmp gt incr -1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n            assert {[r zadd ztmp lt incr -1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n            assert {[r zadd ztmp gt incr 1 y] eq {}}\n            assert {[r zscore ztmp y] == -inf}\n        }\n\n        test \"ZADD INCR works like ZINCRBY - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            r zadd ztmp INCR 15 x\n            assert {[r zscore ztmp x] == 25}\n        }\n\n        test \"ZADD INCR works with a single score-elemenet pair - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            catch {r zadd ztmp INCR 15 x 10 y} err\n            set err\n        } {ERR*}\n\n        test \"ZADD CH option changes return value to all changed elements - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x 20 y 30 z\n            assert {[r zadd ztmp 11 x 21 y 30 z] == 0}\n            assert {[r zadd ztmp ch 12 x 22 y 30 z] == 2}\n        }\n\n        test \"ZINCRBY calls leading to NaN result in error - $encoding\" {\n            r zincrby myzset +inf abc\n            assert_error \"*NaN*\" {r zincrby myzset -inf abc}\n        }\n\n        test {ZADD - Variadic version base case - $encoding} {\n            r del myzset\n            list [r zadd myzset 10 a 20 b 30 c] [r zrange myzset 0 -1 withscores]\n        } {3 {a 10 b 20 c 30}}\n\n        test {ZADD - Return value is the number of actually added items - $encoding} {\n            list [r zadd myzset 5 x 20 b 30 c] [r zrange myzset 0 -1 withscores]\n        } {1 {x 5 a 10 b 20 c 30}}\n\n        test {ZADD - Variadic version does not add nothing on single parsing err - $encoding} {\n            r del myzset\n            catch {r zadd myzset 10 a 20 b 30.badscore c} e\n            assert_match {*ERR*not*float*} $e\n            r exists myzset\n        } {0}\n\n        test {ZADD - Variadic version will raise error on missing arg - $encoding} {\n            r del myzset\n            catch {r zadd myzset 10 a 20 b 30 c 40} e\n            assert_match {*ERR*syntax*} $e\n        }\n\n        test {ZINCRBY does not work variadic even if shares ZADD implementation - $encoding} {\n            r del myzset\n            catch {r zincrby myzset 10 a 20 b 30 c} e\n            assert_match {*ERR*wrong*number*arg*} $e\n        }\n\n        test \"ZCARD basics - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 a 20 b 30 c\n            assert_equal 3 [r zcard ztmp]\n            assert_equal 0 [r zcard zdoesntexist]\n        }\n\n        test \"ZREM removes key after last element is removed - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 x\n            r zadd ztmp 20 y\n\n            assert_equal 1 [r exists ztmp]\n            assert_equal 0 [r zrem ztmp z]\n            assert_equal 1 [r zrem ztmp y]\n            assert_equal 1 [r zrem ztmp x]\n            assert_equal 0 [r exists ztmp]\n        }\n\n        test \"ZREM variadic version - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 a 20 b 30 c\n            assert_equal 2 [r zrem ztmp x y a b k]\n            assert_equal 0 [r zrem ztmp foo bar]\n            assert_equal 1 [r zrem ztmp c]\n            r exists ztmp\n        } {0}\n\n        test \"ZREM variadic version -- remove elements after key deletion - $encoding\" {\n            r del ztmp\n            r zadd ztmp 10 a 20 b 30 c\n            r zrem ztmp a b c d e f g\n        } {3}\n\n        test \"ZRANGE basics - $encoding\" {\n            r del ztmp\n            r zadd ztmp 1 a\n            r zadd ztmp 2 b\n            r zadd ztmp 3 c\n            r zadd ztmp 4 d\n\n            assert_equal {a b c d} [r zrange ztmp 0 -1]\n            assert_equal {a b c} [r zrange ztmp 0 -2]\n            assert_equal {b c d} [r zrange ztmp 1 -1]\n            assert_equal {b c} [r zrange ztmp 1 -2]\n            assert_equal {c d} [r zrange ztmp -2 -1]\n            assert_equal {c} [r zrange ztmp -2 -2]\n\n            # out of range start index\n            assert_equal {a b c} [r zrange ztmp -5 2]\n            assert_equal {a b} [r zrange ztmp -5 1]\n            assert_equal {} [r zrange ztmp 5 -1]\n            assert_equal {} [r zrange ztmp 5 -2]\n\n            # out of range end index\n            assert_equal {a b c d} [r zrange ztmp 0 5]\n            assert_equal {b c d} [r zrange ztmp 1 5]\n            assert_equal {} [r zrange ztmp 0 -5]\n            assert_equal {} [r zrange ztmp 1 -5]\n\n            # withscores\n            assert_equal {a 1 b 2 c 3 d 4} [r zrange ztmp 0 -1 withscores]\n        }\n\n        test \"ZREVRANGE basics - $encoding\" {\n            r del ztmp\n            r zadd ztmp 1 a\n            r zadd ztmp 2 b\n            r zadd ztmp 3 c\n            r zadd ztmp 4 d\n\n            assert_equal {d c b a} [r zrevrange ztmp 0 -1]\n            assert_equal {d c b} [r zrevrange ztmp 0 -2]\n            assert_equal {c b a} [r zrevrange ztmp 1 -1]\n            assert_equal {c b} [r zrevrange ztmp 1 -2]\n            assert_equal {b a} [r zrevrange ztmp -2 -1]\n            assert_equal {b} [r zrevrange ztmp -2 -2]\n\n            # out of range start index\n            assert_equal {d c b} [r zrevrange ztmp -5 2]\n            assert_equal {d c} [r zrevrange ztmp -5 1]\n            assert_equal {} [r zrevrange ztmp 5 -1]\n            assert_equal {} [r zrevrange ztmp 5 -2]\n\n            # out of range end index\n            assert_equal {d c b a} [r zrevrange ztmp 0 5]\n            assert_equal {c b a} [r zrevrange ztmp 1 5]\n            assert_equal {} [r zrevrange ztmp 0 -5]\n            assert_equal {} [r zrevrange ztmp 1 -5]\n\n            # withscores\n            assert_equal {d 4 c 3 b 2 a 1} [r zrevrange ztmp 0 -1 withscores]\n        }\n\n        test \"ZRANK/ZREVRANK basics - $encoding\" {\n            r del zranktmp\n            r zadd zranktmp 10 x\n            r zadd zranktmp 20 y\n            r zadd zranktmp 30 z\n            assert_equal 0 [r zrank zranktmp x]\n            assert_equal 1 [r zrank zranktmp y]\n            assert_equal 2 [r zrank zranktmp z]\n            assert_equal \"\" [r zrank zranktmp foo]\n            assert_equal 2 [r zrevrank zranktmp x]\n            assert_equal 1 [r zrevrank zranktmp y]\n            assert_equal 0 [r zrevrank zranktmp z]\n            assert_equal \"\" [r zrevrank zranktmp foo]\n        }\n\n        test \"ZRANK - after deletion - $encoding\" {\n            r zrem zranktmp y\n            assert_equal 0 [r zrank zranktmp x]\n            assert_equal 1 [r zrank zranktmp z]\n        }\n\n        test \"ZINCRBY - can create a new sorted set - $encoding\" {\n            r del zset\n            r zincrby zset 1 foo\n            assert_equal {foo} [r zrange zset 0 -1]\n            assert_equal 1 [r zscore zset foo]\n        }\n\n        test \"ZINCRBY - increment and decrement - $encoding\" {\n            r zincrby zset 2 foo\n            r zincrby zset 1 bar\n            assert_equal {bar foo} [r zrange zset 0 -1]\n\n            r zincrby zset 10 bar\n            r zincrby zset -5 foo\n            r zincrby zset -5 bar\n            assert_equal {foo bar} [r zrange zset 0 -1]\n\n            assert_equal -2 [r zscore zset foo]\n            assert_equal  6 [r zscore zset bar]\n        }\n\n        test \"ZINCRBY return value - $encoding\" {\n            r del ztmp\n            set retval [r zincrby ztmp 1.0 x]\n            assert {$retval == 1.0}\n        }\n\n        proc create_default_zset {} {\n            create_zset zset {-inf a 1 b 2 c 3 d 4 e 5 f +inf g}\n        }\n\n        test \"ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - $encoding\" {\n            create_default_zset\n\n            # inclusive range\n            assert_equal {a b c} [r zrangebyscore zset -inf 2]\n            assert_equal {b c d} [r zrangebyscore zset 0 3]\n            assert_equal {d e f} [r zrangebyscore zset 3 6]\n            assert_equal {e f g} [r zrangebyscore zset 4 +inf]\n            assert_equal {c b a} [r zrevrangebyscore zset 2 -inf]\n            assert_equal {d c b} [r zrevrangebyscore zset 3 0]\n            assert_equal {f e d} [r zrevrangebyscore zset 6 3]\n            assert_equal {g f e} [r zrevrangebyscore zset +inf 4]\n            assert_equal 3 [r zcount zset 0 3]\n\n            # exclusive range\n            assert_equal {b}   [r zrangebyscore zset (-inf (2]\n            assert_equal {b c} [r zrangebyscore zset (0 (3]\n            assert_equal {e f} [r zrangebyscore zset (3 (6]\n            assert_equal {f}   [r zrangebyscore zset (4 (+inf]\n            assert_equal {b}   [r zrevrangebyscore zset (2 (-inf]\n            assert_equal {c b} [r zrevrangebyscore zset (3 (0]\n            assert_equal {f e} [r zrevrangebyscore zset (6 (3]\n            assert_equal {f}   [r zrevrangebyscore zset (+inf (4]\n            assert_equal 2 [r zcount zset (0 (3]\n\n            # test empty ranges\n            r zrem zset a\n            r zrem zset g\n\n            # inclusive\n            assert_equal {} [r zrangebyscore zset 4 2]\n            assert_equal {} [r zrangebyscore zset 6 +inf]\n            assert_equal {} [r zrangebyscore zset -inf -6]\n            assert_equal {} [r zrevrangebyscore zset +inf 6]\n            assert_equal {} [r zrevrangebyscore zset -6 -inf]\n\n            # exclusive\n            assert_equal {} [r zrangebyscore zset (4 (2]\n            assert_equal {} [r zrangebyscore zset 2 (2]\n            assert_equal {} [r zrangebyscore zset (2 2]\n            assert_equal {} [r zrangebyscore zset (6 (+inf]\n            assert_equal {} [r zrangebyscore zset (-inf (-6]\n            assert_equal {} [r zrevrangebyscore zset (+inf (6]\n            assert_equal {} [r zrevrangebyscore zset (-6 (-inf]\n\n            # empty inner range\n            assert_equal {} [r zrangebyscore zset 2.4 2.6]\n            assert_equal {} [r zrangebyscore zset (2.4 2.6]\n            assert_equal {} [r zrangebyscore zset 2.4 (2.6]\n            assert_equal {} [r zrangebyscore zset (2.4 (2.6]\n        }\n\n        test \"ZRANGEBYSCORE with WITHSCORES - $encoding\" {\n            create_default_zset\n            assert_equal {b 1 c 2 d 3} [r zrangebyscore zset 0 3 withscores]\n            assert_equal {d 3 c 2 b 1} [r zrevrangebyscore zset 3 0 withscores]\n        }\n\n        test \"ZRANGEBYSCORE with LIMIT - $encoding\" {\n            create_default_zset\n            assert_equal {b c}   [r zrangebyscore zset 0 10 LIMIT 0 2]\n            assert_equal {d e f} [r zrangebyscore zset 0 10 LIMIT 2 3]\n            assert_equal {d e f} [r zrangebyscore zset 0 10 LIMIT 2 10]\n            assert_equal {}      [r zrangebyscore zset 0 10 LIMIT 20 10]\n            assert_equal {f e}   [r zrevrangebyscore zset 10 0 LIMIT 0 2]\n            assert_equal {d c b} [r zrevrangebyscore zset 10 0 LIMIT 2 3]\n            assert_equal {d c b} [r zrevrangebyscore zset 10 0 LIMIT 2 10]\n            assert_equal {}      [r zrevrangebyscore zset 10 0 LIMIT 20 10]\n        }\n\n        test \"ZRANGEBYSCORE with LIMIT and WITHSCORES - $encoding\" {\n            create_default_zset\n            assert_equal {e 4 f 5} [r zrangebyscore zset 2 5 LIMIT 2 3 WITHSCORES]\n            assert_equal {d 3 c 2} [r zrevrangebyscore zset 5 2 LIMIT 2 3 WITHSCORES]\n            assert_equal {} [r zrangebyscore zset 2 5 LIMIT 12 13 WITHSCORES]\n        }\n\n        test \"ZRANGEBYSCORE with non-value min or max - $encoding\" {\n            assert_error \"*not*float*\" {r zrangebyscore fooz str 1}\n            assert_error \"*not*float*\" {r zrangebyscore fooz 1 str}\n            assert_error \"*not*float*\" {r zrangebyscore fooz 1 NaN}\n        }\n\n        proc create_default_lex_zset {} {\n            create_zset zset {0 alpha 0 bar 0 cool 0 down\n                              0 elephant 0 foo 0 great 0 hill\n                              0 omega}\n        }\n\n        test \"ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - $encoding\" {\n            create_default_lex_zset\n\n            # inclusive range\n            assert_equal {alpha bar cool} [r zrangebylex zset - \\[cool]\n            assert_equal {bar cool down} [r zrangebylex zset \\[bar \\[down]\n            assert_equal {great hill omega} [r zrangebylex zset \\[g +]\n            assert_equal {cool bar alpha} [r zrevrangebylex zset \\[cool -]\n            assert_equal {down cool bar} [r zrevrangebylex zset \\[down \\[bar]\n            assert_equal {omega hill great foo elephant down} [r zrevrangebylex zset + \\[d]\n            assert_equal 3 [r zlexcount zset \\[ele \\[h]\n\n            # exclusive range\n            assert_equal {alpha bar} [r zrangebylex zset - (cool]\n            assert_equal {cool} [r zrangebylex zset (bar (down]\n            assert_equal {hill omega} [r zrangebylex zset (great +]\n            assert_equal {bar alpha} [r zrevrangebylex zset (cool -]\n            assert_equal {cool} [r zrevrangebylex zset (down (bar]\n            assert_equal {omega hill} [r zrevrangebylex zset + (great]\n            assert_equal 2 [r zlexcount zset (ele (great]\n\n            # inclusive and exclusive\n            assert_equal {} [r zrangebylex zset (az (b]\n            assert_equal {} [r zrangebylex zset (z +]\n            assert_equal {} [r zrangebylex zset - \\[aaaa]\n            assert_equal {} [r zrevrangebylex zset \\[elez \\[elex]\n            assert_equal {} [r zrevrangebylex zset (hill (omega]\n        }\n\n        test \"ZLEXCOUNT advanced - $encoding\" {\n            create_default_lex_zset\n\n            assert_equal 9 [r zlexcount zset - +]\n            assert_equal 0 [r zlexcount zset + -]\n            assert_equal 0 [r zlexcount zset + \\[c]\n            assert_equal 0 [r zlexcount zset \\[c -]\n            assert_equal 8 [r zlexcount zset \\[bar +]\n            assert_equal 5 [r zlexcount zset \\[bar \\[foo]\n            assert_equal 4 [r zlexcount zset \\[bar (foo]\n            assert_equal 4 [r zlexcount zset (bar \\[foo]\n            assert_equal 3 [r zlexcount zset (bar (foo]\n            assert_equal 5 [r zlexcount zset - (foo]\n            assert_equal 1 [r zlexcount zset (maxstring +]\n        }\n\n        test \"ZRANGEBYSLEX with LIMIT - $encoding\" {\n            create_default_lex_zset\n            assert_equal {alpha bar} [r zrangebylex zset - \\[cool LIMIT 0 2]\n            assert_equal {bar cool} [r zrangebylex zset - \\[cool LIMIT 1 2]\n            assert_equal {} [r zrangebylex zset \\[bar \\[down LIMIT 0 0]\n            assert_equal {} [r zrangebylex zset \\[bar \\[down LIMIT 2 0]\n            assert_equal {bar} [r zrangebylex zset \\[bar \\[down LIMIT 0 1]\n            assert_equal {cool} [r zrangebylex zset \\[bar \\[down LIMIT 1 1]\n            assert_equal {bar cool down} [r zrangebylex zset \\[bar \\[down LIMIT 0 100]\n            assert_equal {omega hill great foo elephant} [r zrevrangebylex zset + \\[d LIMIT 0 5]\n            assert_equal {omega hill great foo} [r zrevrangebylex zset + \\[d LIMIT 0 4]\n        }\n\n        test \"ZRANGEBYLEX with invalid lex range specifiers - $encoding\" {\n            assert_error \"*not*string*\" {r zrangebylex fooz foo bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz \\[foo bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz foo \\[bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz +x \\[bar}\n            assert_error \"*not*string*\" {r zrangebylex fooz -x \\[bar}\n        }\n\n        test \"ZREMRANGEBYSCORE basics - $encoding\" {\n            proc remrangebyscore {min max} {\n                create_zset zset {1 a 2 b 3 c 4 d 5 e}\n                assert_equal 1 [r exists zset]\n                r zremrangebyscore zset $min $max\n            }\n\n            # inner range\n            assert_equal 3 [remrangebyscore 2 4]\n            assert_equal {a e} [r zrange zset 0 -1]\n\n            # start underflow\n            assert_equal 1 [remrangebyscore -10 1]\n            assert_equal {b c d e} [r zrange zset 0 -1]\n\n            # end overflow\n            assert_equal 1 [remrangebyscore 5 10]\n            assert_equal {a b c d} [r zrange zset 0 -1]\n\n            # switch min and max\n            assert_equal 0 [remrangebyscore 4 2]\n            assert_equal {a b c d e} [r zrange zset 0 -1]\n\n            # -inf to mid\n            assert_equal 3 [remrangebyscore -inf 3]\n            assert_equal {d e} [r zrange zset 0 -1]\n\n            # mid to +inf\n            assert_equal 3 [remrangebyscore 3 +inf]\n            assert_equal {a b} [r zrange zset 0 -1]\n\n            # -inf to +inf\n            assert_equal 5 [remrangebyscore -inf +inf]\n            assert_equal {} [r zrange zset 0 -1]\n\n            # exclusive min\n            assert_equal 4 [remrangebyscore (1 5]\n            assert_equal {a} [r zrange zset 0 -1]\n            assert_equal 3 [remrangebyscore (2 5]\n            assert_equal {a b} [r zrange zset 0 -1]\n\n            # exclusive max\n            assert_equal 4 [remrangebyscore 1 (5]\n            assert_equal {e} [r zrange zset 0 -1]\n            assert_equal 3 [remrangebyscore 1 (4]\n            assert_equal {d e} [r zrange zset 0 -1]\n\n            # exclusive min and max\n            assert_equal 3 [remrangebyscore (1 (5]\n            assert_equal {a e} [r zrange zset 0 -1]\n\n            # destroy when empty\n            assert_equal 5 [remrangebyscore 1 5]\n            assert_equal 0 [r exists zset]\n        }\n\n        test \"ZREMRANGEBYSCORE with non-value min or max - $encoding\" {\n            assert_error \"*not*float*\" {r zremrangebyscore fooz str 1}\n            assert_error \"*not*float*\" {r zremrangebyscore fooz 1 str}\n            assert_error \"*not*float*\" {r zremrangebyscore fooz 1 NaN}\n        }\n\n        test \"ZREMRANGEBYRANK basics - $encoding\" {\n            proc remrangebyrank {min max} {\n                create_zset zset {1 a 2 b 3 c 4 d 5 e}\n                assert_equal 1 [r exists zset]\n                r zremrangebyrank zset $min $max\n            }\n\n            # inner range\n            assert_equal 3 [remrangebyrank 1 3]\n            assert_equal {a e} [r zrange zset 0 -1]\n\n            # start underflow\n            assert_equal 1 [remrangebyrank -10 0]\n            assert_equal {b c d e} [r zrange zset 0 -1]\n\n            # start overflow\n            assert_equal 0 [remrangebyrank 10 -1]\n            assert_equal {a b c d e} [r zrange zset 0 -1]\n\n            # end underflow\n            assert_equal 0 [remrangebyrank 0 -10]\n            assert_equal {a b c d e} [r zrange zset 0 -1]\n\n            # end overflow\n            assert_equal 5 [remrangebyrank 0 10]\n            assert_equal {} [r zrange zset 0 -1]\n\n            # destroy when empty\n            assert_equal 5 [remrangebyrank 0 4]\n            assert_equal 0 [r exists zset]\n        }\n\n        test \"ZUNIONSTORE against non-existing key doesn't set destination - $encoding\" {\n            r del zseta{t}\n            assert_equal 0 [r zunionstore dst_key{t} 1 zseta{t}]\n            assert_equal 0 [r exists dst_key{t}]\n        }\n\n        test \"ZUNION/ZINTER/ZINTERCARD/ZDIFF against non-existing key - $encoding\" {\n            r del zseta\n            assert_equal {} [r zunion 1 zseta]\n            assert_equal {} [r zinter 1 zseta]\n            assert_equal 0 [r zintercard 1 zseta]\n            assert_equal 0 [r zintercard 1 zseta limit 0]\n            assert_equal {} [r zdiff 1 zseta]\n        }\n\n        test \"ZUNIONSTORE with empty set - $encoding\" {\n            r del zseta{t} zsetb{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zunionstore zsetc{t} 2 zseta{t} zsetb{t}\n            r zrange zsetc{t} 0 -1 withscores\n        } {a 1 b 2}\n\n        test \"ZUNION/ZINTER/ZINTERCARD/ZDIFF with empty set - $encoding\" {\n            r del zseta{t} zsetb{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            assert_equal {a 1 b 2} [r zunion 2 zseta{t} zsetb{t} withscores]\n            assert_equal {} [r zinter 2 zseta{t} zsetb{t} withscores]\n            assert_equal 0 [r zintercard 2 zseta{t} zsetb{t}]\n            assert_equal 0 [r zintercard 2 zseta{t} zsetb{t} limit 0]\n            assert_equal {a 1 b 2} [r zdiff 2 zseta{t} zsetb{t} withscores]\n        }\n\n        test \"ZUNIONSTORE basics - $encoding\" {\n            r del zseta{t} zsetb{t} zsetc{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zadd zseta{t} 3 c\n            r zadd zsetb{t} 1 b\n            r zadd zsetb{t} 2 c\n            r zadd zsetb{t} 3 d\n\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {a 1 b 3 d 3 c 5} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION/ZINTER/ZINTERCARD/ZDIFF with integer members - $encoding\" {\n            r del zsetd{t} zsetf{t}\n            r zadd zsetd{t} 1 1\n            r zadd zsetd{t} 2 2\n            r zadd zsetd{t} 3 3\n            r zadd zsetf{t} 1 1\n            r zadd zsetf{t} 3 3\n            r zadd zsetf{t} 4 4\n\n            assert_equal {1 2 2 2 4 4 3 6} [r zunion 2 zsetd{t} zsetf{t} withscores]\n            assert_equal {1 2 3 6} [r zinter 2 zsetd{t} zsetf{t} withscores]\n            assert_equal 2 [r zintercard 2 zsetd{t} zsetf{t}]\n            assert_equal 2 [r zintercard 2 zsetd{t} zsetf{t} limit 0]\n            assert_equal {2 2} [r zdiff 2 zsetd{t} zsetf{t} withscores]\n        }\n\n        test \"ZUNIONSTORE with weights - $encoding\" {\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t} weights 2 3]\n            assert_equal {a 2 b 7 d 9 c 12} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION with weights - $encoding\" {\n            assert_equal {a 2 b 7 d 9 c 12} [r zunion 2 zseta{t} zsetb{t} weights 2 3 withscores]\n            assert_equal {b 7 c 12} [r zinter 2 zseta{t} zsetb{t} weights 2 3 withscores]\n        }\n\n        test \"ZUNIONSTORE with a regular set and weights - $encoding\" {\n            r del seta{t}\n            r sadd seta{t} a\n            r sadd seta{t} b\n            r sadd seta{t} c\n\n            assert_equal 4 [r zunionstore zsetc{t} 2 seta{t} zsetb{t} weights 2 3]\n            assert_equal {a 2 b 5 c 8 d 9} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNIONSTORE with AGGREGATE MIN - $encoding\" {\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t} aggregate min]\n            assert_equal {a 1 b 1 c 2 d 3} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION/ZINTER with AGGREGATE MIN - $encoding\" {\n            assert_equal {a 1 b 1 c 2 d 3} [r zunion 2 zseta{t} zsetb{t} aggregate min withscores]\n            assert_equal {b 1 c 2} [r zinter 2 zseta{t} zsetb{t} aggregate min withscores]\n        }\n\n        test \"ZUNIONSTORE with AGGREGATE MAX - $encoding\" {\n            assert_equal 4 [r zunionstore zsetc{t} 2 zseta{t} zsetb{t} aggregate max]\n            assert_equal {a 1 b 2 c 3 d 3} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZUNION/ZINTER with AGGREGATE MAX - $encoding\" {\n            assert_equal {a 1 b 2 c 3 d 3} [r zunion 2 zseta{t} zsetb{t} aggregate max withscores]\n            assert_equal {b 2 c 3} [r zinter 2 zseta{t} zsetb{t} aggregate max withscores]\n        }\n\n        test \"ZINTERSTORE basics - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {b 3 c 5} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTER basics - $encoding\" {\n            assert_equal {b 3 c 5} [r zinter 2 zseta{t} zsetb{t} withscores]\n        }\n\n        test \"ZINTERCARD with illegal arguments\" {\n            assert_error \"ERR syntax error*\" {r zintercard 1 zseta{t} zseta{t}}\n            assert_error \"ERR syntax error*\" {r zintercard 1 zseta{t} bar_arg}\n            assert_error \"ERR syntax error*\" {r zintercard 1 zseta{t} LIMIT}\n\n            assert_error \"ERR LIMIT*\" {r zintercard 1 myset{t} LIMIT -1}\n            assert_error \"ERR LIMIT*\" {r zintercard 1 myset{t} LIMIT a}\n        }\n\n        test \"ZINTERCARD basics - $encoding\" {\n            assert_equal 2 [r zintercard 2 zseta{t} zsetb{t}]\n            assert_equal 2 [r zintercard 2 zseta{t} zsetb{t} limit 0]\n            assert_equal 1 [r zintercard 2 zseta{t} zsetb{t} limit 1]\n            assert_equal 2 [r zintercard 2 zseta{t} zsetb{t} limit 10]\n        }\n\n        test \"ZINTER RESP3 - $encoding\" {\n            r hello 3\n            assert_equal {{b 3.0} {c 5.0}} [r zinter 2 zseta{t} zsetb{t} withscores]\n            r hello 2\n        }\n\n        test \"ZINTERSTORE with weights - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t} weights 2 3]\n            assert_equal {b 7 c 12} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTER with weights - $encoding\" {\n            assert_equal {b 7 c 12} [r zinter 2 zseta{t} zsetb{t} weights 2 3 withscores]\n        }\n\n        test \"ZINTERSTORE with a regular set and weights - $encoding\" {\n            r del seta{t}\n            r sadd seta{t} a\n            r sadd seta{t} b\n            r sadd seta{t} c\n            assert_equal 2 [r zinterstore zsetc{t} 2 seta{t} zsetb{t} weights 2 3]\n            assert_equal {b 5 c 8} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTERSTORE with AGGREGATE MIN - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t} aggregate min]\n            assert_equal {b 1 c 2} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZINTERSTORE with AGGREGATE MAX - $encoding\" {\n            assert_equal 2 [r zinterstore zsetc{t} 2 zseta{t} zsetb{t} aggregate max]\n            assert_equal {b 2 c 3} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        foreach cmd {ZUNIONSTORE ZINTERSTORE} {\n            test \"$cmd with +inf/-inf scores - $encoding\" {\n                r del zsetinf1{t} zsetinf2{t}\n\n                r zadd zsetinf1{t} +inf key\n                r zadd zsetinf2{t} +inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal inf [r zscore zsetinf3{t} key]\n\n                r zadd zsetinf1{t} -inf key\n                r zadd zsetinf2{t} +inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal 0 [r zscore zsetinf3{t} key]\n\n                r zadd zsetinf1{t} +inf key\n                r zadd zsetinf2{t} -inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal 0 [r zscore zsetinf3{t} key]\n\n                r zadd zsetinf1{t} -inf key\n                r zadd zsetinf2{t} -inf key\n                r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t}\n                assert_equal -inf [r zscore zsetinf3{t} key]\n            }\n\n            test \"$cmd with NaN weights - $encoding\" {\n                r del zsetinf1{t} zsetinf2{t}\n\n                r zadd zsetinf1{t} 1.0 key\n                r zadd zsetinf2{t} 1.0 key\n                assert_error \"*weight*not*float*\" {\n                    r $cmd zsetinf3{t} 2 zsetinf1{t} zsetinf2{t} weights nan nan\n                }\n            }\n        }\n\n        test \"ZDIFFSTORE basics - $encoding\" {\n            assert_equal 1 [r zdiffstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {a 1} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF basics - $encoding\" {\n            assert_equal {a 1} [r zdiff 2 zseta{t} zsetb{t} withscores]\n        }\n\n        test \"ZDIFFSTORE with a regular set - $encoding\" {\n            r del seta{t}\n            r sadd seta{t} a\n            r sadd seta{t} b\n            r sadd seta{t} c\n            assert_equal 1 [r zdiffstore zsetc{t} 2 seta{t} zsetb{t}]\n            assert_equal {a 1} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF subtracting set from itself - $encoding\" {\n            assert_equal 0 [r zdiffstore zsetc{t} 2 zseta{t} zseta{t}]\n            assert_equal {} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF algorithm 1 - $encoding\" {\n            r del zseta{t} zsetb{t} zsetc{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zadd zseta{t} 3 c\n            r zadd zsetb{t} 1 b\n            r zadd zsetb{t} 2 c\n            r zadd zsetb{t} 3 d\n            assert_equal 1 [r zdiffstore zsetc{t} 2 zseta{t} zsetb{t}]\n            assert_equal {a 1} [r zrange zsetc{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF algorithm 2 - $encoding\" {\n            r del zseta{t} zsetb{t} zsetc{t} zsetd{t} zsete{t}\n            r zadd zseta{t} 1 a\n            r zadd zseta{t} 2 b\n            r zadd zseta{t} 3 c\n            r zadd zseta{t} 5 e\n            r zadd zsetb{t} 1 b\n            r zadd zsetc{t} 1 c\n            r zadd zsetd{t} 1 d\n            assert_equal 2 [r zdiffstore zsete{t} 4 zseta{t} zsetb{t} zsetc{t} zsetd{t}]\n            assert_equal {a 1 e 5} [r zrange zsete{t} 0 -1 withscores]\n        }\n\n        test \"ZDIFF fuzzing - $encoding\" {\n            for {set j 0} {$j < 100} {incr j} {\n                unset -nocomplain s\n                array set s {}\n                set args {}\n                set num_sets [expr {[randomInt 10]+1}]\n                for {set i 0} {$i < $num_sets} {incr i} {\n                    set num_elements [randomInt 100]\n                    r del zset_$i{t}\n                    lappend args zset_$i{t}\n                    while {$num_elements} {\n                        set ele [randomValue]\n                        r zadd zset_$i{t} [randomInt 100] $ele\n                        if {$i == 0} {\n                            set s($ele) x\n                        } else {\n                            unset -nocomplain s($ele)\n                        }\n                        incr num_elements -1\n                    }\n                }\n                set result [lsort [r zdiff [llength $args] {*}$args]]\n                assert_equal $result [lsort [array names s]]\n            }\n        }\n\n        foreach {pop} {ZPOPMIN ZPOPMAX} {\n            test \"$pop with the count 0 returns an empty array\" {\n                r del zset\n                r zadd zset 1 a 2 b 3 c\n                assert_equal {} [r $pop zset 0]\n\n                # Make sure we can distinguish between an empty array and a null response\n                r readraw 1\n                assert_equal {*0} [r $pop zset 0]\n                r readraw 0\n\n                assert_equal 3 [r zcard zset]\n            }\n\n            test \"$pop with negative count\" {\n                r set zset foo\n                assert_error \"ERR *must be positive\" {r $pop zset -1}\n\n                r del zset\n                assert_error \"ERR *must be positive\" {r $pop zset -2}\n\n                r zadd zset 1 a 2 b 3 c\n                assert_error \"ERR *must be positive\" {r $pop zset -3}\n            }\n        }\n\n    foreach {popmin popmax} {ZPOPMIN ZPOPMAX ZMPOP_MIN ZMPOP_MAX} {\n        test \"Basic $popmin/$popmax with a single key - $encoding\" {\n            r del zset\n            verify_zpop_response r $popmin zset 0 {} {}\n\n            create_zset zset {-1 a 1 b 2 c 3 d 4 e}\n            verify_zpop_response r $popmin zset 0 {a -1} {zset {{a -1}}}\n            verify_zpop_response r $popmin zset 0 {b 1} {zset {{b 1}}}\n            verify_zpop_response r $popmax zset 0 {e 4} {zset {{e 4}}}\n            verify_zpop_response r $popmax zset 0 {d 3} {zset {{d 3}}}\n            verify_zpop_response r $popmin zset 0 {c 2} {zset {{c 2}}}\n            assert_equal 0 [r exists zset]\n        }\n\n        test \"$popmin/$popmax with count - $encoding\" {\n            r del z1\n            verify_zpop_response r $popmin z1 2 {} {}\n\n            create_zset z1 {0 a 1 b 2 c 3 d}\n            verify_zpop_response r $popmin z1 2 {a 0 b 1} {z1 {{a 0} {b 1}}}\n            verify_zpop_response r $popmax z1 2 {d 3 c 2} {z1 {{d 3} {c 2}}}\n        }\n    }\n\n    foreach {popmin popmax} {BZPOPMIN BZPOPMAX BZMPOP_MIN BZMPOP_MAX} {\n        test \"$popmin/$popmax with a single existing sorted set - $encoding\" {\n            set rd [redis_deferring_client]\n            create_zset zset {0 a 1 b 2 c 3 d}\n\n            verify_bzpop_response $rd $popmin zset 5 0 {zset a 0} {zset {{a 0}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset d 3} {zset {{d 3}}}\n            verify_bzpop_response $rd $popmin zset 5 0 {zset b 1} {zset {{b 1}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset c 2} {zset {{c 2}}}\n            assert_equal 0 [r exists zset]\n            $rd close\n        }\n\n        test \"$popmin/$popmax with multiple existing sorted sets - $encoding\" {\n            set rd [redis_deferring_client]\n            create_zset z1{t} {0 a 1 b 2 c}\n            create_zset z2{t} {3 d 4 e 5 f}\n\n            verify_bzpop_two_key_response $rd $popmin z1{t} z2{t} 5 0 {z1{t} a 0} {z1{t} {{a 0}}}\n            verify_bzpop_two_key_response $rd $popmax z1{t} z2{t} 5 0 {z1{t} c 2} {z1{t} {{c 2}}}\n            assert_equal 1 [r zcard z1{t}]\n            assert_equal 3 [r zcard z2{t}]\n\n            verify_bzpop_two_key_response $rd $popmax z2{t} z1{t} 5 0 {z2{t} f 5} {z2{t} {{f 5}}}\n            verify_bzpop_two_key_response $rd $popmin z2{t} z1{t} 5 0 {z2{t} d 3} {z2{t} {{d 3}}}\n            assert_equal 1 [r zcard z1{t}]\n            assert_equal 1 [r zcard z2{t}]\n            $rd close\n        }\n\n        test \"$popmin/$popmax second sorted set has members - $encoding\" {\n            set rd [redis_deferring_client]\n            r del z1{t}\n            create_zset z2{t} {3 d 4 e 5 f}\n\n            verify_bzpop_two_key_response $rd $popmax z1{t} z2{t} 5 0 {z2{t} f 5} {z2{t} {{f 5}}}\n            verify_bzpop_two_key_response $rd $popmin z1{t} z2{t} 5 0 {z2{t} d 3} {z2{t} {{d 3}}}\n            assert_equal 0 [r zcard z1{t}]\n            assert_equal 1 [r zcard z2{t}]\n            $rd close\n        }\n    }\n\n    foreach {popmin popmax} {ZPOPMIN ZPOPMAX ZMPOP_MIN ZMPOP_MAX} {\n        test \"Basic $popmin/$popmax - $encoding RESP3\" {\n            r hello 3\n            create_zset z1 {0 a 1 b 2 c 3 d}\n            verify_zpop_response r $popmin z1 0 {a 0.0} {z1 {{a 0.0}}}\n            verify_zpop_response r $popmax z1 0 {d 3.0} {z1 {{d 3.0}}}\n            r hello 2\n        }\n\n        test \"$popmin/$popmax with count - $encoding RESP3\" {\n            r hello 3\n            create_zset z1 {0 a 1 b 2 c 3 d}\n            verify_zpop_response r $popmin z1 2 {{a 0.0} {b 1.0}} {z1 {{a 0.0} {b 1.0}}}\n            verify_zpop_response r $popmax z1 2 {{d 3.0} {c 2.0}} {z1 {{d 3.0} {c 2.0}}}\n            r hello 2\n        }\n    }\n\n    foreach {popmin popmax} {BZPOPMIN BZPOPMAX BZMPOP_MIN BZMPOP_MAX} {\n        test \"$popmin/$popmax - $encoding RESP3\" {\n            r hello 3\n            set rd [redis_deferring_client]\n            create_zset zset {0 a 1 b 2 c 3 d}\n\n            verify_bzpop_response $rd $popmin zset 5 0 {zset a 0} {zset {{a 0}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset d 3} {zset {{d 3}}}\n            verify_bzpop_response $rd $popmin zset 5 0 {zset b 1} {zset {{b 1}}}\n            verify_bzpop_response $rd $popmax zset 5 0 {zset c 2} {zset {{c 2}}}\n\n            assert_equal 0 [r exists zset]\n            r hello 2\n            $rd close\n        }\n    }\n\n        r config set zset-max-ziplist-entries $original_max_entries\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    basics listpack\n    basics skiplist\n\n    test \"ZPOP/ZMPOP against wrong type\" {\n        r set foo{t} bar\n        assert_error \"*WRONGTYPE*\" {r zpopmin foo{t}}\n        assert_error \"*WRONGTYPE*\" {r zpopmin foo{t} 0}\n        assert_error \"*WRONGTYPE*\" {r zpopmax foo{t}}\n        assert_error \"*WRONGTYPE*\" {r zpopmax foo{t} 0}\n        assert_error \"*WRONGTYPE*\" {r zpopmin foo{t} 2}\n\n        assert_error \"*WRONGTYPE*\" {r zmpop 1 foo{t} min}\n        assert_error \"*WRONGTYPE*\" {r zmpop 1 foo{t} max}\n        assert_error \"*WRONGTYPE*\" {r zmpop 1 foo{t} max count 200}\n\n        r del foo{t}\n        r set foo2{t} bar\n        assert_error \"*WRONGTYPE*\" {r zmpop 2 foo{t} foo2{t} min}\n        assert_error \"*WRONGTYPE*\" {r zmpop 2 foo2{t} foo1{t} max count 1}\n    }\n\n    test \"ZMPOP with illegal argument\" {\n        assert_error \"ERR wrong number of arguments for 'zmpop' command\" {r zmpop}\n        assert_error \"ERR wrong number of arguments for 'zmpop' command\" {r zmpop 1}\n        assert_error \"ERR wrong number of arguments for 'zmpop' command\" {r zmpop 1 myzset{t}}\n\n        assert_error \"ERR numkeys*\" {r zmpop 0 myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r zmpop a myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r zmpop -1 myzset{t} MAX}\n\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} bad_where}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} MIN bar_arg}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} MAX MIN}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} COUNT}\n        assert_error \"ERR syntax error*\" {r zmpop 1 myzset{t} MAX COUNT 1 COUNT 2}\n        assert_error \"ERR syntax error*\" {r zmpop 2 myzset{t} myzset2{t} bad_arg}\n\n        assert_error \"ERR count*\" {r zmpop 1 myzset{t} MIN COUNT 0}\n        assert_error \"ERR count*\" {r zmpop 1 myzset{t} MAX COUNT a}\n        assert_error \"ERR count*\" {r zmpop 1 myzset{t} MIN COUNT -1}\n        assert_error \"ERR count*\" {r zmpop 2 myzset{t} myzset2{t} MAX COUNT -1}\n    }\n\n    test \"ZMPOP propagate as pop with count command to replica\" {\n        set repl [attach_to_replication_stream]\n\n        # ZMPOP min/max propagate as ZPOPMIN/ZPOPMAX with count\n        r zadd myzset{t} 1 one 2 two 3 three\n\n        # Pop elements from one zset.\n        r zmpop 1 myzset{t} min\n        r zmpop 1 myzset{t} max count 1\n\n        # Now the zset have only one element\n        r zmpop 2 myzset{t} myzset2{t} min count 10\n\n        # No elements so we don't propagate.\n        r zmpop 2 myzset{t} myzset2{t} max count 10\n\n        # Pop elements from the second zset.\n        r zadd myzset2{t} 1 one 2 two 3 three\n        r zmpop 2 myzset{t} myzset2{t} min count 2\n        r zmpop 2 myzset{t} myzset2{t} max count 1\n\n        # Pop all elements.\n        r zadd myzset{t} 1 one 2 two 3 three\n        r zadd myzset2{t} 4 four 5 five 6 six\n        r zmpop 2 myzset{t} myzset2{t} min count 10\n        r zmpop 2 myzset{t} myzset2{t} max count 10\n\n        assert_replication_stream $repl {\n            {select *}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zpopmin myzset{t} 1}\n            {zpopmax myzset{t} 1}\n            {zpopmin myzset{t} 1}\n            {zadd myzset2{t} 1 one 2 two 3 three}\n            {zpopmin myzset2{t} 2}\n            {zpopmax myzset2{t} 1}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zadd myzset2{t} 4 four 5 five 6 six}\n            {zpopmin myzset{t} 3}\n            {zpopmax myzset2{t} 3}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    foreach resp {3 2} {\n        set rd [redis_deferring_client]\n\n        if {[lsearch $::denytags \"resp3\"] >= 0} {\n            if {$resp == 3} {continue}\n        } else {\n            r hello $resp\n            $rd hello $resp\n            $rd read\n        }\n\n        test \"ZPOPMIN/ZPOPMAX readraw in RESP$resp\" {\n            r del zset{t}\n            create_zset zset2{t} {1 a 2 b 3 c 4 d 5 e}\n\n            r readraw 1\n\n            # ZPOP against non existing key.\n            assert_equal {*0} [r zpopmin zset{t}]\n            assert_equal {*0} [r zpopmin zset{t} 1]\n\n            # ZPOP without COUNT option.\n            assert_equal {*2} [r zpopmin zset2{t}]\n            assert_equal [r read] {$1}\n            assert_equal [r read] {a}\n            verify_score_response r $resp 1\n\n            # ZPOP with COUNT option.\n            if {$resp == 2} {\n                assert_equal {*2} [r zpopmax zset2{t} 1]\n                assert_equal [r read] {$1}\n                assert_equal [r read] {e}\n            } elseif {$resp == 3} {\n                assert_equal {*1} [r zpopmax zset2{t} 1]\n                assert_equal [r read] {*2}\n                assert_equal [r read] {$1}\n                assert_equal [r read] {e}\n            }\n            verify_score_response r $resp 5\n\n            r readraw 0\n        }\n\n        test \"BZPOPMIN/BZPOPMAX readraw in RESP$resp\" {\n            r del zset{t}\n            create_zset zset2{t} {1 a 2 b 3 c 4 d 5 e}\n\n            $rd readraw 1\n\n            # BZPOP released on timeout.\n            $rd bzpopmin zset{t} 0.01\n            verify_nil_response $resp [$rd read]\n            $rd bzpopmax zset{t} 0.01\n            verify_nil_response $resp [$rd read]\n\n            # BZPOP non-blocking path.\n            $rd bzpopmin zset1{t} zset2{t} 0.1\n            assert_equal [$rd read] {*3}\n            assert_equal [$rd read] {$8}\n            assert_equal [$rd read] {zset2{t}}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {a}\n            verify_score_response $rd $resp 1\n\n            # BZPOP blocking path.\n            $rd bzpopmin zset{t} 5\n            wait_for_blocked_client\n            r zadd zset{t} 1 a\n            assert_equal [$rd read] {*3}\n            assert_equal [$rd read] {$7}\n            assert_equal [$rd read] {zset{t}}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {a}\n            verify_score_response $rd $resp 1\n\n            $rd readraw 0\n        }\n\n        test \"ZMPOP readraw in RESP$resp\" {\n            r del zset{t} zset2{t}\n            create_zset zset3{t} {1 a}\n            create_zset zset4{t} {1 a 2 b 3 c 4 d 5 e}\n\n            r readraw 1\n\n            # ZMPOP against non existing key.\n            verify_nil_response $resp [r zmpop 1 zset{t} min]\n            verify_nil_response $resp [r zmpop 1 zset{t} max count 1]\n            verify_nil_response $resp [r zmpop 2 zset{t} zset2{t} min]\n            verify_nil_response $resp [r zmpop 2 zset{t} zset2{t} max count 1]\n\n            # ZMPOP with one input key.\n            assert_equal {*2} [r zmpop 1 zset3{t} max]\n            assert_equal [r read] {$8}\n            assert_equal [r read] {zset3{t}}\n            assert_equal [r read] {*1}\n            assert_equal [r read] {*2}\n            assert_equal [r read] {$1}\n            assert_equal [r read] {a}\n            verify_score_response r $resp 1\n\n            # ZMPOP with COUNT option.\n            assert_equal {*2} [r zmpop 2 zset3{t} zset4{t} min count 2]\n            assert_equal [r read] {$8}\n            assert_equal [r read] {zset4{t}}\n            assert_equal [r read] {*2}\n            assert_equal [r read] {*2}\n            assert_equal [r read] {$1}\n            assert_equal [r read] {a}\n            verify_score_response r $resp 1\n            assert_equal [r read] {*2}\n            assert_equal [r read] {$1}\n            assert_equal [r read] {b}\n            verify_score_response r $resp 2\n\n            r readraw 0\n        }\n\n        test \"BZMPOP readraw in RESP$resp\" {\n            r del zset{t} zset2{t}\n            create_zset zset3{t} {1 a 2 b 3 c 4 d 5 e}\n\n            $rd readraw 1\n\n            # BZMPOP released on timeout.\n            $rd bzmpop 0.01 1 zset{t} min\n            verify_nil_response $resp [$rd read]\n            $rd bzmpop 0.01 2 zset{t} zset2{t} max\n            verify_nil_response $resp [$rd read]\n\n            # BZMPOP non-blocking path.\n            $rd bzmpop 0.1 2 zset3{t} zset4{t} min\n\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$8}\n            assert_equal [$rd read] {zset3{t}}\n            assert_equal [$rd read] {*1}\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {a}\n            verify_score_response $rd $resp 1\n\n            # BZMPOP blocking path with COUNT option.\n            $rd bzmpop 5 2 zset{t} zset2{t} max count 2\n            wait_for_blocked_client\n            r zadd zset2{t} 1 a 2 b 3 c\n\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$8}\n            assert_equal [$rd read] {zset2{t}}\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {c}\n            verify_score_response $rd $resp 3\n            assert_equal [$rd read] {*2}\n            assert_equal [$rd read] {$1}\n            assert_equal [$rd read] {b}\n            verify_score_response $rd $resp 2\n\n        }\n\n        $rd close\n    }\n\n    test {ZINTERSTORE regression with two sets, intset+hashtable} {\n        r del seta{t} setb{t} setc{t}\n        r sadd set1{t} a\n        r sadd set2{t} 10\n        r zinterstore set3{t} 2 set1{t} set2{t}\n    } {0}\n\n    test {ZUNIONSTORE regression, should not create NaN in scores} {\n        r zadd z{t} -inf neginf\n        r zunionstore out{t} 1 z{t} weights 0\n        r zrange out{t} 0 -1 withscores\n    } {neginf 0}\n\n    test {ZINTERSTORE #516 regression, mixed sets and ziplist zsets} {\n        r sadd one{t} 100 101 102 103\n        r sadd two{t} 100 200 201 202\n        r zadd three{t} 1 500 1 501 1 502 1 503 1 100\n        r zinterstore to_here{t} 3 one{t} two{t} three{t} WEIGHTS 0 0 1\n        r zrange to_here{t} 0 -1\n    } {100}\n\n    test {ZUNIONSTORE result is sorted} {\n        # Create two sets with common and not common elements, perform\n        # the UNION, check that elements are still sorted.\n        r del one{t} two{t} dest{t}\n        set cmd1 [list r zadd one{t}]\n        set cmd2 [list r zadd two{t}]\n        for {set j 0} {$j < 1000} {incr j} {\n            lappend cmd1 [expr rand()] [randomInt 1000]\n            lappend cmd2 [expr rand()] [randomInt 1000]\n        }\n        {*}$cmd1\n        {*}$cmd2\n        assert {[r zcard one{t}] > 100}\n        assert {[r zcard two{t}] > 100}\n        r zunionstore dest{t} 2 one{t} two{t}\n        set oldscore 0\n        foreach {ele score} [r zrange dest{t} 0 -1 withscores] {\n            assert {$score >= $oldscore}\n            set oldscore $score\n        }\n    }\n\n    test \"ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE error if using WITHSCORES \" {\n        assert_error \"*ERR*syntax*\" {r zunionstore foo{t} 2 zsetd{t} zsetf{t} withscores}\n        assert_error \"*ERR*syntax*\" {r zinterstore foo{t} 2 zsetd{t} zsetf{t} withscores}\n        assert_error \"*ERR*syntax*\" {r zdiffstore foo{t} 2 zsetd{t} zsetf{t} withscores}\n    }\n\n    test {ZMSCORE retrieve} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n\n        r zmscore zmscoretest x y\n    } {10 20}\n\n    test {ZMSCORE retrieve from empty set} {\n        r del zmscoretest\n\n        r zmscore zmscoretest x y\n    } {{} {}}\n\n    test {ZMSCORE retrieve with missing member} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n\n        r zmscore zmscoretest x y\n    } {10 {}}\n\n    test {ZMSCORE retrieve single member} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n\n        r zmscore zmscoretest x\n    } {10}\n\n    test {ZMSCORE retrieve requires one or more members} {\n        r del zmscoretest\n        r zadd zmscoretest 10 x\n        r zadd zmscoretest 20 y\n\n        catch {r zmscore zmscoretest} e\n        assert_match {*ERR*wrong*number*arg*} $e\n    }\n\n    test \"ZSET commands don't accept the empty strings as valid score\" {\n        assert_error \"*not*float*\" {r zadd myzset \"\" abc}\n    }\n\n    test \"zunionInterDiffGenericCommand at least 1 input key\" {\n        assert_error {*at least 1 input key * 'zunion' command} {r zunion 0 key{t}}\n        assert_error {*at least 1 input key * 'zunionstore' command} {r zunionstore dst_key{t} 0 key{t}}\n        assert_error {*at least 1 input key * 'zinter' command} {r zinter 0 key{t}}\n        assert_error {*at least 1 input key * 'zinterstore' command} {r zinterstore dst_key{t} 0 key{t}}\n        assert_error {*at least 1 input key * 'zdiff' command} {r zdiff 0 key{t}}\n        assert_error {*at least 1 input key * 'zdiffstore' command} {r zdiffstore dst_key{t} 0 key{t}}\n        assert_error {*at least 1 input key * 'zintercard' command} {r zintercard 0 key{t}}\n    }\n\n    proc stressers {encoding} {\n        set original_max_entries [lindex [r config get zset-max-ziplist-entries] 1]\n        set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n        if {$encoding == \"listpack\"} {\n            # Little extra to allow proper fuzzing in the sorting stresser\n            r config set zset-max-ziplist-entries 256\n            r config set zset-max-ziplist-value 64\n            set elements 128\n        } elseif {$encoding == \"skiplist\"} {\n            r config set zset-max-ziplist-entries 0\n            r config set zset-max-ziplist-value 0\n            if {$::accurate} {set elements 1000} else {set elements 100}\n        } else {\n            puts \"Unknown sorted set encoding\"\n            exit\n        }\n\n        test \"ZSCORE - $encoding\" {\n            r del zscoretest\n            set aux {}\n            for {set i 0} {$i < $elements} {incr i} {\n                set score [expr rand()]\n                lappend aux $score\n                r zadd zscoretest $score $i\n            }\n\n            assert_encoding $encoding zscoretest\n            for {set i 0} {$i < $elements} {incr i} {\n                assert_equal [lindex $aux $i] [r zscore zscoretest $i]\n            }\n        }\n\n        test \"ZMSCORE - $encoding\" {\n            r del zscoretest\n            set aux {}\n            for {set i 0} {$i < $elements} {incr i} {\n                set score [expr rand()]\n                lappend aux $score\n                r zadd zscoretest $score $i\n            }\n\n            assert_encoding $encoding zscoretest\n            for {set i 0} {$i < $elements} {incr i} {\n                assert_equal [lindex $aux $i] [r zmscore zscoretest $i]\n            }\n        }\n\n        test \"ZSCORE after a DEBUG RELOAD - $encoding\" {\n            r del zscoretest\n            set aux {}\n            for {set i 0} {$i < $elements} {incr i} {\n                set score [expr rand()]\n                lappend aux $score\n                r zadd zscoretest $score $i\n            }\n\n            r debug reload\n            assert_encoding $encoding zscoretest\n            for {set i 0} {$i < $elements} {incr i} {\n                assert_equal [lindex $aux $i] [r zscore zscoretest $i]\n            }\n        } {} {needs:debug}\n\n        test \"ZSET sorting stresser - $encoding\" {\n            set delta 0\n            for {set test 0} {$test < 2} {incr test} {\n                unset -nocomplain auxarray\n                array set auxarray {}\n                set auxlist {}\n                r del myzset\n                for {set i 0} {$i < $elements} {incr i} {\n                    if {$test == 0} {\n                        set score [expr rand()]\n                    } else {\n                        set score [expr int(rand()*10)]\n                    }\n                    set auxarray($i) $score\n                    r zadd myzset $score $i\n                    # Random update\n                    if {[expr rand()] < .2} {\n                        set j [expr int(rand()*1000)]\n                        if {$test == 0} {\n                            set score [expr rand()]\n                        } else {\n                            set score [expr int(rand()*10)]\n                        }\n                        set auxarray($j) $score\n                        r zadd myzset $score $j\n                    }\n                }\n                foreach {item score} [array get auxarray] {\n                    lappend auxlist [list $score $item]\n                }\n                set sorted [lsort -command zlistAlikeSort $auxlist]\n                set auxlist {}\n                foreach x $sorted {\n                    lappend auxlist [lindex $x 1]\n                }\n\n                assert_encoding $encoding myzset\n                set fromredis [r zrange myzset 0 -1]\n                set delta 0\n                for {set i 0} {$i < [llength $fromredis]} {incr i} {\n                    if {[lindex $fromredis $i] != [lindex $auxlist $i]} {\n                        incr delta\n                    }\n                }\n            }\n            assert_equal 0 $delta\n        }\n\n        test \"ZRANGEBYSCORE fuzzy test, 100 ranges in $elements element sorted set - $encoding\" {\n            set err {}\n            r del zset\n            for {set i 0} {$i < $elements} {incr i} {\n                r zadd zset [expr rand()] $i\n            }\n\n            assert_encoding $encoding zset\n            for {set i 0} {$i < 100} {incr i} {\n                set min [expr rand()]\n                set max [expr rand()]\n                if {$min > $max} {\n                    set aux $min\n                    set min $max\n                    set max $aux\n                }\n                set low [r zrangebyscore zset -inf $min]\n                set ok [r zrangebyscore zset $min $max]\n                set high [r zrangebyscore zset $max +inf]\n                set lowx [r zrangebyscore zset -inf ($min]\n                set okx [r zrangebyscore zset ($min ($max]\n                set highx [r zrangebyscore zset ($max +inf]\n\n                if {[r zcount zset -inf $min] != [llength $low]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset $min $max] != [llength $ok]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset $max +inf] != [llength $high]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset -inf ($min] != [llength $lowx]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset ($min ($max] != [llength $okx]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n                if {[r zcount zset ($max +inf] != [llength $highx]} {\n                    append err \"Error, len does not match zcount\\n\"\n                }\n\n                foreach x $low {\n                    set score [r zscore zset $x]\n                    if {$score > $min} {\n                        append err \"Error, score for $x is $score > $min\\n\"\n                    }\n                }\n                foreach x $lowx {\n                    set score [r zscore zset $x]\n                    if {$score >= $min} {\n                        append err \"Error, score for $x is $score >= $min\\n\"\n                    }\n                }\n                foreach x $ok {\n                    set score [r zscore zset $x]\n                    if {$score < $min || $score > $max} {\n                        append err \"Error, score for $x is $score outside $min-$max range\\n\"\n                    }\n                }\n                foreach x $okx {\n                    set score [r zscore zset $x]\n                    if {$score <= $min || $score >= $max} {\n                        append err \"Error, score for $x is $score outside $min-$max open range\\n\"\n                    }\n                }\n                foreach x $high {\n                    set score [r zscore zset $x]\n                    if {$score < $max} {\n                        append err \"Error, score for $x is $score < $max\\n\"\n                    }\n                }\n                foreach x $highx {\n                    set score [r zscore zset $x]\n                    if {$score <= $max} {\n                        append err \"Error, score for $x is $score <= $max\\n\"\n                    }\n                }\n            }\n            assert_equal {} $err\n        }\n\n        test \"ZRANGEBYLEX fuzzy test, 100 ranges in $elements element sorted set - $encoding\" {\n            set lexset {}\n            r del zset\n            for {set j 0} {$j < $elements} {incr j} {\n                set e [randstring 0 30 alpha]\n                lappend lexset $e\n                r zadd zset 0 $e\n            }\n            set lexset [lsort -unique $lexset]\n            for {set j 0} {$j < 100} {incr j} {\n                set min [randstring 0 30 alpha]\n                set max [randstring 0 30 alpha]\n                set mininc [randomInt 2]\n                set maxinc [randomInt 2]\n                if {$mininc} {set cmin \"\\[$min\"} else {set cmin \"($min\"}\n                if {$maxinc} {set cmax \"\\[$max\"} else {set cmax \"($max\"}\n                set rev [randomInt 2]\n                if {$rev} {\n                    set cmd zrevrangebylex\n                } else {\n                    set cmd zrangebylex\n                }\n\n                # Make sure data is the same in both sides\n                assert {[r zrange zset 0 -1] eq $lexset}\n\n                # Get the Redis output\n                set output [r $cmd zset $cmin $cmax]\n                if {$rev} {\n                    set outlen [r zlexcount zset $cmax $cmin]\n                } else {\n                    set outlen [r zlexcount zset $cmin $cmax]\n                }\n\n                # Compute the same output via Tcl\n                set o {}\n                set copy $lexset\n                if {(!$rev && [string compare $min $max] > 0) ||\n                    ($rev && [string compare $max $min] > 0)} {\n                    # Empty output when ranges are inverted.\n                } else {\n                    if {$rev} {\n                        # Invert the Tcl array using Redis itself.\n                        set copy [r zrevrange zset 0 -1]\n                        # Invert min / max as well\n                        lassign [list $min $max $mininc $maxinc] \\\n                            max min maxinc mininc\n                    }\n                    foreach e $copy {\n                        set mincmp [string compare $e $min]\n                        set maxcmp [string compare $e $max]\n                        if {\n                             ($mininc && $mincmp >= 0 || !$mininc && $mincmp > 0)\n                             &&\n                             ($maxinc && $maxcmp <= 0 || !$maxinc && $maxcmp < 0)\n                        } {\n                            lappend o $e\n                        }\n                    }\n                }\n                assert {$o eq $output}\n                assert {$outlen eq [llength $output]}\n            }\n        }\n\n        test \"ZREMRANGEBYLEX fuzzy test, 100 ranges in $elements element sorted set - $encoding\" {\n            set lexset {}\n            r del zset{t} zsetcopy{t}\n            for {set j 0} {$j < $elements} {incr j} {\n                set e [randstring 0 30 alpha]\n                lappend lexset $e\n                r zadd zset{t} 0 $e\n            }\n            set lexset [lsort -unique $lexset]\n            for {set j 0} {$j < 100} {incr j} {\n                # Copy...\n                r zunionstore zsetcopy{t} 1 zset{t}\n                set lexsetcopy $lexset\n\n                set min [randstring 0 30 alpha]\n                set max [randstring 0 30 alpha]\n                set mininc [randomInt 2]\n                set maxinc [randomInt 2]\n                if {$mininc} {set cmin \"\\[$min\"} else {set cmin \"($min\"}\n                if {$maxinc} {set cmax \"\\[$max\"} else {set cmax \"($max\"}\n\n                # Make sure data is the same in both sides\n                assert {[r zrange zset{t} 0 -1] eq $lexset}\n\n                # Get the range we are going to remove\n                set torem [r zrangebylex zset{t} $cmin $cmax]\n                set toremlen [r zlexcount zset{t} $cmin $cmax]\n                r zremrangebylex zsetcopy{t} $cmin $cmax\n                set output [r zrange zsetcopy{t} 0 -1]\n\n                # Remove the range with Tcl from the original list\n                if {$toremlen} {\n                    set first [lsearch -exact $lexsetcopy [lindex $torem 0]]\n                    set last [expr {$first+$toremlen-1}]\n                    set lexsetcopy [lreplace $lexsetcopy $first $last]\n                }\n                assert {$lexsetcopy eq $output}\n            }\n        }\n\n        test \"ZSETs skiplist implementation backlink consistency test - $encoding\" {\n            set diff 0\n            for {set j 0} {$j < $elements} {incr j} {\n                r zadd myzset [expr rand()] \"Element-$j\"\n                r zrem myzset \"Element-[expr int(rand()*$elements)]\"\n            }\n\n            assert_encoding $encoding myzset\n            set l1 [r zrange myzset 0 -1]\n            set l2 [r zrevrange myzset 0 -1]\n            for {set j 0} {$j < [llength $l1]} {incr j} {\n                if {[lindex $l1 $j] ne [lindex $l2 end-$j]} {\n                    incr diff\n                }\n            }\n            assert_equal 0 $diff\n        }\n\n        test \"ZSETs ZRANK augmented skip list stress testing - $encoding\" {\n            set err {}\n            r del myzset\n            for {set k 0} {$k < 2000} {incr k} {\n                set i [expr {$k % $elements}]\n                if {[expr rand()] < .2} {\n                    r zrem myzset $i\n                } else {\n                    set score [expr rand()]\n                    r zadd myzset $score $i\n                    assert_encoding $encoding myzset\n                }\n\n                set card [r zcard myzset]\n                if {$card > 0} {\n                    set index [randomInt $card]\n                    set ele [lindex [r zrange myzset $index $index] 0]\n                    set rank [r zrank myzset $ele]\n                    if {$rank != $index} {\n                        set err \"$ele RANK is wrong! ($rank != $index)\"\n                        break\n                    }\n                }\n            }\n            assert_equal {} $err\n        }\n\n    foreach {pop} {BZPOPMIN BZMPOP_MIN} {\n        test \"$pop, ZADD + DEL should not awake blocked client\" {\n            set rd [redis_deferring_client]\n            r del zset\n\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n\n            r multi\n            r zadd zset 0 foo\n            r del zset\n            r exec\n            r del zset\n            r zadd zset 1 bar\n\n            verify_pop_response $pop [$rd read] {zset bar 1} {zset {{bar 1}}}\n            $rd close\n        }\n\n        test \"$pop, ZADD + DEL + SET should not awake blocked client\" {\n            set rd [redis_deferring_client]\n            r del zset\n\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n\n            r multi\n            r zadd zset 0 foo\n            r del zset\n            r set zset foo\n            r exec\n            r del zset\n            r zadd zset 1 bar\n\n            verify_pop_response $pop [$rd read] {zset bar 1} {zset {{bar 1}}}\n            $rd close\n        }\n    }\n\n        test \"BZPOPMIN with same key multiple times should work\" {\n            set rd [redis_deferring_client]\n            r del z1{t} z2{t}\n\n            # Data arriving after the BZPOPMIN.\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            wait_for_blocked_client\n            r zadd z1{t} 0 a\n            assert_equal [$rd read] {z1{t} a 0}\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            wait_for_blocked_client\n            r zadd z2{t} 1 b\n            assert_equal [$rd read] {z2{t} b 1}\n\n            # Data already there.\n            r zadd z1{t} 0 a\n            r zadd z2{t} 1 b\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            assert_equal [$rd read] {z1{t} a 0}\n            $rd bzpopmin z1{t} z2{t} z2{t} z1{t} 0\n            assert_equal [$rd read] {z2{t} b 1}\n            $rd close\n        }\n\n    foreach {pop} {BZPOPMIN BZMPOP_MIN} {\n        test \"MULTI/EXEC is isolated from the point of view of $pop\" {\n            set rd [redis_deferring_client]\n            r del zset\n\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n\n            r multi\n            r zadd zset 0 a\n            r zadd zset 1 b\n            r zadd zset 2 c\n            r exec\n\n            verify_pop_response $pop [$rd read] {zset a 0} {zset {{a 0}}}\n            $rd close\n        }\n\n        test \"$pop with variadic ZADD\" {\n            set rd [redis_deferring_client]\n            r del zset\n            if {$::valgrind} {after 100}\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n            if {$::valgrind} {after 100}\n            assert_equal 2 [r zadd zset -1 foo 1 bar]\n            if {$::valgrind} {after 100}\n            verify_pop_response $pop [$rd read] {zset foo -1} {zset {{foo -1}}}\n            assert_equal {bar} [r zrange zset 0 -1]\n            $rd close\n        }\n\n        test \"$pop with zero timeout should block indefinitely\" {\n            set rd [redis_deferring_client]\n            r del zset\n            bzpop_command $rd $pop zset 0\n            wait_for_blocked_client\n            after 1000\n            r zadd zset 0 foo\n            verify_pop_response $pop [$rd read] {zset foo 0} {zset {{foo 0}}}\n            $rd close\n        }\n    }\n\n        r config set zset-max-ziplist-entries $original_max_entries\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    tags {\"slow\"} {\n        stressers listpack\n        stressers skiplist\n    }\n\n    test \"BZPOP/BZMPOP against wrong type\" {\n        r set foo{t} bar\n        assert_error \"*WRONGTYPE*\" {r bzpopmin foo{t} 1}\n        assert_error \"*WRONGTYPE*\" {r bzpopmax foo{t} 1}\n\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 1 foo{t} min}\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 1 foo{t} max}\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 1 foo{t} min count 10}\n\n        r del foo{t}\n        r set foo2{t} bar\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 2 foo{t} foo2{t} min}\n        assert_error \"*WRONGTYPE*\" {r bzmpop 1 2 foo2{t} foo{t} max count 1}\n    }\n\n    test \"BZMPOP with illegal argument\" {\n        assert_error \"ERR wrong number of arguments for 'bzmpop' command\" {r bzmpop}\n        assert_error \"ERR wrong number of arguments for 'bzmpop' command\" {r bzmpop 0 1}\n        assert_error \"ERR wrong number of arguments for 'bzmpop' command\" {r bzmpop 0 1 myzset{t}}\n\n        assert_error \"ERR numkeys*\" {r bzmpop 1 0 myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r bzmpop 1 a myzset{t} MIN}\n        assert_error \"ERR numkeys*\" {r bzmpop 1 -1 myzset{t} MAX}\n\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} bad_where}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} MIN bar_arg}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} MAX MIN}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} COUNT}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 1 myzset{t} MIN COUNT 1 COUNT 2}\n        assert_error \"ERR syntax error*\" {r bzmpop 1 2 myzset{t} myzset2{t} bad_arg}\n\n        assert_error \"ERR count*\" {r bzmpop 1 1 myzset{t} MIN COUNT 0}\n        assert_error \"ERR count*\" {r bzmpop 1 1 myzset{t} MAX COUNT a}\n        assert_error \"ERR count*\" {r bzmpop 1 1 myzset{t} MIN COUNT -1}\n        assert_error \"ERR count*\" {r bzmpop 1 2 myzset{t} myzset2{t} MAX COUNT -1}\n    }\n\n    test \"BZMPOP with multiple blocked clients\" {\n        set rd1 [redis_deferring_client]\n        set rd2 [redis_deferring_client]\n        set rd3 [redis_deferring_client]\n        set rd4 [redis_deferring_client]\n        r del myzset{t} myzset2{t}\n\n        $rd1 bzmpop 0 2 myzset{t} myzset2{t} min count 1\n        wait_for_blocked_clients_count 1\n        $rd2 bzmpop 0 2 myzset{t} myzset2{t} max count 10\n        wait_for_blocked_clients_count 2\n        $rd3 bzmpop 0 2 myzset{t} myzset2{t} min count 10\n        wait_for_blocked_clients_count 3\n        $rd4 bzmpop 0 2 myzset{t} myzset2{t} max count 1\n        wait_for_blocked_clients_count 4\n\n        r multi\n        r zadd myzset{t} 1 a 2 b 3 c 4 d 5 e\n        r zadd myzset2{t} 1 a 2 b 3 c 4 d 5 e\n        r exec\n\n        assert_equal {myzset{t} {{a 1}}} [$rd1 read]\n        assert_equal {myzset{t} {{e 5} {d 4} {c 3} {b 2}}} [$rd2 read]\n        assert_equal {myzset2{t} {{a 1} {b 2} {c 3} {d 4} {e 5}}} [$rd3 read]\n\n        r zadd myzset2{t} 1 a 2 b 3 c\n        assert_equal {myzset2{t} {{c 3}}} [$rd4 read]\n\n        r del myzset{t} myzset2{t}\n        $rd1 close\n        $rd2 close\n        $rd3 close\n        $rd4 close\n    }\n\n    test \"BZMPOP propagate as pop with count command to replica\" {\n        set rd [redis_deferring_client]\n        set repl [attach_to_replication_stream]\n\n        # BZMPOP without being blocked.\n        r zadd myzset{t} 1 one 2 two 3 three\n        r zadd myzset2{t} 4 four 5 five 6 six\n        r bzmpop 0 1 myzset{t} min\n        r bzmpop 0 2 myzset{t} myzset2{t} max count 10\n        r bzmpop 0 2 myzset{t} myzset2{t} max count 10\n\n        # BZMPOP that gets blocked.\n        $rd bzmpop 0 1 myzset{t} min count 1\n        wait_for_blocked_client\n        r zadd myzset{t} 1 one\n        $rd bzmpop 0 2 myzset{t} myzset2{t} min count 5\n        wait_for_blocked_client\n        r zadd myzset{t} 1 one 2 two 3 three\n        $rd bzmpop 0 2 myzset{t} myzset2{t} max count 10\n        wait_for_blocked_client\n        r zadd myzset2{t} 4 four 5 five 6 six\n\n        # Released on timeout.\n        assert_equal {} [r bzmpop 0.01 1 myzset{t} max count 10]\n        r set foo{t} bar ;# something else to propagate after, so we can make sure the above pop didn't.\n\n        $rd close\n\n        assert_replication_stream $repl {\n            {select *}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zadd myzset2{t} 4 four 5 five 6 six}\n            {zpopmin myzset{t} 1}\n            {zpopmax myzset{t} 2}\n            {zpopmax myzset2{t} 3}\n            {zadd myzset{t} 1 one}\n            {zpopmin myzset{t} 1}\n            {zadd myzset{t} 1 one 2 two 3 three}\n            {zpopmin myzset{t} 3}\n            {zadd myzset2{t} 4 four 5 five 6 six}\n            {zpopmax myzset2{t} 3}\n            {set foo{t} bar}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test \"BZMPOP should not blocks on non key arguments - #10762\" {\n        set rd1 [redis_deferring_client]\n        set rd2 [redis_deferring_client]\n        r del myzset myzset2 myzset3\n\n        $rd1 bzmpop 0 1 myzset min count 10\n        wait_for_blocked_clients_count 1\n        $rd2 bzmpop 0 2 myzset2 myzset3 max count 10\n        wait_for_blocked_clients_count 2\n\n        # These non-key keys will not unblock the clients.\n        r zadd 0 100 timeout_value\n        r zadd 1 200 numkeys_value\n        r zadd min 300 min_token\n        r zadd max 400 max_token\n        r zadd count 500 count_token\n        r zadd 10 600 count_value\n\n        r zadd myzset 1 zset\n        r zadd myzset3 1 zset3\n        assert_equal {myzset {{zset 1}}} [$rd1 read]\n        assert_equal {myzset3 {{zset3 1}}} [$rd2 read]\n\n        $rd1 close\n        $rd2 close\n    } {0} {cluster:skip}\n\n    test {ZSET skiplist order consistency when elements are moved} {\n        set original_max [lindex [r config get zset-max-ziplist-entries] 1]\n        r config set zset-max-ziplist-entries 0\n        for {set times 0} {$times < 10} {incr times} {\n            r del zset\n            for {set j 0} {$j < 1000} {incr j} {\n                r zadd zset [randomInt 50] ele-[randomInt 10]\n            }\n\n            # Make sure that element ordering is correct\n            set prev_element {}\n            set prev_score -1\n            foreach {element score} [r zrange zset 0 -1 WITHSCORES] {\n                # Assert that elements are in increasing ordering\n                assert {\n                    $prev_score < $score ||\n                    ($prev_score == $score &&\n                     [string compare $prev_element $element] == -1)\n                }\n                set prev_element $element\n                set prev_score $score\n            }\n        }\n        r config set zset-max-ziplist-entries $original_max\n    }\n\n    test {ZRANGESTORE basic} {\n        r flushall\n        r zadd z1{t} 1 a 2 b 3 c 4 d\n        set res [r zrangestore z2{t} z1{t} 0 -1]\n        assert_equal $res 4\n        r zrange z2{t} 0 -1 withscores\n    } {a 1 b 2 c 3 d 4}\n\n    test {ZRANGESTORE RESP3} {\n        r hello 3\n        assert_equal [r zrange z2{t} 0 -1 withscores] {{a 1.0} {b 2.0} {c 3.0} {d 4.0}}\n        r hello 2\n    } \n\n    test {ZRANGESTORE range} {\n        set res [r zrangestore z2{t} z1{t} 1 2]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {b 2 c 3}\n\n    test {ZRANGESTORE BYLEX} {\n        set res [r zrangestore z2{t} z1{t} \\[b \\[c BYLEX]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {b 2 c 3}\n\n    test {ZRANGESTORE BYSCORE} {\n        set res [r zrangestore z2{t} z1{t} 1 2 BYSCORE]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {a 1 b 2}\n\n    test {ZRANGESTORE BYSCORE LIMIT} {\n        set res [r zrangestore z2{t} z1{t} 0 5 BYSCORE LIMIT 0 2]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {a 1 b 2}\n\n    test {ZRANGESTORE BYSCORE REV LIMIT} {\n        set res [r zrangestore z2{t} z1{t} 5 0 BYSCORE REV LIMIT 0 2]\n        assert_equal $res 2\n        r zrange z2{t} 0 -1 withscores\n    } {c 3 d 4}\n\n    test {ZRANGE BYSCORE REV LIMIT} {\n        r zrange z1{t} 5 0 BYSCORE REV LIMIT 0 2 WITHSCORES\n    } {d 4 c 3}\n\n    test {ZRANGESTORE - src key missing} {\n        set res [r zrangestore z2{t} missing{t} 0 -1]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGESTORE - src key wrong type} {\n        r zadd z2{t} 1 a\n        r set foo{t} bar\n        assert_error \"*WRONGTYPE*\" {r zrangestore z2{t} foo{t} 0 -1}\n        r zrange z2{t} 0 -1\n    } {a}\n\n    test {ZRANGESTORE - empty range} {\n        set res [r zrangestore z2{t} z1{t} 5 6]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGESTORE BYLEX - empty range} {\n        set res [r zrangestore z2{t} z1{t} \\[f \\[g BYLEX]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGESTORE BYSCORE - empty range} {\n        set res [r zrangestore z2{t} z1{t} 5 6 BYSCORE]\n        assert_equal $res 0\n        r exists z2{t}\n    } {0}\n\n    test {ZRANGE BYLEX} {\n        r zrange z1{t} \\[b \\[c BYLEX\n    } {b c}\n\n    test {ZRANGESTORE invalid syntax} {\n        catch {r zrangestore z2{t} z1{t} 0 -1 limit 1 2} err\n        assert_match \"*syntax*\" $err\n        catch {r zrangestore z2{t} z1{t} 0 -1 WITHSCORES} err\n        assert_match \"*syntax*\" $err\n    }\n\n    test {ZRANGESTORE with zset-max-listpack-entries 0 #10767 case} {\n        set original_max [lindex [r config get zset-max-listpack-entries] 1]\n        r config set zset-max-listpack-entries 0\n        r del z1{t} z2{t}\n        r zadd z1{t} 1 a\n        assert_equal 1 [r zrangestore z2{t} z1{t} 0 -1]\n        r config set zset-max-listpack-entries $original_max\n    }\n\n    test {ZRANGESTORE with zset-max-listpack-entries 1 dst key should use skiplist encoding} {\n        set original_max [lindex [r config get zset-max-listpack-entries] 1]\n        r config set zset-max-listpack-entries 1\n        r del z1{t} z2{t} z3{t}\n        r zadd z1{t} 1 a 2 b\n        assert_equal 1 [r zrangestore z2{t} z1{t} 0 0]\n        assert_encoding listpack z2{t}\n        assert_equal 2 [r zrangestore z3{t} z1{t} 0 1]\n        assert_encoding skiplist z3{t}\n        r config set zset-max-listpack-entries $original_max\n    }\n\n    test {ZRANGE invalid syntax} {\n        catch {r zrange z1{t} 0 -1 limit 1 2} err\n        assert_match \"*syntax*\" $err\n        catch {r zrange z1{t} 0 -1 BYLEX WITHSCORES} err\n        assert_match \"*syntax*\" $err\n        catch {r zrevrange z1{t} 0 -1 BYSCORE} err\n        assert_match \"*syntax*\" $err\n        catch {r zrangebyscore z1{t} 0 -1 REV} err\n        assert_match \"*syntax*\" $err\n    }\n\n    proc get_keys {l} {\n        set res {}\n        foreach {score key} $l {\n            lappend res $key\n        }\n        return $res\n    }\n\n    # Check whether the zset members belong to the zset\n    proc check_member {mydict res} {\n        foreach ele $res {\n            assert {[dict exists $mydict $ele]}\n        }\n    }\n\n    # Check whether the zset members and score belong to the zset\n    proc check_member_and_score {mydict res} {\n       foreach {key val} $res {\n            assert_equal $val [dict get $mydict $key]\n        }\n    }\n\n    foreach {type contents} \"listpack {1 a 2 b 3 c} skiplist {1 a 2 b 3 [randstring 70 90 alpha]}\" {\n        set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n        r config set zset-max-ziplist-value 10\n        create_zset myzset $contents\n        assert_encoding $type myzset\n\n        test \"ZRANDMEMBER - $type\" {\n            unset -nocomplain myzset\n            array set myzset {}\n            for {set i 0} {$i < 100} {incr i} {\n                set key [r zrandmember myzset]\n                set myzset($key) 1\n            }\n            assert_equal [lsort [get_keys $contents]] [lsort [array names myzset]]\n        }\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    test \"ZRANDMEMBER with RESP3\" {\n        r hello 3\n        set res [r zrandmember myzset 3 withscores]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 2\n\n        set res [r zrandmember myzset 3]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 1\n        r hello 2\n    }\n\n    test \"ZRANDMEMBER count of 0 is handled correctly\" {\n        r zrandmember myzset 0\n    } {}\n\n    test \"ZRANDMEMBER with <count> against non existing key\" {\n        r zrandmember nonexisting_key 100\n    } {}\n\n    test \"ZRANDMEMBER count overflow\" {\n        r zadd myzset 0 a\n        assert_error {*value is out of range*} {r zrandmember myzset -9223372036854770000 withscores}\n        assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808 withscores}\n        assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808}\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"ZRANDMEMBER count of 0 is handled correctly - emptyarray\" {\n        r zrandmember myzset 0\n    } {*0}\n\n    test \"ZRANDMEMBER with <count> against non existing key - emptyarray\" {\n        r zrandmember nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} \"\n        skiplist {1 a 2 b 3 c 4 d 5 e 6 f 7 g 7 h 9 i 10 [randstring 70 90 alpha]}\n        listpack {1 a 2 b 3 c 4 d 5 e 6 f 7 g 7 h 9 i 10 j} \" {\n        test \"ZRANDMEMBER with <count> - $type\" {\n            set original_max_value [lindex [r config get zset-max-ziplist-value] 1]\n            r config set zset-max-ziplist-value 10\n            create_zset myzset $contents\n            assert_encoding $type myzset\n\n            # create a dict for easy lookup\n            set mydict [dict create {*}[r zrange myzset 0 -1 withscores]]\n\n            # We'll stress different parts of the code, see the implementation\n            # of ZRANDMEMBER for more information, but basically there are\n            # four different code paths.\n\n            # PATH 1: Use negative count.\n\n            # 1) Check that it returns repeated elements with and without values.\n            # 2) Check that all the elements actually belong to the original zset.\n            set res [r zrandmember myzset -20]\n            assert_equal [llength $res] 20\n            check_member $mydict $res\n\n            set res [r zrandmember myzset -1001]\n            assert_equal [llength $res] 1001\n            check_member $mydict $res\n\n            # again with WITHSCORES\n            set res [r zrandmember myzset -20 withscores]\n            assert_equal [llength $res] 40\n            check_member_and_score $mydict $res\n\n            set res [r zrandmember myzset -1001 withscores]\n            assert_equal [llength $res] 2002\n            check_member_and_score $mydict $res\n\n            # Test random uniform distribution\n            # df = 9, 40 means 0.00001 probability\n            set res [r zrandmember myzset -1000]\n            assert_lessthan [chi_square_value $res] 40\n            check_member $mydict $res\n\n            # 3) Check that eventually all the elements are returned.\n            #    Use both WITHSCORES and without\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                if {[expr {$iterations % 2}] == 0} {\n                    set res [r zrandmember myzset -3 withscores]\n                    foreach {key val} $res {\n                        dict append auxset $key $val\n                    }\n                } else {\n                    set res [r zrandmember myzset -3]\n                    foreach key $res {\n                        dict append auxset $key\n                    }\n                }\n                if {[lsort [dict keys $mydict]] eq\n                    [lsort [dict keys $auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {10 20} {\n                set res [r zrandmember myzset $size]\n                assert_equal [llength $res] 10\n                assert_equal [lsort $res] [lsort [dict keys $mydict]]\n                check_member $mydict $res\n\n                # again with WITHSCORES\n                set res [r zrandmember myzset $size withscores]\n                assert_equal [llength $res] 20\n                assert_equal [lsort $res] [lsort $mydict]\n                check_member_and_score $mydict $res\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n            foreach size {1 2 8} {\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                set res [r zrandmember myzset $size]\n                assert_equal [llength $res] $size\n                check_member $mydict $res\n\n                # again with WITHSCORES\n                set res [r zrandmember myzset $size withscores]\n                assert_equal [llength $res] [expr {$size * 2}]\n                check_member_and_score $mydict $res\n\n                # 2) Check that eventually all the elements are returned.\n                #    Use both WITHSCORES and without\n                unset -nocomplain auxset\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                set all_ele_return false\n                while {$iterations != 0} {\n                    incr iterations -1\n                    if {[expr {$iterations % 2}] == 0} {\n                        set res [r zrandmember myzset $size withscores]\n                        foreach {key value} $res {\n                            dict append auxset $key $value\n                            lappend allkey $key\n                        }\n                    } else {\n                        set res [r zrandmember myzset $size]\n                        foreach key $res {\n                            dict append auxset $key\n                            lappend allkey $key\n                        }\n                    }\n                    if {[lsort [dict keys $mydict]] eq\n                        [lsort [dict keys $auxset]]} {\n                        set all_ele_return true\n                    }\n                }\n                assert_equal $all_ele_return true\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n        r config set zset-max-ziplist-value $original_max_value\n    }\n\n    test {zset score double range} {\n        set dblmax 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000000000000\n        r del zz\n        r zadd zz $dblmax dblmax\n        assert_encoding listpack zz\n        r zscore zz dblmax\n    } {1.7976931348623157e+308}\n\n}\n"], "filenames": ["src/t_hash.c", "src/t_set.c", "src/t_zset.c", "tests/unit/type/hash.tcl", "tests/unit/type/set.tcl", "tests/unit/type/zset.tcl"], "buggy_code_start_loc": [1123, 668, 4292, 76, 645, 2305], "buggy_code_end_loc": [1130, 669, 4299, 76, 645, 2305], "fixing_code_start_loc": [1123, 668, 4292, 77, 646, 2306], "fixing_code_end_loc": [1130, 669, 4299, 79, 651, 2308], "type": "CWE-190", "message": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands can trigger an integer overflow, resulting in a runtime assertion and termination of the Redis server process. This problem affects all Redis versions. Patches were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.", "other": {"cve": {"id": "CVE-2023-25155", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-02T04:15:10.807", "lastModified": "2023-03-10T05:02:32.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands can trigger an integer overflow, resulting in a runtime assertion and termination of the Redis server process. This problem affects all Redis versions. Patches were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.18", "matchCriteriaId": "6F70AB47-0452-4438-87FC-6CBD440815EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.11", "matchCriteriaId": "F953DA13-66E1-4983-9744-F861931E8628"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.9", "matchCriteriaId": "BB0A4E48-9EF2-4F32-B72C-7F243EC31DB2"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/releases/tag/6.0.18", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/redis/redis/releases/tag/6.2.11", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/redis/redis/releases/tag/7.0.9", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-x2r7-j9vw-3w83", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619"}}