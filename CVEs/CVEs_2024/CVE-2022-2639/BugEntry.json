{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2007-2017 Nicira, Inc.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"flow.h\"\n#include \"datapath.h\"\n#include <linux/uaccess.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <net/llc_pdu.h>\n#include <linux/kernel.h>\n#include <linux/jhash.h>\n#include <linux/jiffies.h>\n#include <linux/llc.h>\n#include <linux/module.h>\n#include <linux/in.h>\n#include <linux/rcupdate.h>\n#include <linux/if_arp.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/sctp.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/rculist.h>\n#include <net/geneve.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/mpls.h>\n#include <net/vxlan.h>\n#include <net/tun_proto.h>\n#include <net/erspan.h>\n\n#include \"flow_netlink.h\"\n\nstruct ovs_len_tbl {\n\tint len;\n\tconst struct ovs_len_tbl *next;\n};\n\n#define OVS_ATTR_NESTED -1\n#define OVS_ATTR_VARIABLE -2\n\nstatic bool actions_may_change_flow(const struct nlattr *actions)\n{\n\tstruct nlattr *nla;\n\tint rem;\n\n\tnla_for_each_nested(nla, actions, rem) {\n\t\tu16 action = nla_type(nla);\n\n\t\tswitch (action) {\n\t\tcase OVS_ACTION_ATTR_OUTPUT:\n\t\tcase OVS_ACTION_ATTR_RECIRC:\n\t\tcase OVS_ACTION_ATTR_TRUNC:\n\t\tcase OVS_ACTION_ATTR_USERSPACE:\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\tcase OVS_ACTION_ATTR_CT_CLEAR:\n\t\tcase OVS_ACTION_ATTR_HASH:\n\t\tcase OVS_ACTION_ATTR_POP_ETH:\n\t\tcase OVS_ACTION_ATTR_POP_MPLS:\n\t\tcase OVS_ACTION_ATTR_POP_NSH:\n\t\tcase OVS_ACTION_ATTR_POP_VLAN:\n\t\tcase OVS_ACTION_ATTR_PUSH_ETH:\n\t\tcase OVS_ACTION_ATTR_PUSH_MPLS:\n\t\tcase OVS_ACTION_ATTR_PUSH_NSH:\n\t\tcase OVS_ACTION_ATTR_PUSH_VLAN:\n\t\tcase OVS_ACTION_ATTR_SAMPLE:\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\tcase OVS_ACTION_ATTR_SET_MASKED:\n\t\tcase OVS_ACTION_ATTR_METER:\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN:\n\t\tcase OVS_ACTION_ATTR_ADD_MPLS:\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void update_range(struct sw_flow_match *match,\n\t\t\t size_t offset, size_t size, bool is_mask)\n{\n\tstruct sw_flow_key_range *range;\n\tsize_t start = rounddown(offset, sizeof(long));\n\tsize_t end = roundup(offset + size, sizeof(long));\n\n\tif (!is_mask)\n\t\trange = &match->range;\n\telse\n\t\trange = &match->mask->range;\n\n\tif (range->start == range->end) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\treturn;\n\t}\n\n\tif (range->start > start)\n\t\trange->start = start;\n\n\tif (range->end < end)\n\t\trange->end = end;\n}\n\n#define SW_FLOW_KEY_PUT(match, field, value, is_mask) \\\n\tdo { \\\n\t\tupdate_range(match, offsetof(struct sw_flow_key, field),    \\\n\t\t\t     sizeof((match)->key->field), is_mask);\t    \\\n\t\tif (is_mask)\t\t\t\t\t\t    \\\n\t\t\t(match)->mask->key.field = value;\t\t    \\\n\t\telse\t\t\t\t\t\t\t    \\\n\t\t\t(match)->key->field = value;\t\t            \\\n\t} while (0)\n\n#define SW_FLOW_KEY_MEMCPY_OFFSET(match, offset, value_p, len, is_mask)\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\tupdate_range(match, offset, len, is_mask);\t\t    \\\n\t\tif (is_mask)\t\t\t\t\t\t    \\\n\t\t\tmemcpy((u8 *)&(match)->mask->key + offset, value_p, \\\n\t\t\t       len);\t\t\t\t\t   \\\n\t\telse\t\t\t\t\t\t\t    \\\n\t\t\tmemcpy((u8 *)(match)->key + offset, value_p, len);  \\\n\t} while (0)\n\n#define SW_FLOW_KEY_MEMCPY(match, field, value_p, len, is_mask)\t\t      \\\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, offsetof(struct sw_flow_key, field), \\\n\t\t\t\t  value_p, len, is_mask)\n\n#define SW_FLOW_KEY_MEMSET_FIELD(match, field, value, is_mask)\t\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\tupdate_range(match, offsetof(struct sw_flow_key, field),    \\\n\t\t\t     sizeof((match)->key->field), is_mask);\t    \\\n\t\tif (is_mask)\t\t\t\t\t\t    \\\n\t\t\tmemset((u8 *)&(match)->mask->key.field, value,      \\\n\t\t\t       sizeof((match)->mask->key.field));\t    \\\n\t\telse\t\t\t\t\t\t\t    \\\n\t\t\tmemset((u8 *)&(match)->key->field, value,           \\\n\t\t\t       sizeof((match)->key->field));                \\\n\t} while (0)\n\nstatic bool match_validate(const struct sw_flow_match *match,\n\t\t\t   u64 key_attrs, u64 mask_attrs, bool log)\n{\n\tu64 key_expected = 0;\n\tu64 mask_allowed = key_attrs;  /* At most allow all key attributes */\n\n\t/* The following mask attributes allowed only if they\n\t * pass the validation tests. */\n\tmask_allowed &= ~((1 << OVS_KEY_ATTR_IPV4)\n\t\t\t| (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4)\n\t\t\t| (1 << OVS_KEY_ATTR_IPV6)\n\t\t\t| (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6)\n\t\t\t| (1 << OVS_KEY_ATTR_TCP)\n\t\t\t| (1 << OVS_KEY_ATTR_TCP_FLAGS)\n\t\t\t| (1 << OVS_KEY_ATTR_UDP)\n\t\t\t| (1 << OVS_KEY_ATTR_SCTP)\n\t\t\t| (1 << OVS_KEY_ATTR_ICMP)\n\t\t\t| (1 << OVS_KEY_ATTR_ICMPV6)\n\t\t\t| (1 << OVS_KEY_ATTR_ARP)\n\t\t\t| (1 << OVS_KEY_ATTR_ND)\n\t\t\t| (1 << OVS_KEY_ATTR_MPLS)\n\t\t\t| (1 << OVS_KEY_ATTR_NSH));\n\n\t/* Always allowed mask fields. */\n\tmask_allowed |= ((1 << OVS_KEY_ATTR_TUNNEL)\n\t\t       | (1 << OVS_KEY_ATTR_IN_PORT)\n\t\t       | (1 << OVS_KEY_ATTR_ETHERTYPE));\n\n\t/* Check key attributes. */\n\tif (match->key->eth.type == htons(ETH_P_ARP)\n\t\t\t|| match->key->eth.type == htons(ETH_P_RARP)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_ARP;\n\t\tif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ARP;\n\t}\n\n\tif (eth_p_mpls(match->key->eth.type)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_MPLS;\n\t\tif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_MPLS;\n\t}\n\n\tif (match->key->eth.type == htons(ETH_P_IP)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_IPV4;\n\t\tif (match->mask && match->mask->key.eth.type == htons(0xffff)) {\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_IPV4;\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4;\n\t\t}\n\n\t\tif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\n\t\t\tif (match->key->ip.proto == IPPROTO_UDP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_SCTP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_TCP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff)) {\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_ICMP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_ICMP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ICMP;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (match->key->eth.type == htons(ETH_P_IPV6)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_IPV6;\n\t\tif (match->mask && match->mask->key.eth.type == htons(0xffff)) {\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_IPV6;\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6;\n\t\t}\n\n\t\tif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\n\t\t\tif (match->key->ip.proto == IPPROTO_UDP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_SCTP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_TCP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff)) {\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_ICMPV6) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_ICMPV6;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ICMPV6;\n\n\t\t\t\tif (match->key->tp.src ==\n\t\t\t\t\t\thtons(NDISC_NEIGHBOUR_SOLICITATION) ||\n\t\t\t\t    match->key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) {\n\t\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_ND;\n\t\t\t\t\t/* Original direction conntrack tuple\n\t\t\t\t\t * uses the same space as the ND fields\n\t\t\t\t\t * in the key, so both are not allowed\n\t\t\t\t\t * at the same time.\n\t\t\t\t\t */\n\t\t\t\t\tmask_allowed &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6);\n\t\t\t\t\tif (match->mask && (match->mask->key.tp.src == htons(0xff)))\n\t\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (match->key->eth.type == htons(ETH_P_NSH)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_NSH;\n\t\tif (match->mask &&\n\t\t    match->mask->key.eth.type == htons(0xffff)) {\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_NSH;\n\t\t}\n\t}\n\n\tif ((key_attrs & key_expected) != key_expected) {\n\t\t/* Key attributes check failed. */\n\t\tOVS_NLERR(log, \"Missing key (keys=%llx, expected=%llx)\",\n\t\t\t  (unsigned long long)key_attrs,\n\t\t\t  (unsigned long long)key_expected);\n\t\treturn false;\n\t}\n\n\tif ((mask_attrs & mask_allowed) != mask_attrs) {\n\t\t/* Mask attributes check failed. */\n\t\tOVS_NLERR(log, \"Unexpected mask (mask=%llx, allowed=%llx)\",\n\t\t\t  (unsigned long long)mask_attrs,\n\t\t\t  (unsigned long long)mask_allowed);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nsize_t ovs_tun_key_attr_size(void)\n{\n\t/* Whenever adding new OVS_TUNNEL_KEY_ FIELDS, we should consider\n\t * updating this function.\n\t */\n\treturn    nla_total_size_64bit(8) /* OVS_TUNNEL_KEY_ATTR_ID */\n\t\t+ nla_total_size(16)   /* OVS_TUNNEL_KEY_ATTR_IPV[46]_SRC */\n\t\t+ nla_total_size(16)   /* OVS_TUNNEL_KEY_ATTR_IPV[46]_DST */\n\t\t+ nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TOS */\n\t\t+ nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TTL */\n\t\t+ nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT */\n\t\t+ nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_CSUM */\n\t\t+ nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_OAM */\n\t\t+ nla_total_size(256)  /* OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS */\n\t\t/* OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS and\n\t\t * OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS is mutually exclusive with\n\t\t * OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS and covered by it.\n\t\t */\n\t\t+ nla_total_size(2)    /* OVS_TUNNEL_KEY_ATTR_TP_SRC */\n\t\t+ nla_total_size(2);   /* OVS_TUNNEL_KEY_ATTR_TP_DST */\n}\n\nstatic size_t ovs_nsh_key_attr_size(void)\n{\n\t/* Whenever adding new OVS_NSH_KEY_ FIELDS, we should consider\n\t * updating this function.\n\t */\n\treturn  nla_total_size(NSH_BASE_HDR_LEN) /* OVS_NSH_KEY_ATTR_BASE */\n\t\t/* OVS_NSH_KEY_ATTR_MD1 and OVS_NSH_KEY_ATTR_MD2 are\n\t\t * mutually exclusive, so the bigger one can cover\n\t\t * the small one.\n\t\t */\n\t\t+ nla_total_size(NSH_CTX_HDRS_MAX_LEN);\n}\n\nsize_t ovs_key_attr_size(void)\n{\n\t/* Whenever adding new OVS_KEY_ FIELDS, we should consider\n\t * updating this function.\n\t */\n\tBUILD_BUG_ON(OVS_KEY_ATTR_MAX != 32);\n\n\treturn    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */\n\t\t+ nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */\n\t\t  + ovs_tun_key_attr_size()\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_IN_PORT */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_STATE */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_CT_ZONE */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_MARK */\n\t\t+ nla_total_size(16)  /* OVS_KEY_ATTR_CT_LABELS */\n\t\t+ nla_total_size(40)  /* OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6 */\n\t\t+ nla_total_size(0)   /* OVS_KEY_ATTR_NSH */\n\t\t  + ovs_nsh_key_attr_size()\n\t\t+ nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */\n\t\t+ nla_total_size(0)   /* OVS_KEY_ATTR_ENCAP */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\n\t\t+ nla_total_size(40)  /* OVS_KEY_ATTR_IPV6 */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_ICMPV6 */\n\t\t+ nla_total_size(28)  /* OVS_KEY_ATTR_ND */\n\t\t+ nla_total_size(2);  /* OVS_KEY_ATTR_IPV6_EXTHDRS */\n}\n\nstatic const struct ovs_len_tbl ovs_vxlan_ext_key_lens[OVS_VXLAN_EXT_MAX + 1] = {\n\t[OVS_VXLAN_EXT_GBP]\t    = { .len = sizeof(u32) },\n};\n\nstatic const struct ovs_len_tbl ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1] = {\n\t[OVS_TUNNEL_KEY_ATTR_ID]\t    = { .len = sizeof(u64) },\n\t[OVS_TUNNEL_KEY_ATTR_IPV4_SRC]\t    = { .len = sizeof(u32) },\n\t[OVS_TUNNEL_KEY_ATTR_IPV4_DST]\t    = { .len = sizeof(u32) },\n\t[OVS_TUNNEL_KEY_ATTR_TOS]\t    = { .len = 1 },\n\t[OVS_TUNNEL_KEY_ATTR_TTL]\t    = { .len = 1 },\n\t[OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = { .len = 0 },\n\t[OVS_TUNNEL_KEY_ATTR_CSUM]\t    = { .len = 0 },\n\t[OVS_TUNNEL_KEY_ATTR_TP_SRC]\t    = { .len = sizeof(u16) },\n\t[OVS_TUNNEL_KEY_ATTR_TP_DST]\t    = { .len = sizeof(u16) },\n\t[OVS_TUNNEL_KEY_ATTR_OAM]\t    = { .len = 0 },\n\t[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = { .len = OVS_ATTR_VARIABLE },\n\t[OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = { .len = OVS_ATTR_NESTED,\n\t\t\t\t\t\t.next = ovs_vxlan_ext_key_lens },\n\t[OVS_TUNNEL_KEY_ATTR_IPV6_SRC]      = { .len = sizeof(struct in6_addr) },\n\t[OVS_TUNNEL_KEY_ATTR_IPV6_DST]      = { .len = sizeof(struct in6_addr) },\n\t[OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS]   = { .len = OVS_ATTR_VARIABLE },\n\t[OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE]   = { .len = 0 },\n};\n\nstatic const struct ovs_len_tbl\novs_nsh_key_attr_lens[OVS_NSH_KEY_ATTR_MAX + 1] = {\n\t[OVS_NSH_KEY_ATTR_BASE] = { .len = sizeof(struct ovs_nsh_key_base) },\n\t[OVS_NSH_KEY_ATTR_MD1]  = { .len = sizeof(struct ovs_nsh_key_md1) },\n\t[OVS_NSH_KEY_ATTR_MD2]  = { .len = OVS_ATTR_VARIABLE },\n};\n\n/* The size of the argument for each %OVS_KEY_ATTR_* Netlink attribute.  */\nstatic const struct ovs_len_tbl ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {\n\t[OVS_KEY_ATTR_ENCAP]\t = { .len = OVS_ATTR_NESTED },\n\t[OVS_KEY_ATTR_PRIORITY]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_IN_PORT]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_SKB_MARK]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_ETHERNET]\t = { .len = sizeof(struct ovs_key_ethernet) },\n\t[OVS_KEY_ATTR_VLAN]\t = { .len = sizeof(__be16) },\n\t[OVS_KEY_ATTR_ETHERTYPE] = { .len = sizeof(__be16) },\n\t[OVS_KEY_ATTR_IPV4]\t = { .len = sizeof(struct ovs_key_ipv4) },\n\t[OVS_KEY_ATTR_IPV6]\t = { .len = sizeof(struct ovs_key_ipv6) },\n\t[OVS_KEY_ATTR_TCP]\t = { .len = sizeof(struct ovs_key_tcp) },\n\t[OVS_KEY_ATTR_TCP_FLAGS] = { .len = sizeof(__be16) },\n\t[OVS_KEY_ATTR_UDP]\t = { .len = sizeof(struct ovs_key_udp) },\n\t[OVS_KEY_ATTR_SCTP]\t = { .len = sizeof(struct ovs_key_sctp) },\n\t[OVS_KEY_ATTR_ICMP]\t = { .len = sizeof(struct ovs_key_icmp) },\n\t[OVS_KEY_ATTR_ICMPV6]\t = { .len = sizeof(struct ovs_key_icmpv6) },\n\t[OVS_KEY_ATTR_ARP]\t = { .len = sizeof(struct ovs_key_arp) },\n\t[OVS_KEY_ATTR_ND]\t = { .len = sizeof(struct ovs_key_nd) },\n\t[OVS_KEY_ATTR_RECIRC_ID] = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_DP_HASH]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_TUNNEL]\t = { .len = OVS_ATTR_NESTED,\n\t\t\t\t     .next = ovs_tunnel_key_lens, },\n\t[OVS_KEY_ATTR_MPLS]\t = { .len = OVS_ATTR_VARIABLE },\n\t[OVS_KEY_ATTR_CT_STATE]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_CT_ZONE]\t = { .len = sizeof(u16) },\n\t[OVS_KEY_ATTR_CT_MARK]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_CT_LABELS] = { .len = sizeof(struct ovs_key_ct_labels) },\n\t[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4] = {\n\t\t.len = sizeof(struct ovs_key_ct_tuple_ipv4) },\n\t[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6] = {\n\t\t.len = sizeof(struct ovs_key_ct_tuple_ipv6) },\n\t[OVS_KEY_ATTR_NSH]       = { .len = OVS_ATTR_NESTED,\n\t\t\t\t     .next = ovs_nsh_key_attr_lens, },\n\t[OVS_KEY_ATTR_IPV6_EXTHDRS] = {\n\t\t.len = sizeof(struct ovs_key_ipv6_exthdrs) },\n};\n\nstatic bool check_attr_len(unsigned int attr_len, unsigned int expected_len)\n{\n\treturn expected_len == attr_len ||\n\t       expected_len == OVS_ATTR_NESTED ||\n\t       expected_len == OVS_ATTR_VARIABLE;\n}\n\nstatic bool is_all_zero(const u8 *fp, size_t size)\n{\n\tint i;\n\n\tif (!fp)\n\t\treturn false;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (fp[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int __parse_flow_nlattrs(const struct nlattr *attr,\n\t\t\t\tconst struct nlattr *a[],\n\t\t\t\tu64 *attrsp, bool log, bool nz)\n{\n\tconst struct nlattr *nla;\n\tu64 attrs;\n\tint rem;\n\n\tattrs = *attrsp;\n\tnla_for_each_nested(nla, attr, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tint expected_len;\n\n\t\tif (type > OVS_KEY_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"Key type %d is out of range max %d\",\n\t\t\t\t  type, OVS_KEY_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (type == OVS_KEY_ATTR_PACKET_TYPE ||\n\t\t    type == OVS_KEY_ATTR_ND_EXTENSIONS ||\n\t\t    type == OVS_KEY_ATTR_TUNNEL_INFO) {\n\t\t\tOVS_NLERR(log, \"Key type %d is not supported\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (attrs & (1ULL << type)) {\n\t\t\tOVS_NLERR(log, \"Duplicate key (type %d).\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\texpected_len = ovs_key_lens[type].len;\n\t\tif (!check_attr_len(nla_len(nla), expected_len)) {\n\t\t\tOVS_NLERR(log, \"Key %d has unexpected len %d expected %d\",\n\t\t\t\t  type, nla_len(nla), expected_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!nz || !is_all_zero(nla_data(nla), nla_len(nla))) {\n\t\t\tattrs |= 1ULL << type;\n\t\t\ta[type] = nla;\n\t\t}\n\t}\n\tif (rem) {\n\t\tOVS_NLERR(log, \"Message has %d unknown bytes.\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\t*attrsp = attrs;\n\treturn 0;\n}\n\nstatic int parse_flow_mask_nlattrs(const struct nlattr *attr,\n\t\t\t\t   const struct nlattr *a[], u64 *attrsp,\n\t\t\t\t   bool log)\n{\n\treturn __parse_flow_nlattrs(attr, a, attrsp, log, true);\n}\n\nint parse_flow_nlattrs(const struct nlattr *attr, const struct nlattr *a[],\n\t\t       u64 *attrsp, bool log)\n{\n\treturn __parse_flow_nlattrs(attr, a, attrsp, log, false);\n}\n\nstatic int genev_tun_opt_from_nlattr(const struct nlattr *a,\n\t\t\t\t     struct sw_flow_match *match, bool is_mask,\n\t\t\t\t     bool log)\n{\n\tunsigned long opt_key_offset;\n\n\tif (nla_len(a) > sizeof(match->key->tun_opts)) {\n\t\tOVS_NLERR(log, \"Geneve option length err (len %d, max %zu).\",\n\t\t\t  nla_len(a), sizeof(match->key->tun_opts));\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_len(a) % 4 != 0) {\n\t\tOVS_NLERR(log, \"Geneve opt len %d is not a multiple of 4.\",\n\t\t\t  nla_len(a));\n\t\treturn -EINVAL;\n\t}\n\n\t/* We need to record the length of the options passed\n\t * down, otherwise packets with the same format but\n\t * additional options will be silently matched.\n\t */\n\tif (!is_mask) {\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),\n\t\t\t\tfalse);\n\t} else {\n\t\t/* This is somewhat unusual because it looks at\n\t\t * both the key and mask while parsing the\n\t\t * attributes (and by extension assumes the key\n\t\t * is parsed first). Normally, we would verify\n\t\t * that each is the correct length and that the\n\t\t * attributes line up in the validate function.\n\t\t * However, that is difficult because this is\n\t\t * variable length and we won't have the\n\t\t * information later.\n\t\t */\n\t\tif (match->key->tun_opts_len != nla_len(a)) {\n\t\t\tOVS_NLERR(log, \"Geneve option len %d != mask len %d\",\n\t\t\t\t  match->key->tun_opts_len, nla_len(a));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\n\t}\n\n\topt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\n\t\t\t\t  nla_len(a), is_mask);\n\treturn 0;\n}\n\nstatic int vxlan_tun_opt_from_nlattr(const struct nlattr *attr,\n\t\t\t\t     struct sw_flow_match *match, bool is_mask,\n\t\t\t\t     bool log)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tunsigned long opt_key_offset;\n\tstruct vxlan_metadata opts;\n\n\tBUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));\n\n\tmemset(&opts, 0, sizeof(opts));\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\tif (type > OVS_VXLAN_EXT_MAX) {\n\t\t\tOVS_NLERR(log, \"VXLAN extension %d out of range max %d\",\n\t\t\t\t  type, OVS_VXLAN_EXT_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!check_attr_len(nla_len(a),\n\t\t\t\t    ovs_vxlan_ext_key_lens[type].len)) {\n\t\t\tOVS_NLERR(log, \"VXLAN extension %d has unexpected len %d expected %d\",\n\t\t\t\t  type, nla_len(a),\n\t\t\t\t  ovs_vxlan_ext_key_lens[type].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_VXLAN_EXT_GBP:\n\t\t\topts.gbp = nla_get_u32(a);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown VXLAN extension attribute %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (rem) {\n\t\tOVS_NLERR(log, \"VXLAN extension message has %d unknown bytes.\",\n\t\t\t  rem);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask)\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false);\n\telse\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\n\n\topt_key_offset = TUN_METADATA_OFFSET(sizeof(opts));\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts),\n\t\t\t\t  is_mask);\n\treturn 0;\n}\n\nstatic int erspan_tun_opt_from_nlattr(const struct nlattr *a,\n\t\t\t\t      struct sw_flow_match *match, bool is_mask,\n\t\t\t\t      bool log)\n{\n\tunsigned long opt_key_offset;\n\n\tBUILD_BUG_ON(sizeof(struct erspan_metadata) >\n\t\t     sizeof(match->key->tun_opts));\n\n\tif (nla_len(a) > sizeof(match->key->tun_opts)) {\n\t\tOVS_NLERR(log, \"ERSPAN option length err (len %d, max %zu).\",\n\t\t\t  nla_len(a), sizeof(match->key->tun_opts));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask)\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len,\n\t\t\t\tsizeof(struct erspan_metadata), false);\n\telse\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\n\n\topt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\n\t\t\t\t  nla_len(a), is_mask);\n\treturn 0;\n}\n\nstatic int ip_tun_from_nlattr(const struct nlattr *attr,\n\t\t\t      struct sw_flow_match *match, bool is_mask,\n\t\t\t      bool log)\n{\n\tbool ttl = false, ipv4 = false, ipv6 = false;\n\tbool info_bridge_mode = false;\n\t__be16 tun_flags = 0;\n\tint opts_type = 0;\n\tstruct nlattr *a;\n\tint rem;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tint err;\n\n\t\tif (type > OVS_TUNNEL_KEY_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"Tunnel attr %d out of range max %d\",\n\t\t\t\t  type, OVS_TUNNEL_KEY_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!check_attr_len(nla_len(a),\n\t\t\t\t    ovs_tunnel_key_lens[type].len)) {\n\t\t\tOVS_NLERR(log, \"Tunnel attr %d has unexpected len %d expected %d\",\n\t\t\t\t  type, nla_len(a), ovs_tunnel_key_lens[type].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_TUNNEL_KEY_ATTR_ID:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tun_id,\n\t\t\t\t\tnla_get_be64(a), is_mask);\n\t\t\ttun_flags |= TUNNEL_KEY;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV4_SRC:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv4.src,\n\t\t\t\t\tnla_get_in_addr(a), is_mask);\n\t\t\tipv4 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV4_DST:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv4.dst,\n\t\t\t\t\tnla_get_in_addr(a), is_mask);\n\t\t\tipv4 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV6_SRC:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv6.src,\n\t\t\t\t\tnla_get_in6_addr(a), is_mask);\n\t\t\tipv6 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV6_DST:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,\n\t\t\t\t\tnla_get_in6_addr(a), is_mask);\n\t\t\tipv6 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TOS:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tos,\n\t\t\t\t\tnla_get_u8(a), is_mask);\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TTL:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.ttl,\n\t\t\t\t\tnla_get_u8(a), is_mask);\n\t\t\tttl = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT:\n\t\t\ttun_flags |= TUNNEL_DONT_FRAGMENT;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_CSUM:\n\t\t\ttun_flags |= TUNNEL_CSUM;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TP_SRC:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tp_src,\n\t\t\t\t\tnla_get_be16(a), is_mask);\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TP_DST:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tp_dst,\n\t\t\t\t\tnla_get_be16(a), is_mask);\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_OAM:\n\t\t\ttun_flags |= TUNNEL_OAM;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\n\t\t\tif (opts_type) {\n\t\t\t\tOVS_NLERR(log, \"Multiple metadata blocks provided\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = genev_tun_opt_from_nlattr(a, match, is_mask, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttun_flags |= TUNNEL_GENEVE_OPT;\n\t\t\topts_type = type;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\n\t\t\tif (opts_type) {\n\t\t\t\tOVS_NLERR(log, \"Multiple metadata blocks provided\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = vxlan_tun_opt_from_nlattr(a, match, is_mask, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttun_flags |= TUNNEL_VXLAN_OPT;\n\t\t\topts_type = type;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_PAD:\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS:\n\t\t\tif (opts_type) {\n\t\t\t\tOVS_NLERR(log, \"Multiple metadata blocks provided\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = erspan_tun_opt_from_nlattr(a, match, is_mask,\n\t\t\t\t\t\t\t log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttun_flags |= TUNNEL_ERSPAN_OPT;\n\t\t\topts_type = type;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE:\n\t\t\tinfo_bridge_mode = true;\n\t\t\tipv4 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown IP tunnel attribute %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tSW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);\n\tif (is_mask)\n\t\tSW_FLOW_KEY_MEMSET_FIELD(match, tun_proto, 0xff, true);\n\telse\n\t\tSW_FLOW_KEY_PUT(match, tun_proto, ipv6 ? AF_INET6 : AF_INET,\n\t\t\t\tfalse);\n\n\tif (rem > 0) {\n\t\tOVS_NLERR(log, \"IP tunnel attribute has %d unknown bytes.\",\n\t\t\t  rem);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ipv4 && ipv6) {\n\t\tOVS_NLERR(log, \"Mixed IPv4 and IPv6 tunnel attributes\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask) {\n\t\tif (!ipv4 && !ipv6) {\n\t\t\tOVS_NLERR(log, \"IP tunnel dst address not specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ipv4) {\n\t\t\tif (info_bridge_mode) {\n\t\t\t\tif (match->key->tun_key.u.ipv4.src ||\n\t\t\t\t    match->key->tun_key.u.ipv4.dst ||\n\t\t\t\t    match->key->tun_key.tp_src ||\n\t\t\t\t    match->key->tun_key.tp_dst ||\n\t\t\t\t    match->key->tun_key.ttl ||\n\t\t\t\t    match->key->tun_key.tos ||\n\t\t\t\t    tun_flags & ~TUNNEL_KEY) {\n\t\t\t\t\tOVS_NLERR(log, \"IPv4 tun info is not correct\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else if (!match->key->tun_key.u.ipv4.dst) {\n\t\t\t\tOVS_NLERR(log, \"IPv4 tunnel dst address is zero\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (ipv6 && ipv6_addr_any(&match->key->tun_key.u.ipv6.dst)) {\n\t\t\tOVS_NLERR(log, \"IPv6 tunnel dst address is zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ttl && !info_bridge_mode) {\n\t\t\tOVS_NLERR(log, \"IP tunnel TTL not specified.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn opts_type;\n}\n\nstatic int vxlan_opt_to_nlattr(struct sk_buff *skb,\n\t\t\t       const void *tun_opts, int swkey_tun_opts_len)\n{\n\tconst struct vxlan_metadata *opts = tun_opts;\n\tstruct nlattr *nla;\n\n\tnla = nla_nest_start_noflag(skb, OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, OVS_VXLAN_EXT_GBP, opts->gbp) < 0)\n\t\treturn -EMSGSIZE;\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\nstatic int __ip_tun_to_nlattr(struct sk_buff *skb,\n\t\t\t      const struct ip_tunnel_key *output,\n\t\t\t      const void *tun_opts, int swkey_tun_opts_len,\n\t\t\t      unsigned short tun_proto, u8 mode)\n{\n\tif (output->tun_flags & TUNNEL_KEY &&\n\t    nla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id,\n\t\t\t OVS_TUNNEL_KEY_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (mode & IP_TUNNEL_INFO_BRIDGE)\n\t\treturn nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE)\n\t\t       ? -EMSGSIZE : 0;\n\n\tswitch (tun_proto) {\n\tcase AF_INET:\n\t\tif (output->u.ipv4.src &&\n\t\t    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC,\n\t\t\t\t    output->u.ipv4.src))\n\t\t\treturn -EMSGSIZE;\n\t\tif (output->u.ipv4.dst &&\n\t\t    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST,\n\t\t\t\t    output->u.ipv4.dst))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!ipv6_addr_any(&output->u.ipv6.src) &&\n\t\t    nla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_SRC,\n\t\t\t\t     &output->u.ipv6.src))\n\t\t\treturn -EMSGSIZE;\n\t\tif (!ipv6_addr_any(&output->u.ipv6.dst) &&\n\t\t    nla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_DST,\n\t\t\t\t     &output->u.ipv6.dst))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n\tif (output->tos &&\n\t    nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->tos))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ttl))\n\t\treturn -EMSGSIZE;\n\tif ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&\n\t    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\n\t\treturn -EMSGSIZE;\n\tif ((output->tun_flags & TUNNEL_CSUM) &&\n\t    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_CSUM))\n\t\treturn -EMSGSIZE;\n\tif (output->tp_src &&\n\t    nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_SRC, output->tp_src))\n\t\treturn -EMSGSIZE;\n\tif (output->tp_dst &&\n\t    nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_DST, output->tp_dst))\n\t\treturn -EMSGSIZE;\n\tif ((output->tun_flags & TUNNEL_OAM) &&\n\t    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_OAM))\n\t\treturn -EMSGSIZE;\n\tif (swkey_tun_opts_len) {\n\t\tif (output->tun_flags & TUNNEL_GENEVE_OPT &&\n\t\t    nla_put(skb, OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,\n\t\t\t    swkey_tun_opts_len, tun_opts))\n\t\t\treturn -EMSGSIZE;\n\t\telse if (output->tun_flags & TUNNEL_VXLAN_OPT &&\n\t\t\t vxlan_opt_to_nlattr(skb, tun_opts, swkey_tun_opts_len))\n\t\t\treturn -EMSGSIZE;\n\t\telse if (output->tun_flags & TUNNEL_ERSPAN_OPT &&\n\t\t\t nla_put(skb, OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS,\n\t\t\t\t swkey_tun_opts_len, tun_opts))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip_tun_to_nlattr(struct sk_buff *skb,\n\t\t\t    const struct ip_tunnel_key *output,\n\t\t\t    const void *tun_opts, int swkey_tun_opts_len,\n\t\t\t    unsigned short tun_proto, u8 mode)\n{\n\tstruct nlattr *nla;\n\tint err;\n\n\tnla = nla_nest_start_noflag(skb, OVS_KEY_ATTR_TUNNEL);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\terr = __ip_tun_to_nlattr(skb, output, tun_opts, swkey_tun_opts_len,\n\t\t\t\t tun_proto, mode);\n\tif (err)\n\t\treturn err;\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\nint ovs_nla_put_tunnel_info(struct sk_buff *skb,\n\t\t\t    struct ip_tunnel_info *tun_info)\n{\n\treturn __ip_tun_to_nlattr(skb, &tun_info->key,\n\t\t\t\t  ip_tunnel_info_opts(tun_info),\n\t\t\t\t  tun_info->options_len,\n\t\t\t\t  ip_tunnel_info_af(tun_info), tun_info->mode);\n}\n\nstatic int encode_vlan_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t    const struct nlattr *a[],\n\t\t\t\t    bool is_mask, bool inner)\n{\n\t__be16 tci = 0;\n\t__be16 tpid = 0;\n\n\tif (a[OVS_KEY_ATTR_VLAN])\n\t\ttci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\n\n\tif (a[OVS_KEY_ATTR_ETHERTYPE])\n\t\ttpid = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\n\n\tif (likely(!inner)) {\n\t\tSW_FLOW_KEY_PUT(match, eth.vlan.tpid, tpid, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, eth.vlan.tci, tci, is_mask);\n\t} else {\n\t\tSW_FLOW_KEY_PUT(match, eth.cvlan.tpid, tpid, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, eth.cvlan.tci, tci, is_mask);\n\t}\n\treturn 0;\n}\n\nstatic int validate_vlan_from_nlattrs(const struct sw_flow_match *match,\n\t\t\t\t      u64 key_attrs, bool inner,\n\t\t\t\t      const struct nlattr **a, bool log)\n{\n\t__be16 tci = 0;\n\n\tif (!((key_attrs & (1 << OVS_KEY_ATTR_ETHERNET)) &&\n\t      (key_attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) &&\n\t       eth_type_vlan(nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE])))) {\n\t\t/* Not a VLAN. */\n\t\treturn 0;\n\t}\n\n\tif (!((key_attrs & (1 << OVS_KEY_ATTR_VLAN)) &&\n\t      (key_attrs & (1 << OVS_KEY_ATTR_ENCAP)))) {\n\t\tOVS_NLERR(log, \"Invalid %s frame\", (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (a[OVS_KEY_ATTR_VLAN])\n\t\ttci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\n\n\tif (!(tci & htons(VLAN_CFI_MASK))) {\n\t\tif (tci) {\n\t\t\tOVS_NLERR(log, \"%s TCI does not have VLAN_CFI_MASK bit set.\",\n\t\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\t\treturn -EINVAL;\n\t\t} else if (nla_len(a[OVS_KEY_ATTR_ENCAP])) {\n\t\t\t/* Corner case for truncated VLAN header. */\n\t\t\tOVS_NLERR(log, \"Truncated %s header has non-zero encap attribute.\",\n\t\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int validate_vlan_mask_from_nlattrs(const struct sw_flow_match *match,\n\t\t\t\t\t   u64 key_attrs, bool inner,\n\t\t\t\t\t   const struct nlattr **a, bool log)\n{\n\t__be16 tci = 0;\n\t__be16 tpid = 0;\n\tbool encap_valid = !!(match->key->eth.vlan.tci &\n\t\t\t      htons(VLAN_CFI_MASK));\n\tbool i_encap_valid = !!(match->key->eth.cvlan.tci &\n\t\t\t\thtons(VLAN_CFI_MASK));\n\n\tif (!(key_attrs & (1 << OVS_KEY_ATTR_ENCAP))) {\n\t\t/* Not a VLAN. */\n\t\treturn 0;\n\t}\n\n\tif ((!inner && !encap_valid) || (inner && !i_encap_valid)) {\n\t\tOVS_NLERR(log, \"Encap mask attribute is set for non-%s frame.\",\n\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (a[OVS_KEY_ATTR_VLAN])\n\t\ttci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\n\n\tif (a[OVS_KEY_ATTR_ETHERTYPE])\n\t\ttpid = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\n\n\tif (tpid != htons(0xffff)) {\n\t\tOVS_NLERR(log, \"Must have an exact match on %s TPID (mask=%x).\",\n\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\", ntohs(tpid));\n\t\treturn -EINVAL;\n\t}\n\tif (!(tci & htons(VLAN_CFI_MASK))) {\n\t\tOVS_NLERR(log, \"%s TCI mask does not have exact match for VLAN_CFI_MASK bit.\",\n\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\nstatic int __parse_vlan_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t     u64 *key_attrs, bool inner,\n\t\t\t\t     const struct nlattr **a, bool is_mask,\n\t\t\t\t     bool log)\n{\n\tint err;\n\tconst struct nlattr *encap;\n\n\tif (!is_mask)\n\t\terr = validate_vlan_from_nlattrs(match, *key_attrs, inner,\n\t\t\t\t\t\t a, log);\n\telse\n\t\terr = validate_vlan_mask_from_nlattrs(match, *key_attrs, inner,\n\t\t\t\t\t\t      a, log);\n\tif (err <= 0)\n\t\treturn err;\n\n\terr = encode_vlan_from_nlattrs(match, a, is_mask, inner);\n\tif (err)\n\t\treturn err;\n\n\t*key_attrs &= ~(1 << OVS_KEY_ATTR_ENCAP);\n\t*key_attrs &= ~(1 << OVS_KEY_ATTR_VLAN);\n\t*key_attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\n\n\tencap = a[OVS_KEY_ATTR_ENCAP];\n\n\tif (!is_mask)\n\t\terr = parse_flow_nlattrs(encap, a, key_attrs, log);\n\telse\n\t\terr = parse_flow_mask_nlattrs(encap, a, key_attrs, log);\n\n\treturn err;\n}\n\nstatic int parse_vlan_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t   u64 *key_attrs, const struct nlattr **a,\n\t\t\t\t   bool is_mask, bool log)\n{\n\tint err;\n\tbool encap_valid = false;\n\n\terr = __parse_vlan_from_nlattrs(match, key_attrs, false, a,\n\t\t\t\t\tis_mask, log);\n\tif (err)\n\t\treturn err;\n\n\tencap_valid = !!(match->key->eth.vlan.tci & htons(VLAN_CFI_MASK));\n\tif (encap_valid) {\n\t\terr = __parse_vlan_from_nlattrs(match, key_attrs, true, a,\n\t\t\t\t\t\tis_mask, log);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_eth_type_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t       u64 *attrs, const struct nlattr **a,\n\t\t\t\t       bool is_mask, bool log)\n{\n\t__be16 eth_type;\n\n\teth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\n\tif (is_mask) {\n\t\t/* Always exact match EtherType. */\n\t\teth_type = htons(0xffff);\n\t} else if (!eth_proto_is_802_3(eth_type)) {\n\t\tOVS_NLERR(log, \"EtherType %x is less than min %x\",\n\t\t\t\tntohs(eth_type), ETH_P_802_3_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\tSW_FLOW_KEY_PUT(match, eth.type, eth_type, is_mask);\n\t*attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\n\treturn 0;\n}\n\nstatic int metadata_from_nlattrs(struct net *net, struct sw_flow_match *match,\n\t\t\t\t u64 *attrs, const struct nlattr **a,\n\t\t\t\t bool is_mask, bool log)\n{\n\tu8 mac_proto = MAC_PROTO_ETHERNET;\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_DP_HASH)) {\n\t\tu32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);\n\n\t\tSW_FLOW_KEY_PUT(match, ovs_flow_hash, hash_val, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_DP_HASH);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_RECIRC_ID)) {\n\t\tu32 recirc_id = nla_get_u32(a[OVS_KEY_ATTR_RECIRC_ID]);\n\n\t\tSW_FLOW_KEY_PUT(match, recirc_id, recirc_id, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_RECIRC_ID);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_PRIORITY)) {\n\t\tSW_FLOW_KEY_PUT(match, phy.priority,\n\t\t\t  nla_get_u32(a[OVS_KEY_ATTR_PRIORITY]), is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_PRIORITY);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_IN_PORT)) {\n\t\tu32 in_port = nla_get_u32(a[OVS_KEY_ATTR_IN_PORT]);\n\n\t\tif (is_mask) {\n\t\t\tin_port = 0xffffffff; /* Always exact match in_port. */\n\t\t} else if (in_port >= DP_MAX_PORTS) {\n\t\t\tOVS_NLERR(log, \"Port %d exceeds max allowable %d\",\n\t\t\t\t  in_port, DP_MAX_PORTS);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, phy.in_port, in_port, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_IN_PORT);\n\t} else if (!is_mask) {\n\t\tSW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_SKB_MARK)) {\n\t\tuint32_t mark = nla_get_u32(a[OVS_KEY_ATTR_SKB_MARK]);\n\n\t\tSW_FLOW_KEY_PUT(match, phy.skb_mark, mark, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_SKB_MARK);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_TUNNEL)) {\n\t\tif (ip_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,\n\t\t\t\t       is_mask, log) < 0)\n\t\t\treturn -EINVAL;\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_STATE)) {\n\t\tu32 ct_state = nla_get_u32(a[OVS_KEY_ATTR_CT_STATE]);\n\n\t\tif (ct_state & ~CT_SUPPORTED_MASK) {\n\t\t\tOVS_NLERR(log, \"ct_state flags %08x unsupported\",\n\t\t\t\t  ct_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, ct_state, ct_state, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_ZONE)) {\n\t\tu16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);\n\n\t\tSW_FLOW_KEY_PUT(match, ct_zone, ct_zone, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_MARK)) {\n\t\tu32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);\n\n\t\tSW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_LABELS) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_LABELS)) {\n\t\tconst struct ovs_key_ct_labels *cl;\n\n\t\tcl = nla_data(a[OVS_KEY_ATTR_CT_LABELS]);\n\t\tSW_FLOW_KEY_MEMCPY(match, ct.labels, cl->ct_labels,\n\t\t\t\t   sizeof(*cl), is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);\n\t}\n\tif (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4)) {\n\t\tconst struct ovs_key_ct_tuple_ipv4 *ct;\n\n\t\tct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4]);\n\n\t\tSW_FLOW_KEY_PUT(match, ipv4.ct_orig.src, ct->ipv4_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.ct_orig.dst, ct->ipv4_dst, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct_orig_proto, ct->ipv4_proto, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4);\n\t}\n\tif (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6)) {\n\t\tconst struct ovs_key_ct_tuple_ipv6 *ct;\n\n\t\tct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6]);\n\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.src, &ct->ipv6_src,\n\t\t\t\t   sizeof(match->key->ipv6.ct_orig.src),\n\t\t\t\t   is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.dst, &ct->ipv6_dst,\n\t\t\t\t   sizeof(match->key->ipv6.ct_orig.dst),\n\t\t\t\t   is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct_orig_proto, ct->ipv6_proto, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6);\n\t}\n\n\t/* For layer 3 packets the Ethernet type is provided\n\t * and treated as metadata but no MAC addresses are provided.\n\t */\n\tif (!(*attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&\n\t    (*attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)))\n\t\tmac_proto = MAC_PROTO_NONE;\n\n\t/* Always exact match mac_proto */\n\tSW_FLOW_KEY_PUT(match, mac_proto, is_mask ? 0xff : mac_proto, is_mask);\n\n\tif (mac_proto == MAC_PROTO_NONE)\n\t\treturn parse_eth_type_from_nlattrs(match, attrs, a, is_mask,\n\t\t\t\t\t\t   log);\n\n\treturn 0;\n}\n\nint nsh_hdr_from_nlattr(const struct nlattr *attr,\n\t\t\tstruct nshhdr *nh, size_t size)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tu8 flags = 0;\n\tu8 ttl = 0;\n\tint mdlen = 0;\n\n\t/* validate_nsh has check this, so we needn't do duplicate check here\n\t */\n\tif (size < NSH_BASE_HDR_LEN)\n\t\treturn -ENOBUFS;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\tswitch (type) {\n\t\tcase OVS_NSH_KEY_ATTR_BASE: {\n\t\t\tconst struct ovs_nsh_key_base *base = nla_data(a);\n\n\t\t\tflags = base->flags;\n\t\t\tttl = base->ttl;\n\t\t\tnh->np = base->np;\n\t\t\tnh->mdtype = base->mdtype;\n\t\t\tnh->path_hdr = base->path_hdr;\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD1:\n\t\t\tmdlen = nla_len(a);\n\t\t\tif (mdlen > size - NSH_BASE_HDR_LEN)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tmemcpy(&nh->md1, nla_data(a), mdlen);\n\t\t\tbreak;\n\n\t\tcase OVS_NSH_KEY_ATTR_MD2:\n\t\t\tmdlen = nla_len(a);\n\t\t\tif (mdlen > size - NSH_BASE_HDR_LEN)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tmemcpy(&nh->md2, nla_data(a), mdlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* nsh header length  = NSH_BASE_HDR_LEN + mdlen */\n\tnh->ver_flags_ttl_len = 0;\n\tnsh_set_flags_ttl_len(nh, flags, ttl, NSH_BASE_HDR_LEN + mdlen);\n\n\treturn 0;\n}\n\nint nsh_key_from_nlattr(const struct nlattr *attr,\n\t\t\tstruct ovs_key_nsh *nsh, struct ovs_key_nsh *nsh_mask)\n{\n\tstruct nlattr *a;\n\tint rem;\n\n\t/* validate_nsh has check this, so we needn't do duplicate check here\n\t */\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\tswitch (type) {\n\t\tcase OVS_NSH_KEY_ATTR_BASE: {\n\t\t\tconst struct ovs_nsh_key_base *base = nla_data(a);\n\t\t\tconst struct ovs_nsh_key_base *base_mask = base + 1;\n\n\t\t\tnsh->base = *base;\n\t\t\tnsh_mask->base = *base_mask;\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD1: {\n\t\t\tconst struct ovs_nsh_key_md1 *md1 = nla_data(a);\n\t\t\tconst struct ovs_nsh_key_md1 *md1_mask = md1 + 1;\n\n\t\t\tmemcpy(nsh->context, md1->context, sizeof(*md1));\n\t\t\tmemcpy(nsh_mask->context, md1_mask->context,\n\t\t\t       sizeof(*md1_mask));\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD2:\n\t\t\t/* Not supported yet */\n\t\t\treturn -ENOTSUPP;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nsh_key_put_from_nlattr(const struct nlattr *attr,\n\t\t\t\t   struct sw_flow_match *match, bool is_mask,\n\t\t\t\t   bool is_push_nsh, bool log)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tbool has_base = false;\n\tbool has_md1 = false;\n\tbool has_md2 = false;\n\tu8 mdtype = 0;\n\tint mdlen = 0;\n\n\tif (WARN_ON(is_push_nsh && is_mask))\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tint i;\n\n\t\tif (type > OVS_NSH_KEY_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"nsh attr %d is out of range max %d\",\n\t\t\t\t  type, OVS_NSH_KEY_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!check_attr_len(nla_len(a),\n\t\t\t\t    ovs_nsh_key_attr_lens[type].len)) {\n\t\t\tOVS_NLERR(\n\t\t\t    log,\n\t\t\t    \"nsh attr %d has unexpected len %d expected %d\",\n\t\t\t    type,\n\t\t\t    nla_len(a),\n\t\t\t    ovs_nsh_key_attr_lens[type].len\n\t\t\t);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_NSH_KEY_ATTR_BASE: {\n\t\t\tconst struct ovs_nsh_key_base *base = nla_data(a);\n\n\t\t\thas_base = true;\n\t\t\tmdtype = base->mdtype;\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.flags,\n\t\t\t\t\tbase->flags, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.ttl,\n\t\t\t\t\tbase->ttl, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.mdtype,\n\t\t\t\t\tbase->mdtype, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.np,\n\t\t\t\t\tbase->np, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.path_hdr,\n\t\t\t\t\tbase->path_hdr, is_mask);\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD1: {\n\t\t\tconst struct ovs_nsh_key_md1 *md1 = nla_data(a);\n\n\t\t\thas_md1 = true;\n\t\t\tfor (i = 0; i < NSH_MD1_CONTEXT_SIZE; i++)\n\t\t\t\tSW_FLOW_KEY_PUT(match, nsh.context[i],\n\t\t\t\t\t\tmd1->context[i], is_mask);\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD2:\n\t\t\tif (!is_push_nsh) /* Not supported MD type 2 yet */\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\thas_md2 = true;\n\t\t\tmdlen = nla_len(a);\n\t\t\tif (mdlen > NSH_CTX_HDRS_MAX_LEN || mdlen <= 0) {\n\t\t\t\tOVS_NLERR(\n\t\t\t\t    log,\n\t\t\t\t    \"Invalid MD length %d for MD type %d\",\n\t\t\t\t    mdlen,\n\t\t\t\t    mdtype\n\t\t\t\t);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown nsh attribute %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (rem > 0) {\n\t\tOVS_NLERR(log, \"nsh attribute has %d unknown bytes.\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\tif (has_md1 && has_md2) {\n\t\tOVS_NLERR(\n\t\t    1,\n\t\t    \"invalid nsh attribute: md1 and md2 are exclusive.\"\n\t\t);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask) {\n\t\tif ((has_md1 && mdtype != NSH_M_TYPE1) ||\n\t\t    (has_md2 && mdtype != NSH_M_TYPE2)) {\n\t\t\tOVS_NLERR(1, \"nsh attribute has unmatched MD type %d.\",\n\t\t\t\t  mdtype);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_push_nsh &&\n\t\t    (!has_base || (!has_md1 && !has_md2))) {\n\t\t\tOVS_NLERR(\n\t\t\t    1,\n\t\t\t    \"push_nsh: missing base or metadata attributes\"\n\t\t\t);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ovs_key_from_nlattrs(struct net *net, struct sw_flow_match *match,\n\t\t\t\tu64 attrs, const struct nlattr **a,\n\t\t\t\tbool is_mask, bool log)\n{\n\tint err;\n\n\terr = metadata_from_nlattrs(net, match, &attrs, a, is_mask, log);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ETHERNET)) {\n\t\tconst struct ovs_key_ethernet *eth_key;\n\n\t\teth_key = nla_data(a[OVS_KEY_ATTR_ETHERNET]);\n\t\tSW_FLOW_KEY_MEMCPY(match, eth.src,\n\t\t\t\teth_key->eth_src, ETH_ALEN, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, eth.dst,\n\t\t\t\teth_key->eth_dst, ETH_ALEN, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ETHERNET);\n\n\t\tif (attrs & (1 << OVS_KEY_ATTR_VLAN)) {\n\t\t\t/* VLAN attribute is always parsed before getting here since it\n\t\t\t * may occur multiple times.\n\t\t\t */\n\t\t\tOVS_NLERR(log, \"VLAN attribute unexpected.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) {\n\t\t\terr = parse_eth_type_from_nlattrs(match, &attrs, a, is_mask,\n\t\t\t\t\t\t\t  log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (!is_mask) {\n\t\t\tSW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);\n\t\t}\n\t} else if (!match->key->eth.type) {\n\t\tOVS_NLERR(log, \"Either Ethernet header or EtherType is required.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_IPV4)) {\n\t\tconst struct ovs_key_ipv4 *ipv4_key;\n\n\t\tipv4_key = nla_data(a[OVS_KEY_ATTR_IPV4]);\n\t\tif (!is_mask && ipv4_key->ipv4_frag > OVS_FRAG_TYPE_MAX) {\n\t\t\tOVS_NLERR(log, \"IPv4 frag type %d is out of range max %d\",\n\t\t\t\t  ipv4_key->ipv4_frag, OVS_FRAG_TYPE_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tSW_FLOW_KEY_PUT(match, ip.proto,\n\t\t\t\tipv4_key->ipv4_proto, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.tos,\n\t\t\t\tipv4_key->ipv4_tos, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.ttl,\n\t\t\t\tipv4_key->ipv4_ttl, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.frag,\n\t\t\t\tipv4_key->ipv4_frag, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.src,\n\t\t\t\tipv4_key->ipv4_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\n\t\t\t\tipv4_key->ipv4_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_IPV4);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_IPV6)) {\n\t\tconst struct ovs_key_ipv6 *ipv6_key;\n\n\t\tipv6_key = nla_data(a[OVS_KEY_ATTR_IPV6]);\n\t\tif (!is_mask && ipv6_key->ipv6_frag > OVS_FRAG_TYPE_MAX) {\n\t\t\tOVS_NLERR(log, \"IPv6 frag type %d is out of range max %d\",\n\t\t\t\t  ipv6_key->ipv6_frag, OVS_FRAG_TYPE_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_mask && ipv6_key->ipv6_label & htonl(0xFFF00000)) {\n\t\t\tOVS_NLERR(log, \"IPv6 flow label %x is out of range (max=%x)\",\n\t\t\t\t  ntohl(ipv6_key->ipv6_label), (1 << 20) - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, ipv6.label,\n\t\t\t\tipv6_key->ipv6_label, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.proto,\n\t\t\t\tipv6_key->ipv6_proto, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.tos,\n\t\t\t\tipv6_key->ipv6_tclass, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.ttl,\n\t\t\t\tipv6_key->ipv6_hlimit, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.frag,\n\t\t\t\tipv6_key->ipv6_frag, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.addr.src,\n\t\t\t\tipv6_key->ipv6_src,\n\t\t\t\tsizeof(match->key->ipv6.addr.src),\n\t\t\t\tis_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.addr.dst,\n\t\t\t\tipv6_key->ipv6_dst,\n\t\t\t\tsizeof(match->key->ipv6.addr.dst),\n\t\t\t\tis_mask);\n\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_IPV6);\n\t}\n\n\tif (attrs & (1ULL << OVS_KEY_ATTR_IPV6_EXTHDRS)) {\n\t\tconst struct ovs_key_ipv6_exthdrs *ipv6_exthdrs_key;\n\n\t\tipv6_exthdrs_key = nla_data(a[OVS_KEY_ATTR_IPV6_EXTHDRS]);\n\n\t\tSW_FLOW_KEY_PUT(match, ipv6.exthdrs,\n\t\t\t\tipv6_exthdrs_key->hdrs, is_mask);\n\n\t\tattrs &= ~(1ULL << OVS_KEY_ATTR_IPV6_EXTHDRS);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ARP)) {\n\t\tconst struct ovs_key_arp *arp_key;\n\n\t\tarp_key = nla_data(a[OVS_KEY_ATTR_ARP]);\n\t\tif (!is_mask && (arp_key->arp_op & htons(0xff00))) {\n\t\t\tOVS_NLERR(log, \"Unknown ARP opcode (opcode=%d).\",\n\t\t\t\t  arp_key->arp_op);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.src,\n\t\t\t\tarp_key->arp_sip, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\n\t\t\tarp_key->arp_tip, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.proto,\n\t\t\t\tntohs(arp_key->arp_op), is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv4.arp.sha,\n\t\t\t\tarp_key->arp_sha, ETH_ALEN, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv4.arp.tha,\n\t\t\t\tarp_key->arp_tha, ETH_ALEN, is_mask);\n\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ARP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_NSH)) {\n\t\tif (nsh_key_put_from_nlattr(a[OVS_KEY_ATTR_NSH], match,\n\t\t\t\t\t    is_mask, false, log) < 0)\n\t\t\treturn -EINVAL;\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_NSH);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_MPLS)) {\n\t\tconst struct ovs_key_mpls *mpls_key;\n\t\tu32 hdr_len;\n\t\tu32 label_count, label_count_mask, i;\n\n\t\tmpls_key = nla_data(a[OVS_KEY_ATTR_MPLS]);\n\t\thdr_len = nla_len(a[OVS_KEY_ATTR_MPLS]);\n\t\tlabel_count = hdr_len / sizeof(struct ovs_key_mpls);\n\n\t\tif (label_count == 0 || label_count > MPLS_LABEL_DEPTH ||\n\t\t    hdr_len % sizeof(struct ovs_key_mpls))\n\t\t\treturn -EINVAL;\n\n\t\tlabel_count_mask =  GENMASK(label_count - 1, 0);\n\n\t\tfor (i = 0 ; i < label_count; i++)\n\t\t\tSW_FLOW_KEY_PUT(match, mpls.lse[i],\n\t\t\t\t\tmpls_key[i].mpls_lse, is_mask);\n\n\t\tSW_FLOW_KEY_PUT(match, mpls.num_labels_mask,\n\t\t\t\tlabel_count_mask, is_mask);\n\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_MPLS);\n\t }\n\n\tif (attrs & (1 << OVS_KEY_ATTR_TCP)) {\n\t\tconst struct ovs_key_tcp *tcp_key;\n\n\t\ttcp_key = nla_data(a[OVS_KEY_ATTR_TCP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src, tcp_key->tcp_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst, tcp_key->tcp_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_TCP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_TCP_FLAGS)) {\n\t\tSW_FLOW_KEY_PUT(match, tp.flags,\n\t\t\t\tnla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\n\t\t\t\tis_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_TCP_FLAGS);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_UDP)) {\n\t\tconst struct ovs_key_udp *udp_key;\n\n\t\tudp_key = nla_data(a[OVS_KEY_ATTR_UDP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src, udp_key->udp_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst, udp_key->udp_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_UDP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_SCTP)) {\n\t\tconst struct ovs_key_sctp *sctp_key;\n\n\t\tsctp_key = nla_data(a[OVS_KEY_ATTR_SCTP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src, sctp_key->sctp_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst, sctp_key->sctp_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_SCTP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ICMP)) {\n\t\tconst struct ovs_key_icmp *icmp_key;\n\n\t\ticmp_key = nla_data(a[OVS_KEY_ATTR_ICMP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src,\n\t\t\t\thtons(icmp_key->icmp_type), is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst,\n\t\t\t\thtons(icmp_key->icmp_code), is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ICMP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ICMPV6)) {\n\t\tconst struct ovs_key_icmpv6 *icmpv6_key;\n\n\t\ticmpv6_key = nla_data(a[OVS_KEY_ATTR_ICMPV6]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src,\n\t\t\t\thtons(icmpv6_key->icmpv6_type), is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst,\n\t\t\t\thtons(icmpv6_key->icmpv6_code), is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ICMPV6);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ND)) {\n\t\tconst struct ovs_key_nd *nd_key;\n\n\t\tnd_key = nla_data(a[OVS_KEY_ATTR_ND]);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.nd.target,\n\t\t\tnd_key->nd_target,\n\t\t\tsizeof(match->key->ipv6.nd.target),\n\t\t\tis_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.nd.sll,\n\t\t\tnd_key->nd_sll, ETH_ALEN, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.nd.tll,\n\t\t\t\tnd_key->nd_tll, ETH_ALEN, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ND);\n\t}\n\n\tif (attrs != 0) {\n\t\tOVS_NLERR(log, \"Unknown key attributes %llx\",\n\t\t\t  (unsigned long long)attrs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void nlattr_set(struct nlattr *attr, u8 val,\n\t\t       const struct ovs_len_tbl *tbl)\n{\n\tstruct nlattr *nla;\n\tint rem;\n\n\t/* The nlattr stream should already have been validated */\n\tnla_for_each_nested(nla, attr, rem) {\n\t\tif (tbl[nla_type(nla)].len == OVS_ATTR_NESTED)\n\t\t\tnlattr_set(nla, val, tbl[nla_type(nla)].next ? : tbl);\n\t\telse\n\t\t\tmemset(nla_data(nla), val, nla_len(nla));\n\n\t\tif (nla_type(nla) == OVS_KEY_ATTR_CT_STATE)\n\t\t\t*(u32 *)nla_data(nla) &= CT_SUPPORTED_MASK;\n\t}\n}\n\nstatic void mask_set_nlattr(struct nlattr *attr, u8 val)\n{\n\tnlattr_set(attr, val, ovs_key_lens);\n}\n\n/**\n * ovs_nla_get_match - parses Netlink attributes into a flow key and\n * mask. In case the 'mask' is NULL, the flow is treated as exact match\n * flow. Otherwise, it is treated as a wildcarded flow, except the mask\n * does not include any don't care bit.\n * @net: Used to determine per-namespace field support.\n * @match: receives the extracted flow match information.\n * @nla_key: Netlink attribute holding nested %OVS_KEY_ATTR_* Netlink attribute\n * sequence. The fields should of the packet that triggered the creation\n * of this flow.\n * @nla_mask: Optional. Netlink attribute holding nested %OVS_KEY_ATTR_*\n * Netlink attribute specifies the mask field of the wildcarded flow.\n * @log: Boolean to allow kernel error logging.  Normally true, but when\n * probing for feature compatibility this should be passed in as false to\n * suppress unnecessary error logging.\n */\nint ovs_nla_get_match(struct net *net, struct sw_flow_match *match,\n\t\t      const struct nlattr *nla_key,\n\t\t      const struct nlattr *nla_mask,\n\t\t      bool log)\n{\n\tconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\n\tstruct nlattr *newmask = NULL;\n\tu64 key_attrs = 0;\n\tu64 mask_attrs = 0;\n\tint err;\n\n\terr = parse_flow_nlattrs(nla_key, a, &key_attrs, log);\n\tif (err)\n\t\treturn err;\n\n\terr = parse_vlan_from_nlattrs(match, &key_attrs, a, false, log);\n\tif (err)\n\t\treturn err;\n\n\terr = ovs_key_from_nlattrs(net, match, key_attrs, a, false, log);\n\tif (err)\n\t\treturn err;\n\n\tif (match->mask) {\n\t\tif (!nla_mask) {\n\t\t\t/* Create an exact match mask. We need to set to 0xff\n\t\t\t * all the 'match->mask' fields that have been touched\n\t\t\t * in 'match->key'. We cannot simply memset\n\t\t\t * 'match->mask', because padding bytes and fields not\n\t\t\t * specified in 'match->key' should be left to 0.\n\t\t\t * Instead, we use a stream of netlink attributes,\n\t\t\t * copied from 'key' and set to 0xff.\n\t\t\t * ovs_key_from_nlattrs() will take care of filling\n\t\t\t * 'match->mask' appropriately.\n\t\t\t */\n\t\t\tnewmask = kmemdup(nla_key,\n\t\t\t\t\t  nla_total_size(nla_len(nla_key)),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!newmask)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmask_set_nlattr(newmask, 0xff);\n\n\t\t\t/* The userspace does not send tunnel attributes that\n\t\t\t * are 0, but we should not wildcard them nonetheless.\n\t\t\t */\n\t\t\tif (match->key->tun_proto)\n\t\t\t\tSW_FLOW_KEY_MEMSET_FIELD(match, tun_key,\n\t\t\t\t\t\t\t 0xff, true);\n\n\t\t\tnla_mask = newmask;\n\t\t}\n\n\t\terr = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);\n\t\tif (err)\n\t\t\tgoto free_newmask;\n\n\t\t/* Always match on tci. */\n\t\tSW_FLOW_KEY_PUT(match, eth.vlan.tci, htons(0xffff), true);\n\t\tSW_FLOW_KEY_PUT(match, eth.cvlan.tci, htons(0xffff), true);\n\n\t\terr = parse_vlan_from_nlattrs(match, &mask_attrs, a, true, log);\n\t\tif (err)\n\t\t\tgoto free_newmask;\n\n\t\terr = ovs_key_from_nlattrs(net, match, mask_attrs, a, true,\n\t\t\t\t\t   log);\n\t\tif (err)\n\t\t\tgoto free_newmask;\n\t}\n\n\tif (!match_validate(match, key_attrs, mask_attrs, log))\n\t\terr = -EINVAL;\n\nfree_newmask:\n\tkfree(newmask);\n\treturn err;\n}\n\nstatic size_t get_ufid_len(const struct nlattr *attr, bool log)\n{\n\tsize_t len;\n\n\tif (!attr)\n\t\treturn 0;\n\n\tlen = nla_len(attr);\n\tif (len < 1 || len > MAX_UFID_LENGTH) {\n\t\tOVS_NLERR(log, \"ufid size %u bytes exceeds the range (1, %d)\",\n\t\t\t  nla_len(attr), MAX_UFID_LENGTH);\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\n/* Initializes 'flow->ufid', returning true if 'attr' contains a valid UFID,\n * or false otherwise.\n */\nbool ovs_nla_get_ufid(struct sw_flow_id *sfid, const struct nlattr *attr,\n\t\t      bool log)\n{\n\tsfid->ufid_len = get_ufid_len(attr, log);\n\tif (sfid->ufid_len)\n\t\tmemcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);\n\n\treturn sfid->ufid_len;\n}\n\nint ovs_nla_get_identifier(struct sw_flow_id *sfid, const struct nlattr *ufid,\n\t\t\t   const struct sw_flow_key *key, bool log)\n{\n\tstruct sw_flow_key *new_key;\n\n\tif (ovs_nla_get_ufid(sfid, ufid, log))\n\t\treturn 0;\n\n\t/* If UFID was not provided, use unmasked key. */\n\tnew_key = kmalloc(sizeof(*new_key), GFP_KERNEL);\n\tif (!new_key)\n\t\treturn -ENOMEM;\n\tmemcpy(new_key, key, sizeof(*key));\n\tsfid->unmasked_key = new_key;\n\n\treturn 0;\n}\n\nu32 ovs_nla_get_ufid_flags(const struct nlattr *attr)\n{\n\treturn attr ? nla_get_u32(attr) : 0;\n}\n\n/**\n * ovs_nla_get_flow_metadata - parses Netlink attributes into a flow key.\n * @net: Network namespace.\n * @key: Receives extracted in_port, priority, tun_key, skb_mark and conntrack\n * metadata.\n * @a: Array of netlink attributes holding parsed %OVS_KEY_ATTR_* Netlink\n * attributes.\n * @attrs: Bit mask for the netlink attributes included in @a.\n * @log: Boolean to allow kernel error logging.  Normally true, but when\n * probing for feature compatibility this should be passed in as false to\n * suppress unnecessary error logging.\n *\n * This parses a series of Netlink attributes that form a flow key, which must\n * take the same form accepted by flow_from_nlattrs(), but only enough of it to\n * get the metadata, that is, the parts of the flow key that cannot be\n * extracted from the packet itself.\n *\n * This must be called before the packet key fields are filled in 'key'.\n */\n\nint ovs_nla_get_flow_metadata(struct net *net,\n\t\t\t      const struct nlattr *a[OVS_KEY_ATTR_MAX + 1],\n\t\t\t      u64 attrs, struct sw_flow_key *key, bool log)\n{\n\tstruct sw_flow_match match;\n\n\tmemset(&match, 0, sizeof(match));\n\tmatch.key = key;\n\n\tkey->ct_state = 0;\n\tkey->ct_zone = 0;\n\tkey->ct_orig_proto = 0;\n\tmemset(&key->ct, 0, sizeof(key->ct));\n\tmemset(&key->ipv4.ct_orig, 0, sizeof(key->ipv4.ct_orig));\n\tmemset(&key->ipv6.ct_orig, 0, sizeof(key->ipv6.ct_orig));\n\n\tkey->phy.in_port = DP_MAX_PORTS;\n\n\treturn metadata_from_nlattrs(net, &match, &attrs, a, false, log);\n}\n\nstatic int ovs_nla_put_vlan(struct sk_buff *skb, const struct vlan_head *vh,\n\t\t\t    bool is_mask)\n{\n\t__be16 eth_type = !is_mask ? vh->tpid : htons(0xffff);\n\n\tif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, eth_type) ||\n\t    nla_put_be16(skb, OVS_KEY_ATTR_VLAN, vh->tci))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int nsh_key_to_nlattr(const struct ovs_key_nsh *nsh, bool is_mask,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, OVS_KEY_ATTR_NSH);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put(skb, OVS_NSH_KEY_ATTR_BASE, sizeof(nsh->base), &nsh->base))\n\t\tgoto nla_put_failure;\n\n\tif (is_mask || nsh->base.mdtype == NSH_M_TYPE1) {\n\t\tif (nla_put(skb, OVS_NSH_KEY_ATTR_MD1,\n\t\t\t    sizeof(nsh->context), nsh->context))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t/* Don't support MD type 2 yet */\n\n\tnla_nest_end(skb, start);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int __ovs_nla_put_key(const struct sw_flow_key *swkey,\n\t\t\t     const struct sw_flow_key *output, bool is_mask,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ovs_key_ethernet *eth_key;\n\tstruct nlattr *nla;\n\tstruct nlattr *encap = NULL;\n\tstruct nlattr *in_encap = NULL;\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_RECIRC_ID, output->recirc_id))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_DP_HASH, output->ovs_flow_hash))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))\n\t\tgoto nla_put_failure;\n\n\tif ((swkey->tun_proto || is_mask)) {\n\t\tconst void *opts = NULL;\n\n\t\tif (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)\n\t\t\topts = TUN_METADATA_OPTS(output, swkey->tun_opts_len);\n\n\t\tif (ip_tun_to_nlattr(skb, &output->tun_key, opts,\n\t\t\t\t     swkey->tun_opts_len, swkey->tun_proto, 0))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (swkey->phy.in_port == DP_MAX_PORTS) {\n\t\tif (is_mask && (output->phy.in_port == 0xffff))\n\t\t\tif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT, 0xffffffff))\n\t\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tu16 upper_u16;\n\t\tupper_u16 = !is_mask ? 0 : 0xffff;\n\n\t\tif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT,\n\t\t\t\t(upper_u16 << 16) | output->phy.in_port))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))\n\t\tgoto nla_put_failure;\n\n\tif (ovs_ct_put_key(swkey, output, skb))\n\t\tgoto nla_put_failure;\n\n\tif (ovs_key_mac_proto(swkey) == MAC_PROTO_ETHERNET) {\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\n\t\teth_key = nla_data(nla);\n\t\tether_addr_copy(eth_key->eth_src, output->eth.src);\n\t\tether_addr_copy(eth_key->eth_dst, output->eth.dst);\n\n\t\tif (swkey->eth.vlan.tci || eth_type_vlan(swkey->eth.type)) {\n\t\t\tif (ovs_nla_put_vlan(skb, &output->eth.vlan, is_mask))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tencap = nla_nest_start_noflag(skb, OVS_KEY_ATTR_ENCAP);\n\t\t\tif (!swkey->eth.vlan.tci)\n\t\t\t\tgoto unencap;\n\n\t\t\tif (swkey->eth.cvlan.tci || eth_type_vlan(swkey->eth.type)) {\n\t\t\t\tif (ovs_nla_put_vlan(skb, &output->eth.cvlan, is_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tin_encap = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t\t OVS_KEY_ATTR_ENCAP);\n\t\t\t\tif (!swkey->eth.cvlan.tci)\n\t\t\t\t\tgoto unencap;\n\t\t\t}\n\t\t}\n\n\t\tif (swkey->eth.type == htons(ETH_P_802_2)) {\n\t\t\t/*\n\t\t\t* Ethertype 802.2 is represented in the netlink with omitted\n\t\t\t* OVS_KEY_ATTR_ETHERTYPE in the flow key attribute, and\n\t\t\t* 0xffff in the mask attribute.  Ethertype can also\n\t\t\t* be wildcarded.\n\t\t\t*/\n\t\t\tif (is_mask && output->eth.type)\n\t\t\t\tif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,\n\t\t\t\t\t\t\toutput->eth.type))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\tgoto unencap;\n\t\t}\n\t}\n\n\tif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))\n\t\tgoto nla_put_failure;\n\n\tif (eth_type_vlan(swkey->eth.type)) {\n\t\t/* There are 3 VLAN tags, we don't know anything about the rest\n\t\t * of the packet, so truncate here.\n\t\t */\n\t\tWARN_ON_ONCE(!(encap && in_encap));\n\t\tgoto unencap;\n\t}\n\n\tif (swkey->eth.type == htons(ETH_P_IP)) {\n\t\tstruct ovs_key_ipv4 *ipv4_key;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_IPV4, sizeof(*ipv4_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tipv4_key = nla_data(nla);\n\t\tipv4_key->ipv4_src = output->ipv4.addr.src;\n\t\tipv4_key->ipv4_dst = output->ipv4.addr.dst;\n\t\tipv4_key->ipv4_proto = output->ip.proto;\n\t\tipv4_key->ipv4_tos = output->ip.tos;\n\t\tipv4_key->ipv4_ttl = output->ip.ttl;\n\t\tipv4_key->ipv4_frag = output->ip.frag;\n\t} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\n\t\tstruct ovs_key_ipv6 *ipv6_key;\n\t\tstruct ovs_key_ipv6_exthdrs *ipv6_exthdrs_key;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_IPV6, sizeof(*ipv6_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tipv6_key = nla_data(nla);\n\t\tmemcpy(ipv6_key->ipv6_src, &output->ipv6.addr.src,\n\t\t\t\tsizeof(ipv6_key->ipv6_src));\n\t\tmemcpy(ipv6_key->ipv6_dst, &output->ipv6.addr.dst,\n\t\t\t\tsizeof(ipv6_key->ipv6_dst));\n\t\tipv6_key->ipv6_label = output->ipv6.label;\n\t\tipv6_key->ipv6_proto = output->ip.proto;\n\t\tipv6_key->ipv6_tclass = output->ip.tos;\n\t\tipv6_key->ipv6_hlimit = output->ip.ttl;\n\t\tipv6_key->ipv6_frag = output->ip.frag;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_IPV6_EXTHDRS,\n\t\t\t\t  sizeof(*ipv6_exthdrs_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tipv6_exthdrs_key = nla_data(nla);\n\t\tipv6_exthdrs_key->hdrs = output->ipv6.exthdrs;\n\t} else if (swkey->eth.type == htons(ETH_P_NSH)) {\n\t\tif (nsh_key_to_nlattr(&output->nsh, is_mask, skb))\n\t\t\tgoto nla_put_failure;\n\t} else if (swkey->eth.type == htons(ETH_P_ARP) ||\n\t\t   swkey->eth.type == htons(ETH_P_RARP)) {\n\t\tstruct ovs_key_arp *arp_key;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ARP, sizeof(*arp_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tarp_key = nla_data(nla);\n\t\tmemset(arp_key, 0, sizeof(struct ovs_key_arp));\n\t\tarp_key->arp_sip = output->ipv4.addr.src;\n\t\tarp_key->arp_tip = output->ipv4.addr.dst;\n\t\tarp_key->arp_op = htons(output->ip.proto);\n\t\tether_addr_copy(arp_key->arp_sha, output->ipv4.arp.sha);\n\t\tether_addr_copy(arp_key->arp_tha, output->ipv4.arp.tha);\n\t} else if (eth_p_mpls(swkey->eth.type)) {\n\t\tu8 i, num_labels;\n\t\tstruct ovs_key_mpls *mpls_key;\n\n\t\tnum_labels = hweight_long(output->mpls.num_labels_mask);\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_MPLS,\n\t\t\t\t  num_labels * sizeof(*mpls_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\n\t\tmpls_key = nla_data(nla);\n\t\tfor (i = 0; i < num_labels; i++)\n\t\t\tmpls_key[i].mpls_lse = output->mpls.lse[i];\n\t}\n\n\tif ((swkey->eth.type == htons(ETH_P_IP) ||\n\t     swkey->eth.type == htons(ETH_P_IPV6)) &&\n\t     swkey->ip.frag != OVS_FRAG_TYPE_LATER) {\n\n\t\tif (swkey->ip.proto == IPPROTO_TCP) {\n\t\t\tstruct ovs_key_tcp *tcp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_TCP, sizeof(*tcp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ttcp_key = nla_data(nla);\n\t\t\ttcp_key->tcp_src = output->tp.src;\n\t\t\ttcp_key->tcp_dst = output->tp.dst;\n\t\t\tif (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\n\t\t\t\t\t output->tp.flags))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (swkey->ip.proto == IPPROTO_UDP) {\n\t\t\tstruct ovs_key_udp *udp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_UDP, sizeof(*udp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tudp_key = nla_data(nla);\n\t\t\tudp_key->udp_src = output->tp.src;\n\t\t\tudp_key->udp_dst = output->tp.dst;\n\t\t} else if (swkey->ip.proto == IPPROTO_SCTP) {\n\t\t\tstruct ovs_key_sctp *sctp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_SCTP, sizeof(*sctp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tsctp_key = nla_data(nla);\n\t\t\tsctp_key->sctp_src = output->tp.src;\n\t\t\tsctp_key->sctp_dst = output->tp.dst;\n\t\t} else if (swkey->eth.type == htons(ETH_P_IP) &&\n\t\t\t   swkey->ip.proto == IPPROTO_ICMP) {\n\t\t\tstruct ovs_key_icmp *icmp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ICMP, sizeof(*icmp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ticmp_key = nla_data(nla);\n\t\t\ticmp_key->icmp_type = ntohs(output->tp.src);\n\t\t\ticmp_key->icmp_code = ntohs(output->tp.dst);\n\t\t} else if (swkey->eth.type == htons(ETH_P_IPV6) &&\n\t\t\t   swkey->ip.proto == IPPROTO_ICMPV6) {\n\t\t\tstruct ovs_key_icmpv6 *icmpv6_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ICMPV6,\n\t\t\t\t\t\tsizeof(*icmpv6_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ticmpv6_key = nla_data(nla);\n\t\t\ticmpv6_key->icmpv6_type = ntohs(output->tp.src);\n\t\t\ticmpv6_key->icmpv6_code = ntohs(output->tp.dst);\n\n\t\t\tif (swkey->tp.src == htons(NDISC_NEIGHBOUR_SOLICITATION) ||\n\t\t\t    swkey->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) {\n\t\t\t\tstruct ovs_key_nd *nd_key;\n\n\t\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ND, sizeof(*nd_key));\n\t\t\t\tif (!nla)\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tnd_key = nla_data(nla);\n\t\t\t\tmemcpy(nd_key->nd_target, &output->ipv6.nd.target,\n\t\t\t\t\t\t\tsizeof(nd_key->nd_target));\n\t\t\t\tether_addr_copy(nd_key->nd_sll, output->ipv6.nd.sll);\n\t\t\t\tether_addr_copy(nd_key->nd_tll, output->ipv6.nd.tll);\n\t\t\t}\n\t\t}\n\t}\n\nunencap:\n\tif (in_encap)\n\t\tnla_nest_end(skb, in_encap);\n\tif (encap)\n\t\tnla_nest_end(skb, encap);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nint ovs_nla_put_key(const struct sw_flow_key *swkey,\n\t\t    const struct sw_flow_key *output, int attr, bool is_mask,\n\t\t    struct sk_buff *skb)\n{\n\tint err;\n\tstruct nlattr *nla;\n\n\tnla = nla_nest_start_noflag(skb, attr);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\terr = __ovs_nla_put_key(swkey, output, is_mask, skb);\n\tif (err)\n\t\treturn err;\n\tnla_nest_end(skb, nla);\n\n\treturn 0;\n}\n\n/* Called with ovs_mutex or RCU read lock. */\nint ovs_nla_put_identifier(const struct sw_flow *flow, struct sk_buff *skb)\n{\n\tif (ovs_identifier_is_ufid(&flow->id))\n\t\treturn nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id.ufid_len,\n\t\t\t       flow->id.ufid);\n\n\treturn ovs_nla_put_key(flow->id.unmasked_key, flow->id.unmasked_key,\n\t\t\t       OVS_FLOW_ATTR_KEY, false, skb);\n}\n\n/* Called with ovs_mutex or RCU read lock. */\nint ovs_nla_put_masked_key(const struct sw_flow *flow, struct sk_buff *skb)\n{\n\treturn ovs_nla_put_key(&flow->key, &flow->key,\n\t\t\t\tOVS_FLOW_ATTR_KEY, false, skb);\n}\n\n/* Called with ovs_mutex or RCU read lock. */\nint ovs_nla_put_mask(const struct sw_flow *flow, struct sk_buff *skb)\n{\n\treturn ovs_nla_put_key(&flow->key, &flow->mask->key,\n\t\t\t\tOVS_FLOW_ATTR_MASK, true, skb);\n}\n\n#define MAX_ACTIONS_BUFSIZE\t(32 * 1024)\n\nstatic struct sw_flow_actions *nla_alloc_flow_actions(int size)\n{\n\tstruct sw_flow_actions *sfa;\n\n\tWARN_ON_ONCE(size > MAX_ACTIONS_BUFSIZE);\n\n\tsfa = kmalloc(sizeof(*sfa) + size, GFP_KERNEL);\n\tif (!sfa)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsfa->actions_len = 0;\n\treturn sfa;\n}\n\nstatic void ovs_nla_free_nested_actions(const struct nlattr *actions, int len);\n\nstatic void ovs_nla_free_check_pkt_len_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a;\n\tint rem;\n\n\tnla_for_each_nested(a, action, rem) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL:\n\t\tcase OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER:\n\t\t\tovs_nla_free_nested_actions(nla_data(a), nla_len(a));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ovs_nla_free_clone_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a = nla_data(action);\n\tint rem = nla_len(action);\n\n\tswitch (nla_type(a)) {\n\tcase OVS_CLONE_ATTR_EXEC:\n\t\t/* The real list of actions follows this attribute. */\n\t\ta = nla_next(a, &rem);\n\t\tovs_nla_free_nested_actions(a, rem);\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_dec_ttl_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a = nla_data(action);\n\n\tswitch (nla_type(a)) {\n\tcase OVS_DEC_TTL_ATTR_ACTION:\n\t\tovs_nla_free_nested_actions(nla_data(a), nla_len(a));\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_sample_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a = nla_data(action);\n\tint rem = nla_len(action);\n\n\tswitch (nla_type(a)) {\n\tcase OVS_SAMPLE_ATTR_ARG:\n\t\t/* The real list of actions follows this attribute. */\n\t\ta = nla_next(a, &rem);\n\t\tovs_nla_free_nested_actions(a, rem);\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_set_action(const struct nlattr *a)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tstruct ovs_tunnel_info *ovs_tun;\n\n\tswitch (nla_type(ovs_key)) {\n\tcase OVS_KEY_ATTR_TUNNEL_INFO:\n\t\tovs_tun = nla_data(ovs_key);\n\t\tdst_release((struct dst_entry *)ovs_tun->tun_dst);\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_nested_actions(const struct nlattr *actions, int len)\n{\n\tconst struct nlattr *a;\n\tint rem;\n\n\t/* Whenever new actions are added, the need to update this\n\t * function should be considered.\n\t */\n\tBUILD_BUG_ON(OVS_ACTION_ATTR_MAX != 23);\n\n\tif (!actions)\n\t\treturn;\n\n\tnla_for_each_attr(a, actions, len, rem) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN:\n\t\t\tovs_nla_free_check_pkt_len_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE:\n\t\t\tovs_nla_free_clone_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\tovs_ct_free_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\tovs_nla_free_dec_ttl_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE:\n\t\t\tovs_nla_free_sample_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\tovs_nla_free_set_action(a);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ovs_nla_free_flow_actions(struct sw_flow_actions *sf_acts)\n{\n\tif (!sf_acts)\n\t\treturn;\n\n\tovs_nla_free_nested_actions(sf_acts->actions, sf_acts->actions_len);\n\tkfree(sf_acts);\n}\n\nstatic void __ovs_nla_free_flow_actions(struct rcu_head *head)\n{\n\tovs_nla_free_flow_actions(container_of(head, struct sw_flow_actions, rcu));\n}\n\n/* Schedules 'sf_acts' to be freed after the next RCU grace period.\n * The caller must hold rcu_read_lock for this to be sensible. */\nvoid ovs_nla_free_flow_actions_rcu(struct sw_flow_actions *sf_acts)\n{\n\tcall_rcu(&sf_acts->rcu, __ovs_nla_free_flow_actions);\n}\n\nstatic struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\n\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}\n\nstatic struct nlattr *__add_action(struct sw_flow_actions **sfa,\n\t\t\t\t   int attrtype, void *data, int len, bool log)\n{\n\tstruct nlattr *a;\n\n\ta = reserve_sfa_size(sfa, nla_attr_size(len), log);\n\tif (IS_ERR(a))\n\t\treturn a;\n\n\ta->nla_type = attrtype;\n\ta->nla_len = nla_attr_size(len);\n\n\tif (data)\n\t\tmemcpy(nla_data(a), data, len);\n\tmemset((unsigned char *) a + a->nla_len, 0, nla_padlen(len));\n\n\treturn a;\n}\n\nint ovs_nla_add_action(struct sw_flow_actions **sfa, int attrtype, void *data,\n\t\t       int len, bool log)\n{\n\tstruct nlattr *a;\n\n\ta = __add_action(sfa, attrtype, data, len, log);\n\n\treturn PTR_ERR_OR_ZERO(a);\n}\n\nstatic inline int add_nested_action_start(struct sw_flow_actions **sfa,\n\t\t\t\t\t  int attrtype, bool log)\n{\n\tint used = (*sfa)->actions_len;\n\tint err;\n\n\terr = ovs_nla_add_action(sfa, attrtype, NULL, 0, log);\n\tif (err)\n\t\treturn err;\n\n\treturn used;\n}\n\nstatic inline void add_nested_action_end(struct sw_flow_actions *sfa,\n\t\t\t\t\t int st_offset)\n{\n\tstruct nlattr *a = (struct nlattr *) ((unsigned char *)sfa->actions +\n\t\t\t\t\t\t\t       st_offset);\n\n\ta->nla_len = sfa->actions_len - st_offset;\n}\n\nstatic int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\n\t\t\t\t  const struct sw_flow_key *key,\n\t\t\t\t  struct sw_flow_actions **sfa,\n\t\t\t\t  __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t  u32 mpls_label_count, bool log);\n\nstatic int validate_and_copy_sample(struct net *net, const struct nlattr *attr,\n\t\t\t\t    const struct sw_flow_key *key,\n\t\t\t\t    struct sw_flow_actions **sfa,\n\t\t\t\t    __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t    u32 mpls_label_count, bool log, bool last)\n{\n\tconst struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];\n\tconst struct nlattr *probability, *actions;\n\tconst struct nlattr *a;\n\tint rem, start, err;\n\tstruct sample_arg arg;\n\n\tmemset(attrs, 0, sizeof(attrs));\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tif (!type || type > OVS_SAMPLE_ATTR_MAX || attrs[type])\n\t\t\treturn -EINVAL;\n\t\tattrs[type] = a;\n\t}\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tprobability = attrs[OVS_SAMPLE_ATTR_PROBABILITY];\n\tif (!probability || nla_len(probability) != sizeof(u32))\n\t\treturn -EINVAL;\n\n\tactions = attrs[OVS_SAMPLE_ATTR_ACTIONS];\n\tif (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN))\n\t\treturn -EINVAL;\n\n\t/* validation done, copy sample action. */\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SAMPLE, log);\n\tif (start < 0)\n\t\treturn start;\n\n\t/* When both skb and flow may be changed, put the sample\n\t * into a deferred fifo. On the other hand, if only skb\n\t * may be modified, the actions can be executed in place.\n\t *\n\t * Do this analysis at the flow installation time.\n\t * Set 'clone_action->exec' to true if the actions can be\n\t * executed without being deferred.\n\t *\n\t * If the sample is the last action, it can always be excuted\n\t * rather than deferred.\n\t */\n\targ.exec = last || !actions_may_change_flow(actions);\n\targ.probability = nla_get_u32(probability);\n\n\terr = ovs_nla_add_action(sfa, OVS_SAMPLE_ATTR_ARG, &arg, sizeof(arg),\n\t\t\t\t log);\n\tif (err)\n\t\treturn err;\n\n\terr = __ovs_nla_copy_actions(net, actions, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, start);\n\n\treturn 0;\n}\n\nstatic int validate_and_copy_dec_ttl(struct net *net,\n\t\t\t\t     const struct nlattr *attr,\n\t\t\t\t     const struct sw_flow_key *key,\n\t\t\t\t     struct sw_flow_actions **sfa,\n\t\t\t\t     __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t     u32 mpls_label_count, bool log)\n{\n\tconst struct nlattr *attrs[OVS_DEC_TTL_ATTR_MAX + 1];\n\tint start, action_start, err, rem;\n\tconst struct nlattr *a, *actions;\n\n\tmemset(attrs, 0, sizeof(attrs));\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\t/* Ignore unknown attributes to be future proof. */\n\t\tif (type > OVS_DEC_TTL_ATTR_MAX)\n\t\t\tcontinue;\n\n\t\tif (!type || attrs[type]) {\n\t\t\tOVS_NLERR(log, \"Duplicate or invalid key (type %d).\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tattrs[type] = a;\n\t}\n\n\tif (rem) {\n\t\tOVS_NLERR(log, \"Message has %d unknown bytes.\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\tactions = attrs[OVS_DEC_TTL_ATTR_ACTION];\n\tif (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN)) {\n\t\tOVS_NLERR(log, \"Missing valid actions attribute.\");\n\t\treturn -EINVAL;\n\t}\n\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_DEC_TTL, log);\n\tif (start < 0)\n\t\treturn start;\n\n\taction_start = add_nested_action_start(sfa, OVS_DEC_TTL_ATTR_ACTION, log);\n\tif (action_start < 0)\n\t\treturn action_start;\n\n\terr = __ovs_nla_copy_actions(net, actions, key, sfa, eth_type,\n\t\t\t\t     vlan_tci, mpls_label_count, log);\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, action_start);\n\tadd_nested_action_end(*sfa, start);\n\treturn 0;\n}\n\nstatic int validate_and_copy_clone(struct net *net,\n\t\t\t\t   const struct nlattr *attr,\n\t\t\t\t   const struct sw_flow_key *key,\n\t\t\t\t   struct sw_flow_actions **sfa,\n\t\t\t\t   __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t   u32 mpls_label_count, bool log, bool last)\n{\n\tint start, err;\n\tu32 exec;\n\n\tif (nla_len(attr) && nla_len(attr) < NLA_HDRLEN)\n\t\treturn -EINVAL;\n\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_CLONE, log);\n\tif (start < 0)\n\t\treturn start;\n\n\texec = last || !actions_may_change_flow(attr);\n\n\terr = ovs_nla_add_action(sfa, OVS_CLONE_ATTR_EXEC, &exec,\n\t\t\t\t sizeof(exec), log);\n\tif (err)\n\t\treturn err;\n\n\terr = __ovs_nla_copy_actions(net, attr, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, start);\n\n\treturn 0;\n}\n\nvoid ovs_match_init(struct sw_flow_match *match,\n\t\t    struct sw_flow_key *key,\n\t\t    bool reset_key,\n\t\t    struct sw_flow_mask *mask)\n{\n\tmemset(match, 0, sizeof(*match));\n\tmatch->key = key;\n\tmatch->mask = mask;\n\n\tif (reset_key)\n\t\tmemset(key, 0, sizeof(*key));\n\n\tif (mask) {\n\t\tmemset(&mask->key, 0, sizeof(mask->key));\n\t\tmask->range.start = mask->range.end = 0;\n\t}\n}\n\nstatic int validate_geneve_opts(struct sw_flow_key *key)\n{\n\tstruct geneve_opt *option;\n\tint opts_len = key->tun_opts_len;\n\tbool crit_opt = false;\n\n\toption = (struct geneve_opt *)TUN_METADATA_OPTS(key, key->tun_opts_len);\n\twhile (opts_len > 0) {\n\t\tint len;\n\n\t\tif (opts_len < sizeof(*option))\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(*option) + option->length * 4;\n\t\tif (len > opts_len)\n\t\t\treturn -EINVAL;\n\n\t\tcrit_opt |= !!(option->type & GENEVE_CRIT_OPT_TYPE);\n\n\t\toption = (struct geneve_opt *)((u8 *)option + len);\n\t\topts_len -= len;\n\t}\n\n\tkey->tun_key.tun_flags |= crit_opt ? TUNNEL_CRIT_OPT : 0;\n\n\treturn 0;\n}\n\nstatic int validate_and_copy_set_tun(const struct nlattr *attr,\n\t\t\t\t     struct sw_flow_actions **sfa, bool log)\n{\n\tstruct sw_flow_match match;\n\tstruct sw_flow_key key;\n\tstruct metadata_dst *tun_dst;\n\tstruct ip_tunnel_info *tun_info;\n\tstruct ovs_tunnel_info *ovs_tun;\n\tstruct nlattr *a;\n\tint err = 0, start, opts_type;\n\t__be16 dst_opt_type;\n\n\tdst_opt_type = 0;\n\tovs_match_init(&match, &key, true, NULL);\n\topts_type = ip_tun_from_nlattr(nla_data(attr), &match, false, log);\n\tif (opts_type < 0)\n\t\treturn opts_type;\n\n\tif (key.tun_opts_len) {\n\t\tswitch (opts_type) {\n\t\tcase OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\n\t\t\terr = validate_geneve_opts(&key);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tdst_opt_type = TUNNEL_GENEVE_OPT;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\n\t\t\tdst_opt_type = TUNNEL_VXLAN_OPT;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS:\n\t\t\tdst_opt_type = TUNNEL_ERSPAN_OPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET, log);\n\tif (start < 0)\n\t\treturn start;\n\n\ttun_dst = metadata_dst_alloc(key.tun_opts_len, METADATA_IP_TUNNEL,\n\t\t\t\t     GFP_KERNEL);\n\n\tif (!tun_dst)\n\t\treturn -ENOMEM;\n\n\terr = dst_cache_init(&tun_dst->u.tun_info.dst_cache, GFP_KERNEL);\n\tif (err) {\n\t\tdst_release((struct dst_entry *)tun_dst);\n\t\treturn err;\n\t}\n\n\ta = __add_action(sfa, OVS_KEY_ATTR_TUNNEL_INFO, NULL,\n\t\t\t sizeof(*ovs_tun), log);\n\tif (IS_ERR(a)) {\n\t\tdst_release((struct dst_entry *)tun_dst);\n\t\treturn PTR_ERR(a);\n\t}\n\n\tovs_tun = nla_data(a);\n\tovs_tun->tun_dst = tun_dst;\n\n\ttun_info = &tun_dst->u.tun_info;\n\ttun_info->mode = IP_TUNNEL_INFO_TX;\n\tif (key.tun_proto == AF_INET6)\n\t\ttun_info->mode |= IP_TUNNEL_INFO_IPV6;\n\telse if (key.tun_proto == AF_INET && key.tun_key.u.ipv4.dst == 0)\n\t\ttun_info->mode |= IP_TUNNEL_INFO_BRIDGE;\n\ttun_info->key = key.tun_key;\n\n\t/* We need to store the options in the action itself since\n\t * everything else will go away after flow setup. We can append\n\t * it to tun_info and then point there.\n\t */\n\tip_tunnel_info_opts_set(tun_info,\n\t\t\t\tTUN_METADATA_OPTS(&key, key.tun_opts_len),\n\t\t\t\tkey.tun_opts_len, dst_opt_type);\n\tadd_nested_action_end(*sfa, start);\n\n\treturn err;\n}\n\nstatic bool validate_nsh(const struct nlattr *attr, bool is_mask,\n\t\t\t bool is_push_nsh, bool log)\n{\n\tstruct sw_flow_match match;\n\tstruct sw_flow_key key;\n\tint ret = 0;\n\n\tovs_match_init(&match, &key, true, NULL);\n\tret = nsh_key_put_from_nlattr(attr, &match, is_mask,\n\t\t\t\t      is_push_nsh, log);\n\treturn !ret;\n}\n\n/* Return false if there are any non-masked bits set.\n * Mask follows data immediately, before any netlink padding.\n */\nstatic bool validate_masked(u8 *data, int len)\n{\n\tu8 *mask = data + len;\n\n\twhile (len--)\n\t\tif (*data++ & ~*mask++)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int validate_set(const struct nlattr *a,\n\t\t\tconst struct sw_flow_key *flow_key,\n\t\t\tstruct sw_flow_actions **sfa, bool *skip_copy,\n\t\t\tu8 mac_proto, __be16 eth_type, bool masked, bool log)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tint key_type = nla_type(ovs_key);\n\tsize_t key_len;\n\n\t/* There can be only one key in a action */\n\tif (nla_total_size(nla_len(ovs_key)) != nla_len(a))\n\t\treturn -EINVAL;\n\n\tkey_len = nla_len(ovs_key);\n\tif (masked)\n\t\tkey_len /= 2;\n\n\tif (key_type > OVS_KEY_ATTR_MAX ||\n\t    !check_attr_len(key_len, ovs_key_lens[key_type].len))\n\t\treturn -EINVAL;\n\n\tif (masked && !validate_masked(nla_data(ovs_key), key_len))\n\t\treturn -EINVAL;\n\n\tswitch (key_type) {\n\tcase OVS_KEY_ATTR_PRIORITY:\n\tcase OVS_KEY_ATTR_SKB_MARK:\n\tcase OVS_KEY_ATTR_CT_MARK:\n\tcase OVS_KEY_ATTR_CT_LABELS:\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_ETHERNET:\n\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_TUNNEL: {\n\t\tint err;\n\n\t\tif (masked)\n\t\t\treturn -EINVAL; /* Masked tunnel set not supported. */\n\n\t\t*skip_copy = true;\n\t\terr = validate_and_copy_set_tun(a, sfa, log);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\tcase OVS_KEY_ATTR_IPV4: {\n\t\tconst struct ovs_key_ipv4 *ipv4_key;\n\n\t\tif (eth_type != htons(ETH_P_IP))\n\t\t\treturn -EINVAL;\n\n\t\tipv4_key = nla_data(ovs_key);\n\n\t\tif (masked) {\n\t\t\tconst struct ovs_key_ipv4 *mask = ipv4_key + 1;\n\n\t\t\t/* Non-writeable fields. */\n\t\t\tif (mask->ipv4_proto || mask->ipv4_frag)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ipv4_key->ipv4_proto != flow_key->ip.proto)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (ipv4_key->ipv4_frag != flow_key->ip.frag)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase OVS_KEY_ATTR_IPV6: {\n\t\tconst struct ovs_key_ipv6 *ipv6_key;\n\n\t\tif (eth_type != htons(ETH_P_IPV6))\n\t\t\treturn -EINVAL;\n\n\t\tipv6_key = nla_data(ovs_key);\n\n\t\tif (masked) {\n\t\t\tconst struct ovs_key_ipv6 *mask = ipv6_key + 1;\n\n\t\t\t/* Non-writeable fields. */\n\t\t\tif (mask->ipv6_proto || mask->ipv6_frag)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Invalid bits in the flow label mask? */\n\t\t\tif (ntohl(mask->ipv6_label) & 0xFFF00000)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ipv6_key->ipv6_proto != flow_key->ip.proto)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (ipv6_key->ipv6_frag != flow_key->ip.frag)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ntohl(ipv6_key->ipv6_label) & 0xFFF00000)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\t}\n\tcase OVS_KEY_ATTR_TCP:\n\t\tif ((eth_type != htons(ETH_P_IP) &&\n\t\t     eth_type != htons(ETH_P_IPV6)) ||\n\t\t    flow_key->ip.proto != IPPROTO_TCP)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_UDP:\n\t\tif ((eth_type != htons(ETH_P_IP) &&\n\t\t     eth_type != htons(ETH_P_IPV6)) ||\n\t\t    flow_key->ip.proto != IPPROTO_UDP)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_MPLS:\n\t\tif (!eth_p_mpls(eth_type))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_SCTP:\n\t\tif ((eth_type != htons(ETH_P_IP) &&\n\t\t     eth_type != htons(ETH_P_IPV6)) ||\n\t\t    flow_key->ip.proto != IPPROTO_SCTP)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_NSH:\n\t\tif (eth_type != htons(ETH_P_NSH))\n\t\t\treturn -EINVAL;\n\t\tif (!validate_nsh(nla_data(a), masked, false, log))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Convert non-masked non-tunnel set actions to masked set actions. */\n\tif (!masked && key_type != OVS_KEY_ATTR_TUNNEL) {\n\t\tint start, len = key_len * 2;\n\t\tstruct nlattr *at;\n\n\t\t*skip_copy = true;\n\n\t\tstart = add_nested_action_start(sfa,\n\t\t\t\t\t\tOVS_ACTION_ATTR_SET_TO_MASKED,\n\t\t\t\t\t\tlog);\n\t\tif (start < 0)\n\t\t\treturn start;\n\n\t\tat = __add_action(sfa, key_type, NULL, len, log);\n\t\tif (IS_ERR(at))\n\t\t\treturn PTR_ERR(at);\n\n\t\tmemcpy(nla_data(at), nla_data(ovs_key), key_len); /* Key. */\n\t\tmemset(nla_data(at) + key_len, 0xff, key_len);    /* Mask. */\n\t\t/* Clear non-writeable bits from otherwise writeable fields. */\n\t\tif (key_type == OVS_KEY_ATTR_IPV6) {\n\t\t\tstruct ovs_key_ipv6 *mask = nla_data(at) + key_len;\n\n\t\t\tmask->ipv6_label &= htonl(0x000FFFFF);\n\t\t}\n\t\tadd_nested_action_end(*sfa, start);\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_userspace(const struct nlattr *attr)\n{\n\tstatic const struct nla_policy userspace_policy[OVS_USERSPACE_ATTR_MAX + 1] = {\n\t\t[OVS_USERSPACE_ATTR_PID] = {.type = NLA_U32 },\n\t\t[OVS_USERSPACE_ATTR_USERDATA] = {.type = NLA_UNSPEC },\n\t\t[OVS_USERSPACE_ATTR_EGRESS_TUN_PORT] = {.type = NLA_U32 },\n\t};\n\tstruct nlattr *a[OVS_USERSPACE_ATTR_MAX + 1];\n\tint error;\n\n\terror = nla_parse_nested_deprecated(a, OVS_USERSPACE_ATTR_MAX, attr,\n\t\t\t\t\t    userspace_policy, NULL);\n\tif (error)\n\t\treturn error;\n\n\tif (!a[OVS_USERSPACE_ATTR_PID] ||\n\t    !nla_get_u32(a[OVS_USERSPACE_ATTR_PID]))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy cpl_policy[OVS_CHECK_PKT_LEN_ATTR_MAX + 1] = {\n\t[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN] = {.type = NLA_U16 },\n\t[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER] = {.type = NLA_NESTED },\n\t[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL] = {.type = NLA_NESTED },\n};\n\nstatic int validate_and_copy_check_pkt_len(struct net *net,\n\t\t\t\t\t   const struct nlattr *attr,\n\t\t\t\t\t   const struct sw_flow_key *key,\n\t\t\t\t\t   struct sw_flow_actions **sfa,\n\t\t\t\t\t   __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t\t   u32 mpls_label_count,\n\t\t\t\t\t   bool log, bool last)\n{\n\tconst struct nlattr *acts_if_greater, *acts_if_lesser_eq;\n\tstruct nlattr *a[OVS_CHECK_PKT_LEN_ATTR_MAX + 1];\n\tstruct check_pkt_len_arg arg;\n\tint nested_acts_start;\n\tint start, err;\n\n\terr = nla_parse_deprecated_strict(a, OVS_CHECK_PKT_LEN_ATTR_MAX,\n\t\t\t\t\t  nla_data(attr), nla_len(attr),\n\t\t\t\t\t  cpl_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!a[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN] ||\n\t    !nla_get_u16(a[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN]))\n\t\treturn -EINVAL;\n\n\tacts_if_lesser_eq = a[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL];\n\tacts_if_greater = a[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER];\n\n\t/* Both the nested action should be present. */\n\tif (!acts_if_greater || !acts_if_lesser_eq)\n\t\treturn -EINVAL;\n\n\t/* validation done, copy the nested actions. */\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_CHECK_PKT_LEN,\n\t\t\t\t\tlog);\n\tif (start < 0)\n\t\treturn start;\n\n\targ.pkt_len = nla_get_u16(a[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN]);\n\targ.exec_for_lesser_equal =\n\t\tlast || !actions_may_change_flow(acts_if_lesser_eq);\n\targ.exec_for_greater =\n\t\tlast || !actions_may_change_flow(acts_if_greater);\n\n\terr = ovs_nla_add_action(sfa, OVS_CHECK_PKT_LEN_ATTR_ARG, &arg,\n\t\t\t\t sizeof(arg), log);\n\tif (err)\n\t\treturn err;\n\n\tnested_acts_start = add_nested_action_start(sfa,\n\t\tOVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL, log);\n\tif (nested_acts_start < 0)\n\t\treturn nested_acts_start;\n\n\terr = __ovs_nla_copy_actions(net, acts_if_lesser_eq, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, nested_acts_start);\n\n\tnested_acts_start = add_nested_action_start(sfa,\n\t\tOVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER, log);\n\tif (nested_acts_start < 0)\n\t\treturn nested_acts_start;\n\n\terr = __ovs_nla_copy_actions(net, acts_if_greater, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, nested_acts_start);\n\tadd_nested_action_end(*sfa, start);\n\treturn 0;\n}\n\nstatic int copy_action(const struct nlattr *from,\n\t\t       struct sw_flow_actions **sfa, bool log)\n{\n\tint totlen = NLA_ALIGN(from->nla_len);\n\tstruct nlattr *to;\n\n\tto = reserve_sfa_size(sfa, from->nla_len, log);\n\tif (IS_ERR(to))\n\t\treturn PTR_ERR(to);\n\n\tmemcpy(to, from, totlen);\n\treturn 0;\n}\n\nstatic int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\n\t\t\t\t  const struct sw_flow_key *key,\n\t\t\t\t  struct sw_flow_actions **sfa,\n\t\t\t\t  __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t  u32 mpls_label_count, bool log)\n{\n\tu8 mac_proto = ovs_key_mac_proto(key);\n\tconst struct nlattr *a;\n\tint rem, err;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\t/* Expected argument lengths, (u32)-1 for variable length. */\n\t\tstatic const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {\n\t\t\t[OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),\n\t\t\t[OVS_ACTION_ATTR_RECIRC] = sizeof(u32),\n\t\t\t[OVS_ACTION_ATTR_USERSPACE] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_PUSH_MPLS] = sizeof(struct ovs_action_push_mpls),\n\t\t\t[OVS_ACTION_ATTR_POP_MPLS] = sizeof(__be16),\n\t\t\t[OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),\n\t\t\t[OVS_ACTION_ATTR_POP_VLAN] = 0,\n\t\t\t[OVS_ACTION_ATTR_SET] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_SET_MASKED] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_SAMPLE] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash),\n\t\t\t[OVS_ACTION_ATTR_CT] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_CT_CLEAR] = 0,\n\t\t\t[OVS_ACTION_ATTR_TRUNC] = sizeof(struct ovs_action_trunc),\n\t\t\t[OVS_ACTION_ATTR_PUSH_ETH] = sizeof(struct ovs_action_push_eth),\n\t\t\t[OVS_ACTION_ATTR_POP_ETH] = 0,\n\t\t\t[OVS_ACTION_ATTR_PUSH_NSH] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_POP_NSH] = 0,\n\t\t\t[OVS_ACTION_ATTR_METER] = sizeof(u32),\n\t\t\t[OVS_ACTION_ATTR_CLONE] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_CHECK_PKT_LEN] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_ADD_MPLS] = sizeof(struct ovs_action_add_mpls),\n\t\t\t[OVS_ACTION_ATTR_DEC_TTL] = (u32)-1,\n\t\t};\n\t\tconst struct ovs_action_push_vlan *vlan;\n\t\tint type = nla_type(a);\n\t\tbool skip_copy;\n\n\t\tif (type > OVS_ACTION_ATTR_MAX ||\n\t\t    (action_lens[type] != nla_len(a) &&\n\t\t     action_lens[type] != (u32)-1))\n\t\t\treturn -EINVAL;\n\n\t\tskip_copy = false;\n\t\tswitch (type) {\n\t\tcase OVS_ACTION_ATTR_UNSPEC:\n\t\t\treturn -EINVAL;\n\n\t\tcase OVS_ACTION_ATTR_USERSPACE:\n\t\t\terr = validate_userspace(a);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_OUTPUT:\n\t\t\tif (nla_get_u32(a) >= DP_MAX_PORTS)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_TRUNC: {\n\t\t\tconst struct ovs_action_trunc *trunc = nla_data(a);\n\n\t\t\tif (trunc->max_len < ETH_HLEN)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_HASH: {\n\t\t\tconst struct ovs_action_hash *act_hash = nla_data(a);\n\n\t\t\tswitch (act_hash->hash_alg) {\n\t\t\tcase OVS_HASH_ALG_L4:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn  -EINVAL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_POP_VLAN:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\t\treturn -EINVAL;\n\t\t\tvlan_tci = htons(0);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_VLAN:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\t\treturn -EINVAL;\n\t\t\tvlan = nla_data(a);\n\t\t\tif (!eth_type_vlan(vlan->vlan_tpid))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!(vlan->vlan_tci & htons(VLAN_CFI_MASK)))\n\t\t\t\treturn -EINVAL;\n\t\t\tvlan_tci = vlan->vlan_tci;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_RECIRC:\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_ADD_MPLS: {\n\t\t\tconst struct ovs_action_add_mpls *mpls = nla_data(a);\n\n\t\t\tif (!eth_p_mpls(mpls->mpls_ethertype))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (mpls->tun_flags & OVS_MPLS_L3_TUNNEL_FLAG_MASK) {\n\t\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK) ||\n\t\t\t\t    (eth_type != htons(ETH_P_IP) &&\n\t\t\t\t     eth_type != htons(ETH_P_IPV6) &&\n\t\t\t\t     eth_type != htons(ETH_P_ARP) &&\n\t\t\t\t     eth_type != htons(ETH_P_RARP) &&\n\t\t\t\t     !eth_p_mpls(eth_type)))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tmpls_label_count++;\n\t\t\t} else {\n\t\t\t\tif (mac_proto == MAC_PROTO_ETHERNET) {\n\t\t\t\t\tmpls_label_count = 1;\n\t\t\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\t\t} else {\n\t\t\t\t\tmpls_label_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\teth_type = mpls->mpls_ethertype;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_PUSH_MPLS: {\n\t\t\tconst struct ovs_action_push_mpls *mpls = nla_data(a);\n\n\t\t\tif (!eth_p_mpls(mpls->mpls_ethertype))\n\t\t\t\treturn -EINVAL;\n\t\t\t/* Prohibit push MPLS other than to a white list\n\t\t\t * for packets that have a known tag order.\n\t\t\t */\n\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK) ||\n\t\t\t    (eth_type != htons(ETH_P_IP) &&\n\t\t\t     eth_type != htons(ETH_P_IPV6) &&\n\t\t\t     eth_type != htons(ETH_P_ARP) &&\n\t\t\t     eth_type != htons(ETH_P_RARP) &&\n\t\t\t     !eth_p_mpls(eth_type)))\n\t\t\t\treturn -EINVAL;\n\t\t\teth_type = mpls->mpls_ethertype;\n\t\t\tmpls_label_count++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_POP_MPLS: {\n\t\t\t__be16  proto;\n\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK) ||\n\t\t\t    !eth_p_mpls(eth_type))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Disallow subsequent L2.5+ set actions and mpls_pop\n\t\t\t * actions once the last MPLS label in the packet is\n\t\t\t * is popped as there is no check here to ensure that\n\t\t\t * the new eth type is valid and thus set actions could\n\t\t\t * write off the end of the packet or otherwise corrupt\n\t\t\t * it.\n\t\t\t *\n\t\t\t * Support for these actions is planned using packet\n\t\t\t * recirculation.\n\t\t\t */\n\t\t\tproto = nla_get_be16(a);\n\n\t\t\tif (proto == htons(ETH_P_TEB) &&\n\t\t\t    mac_proto != MAC_PROTO_NONE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmpls_label_count--;\n\n\t\t\tif (!eth_p_mpls(proto) || !mpls_label_count)\n\t\t\t\teth_type = htons(0);\n\t\t\telse\n\t\t\t\teth_type =  proto;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\terr = validate_set(a, key, sfa,\n\t\t\t\t\t   &skip_copy, mac_proto, eth_type,\n\t\t\t\t\t   false, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET_MASKED:\n\t\t\terr = validate_set(a, key, sfa,\n\t\t\t\t\t   &skip_copy, mac_proto, eth_type,\n\t\t\t\t\t   true, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = validate_and_copy_sample(net, a, key, sfa,\n\t\t\t\t\t\t       eth_type, vlan_tci,\n\t\t\t\t\t\t       mpls_label_count,\n\t\t\t\t\t\t       log, last);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\terr = ovs_ct_copy_action(net, a, key, sfa, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT_CLEAR:\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_ETH:\n\t\t\t/* Disallow pushing an Ethernet header if one\n\t\t\t * is already present */\n\t\t\tif (mac_proto != MAC_PROTO_NONE)\n\t\t\t\treturn -EINVAL;\n\t\t\tmac_proto = MAC_PROTO_ETHERNET;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_POP_ETH:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK))\n\t\t\t\treturn -EINVAL;\n\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_NSH:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET) {\n\t\t\t\tu8 next_proto;\n\n\t\t\t\tnext_proto = tun_p_from_eth_p(eth_type);\n\t\t\t\tif (!next_proto)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\tif (!validate_nsh(nla_data(a), false, true, true))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_POP_NSH: {\n\t\t\t__be16 inner_proto;\n\n\t\t\tif (eth_type != htons(ETH_P_NSH))\n\t\t\t\treturn -EINVAL;\n\t\t\tinner_proto = tun_p_to_eth_p(key->nsh.base.np);\n\t\t\tif (!inner_proto)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (key->nsh.base.np == TUN_P_ETHERNET)\n\t\t\t\tmac_proto = MAC_PROTO_ETHERNET;\n\t\t\telse\n\t\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_METER:\n\t\t\t/* Non-existent meters are simply ignored.  */\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = validate_and_copy_clone(net, a, key, sfa,\n\t\t\t\t\t\t      eth_type, vlan_tci,\n\t\t\t\t\t\t      mpls_label_count,\n\t\t\t\t\t\t      log, last);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = validate_and_copy_check_pkt_len(net, a, key, sfa,\n\t\t\t\t\t\t\t      eth_type,\n\t\t\t\t\t\t\t      vlan_tci,\n\t\t\t\t\t\t\t      mpls_label_count,\n\t\t\t\t\t\t\t      log, last);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\terr = validate_and_copy_dec_ttl(net, a, key, sfa,\n\t\t\t\t\t\t\teth_type, vlan_tci,\n\t\t\t\t\t\t\tmpls_label_count, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown Action type %d\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!skip_copy) {\n\t\t\terr = copy_action(a, sfa, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (rem > 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* 'key' must be the masked key. */\nint ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\n\t\t\t const struct sw_flow_key *key,\n\t\t\t struct sw_flow_actions **sfa, bool log)\n{\n\tint err;\n\tu32 mpls_label_count = 0;\n\n\t*sfa = nla_alloc_flow_actions(min(nla_len(attr), MAX_ACTIONS_BUFSIZE));\n\tif (IS_ERR(*sfa))\n\t\treturn PTR_ERR(*sfa);\n\n\tif (eth_p_mpls(key->eth.type))\n\t\tmpls_label_count = hweight_long(key->mpls.num_labels_mask);\n\n\t(*sfa)->orig_len = nla_len(attr);\n\terr = __ovs_nla_copy_actions(net, attr, key, sfa, key->eth.type,\n\t\t\t\t     key->eth.vlan.tci, mpls_label_count, log);\n\tif (err)\n\t\tovs_nla_free_flow_actions(*sfa);\n\n\treturn err;\n}\n\nstatic int sample_action_to_attr(const struct nlattr *attr,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct nlattr *start, *ac_start = NULL, *sample_arg;\n\tint err = 0, rem = nla_len(attr);\n\tconst struct sample_arg *arg;\n\tstruct nlattr *actions;\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_SAMPLE);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tsample_arg = nla_data(attr);\n\targ = nla_data(sample_arg);\n\tactions = nla_next(sample_arg, &rem);\n\n\tif (nla_put_u32(skb, OVS_SAMPLE_ATTR_PROBABILITY, arg->probability)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tac_start = nla_nest_start_noflag(skb, OVS_SAMPLE_ATTR_ACTIONS);\n\tif (!ac_start) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ovs_nla_put_actions(actions, rem, skb);\n\nout:\n\tif (err) {\n\t\tnla_nest_cancel(skb, ac_start);\n\t\tnla_nest_cancel(skb, start);\n\t} else {\n\t\tnla_nest_end(skb, ac_start);\n\t\tnla_nest_end(skb, start);\n\t}\n\n\treturn err;\n}\n\nstatic int clone_action_to_attr(const struct nlattr *attr,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nlattr *start;\n\tint err = 0, rem = nla_len(attr);\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_CLONE);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\t/* Skipping the OVS_CLONE_ATTR_EXEC that is always the first attribute. */\n\tattr = nla_next(nla_data(attr), &rem);\n\terr = ovs_nla_put_actions(attr, rem, skb);\n\n\tif (err)\n\t\tnla_nest_cancel(skb, start);\n\telse\n\t\tnla_nest_end(skb, start);\n\n\treturn err;\n}\n\nstatic int check_pkt_len_action_to_attr(const struct nlattr *attr,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nlattr *start, *ac_start = NULL;\n\tconst struct check_pkt_len_arg *arg;\n\tconst struct nlattr *a, *cpl_arg;\n\tint err = 0, rem = nla_len(attr);\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_CHECK_PKT_LEN);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\t/* The first nested attribute in 'attr' is always\n\t * 'OVS_CHECK_PKT_LEN_ATTR_ARG'.\n\t */\n\tcpl_arg = nla_data(attr);\n\targ = nla_data(cpl_arg);\n\n\tif (nla_put_u16(skb, OVS_CHECK_PKT_LEN_ATTR_PKT_LEN, arg->pkt_len)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* Second nested attribute in 'attr' is always\n\t * 'OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL'.\n\t */\n\ta = nla_next(cpl_arg, &rem);\n\tac_start =  nla_nest_start_noflag(skb,\n\t\t\t\t\t  OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL);\n\tif (!ac_start) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, ac_start);\n\t\tgoto out;\n\t} else {\n\t\tnla_nest_end(skb, ac_start);\n\t}\n\n\t/* Third nested attribute in 'attr' is always\n\t * OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER.\n\t */\n\ta = nla_next(a, &rem);\n\tac_start =  nla_nest_start_noflag(skb,\n\t\t\t\t\t  OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER);\n\tif (!ac_start) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, ac_start);\n\t\tgoto out;\n\t} else {\n\t\tnla_nest_end(skb, ac_start);\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n\nout:\n\tnla_nest_cancel(skb, start);\n\treturn err;\n}\n\nstatic int dec_ttl_action_to_attr(const struct nlattr *attr,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct nlattr *start, *action_start;\n\tconst struct nlattr *a;\n\tint err = 0, rem;\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_DEC_TTL);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tnla_for_each_attr(a, nla_data(attr), nla_len(attr), rem) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_DEC_TTL_ATTR_ACTION:\n\n\t\t\taction_start = nla_nest_start_noflag(skb, OVS_DEC_TTL_ATTR_ACTION);\n\t\t\tif (!action_start) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnla_nest_end(skb, action_start);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Ignore all other option to be future compatible */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n\nout:\n\tnla_nest_cancel(skb, start);\n\treturn err;\n}\n\nstatic int set_action_to_attr(const struct nlattr *a, struct sk_buff *skb)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tint key_type = nla_type(ovs_key);\n\tstruct nlattr *start;\n\tint err;\n\n\tswitch (key_type) {\n\tcase OVS_KEY_ATTR_TUNNEL_INFO: {\n\t\tstruct ovs_tunnel_info *ovs_tun = nla_data(ovs_key);\n\t\tstruct ip_tunnel_info *tun_info = &ovs_tun->tun_dst->u.tun_info;\n\n\t\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_SET);\n\t\tif (!start)\n\t\t\treturn -EMSGSIZE;\n\n\t\terr =  ip_tun_to_nlattr(skb, &tun_info->key,\n\t\t\t\t\tip_tunnel_info_opts(tun_info),\n\t\t\t\t\ttun_info->options_len,\n\t\t\t\t\tip_tunnel_info_af(tun_info), tun_info->mode);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnla_nest_end(skb, start);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a), ovs_key))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int masked_set_action_to_set_action_attr(const struct nlattr *a,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tstruct nlattr *nla;\n\tsize_t key_len = nla_len(ovs_key) / 2;\n\n\t/* Revert the conversion we did from a non-masked set action to\n\t * masked set action.\n\t */\n\tnla = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_SET);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put(skb, nla_type(ovs_key), key_len, nla_data(ovs_key)))\n\t\treturn -EMSGSIZE;\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\nint ovs_nla_put_actions(const struct nlattr *attr, int len, struct sk_buff *skb)\n{\n\tconst struct nlattr *a;\n\tint rem, err;\n\n\tnla_for_each_attr(a, attr, len, rem) {\n\t\tint type = nla_type(a);\n\n\t\tswitch (type) {\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\terr = set_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET_TO_MASKED:\n\t\t\terr = masked_set_action_to_set_action_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE:\n\t\t\terr = sample_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\terr = ovs_ct_action_to_attr(nla_data(a), skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE:\n\t\t\terr = clone_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN:\n\t\t\terr = check_pkt_len_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\terr = dec_ttl_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (nla_put(skb, type, nla_len(a), nla_data(a)))\n\t\t\t\treturn -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2007-2017 Nicira, Inc.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"flow.h\"\n#include \"datapath.h\"\n#include <linux/uaccess.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <net/llc_pdu.h>\n#include <linux/kernel.h>\n#include <linux/jhash.h>\n#include <linux/jiffies.h>\n#include <linux/llc.h>\n#include <linux/module.h>\n#include <linux/in.h>\n#include <linux/rcupdate.h>\n#include <linux/if_arp.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/sctp.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/rculist.h>\n#include <net/geneve.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/mpls.h>\n#include <net/vxlan.h>\n#include <net/tun_proto.h>\n#include <net/erspan.h>\n\n#include \"flow_netlink.h\"\n\nstruct ovs_len_tbl {\n\tint len;\n\tconst struct ovs_len_tbl *next;\n};\n\n#define OVS_ATTR_NESTED -1\n#define OVS_ATTR_VARIABLE -2\n\nstatic bool actions_may_change_flow(const struct nlattr *actions)\n{\n\tstruct nlattr *nla;\n\tint rem;\n\n\tnla_for_each_nested(nla, actions, rem) {\n\t\tu16 action = nla_type(nla);\n\n\t\tswitch (action) {\n\t\tcase OVS_ACTION_ATTR_OUTPUT:\n\t\tcase OVS_ACTION_ATTR_RECIRC:\n\t\tcase OVS_ACTION_ATTR_TRUNC:\n\t\tcase OVS_ACTION_ATTR_USERSPACE:\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\tcase OVS_ACTION_ATTR_CT_CLEAR:\n\t\tcase OVS_ACTION_ATTR_HASH:\n\t\tcase OVS_ACTION_ATTR_POP_ETH:\n\t\tcase OVS_ACTION_ATTR_POP_MPLS:\n\t\tcase OVS_ACTION_ATTR_POP_NSH:\n\t\tcase OVS_ACTION_ATTR_POP_VLAN:\n\t\tcase OVS_ACTION_ATTR_PUSH_ETH:\n\t\tcase OVS_ACTION_ATTR_PUSH_MPLS:\n\t\tcase OVS_ACTION_ATTR_PUSH_NSH:\n\t\tcase OVS_ACTION_ATTR_PUSH_VLAN:\n\t\tcase OVS_ACTION_ATTR_SAMPLE:\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\tcase OVS_ACTION_ATTR_SET_MASKED:\n\t\tcase OVS_ACTION_ATTR_METER:\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN:\n\t\tcase OVS_ACTION_ATTR_ADD_MPLS:\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void update_range(struct sw_flow_match *match,\n\t\t\t size_t offset, size_t size, bool is_mask)\n{\n\tstruct sw_flow_key_range *range;\n\tsize_t start = rounddown(offset, sizeof(long));\n\tsize_t end = roundup(offset + size, sizeof(long));\n\n\tif (!is_mask)\n\t\trange = &match->range;\n\telse\n\t\trange = &match->mask->range;\n\n\tif (range->start == range->end) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\treturn;\n\t}\n\n\tif (range->start > start)\n\t\trange->start = start;\n\n\tif (range->end < end)\n\t\trange->end = end;\n}\n\n#define SW_FLOW_KEY_PUT(match, field, value, is_mask) \\\n\tdo { \\\n\t\tupdate_range(match, offsetof(struct sw_flow_key, field),    \\\n\t\t\t     sizeof((match)->key->field), is_mask);\t    \\\n\t\tif (is_mask)\t\t\t\t\t\t    \\\n\t\t\t(match)->mask->key.field = value;\t\t    \\\n\t\telse\t\t\t\t\t\t\t    \\\n\t\t\t(match)->key->field = value;\t\t            \\\n\t} while (0)\n\n#define SW_FLOW_KEY_MEMCPY_OFFSET(match, offset, value_p, len, is_mask)\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\tupdate_range(match, offset, len, is_mask);\t\t    \\\n\t\tif (is_mask)\t\t\t\t\t\t    \\\n\t\t\tmemcpy((u8 *)&(match)->mask->key + offset, value_p, \\\n\t\t\t       len);\t\t\t\t\t   \\\n\t\telse\t\t\t\t\t\t\t    \\\n\t\t\tmemcpy((u8 *)(match)->key + offset, value_p, len);  \\\n\t} while (0)\n\n#define SW_FLOW_KEY_MEMCPY(match, field, value_p, len, is_mask)\t\t      \\\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, offsetof(struct sw_flow_key, field), \\\n\t\t\t\t  value_p, len, is_mask)\n\n#define SW_FLOW_KEY_MEMSET_FIELD(match, field, value, is_mask)\t\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\tupdate_range(match, offsetof(struct sw_flow_key, field),    \\\n\t\t\t     sizeof((match)->key->field), is_mask);\t    \\\n\t\tif (is_mask)\t\t\t\t\t\t    \\\n\t\t\tmemset((u8 *)&(match)->mask->key.field, value,      \\\n\t\t\t       sizeof((match)->mask->key.field));\t    \\\n\t\telse\t\t\t\t\t\t\t    \\\n\t\t\tmemset((u8 *)&(match)->key->field, value,           \\\n\t\t\t       sizeof((match)->key->field));                \\\n\t} while (0)\n\nstatic bool match_validate(const struct sw_flow_match *match,\n\t\t\t   u64 key_attrs, u64 mask_attrs, bool log)\n{\n\tu64 key_expected = 0;\n\tu64 mask_allowed = key_attrs;  /* At most allow all key attributes */\n\n\t/* The following mask attributes allowed only if they\n\t * pass the validation tests. */\n\tmask_allowed &= ~((1 << OVS_KEY_ATTR_IPV4)\n\t\t\t| (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4)\n\t\t\t| (1 << OVS_KEY_ATTR_IPV6)\n\t\t\t| (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6)\n\t\t\t| (1 << OVS_KEY_ATTR_TCP)\n\t\t\t| (1 << OVS_KEY_ATTR_TCP_FLAGS)\n\t\t\t| (1 << OVS_KEY_ATTR_UDP)\n\t\t\t| (1 << OVS_KEY_ATTR_SCTP)\n\t\t\t| (1 << OVS_KEY_ATTR_ICMP)\n\t\t\t| (1 << OVS_KEY_ATTR_ICMPV6)\n\t\t\t| (1 << OVS_KEY_ATTR_ARP)\n\t\t\t| (1 << OVS_KEY_ATTR_ND)\n\t\t\t| (1 << OVS_KEY_ATTR_MPLS)\n\t\t\t| (1 << OVS_KEY_ATTR_NSH));\n\n\t/* Always allowed mask fields. */\n\tmask_allowed |= ((1 << OVS_KEY_ATTR_TUNNEL)\n\t\t       | (1 << OVS_KEY_ATTR_IN_PORT)\n\t\t       | (1 << OVS_KEY_ATTR_ETHERTYPE));\n\n\t/* Check key attributes. */\n\tif (match->key->eth.type == htons(ETH_P_ARP)\n\t\t\t|| match->key->eth.type == htons(ETH_P_RARP)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_ARP;\n\t\tif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ARP;\n\t}\n\n\tif (eth_p_mpls(match->key->eth.type)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_MPLS;\n\t\tif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_MPLS;\n\t}\n\n\tif (match->key->eth.type == htons(ETH_P_IP)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_IPV4;\n\t\tif (match->mask && match->mask->key.eth.type == htons(0xffff)) {\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_IPV4;\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4;\n\t\t}\n\n\t\tif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\n\t\t\tif (match->key->ip.proto == IPPROTO_UDP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_SCTP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_TCP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff)) {\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_ICMP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_ICMP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ICMP;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (match->key->eth.type == htons(ETH_P_IPV6)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_IPV6;\n\t\tif (match->mask && match->mask->key.eth.type == htons(0xffff)) {\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_IPV6;\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6;\n\t\t}\n\n\t\tif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\n\t\t\tif (match->key->ip.proto == IPPROTO_UDP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_SCTP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_TCP) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff)) {\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match->key->ip.proto == IPPROTO_ICMPV6) {\n\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_ICMPV6;\n\t\t\t\tif (match->mask && (match->mask->key.ip.proto == 0xff))\n\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ICMPV6;\n\n\t\t\t\tif (match->key->tp.src ==\n\t\t\t\t\t\thtons(NDISC_NEIGHBOUR_SOLICITATION) ||\n\t\t\t\t    match->key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) {\n\t\t\t\t\tkey_expected |= 1 << OVS_KEY_ATTR_ND;\n\t\t\t\t\t/* Original direction conntrack tuple\n\t\t\t\t\t * uses the same space as the ND fields\n\t\t\t\t\t * in the key, so both are not allowed\n\t\t\t\t\t * at the same time.\n\t\t\t\t\t */\n\t\t\t\t\tmask_allowed &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6);\n\t\t\t\t\tif (match->mask && (match->mask->key.tp.src == htons(0xff)))\n\t\t\t\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_ND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (match->key->eth.type == htons(ETH_P_NSH)) {\n\t\tkey_expected |= 1 << OVS_KEY_ATTR_NSH;\n\t\tif (match->mask &&\n\t\t    match->mask->key.eth.type == htons(0xffff)) {\n\t\t\tmask_allowed |= 1 << OVS_KEY_ATTR_NSH;\n\t\t}\n\t}\n\n\tif ((key_attrs & key_expected) != key_expected) {\n\t\t/* Key attributes check failed. */\n\t\tOVS_NLERR(log, \"Missing key (keys=%llx, expected=%llx)\",\n\t\t\t  (unsigned long long)key_attrs,\n\t\t\t  (unsigned long long)key_expected);\n\t\treturn false;\n\t}\n\n\tif ((mask_attrs & mask_allowed) != mask_attrs) {\n\t\t/* Mask attributes check failed. */\n\t\tOVS_NLERR(log, \"Unexpected mask (mask=%llx, allowed=%llx)\",\n\t\t\t  (unsigned long long)mask_attrs,\n\t\t\t  (unsigned long long)mask_allowed);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nsize_t ovs_tun_key_attr_size(void)\n{\n\t/* Whenever adding new OVS_TUNNEL_KEY_ FIELDS, we should consider\n\t * updating this function.\n\t */\n\treturn    nla_total_size_64bit(8) /* OVS_TUNNEL_KEY_ATTR_ID */\n\t\t+ nla_total_size(16)   /* OVS_TUNNEL_KEY_ATTR_IPV[46]_SRC */\n\t\t+ nla_total_size(16)   /* OVS_TUNNEL_KEY_ATTR_IPV[46]_DST */\n\t\t+ nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TOS */\n\t\t+ nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TTL */\n\t\t+ nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT */\n\t\t+ nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_CSUM */\n\t\t+ nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_OAM */\n\t\t+ nla_total_size(256)  /* OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS */\n\t\t/* OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS and\n\t\t * OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS is mutually exclusive with\n\t\t * OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS and covered by it.\n\t\t */\n\t\t+ nla_total_size(2)    /* OVS_TUNNEL_KEY_ATTR_TP_SRC */\n\t\t+ nla_total_size(2);   /* OVS_TUNNEL_KEY_ATTR_TP_DST */\n}\n\nstatic size_t ovs_nsh_key_attr_size(void)\n{\n\t/* Whenever adding new OVS_NSH_KEY_ FIELDS, we should consider\n\t * updating this function.\n\t */\n\treturn  nla_total_size(NSH_BASE_HDR_LEN) /* OVS_NSH_KEY_ATTR_BASE */\n\t\t/* OVS_NSH_KEY_ATTR_MD1 and OVS_NSH_KEY_ATTR_MD2 are\n\t\t * mutually exclusive, so the bigger one can cover\n\t\t * the small one.\n\t\t */\n\t\t+ nla_total_size(NSH_CTX_HDRS_MAX_LEN);\n}\n\nsize_t ovs_key_attr_size(void)\n{\n\t/* Whenever adding new OVS_KEY_ FIELDS, we should consider\n\t * updating this function.\n\t */\n\tBUILD_BUG_ON(OVS_KEY_ATTR_MAX != 32);\n\n\treturn    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */\n\t\t+ nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */\n\t\t  + ovs_tun_key_attr_size()\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_IN_PORT */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_STATE */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_CT_ZONE */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_CT_MARK */\n\t\t+ nla_total_size(16)  /* OVS_KEY_ATTR_CT_LABELS */\n\t\t+ nla_total_size(40)  /* OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6 */\n\t\t+ nla_total_size(0)   /* OVS_KEY_ATTR_NSH */\n\t\t  + ovs_nsh_key_attr_size()\n\t\t+ nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\n\t\t+ nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */\n\t\t+ nla_total_size(0)   /* OVS_KEY_ATTR_ENCAP */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\n\t\t+ nla_total_size(40)  /* OVS_KEY_ATTR_IPV6 */\n\t\t+ nla_total_size(2)   /* OVS_KEY_ATTR_ICMPV6 */\n\t\t+ nla_total_size(28)  /* OVS_KEY_ATTR_ND */\n\t\t+ nla_total_size(2);  /* OVS_KEY_ATTR_IPV6_EXTHDRS */\n}\n\nstatic const struct ovs_len_tbl ovs_vxlan_ext_key_lens[OVS_VXLAN_EXT_MAX + 1] = {\n\t[OVS_VXLAN_EXT_GBP]\t    = { .len = sizeof(u32) },\n};\n\nstatic const struct ovs_len_tbl ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1] = {\n\t[OVS_TUNNEL_KEY_ATTR_ID]\t    = { .len = sizeof(u64) },\n\t[OVS_TUNNEL_KEY_ATTR_IPV4_SRC]\t    = { .len = sizeof(u32) },\n\t[OVS_TUNNEL_KEY_ATTR_IPV4_DST]\t    = { .len = sizeof(u32) },\n\t[OVS_TUNNEL_KEY_ATTR_TOS]\t    = { .len = 1 },\n\t[OVS_TUNNEL_KEY_ATTR_TTL]\t    = { .len = 1 },\n\t[OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = { .len = 0 },\n\t[OVS_TUNNEL_KEY_ATTR_CSUM]\t    = { .len = 0 },\n\t[OVS_TUNNEL_KEY_ATTR_TP_SRC]\t    = { .len = sizeof(u16) },\n\t[OVS_TUNNEL_KEY_ATTR_TP_DST]\t    = { .len = sizeof(u16) },\n\t[OVS_TUNNEL_KEY_ATTR_OAM]\t    = { .len = 0 },\n\t[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = { .len = OVS_ATTR_VARIABLE },\n\t[OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = { .len = OVS_ATTR_NESTED,\n\t\t\t\t\t\t.next = ovs_vxlan_ext_key_lens },\n\t[OVS_TUNNEL_KEY_ATTR_IPV6_SRC]      = { .len = sizeof(struct in6_addr) },\n\t[OVS_TUNNEL_KEY_ATTR_IPV6_DST]      = { .len = sizeof(struct in6_addr) },\n\t[OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS]   = { .len = OVS_ATTR_VARIABLE },\n\t[OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE]   = { .len = 0 },\n};\n\nstatic const struct ovs_len_tbl\novs_nsh_key_attr_lens[OVS_NSH_KEY_ATTR_MAX + 1] = {\n\t[OVS_NSH_KEY_ATTR_BASE] = { .len = sizeof(struct ovs_nsh_key_base) },\n\t[OVS_NSH_KEY_ATTR_MD1]  = { .len = sizeof(struct ovs_nsh_key_md1) },\n\t[OVS_NSH_KEY_ATTR_MD2]  = { .len = OVS_ATTR_VARIABLE },\n};\n\n/* The size of the argument for each %OVS_KEY_ATTR_* Netlink attribute.  */\nstatic const struct ovs_len_tbl ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {\n\t[OVS_KEY_ATTR_ENCAP]\t = { .len = OVS_ATTR_NESTED },\n\t[OVS_KEY_ATTR_PRIORITY]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_IN_PORT]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_SKB_MARK]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_ETHERNET]\t = { .len = sizeof(struct ovs_key_ethernet) },\n\t[OVS_KEY_ATTR_VLAN]\t = { .len = sizeof(__be16) },\n\t[OVS_KEY_ATTR_ETHERTYPE] = { .len = sizeof(__be16) },\n\t[OVS_KEY_ATTR_IPV4]\t = { .len = sizeof(struct ovs_key_ipv4) },\n\t[OVS_KEY_ATTR_IPV6]\t = { .len = sizeof(struct ovs_key_ipv6) },\n\t[OVS_KEY_ATTR_TCP]\t = { .len = sizeof(struct ovs_key_tcp) },\n\t[OVS_KEY_ATTR_TCP_FLAGS] = { .len = sizeof(__be16) },\n\t[OVS_KEY_ATTR_UDP]\t = { .len = sizeof(struct ovs_key_udp) },\n\t[OVS_KEY_ATTR_SCTP]\t = { .len = sizeof(struct ovs_key_sctp) },\n\t[OVS_KEY_ATTR_ICMP]\t = { .len = sizeof(struct ovs_key_icmp) },\n\t[OVS_KEY_ATTR_ICMPV6]\t = { .len = sizeof(struct ovs_key_icmpv6) },\n\t[OVS_KEY_ATTR_ARP]\t = { .len = sizeof(struct ovs_key_arp) },\n\t[OVS_KEY_ATTR_ND]\t = { .len = sizeof(struct ovs_key_nd) },\n\t[OVS_KEY_ATTR_RECIRC_ID] = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_DP_HASH]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_TUNNEL]\t = { .len = OVS_ATTR_NESTED,\n\t\t\t\t     .next = ovs_tunnel_key_lens, },\n\t[OVS_KEY_ATTR_MPLS]\t = { .len = OVS_ATTR_VARIABLE },\n\t[OVS_KEY_ATTR_CT_STATE]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_CT_ZONE]\t = { .len = sizeof(u16) },\n\t[OVS_KEY_ATTR_CT_MARK]\t = { .len = sizeof(u32) },\n\t[OVS_KEY_ATTR_CT_LABELS] = { .len = sizeof(struct ovs_key_ct_labels) },\n\t[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4] = {\n\t\t.len = sizeof(struct ovs_key_ct_tuple_ipv4) },\n\t[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6] = {\n\t\t.len = sizeof(struct ovs_key_ct_tuple_ipv6) },\n\t[OVS_KEY_ATTR_NSH]       = { .len = OVS_ATTR_NESTED,\n\t\t\t\t     .next = ovs_nsh_key_attr_lens, },\n\t[OVS_KEY_ATTR_IPV6_EXTHDRS] = {\n\t\t.len = sizeof(struct ovs_key_ipv6_exthdrs) },\n};\n\nstatic bool check_attr_len(unsigned int attr_len, unsigned int expected_len)\n{\n\treturn expected_len == attr_len ||\n\t       expected_len == OVS_ATTR_NESTED ||\n\t       expected_len == OVS_ATTR_VARIABLE;\n}\n\nstatic bool is_all_zero(const u8 *fp, size_t size)\n{\n\tint i;\n\n\tif (!fp)\n\t\treturn false;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (fp[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int __parse_flow_nlattrs(const struct nlattr *attr,\n\t\t\t\tconst struct nlattr *a[],\n\t\t\t\tu64 *attrsp, bool log, bool nz)\n{\n\tconst struct nlattr *nla;\n\tu64 attrs;\n\tint rem;\n\n\tattrs = *attrsp;\n\tnla_for_each_nested(nla, attr, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tint expected_len;\n\n\t\tif (type > OVS_KEY_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"Key type %d is out of range max %d\",\n\t\t\t\t  type, OVS_KEY_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (type == OVS_KEY_ATTR_PACKET_TYPE ||\n\t\t    type == OVS_KEY_ATTR_ND_EXTENSIONS ||\n\t\t    type == OVS_KEY_ATTR_TUNNEL_INFO) {\n\t\t\tOVS_NLERR(log, \"Key type %d is not supported\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (attrs & (1ULL << type)) {\n\t\t\tOVS_NLERR(log, \"Duplicate key (type %d).\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\texpected_len = ovs_key_lens[type].len;\n\t\tif (!check_attr_len(nla_len(nla), expected_len)) {\n\t\t\tOVS_NLERR(log, \"Key %d has unexpected len %d expected %d\",\n\t\t\t\t  type, nla_len(nla), expected_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!nz || !is_all_zero(nla_data(nla), nla_len(nla))) {\n\t\t\tattrs |= 1ULL << type;\n\t\t\ta[type] = nla;\n\t\t}\n\t}\n\tif (rem) {\n\t\tOVS_NLERR(log, \"Message has %d unknown bytes.\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\t*attrsp = attrs;\n\treturn 0;\n}\n\nstatic int parse_flow_mask_nlattrs(const struct nlattr *attr,\n\t\t\t\t   const struct nlattr *a[], u64 *attrsp,\n\t\t\t\t   bool log)\n{\n\treturn __parse_flow_nlattrs(attr, a, attrsp, log, true);\n}\n\nint parse_flow_nlattrs(const struct nlattr *attr, const struct nlattr *a[],\n\t\t       u64 *attrsp, bool log)\n{\n\treturn __parse_flow_nlattrs(attr, a, attrsp, log, false);\n}\n\nstatic int genev_tun_opt_from_nlattr(const struct nlattr *a,\n\t\t\t\t     struct sw_flow_match *match, bool is_mask,\n\t\t\t\t     bool log)\n{\n\tunsigned long opt_key_offset;\n\n\tif (nla_len(a) > sizeof(match->key->tun_opts)) {\n\t\tOVS_NLERR(log, \"Geneve option length err (len %d, max %zu).\",\n\t\t\t  nla_len(a), sizeof(match->key->tun_opts));\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_len(a) % 4 != 0) {\n\t\tOVS_NLERR(log, \"Geneve opt len %d is not a multiple of 4.\",\n\t\t\t  nla_len(a));\n\t\treturn -EINVAL;\n\t}\n\n\t/* We need to record the length of the options passed\n\t * down, otherwise packets with the same format but\n\t * additional options will be silently matched.\n\t */\n\tif (!is_mask) {\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),\n\t\t\t\tfalse);\n\t} else {\n\t\t/* This is somewhat unusual because it looks at\n\t\t * both the key and mask while parsing the\n\t\t * attributes (and by extension assumes the key\n\t\t * is parsed first). Normally, we would verify\n\t\t * that each is the correct length and that the\n\t\t * attributes line up in the validate function.\n\t\t * However, that is difficult because this is\n\t\t * variable length and we won't have the\n\t\t * information later.\n\t\t */\n\t\tif (match->key->tun_opts_len != nla_len(a)) {\n\t\t\tOVS_NLERR(log, \"Geneve option len %d != mask len %d\",\n\t\t\t\t  match->key->tun_opts_len, nla_len(a));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\n\t}\n\n\topt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\n\t\t\t\t  nla_len(a), is_mask);\n\treturn 0;\n}\n\nstatic int vxlan_tun_opt_from_nlattr(const struct nlattr *attr,\n\t\t\t\t     struct sw_flow_match *match, bool is_mask,\n\t\t\t\t     bool log)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tunsigned long opt_key_offset;\n\tstruct vxlan_metadata opts;\n\n\tBUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));\n\n\tmemset(&opts, 0, sizeof(opts));\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\tif (type > OVS_VXLAN_EXT_MAX) {\n\t\t\tOVS_NLERR(log, \"VXLAN extension %d out of range max %d\",\n\t\t\t\t  type, OVS_VXLAN_EXT_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!check_attr_len(nla_len(a),\n\t\t\t\t    ovs_vxlan_ext_key_lens[type].len)) {\n\t\t\tOVS_NLERR(log, \"VXLAN extension %d has unexpected len %d expected %d\",\n\t\t\t\t  type, nla_len(a),\n\t\t\t\t  ovs_vxlan_ext_key_lens[type].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_VXLAN_EXT_GBP:\n\t\t\topts.gbp = nla_get_u32(a);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown VXLAN extension attribute %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (rem) {\n\t\tOVS_NLERR(log, \"VXLAN extension message has %d unknown bytes.\",\n\t\t\t  rem);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask)\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false);\n\telse\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\n\n\topt_key_offset = TUN_METADATA_OFFSET(sizeof(opts));\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts),\n\t\t\t\t  is_mask);\n\treturn 0;\n}\n\nstatic int erspan_tun_opt_from_nlattr(const struct nlattr *a,\n\t\t\t\t      struct sw_flow_match *match, bool is_mask,\n\t\t\t\t      bool log)\n{\n\tunsigned long opt_key_offset;\n\n\tBUILD_BUG_ON(sizeof(struct erspan_metadata) >\n\t\t     sizeof(match->key->tun_opts));\n\n\tif (nla_len(a) > sizeof(match->key->tun_opts)) {\n\t\tOVS_NLERR(log, \"ERSPAN option length err (len %d, max %zu).\",\n\t\t\t  nla_len(a), sizeof(match->key->tun_opts));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask)\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len,\n\t\t\t\tsizeof(struct erspan_metadata), false);\n\telse\n\t\tSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\n\n\topt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\n\tSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\n\t\t\t\t  nla_len(a), is_mask);\n\treturn 0;\n}\n\nstatic int ip_tun_from_nlattr(const struct nlattr *attr,\n\t\t\t      struct sw_flow_match *match, bool is_mask,\n\t\t\t      bool log)\n{\n\tbool ttl = false, ipv4 = false, ipv6 = false;\n\tbool info_bridge_mode = false;\n\t__be16 tun_flags = 0;\n\tint opts_type = 0;\n\tstruct nlattr *a;\n\tint rem;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tint err;\n\n\t\tif (type > OVS_TUNNEL_KEY_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"Tunnel attr %d out of range max %d\",\n\t\t\t\t  type, OVS_TUNNEL_KEY_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!check_attr_len(nla_len(a),\n\t\t\t\t    ovs_tunnel_key_lens[type].len)) {\n\t\t\tOVS_NLERR(log, \"Tunnel attr %d has unexpected len %d expected %d\",\n\t\t\t\t  type, nla_len(a), ovs_tunnel_key_lens[type].len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_TUNNEL_KEY_ATTR_ID:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tun_id,\n\t\t\t\t\tnla_get_be64(a), is_mask);\n\t\t\ttun_flags |= TUNNEL_KEY;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV4_SRC:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv4.src,\n\t\t\t\t\tnla_get_in_addr(a), is_mask);\n\t\t\tipv4 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV4_DST:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv4.dst,\n\t\t\t\t\tnla_get_in_addr(a), is_mask);\n\t\t\tipv4 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV6_SRC:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv6.src,\n\t\t\t\t\tnla_get_in6_addr(a), is_mask);\n\t\t\tipv6 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV6_DST:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,\n\t\t\t\t\tnla_get_in6_addr(a), is_mask);\n\t\t\tipv6 = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TOS:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tos,\n\t\t\t\t\tnla_get_u8(a), is_mask);\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TTL:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.ttl,\n\t\t\t\t\tnla_get_u8(a), is_mask);\n\t\t\tttl = true;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT:\n\t\t\ttun_flags |= TUNNEL_DONT_FRAGMENT;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_CSUM:\n\t\t\ttun_flags |= TUNNEL_CSUM;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TP_SRC:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tp_src,\n\t\t\t\t\tnla_get_be16(a), is_mask);\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_TP_DST:\n\t\t\tSW_FLOW_KEY_PUT(match, tun_key.tp_dst,\n\t\t\t\t\tnla_get_be16(a), is_mask);\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_OAM:\n\t\t\ttun_flags |= TUNNEL_OAM;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\n\t\t\tif (opts_type) {\n\t\t\t\tOVS_NLERR(log, \"Multiple metadata blocks provided\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = genev_tun_opt_from_nlattr(a, match, is_mask, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttun_flags |= TUNNEL_GENEVE_OPT;\n\t\t\topts_type = type;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\n\t\t\tif (opts_type) {\n\t\t\t\tOVS_NLERR(log, \"Multiple metadata blocks provided\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = vxlan_tun_opt_from_nlattr(a, match, is_mask, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttun_flags |= TUNNEL_VXLAN_OPT;\n\t\t\topts_type = type;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_PAD:\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS:\n\t\t\tif (opts_type) {\n\t\t\t\tOVS_NLERR(log, \"Multiple metadata blocks provided\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = erspan_tun_opt_from_nlattr(a, match, is_mask,\n\t\t\t\t\t\t\t log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttun_flags |= TUNNEL_ERSPAN_OPT;\n\t\t\topts_type = type;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE:\n\t\t\tinfo_bridge_mode = true;\n\t\t\tipv4 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown IP tunnel attribute %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tSW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);\n\tif (is_mask)\n\t\tSW_FLOW_KEY_MEMSET_FIELD(match, tun_proto, 0xff, true);\n\telse\n\t\tSW_FLOW_KEY_PUT(match, tun_proto, ipv6 ? AF_INET6 : AF_INET,\n\t\t\t\tfalse);\n\n\tif (rem > 0) {\n\t\tOVS_NLERR(log, \"IP tunnel attribute has %d unknown bytes.\",\n\t\t\t  rem);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ipv4 && ipv6) {\n\t\tOVS_NLERR(log, \"Mixed IPv4 and IPv6 tunnel attributes\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask) {\n\t\tif (!ipv4 && !ipv6) {\n\t\t\tOVS_NLERR(log, \"IP tunnel dst address not specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ipv4) {\n\t\t\tif (info_bridge_mode) {\n\t\t\t\tif (match->key->tun_key.u.ipv4.src ||\n\t\t\t\t    match->key->tun_key.u.ipv4.dst ||\n\t\t\t\t    match->key->tun_key.tp_src ||\n\t\t\t\t    match->key->tun_key.tp_dst ||\n\t\t\t\t    match->key->tun_key.ttl ||\n\t\t\t\t    match->key->tun_key.tos ||\n\t\t\t\t    tun_flags & ~TUNNEL_KEY) {\n\t\t\t\t\tOVS_NLERR(log, \"IPv4 tun info is not correct\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else if (!match->key->tun_key.u.ipv4.dst) {\n\t\t\t\tOVS_NLERR(log, \"IPv4 tunnel dst address is zero\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (ipv6 && ipv6_addr_any(&match->key->tun_key.u.ipv6.dst)) {\n\t\t\tOVS_NLERR(log, \"IPv6 tunnel dst address is zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ttl && !info_bridge_mode) {\n\t\t\tOVS_NLERR(log, \"IP tunnel TTL not specified.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn opts_type;\n}\n\nstatic int vxlan_opt_to_nlattr(struct sk_buff *skb,\n\t\t\t       const void *tun_opts, int swkey_tun_opts_len)\n{\n\tconst struct vxlan_metadata *opts = tun_opts;\n\tstruct nlattr *nla;\n\n\tnla = nla_nest_start_noflag(skb, OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, OVS_VXLAN_EXT_GBP, opts->gbp) < 0)\n\t\treturn -EMSGSIZE;\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\nstatic int __ip_tun_to_nlattr(struct sk_buff *skb,\n\t\t\t      const struct ip_tunnel_key *output,\n\t\t\t      const void *tun_opts, int swkey_tun_opts_len,\n\t\t\t      unsigned short tun_proto, u8 mode)\n{\n\tif (output->tun_flags & TUNNEL_KEY &&\n\t    nla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id,\n\t\t\t OVS_TUNNEL_KEY_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (mode & IP_TUNNEL_INFO_BRIDGE)\n\t\treturn nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE)\n\t\t       ? -EMSGSIZE : 0;\n\n\tswitch (tun_proto) {\n\tcase AF_INET:\n\t\tif (output->u.ipv4.src &&\n\t\t    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC,\n\t\t\t\t    output->u.ipv4.src))\n\t\t\treturn -EMSGSIZE;\n\t\tif (output->u.ipv4.dst &&\n\t\t    nla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST,\n\t\t\t\t    output->u.ipv4.dst))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!ipv6_addr_any(&output->u.ipv6.src) &&\n\t\t    nla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_SRC,\n\t\t\t\t     &output->u.ipv6.src))\n\t\t\treturn -EMSGSIZE;\n\t\tif (!ipv6_addr_any(&output->u.ipv6.dst) &&\n\t\t    nla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_DST,\n\t\t\t\t     &output->u.ipv6.dst))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n\tif (output->tos &&\n\t    nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->tos))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ttl))\n\t\treturn -EMSGSIZE;\n\tif ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&\n\t    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\n\t\treturn -EMSGSIZE;\n\tif ((output->tun_flags & TUNNEL_CSUM) &&\n\t    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_CSUM))\n\t\treturn -EMSGSIZE;\n\tif (output->tp_src &&\n\t    nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_SRC, output->tp_src))\n\t\treturn -EMSGSIZE;\n\tif (output->tp_dst &&\n\t    nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_DST, output->tp_dst))\n\t\treturn -EMSGSIZE;\n\tif ((output->tun_flags & TUNNEL_OAM) &&\n\t    nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_OAM))\n\t\treturn -EMSGSIZE;\n\tif (swkey_tun_opts_len) {\n\t\tif (output->tun_flags & TUNNEL_GENEVE_OPT &&\n\t\t    nla_put(skb, OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,\n\t\t\t    swkey_tun_opts_len, tun_opts))\n\t\t\treturn -EMSGSIZE;\n\t\telse if (output->tun_flags & TUNNEL_VXLAN_OPT &&\n\t\t\t vxlan_opt_to_nlattr(skb, tun_opts, swkey_tun_opts_len))\n\t\t\treturn -EMSGSIZE;\n\t\telse if (output->tun_flags & TUNNEL_ERSPAN_OPT &&\n\t\t\t nla_put(skb, OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS,\n\t\t\t\t swkey_tun_opts_len, tun_opts))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip_tun_to_nlattr(struct sk_buff *skb,\n\t\t\t    const struct ip_tunnel_key *output,\n\t\t\t    const void *tun_opts, int swkey_tun_opts_len,\n\t\t\t    unsigned short tun_proto, u8 mode)\n{\n\tstruct nlattr *nla;\n\tint err;\n\n\tnla = nla_nest_start_noflag(skb, OVS_KEY_ATTR_TUNNEL);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\terr = __ip_tun_to_nlattr(skb, output, tun_opts, swkey_tun_opts_len,\n\t\t\t\t tun_proto, mode);\n\tif (err)\n\t\treturn err;\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\nint ovs_nla_put_tunnel_info(struct sk_buff *skb,\n\t\t\t    struct ip_tunnel_info *tun_info)\n{\n\treturn __ip_tun_to_nlattr(skb, &tun_info->key,\n\t\t\t\t  ip_tunnel_info_opts(tun_info),\n\t\t\t\t  tun_info->options_len,\n\t\t\t\t  ip_tunnel_info_af(tun_info), tun_info->mode);\n}\n\nstatic int encode_vlan_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t    const struct nlattr *a[],\n\t\t\t\t    bool is_mask, bool inner)\n{\n\t__be16 tci = 0;\n\t__be16 tpid = 0;\n\n\tif (a[OVS_KEY_ATTR_VLAN])\n\t\ttci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\n\n\tif (a[OVS_KEY_ATTR_ETHERTYPE])\n\t\ttpid = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\n\n\tif (likely(!inner)) {\n\t\tSW_FLOW_KEY_PUT(match, eth.vlan.tpid, tpid, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, eth.vlan.tci, tci, is_mask);\n\t} else {\n\t\tSW_FLOW_KEY_PUT(match, eth.cvlan.tpid, tpid, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, eth.cvlan.tci, tci, is_mask);\n\t}\n\treturn 0;\n}\n\nstatic int validate_vlan_from_nlattrs(const struct sw_flow_match *match,\n\t\t\t\t      u64 key_attrs, bool inner,\n\t\t\t\t      const struct nlattr **a, bool log)\n{\n\t__be16 tci = 0;\n\n\tif (!((key_attrs & (1 << OVS_KEY_ATTR_ETHERNET)) &&\n\t      (key_attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) &&\n\t       eth_type_vlan(nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE])))) {\n\t\t/* Not a VLAN. */\n\t\treturn 0;\n\t}\n\n\tif (!((key_attrs & (1 << OVS_KEY_ATTR_VLAN)) &&\n\t      (key_attrs & (1 << OVS_KEY_ATTR_ENCAP)))) {\n\t\tOVS_NLERR(log, \"Invalid %s frame\", (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (a[OVS_KEY_ATTR_VLAN])\n\t\ttci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\n\n\tif (!(tci & htons(VLAN_CFI_MASK))) {\n\t\tif (tci) {\n\t\t\tOVS_NLERR(log, \"%s TCI does not have VLAN_CFI_MASK bit set.\",\n\t\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\t\treturn -EINVAL;\n\t\t} else if (nla_len(a[OVS_KEY_ATTR_ENCAP])) {\n\t\t\t/* Corner case for truncated VLAN header. */\n\t\t\tOVS_NLERR(log, \"Truncated %s header has non-zero encap attribute.\",\n\t\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int validate_vlan_mask_from_nlattrs(const struct sw_flow_match *match,\n\t\t\t\t\t   u64 key_attrs, bool inner,\n\t\t\t\t\t   const struct nlattr **a, bool log)\n{\n\t__be16 tci = 0;\n\t__be16 tpid = 0;\n\tbool encap_valid = !!(match->key->eth.vlan.tci &\n\t\t\t      htons(VLAN_CFI_MASK));\n\tbool i_encap_valid = !!(match->key->eth.cvlan.tci &\n\t\t\t\thtons(VLAN_CFI_MASK));\n\n\tif (!(key_attrs & (1 << OVS_KEY_ATTR_ENCAP))) {\n\t\t/* Not a VLAN. */\n\t\treturn 0;\n\t}\n\n\tif ((!inner && !encap_valid) || (inner && !i_encap_valid)) {\n\t\tOVS_NLERR(log, \"Encap mask attribute is set for non-%s frame.\",\n\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (a[OVS_KEY_ATTR_VLAN])\n\t\ttci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\n\n\tif (a[OVS_KEY_ATTR_ETHERTYPE])\n\t\ttpid = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\n\n\tif (tpid != htons(0xffff)) {\n\t\tOVS_NLERR(log, \"Must have an exact match on %s TPID (mask=%x).\",\n\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\", ntohs(tpid));\n\t\treturn -EINVAL;\n\t}\n\tif (!(tci & htons(VLAN_CFI_MASK))) {\n\t\tOVS_NLERR(log, \"%s TCI mask does not have exact match for VLAN_CFI_MASK bit.\",\n\t\t\t  (inner) ? \"C-VLAN\" : \"VLAN\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\nstatic int __parse_vlan_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t     u64 *key_attrs, bool inner,\n\t\t\t\t     const struct nlattr **a, bool is_mask,\n\t\t\t\t     bool log)\n{\n\tint err;\n\tconst struct nlattr *encap;\n\n\tif (!is_mask)\n\t\terr = validate_vlan_from_nlattrs(match, *key_attrs, inner,\n\t\t\t\t\t\t a, log);\n\telse\n\t\terr = validate_vlan_mask_from_nlattrs(match, *key_attrs, inner,\n\t\t\t\t\t\t      a, log);\n\tif (err <= 0)\n\t\treturn err;\n\n\terr = encode_vlan_from_nlattrs(match, a, is_mask, inner);\n\tif (err)\n\t\treturn err;\n\n\t*key_attrs &= ~(1 << OVS_KEY_ATTR_ENCAP);\n\t*key_attrs &= ~(1 << OVS_KEY_ATTR_VLAN);\n\t*key_attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\n\n\tencap = a[OVS_KEY_ATTR_ENCAP];\n\n\tif (!is_mask)\n\t\terr = parse_flow_nlattrs(encap, a, key_attrs, log);\n\telse\n\t\terr = parse_flow_mask_nlattrs(encap, a, key_attrs, log);\n\n\treturn err;\n}\n\nstatic int parse_vlan_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t   u64 *key_attrs, const struct nlattr **a,\n\t\t\t\t   bool is_mask, bool log)\n{\n\tint err;\n\tbool encap_valid = false;\n\n\terr = __parse_vlan_from_nlattrs(match, key_attrs, false, a,\n\t\t\t\t\tis_mask, log);\n\tif (err)\n\t\treturn err;\n\n\tencap_valid = !!(match->key->eth.vlan.tci & htons(VLAN_CFI_MASK));\n\tif (encap_valid) {\n\t\terr = __parse_vlan_from_nlattrs(match, key_attrs, true, a,\n\t\t\t\t\t\tis_mask, log);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_eth_type_from_nlattrs(struct sw_flow_match *match,\n\t\t\t\t       u64 *attrs, const struct nlattr **a,\n\t\t\t\t       bool is_mask, bool log)\n{\n\t__be16 eth_type;\n\n\teth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\n\tif (is_mask) {\n\t\t/* Always exact match EtherType. */\n\t\teth_type = htons(0xffff);\n\t} else if (!eth_proto_is_802_3(eth_type)) {\n\t\tOVS_NLERR(log, \"EtherType %x is less than min %x\",\n\t\t\t\tntohs(eth_type), ETH_P_802_3_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\tSW_FLOW_KEY_PUT(match, eth.type, eth_type, is_mask);\n\t*attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\n\treturn 0;\n}\n\nstatic int metadata_from_nlattrs(struct net *net, struct sw_flow_match *match,\n\t\t\t\t u64 *attrs, const struct nlattr **a,\n\t\t\t\t bool is_mask, bool log)\n{\n\tu8 mac_proto = MAC_PROTO_ETHERNET;\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_DP_HASH)) {\n\t\tu32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);\n\n\t\tSW_FLOW_KEY_PUT(match, ovs_flow_hash, hash_val, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_DP_HASH);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_RECIRC_ID)) {\n\t\tu32 recirc_id = nla_get_u32(a[OVS_KEY_ATTR_RECIRC_ID]);\n\n\t\tSW_FLOW_KEY_PUT(match, recirc_id, recirc_id, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_RECIRC_ID);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_PRIORITY)) {\n\t\tSW_FLOW_KEY_PUT(match, phy.priority,\n\t\t\t  nla_get_u32(a[OVS_KEY_ATTR_PRIORITY]), is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_PRIORITY);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_IN_PORT)) {\n\t\tu32 in_port = nla_get_u32(a[OVS_KEY_ATTR_IN_PORT]);\n\n\t\tif (is_mask) {\n\t\t\tin_port = 0xffffffff; /* Always exact match in_port. */\n\t\t} else if (in_port >= DP_MAX_PORTS) {\n\t\t\tOVS_NLERR(log, \"Port %d exceeds max allowable %d\",\n\t\t\t\t  in_port, DP_MAX_PORTS);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, phy.in_port, in_port, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_IN_PORT);\n\t} else if (!is_mask) {\n\t\tSW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_SKB_MARK)) {\n\t\tuint32_t mark = nla_get_u32(a[OVS_KEY_ATTR_SKB_MARK]);\n\n\t\tSW_FLOW_KEY_PUT(match, phy.skb_mark, mark, is_mask);\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_SKB_MARK);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_TUNNEL)) {\n\t\tif (ip_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,\n\t\t\t\t       is_mask, log) < 0)\n\t\t\treturn -EINVAL;\n\t\t*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);\n\t}\n\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_STATE)) {\n\t\tu32 ct_state = nla_get_u32(a[OVS_KEY_ATTR_CT_STATE]);\n\n\t\tif (ct_state & ~CT_SUPPORTED_MASK) {\n\t\t\tOVS_NLERR(log, \"ct_state flags %08x unsupported\",\n\t\t\t\t  ct_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, ct_state, ct_state, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_ZONE)) {\n\t\tu16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);\n\n\t\tSW_FLOW_KEY_PUT(match, ct_zone, ct_zone, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_MARK)) {\n\t\tu32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);\n\n\t\tSW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);\n\t}\n\tif (*attrs & (1 << OVS_KEY_ATTR_CT_LABELS) &&\n\t    ovs_ct_verify(net, OVS_KEY_ATTR_CT_LABELS)) {\n\t\tconst struct ovs_key_ct_labels *cl;\n\n\t\tcl = nla_data(a[OVS_KEY_ATTR_CT_LABELS]);\n\t\tSW_FLOW_KEY_MEMCPY(match, ct.labels, cl->ct_labels,\n\t\t\t\t   sizeof(*cl), is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);\n\t}\n\tif (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4)) {\n\t\tconst struct ovs_key_ct_tuple_ipv4 *ct;\n\n\t\tct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4]);\n\n\t\tSW_FLOW_KEY_PUT(match, ipv4.ct_orig.src, ct->ipv4_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.ct_orig.dst, ct->ipv4_dst, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct_orig_proto, ct->ipv4_proto, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4);\n\t}\n\tif (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6)) {\n\t\tconst struct ovs_key_ct_tuple_ipv6 *ct;\n\n\t\tct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6]);\n\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.src, &ct->ipv6_src,\n\t\t\t\t   sizeof(match->key->ipv6.ct_orig.src),\n\t\t\t\t   is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.dst, &ct->ipv6_dst,\n\t\t\t\t   sizeof(match->key->ipv6.ct_orig.dst),\n\t\t\t\t   is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ct_orig_proto, ct->ipv6_proto, is_mask);\n\t\t*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6);\n\t}\n\n\t/* For layer 3 packets the Ethernet type is provided\n\t * and treated as metadata but no MAC addresses are provided.\n\t */\n\tif (!(*attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&\n\t    (*attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)))\n\t\tmac_proto = MAC_PROTO_NONE;\n\n\t/* Always exact match mac_proto */\n\tSW_FLOW_KEY_PUT(match, mac_proto, is_mask ? 0xff : mac_proto, is_mask);\n\n\tif (mac_proto == MAC_PROTO_NONE)\n\t\treturn parse_eth_type_from_nlattrs(match, attrs, a, is_mask,\n\t\t\t\t\t\t   log);\n\n\treturn 0;\n}\n\nint nsh_hdr_from_nlattr(const struct nlattr *attr,\n\t\t\tstruct nshhdr *nh, size_t size)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tu8 flags = 0;\n\tu8 ttl = 0;\n\tint mdlen = 0;\n\n\t/* validate_nsh has check this, so we needn't do duplicate check here\n\t */\n\tif (size < NSH_BASE_HDR_LEN)\n\t\treturn -ENOBUFS;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\tswitch (type) {\n\t\tcase OVS_NSH_KEY_ATTR_BASE: {\n\t\t\tconst struct ovs_nsh_key_base *base = nla_data(a);\n\n\t\t\tflags = base->flags;\n\t\t\tttl = base->ttl;\n\t\t\tnh->np = base->np;\n\t\t\tnh->mdtype = base->mdtype;\n\t\t\tnh->path_hdr = base->path_hdr;\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD1:\n\t\t\tmdlen = nla_len(a);\n\t\t\tif (mdlen > size - NSH_BASE_HDR_LEN)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tmemcpy(&nh->md1, nla_data(a), mdlen);\n\t\t\tbreak;\n\n\t\tcase OVS_NSH_KEY_ATTR_MD2:\n\t\t\tmdlen = nla_len(a);\n\t\t\tif (mdlen > size - NSH_BASE_HDR_LEN)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tmemcpy(&nh->md2, nla_data(a), mdlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* nsh header length  = NSH_BASE_HDR_LEN + mdlen */\n\tnh->ver_flags_ttl_len = 0;\n\tnsh_set_flags_ttl_len(nh, flags, ttl, NSH_BASE_HDR_LEN + mdlen);\n\n\treturn 0;\n}\n\nint nsh_key_from_nlattr(const struct nlattr *attr,\n\t\t\tstruct ovs_key_nsh *nsh, struct ovs_key_nsh *nsh_mask)\n{\n\tstruct nlattr *a;\n\tint rem;\n\n\t/* validate_nsh has check this, so we needn't do duplicate check here\n\t */\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\tswitch (type) {\n\t\tcase OVS_NSH_KEY_ATTR_BASE: {\n\t\t\tconst struct ovs_nsh_key_base *base = nla_data(a);\n\t\t\tconst struct ovs_nsh_key_base *base_mask = base + 1;\n\n\t\t\tnsh->base = *base;\n\t\t\tnsh_mask->base = *base_mask;\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD1: {\n\t\t\tconst struct ovs_nsh_key_md1 *md1 = nla_data(a);\n\t\t\tconst struct ovs_nsh_key_md1 *md1_mask = md1 + 1;\n\n\t\t\tmemcpy(nsh->context, md1->context, sizeof(*md1));\n\t\t\tmemcpy(nsh_mask->context, md1_mask->context,\n\t\t\t       sizeof(*md1_mask));\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD2:\n\t\t\t/* Not supported yet */\n\t\t\treturn -ENOTSUPP;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nsh_key_put_from_nlattr(const struct nlattr *attr,\n\t\t\t\t   struct sw_flow_match *match, bool is_mask,\n\t\t\t\t   bool is_push_nsh, bool log)\n{\n\tstruct nlattr *a;\n\tint rem;\n\tbool has_base = false;\n\tbool has_md1 = false;\n\tbool has_md2 = false;\n\tu8 mdtype = 0;\n\tint mdlen = 0;\n\n\tif (WARN_ON(is_push_nsh && is_mask))\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tint i;\n\n\t\tif (type > OVS_NSH_KEY_ATTR_MAX) {\n\t\t\tOVS_NLERR(log, \"nsh attr %d is out of range max %d\",\n\t\t\t\t  type, OVS_NSH_KEY_ATTR_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!check_attr_len(nla_len(a),\n\t\t\t\t    ovs_nsh_key_attr_lens[type].len)) {\n\t\t\tOVS_NLERR(\n\t\t\t    log,\n\t\t\t    \"nsh attr %d has unexpected len %d expected %d\",\n\t\t\t    type,\n\t\t\t    nla_len(a),\n\t\t\t    ovs_nsh_key_attr_lens[type].len\n\t\t\t);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase OVS_NSH_KEY_ATTR_BASE: {\n\t\t\tconst struct ovs_nsh_key_base *base = nla_data(a);\n\n\t\t\thas_base = true;\n\t\t\tmdtype = base->mdtype;\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.flags,\n\t\t\t\t\tbase->flags, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.ttl,\n\t\t\t\t\tbase->ttl, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.mdtype,\n\t\t\t\t\tbase->mdtype, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.np,\n\t\t\t\t\tbase->np, is_mask);\n\t\t\tSW_FLOW_KEY_PUT(match, nsh.base.path_hdr,\n\t\t\t\t\tbase->path_hdr, is_mask);\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD1: {\n\t\t\tconst struct ovs_nsh_key_md1 *md1 = nla_data(a);\n\n\t\t\thas_md1 = true;\n\t\t\tfor (i = 0; i < NSH_MD1_CONTEXT_SIZE; i++)\n\t\t\t\tSW_FLOW_KEY_PUT(match, nsh.context[i],\n\t\t\t\t\t\tmd1->context[i], is_mask);\n\t\t\tbreak;\n\t\t}\n\t\tcase OVS_NSH_KEY_ATTR_MD2:\n\t\t\tif (!is_push_nsh) /* Not supported MD type 2 yet */\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\thas_md2 = true;\n\t\t\tmdlen = nla_len(a);\n\t\t\tif (mdlen > NSH_CTX_HDRS_MAX_LEN || mdlen <= 0) {\n\t\t\t\tOVS_NLERR(\n\t\t\t\t    log,\n\t\t\t\t    \"Invalid MD length %d for MD type %d\",\n\t\t\t\t    mdlen,\n\t\t\t\t    mdtype\n\t\t\t\t);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown nsh attribute %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (rem > 0) {\n\t\tOVS_NLERR(log, \"nsh attribute has %d unknown bytes.\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\tif (has_md1 && has_md2) {\n\t\tOVS_NLERR(\n\t\t    1,\n\t\t    \"invalid nsh attribute: md1 and md2 are exclusive.\"\n\t\t);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_mask) {\n\t\tif ((has_md1 && mdtype != NSH_M_TYPE1) ||\n\t\t    (has_md2 && mdtype != NSH_M_TYPE2)) {\n\t\t\tOVS_NLERR(1, \"nsh attribute has unmatched MD type %d.\",\n\t\t\t\t  mdtype);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_push_nsh &&\n\t\t    (!has_base || (!has_md1 && !has_md2))) {\n\t\t\tOVS_NLERR(\n\t\t\t    1,\n\t\t\t    \"push_nsh: missing base or metadata attributes\"\n\t\t\t);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ovs_key_from_nlattrs(struct net *net, struct sw_flow_match *match,\n\t\t\t\tu64 attrs, const struct nlattr **a,\n\t\t\t\tbool is_mask, bool log)\n{\n\tint err;\n\n\terr = metadata_from_nlattrs(net, match, &attrs, a, is_mask, log);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ETHERNET)) {\n\t\tconst struct ovs_key_ethernet *eth_key;\n\n\t\teth_key = nla_data(a[OVS_KEY_ATTR_ETHERNET]);\n\t\tSW_FLOW_KEY_MEMCPY(match, eth.src,\n\t\t\t\teth_key->eth_src, ETH_ALEN, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, eth.dst,\n\t\t\t\teth_key->eth_dst, ETH_ALEN, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ETHERNET);\n\n\t\tif (attrs & (1 << OVS_KEY_ATTR_VLAN)) {\n\t\t\t/* VLAN attribute is always parsed before getting here since it\n\t\t\t * may occur multiple times.\n\t\t\t */\n\t\t\tOVS_NLERR(log, \"VLAN attribute unexpected.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) {\n\t\t\terr = parse_eth_type_from_nlattrs(match, &attrs, a, is_mask,\n\t\t\t\t\t\t\t  log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (!is_mask) {\n\t\t\tSW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);\n\t\t}\n\t} else if (!match->key->eth.type) {\n\t\tOVS_NLERR(log, \"Either Ethernet header or EtherType is required.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_IPV4)) {\n\t\tconst struct ovs_key_ipv4 *ipv4_key;\n\n\t\tipv4_key = nla_data(a[OVS_KEY_ATTR_IPV4]);\n\t\tif (!is_mask && ipv4_key->ipv4_frag > OVS_FRAG_TYPE_MAX) {\n\t\t\tOVS_NLERR(log, \"IPv4 frag type %d is out of range max %d\",\n\t\t\t\t  ipv4_key->ipv4_frag, OVS_FRAG_TYPE_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tSW_FLOW_KEY_PUT(match, ip.proto,\n\t\t\t\tipv4_key->ipv4_proto, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.tos,\n\t\t\t\tipv4_key->ipv4_tos, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.ttl,\n\t\t\t\tipv4_key->ipv4_ttl, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.frag,\n\t\t\t\tipv4_key->ipv4_frag, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.src,\n\t\t\t\tipv4_key->ipv4_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\n\t\t\t\tipv4_key->ipv4_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_IPV4);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_IPV6)) {\n\t\tconst struct ovs_key_ipv6 *ipv6_key;\n\n\t\tipv6_key = nla_data(a[OVS_KEY_ATTR_IPV6]);\n\t\tif (!is_mask && ipv6_key->ipv6_frag > OVS_FRAG_TYPE_MAX) {\n\t\t\tOVS_NLERR(log, \"IPv6 frag type %d is out of range max %d\",\n\t\t\t\t  ipv6_key->ipv6_frag, OVS_FRAG_TYPE_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_mask && ipv6_key->ipv6_label & htonl(0xFFF00000)) {\n\t\t\tOVS_NLERR(log, \"IPv6 flow label %x is out of range (max=%x)\",\n\t\t\t\t  ntohl(ipv6_key->ipv6_label), (1 << 20) - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, ipv6.label,\n\t\t\t\tipv6_key->ipv6_label, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.proto,\n\t\t\t\tipv6_key->ipv6_proto, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.tos,\n\t\t\t\tipv6_key->ipv6_tclass, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.ttl,\n\t\t\t\tipv6_key->ipv6_hlimit, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.frag,\n\t\t\t\tipv6_key->ipv6_frag, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.addr.src,\n\t\t\t\tipv6_key->ipv6_src,\n\t\t\t\tsizeof(match->key->ipv6.addr.src),\n\t\t\t\tis_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.addr.dst,\n\t\t\t\tipv6_key->ipv6_dst,\n\t\t\t\tsizeof(match->key->ipv6.addr.dst),\n\t\t\t\tis_mask);\n\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_IPV6);\n\t}\n\n\tif (attrs & (1ULL << OVS_KEY_ATTR_IPV6_EXTHDRS)) {\n\t\tconst struct ovs_key_ipv6_exthdrs *ipv6_exthdrs_key;\n\n\t\tipv6_exthdrs_key = nla_data(a[OVS_KEY_ATTR_IPV6_EXTHDRS]);\n\n\t\tSW_FLOW_KEY_PUT(match, ipv6.exthdrs,\n\t\t\t\tipv6_exthdrs_key->hdrs, is_mask);\n\n\t\tattrs &= ~(1ULL << OVS_KEY_ATTR_IPV6_EXTHDRS);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ARP)) {\n\t\tconst struct ovs_key_arp *arp_key;\n\n\t\tarp_key = nla_data(a[OVS_KEY_ATTR_ARP]);\n\t\tif (!is_mask && (arp_key->arp_op & htons(0xff00))) {\n\t\t\tOVS_NLERR(log, \"Unknown ARP opcode (opcode=%d).\",\n\t\t\t\t  arp_key->arp_op);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.src,\n\t\t\t\tarp_key->arp_sip, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\n\t\t\tarp_key->arp_tip, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, ip.proto,\n\t\t\t\tntohs(arp_key->arp_op), is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv4.arp.sha,\n\t\t\t\tarp_key->arp_sha, ETH_ALEN, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv4.arp.tha,\n\t\t\t\tarp_key->arp_tha, ETH_ALEN, is_mask);\n\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ARP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_NSH)) {\n\t\tif (nsh_key_put_from_nlattr(a[OVS_KEY_ATTR_NSH], match,\n\t\t\t\t\t    is_mask, false, log) < 0)\n\t\t\treturn -EINVAL;\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_NSH);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_MPLS)) {\n\t\tconst struct ovs_key_mpls *mpls_key;\n\t\tu32 hdr_len;\n\t\tu32 label_count, label_count_mask, i;\n\n\t\tmpls_key = nla_data(a[OVS_KEY_ATTR_MPLS]);\n\t\thdr_len = nla_len(a[OVS_KEY_ATTR_MPLS]);\n\t\tlabel_count = hdr_len / sizeof(struct ovs_key_mpls);\n\n\t\tif (label_count == 0 || label_count > MPLS_LABEL_DEPTH ||\n\t\t    hdr_len % sizeof(struct ovs_key_mpls))\n\t\t\treturn -EINVAL;\n\n\t\tlabel_count_mask =  GENMASK(label_count - 1, 0);\n\n\t\tfor (i = 0 ; i < label_count; i++)\n\t\t\tSW_FLOW_KEY_PUT(match, mpls.lse[i],\n\t\t\t\t\tmpls_key[i].mpls_lse, is_mask);\n\n\t\tSW_FLOW_KEY_PUT(match, mpls.num_labels_mask,\n\t\t\t\tlabel_count_mask, is_mask);\n\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_MPLS);\n\t }\n\n\tif (attrs & (1 << OVS_KEY_ATTR_TCP)) {\n\t\tconst struct ovs_key_tcp *tcp_key;\n\n\t\ttcp_key = nla_data(a[OVS_KEY_ATTR_TCP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src, tcp_key->tcp_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst, tcp_key->tcp_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_TCP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_TCP_FLAGS)) {\n\t\tSW_FLOW_KEY_PUT(match, tp.flags,\n\t\t\t\tnla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\n\t\t\t\tis_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_TCP_FLAGS);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_UDP)) {\n\t\tconst struct ovs_key_udp *udp_key;\n\n\t\tudp_key = nla_data(a[OVS_KEY_ATTR_UDP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src, udp_key->udp_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst, udp_key->udp_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_UDP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_SCTP)) {\n\t\tconst struct ovs_key_sctp *sctp_key;\n\n\t\tsctp_key = nla_data(a[OVS_KEY_ATTR_SCTP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src, sctp_key->sctp_src, is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst, sctp_key->sctp_dst, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_SCTP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ICMP)) {\n\t\tconst struct ovs_key_icmp *icmp_key;\n\n\t\ticmp_key = nla_data(a[OVS_KEY_ATTR_ICMP]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src,\n\t\t\t\thtons(icmp_key->icmp_type), is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst,\n\t\t\t\thtons(icmp_key->icmp_code), is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ICMP);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ICMPV6)) {\n\t\tconst struct ovs_key_icmpv6 *icmpv6_key;\n\n\t\ticmpv6_key = nla_data(a[OVS_KEY_ATTR_ICMPV6]);\n\t\tSW_FLOW_KEY_PUT(match, tp.src,\n\t\t\t\thtons(icmpv6_key->icmpv6_type), is_mask);\n\t\tSW_FLOW_KEY_PUT(match, tp.dst,\n\t\t\t\thtons(icmpv6_key->icmpv6_code), is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ICMPV6);\n\t}\n\n\tif (attrs & (1 << OVS_KEY_ATTR_ND)) {\n\t\tconst struct ovs_key_nd *nd_key;\n\n\t\tnd_key = nla_data(a[OVS_KEY_ATTR_ND]);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.nd.target,\n\t\t\tnd_key->nd_target,\n\t\t\tsizeof(match->key->ipv6.nd.target),\n\t\t\tis_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.nd.sll,\n\t\t\tnd_key->nd_sll, ETH_ALEN, is_mask);\n\t\tSW_FLOW_KEY_MEMCPY(match, ipv6.nd.tll,\n\t\t\t\tnd_key->nd_tll, ETH_ALEN, is_mask);\n\t\tattrs &= ~(1 << OVS_KEY_ATTR_ND);\n\t}\n\n\tif (attrs != 0) {\n\t\tOVS_NLERR(log, \"Unknown key attributes %llx\",\n\t\t\t  (unsigned long long)attrs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void nlattr_set(struct nlattr *attr, u8 val,\n\t\t       const struct ovs_len_tbl *tbl)\n{\n\tstruct nlattr *nla;\n\tint rem;\n\n\t/* The nlattr stream should already have been validated */\n\tnla_for_each_nested(nla, attr, rem) {\n\t\tif (tbl[nla_type(nla)].len == OVS_ATTR_NESTED)\n\t\t\tnlattr_set(nla, val, tbl[nla_type(nla)].next ? : tbl);\n\t\telse\n\t\t\tmemset(nla_data(nla), val, nla_len(nla));\n\n\t\tif (nla_type(nla) == OVS_KEY_ATTR_CT_STATE)\n\t\t\t*(u32 *)nla_data(nla) &= CT_SUPPORTED_MASK;\n\t}\n}\n\nstatic void mask_set_nlattr(struct nlattr *attr, u8 val)\n{\n\tnlattr_set(attr, val, ovs_key_lens);\n}\n\n/**\n * ovs_nla_get_match - parses Netlink attributes into a flow key and\n * mask. In case the 'mask' is NULL, the flow is treated as exact match\n * flow. Otherwise, it is treated as a wildcarded flow, except the mask\n * does not include any don't care bit.\n * @net: Used to determine per-namespace field support.\n * @match: receives the extracted flow match information.\n * @nla_key: Netlink attribute holding nested %OVS_KEY_ATTR_* Netlink attribute\n * sequence. The fields should of the packet that triggered the creation\n * of this flow.\n * @nla_mask: Optional. Netlink attribute holding nested %OVS_KEY_ATTR_*\n * Netlink attribute specifies the mask field of the wildcarded flow.\n * @log: Boolean to allow kernel error logging.  Normally true, but when\n * probing for feature compatibility this should be passed in as false to\n * suppress unnecessary error logging.\n */\nint ovs_nla_get_match(struct net *net, struct sw_flow_match *match,\n\t\t      const struct nlattr *nla_key,\n\t\t      const struct nlattr *nla_mask,\n\t\t      bool log)\n{\n\tconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\n\tstruct nlattr *newmask = NULL;\n\tu64 key_attrs = 0;\n\tu64 mask_attrs = 0;\n\tint err;\n\n\terr = parse_flow_nlattrs(nla_key, a, &key_attrs, log);\n\tif (err)\n\t\treturn err;\n\n\terr = parse_vlan_from_nlattrs(match, &key_attrs, a, false, log);\n\tif (err)\n\t\treturn err;\n\n\terr = ovs_key_from_nlattrs(net, match, key_attrs, a, false, log);\n\tif (err)\n\t\treturn err;\n\n\tif (match->mask) {\n\t\tif (!nla_mask) {\n\t\t\t/* Create an exact match mask. We need to set to 0xff\n\t\t\t * all the 'match->mask' fields that have been touched\n\t\t\t * in 'match->key'. We cannot simply memset\n\t\t\t * 'match->mask', because padding bytes and fields not\n\t\t\t * specified in 'match->key' should be left to 0.\n\t\t\t * Instead, we use a stream of netlink attributes,\n\t\t\t * copied from 'key' and set to 0xff.\n\t\t\t * ovs_key_from_nlattrs() will take care of filling\n\t\t\t * 'match->mask' appropriately.\n\t\t\t */\n\t\t\tnewmask = kmemdup(nla_key,\n\t\t\t\t\t  nla_total_size(nla_len(nla_key)),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!newmask)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmask_set_nlattr(newmask, 0xff);\n\n\t\t\t/* The userspace does not send tunnel attributes that\n\t\t\t * are 0, but we should not wildcard them nonetheless.\n\t\t\t */\n\t\t\tif (match->key->tun_proto)\n\t\t\t\tSW_FLOW_KEY_MEMSET_FIELD(match, tun_key,\n\t\t\t\t\t\t\t 0xff, true);\n\n\t\t\tnla_mask = newmask;\n\t\t}\n\n\t\terr = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);\n\t\tif (err)\n\t\t\tgoto free_newmask;\n\n\t\t/* Always match on tci. */\n\t\tSW_FLOW_KEY_PUT(match, eth.vlan.tci, htons(0xffff), true);\n\t\tSW_FLOW_KEY_PUT(match, eth.cvlan.tci, htons(0xffff), true);\n\n\t\terr = parse_vlan_from_nlattrs(match, &mask_attrs, a, true, log);\n\t\tif (err)\n\t\t\tgoto free_newmask;\n\n\t\terr = ovs_key_from_nlattrs(net, match, mask_attrs, a, true,\n\t\t\t\t\t   log);\n\t\tif (err)\n\t\t\tgoto free_newmask;\n\t}\n\n\tif (!match_validate(match, key_attrs, mask_attrs, log))\n\t\terr = -EINVAL;\n\nfree_newmask:\n\tkfree(newmask);\n\treturn err;\n}\n\nstatic size_t get_ufid_len(const struct nlattr *attr, bool log)\n{\n\tsize_t len;\n\n\tif (!attr)\n\t\treturn 0;\n\n\tlen = nla_len(attr);\n\tif (len < 1 || len > MAX_UFID_LENGTH) {\n\t\tOVS_NLERR(log, \"ufid size %u bytes exceeds the range (1, %d)\",\n\t\t\t  nla_len(attr), MAX_UFID_LENGTH);\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\n/* Initializes 'flow->ufid', returning true if 'attr' contains a valid UFID,\n * or false otherwise.\n */\nbool ovs_nla_get_ufid(struct sw_flow_id *sfid, const struct nlattr *attr,\n\t\t      bool log)\n{\n\tsfid->ufid_len = get_ufid_len(attr, log);\n\tif (sfid->ufid_len)\n\t\tmemcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);\n\n\treturn sfid->ufid_len;\n}\n\nint ovs_nla_get_identifier(struct sw_flow_id *sfid, const struct nlattr *ufid,\n\t\t\t   const struct sw_flow_key *key, bool log)\n{\n\tstruct sw_flow_key *new_key;\n\n\tif (ovs_nla_get_ufid(sfid, ufid, log))\n\t\treturn 0;\n\n\t/* If UFID was not provided, use unmasked key. */\n\tnew_key = kmalloc(sizeof(*new_key), GFP_KERNEL);\n\tif (!new_key)\n\t\treturn -ENOMEM;\n\tmemcpy(new_key, key, sizeof(*key));\n\tsfid->unmasked_key = new_key;\n\n\treturn 0;\n}\n\nu32 ovs_nla_get_ufid_flags(const struct nlattr *attr)\n{\n\treturn attr ? nla_get_u32(attr) : 0;\n}\n\n/**\n * ovs_nla_get_flow_metadata - parses Netlink attributes into a flow key.\n * @net: Network namespace.\n * @key: Receives extracted in_port, priority, tun_key, skb_mark and conntrack\n * metadata.\n * @a: Array of netlink attributes holding parsed %OVS_KEY_ATTR_* Netlink\n * attributes.\n * @attrs: Bit mask for the netlink attributes included in @a.\n * @log: Boolean to allow kernel error logging.  Normally true, but when\n * probing for feature compatibility this should be passed in as false to\n * suppress unnecessary error logging.\n *\n * This parses a series of Netlink attributes that form a flow key, which must\n * take the same form accepted by flow_from_nlattrs(), but only enough of it to\n * get the metadata, that is, the parts of the flow key that cannot be\n * extracted from the packet itself.\n *\n * This must be called before the packet key fields are filled in 'key'.\n */\n\nint ovs_nla_get_flow_metadata(struct net *net,\n\t\t\t      const struct nlattr *a[OVS_KEY_ATTR_MAX + 1],\n\t\t\t      u64 attrs, struct sw_flow_key *key, bool log)\n{\n\tstruct sw_flow_match match;\n\n\tmemset(&match, 0, sizeof(match));\n\tmatch.key = key;\n\n\tkey->ct_state = 0;\n\tkey->ct_zone = 0;\n\tkey->ct_orig_proto = 0;\n\tmemset(&key->ct, 0, sizeof(key->ct));\n\tmemset(&key->ipv4.ct_orig, 0, sizeof(key->ipv4.ct_orig));\n\tmemset(&key->ipv6.ct_orig, 0, sizeof(key->ipv6.ct_orig));\n\n\tkey->phy.in_port = DP_MAX_PORTS;\n\n\treturn metadata_from_nlattrs(net, &match, &attrs, a, false, log);\n}\n\nstatic int ovs_nla_put_vlan(struct sk_buff *skb, const struct vlan_head *vh,\n\t\t\t    bool is_mask)\n{\n\t__be16 eth_type = !is_mask ? vh->tpid : htons(0xffff);\n\n\tif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, eth_type) ||\n\t    nla_put_be16(skb, OVS_KEY_ATTR_VLAN, vh->tci))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int nsh_key_to_nlattr(const struct ovs_key_nsh *nsh, bool is_mask,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nlattr *start;\n\n\tstart = nla_nest_start_noflag(skb, OVS_KEY_ATTR_NSH);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put(skb, OVS_NSH_KEY_ATTR_BASE, sizeof(nsh->base), &nsh->base))\n\t\tgoto nla_put_failure;\n\n\tif (is_mask || nsh->base.mdtype == NSH_M_TYPE1) {\n\t\tif (nla_put(skb, OVS_NSH_KEY_ATTR_MD1,\n\t\t\t    sizeof(nsh->context), nsh->context))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\t/* Don't support MD type 2 yet */\n\n\tnla_nest_end(skb, start);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int __ovs_nla_put_key(const struct sw_flow_key *swkey,\n\t\t\t     const struct sw_flow_key *output, bool is_mask,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ovs_key_ethernet *eth_key;\n\tstruct nlattr *nla;\n\tstruct nlattr *encap = NULL;\n\tstruct nlattr *in_encap = NULL;\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_RECIRC_ID, output->recirc_id))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_DP_HASH, output->ovs_flow_hash))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))\n\t\tgoto nla_put_failure;\n\n\tif ((swkey->tun_proto || is_mask)) {\n\t\tconst void *opts = NULL;\n\n\t\tif (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)\n\t\t\topts = TUN_METADATA_OPTS(output, swkey->tun_opts_len);\n\n\t\tif (ip_tun_to_nlattr(skb, &output->tun_key, opts,\n\t\t\t\t     swkey->tun_opts_len, swkey->tun_proto, 0))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (swkey->phy.in_port == DP_MAX_PORTS) {\n\t\tif (is_mask && (output->phy.in_port == 0xffff))\n\t\t\tif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT, 0xffffffff))\n\t\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tu16 upper_u16;\n\t\tupper_u16 = !is_mask ? 0 : 0xffff;\n\n\t\tif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT,\n\t\t\t\t(upper_u16 << 16) | output->phy.in_port))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))\n\t\tgoto nla_put_failure;\n\n\tif (ovs_ct_put_key(swkey, output, skb))\n\t\tgoto nla_put_failure;\n\n\tif (ovs_key_mac_proto(swkey) == MAC_PROTO_ETHERNET) {\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\n\t\teth_key = nla_data(nla);\n\t\tether_addr_copy(eth_key->eth_src, output->eth.src);\n\t\tether_addr_copy(eth_key->eth_dst, output->eth.dst);\n\n\t\tif (swkey->eth.vlan.tci || eth_type_vlan(swkey->eth.type)) {\n\t\t\tif (ovs_nla_put_vlan(skb, &output->eth.vlan, is_mask))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tencap = nla_nest_start_noflag(skb, OVS_KEY_ATTR_ENCAP);\n\t\t\tif (!swkey->eth.vlan.tci)\n\t\t\t\tgoto unencap;\n\n\t\t\tif (swkey->eth.cvlan.tci || eth_type_vlan(swkey->eth.type)) {\n\t\t\t\tif (ovs_nla_put_vlan(skb, &output->eth.cvlan, is_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tin_encap = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t\t OVS_KEY_ATTR_ENCAP);\n\t\t\t\tif (!swkey->eth.cvlan.tci)\n\t\t\t\t\tgoto unencap;\n\t\t\t}\n\t\t}\n\n\t\tif (swkey->eth.type == htons(ETH_P_802_2)) {\n\t\t\t/*\n\t\t\t* Ethertype 802.2 is represented in the netlink with omitted\n\t\t\t* OVS_KEY_ATTR_ETHERTYPE in the flow key attribute, and\n\t\t\t* 0xffff in the mask attribute.  Ethertype can also\n\t\t\t* be wildcarded.\n\t\t\t*/\n\t\t\tif (is_mask && output->eth.type)\n\t\t\t\tif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,\n\t\t\t\t\t\t\toutput->eth.type))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\tgoto unencap;\n\t\t}\n\t}\n\n\tif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))\n\t\tgoto nla_put_failure;\n\n\tif (eth_type_vlan(swkey->eth.type)) {\n\t\t/* There are 3 VLAN tags, we don't know anything about the rest\n\t\t * of the packet, so truncate here.\n\t\t */\n\t\tWARN_ON_ONCE(!(encap && in_encap));\n\t\tgoto unencap;\n\t}\n\n\tif (swkey->eth.type == htons(ETH_P_IP)) {\n\t\tstruct ovs_key_ipv4 *ipv4_key;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_IPV4, sizeof(*ipv4_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tipv4_key = nla_data(nla);\n\t\tipv4_key->ipv4_src = output->ipv4.addr.src;\n\t\tipv4_key->ipv4_dst = output->ipv4.addr.dst;\n\t\tipv4_key->ipv4_proto = output->ip.proto;\n\t\tipv4_key->ipv4_tos = output->ip.tos;\n\t\tipv4_key->ipv4_ttl = output->ip.ttl;\n\t\tipv4_key->ipv4_frag = output->ip.frag;\n\t} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\n\t\tstruct ovs_key_ipv6 *ipv6_key;\n\t\tstruct ovs_key_ipv6_exthdrs *ipv6_exthdrs_key;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_IPV6, sizeof(*ipv6_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tipv6_key = nla_data(nla);\n\t\tmemcpy(ipv6_key->ipv6_src, &output->ipv6.addr.src,\n\t\t\t\tsizeof(ipv6_key->ipv6_src));\n\t\tmemcpy(ipv6_key->ipv6_dst, &output->ipv6.addr.dst,\n\t\t\t\tsizeof(ipv6_key->ipv6_dst));\n\t\tipv6_key->ipv6_label = output->ipv6.label;\n\t\tipv6_key->ipv6_proto = output->ip.proto;\n\t\tipv6_key->ipv6_tclass = output->ip.tos;\n\t\tipv6_key->ipv6_hlimit = output->ip.ttl;\n\t\tipv6_key->ipv6_frag = output->ip.frag;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_IPV6_EXTHDRS,\n\t\t\t\t  sizeof(*ipv6_exthdrs_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tipv6_exthdrs_key = nla_data(nla);\n\t\tipv6_exthdrs_key->hdrs = output->ipv6.exthdrs;\n\t} else if (swkey->eth.type == htons(ETH_P_NSH)) {\n\t\tif (nsh_key_to_nlattr(&output->nsh, is_mask, skb))\n\t\t\tgoto nla_put_failure;\n\t} else if (swkey->eth.type == htons(ETH_P_ARP) ||\n\t\t   swkey->eth.type == htons(ETH_P_RARP)) {\n\t\tstruct ovs_key_arp *arp_key;\n\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ARP, sizeof(*arp_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\t\tarp_key = nla_data(nla);\n\t\tmemset(arp_key, 0, sizeof(struct ovs_key_arp));\n\t\tarp_key->arp_sip = output->ipv4.addr.src;\n\t\tarp_key->arp_tip = output->ipv4.addr.dst;\n\t\tarp_key->arp_op = htons(output->ip.proto);\n\t\tether_addr_copy(arp_key->arp_sha, output->ipv4.arp.sha);\n\t\tether_addr_copy(arp_key->arp_tha, output->ipv4.arp.tha);\n\t} else if (eth_p_mpls(swkey->eth.type)) {\n\t\tu8 i, num_labels;\n\t\tstruct ovs_key_mpls *mpls_key;\n\n\t\tnum_labels = hweight_long(output->mpls.num_labels_mask);\n\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_MPLS,\n\t\t\t\t  num_labels * sizeof(*mpls_key));\n\t\tif (!nla)\n\t\t\tgoto nla_put_failure;\n\n\t\tmpls_key = nla_data(nla);\n\t\tfor (i = 0; i < num_labels; i++)\n\t\t\tmpls_key[i].mpls_lse = output->mpls.lse[i];\n\t}\n\n\tif ((swkey->eth.type == htons(ETH_P_IP) ||\n\t     swkey->eth.type == htons(ETH_P_IPV6)) &&\n\t     swkey->ip.frag != OVS_FRAG_TYPE_LATER) {\n\n\t\tif (swkey->ip.proto == IPPROTO_TCP) {\n\t\t\tstruct ovs_key_tcp *tcp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_TCP, sizeof(*tcp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ttcp_key = nla_data(nla);\n\t\t\ttcp_key->tcp_src = output->tp.src;\n\t\t\ttcp_key->tcp_dst = output->tp.dst;\n\t\t\tif (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\n\t\t\t\t\t output->tp.flags))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (swkey->ip.proto == IPPROTO_UDP) {\n\t\t\tstruct ovs_key_udp *udp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_UDP, sizeof(*udp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tudp_key = nla_data(nla);\n\t\t\tudp_key->udp_src = output->tp.src;\n\t\t\tudp_key->udp_dst = output->tp.dst;\n\t\t} else if (swkey->ip.proto == IPPROTO_SCTP) {\n\t\t\tstruct ovs_key_sctp *sctp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_SCTP, sizeof(*sctp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tsctp_key = nla_data(nla);\n\t\t\tsctp_key->sctp_src = output->tp.src;\n\t\t\tsctp_key->sctp_dst = output->tp.dst;\n\t\t} else if (swkey->eth.type == htons(ETH_P_IP) &&\n\t\t\t   swkey->ip.proto == IPPROTO_ICMP) {\n\t\t\tstruct ovs_key_icmp *icmp_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ICMP, sizeof(*icmp_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ticmp_key = nla_data(nla);\n\t\t\ticmp_key->icmp_type = ntohs(output->tp.src);\n\t\t\ticmp_key->icmp_code = ntohs(output->tp.dst);\n\t\t} else if (swkey->eth.type == htons(ETH_P_IPV6) &&\n\t\t\t   swkey->ip.proto == IPPROTO_ICMPV6) {\n\t\t\tstruct ovs_key_icmpv6 *icmpv6_key;\n\n\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ICMPV6,\n\t\t\t\t\t\tsizeof(*icmpv6_key));\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ticmpv6_key = nla_data(nla);\n\t\t\ticmpv6_key->icmpv6_type = ntohs(output->tp.src);\n\t\t\ticmpv6_key->icmpv6_code = ntohs(output->tp.dst);\n\n\t\t\tif (swkey->tp.src == htons(NDISC_NEIGHBOUR_SOLICITATION) ||\n\t\t\t    swkey->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) {\n\t\t\t\tstruct ovs_key_nd *nd_key;\n\n\t\t\t\tnla = nla_reserve(skb, OVS_KEY_ATTR_ND, sizeof(*nd_key));\n\t\t\t\tif (!nla)\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tnd_key = nla_data(nla);\n\t\t\t\tmemcpy(nd_key->nd_target, &output->ipv6.nd.target,\n\t\t\t\t\t\t\tsizeof(nd_key->nd_target));\n\t\t\t\tether_addr_copy(nd_key->nd_sll, output->ipv6.nd.sll);\n\t\t\t\tether_addr_copy(nd_key->nd_tll, output->ipv6.nd.tll);\n\t\t\t}\n\t\t}\n\t}\n\nunencap:\n\tif (in_encap)\n\t\tnla_nest_end(skb, in_encap);\n\tif (encap)\n\t\tnla_nest_end(skb, encap);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nint ovs_nla_put_key(const struct sw_flow_key *swkey,\n\t\t    const struct sw_flow_key *output, int attr, bool is_mask,\n\t\t    struct sk_buff *skb)\n{\n\tint err;\n\tstruct nlattr *nla;\n\n\tnla = nla_nest_start_noflag(skb, attr);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\terr = __ovs_nla_put_key(swkey, output, is_mask, skb);\n\tif (err)\n\t\treturn err;\n\tnla_nest_end(skb, nla);\n\n\treturn 0;\n}\n\n/* Called with ovs_mutex or RCU read lock. */\nint ovs_nla_put_identifier(const struct sw_flow *flow, struct sk_buff *skb)\n{\n\tif (ovs_identifier_is_ufid(&flow->id))\n\t\treturn nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id.ufid_len,\n\t\t\t       flow->id.ufid);\n\n\treturn ovs_nla_put_key(flow->id.unmasked_key, flow->id.unmasked_key,\n\t\t\t       OVS_FLOW_ATTR_KEY, false, skb);\n}\n\n/* Called with ovs_mutex or RCU read lock. */\nint ovs_nla_put_masked_key(const struct sw_flow *flow, struct sk_buff *skb)\n{\n\treturn ovs_nla_put_key(&flow->key, &flow->key,\n\t\t\t\tOVS_FLOW_ATTR_KEY, false, skb);\n}\n\n/* Called with ovs_mutex or RCU read lock. */\nint ovs_nla_put_mask(const struct sw_flow *flow, struct sk_buff *skb)\n{\n\treturn ovs_nla_put_key(&flow->key, &flow->mask->key,\n\t\t\t\tOVS_FLOW_ATTR_MASK, true, skb);\n}\n\n#define MAX_ACTIONS_BUFSIZE\t(32 * 1024)\n\nstatic struct sw_flow_actions *nla_alloc_flow_actions(int size)\n{\n\tstruct sw_flow_actions *sfa;\n\n\tWARN_ON_ONCE(size > MAX_ACTIONS_BUFSIZE);\n\n\tsfa = kmalloc(sizeof(*sfa) + size, GFP_KERNEL);\n\tif (!sfa)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsfa->actions_len = 0;\n\treturn sfa;\n}\n\nstatic void ovs_nla_free_nested_actions(const struct nlattr *actions, int len);\n\nstatic void ovs_nla_free_check_pkt_len_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a;\n\tint rem;\n\n\tnla_for_each_nested(a, action, rem) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL:\n\t\tcase OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER:\n\t\t\tovs_nla_free_nested_actions(nla_data(a), nla_len(a));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ovs_nla_free_clone_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a = nla_data(action);\n\tint rem = nla_len(action);\n\n\tswitch (nla_type(a)) {\n\tcase OVS_CLONE_ATTR_EXEC:\n\t\t/* The real list of actions follows this attribute. */\n\t\ta = nla_next(a, &rem);\n\t\tovs_nla_free_nested_actions(a, rem);\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_dec_ttl_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a = nla_data(action);\n\n\tswitch (nla_type(a)) {\n\tcase OVS_DEC_TTL_ATTR_ACTION:\n\t\tovs_nla_free_nested_actions(nla_data(a), nla_len(a));\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_sample_action(const struct nlattr *action)\n{\n\tconst struct nlattr *a = nla_data(action);\n\tint rem = nla_len(action);\n\n\tswitch (nla_type(a)) {\n\tcase OVS_SAMPLE_ATTR_ARG:\n\t\t/* The real list of actions follows this attribute. */\n\t\ta = nla_next(a, &rem);\n\t\tovs_nla_free_nested_actions(a, rem);\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_set_action(const struct nlattr *a)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tstruct ovs_tunnel_info *ovs_tun;\n\n\tswitch (nla_type(ovs_key)) {\n\tcase OVS_KEY_ATTR_TUNNEL_INFO:\n\t\tovs_tun = nla_data(ovs_key);\n\t\tdst_release((struct dst_entry *)ovs_tun->tun_dst);\n\t\tbreak;\n\t}\n}\n\nstatic void ovs_nla_free_nested_actions(const struct nlattr *actions, int len)\n{\n\tconst struct nlattr *a;\n\tint rem;\n\n\t/* Whenever new actions are added, the need to update this\n\t * function should be considered.\n\t */\n\tBUILD_BUG_ON(OVS_ACTION_ATTR_MAX != 23);\n\n\tif (!actions)\n\t\treturn;\n\n\tnla_for_each_attr(a, actions, len, rem) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN:\n\t\t\tovs_nla_free_check_pkt_len_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE:\n\t\t\tovs_nla_free_clone_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\tovs_ct_free_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\tovs_nla_free_dec_ttl_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE:\n\t\t\tovs_nla_free_sample_action(a);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\tovs_nla_free_set_action(a);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ovs_nla_free_flow_actions(struct sw_flow_actions *sf_acts)\n{\n\tif (!sf_acts)\n\t\treturn;\n\n\tovs_nla_free_nested_actions(sf_acts->actions, sf_acts->actions_len);\n\tkfree(sf_acts);\n}\n\nstatic void __ovs_nla_free_flow_actions(struct rcu_head *head)\n{\n\tovs_nla_free_flow_actions(container_of(head, struct sw_flow_actions, rcu));\n}\n\n/* Schedules 'sf_acts' to be freed after the next RCU grace period.\n * The caller must hold rcu_read_lock for this to be sensible. */\nvoid ovs_nla_free_flow_actions_rcu(struct sw_flow_actions *sf_acts)\n{\n\tcall_rcu(&sf_acts->rcu, __ovs_nla_free_flow_actions);\n}\n\nstatic struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((next_offset + req_size) > MAX_ACTIONS_BUFSIZE) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\n\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}\n\nstatic struct nlattr *__add_action(struct sw_flow_actions **sfa,\n\t\t\t\t   int attrtype, void *data, int len, bool log)\n{\n\tstruct nlattr *a;\n\n\ta = reserve_sfa_size(sfa, nla_attr_size(len), log);\n\tif (IS_ERR(a))\n\t\treturn a;\n\n\ta->nla_type = attrtype;\n\ta->nla_len = nla_attr_size(len);\n\n\tif (data)\n\t\tmemcpy(nla_data(a), data, len);\n\tmemset((unsigned char *) a + a->nla_len, 0, nla_padlen(len));\n\n\treturn a;\n}\n\nint ovs_nla_add_action(struct sw_flow_actions **sfa, int attrtype, void *data,\n\t\t       int len, bool log)\n{\n\tstruct nlattr *a;\n\n\ta = __add_action(sfa, attrtype, data, len, log);\n\n\treturn PTR_ERR_OR_ZERO(a);\n}\n\nstatic inline int add_nested_action_start(struct sw_flow_actions **sfa,\n\t\t\t\t\t  int attrtype, bool log)\n{\n\tint used = (*sfa)->actions_len;\n\tint err;\n\n\terr = ovs_nla_add_action(sfa, attrtype, NULL, 0, log);\n\tif (err)\n\t\treturn err;\n\n\treturn used;\n}\n\nstatic inline void add_nested_action_end(struct sw_flow_actions *sfa,\n\t\t\t\t\t int st_offset)\n{\n\tstruct nlattr *a = (struct nlattr *) ((unsigned char *)sfa->actions +\n\t\t\t\t\t\t\t       st_offset);\n\n\ta->nla_len = sfa->actions_len - st_offset;\n}\n\nstatic int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\n\t\t\t\t  const struct sw_flow_key *key,\n\t\t\t\t  struct sw_flow_actions **sfa,\n\t\t\t\t  __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t  u32 mpls_label_count, bool log);\n\nstatic int validate_and_copy_sample(struct net *net, const struct nlattr *attr,\n\t\t\t\t    const struct sw_flow_key *key,\n\t\t\t\t    struct sw_flow_actions **sfa,\n\t\t\t\t    __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t    u32 mpls_label_count, bool log, bool last)\n{\n\tconst struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];\n\tconst struct nlattr *probability, *actions;\n\tconst struct nlattr *a;\n\tint rem, start, err;\n\tstruct sample_arg arg;\n\n\tmemset(attrs, 0, sizeof(attrs));\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\t\tif (!type || type > OVS_SAMPLE_ATTR_MAX || attrs[type])\n\t\t\treturn -EINVAL;\n\t\tattrs[type] = a;\n\t}\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tprobability = attrs[OVS_SAMPLE_ATTR_PROBABILITY];\n\tif (!probability || nla_len(probability) != sizeof(u32))\n\t\treturn -EINVAL;\n\n\tactions = attrs[OVS_SAMPLE_ATTR_ACTIONS];\n\tif (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN))\n\t\treturn -EINVAL;\n\n\t/* validation done, copy sample action. */\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SAMPLE, log);\n\tif (start < 0)\n\t\treturn start;\n\n\t/* When both skb and flow may be changed, put the sample\n\t * into a deferred fifo. On the other hand, if only skb\n\t * may be modified, the actions can be executed in place.\n\t *\n\t * Do this analysis at the flow installation time.\n\t * Set 'clone_action->exec' to true if the actions can be\n\t * executed without being deferred.\n\t *\n\t * If the sample is the last action, it can always be excuted\n\t * rather than deferred.\n\t */\n\targ.exec = last || !actions_may_change_flow(actions);\n\targ.probability = nla_get_u32(probability);\n\n\terr = ovs_nla_add_action(sfa, OVS_SAMPLE_ATTR_ARG, &arg, sizeof(arg),\n\t\t\t\t log);\n\tif (err)\n\t\treturn err;\n\n\terr = __ovs_nla_copy_actions(net, actions, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, start);\n\n\treturn 0;\n}\n\nstatic int validate_and_copy_dec_ttl(struct net *net,\n\t\t\t\t     const struct nlattr *attr,\n\t\t\t\t     const struct sw_flow_key *key,\n\t\t\t\t     struct sw_flow_actions **sfa,\n\t\t\t\t     __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t     u32 mpls_label_count, bool log)\n{\n\tconst struct nlattr *attrs[OVS_DEC_TTL_ATTR_MAX + 1];\n\tint start, action_start, err, rem;\n\tconst struct nlattr *a, *actions;\n\n\tmemset(attrs, 0, sizeof(attrs));\n\tnla_for_each_nested(a, attr, rem) {\n\t\tint type = nla_type(a);\n\n\t\t/* Ignore unknown attributes to be future proof. */\n\t\tif (type > OVS_DEC_TTL_ATTR_MAX)\n\t\t\tcontinue;\n\n\t\tif (!type || attrs[type]) {\n\t\t\tOVS_NLERR(log, \"Duplicate or invalid key (type %d).\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tattrs[type] = a;\n\t}\n\n\tif (rem) {\n\t\tOVS_NLERR(log, \"Message has %d unknown bytes.\", rem);\n\t\treturn -EINVAL;\n\t}\n\n\tactions = attrs[OVS_DEC_TTL_ATTR_ACTION];\n\tif (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN)) {\n\t\tOVS_NLERR(log, \"Missing valid actions attribute.\");\n\t\treturn -EINVAL;\n\t}\n\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_DEC_TTL, log);\n\tif (start < 0)\n\t\treturn start;\n\n\taction_start = add_nested_action_start(sfa, OVS_DEC_TTL_ATTR_ACTION, log);\n\tif (action_start < 0)\n\t\treturn action_start;\n\n\terr = __ovs_nla_copy_actions(net, actions, key, sfa, eth_type,\n\t\t\t\t     vlan_tci, mpls_label_count, log);\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, action_start);\n\tadd_nested_action_end(*sfa, start);\n\treturn 0;\n}\n\nstatic int validate_and_copy_clone(struct net *net,\n\t\t\t\t   const struct nlattr *attr,\n\t\t\t\t   const struct sw_flow_key *key,\n\t\t\t\t   struct sw_flow_actions **sfa,\n\t\t\t\t   __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t   u32 mpls_label_count, bool log, bool last)\n{\n\tint start, err;\n\tu32 exec;\n\n\tif (nla_len(attr) && nla_len(attr) < NLA_HDRLEN)\n\t\treturn -EINVAL;\n\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_CLONE, log);\n\tif (start < 0)\n\t\treturn start;\n\n\texec = last || !actions_may_change_flow(attr);\n\n\terr = ovs_nla_add_action(sfa, OVS_CLONE_ATTR_EXEC, &exec,\n\t\t\t\t sizeof(exec), log);\n\tif (err)\n\t\treturn err;\n\n\terr = __ovs_nla_copy_actions(net, attr, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, start);\n\n\treturn 0;\n}\n\nvoid ovs_match_init(struct sw_flow_match *match,\n\t\t    struct sw_flow_key *key,\n\t\t    bool reset_key,\n\t\t    struct sw_flow_mask *mask)\n{\n\tmemset(match, 0, sizeof(*match));\n\tmatch->key = key;\n\tmatch->mask = mask;\n\n\tif (reset_key)\n\t\tmemset(key, 0, sizeof(*key));\n\n\tif (mask) {\n\t\tmemset(&mask->key, 0, sizeof(mask->key));\n\t\tmask->range.start = mask->range.end = 0;\n\t}\n}\n\nstatic int validate_geneve_opts(struct sw_flow_key *key)\n{\n\tstruct geneve_opt *option;\n\tint opts_len = key->tun_opts_len;\n\tbool crit_opt = false;\n\n\toption = (struct geneve_opt *)TUN_METADATA_OPTS(key, key->tun_opts_len);\n\twhile (opts_len > 0) {\n\t\tint len;\n\n\t\tif (opts_len < sizeof(*option))\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(*option) + option->length * 4;\n\t\tif (len > opts_len)\n\t\t\treturn -EINVAL;\n\n\t\tcrit_opt |= !!(option->type & GENEVE_CRIT_OPT_TYPE);\n\n\t\toption = (struct geneve_opt *)((u8 *)option + len);\n\t\topts_len -= len;\n\t}\n\n\tkey->tun_key.tun_flags |= crit_opt ? TUNNEL_CRIT_OPT : 0;\n\n\treturn 0;\n}\n\nstatic int validate_and_copy_set_tun(const struct nlattr *attr,\n\t\t\t\t     struct sw_flow_actions **sfa, bool log)\n{\n\tstruct sw_flow_match match;\n\tstruct sw_flow_key key;\n\tstruct metadata_dst *tun_dst;\n\tstruct ip_tunnel_info *tun_info;\n\tstruct ovs_tunnel_info *ovs_tun;\n\tstruct nlattr *a;\n\tint err = 0, start, opts_type;\n\t__be16 dst_opt_type;\n\n\tdst_opt_type = 0;\n\tovs_match_init(&match, &key, true, NULL);\n\topts_type = ip_tun_from_nlattr(nla_data(attr), &match, false, log);\n\tif (opts_type < 0)\n\t\treturn opts_type;\n\n\tif (key.tun_opts_len) {\n\t\tswitch (opts_type) {\n\t\tcase OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\n\t\t\terr = validate_geneve_opts(&key);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tdst_opt_type = TUNNEL_GENEVE_OPT;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\n\t\t\tdst_opt_type = TUNNEL_VXLAN_OPT;\n\t\t\tbreak;\n\t\tcase OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS:\n\t\t\tdst_opt_type = TUNNEL_ERSPAN_OPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET, log);\n\tif (start < 0)\n\t\treturn start;\n\n\ttun_dst = metadata_dst_alloc(key.tun_opts_len, METADATA_IP_TUNNEL,\n\t\t\t\t     GFP_KERNEL);\n\n\tif (!tun_dst)\n\t\treturn -ENOMEM;\n\n\terr = dst_cache_init(&tun_dst->u.tun_info.dst_cache, GFP_KERNEL);\n\tif (err) {\n\t\tdst_release((struct dst_entry *)tun_dst);\n\t\treturn err;\n\t}\n\n\ta = __add_action(sfa, OVS_KEY_ATTR_TUNNEL_INFO, NULL,\n\t\t\t sizeof(*ovs_tun), log);\n\tif (IS_ERR(a)) {\n\t\tdst_release((struct dst_entry *)tun_dst);\n\t\treturn PTR_ERR(a);\n\t}\n\n\tovs_tun = nla_data(a);\n\tovs_tun->tun_dst = tun_dst;\n\n\ttun_info = &tun_dst->u.tun_info;\n\ttun_info->mode = IP_TUNNEL_INFO_TX;\n\tif (key.tun_proto == AF_INET6)\n\t\ttun_info->mode |= IP_TUNNEL_INFO_IPV6;\n\telse if (key.tun_proto == AF_INET && key.tun_key.u.ipv4.dst == 0)\n\t\ttun_info->mode |= IP_TUNNEL_INFO_BRIDGE;\n\ttun_info->key = key.tun_key;\n\n\t/* We need to store the options in the action itself since\n\t * everything else will go away after flow setup. We can append\n\t * it to tun_info and then point there.\n\t */\n\tip_tunnel_info_opts_set(tun_info,\n\t\t\t\tTUN_METADATA_OPTS(&key, key.tun_opts_len),\n\t\t\t\tkey.tun_opts_len, dst_opt_type);\n\tadd_nested_action_end(*sfa, start);\n\n\treturn err;\n}\n\nstatic bool validate_nsh(const struct nlattr *attr, bool is_mask,\n\t\t\t bool is_push_nsh, bool log)\n{\n\tstruct sw_flow_match match;\n\tstruct sw_flow_key key;\n\tint ret = 0;\n\n\tovs_match_init(&match, &key, true, NULL);\n\tret = nsh_key_put_from_nlattr(attr, &match, is_mask,\n\t\t\t\t      is_push_nsh, log);\n\treturn !ret;\n}\n\n/* Return false if there are any non-masked bits set.\n * Mask follows data immediately, before any netlink padding.\n */\nstatic bool validate_masked(u8 *data, int len)\n{\n\tu8 *mask = data + len;\n\n\twhile (len--)\n\t\tif (*data++ & ~*mask++)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int validate_set(const struct nlattr *a,\n\t\t\tconst struct sw_flow_key *flow_key,\n\t\t\tstruct sw_flow_actions **sfa, bool *skip_copy,\n\t\t\tu8 mac_proto, __be16 eth_type, bool masked, bool log)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tint key_type = nla_type(ovs_key);\n\tsize_t key_len;\n\n\t/* There can be only one key in a action */\n\tif (nla_total_size(nla_len(ovs_key)) != nla_len(a))\n\t\treturn -EINVAL;\n\n\tkey_len = nla_len(ovs_key);\n\tif (masked)\n\t\tkey_len /= 2;\n\n\tif (key_type > OVS_KEY_ATTR_MAX ||\n\t    !check_attr_len(key_len, ovs_key_lens[key_type].len))\n\t\treturn -EINVAL;\n\n\tif (masked && !validate_masked(nla_data(ovs_key), key_len))\n\t\treturn -EINVAL;\n\n\tswitch (key_type) {\n\tcase OVS_KEY_ATTR_PRIORITY:\n\tcase OVS_KEY_ATTR_SKB_MARK:\n\tcase OVS_KEY_ATTR_CT_MARK:\n\tcase OVS_KEY_ATTR_CT_LABELS:\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_ETHERNET:\n\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_TUNNEL: {\n\t\tint err;\n\n\t\tif (masked)\n\t\t\treturn -EINVAL; /* Masked tunnel set not supported. */\n\n\t\t*skip_copy = true;\n\t\terr = validate_and_copy_set_tun(a, sfa, log);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\tcase OVS_KEY_ATTR_IPV4: {\n\t\tconst struct ovs_key_ipv4 *ipv4_key;\n\n\t\tif (eth_type != htons(ETH_P_IP))\n\t\t\treturn -EINVAL;\n\n\t\tipv4_key = nla_data(ovs_key);\n\n\t\tif (masked) {\n\t\t\tconst struct ovs_key_ipv4 *mask = ipv4_key + 1;\n\n\t\t\t/* Non-writeable fields. */\n\t\t\tif (mask->ipv4_proto || mask->ipv4_frag)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ipv4_key->ipv4_proto != flow_key->ip.proto)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (ipv4_key->ipv4_frag != flow_key->ip.frag)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase OVS_KEY_ATTR_IPV6: {\n\t\tconst struct ovs_key_ipv6 *ipv6_key;\n\n\t\tif (eth_type != htons(ETH_P_IPV6))\n\t\t\treturn -EINVAL;\n\n\t\tipv6_key = nla_data(ovs_key);\n\n\t\tif (masked) {\n\t\t\tconst struct ovs_key_ipv6 *mask = ipv6_key + 1;\n\n\t\t\t/* Non-writeable fields. */\n\t\t\tif (mask->ipv6_proto || mask->ipv6_frag)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Invalid bits in the flow label mask? */\n\t\t\tif (ntohl(mask->ipv6_label) & 0xFFF00000)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ipv6_key->ipv6_proto != flow_key->ip.proto)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (ipv6_key->ipv6_frag != flow_key->ip.frag)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ntohl(ipv6_key->ipv6_label) & 0xFFF00000)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\t}\n\tcase OVS_KEY_ATTR_TCP:\n\t\tif ((eth_type != htons(ETH_P_IP) &&\n\t\t     eth_type != htons(ETH_P_IPV6)) ||\n\t\t    flow_key->ip.proto != IPPROTO_TCP)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_UDP:\n\t\tif ((eth_type != htons(ETH_P_IP) &&\n\t\t     eth_type != htons(ETH_P_IPV6)) ||\n\t\t    flow_key->ip.proto != IPPROTO_UDP)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_MPLS:\n\t\tif (!eth_p_mpls(eth_type))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_SCTP:\n\t\tif ((eth_type != htons(ETH_P_IP) &&\n\t\t     eth_type != htons(ETH_P_IPV6)) ||\n\t\t    flow_key->ip.proto != IPPROTO_SCTP)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase OVS_KEY_ATTR_NSH:\n\t\tif (eth_type != htons(ETH_P_NSH))\n\t\t\treturn -EINVAL;\n\t\tif (!validate_nsh(nla_data(a), masked, false, log))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Convert non-masked non-tunnel set actions to masked set actions. */\n\tif (!masked && key_type != OVS_KEY_ATTR_TUNNEL) {\n\t\tint start, len = key_len * 2;\n\t\tstruct nlattr *at;\n\n\t\t*skip_copy = true;\n\n\t\tstart = add_nested_action_start(sfa,\n\t\t\t\t\t\tOVS_ACTION_ATTR_SET_TO_MASKED,\n\t\t\t\t\t\tlog);\n\t\tif (start < 0)\n\t\t\treturn start;\n\n\t\tat = __add_action(sfa, key_type, NULL, len, log);\n\t\tif (IS_ERR(at))\n\t\t\treturn PTR_ERR(at);\n\n\t\tmemcpy(nla_data(at), nla_data(ovs_key), key_len); /* Key. */\n\t\tmemset(nla_data(at) + key_len, 0xff, key_len);    /* Mask. */\n\t\t/* Clear non-writeable bits from otherwise writeable fields. */\n\t\tif (key_type == OVS_KEY_ATTR_IPV6) {\n\t\t\tstruct ovs_key_ipv6 *mask = nla_data(at) + key_len;\n\n\t\t\tmask->ipv6_label &= htonl(0x000FFFFF);\n\t\t}\n\t\tadd_nested_action_end(*sfa, start);\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_userspace(const struct nlattr *attr)\n{\n\tstatic const struct nla_policy userspace_policy[OVS_USERSPACE_ATTR_MAX + 1] = {\n\t\t[OVS_USERSPACE_ATTR_PID] = {.type = NLA_U32 },\n\t\t[OVS_USERSPACE_ATTR_USERDATA] = {.type = NLA_UNSPEC },\n\t\t[OVS_USERSPACE_ATTR_EGRESS_TUN_PORT] = {.type = NLA_U32 },\n\t};\n\tstruct nlattr *a[OVS_USERSPACE_ATTR_MAX + 1];\n\tint error;\n\n\terror = nla_parse_nested_deprecated(a, OVS_USERSPACE_ATTR_MAX, attr,\n\t\t\t\t\t    userspace_policy, NULL);\n\tif (error)\n\t\treturn error;\n\n\tif (!a[OVS_USERSPACE_ATTR_PID] ||\n\t    !nla_get_u32(a[OVS_USERSPACE_ATTR_PID]))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy cpl_policy[OVS_CHECK_PKT_LEN_ATTR_MAX + 1] = {\n\t[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN] = {.type = NLA_U16 },\n\t[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER] = {.type = NLA_NESTED },\n\t[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL] = {.type = NLA_NESTED },\n};\n\nstatic int validate_and_copy_check_pkt_len(struct net *net,\n\t\t\t\t\t   const struct nlattr *attr,\n\t\t\t\t\t   const struct sw_flow_key *key,\n\t\t\t\t\t   struct sw_flow_actions **sfa,\n\t\t\t\t\t   __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t\t   u32 mpls_label_count,\n\t\t\t\t\t   bool log, bool last)\n{\n\tconst struct nlattr *acts_if_greater, *acts_if_lesser_eq;\n\tstruct nlattr *a[OVS_CHECK_PKT_LEN_ATTR_MAX + 1];\n\tstruct check_pkt_len_arg arg;\n\tint nested_acts_start;\n\tint start, err;\n\n\terr = nla_parse_deprecated_strict(a, OVS_CHECK_PKT_LEN_ATTR_MAX,\n\t\t\t\t\t  nla_data(attr), nla_len(attr),\n\t\t\t\t\t  cpl_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!a[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN] ||\n\t    !nla_get_u16(a[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN]))\n\t\treturn -EINVAL;\n\n\tacts_if_lesser_eq = a[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL];\n\tacts_if_greater = a[OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER];\n\n\t/* Both the nested action should be present. */\n\tif (!acts_if_greater || !acts_if_lesser_eq)\n\t\treturn -EINVAL;\n\n\t/* validation done, copy the nested actions. */\n\tstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_CHECK_PKT_LEN,\n\t\t\t\t\tlog);\n\tif (start < 0)\n\t\treturn start;\n\n\targ.pkt_len = nla_get_u16(a[OVS_CHECK_PKT_LEN_ATTR_PKT_LEN]);\n\targ.exec_for_lesser_equal =\n\t\tlast || !actions_may_change_flow(acts_if_lesser_eq);\n\targ.exec_for_greater =\n\t\tlast || !actions_may_change_flow(acts_if_greater);\n\n\terr = ovs_nla_add_action(sfa, OVS_CHECK_PKT_LEN_ATTR_ARG, &arg,\n\t\t\t\t sizeof(arg), log);\n\tif (err)\n\t\treturn err;\n\n\tnested_acts_start = add_nested_action_start(sfa,\n\t\tOVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL, log);\n\tif (nested_acts_start < 0)\n\t\treturn nested_acts_start;\n\n\terr = __ovs_nla_copy_actions(net, acts_if_lesser_eq, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, nested_acts_start);\n\n\tnested_acts_start = add_nested_action_start(sfa,\n\t\tOVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER, log);\n\tif (nested_acts_start < 0)\n\t\treturn nested_acts_start;\n\n\terr = __ovs_nla_copy_actions(net, acts_if_greater, key, sfa,\n\t\t\t\t     eth_type, vlan_tci, mpls_label_count, log);\n\n\tif (err)\n\t\treturn err;\n\n\tadd_nested_action_end(*sfa, nested_acts_start);\n\tadd_nested_action_end(*sfa, start);\n\treturn 0;\n}\n\nstatic int copy_action(const struct nlattr *from,\n\t\t       struct sw_flow_actions **sfa, bool log)\n{\n\tint totlen = NLA_ALIGN(from->nla_len);\n\tstruct nlattr *to;\n\n\tto = reserve_sfa_size(sfa, from->nla_len, log);\n\tif (IS_ERR(to))\n\t\treturn PTR_ERR(to);\n\n\tmemcpy(to, from, totlen);\n\treturn 0;\n}\n\nstatic int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\n\t\t\t\t  const struct sw_flow_key *key,\n\t\t\t\t  struct sw_flow_actions **sfa,\n\t\t\t\t  __be16 eth_type, __be16 vlan_tci,\n\t\t\t\t  u32 mpls_label_count, bool log)\n{\n\tu8 mac_proto = ovs_key_mac_proto(key);\n\tconst struct nlattr *a;\n\tint rem, err;\n\n\tnla_for_each_nested(a, attr, rem) {\n\t\t/* Expected argument lengths, (u32)-1 for variable length. */\n\t\tstatic const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {\n\t\t\t[OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),\n\t\t\t[OVS_ACTION_ATTR_RECIRC] = sizeof(u32),\n\t\t\t[OVS_ACTION_ATTR_USERSPACE] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_PUSH_MPLS] = sizeof(struct ovs_action_push_mpls),\n\t\t\t[OVS_ACTION_ATTR_POP_MPLS] = sizeof(__be16),\n\t\t\t[OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),\n\t\t\t[OVS_ACTION_ATTR_POP_VLAN] = 0,\n\t\t\t[OVS_ACTION_ATTR_SET] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_SET_MASKED] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_SAMPLE] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash),\n\t\t\t[OVS_ACTION_ATTR_CT] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_CT_CLEAR] = 0,\n\t\t\t[OVS_ACTION_ATTR_TRUNC] = sizeof(struct ovs_action_trunc),\n\t\t\t[OVS_ACTION_ATTR_PUSH_ETH] = sizeof(struct ovs_action_push_eth),\n\t\t\t[OVS_ACTION_ATTR_POP_ETH] = 0,\n\t\t\t[OVS_ACTION_ATTR_PUSH_NSH] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_POP_NSH] = 0,\n\t\t\t[OVS_ACTION_ATTR_METER] = sizeof(u32),\n\t\t\t[OVS_ACTION_ATTR_CLONE] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_CHECK_PKT_LEN] = (u32)-1,\n\t\t\t[OVS_ACTION_ATTR_ADD_MPLS] = sizeof(struct ovs_action_add_mpls),\n\t\t\t[OVS_ACTION_ATTR_DEC_TTL] = (u32)-1,\n\t\t};\n\t\tconst struct ovs_action_push_vlan *vlan;\n\t\tint type = nla_type(a);\n\t\tbool skip_copy;\n\n\t\tif (type > OVS_ACTION_ATTR_MAX ||\n\t\t    (action_lens[type] != nla_len(a) &&\n\t\t     action_lens[type] != (u32)-1))\n\t\t\treturn -EINVAL;\n\n\t\tskip_copy = false;\n\t\tswitch (type) {\n\t\tcase OVS_ACTION_ATTR_UNSPEC:\n\t\t\treturn -EINVAL;\n\n\t\tcase OVS_ACTION_ATTR_USERSPACE:\n\t\t\terr = validate_userspace(a);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_OUTPUT:\n\t\t\tif (nla_get_u32(a) >= DP_MAX_PORTS)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_TRUNC: {\n\t\t\tconst struct ovs_action_trunc *trunc = nla_data(a);\n\n\t\t\tif (trunc->max_len < ETH_HLEN)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_HASH: {\n\t\t\tconst struct ovs_action_hash *act_hash = nla_data(a);\n\n\t\t\tswitch (act_hash->hash_alg) {\n\t\t\tcase OVS_HASH_ALG_L4:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn  -EINVAL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_POP_VLAN:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\t\treturn -EINVAL;\n\t\t\tvlan_tci = htons(0);\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_VLAN:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\t\treturn -EINVAL;\n\t\t\tvlan = nla_data(a);\n\t\t\tif (!eth_type_vlan(vlan->vlan_tpid))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!(vlan->vlan_tci & htons(VLAN_CFI_MASK)))\n\t\t\t\treturn -EINVAL;\n\t\t\tvlan_tci = vlan->vlan_tci;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_RECIRC:\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_ADD_MPLS: {\n\t\t\tconst struct ovs_action_add_mpls *mpls = nla_data(a);\n\n\t\t\tif (!eth_p_mpls(mpls->mpls_ethertype))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (mpls->tun_flags & OVS_MPLS_L3_TUNNEL_FLAG_MASK) {\n\t\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK) ||\n\t\t\t\t    (eth_type != htons(ETH_P_IP) &&\n\t\t\t\t     eth_type != htons(ETH_P_IPV6) &&\n\t\t\t\t     eth_type != htons(ETH_P_ARP) &&\n\t\t\t\t     eth_type != htons(ETH_P_RARP) &&\n\t\t\t\t     !eth_p_mpls(eth_type)))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tmpls_label_count++;\n\t\t\t} else {\n\t\t\t\tif (mac_proto == MAC_PROTO_ETHERNET) {\n\t\t\t\t\tmpls_label_count = 1;\n\t\t\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\t\t} else {\n\t\t\t\t\tmpls_label_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\teth_type = mpls->mpls_ethertype;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_PUSH_MPLS: {\n\t\t\tconst struct ovs_action_push_mpls *mpls = nla_data(a);\n\n\t\t\tif (!eth_p_mpls(mpls->mpls_ethertype))\n\t\t\t\treturn -EINVAL;\n\t\t\t/* Prohibit push MPLS other than to a white list\n\t\t\t * for packets that have a known tag order.\n\t\t\t */\n\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK) ||\n\t\t\t    (eth_type != htons(ETH_P_IP) &&\n\t\t\t     eth_type != htons(ETH_P_IPV6) &&\n\t\t\t     eth_type != htons(ETH_P_ARP) &&\n\t\t\t     eth_type != htons(ETH_P_RARP) &&\n\t\t\t     !eth_p_mpls(eth_type)))\n\t\t\t\treturn -EINVAL;\n\t\t\teth_type = mpls->mpls_ethertype;\n\t\t\tmpls_label_count++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_POP_MPLS: {\n\t\t\t__be16  proto;\n\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK) ||\n\t\t\t    !eth_p_mpls(eth_type))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Disallow subsequent L2.5+ set actions and mpls_pop\n\t\t\t * actions once the last MPLS label in the packet is\n\t\t\t * is popped as there is no check here to ensure that\n\t\t\t * the new eth type is valid and thus set actions could\n\t\t\t * write off the end of the packet or otherwise corrupt\n\t\t\t * it.\n\t\t\t *\n\t\t\t * Support for these actions is planned using packet\n\t\t\t * recirculation.\n\t\t\t */\n\t\t\tproto = nla_get_be16(a);\n\n\t\t\tif (proto == htons(ETH_P_TEB) &&\n\t\t\t    mac_proto != MAC_PROTO_NONE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmpls_label_count--;\n\n\t\t\tif (!eth_p_mpls(proto) || !mpls_label_count)\n\t\t\t\teth_type = htons(0);\n\t\t\telse\n\t\t\t\teth_type =  proto;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\terr = validate_set(a, key, sfa,\n\t\t\t\t\t   &skip_copy, mac_proto, eth_type,\n\t\t\t\t\t   false, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET_MASKED:\n\t\t\terr = validate_set(a, key, sfa,\n\t\t\t\t\t   &skip_copy, mac_proto, eth_type,\n\t\t\t\t\t   true, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = validate_and_copy_sample(net, a, key, sfa,\n\t\t\t\t\t\t       eth_type, vlan_tci,\n\t\t\t\t\t\t       mpls_label_count,\n\t\t\t\t\t\t       log, last);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\terr = ovs_ct_copy_action(net, a, key, sfa, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT_CLEAR:\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_ETH:\n\t\t\t/* Disallow pushing an Ethernet header if one\n\t\t\t * is already present */\n\t\t\tif (mac_proto != MAC_PROTO_NONE)\n\t\t\t\treturn -EINVAL;\n\t\t\tmac_proto = MAC_PROTO_ETHERNET;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_POP_ETH:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vlan_tci & htons(VLAN_CFI_MASK))\n\t\t\t\treturn -EINVAL;\n\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_PUSH_NSH:\n\t\t\tif (mac_proto != MAC_PROTO_ETHERNET) {\n\t\t\t\tu8 next_proto;\n\n\t\t\t\tnext_proto = tun_p_from_eth_p(eth_type);\n\t\t\t\tif (!next_proto)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\tif (!validate_nsh(nla_data(a), false, true, true))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_POP_NSH: {\n\t\t\t__be16 inner_proto;\n\n\t\t\tif (eth_type != htons(ETH_P_NSH))\n\t\t\t\treturn -EINVAL;\n\t\t\tinner_proto = tun_p_to_eth_p(key->nsh.base.np);\n\t\t\tif (!inner_proto)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (key->nsh.base.np == TUN_P_ETHERNET)\n\t\t\t\tmac_proto = MAC_PROTO_ETHERNET;\n\t\t\telse\n\t\t\t\tmac_proto = MAC_PROTO_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_METER:\n\t\t\t/* Non-existent meters are simply ignored.  */\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = validate_and_copy_clone(net, a, key, sfa,\n\t\t\t\t\t\t      eth_type, vlan_tci,\n\t\t\t\t\t\t      mpls_label_count,\n\t\t\t\t\t\t      log, last);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN: {\n\t\t\tbool last = nla_is_last(a, rem);\n\n\t\t\terr = validate_and_copy_check_pkt_len(net, a, key, sfa,\n\t\t\t\t\t\t\t      eth_type,\n\t\t\t\t\t\t\t      vlan_tci,\n\t\t\t\t\t\t\t      mpls_label_count,\n\t\t\t\t\t\t\t      log, last);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\terr = validate_and_copy_dec_ttl(net, a, key, sfa,\n\t\t\t\t\t\t\teth_type, vlan_tci,\n\t\t\t\t\t\t\tmpls_label_count, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tskip_copy = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tOVS_NLERR(log, \"Unknown Action type %d\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!skip_copy) {\n\t\t\terr = copy_action(a, sfa, log);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (rem > 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* 'key' must be the masked key. */\nint ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\n\t\t\t const struct sw_flow_key *key,\n\t\t\t struct sw_flow_actions **sfa, bool log)\n{\n\tint err;\n\tu32 mpls_label_count = 0;\n\n\t*sfa = nla_alloc_flow_actions(min(nla_len(attr), MAX_ACTIONS_BUFSIZE));\n\tif (IS_ERR(*sfa))\n\t\treturn PTR_ERR(*sfa);\n\n\tif (eth_p_mpls(key->eth.type))\n\t\tmpls_label_count = hweight_long(key->mpls.num_labels_mask);\n\n\t(*sfa)->orig_len = nla_len(attr);\n\terr = __ovs_nla_copy_actions(net, attr, key, sfa, key->eth.type,\n\t\t\t\t     key->eth.vlan.tci, mpls_label_count, log);\n\tif (err)\n\t\tovs_nla_free_flow_actions(*sfa);\n\n\treturn err;\n}\n\nstatic int sample_action_to_attr(const struct nlattr *attr,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct nlattr *start, *ac_start = NULL, *sample_arg;\n\tint err = 0, rem = nla_len(attr);\n\tconst struct sample_arg *arg;\n\tstruct nlattr *actions;\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_SAMPLE);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tsample_arg = nla_data(attr);\n\targ = nla_data(sample_arg);\n\tactions = nla_next(sample_arg, &rem);\n\n\tif (nla_put_u32(skb, OVS_SAMPLE_ATTR_PROBABILITY, arg->probability)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tac_start = nla_nest_start_noflag(skb, OVS_SAMPLE_ATTR_ACTIONS);\n\tif (!ac_start) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ovs_nla_put_actions(actions, rem, skb);\n\nout:\n\tif (err) {\n\t\tnla_nest_cancel(skb, ac_start);\n\t\tnla_nest_cancel(skb, start);\n\t} else {\n\t\tnla_nest_end(skb, ac_start);\n\t\tnla_nest_end(skb, start);\n\t}\n\n\treturn err;\n}\n\nstatic int clone_action_to_attr(const struct nlattr *attr,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nlattr *start;\n\tint err = 0, rem = nla_len(attr);\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_CLONE);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\t/* Skipping the OVS_CLONE_ATTR_EXEC that is always the first attribute. */\n\tattr = nla_next(nla_data(attr), &rem);\n\terr = ovs_nla_put_actions(attr, rem, skb);\n\n\tif (err)\n\t\tnla_nest_cancel(skb, start);\n\telse\n\t\tnla_nest_end(skb, start);\n\n\treturn err;\n}\n\nstatic int check_pkt_len_action_to_attr(const struct nlattr *attr,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nlattr *start, *ac_start = NULL;\n\tconst struct check_pkt_len_arg *arg;\n\tconst struct nlattr *a, *cpl_arg;\n\tint err = 0, rem = nla_len(attr);\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_CHECK_PKT_LEN);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\t/* The first nested attribute in 'attr' is always\n\t * 'OVS_CHECK_PKT_LEN_ATTR_ARG'.\n\t */\n\tcpl_arg = nla_data(attr);\n\targ = nla_data(cpl_arg);\n\n\tif (nla_put_u16(skb, OVS_CHECK_PKT_LEN_ATTR_PKT_LEN, arg->pkt_len)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* Second nested attribute in 'attr' is always\n\t * 'OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL'.\n\t */\n\ta = nla_next(cpl_arg, &rem);\n\tac_start =  nla_nest_start_noflag(skb,\n\t\t\t\t\t  OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL);\n\tif (!ac_start) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, ac_start);\n\t\tgoto out;\n\t} else {\n\t\tnla_nest_end(skb, ac_start);\n\t}\n\n\t/* Third nested attribute in 'attr' is always\n\t * OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER.\n\t */\n\ta = nla_next(a, &rem);\n\tac_start =  nla_nest_start_noflag(skb,\n\t\t\t\t\t  OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER);\n\tif (!ac_start) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\terr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, ac_start);\n\t\tgoto out;\n\t} else {\n\t\tnla_nest_end(skb, ac_start);\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n\nout:\n\tnla_nest_cancel(skb, start);\n\treturn err;\n}\n\nstatic int dec_ttl_action_to_attr(const struct nlattr *attr,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct nlattr *start, *action_start;\n\tconst struct nlattr *a;\n\tint err = 0, rem;\n\n\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_DEC_TTL);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\tnla_for_each_attr(a, nla_data(attr), nla_len(attr), rem) {\n\t\tswitch (nla_type(a)) {\n\t\tcase OVS_DEC_TTL_ATTR_ACTION:\n\n\t\t\taction_start = nla_nest_start_noflag(skb, OVS_DEC_TTL_ATTR_ACTION);\n\t\t\tif (!action_start) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnla_nest_end(skb, action_start);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Ignore all other option to be future compatible */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnla_nest_end(skb, start);\n\treturn 0;\n\nout:\n\tnla_nest_cancel(skb, start);\n\treturn err;\n}\n\nstatic int set_action_to_attr(const struct nlattr *a, struct sk_buff *skb)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tint key_type = nla_type(ovs_key);\n\tstruct nlattr *start;\n\tint err;\n\n\tswitch (key_type) {\n\tcase OVS_KEY_ATTR_TUNNEL_INFO: {\n\t\tstruct ovs_tunnel_info *ovs_tun = nla_data(ovs_key);\n\t\tstruct ip_tunnel_info *tun_info = &ovs_tun->tun_dst->u.tun_info;\n\n\t\tstart = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_SET);\n\t\tif (!start)\n\t\t\treturn -EMSGSIZE;\n\n\t\terr =  ip_tun_to_nlattr(skb, &tun_info->key,\n\t\t\t\t\tip_tunnel_info_opts(tun_info),\n\t\t\t\t\ttun_info->options_len,\n\t\t\t\t\tip_tunnel_info_af(tun_info), tun_info->mode);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnla_nest_end(skb, start);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a), ovs_key))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int masked_set_action_to_set_action_attr(const struct nlattr *a,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst struct nlattr *ovs_key = nla_data(a);\n\tstruct nlattr *nla;\n\tsize_t key_len = nla_len(ovs_key) / 2;\n\n\t/* Revert the conversion we did from a non-masked set action to\n\t * masked set action.\n\t */\n\tnla = nla_nest_start_noflag(skb, OVS_ACTION_ATTR_SET);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put(skb, nla_type(ovs_key), key_len, nla_data(ovs_key)))\n\t\treturn -EMSGSIZE;\n\n\tnla_nest_end(skb, nla);\n\treturn 0;\n}\n\nint ovs_nla_put_actions(const struct nlattr *attr, int len, struct sk_buff *skb)\n{\n\tconst struct nlattr *a;\n\tint rem, err;\n\n\tnla_for_each_attr(a, attr, len, rem) {\n\t\tint type = nla_type(a);\n\n\t\tswitch (type) {\n\t\tcase OVS_ACTION_ATTR_SET:\n\t\t\terr = set_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SET_TO_MASKED:\n\t\t\terr = masked_set_action_to_set_action_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_SAMPLE:\n\t\t\terr = sample_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CT:\n\t\t\terr = ovs_ct_action_to_attr(nla_data(a), skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CLONE:\n\t\t\terr = clone_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_CHECK_PKT_LEN:\n\t\t\terr = check_pkt_len_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase OVS_ACTION_ATTR_DEC_TTL:\n\t\t\terr = dec_ttl_action_to_attr(a, skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (nla_put(skb, type, nla_len(a), nla_data(a)))\n\t\t\t\treturn -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "filenames": ["net/openvswitch/flow_netlink.c"], "buggy_code_start_loc": [2468], "buggy_code_end_loc": [2469], "fixing_code_start_loc": [2468], "fixing_code_end_loc": [2469], "type": "CWE-191", "message": "An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system.", "other": {"cve": {"id": "CVE-2022-2639", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-01T21:15:09.600", "lastModified": "2023-01-20T13:05:07.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system."}, {"lang": "es", "value": "Se ha encontrado un error de coerci\u00f3n de enteros en el m\u00f3dulo del kernel openvswitch. Dado un n\u00famero suficientemente grande de acciones, mientras ses copiado y es reservada memoria para una nueva acci\u00f3n de un nuevo flujo, la funci\u00f3n reserve_sfa_size() no devuelve -EMSGSIZE como es esperado, conllevando potencialmente a un acceso de escritura fuera de l\u00edmites. Este fallo permite a un usuario local bloquearse o potencialmente escalar sus privilegios en el sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-192"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.18.139", "versionEndExcluding": "3.19", "matchCriteriaId": "00ECE319-2D3D-436D-9AE0-E83440DA1972"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4.179", "versionEndExcluding": "4.5", "matchCriteriaId": "93408D6A-A152-414B-9F27-4CF1E0D3C9A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9.169", "versionEndExcluding": "4.9.312", "matchCriteriaId": "048C90D6-63DC-47D5-A9F7-9FED6D0A06DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14.112", "versionEndExcluding": "4.14.277", "matchCriteriaId": "C27466CC-35AC-465C-9EEC-5F451E1B38A2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19.35", "versionEndExcluding": "4.19.240", "matchCriteriaId": "567BAF59-C306-43ED-9997-EA973F2B811A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.8", "versionEndExcluding": "5.4.191", "matchCriteriaId": "550A7DCC-5944-4B55-8AAA-F4E53AC1F825"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.113", "matchCriteriaId": "3AE702C9-4FF9-4ADB-A885-74A6BAB430C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.11", "versionEndExcluding": "5.15.36", "matchCriteriaId": "8F146BAE-AA87-4430-8438-C3554714F30E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.16", "versionEndExcluding": "5.17.5", "matchCriteriaId": "31F42CF8-1960-440A-951C-1851EBFDC481"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2084479", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/cefa91b2332d7009bc0be5d951d6cbbf349f90f8", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cefa91b2332d7009bc0be5d951d6cbbf349f90f8"}}