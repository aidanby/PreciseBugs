{"buggy_code": ["package Apache::Session::Browseable::Store::LDAP;\n\nuse strict;\nuse Net::LDAP;\n\nour $VERSION = '1.2.2';\n\nsub new {\n    my $class = shift;\n    return bless {}, $class;\n}\n\nsub insert {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    my $index =\n      ref( $session->{args}->{Index} )\n      ? $session->{args}->{Index}\n      : [ split /\\s+/, $session->{args}->{Index} ];\n    my $id = $session->{data}->{_session_id};\n\n    my $attrIndex;\n    foreach my $i (@$index) {\n        my $t;\n        next unless ( $t = $session->{data}->{$i} );\n        push @$attrIndex, \"${i}_$t\";\n    }\n    my $attrs = [\n        objectClass                      => $self->{args}->{ldapObjectClass},\n        $self->{args}->{ldapAttributeId} => $session->{data}->{_session_id},\n        $self->{args}->{ldapAttributeContent} => $session->{serialized},\n    ];\n    push @$attrs, ( $self->{args}->{ldapAttributeIndex} => $attrIndex )\n      if ($attrIndex);\n\n    my $msg = $self->ldap->add(\n        $self->{args}->{ldapAttributeId} . \"=$id,\"\n          . $self->{args}->{ldapConfBase},\n        attrs => $attrs,\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub update {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    my $index =\n      ref( $session->{args}->{Index} )\n      ? $session->{args}->{Index}\n      : [ split /\\s+/, $session->{args}->{Index} ];\n    my $id = $session->{data}->{_session_id};\n\n    my $attrIndex;\n    foreach my $i (@$index) {\n        my $t;\n        next unless ( $t = $session->{data}->{$i} );\n        push @$attrIndex, \"${i}_$t\";\n    }\n\n    my $attrs =\n      { $self->{args}->{ldapAttributeContent} => $session->{serialized} };\n    $attrs->{ $self->{args}->{ldapAttributeIndex} } = $attrIndex\n      if ($attrIndex);\n\n    my $msg = $self->ldap->modify(\n        $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        replace => $attrs,\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub materialize {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    my $msg = $self->ldap->search(\n        base => $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        filter => '(objectClass=' . $self->{args}->{ldapObjectClass} . ')',\n        scope  => 'base',\n        attrs  => [ $self->{args}->{ldapAttributeContent} ],\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n\n    eval {\n        $session->{serialized} = $msg->shift_entry()\n          ->get_value( $self->{args}->{ldapAttributeContent} );\n    };\n\n    if ( !defined $session->{serialized} ) {\n        die \"Object does not exist in data store\";\n    }\n}\n\nsub remove {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    $self->ldap->delete( $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase} );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n}\n\nsub ldap {\n    my $self = shift;\n    return $self->{ldap} if ( $self->{ldap} );\n\n    # Parse servers configuration\n    my $useTls = 0;\n    my $tlsParam;\n    my @servers = ();\n    foreach my $server ( split /[\\s,]+/, $self->{args}->{ldapServer} ) {\n        if ( $server =~ m{^ldap\\+tls://([^/]+)/?\\??(.*)$} ) {\n            $useTls   = 1;\n            $server   = $1;\n            $tlsParam = $2 || \"\";\n        }\n        else {\n            $useTls = 0;\n        }\n        push @servers, $server;\n    }\n\n    # Connect\n    my $ldap = Net::LDAP->new(\n        \\@servers,\n        onerror => undef,\n        (\n            $self->{args}->{ldapRaw} ? ( raw => $self->{args}->{ldapRaw} )\n            : ()\n        ),\n        (\n            $self->{args}->{ldapPort} ? ( port => $self->{args}->{ldapPort} )\n            : ()\n        ),\n    ) or die( 'Unable to connect to ' . join( ' ', @servers ) );\n\n    # Start TLS if needed\n    if ($useTls) {\n        my %h = split( /[&=]/, $tlsParam );\n        $h{cafile} = $self->{args}->{caFile} if ( $self->{args}->{caFile} );\n        $h{capath} = $self->{args}->{caPath} if ( $self->{args}->{caPath} );\n        my $start_tls = $ldap->start_tls(%h);\n        if ( $start_tls->code ) {\n            $self->logError($start_tls);\n            return;\n        }\n    }\n\n    # Bind with credentials\n    my $bind = $ldap->bind( $self->{args}->{ldapBindDN},\n        password => $self->{args}->{ldapBindPassword} );\n    if ( $bind->code ) {\n        $self->logError($bind);\n        return;\n    }\n\n    $self->{ldap} = $ldap;\n    return $ldap;\n}\n\nsub logError {\n    my $self           = shift;\n    my $ldap_operation = shift;\n    die \"LDAP error \" . $ldap_operation->code . \": \" . $ldap_operation->error;\n}\n\n1;\n\n=pod\n\n=head1 NAME\n\nApache::Session::Browseable::Store::LDAP - Use LDAP to store persistent objects\n\n=head1 SYNOPSIS\n\n use Apache::Session::Browseable::Store::LDAP;\n\n my $store = new Apache::Session::Browseable::Store::LDAP;\n\n $store->insert($ref);\n $store->update($ref);\n $store->materialize($ref);\n $store->remove($ref);\n\n=head1 DESCRIPTION\n\nThis module fulfills the storage interface of Apache::Session.  The serialized\nobjects are stored in an LDAP directory file using the Net::LDAP Perl module.\n\n=head1 OPTIONS\n\nThis module requires one argument in the usual Apache::Session style. The\nkeys ldapServer, ldapBase, ldapBindDN, ldapBindPassword are required. The key\nldapPort, ldapObjectClass, ldapAttributeId, ldapAttributeContent,\nldapAttributeIndex, and ldapRaw are optional.\nExample:\n\n tie %s, 'Apache::Session::Browseable::LDAP', undef,\n    {\n        ldapServer           => 'localhost',\n        ldapBase             => 'dc=example,dc=com',\n        ldapBindDN           => 'cn=admin,dc=example,dc=com',\n        ldapBindPassword     => 'pass',\n        Index                => 'uid ipAddr',\n        ldapObjectClass      => 'applicationProcess',\n        ldapAttributeId      => 'cn',\n        ldapAttributeContent => 'description',\n        ldapAttributeIndex   => 'ou',\n        ldapRaw              => '(?i:^jpegPhoto|;binary)',\n    };\n\n=head1 AUTHOR\n\nXavier Guimard, E<lt>guimard@E<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2010-2017 by Xavier Guimard\nCopyright (C) 2015-2017 by Clement Oudot\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\n=head1 SEE ALSO\n\nL<Apache::Session>\n\n=cut\n"], "fixing_code": ["package Apache::Session::Browseable::Store::LDAP;\n\nuse strict;\nuse Net::LDAP;\n\nour $VERSION = '1.2.2';\n\nsub new {\n    my $class = shift;\n    return bless {}, $class;\n}\n\nsub insert {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    my $index =\n      ref( $session->{args}->{Index} )\n      ? $session->{args}->{Index}\n      : [ split /\\s+/, $session->{args}->{Index} ];\n    my $id = $session->{data}->{_session_id};\n\n    my $attrIndex;\n    foreach my $i (@$index) {\n        my $t;\n        next unless ( $t = $session->{data}->{$i} );\n        push @$attrIndex, \"${i}_$t\";\n    }\n    my $attrs = [\n        objectClass                      => $self->{args}->{ldapObjectClass},\n        $self->{args}->{ldapAttributeId} => $session->{data}->{_session_id},\n        $self->{args}->{ldapAttributeContent} => $session->{serialized},\n    ];\n    push @$attrs, ( $self->{args}->{ldapAttributeIndex} => $attrIndex )\n      if ($attrIndex);\n\n    my $msg = $self->ldap->add(\n        $self->{args}->{ldapAttributeId} . \"=$id,\"\n          . $self->{args}->{ldapConfBase},\n        attrs => $attrs,\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub update {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    my $index =\n      ref( $session->{args}->{Index} )\n      ? $session->{args}->{Index}\n      : [ split /\\s+/, $session->{args}->{Index} ];\n    my $id = $session->{data}->{_session_id};\n\n    my $attrIndex;\n    foreach my $i (@$index) {\n        my $t;\n        next unless ( $t = $session->{data}->{$i} );\n        push @$attrIndex, \"${i}_$t\";\n    }\n\n    my $attrs =\n      { $self->{args}->{ldapAttributeContent} => $session->{serialized} };\n    $attrs->{ $self->{args}->{ldapAttributeIndex} } = $attrIndex\n      if ($attrIndex);\n\n    my $msg = $self->ldap->modify(\n        $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        replace => $attrs,\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n}\n\nsub materialize {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    my $msg = $self->ldap->search(\n        base => $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase},\n        filter => '(objectClass=' . $self->{args}->{ldapObjectClass} . ')',\n        scope  => 'base',\n        attrs  => [ $self->{args}->{ldapAttributeContent} ],\n    );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n    $self->logError($msg) if ( $msg->code );\n\n    eval {\n        $session->{serialized} = $msg->shift_entry()\n          ->get_value( $self->{args}->{ldapAttributeContent} );\n    };\n\n    if ( !defined $session->{serialized} ) {\n        die \"Object does not exist in data store\";\n    }\n}\n\nsub remove {\n    my $self    = shift;\n    my $session = shift;\n    $self->{args} = $session->{args};\n    $self->{args}->{ldapObjectClass}      ||= 'applicationProcess';\n    $self->{args}->{ldapAttributeId}      ||= 'cn';\n    $self->{args}->{ldapAttributeContent} ||= 'description';\n    $self->{args}->{ldapAttributeIndex}   ||= 'ou';\n\n    $self->ldap->delete( $self->{args}->{ldapAttributeId} . \"=\"\n          . $session->{data}->{_session_id} . \",\"\n          . $self->{args}->{ldapConfBase} );\n\n    $self->ldap->unbind() && delete $self->{ldap};\n}\n\nsub ldap {\n    my $self = shift;\n    return $self->{ldap} if ( $self->{ldap} );\n\n    # Parse servers configuration\n    my $useTls = 0;\n    my $tlsParam;\n    my @servers = ();\n    foreach my $server ( split /[\\s,]+/, $self->{args}->{ldapServer} ) {\n        if ( $server =~ m{^ldap\\+tls://([^/]+)/?\\??(.*)$} ) {\n            $useTls   = 1;\n            $server   = $1;\n            $tlsParam = $2 || \"\";\n        }\n        else {\n            $useTls = 0;\n        }\n        push @servers, $server;\n    }\n\n    # Compatibility\n    my $caFile = $self->{args}->{ldapCAFile} || $self->{args}->{caFile};\n    my $caPath = $self->{args}->{ldapCAPath} || $self->{args}->{caPath};\n\n    # Connect\n    my $ldap = Net::LDAP->new(\n        \\@servers,\n        onerror => undef,\n        verify => $self->{args}->{ldapVerify} || \"require\",\n\t( $caFile ? ( cafile => $caFile ) : () ),\n\t( $caPath ? ( capath => $caPath ) : () ),\n\n        (\n            $self->{args}->{ldapRaw} ? ( raw => $self->{args}->{ldapRaw} )\n            : ()\n        ),\n        (\n            $self->{args}->{ldapPort} ? ( port => $self->{args}->{ldapPort} )\n            : ()\n        ),\n    ) or die( 'Unable to connect to ' . join( ' ', @servers ) );\n\n    # Start TLS if needed\n\n    if ($useTls) {\n        my %h = split( /[&=]/, $tlsParam );\n        $h{verify} = $self->{args}->{ldapVerify} || \"require\";\n        $h{cafile} = $caFile if ( $caFile );\n        $h{capath} = $caPath if ( $caPath );\n        my $start_tls = $ldap->start_tls(%h);\n        if ( $start_tls->code ) {\n            $self->logError($start_tls);\n            return;\n        }\n    }\n\n    # Bind with credentials\n    my $bind = $ldap->bind( $self->{args}->{ldapBindDN},\n        password => $self->{args}->{ldapBindPassword} );\n    if ( $bind->code ) {\n        $self->logError($bind);\n        return;\n    }\n\n    $self->{ldap} = $ldap;\n    return $ldap;\n}\n\nsub logError {\n    my $self           = shift;\n    my $ldap_operation = shift;\n    die \"LDAP error \" . $ldap_operation->code . \": \" . $ldap_operation->error;\n}\n\n1;\n\n=pod\n\n=head1 NAME\n\nApache::Session::Browseable::Store::LDAP - Use LDAP to store persistent objects\n\n=head1 SYNOPSIS\n\n use Apache::Session::Browseable::Store::LDAP;\n\n my $store = new Apache::Session::Browseable::Store::LDAP;\n\n $store->insert($ref);\n $store->update($ref);\n $store->materialize($ref);\n $store->remove($ref);\n\n=head1 DESCRIPTION\n\nThis module fulfills the storage interface of Apache::Session.  The serialized\nobjects are stored in an LDAP directory file using the Net::LDAP Perl module.\n\n=head1 OPTIONS\n\nThis module requires one argument in the usual Apache::Session style. The\nkeys ldapServer, ldapBase, ldapBindDN, ldapBindPassword are required. The key\nldapPort, ldapObjectClass, ldapAttributeId, ldapAttributeContent,\nldapAttributeIndex, and ldapRaw are optional.\nExample:\n\n tie %s, 'Apache::Session::Browseable::LDAP', undef,\n    {\n        ldapServer           => 'localhost',\n        ldapBase             => 'dc=example,dc=com',\n        ldapBindDN           => 'cn=admin,dc=example,dc=com',\n        ldapBindPassword     => 'pass',\n        Index                => 'uid ipAddr',\n        ldapObjectClass      => 'applicationProcess',\n        ldapAttributeId      => 'cn',\n        ldapAttributeContent => 'description',\n        ldapAttributeIndex   => 'ou',\n        ldapRaw              => '(?i:^jpegPhoto|;binary)',\n    };\n\n=head1 AUTHOR\n\nXavier Guimard, E<lt>guimard@E<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2010-2017 by Xavier Guimard\nCopyright (C) 2015-2017 by Clement Oudot\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\n=head1 SEE ALSO\n\nL<Apache::Session>\n\n=cut\n"], "filenames": ["lib/Apache/Session/Browseable/Store/LDAP.pm"], "buggy_code_start_loc": [156], "buggy_code_end_loc": [176], "fixing_code_start_loc": [157], "fixing_code_end_loc": [186], "type": "CWE-295", "message": "In Apache::Session::Browseable before 1.3.6, validity of the X.509 certificate is not checked by default when connecting to remote LDAP backends, because the default configuration of the Net::LDAPS module for Perl is used. NOTE: this can, for example, be fixed in conjunction with the CVE-2020-16093 fix.", "other": {"cve": {"id": "CVE-2020-36659", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-27T05:15:17.380", "lastModified": "2023-02-06T19:54:14.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Apache::Session::Browseable before 1.3.6, validity of the X.509 certificate is not checked by default when connecting to remote LDAP backends, because the default configuration of the Net::LDAPS module for Perl is used. NOTE: this can, for example, be fixed in conjunction with the CVE-2020-16093 fix."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lemonldap-ng:apache\\:\\:session\\:\\:browsable:*:*:*:*:*:perl:*:*", "versionEndExcluding": "1.3.6", "matchCriteriaId": "867DE619-B303-4A79-9060-0BBF0A01A899"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/LemonLDAPNG/Apache-Session-Browseable/commit/fdf393235140b293cae5578ef136055a78f3574f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LemonLDAPNG/Apache-Session-Browseable/commit/fdf393235140b293cae5578ef136055a78f3574f"}}