{"buggy_code": ["package auth.sso.oidc.custom;\n\nimport com.nimbusds.oauth2.sdk.AuthorizationGrant;\nimport com.nimbusds.oauth2.sdk.AuthorizationCode;\nimport com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;\nimport com.nimbusds.oauth2.sdk.ParseException;\nimport com.nimbusds.oauth2.sdk.TokenErrorResponse;\nimport com.nimbusds.oauth2.sdk.TokenRequest;\nimport com.nimbusds.oauth2.sdk.TokenResponse;\nimport com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\nimport com.nimbusds.oauth2.sdk.auth.ClientAuthenticationMethod;\nimport com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\nimport com.nimbusds.oauth2.sdk.auth.ClientSecretPost;\nimport com.nimbusds.oauth2.sdk.auth.Secret;\nimport com.nimbusds.oauth2.sdk.http.HTTPRequest;\nimport com.nimbusds.oauth2.sdk.http.HTTPResponse;\nimport com.nimbusds.oauth2.sdk.id.ClientID;\nimport com.nimbusds.openid.connect.sdk.OIDCTokenResponse;\nimport com.nimbusds.openid.connect.sdk.OIDCTokenResponseParser;\nimport com.nimbusds.openid.connect.sdk.token.OIDCTokens;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\nimport org.pac4j.core.context.WebContext;\nimport org.pac4j.core.credentials.authenticator.Authenticator;\nimport org.pac4j.core.exception.TechnicalException;\nimport org.pac4j.core.util.CommonHelper;\nimport org.pac4j.oidc.client.OidcClient;\nimport org.pac4j.oidc.config.OidcConfiguration;\nimport org.pac4j.oidc.credentials.OidcCredentials;\nimport org.pac4j.oidc.credentials.authenticator.OidcAuthenticator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\npublic class CustomOidcAuthenticator implements Authenticator<OidcCredentials> {\n\n  private static final Logger logger = LoggerFactory.getLogger(OidcAuthenticator.class);\n\n  private static final Collection<ClientAuthenticationMethod> SUPPORTED_METHODS =\n      Arrays.asList(\n          ClientAuthenticationMethod.CLIENT_SECRET_POST,\n          ClientAuthenticationMethod.CLIENT_SECRET_BASIC,\n          ClientAuthenticationMethod.NONE);\n\n  protected OidcConfiguration configuration;\n\n  protected OidcClient<OidcConfiguration> client;\n\n  private final ClientAuthentication clientAuthentication;\n\n  public CustomOidcAuthenticator(final OidcClient<OidcConfiguration> client) {\n    CommonHelper.assertNotNull(\"configuration\", client.getConfiguration());\n    CommonHelper.assertNotNull(\"client\", client);\n    this.configuration = client.getConfiguration();\n    this.client = client;\n\n    // check authentication methods\n    final List<ClientAuthenticationMethod> metadataMethods = configuration.findProviderMetadata().getTokenEndpointAuthMethods();\n\n    final ClientAuthenticationMethod preferredMethod = getPreferredAuthenticationMethod(configuration);\n\n    final ClientAuthenticationMethod chosenMethod;\n    if (CommonHelper.isNotEmpty(metadataMethods)) {\n      if (preferredMethod != null) {\n        if (ClientAuthenticationMethod.NONE.equals(preferredMethod) || metadataMethods.contains(preferredMethod)) {\n          chosenMethod = preferredMethod;\n        } else {\n          throw new TechnicalException(\n              \"Preferred authentication method (\"\n                  + preferredMethod\n                  + \") not supported \"\n                  + \"by provider according to provider metadata (\"\n                  + metadataMethods\n                  + \").\");\n        }\n      } else {\n        chosenMethod = firstSupportedMethod(metadataMethods);\n      }\n    } else {\n      chosenMethod = preferredMethod != null ? preferredMethod : ClientAuthenticationMethod.getDefault();\n      logger.info(\"Provider metadata does not provide Token endpoint authentication methods. Using: {}\",\n          chosenMethod);\n    }\n\n    final ClientID clientID = new ClientID(configuration.getClientId());\n    if (ClientAuthenticationMethod.CLIENT_SECRET_POST.equals(chosenMethod)) {\n      final Secret secret = new Secret(configuration.getSecret());\n      clientAuthentication = new ClientSecretPost(clientID, secret);\n    } else if (ClientAuthenticationMethod.CLIENT_SECRET_BASIC.equals(chosenMethod)) {\n      final Secret secret = new Secret(configuration.getSecret());\n      clientAuthentication = new ClientSecretBasic(clientID, secret);\n    } else if (ClientAuthenticationMethod.NONE.equals(chosenMethod)) {\n      clientAuthentication = null; // No client authentication in none mode\n    } else {\n      throw new TechnicalException(\"Unsupported client authentication method: \" + chosenMethod);\n    }\n  }\n\n  /**\n   * The preferred {@link ClientAuthenticationMethod} specified in the given\n   * {@link OidcConfiguration}, or <code>null</code> meaning that the a\n   * provider-supported method should be chosen.\n   */\n  private static ClientAuthenticationMethod getPreferredAuthenticationMethod(OidcConfiguration config) {\n    final ClientAuthenticationMethod configurationMethod = config.getClientAuthenticationMethod();\n    if (configurationMethod == null) {\n      return null;\n    }\n\n    if (!SUPPORTED_METHODS.contains(configurationMethod)) {\n      throw new TechnicalException(\"Configured authentication method (\" + configurationMethod + \") is not supported.\");\n    }\n\n    return configurationMethod;\n  }\n\n  /**\n   * The first {@link ClientAuthenticationMethod} from the given list of\n   * methods that is supported by this implementation.\n   *\n   * @throws TechnicalException\n   *         if none of the provider-supported methods is supported.\n   */\n  private static ClientAuthenticationMethod firstSupportedMethod(final List<ClientAuthenticationMethod> metadataMethods) {\n    Optional<ClientAuthenticationMethod> firstSupported =\n        metadataMethods.stream().filter((m) -> SUPPORTED_METHODS.contains(m)).findFirst();\n    if (firstSupported.isPresent()) {\n      return firstSupported.get();\n    } else {\n      throw new TechnicalException(\"None of the Token endpoint provider metadata authentication methods are supported: \"\n          +  metadataMethods);\n    }\n  }\n\n  @Override\n  public void validate(final OidcCredentials credentials, final WebContext context) {\n    final AuthorizationCode code = credentials.getCode();\n    // if we have a code\n    if (code != null) {\n      try {\n        final String computedCallbackUrl = client.computeFinalCallbackUrl(context);\n        // Token request\n        final TokenRequest request = createTokenRequest(new AuthorizationCodeGrant(code, new URI(computedCallbackUrl)));\n        HTTPRequest tokenHttpRequest = request.toHTTPRequest();\n        tokenHttpRequest.setConnectTimeout(configuration.getConnectTimeout());\n        tokenHttpRequest.setReadTimeout(configuration.getReadTimeout());\n\n        final HTTPResponse httpResponse = tokenHttpRequest.send();\n        logger.debug(\"Token response: status={}, content={}\", httpResponse.getStatusCode(),\n            httpResponse.getContent());\n\n        final TokenResponse response = OIDCTokenResponseParser.parse(httpResponse);\n        if (response instanceof TokenErrorResponse) {\n          throw new TechnicalException(\"Bad token response, error=\" + ((TokenErrorResponse) response).getErrorObject());\n        }\n        logger.debug(\"Token response successful\");\n        final OIDCTokenResponse tokenSuccessResponse = (OIDCTokenResponse) response;\n\n        // save tokens in credentials\n        final OIDCTokens oidcTokens = tokenSuccessResponse.getOIDCTokens();\n        credentials.setAccessToken(oidcTokens.getAccessToken());\n        credentials.setRefreshToken(oidcTokens.getRefreshToken());\n        credentials.setIdToken(oidcTokens.getIDToken());\n\n      } catch (final URISyntaxException | IOException | ParseException e) {\n        throw new TechnicalException(e);\n      }\n    }\n  }\n\n  private TokenRequest createTokenRequest(final AuthorizationGrant grant) {\n    if (clientAuthentication != null) {\n      return new TokenRequest(configuration.findProviderMetadata().getTokenEndpointURI(),\n          this.clientAuthentication, grant);\n    } else {\n      return new TokenRequest(configuration.findProviderMetadata().getTokenEndpointURI(),\n          new ClientID(configuration.getClientId()), grant);\n    }\n  }\n}\n"], "fixing_code": ["package auth.sso.oidc.custom;\n\nimport com.nimbusds.oauth2.sdk.AuthorizationGrant;\nimport com.nimbusds.oauth2.sdk.AuthorizationCode;\nimport com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;\nimport com.nimbusds.oauth2.sdk.ParseException;\nimport com.nimbusds.oauth2.sdk.TokenErrorResponse;\nimport com.nimbusds.oauth2.sdk.TokenRequest;\nimport com.nimbusds.oauth2.sdk.TokenResponse;\nimport com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\nimport com.nimbusds.oauth2.sdk.auth.ClientAuthenticationMethod;\nimport com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\nimport com.nimbusds.oauth2.sdk.auth.ClientSecretPost;\nimport com.nimbusds.oauth2.sdk.auth.Secret;\nimport com.nimbusds.oauth2.sdk.http.HTTPRequest;\nimport com.nimbusds.oauth2.sdk.http.HTTPResponse;\nimport com.nimbusds.oauth2.sdk.id.ClientID;\nimport com.nimbusds.oauth2.sdk.pkce.CodeVerifier;\nimport com.nimbusds.openid.connect.sdk.OIDCTokenResponse;\nimport com.nimbusds.openid.connect.sdk.OIDCTokenResponseParser;\nimport com.nimbusds.openid.connect.sdk.token.OIDCTokens;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Optional;\nimport org.pac4j.core.context.WebContext;\nimport org.pac4j.core.credentials.authenticator.Authenticator;\nimport org.pac4j.core.exception.TechnicalException;\nimport org.pac4j.core.util.CommonHelper;\nimport org.pac4j.oidc.client.OidcClient;\nimport org.pac4j.oidc.config.OidcConfiguration;\nimport org.pac4j.oidc.credentials.OidcCredentials;\nimport org.pac4j.oidc.credentials.authenticator.OidcAuthenticator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\npublic class CustomOidcAuthenticator implements Authenticator<OidcCredentials> {\n\n  private static final Logger logger = LoggerFactory.getLogger(OidcAuthenticator.class);\n\n  private static final Collection<ClientAuthenticationMethod> SUPPORTED_METHODS =\n      Arrays.asList(\n          ClientAuthenticationMethod.CLIENT_SECRET_POST,\n          ClientAuthenticationMethod.CLIENT_SECRET_BASIC,\n          ClientAuthenticationMethod.NONE);\n\n  protected OidcConfiguration configuration;\n\n  protected OidcClient<OidcConfiguration> client;\n\n  private final ClientAuthentication clientAuthentication;\n\n  public CustomOidcAuthenticator(final OidcClient<OidcConfiguration> client) {\n    CommonHelper.assertNotNull(\"configuration\", client.getConfiguration());\n    CommonHelper.assertNotNull(\"client\", client);\n    this.configuration = client.getConfiguration();\n    this.client = client;\n\n    // check authentication methods\n    final List<ClientAuthenticationMethod> metadataMethods = configuration.findProviderMetadata().getTokenEndpointAuthMethods();\n\n    final ClientAuthenticationMethod preferredMethod = getPreferredAuthenticationMethod(configuration);\n\n    final ClientAuthenticationMethod chosenMethod;\n    if (CommonHelper.isNotEmpty(metadataMethods)) {\n      if (preferredMethod != null) {\n        if (ClientAuthenticationMethod.NONE.equals(preferredMethod) || metadataMethods.contains(preferredMethod)) {\n          chosenMethod = preferredMethod;\n        } else {\n          throw new TechnicalException(\n              \"Preferred authentication method (\"\n                  + preferredMethod\n                  + \") not supported \"\n                  + \"by provider according to provider metadata (\"\n                  + metadataMethods\n                  + \").\");\n        }\n      } else {\n        chosenMethod = firstSupportedMethod(metadataMethods);\n      }\n    } else {\n      chosenMethod = preferredMethod != null ? preferredMethod : ClientAuthenticationMethod.getDefault();\n      logger.info(\"Provider metadata does not provide Token endpoint authentication methods. Using: {}\",\n          chosenMethod);\n    }\n\n    final ClientID clientID = new ClientID(configuration.getClientId());\n    if (ClientAuthenticationMethod.CLIENT_SECRET_POST.equals(chosenMethod)) {\n      final Secret secret = new Secret(configuration.getSecret());\n      clientAuthentication = new ClientSecretPost(clientID, secret);\n    } else if (ClientAuthenticationMethod.CLIENT_SECRET_BASIC.equals(chosenMethod)) {\n      final Secret secret = new Secret(configuration.getSecret());\n      clientAuthentication = new ClientSecretBasic(clientID, secret);\n    } else if (ClientAuthenticationMethod.NONE.equals(chosenMethod)) {\n      clientAuthentication = null; // No client authentication in none mode\n    } else {\n      throw new TechnicalException(\"Unsupported client authentication method: \" + chosenMethod);\n    }\n  }\n\n  /**\n   * The preferred {@link ClientAuthenticationMethod} specified in the given\n   * {@link OidcConfiguration}, or <code>null</code> meaning that the a\n   * provider-supported method should be chosen.\n   */\n  private static ClientAuthenticationMethod getPreferredAuthenticationMethod(OidcConfiguration config) {\n    final ClientAuthenticationMethod configurationMethod = config.getClientAuthenticationMethod();\n    if (configurationMethod == null) {\n      return null;\n    }\n\n    if (!SUPPORTED_METHODS.contains(configurationMethod)) {\n      throw new TechnicalException(\"Configured authentication method (\" + configurationMethod + \") is not supported.\");\n    }\n\n    return configurationMethod;\n  }\n\n  /**\n   * The first {@link ClientAuthenticationMethod} from the given list of\n   * methods that is supported by this implementation.\n   *\n   * @throws TechnicalException\n   *         if none of the provider-supported methods is supported.\n   */\n  private static ClientAuthenticationMethod firstSupportedMethod(final List<ClientAuthenticationMethod> metadataMethods) {\n    Optional<ClientAuthenticationMethod> firstSupported =\n        metadataMethods.stream().filter((m) -> SUPPORTED_METHODS.contains(m)).findFirst();\n    if (firstSupported.isPresent()) {\n      return firstSupported.get();\n    } else {\n      throw new TechnicalException(\"None of the Token endpoint provider metadata authentication methods are supported: \"\n          +  metadataMethods);\n    }\n  }\n\n  @Override\n  public void validate(final OidcCredentials credentials, final WebContext context) {\n    final AuthorizationCode code = credentials.getCode();\n    // if we have a code\n    if (code != null) {\n      try {\n        final String computedCallbackUrl = client.computeFinalCallbackUrl(context);\n        CodeVerifier verifier = (CodeVerifier) configuration.getValueRetriever()\n                .retrieve(client.getCodeVerifierSessionAttributeName(), client, context).orElse(null);\n        // Token request\n        final TokenRequest request = createTokenRequest(new AuthorizationCodeGrant(code, new URI(computedCallbackUrl), verifier));\n        HTTPRequest tokenHttpRequest = request.toHTTPRequest();\n        tokenHttpRequest.setConnectTimeout(configuration.getConnectTimeout());\n        tokenHttpRequest.setReadTimeout(configuration.getReadTimeout());\n\n        final HTTPResponse httpResponse = tokenHttpRequest.send();\n        logger.debug(\"Token response: status={}, content={}\", httpResponse.getStatusCode(),\n            httpResponse.getContent());\n\n        final TokenResponse response = OIDCTokenResponseParser.parse(httpResponse);\n        if (response instanceof TokenErrorResponse) {\n          throw new TechnicalException(\"Bad token response, error=\" + ((TokenErrorResponse) response).getErrorObject());\n        }\n        logger.debug(\"Token response successful\");\n        final OIDCTokenResponse tokenSuccessResponse = (OIDCTokenResponse) response;\n\n        // save tokens in credentials\n        final OIDCTokens oidcTokens = tokenSuccessResponse.getOIDCTokens();\n        credentials.setAccessToken(oidcTokens.getAccessToken());\n        credentials.setRefreshToken(oidcTokens.getRefreshToken());\n        credentials.setIdToken(oidcTokens.getIDToken());\n\n      } catch (final URISyntaxException | IOException | ParseException e) {\n        throw new TechnicalException(e);\n      }\n    }\n  }\n\n  private TokenRequest createTokenRequest(final AuthorizationGrant grant) {\n    if (clientAuthentication != null) {\n      return new TokenRequest(configuration.findProviderMetadata().getTokenEndpointURI(),\n          this.clientAuthentication, grant);\n    } else {\n      return new TokenRequest(configuration.findProviderMetadata().getTokenEndpointURI(),\n          new ClientID(configuration.getClientId()), grant);\n    }\n  }\n}\n"], "filenames": ["datahub-frontend/app/auth/sso/oidc/custom/CustomOidcAuthenticator.java"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [149], "fixing_code_start_loc": [18], "fixing_code_end_loc": [152], "type": "CWE-502", "message": "DataHub is an open-source metadata platform. When the DataHub frontend is configured to authenticate via SSO, it will leverage the pac4j library. The processing of the `id_token` is done in an unsafe manner which is not properly accounted for by the DataHub frontend. Specifically, if any of the id_token claims value start with the {#sb64} prefix, pac4j considers the value to be a serialized Java object and will deserialize it. This issue may lead to Remote Code Execution (RCE) in the worst case. Although a `RestrictedObjectInputStream` is in place, that puts some restriction on what classes can be deserialized, it still allows a broad range of java packages and potentially exploitable with different gadget chains. Users are advised to upgrade. There are no known workarounds. This vulnerability was discovered and reported by the GitHub Security lab and is tracked as GHSL-2022-086.", "other": {"cve": {"id": "CVE-2023-25558", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-11T01:23:26.437", "lastModified": "2023-02-21T19:56:04.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DataHub is an open-source metadata platform. When the DataHub frontend is configured to authenticate via SSO, it will leverage the pac4j library. The processing of the `id_token` is done in an unsafe manner which is not properly accounted for by the DataHub frontend. Specifically, if any of the id_token claims value start with the {#sb64} prefix, pac4j considers the value to be a serialized Java object and will deserialize it. This issue may lead to Remote Code Execution (RCE) in the worst case. Although a `RestrictedObjectInputStream` is in place, that puts some restriction on what classes can be deserialized, it still allows a broad range of java packages and potentially exploitable with different gadget chains. Users are advised to upgrade. There are no known workarounds. This vulnerability was discovered and reported by the GitHub Security lab and is tracked as GHSL-2022-086."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:datahub_project:datahub:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.5", "matchCriteriaId": "2708E599-3544-42CD-9C8F-77505D536A47"}]}]}], "references": [{"url": "https://github.com/datahub-project/datahub/commit/2a182f484677d056730d6b4e9f0143e67368359f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/datahub-project/datahub/security/advisories/GHSA-hrwp-2q5c-86wv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/datahub-project/datahub/commit/2a182f484677d056730d6b4e9f0143e67368359f"}}