{"buggy_code": ["/*\n * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"event2/event-config.h\"\n#include \"evconfig-private.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#undef WIN32_LEAN_AND_MEAN\n#include <io.h>\n#include <tchar.h>\n#include <process.h>\n#undef _WIN32_WINNT\n/* For structs needed by GetAdaptersAddresses */\n#define _WIN32_WINNT 0x0501\n#include <iphlpapi.h>\n#endif\n\n#include <sys/types.h>\n#ifdef EVENT__HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef EVENT__HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef EVENT__HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef EVENT__HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#ifdef EVENT__HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef EVENT__HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n#ifdef EVENT__HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>\n#endif\n#ifdef EVENT__HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#include <time.h>\n#include <sys/stat.h>\n#ifdef EVENT__HAVE_IFADDRS_H\n#include <ifaddrs.h>\n#endif\n\n#include \"event2/util.h\"\n#include \"util-internal.h\"\n#include \"log-internal.h\"\n#include \"mm-internal.h\"\n#include \"evthread-internal.h\"\n\n#include \"strlcpy-internal.h\"\n#include \"ipv6-internal.h\"\n\n#ifdef _WIN32\n#define HT_NO_CACHE_HASH_VALUES\n#include \"ht-internal.h\"\n#define open _open\n#define read _read\n#define close _close\n#ifndef fstat\n#define fstat _fstati64\n#endif\n#ifndef stat\n#define stat _stati64\n#endif\n#define mode_t int\n#endif\n\nint\nevutil_open_closeonexec_(const char *pathname, int flags, unsigned mode)\n{\n\tint fd;\n\n#ifdef O_CLOEXEC\n\tfd = open(pathname, flags|O_CLOEXEC, (mode_t)mode);\n\tif (fd >= 0 || errno == EINVAL)\n\t\treturn fd;\n\t/* If we got an EINVAL, fall through and try without O_CLOEXEC */\n#endif\n\tfd = open(pathname, flags, (mode_t)mode);\n\tif (fd < 0)\n\t\treturn -1;\n\n#if defined(FD_CLOEXEC)\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\treturn fd;\n}\n\n/**\n   Read the contents of 'filename' into a newly allocated NUL-terminated\n   string.  Set *content_out to hold this string, and *len_out to hold its\n   length (not including the appended NUL).  If 'is_binary', open the file in\n   binary mode.\n\n   Returns 0 on success, -1 if the open fails, and -2 for all other failures.\n\n   Used internally only; may go away in a future version.\n */\nint\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)\n{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}\n\nint\nevutil_socketpair(int family, int type, int protocol, evutil_socket_t fd[2])\n{\n#ifndef _WIN32\n\treturn socketpair(family, type, protocol, fd);\n#else\n\treturn evutil_ersatz_socketpair_(family, type, protocol, fd);\n#endif\n}\n\nint\nevutil_ersatz_socketpair_(int family, int type, int protocol,\n    evutil_socket_t fd[2])\n{\n\t/* This code is originally from Tor.  Used with permission. */\n\n\t/* This socketpair does not work when localhost is down. So\n\t * it's really not the same thing at all. But it's close enough\n\t * for now, and really, when localhost is down sometimes, we\n\t * have other problems too.\n\t */\n#ifdef _WIN32\n#define ERR(e) WSA##e\n#else\n#define ERR(e) e\n#endif\n\tevutil_socket_t listener = -1;\n\tevutil_socket_t connector = -1;\n\tevutil_socket_t acceptor = -1;\n\tstruct sockaddr_in listen_addr;\n\tstruct sockaddr_in connect_addr;\n\tev_socklen_t size;\n\tint saved_errno = -1;\n\tint family_test;\n\t\n\tfamily_test = family != AF_INET;\n#ifdef AF_UNIX\n\tfamily_test = family_test && (family != AF_UNIX);\n#endif\n\tif (protocol || family_test) {\n\t\tEVUTIL_SET_SOCKET_ERROR(ERR(EAFNOSUPPORT));\n\t\treturn -1;\n\t}\n\t\n\tif (!fd) {\n\t\tEVUTIL_SET_SOCKET_ERROR(ERR(EINVAL));\n\t\treturn -1;\n\t}\n\n\tlistener = socket(AF_INET, type, 0);\n\tif (listener < 0)\n\t\treturn -1;\n\tmemset(&listen_addr, 0, sizeof(listen_addr));\n\tlisten_addr.sin_family = AF_INET;\n\tlisten_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tlisten_addr.sin_port = 0;\t/* kernel chooses port.\t */\n\tif (bind(listener, (struct sockaddr *) &listen_addr, sizeof (listen_addr))\n\t\t== -1)\n\t\tgoto tidy_up_and_fail;\n\tif (listen(listener, 1) == -1)\n\t\tgoto tidy_up_and_fail;\n\n\tconnector = socket(AF_INET, type, 0);\n\tif (connector < 0)\n\t\tgoto tidy_up_and_fail;\n\n\tmemset(&connect_addr, 0, sizeof(connect_addr));\n\n\t/* We want to find out the port number to connect to.  */\n\tsize = sizeof(connect_addr);\n\tif (getsockname(listener, (struct sockaddr *) &connect_addr, &size) == -1)\n\t\tgoto tidy_up_and_fail;\n\tif (size != sizeof (connect_addr))\n\t\tgoto abort_tidy_up_and_fail;\n\tif (connect(connector, (struct sockaddr *) &connect_addr,\n\t\t\t\tsizeof(connect_addr)) == -1)\n\t\tgoto tidy_up_and_fail;\n\n\tsize = sizeof(listen_addr);\n\tacceptor = accept(listener, (struct sockaddr *) &listen_addr, &size);\n\tif (acceptor < 0)\n\t\tgoto tidy_up_and_fail;\n\tif (size != sizeof(listen_addr))\n\t\tgoto abort_tidy_up_and_fail;\n\t/* Now check we are talking to ourself by matching port and host on the\n\t   two sockets.\t */\n\tif (getsockname(connector, (struct sockaddr *) &connect_addr, &size) == -1)\n\t\tgoto tidy_up_and_fail;\n\tif (size != sizeof (connect_addr)\n\t\t|| listen_addr.sin_family != connect_addr.sin_family\n\t\t|| listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr\n\t\t|| listen_addr.sin_port != connect_addr.sin_port)\n\t\tgoto abort_tidy_up_and_fail;\n\tevutil_closesocket(listener);\n\tfd[0] = connector;\n\tfd[1] = acceptor;\n\n\treturn 0;\n\n abort_tidy_up_and_fail:\n\tsaved_errno = ERR(ECONNABORTED);\n tidy_up_and_fail:\n\tif (saved_errno < 0)\n\t\tsaved_errno = EVUTIL_SOCKET_ERROR();\n\tif (listener != -1)\n\t\tevutil_closesocket(listener);\n\tif (connector != -1)\n\t\tevutil_closesocket(connector);\n\tif (acceptor != -1)\n\t\tevutil_closesocket(acceptor);\n\n\tEVUTIL_SET_SOCKET_ERROR(saved_errno);\n\treturn -1;\n#undef ERR\n}\n\nint\nevutil_make_socket_nonblocking(evutil_socket_t fd)\n{\n#ifdef _WIN32\n\t{\n\t\tunsigned long nonblocking = 1;\n\t\tif (ioctlsocket(fd, FIONBIO, &nonblocking) == SOCKET_ERROR) {\n\t\t\tevent_sock_warn(fd, \"fcntl(%d, F_GETFL)\", (int)fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n#else\n\t{\n\t\tint flags;\n\t\tif ((flags = fcntl(fd, F_GETFL, NULL)) < 0) {\n\t\t\tevent_warn(\"fcntl(%d, F_GETFL)\", fd);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(flags & O_NONBLOCK)) {\n\t\t\tif (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n\t\t\t\tevent_warn(\"fcntl(%d, F_SETFL)\", fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n/* Faster version of evutil_make_socket_nonblocking for internal use.\n *\n * Requires that no F_SETFL flags were previously set on the fd.\n */\nstatic int\nevutil_fast_socket_nonblocking(evutil_socket_t fd)\n{\n#ifdef _WIN32\n\treturn evutil_make_socket_nonblocking(fd);\n#else\n\tif (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {\n\t\tevent_warn(\"fcntl(%d, F_SETFL)\", fd);\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}\n\nint\nevutil_make_listen_socket_reuseable(evutil_socket_t sock)\n{\n#if defined(SO_REUSEADDR) && !defined(_WIN32)\n\tint one = 1;\n\t/* REUSEADDR on Unix means, \"don't hang on to this address after the\n\t * listener is closed.\"  On Windows, though, it means \"don't keep other\n\t * processes from binding to this address while we're using it. */\n\treturn setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*) &one,\n\t    (ev_socklen_t)sizeof(one));\n#else\n\treturn 0;\n#endif\n}\n\nint\nevutil_make_listen_socket_reuseable_port(evutil_socket_t sock)\n{\n#if defined __linux__ && defined(SO_REUSEPORT)\n\tint one = 1;\n\t/* REUSEPORT on Linux 3.9+ means, \"Multiple servers (processes or\n\t * threads) can bind to the same port if they each set the option. */\n\treturn setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, (void*) &one,\n\t    (ev_socklen_t)sizeof(one));\n#else\n\treturn 0;\n#endif\n}\n\nint\nevutil_make_tcp_listen_socket_deferred(evutil_socket_t sock)\n{\n#if defined(EVENT__HAVE_NETINET_TCP_H) && defined(TCP_DEFER_ACCEPT)\n\tint one = 1;\n\n\t/* TCP_DEFER_ACCEPT tells the kernel to call defer accept() only after data\n\t * has arrived and ready to read */ \n\treturn setsockopt(sock, IPPROTO_TCP, TCP_DEFER_ACCEPT, &one,\n\t\t(ev_socklen_t)sizeof(one)); \n#endif\n\treturn 0;\n}\n\nint\nevutil_make_socket_closeonexec(evutil_socket_t fd)\n{\n#if !defined(_WIN32) && defined(EVENT__HAVE_SETFD)\n\tint flags;\n\tif ((flags = fcntl(fd, F_GETFD, NULL)) < 0) {\n\t\tevent_warn(\"fcntl(%d, F_GETFD)\", fd);\n\t\treturn -1;\n\t}\n\tif (!(flags & FD_CLOEXEC)) {\n\t\tif (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1) {\n\t\t\tevent_warn(\"fcntl(%d, F_SETFD)\", fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n/* Faster version of evutil_make_socket_closeonexec for internal use.\n *\n * Requires that no F_SETFD flags were previously set on the fd.\n */\nstatic int\nevutil_fast_socket_closeonexec(evutil_socket_t fd)\n{\n#if !defined(_WIN32) && defined(EVENT__HAVE_SETFD)\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {\n\t\tevent_warn(\"fcntl(%d, F_SETFD)\", fd);\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}\n\nint\nevutil_closesocket(evutil_socket_t sock)\n{\n#ifndef _WIN32\n\treturn close(sock);\n#else\n\treturn closesocket(sock);\n#endif\n}\n\nev_int64_t\nevutil_strtoll(const char *s, char **endptr, int base)\n{\n#ifdef EVENT__HAVE_STRTOLL\n\treturn (ev_int64_t)strtoll(s, endptr, base);\n#elif EVENT__SIZEOF_LONG == 8\n\treturn (ev_int64_t)strtol(s, endptr, base);\n#elif defined(_WIN32) && defined(_MSC_VER) && _MSC_VER < 1300\n\t/* XXXX on old versions of MS APIs, we only support base\n\t * 10. */\n\tev_int64_t r;\n\tif (base != 10)\n\t\treturn 0;\n\tr = (ev_int64_t) _atoi64(s);\n\twhile (isspace(*s))\n\t\t++s;\n\tif (*s == '-')\n\t\t++s;\n\twhile (isdigit(*s))\n\t\t++s;\n\tif (endptr)\n\t\t*endptr = (char*) s;\n\treturn r;\n#elif defined(_WIN32)\n\treturn (ev_int64_t) _strtoi64(s, endptr, base);\n#elif defined(EVENT__SIZEOF_LONG_LONG) && EVENT__SIZEOF_LONG_LONG == 8\n\tlong long r;\n\tint n;\n\tif (base != 10 && base != 16)\n\t\treturn 0;\n\tif (base == 10) {\n\t\tn = sscanf(s, \"%lld\", &r);\n\t} else {\n\t\tunsigned long long ru=0;\n\t\tn = sscanf(s, \"%llx\", &ru);\n\t\tif (ru > EV_INT64_MAX)\n\t\t\treturn 0;\n\t\tr = (long long) ru;\n\t}\n\tif (n != 1)\n\t\treturn 0;\n\twhile (EVUTIL_ISSPACE_(*s))\n\t\t++s;\n\tif (*s == '-')\n\t\t++s;\n\tif (base == 10) {\n\t\twhile (EVUTIL_ISDIGIT_(*s))\n\t\t\t++s;\n\t} else {\n\t\twhile (EVUTIL_ISXDIGIT_(*s))\n\t\t\t++s;\n\t}\n\tif (endptr)\n\t\t*endptr = (char*) s;\n\treturn r;\n#else\n#error \"I don't know how to parse 64-bit integers.\"\n#endif\n}\n\n#ifdef _WIN32\nint\nevutil_socket_geterror(evutil_socket_t sock)\n{\n\tint optval, optvallen=sizeof(optval);\n\tint err = WSAGetLastError();\n\tif (err == WSAEWOULDBLOCK && sock >= 0) {\n\t\tif (getsockopt(sock, SOL_SOCKET, SO_ERROR, (void*)&optval,\n\t\t\t\t\t   &optvallen))\n\t\t\treturn err;\n\t\tif (optval)\n\t\t\treturn optval;\n\t}\n\treturn err;\n}\n#endif\n\n/* XXX we should use an enum here. */\n/* 2 for connection refused, 1 for connected, 0 for not yet, -1 for error. */\nint\nevutil_socket_connect_(evutil_socket_t *fd_ptr, const struct sockaddr *sa, int socklen)\n{\n\tint made_fd = 0;\n\n\tif (*fd_ptr < 0) {\n\t\tif ((*fd_ptr = socket(sa->sa_family, SOCK_STREAM, 0)) < 0)\n\t\t\tgoto err;\n\t\tmade_fd = 1;\n\t\tif (evutil_make_socket_nonblocking(*fd_ptr) < 0) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (connect(*fd_ptr, sa, socklen) < 0) {\n\t\tint e = evutil_socket_geterror(*fd_ptr);\n\t\tif (EVUTIL_ERR_CONNECT_RETRIABLE(e))\n\t\t\treturn 0;\n\t\tif (EVUTIL_ERR_CONNECT_REFUSED(e))\n\t\t\treturn 2;\n\t\tgoto err;\n\t} else {\n\t\treturn 1;\n\t}\n\nerr:\n\tif (made_fd) {\n\t\tevutil_closesocket(*fd_ptr);\n\t\t*fd_ptr = -1;\n\t}\n\treturn -1;\n}\n\n/* Check whether a socket on which we called connect() is done\n   connecting. Return 1 for connected, 0 for not yet, -1 for error.  In the\n   error case, set the current socket errno to the error that happened during\n   the connect operation. */\nint\nevutil_socket_finished_connecting_(evutil_socket_t fd)\n{\n\tint e;\n\tev_socklen_t elen = sizeof(e);\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&e, &elen) < 0)\n\t\treturn -1;\n\n\tif (e) {\n\t\tif (EVUTIL_ERR_CONNECT_RETRIABLE(e))\n\t\t\treturn 0;\n\t\tEVUTIL_SET_SOCKET_ERROR(e);\n\t\treturn -1;\n\t}\n\n\treturn 1;\n}\n\n#if (EVUTIL_AI_PASSIVE|EVUTIL_AI_CANONNAME|EVUTIL_AI_NUMERICHOST| \\\n     EVUTIL_AI_NUMERICSERV|EVUTIL_AI_V4MAPPED|EVUTIL_AI_ALL| \\\n     EVUTIL_AI_ADDRCONFIG) != \\\n    (EVUTIL_AI_PASSIVE^EVUTIL_AI_CANONNAME^EVUTIL_AI_NUMERICHOST^ \\\n     EVUTIL_AI_NUMERICSERV^EVUTIL_AI_V4MAPPED^EVUTIL_AI_ALL^ \\\n     EVUTIL_AI_ADDRCONFIG)\n#error \"Some of our EVUTIL_AI_* flags seem to overlap with system AI_* flags\"\n#endif\n\n/* We sometimes need to know whether we have an ipv4 address and whether we\n   have an ipv6 address. If 'have_checked_interfaces', then we've already done\n   the test.  If 'had_ipv4_address', then it turns out we had an ipv4 address.\n   If 'had_ipv6_address', then it turns out we had an ipv6 address.   These are\n   set by evutil_check_interfaces. */\nstatic int have_checked_interfaces, had_ipv4_address, had_ipv6_address;\n\n/* Macro: True iff the IPv4 address 'addr', in host order, is in 127.0.0.0/8\n */\n#define EVUTIL_V4ADDR_IS_LOCALHOST(addr) (((addr)>>24) == 127)\n\n/* Macro: True iff the IPv4 address 'addr', in host order, is a class D\n * (multiclass) address.\n */\n#define EVUTIL_V4ADDR_IS_CLASSD(addr) ((((addr)>>24) & 0xf0) == 0xe0)\n\nstatic void\nevutil_found_ifaddr(const struct sockaddr *sa)\n{\n\tconst char ZEROES[] = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n\n\tif (sa->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\t\tev_uint32_t addr = ntohl(sin->sin_addr.s_addr);\n\t\tif (addr == 0 ||\n\t\t    EVUTIL_V4ADDR_IS_LOCALHOST(addr) ||\n\t\t    EVUTIL_V4ADDR_IS_CLASSD(addr)) {\n\t\t\t/* Not actually a usable external address. */\n\t\t} else {\n\t\t\tevent_debug((\"Detected an IPv4 interface\"));\n\t\t\thad_ipv4_address = 1;\n\t\t}\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\n\t\tconst unsigned char *addr =\n\t\t    (unsigned char*)sin6->sin6_addr.s6_addr;\n\t\tif (!memcmp(addr, ZEROES, 8) ||\n\t\t    ((addr[0] & 0xfe) == 0xfc) ||\n\t\t    (addr[0] == 0xfe && (addr[1] & 0xc0) == 0x80) ||\n\t\t    (addr[0] == 0xfe && (addr[1] & 0xc0) == 0xc0) ||\n\t\t    (addr[0] == 0xff)) {\n\t\t\t/* This is a reserved, ipv4compat, ipv4map, loopback,\n\t\t\t * link-local, multicast, or unspecified address. */\n\t\t} else {\n\t\t\tevent_debug((\"Detected an IPv6 interface\"));\n\t\t\thad_ipv6_address = 1;\n\t\t}\n\t}\n}\n\n#ifdef _WIN32\ntypedef ULONG (WINAPI *GetAdaptersAddresses_fn_t)(\n              ULONG, ULONG, PVOID, PIP_ADAPTER_ADDRESSES, PULONG);\n#endif\n\nstatic int\nevutil_check_ifaddrs(void)\n{\n#if defined(EVENT__HAVE_GETIFADDRS)\n\t/* Most free Unixy systems provide getifaddrs, which gives us a linked list\n\t * of struct ifaddrs. */\n\tstruct ifaddrs *ifa = NULL;\n\tconst struct ifaddrs *i;\n\tif (getifaddrs(&ifa) < 0) {\n\t\tevent_warn(\"Unable to call getifaddrs()\");\n\t\treturn -1;\n\t}\n\n\tfor (i = ifa; i; i = i->ifa_next) {\n\t\tif (!i->ifa_addr)\n\t\t\tcontinue;\n\t\tevutil_found_ifaddr(i->ifa_addr);\n\t}\n\n\tfreeifaddrs(ifa);\n\treturn 0;\n#elif defined(_WIN32)\n\t/* Windows XP began to provide GetAdaptersAddresses. Windows 2000 had a\n\t   \"GetAdaptersInfo\", but that's deprecated; let's just try\n\t   GetAdaptersAddresses and fall back to connect+getsockname.\n\t*/\n\tHMODULE lib = evutil_load_windows_system_library_(TEXT(\"ihplapi.dll\"));\n\tGetAdaptersAddresses_fn_t fn;\n\tULONG size, res;\n\tIP_ADAPTER_ADDRESSES *addresses = NULL, *address;\n\tint result = -1;\n\n#define FLAGS (GAA_FLAG_SKIP_ANYCAST | \\\n               GAA_FLAG_SKIP_MULTICAST | \\\n               GAA_FLAG_SKIP_DNS_SERVER)\n\n\tif (!lib)\n\t\tgoto done;\n\n\tif (!(fn = (GetAdaptersAddresses_fn_t) GetProcAddress(lib, \"GetAdaptersAddresses\")))\n\t\tgoto done;\n\n\t/* Guess how much space we need. */\n\tsize = 15*1024;\n\taddresses = mm_malloc(size);\n\tif (!addresses)\n\t\tgoto done;\n\tres = fn(AF_UNSPEC, FLAGS, NULL, addresses, &size);\n\tif (res == ERROR_BUFFER_OVERFLOW) {\n\t\t/* we didn't guess that we needed enough space; try again */\n\t\tmm_free(addresses);\n\t\taddresses = mm_malloc(size);\n\t\tif (!addresses)\n\t\t\tgoto done;\n\t\tres = fn(AF_UNSPEC, FLAGS, NULL, addresses, &size);\n\t}\n\tif (res != NO_ERROR)\n\t\tgoto done;\n\n\tfor (address = addresses; address; address = address->Next) {\n\t\tIP_ADAPTER_UNICAST_ADDRESS *a;\n\t\tfor (a = address->FirstUnicastAddress; a; a = a->Next) {\n\t\t\t/* Yes, it's a linked list inside a linked list */\n\t\t\tstruct sockaddr *sa = a->Address.lpSockaddr;\n\t\t\tevutil_found_ifaddr(sa);\n\t\t}\n\t}\n\n\tresult = 0;\ndone:\n\tif (lib)\n\t\tFreeLibrary(lib);\n\tif (addresses)\n\t\tmm_free(addresses);\n\treturn result;\n#else\n\treturn -1;\n#endif\n}\n\n/* Test whether we have an ipv4 interface and an ipv6 interface.  Return 0 if\n * the test seemed successful. */\nstatic int\nevutil_check_interfaces(int force_recheck)\n{\n\tevutil_socket_t fd = -1;\n\tstruct sockaddr_in sin, sin_out;\n\tstruct sockaddr_in6 sin6, sin6_out;\n\tev_socklen_t sin_out_len = sizeof(sin_out);\n\tev_socklen_t sin6_out_len = sizeof(sin6_out);\n\tint r;\n\tif (have_checked_interfaces && !force_recheck)\n\t\treturn 0;\n\n\tif (evutil_check_ifaddrs() == 0) {\n\t\t/* Use a nice sane interface, if this system has one. */\n\t\treturn 0;\n\t}\n\n\t/* Ugh. There was no nice sane interface.  So to check whether we have\n\t * an interface open for a given protocol, will try to make a UDP\n\t * 'connection' to a remote host on the internet.  We don't actually\n\t * use it, so the address doesn't matter, but we want to pick one that\n\t * keep us from using a host- or link-local interface. */\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(53);\n\tr = evutil_inet_pton(AF_INET, \"18.244.0.188\", &sin.sin_addr);\n\tEVUTIL_ASSERT(r);\n\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = htons(53);\n\tr = evutil_inet_pton(AF_INET6, \"2001:4860:b002::68\", &sin6.sin6_addr);\n\tEVUTIL_ASSERT(r);\n\n\tmemset(&sin_out, 0, sizeof(sin_out));\n\tmemset(&sin6_out, 0, sizeof(sin6_out));\n\n\t/* XXX some errnos mean 'no address'; some mean 'not enough sockets'. */\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) >= 0 &&\n\t    connect(fd, (struct sockaddr*)&sin, sizeof(sin)) == 0 &&\n\t    getsockname(fd, (struct sockaddr*)&sin_out, &sin_out_len) == 0) {\n\t\t/* We might have an IPv4 interface. */\n\t\tevutil_found_ifaddr((struct sockaddr*) &sin_out);\n\t}\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n\n\tif ((fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP)) >= 0 &&\n\t    connect(fd, (struct sockaddr*)&sin6, sizeof(sin6)) == 0 &&\n\t    getsockname(fd, (struct sockaddr*)&sin6_out, &sin6_out_len) == 0) {\n\t\t/* We might have an IPv6 interface. */\n\t\tevutil_found_ifaddr((struct sockaddr*) &sin6_out);\n\t}\n\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n\n\treturn 0;\n}\n\n/* Internal addrinfo flag.  This one is set when we allocate the addrinfo from\n * inside libevent.  Otherwise, the built-in getaddrinfo() function allocated\n * it, and we should trust what they said.\n **/\n#define EVUTIL_AI_LIBEVENT_ALLOCATED 0x80000000\n\n/* Helper: construct a new addrinfo containing the socket address in\n * 'sa', which must be a sockaddr_in or a sockaddr_in6.  Take the\n * socktype and protocol info from hints.  If they weren't set, then\n * allocate both a TCP and a UDP addrinfo.\n */\nstruct evutil_addrinfo *\nevutil_new_addrinfo_(struct sockaddr *sa, ev_socklen_t socklen,\n    const struct evutil_addrinfo *hints)\n{\n\tstruct evutil_addrinfo *res;\n\tEVUTIL_ASSERT(hints);\n\n\tif (hints->ai_socktype == 0 && hints->ai_protocol == 0) {\n\t\t/* Indecisive user! Give them a UDP and a TCP. */\n\t\tstruct evutil_addrinfo *r1, *r2;\n\t\tstruct evutil_addrinfo tmp;\n\t\tmemcpy(&tmp, hints, sizeof(tmp));\n\t\ttmp.ai_socktype = SOCK_STREAM; tmp.ai_protocol = IPPROTO_TCP;\n\t\tr1 = evutil_new_addrinfo_(sa, socklen, &tmp);\n\t\tif (!r1)\n\t\t\treturn NULL;\n\t\ttmp.ai_socktype = SOCK_DGRAM; tmp.ai_protocol = IPPROTO_UDP;\n\t\tr2 = evutil_new_addrinfo_(sa, socklen, &tmp);\n\t\tif (!r2) {\n\t\t\tevutil_freeaddrinfo(r1);\n\t\t\treturn NULL;\n\t\t}\n\t\tr1->ai_next = r2;\n\t\treturn r1;\n\t}\n\n\t/* We're going to allocate extra space to hold the sockaddr. */\n\tres = mm_calloc(1,sizeof(struct evutil_addrinfo)+socklen);\n\tif (!res)\n\t\treturn NULL;\n\tres->ai_addr = (struct sockaddr*)\n\t    (((char*)res) + sizeof(struct evutil_addrinfo));\n\tmemcpy(res->ai_addr, sa, socklen);\n\tres->ai_addrlen = socklen;\n\tres->ai_family = sa->sa_family; /* Same or not? XXX */\n\tres->ai_flags = EVUTIL_AI_LIBEVENT_ALLOCATED;\n\tres->ai_socktype = hints->ai_socktype;\n\tres->ai_protocol = hints->ai_protocol;\n\n\treturn res;\n}\n\n/* Append the addrinfo 'append' to the end of 'first', and return the start of\n * the list.  Either element can be NULL, in which case we return the element\n * that is not NULL. */\nstruct evutil_addrinfo *\nevutil_addrinfo_append_(struct evutil_addrinfo *first,\n    struct evutil_addrinfo *append)\n{\n\tstruct evutil_addrinfo *ai = first;\n\tif (!ai)\n\t\treturn append;\n\twhile (ai->ai_next)\n\t\tai = ai->ai_next;\n\tai->ai_next = append;\n\n\treturn first;\n}\n\nstatic int\nparse_numeric_servname(const char *servname)\n{\n\tint n;\n\tchar *endptr=NULL;\n\tn = (int) strtol(servname, &endptr, 10);\n\tif (n>=0 && n <= 65535 && servname[0] && endptr && !endptr[0])\n\t\treturn n;\n\telse\n\t\treturn -1;\n}\n\n/** Parse a service name in 'servname', which can be a decimal port.\n * Return the port number, or -1 on error.\n */\nstatic int\nevutil_parse_servname(const char *servname, const char *protocol,\n    const struct evutil_addrinfo *hints)\n{\n\tint n = parse_numeric_servname(servname);\n\tif (n>=0)\n\t\treturn n;\n#if defined(EVENT__HAVE_GETSERVBYNAME) || defined(_WIN32)\n\tif (!(hints->ai_flags & EVUTIL_AI_NUMERICSERV)) {\n\t\tstruct servent *ent = getservbyname(servname, protocol);\n\t\tif (ent) {\n\t\t\treturn ntohs(ent->s_port);\n\t\t}\n\t}\n#endif\n\treturn -1;\n}\n\n/* Return a string corresponding to a protocol number that we can pass to\n * getservyname.  */\nstatic const char *\nevutil_unparse_protoname(int proto)\n{\n\tswitch (proto) {\n\tcase 0:\n\t\treturn NULL;\n\tcase IPPROTO_TCP:\n\t\treturn \"tcp\";\n\tcase IPPROTO_UDP:\n\t\treturn \"udp\";\n#ifdef IPPROTO_SCTP\n\tcase IPPROTO_SCTP:\n\t\treturn \"sctp\";\n#endif\n\tdefault:\n#ifdef EVENT__HAVE_GETPROTOBYNUMBER\n\t\t{\n\t\t\tstruct protoent *ent = getprotobynumber(proto);\n\t\t\tif (ent)\n\t\t\t\treturn ent->p_name;\n\t\t}\n#endif\n\t\treturn NULL;\n\t}\n}\n\nstatic void\nevutil_getaddrinfo_infer_protocols(struct evutil_addrinfo *hints)\n{\n\t/* If we can guess the protocol from the socktype, do so. */\n\tif (!hints->ai_protocol && hints->ai_socktype) {\n\t\tif (hints->ai_socktype == SOCK_DGRAM)\n\t\t\thints->ai_protocol = IPPROTO_UDP;\n\t\telse if (hints->ai_socktype == SOCK_STREAM)\n\t\t\thints->ai_protocol = IPPROTO_TCP;\n\t}\n\n\t/* Set the socktype if it isn't set. */\n\tif (!hints->ai_socktype && hints->ai_protocol) {\n\t\tif (hints->ai_protocol == IPPROTO_UDP)\n\t\t\thints->ai_socktype = SOCK_DGRAM;\n\t\telse if (hints->ai_protocol == IPPROTO_TCP)\n\t\t\thints->ai_socktype = SOCK_STREAM;\n#ifdef IPPROTO_SCTP\n\t\telse if (hints->ai_protocol == IPPROTO_SCTP)\n\t\t\thints->ai_socktype = SOCK_STREAM;\n#endif\n\t}\n}\n\n#if AF_UNSPEC != PF_UNSPEC\n#error \"I cannot build on a system where AF_UNSPEC != PF_UNSPEC\"\n#endif\n\n/** Implements the part of looking up hosts by name that's common to both\n * the blocking and nonblocking resolver:\n *   - Adjust 'hints' to have a reasonable socktype and protocol.\n *   - Look up the port based on 'servname', and store it in *portnum,\n *   - Handle the nodename==NULL case\n *   - Handle some invalid arguments cases.\n *   - Handle the cases where nodename is an IPv4 or IPv6 address.\n *\n * If we need the resolver to look up the hostname, we return\n * EVUTIL_EAI_NEED_RESOLVE.  Otherwise, we can completely implement\n * getaddrinfo: we return 0 or an appropriate EVUTIL_EAI_* error, and\n * set *res as getaddrinfo would.\n */\nint\nevutil_getaddrinfo_common_(const char *nodename, const char *servname,\n    struct evutil_addrinfo *hints, struct evutil_addrinfo **res, int *portnum)\n{\n\tint port = 0;\n\tconst char *pname;\n\n\tif (nodename == NULL && servname == NULL)\n\t\treturn EVUTIL_EAI_NONAME;\n\n\t/* We only understand 3 families */\n\tif (hints->ai_family != PF_UNSPEC && hints->ai_family != PF_INET &&\n\t    hints->ai_family != PF_INET6)\n\t\treturn EVUTIL_EAI_FAMILY;\n\n\tevutil_getaddrinfo_infer_protocols(hints);\n\n\t/* Look up the port number and protocol, if possible. */\n\tpname = evutil_unparse_protoname(hints->ai_protocol);\n\tif (servname) {\n\t\t/* XXXX We could look at the protocol we got back from\n\t\t * getservbyname, but it doesn't seem too useful. */\n\t\tport = evutil_parse_servname(servname, pname, hints);\n\t\tif (port < 0) {\n\t\t\treturn EVUTIL_EAI_NONAME;\n\t\t}\n\t}\n\n\t/* If we have no node name, then we're supposed to bind to 'any' and\n\t * connect to localhost. */\n\tif (nodename == NULL) {\n\t\tstruct evutil_addrinfo *res4=NULL, *res6=NULL;\n\t\tif (hints->ai_family != PF_INET) { /* INET6 or UNSPEC. */\n\t\t\tstruct sockaddr_in6 sin6;\n\t\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_port = htons(port);\n\t\t\tif (hints->ai_flags & EVUTIL_AI_PASSIVE) {\n\t\t\t\t/* Bind to :: */\n\t\t\t} else {\n\t\t\t\t/* connect to ::1 */\n\t\t\t\tsin6.sin6_addr.s6_addr[15] = 1;\n\t\t\t}\n\t\t\tres6 = evutil_new_addrinfo_((struct sockaddr*)&sin6,\n\t\t\t    sizeof(sin6), hints);\n\t\t\tif (!res6)\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t}\n\n\t\tif (hints->ai_family != PF_INET6) { /* INET or UNSPEC */\n\t\t\tstruct sockaddr_in sin;\n\t\t\tmemset(&sin, 0, sizeof(sin));\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = htons(port);\n\t\t\tif (hints->ai_flags & EVUTIL_AI_PASSIVE) {\n\t\t\t\t/* Bind to 0.0.0.0 */\n\t\t\t} else {\n\t\t\t\t/* connect to 127.0.0.1 */\n\t\t\t\tsin.sin_addr.s_addr = htonl(0x7f000001);\n\t\t\t}\n\t\t\tres4 = evutil_new_addrinfo_((struct sockaddr*)&sin,\n\t\t\t    sizeof(sin), hints);\n\t\t\tif (!res4) {\n\t\t\t\tif (res6)\n\t\t\t\t\tevutil_freeaddrinfo(res6);\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t\t}\n\t\t}\n\t\t*res = evutil_addrinfo_append_(res4, res6);\n\t\treturn 0;\n\t}\n\n\t/* If we can, we should try to parse the hostname without resolving\n\t * it. */\n\t/* Try ipv6. */\n\tif (hints->ai_family == PF_INET6 || hints->ai_family == PF_UNSPEC) {\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tif (1==evutil_inet_pton(AF_INET6, nodename, &sin6.sin6_addr)) {\n\t\t\t/* Got an ipv6 address. */\n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_port = htons(port);\n\t\t\t*res = evutil_new_addrinfo_((struct sockaddr*)&sin6,\n\t\t\t    sizeof(sin6), hints);\n\t\t\tif (!*res)\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Try ipv4. */\n\tif (hints->ai_family == PF_INET || hints->ai_family == PF_UNSPEC) {\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tif (1==evutil_inet_pton(AF_INET, nodename, &sin.sin_addr)) {\n\t\t\t/* Got an ipv6 address. */\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = htons(port);\n\t\t\t*res = evutil_new_addrinfo_((struct sockaddr*)&sin,\n\t\t\t    sizeof(sin), hints);\n\t\t\tif (!*res)\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\t/* If we have reached this point, we definitely need to do a DNS\n\t * lookup. */\n\tif ((hints->ai_flags & EVUTIL_AI_NUMERICHOST)) {\n\t\t/* If we're not allowed to do one, then say so. */\n\t\treturn EVUTIL_EAI_NONAME;\n\t}\n\t*portnum = port;\n\treturn EVUTIL_EAI_NEED_RESOLVE;\n}\n\n#ifdef EVENT__HAVE_GETADDRINFO\n#define USE_NATIVE_GETADDRINFO\n#endif\n\n#ifdef USE_NATIVE_GETADDRINFO\n/* A mask of all the flags that we declare, so we can clear them before calling\n * the native getaddrinfo */\nstatic const unsigned int ALL_NONNATIVE_AI_FLAGS =\n#ifndef AI_PASSIVE\n    EVUTIL_AI_PASSIVE |\n#endif\n#ifndef AI_CANONNAME\n    EVUTIL_AI_CANONNAME |\n#endif\n#ifndef AI_NUMERICHOST\n    EVUTIL_AI_NUMERICHOST |\n#endif\n#ifndef AI_NUMERICSERV\n    EVUTIL_AI_NUMERICSERV |\n#endif\n#ifndef AI_ADDRCONFIG\n    EVUTIL_AI_ADDRCONFIG |\n#endif\n#ifndef AI_ALL\n    EVUTIL_AI_ALL |\n#endif\n#ifndef AI_V4MAPPED\n    EVUTIL_AI_V4MAPPED |\n#endif\n    EVUTIL_AI_LIBEVENT_ALLOCATED;\n\nstatic const unsigned int ALL_NATIVE_AI_FLAGS =\n#ifdef AI_PASSIVE\n    AI_PASSIVE |\n#endif\n#ifdef AI_CANONNAME\n    AI_CANONNAME |\n#endif\n#ifdef AI_NUMERICHOST\n    AI_NUMERICHOST |\n#endif\n#ifdef AI_NUMERICSERV\n    AI_NUMERICSERV |\n#endif\n#ifdef AI_ADDRCONFIG\n    AI_ADDRCONFIG |\n#endif\n#ifdef AI_ALL\n    AI_ALL |\n#endif\n#ifdef AI_V4MAPPED\n    AI_V4MAPPED |\n#endif\n    0;\n#endif\n\n#ifndef USE_NATIVE_GETADDRINFO\n/* Helper for systems with no getaddrinfo(): make one or more addrinfos out of\n * a struct hostent.\n */\nstatic struct evutil_addrinfo *\naddrinfo_from_hostent(const struct hostent *ent,\n    int port, const struct evutil_addrinfo *hints)\n{\n\tint i;\n\tstruct sockaddr_in sin;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr *sa;\n\tint socklen;\n\tstruct evutil_addrinfo *res=NULL, *ai;\n\tvoid *addrp;\n\n\tif (ent->h_addrtype == PF_INET) {\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tsa = (struct sockaddr *)&sin;\n\t\tsocklen = sizeof(struct sockaddr_in);\n\t\taddrp = &sin.sin_addr;\n\t\tif (ent->h_length != sizeof(sin.sin_addr)) {\n\t\t\tevent_warnx(\"Weird h_length from gethostbyname\");\n\t\t\treturn NULL;\n\t\t}\n\t} else if (ent->h_addrtype == PF_INET6) {\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tsa = (struct sockaddr *)&sin6;\n\t\tsocklen = sizeof(struct sockaddr_in6);\n\t\taddrp = &sin6.sin6_addr;\n\t\tif (ent->h_length != sizeof(sin6.sin6_addr)) {\n\t\t\tevent_warnx(\"Weird h_length from gethostbyname\");\n\t\t\treturn NULL;\n\t\t}\n\t} else\n\t\treturn NULL;\n\n\tfor (i = 0; ent->h_addr_list[i]; ++i) {\n\t\tmemcpy(addrp, ent->h_addr_list[i], ent->h_length);\n\t\tai = evutil_new_addrinfo_(sa, socklen, hints);\n\t\tif (!ai) {\n\t\t\tevutil_freeaddrinfo(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tres = evutil_addrinfo_append_(res, ai);\n\t}\n\n\tif (res && ((hints->ai_flags & EVUTIL_AI_CANONNAME) && ent->h_name)) {\n\t\tres->ai_canonname = mm_strdup(ent->h_name);\n\t\tif (res->ai_canonname == NULL) {\n\t\t\tevutil_freeaddrinfo(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn res;\n}\n#endif\n\n/* If the EVUTIL_AI_ADDRCONFIG flag is set on hints->ai_flags, and\n * hints->ai_family is PF_UNSPEC, then revise the value of hints->ai_family so\n * that we'll only get addresses we could maybe connect to.\n */\nvoid\nevutil_adjust_hints_for_addrconfig_(struct evutil_addrinfo *hints)\n{\n\tif (!(hints->ai_flags & EVUTIL_AI_ADDRCONFIG))\n\t\treturn;\n\tif (hints->ai_family != PF_UNSPEC)\n\t\treturn;\n\tif (!have_checked_interfaces)\n\t\tevutil_check_interfaces(0);\n\tif (had_ipv4_address && !had_ipv6_address) {\n\t\thints->ai_family = PF_INET;\n\t} else if (!had_ipv4_address && had_ipv6_address) {\n\t\thints->ai_family = PF_INET6;\n\t}\n}\n\n#ifdef USE_NATIVE_GETADDRINFO\nstatic int need_numeric_port_hack_=0;\nstatic int need_socktype_protocol_hack_=0;\nstatic int tested_for_getaddrinfo_hacks=0;\n\n/* Some older BSDs (like OpenBSD up to 4.6) used to believe that\n   giving a numeric port without giving an ai_socktype was verboten.\n   We test for this so we can apply an appropriate workaround.  If it\n   turns out that the bug is present, then:\n\n    - If nodename==NULL and servname is numeric, we build an answer\n      ourselves using evutil_getaddrinfo_common_().\n\n    - If nodename!=NULL and servname is numeric, then we set\n      servname=NULL when calling getaddrinfo, and post-process the\n      result to set the ports on it.\n\n   We test for this bug at runtime, since otherwise we can't have the\n   same binary run on multiple BSD versions.\n\n   - Some versions of Solaris believe that it's nice to leave to protocol\n     field set to 0.  We test for this so we can apply an appropriate\n     workaround.\n*/\nstatic void\ntest_for_getaddrinfo_hacks(void)\n{\n\tint r, r2;\n\tstruct evutil_addrinfo *ai=NULL, *ai2=NULL;\n\tstruct evutil_addrinfo hints;\n\n\tmemset(&hints,0,sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_flags =\n#ifdef AI_NUMERICHOST\n\t    AI_NUMERICHOST |\n#endif\n#ifdef AI_NUMERICSERV\n\t    AI_NUMERICSERV |\n#endif\n\t    0;\n\tr = getaddrinfo(\"1.2.3.4\", \"80\", &hints, &ai);\n\thints.ai_socktype = SOCK_STREAM;\n\tr2 = getaddrinfo(\"1.2.3.4\", \"80\", &hints, &ai2);\n\tif (r2 == 0 && r != 0) {\n\t\tneed_numeric_port_hack_=1;\n\t}\n\tif (ai2 && ai2->ai_protocol == 0) {\n\t\tneed_socktype_protocol_hack_=1;\n\t}\n\n\tif (ai)\n\t\tfreeaddrinfo(ai);\n\tif (ai2)\n\t\tfreeaddrinfo(ai2);\n\ttested_for_getaddrinfo_hacks=1;\n}\n\nstatic inline int\nneed_numeric_port_hack(void)\n{\n\tif (!tested_for_getaddrinfo_hacks)\n\t\ttest_for_getaddrinfo_hacks();\n\treturn need_numeric_port_hack_;\n}\n\nstatic inline int\nneed_socktype_protocol_hack(void)\n{\n\tif (!tested_for_getaddrinfo_hacks)\n\t\ttest_for_getaddrinfo_hacks();\n\treturn need_socktype_protocol_hack_;\n}\n\nstatic void\napply_numeric_port_hack(int port, struct evutil_addrinfo **ai)\n{\n\t/* Now we run through the list and set the ports on all of the\n\t * results where ports would make sense. */\n\tfor ( ; *ai; ai = &(*ai)->ai_next) {\n\t\tstruct sockaddr *sa = (*ai)->ai_addr;\n\t\tif (sa && sa->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in*)sa;\n\t\t\tsin->sin_port = htons(port);\n\t\t} else if (sa && sa->sa_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6*)sa;\n\t\t\tsin6->sin6_port = htons(port);\n\t\t} else {\n\t\t\t/* A numeric port makes no sense here; remove this one\n\t\t\t * from the list. */\n\t\t\tstruct evutil_addrinfo *victim = *ai;\n\t\t\t*ai = victim->ai_next;\n\t\t\tvictim->ai_next = NULL;\n\t\t\tfreeaddrinfo(victim);\n\t\t}\n\t}\n}\n\nstatic int\napply_socktype_protocol_hack(struct evutil_addrinfo *ai)\n{\n\tstruct evutil_addrinfo *ai_new;\n\tfor (; ai; ai = ai->ai_next) {\n\t\tevutil_getaddrinfo_infer_protocols(ai);\n\t\tif (ai->ai_socktype || ai->ai_protocol)\n\t\t\tcontinue;\n\t\tai_new = mm_malloc(sizeof(*ai_new));\n\t\tif (!ai_new)\n\t\t\treturn -1;\n\t\tmemcpy(ai_new, ai, sizeof(*ai_new));\n\t\tai->ai_socktype = SOCK_STREAM;\n\t\tai->ai_protocol = IPPROTO_TCP;\n\t\tai_new->ai_socktype = SOCK_DGRAM;\n\t\tai_new->ai_protocol = IPPROTO_UDP;\n\n\t\tai_new->ai_next = ai->ai_next;\n\t\tai->ai_next = ai_new;\n\t}\n\treturn 0;\n}\n#endif\n\nint\nevutil_getaddrinfo(const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res)\n{\n#ifdef USE_NATIVE_GETADDRINFO\n\tstruct evutil_addrinfo hints;\n\tint portnum=-1, need_np_hack, err;\n\n\tif (hints_in) {\n\t\tmemcpy(&hints, hints_in, sizeof(hints));\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = PF_UNSPEC;\n\t}\n\n#ifndef AI_ADDRCONFIG\n\t/* Not every system has AI_ADDRCONFIG, so fake it. */\n\tif (hints.ai_family == PF_UNSPEC &&\n\t    (hints.ai_flags & EVUTIL_AI_ADDRCONFIG)) {\n\t\tevutil_adjust_hints_for_addrconfig_(&hints);\n\t}\n#endif\n\n#ifndef AI_NUMERICSERV\n\t/* Not every system has AI_NUMERICSERV, so fake it. */\n\tif (hints.ai_flags & EVUTIL_AI_NUMERICSERV) {\n\t\tif (servname && parse_numeric_servname(servname)<0)\n\t\t\treturn EVUTIL_EAI_NONAME;\n\t}\n#endif\n\n\t/* Enough operating systems handle enough common non-resolve\n\t * cases here weirdly enough that we are better off just\n\t * overriding them.  For example:\n\t *\n\t * - Windows doesn't like to infer the protocol from the\n\t *   socket type, or fill in socket or protocol types much at\n\t *   all.  It also seems to do its own broken implicit\n\t *   always-on version of AI_ADDRCONFIG that keeps it from\n\t *   ever resolving even a literal IPv6 address when\n\t *   ai_addrtype is PF_UNSPEC.\n\t */\n#ifdef _WIN32\n\t{\n\t\tint tmp_port;\n\t\terr = evutil_getaddrinfo_common_(nodename,servname,&hints,\n\t\t    res, &tmp_port);\n\t\tif (err == 0 ||\n\t\t    err == EVUTIL_EAI_MEMORY ||\n\t\t    err == EVUTIL_EAI_NONAME)\n\t\t\treturn err;\n\t\t/* If we make it here, the system getaddrinfo can\n\t\t * have a crack at it. */\n\t}\n#endif\n\n\t/* See documentation for need_numeric_port_hack above.*/\n\tneed_np_hack = need_numeric_port_hack() && servname && !hints.ai_socktype\n\t    && ((portnum=parse_numeric_servname(servname)) >= 0);\n\tif (need_np_hack) {\n\t\tif (!nodename)\n\t\t\treturn evutil_getaddrinfo_common_(\n\t\t\t\tNULL,servname,&hints, res, &portnum);\n\t\tservname = NULL;\n\t}\n\n\tif (need_socktype_protocol_hack()) {\n\t\tevutil_getaddrinfo_infer_protocols(&hints);\n\t}\n\n\t/* Make sure that we didn't actually steal any AI_FLAGS values that\n\t * the system is using.  (This is a constant expression, and should ge\n\t * optimized out.)\n\t *\n\t * XXXX Turn this into a compile-time failure rather than a run-time\n\t * failure.\n\t */\n\tEVUTIL_ASSERT((ALL_NONNATIVE_AI_FLAGS & ALL_NATIVE_AI_FLAGS) == 0);\n\n\t/* Clear any flags that only libevent understands. */\n\thints.ai_flags &= ~ALL_NONNATIVE_AI_FLAGS;\n\n\terr = getaddrinfo(nodename, servname, &hints, res);\n\tif (need_np_hack)\n\t\tapply_numeric_port_hack(portnum, res);\n\n\tif (need_socktype_protocol_hack()) {\n\t\tif (apply_socktype_protocol_hack(*res) < 0) {\n\t\t\tevutil_freeaddrinfo(*res);\n\t\t\t*res = NULL;\n\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t}\n\t}\n\treturn err;\n#else\n\tint port=0, err;\n\tstruct hostent *ent = NULL;\n\tstruct evutil_addrinfo hints;\n\n\tif (hints_in) {\n\t\tmemcpy(&hints, hints_in, sizeof(hints));\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = PF_UNSPEC;\n\t}\n\n\tevutil_adjust_hints_for_addrconfig_(&hints);\n\n\terr = evutil_getaddrinfo_common_(nodename, servname, &hints, res, &port);\n\tif (err != EVUTIL_EAI_NEED_RESOLVE) {\n\t\t/* We either succeeded or failed.  No need to continue */\n\t\treturn err;\n\t}\n\n\terr = 0;\n\t/* Use any of the various gethostbyname_r variants as available. */\n\t{\n#ifdef EVENT__HAVE_GETHOSTBYNAME_R_6_ARG\n\t\t/* This one is what glibc provides. */\n\t\tchar buf[2048];\n\t\tstruct hostent hostent;\n\t\tint r;\n\t\tr = gethostbyname_r(nodename, &hostent, buf, sizeof(buf), &ent,\n\t\t    &err);\n#elif defined(EVENT__HAVE_GETHOSTBYNAME_R_5_ARG)\n\t\tchar buf[2048];\n\t\tstruct hostent hostent;\n\t\tent = gethostbyname_r(nodename, &hostent, buf, sizeof(buf),\n\t\t    &err);\n#elif defined(EVENT__HAVE_GETHOSTBYNAME_R_3_ARG)\n\t\tstruct hostent_data data;\n\t\tstruct hostent hostent;\n\t\tmemset(&data, 0, sizeof(data));\n\t\terr = gethostbyname_r(nodename, &hostent, &data);\n\t\tent = err ? NULL : &hostent;\n#else\n\t\t/* fall back to gethostbyname. */\n\t\t/* XXXX This needs a lock everywhere but Windows. */\n\t\tent = gethostbyname(nodename);\n#ifdef _WIN32\n\t\terr = WSAGetLastError();\n#else\n\t\terr = h_errno;\n#endif\n#endif\n\n\t\t/* Now we have either ent or err set. */\n\t\tif (!ent) {\n\t\t\t/* XXX is this right for windows ? */\n\t\t\tswitch (err) {\n\t\t\tcase TRY_AGAIN:\n\t\t\t\treturn EVUTIL_EAI_AGAIN;\n\t\t\tcase NO_RECOVERY:\n\t\t\tdefault:\n\t\t\t\treturn EVUTIL_EAI_FAIL;\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\treturn EVUTIL_EAI_NONAME;\n\t\t\tcase NO_ADDRESS:\n#if NO_DATA != NO_ADDRESS\n\t\t\tcase NO_DATA:\n#endif\n\t\t\t\treturn EVUTIL_EAI_NODATA;\n\t\t\t}\n\t\t}\n\n\t\tif (ent->h_addrtype != hints.ai_family &&\n\t\t    hints.ai_family != PF_UNSPEC) {\n\t\t\t/* This wasn't the type we were hoping for.  Too bad\n\t\t\t * we never had a chance to ask gethostbyname for what\n\t\t\t * we wanted. */\n\t\t\treturn EVUTIL_EAI_NONAME;\n\t\t}\n\n\t\t/* Make sure we got _some_ answers. */\n\t\tif (ent->h_length == 0)\n\t\t\treturn EVUTIL_EAI_NODATA;\n\n\t\t/* If we got an address type we don't know how to make a\n\t\t   sockaddr for, give up. */\n\t\tif (ent->h_addrtype != PF_INET && ent->h_addrtype != PF_INET6)\n\t\t\treturn EVUTIL_EAI_FAMILY;\n\n\t\t*res = addrinfo_from_hostent(ent, port, &hints);\n\t\tif (! *res)\n\t\t\treturn EVUTIL_EAI_MEMORY;\n\t}\n\n\treturn 0;\n#endif\n}\n\nvoid\nevutil_freeaddrinfo(struct evutil_addrinfo *ai)\n{\n#ifdef EVENT__HAVE_GETADDRINFO\n\tif (!(ai->ai_flags & EVUTIL_AI_LIBEVENT_ALLOCATED)) {\n\t\tfreeaddrinfo(ai);\n\t\treturn;\n\t}\n#endif\n\twhile (ai) {\n\t\tstruct evutil_addrinfo *next = ai->ai_next;\n\t\tif (ai->ai_canonname)\n\t\t\tmm_free(ai->ai_canonname);\n\t\tmm_free(ai);\n\t\tai = next;\n\t}\n}\n\nstatic evdns_getaddrinfo_fn evdns_getaddrinfo_impl = NULL;\n\nvoid\nevutil_set_evdns_getaddrinfo_fn_(evdns_getaddrinfo_fn fn)\n{\n\tif (!evdns_getaddrinfo_impl)\n\t\tevdns_getaddrinfo_impl = fn;\n}\n\n/* Internal helper function: act like evdns_getaddrinfo if dns_base is set;\n * otherwise do a blocking resolve and pass the result to the callback in the\n * way that evdns_getaddrinfo would.\n */\nint\nevutil_getaddrinfo_async_(struct evdns_base *dns_base,\n    const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in,\n    void (*cb)(int, struct evutil_addrinfo *, void *), void *arg)\n{\n\tif (dns_base && evdns_getaddrinfo_impl) {\n\t\tevdns_getaddrinfo_impl(\n\t\t\tdns_base, nodename, servname, hints_in, cb, arg);\n\t} else {\n\t\tstruct evutil_addrinfo *ai=NULL;\n\t\tint err;\n\t\terr = evutil_getaddrinfo(nodename, servname, hints_in, &ai);\n\t\tcb(err, ai, arg);\n\t}\n\treturn 0;\n}\n\nconst char *\nevutil_gai_strerror(int err)\n{\n\t/* As a sneaky side-benefit, this case statement will get most\n\t * compilers to tell us if any of the error codes we defined\n\t * conflict with the platform's native error codes. */\n\tswitch (err) {\n\tcase EVUTIL_EAI_CANCEL:\n\t\treturn \"Request canceled\";\n\tcase 0:\n\t\treturn \"No error\";\n\n\tcase EVUTIL_EAI_ADDRFAMILY:\n\t\treturn \"address family for nodename not supported\";\n\tcase EVUTIL_EAI_AGAIN:\n\t\treturn \"temporary failure in name resolution\";\n\tcase EVUTIL_EAI_BADFLAGS:\n\t\treturn \"invalid value for ai_flags\";\n\tcase EVUTIL_EAI_FAIL:\n\t\treturn \"non-recoverable failure in name resolution\";\n\tcase EVUTIL_EAI_FAMILY:\n\t\treturn \"ai_family not supported\";\n\tcase EVUTIL_EAI_MEMORY:\n\t\treturn \"memory allocation failure\";\n\tcase EVUTIL_EAI_NODATA:\n\t\treturn \"no address associated with nodename\";\n\tcase EVUTIL_EAI_NONAME:\n\t\treturn \"nodename nor servname provided, or not known\";\n\tcase EVUTIL_EAI_SERVICE:\n\t\treturn \"servname not supported for ai_socktype\";\n\tcase EVUTIL_EAI_SOCKTYPE:\n\t\treturn \"ai_socktype not supported\";\n\tcase EVUTIL_EAI_SYSTEM:\n\t\treturn \"system error\";\n\tdefault:\n#if defined(USE_NATIVE_GETADDRINFO) && defined(_WIN32)\n\t\treturn gai_strerrorA(err);\n#elif defined(USE_NATIVE_GETADDRINFO)\n\t\treturn gai_strerror(err);\n#else\n\t\treturn \"Unknown error code\";\n#endif\n\t}\n}\n\n#ifdef _WIN32\n/* destructively remove a trailing line terminator from s */\nstatic void\nchomp (char *s)\n{\n\tsize_t len;\n\tif (s && (len = strlen (s)) > 0 && s[len - 1] == '\\n') {\n\t\ts[--len] = 0;\n\t\tif (len > 0 && s[len - 1] == '\\r')\n\t\t\ts[--len] = 0;\n\t}\n}\n\n/* FormatMessage returns allocated strings, but evutil_socket_error_to_string\n * is supposed to return a string which is good indefinitely without having\n * to be freed.  To make this work without leaking memory, we cache the\n * string the first time FormatMessage is called on a particular error\n * code, and then return the cached string on subsequent calls with the\n * same code.  The strings aren't freed until libevent_global_shutdown\n * (or never).  We use a linked list to cache the errors, because we\n * only expect there to be a few dozen, and that should be fast enough.\n */\n\nstruct cached_sock_errs_entry {\n\tHT_ENTRY(cached_sock_errs_entry) node;\n\tDWORD code;\n\tchar *msg; /* allocated with LocalAlloc; free with LocalFree */\n};\n\nstatic inline unsigned\nhash_cached_sock_errs(const struct cached_sock_errs_entry *e)\n{\n\t/* Use Murmur3's 32-bit finalizer as an integer hash function */\n\tDWORD h = e->code;\n\th ^= h >> 16;\n\th *= 0x85ebca6b;\n\th ^= h >> 13;\n\th *= 0xc2b2ae35;\n\th ^= h >> 16;\n\treturn h;\n}\n\nstatic inline int\neq_cached_sock_errs(const struct cached_sock_errs_entry *a,\n\t\t    const struct cached_sock_errs_entry *b)\n{\n\treturn a->code == b->code;\n}\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\nstatic void *windows_socket_errors_lock_ = NULL;\n#endif\n\nstatic HT_HEAD(cached_sock_errs_map, cached_sock_errs_entry)\n     windows_socket_errors = HT_INITIALIZER();\n\nHT_PROTOTYPE(cached_sock_errs_map,\n\t     cached_sock_errs_entry,\n\t     node,\n\t     hash_cached_sock_errs,\n\t     eq_cached_sock_errs);\n\nHT_GENERATE(cached_sock_errs_map,\n\t    cached_sock_errs_entry,\n\t    node,\n\t    hash_cached_sock_errs,\n\t    eq_cached_sock_errs,\n\t    0.5,\n\t    mm_malloc,\n\t    mm_realloc,\n\t    mm_free);\n\n/** Equivalent to strerror, but for windows socket errors. */\nconst char *\nevutil_socket_error_to_string(int errcode)\n{\n\tstruct cached_sock_errs_entry *errs, *newerr, find;\n\tchar *msg = NULL;\n\n\tEVLOCK_LOCK(windows_socket_errors_lock_, 0);\n\n\tfind.code = errcode;\n\terrs = HT_FIND(cached_sock_errs_map, &windows_socket_errors, &find);\n\tif (errs) {\n\t\tmsg = errs->msg;\n\t\tgoto done;\n\t}\n\n\tif (0 != FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t       FORMAT_MESSAGE_IGNORE_INSERTS |\n\t\t\t       FORMAT_MESSAGE_ALLOCATE_BUFFER,\n\t\t\t       NULL, errcode, 0, (char *)&msg, 0, NULL))\n\t\tchomp (msg);\t/* because message has trailing newline */\n\telse {\n\t\tsize_t len = 50;\n\t\t/* use LocalAlloc because FormatMessage does */\n\t\tmsg = LocalAlloc(LMEM_FIXED, len);\n\t\tif (!msg) {\n\t\t\tmsg = (char *)\"LocalAlloc failed during Winsock error\";\n\t\t\tgoto done;\n\t\t}\n\t\tevutil_snprintf(msg, len, \"winsock error 0x%08x\", errcode);\n\t}\n\n\tnewerr = (struct cached_sock_errs_entry *)\n\t\tmm_malloc(sizeof (struct cached_sock_errs_entry));\n\n\tif (!newerr) {\n\t\tLocalFree(msg);\n\t\tmsg = (char *)\"malloc failed during Winsock error\";\n\t\tgoto done;\n\t}\n\n\tnewerr->code = errcode;\n\tnewerr->msg = msg;\n\tHT_INSERT(cached_sock_errs_map, &windows_socket_errors, newerr);\n\n done:\n\tEVLOCK_UNLOCK(windows_socket_errors_lock_, 0);\n\n\treturn msg;\n}\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\nint\nevutil_global_setup_locks_(const int enable_locks)\n{\n\tEVTHREAD_SETUP_GLOBAL_LOCK(windows_socket_errors_lock_, 0);\n\treturn 0;\n}\n#endif\n\nstatic void\nevutil_free_sock_err_globals(void)\n{\n\tstruct cached_sock_errs_entry **errs, *tofree;\n\n\tfor (errs = HT_START(cached_sock_errs_map, &windows_socket_errors)\n\t\t     ; errs; ) {\n\t\ttofree = *errs;\n\t\terrs = HT_NEXT_RMV(cached_sock_errs_map,\n\t\t\t\t   &windows_socket_errors,\n\t\t\t\t   errs);\n\t\tLocalFree(tofree->msg);\n\t\tmm_free(tofree);\n\t}\n\n\tHT_CLEAR(cached_sock_errs_map, &windows_socket_errors);\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\tif (windows_socket_errors_lock_ != NULL) {\n\t\tEVTHREAD_FREE_LOCK(windows_socket_errors_lock_, 0);\n\t\twindows_socket_errors_lock_ = NULL;\n\t}\n#endif\n}\n\n#else\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\nint\nevutil_global_setup_locks_(const int enable_locks)\n{\n\treturn 0;\n}\n#endif\n\nstatic void\nevutil_free_sock_err_globals(void)\n{\n}\n\n#endif\n\nint\nevutil_snprintf(char *buf, size_t buflen, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\tva_start(ap, format);\n\tr = evutil_vsnprintf(buf, buflen, format, ap);\n\tva_end(ap);\n\treturn r;\n}\n\nint\nevutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)\n{\n\tint r;\n\tif (!buflen)\n\t\treturn 0;\n#if defined(_MSC_VER) || defined(_WIN32)\n\tr = _vsnprintf(buf, buflen, format, ap);\n\tif (r < 0)\n\t\tr = _vscprintf(format, ap);\n#elif defined(sgi)\n\t/* Make sure we always use the correct vsnprintf on IRIX */\n\textern int      _xpg5_vsnprintf(char * __restrict,\n\t\t__SGI_LIBC_NAMESPACE_QUALIFIER size_t,\n\t\tconst char * __restrict, /* va_list */ char *);\n\n\tr = _xpg5_vsnprintf(buf, buflen, format, ap);\n#else\n\tr = vsnprintf(buf, buflen, format, ap);\n#endif\n\tbuf[buflen-1] = '\\0';\n\treturn r;\n}\n\n#define USE_INTERNAL_NTOP\n#define USE_INTERNAL_PTON\n\nconst char *\nevutil_inet_ntop(int af, const void *src, char *dst, size_t len)\n{\n#if defined(EVENT__HAVE_INET_NTOP) && !defined(USE_INTERNAL_NTOP)\n\treturn inet_ntop(af, src, dst, len);\n#else\n\tif (af == AF_INET) {\n\t\tconst struct in_addr *in = src;\n\t\tconst ev_uint32_t a = ntohl(in->s_addr);\n\t\tint r;\n\t\tr = evutil_snprintf(dst, len, \"%d.%d.%d.%d\",\n\t\t    (int)(ev_uint8_t)((a>>24)&0xff),\n\t\t    (int)(ev_uint8_t)((a>>16)&0xff),\n\t\t    (int)(ev_uint8_t)((a>>8 )&0xff),\n\t\t    (int)(ev_uint8_t)((a    )&0xff));\n\t\tif (r<0||(size_t)r>=len)\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn dst;\n#ifdef AF_INET6\n\t} else if (af == AF_INET6) {\n\t\tconst struct in6_addr *addr = src;\n\t\tchar buf[64], *cp;\n\t\tint longestGapLen = 0, longestGapPos = -1, i,\n\t\t\tcurGapPos = -1, curGapLen = 0;\n\t\tev_uint16_t words[8];\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\twords[i] =\n\t\t\t    (((ev_uint16_t)addr->s6_addr[2*i])<<8) + addr->s6_addr[2*i+1];\n\t\t}\n\t\tif (words[0] == 0 && words[1] == 0 && words[2] == 0 && words[3] == 0 &&\n\t\t    words[4] == 0 && ((words[5] == 0 && words[6] && words[7]) ||\n\t\t\t(words[5] == 0xffff))) {\n\t\t\t/* This is an IPv4 address. */\n\t\t\tif (words[5] == 0) {\n\t\t\t\tevutil_snprintf(buf, sizeof(buf), \"::%d.%d.%d.%d\",\n\t\t\t\t    addr->s6_addr[12], addr->s6_addr[13],\n\t\t\t\t    addr->s6_addr[14], addr->s6_addr[15]);\n\t\t\t} else {\n\t\t\t\tevutil_snprintf(buf, sizeof(buf), \"::%x:%d.%d.%d.%d\", words[5],\n\t\t\t\t    addr->s6_addr[12], addr->s6_addr[13],\n\t\t\t\t    addr->s6_addr[14], addr->s6_addr[15]);\n\t\t\t}\n\t\t\tif (strlen(buf) > len)\n\t\t\t\treturn NULL;\n\t\t\tstrlcpy(dst, buf, len);\n\t\t\treturn dst;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < 8) {\n\t\t\tif (words[i] == 0) {\n\t\t\t\tcurGapPos = i++;\n\t\t\t\tcurGapLen = 1;\n\t\t\t\twhile (i<8 && words[i] == 0) {\n\t\t\t\t\t++i; ++curGapLen;\n\t\t\t\t}\n\t\t\t\tif (curGapLen > longestGapLen) {\n\t\t\t\t\tlongestGapPos = curGapPos;\n\t\t\t\t\tlongestGapLen = curGapLen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\tif (longestGapLen<=1)\n\t\t\tlongestGapPos = -1;\n\n\t\tcp = buf;\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tif (words[i] == 0 && longestGapPos == i) {\n\t\t\t\tif (i == 0)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\t*cp++ = ':';\n\t\t\t\twhile (i < 8 && words[i] == 0)\n\t\t\t\t\t++i;\n\t\t\t\t--i; /* to compensate for loop increment. */\n\t\t\t} else {\n\t\t\t\tevutil_snprintf(cp,\n\t\t\t\t\t\t\t\tsizeof(buf)-(cp-buf), \"%x\", (unsigned)words[i]);\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tif (i != 7)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t}\n\t\t}\n\t\t*cp = '\\0';\n\t\tif (strlen(buf) > len)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, buf, len);\n\t\treturn dst;\n#endif\n\t} else {\n\t\treturn NULL;\n\t}\n#endif\n}\n\nint\nevutil_inet_pton(int af, const char *src, void *dst)\n{\n#if defined(EVENT__HAVE_INET_PTON) && !defined(USE_INTERNAL_PTON)\n\treturn inet_pton(af, src, dst);\n#else\n\tif (af == AF_INET) {\n\t\tunsigned a,b,c,d;\n\t\tchar more;\n\t\tstruct in_addr *addr = dst;\n\t\tif (sscanf(src, \"%u.%u.%u.%u%c\", &a,&b,&c,&d,&more) != 4)\n\t\t\treturn 0;\n\t\tif (a > 255) return 0;\n\t\tif (b > 255) return 0;\n\t\tif (c > 255) return 0;\n\t\tif (d > 255) return 0;\n\t\taddr->s_addr = htonl((a<<24) | (b<<16) | (c<<8) | d);\n\t\treturn 1;\n#ifdef AF_INET6\n\t} else if (af == AF_INET6) {\n\t\tstruct in6_addr *out = dst;\n\t\tev_uint16_t words[8];\n\t\tint gapPos = -1, i, setWords=0;\n\t\tconst char *dot = strchr(src, '.');\n\t\tconst char *eow; /* end of words. */\n\t\tif (dot == src)\n\t\t\treturn 0;\n\t\telse if (!dot)\n\t\t\teow = src+strlen(src);\n\t\telse {\n\t\t\tunsigned byte1,byte2,byte3,byte4;\n\t\t\tchar more;\n\t\t\tfor (eow = dot-1; eow >= src && EVUTIL_ISDIGIT_(*eow); --eow)\n\t\t\t\t;\n\t\t\t++eow;\n\n\t\t\t/* We use \"scanf\" because some platform inet_aton()s are too lax\n\t\t\t * about IPv4 addresses of the form \"1.2.3\" */\n\t\t\tif (sscanf(eow, \"%u.%u.%u.%u%c\",\n\t\t\t\t\t   &byte1,&byte2,&byte3,&byte4,&more) != 4)\n\t\t\t\treturn 0;\n\n\t\t\tif (byte1 > 255 ||\n\t\t\t    byte2 > 255 ||\n\t\t\t    byte3 > 255 ||\n\t\t\t    byte4 > 255)\n\t\t\t\treturn 0;\n\n\t\t\twords[6] = (byte1<<8) | byte2;\n\t\t\twords[7] = (byte3<<8) | byte4;\n\t\t\tsetWords += 2;\n\t\t}\n\n\t\ti = 0;\n\t\twhile (src < eow) {\n\t\t\tif (i > 7)\n\t\t\t\treturn 0;\n\t\t\tif (EVUTIL_ISXDIGIT_(*src)) {\n\t\t\t\tchar *next;\n\t\t\t\tlong r = strtol(src, &next, 16);\n\t\t\t\tif (next > 4+src)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (next == src)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (r<0 || r>65536)\n\t\t\t\t\treturn 0;\n\n\t\t\t\twords[i++] = (ev_uint16_t)r;\n\t\t\t\tsetWords++;\n\t\t\t\tsrc = next;\n\t\t\t\tif (*src != ':' && src != eow)\n\t\t\t\t\treturn 0;\n\t\t\t\t++src;\n\t\t\t} else if (*src == ':' && i > 0 && gapPos==-1) {\n\t\t\t\tgapPos = i;\n\t\t\t\t++src;\n\t\t\t} else if (*src == ':' && i == 0 && src[1] == ':' && gapPos==-1) {\n\t\t\t\tgapPos = i;\n\t\t\t\tsrc += 2;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (setWords > 8 ||\n\t\t\t(setWords == 8 && gapPos != -1) ||\n\t\t\t(setWords < 8 && gapPos == -1))\n\t\t\treturn 0;\n\n\t\tif (gapPos >= 0) {\n\t\t\tint nToMove = setWords - (dot ? 2 : 0) - gapPos;\n\t\t\tint gapLen = 8 - setWords;\n\t\t\t/* assert(nToMove >= 0); */\n\t\t\tif (nToMove < 0)\n\t\t\t\treturn -1; /* should be impossible */\n\t\t\tmemmove(&words[gapPos+gapLen], &words[gapPos],\n\t\t\t\t\tsizeof(ev_uint16_t)*nToMove);\n\t\t\tmemset(&words[gapPos], 0, sizeof(ev_uint16_t)*gapLen);\n\t\t}\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tout->s6_addr[2*i  ] = words[i] >> 8;\n\t\t\tout->s6_addr[2*i+1] = words[i] & 0xff;\n\t\t}\n\n\t\treturn 1;\n#endif\n\t} else {\n\t\treturn -1;\n\t}\n#endif\n}\n\nint\nevutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)\n{\n\tint port;\n\tchar buf[128];\n\tconst char *cp, *addr_part, *port_part;\n\tint is_ipv6;\n\t/* recognized formats are:\n\t * [ipv6]:port\n\t * ipv6\n\t * [ipv6]\n\t * ipv4:port\n\t * ipv4\n\t */\n\n\tcp = strchr(ip_as_string, ':');\n\tif (*ip_as_string == '[') {\n\t\tint len;\n\t\tif (!(cp = strchr(ip_as_string, ']'))) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen = (int) ( cp-(ip_as_string + 1) );\n\t\tif (len > (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string+1, len);\n\t\tbuf[len] = '\\0';\n\t\taddr_part = buf;\n\t\tif (cp[1] == ':')\n\t\t\tport_part = cp+2;\n\t\telse\n\t\t\tport_part = NULL;\n\t\tis_ipv6 = 1;\n\t} else if (cp && strchr(cp+1, ':')) {\n\t\tis_ipv6 = 1;\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t} else if (cp) {\n\t\tis_ipv6 = 0;\n\t\tif (cp - ip_as_string > (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string, cp-ip_as_string);\n\t\tbuf[cp-ip_as_string] = '\\0';\n\t\taddr_part = buf;\n\t\tport_part = cp+1;\n\t} else {\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t\tis_ipv6 = 0;\n\t}\n\n\tif (port_part == NULL) {\n\t\tport = 0;\n\t} else {\n\t\tport = atoi(port_part);\n\t\tif (port <= 0 || port > 65535) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!addr_part)\n\t\treturn -1; /* Should be impossible. */\n#ifdef AF_INET6\n\tif (is_ipv6)\n\t{\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&sin6, 0, sizeof(sin6));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n\t\tsin6.sin6_len = sizeof(sin6);\n#endif\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET6, addr_part, &sin6.sin6_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin6) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin6, sizeof(sin6));\n\t\t*outlen = sizeof(sin6);\n\t\treturn 0;\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&sin, 0, sizeof(sin));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n\t\tsin.sin_len = sizeof(sin);\n#endif\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET, addr_part, &sin.sin_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin, sizeof(sin));\n\t\t*outlen = sizeof(sin);\n\t\treturn 0;\n\t}\n}\n\nconst char *\nevutil_format_sockaddr_port_(const struct sockaddr *sa, char *out, size_t outlen)\n{\n\tchar b[128];\n\tconst char *res=NULL;\n\tint port;\n\tif (sa->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin = (const struct sockaddr_in*)sa;\n\t\tres = evutil_inet_ntop(AF_INET, &sin->sin_addr,b,sizeof(b));\n\t\tport = ntohs(sin->sin_port);\n\t\tif (res) {\n\t\t\tevutil_snprintf(out, outlen, \"%s:%d\", b, port);\n\t\t\treturn out;\n\t\t}\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin6 = (const struct sockaddr_in6*)sa;\n\t\tres = evutil_inet_ntop(AF_INET6, &sin6->sin6_addr,b,sizeof(b));\n\t\tport = ntohs(sin6->sin6_port);\n\t\tif (res) {\n\t\t\tevutil_snprintf(out, outlen, \"[%s]:%d\", b, port);\n\t\t\treturn out;\n\t\t}\n\t}\n\n\tevutil_snprintf(out, outlen, \"<addr with socktype %d>\",\n\t    (int)sa->sa_family);\n\treturn out;\n}\n\nint\nevutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,\n    int include_port)\n{\n\tint r;\n\tif (0 != (r = (sa1->sa_family - sa2->sa_family)))\n\t\treturn r;\n\n\tif (sa1->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin1, *sin2;\n\t\tsin1 = (const struct sockaddr_in *)sa1;\n\t\tsin2 = (const struct sockaddr_in *)sa2;\n\t\tif (sin1->sin_addr.s_addr < sin2->sin_addr.s_addr)\n\t\t\treturn -1;\n\t\telse if (sin1->sin_addr.s_addr > sin2->sin_addr.s_addr)\n\t\t\treturn 1;\n\t\telse if (include_port &&\n\t\t    (r = ((int)sin1->sin_port - (int)sin2->sin_port)))\n\t\t\treturn r;\n\t\telse\n\t\t\treturn 0;\n\t}\n#ifdef AF_INET6\n\telse if (sa1->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin1, *sin2;\n\t\tsin1 = (const struct sockaddr_in6 *)sa1;\n\t\tsin2 = (const struct sockaddr_in6 *)sa2;\n\t\tif ((r = memcmp(sin1->sin6_addr.s6_addr, sin2->sin6_addr.s6_addr, 16)))\n\t\t\treturn r;\n\t\telse if (include_port &&\n\t\t    (r = ((int)sin1->sin6_port - (int)sin2->sin6_port)))\n\t\t\treturn r;\n\t\telse\n\t\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}\n\n/* Tables to implement ctypes-replacement EVUTIL_IS*() functions.  Each table\n * has 256 bits to look up whether a character is in some set or not.  This\n * fails on non-ASCII platforms, but so does every other place where we\n * take a char and write it onto the network.\n **/\nstatic const ev_uint32_t EVUTIL_ISALPHA_TABLE[8] =\n  { 0, 0, 0x7fffffe, 0x7fffffe, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISALNUM_TABLE[8] =\n  { 0, 0x3ff0000, 0x7fffffe, 0x7fffffe, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISSPACE_TABLE[8] = { 0x3e00, 0x1, 0, 0, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISXDIGIT_TABLE[8] =\n  { 0, 0x3ff0000, 0x7e, 0x7e, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISDIGIT_TABLE[8] = { 0, 0x3ff0000, 0, 0, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISPRINT_TABLE[8] =\n  { 0, 0xffffffff, 0xffffffff, 0x7fffffff, 0, 0, 0, 0x0 };\nstatic const ev_uint32_t EVUTIL_ISUPPER_TABLE[8] = { 0, 0, 0x7fffffe, 0, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISLOWER_TABLE[8] = { 0, 0, 0, 0x7fffffe, 0, 0, 0, 0 };\n/* Upper-casing and lowercasing tables to map characters to upper/lowercase\n * equivalents. */\nstatic const unsigned char EVUTIL_TOUPPER_TABLE[256] = {\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,\n  80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,\n  96,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,\n  80,81,82,83,84,85,86,87,88,89,90,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,\n};\nstatic const unsigned char EVUTIL_TOLOWER_TABLE[256] = {\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,120,121,122,91,92,93,94,95,\n  96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,\n};\n\n#define IMPL_CTYPE_FN(name)\t\t\t\t\t\t\\\n\tint EVUTIL_##name##_(char c) {\t\t\t\t\t\\\n\t\tev_uint8_t u = c;\t\t\t\t\t\\\n\t\treturn !!(EVUTIL_##name##_TABLE[(u >> 5) & 7] & (1 << (u & 31))); \\\n\t}\nIMPL_CTYPE_FN(ISALPHA)\nIMPL_CTYPE_FN(ISALNUM)\nIMPL_CTYPE_FN(ISSPACE)\nIMPL_CTYPE_FN(ISDIGIT)\nIMPL_CTYPE_FN(ISXDIGIT)\nIMPL_CTYPE_FN(ISPRINT)\nIMPL_CTYPE_FN(ISLOWER)\nIMPL_CTYPE_FN(ISUPPER)\n\nchar EVUTIL_TOLOWER_(char c)\n{\n\treturn ((char)EVUTIL_TOLOWER_TABLE[(ev_uint8_t)c]);\n}\nchar EVUTIL_TOUPPER_(char c)\n{\n\treturn ((char)EVUTIL_TOUPPER_TABLE[(ev_uint8_t)c]);\n}\nint\nevutil_ascii_strcasecmp(const char *s1, const char *s2)\n{\n\tchar c1, c2;\n\twhile (1) {\n\t\tc1 = EVUTIL_TOLOWER_(*s1++);\n\t\tc2 = EVUTIL_TOLOWER_(*s2++);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\telse if (c1 > c2)\n\t\t\treturn 1;\n\t\telse if (c1 == 0)\n\t\t\treturn 0;\n\t}\n}\nint evutil_ascii_strncasecmp(const char *s1, const char *s2, size_t n)\n{\n\tchar c1, c2;\n\twhile (n--) {\n\t\tc1 = EVUTIL_TOLOWER_(*s1++);\n\t\tc2 = EVUTIL_TOLOWER_(*s2++);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\telse if (c1 > c2)\n\t\t\treturn 1;\n\t\telse if (c1 == 0)\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nvoid\nevutil_rtrim_lws_(char *str)\n{\n\tchar *cp;\n\n\tif (str == NULL)\n\t\treturn;\n\n\tif ((cp = strchr(str, '\\0')) == NULL || (cp == str))\n\t\treturn;\n\n\t--cp;\n\n\twhile (*cp == ' ' || *cp == '\\t') {\n\t\t*cp = '\\0';\n\t\tif (cp == str)\n\t\t\tbreak;\n\t\t--cp;\n\t}\n}\n\nstatic int\nevutil_issetugid(void)\n{\n#ifdef EVENT__HAVE_ISSETUGID\n\treturn issetugid();\n#else\n\n#ifdef EVENT__HAVE_GETEUID\n\tif (getuid() != geteuid())\n\t\treturn 1;\n#endif\n#ifdef EVENT__HAVE_GETEGID\n\tif (getgid() != getegid())\n\t\treturn 1;\n#endif\n\treturn 0;\n#endif\n}\n\nconst char *\nevutil_getenv_(const char *varname)\n{\n\tif (evutil_issetugid())\n\t\treturn NULL;\n\n\treturn getenv(varname);\n}\n\nev_uint32_t\nevutil_weakrand_seed_(struct evutil_weakrand_state *state, ev_uint32_t seed)\n{\n\tif (seed == 0) {\n\t\tstruct timeval tv;\n\t\tevutil_gettimeofday(&tv, NULL);\n\t\tseed = (ev_uint32_t)tv.tv_sec + (ev_uint32_t)tv.tv_usec;\n#ifdef _WIN32\n\t\tseed += (ev_uint32_t) _getpid();\n#else\n\t\tseed += (ev_uint32_t) getpid();\n#endif\n\t}\n\tstate->seed = seed;\n\treturn seed;\n}\n\nev_int32_t\nevutil_weakrand_(struct evutil_weakrand_state *state)\n{\n\t/* This RNG implementation is a linear congruential generator, with\n\t * modulus 2^31, multiplier 1103515245, and addend 12345.  It's also\n\t * used by OpenBSD, and by Glibc's TYPE_0 RNG.\n\t *\n\t * The linear congruential generator is not an industrial-strength\n\t * RNG!  It's fast, but it can have higher-order patterns.  Notably,\n\t * the low bits tend to have periodicity.\n\t */\n\tstate->seed = ((state->seed) * 1103515245 + 12345) & 0x7fffffff;\n\treturn (ev_int32_t)(state->seed);\n}\n\nev_int32_t\nevutil_weakrand_range_(struct evutil_weakrand_state *state, ev_int32_t top)\n{\n\tev_int32_t divisor, result;\n\n\t/* We can't just do weakrand() % top, since the low bits of the LCG\n\t * are less random than the high ones.  (Specifically, since the LCG\n\t * modulus is 2^N, every 2^m for m<N will divide the modulus, and so\n\t * therefore the low m bits of the LCG will have period 2^m.) */\n\tdivisor = EVUTIL_WEAKRAND_MAX / top;\n\tdo {\n\t\tresult = evutil_weakrand_(state) / divisor;\n\t} while (result >= top);\n\treturn result;\n}\n\n/**\n * Volatile pointer to memset: we use this to keep the compiler from\n * eliminating our call to memset.\n */\nvoid * (*volatile evutil_memset_volatile_)(void *, int, size_t) = memset;\n\nvoid\nevutil_memclear_(void *mem, size_t len)\n{\n\tevutil_memset_volatile_(mem, 0, len);\n}\n\nint\nevutil_sockaddr_is_loopback_(const struct sockaddr *addr)\n{\n\tstatic const char LOOPBACK_S6[16] =\n\t    \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\";\n\tif (addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)addr;\n\t\treturn (ntohl(sin->sin_addr.s_addr) & 0xff000000) == 0x7f000000;\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;\n\t\treturn !memcmp(sin6->sin6_addr.s6_addr, LOOPBACK_S6, 16);\n\t}\n\treturn 0;\n}\n\nint\nevutil_hex_char_to_int_(char c)\n{\n\tswitch(c)\n\t{\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'A': case 'a': return 10;\n\t\tcase 'B': case 'b': return 11;\n\t\tcase 'C': case 'c': return 12;\n\t\tcase 'D': case 'd': return 13;\n\t\tcase 'E': case 'e': return 14;\n\t\tcase 'F': case 'f': return 15;\n\t}\n\treturn -1;\n}\n\n#ifdef _WIN32\nHMODULE\nevutil_load_windows_system_library_(const TCHAR *library_name)\n{\n  TCHAR path[MAX_PATH];\n  unsigned n;\n  n = GetSystemDirectory(path, MAX_PATH);\n  if (n == 0 || n + _tcslen(library_name) + 2 >= MAX_PATH)\n    return 0;\n  _tcscat(path, TEXT(\"\\\\\"));\n  _tcscat(path, library_name);\n  return LoadLibrary(path);\n}\n#endif\n\n/* Internal wrapper around 'socket' to provide Linux-style support for\n * syscall-saving methods where available.\n *\n * In addition to regular socket behavior, you can use a bitwise or to set the\n * flags EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'type' argument,\n * to make the socket nonblocking or close-on-exec with as few syscalls as\n * possible.\n */\nevutil_socket_t\nevutil_socket_(int domain, int type, int protocol)\n{\n\tevutil_socket_t r;\n#if defined(SOCK_NONBLOCK) && defined(SOCK_CLOEXEC)\n\tr = socket(domain, type, protocol);\n\tif (r >= 0)\n\t\treturn r;\n\telse if ((type & (SOCK_NONBLOCK|SOCK_CLOEXEC)) == 0)\n\t\treturn -1;\n#endif\n#define SOCKET_TYPE_MASK (~(EVUTIL_SOCK_NONBLOCK|EVUTIL_SOCK_CLOEXEC))\n\tr = socket(domain, type & SOCKET_TYPE_MASK, protocol);\n\tif (r < 0)\n\t\treturn -1;\n\tif (type & EVUTIL_SOCK_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (type & EVUTIL_SOCK_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn r;\n}\n\n/* Internal wrapper around 'accept' or 'accept4' to provide Linux-style\n * support for syscall-saving methods where available.\n *\n * In addition to regular accept behavior, you can set one or more of flags\n * EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'flags' argument, to\n * make the socket nonblocking or close-on-exec with as few syscalls as\n * possible.\n */\nevutil_socket_t\nevutil_accept4_(evutil_socket_t sockfd, struct sockaddr *addr,\n    ev_socklen_t *addrlen, int flags)\n{\n\tevutil_socket_t result;\n#if defined(EVENT__HAVE_ACCEPT4) && defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)\n\tresult = accept4(sockfd, addr, addrlen, flags);\n\tif (result >= 0 || (errno != EINVAL && errno != ENOSYS)) {\n\t\t/* A nonnegative result means that we succeeded, so return.\n\t\t * Failing with EINVAL means that an option wasn't supported,\n\t\t * and failing with ENOSYS means that the syscall wasn't\n\t\t * there: in those cases we want to fall back.  Otherwise, we\n\t\t * got a real error, and we should return. */\n\t\treturn result;\n\t}\n#endif\n\tresult = accept(sockfd, addr, addrlen);\n\tif (result < 0)\n\t\treturn result;\n\n\tif (flags & EVUTIL_SOCK_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(result) < 0) {\n\t\t\tevutil_closesocket(result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & EVUTIL_SOCK_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(result) < 0) {\n\t\t\tevutil_closesocket(result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn result;\n}\n\n/* Internal function: Set fd[0] and fd[1] to a pair of fds such that writes on\n * fd[0] get read from fd[1].  Make both fds nonblocking and close-on-exec.\n * Return 0 on success, -1 on failure.\n */\nint\nevutil_make_internal_pipe_(evutil_socket_t fd[2])\n{\n\t/*\n\t  Making the second socket nonblocking is a bit subtle, given that we\n\t  ignore any EAGAIN returns when writing to it, and you don't usally\n\t  do that for a nonblocking socket. But if the kernel gives us EAGAIN,\n\t  then there's no need to add any more data to the buffer, since\n\t  the main thread is already either about to wake up and drain it,\n\t  or woken up and in the process of draining it.\n\t*/\n\n#if defined(EVENT__HAVE_PIPE2)\n\tif (pipe2(fd, O_NONBLOCK|O_CLOEXEC) == 0)\n\t\treturn 0;\n#endif\n#if defined(EVENT__HAVE_PIPE)\n\tif (pipe(fd) == 0) {\n\t\tif (evutil_fast_socket_nonblocking(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_nonblocking(fd[1]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[1]) < 0) {\n\t\t\tclose(fd[0]);\n\t\t\tclose(fd[1]);\n\t\t\tfd[0] = fd[1] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tevent_warn(\"%s: pipe\", __func__);\n\t}\n#endif\n\n#ifdef _WIN32\n#define LOCAL_SOCKETPAIR_AF AF_INET\n#else\n#define LOCAL_SOCKETPAIR_AF AF_UNIX\n#endif\n\tif (evutil_socketpair(LOCAL_SOCKETPAIR_AF, SOCK_STREAM, 0, fd) == 0) {\n\t\tif (evutil_fast_socket_nonblocking(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_nonblocking(fd[1]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[1]) < 0) {\n\t\t\tevutil_closesocket(fd[0]);\n\t\t\tevutil_closesocket(fd[1]);\n\t\t\tfd[0] = fd[1] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tfd[0] = fd[1] = -1;\n\treturn -1;\n}\n\n/* Wrapper around eventfd on systems that provide it.  Unlike the system\n * eventfd, it always supports EVUTIL_EFD_CLOEXEC and EVUTIL_EFD_NONBLOCK as\n * flags.  Returns -1 on error or if eventfd is not supported.\n */\nevutil_socket_t\nevutil_eventfd_(unsigned initval, int flags)\n{\n#if defined(EVENT__HAVE_EVENTFD) && defined(EVENT__HAVE_SYS_EVENTFD_H)\n\tint r;\n#if defined(EFD_CLOEXEC) && defined(EFD_NONBLOCK)\n\tr = eventfd(initval, flags);\n\tif (r >= 0 || flags == 0)\n\t\treturn r;\n#endif\n\tr = eventfd(initval, 0);\n\tif (r < 0)\n\t\treturn r;\n\tif (flags & EVUTIL_EFD_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & EVUTIL_EFD_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn r;\n#else\n\treturn -1;\n#endif\n}\n\nvoid\nevutil_free_globals_(void)\n{\n\tevutil_free_secure_rng_globals_();\n\tevutil_free_sock_err_globals();\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"event2/event-config.h\"\n#include \"evconfig-private.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#undef WIN32_LEAN_AND_MEAN\n#include <io.h>\n#include <tchar.h>\n#include <process.h>\n#undef _WIN32_WINNT\n/* For structs needed by GetAdaptersAddresses */\n#define _WIN32_WINNT 0x0501\n#include <iphlpapi.h>\n#endif\n\n#include <sys/types.h>\n#ifdef EVENT__HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef EVENT__HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef EVENT__HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef EVENT__HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#ifdef EVENT__HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef EVENT__HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n#ifdef EVENT__HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>\n#endif\n#ifdef EVENT__HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#include <time.h>\n#include <sys/stat.h>\n#ifdef EVENT__HAVE_IFADDRS_H\n#include <ifaddrs.h>\n#endif\n\n#include \"event2/util.h\"\n#include \"util-internal.h\"\n#include \"log-internal.h\"\n#include \"mm-internal.h\"\n#include \"evthread-internal.h\"\n\n#include \"strlcpy-internal.h\"\n#include \"ipv6-internal.h\"\n\n#ifdef _WIN32\n#define HT_NO_CACHE_HASH_VALUES\n#include \"ht-internal.h\"\n#define open _open\n#define read _read\n#define close _close\n#ifndef fstat\n#define fstat _fstati64\n#endif\n#ifndef stat\n#define stat _stati64\n#endif\n#define mode_t int\n#endif\n\nint\nevutil_open_closeonexec_(const char *pathname, int flags, unsigned mode)\n{\n\tint fd;\n\n#ifdef O_CLOEXEC\n\tfd = open(pathname, flags|O_CLOEXEC, (mode_t)mode);\n\tif (fd >= 0 || errno == EINVAL)\n\t\treturn fd;\n\t/* If we got an EINVAL, fall through and try without O_CLOEXEC */\n#endif\n\tfd = open(pathname, flags, (mode_t)mode);\n\tif (fd < 0)\n\t\treturn -1;\n\n#if defined(FD_CLOEXEC)\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\treturn fd;\n}\n\n/**\n   Read the contents of 'filename' into a newly allocated NUL-terminated\n   string.  Set *content_out to hold this string, and *len_out to hold its\n   length (not including the appended NUL).  If 'is_binary', open the file in\n   binary mode.\n\n   Returns 0 on success, -1 if the open fails, and -2 for all other failures.\n\n   Used internally only; may go away in a future version.\n */\nint\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)\n{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}\n\nint\nevutil_socketpair(int family, int type, int protocol, evutil_socket_t fd[2])\n{\n#ifndef _WIN32\n\treturn socketpair(family, type, protocol, fd);\n#else\n\treturn evutil_ersatz_socketpair_(family, type, protocol, fd);\n#endif\n}\n\nint\nevutil_ersatz_socketpair_(int family, int type, int protocol,\n    evutil_socket_t fd[2])\n{\n\t/* This code is originally from Tor.  Used with permission. */\n\n\t/* This socketpair does not work when localhost is down. So\n\t * it's really not the same thing at all. But it's close enough\n\t * for now, and really, when localhost is down sometimes, we\n\t * have other problems too.\n\t */\n#ifdef _WIN32\n#define ERR(e) WSA##e\n#else\n#define ERR(e) e\n#endif\n\tevutil_socket_t listener = -1;\n\tevutil_socket_t connector = -1;\n\tevutil_socket_t acceptor = -1;\n\tstruct sockaddr_in listen_addr;\n\tstruct sockaddr_in connect_addr;\n\tev_socklen_t size;\n\tint saved_errno = -1;\n\tint family_test;\n\t\n\tfamily_test = family != AF_INET;\n#ifdef AF_UNIX\n\tfamily_test = family_test && (family != AF_UNIX);\n#endif\n\tif (protocol || family_test) {\n\t\tEVUTIL_SET_SOCKET_ERROR(ERR(EAFNOSUPPORT));\n\t\treturn -1;\n\t}\n\t\n\tif (!fd) {\n\t\tEVUTIL_SET_SOCKET_ERROR(ERR(EINVAL));\n\t\treturn -1;\n\t}\n\n\tlistener = socket(AF_INET, type, 0);\n\tif (listener < 0)\n\t\treturn -1;\n\tmemset(&listen_addr, 0, sizeof(listen_addr));\n\tlisten_addr.sin_family = AF_INET;\n\tlisten_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tlisten_addr.sin_port = 0;\t/* kernel chooses port.\t */\n\tif (bind(listener, (struct sockaddr *) &listen_addr, sizeof (listen_addr))\n\t\t== -1)\n\t\tgoto tidy_up_and_fail;\n\tif (listen(listener, 1) == -1)\n\t\tgoto tidy_up_and_fail;\n\n\tconnector = socket(AF_INET, type, 0);\n\tif (connector < 0)\n\t\tgoto tidy_up_and_fail;\n\n\tmemset(&connect_addr, 0, sizeof(connect_addr));\n\n\t/* We want to find out the port number to connect to.  */\n\tsize = sizeof(connect_addr);\n\tif (getsockname(listener, (struct sockaddr *) &connect_addr, &size) == -1)\n\t\tgoto tidy_up_and_fail;\n\tif (size != sizeof (connect_addr))\n\t\tgoto abort_tidy_up_and_fail;\n\tif (connect(connector, (struct sockaddr *) &connect_addr,\n\t\t\t\tsizeof(connect_addr)) == -1)\n\t\tgoto tidy_up_and_fail;\n\n\tsize = sizeof(listen_addr);\n\tacceptor = accept(listener, (struct sockaddr *) &listen_addr, &size);\n\tif (acceptor < 0)\n\t\tgoto tidy_up_and_fail;\n\tif (size != sizeof(listen_addr))\n\t\tgoto abort_tidy_up_and_fail;\n\t/* Now check we are talking to ourself by matching port and host on the\n\t   two sockets.\t */\n\tif (getsockname(connector, (struct sockaddr *) &connect_addr, &size) == -1)\n\t\tgoto tidy_up_and_fail;\n\tif (size != sizeof (connect_addr)\n\t\t|| listen_addr.sin_family != connect_addr.sin_family\n\t\t|| listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr\n\t\t|| listen_addr.sin_port != connect_addr.sin_port)\n\t\tgoto abort_tidy_up_and_fail;\n\tevutil_closesocket(listener);\n\tfd[0] = connector;\n\tfd[1] = acceptor;\n\n\treturn 0;\n\n abort_tidy_up_and_fail:\n\tsaved_errno = ERR(ECONNABORTED);\n tidy_up_and_fail:\n\tif (saved_errno < 0)\n\t\tsaved_errno = EVUTIL_SOCKET_ERROR();\n\tif (listener != -1)\n\t\tevutil_closesocket(listener);\n\tif (connector != -1)\n\t\tevutil_closesocket(connector);\n\tif (acceptor != -1)\n\t\tevutil_closesocket(acceptor);\n\n\tEVUTIL_SET_SOCKET_ERROR(saved_errno);\n\treturn -1;\n#undef ERR\n}\n\nint\nevutil_make_socket_nonblocking(evutil_socket_t fd)\n{\n#ifdef _WIN32\n\t{\n\t\tunsigned long nonblocking = 1;\n\t\tif (ioctlsocket(fd, FIONBIO, &nonblocking) == SOCKET_ERROR) {\n\t\t\tevent_sock_warn(fd, \"fcntl(%d, F_GETFL)\", (int)fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n#else\n\t{\n\t\tint flags;\n\t\tif ((flags = fcntl(fd, F_GETFL, NULL)) < 0) {\n\t\t\tevent_warn(\"fcntl(%d, F_GETFL)\", fd);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(flags & O_NONBLOCK)) {\n\t\t\tif (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n\t\t\t\tevent_warn(\"fcntl(%d, F_SETFL)\", fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n/* Faster version of evutil_make_socket_nonblocking for internal use.\n *\n * Requires that no F_SETFL flags were previously set on the fd.\n */\nstatic int\nevutil_fast_socket_nonblocking(evutil_socket_t fd)\n{\n#ifdef _WIN32\n\treturn evutil_make_socket_nonblocking(fd);\n#else\n\tif (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {\n\t\tevent_warn(\"fcntl(%d, F_SETFL)\", fd);\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}\n\nint\nevutil_make_listen_socket_reuseable(evutil_socket_t sock)\n{\n#if defined(SO_REUSEADDR) && !defined(_WIN32)\n\tint one = 1;\n\t/* REUSEADDR on Unix means, \"don't hang on to this address after the\n\t * listener is closed.\"  On Windows, though, it means \"don't keep other\n\t * processes from binding to this address while we're using it. */\n\treturn setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*) &one,\n\t    (ev_socklen_t)sizeof(one));\n#else\n\treturn 0;\n#endif\n}\n\nint\nevutil_make_listen_socket_reuseable_port(evutil_socket_t sock)\n{\n#if defined __linux__ && defined(SO_REUSEPORT)\n\tint one = 1;\n\t/* REUSEPORT on Linux 3.9+ means, \"Multiple servers (processes or\n\t * threads) can bind to the same port if they each set the option. */\n\treturn setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, (void*) &one,\n\t    (ev_socklen_t)sizeof(one));\n#else\n\treturn 0;\n#endif\n}\n\nint\nevutil_make_tcp_listen_socket_deferred(evutil_socket_t sock)\n{\n#if defined(EVENT__HAVE_NETINET_TCP_H) && defined(TCP_DEFER_ACCEPT)\n\tint one = 1;\n\n\t/* TCP_DEFER_ACCEPT tells the kernel to call defer accept() only after data\n\t * has arrived and ready to read */ \n\treturn setsockopt(sock, IPPROTO_TCP, TCP_DEFER_ACCEPT, &one,\n\t\t(ev_socklen_t)sizeof(one)); \n#endif\n\treturn 0;\n}\n\nint\nevutil_make_socket_closeonexec(evutil_socket_t fd)\n{\n#if !defined(_WIN32) && defined(EVENT__HAVE_SETFD)\n\tint flags;\n\tif ((flags = fcntl(fd, F_GETFD, NULL)) < 0) {\n\t\tevent_warn(\"fcntl(%d, F_GETFD)\", fd);\n\t\treturn -1;\n\t}\n\tif (!(flags & FD_CLOEXEC)) {\n\t\tif (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1) {\n\t\t\tevent_warn(\"fcntl(%d, F_SETFD)\", fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n/* Faster version of evutil_make_socket_closeonexec for internal use.\n *\n * Requires that no F_SETFD flags were previously set on the fd.\n */\nstatic int\nevutil_fast_socket_closeonexec(evutil_socket_t fd)\n{\n#if !defined(_WIN32) && defined(EVENT__HAVE_SETFD)\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {\n\t\tevent_warn(\"fcntl(%d, F_SETFD)\", fd);\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}\n\nint\nevutil_closesocket(evutil_socket_t sock)\n{\n#ifndef _WIN32\n\treturn close(sock);\n#else\n\treturn closesocket(sock);\n#endif\n}\n\nev_int64_t\nevutil_strtoll(const char *s, char **endptr, int base)\n{\n#ifdef EVENT__HAVE_STRTOLL\n\treturn (ev_int64_t)strtoll(s, endptr, base);\n#elif EVENT__SIZEOF_LONG == 8\n\treturn (ev_int64_t)strtol(s, endptr, base);\n#elif defined(_WIN32) && defined(_MSC_VER) && _MSC_VER < 1300\n\t/* XXXX on old versions of MS APIs, we only support base\n\t * 10. */\n\tev_int64_t r;\n\tif (base != 10)\n\t\treturn 0;\n\tr = (ev_int64_t) _atoi64(s);\n\twhile (isspace(*s))\n\t\t++s;\n\tif (*s == '-')\n\t\t++s;\n\twhile (isdigit(*s))\n\t\t++s;\n\tif (endptr)\n\t\t*endptr = (char*) s;\n\treturn r;\n#elif defined(_WIN32)\n\treturn (ev_int64_t) _strtoi64(s, endptr, base);\n#elif defined(EVENT__SIZEOF_LONG_LONG) && EVENT__SIZEOF_LONG_LONG == 8\n\tlong long r;\n\tint n;\n\tif (base != 10 && base != 16)\n\t\treturn 0;\n\tif (base == 10) {\n\t\tn = sscanf(s, \"%lld\", &r);\n\t} else {\n\t\tunsigned long long ru=0;\n\t\tn = sscanf(s, \"%llx\", &ru);\n\t\tif (ru > EV_INT64_MAX)\n\t\t\treturn 0;\n\t\tr = (long long) ru;\n\t}\n\tif (n != 1)\n\t\treturn 0;\n\twhile (EVUTIL_ISSPACE_(*s))\n\t\t++s;\n\tif (*s == '-')\n\t\t++s;\n\tif (base == 10) {\n\t\twhile (EVUTIL_ISDIGIT_(*s))\n\t\t\t++s;\n\t} else {\n\t\twhile (EVUTIL_ISXDIGIT_(*s))\n\t\t\t++s;\n\t}\n\tif (endptr)\n\t\t*endptr = (char*) s;\n\treturn r;\n#else\n#error \"I don't know how to parse 64-bit integers.\"\n#endif\n}\n\n#ifdef _WIN32\nint\nevutil_socket_geterror(evutil_socket_t sock)\n{\n\tint optval, optvallen=sizeof(optval);\n\tint err = WSAGetLastError();\n\tif (err == WSAEWOULDBLOCK && sock >= 0) {\n\t\tif (getsockopt(sock, SOL_SOCKET, SO_ERROR, (void*)&optval,\n\t\t\t\t\t   &optvallen))\n\t\t\treturn err;\n\t\tif (optval)\n\t\t\treturn optval;\n\t}\n\treturn err;\n}\n#endif\n\n/* XXX we should use an enum here. */\n/* 2 for connection refused, 1 for connected, 0 for not yet, -1 for error. */\nint\nevutil_socket_connect_(evutil_socket_t *fd_ptr, const struct sockaddr *sa, int socklen)\n{\n\tint made_fd = 0;\n\n\tif (*fd_ptr < 0) {\n\t\tif ((*fd_ptr = socket(sa->sa_family, SOCK_STREAM, 0)) < 0)\n\t\t\tgoto err;\n\t\tmade_fd = 1;\n\t\tif (evutil_make_socket_nonblocking(*fd_ptr) < 0) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (connect(*fd_ptr, sa, socklen) < 0) {\n\t\tint e = evutil_socket_geterror(*fd_ptr);\n\t\tif (EVUTIL_ERR_CONNECT_RETRIABLE(e))\n\t\t\treturn 0;\n\t\tif (EVUTIL_ERR_CONNECT_REFUSED(e))\n\t\t\treturn 2;\n\t\tgoto err;\n\t} else {\n\t\treturn 1;\n\t}\n\nerr:\n\tif (made_fd) {\n\t\tevutil_closesocket(*fd_ptr);\n\t\t*fd_ptr = -1;\n\t}\n\treturn -1;\n}\n\n/* Check whether a socket on which we called connect() is done\n   connecting. Return 1 for connected, 0 for not yet, -1 for error.  In the\n   error case, set the current socket errno to the error that happened during\n   the connect operation. */\nint\nevutil_socket_finished_connecting_(evutil_socket_t fd)\n{\n\tint e;\n\tev_socklen_t elen = sizeof(e);\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&e, &elen) < 0)\n\t\treturn -1;\n\n\tif (e) {\n\t\tif (EVUTIL_ERR_CONNECT_RETRIABLE(e))\n\t\t\treturn 0;\n\t\tEVUTIL_SET_SOCKET_ERROR(e);\n\t\treturn -1;\n\t}\n\n\treturn 1;\n}\n\n#if (EVUTIL_AI_PASSIVE|EVUTIL_AI_CANONNAME|EVUTIL_AI_NUMERICHOST| \\\n     EVUTIL_AI_NUMERICSERV|EVUTIL_AI_V4MAPPED|EVUTIL_AI_ALL| \\\n     EVUTIL_AI_ADDRCONFIG) != \\\n    (EVUTIL_AI_PASSIVE^EVUTIL_AI_CANONNAME^EVUTIL_AI_NUMERICHOST^ \\\n     EVUTIL_AI_NUMERICSERV^EVUTIL_AI_V4MAPPED^EVUTIL_AI_ALL^ \\\n     EVUTIL_AI_ADDRCONFIG)\n#error \"Some of our EVUTIL_AI_* flags seem to overlap with system AI_* flags\"\n#endif\n\n/* We sometimes need to know whether we have an ipv4 address and whether we\n   have an ipv6 address. If 'have_checked_interfaces', then we've already done\n   the test.  If 'had_ipv4_address', then it turns out we had an ipv4 address.\n   If 'had_ipv6_address', then it turns out we had an ipv6 address.   These are\n   set by evutil_check_interfaces. */\nstatic int have_checked_interfaces, had_ipv4_address, had_ipv6_address;\n\n/* Macro: True iff the IPv4 address 'addr', in host order, is in 127.0.0.0/8\n */\n#define EVUTIL_V4ADDR_IS_LOCALHOST(addr) (((addr)>>24) == 127)\n\n/* Macro: True iff the IPv4 address 'addr', in host order, is a class D\n * (multiclass) address.\n */\n#define EVUTIL_V4ADDR_IS_CLASSD(addr) ((((addr)>>24) & 0xf0) == 0xe0)\n\nstatic void\nevutil_found_ifaddr(const struct sockaddr *sa)\n{\n\tconst char ZEROES[] = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n\n\tif (sa->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\t\tev_uint32_t addr = ntohl(sin->sin_addr.s_addr);\n\t\tif (addr == 0 ||\n\t\t    EVUTIL_V4ADDR_IS_LOCALHOST(addr) ||\n\t\t    EVUTIL_V4ADDR_IS_CLASSD(addr)) {\n\t\t\t/* Not actually a usable external address. */\n\t\t} else {\n\t\t\tevent_debug((\"Detected an IPv4 interface\"));\n\t\t\thad_ipv4_address = 1;\n\t\t}\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\n\t\tconst unsigned char *addr =\n\t\t    (unsigned char*)sin6->sin6_addr.s6_addr;\n\t\tif (!memcmp(addr, ZEROES, 8) ||\n\t\t    ((addr[0] & 0xfe) == 0xfc) ||\n\t\t    (addr[0] == 0xfe && (addr[1] & 0xc0) == 0x80) ||\n\t\t    (addr[0] == 0xfe && (addr[1] & 0xc0) == 0xc0) ||\n\t\t    (addr[0] == 0xff)) {\n\t\t\t/* This is a reserved, ipv4compat, ipv4map, loopback,\n\t\t\t * link-local, multicast, or unspecified address. */\n\t\t} else {\n\t\t\tevent_debug((\"Detected an IPv6 interface\"));\n\t\t\thad_ipv6_address = 1;\n\t\t}\n\t}\n}\n\n#ifdef _WIN32\ntypedef ULONG (WINAPI *GetAdaptersAddresses_fn_t)(\n              ULONG, ULONG, PVOID, PIP_ADAPTER_ADDRESSES, PULONG);\n#endif\n\nstatic int\nevutil_check_ifaddrs(void)\n{\n#if defined(EVENT__HAVE_GETIFADDRS)\n\t/* Most free Unixy systems provide getifaddrs, which gives us a linked list\n\t * of struct ifaddrs. */\n\tstruct ifaddrs *ifa = NULL;\n\tconst struct ifaddrs *i;\n\tif (getifaddrs(&ifa) < 0) {\n\t\tevent_warn(\"Unable to call getifaddrs()\");\n\t\treturn -1;\n\t}\n\n\tfor (i = ifa; i; i = i->ifa_next) {\n\t\tif (!i->ifa_addr)\n\t\t\tcontinue;\n\t\tevutil_found_ifaddr(i->ifa_addr);\n\t}\n\n\tfreeifaddrs(ifa);\n\treturn 0;\n#elif defined(_WIN32)\n\t/* Windows XP began to provide GetAdaptersAddresses. Windows 2000 had a\n\t   \"GetAdaptersInfo\", but that's deprecated; let's just try\n\t   GetAdaptersAddresses and fall back to connect+getsockname.\n\t*/\n\tHMODULE lib = evutil_load_windows_system_library_(TEXT(\"ihplapi.dll\"));\n\tGetAdaptersAddresses_fn_t fn;\n\tULONG size, res;\n\tIP_ADAPTER_ADDRESSES *addresses = NULL, *address;\n\tint result = -1;\n\n#define FLAGS (GAA_FLAG_SKIP_ANYCAST | \\\n               GAA_FLAG_SKIP_MULTICAST | \\\n               GAA_FLAG_SKIP_DNS_SERVER)\n\n\tif (!lib)\n\t\tgoto done;\n\n\tif (!(fn = (GetAdaptersAddresses_fn_t) GetProcAddress(lib, \"GetAdaptersAddresses\")))\n\t\tgoto done;\n\n\t/* Guess how much space we need. */\n\tsize = 15*1024;\n\taddresses = mm_malloc(size);\n\tif (!addresses)\n\t\tgoto done;\n\tres = fn(AF_UNSPEC, FLAGS, NULL, addresses, &size);\n\tif (res == ERROR_BUFFER_OVERFLOW) {\n\t\t/* we didn't guess that we needed enough space; try again */\n\t\tmm_free(addresses);\n\t\taddresses = mm_malloc(size);\n\t\tif (!addresses)\n\t\t\tgoto done;\n\t\tres = fn(AF_UNSPEC, FLAGS, NULL, addresses, &size);\n\t}\n\tif (res != NO_ERROR)\n\t\tgoto done;\n\n\tfor (address = addresses; address; address = address->Next) {\n\t\tIP_ADAPTER_UNICAST_ADDRESS *a;\n\t\tfor (a = address->FirstUnicastAddress; a; a = a->Next) {\n\t\t\t/* Yes, it's a linked list inside a linked list */\n\t\t\tstruct sockaddr *sa = a->Address.lpSockaddr;\n\t\t\tevutil_found_ifaddr(sa);\n\t\t}\n\t}\n\n\tresult = 0;\ndone:\n\tif (lib)\n\t\tFreeLibrary(lib);\n\tif (addresses)\n\t\tmm_free(addresses);\n\treturn result;\n#else\n\treturn -1;\n#endif\n}\n\n/* Test whether we have an ipv4 interface and an ipv6 interface.  Return 0 if\n * the test seemed successful. */\nstatic int\nevutil_check_interfaces(int force_recheck)\n{\n\tevutil_socket_t fd = -1;\n\tstruct sockaddr_in sin, sin_out;\n\tstruct sockaddr_in6 sin6, sin6_out;\n\tev_socklen_t sin_out_len = sizeof(sin_out);\n\tev_socklen_t sin6_out_len = sizeof(sin6_out);\n\tint r;\n\tif (have_checked_interfaces && !force_recheck)\n\t\treturn 0;\n\n\tif (evutil_check_ifaddrs() == 0) {\n\t\t/* Use a nice sane interface, if this system has one. */\n\t\treturn 0;\n\t}\n\n\t/* Ugh. There was no nice sane interface.  So to check whether we have\n\t * an interface open for a given protocol, will try to make a UDP\n\t * 'connection' to a remote host on the internet.  We don't actually\n\t * use it, so the address doesn't matter, but we want to pick one that\n\t * keep us from using a host- or link-local interface. */\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(53);\n\tr = evutil_inet_pton(AF_INET, \"18.244.0.188\", &sin.sin_addr);\n\tEVUTIL_ASSERT(r);\n\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = htons(53);\n\tr = evutil_inet_pton(AF_INET6, \"2001:4860:b002::68\", &sin6.sin6_addr);\n\tEVUTIL_ASSERT(r);\n\n\tmemset(&sin_out, 0, sizeof(sin_out));\n\tmemset(&sin6_out, 0, sizeof(sin6_out));\n\n\t/* XXX some errnos mean 'no address'; some mean 'not enough sockets'. */\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) >= 0 &&\n\t    connect(fd, (struct sockaddr*)&sin, sizeof(sin)) == 0 &&\n\t    getsockname(fd, (struct sockaddr*)&sin_out, &sin_out_len) == 0) {\n\t\t/* We might have an IPv4 interface. */\n\t\tevutil_found_ifaddr((struct sockaddr*) &sin_out);\n\t}\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n\n\tif ((fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP)) >= 0 &&\n\t    connect(fd, (struct sockaddr*)&sin6, sizeof(sin6)) == 0 &&\n\t    getsockname(fd, (struct sockaddr*)&sin6_out, &sin6_out_len) == 0) {\n\t\t/* We might have an IPv6 interface. */\n\t\tevutil_found_ifaddr((struct sockaddr*) &sin6_out);\n\t}\n\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n\n\treturn 0;\n}\n\n/* Internal addrinfo flag.  This one is set when we allocate the addrinfo from\n * inside libevent.  Otherwise, the built-in getaddrinfo() function allocated\n * it, and we should trust what they said.\n **/\n#define EVUTIL_AI_LIBEVENT_ALLOCATED 0x80000000\n\n/* Helper: construct a new addrinfo containing the socket address in\n * 'sa', which must be a sockaddr_in or a sockaddr_in6.  Take the\n * socktype and protocol info from hints.  If they weren't set, then\n * allocate both a TCP and a UDP addrinfo.\n */\nstruct evutil_addrinfo *\nevutil_new_addrinfo_(struct sockaddr *sa, ev_socklen_t socklen,\n    const struct evutil_addrinfo *hints)\n{\n\tstruct evutil_addrinfo *res;\n\tEVUTIL_ASSERT(hints);\n\n\tif (hints->ai_socktype == 0 && hints->ai_protocol == 0) {\n\t\t/* Indecisive user! Give them a UDP and a TCP. */\n\t\tstruct evutil_addrinfo *r1, *r2;\n\t\tstruct evutil_addrinfo tmp;\n\t\tmemcpy(&tmp, hints, sizeof(tmp));\n\t\ttmp.ai_socktype = SOCK_STREAM; tmp.ai_protocol = IPPROTO_TCP;\n\t\tr1 = evutil_new_addrinfo_(sa, socklen, &tmp);\n\t\tif (!r1)\n\t\t\treturn NULL;\n\t\ttmp.ai_socktype = SOCK_DGRAM; tmp.ai_protocol = IPPROTO_UDP;\n\t\tr2 = evutil_new_addrinfo_(sa, socklen, &tmp);\n\t\tif (!r2) {\n\t\t\tevutil_freeaddrinfo(r1);\n\t\t\treturn NULL;\n\t\t}\n\t\tr1->ai_next = r2;\n\t\treturn r1;\n\t}\n\n\t/* We're going to allocate extra space to hold the sockaddr. */\n\tres = mm_calloc(1,sizeof(struct evutil_addrinfo)+socklen);\n\tif (!res)\n\t\treturn NULL;\n\tres->ai_addr = (struct sockaddr*)\n\t    (((char*)res) + sizeof(struct evutil_addrinfo));\n\tmemcpy(res->ai_addr, sa, socklen);\n\tres->ai_addrlen = socklen;\n\tres->ai_family = sa->sa_family; /* Same or not? XXX */\n\tres->ai_flags = EVUTIL_AI_LIBEVENT_ALLOCATED;\n\tres->ai_socktype = hints->ai_socktype;\n\tres->ai_protocol = hints->ai_protocol;\n\n\treturn res;\n}\n\n/* Append the addrinfo 'append' to the end of 'first', and return the start of\n * the list.  Either element can be NULL, in which case we return the element\n * that is not NULL. */\nstruct evutil_addrinfo *\nevutil_addrinfo_append_(struct evutil_addrinfo *first,\n    struct evutil_addrinfo *append)\n{\n\tstruct evutil_addrinfo *ai = first;\n\tif (!ai)\n\t\treturn append;\n\twhile (ai->ai_next)\n\t\tai = ai->ai_next;\n\tai->ai_next = append;\n\n\treturn first;\n}\n\nstatic int\nparse_numeric_servname(const char *servname)\n{\n\tint n;\n\tchar *endptr=NULL;\n\tn = (int) strtol(servname, &endptr, 10);\n\tif (n>=0 && n <= 65535 && servname[0] && endptr && !endptr[0])\n\t\treturn n;\n\telse\n\t\treturn -1;\n}\n\n/** Parse a service name in 'servname', which can be a decimal port.\n * Return the port number, or -1 on error.\n */\nstatic int\nevutil_parse_servname(const char *servname, const char *protocol,\n    const struct evutil_addrinfo *hints)\n{\n\tint n = parse_numeric_servname(servname);\n\tif (n>=0)\n\t\treturn n;\n#if defined(EVENT__HAVE_GETSERVBYNAME) || defined(_WIN32)\n\tif (!(hints->ai_flags & EVUTIL_AI_NUMERICSERV)) {\n\t\tstruct servent *ent = getservbyname(servname, protocol);\n\t\tif (ent) {\n\t\t\treturn ntohs(ent->s_port);\n\t\t}\n\t}\n#endif\n\treturn -1;\n}\n\n/* Return a string corresponding to a protocol number that we can pass to\n * getservyname.  */\nstatic const char *\nevutil_unparse_protoname(int proto)\n{\n\tswitch (proto) {\n\tcase 0:\n\t\treturn NULL;\n\tcase IPPROTO_TCP:\n\t\treturn \"tcp\";\n\tcase IPPROTO_UDP:\n\t\treturn \"udp\";\n#ifdef IPPROTO_SCTP\n\tcase IPPROTO_SCTP:\n\t\treturn \"sctp\";\n#endif\n\tdefault:\n#ifdef EVENT__HAVE_GETPROTOBYNUMBER\n\t\t{\n\t\t\tstruct protoent *ent = getprotobynumber(proto);\n\t\t\tif (ent)\n\t\t\t\treturn ent->p_name;\n\t\t}\n#endif\n\t\treturn NULL;\n\t}\n}\n\nstatic void\nevutil_getaddrinfo_infer_protocols(struct evutil_addrinfo *hints)\n{\n\t/* If we can guess the protocol from the socktype, do so. */\n\tif (!hints->ai_protocol && hints->ai_socktype) {\n\t\tif (hints->ai_socktype == SOCK_DGRAM)\n\t\t\thints->ai_protocol = IPPROTO_UDP;\n\t\telse if (hints->ai_socktype == SOCK_STREAM)\n\t\t\thints->ai_protocol = IPPROTO_TCP;\n\t}\n\n\t/* Set the socktype if it isn't set. */\n\tif (!hints->ai_socktype && hints->ai_protocol) {\n\t\tif (hints->ai_protocol == IPPROTO_UDP)\n\t\t\thints->ai_socktype = SOCK_DGRAM;\n\t\telse if (hints->ai_protocol == IPPROTO_TCP)\n\t\t\thints->ai_socktype = SOCK_STREAM;\n#ifdef IPPROTO_SCTP\n\t\telse if (hints->ai_protocol == IPPROTO_SCTP)\n\t\t\thints->ai_socktype = SOCK_STREAM;\n#endif\n\t}\n}\n\n#if AF_UNSPEC != PF_UNSPEC\n#error \"I cannot build on a system where AF_UNSPEC != PF_UNSPEC\"\n#endif\n\n/** Implements the part of looking up hosts by name that's common to both\n * the blocking and nonblocking resolver:\n *   - Adjust 'hints' to have a reasonable socktype and protocol.\n *   - Look up the port based on 'servname', and store it in *portnum,\n *   - Handle the nodename==NULL case\n *   - Handle some invalid arguments cases.\n *   - Handle the cases where nodename is an IPv4 or IPv6 address.\n *\n * If we need the resolver to look up the hostname, we return\n * EVUTIL_EAI_NEED_RESOLVE.  Otherwise, we can completely implement\n * getaddrinfo: we return 0 or an appropriate EVUTIL_EAI_* error, and\n * set *res as getaddrinfo would.\n */\nint\nevutil_getaddrinfo_common_(const char *nodename, const char *servname,\n    struct evutil_addrinfo *hints, struct evutil_addrinfo **res, int *portnum)\n{\n\tint port = 0;\n\tconst char *pname;\n\n\tif (nodename == NULL && servname == NULL)\n\t\treturn EVUTIL_EAI_NONAME;\n\n\t/* We only understand 3 families */\n\tif (hints->ai_family != PF_UNSPEC && hints->ai_family != PF_INET &&\n\t    hints->ai_family != PF_INET6)\n\t\treturn EVUTIL_EAI_FAMILY;\n\n\tevutil_getaddrinfo_infer_protocols(hints);\n\n\t/* Look up the port number and protocol, if possible. */\n\tpname = evutil_unparse_protoname(hints->ai_protocol);\n\tif (servname) {\n\t\t/* XXXX We could look at the protocol we got back from\n\t\t * getservbyname, but it doesn't seem too useful. */\n\t\tport = evutil_parse_servname(servname, pname, hints);\n\t\tif (port < 0) {\n\t\t\treturn EVUTIL_EAI_NONAME;\n\t\t}\n\t}\n\n\t/* If we have no node name, then we're supposed to bind to 'any' and\n\t * connect to localhost. */\n\tif (nodename == NULL) {\n\t\tstruct evutil_addrinfo *res4=NULL, *res6=NULL;\n\t\tif (hints->ai_family != PF_INET) { /* INET6 or UNSPEC. */\n\t\t\tstruct sockaddr_in6 sin6;\n\t\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_port = htons(port);\n\t\t\tif (hints->ai_flags & EVUTIL_AI_PASSIVE) {\n\t\t\t\t/* Bind to :: */\n\t\t\t} else {\n\t\t\t\t/* connect to ::1 */\n\t\t\t\tsin6.sin6_addr.s6_addr[15] = 1;\n\t\t\t}\n\t\t\tres6 = evutil_new_addrinfo_((struct sockaddr*)&sin6,\n\t\t\t    sizeof(sin6), hints);\n\t\t\tif (!res6)\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t}\n\n\t\tif (hints->ai_family != PF_INET6) { /* INET or UNSPEC */\n\t\t\tstruct sockaddr_in sin;\n\t\t\tmemset(&sin, 0, sizeof(sin));\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = htons(port);\n\t\t\tif (hints->ai_flags & EVUTIL_AI_PASSIVE) {\n\t\t\t\t/* Bind to 0.0.0.0 */\n\t\t\t} else {\n\t\t\t\t/* connect to 127.0.0.1 */\n\t\t\t\tsin.sin_addr.s_addr = htonl(0x7f000001);\n\t\t\t}\n\t\t\tres4 = evutil_new_addrinfo_((struct sockaddr*)&sin,\n\t\t\t    sizeof(sin), hints);\n\t\t\tif (!res4) {\n\t\t\t\tif (res6)\n\t\t\t\t\tevutil_freeaddrinfo(res6);\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t\t}\n\t\t}\n\t\t*res = evutil_addrinfo_append_(res4, res6);\n\t\treturn 0;\n\t}\n\n\t/* If we can, we should try to parse the hostname without resolving\n\t * it. */\n\t/* Try ipv6. */\n\tif (hints->ai_family == PF_INET6 || hints->ai_family == PF_UNSPEC) {\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tif (1==evutil_inet_pton(AF_INET6, nodename, &sin6.sin6_addr)) {\n\t\t\t/* Got an ipv6 address. */\n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_port = htons(port);\n\t\t\t*res = evutil_new_addrinfo_((struct sockaddr*)&sin6,\n\t\t\t    sizeof(sin6), hints);\n\t\t\tif (!*res)\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Try ipv4. */\n\tif (hints->ai_family == PF_INET || hints->ai_family == PF_UNSPEC) {\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tif (1==evutil_inet_pton(AF_INET, nodename, &sin.sin_addr)) {\n\t\t\t/* Got an ipv6 address. */\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = htons(port);\n\t\t\t*res = evutil_new_addrinfo_((struct sockaddr*)&sin,\n\t\t\t    sizeof(sin), hints);\n\t\t\tif (!*res)\n\t\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\t/* If we have reached this point, we definitely need to do a DNS\n\t * lookup. */\n\tif ((hints->ai_flags & EVUTIL_AI_NUMERICHOST)) {\n\t\t/* If we're not allowed to do one, then say so. */\n\t\treturn EVUTIL_EAI_NONAME;\n\t}\n\t*portnum = port;\n\treturn EVUTIL_EAI_NEED_RESOLVE;\n}\n\n#ifdef EVENT__HAVE_GETADDRINFO\n#define USE_NATIVE_GETADDRINFO\n#endif\n\n#ifdef USE_NATIVE_GETADDRINFO\n/* A mask of all the flags that we declare, so we can clear them before calling\n * the native getaddrinfo */\nstatic const unsigned int ALL_NONNATIVE_AI_FLAGS =\n#ifndef AI_PASSIVE\n    EVUTIL_AI_PASSIVE |\n#endif\n#ifndef AI_CANONNAME\n    EVUTIL_AI_CANONNAME |\n#endif\n#ifndef AI_NUMERICHOST\n    EVUTIL_AI_NUMERICHOST |\n#endif\n#ifndef AI_NUMERICSERV\n    EVUTIL_AI_NUMERICSERV |\n#endif\n#ifndef AI_ADDRCONFIG\n    EVUTIL_AI_ADDRCONFIG |\n#endif\n#ifndef AI_ALL\n    EVUTIL_AI_ALL |\n#endif\n#ifndef AI_V4MAPPED\n    EVUTIL_AI_V4MAPPED |\n#endif\n    EVUTIL_AI_LIBEVENT_ALLOCATED;\n\nstatic const unsigned int ALL_NATIVE_AI_FLAGS =\n#ifdef AI_PASSIVE\n    AI_PASSIVE |\n#endif\n#ifdef AI_CANONNAME\n    AI_CANONNAME |\n#endif\n#ifdef AI_NUMERICHOST\n    AI_NUMERICHOST |\n#endif\n#ifdef AI_NUMERICSERV\n    AI_NUMERICSERV |\n#endif\n#ifdef AI_ADDRCONFIG\n    AI_ADDRCONFIG |\n#endif\n#ifdef AI_ALL\n    AI_ALL |\n#endif\n#ifdef AI_V4MAPPED\n    AI_V4MAPPED |\n#endif\n    0;\n#endif\n\n#ifndef USE_NATIVE_GETADDRINFO\n/* Helper for systems with no getaddrinfo(): make one or more addrinfos out of\n * a struct hostent.\n */\nstatic struct evutil_addrinfo *\naddrinfo_from_hostent(const struct hostent *ent,\n    int port, const struct evutil_addrinfo *hints)\n{\n\tint i;\n\tstruct sockaddr_in sin;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr *sa;\n\tint socklen;\n\tstruct evutil_addrinfo *res=NULL, *ai;\n\tvoid *addrp;\n\n\tif (ent->h_addrtype == PF_INET) {\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tsa = (struct sockaddr *)&sin;\n\t\tsocklen = sizeof(struct sockaddr_in);\n\t\taddrp = &sin.sin_addr;\n\t\tif (ent->h_length != sizeof(sin.sin_addr)) {\n\t\t\tevent_warnx(\"Weird h_length from gethostbyname\");\n\t\t\treturn NULL;\n\t\t}\n\t} else if (ent->h_addrtype == PF_INET6) {\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tsa = (struct sockaddr *)&sin6;\n\t\tsocklen = sizeof(struct sockaddr_in6);\n\t\taddrp = &sin6.sin6_addr;\n\t\tif (ent->h_length != sizeof(sin6.sin6_addr)) {\n\t\t\tevent_warnx(\"Weird h_length from gethostbyname\");\n\t\t\treturn NULL;\n\t\t}\n\t} else\n\t\treturn NULL;\n\n\tfor (i = 0; ent->h_addr_list[i]; ++i) {\n\t\tmemcpy(addrp, ent->h_addr_list[i], ent->h_length);\n\t\tai = evutil_new_addrinfo_(sa, socklen, hints);\n\t\tif (!ai) {\n\t\t\tevutil_freeaddrinfo(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tres = evutil_addrinfo_append_(res, ai);\n\t}\n\n\tif (res && ((hints->ai_flags & EVUTIL_AI_CANONNAME) && ent->h_name)) {\n\t\tres->ai_canonname = mm_strdup(ent->h_name);\n\t\tif (res->ai_canonname == NULL) {\n\t\t\tevutil_freeaddrinfo(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn res;\n}\n#endif\n\n/* If the EVUTIL_AI_ADDRCONFIG flag is set on hints->ai_flags, and\n * hints->ai_family is PF_UNSPEC, then revise the value of hints->ai_family so\n * that we'll only get addresses we could maybe connect to.\n */\nvoid\nevutil_adjust_hints_for_addrconfig_(struct evutil_addrinfo *hints)\n{\n\tif (!(hints->ai_flags & EVUTIL_AI_ADDRCONFIG))\n\t\treturn;\n\tif (hints->ai_family != PF_UNSPEC)\n\t\treturn;\n\tif (!have_checked_interfaces)\n\t\tevutil_check_interfaces(0);\n\tif (had_ipv4_address && !had_ipv6_address) {\n\t\thints->ai_family = PF_INET;\n\t} else if (!had_ipv4_address && had_ipv6_address) {\n\t\thints->ai_family = PF_INET6;\n\t}\n}\n\n#ifdef USE_NATIVE_GETADDRINFO\nstatic int need_numeric_port_hack_=0;\nstatic int need_socktype_protocol_hack_=0;\nstatic int tested_for_getaddrinfo_hacks=0;\n\n/* Some older BSDs (like OpenBSD up to 4.6) used to believe that\n   giving a numeric port without giving an ai_socktype was verboten.\n   We test for this so we can apply an appropriate workaround.  If it\n   turns out that the bug is present, then:\n\n    - If nodename==NULL and servname is numeric, we build an answer\n      ourselves using evutil_getaddrinfo_common_().\n\n    - If nodename!=NULL and servname is numeric, then we set\n      servname=NULL when calling getaddrinfo, and post-process the\n      result to set the ports on it.\n\n   We test for this bug at runtime, since otherwise we can't have the\n   same binary run on multiple BSD versions.\n\n   - Some versions of Solaris believe that it's nice to leave to protocol\n     field set to 0.  We test for this so we can apply an appropriate\n     workaround.\n*/\nstatic void\ntest_for_getaddrinfo_hacks(void)\n{\n\tint r, r2;\n\tstruct evutil_addrinfo *ai=NULL, *ai2=NULL;\n\tstruct evutil_addrinfo hints;\n\n\tmemset(&hints,0,sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_flags =\n#ifdef AI_NUMERICHOST\n\t    AI_NUMERICHOST |\n#endif\n#ifdef AI_NUMERICSERV\n\t    AI_NUMERICSERV |\n#endif\n\t    0;\n\tr = getaddrinfo(\"1.2.3.4\", \"80\", &hints, &ai);\n\thints.ai_socktype = SOCK_STREAM;\n\tr2 = getaddrinfo(\"1.2.3.4\", \"80\", &hints, &ai2);\n\tif (r2 == 0 && r != 0) {\n\t\tneed_numeric_port_hack_=1;\n\t}\n\tif (ai2 && ai2->ai_protocol == 0) {\n\t\tneed_socktype_protocol_hack_=1;\n\t}\n\n\tif (ai)\n\t\tfreeaddrinfo(ai);\n\tif (ai2)\n\t\tfreeaddrinfo(ai2);\n\ttested_for_getaddrinfo_hacks=1;\n}\n\nstatic inline int\nneed_numeric_port_hack(void)\n{\n\tif (!tested_for_getaddrinfo_hacks)\n\t\ttest_for_getaddrinfo_hacks();\n\treturn need_numeric_port_hack_;\n}\n\nstatic inline int\nneed_socktype_protocol_hack(void)\n{\n\tif (!tested_for_getaddrinfo_hacks)\n\t\ttest_for_getaddrinfo_hacks();\n\treturn need_socktype_protocol_hack_;\n}\n\nstatic void\napply_numeric_port_hack(int port, struct evutil_addrinfo **ai)\n{\n\t/* Now we run through the list and set the ports on all of the\n\t * results where ports would make sense. */\n\tfor ( ; *ai; ai = &(*ai)->ai_next) {\n\t\tstruct sockaddr *sa = (*ai)->ai_addr;\n\t\tif (sa && sa->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in*)sa;\n\t\t\tsin->sin_port = htons(port);\n\t\t} else if (sa && sa->sa_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6*)sa;\n\t\t\tsin6->sin6_port = htons(port);\n\t\t} else {\n\t\t\t/* A numeric port makes no sense here; remove this one\n\t\t\t * from the list. */\n\t\t\tstruct evutil_addrinfo *victim = *ai;\n\t\t\t*ai = victim->ai_next;\n\t\t\tvictim->ai_next = NULL;\n\t\t\tfreeaddrinfo(victim);\n\t\t}\n\t}\n}\n\nstatic int\napply_socktype_protocol_hack(struct evutil_addrinfo *ai)\n{\n\tstruct evutil_addrinfo *ai_new;\n\tfor (; ai; ai = ai->ai_next) {\n\t\tevutil_getaddrinfo_infer_protocols(ai);\n\t\tif (ai->ai_socktype || ai->ai_protocol)\n\t\t\tcontinue;\n\t\tai_new = mm_malloc(sizeof(*ai_new));\n\t\tif (!ai_new)\n\t\t\treturn -1;\n\t\tmemcpy(ai_new, ai, sizeof(*ai_new));\n\t\tai->ai_socktype = SOCK_STREAM;\n\t\tai->ai_protocol = IPPROTO_TCP;\n\t\tai_new->ai_socktype = SOCK_DGRAM;\n\t\tai_new->ai_protocol = IPPROTO_UDP;\n\n\t\tai_new->ai_next = ai->ai_next;\n\t\tai->ai_next = ai_new;\n\t}\n\treturn 0;\n}\n#endif\n\nint\nevutil_getaddrinfo(const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res)\n{\n#ifdef USE_NATIVE_GETADDRINFO\n\tstruct evutil_addrinfo hints;\n\tint portnum=-1, need_np_hack, err;\n\n\tif (hints_in) {\n\t\tmemcpy(&hints, hints_in, sizeof(hints));\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = PF_UNSPEC;\n\t}\n\n#ifndef AI_ADDRCONFIG\n\t/* Not every system has AI_ADDRCONFIG, so fake it. */\n\tif (hints.ai_family == PF_UNSPEC &&\n\t    (hints.ai_flags & EVUTIL_AI_ADDRCONFIG)) {\n\t\tevutil_adjust_hints_for_addrconfig_(&hints);\n\t}\n#endif\n\n#ifndef AI_NUMERICSERV\n\t/* Not every system has AI_NUMERICSERV, so fake it. */\n\tif (hints.ai_flags & EVUTIL_AI_NUMERICSERV) {\n\t\tif (servname && parse_numeric_servname(servname)<0)\n\t\t\treturn EVUTIL_EAI_NONAME;\n\t}\n#endif\n\n\t/* Enough operating systems handle enough common non-resolve\n\t * cases here weirdly enough that we are better off just\n\t * overriding them.  For example:\n\t *\n\t * - Windows doesn't like to infer the protocol from the\n\t *   socket type, or fill in socket or protocol types much at\n\t *   all.  It also seems to do its own broken implicit\n\t *   always-on version of AI_ADDRCONFIG that keeps it from\n\t *   ever resolving even a literal IPv6 address when\n\t *   ai_addrtype is PF_UNSPEC.\n\t */\n#ifdef _WIN32\n\t{\n\t\tint tmp_port;\n\t\terr = evutil_getaddrinfo_common_(nodename,servname,&hints,\n\t\t    res, &tmp_port);\n\t\tif (err == 0 ||\n\t\t    err == EVUTIL_EAI_MEMORY ||\n\t\t    err == EVUTIL_EAI_NONAME)\n\t\t\treturn err;\n\t\t/* If we make it here, the system getaddrinfo can\n\t\t * have a crack at it. */\n\t}\n#endif\n\n\t/* See documentation for need_numeric_port_hack above.*/\n\tneed_np_hack = need_numeric_port_hack() && servname && !hints.ai_socktype\n\t    && ((portnum=parse_numeric_servname(servname)) >= 0);\n\tif (need_np_hack) {\n\t\tif (!nodename)\n\t\t\treturn evutil_getaddrinfo_common_(\n\t\t\t\tNULL,servname,&hints, res, &portnum);\n\t\tservname = NULL;\n\t}\n\n\tif (need_socktype_protocol_hack()) {\n\t\tevutil_getaddrinfo_infer_protocols(&hints);\n\t}\n\n\t/* Make sure that we didn't actually steal any AI_FLAGS values that\n\t * the system is using.  (This is a constant expression, and should ge\n\t * optimized out.)\n\t *\n\t * XXXX Turn this into a compile-time failure rather than a run-time\n\t * failure.\n\t */\n\tEVUTIL_ASSERT((ALL_NONNATIVE_AI_FLAGS & ALL_NATIVE_AI_FLAGS) == 0);\n\n\t/* Clear any flags that only libevent understands. */\n\thints.ai_flags &= ~ALL_NONNATIVE_AI_FLAGS;\n\n\terr = getaddrinfo(nodename, servname, &hints, res);\n\tif (need_np_hack)\n\t\tapply_numeric_port_hack(portnum, res);\n\n\tif (need_socktype_protocol_hack()) {\n\t\tif (apply_socktype_protocol_hack(*res) < 0) {\n\t\t\tevutil_freeaddrinfo(*res);\n\t\t\t*res = NULL;\n\t\t\treturn EVUTIL_EAI_MEMORY;\n\t\t}\n\t}\n\treturn err;\n#else\n\tint port=0, err;\n\tstruct hostent *ent = NULL;\n\tstruct evutil_addrinfo hints;\n\n\tif (hints_in) {\n\t\tmemcpy(&hints, hints_in, sizeof(hints));\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = PF_UNSPEC;\n\t}\n\n\tevutil_adjust_hints_for_addrconfig_(&hints);\n\n\terr = evutil_getaddrinfo_common_(nodename, servname, &hints, res, &port);\n\tif (err != EVUTIL_EAI_NEED_RESOLVE) {\n\t\t/* We either succeeded or failed.  No need to continue */\n\t\treturn err;\n\t}\n\n\terr = 0;\n\t/* Use any of the various gethostbyname_r variants as available. */\n\t{\n#ifdef EVENT__HAVE_GETHOSTBYNAME_R_6_ARG\n\t\t/* This one is what glibc provides. */\n\t\tchar buf[2048];\n\t\tstruct hostent hostent;\n\t\tint r;\n\t\tr = gethostbyname_r(nodename, &hostent, buf, sizeof(buf), &ent,\n\t\t    &err);\n#elif defined(EVENT__HAVE_GETHOSTBYNAME_R_5_ARG)\n\t\tchar buf[2048];\n\t\tstruct hostent hostent;\n\t\tent = gethostbyname_r(nodename, &hostent, buf, sizeof(buf),\n\t\t    &err);\n#elif defined(EVENT__HAVE_GETHOSTBYNAME_R_3_ARG)\n\t\tstruct hostent_data data;\n\t\tstruct hostent hostent;\n\t\tmemset(&data, 0, sizeof(data));\n\t\terr = gethostbyname_r(nodename, &hostent, &data);\n\t\tent = err ? NULL : &hostent;\n#else\n\t\t/* fall back to gethostbyname. */\n\t\t/* XXXX This needs a lock everywhere but Windows. */\n\t\tent = gethostbyname(nodename);\n#ifdef _WIN32\n\t\terr = WSAGetLastError();\n#else\n\t\terr = h_errno;\n#endif\n#endif\n\n\t\t/* Now we have either ent or err set. */\n\t\tif (!ent) {\n\t\t\t/* XXX is this right for windows ? */\n\t\t\tswitch (err) {\n\t\t\tcase TRY_AGAIN:\n\t\t\t\treturn EVUTIL_EAI_AGAIN;\n\t\t\tcase NO_RECOVERY:\n\t\t\tdefault:\n\t\t\t\treturn EVUTIL_EAI_FAIL;\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\treturn EVUTIL_EAI_NONAME;\n\t\t\tcase NO_ADDRESS:\n#if NO_DATA != NO_ADDRESS\n\t\t\tcase NO_DATA:\n#endif\n\t\t\t\treturn EVUTIL_EAI_NODATA;\n\t\t\t}\n\t\t}\n\n\t\tif (ent->h_addrtype != hints.ai_family &&\n\t\t    hints.ai_family != PF_UNSPEC) {\n\t\t\t/* This wasn't the type we were hoping for.  Too bad\n\t\t\t * we never had a chance to ask gethostbyname for what\n\t\t\t * we wanted. */\n\t\t\treturn EVUTIL_EAI_NONAME;\n\t\t}\n\n\t\t/* Make sure we got _some_ answers. */\n\t\tif (ent->h_length == 0)\n\t\t\treturn EVUTIL_EAI_NODATA;\n\n\t\t/* If we got an address type we don't know how to make a\n\t\t   sockaddr for, give up. */\n\t\tif (ent->h_addrtype != PF_INET && ent->h_addrtype != PF_INET6)\n\t\t\treturn EVUTIL_EAI_FAMILY;\n\n\t\t*res = addrinfo_from_hostent(ent, port, &hints);\n\t\tif (! *res)\n\t\t\treturn EVUTIL_EAI_MEMORY;\n\t}\n\n\treturn 0;\n#endif\n}\n\nvoid\nevutil_freeaddrinfo(struct evutil_addrinfo *ai)\n{\n#ifdef EVENT__HAVE_GETADDRINFO\n\tif (!(ai->ai_flags & EVUTIL_AI_LIBEVENT_ALLOCATED)) {\n\t\tfreeaddrinfo(ai);\n\t\treturn;\n\t}\n#endif\n\twhile (ai) {\n\t\tstruct evutil_addrinfo *next = ai->ai_next;\n\t\tif (ai->ai_canonname)\n\t\t\tmm_free(ai->ai_canonname);\n\t\tmm_free(ai);\n\t\tai = next;\n\t}\n}\n\nstatic evdns_getaddrinfo_fn evdns_getaddrinfo_impl = NULL;\n\nvoid\nevutil_set_evdns_getaddrinfo_fn_(evdns_getaddrinfo_fn fn)\n{\n\tif (!evdns_getaddrinfo_impl)\n\t\tevdns_getaddrinfo_impl = fn;\n}\n\n/* Internal helper function: act like evdns_getaddrinfo if dns_base is set;\n * otherwise do a blocking resolve and pass the result to the callback in the\n * way that evdns_getaddrinfo would.\n */\nint\nevutil_getaddrinfo_async_(struct evdns_base *dns_base,\n    const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in,\n    void (*cb)(int, struct evutil_addrinfo *, void *), void *arg)\n{\n\tif (dns_base && evdns_getaddrinfo_impl) {\n\t\tevdns_getaddrinfo_impl(\n\t\t\tdns_base, nodename, servname, hints_in, cb, arg);\n\t} else {\n\t\tstruct evutil_addrinfo *ai=NULL;\n\t\tint err;\n\t\terr = evutil_getaddrinfo(nodename, servname, hints_in, &ai);\n\t\tcb(err, ai, arg);\n\t}\n\treturn 0;\n}\n\nconst char *\nevutil_gai_strerror(int err)\n{\n\t/* As a sneaky side-benefit, this case statement will get most\n\t * compilers to tell us if any of the error codes we defined\n\t * conflict with the platform's native error codes. */\n\tswitch (err) {\n\tcase EVUTIL_EAI_CANCEL:\n\t\treturn \"Request canceled\";\n\tcase 0:\n\t\treturn \"No error\";\n\n\tcase EVUTIL_EAI_ADDRFAMILY:\n\t\treturn \"address family for nodename not supported\";\n\tcase EVUTIL_EAI_AGAIN:\n\t\treturn \"temporary failure in name resolution\";\n\tcase EVUTIL_EAI_BADFLAGS:\n\t\treturn \"invalid value for ai_flags\";\n\tcase EVUTIL_EAI_FAIL:\n\t\treturn \"non-recoverable failure in name resolution\";\n\tcase EVUTIL_EAI_FAMILY:\n\t\treturn \"ai_family not supported\";\n\tcase EVUTIL_EAI_MEMORY:\n\t\treturn \"memory allocation failure\";\n\tcase EVUTIL_EAI_NODATA:\n\t\treturn \"no address associated with nodename\";\n\tcase EVUTIL_EAI_NONAME:\n\t\treturn \"nodename nor servname provided, or not known\";\n\tcase EVUTIL_EAI_SERVICE:\n\t\treturn \"servname not supported for ai_socktype\";\n\tcase EVUTIL_EAI_SOCKTYPE:\n\t\treturn \"ai_socktype not supported\";\n\tcase EVUTIL_EAI_SYSTEM:\n\t\treturn \"system error\";\n\tdefault:\n#if defined(USE_NATIVE_GETADDRINFO) && defined(_WIN32)\n\t\treturn gai_strerrorA(err);\n#elif defined(USE_NATIVE_GETADDRINFO)\n\t\treturn gai_strerror(err);\n#else\n\t\treturn \"Unknown error code\";\n#endif\n\t}\n}\n\n#ifdef _WIN32\n/* destructively remove a trailing line terminator from s */\nstatic void\nchomp (char *s)\n{\n\tsize_t len;\n\tif (s && (len = strlen (s)) > 0 && s[len - 1] == '\\n') {\n\t\ts[--len] = 0;\n\t\tif (len > 0 && s[len - 1] == '\\r')\n\t\t\ts[--len] = 0;\n\t}\n}\n\n/* FormatMessage returns allocated strings, but evutil_socket_error_to_string\n * is supposed to return a string which is good indefinitely without having\n * to be freed.  To make this work without leaking memory, we cache the\n * string the first time FormatMessage is called on a particular error\n * code, and then return the cached string on subsequent calls with the\n * same code.  The strings aren't freed until libevent_global_shutdown\n * (or never).  We use a linked list to cache the errors, because we\n * only expect there to be a few dozen, and that should be fast enough.\n */\n\nstruct cached_sock_errs_entry {\n\tHT_ENTRY(cached_sock_errs_entry) node;\n\tDWORD code;\n\tchar *msg; /* allocated with LocalAlloc; free with LocalFree */\n};\n\nstatic inline unsigned\nhash_cached_sock_errs(const struct cached_sock_errs_entry *e)\n{\n\t/* Use Murmur3's 32-bit finalizer as an integer hash function */\n\tDWORD h = e->code;\n\th ^= h >> 16;\n\th *= 0x85ebca6b;\n\th ^= h >> 13;\n\th *= 0xc2b2ae35;\n\th ^= h >> 16;\n\treturn h;\n}\n\nstatic inline int\neq_cached_sock_errs(const struct cached_sock_errs_entry *a,\n\t\t    const struct cached_sock_errs_entry *b)\n{\n\treturn a->code == b->code;\n}\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\nstatic void *windows_socket_errors_lock_ = NULL;\n#endif\n\nstatic HT_HEAD(cached_sock_errs_map, cached_sock_errs_entry)\n     windows_socket_errors = HT_INITIALIZER();\n\nHT_PROTOTYPE(cached_sock_errs_map,\n\t     cached_sock_errs_entry,\n\t     node,\n\t     hash_cached_sock_errs,\n\t     eq_cached_sock_errs);\n\nHT_GENERATE(cached_sock_errs_map,\n\t    cached_sock_errs_entry,\n\t    node,\n\t    hash_cached_sock_errs,\n\t    eq_cached_sock_errs,\n\t    0.5,\n\t    mm_malloc,\n\t    mm_realloc,\n\t    mm_free);\n\n/** Equivalent to strerror, but for windows socket errors. */\nconst char *\nevutil_socket_error_to_string(int errcode)\n{\n\tstruct cached_sock_errs_entry *errs, *newerr, find;\n\tchar *msg = NULL;\n\n\tEVLOCK_LOCK(windows_socket_errors_lock_, 0);\n\n\tfind.code = errcode;\n\terrs = HT_FIND(cached_sock_errs_map, &windows_socket_errors, &find);\n\tif (errs) {\n\t\tmsg = errs->msg;\n\t\tgoto done;\n\t}\n\n\tif (0 != FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t       FORMAT_MESSAGE_IGNORE_INSERTS |\n\t\t\t       FORMAT_MESSAGE_ALLOCATE_BUFFER,\n\t\t\t       NULL, errcode, 0, (char *)&msg, 0, NULL))\n\t\tchomp (msg);\t/* because message has trailing newline */\n\telse {\n\t\tsize_t len = 50;\n\t\t/* use LocalAlloc because FormatMessage does */\n\t\tmsg = LocalAlloc(LMEM_FIXED, len);\n\t\tif (!msg) {\n\t\t\tmsg = (char *)\"LocalAlloc failed during Winsock error\";\n\t\t\tgoto done;\n\t\t}\n\t\tevutil_snprintf(msg, len, \"winsock error 0x%08x\", errcode);\n\t}\n\n\tnewerr = (struct cached_sock_errs_entry *)\n\t\tmm_malloc(sizeof (struct cached_sock_errs_entry));\n\n\tif (!newerr) {\n\t\tLocalFree(msg);\n\t\tmsg = (char *)\"malloc failed during Winsock error\";\n\t\tgoto done;\n\t}\n\n\tnewerr->code = errcode;\n\tnewerr->msg = msg;\n\tHT_INSERT(cached_sock_errs_map, &windows_socket_errors, newerr);\n\n done:\n\tEVLOCK_UNLOCK(windows_socket_errors_lock_, 0);\n\n\treturn msg;\n}\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\nint\nevutil_global_setup_locks_(const int enable_locks)\n{\n\tEVTHREAD_SETUP_GLOBAL_LOCK(windows_socket_errors_lock_, 0);\n\treturn 0;\n}\n#endif\n\nstatic void\nevutil_free_sock_err_globals(void)\n{\n\tstruct cached_sock_errs_entry **errs, *tofree;\n\n\tfor (errs = HT_START(cached_sock_errs_map, &windows_socket_errors)\n\t\t     ; errs; ) {\n\t\ttofree = *errs;\n\t\terrs = HT_NEXT_RMV(cached_sock_errs_map,\n\t\t\t\t   &windows_socket_errors,\n\t\t\t\t   errs);\n\t\tLocalFree(tofree->msg);\n\t\tmm_free(tofree);\n\t}\n\n\tHT_CLEAR(cached_sock_errs_map, &windows_socket_errors);\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\tif (windows_socket_errors_lock_ != NULL) {\n\t\tEVTHREAD_FREE_LOCK(windows_socket_errors_lock_, 0);\n\t\twindows_socket_errors_lock_ = NULL;\n\t}\n#endif\n}\n\n#else\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\nint\nevutil_global_setup_locks_(const int enable_locks)\n{\n\treturn 0;\n}\n#endif\n\nstatic void\nevutil_free_sock_err_globals(void)\n{\n}\n\n#endif\n\nint\nevutil_snprintf(char *buf, size_t buflen, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\tva_start(ap, format);\n\tr = evutil_vsnprintf(buf, buflen, format, ap);\n\tva_end(ap);\n\treturn r;\n}\n\nint\nevutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)\n{\n\tint r;\n\tif (!buflen)\n\t\treturn 0;\n#if defined(_MSC_VER) || defined(_WIN32)\n\tr = _vsnprintf(buf, buflen, format, ap);\n\tif (r < 0)\n\t\tr = _vscprintf(format, ap);\n#elif defined(sgi)\n\t/* Make sure we always use the correct vsnprintf on IRIX */\n\textern int      _xpg5_vsnprintf(char * __restrict,\n\t\t__SGI_LIBC_NAMESPACE_QUALIFIER size_t,\n\t\tconst char * __restrict, /* va_list */ char *);\n\n\tr = _xpg5_vsnprintf(buf, buflen, format, ap);\n#else\n\tr = vsnprintf(buf, buflen, format, ap);\n#endif\n\tbuf[buflen-1] = '\\0';\n\treturn r;\n}\n\n#define USE_INTERNAL_NTOP\n#define USE_INTERNAL_PTON\n\nconst char *\nevutil_inet_ntop(int af, const void *src, char *dst, size_t len)\n{\n#if defined(EVENT__HAVE_INET_NTOP) && !defined(USE_INTERNAL_NTOP)\n\treturn inet_ntop(af, src, dst, len);\n#else\n\tif (af == AF_INET) {\n\t\tconst struct in_addr *in = src;\n\t\tconst ev_uint32_t a = ntohl(in->s_addr);\n\t\tint r;\n\t\tr = evutil_snprintf(dst, len, \"%d.%d.%d.%d\",\n\t\t    (int)(ev_uint8_t)((a>>24)&0xff),\n\t\t    (int)(ev_uint8_t)((a>>16)&0xff),\n\t\t    (int)(ev_uint8_t)((a>>8 )&0xff),\n\t\t    (int)(ev_uint8_t)((a    )&0xff));\n\t\tif (r<0||(size_t)r>=len)\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn dst;\n#ifdef AF_INET6\n\t} else if (af == AF_INET6) {\n\t\tconst struct in6_addr *addr = src;\n\t\tchar buf[64], *cp;\n\t\tint longestGapLen = 0, longestGapPos = -1, i,\n\t\t\tcurGapPos = -1, curGapLen = 0;\n\t\tev_uint16_t words[8];\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\twords[i] =\n\t\t\t    (((ev_uint16_t)addr->s6_addr[2*i])<<8) + addr->s6_addr[2*i+1];\n\t\t}\n\t\tif (words[0] == 0 && words[1] == 0 && words[2] == 0 && words[3] == 0 &&\n\t\t    words[4] == 0 && ((words[5] == 0 && words[6] && words[7]) ||\n\t\t\t(words[5] == 0xffff))) {\n\t\t\t/* This is an IPv4 address. */\n\t\t\tif (words[5] == 0) {\n\t\t\t\tevutil_snprintf(buf, sizeof(buf), \"::%d.%d.%d.%d\",\n\t\t\t\t    addr->s6_addr[12], addr->s6_addr[13],\n\t\t\t\t    addr->s6_addr[14], addr->s6_addr[15]);\n\t\t\t} else {\n\t\t\t\tevutil_snprintf(buf, sizeof(buf), \"::%x:%d.%d.%d.%d\", words[5],\n\t\t\t\t    addr->s6_addr[12], addr->s6_addr[13],\n\t\t\t\t    addr->s6_addr[14], addr->s6_addr[15]);\n\t\t\t}\n\t\t\tif (strlen(buf) > len)\n\t\t\t\treturn NULL;\n\t\t\tstrlcpy(dst, buf, len);\n\t\t\treturn dst;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < 8) {\n\t\t\tif (words[i] == 0) {\n\t\t\t\tcurGapPos = i++;\n\t\t\t\tcurGapLen = 1;\n\t\t\t\twhile (i<8 && words[i] == 0) {\n\t\t\t\t\t++i; ++curGapLen;\n\t\t\t\t}\n\t\t\t\tif (curGapLen > longestGapLen) {\n\t\t\t\t\tlongestGapPos = curGapPos;\n\t\t\t\t\tlongestGapLen = curGapLen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\tif (longestGapLen<=1)\n\t\t\tlongestGapPos = -1;\n\n\t\tcp = buf;\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tif (words[i] == 0 && longestGapPos == i) {\n\t\t\t\tif (i == 0)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\t*cp++ = ':';\n\t\t\t\twhile (i < 8 && words[i] == 0)\n\t\t\t\t\t++i;\n\t\t\t\t--i; /* to compensate for loop increment. */\n\t\t\t} else {\n\t\t\t\tevutil_snprintf(cp,\n\t\t\t\t\t\t\t\tsizeof(buf)-(cp-buf), \"%x\", (unsigned)words[i]);\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tif (i != 7)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t}\n\t\t}\n\t\t*cp = '\\0';\n\t\tif (strlen(buf) > len)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, buf, len);\n\t\treturn dst;\n#endif\n\t} else {\n\t\treturn NULL;\n\t}\n#endif\n}\n\nint\nevutil_inet_pton(int af, const char *src, void *dst)\n{\n#if defined(EVENT__HAVE_INET_PTON) && !defined(USE_INTERNAL_PTON)\n\treturn inet_pton(af, src, dst);\n#else\n\tif (af == AF_INET) {\n\t\tunsigned a,b,c,d;\n\t\tchar more;\n\t\tstruct in_addr *addr = dst;\n\t\tif (sscanf(src, \"%u.%u.%u.%u%c\", &a,&b,&c,&d,&more) != 4)\n\t\t\treturn 0;\n\t\tif (a > 255) return 0;\n\t\tif (b > 255) return 0;\n\t\tif (c > 255) return 0;\n\t\tif (d > 255) return 0;\n\t\taddr->s_addr = htonl((a<<24) | (b<<16) | (c<<8) | d);\n\t\treturn 1;\n#ifdef AF_INET6\n\t} else if (af == AF_INET6) {\n\t\tstruct in6_addr *out = dst;\n\t\tev_uint16_t words[8];\n\t\tint gapPos = -1, i, setWords=0;\n\t\tconst char *dot = strchr(src, '.');\n\t\tconst char *eow; /* end of words. */\n\t\tif (dot == src)\n\t\t\treturn 0;\n\t\telse if (!dot)\n\t\t\teow = src+strlen(src);\n\t\telse {\n\t\t\tunsigned byte1,byte2,byte3,byte4;\n\t\t\tchar more;\n\t\t\tfor (eow = dot-1; eow >= src && EVUTIL_ISDIGIT_(*eow); --eow)\n\t\t\t\t;\n\t\t\t++eow;\n\n\t\t\t/* We use \"scanf\" because some platform inet_aton()s are too lax\n\t\t\t * about IPv4 addresses of the form \"1.2.3\" */\n\t\t\tif (sscanf(eow, \"%u.%u.%u.%u%c\",\n\t\t\t\t\t   &byte1,&byte2,&byte3,&byte4,&more) != 4)\n\t\t\t\treturn 0;\n\n\t\t\tif (byte1 > 255 ||\n\t\t\t    byte2 > 255 ||\n\t\t\t    byte3 > 255 ||\n\t\t\t    byte4 > 255)\n\t\t\t\treturn 0;\n\n\t\t\twords[6] = (byte1<<8) | byte2;\n\t\t\twords[7] = (byte3<<8) | byte4;\n\t\t\tsetWords += 2;\n\t\t}\n\n\t\ti = 0;\n\t\twhile (src < eow) {\n\t\t\tif (i > 7)\n\t\t\t\treturn 0;\n\t\t\tif (EVUTIL_ISXDIGIT_(*src)) {\n\t\t\t\tchar *next;\n\t\t\t\tlong r = strtol(src, &next, 16);\n\t\t\t\tif (next > 4+src)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (next == src)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (r<0 || r>65536)\n\t\t\t\t\treturn 0;\n\n\t\t\t\twords[i++] = (ev_uint16_t)r;\n\t\t\t\tsetWords++;\n\t\t\t\tsrc = next;\n\t\t\t\tif (*src != ':' && src != eow)\n\t\t\t\t\treturn 0;\n\t\t\t\t++src;\n\t\t\t} else if (*src == ':' && i > 0 && gapPos==-1) {\n\t\t\t\tgapPos = i;\n\t\t\t\t++src;\n\t\t\t} else if (*src == ':' && i == 0 && src[1] == ':' && gapPos==-1) {\n\t\t\t\tgapPos = i;\n\t\t\t\tsrc += 2;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (setWords > 8 ||\n\t\t\t(setWords == 8 && gapPos != -1) ||\n\t\t\t(setWords < 8 && gapPos == -1))\n\t\t\treturn 0;\n\n\t\tif (gapPos >= 0) {\n\t\t\tint nToMove = setWords - (dot ? 2 : 0) - gapPos;\n\t\t\tint gapLen = 8 - setWords;\n\t\t\t/* assert(nToMove >= 0); */\n\t\t\tif (nToMove < 0)\n\t\t\t\treturn -1; /* should be impossible */\n\t\t\tmemmove(&words[gapPos+gapLen], &words[gapPos],\n\t\t\t\t\tsizeof(ev_uint16_t)*nToMove);\n\t\t\tmemset(&words[gapPos], 0, sizeof(ev_uint16_t)*gapLen);\n\t\t}\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tout->s6_addr[2*i  ] = words[i] >> 8;\n\t\t\tout->s6_addr[2*i+1] = words[i] & 0xff;\n\t\t}\n\n\t\treturn 1;\n#endif\n\t} else {\n\t\treturn -1;\n\t}\n#endif\n}\n\nint\nevutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)\n{\n\tint port;\n\tchar buf[128];\n\tconst char *cp, *addr_part, *port_part;\n\tint is_ipv6;\n\t/* recognized formats are:\n\t * [ipv6]:port\n\t * ipv6\n\t * [ipv6]\n\t * ipv4:port\n\t * ipv4\n\t */\n\n\tcp = strchr(ip_as_string, ':');\n\tif (*ip_as_string == '[') {\n\t\tsize_t len;\n\t\tif (!(cp = strchr(ip_as_string, ']'))) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen = ( cp-(ip_as_string + 1) );\n\t\tif (len > sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string+1, len);\n\t\tbuf[len] = '\\0';\n\t\taddr_part = buf;\n\t\tif (cp[1] == ':')\n\t\t\tport_part = cp+2;\n\t\telse\n\t\t\tport_part = NULL;\n\t\tis_ipv6 = 1;\n\t} else if (cp && strchr(cp+1, ':')) {\n\t\tis_ipv6 = 1;\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t} else if (cp) {\n\t\tis_ipv6 = 0;\n\t\tif (cp - ip_as_string > (int)sizeof(buf)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, ip_as_string, cp-ip_as_string);\n\t\tbuf[cp-ip_as_string] = '\\0';\n\t\taddr_part = buf;\n\t\tport_part = cp+1;\n\t} else {\n\t\taddr_part = ip_as_string;\n\t\tport_part = NULL;\n\t\tis_ipv6 = 0;\n\t}\n\n\tif (port_part == NULL) {\n\t\tport = 0;\n\t} else {\n\t\tport = atoi(port_part);\n\t\tif (port <= 0 || port > 65535) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!addr_part)\n\t\treturn -1; /* Should be impossible. */\n#ifdef AF_INET6\n\tif (is_ipv6)\n\t{\n\t\tstruct sockaddr_in6 sin6;\n\t\tmemset(&sin6, 0, sizeof(sin6));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n\t\tsin6.sin6_len = sizeof(sin6);\n#endif\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET6, addr_part, &sin6.sin6_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin6) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin6, sizeof(sin6));\n\t\t*outlen = sizeof(sin6);\n\t\treturn 0;\n\t}\n\telse\n#endif\n\t{\n\t\tstruct sockaddr_in sin;\n\t\tmemset(&sin, 0, sizeof(sin));\n#ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n\t\tsin.sin_len = sizeof(sin);\n#endif\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tif (1 != evutil_inet_pton(AF_INET, addr_part, &sin.sin_addr))\n\t\t\treturn -1;\n\t\tif ((int)sizeof(sin) > *outlen)\n\t\t\treturn -1;\n\t\tmemset(out, 0, *outlen);\n\t\tmemcpy(out, &sin, sizeof(sin));\n\t\t*outlen = sizeof(sin);\n\t\treturn 0;\n\t}\n}\n\nconst char *\nevutil_format_sockaddr_port_(const struct sockaddr *sa, char *out, size_t outlen)\n{\n\tchar b[128];\n\tconst char *res=NULL;\n\tint port;\n\tif (sa->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin = (const struct sockaddr_in*)sa;\n\t\tres = evutil_inet_ntop(AF_INET, &sin->sin_addr,b,sizeof(b));\n\t\tport = ntohs(sin->sin_port);\n\t\tif (res) {\n\t\t\tevutil_snprintf(out, outlen, \"%s:%d\", b, port);\n\t\t\treturn out;\n\t\t}\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin6 = (const struct sockaddr_in6*)sa;\n\t\tres = evutil_inet_ntop(AF_INET6, &sin6->sin6_addr,b,sizeof(b));\n\t\tport = ntohs(sin6->sin6_port);\n\t\tif (res) {\n\t\t\tevutil_snprintf(out, outlen, \"[%s]:%d\", b, port);\n\t\t\treturn out;\n\t\t}\n\t}\n\n\tevutil_snprintf(out, outlen, \"<addr with socktype %d>\",\n\t    (int)sa->sa_family);\n\treturn out;\n}\n\nint\nevutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,\n    int include_port)\n{\n\tint r;\n\tif (0 != (r = (sa1->sa_family - sa2->sa_family)))\n\t\treturn r;\n\n\tif (sa1->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in *sin1, *sin2;\n\t\tsin1 = (const struct sockaddr_in *)sa1;\n\t\tsin2 = (const struct sockaddr_in *)sa2;\n\t\tif (sin1->sin_addr.s_addr < sin2->sin_addr.s_addr)\n\t\t\treturn -1;\n\t\telse if (sin1->sin_addr.s_addr > sin2->sin_addr.s_addr)\n\t\t\treturn 1;\n\t\telse if (include_port &&\n\t\t    (r = ((int)sin1->sin_port - (int)sin2->sin_port)))\n\t\t\treturn r;\n\t\telse\n\t\t\treturn 0;\n\t}\n#ifdef AF_INET6\n\telse if (sa1->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 *sin1, *sin2;\n\t\tsin1 = (const struct sockaddr_in6 *)sa1;\n\t\tsin2 = (const struct sockaddr_in6 *)sa2;\n\t\tif ((r = memcmp(sin1->sin6_addr.s6_addr, sin2->sin6_addr.s6_addr, 16)))\n\t\t\treturn r;\n\t\telse if (include_port &&\n\t\t    (r = ((int)sin1->sin6_port - (int)sin2->sin6_port)))\n\t\t\treturn r;\n\t\telse\n\t\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}\n\n/* Tables to implement ctypes-replacement EVUTIL_IS*() functions.  Each table\n * has 256 bits to look up whether a character is in some set or not.  This\n * fails on non-ASCII platforms, but so does every other place where we\n * take a char and write it onto the network.\n **/\nstatic const ev_uint32_t EVUTIL_ISALPHA_TABLE[8] =\n  { 0, 0, 0x7fffffe, 0x7fffffe, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISALNUM_TABLE[8] =\n  { 0, 0x3ff0000, 0x7fffffe, 0x7fffffe, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISSPACE_TABLE[8] = { 0x3e00, 0x1, 0, 0, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISXDIGIT_TABLE[8] =\n  { 0, 0x3ff0000, 0x7e, 0x7e, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISDIGIT_TABLE[8] = { 0, 0x3ff0000, 0, 0, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISPRINT_TABLE[8] =\n  { 0, 0xffffffff, 0xffffffff, 0x7fffffff, 0, 0, 0, 0x0 };\nstatic const ev_uint32_t EVUTIL_ISUPPER_TABLE[8] = { 0, 0, 0x7fffffe, 0, 0, 0, 0, 0 };\nstatic const ev_uint32_t EVUTIL_ISLOWER_TABLE[8] = { 0, 0, 0, 0x7fffffe, 0, 0, 0, 0 };\n/* Upper-casing and lowercasing tables to map characters to upper/lowercase\n * equivalents. */\nstatic const unsigned char EVUTIL_TOUPPER_TABLE[256] = {\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,\n  80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,\n  96,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,\n  80,81,82,83,84,85,86,87,88,89,90,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,\n};\nstatic const unsigned char EVUTIL_TOLOWER_TABLE[256] = {\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,120,121,122,91,92,93,94,95,\n  96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,\n  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,\n  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,\n  192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n  208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n  224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,\n};\n\n#define IMPL_CTYPE_FN(name)\t\t\t\t\t\t\\\n\tint EVUTIL_##name##_(char c) {\t\t\t\t\t\\\n\t\tev_uint8_t u = c;\t\t\t\t\t\\\n\t\treturn !!(EVUTIL_##name##_TABLE[(u >> 5) & 7] & (1 << (u & 31))); \\\n\t}\nIMPL_CTYPE_FN(ISALPHA)\nIMPL_CTYPE_FN(ISALNUM)\nIMPL_CTYPE_FN(ISSPACE)\nIMPL_CTYPE_FN(ISDIGIT)\nIMPL_CTYPE_FN(ISXDIGIT)\nIMPL_CTYPE_FN(ISPRINT)\nIMPL_CTYPE_FN(ISLOWER)\nIMPL_CTYPE_FN(ISUPPER)\n\nchar EVUTIL_TOLOWER_(char c)\n{\n\treturn ((char)EVUTIL_TOLOWER_TABLE[(ev_uint8_t)c]);\n}\nchar EVUTIL_TOUPPER_(char c)\n{\n\treturn ((char)EVUTIL_TOUPPER_TABLE[(ev_uint8_t)c]);\n}\nint\nevutil_ascii_strcasecmp(const char *s1, const char *s2)\n{\n\tchar c1, c2;\n\twhile (1) {\n\t\tc1 = EVUTIL_TOLOWER_(*s1++);\n\t\tc2 = EVUTIL_TOLOWER_(*s2++);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\telse if (c1 > c2)\n\t\t\treturn 1;\n\t\telse if (c1 == 0)\n\t\t\treturn 0;\n\t}\n}\nint evutil_ascii_strncasecmp(const char *s1, const char *s2, size_t n)\n{\n\tchar c1, c2;\n\twhile (n--) {\n\t\tc1 = EVUTIL_TOLOWER_(*s1++);\n\t\tc2 = EVUTIL_TOLOWER_(*s2++);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\telse if (c1 > c2)\n\t\t\treturn 1;\n\t\telse if (c1 == 0)\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nvoid\nevutil_rtrim_lws_(char *str)\n{\n\tchar *cp;\n\n\tif (str == NULL)\n\t\treturn;\n\n\tif ((cp = strchr(str, '\\0')) == NULL || (cp == str))\n\t\treturn;\n\n\t--cp;\n\n\twhile (*cp == ' ' || *cp == '\\t') {\n\t\t*cp = '\\0';\n\t\tif (cp == str)\n\t\t\tbreak;\n\t\t--cp;\n\t}\n}\n\nstatic int\nevutil_issetugid(void)\n{\n#ifdef EVENT__HAVE_ISSETUGID\n\treturn issetugid();\n#else\n\n#ifdef EVENT__HAVE_GETEUID\n\tif (getuid() != geteuid())\n\t\treturn 1;\n#endif\n#ifdef EVENT__HAVE_GETEGID\n\tif (getgid() != getegid())\n\t\treturn 1;\n#endif\n\treturn 0;\n#endif\n}\n\nconst char *\nevutil_getenv_(const char *varname)\n{\n\tif (evutil_issetugid())\n\t\treturn NULL;\n\n\treturn getenv(varname);\n}\n\nev_uint32_t\nevutil_weakrand_seed_(struct evutil_weakrand_state *state, ev_uint32_t seed)\n{\n\tif (seed == 0) {\n\t\tstruct timeval tv;\n\t\tevutil_gettimeofday(&tv, NULL);\n\t\tseed = (ev_uint32_t)tv.tv_sec + (ev_uint32_t)tv.tv_usec;\n#ifdef _WIN32\n\t\tseed += (ev_uint32_t) _getpid();\n#else\n\t\tseed += (ev_uint32_t) getpid();\n#endif\n\t}\n\tstate->seed = seed;\n\treturn seed;\n}\n\nev_int32_t\nevutil_weakrand_(struct evutil_weakrand_state *state)\n{\n\t/* This RNG implementation is a linear congruential generator, with\n\t * modulus 2^31, multiplier 1103515245, and addend 12345.  It's also\n\t * used by OpenBSD, and by Glibc's TYPE_0 RNG.\n\t *\n\t * The linear congruential generator is not an industrial-strength\n\t * RNG!  It's fast, but it can have higher-order patterns.  Notably,\n\t * the low bits tend to have periodicity.\n\t */\n\tstate->seed = ((state->seed) * 1103515245 + 12345) & 0x7fffffff;\n\treturn (ev_int32_t)(state->seed);\n}\n\nev_int32_t\nevutil_weakrand_range_(struct evutil_weakrand_state *state, ev_int32_t top)\n{\n\tev_int32_t divisor, result;\n\n\t/* We can't just do weakrand() % top, since the low bits of the LCG\n\t * are less random than the high ones.  (Specifically, since the LCG\n\t * modulus is 2^N, every 2^m for m<N will divide the modulus, and so\n\t * therefore the low m bits of the LCG will have period 2^m.) */\n\tdivisor = EVUTIL_WEAKRAND_MAX / top;\n\tdo {\n\t\tresult = evutil_weakrand_(state) / divisor;\n\t} while (result >= top);\n\treturn result;\n}\n\n/**\n * Volatile pointer to memset: we use this to keep the compiler from\n * eliminating our call to memset.\n */\nvoid * (*volatile evutil_memset_volatile_)(void *, int, size_t) = memset;\n\nvoid\nevutil_memclear_(void *mem, size_t len)\n{\n\tevutil_memset_volatile_(mem, 0, len);\n}\n\nint\nevutil_sockaddr_is_loopback_(const struct sockaddr *addr)\n{\n\tstatic const char LOOPBACK_S6[16] =\n\t    \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\";\n\tif (addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)addr;\n\t\treturn (ntohl(sin->sin_addr.s_addr) & 0xff000000) == 0x7f000000;\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;\n\t\treturn !memcmp(sin6->sin6_addr.s6_addr, LOOPBACK_S6, 16);\n\t}\n\treturn 0;\n}\n\nint\nevutil_hex_char_to_int_(char c)\n{\n\tswitch(c)\n\t{\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'A': case 'a': return 10;\n\t\tcase 'B': case 'b': return 11;\n\t\tcase 'C': case 'c': return 12;\n\t\tcase 'D': case 'd': return 13;\n\t\tcase 'E': case 'e': return 14;\n\t\tcase 'F': case 'f': return 15;\n\t}\n\treturn -1;\n}\n\n#ifdef _WIN32\nHMODULE\nevutil_load_windows_system_library_(const TCHAR *library_name)\n{\n  TCHAR path[MAX_PATH];\n  unsigned n;\n  n = GetSystemDirectory(path, MAX_PATH);\n  if (n == 0 || n + _tcslen(library_name) + 2 >= MAX_PATH)\n    return 0;\n  _tcscat(path, TEXT(\"\\\\\"));\n  _tcscat(path, library_name);\n  return LoadLibrary(path);\n}\n#endif\n\n/* Internal wrapper around 'socket' to provide Linux-style support for\n * syscall-saving methods where available.\n *\n * In addition to regular socket behavior, you can use a bitwise or to set the\n * flags EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'type' argument,\n * to make the socket nonblocking or close-on-exec with as few syscalls as\n * possible.\n */\nevutil_socket_t\nevutil_socket_(int domain, int type, int protocol)\n{\n\tevutil_socket_t r;\n#if defined(SOCK_NONBLOCK) && defined(SOCK_CLOEXEC)\n\tr = socket(domain, type, protocol);\n\tif (r >= 0)\n\t\treturn r;\n\telse if ((type & (SOCK_NONBLOCK|SOCK_CLOEXEC)) == 0)\n\t\treturn -1;\n#endif\n#define SOCKET_TYPE_MASK (~(EVUTIL_SOCK_NONBLOCK|EVUTIL_SOCK_CLOEXEC))\n\tr = socket(domain, type & SOCKET_TYPE_MASK, protocol);\n\tif (r < 0)\n\t\treturn -1;\n\tif (type & EVUTIL_SOCK_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (type & EVUTIL_SOCK_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn r;\n}\n\n/* Internal wrapper around 'accept' or 'accept4' to provide Linux-style\n * support for syscall-saving methods where available.\n *\n * In addition to regular accept behavior, you can set one or more of flags\n * EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'flags' argument, to\n * make the socket nonblocking or close-on-exec with as few syscalls as\n * possible.\n */\nevutil_socket_t\nevutil_accept4_(evutil_socket_t sockfd, struct sockaddr *addr,\n    ev_socklen_t *addrlen, int flags)\n{\n\tevutil_socket_t result;\n#if defined(EVENT__HAVE_ACCEPT4) && defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)\n\tresult = accept4(sockfd, addr, addrlen, flags);\n\tif (result >= 0 || (errno != EINVAL && errno != ENOSYS)) {\n\t\t/* A nonnegative result means that we succeeded, so return.\n\t\t * Failing with EINVAL means that an option wasn't supported,\n\t\t * and failing with ENOSYS means that the syscall wasn't\n\t\t * there: in those cases we want to fall back.  Otherwise, we\n\t\t * got a real error, and we should return. */\n\t\treturn result;\n\t}\n#endif\n\tresult = accept(sockfd, addr, addrlen);\n\tif (result < 0)\n\t\treturn result;\n\n\tif (flags & EVUTIL_SOCK_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(result) < 0) {\n\t\t\tevutil_closesocket(result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & EVUTIL_SOCK_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(result) < 0) {\n\t\t\tevutil_closesocket(result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn result;\n}\n\n/* Internal function: Set fd[0] and fd[1] to a pair of fds such that writes on\n * fd[0] get read from fd[1].  Make both fds nonblocking and close-on-exec.\n * Return 0 on success, -1 on failure.\n */\nint\nevutil_make_internal_pipe_(evutil_socket_t fd[2])\n{\n\t/*\n\t  Making the second socket nonblocking is a bit subtle, given that we\n\t  ignore any EAGAIN returns when writing to it, and you don't usally\n\t  do that for a nonblocking socket. But if the kernel gives us EAGAIN,\n\t  then there's no need to add any more data to the buffer, since\n\t  the main thread is already either about to wake up and drain it,\n\t  or woken up and in the process of draining it.\n\t*/\n\n#if defined(EVENT__HAVE_PIPE2)\n\tif (pipe2(fd, O_NONBLOCK|O_CLOEXEC) == 0)\n\t\treturn 0;\n#endif\n#if defined(EVENT__HAVE_PIPE)\n\tif (pipe(fd) == 0) {\n\t\tif (evutil_fast_socket_nonblocking(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_nonblocking(fd[1]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[1]) < 0) {\n\t\t\tclose(fd[0]);\n\t\t\tclose(fd[1]);\n\t\t\tfd[0] = fd[1] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tevent_warn(\"%s: pipe\", __func__);\n\t}\n#endif\n\n#ifdef _WIN32\n#define LOCAL_SOCKETPAIR_AF AF_INET\n#else\n#define LOCAL_SOCKETPAIR_AF AF_UNIX\n#endif\n\tif (evutil_socketpair(LOCAL_SOCKETPAIR_AF, SOCK_STREAM, 0, fd) == 0) {\n\t\tif (evutil_fast_socket_nonblocking(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_nonblocking(fd[1]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[1]) < 0) {\n\t\t\tevutil_closesocket(fd[0]);\n\t\t\tevutil_closesocket(fd[1]);\n\t\t\tfd[0] = fd[1] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tfd[0] = fd[1] = -1;\n\treturn -1;\n}\n\n/* Wrapper around eventfd on systems that provide it.  Unlike the system\n * eventfd, it always supports EVUTIL_EFD_CLOEXEC and EVUTIL_EFD_NONBLOCK as\n * flags.  Returns -1 on error or if eventfd is not supported.\n */\nevutil_socket_t\nevutil_eventfd_(unsigned initval, int flags)\n{\n#if defined(EVENT__HAVE_EVENTFD) && defined(EVENT__HAVE_SYS_EVENTFD_H)\n\tint r;\n#if defined(EFD_CLOEXEC) && defined(EFD_NONBLOCK)\n\tr = eventfd(initval, flags);\n\tif (r >= 0 || flags == 0)\n\t\treturn r;\n#endif\n\tr = eventfd(initval, 0);\n\tif (r < 0)\n\t\treturn r;\n\tif (flags & EVUTIL_EFD_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & EVUTIL_EFD_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn r;\n#else\n\treturn -1;\n#endif\n}\n\nvoid\nevutil_free_globals_(void)\n{\n\tevutil_free_secure_rng_globals_();\n\tevutil_free_sock_err_globals();\n}\n"], "filenames": ["evutil.c"], "buggy_code_start_loc": [2061], "buggy_code_end_loc": [2067], "fixing_code_start_loc": [2061], "fixing_code_end_loc": [2067], "type": "CWE-787", "message": "Stack-based buffer overflow in the evutil_parse_sockaddr_port function in evutil.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (segmentation fault) via vectors involving a long string in brackets in the ip_as_string argument.", "other": {"cve": {"id": "CVE-2016-10196", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T15:59:00.437", "lastModified": "2022-01-31T17:38:26.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the evutil_parse_sockaddr_port function in evutil.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (segmentation fault) via vectors involving a long string in brackets in the ip_as_string argument."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n evutil_parse_sockaddr_port en evutil.c en libevent en versiones anteriores a 2.1.6-beta permite a atacantes provocar una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n) a trav\u00e9s de vectores que implican una cadena larga entre corchetes en el argumento ip_as_string."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.5", "matchCriteriaId": "469B6003-26EE-4332-A275-EB8FB208C484"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:*:*:*", "versionEndExcluding": "53.0", "matchCriteriaId": "83FECC93-8DC3-41D0-8E53-45E1F4D53321"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox_esr:*:*:*:*:*:*:*:*", "versionEndExcluding": "45.9.0", "matchCriteriaId": "58F03A98-1317-4A15-BAB3-AC045AA9AAE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox_esr:52.0:*:*:*:*:*:*:*", "matchCriteriaId": "6AC0200B-0E23-446D-97FF-33341B55B886"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:thunderbird:*:*:*:*:*:*:*:*", "versionEndExcluding": "52.1.0", "matchCriteriaId": "762A750E-2FFF-48F5-941A-99ED9FC2549B"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3789", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/31/17", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/02/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96014", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038320", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1104", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1106", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1201", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.mozilla.org/show_bug.cgi?id=1343453", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/libevent/libevent/blob/release-2.1.6-beta/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/libevent/libevent/commit/329acc18a0768c21ba22522f01a5c7f46cacc4d5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libevent/libevent/issues/318", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201705-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mozilla.org/security/advisories/mfsa2017-10/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mozilla.org/security/advisories/mfsa2017-11/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mozilla.org/security/advisories/mfsa2017-12/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mozilla.org/security/advisories/mfsa2017-13/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libevent/libevent/commit/329acc18a0768c21ba22522f01a5c7f46cacc4d5"}}