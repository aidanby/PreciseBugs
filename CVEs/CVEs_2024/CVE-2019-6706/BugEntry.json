{"buggy_code": ["--[=[\n** lua.stx / llex.c\nTue Dec  2 10:45:48 EDT 1997\n>> BUG: \"lastline\" was not reset on function entry, so debug information\n>> started only in the 2nd line of a function.\n\n\n\n=================================================================\n--- Version 3.1 alpha\n\n** lua.c\nThu Jan 15 14:34:58 EDT 1998\n>> must include \"stdlib.h\" (for \"exit()\").\n\n** lbuiltin.c / lobject.h\nThu Jan 15 14:34:58 EDT 1998\n>> MAX_WORD may be bigger than MAX_INT\n(by lhf)\n\n** llex.c\nMon Jan 19 18:17:18 EDT 1998\n>> wrong line number (+1) in error report when file starts with \"#...\"\n\n** lstrlib.c\nTue Jan 27 15:27:49 EDT 1998\n>> formats like \"%020d\" were considered too big (3 digits); moreover,\n>> some sistems limit printf to at most 500 chars, so we can limit sizes\n>> to 2 digits (99).\n\n** lapi.c\nTue Jan 27 17:12:36 EDT 1998\n>> \"lua_getstring\" may create a new string, so should check GC\n\n** lstring.c / ltable.c\nWed Jan 28 14:48:12 EDT 1998\n>> tables can become full of \"empty\" slots, and keep growing without limits.\n\n** lstrlib.c\nMon Mar  9 15:26:09 EST 1998\n>> gsub('a', '(b?)%1*' ...) loops (because the capture is empty).\n\n** lstrlib.c\nMon May 18 19:20:00 EST 1998\n>> arguments for \"format\" 'x', 'X', 'o' and 'u' must be unsigned int.\n\n\n\n=================================================================\n--- Version 3.1\n\n** liolib.c / lauxlib.c\nMon Sep  7 15:57:02 EST 1998\n>> function \"luaL_argerror\" prints wrong argument number (from a user's point\nof view) when functions have upvalues.\n\n** lstrlib.c\nTue Nov 10 17:29:36 EDT 1998\n>> gsub/strfind do not check whether captures are properly finished.\n(by roberto/tomas)\n\n** lbuiltin.c\nFri Dec 18 11:22:55 EDT 1998\n>> \"tonumber\" goes crazy with negative numbers in other bases (not 10),\nbecause \"strtol\" returns long, not unsigned long.\n(by Visual C++)\n\n** lstrlib.c\nMon Jan  4 10:41:40 EDT 1999\n>> \"format\" does not check size of format item (such as \"%00000...00000d\").\n\n** lapi.c\nWed Feb  3 14:40:21 EDT 1999\n>> getlocal cannot return the local itself, since lua_isstring and\nlua_isnumber can modify it.\n\n** lstrlib.c\nThu Feb  4 17:08:50 EDT 1999\n>> format \"%s\" may break limit of \"sprintf\" on some machines.\n(by Marcelo Sales)\n\n** lzio.c\nThu Mar  4 11:49:37 EST 1999\n>> file stream cannot call fread after EOF.\n(by lhf)\n\n\n\n=================================================================\n--- Version 3.2 (beta)\n\n** lstrlib.c\nFri Apr 30 11:10:20 EST 1999\n>> '$' at end of pattern was matching regular '$', too.\n(by anna; since 2.5)\n\n** lbuiltin.c\nFri May 21 17:15:11 EST 1999\n>> foreach, foreachi, foreachvar points to function in stack when stack\ncan be reallocated.\n(by tomas; since 3.2 beta)\n\n** lparser.c\nWed Jun 16 10:32:46 EST 1999\n>> cannot assign to unlimited variables, because it causes overflow in\nthe number of returns of a function.\n(since 3.1)\n\n\n\n=================================================================\n--- Version 3.2\n\n** lmathlib.c\nWed Aug 18 11:28:38 EST 1999\n>> random(0) and random(x,0) are wrong (0 is read as no argument!).\n(by Dave Bollinger; since 3.1)\n\n** lparser.c\nThu Sep  2 10:07:20 EST 1999\n>> in the (old) expression << ls->fs->f->consts[checkname(ls)] >>, checkname\ncould realloc f->consts.\n(by Supratik Champati; since 3.2 beta)\n\n** lobject.c / lbuiltin.c\nWed Sep  8 17:41:54 EST 1999\n>> tonumber'e1' and tonumber('  ', x), for x!=10, gave 0 instead of nil.\n(since 3.1)\n\n** lstrlib.c\nThu Nov 11 14:36:30 EDT 1999\n>> `strfind' does not handle \\0 in plain search.\n(by Jon Kleiser; since 3.1)\n\n** lparser.c\nWed Dec 29 16:05:43 EDT 1999\n>> return gives wrong line in debug information\n(by lhf; since 3.2 [at least])\n\n** ldo.c\nThu Dec 30 16:39:33 EDT 1999\n>> cannot reopen stdin (for binary mode)\n(by lhf & roberto; since 3.1)\n\n** lapi.c\nThu Mar  2 09:41:53 EST 2000\n>> lua_settable should check stack space (it could call a T.M.)\n(by lhf & celes; since 3.2; it was already fixed by fixed stack)\n\n** lparser.c\nMon Apr  3 09:59:06 EST 2000\n>> '%' should be in expfollow\n(by Edgar Toernig; since 3.1; it was already fixed)\n\n** lbuiltin.c\nMon Apr  3 10:05:05 EST 2000\n>> tostring() without arguments gives seg. fault.\n(by Edgar Toernig; since 3.0)\n\n\n\n=================================================================\n--- Version 4.0 alpha\n\nTested with full test suites (as locked in Mon Apr 24 14:23:11 EST 2000)\nin the following platforms:\n* Linux   - gcc, g++\n* AIX     - gcc\n* Solaris - gcc, cc\n* IRIX\t  - cc, cc-purify\n* Windows - Visual C++ (.c e .cpp, warning level=4)\n\n\n** lstrlib.c\nTue May  2 15:27:58 EST 2000\n>> `strfind' gets wrong subject length when there is an offset\n(by Jon Kleiser; since 4.0a)\n\n** lparser.c\nFri May 12 15:11:12 EST 2000\n>> first element in a list constructor is not adjusted to one value\n>> (e.g. \u00aba = {gsub('a','a','')}\u00bb)\n(by Tomas; since 4.0a)\n\n** lparser.c\nWed May 24 14:50:16 EST 2000\n>> record-constructor starting with an upvalue name gets an error\n>> (e.g. \u00ablocal a; function f() x = {a=1} end\u00bb)\n(by Edgar Toernig; since 3.1)\n\n** lparser.c\nTue Aug 29 15:56:05 EST 2000\n>> error message for `for' uses `while'\n(since 4.0a; already corrected)\n\n** lgc.c\nTue Aug 29 15:57:41 EST 2000\n>> gc tag method for nil could call line hook\n(by ry; since ?)\n\n\n\n=================================================================\n--- Version 4.0 Beta\n\n** liolib.c\nFri Sep 22 15:12:37 EST 2000\n>> `read(\"*w\")' should return nil at EOF\n(by roberto; since 4.0b)\n\n** lvm.c\nMon Sep 25 11:47:48 EST 2000\n>> lua_gettable does not get key from stack top\n(by Philip Yi; since 4.0b)\n\n** lgc.c\nMon Sep 25 11:50:48 EST 2000\n>> GC may crash when checking locked C closures\n(by Philip Yi; since 4.0b)\n\n** lapi.c\nWed Sep 27 09:50:19 EST 2000\n>> lua_tag should return LUA_NOTAG for non-valid indices\n(by Paul Hankin; since 4.0b)\n\n** llex.h / llex.c / lparser.c\nWed Sep 27 13:39:45 EST 2000\n>> parser overwrites semantic information when looking ahead\n>> (e.g. \u00aba = {print'foo'}\u00bb)\n(by Edgar Toernig; since 4.0b, deriving from previous bug)\n\n** liolib.c\nThu Oct 26 10:50:46 EDT 2000\n>> in function `read_file', realloc() doesn't free the buffer if it can't\n>> allocate new memory\n(by Mauro Vezzosi; since 4.0b)\n\n\n\n=================================================================\n--- Version 4.0\n\n** lparser.c\nWed Nov 29 09:51:44 EDT 2000\n>> parser does not accept a `;' after a `return'\n(by lhf; since 4.0b)\n\n** liolib.c\nFri Dec 22 15:30:42 EDT 2000\n>> when `read' fails it must return nil (and not no value)\n(by cassino; since at least 3.1)\n\n** lstring.c/lapi.c\nThu Feb  1 11:55:45 EDT 2001\n>> lua_pushuserdata(L, NULL) is buggy\n(by Edgar Toernig; since 4.0)\n\n** ldo.c\nFri Feb  2 14:06:40 EDT 2001\n>> \u00abwhile 1 dostring[[print('hello\\n')]] end\u00bb never reclaims memory\n(by Andrew Paton; since 4.0b)\n\n** lbaselib.c\nTue Feb  6 11:57:13 EDT 2001\n>> ESC (which starts precompiled code) in C is \\33, not \\27\n(by Edgar Toernig and lhf; since 4.0b)\n\n** lparser.c\nTue Jul 10 16:59:18 EST 2001\n>> error message for `%a' gave wrong line number\n(by Leonardo Constantino; since 4.0)\n\n** lbaselib.c\nFri Dec 21 15:21:05 EDT 2001\n>> seg. fault when rawget/rawset get extra arguments\n(by Eric Mauger; since 4.0b)\n\n** lvm.c\nWed Jun 19 13:28:20 EST 2002\n>> line hook gets wrong `ar'\n(by Daniel C. Sinclair; since 4.0.b)\n\n** ldo.c\nWed Jun 19 13:31:49 EST 2002\n>> `protectedparser' may run GC, and then collect `filename'\n>> (in function `parse_file')\n(by Alex Bilyk; since 4.0)\n\n\n\n\n=================================================================\n--- Version 5.0 alpha\n\n** lgc.c\nFri Aug 30 13:49:14 EST 2002\n>> GC metamethod stored in a weak metatable being collected together with\n>> userdata may not be cleared properly\n(by Roberto; since 5.0a)\n\n** lapi.c\nThu Nov 21 11:00:00 EST 2002\n>> ULONG_MAX>>10 may not fit into an int\n(by Jeff Petkau; since 4.0)\n\n** lparser.c\nFri Dec  6 17:06:40 UTC 2002\n>> scope of generic for variables is not sound\n(by Gavin Wraith; since 5.0a)\n\n\n\n\n=================================================================\n--- Version 5.0 beta\n** lbaselib.c\nFri Dec 20 09:53:19 UTC 2002\n>> `resume' was checking the wrong value for stack overflow\n(by Maik Zimmermann; since 5.0b)\n\n** ldo.c\nThu Jan 23 11:29:06 UTC 2003\n>> error during garbage collection in luaD_protectedparser is not being\n>> protected\n(by Benoit Germain; since 5.0a)\n\n** ldo.c (and others)\nFri Feb 28 14:20:33 EST 2003\n>> GC metamethod calls could mess C/Lua stack syncronization\n(by Roberto; since 5.0b)\n\n** lzio.h/zlio.c\nThu Mar 20 11:40:12 EST 2003\n>> zio mixes a 255 as first char in a buffer with EOZ\n(by lhf; since 5.0a)\n\n\n\n--]=]\n-----------------------------------------------------------------\n-- Lua 5.0 (final)\n\nBug{\nwhat = [[lua_closethread exists only in the manual]],\nreport = [[by Nguyen Binh, 28/04/2003]],\npatch = [[no patch; the manual is wrong]],\n}\n\n\nBug{\nwhat = [[attempt to resume a running coroutine crashes Lua]],\nexample = [[\nfunction co_func (current_co)\n   coroutine.resume(co)\nend\nco = coroutine.create(co_func)\ncoroutine.resume(co)\ncoroutine.resume(co)     --> seg. fault\n]],\nreport = [[by Alex Bilyk, 09/05/2003]], \npatch = [[\n* ldo.c:\n325,326c325\n<     if (nargs >= L->top - L->base)\n<       luaG_runerror(L, \"cannot resume dead coroutine\");\n---\n>     lua_assert(nargs < L->top - L->base);\n329c328,329\n<   else if (ci->state & CI_YIELD) {  /* inside a yield? */\n---\n>   else {  /* inside a yield */\n>     lua_assert(ci->state & CI_YIELD);\n344,345d343\n<   else\n<     luaG_runerror(L, \"cannot resume non-suspended coroutine\");\n351a350,358\n> static int resume_error (lua_State *L, const char *msg) {\n>   L->top = L->ci->base;\n>   setsvalue2s(L->top, luaS_new(L, msg));\n>   incr_top(L);\n>   lua_unlock(L);\n>   return LUA_ERRRUN;\n> }\n> \n> \n355a363,368\n>   if (L->ci == L->base_ci) {\n>     if (nargs >= L->top - L->base)\n>       return resume_error(L, \"cannot resume dead coroutine\");\n>   }\n>   else if (!(L->ci->state & CI_YIELD))  /* not inside a yield? */\n>     return resume_error(L, \"cannot resume non-suspended coroutine\");\n]],\n}\n\n\nBug{\nwhat = [[file:close cannot be called without a file. (results in seg fault)]],\nexample = [[\n> io.stdin.close()    -- correct call shold be io.stdin:close()\n]],\nreport = [[by Tuomo Valkonen, 27/05/2003]], \npatch = [[\n* liolib.c:\n161c161\n<   if (lua_isnone(L, 1)) {\n---\n>   if (lua_isnone(L, 1) && lua_type(L, lua_upvalueindex(1)) == LUA_TTABLE) {\n]],   --}}\n}\n\n\nBug{\nwhat = [[C functions also may have stacks larger than current top]],\nexample = [[\nMust recompile lua with a change in lua.c and with lua_assert defined:\n* lua.c:\n381a382\n>   lua_checkstack(l, 1000);\n]],\nreport = [[Alex Bilyk, 09/06/2003]],\npatch = [[\n* lgc.c:\n247c247\n<     if (!(ci->state & CI_C) && lim < ci->top)\n---\n>     if (lim < ci->top)\n]],\n}\n\n\nBug{\nwhat = [[`pc' address is invalidated when a coroutine is suspended]],\nexample = [[\nfunction g(x)\n    coroutine.yield(x)\nend\n\nfunction f (i)\n  debug.sethook(print, \"l\")\n  for j=1,1000 do\n    g(i+j)\n  end\nend\n\nco = coroutine.wrap(f)\nco(10)\npcall(co)\npcall(co)\n]],\nreport = [[Nick Trout, 07/07/2003]],\npatch = [[\n* lvm.c:\n402,403c402,403\n<   L->ci->u.l.pc = &pc;\n<   if (L->hookmask & LUA_MASKCALL)\n---\n>   if (L->hookmask & LUA_MASKCALL) {\n>     L->ci->u.l.pc = &pc;\n404a405\n>   }\n405a407\n>   L->ci->u.l.pc = &pc;\n676,678c678\n<           lua_assert(ci->u.l.pc == &pc &&\n<                      ttisfunction(ci->base - 1) &&\n<                      (ci->state & CI_SAVEDPC));\n---\n>           lua_assert(ttisfunction(ci->base - 1) && (ci->state & CI_SAVEDPC));\n]]\n}\n\n\nBug{\nwhat = [[userdata to be collected still counts into new GC threshold,\nincreasing memory consumption]],\nreport = [[Roberto, 25/07/2003]],\nexample = [[\na = newproxy(true)\ngetmetatable(a).__gc = function () end\nfor i=1,10000000 do\n  newproxy(a)\n  if math.mod(i, 10000) == 0 then print(gcinfo()) end\nend\n]],\npatch = [[\n* lgc.h:\n18c18\n< void luaC_separateudata (lua_State *L);\n---\n> size_t luaC_separateudata (lua_State *L);\n\n* lgc.c:\n113c113,114\n< void luaC_separateudata (lua_State *L) {\n---\n> size_t luaC_separateudata (lua_State *L) {\n>   size_t deadmem = 0;\n127a129\n>       deadmem += sizeudata(gcotou(curr)->uv.len);\n136a139\n>   return deadmem;\n390c393\n< static void checkSizes (lua_State *L) {\n---\n> static void checkSizes (lua_State *L, size_t deadmem) {\n400c403\n<   G(L)->GCthreshold = 2*G(L)->nblocks;  /* new threshold */\n---\n>   G(L)->GCthreshold = 2*G(L)->nblocks - deadmem;  /* new threshold */\n454c457,458\n< static void mark (lua_State *L) {\n---\n> static size_t mark (lua_State *L) {\n>   size_t deadmem;\n467c471\n<   luaC_separateudata(L);  /* separate userdata to be preserved */\n---\n>   deadmem = luaC_separateudata(L);  /* separate userdata to be preserved */\n475a480\n>   return deadmem;\n480c485\n<   mark(L);\n---\n>   size_t deadmem = mark(L);\n482c487\n<   checkSizes(L);\n---\n>   checkSizes(L, deadmem);\n]]\n}\n\nBug{\nwhat=[[IBM AS400 (OS400) has sizeof(void *)==16, and a `%p' may generate\nup to 60 characters in a `printf'. That causes a buffer overflow in\n`tostring'.]],\n\nreport = [[David Burgess, 25/08/2003]],\n\nexample = [[print{}; (in an AS400 machine)]],\n\npatch = [[\n* liolib.c:\n178c178\n<   char buff[32];\n---\n>   char buff[128];\n\n* lbaselib.c:\n327c327\n<   char buff[64];\n---\n>   char buff[128];\n]]\n}\n\n\nBug{\nwhat = [[syntax `local function' does not increment stack size]],\n\nreport = [[Rici Lake, 26/09/2003]],\n\nexample = [[\n-- must run this with precompiled code\nlocal a,b,c\nlocal function d () end\n]],\n\npatch = [[\n* lparser.c:\n1143a1144\n>   FuncState *fs = ls->fs;\n1145c1146,1147\n<   init_exp(&v, VLOCAL, ls->fs->freereg++);\n---\n>   init_exp(&v, VLOCAL, fs->freereg);\n>   luaK_reserveregs(fs, 1);\n1148c1150,1152\n<   luaK_storevar(ls->fs, &v, &b);\n---\n>   luaK_storevar(fs, &v, &b);\n>   /* debug information will only see the variable after this point! */\n>   getlocvar(fs, fs->nactvar - 1).startpc = fs->pc;\n]],\n\n}\n\n\nBug{\n\nwhat = [[count hook may be called without being set]],\n\nreport = [[Andreas Stenius, 06/10/2003]],\n\nexample = [[\nset your hooks with\n\n  lua_sethook(L, my_hook, LUA_MASKLINE | LUA_MASKRET, 1);\n\n(It is weird to use a count > 0 without setting the count hook,\nbut it is not wrong.)\n]],\n\npatch = [[\n* lvm.c:\n69c69\n<   if (mask > LUA_MASKLINE) {  /* instruction-hook set? */\n---\n>   if (mask & LUA_MASKCOUNT) {  /* instruction-hook set? */\n]],\n\n}\n\n\nBug{\n\nwhat = [[`dofile' eats one return value when called without arguments]],\n\nreport = [[Frederico Abraham, 15/01/2004]],\n\nexample = [[\na,b = dofile()   --< here you enter `return 1,2,3 <eof>'\nprint(a,b)   --> 2   3   (should be 1 and 2)\n]],\n\npatch = [[\n* lbaselib.c:\n313a314\n>   int n = lua_gettop(L);\n317c318\n<   return lua_gettop(L) - 1;\n---\n>   return lua_gettop(L) - n;\n]],\n\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.0.2\n\nBug{\nwhat = [[string concatenation may cause arithmetic overflow, leading\nto a buffer overflow]],\n\nreport = [[Rici Lake, 20/05/2004]],\n\nexample = [[\nlongs = string.rep(\"\\0\", 2^25)\nfunction catter(i)\n    return assert(loadstring(\n      string.format(\"return function(a) return a%s end\",\n                     string.rep(\"..a\", i-1))))()\nend\nrep129 = catter(129)\nrep129(longs)\n]],\n\npatch = [[\n* lvm.c:\n@@ -321,15 +321,15 @@\n         luaG_concaterror(L, top-2, top-1);\n     } else if (tsvalue(top-1)->tsv.len > 0) {  /* if len=0, do nothing */\n       /* at least two string values; get as many as possible */\n-      lu_mem tl = cast(lu_mem, tsvalue(top-1)->tsv.len) +\n-                  cast(lu_mem, tsvalue(top-2)->tsv.len);\n+      size_t tl = tsvalue(top-1)->tsv.len;\n       char *buffer;\n       int i;\n-      while (n < total && tostring(L, top-n-1)) {  /* collect total length */\n-        tl += tsvalue(top-n-1)->tsv.len;\n-        n++;\n+      /* collect total length */\n+      for (n = 1; n < total && tostring(L, top-n-1); n++) {\n+        size_t l = tsvalue(top-n-1)->tsv.len;\n+        if (l >= MAX_SIZET - tl) luaG_runerror(L, \"string length overflow\");\n+        tl += l;\n       }\n-      if (tl > MAX_SIZET) luaG_runerror(L, \"string size overflow\");\n       buffer = luaZ_openspace(L, &G(L)->buff, tl);\n       tl = 0;\n       for (i=n; i>0; i--) {  /* concat all strings */\n]]\n}\n\n\nBug{\nwhat = [[lua_getupvalue and setupvalue do not check for index too small]],\n\nreport = [[Mike Pall, ?/2004]],\n\nexample = [[debug.getupvalue(function() end, 0)]],\n\npatch = [[\n* lapi.c\n941c941\n<     if (n > f->c.nupvalues) return NULL;\n---\n>     if (!(1 <= n && n <= f->c.nupvalues)) return NULL;\n947c947\n<     if (n > p->sizeupvalues) return NULL;\n---\n>     if (!(1 <= n && n <= p->sizeupvalues)) return NULL;\n]]\n}\n\n\nBug{\nwhat = [[values holded in open upvalues of suspended threads may be\nincorrectly collected]],\n\nreport = [[Spencer Schumann, 31/12/2004]],\n\nexample = [[\nlocal thread_id = 0\nlocal threads = {}\n\nfunction fn(thread)\n    thread_id = thread_id + 1\n    threads[thread_id] = function()\n                             thread = nil\n                         end\n    coroutine.yield()\nend\n\nwhile true do\n    local thread = coroutine.create(fn)\n    coroutine.resume(thread, thread)\nend\n]],\n\npatch = [[\n* lgc.c:\n221,224c221,222\n<       if (!u->marked) {\n<         markobject(st, &u->value);\n<         u->marked = 1;\n<       }\n---\n>       markobject(st, u->v);\n>       u->marked = 1;\n]],\n}\n\n\nBug{\nwhat = [[rawset/rawget do not ignore extra arguments]],\n\nreport = [[Romulo Bahiense, 11/03/2005]],\n\nexample = [[\na = {}\nrawset(a, 1, 2, 3)\nprint(a[1], a[2])    -- should be 2 and nil\n]],\n\npatch = [[\n* lbaselib.c:\n175a176\n>   lua_settop(L, 2);\n183a185\n>   lua_settop(L, 3);\n]],\n}\n\n\nBug{\nwhat = [[weak tables that survive one collection are never collected]],\n\nreport = [[Chromix, 02/01/2006]],\n\nexample = [[\na = {}\nprint(gcinfo())\nfor i = 1, 10000 do\n  a[i] = setmetatable({}, {__mode = \"v\"})\nend\ncollectgarbage()\na = nil\ncollectgarbage()\nprint(gcinfo())\n]],\n\npatch = [[\n* lgc.c\n@@ -366,7 +366,7 @@\n   GCObject *curr;\n   int count = 0;  /* number of collected items */\n   while ((curr = *p) != NULL) {\n-    if (curr->gch.marked > limit) {\n+    if ((curr->gch.marked & ~(KEYWEAK | VALUEWEAK)) > limit) {\n       unmark(curr);\n       p = &curr->gch.next;\n     }\n]],\n\n}\n\n\nBug{\nwhat = [[Some \"not not exp\" may not result in boolean values]],\nreport = [[]],\nsince = [[4.0]],\nexample = [[\n-- should print false, but prints nil\nprint(not not (nil and 4))\n]],\npatch = [[]],\n}\n\n\nBug{\nwhat = [[On some machines, closing a \"piped file\" (created with io.popen)\nmay crash Lua]],\nreport = [[]],\nsince = [[5.0]],\nexample = [[\n-- only on some machines\n  f = io.popen(\"ls\")\n  f:close()\n]],\npatch = [[]],\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1\n\nBug{\nwhat = [[In 16-bit machines, expressions and/or with numeric constants as the\nright operand may result in weird values]],\n\nreport = [[Andreas Stenius/Kein-Hong Man, 15/03/2006]],\n\nexample = [[\nprint(false or 0)   -- on 16-bit machines\n]],\n\npatch = [[\n* lcode.c:\n@@ -731,17 +731,15 @@\n     case OPR_AND: {\n       lua_assert(e1->t == NO_JUMP);  /* list must be closed */\n       luaK_dischargevars(fs, e2);\n-      luaK_concat(fs, &e1->f, e2->f);\n-      e1->k = e2->k; e1->u.s.info = e2->u.s.info;\n-      e1->u.s.aux = e2->u.s.aux; e1->t = e2->t;\n+      luaK_concat(fs, &e2->f, e1->f);\n+      *e1 = *e2;\n       break;\n     }\n     case OPR_OR: {\n       lua_assert(e1->f == NO_JUMP);  /* list must be closed */\n       luaK_dischargevars(fs, e2);\n-      luaK_concat(fs, &e1->t, e2->t);\n-      e1->k = e2->k; e1->u.s.info = e2->u.s.info;\n-      e1->u.s.aux = e2->u.s.aux; e1->f = e2->f;\n+      luaK_concat(fs, &e2->t, e1->t);\n+      *e1 = *e2;\n       break;\n     }\n]],\n\n}\n\n\nBug{\nwhat = [[luaL_checkudata may produce wrong error message]],\n\nreport = [[Greg Falcon, 21/03/2006]],\n\nexample = [[\ngetmetatable(io.stdin).__gc()\n  --> bad argument #1 to '__gc' (FILE* expected, got table)\n]],\n\npatch = [[\n* lauxlib.c:\n@@ -123,11 +123,17 @@\n\n LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {\n   void *p = lua_touserdata(L, ud);\n-  lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */\n-  if (p == NULL || !lua_getmetatable(L, ud) || !lua_rawequal(L, -1, -2))\n-    luaL_typerror(L, ud, tname);\n-  lua_pop(L, 2);  /* remove both metatables */\n-  return p;\n+  if (p != NULL) {  /* value is a userdata? */\n+    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n+      lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */\n+      if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */\n+        lua_pop(L, 2);  /* remove both metatables */\n+        return p;\n+      }\n+    }\n+  }\n+  luaL_typerror(L, ud, tname);  /* else error */\n+  return NULL;  /* to avoid warnings */\n }\n]]\n\n}\n\n\nBug{\nwhat = [[\nIn Windows,\nwhen Lua is used in an application that also uses DirectX,\nit may present an erractic behavior.\nTHIS IS NOT A LUA BUG!\nThe problem is that DirectX violates an ABI that Lua depends on.]],\n\npatch = [[\nThe simplest solution is to use DirectX with\nthe D3DCREATE_FPU_PRESERVE flag.\n\nOtherwise, you can change the definition of lua_number2int,\nin luaconf.h, to this one:\n#define lua_number2int(i,d)   __asm fld d   __asm fistp i\n]],\n\n}\n\n\nBug{\nwhat = [[option '%q' in string.format does not handle '\\r' correctly.]],\n\nexample = [[\nlocal s = \"a string with \\r and \\n and \\r\\n and \\n\\r\"\nlocal c = string.format(\"return %q\", s)\nassert(assert(loadstring(c))() == s)\n]],\n\npatch = [[\n* lstrlib.c:\n@@ -703,6 +703,10 @@\n         luaL_addchar(b, *s);\n         break;\n       }\n+      case '\\r': {\n+        luaL_addlstring(b, \"\\\\r\", 2);\n+        break;\n+      }\n       case '\\0': {\n         luaL_addlstring(b, \"\\\\000\", 4);\n         break;\n]],\n\n}\n\n\nBug{\nwhat = [[lua_dostring/lua_dofile should return any values returned\nby the chunk]],\n\npatch = [[\n* lauxlib.h:\n@@ -108,9 +108,11 @@\n\n #define luaL_typename(L,i)     lua_typename(L, lua_type(L,(i)))\n\n-#define luaL_dofile(L, fn)     (luaL_loadfile(L, fn) || lua_pcall(L, 0, 0, 0))\n+#define luaL_dofile(L, fn) \\\n+       (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n-#define luaL_dostring(L, s)    (luaL_loadstring(L, s) || lua_pcall(L, 0, 0, 0))+#define luaL_dostring(L, s) \\\n+       (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))\n]],\n\n}\n\n\nBug{\n\nwhat = [[garbage collector does not compensate enough for finalizers]],\n\npatch = [[\nlgc.c:\n@@ -322,4 +322,6 @@\n\n-static void propagateall (global_State *g) {\n-  while (g->gray) propagatemark(g);\n+static size_t propagateall (global_State *g) {\n+  size_t m = 0;\n+  while (g->gray) m += propagatemark(g);\n+  return m;\n }\n@@ -542,3 +544,3 @@\n   marktmu(g);  /* mark `preserved' userdata */\n-  propagateall(g);  /* remark, to propagate `preserveness' */\n+  udsize += propagateall(g);  /* remark, to propagate `preserveness' */\n   cleartable(g->weak);  /* remove collected objects from weak tables */\n@@ -592,2 +594,4 @@\n         GCTM(L);\n+        if (g->estimate > GCFINALIZECOST)\n+          g->estimate -= GCFINALIZECOST;\n]]\n}\n\n\nBug{\n\nwhat = [[debug hooks may get wrong when mixed with coroutines]],\n\nreport = [[by Ivko Stanilov, 03/06/2006]],\n\nexample = [[\nco = coroutine.create(function (a,b)\n   coroutine.yield(a, b)\n   return b, \"end\"\nend)\n\ndebug.sethook(co, function() end, \"lcr\")\ncoroutine.resume(co, 100, 2000)\ncoroutine.resume(co, 100, 2000)\n]],\n\npatch = [[\n* ldo.c:\n@@ -389,6 +389,7 @@\n       return;\n   }\n   else {  /* resuming from previous yield */\n+    L->status = 0;\n     if (!f_isLua(ci)) {  /* `common' yield? */\n       /* finish interrupted execution of `OP_CALL' */\n       lua_assert(GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_CALL ||\n@@ -399,7 +400,6 @@\n     else  /* yielded inside a hook: just continue its execution */\n       L->base = L->ci->base;\n   }\n-  L->status = 0;\n   luaV_execute(L, cast_int(L->ci - L->base_ci));\n }\n]],\n\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.1\n\nBug{\nwhat = [[list constructors have wrong limit]],\n\nreport = [[by Norman Ramsey, June 2006]],\n\nsince = \"5.1\",\n\nexample = [[\na = {}\na[1] = \"x={1\"\nfor i = 2, 2^20 do\n  a[i] = 1\nend\na[#a + 1] = \"}\"\ns = table.concat(a, \",\")\nassert(loadstring(s))()\nprint(#x)\n]],\n\npatch = [[\n* lparser.c:\n@@ -489,7 +489,7 @@\n\n static void listfield (LexState *ls, struct ConsControl *cc) {\n   expr(ls, &cc->v);\n-  luaY_checklimit(ls->fs, cc->na, MAXARG_Bx, \"items in a constructor\");\n+  luaY_checklimit(ls->fs, cc->na, MAX_INT, \"items in a constructor\");\n   cc->na++;\n   cc->tostore++;\n }\n]],\n\n}\n\n\nBug{\nwhat = [[wrong message error in some cases involving closures]],\n\nreport = [[Shmuel Zeigerman, on 07/2006]],\n\nsince = \"5.1\",\n\nexample = [[\nlocal Var\nlocal function main()\n  NoSuchName (function() Var=0 end)\nend\nmain()\n--> lua5.1: temp:3: attempt to call upvalue 'Var' (a nil value)\n]],\n\npatch = [[\n*ldebug.c:\n@@ -435,14 +435,16 @@\n         break;\n       }\n       case OP_CLOSURE: {\n-        int nup;\n+        int nup, j;\n         check(b < pt->sizep);\n         nup = pt->p[b]->nups;\n         check(pc + nup < pt->sizecode);\n-        for (; nup>0; nup--) {\n-          OpCode op1 = GET_OPCODE(pt->code[pc+nup]);\n+        for (j = 1; j <= nup; j++) {\n+          OpCode op1 = GET_OPCODE(pt->code[pc + j]);\n           check(op1 == OP_GETUPVAL || op1 == OP_MOVE);\n         }\n+        if (reg != NO_REG)  /* tracing? */\n+          pc += nup;  /* do not 'execute' these pseudo-instructions */\n         break;\n       }\n       case OP_VARARG: {\n]],\n\n}\n\n\nBug{\nwhat = [[string.format(\"%\") may read past the string]],\nreport = [[Roberto, on 09/2006]],\nsince = [[5.0]],\nexample = [[print(string.format(\"%\"))]],\npatch = [[\n*lstrlib.c:\n@@ -723,7 +723,7 @@\n\n static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {   const char *p = strfrmt;\n-  while (strchr(FLAGS, *p)) p++;  /* skip flags */\n+  while (*p != '\\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */\n   if ((size_t)(p - strfrmt) >= sizeof(FLAGS))\n     luaL_error(L, \"invalid format (repeated flags)\");\n   if (isdigit(uchar(*p))) p++;  /* skip width */\n]],\n}\n\n\nBug{\nwhat = [[os.date throws an error when result is the empty string]],\nreport = [[]],\nsince = [[4.0]],\nexample = [[print(os.date(\"\"))]],\npatch = [[\n*loslib.c:\n@@ -148,7 +148,18 @@\n   else {\n-    char b[256];\n-    if (strftime(b, sizeof(b), s, stm))\n-      lua_pushstring(L, b);\n-    else\n-      return luaL_error(L, LUA_QL(\"date\") \" format too long\");\n+    char cc[3];\n+    luaL_Buffer b;\n+    cc[0] = '%'; cc[2] = '\\0';\n+    luaL_buffinit(L, &b);\n+    for (; *s; s++) {\n+      if (*s != '%' || *(s + 1) == '\\0')  /* no conversion specifier? */\n+        luaL_addchar(&b, *s);\n+      else {\n+        size_t reslen;\n+        char buff[200];  /* should be big enough for any conversion result */\n+        cc[1] = *(++s);\n+        reslen = strftime(buff, sizeof(buff), cc, stm);\n+        luaL_addlstring(&b, buff, reslen);\n+      }\n+    }\n+    luaL_pushresult(&b);\n   }\n]],\n}\n\n\nBug{\nwhat = [[setfenv accepts invalid 1st argument]],\nreport = [[Doug Rogers, on 02/2007]],\nsince = [[5.0]],\nexample = [[setfenv(nil, {})   -- should throw an error]],\npatch = [[\n*lbaselib.c:\n@@ -116,3 +116,3 @@\n\n-static void getfunc (lua_State *L) {\n+static void getfunc (lua_State *L, int opt) {\n   if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);\n@@ -120,3 +120,3 @@\n     lua_Debug ar;\n-    int level = luaL_optint(L, 1, 1);\n+    int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);\n     luaL_argcheck(L, level >= 0, 1, \"level must be non-negative\");\n@@ -133,3 +133,3 @@\n static int luaB_getfenv (lua_State *L) {\n-  getfunc(L);\n+  getfunc(L, 1);\n   if (lua_iscfunction(L, -1))  /* is a C function? */\n@@ -144,3 +144,3 @@\n   luaL_checktype(L, 2, LUA_TTABLE);\n-  getfunc(L);\n+  getfunc(L, 0);\n   lua_pushvalue(L, 2);\n]],\n}\n\n\nBug{\nwhat = [[wrong code for arithmetic expressions in some specific scenarios]],\nreport = [[Thierry Grellier, on 01/2007]],\nsince = [[5.1]],\nexample = [[\n-- use a large number of names (almost 256)\nv1=1; v2=1; v3=1; v4=1; v5=1; v6=1; v7=1; v8=1; v9=1;\nv10=1; v11=1; v12=1; v13=1; v14=1; v15=1; v16=1; v17=1;\nv18=1; v19=1; v20=1; v21=1; v22=1; v23=1; v24=1; v25=1;\nv26=1; v27=1; v28=1; v29=1; v30=1; v31=1; v32=1; v33=1;\nv34=1; v35=1; v36=1; v37=1; v38=1; v39=1; v40=1; v41=1;\nv42=1; v43=1; v44=1; v45=1; v46=1; v47=1; v48=1; v49=1;\nv50=1; v51=1; v52=1; v53=1; v54=1; v55=1; v56=1; v57=1;\nv58=1; v59=1; v60=1; v61=1; v62=1; v63=1; v64=1; v65=1;\nv66=1; v67=1; v68=1; v69=1; v70=1; v71=1; v72=1; v73=1;\nv74=1; v75=1; v76=1; v77=1; v78=1; v79=1; v80=1; v81=1;\nv82=1; v83=1; v84=1; v85=1; v86=1; v87=1; v88=1; v89=1;\nv90=1; v91=1; v92=1; v93=1; v94=1; v95=1; v96=1; v97=1;\nv98=1; v99=1; v100=1; v101=1; v102=1; v103=1; v104=1; v105=1;\nv106=1; v107=1; v108=1; v109=1; v110=1; v111=1; v112=1; v113=1;\nv114=1; v115=1; v116=1; v117=1; v118=1; v119=1; v120=1; v121=1;\nv122=1; v123=1; v124=1; v125=1; v126=1; v127=1; v128=1; v129=1;\nv130=1; v131=1; v132=1; v133=1; v134=1; v135=1; v136=1; v137=1;\nv138=1; v139=1; v140=1; v141=1; v142=1; v143=1; v144=1; v145=1;\nv146=1; v147=1; v148=1; v149=1; v150=1; v151=1; v152=1; v153=1;\nv154=1; v155=1; v156=1; v157=1; v158=1; v159=1; v160=1; v161=1;\nv162=1; v163=1; v164=1; v165=1; v166=1; v167=1; v168=1; v169=1;\nv170=1; v171=1; v172=1; v173=1; v174=1; v175=1; v176=1; v177=1;\nv178=1; v179=1; v180=1; v181=1; v182=1; v183=1; v184=1; v185=1;\nv186=1; v187=1; v188=1; v189=1; v190=1; v191=1; v192=1; v193=1;\nv194=1; v195=1; v196=1; v197=1; v198=1; v199=1; v200=1; v201=1;\nv202=1; v203=1; v204=1; v205=1; v206=1; v207=1; v208=1; v209=1;\nv210=1; v211=1; v212=1; v213=1; v214=1; v215=1; v216=1; v217=1;\nv218=1; v219=1; v220=1; v221=1; v222=1; v223=1; v224=1; v225=1;\nv226=1; v227=1; v228=1; v229=1; v230=1; v231=1; v232=1; v233=1;\nv234=1; v235=1; v236=1; v237=1; v238=1; v239=1; v240=1; v241=1;\nv242=1; v243=1; v244=1; v245=1; v246=1; v247=1; v248=1; v249=1;\nv250=1;\nv251={k1 = 1};\nv252=1;\nprint(2 * v251.k1, v251.k1 * 2);   -- 2 2, OK\nv253=1;\nprint(2 * v251.k1, v251.k1 * 2);   -- 1 2, ???\n]],\npatch = [[\n*lcode.c:\n@@ -657,10 +657,16 @@\n   if (constfolding(op, e1, e2))\n     return;\n   else {\n-    int o1 = luaK_exp2RK(fs, e1);\n     int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;\n-    freeexp(fs, e2);\n-    freeexp(fs, e1);\n+    int o1 = luaK_exp2RK(fs, e1);\n+    if (o1 > o2) {\n+      freeexp(fs, e1);\n+      freeexp(fs, e2);\n+    }\n+    else {\n+      freeexp(fs, e2);\n+      freeexp(fs, e1);\n+    }\n     e1->u.s.info = luaK_codeABC(fs, op, 0, o1, o2);\n     e1->k = VRELOCABLE;\n   }\n@@ -718,10 +724,15 @@\n       luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */\n       break;\n     }\n-    default: {\n+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:\n+    case OPR_MOD: case OPR_POW: {\n       if (!isnumeral(v)) luaK_exp2RK(fs, v);\n       break;\n     }\n+    default: {\n+      luaK_exp2RK(fs, v);\n+      break;\n+    }\n   }\n }\n]],\n}\n\nBug{\nwhat = [[assignment of nil to parameter may be optimized away]],\nreport = [[Thomas Lauer, on 03/2007]],\nsince = [[5.1]],\nexample = [[\nfunction f (a)\n  a=nil\n  return a\nend\n\nprint(f(\"test\"))\n]],\npatch = [[\n*lcode.c:\n@@ -35,16 +35,20 @@\n void luaK_nil (FuncState *fs, int from, int n) {\n   Instruction *previous;\n   if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */\n-    if (fs->pc == 0)  /* function start? */\n-      return;  /* positions are already clean */\n-    previous = &fs->f->code[fs->pc-1];\n-    if (GET_OPCODE(*previous) == OP_LOADNIL) {\n-      int pfrom = GETARG_A(*previous);\n-      int pto = GETARG_B(*previous);\n-      if (pfrom <= from && from <= pto+1) {  /* can connect both? */\n-        if (from+n-1 > pto)\n-          SETARG_B(*previous, from+n-1);\n-        return;\n+    if (fs->pc == 0) {  /* function start? */\n+      if (from >= fs->nactvar)\n+        return;  /* positions are already clean */\n+    }\n+    else {\n+      previous = &fs->f->code[fs->pc-1];\n+      if (GET_OPCODE(*previous) == OP_LOADNIL) {\n+        int pfrom = GETARG_A(*previous);\n+        int pto = GETARG_B(*previous);\n+        if (pfrom <= from && from <= pto+1) {  /* can connect both? */\n+          if (from+n-1 > pto)\n+            SETARG_B(*previous, from+n-1);\n+          return;\n+        }\n       }\n     }\n   }\n]],\n}\n\n\nBug{\nwhat = [[__concat metamethod converts numbers to strings]],\nreport = [[Paul Winwood, on 12/2006]],\nsince = [[5.0]],\nexample = [[\na = {}\nsetmetatable(a, {__concat = function (a,b) print(type(a), type(b)) end})\na = 4 .. a\n]],\npatch = [[\n*lvm.c:\n@@ -281,10 +281,12 @@\n   do {\n     StkId top = L->base + last + 1;\n     int n = 2;  /* number of elements handled in this pass (at least 2) */\n-    if (!tostring(L, top-2) || !tostring(L, top-1)) {\n+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {\n       if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))\n         luaG_concaterror(L, top-2, top-1);\n-    } else if (tsvalue(top-1)->len > 0) {  /* if len=0, do nothing */\n+    } else if (tsvalue(top-1)->len == 0)  /* second op is empty? */\n+      (void)tostring(L, top - 2);  /* result is first op (as string) */\n+    else {\n       /* at least two string values; get as many as possible */\n       size_t tl = tsvalue(top-1)->len;\n       char *buffer;\n]],\n}\n\n\nBug{\nwhat = [[As a library, loadlib.c should not access Lua internals\n(via lobject.h)]],\nreport = [[J\u00e9r\u00f4me Vuarand, on 03/2007]],\nsince = [[5.0]],\nexample = [[the bug has no effect on external behavior]],\npatch = [[remove the '#include \"lobject.h\" and use\n'lua_pushfstring' instead of 'luaO_pushfstring']],\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.2\n\nBug{\nwhat = [[Lua may close standard files,\nwhich then may be used by C]],\nreport = [[David Manura/Ross Berteig, on 04/2007]],\nsince = [[]],\nexample = [[\nio.close(io.stderr)\n-- in some systems, following attempts to write to 'stderr' may crash\na = a + 1\n]],\npatch = [[\n]],\n}\n\nBug{\nwhat = [[code generated for \"-nil\", \"-true\", and \"-false\" is wrong]],\nreport = [[David Manura/Rici Lake, on 04/2007]],\nsince = [[5.1]],\nexample = [[print(-nil)]],\npatch = [[\nlcode.c:\n@@ -699,7 +699,7 @@\n   e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;\n   switch (op) {\n     case OPR_MINUS: {\n-      if (e->k == VK)\n+      if (!isnumeral(e))\n         luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */\n       codearith(fs, OP_UNM, e, &e2);\n       break;\n]],\n}\n\nBug{\nwhat = [[Count hook may be called without being set.]],\nreport = [[Mike Pall, on 05/2007]],\nsince = [[?]],\nexample = [[]],\npatch = [[\nlvm.c:\n@@ -61,11 +61,9 @@\n   lu_byte mask = L->hookmask;\n   const Instruction *oldpc = L->savedpc;\n   L->savedpc = pc;\n-  if (mask > LUA_MASKLINE) {  /* instruction-hook set? */\n-    if (L->hookcount == 0) {\n-      resethookcount(L);\n-      luaD_callhook(L, LUA_HOOKCOUNT, -1);\n-    }\n+  if ((mask & LUA_MASKCOUNT) && L->hookcount == 0) {\n+    resethookcount(L);\n+    luaD_callhook(L, LUA_HOOKCOUNT, -1);\n   }\n   if (mask & LUA_MASKLINE) {\n     Proto *p = ci_func(L->ci)->l.p;\n]],\n}\n\nBug{\nwhat = [[recursive coroutines may overflow C stack]],\nreport = [[ , on ]],\nsince = [[5.0]],\nexample = [[\na = function(a) coroutine.wrap(a)(a) end\na(a)\n]],\npatch = [[The 'nCcalls' counter should be shared by all threads.\n(That is, it should be declared in the 'global_State' structure,\nnot in 'lua_State'.)\n]],\n}\n\nBug{\nwhat = [[wrong error message in some concatenations]],\nreport = [[Alex Davies, on 05/2007]],\nsince = [[5.1.2]],\nexample = [[a = nil; a = (1)..a]],\npatch = [[\nldebug.c:\n@@ -563,8 +563,8 @@\n\n\n void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {\n-  if (ttisstring(p1)) p1 = p2;\n-  lua_assert(!ttisstring(p1));\n+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;\n+  lua_assert(!ttisstring(p1) && !ttisnumber(p1));\n   luaG_typeerror(L, p1, \"concatenate\");\n }\n\n]],\n}\n\nBug{\nwhat = [[Very small numbers all collide in the hash function.\n(This creates only performance problems; the behavoir is correct.)]],\nreport = [[, on ]],\nsince = [[5.0]],\nexample = [[]],\npatch = [[\nltable.c:\n87,88c87,88\n<   n += 1;  /* normalize number (avoid -0) */\n<   lua_assert(sizeof(a) <= sizeof(n));\n---\n>   if (luai_numeq(n, 0))  /* avoid problems with -0 */\n>     return gnode(t, 0);\n]],\n}\n\nBug{\nwhat = [[Too many variables in an assignment may cause a\nC stack overflow]],\nreport = [[Mike Pall, on 07/2007]],\nsince = [[5.0]],\nexample = [[\n$ ulimit -s 1024       # Reduce C stack to 1MB for quicker results\n$ lua -e 'local s = \"a,\"; for i=1,18 do s = s..s end print(loadstring(\"local a;\"..s..\"a=nil\", \"\"))'\n]],\npatch = [[\nlparser.c:\n@@ -938,6 +938,8 @@\n     primaryexp(ls, &nv.v);\n     if (nv.v.k == VLOCAL)\n       check_conflict(ls, lh, &nv.v);\n+    luaY_checklimit(ls->fs, nvars, LUAI_MAXCCALLS - ls->L->nCcalls,\n+                    \"variable names\");\n     assignment(ls, &nv, nvars+1);\n   }\n   else {  /* assignment -> `=' explist1 */\n]],\n}\n\nBug{\nwhat = [[An error in a module loaded through the '-l' option\nshows no traceback]],\nreport = [[David Manura, on 08/2007]],\nsince = [[5.1]],\nexample = [[lua -ltemp    (assuming temp.lua has an error)]],\npatch = [[\nlua.c:\n@@ -144,7 +144,7 @@\n static int dolibrary (lua_State *L, const char *name) {\n   lua_getglobal(L, \"require\");\n   lua_pushstring(L, name);\n-  return report(L, lua_pcall(L, 1, 0, 0));\n+  return report(L, docall(L, 1, 1));\n }\n]],\n}\n\nBug{\nwhat = [['gsub' may go wild when wrongly called without its third\nargument and with a large subject]],\nreport = [[Florian Berger, on 10/2007]],\nsince = [[5.1]],\nexample = [[\nx = string.rep('a', 10000) .. string.rep('b', 10000)\nprint(#string.gsub(x, 'b'))\n]],\npatch = [[\nlstrlib.c:\n@@ -631,6 +631,2 @@\n     }\n-    default: {\n-      luaL_argerror(L, 3, \"string/function/table expected\"); \n-      return;\n-    }\n   }\n@@ -650,2 +646,3 @@\n   const char *p = luaL_checkstring(L, 2);\n+  int  tr = lua_type(L, 3);\n   int max_s = luaL_optint(L, 4, srcl+1);\n@@ -655,2 +652,5 @@\n   luaL_Buffer b;\n+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||\n+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,\n+                      \"string/function/table expected\");\n   luaL_buffinit(L, &b);\n]],\n}\n\nBug{\nwhat = [[table.remove removes last element of a table when given\nan out-of-bound index]],\nreport = [[Patrick Donnelly, on 11/2007]],\nsince = [[5.0]],\nexample = [[\na = {1,2,3}\ntable.remove(a, 4)\nprint(a[3])   --> nil   (should be 3)\n]],\npatch = [[\nltablib.c:\n@@ -118,7 +118,8 @@\n static int tremove (lua_State *L) {\n   int e = aux_getn(L, 1);\n   int pos = luaL_optint(L, 2, e);\n-  if (e == 0) return 0;  /* table is `empty' */\n+  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */\n+   return 0;  /* nothing to remove */\n   luaL_setn(L, 1, e - 1);  /* t.n = n-1 */\n   lua_rawgeti(L, 1, pos);  /* result = t[pos] */\n   for ( ;pos<e; pos++) {\n]],\n}\n\nBug{\nwhat = [[lua_setfenv may crash if called over an invalid object]],\nreport = [[Mike Pall, on 11/2007]],\nsince = [[5.1]],\nexample = [[\n> debug.setfenv(3, {})\n]],\npatch = [[\nlapi.c:\n@@ -749,7 +749,7 @@\n       res = 0;\n       break;\n   }\n-  luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));\n+  if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));\n   L->top--;\n   lua_unlock(L);\n   return res;\n]],\n}\n\nBug{\nwhat = [[stand-alone interpreter shows incorrect error message\nwhen the \"message\" is a coroutine]],\nreport = [[Patrick Donnelly, on 17/12/2007]],\nsince = [[5.1]],\nexample = [[> error(coroutine.create(function() end))]],\npatch = [[\nlua.c:\n@@ -74,6 +74,8 @@\n \n \n static int traceback (lua_State *L) {\n+  if (!lua_isstring(L, 1))  /* 'message' not a string? */\n+    return 1;  /* keep it intact */\n   lua_getfield(L, LUA_GLOBALSINDEX, \"debug\");\n   if (!lua_istable(L, -1)) {\n     lua_pop(L, 1);\n\n]],\n}\n\nBug{\nwhat = [[debug.sethook/gethook may overflow the thread's stack]],\nreport = [[Ivko Stanilov, on 2008/01/04]],\nsince = [[5.1]],\nexample = [[\na = coroutine.create(function() yield() end) \ncoroutine.resume(a)\ndebug.sethook(a)      -- may overflow the stack of 'a'\n]],\npatch = [[\nldblib.c:\n@@ -268,12 +268,11 @@\n     count = luaL_optint(L, arg+3, 0);\n     func = hookf; mask = makemask(smask, count);\n   }\n-  gethooktable(L1);\n-  lua_pushlightuserdata(L1, L1);\n+  gethooktable(L);\n+  lua_pushlightuserdata(L, L1);\n   lua_pushvalue(L, arg+1);\n-  lua_xmove(L, L1, 1);\n-  lua_rawset(L1, -3);  /* set new hook */\n-  lua_pop(L1, 1);  /* remove hook table */\n+  lua_rawset(L, -3);  /* set new hook */\n+  lua_pop(L, 1);  /* remove hook table */\n   lua_sethook(L1, func, mask, count);  /* set hooks */\n   return 0;\n }\n@@ -288,11 +287,10 @@\n   if (hook != NULL && hook != hookf)  /* external hook? */\n     lua_pushliteral(L, \"external hook\");\n   else {\n-    gethooktable(L1);\n-    lua_pushlightuserdata(L1, L1);\n-    lua_rawget(L1, -2);   /* get hook */\n-    lua_remove(L1, -2);  /* remove hook table */\n-    lua_xmove(L1, L, 1);\n+    gethooktable(L);\n+    lua_pushlightuserdata(L, L1);\n+    lua_rawget(L, -2);   /* get hook */\n+    lua_remove(L, -2);  /* remove hook table */\n   }\n   lua_pushstring(L, unmakemask(mask, buff));\n   lua_pushinteger(L, lua_gethookcount(L1));\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.3\n\nBug{\nwhat = [[LUAI_MAXCSTACK must be smaller than -LUA_REGISTRYINDEX]],\nreport = [[Patrick Donnelly, on 2008/02/11]],\nsince = [[5.1.3]],\nexample = [[\nj = 1e4\nco = coroutine.create(function()\n       t = {}\n       for i = 1, j do t[i] = i end\n       return unpack(t)\nend)\nprint(coroutine.resume(co))\n]],\npatch = [[\nluaconf.h:\n443c443,444\n< ** functions to consume unlimited stack space.\n---\n> ** functions to consume unlimited stack space. (must be smaller than\n> ** -LUA_REGISTRYINDEX)\n445,446c446\n< #define LUAI_MCS_AUX  ((int)(INT_MAX / (4*sizeof(LUA_NUMBER))))\n< #define LUAI_MAXCSTACK        (LUAI_MCS_AUX > SHRT_MAX ? SHRT_MAX : LUAI_MCS_AUX)\n---\n> #define LUAI_MAXCSTACK        8000\n]],\n}\n\nBug{\nwhat = [[coroutine.resume pushes element without ensuring stack size]],\nreport = [[on 2008/02/11]],\nsince = [[5.0]],\nexample = [[(this bug cannot be detected without internal assertions)]],\npatch = [[\nlbaselib.c:\n@@ -526,7 +526,7 @@\n   status = lua_resume(co, narg);\n   if (status == 0 || status == LUA_YIELD) {\n     int nres = lua_gettop(co);\n-    if (!lua_checkstack(L, nres))\n+    if (!lua_checkstack(L, nres + 1))\n       luaL_error(L, \"too many results to resume\");\n     lua_xmove(co, L, nres);  /* move yielded values */\n     return nres;\n]],\n}\n\nBug{\nwhat = [[lua_checkstack may have arithmetic overflow for large 'size']],\nreport = [[Patrick Donnelly, on 2008/02/12]],\nsince = [[5.0]],\nexample = [[\nprint(unpack({1,2,3}, 0, 2^31-3))\n]],\npatch = [[\n--- lapi.c      2008/01/03 15:20:39     2.55.1.3\n+++ lapi.c      2008/02/14 16:05:21\n@@ -93,15 +93,14 @@\n \n \n LUA_API int lua_checkstack (lua_State *L, int size) {\n-  int res;\n+  int res = 1;\n   lua_lock(L);\n-  if ((L->top - L->base + size) > LUAI_MAXCSTACK)\n+  if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)\n     res = 0;  /* stack overflow */\n-  else {\n+  else if (size > 0) {\n     luaD_checkstack(L, size);\n     if (L->ci->top < L->top + size)\n       L->ci->top = L->top + size;\n-    res = 1;\n   }\n   lua_unlock(L);\n   return res;\n]],\n}\n\nBug{\nwhat = [[unpack with maximum indices may crash due to arithmetic overflow]],\nreport = [[Patrick Donnelly, on 2008/02/12]],\nsince = [[5.1]],\nexample = [[\nprint(unpack({1,2,3}, 2^31-1, 2^31-1))\n]],\npatch = [[\n--- lbaselib.c  2008/02/11 16:24:24     1.191.1.5\n+++ lbaselib.c  2008/02/14 16:10:25\n@@ -344,10 +344,12 @@\n   luaL_checktype(L, 1, LUA_TTABLE);\n   i = luaL_optint(L, 2, 1);\n   e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));\n+  if (i > e) return 0;  /* empty range */\n   n = e - i + 1;  /* number of elements */\n-  if (n <= 0) return 0;  /* empty range */\n-  luaL_checkstack(L, n, \"table too big to unpack\");\n-  for (; i<=e; i++)  /* push arg[i...e] */\n+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */\n+    return luaL_error(L, \"too many results to unpack\");\n+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */\n+  while (i++ < e)  /* push arg[i + 1...e] */\n     lua_rawgeti(L, 1, i);\n   return n;\n }\n]],\n}\n\nBug{\nwhat = [[The validator for precompiled code has several flaws that\nallow malicious binary code to crash the application]],\nreport = [[Peter Cawley, on 2008/03/24]],\nsince = [[5.0]],\nexample = [[\na = string.dump(function()return;end)\na = a:gsub(string.char(30,37,122,128), string.char(34,0,0), 1)\nloadstring(a)()\n]],\npatch = [[\n--- ldebug.c    2007/12/28 15:32:23     2.29.1.3\n+++ ldebug.c    2008/04/04 15:15:40\n@@ -275,12 +275,12 @@\n \n static int precheck (const Proto *pt) {\n   check(pt->maxstacksize <= MAXSTACK);\n-  lua_assert(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);\n-  lua_assert(!(pt->is_vararg & VARARG_NEEDSARG) ||\n+  check(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);\n+  check(!(pt->is_vararg & VARARG_NEEDSARG) ||\n               (pt->is_vararg & VARARG_HASARG));\n   check(pt->sizeupvalues <= pt->nups);\n   check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);\n-  check(GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);\n+  check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);\n   return 1;\n }\n \n@@ -363,7 +363,11 @@\n     }\n     switch (op) {\n       case OP_LOADBOOL: {\n-        check(c == 0 || pc+2 < pt->sizecode);  /* check its jump */\n+        if (c == 1) {  /* does it jump? */\n+          check(pc+2 < pt->sizecode);  /* check its jump */\n+          check(GET_OPCODE(pt->code[pc+1]) != OP_SETLIST ||\n+                GETARG_C(pt->code[pc+1]) != 0);\n+        }\n         break;\n       }\n       case OP_LOADNIL: {\n@@ -428,7 +432,10 @@\n       }\n       case OP_SETLIST: {\n         if (b > 0) checkreg(pt, a + b);\n-        if (c == 0) pc++;\n+        if (c == 0) {\n+          pc++;\n+          check(pc < pt->sizecode - 1);\n+        }\n         break;\n       }\n       case OP_CLOSURE: {\n]],\n}\n\nBug{\nwhat = [[maliciously crafted precompiled code can blow the C stack]],\nreport = [[Greg Falcon, on 2008/03/25]],\nsince = [[5.0]],\nexample = [[\nfunction crash(depth)\n  local init = '\\27\\76\\117\\97\\81\\0\\1\\4\\4\\4\\8\\0\\7\\0\\0\\0\\61\\115\\116' ..\n               '\\100\\105\\110\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\2\\2\\0\\0\\0\\36' ..\n               '\\0\\0\\0\\30\\0\\128\\0\\0\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0' ..\n               '\\1\\0\\0\\0\\0\\0\\0\\2'\n  local mid = '\\1\\0\\0\\0\\30\\0\\128\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0'\n  local fin = '\\0\\0\\0\\0\\0\\0\\0\\2\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\2\\0' ..\n              '\\0\\0\\97\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\0'\n  local lch = '\\2\\0\\0\\0\\36\\0\\0\\0\\30\\0\\128\\0\\0\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0' ..\n              '\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\2'\n  local rch = '\\0\\0\\0\\0\\0\\0\\0\\2\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\2\\0' ..\n              '\\0\\0\\97\\0\\1\\0\\0\\0\\1'\n  for i=1,depth do lch,rch = lch..lch,rch..rch end\n  loadstring(init .. lch .. mid .. rch .. fin)\nend\nfor i=1,25 do print(i); crash(i) end\n]],\npatch = [[\n--- lundump.c   2008/04/04 16:00:45     2.7.1.3\n+++ lundump.c   2008/04/04 19:51:41     2.7.1.4\n@@ -161,7 +161,9 @@\n \n static Proto* LoadFunction(LoadState* S, TString* p)\n {\n- Proto* f=luaF_newproto(S->L);\n+ Proto* f;\n+ if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,\"code too deep\");\n+ f=luaF_newproto(S->L);\n  setptvalue2s(S->L,S->L->top,f); incr_top(S->L);\n  f->source=LoadString(S); if (f->source==NULL) f->source=p;\n  f->linedefined=LoadInt(S);\n@@ -175,6 +177,7 @@\n  LoadDebug(S,f);\n  IF (!luaG_checkcode(f), \"bad code\");\n  S->L->top--;\n+ S->L->nCcalls--;\n  return f;\n }\n]],\n}\n\nBug{\nwhat = [[code validator may reject (maliciously crafted) correct code]],\nreport = [[Greg Falcon, on 2008/03/26]],\nsince = [[5.0]],\nexample = [[\nz={}\nfor i=1,27290 do z[i]='1,' end\nz = 'if 1+1==2 then local a={' .. table.concat(z) .. '} end'\nfunc = loadstring(z)\nprint(loadstring(string.dump(func)))\n]],\npatch = [[\n--- ldebug.c    2008/04/04 15:30:05     2.29.1.4\n+++ ldebug.c    2008/04/04 15:47:10\n@@ -346,9 +346,18 @@\n           int dest = pc+1+b;\n           check(0 <= dest && dest < pt->sizecode);\n           if (dest > 0) {\n-            /* cannot jump to a setlist count */\n-            Instruction d = pt->code[dest-1];\n-            check(!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0));\n+            int j;\n+            /* check that it does not jump to a setlist count; this\n+               is tricky, because the count from a previous setlist may\n+               have the same value of an invalid setlist; so, we must\n+               go all the way back to the first of them (if any) */\n+            for (j = 0; j < dest; j++) {\n+              Instruction d = pt->code[dest-1-j];\n+              if (!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0)) break;\n+            }\n+            /* if 'j' is even, previous value is not a setlist (even if\n+               it looks like one) */\n+            check((j&1) == 0);\n           }\n         }\n         break;\n]],\n}\n\nBug{\nwhat = [[maliciously crafted precompiled code can inject invalid boolean\nvalues into Lua code]],\nreport = [[Greg Falcon, on 2008/03/27]],\nsince = [[5.0]],\nexample = [[\nmaybe = string.dump(function() return ({[true]=true})[true] end)\nmaybe = maybe:gsub('\\1\\1','\\1\\2')\nmaybe = loadstring(maybe)()\nassert(type(maybe) == \"boolean\" and maybe ~= true and maybe ~= false)\n]],\npatch = [[\n--- lundump.c   2008/01/18 16:39:11     2.7.1.2\n+++ lundump.c   2008/04/04 15:50:39\n@@ -115,7 +115,7 @@\n        setnilvalue(o);\n        break;\n    case LUA_TBOOLEAN:\n-       setbvalue(o,LoadChar(S));\n+       setbvalue(o,LoadChar(S)!=0);\n        break;\n    case LUA_TNUMBER:\n        setnvalue(o,LoadNumber(S));\n]],\n}\n\n\nBug{\nwhat = [['string.byte' gets confused with some out-of-range negative indices]],\nreport = [[Mike Pall, on 2008/06/03]],\nsince = [[5.1]],\nexample = [[\nprint(string.byte(\"abc\", -5))   --> 97   98   99   (should print nothing)\n]],\npatch = [[\n--- lstrlib.c\t2007/12/28 15:32:23\t1.132.1.3\n+++ lstrlib.c\t2008/07/05 11:53:42\n@@ -35,7 +35,8 @@\n \n static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {\n   /* relative string position: negative means back from end */\n-  return (pos>=0) ? pos : (ptrdiff_t)len+pos+1;\n+  if (pos < 0) pos += (ptrdiff_t)len + 1;\n+  return (pos >= 0) ? pos : 0;\n }\n \n \n]],\n}\n\n\nBug{\nwhat = [[user-requested GC step may loop forever]],\nreport = [[Makoto Hamanaka, on 2008/07/01]],\nsince = [[5.1]],\nexample = [[\ncollectgarbage(\"setpause\", 100) -- small value\ncollectgarbage(\"setstepmul\", 2000) -- large value\ncollectgarbage(\"step\",0)\n]],\npatch = [[\n--- lapi.c\t2008/02/14 16:46:39\t2.55.1.4\n+++ lapi.c\t2008/07/04 18:34:48\n@@ -929,10 +929,13 @@\n         g->GCthreshold = g->totalbytes - a;\n       else\n         g->GCthreshold = 0;\n-      while (g->GCthreshold <= g->totalbytes)\n+      while (g->GCthreshold <= g->totalbytes) {\n         luaC_step(L);\n-      if (g->gcstate == GCSpause)  /* end of cycle? */\n-        res = 1;  /* signal it */\n+        if (g->gcstate == GCSpause) {  /* end of cycle? */\n+          res = 1;  /* signal it */\n+          break;\n+        }\n+      }\n       break;\n     }\n     case LUA_GCSETPAUSE: {\n]],\n}\n\n\nBug{\nwhat = [['module' may change the environment of a C function]],\nreport = [[Peter Cawley, on 2008/07/16]],\nsince = [[5.1]],\nexample = [[\npcall(module, \"xuxu\")\nassert(debug.getfenv(pcall) == xuxu)\n]],\npatch = [[\n--- loadlib.c\t2007/12/28 14:58:43\t1.52.1.2\n+++ loadlib.c\t2008/08/05 19:39:00\n@@ -506,8 +506,11 @@\n \n static void setfenv (lua_State *L) {\n   lua_Debug ar;\n-  lua_getstack(L, 1, &ar);\n-  lua_getinfo(L, \"f\", &ar);\n+  if (lua_getstack(L, 1, &ar) == 0 ||\n+      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n+      lua_iscfunction(L, -1))\n+    luaL_error(L, \"function \" LUA_QL(\"module\")\n+                  \" not called from a Lua function\");\n   lua_pushvalue(L, -2);\n   lua_setfenv(L, -2);\n   lua_pop(L, 1);\n]],\n}\n\n\nBug{\nwhat = [[internal macro 'svalue' is wrong]],\nreport = [[Martijn van Buul, on 2008/08/04]],\nsince = [[5.1]],\nexample = [[\n/* in luaconf.h */\n#define LUAI_USER_ALIGNMENT_T   union { char b[32]; }\n]],\npatch = [[\n--- lobject.h\t2007/12/27 13:02:25\t2.20.1.1\n+++ lobject.h\t2008/08/05 19:40:48\n@@ -210,3 +210,3 @@\n #define getstr(ts)\tcast(const char *, (ts) + 1)\n-#define svalue(o)       getstr(tsvalue(o))\n+#define svalue(o)       getstr(rawtsvalue(o))\n \n]],\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.4\n\nBug{\nwhat = [[malicious zero-length string in binary code may segfault Lua]],\nreport = [[Peter Cawley, on 2008/09/01]],\nsince = [[5.1]],\nexample = [[\nloadstring(('').dump(function()X''end):gsub('\\2%z%z%zX','\\0\\0\\0'))()\n]],\npatch = [[\n]],\n}\n\n\nBug{\nwhat = [[wrong code generation for some particular boolean expressions]],\nreport = [[Brian Kelley, on 2009/04/15]],\nsince = [[5.0]],\nexample = [[\nprint(((1 or false) and true) or false)   --> 1\n-- should be 'true'\n]],\npatch = [[\n--- lcode.c\t2007/12/28 15:32:23\t2.25.1.3\n+++ lcode.c\t2009/06/15 14:07:34\n@@ -544,15 +544,18 @@\n       pc = NO_JUMP;  /* always true; do nothing */\n       break;\n     }\n-    case VFALSE: {\n-      pc = luaK_jump(fs);  /* always jump */\n-      break;\n-    }\n     case VJMP: {\n       invertjump(fs, e);\n       pc = e->u.s.info;\n       break;\n     }\n+    case VFALSE: {\n+      if (!hasjumps(e)) {\n+        pc = luaK_jump(fs);  /* always jump */\n+        break;\n+      }\n+      /* else go through */\n+    }\n     default: {\n       pc = jumponcond(fs, e, 0);\n       break;\n@@ -572,14 +575,17 @@\n       pc = NO_JUMP;  /* always false; do nothing */\n       break;\n     }\n-    case VTRUE: {\n-      pc = luaK_jump(fs);  /* always jump */\n-      break;\n-    }\n     case VJMP: {\n       pc = e->u.s.info;\n       break;\n     }\n+    case VTRUE: {\n+      if (!hasjumps(e)) {\n+        pc = luaK_jump(fs);  /* always jump */\n+        break;\n+      }\n+      /* else go through */\n+    }\n     default: {\n       pc = jumponcond(fs, e, 1);\n       break;\n]],\n}\n\nBug{\nwhat = [['luaV_settable' may invalidate a reference to a table and try\nto reuse it]],\nreport = [[Mark Feldman, on 2009/06/27]],\nsince = [[5.0]],\nexample = [[\ngrandparent = {}\ngrandparent.__newindex = function(s,_,_) print(s) end\n\nparent = {}\nparent.__newindex = parent\nsetmetatable(parent, grandparent)\n\nchild = setmetatable({}, parent)\nchild.foo = 10      --> (crash on some machines)\n]],\npatch = [[\n--- lvm.c\t2007/12/28 15:32:23\t2.63.1.3\n+++ lvm.c\t2009/07/01 20:36:59\n@@ -133,6 +133,7 @@\n \n void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n   int loop;\n+  TValue temp;\n   for (loop = 0; loop < MAXTAGLOOP; loop++) {\n     const TValue *tm;\n     if (ttistable(t)) {  /* `t' is a table? */\n@@ -152,7 +153,9 @@\n       callTM(L, tm, t, key, val);\n       return;\n     }\n-    t = tm;  /* else repeat with `tm' */ \n+    /* else repeat with `tm' */\n+    setobj(L, &temp, tm);  /* avoid pointing inside table (may rehash) */\n+    t = &temp;\n   }\n   luaG_runerror(L, \"loop in settable\");\n }\n]],\n}\n\nBug{\nwhat = [[smart use of varargs may create functions that return too\nmany arguments and overflow the stack of C functions]],\nreport = [[Patrick Donnelly, on 2008/12/10]],\nsince = [[]],\nexample = [[\nlocal function lunpack(i, ...)\n  if i == 0 then return ...\n  else\n    return lunpack(i-1, 1, ...)\n  end\nend\n\nNow, if C calls lunpack(n) with a huge n, it may end with\ntoo many values in its stack and confuse its stack indices.\n]],\npatch = [[\n]],\n}\n\nBug{\nwhat = [['debug.getfenv' does not check whether it has an argument]],\nreport = [[Patrick Donnelly, 2009/07/30]],\nsince = [[5.1]],\nexample = [[debug.getfenv()   -- should raise an error]],\npatch = [[\n--- ldblib.c    2008/01/21 13:11:21     1.104.1.3\n+++ ldblib.c    2009/08/04 18:43:12\n@@ -45,6 +45,7 @@\n \n \n static int db_getfenv (lua_State *L) {\n+  luaL_checkany(L, 1);\n   lua_getfenv(L, 1);\n   return 1;\n }\n]],\n}\n\nBug{\nwhat = [[GC may get stuck during a parser and avoids proper resizing of\nthe string table,\nmaking its lists grow too much and degrading performance]],\nreport = [[Sean Conner, 2009/11/10]],\nsince = [[5.1]],\nexample = [[See http://lua-users.org/lists/lua-l/2009-11/msg00463.html]],\npatch = [[\n--- llex.c\t2007/12/27 13:02:25\t2.20.1.1\n+++ llex.c\t2009/11/23 14:49:40\n@@ -118,8 +118,10 @@\n   lua_State *L = ls->L;\n   TString *ts = luaS_newlstr(L, str, l);\n   TValue *o = luaH_setstr(L, ls->fs->h, ts);  /* entry for `str' */\n-  if (ttisnil(o))\n+  if (ttisnil(o)) {\n     setbvalue(o, 1);  /* make sure `str' will not be collected */\n+    luaC_checkGC(L);\n+  }\n   return ts;\n }\n \n]]\n}\n\nBug{\nwhat = [['string.format' may get buffer as an argument when there are\nmissing arguments and format string is too long]],\nreport = [[Roberto I., 2010/04/12]],\nsince = [[5.0]],\nexample = [[\nx = string.rep(\"x\", 10000) .. \"%d\"\nprint(string.format(x))    -- gives wrong error message\n]],\npatch = [[\n--- lstrlib.c\t2008/07/11 17:27:21\t1.132.1.4\n+++ lstrlib.c\t2010/05/14 15:12:53\n@@ -754,6 +754,7 @@\n \n \n static int str_format (lua_State *L) {\n+  int top = lua_gettop(L);\n   int arg = 1;\n   size_t sfl;\n   const char *strfrmt = luaL_checklstring(L, arg, &sfl);\n@@ -768,7 +769,8 @@\n     else { /* format item */\n       char form[MAX_FORMAT];  /* to store the format (`%...') */\n       char buff[MAX_ITEM];  /* to store the formatted item */\n-      arg++;\n+      if (++arg > top)\n+        luaL_argerror(L, arg, \"no value\");\n       strfrmt = scanformat(L, strfrmt, form);\n       switch (*strfrmt++) {\n         case 'c': {\n]]\n}\n\nBug{\nwhat = [['io.read(op, \"*n\")' may return garbage if second read fails]],\nreport = [[Roberto I., 2010/04/12]],\nsince = [[5.0]],\nexample = [[\nprint(io.read(\"*n\", \"*n\"))   --<< enter \"10   hi\"\n--> file (0x884420)\tnil\n]],\npatch = [[\n--- liolib.c\t2008/01/18 17:47:43\t2.73.1.3\n+++ liolib.c\t2010/05/14 15:29:29\n@@ -276,7 +276,10 @@\n     lua_pushnumber(L, d);\n     return 1;\n   }\n-  else return 0;  /* read fails */\n+  else {\n+    lua_pushnil(L);  /* \"result\" to be removed */\n+    return 0;  /* read fails */\n+  }\n }\n \n \n]]\n}\n\nBug{\nwhat = [[wrong code generation for some particular boolean expressions]],\nreport = [[Thierry Van Elsuwe, 2011/01/20]],\nsince = [[5.0]],\nexample = [[\nprint((('hi' or true) and true) or true)\n--> hi     (should be true)\nprint(((nil and nil) or false) and true)\n--> nil    (should be false)\n]],\npatch = [[\n--- lcode.c\t2009/06/15 14:12:25\t2.25.1.4\n+++ lcode.c\t2011/01/31 14:44:25\n@@ -549,13 +549,6 @@\n       pc = e->u.s.info;\n       break;\n     }\n-    case VFALSE: {\n-      if (!hasjumps(e)) {\n-        pc = luaK_jump(fs);  /* always jump */\n-        break;\n-      }\n-      /* else go through */\n-    }\n     default: {\n       pc = jumponcond(fs, e, 0);\n       break;\n@@ -579,13 +572,6 @@\n       pc = e->u.s.info;\n       break;\n     }\n-    case VTRUE: {\n-      if (!hasjumps(e)) {\n-        pc = luaK_jump(fs);  /* always jump */\n-        break;\n-      }\n-      /* else go through */\n-    }\n     default: {\n       pc = jumponcond(fs, e, 1);\n       break;\n]]\n}\n\nBug{\nwhat = [[__newindex metamethod may not work if metatable is its own\nmetatable]],\nreport = [[Cuero Bugot, 2011/08/09]],\nsince = [[5.1]],\nexample = [[\nmeta={}\nsetmetatable(meta, meta)\nmeta.__newindex = function(t, key, value) print(\"set\") end\no = setmetatable({}, meta)\no.x = 10    -- should print 'set'\n]],\npatch = [[\n--- lvm.c\t2009/07/01 21:10:33\t2.63.1.4\n+++ lvm.c\t2011/08/17 20:36:28\n@@ -142,6 +142,7 @@\n       if (!ttisnil(oldval) ||  /* result is no nil? */\n           (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */\n         setobj2t(L, oldval, val);\n+        h->flags = 0;\n         luaC_barriert(L, h, val);\n         return;\n       }\n]]\n}\n\nBug{\nwhat = [[parser may collect a prototype while building it]],\nreport = [[Ingo van Lil, 2011/10/13]],\nsince = [[5.1.4 (caused by patch 5.1.4-6)]],\nexample = nil,\npatch = [[\n--- lparser.c\t2007/12/28 15:32:23\t2.42.1.3\n+++ lparser.c\t2011/10/17 13:10:43\n@@ -374,9 +374,9 @@\n   lua_assert(luaG_checkcode(f));\n   lua_assert(fs->bl == NULL);\n   ls->fs = fs->prev;\n-  L->top -= 2;  /* remove table and prototype from the stack */\n   /* last token read was anchored in defunct function; must reanchor it */\n   if (fs) anchor_token(ls);\n+  L->top -= 2;  /* remove table and prototype from the stack */\n }\n \n \n]]\n}\n\n\nBug{\nwhat = [[When loading a file,\nLua may call the reader function again after it returned end of input\n]],\nreport = [[Chris Howie, 2013/06/05]],\nsince = [[5.1]],\nfix = [[5.2]],\nexample = [[\nload(function () print(\"called\"); return nil end)\n--> called\n--> called             (should be called only once!)\n]],\npatch = [[\n--- lzio.h\t2007/12/27 13:02:25\t1.21.1.1\n+++ lzio.h\t2013/07/04 13:55:59\n@@ -59,6 +59,7 @@\n   lua_Reader reader;\n   void* data;\t\t\t/* additional data */\n   lua_State *L;\t\t\t/* Lua state (for reader) */\n+  int eoz;\t\t\t/* true if reader has no more data */\n };\n\n\n--- lzio.c\t2007/12/27 13:02:25\t1.31.1.1\n+++ lzio.c\t2013/07/04 13:53:06\n@@ -22,10 +22,14 @@\n   size_t size;\n   lua_State *L = z->L;\n   const char *buff;\n+  if (z->eoz) return EOZ;\n   lua_unlock(L);\n   buff = z->reader(L, z->data, &size);\n   lua_lock(L);\n-  if (buff == NULL || size == 0) return EOZ;\n+  if (buff == NULL || size == 0) {\n+    z->eoz = 1;  /* avoid calling reader function next time */\n+    return EOZ;\n+  }\n   z->n = size - 1;\n   z->p = buff;\n   return char2int(*(z->p++));\n@@ -51,6 +55,7 @@\n   z->data = data;\n   z->n = 0;\n   z->p = NULL;\n+  z->eoz = 0;\n }\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.0\n\nBug{\nwhat = [[memory hoarding when creating Lua hooks for coroutines]],\nreport = [[Arseny Vakhrushev, 2012/01/16]],\nsince = [[5.1]],\nfix = [[5.2.1]],\nexample = [[\ncollectgarbage(); print(collectgarbage'count' * 1024)\n\nfor i = 1, 100 do\n  local co = coroutine.create(function () end)\n  local x = {}\n  for j=1,1000 do x[j] = j end\n  debug.sethook(co, function () return x end, 'l')\nend\n\ncollectgarbage(); print(collectgarbage'count' * 1024)\n-- value should back to near the original level\n]],\npatch = [[\n-- For 5.2\n\n--- ldblib.c\t2011/10/24 14:54:05\t1.131\n+++ ldblib.c\t2012/01/18 02:36:59\n@@ -253,14 +253,15 @@\n }\n \n \n-#define gethooktable(L)\tluaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY);\n+#define gethooktable(L)\tluaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)\n \n \n static void hookf (lua_State *L, lua_Debug *ar) {\n   static const char *const hooknames[] =\n     {\"call\", \"return\", \"line\", \"count\", \"tail call\"};\n   gethooktable(L);\n-  lua_rawgetp(L, -1, L);\n+  lua_pushthread(L);\n+  lua_rawget(L, -2);\n   if (lua_isfunction(L, -1)) {\n     lua_pushstring(L, hooknames[(int)ar->event]);\n     if (ar->currentline >= 0)\n@@ -306,10 +307,15 @@\n     count = luaL_optint(L, arg+3, 0);\n     func = hookf; mask = makemask(smask, count);\n   }\n-  gethooktable(L);\n+  if (gethooktable(L) == 0) {  /* creating hook table? */\n+    lua_pushstring(L, \"k\");\n+    lua_setfield(L, -2, \"__mode\");  /** hooktable.__mode = \"k\" */\n+    lua_pushvalue(L, -1);\n+    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */\n+  }\n+  lua_pushthread(L1); lua_xmove(L1, L, 1);\n   lua_pushvalue(L, arg+1);\n-  lua_rawsetp(L, -2, L1);  /* set new hook */\n-  lua_pop(L, 1);  /* remove hook table */\n+  lua_rawset(L, -3);  /* set new hook */\n   lua_sethook(L1, func, mask, count);  /* set hooks */\n   return 0;\n }\n@@ -325,7 +331,8 @@\n     lua_pushliteral(L, \"external hook\");\n   else {\n     gethooktable(L);\n-    lua_rawgetp(L, -1, L1);   /* get hook */\n+    lua_pushthread(L1); lua_xmove(L1, L, 1);\n+    lua_rawget(L, -2);   /* get hook */\n     lua_remove(L, -2);  /* remove hook table */\n   }\n   lua_pushstring(L, unmakemask(mask, buff));\n]]\n}\n\nBug{\nwhat = [[Lexical gets confused with some combination of arithmetic\noperators and hexadecimal numbers]],\nreport = [[Alexandra Barros, 2012/01/17]],\nsince = [[5.2.0]],\nfix = [[5.2.1]],\nexample = [[print(0xE+1)]],\npatch = [[\n--- llex.c      2011/11/30 12:43:51     2.59\n+++ llex.c      2012/01/20 18:22:50\n@@ -223,12 +223,19 @@\n\n /* LUA_NUMBER */\n static void read_numeral (LexState *ls, SemInfo *seminfo) {\n+  const char *expo = \"Ee\";\n+  int first = ls->current;\n   lua_assert(lisdigit(ls->current));\n-  do {\n-    save_and_next(ls);\n-    if (check_next(ls, \"EePp\"))  /* exponent part? */\n+  save_and_next(ls);\n+  if (first == '0' && check_next(ls, \"Xx\"))  /* hexadecimal? */\n+    expo = \"Pp\";\n+  for (;;) {\n+    if (check_next(ls, expo))  /* exponent part? */\n       check_next(ls, \"+-\");  /* optional exponent sign */\n-  } while (lislalnum(ls->current) || ls->current == '.');\n+    if (lisxdigit(ls->current) || ls->current == '.')\n+      save_and_next(ls);\n+    else  break;\n+  }\n   save(ls, '\\0');\n   buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n   if (!buff2d(ls->buff, &seminfo->r))  /* format error? */\n]]\n}\n\nBug{\nwhat = [[Finalizers may call functions from a dynamic library after\nthe library has been unloaded]],\nreport = [[Josh Haberman, 2012/04/08]],\nsince = [[5.1]],\nfix = [[5.2.1]],\nexample = [[\nlocal u = setmetatable({}, {__gc = function () foo() end})\nlocal m = require 'mod'   -- 'mod' may be any dynamic library written in C\nfoo = m.foo     -- 'foo' may be any function from 'mod'\n-- end program; it crashes\n]],\npatch = [[\nloadlib.c:\n95c95\n< #define LIBPREFIX\t\"LOADLIB: \"\n---\n> #define CLIBS\t\t\"_CLIBS\"\n251,266c251,256\n< \n< static void **ll_register (lua_State *L, const char *path) {\n<   void **plib;\n<   lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n<   lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n<   if (!lua_isnil(L, -1))  /* is there an entry? */\n<     plib = (void **)lua_touserdata(L, -1);\n<   else {  /* no entry yet; create one */\n<     lua_pop(L, 1);  /* remove result from gettable */\n<     plib = (void **)lua_newuserdata(L, sizeof(const void *));\n<     *plib = NULL;\n<     luaL_setmetatable(L, \"_LOADLIB\");\n<     lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n<     lua_pushvalue(L, -2);\n<     lua_settable(L, LUA_REGISTRYINDEX);\n<   }\n---\n> static void *ll_checkclib (lua_State *L, const char *path) {\n>   void *plib;\n>   lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n>   lua_getfield(L, -1, path);\n>   plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n>   lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n270a261,270\n> static void ll_addtoclib (lua_State *L, const char *path, void *plib) {\n>   lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n>   lua_pushlightuserdata(L, plib);\n>   lua_pushvalue(L, -1);\n>   lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n>   lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n>   lua_pop(L, 1);  /* pop CLIBS table */\n> }\n> \n> \n272,273c272,273\n< ** __gc tag method: calls library's `ll_unloadlib' function with the lib\n< ** handle\n---\n> ** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib\n> ** handles in list CLIBS\n276,278c276,281\n<   void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n<   if (*lib) ll_unloadlib(*lib);\n<   *lib = NULL;  /* mark library as closed */\n---\n>   int n = luaL_len(L, 1);\n>   for (; n >= 1; n--) {  /* for each handle, in reverse order */\n>     lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n>     ll_unloadlib(lua_touserdata(L, -1));\n>     lua_pop(L, 1);  /* pop handle */\n>   }\n284,286c287,292\n<   void **reg = ll_register(L, path);\n<   if (*reg == NULL) *reg = ll_load(L, path, *sym == '*');\n<   if (*reg == NULL) return ERRLIB;  /* unable to load library */\n---\n>   void *reg = ll_checkclib(L, path);  /* check loaded C libraries */\n>   if (reg == NULL) {  /* must load library? */\n>     reg = ll_load(L, path, *sym == '*');\n>     if (reg == NULL) return ERRLIB;  /* unable to load library */\n>     ll_addtoclib(L, path, reg);\n>   }\n292c298\n<     lua_CFunction f = ll_sym(L, *reg, sym);\n---\n>     lua_CFunction f = ll_sym(L, reg, sym);\n675,676c681,683\n<   /* create new type _LOADLIB */\n<   luaL_newmetatable(L, \"_LOADLIB\");\n---\n>   /* create table CLIBS to keep track of loaded C libraries */\n>   luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);\n>   lua_createtable(L, 0, 1);  /* metatable for CLIBS */\n678a686\n>   lua_setmetatable(L, -2);\n]]\n}\n\nBug{\nwhat = [[wrong handling of 'nCcalls' in coroutines]],\nreport = [[Alexander Gavrilov, 2012/04/18]],\nsince = [[5.2.0]],\nfix = [[5.2.1]],\nexample = [[\ncoroutine.wrap(function()\n  print(pcall(pcall,pcall,pcall,pcall,pcall,error,3))\nend)()\n]],\npatch = [[\n--- ldo.c\t2011/11/29 15:55:08\t2.102\n+++ ldo.c\t2012/04/26 20:38:32\n@@ -402,8 +402,6 @@\n   int n;\n   lua_assert(ci->u.c.k != NULL);  /* must have a continuation */\n   lua_assert(L->nny == 0);\n-  /* finish 'luaD_call' */\n-  L->nCcalls--;\n   /* finish 'lua_callk' */\n   adjustresults(L, ci->nresults);\n   /* call continuation function */\n@@ -513,7 +511,6 @@\n         api_checknelems(L, n);\n         firstArg = L->top - n;  /* yield results come from continuation */\n       }\n-      L->nCcalls--;  /* finish 'luaD_call' */\n       luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */\n     }\n     unroll(L, NULL);\n]]\n}\n\nBug{\nwhat = [[Internal Lua values may escape through the debug API]],\nreport = [[Dan Tull, 2012/04/20]],\nsince = [[5.1]],\nfix = [[5.2.1]],\nexample = [[\n-- for Lua 5.1\nlocal firsttime = true\nlocal function foo ()\n  if firsttime then\n    firsttime = false\n    return \"a = 1\" \n  else\n    for i = 1, 10 do\n      print(debug.getlocal(2, i))\n    end\n  end\nend\n\nprint(load(foo))   -- prints some lines and then seg. fault.\n]],\npatch = [[\n]]\n}\n\nBug{\nwhat = [[Problems when yielding from debug hooks]],\nreport = [[Erik Cassel, 2012/06/05]],\nsince = [[5.2.0]],\nfix = [[5.2.1]],\nexample = [[\nSet, in C, a line hook that simply yields,\nand then call any Lua function.\nYou get an infinite loop of yields.\n]],\npatch = [[\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.1\n\nBug{\nwhat = [[Some patterns can overflow the C stack, due to recursion]],\nreport = [[Tim Starling, 2012/07/08]],\nsince = [[2.5]],\nfix = [[5.2.2]],\nexample = [[print(string.find(string.rep(\"a\", 2^20), string.rep(\".?\", 2^20)))]],\npatch = [[\n]]\n}\n\n\nBug{\nwhat = [['pcall' may not restore previous error function when\ninside coroutines]],\nreport = [[Alexander Gavrilov, 2012/06/12]],\nsince = [[5.2.0]],\nfix = [[5.2.2]],\nexample = [[\nfunction errfunc(x)\n  return 'errfunc'\nend\n\nfunction test(do_yield)\n  print(do_yield and \"yielding\" or \"not yielding\")\n  pcall(function() -- this pcall sets errfunc back to none\n    if do_yield then\n      coroutine.yield() -- stops errfunc from being restored\n    end\n  end)\n  error('fail!')\nend\n\ncoro = coroutine.wrap(function()\n  print(xpcall(test, errfunc, false))\n  print(xpcall(test, errfunc, true))\n  print(xpcall(test, errfunc, false))\nend)\n\ncoro()\n--> not yielding\n--> false\terrfunc\n--> yielding\ncoro()\n--> false\ttemp:12: fail!       <<<< should be 'errfunc' too\n--> not yielding\n--> false\terrfunc\n]],\npatch = [[\n--- ldo.c\t2012/08/28 18:30:45\t2.107\n+++ ldo.c\t2012/09/23 15:49:55\n@@ -403,7 +403,11 @@\n   int n;\n   lua_assert(ci->u.c.k != NULL);  /* must have a continuation */\n   lua_assert(L->nny == 0);\n-  /* finish 'lua_callk' */\n+  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */\n+    ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */\n+    L->errfunc = ci->u.c.old_errfunc;\n+  }\n+  /* finish 'lua_callk'/'lua_pcall' */\n   adjustresults(L, ci->nresults);\n   /* call continuation function */\n   if (!(ci->callstatus & CIST_STAT))  /* no call status? */\n]]\n}\n\nBug{\nwhat = [[Check for garbage collector in function calls does not cover\nall paths]],\nreport = [[Roberto, 2012/08/15]],\nsince = [[5.2.1]],\nfix = [[5.2.2]],\nexample = [[\nSee <a href=\"http://lua-users.org/lists/lua-l/2012-08/msg00149.html\">\nhttp://lua-users.org/lists/lua-l/2012-08/msg00149.html</a>\n]],\npatch = [[\n@@ -311,6 +311,7 @@\n       ci->top = L->top + LUA_MINSTACK;\n       lua_assert(ci->top <= L->stack_last);\n       ci->callstatus = 0;\n+      luaC_checkGC(L);  /* stack grow uses memory */\n       if (L->hookmask & LUA_MASKCALL)\n         luaD_hook(L, LUA_HOOKCALL, -1);\n       lua_unlock(L);\n@@ -338,6 +339,7 @@\n       ci->u.l.savedpc = p->code;  /* starting point */\n       ci->callstatus = CIST_LUA;\n       L->top = ci->top;\n+      luaC_checkGC(L);  /* stack grow uses memory */\n       if (L->hookmask & LUA_MASKCALL)\n         callhook(L, ci);\n       return 0;\n@@ -393,7 +395,6 @@\n     luaV_execute(L);  /* call it */\n   if (!allowyield) L->nny--;\n   L->nCcalls--;\n-  luaC_checkGC(L);\n }\n]]\n}\n\nBug{\nwhat = [[load/loadfile returns wrong result when given an environment\nfor a binary chunk with no upvalues]],\nreport = [[Vladimir Strakh, 2012/11/28]],\nsince = [[5.2.0]],\nfix = [[5.2.2]],\nexample = [[\nf = load(string.dump(function () return 1 end), nil, \"b\", {})\nprint(type(f))   --> table            (whould be a function)\n]],\npatch = [[\n--- lbaselib.c\t2012/04/27 14:13:19\t1.274\n+++ lbaselib.c\t2012/12/03 20:08:15\n@@ -244,5 +244,11 @@\n \n-static int load_aux (lua_State *L, int status) {\n-  if (status == LUA_OK)\n+static int load_aux (lua_State *L, int status, int envidx) {\n+  if (status == LUA_OK) {\n+    if (envidx != 0) {  /* 'env' parameter? */\n+      lua_pushvalue(L, envidx);  /* environment for loaded function */\n+      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n+        lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n+    }\n     return 1;\n+  }\n   else {\n@@ -258,9 +264,5 @@\n   const char *mode = luaL_optstring(L, 2, NULL);\n-  int env = !lua_isnone(L, 3);  /* 'env' parameter? */\n+  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */\n   int status = luaL_loadfilex(L, fname, mode);\n-  if (status == LUA_OK && env) {  /* 'env' parameter? */\n-    lua_pushvalue(L, 3);\n-    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue of loaded chunk */\n-  }\n-  return load_aux(L, status);\n+  return load_aux(L, status, env);\n }\n@@ -309,5 +311,5 @@\n   size_t l;\n-  int top = lua_gettop(L);\n   const char *s = lua_tolstring(L, 1, &l);\n   const char *mode = luaL_optstring(L, 3, \"bt\");\n+  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */\n   if (s != NULL) {  /* loading a string? */\n@@ -322,7 +324,3 @@\n   }\n-  if (status == LUA_OK && top >= 4) {  /* is there an 'env' argument */\n-    lua_pushvalue(L, 4);  /* environment for loaded function */\n-    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue */\n-  }\n-  return load_aux(L, status);\n+  return load_aux(L, status, env);\n }\n]]\n}\n\nBug{\nwhat = [[Lua does not check memory use when creating error messages]],\nreport = [[John Dunn, 2012/09/24]],\nsince = [[5.2.0]],\nfix = nil,\nexample = [[\nlocal code = \"function test()\\n  bob.joe.larry = 23\\n end\"\n\nload(code)()\n\n-- memory will grow steadly \nfor i = 1, math.huge do\n  pcall(test)\n  if i % 100000 == 0 then\n    io.write(collectgarbage'count'*1024, \"\\n\")\n  end\nend\n]],\npatch = [[\n]]\n}\n\n\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.2\n\n\nBug{\nwhat = [[stack overflow in vararg functions with many fixed\nparameters called with few arguments]],\nreport = [[\u4e91\u98ce, 2013/04/17]],\nsince = [[5.1]],\nfix = [[5.2.3]],\nexample = [[\nfunction f(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,\n           p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,\n           p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,\n           p31, p32, p33, p34, p35, p36, p37, p38, p39, p40,\n           p41, p42, p43, p44, p45, p46, p48, p49, p50, ...)\n  local a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14\nend\n\nf()   -- seg. fault (on some machines)\n]],\npatch = [[\n--- ldo.c\t2012/10/01 14:05:04\t2.108\n+++ ldo.c\t2013/04/19 20:56:06\n@@ -324,7 +324,7 @@\n     case LUA_TLCL: {  /* Lua function: prepare its call */\n       StkId base;\n       Proto *p = clLvalue(func)->p;\n-      luaD_checkstack(L, p->maxstacksize);\n+      luaD_checkstack(L, p->maxstacksize + p->numparams);\n       func = restorestack(L, funcr);\n       n = cast_int(L->top - func) - 1;  /* number of real arguments */\n       for (; n < p->numparams; n++)\n]],\n}\n\nBug{\nwhat = [[garbage collector can trigger too many times in recursive loops]],\nreport = [[Roberto, 2013/04/25]],\nsince = [[5.2.2]],\nfix = [[5.2.3]],\nexample = [[\nfunction f() f() end\nf()   -- it takes too long before a \"stack overflow\" error\n]],\npatch = [[\n--- lgc.c\t2013/04/12 18:48:47\t2.140.1.1\n+++ lgc.c\t2013/04/25 21:30:20\n@@ -495,2 +495,3 @@\n static lu_mem traversestack (global_State *g, lua_State *th) {\n+  int n = 0;\n   StkId o = th->stack;\n@@ -505,3 +506,9 @@\n   }\n-  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;\n+  else {  /* count call infos to compute size */\n+    CallInfo *ci;\n+    for (ci = &th->base_ci; ci != th->ci; ci = ci->next)\n+      n++;\n+  }\n+  return sizeof(lua_State) + sizeof(TValue) * th->stacksize +\n+         sizeof(CallInfo) * n;\n }\n]]\n}\n\n-- [[]]\nBug{\nwhat = [[Wrong assert when reporting concatenation errors\n(manifests only when Lua is compiled in debug mode)]],\nreport = [[Roberto, 2013/05/05]],\nsince = [[?]],\nfix = [[5.2.3]],\nexample = [[\n-- only with Lua compiled in debug mode\nprint({} .. 2)\n]],\npatch = [[\n--- ldebug.c\t2013/04/12 18:48:47\t2.90.1.1\n+++ ldebug.c\t2013/05/05 14:38:30\n@@ -519,5 +519,5 @@\n l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {\n   if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;\n-  lua_assert(!ttisstring(p1) && !ttisnumber(p2));\n+  lua_assert(!ttisstring(p1) && !ttisnumber(p1));\n   luaG_typeerror(L, p1, \"concatenate\");\n }\n]]\n}\n\nBug{\nwhat = [[Wrong error message in some short-cut expressions]],\nreport = [[Egor Skriptunoff, 2013/05/10]],\nsince = [[5.0]],\nfix = [[5.2.3]],\nexample = [[\n> a,b,c = true,true,true\n> (a and b or c)('', '')\nstdin:1: attempt to call a boolean value (global 'c')\n\n    (It should be global 'b' instead of 'c'.)\n]],\npatch = [[\n--- ldebug.c\t2013/05/06 17:20:22\t2.90.1.2\n+++ ldebug.c\t2013/05/14 19:52:48\n@@ -327,12 +327,20 @@\n }\n \n \n+static int filterpc (int pc, int jmptarget) {\n+  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n+    return -1;  /* cannot know who sets that register */\n+  else return pc;  /* current position sets that register */\n+}\n+\n+\n /*\n ** try to find last instruction before 'lastpc' that modified register 'reg'\n */\n static int findsetreg (Proto *p, int lastpc, int reg) {\n   int pc;\n   int setreg = -1;  /* keep last instruction that changed 'reg' */\n+  int jmptarget = 0;  /* any code before this address is conditional */\n   for (pc = 0; pc < lastpc; pc++) {\n     Instruction i = p->code[pc];\n     OpCode op = GET_OPCODE(i);\n@@ -341,33 +349,38 @@\n       case OP_LOADNIL: {\n         int b = GETARG_B(i);\n         if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */\n-          setreg = pc;\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       case OP_TFORCALL: {\n-        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */\n+        if (reg >= a + 2)  /* affect all regs above its base */\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       case OP_CALL:\n       case OP_TAILCALL: {\n-        if (reg >= a) setreg = pc;  /* affect all registers above base */\n+        if (reg >= a)  /* affect all registers above base */\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       case OP_JMP: {\n         int b = GETARG_sBx(i);\n         int dest = pc + 1 + b;\n         /* jump is forward and do not skip `lastpc'? */\n-        if (pc < dest && dest <= lastpc)\n-          pc += b;  /* do the jump */\n+        if (pc < dest && dest <= lastpc) {\n+          if (dest > jmptarget)\n+            jmptarget = dest;  /* update 'jmptarget' */\n+        }\n         break;\n       }\n       case OP_TEST: {\n-        if (reg == a) setreg = pc;  /* jumped code can change 'a' */\n+        if (reg == a)  /* jumped code can change 'a' */\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       default:\n         if (testAMode(op) && reg == a)  /* any instruction that set A */\n-          setreg = pc;\n+          setreg = filterpc(pc, jmptarget);\n         break;\n     }\n   }\n]]\n}\n\nBug{\nwhat = [[luac listings choke on long strings]],\nreport = [[Ashwin Hirschi, 2013/07/03]],\nsince = [[5.1.2]],\nfix = [[5.2.3]],\nexample = [[\n-- When you call 'luac -l' over this chunk, it chokes the output\ns=\"Lorem ipsum dolor sit amet, consectetur, \"\n]],\npatch = [[\n--- luac.c 2011-11-29 15:46:33 -0200  1.69\n+++ luac.c 2013-07-03 21:26:01 -0300\n@@ -251,7 +251,7 @@\n static void PrintConstant(const Proto* f, int i)\n {\n  const TValue* o=&f->k[i];\n- switch (ttype(o))\n+ switch (ttypenv(o))\n  {\n   case LUA_TNIL:\n        printf(\"nil\");\n]]\n}\n\nBug{\nwhat = [[GC can collect a long string still in use during parser]],\nreport = [[Roberto, 2013/08/30]],\nsince = [[5.2]],\nfix = [[5.2.3]],\nexample = [[This bug is very difficult to happen (and to reproduce),\nbecause it depends on the GC running in a very specific way when\nparsing a source code with long (larger than 40 characters) identifiers.]],\npatch = [[\n--- ltable.h\t2013/04/12 18:48:47\t2.16.1.1\n+++ ltable.h\t2013/08/30 15:34:24\n@@ -18,4 +18,8 @@\n #define invalidateTMcache(t)\t((t)->flags = 0)\n \n+/* returns the key, given the value of a table entry */\n+#define keyfromval(v) \\\n+  (gkey(cast(Node *, cast(char *, (v)) - offsetof(Node, i_val))))\n+\n \n LUAI_FUNC const TValue *luaH_getint (Table *t, int key);\n\n--- llex.c\t2013/04/12 18:48:47\t2.63.1.1\n+++ llex.c\t2013/08/30 15:34:59\n@@ -134,4 +134,7 @@\n     luaC_checkGC(L);\n   }\n+  else {  /* string already present */\n+    ts = rawtsvalue(keyfromval(o));  /* re-use value previously stored */\n+  }\n   L->top--;  /* remove string from stack */\n   return ts;\n]]\n}\n\n\nBug{\nwhat = [[Call to macro 'luai_userstateclose' should be done only\nafter the calls to __gc methods.]],\nreport = [[Jean-Luc Jumpertz, 2013/09/02]],\nsince = [[ ]],\nfix = nil,\nexample = [[No example]],\npatch = [[\n--- lstate.c\t2013/04/12 18:48:47\t2.99.1.1\n+++ lstate.c\t2013/11/08 17:39:57\n@@ -194,2 +194,4 @@\n   g->gcrunning = 1;  /* allow gc */\n+  g->version = lua_version(NULL);\n+  luai_userstateopen(L);\n }\n@@ -224,2 +226,4 @@\n   luaC_freeallobjects(L);  /* collect all objects */\n+  if (g->version)  /* closing a fully built state? */\n+    luai_userstateclose(L);\n   luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);\n@@ -289,3 +293,3 @@\n   g->panic = NULL;\n-  g->version = lua_version(NULL);\n+  g->version = NULL;\n   g->gcstate = GCSpause;\n@@ -308,4 +312,2 @@\n   }\n-  else\n-    luai_userstateopen(L);\n   return L;\n@@ -317,3 +319,2 @@\n   lua_lock(L);\n-  luai_userstateclose(L);\n   close_state(L);\n]]\n}\n\n\nBug{\nwhat = [[Resuming the running coroutine makes it unyieldable]],\nreport = [[Florian N\u00fccke, 2013/10/28]],\nsince = [[5.2]],\nfix = [[5.2.3]],\nexample = [[\n-- should print 'true'\nprint(coroutine.resume(coroutine.create(function()\n  coroutine.resume(coroutine.running())\n  coroutine.yield()\nend)))\n]],\npatch = [[\n--- ldo.c\t2013/04/19 21:03:23\t2.108.1.2\n+++ ldo.c\t2013/11/08 18:20:57\n@@ -536,2 +536,3 @@\n   int status;\n+  int oldnny = L->nny;  /* save 'nny' */\n   lua_lock(L);\n@@ -557,3 +558,3 @@\n   }\n-  L->nny = 1;  /* do not allow yields */\n+  L->nny = oldnny;  /* restore 'nny' */\n   L->nCcalls--;\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.3\n\nBug{\nwhat = [[compiler can optimize away overflow check in 'table.unpack']],\nreport = [[Paige DePol, 2014/03/30]],\nsince = [[5.1 (at least)]],\nfix = nil,\nexample = [[\n> unpack({}, 0, 2^31 - 1)\n(segfaults on some platforms with some compiler options)\n]],\npatch = [[\n--- ltablib.c\t2013/04/12 18:48:47\t1.65.1.1\n+++ ltablib.c\t2014/05/07 16:32:55\t1.65.1.2\n@@ -134,13 +135,14 @@\n \n \n static int unpack (lua_State *L) {\n-  int i, e, n;\n+  int i, e;\n+  unsigned int n;\n   luaL_checktype(L, 1, LUA_TTABLE);\n   i = luaL_optint(L, 2, 1);\n   e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));\n   if (i > e) return 0;  /* empty range */\n-  n = e - i + 1;  /* number of elements */\n-  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */\n+  n = (unsigned int)e - (unsigned int)i;  /* number of elements minus 1 */\n+  if (n > (INT_MAX - 10) || !lua_checkstack(L, ++n))\n     return luaL_error(L, \"too many results to unpack\");\n   lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */\n   while (i++ < e)  /* push arg[i + 1...e] */\n]]\n}\n\nBug{\nwhat = [[Ephemeron table can wrongly collect entry with strong key]],\nreport = [[J\u00f6rg Richter, 2014/08/22]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n(This bug is very hard to reproduce,\nbecause it depends on a specific interleaving of\nevents between the incremental collector and the program.)\n]],\npatch = [[\n--- lgc.c\t2013/04/26 18:22:05\t2.140.1.2\n+++ lgc.c\t2014/09/01 13:24:33\n@@ -403,7 +403,7 @@\n       reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n     }\n   }\n-  if (prop)\n+  if (g->gcstate != GCSatomic || prop)\n     linktable(h, &g->ephemeron);  /* have to propagate again */\n   else if (hasclears)  /* does table have white keys? */\n     linktable(h, &g->allweak);  /* may have to clean white keys */\n]]\n}\n\nBug{\nwhat = [[Chunk with too many lines can seg. fault]],\nreport = [[Roberto, 2014/11/14]],\nsince = [[5.1 (at least)]],\nfix = nil,\nexample = [[\n-- the cause of the bug is the use of an unitialized variable, so\n-- it cannot be reproduced reliably\nlocal s = string.rep(\"\\n\", 2^24)\nprint(load(function () return s end))\n]],\npatch = [[\n--- llex.c\t2013/08/30 15:49:41\t2.63.1.2\n+++ llex.c\t2015/02/09 17:05:31\n@@ -153,5 +153,5 @@\n     next(ls);  /* skip `\\n\\r' or `\\r\\n' */\n   if (++ls->linenumber >= MAX_INT)\n-    luaX_syntaxerror(ls, \"chunk has too many lines\");\n+    lexerror(ls, \"chunk has too many lines\", 0);\n }\n \n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.0\n\nBug{\nwhat = [['string.format(\"%f\")' can cause a buffer overflow\n(only when 'lua_Number' is long double!)]],\nreport = [[Roberto, 2015/01/13]],\nsince = [[5.3]],\nfix = nil,\nexample = [[string.format(\"%.99f\", 1e4000)    -- when floats are long double]],\npatch = [[\n--- lstrlib.c\t2014/12/11 14:03:07\t1.221\n+++ lstrlib.c\t2015/02/23 19:01:42\n@@ -800,3 +800,4 @@\n /* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */\n-#define MAX_ITEM\t512\n+#define MAX_ITEM  \\\n+  (sizeof(lua_Number) <= 4 ? 150 : sizeof(lua_Number) <= 8 ? 450 : 5050)\n \n]]\n}\n\nBug{\nwhat = [['debug.getlocal' on a coroutine suspended in a hook\ncan crash the interpreter]],\nreport = [[\u4e91\u98ce, 2015/02/11]],\nsince = [[5.2]],\nfix = nil,\nexample = [[see http://lua-users.org/lists/lua-l/2015-02/msg00146.html]],\npatch = [[\n--- ldebug.c\t2015/01/02 12:52:22\t2.110\n+++ ldebug.c\t2015/02/13 16:03:23\n@@ -49,4 +49,14 @@\n \n \n+static void swapextra (lua_State *L) {\n+  if (L->status == LUA_YIELD) {\n+    CallInfo *ci = L->ci;  /* get function that yielded */\n+    StkId temp = ci->func;  /* exchange its 'func' and 'extra' values */\n+    ci->func = restorestack(L, ci->extra);\n+    ci->extra = savestack(L, temp);\n+  }\n+}\n+\n+\n /*\n ** this function can be called asynchronous (e.g. during a signal)\n@@ -145,4 +155,5 @@\n   const char *name;\n   lua_lock(L);\n+  swapextra(L);\n   if (ar == NULL) {  /* information about non-active function? */\n     if (!isLfunction(L->top - 1))  /* not a Lua function? */\n@@ -159,4 +170,5 @@\n     }\n   }\n+  swapextra(L);\n   lua_unlock(L);\n   return name;\n@@ -166,10 +178,13 @@\n LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n   StkId pos = 0;  /* to avoid warnings */\n-  const char *name = findlocal(L, ar->i_ci, n, &pos);\n+  const char *name;\n   lua_lock(L);\n+  swapextra(L);\n+  name = findlocal(L, ar->i_ci, n, &pos);\n   if (name) {\n     setobjs2s(L, pos, L->top - 1);\n     L->top--;  /* pop value */\n   }\n+  swapextra(L);\n   lua_unlock(L);\n   return name;\n@@ -271,4 +286,5 @@\n   StkId func;\n   lua_lock(L);\n+  swapextra(L);\n   if (*what == '>') {\n     ci = NULL;\n@@ -289,4 +305,5 @@\n     api_incr_top(L);\n   }\n+  swapextra(L);\n   if (strchr(what, 'L'))\n     collectvalidlines(L, cl);\n]]\n}\n\n\nBug{\nwhat = [[suspended '__le' metamethod can give wrong result]],\nreport = [[Eric Zhong, 2015/04/07]],\nsince = [[5.2]],\nfix = nil,\n\nexample = [[\nmt = {__le = function (a,b) coroutine.yield(\"yield\"); return a.x <= b.x end}\nt1 = setmetatable({x=1}, mt)\nt2 = {x=2}\nco = coroutine.wrap(function (a,b) return t2 <= t1 end)\nco()\nprint(co())   --> true  (should be false)\n]],\n\npatch = [[\n--- lstate.h\t2014/10/30 18:53:28\t2.119\n+++ lstate.h\t2015/04/13 15:58:40\n@@ -94,6 +94,7 @@\n #define CIST_YPCALL\t(1<<4)\t/* call is a yieldable protected call */\n #define CIST_TAIL\t(1<<5)\t/* call was tail called */\n #define CIST_HOOKYIELD\t(1<<6)\t/* last hook called yielded */\n+#define CIST_LEQ\t(1<<7)  /* using __lt for __le */\n \n #define isLua(ci)\t((ci)->callstatus & CIST_LUA)\n \n--- lvm.c\t2014/12/27 20:30:38\t2.232\n+++ lvm.c\t2015/04/13 15:51:30\n@@ -292,9 +292,14 @@\n     return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;\n   else if ((res = luaT_callorderTM(L, l, r, TM_LE)) >= 0)  /* first try 'le' */\n     return res;\n-  else if ((res = luaT_callorderTM(L, r, l, TM_LT)) < 0)  /* else try 'lt' */\n-    luaG_ordererror(L, l, r);\n-  return !res;\n+  else {  /* try 'lt': */\n+    L->ci->callstatus |= CIST_LEQ;  /* mark it is doing 'lt' for 'le' */\n+    res = luaT_callorderTM(L, r, l, TM_LT);\n+    L->ci->callstatus ^= CIST_LEQ;  /* clear mark */\n+    if (res < 0)\n+      luaG_ordererror(L, l, r);\n+    return !res;  /* result is negated */\n+  }\n }\n \n \n@@ -553,11 +558,11 @@\n     case OP_LE: case OP_LT: case OP_EQ: {\n       int res = !l_isfalse(L->top - 1);\n       L->top--;\n-      /* metamethod should not be called when operand is K */\n-      lua_assert(!ISK(GETARG_B(inst)));\n-      if (op == OP_LE &&  /* \"<=\" using \"<\" instead? */\n-          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n-        res = !res;  /* invert result */\n+      if (ci->callstatus & CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n+        lua_assert(op == OP_LE);\n+        ci->callstatus ^= CIST_LEQ;  /* clear mark */\n+        res = !res;  /* negate result */\n+      }\n       lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n       if (res != GETARG_A(inst))  /* condition failed? */\n         ci->u.l.savedpc++;  /* skip jump instruction */\n]]\n}\n\n\nBug{\nwhat = [[return hook may not see correct values for\n active local variables when function returns]],\nreport = [[Philipp Janda/Peng Yi, 2015/05/19]],\nsince = [[5.0]],\nfix = nil,\nexample = [[\nsee messasge http://lua-users.org/lists/lua-l/2015-05/msg00376.html]],\npatch = [[\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.1\n\nBug{\nwhat = [['io.lines' does not check maximum number of options]],\nreport = [[Patrick Donnell, 2015/07/10]],\nsince = [[5.3.0]],\nfix = nil,\nexample = [[\n-- can segfault in some machines\nt ={}; for i = 1, 253 do t[i] = 1 end\nio.lines(\"someexistingfile\", table.unpack(t))()\n]],\npatch = [[\n--- liolib.c\t2015/07/07 17:03:34\t2.146\n+++ liolib.c\t2015/07/15 14:40:28\t2.147\n@@ -318,8 +318,15 @@\n static int io_readline (lua_State *L);\n \n \n+/*\n+** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit\n+** in the limit for upvalues of a closure)\n+*/\n+#define MAXARGLINE\t250\n+\n static void aux_lines (lua_State *L, int toclose) {\n   int n = lua_gettop(L) - 1;  /* number of arguments to read */\n+  luaL_argcheck(L, n <= MAXARGLINE, MAXARGLINE + 2, \"too many arguments\");\n   lua_pushinteger(L, n);  /* number of arguments to read */\n   lua_pushboolean(L, toclose);  /* close/not close file when finished */\n   lua_rotate(L, 2, 2);  /* move 'n' and 'toclose' to their positions */\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.2\n\nBug{\nwhat = [[Metatable may access its own dealocated field when\nit has a self reference in __newindex]],\nreport = [[actboy168@gmail.com, 2016/01/01]],\nsince = [[5.3.2]],\nfix = nil,\nexample = [[\nlocal mt = {}\nmt.__newindex = mt\nlocal t = setmetatable({}, mt)\nt[1] = 1     -- will segfault on some machines\n]],\npatch = [[\n--- lvm.c\t2015/11/23 11:30:45\t2.265\n+++ lvm.c\t2016/01/01 14:34:12\n@@ -190,18 +190,19 @@\n   for (loop = 0; loop < MAXTAGLOOP; loop++) {\n     const TValue *tm;\n     if (oldval != NULL) {\n-      lua_assert(ttistable(t) && ttisnil(oldval));\n+      Table *h = hvalue(t);  /* save 't' table */\n+      lua_assert(ttisnil(oldval));\n       /* must check the metamethod */\n-      if ((tm = fasttm(L, hvalue(t)->metatable, TM_NEWINDEX)) == NULL &&\n+      if ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&\n          /* no metamethod; is there a previous entry in the table? */\n          (oldval != luaO_nilobject ||\n          /* no previous entry; must create one. (The next test is\n             always true; we only need the assignment.) */\n-         (oldval = luaH_newkey(L, hvalue(t), key), 1))) {\n+         (oldval = luaH_newkey(L, h, key), 1))) {\n         /* no metamethod and (now) there is an entry with given key */\n         setobj2t(L, cast(TValue *, oldval), val);\n-        invalidateTMcache(hvalue(t));\n-        luaC_barrierback(L, hvalue(t), val);\n+        invalidateTMcache(h);\n+        luaC_barrierback(L, h, val);\n         return;\n       }\n       /* else will try the metamethod */\n]]\n}\n\n\nBug{\nwhat = [[label between local definitions can mix-up their initializations]],\nreport = [[Karel Tuma, 2016/03/01]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\ndo\n  local k = 0\n  local x\n  ::foo::\n  local y       -- should be reset to nil after goto, but it is not\n  assert(not y)\n  y = true\n  k = k + 1\n  if k < 2 then goto foo end\nend\n]],\npatch = [[\n--- lparser.c\t2015/11/02 16:09:30\t2.149\n+++ lparser.c\t2016/03/03 12:03:37\n@@ -1226,7 +1226,7 @@\n   checkrepeated(fs, ll, label);  /* check for repeated labels */\n   checknext(ls, TK_DBCOLON);  /* skip double colon */\n   /* create new entry for this label */\n-  l = newlabelentry(ls, ll, label, line, fs->pc);\n+  l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));\n   skipnoopstat(ls);  /* skip other no-op statements */\n   if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */\n     /* assume that locals are already out of scope */\n]]\n}\n\n\nBug{\nwhat = [['gmatch' iterator fails when called from a coroutine different\nfrom the one that created it]],\nreport = [[Nagaev Boris, 2016/03/18]],\nsince = [[5.3.2]],\nfix = nil,\nexample = [[\nlocal f = string.gmatch(\"1 2 3 4 5\", \"%d+\")\nprint(f())     --> 1\nco = coroutine.wrap(f)\nprint(co())    --> ??? (should be 2)\n]],\npatch = [[\n--- lstrlib.c\t2015/11/25 16:28:17\t1.239\n+++ lstrlib.c\t2016/04/11 15:29:41\n@@ -688,6 +688,7 @@\n static int gmatch_aux (lua_State *L) {\n   GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));\n   const char *src;\n+  gm->ms.L = L;\n   for (src = gm->src; src <= gm->ms.src_end; src++) {\n     const char *e;\n     reprepstate(&gm->ms);\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.3\n\n\nBug{\nwhat = [[expression list with four or more expressions in\na 'for' loop can crash the interpreter]],\nreport = [[Marco Sch\u00f6pl, 2016/06/17]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n-- the next loop will probably crash the interpreter\nrepeat until load \"for _ in _,_,_,_ do local function _() end\"\n]],\npatch = [[\n--- lparser.c\t2016/05/13 19:10:16\t2.153\n+++ lparser.c\t2016/06/17 19:52:48\n@@ -323,6 +323,8 @@\n       luaK_nil(fs, reg, extra);\n     }\n   }\n+  if (nexps > nvars)\n+    ls->fs->freereg -= nexps - nvars;  /* remove extra values */\n }\n \n \n@@ -1160,11 +1162,8 @@\n     int nexps;\n     checknext(ls, '=');\n     nexps = explist(ls, &e);\n-    if (nexps != nvars) {\n+    if (nexps != nvars)\n       adjust_assign(ls, nvars, nexps, &e);\n-      if (nexps > nvars)\n-        ls->fs->freereg -= nexps - nvars;  /* remove extra values */\n-    }\n     else {\n       luaK_setoneret(ls->fs, &e);  /* close last expression */\n       luaK_storevar(ls->fs, &lh->v, &e);\n]]\n}\n\n\nBug{\nwhat = [[Checking a format for 'os.date' may read pass the format string]],\nreport = [[Nagaev Boris, 2016/07/10]],\nsince = [[5.3.3]],\nfix = nil,\nexample = [[\nThis bug does not seem to happen with regular compilers.\nIt needs an \"interceptor\" 'memcmp' function that continues\nreading memory after a difference is found.]],\npatch = [[\n2c2\n< ** $Id: bugs,v 1.160 2018/05/24 20:25:14 roberto Exp roberto $\n---\n> ** $Id: bugs,v 1.160 2018/05/24 20:25:14 roberto Exp roberto $\n263c263,264\n<   for (option = LUA_STRFTIMEOPTIONS; *option != '\\0'; option += oplen) {\n---\n>   int convlen = (int)strlen(conv);\n>   for (option = LUA_STRFTIMEOPTIONS; *option != '\\0' && oplen <= convlen; option += oplen) {\n]]\n}\n\n\nBug{\nwhat = [[Lua can generate wrong code in functions with too many constants]],\nreport = [[Marco Sch\u00f6pl, 2016/07/17]],\nsince = [[5.3.3]],\nfix = nil,\nexample = [[See http://lua-users.org/lists/lua-l/2016-07/msg00303.html]],\npatch = [[\n--- lcode.c     2016/06/20 19:12:46     2.110\n+++ lcode.c     2016/07/18 15:43:41\n@@ -1018,8 +1018,8 @@\n */\n static void codebinexpval (FuncState *fs, OpCode op,\n                            expdesc *e1, expdesc *e2, int line) {\n-  int rk1 = luaK_exp2RK(fs, e1);  /* both operands are \"RK\" */\n-  int rk2 = luaK_exp2RK(fs, e2);\n+  int rk2 = luaK_exp2RK(fs, e2);  /* both operands are \"RK\" */\n+  int rk1 = luaK_exp2RK(fs, e1);\n   freeexps(fs, e1, e2);\n   e1->u.info = luaK_codeABC(fs, op, 0, rk1, rk2);  /* generate opcode */\n   e1->k = VRELOCABLE;  /* all those operations are relocatable */\n]]\n}\n\n\nBug{\nwhat = [[When a coroutine tries to resume a non-suspended coroutine,\nit can do some mess (and break C assertions) before detecting the error]],\nreport = [[Marco Sch\u00f6pl, 2016/07/20]],\nsince = [[ ]],\nfix = nil,\nexample = [[\n-- with C assertions on\nA = coroutine.running()\nB = coroutine.create(function() coroutine.resume(A) end)\ncoroutine.resume(B)\n\n-- or\nA = coroutine.wrap(function() pcall(A, _) end)\nA()\n]],\npatch = [[\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.4\n\n\nBug{\nwhat = [[Wrong code for a goto followed by a label inside an 'if']],\nreport = [[\u4e91\u98ce, 2017/04/13]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n-- should print 32323232..., but prints only '3'\nif true then\n  goto LBL\n  ::loop::\n  print(2)\n  ::LBL::\n  print(3)\n  goto loop\nend\n]],\npatch = [[\n--- lparser.c\t2017/04/19 17:20:42\t2.155.1.1\n+++ lparser.c\t2017/04/29 18:11:40\t2.155.1.2\n@@ -1392,7 +1392,7 @@\n     luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */\n     enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n     gotostat(ls, v.t);  /* handle goto/break */\n-    skipnoopstat(ls);  /* skip other no-op statements */\n+    while (testnext(ls, ';')) {}  /* skip semicolons */\n     if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */\n       leaveblock(fs);\n       return;  /* and that is it */\n]]\n}\n\n\nBug{\nwhat = [[Lua crashes when building sequences with more than 2^30 elements.]],\nreport = [[Viacheslav Usov, 2017/05/11]],\nsince = [[ ]],\nfix = nil,\nexample = [[\n-- crashes if machine has enough memory\nlocal t = {}\nfor i = 1, 0x7fffffff do\n  t[i] = i\nend\n]],\npatch = [[\n--- ltable.c\t2017/04/19 17:20:42\t2.118.1.1\n+++ ltable.c\t2018/05/24 18:34:38\n@@ -223,7 +223,9 @@\n   unsigned int na = 0;  /* number of elements to go to array part */\n   unsigned int optimal = 0;  /* optimal size for array part */\n   /* loop while keys can fill more than half of total size */\n-  for (i = 0, twotoi = 1; *pna > twotoi / 2; i++, twotoi *= 2) {\n+  for (i = 0, twotoi = 1;\n+       twotoi > 0 && *pna > twotoi / 2;\n+       i++, twotoi *= 2) {\n     if (nums[i] > 0) {\n       a += nums[i];\n       if (a > twotoi/2) {  /* more than half elements present? */\n]]\n}\n\n\nBug{\nwhat = [[Table length computation overflows for sequences larger than\n2^31 elements.]],\nreport = [[Viacheslav Usov, 2017/05/12]],\nsince = [[ ]],\nfix = nil,\nexample = [[\n-- on a machine with enough memory\nlocal t = {}\nfor i = 1, 2147483681 do\n  t[i] = i\nend\nprint(#t)\n]],\npatch = [[\n--- ltable.h\t2017/04/19 17:20:42\t2.23.1.1\n+++ ltable.h\t2018/05/24 19:31:50\n@@ -56,3 +56,3 @@\n LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);\n-LUAI_FUNC int luaH_getn (Table *t);\n+LUAI_FUNC lua_Unsigned luaH_getn (Table *t);\n \n--- ltable.c\t2018/05/24 19:22:37\t2.118.1.2\n+++ ltable.c\t2018/05/24 19:25:05\n@@ -614,4 +614,4 @@\n \n-static int unbound_search (Table *t, unsigned int j) {\n-  unsigned int i = j;  /* i is zero or a present index */\n+static lua_Unsigned unbound_search (Table *t, lua_Unsigned j) {\n+  lua_Unsigned i = j;  /* i is zero or a present index */\n   j++;\n@@ -620,3 +620,3 @@\n     i = j;\n-    if (j > cast(unsigned int, MAX_INT)/2) {  /* overflow? */\n+    if (j > l_castS2U(LUA_MAXINTEGER) / 2) {  /* overflow? */\n       /* table was built with bad purposes: resort to linear search */\n@@ -630,3 +630,3 @@\n   while (j - i > 1) {\n-    unsigned int m = (i+j)/2;\n+    lua_Unsigned m = (i+j)/2;\n     if (ttisnil(luaH_getint(t, m))) j = m;\n@@ -642,3 +642,3 @@\n */\n-int luaH_getn (Table *t) {\n+lua_Unsigned luaH_getn (Table *t) {\n   unsigned int j = t->sizearray;\n]]\n}\n\n\nBug{\nwhat = [[Lua does not check GC when creating error messages]],\nreport = [[Viacheslav Usov, 2017/07/06]],\nsince = [[5.3.2]],\nfix = nil,\nexample = [[\nfunction test()  \n  bob.joe.larry = 23\nend\n\n-- memory will grow steadly \nfor i = 1, math.huge do\n  pcall(test)\n  if i % 100000 == 0 then\n    io.write(collectgarbage'count'*1024, \"\\n\")\n  end\nend\n]],\npatch = [[\n--- ldebug.c\t2017/04/19 17:20:42\t2.121.1.1\n+++ ldebug.c\t2017/07/10 17:08:39\n@@ -653,6 +653,7 @@\n   CallInfo *ci = L->ci;\n   const char *msg;\n   va_list argp;\n+  luaC_checkGC(L);  /* error message uses memory */\n   va_start(argp, fmt);\n   msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n   va_end(argp);\n]]\n}\n\n\nBug{\nwhat = [[dead keys with nil values can stay in weak tables]],\nreport = [[\u4e91\u98ce Cloud Wu, 2017/08/15]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n-- The following chunk, under a memory checker like valgrind, \n-- produces a memory access violation.\n\nlocal a = setmetatable({}, {__mode = 'kv'})\n\na['ABCDEFGHIJKLMNOPQRSTUVWXYZ' .. 'abcdefghijklmnopqrstuvwxyz'] = {}\na[next(a)] = nil\ncollectgarbage()\nprint(a['BCDEFGHIJKLMNOPQRSTUVWXYZ' .. 'abcdefghijklmnopqrstuvwxyz'])\n]],\npatch = [[\n--- lgc.c\t2016/12/22 13:08:50\t2.215\n+++ lgc.c\t2017/08/31 16:08:23\n@@ -643,8 +643,9 @@\n     for (n = gnode(h, 0); n < limit; n++) {\n       if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {\n         setnilvalue(gval(n));  /* remove value ... */\n-        removeentry(n);  /* and remove entry from table */\n       }\n+      if (ttisnil(gval(n)))  /* is entry empty? */\n+        removeentry(n);  /* remove entry from table */\n     }\n   }\n }\n]]\n}\n\n\nBug{\nwhat = [['lua_pushcclosure' should not call the garbage collector when\n'n' is zero.]],\nreport = [[Andrew Gierth, 2017/12/05]],\nsince = [[5.3.3]],\nfix = nil,\nexample = [[ ]],\npatch = [[\n--- lapi.c\t2017/04/19 17:13:00\t2.259.1.1\n+++ lapi.c\t2017/12/06 18:14:45\n@@ -533,6 +533,7 @@\n   lua_lock(L);\n   if (n == 0) {\n     setfvalue(L->top, fn);\n+    api_incr_top(L);\n   }\n   else {\n     CClosure *cl;\n@@ -546,9 +547,9 @@\n       /* does not need barrier because closure is white */\n     }\n     setclCvalue(L, L->top, cl);\n+    api_incr_top(L);\n+    luaC_checkGC(L);\n   }\n-  api_incr_top(L);\n-  luaC_checkGC(L);\n   lua_unlock(L);\n }\n]]\n}\n\n\nBug{\nwhat = [[memory-allocation error when resizing a table can leave it\nin an inconsistent state.]],\nreport = [[Roberto, 2017/12/08]],\nsince = [[5.0]],\nfix = nil,\nexample = [[\nlocal a = {x = 1, y = 1, z = 1}\na[1] = 10   -- goes to the hash part (which has 4 slots)\nprint(a[1])   --> 10\n\n-- assume that the 2nd memory allocation from now fails\npcall(rawset, a, 2, 20)   -- forces a rehash\n\n-- a[1] now exists both in the array part (because the array part\n-- grew) and in the hash part (because the allocation of the hash\n-- part failed, keeping it as it was).\n-- This makes the following traversal goes forever...\nfor k,v in pairs(a) do print(k,v) end\n]],\npatch = [[\n--- ltable.c    2018/05/24 19:39:05     2.118.1.3\n+++ ltable.c    2018/06/04 16:00:25\n@@ -332,17 +332,34 @@\n }\n \n \n+typedef struct {\n+  Table *t;\n+  unsigned int nhsize;\n+} AuxsetnodeT;\n+\n+\n+static void auxsetnode (lua_State *L, void *ud) {\n+  AuxsetnodeT *asn = cast(AuxsetnodeT *, ud);\n+  setnodevector(L, asn->t, asn->nhsize);\n+}\n+\n+\n void luaH_resize (lua_State *L, Table *t, unsigned int nasize,\n                                           unsigned int nhsize) {\n   unsigned int i;\n   int j;\n+  AuxsetnodeT asn;\n   unsigned int oldasize = t->sizearray;\n   int oldhsize = allocsizenode(t);\n   Node *nold = t->node;  /* save old hash ... */\n   if (nasize > oldasize)  /* array part must grow? */\n     setarrayvector(L, t, nasize);\n   /* create new hash part with appropriate size */\n-  setnodevector(L, t, nhsize);\n+  asn.t = t; asn.nhsize = nhsize;\n+  if (luaD_rawrunprotected(L, auxsetnode, &asn) != LUA_OK) {  /* mem. error? */\n+    setarrayvector(L, t, oldasize);  /* array back to its original size */\n+    luaD_throw(L, LUA_ERRMEM);  /* rethrow memory error */\n+  }\n   if (nasize < oldasize) {  /* array part must shrink? */\n     t->sizearray = nasize;\n     /* re-insert elements from vanishing slice */\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.5\n\n--[=[\nBug{\nwhat = [[Long brackets with a huge number of '=' overflow some\ninternal buffer arithmetic]],\nreport = [[Marco, 2018/12/12]],\nsince = [[5.1]],\nfix = nil,\nexample = [[\nlocal eqs = string.rep(\"=\", 0x3ffffffe)\nlocal code = \"return [\" .. eqs .. \"[a]\" .. eqs .. \"]\"\nprint(#assert(load(code))())\n]],\npatch = [[\n--- a/llex.c\n+++ b/llex.c\n@@ -244,12 +244,12 @@\n \n \n /*\n-** skip a sequence '[=*[' or ']=*]'; if sequence is well formed, return\n-** its number of '='s; otherwise, return a negative number (-1 iff there\n-** are no '='s after initial bracket)\n+** reads a sequence '[=*[' or ']=*]', leaving the last bracket.\n+** If sequence is well formed, return its number of '='s + 2; otherwise,\n+** return 1 if there is no '='s or 0 otherwise (an unfinished '[==...').\n */\n-static int skip_sep (LexState *ls) {\n-  int count = 0;\n+static size_t skip_sep (LexState *ls) {\n+  size_t count = 0;\n   int s = ls->current;\n   lua_assert(s == '[' || s == ']');\n   save_and_next(ls);\n@@ -257,11 +257,14 @@\n     save_and_next(ls);\n     count++;\n   }\n-  return (ls->current == s) ? count : (-count) - 1;\n+  return (ls->current == s) ? count + 2\n+         : (count == 0) ? 1\n+         : 0;\n+\n }\n \n \n-static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {\n+static void read_long_string (LexState *ls, SemInfo *seminfo, size_t sep) {\n   int line = ls->linenumber;  /* initial line (for error message) */\n   save_and_next(ls);  /* skip 2nd '[' */\n   if (currIsNewline(ls))  /* string starts with a newline? */\n@@ -295,8 +298,8 @@\n     }\n   } endloop:\n   if (seminfo)\n-    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),\n-                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));\n+    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + sep,\n+                                     luaZ_bufflen(ls->buff) - 2 * sep);\n }\n \n \n@@ -444,9 +447,9 @@\n         /* else is a comment */\n         next(ls);\n         if (ls->current == '[') {  /* long comment? */\n-          int sep = skip_sep(ls);\n+          size_t sep = skip_sep(ls);\n           luaZ_resetbuffer(ls->buff);  /* 'skip_sep' may dirty the buffer */\n-          if (sep >= 0) {\n+          if (sep >= 2) {\n             read_long_string(ls, NULL, sep);  /* skip long comment */\n             luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */\n             break;\n@@ -458,12 +461,12 @@\n         break;\n       }\n       case '[': {  /* long string or simply '[' */\n-        int sep = skip_sep(ls);\n-        if (sep >= 0) {\n+        size_t sep = skip_sep(ls);\n+        if (sep >= 2) {\n           read_long_string(ls, seminfo, sep);\n           return TK_STRING;\n         }\n-        else if (sep != -1)  /* '[=...' missing second bracket */\n+        else if (sep == 0)  /* '[=...' missing second bracket */\n           lexerror(ls, \"invalid long string delimiter\", TK_STRING);\n         return '[';\n       }\n]]\n}\n]=]\n\n\n\n\n--[=[\nBug{\nwhat = [[ ]],\nreport = [[ ]],\nsince = [[ ]],\nfix = nil,\nexample = [[ ]],\npatch = [[\n]]\n}\n]=]\n\n\n", "/*\n** $Id: lapi.c,v 2.259.1.2 2017/12/06 18:35:12 roberto Exp $\n** Lua API\n** See Copyright Notice in lua.h\n*/\n\n#define lapi_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n\n\n\nconst char lua_ident[] =\n  \"$LuaVersion: \" LUA_COPYRIGHT \" $\"\n  \"$LuaAuthors: \" LUA_AUTHORS \" $\";\n\n\n/* value at a non-valid index */\n#define NONVALIDVALUE\t\tcast(TValue *, luaO_nilobject)\n\n/* corresponding test */\n#define isvalid(o)\t((o) != luaO_nilobject)\n\n/* test for pseudo index */\n#define ispseudo(i)\t\t((i) <= LUA_REGISTRYINDEX)\n\n/* test for upvalue */\n#define isupvalue(i)\t\t((i) < LUA_REGISTRYINDEX)\n\n/* test for valid but not pseudo index */\n#define isstackindex(i, o)\t(isvalid(o) && !ispseudo(i))\n\n#define api_checkvalidindex(l,o)  api_check(l, isvalid(o), \"invalid index\")\n\n#define api_checkstackindex(l, i, o)  \\\n\tapi_check(l, isstackindex(i, o), \"index not in the stack\")\n\n\nstatic TValue *index2addr (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    TValue *o = ci->func + idx;\n    api_check(L, idx <= ci->top - (ci->func + 1), \"unacceptable index\");\n    if (o >= L->top) return NONVALIDVALUE;\n    else return o;\n  }\n  else if (!ispseudo(idx)) {  /* negative index */\n    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), \"invalid index\");\n    return L->top + idx;\n  }\n  else if (idx == LUA_REGISTRYINDEX)\n    return &G(L)->l_registry;\n  else {  /* upvalues */\n    idx = LUA_REGISTRYINDEX - idx;\n    api_check(L, idx <= MAXUPVAL + 1, \"upvalue index too large\");\n    if (ttislcf(ci->func))  /* light C function? */\n      return NONVALIDVALUE;  /* it has no upvalues */\n    else {\n      CClosure *func = clCvalue(ci->func);\n      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;\n    }\n  }\n}\n\n\n/*\n** to be called by 'lua_checkstack' in protected mode, to grow stack\n** capturing memory errors\n*/\nstatic void growstack (lua_State *L, void *ud) {\n  int size = *(int *)ud;\n  luaD_growstack(L, size);\n}\n\n\nLUA_API int lua_checkstack (lua_State *L, int n) {\n  int res;\n  CallInfo *ci = L->ci;\n  lua_lock(L);\n  api_check(L, n >= 0, \"negative 'n'\");\n  if (L->stack_last - L->top > n)  /* stack large enough? */\n    res = 1;  /* yes; check is OK */\n  else {  /* no; need to grow stack */\n    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;\n    if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */\n      res = 0;  /* no */\n    else  /* try to grow stack */\n      res = (luaD_rawrunprotected(L, &growstack, &n) == LUA_OK);\n  }\n  if (res && ci->top < L->top + n)\n    ci->top = L->top + n;  /* adjust frame top */\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {\n  int i;\n  if (from == to) return;\n  lua_lock(to);\n  api_checknelems(from, n);\n  api_check(from, G(from) == G(to), \"moving among independent states\");\n  api_check(from, to->ci->top - to->top >= n, \"stack overflow\");\n  from->top -= n;\n  for (i = 0; i < n; i++) {\n    setobj2s(to, to->top, from->top + i);\n    to->top++;  /* stack already checked by previous 'api_check' */\n  }\n  lua_unlock(to);\n}\n\n\nLUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {\n  lua_CFunction old;\n  lua_lock(L);\n  old = G(L)->panic;\n  G(L)->panic = panicf;\n  lua_unlock(L);\n  return old;\n}\n\n\nLUA_API const lua_Number *lua_version (lua_State *L) {\n  static const lua_Number version = LUA_VERSION_NUM;\n  if (L == NULL) return &version;\n  else return G(L)->version;\n}\n\n\n\n/*\n** basic stack manipulation\n*/\n\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nLUA_API int lua_absindex (lua_State *L, int idx) {\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top - L->ci->func) + idx;\n}\n\n\nLUA_API int lua_gettop (lua_State *L) {\n  return cast_int(L->top - (L->ci->func + 1));\n}\n\n\nLUA_API void lua_settop (lua_State *L, int idx) {\n  StkId func = L->ci->func;\n  lua_lock(L);\n  if (idx >= 0) {\n    api_check(L, idx <= L->stack_last - (func + 1), \"new top too large\");\n    while (L->top < (func + 1) + idx)\n      setnilvalue(L->top++);\n    L->top = (func + 1) + idx;\n  }\n  else {\n    api_check(L, -(idx+1) <= (L->top - (func + 1)), \"invalid new top\");\n    L->top += idx+1;  /* 'subtract' index (index is negative) */\n  }\n  lua_unlock(L);\n}\n\n\n/*\n** Reverse the stack segment from 'from' to 'to'\n** (auxiliary to 'lua_rotate')\n*/\nstatic void reverse (lua_State *L, StkId from, StkId to) {\n  for (; from < to; from++, to--) {\n    TValue temp;\n    setobj(L, &temp, from);\n    setobjs2s(L, from, to);\n    setobj2s(L, to, &temp);\n  }\n}\n\n\n/*\n** Let x = AB, where A is a prefix of length 'n'. Then,\n** rotate x n == BA. But BA == (A^r . B^r)^r.\n*/\nLUA_API void lua_rotate (lua_State *L, int idx, int n) {\n  StkId p, t, m;\n  lua_lock(L);\n  t = L->top - 1;  /* end of stack segment being rotated */\n  p = index2addr(L, idx);  /* start of segment */\n  api_checkstackindex(L, idx, p);\n  api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), \"invalid 'n'\");\n  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */\n  reverse(L, p, m);  /* reverse the prefix with length 'n' */\n  reverse(L, m + 1, t);  /* reverse the suffix */\n  reverse(L, p, t);  /* reverse the entire segment */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {\n  TValue *fr, *to;\n  lua_lock(L);\n  fr = index2addr(L, fromidx);\n  to = index2addr(L, toidx);\n  api_checkvalidindex(L, to);\n  setobj(L, to, fr);\n  if (isupvalue(toidx))  /* function upvalue? */\n    luaC_barrier(L, clCvalue(L->ci->func), fr);\n  /* LUA_REGISTRYINDEX does not need gc barrier\n     (collector revisits it before finishing collection) */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushvalue (lua_State *L, int idx) {\n  lua_lock(L);\n  setobj2s(L, L->top, index2addr(L, idx));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n\n/*\n** access functions (stack -> C)\n*/\n\n\nLUA_API int lua_type (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (isvalid(o) ? ttnov(o) : LUA_TNONE);\n}\n\n\nLUA_API const char *lua_typename (lua_State *L, int t) {\n  UNUSED(L);\n  api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, \"invalid tag\");\n  return ttypename(t);\n}\n\n\nLUA_API int lua_iscfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (ttislcf(o) || (ttisCclosure(o)));\n}\n\n\nLUA_API int lua_isinteger (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return ttisinteger(o);\n}\n\n\nLUA_API int lua_isnumber (lua_State *L, int idx) {\n  lua_Number n;\n  const TValue *o = index2addr(L, idx);\n  return tonumber(o, &n);\n}\n\n\nLUA_API int lua_isstring (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return (ttisstring(o) || cvt2str(o));\n}\n\n\nLUA_API int lua_isuserdata (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return (ttisfulluserdata(o) || ttislightuserdata(o));\n}\n\n\nLUA_API int lua_rawequal (lua_State *L, int index1, int index2) {\n  StkId o1 = index2addr(L, index1);\n  StkId o2 = index2addr(L, index2);\n  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;\n}\n\n\nLUA_API void lua_arith (lua_State *L, int op) {\n  lua_lock(L);\n  if (op != LUA_OPUNM && op != LUA_OPBNOT)\n    api_checknelems(L, 2);  /* all other operations expect two operands */\n  else {  /* for unary operations, add fake 2nd operand */\n    api_checknelems(L, 1);\n    setobjs2s(L, L->top, L->top - 1);\n    api_incr_top(L);\n  }\n  /* first operand at top - 2, second at top - 1; result go to top - 2 */\n  luaO_arith(L, op, L->top - 2, L->top - 1, L->top - 2);\n  L->top--;  /* remove second operand */\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {\n  StkId o1, o2;\n  int i = 0;\n  lua_lock(L);  /* may call tag method */\n  o1 = index2addr(L, index1);\n  o2 = index2addr(L, index2);\n  if (isvalid(o1) && isvalid(o2)) {\n    switch (op) {\n      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;\n      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;\n      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;\n      default: api_check(L, 0, \"invalid option\");\n    }\n  }\n  lua_unlock(L);\n  return i;\n}\n\n\nLUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {\n  size_t sz = luaO_str2num(s, L->top);\n  if (sz != 0)\n    api_incr_top(L);\n  return sz;\n}\n\n\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {\n  lua_Number n;\n  const TValue *o = index2addr(L, idx);\n  int isnum = tonumber(o, &n);\n  if (!isnum)\n    n = 0;  /* call to 'tonumber' may change 'n' even if it fails */\n  if (pisnum) *pisnum = isnum;\n  return n;\n}\n\n\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {\n  lua_Integer res;\n  const TValue *o = index2addr(L, idx);\n  int isnum = tointeger(o, &res);\n  if (!isnum)\n    res = 0;  /* call to 'tointeger' may change 'n' even if it fails */\n  if (pisnum) *pisnum = isnum;\n  return res;\n}\n\n\nLUA_API int lua_toboolean (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return !l_isfalse(o);\n}\n\n\nLUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {\n  StkId o = index2addr(L, idx);\n  if (!ttisstring(o)) {\n    if (!cvt2str(o)) {  /* not convertible? */\n      if (len != NULL) *len = 0;\n      return NULL;\n    }\n    lua_lock(L);  /* 'luaO_tostring' may create a new string */\n    luaO_tostring(L, o);\n    luaC_checkGC(L);\n    o = index2addr(L, idx);  /* previous call may reallocate the stack */\n    lua_unlock(L);\n  }\n  if (len != NULL)\n    *len = vslen(o);\n  return svalue(o);\n}\n\n\nLUA_API size_t lua_rawlen (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttype(o)) {\n    case LUA_TSHRSTR: return tsvalue(o)->shrlen;\n    case LUA_TLNGSTR: return tsvalue(o)->u.lnglen;\n    case LUA_TUSERDATA: return uvalue(o)->len;\n    case LUA_TTABLE: return luaH_getn(hvalue(o));\n    default: return 0;\n  }\n}\n\n\nLUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  if (ttislcf(o)) return fvalue(o);\n  else if (ttisCclosure(o))\n    return clCvalue(o)->f;\n  else return NULL;  /* not a C function */\n}\n\n\nLUA_API void *lua_touserdata (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttnov(o)) {\n    case LUA_TUSERDATA: return getudatamem(uvalue(o));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\nLUA_API lua_State *lua_tothread (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (!ttisthread(o)) ? NULL : thvalue(o);\n}\n\n\nLUA_API const void *lua_topointer (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttype(o)) {\n    case LUA_TTABLE: return hvalue(o);\n    case LUA_TLCL: return clLvalue(o);\n    case LUA_TCCL: return clCvalue(o);\n    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));\n    case LUA_TTHREAD: return thvalue(o);\n    case LUA_TUSERDATA: return getudatamem(uvalue(o));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\n\n/*\n** push functions (C -> stack)\n*/\n\n\nLUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n) {\n  lua_lock(L);\n  setfltvalue(L->top, n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {\n  lua_lock(L);\n  setivalue(L->top, n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n/*\n** Pushes on the stack a string with given length. Avoid using 's' when\n** 'len' == 0 (as 's' can be NULL in that case), due to later use of\n** 'memcmp' and 'memcpy'.\n*/\nLUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {\n  TString *ts;\n  lua_lock(L);\n  ts = (len == 0) ? luaS_new(L, \"\") : luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top, ts);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushstring (lua_State *L, const char *s) {\n  lua_lock(L);\n  if (s == NULL)\n    setnilvalue(L->top);\n  else {\n    TString *ts;\n    ts = luaS_new(L, s);\n    setsvalue2s(L, L->top, ts);\n    s = getstr(ts);  /* internal copy's address */\n  }\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return s;\n}\n\n\nLUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,\n                                      va_list argp) {\n  const char *ret;\n  lua_lock(L);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *ret;\n  va_list argp;\n  lua_lock(L);\n  va_start(argp, fmt);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {\n  lua_lock(L);\n  if (n == 0) {\n    setfvalue(L->top, fn);\n    api_incr_top(L);\n  }\n  else {\n    CClosure *cl;\n    api_checknelems(L, n);\n    api_check(L, n <= MAXUPVAL, \"upvalue index too large\");\n    cl = luaF_newCclosure(L, n);\n    cl->f = fn;\n    L->top -= n;\n    while (n--) {\n      setobj2n(L, &cl->upvalue[n], L->top + n);\n      /* does not need barrier because closure is white */\n    }\n    setclCvalue(L, L->top, cl);\n    api_incr_top(L);\n    luaC_checkGC(L);\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushboolean (lua_State *L, int b) {\n  lua_lock(L);\n  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(L->top, p);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_pushthread (lua_State *L) {\n  lua_lock(L);\n  setthvalue(L, L->top, L);\n  api_incr_top(L);\n  lua_unlock(L);\n  return (G(L)->mainthread == L);\n}\n\n\n\n/*\n** get functions (Lua -> stack)\n*/\n\n\nstatic int auxgetstr (lua_State *L, const TValue *t, const char *k) {\n  const TValue *slot;\n  TString *str = luaS_new(L, k);\n  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {\n    setobj2s(L, L->top, slot);\n    api_incr_top(L);\n  }\n  else {\n    setsvalue2s(L, L->top, str);\n    api_incr_top(L);\n    luaV_finishget(L, t, L->top - 1, L->top - 1, slot);\n  }\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_getglobal (lua_State *L, const char *name) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  lua_lock(L);\n  return auxgetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);\n}\n\n\nLUA_API int lua_gettable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_getfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);\n  return auxgetstr(L, index2addr(L, idx), k);\n}\n\n\nLUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {\n  StkId t;\n  const TValue *slot;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  if (luaV_fastget(L, t, n, slot, luaH_getint)) {\n    setobj2s(L, L->top, slot);\n    api_incr_top(L);\n  }\n  else {\n    setivalue(L->top, n);\n    api_incr_top(L);\n    luaV_finishget(L, t, L->top - 1, L->top - 1, slot);\n  }\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_rawget (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top, luaH_getint(hvalue(t), n));\n  api_incr_top(L);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {\n  StkId t;\n  TValue k;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  setobj2s(L, L->top, luaH_get(hvalue(t), &k));\n  api_incr_top(L);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API void lua_createtable (lua_State *L, int narray, int nrec) {\n  Table *t;\n  lua_lock(L);\n  t = luaH_new(L);\n  sethvalue(L, L->top, t);\n  api_incr_top(L);\n  if (narray > 0 || nrec > 0)\n    luaH_resize(L, t, narray, nrec);\n  luaC_checkGC(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_getmetatable (lua_State *L, int objindex) {\n  const TValue *obj;\n  Table *mt;\n  int res = 0;\n  lua_lock(L);\n  obj = index2addr(L, objindex);\n  switch (ttnov(obj)) {\n    case LUA_TTABLE:\n      mt = hvalue(obj)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(obj)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttnov(obj)];\n      break;\n  }\n  if (mt != NULL) {\n    sethvalue(L, L->top, mt);\n    api_incr_top(L);\n    res = 1;\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API int lua_getuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  o = index2addr(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  getuservalue(L, uvalue(o), L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\n/*\n** set functions (stack -> Lua)\n*/\n\n/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\nstatic void auxsetstr (lua_State *L, const TValue *t, const char *k) {\n  const TValue *slot;\n  TString *str = luaS_new(L, k);\n  api_checknelems(L, 1);\n  if (luaV_fastset(L, t, str, slot, luaH_getstr, L->top - 1))\n    L->top--;  /* pop value */\n  else {\n    setsvalue2s(L, L->top, str);  /* push 'str' (to make it a TValue) */\n    api_incr_top(L);\n    luaV_finishset(L, t, L->top - 1, L->top - 2, slot);\n    L->top -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);  /* lock done by caller */\n}\n\n\nLUA_API void lua_setglobal (lua_State *L, const char *name) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  auxsetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);\n}\n\n\nLUA_API void lua_settable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2addr(L, idx);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  auxsetstr(L, index2addr(L, idx), k);\n}\n\n\nLUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {\n  StkId t;\n  const TValue *slot;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  if (luaV_fastset(L, t, n, slot, luaH_getint, L->top - 1))\n    L->top--;  /* pop value */\n  else {\n    setivalue(L->top, n);\n    api_incr_top(L);\n    luaV_finishset(L, t, L->top - 1, L->top - 2, slot);\n    L->top -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawset (lua_State *L, int idx) {\n  StkId o;\n  TValue *slot;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  o = index2addr(L, idx);\n  api_check(L, ttistable(o), \"table expected\");\n  slot = luaH_set(L, hvalue(o), L->top - 2);\n  setobj2t(L, slot, L->top - 1);\n  invalidateTMcache(hvalue(o));\n  luaC_barrierback(L, hvalue(o), L->top-1);\n  L->top -= 2;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttistable(o), \"table expected\");\n  luaH_setint(L, hvalue(o), n, L->top - 1);\n  luaC_barrierback(L, hvalue(o), L->top-1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {\n  StkId o;\n  TValue k, *slot;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttistable(o), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  slot = luaH_set(L, hvalue(o), &k);\n  setobj2t(L, slot, L->top - 1);\n  luaC_barrierback(L, hvalue(o), L->top - 1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  obj = index2addr(L, objindex);\n  if (ttisnil(L->top - 1))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1), \"table expected\");\n    mt = hvalue(L->top - 1);\n  }\n  switch (ttnov(obj)) {\n    case LUA_TTABLE: {\n      hvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, gcvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, uvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    default: {\n      G(L)->mt[ttnov(obj)] = mt;\n      break;\n    }\n  }\n  L->top--;\n  lua_unlock(L);\n  return 1;\n}\n\n\nLUA_API void lua_setuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  setuservalue(L, uvalue(o), L->top - 1);\n  luaC_barrier(L, gcvalue(o), L->top - 1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\n/*\n** 'load' and 'call' functions (run Lua code)\n*/\n\n\n#define checkresults(L,na,nr) \\\n     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \\\n\t\"results from function overflow current stack size\")\n\n\nLUA_API void lua_callk (lua_State *L, int nargs, int nresults,\n                        lua_KContext ctx, lua_KFunction k) {\n  StkId func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  func = L->top - (nargs+1);\n  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */\n    L->ci->u.c.k = k;  /* save continuation */\n    L->ci->u.c.ctx = ctx;  /* save context */\n    luaD_call(L, func, nresults);  /* do the call */\n  }\n  else  /* no continuation or no yieldable */\n    luaD_callnoyield(L, func, nresults);  /* just do the call */\n  adjustresults(L, nresults);\n  lua_unlock(L);\n}\n\n\n\n/*\n** Execute a protected call.\n*/\nstruct CallS {  /* data to 'f_call' */\n  StkId func;\n  int nresults;\n};\n\n\nstatic void f_call (lua_State *L, void *ud) {\n  struct CallS *c = cast(struct CallS *, ud);\n  luaD_callnoyield(L, c->func, c->nresults);\n}\n\n\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2addr(L, errfunc);\n    api_checkstackindex(L, errfunc, o);\n    func = savestack(L, o);\n  }\n  c.func = L->top - (nargs+1);  /* function to be called */\n  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->extra = savestack(L, c.func);\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */\n    luaD_call(L, c.func, nresults);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,\n                      const char *chunkname, const char *mode) {\n  ZIO z;\n  int status;\n  lua_lock(L);\n  if (!chunkname) chunkname = \"?\";\n  luaZ_init(L, &z, reader, data);\n  status = luaD_protectedparser(L, &z, chunkname, mode);\n  if (status == LUA_OK) {  /* no errors? */\n    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */\n    if (f->nupvalues >= 1) {  /* does it have an upvalue? */\n      /* get global table from registry */\n      Table *reg = hvalue(&G(L)->l_registry);\n      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n      setobj(L, f->upvals[0]->v, gt);\n      luaC_upvalbarrier(L, f->upvals[0]);\n    }\n  }\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {\n  int status;\n  TValue *o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = L->top - 1;\n  if (isLfunction(o))\n    status = luaU_dump(L, getproto(o), writer, data, strip);\n  else\n    status = 1;\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_status (lua_State *L) {\n  return L->status;\n}\n\n\n/*\n** Garbage-collection function\n*/\n\nLUA_API int lua_gc (lua_State *L, int what, int data) {\n  int res = 0;\n  global_State *g;\n  lua_lock(L);\n  g = G(L);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->gcrunning = 0;\n      break;\n    }\n    case LUA_GCRESTART: {\n      luaE_setdebt(g, 0);\n      g->gcrunning = 1;\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L, 0);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(gettotalbytes(g) >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(gettotalbytes(g) & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      l_mem debt = 1;  /* =1 to signal that it did an actual step */\n      lu_byte oldrunning = g->gcrunning;\n      g->gcrunning = 1;  /* allow GC to run */\n      if (data == 0) {\n        luaE_setdebt(g, -GCSTEPSIZE);  /* to do a \"small\" step */\n        luaC_step(L);\n      }\n      else {  /* add 'data' to total debt */\n        debt = cast(l_mem, data) * 1024 + g->GCdebt;\n        luaE_setdebt(g, debt);\n        luaC_checkGC(L);\n      }\n      g->gcrunning = oldrunning;  /* restore previous state */\n      if (debt > 0 && g->gcstate == GCSpause)  /* end of cycle? */\n        res = 1;  /* signal it */\n      break;\n    }\n    case LUA_GCSETPAUSE: {\n      res = g->gcpause;\n      g->gcpause = data;\n      break;\n    }\n    case LUA_GCSETSTEPMUL: {\n      res = g->gcstepmul;\n      if (data < 40) data = 40;  /* avoid ridiculous low values (and 0) */\n      g->gcstepmul = data;\n      break;\n    }\n    case LUA_GCISRUNNING: {\n      res = g->gcrunning;\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\n\n/*\n** miscellaneous functions\n*/\n\n\nLUA_API int lua_error (lua_State *L) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}\n\n\nLUA_API int lua_next (lua_State *L, int idx) {\n  StkId t;\n  int more;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  more = luaH_next(L, hvalue(t), L->top - 1);\n  if (more) {\n    api_incr_top(L);\n  }\n  else  /* no more elements */\n    L->top -= 1;  /* remove key */\n  lua_unlock(L);\n  return more;\n}\n\n\nLUA_API void lua_concat (lua_State *L, int n) {\n  lua_lock(L);\n  api_checknelems(L, n);\n  if (n >= 2) {\n    luaV_concat(L, n);\n  }\n  else if (n == 0) {  /* push empty string */\n    setsvalue2s(L, L->top, luaS_newlstr(L, \"\", 0));\n    api_incr_top(L);\n  }\n  /* else n == 1; nothing to do */\n  luaC_checkGC(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_len (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_objlen(L, L->top, t);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {\n  lua_Alloc f;\n  lua_lock(L);\n  if (ud) *ud = G(L)->ud;\n  f = G(L)->frealloc;\n  lua_unlock(L);\n  return f;\n}\n\n\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {\n  lua_lock(L);\n  G(L)->ud = ud;\n  G(L)->frealloc = f;\n  lua_unlock(L);\n}\n\n\nLUA_API void *lua_newuserdata (lua_State *L, size_t size) {\n  Udata *u;\n  lua_lock(L);\n  u = luaS_newudata(L, size);\n  setuvalue(L, L->top, u);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getudatamem(u);\n}\n\n\n\nstatic const char *aux_upvalue (StkId fi, int n, TValue **val,\n                                CClosure **owner, UpVal **uv) {\n  switch (ttype(fi)) {\n    case LUA_TCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (!(1 <= n && n <= f->nupvalues)) return NULL;\n      *val = &f->upvalue[n-1];\n      if (owner) *owner = f;\n      return \"\";\n    }\n    case LUA_TLCL: {  /* Lua closure */\n      LClosure *f = clLvalue(fi);\n      TString *name;\n      Proto *p = f->p;\n      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;\n      *val = f->upvals[n-1]->v;\n      if (uv) *uv = f->upvals[n - 1];\n      name = p->upvalues[n-1].name;\n      return (name == NULL) ? \"(*no name)\" : getstr(name);\n    }\n    default: return NULL;  /* not a closure */\n  }\n}\n\n\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  lua_lock(L);\n  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL, NULL);\n  if (name) {\n    setobj2s(L, L->top, val);\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  CClosure *owner = NULL;\n  UpVal *uv = NULL;\n  StkId fi;\n  lua_lock(L);\n  fi = index2addr(L, funcindex);\n  api_checknelems(L, 1);\n  name = aux_upvalue(fi, n, &val, &owner, &uv);\n  if (name) {\n    L->top--;\n    setobj(L, val, L->top);\n    if (owner) { luaC_barrier(L, owner, L->top); }\n    else if (uv) { luaC_upvalbarrier(L, uv); }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  /* get its upvalue pointer */\n}\n\n\nLUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  /* lua closure */\n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}\n\n\nLUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}\n\n\n", "# makefile for building Lua\n# see INSTALL for installation instructions\n# see ../Makefile and luaconf.h for further customization\n\n# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================\n\n# Warnings valid for both C and C++\nCWARNSCPP= \\\n\t-pedantic \\\n\t-Wextra \\\n\t-Wshadow \\\n\t-Wsign-compare \\\n\t-Wundef \\\n\t-Wwrite-strings \\\n\t-Wredundant-decls \\\n\t-Wdisabled-optimization \\\n\t-Waggregate-return \\\n\t-Wdouble-promotion \\\n\t#-Wno-aggressive-loop-optimizations   # not accepted by clang \\\n\t#-Wlogical-op   # not accepted by clang \\\n\t# the next warnings generate too much noise, so they are disabled\n\t# -Wconversion  -Wno-sign-conversion \\\n\t# -Wsign-conversion \\\n\t# -Wconversion \\\n\t# -Wstrict-overflow=2 \\\n\t# -Wformat=2 \\\n\t# -Wcast-qual \\\n\n# The next warnings are neither valid nor needed for C++\nCWARNSC= -Wdeclaration-after-statement \\\n\t-Wmissing-prototypes \\\n\t-Wnested-externs \\\n\t-Wstrict-prototypes \\\n\t-Wc++-compat \\\n\t-Wold-style-definition \\\n\n\nCWARNS= $(CWARNSCPP)  $(CWARNSC)\n\n\n# -DEXTERNMEMCHECK -DHARDSTACKTESTS -DHARDMEMTESTS -DTRACEMEM='\"tempmem\"'\n# -g -DLUA_USER_H='\"ltests.h\"'\n# -pg -malign-double\n# -DLUA_USE_CTYPE -DLUA_USE_APICHECK\n# (in clang, '-ftrapv' for runtime checks of integer overflows)\n# -fsanitize=undefined -ftrapv\nTESTS= -DLUA_USER_H='\"ltests.h\"'\n\n# -mtune=native -fomit-frame-pointer\n# -fno-stack-protector\nLOCAL = $(TESTS) $(CWARNS) -g\n\n\n\n# enable Linux goodies\nMYCFLAGS= $(LOCAL) -std=c99 -DLUA_USE_LINUX -DLUA_COMPAT_5_2\nMYLDFLAGS= $(LOCAL) -Wl,-E\nMYLIBS= -ldl -lreadline\n\n\nCC= clang-3.8\nCFLAGS= -Wall -O2 $(MYCFLAGS)\nAR= ar rcu\nRANLIB= ranlib\nRM= rm -f\n\n\n\n# == END OF USER SETTINGS. NO NEED TO CHANGE ANYTHING BELOW THIS LINE =========\n\n\nLIBS = -lm\n\nCORE_T=\tliblua.a\nCORE_O=\tlapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \\\n\tlmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o \\\n\tltm.o lundump.o lvm.o lzio.o ltests.o\nAUX_O=\tlauxlib.o\nLIB_O=\tlbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o \\\n\tlutf8lib.o lbitlib.o loadlib.o lcorolib.o linit.o\n\nLUA_T=\tlua\nLUA_O=\tlua.o\n\n# LUAC_T=\tluac\n# LUAC_O=\tluac.o print.o\n\nALL_T= $(CORE_T) $(LUA_T) $(LUAC_T)\nALL_O= $(CORE_O) $(LUA_O) $(LUAC_O) $(AUX_O) $(LIB_O)\nALL_A= $(CORE_T)\n\nall:\t$(ALL_T)\n\no:\t$(ALL_O)\n\na:\t$(ALL_A)\n\n$(CORE_T): $(CORE_O) $(AUX_O) $(LIB_O)\n\t$(AR) $@ $?\n\t$(RANLIB) $@\n\n$(LUA_T): $(LUA_O) $(CORE_T)\n\t$(CC) -o $@ $(MYLDFLAGS) $(LUA_O) $(CORE_T) $(LIBS) $(MYLIBS) $(DL)\n\n$(LUAC_T): $(LUAC_O) $(CORE_T)\n\t$(CC) -o $@ $(MYLDFLAGS) $(LUAC_O) $(CORE_T) $(LIBS) $(MYLIBS)\n\nclean:\n\trcsclean -u\n\t$(RM) $(ALL_T) $(ALL_O)\n\ndepend:\n\t@$(CC) $(CFLAGS) -MM *.c\n\necho:\n\t@echo \"CC = $(CC)\"\n\t@echo \"CFLAGS = $(CFLAGS)\"\n\t@echo \"AR = $(AR)\"\n\t@echo \"RANLIB = $(RANLIB)\"\n\t@echo \"RM = $(RM)\"\n\t@echo \"MYCFLAGS = $(MYCFLAGS)\"\n\t@echo \"MYLDFLAGS = $(MYLDFLAGS)\"\n\t@echo \"MYLIBS = $(MYLIBS)\"\n\t@echo \"DL = $(DL)\"\n\n$(ALL_O): makefile\n\n# DO NOT EDIT\n# automatically made with 'gcc -MM l*.c'\n\nlapi.o: lapi.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lstring.h \\\n ltable.h lundump.h lvm.h\nlauxlib.o: lauxlib.c lprefix.h lua.h luaconf.h lauxlib.h\nlbaselib.o: lbaselib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlbitlib.o: lbitlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlcode.o: lcode.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \\\n llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \\\n ldo.h lgc.h lstring.h ltable.h lvm.h\nlcorolib.o: lcorolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlctype.o: lctype.c lprefix.h lctype.h lua.h luaconf.h llimits.h\nldblib.o: ldblib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nldebug.o: ldebug.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lcode.h llex.h lopcodes.h lparser.h \\\n ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h\nldo.o: ldo.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \\\n lparser.h lstring.h ltable.h lundump.h lvm.h\nldump.o: ldump.c lprefix.h lua.h luaconf.h lobject.h llimits.h lstate.h \\\n ltm.h lzio.h lmem.h lundump.h\nlfunc.o: lfunc.c lprefix.h lua.h luaconf.h lfunc.h lobject.h llimits.h \\\n lgc.h lstate.h ltm.h lzio.h lmem.h\nlgc.o: lgc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h\nlinit.o: linit.c lprefix.h lua.h luaconf.h lualib.h lauxlib.h\nliolib.o: liolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nllex.o: llex.c lprefix.h lua.h luaconf.h lctype.h llimits.h ldebug.h \\\n lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lgc.h llex.h lparser.h \\\n lstring.h ltable.h\nlmathlib.o: lmathlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlmem.o: lmem.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h\nloadlib.o: loadlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlobject.o: lobject.c lprefix.h lua.h luaconf.h lctype.h llimits.h \\\n ldebug.h lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h \\\n lvm.h\nlopcodes.o: lopcodes.c lprefix.h lopcodes.h llimits.h lua.h luaconf.h\nloslib.o: loslib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlparser.o: lparser.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \\\n llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \\\n ldo.h lfunc.h lstring.h lgc.h ltable.h\nlstate.o: lstate.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h llex.h \\\n lstring.h ltable.h\nlstring.o: lstring.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \\\n lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h\nlstrlib.o: lstrlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nltable.o: ltable.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h\nltablib.o: ltablib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nltests.o: ltests.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lauxlib.h lcode.h llex.h lopcodes.h \\\n lparser.h lctype.h ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h \\\n lualib.h\nltm.o: ltm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h ltable.h lvm.h\nlua.o: lua.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlundump.o: lundump.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \\\n lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h \\\n lundump.h\nlutf8lib.o: lutf8lib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlvm.o: lvm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h \\\n ltable.h lvm.h\nlzio.o: lzio.c lprefix.h lua.h luaconf.h llimits.h lmem.h lstate.h \\\n lobject.h ltm.h lzio.h\n\n# (end of Makefile)\n"], "fixing_code": ["--[=[\n** lua.stx / llex.c\nTue Dec  2 10:45:48 EDT 1997\n>> BUG: \"lastline\" was not reset on function entry, so debug information\n>> started only in the 2nd line of a function.\n\n\n\n=================================================================\n--- Version 3.1 alpha\n\n** lua.c\nThu Jan 15 14:34:58 EDT 1998\n>> must include \"stdlib.h\" (for \"exit()\").\n\n** lbuiltin.c / lobject.h\nThu Jan 15 14:34:58 EDT 1998\n>> MAX_WORD may be bigger than MAX_INT\n(by lhf)\n\n** llex.c\nMon Jan 19 18:17:18 EDT 1998\n>> wrong line number (+1) in error report when file starts with \"#...\"\n\n** lstrlib.c\nTue Jan 27 15:27:49 EDT 1998\n>> formats like \"%020d\" were considered too big (3 digits); moreover,\n>> some sistems limit printf to at most 500 chars, so we can limit sizes\n>> to 2 digits (99).\n\n** lapi.c\nTue Jan 27 17:12:36 EDT 1998\n>> \"lua_getstring\" may create a new string, so should check GC\n\n** lstring.c / ltable.c\nWed Jan 28 14:48:12 EDT 1998\n>> tables can become full of \"empty\" slots, and keep growing without limits.\n\n** lstrlib.c\nMon Mar  9 15:26:09 EST 1998\n>> gsub('a', '(b?)%1*' ...) loops (because the capture is empty).\n\n** lstrlib.c\nMon May 18 19:20:00 EST 1998\n>> arguments for \"format\" 'x', 'X', 'o' and 'u' must be unsigned int.\n\n\n\n=================================================================\n--- Version 3.1\n\n** liolib.c / lauxlib.c\nMon Sep  7 15:57:02 EST 1998\n>> function \"luaL_argerror\" prints wrong argument number (from a user's point\nof view) when functions have upvalues.\n\n** lstrlib.c\nTue Nov 10 17:29:36 EDT 1998\n>> gsub/strfind do not check whether captures are properly finished.\n(by roberto/tomas)\n\n** lbuiltin.c\nFri Dec 18 11:22:55 EDT 1998\n>> \"tonumber\" goes crazy with negative numbers in other bases (not 10),\nbecause \"strtol\" returns long, not unsigned long.\n(by Visual C++)\n\n** lstrlib.c\nMon Jan  4 10:41:40 EDT 1999\n>> \"format\" does not check size of format item (such as \"%00000...00000d\").\n\n** lapi.c\nWed Feb  3 14:40:21 EDT 1999\n>> getlocal cannot return the local itself, since lua_isstring and\nlua_isnumber can modify it.\n\n** lstrlib.c\nThu Feb  4 17:08:50 EDT 1999\n>> format \"%s\" may break limit of \"sprintf\" on some machines.\n(by Marcelo Sales)\n\n** lzio.c\nThu Mar  4 11:49:37 EST 1999\n>> file stream cannot call fread after EOF.\n(by lhf)\n\n\n\n=================================================================\n--- Version 3.2 (beta)\n\n** lstrlib.c\nFri Apr 30 11:10:20 EST 1999\n>> '$' at end of pattern was matching regular '$', too.\n(by anna; since 2.5)\n\n** lbuiltin.c\nFri May 21 17:15:11 EST 1999\n>> foreach, foreachi, foreachvar points to function in stack when stack\ncan be reallocated.\n(by tomas; since 3.2 beta)\n\n** lparser.c\nWed Jun 16 10:32:46 EST 1999\n>> cannot assign to unlimited variables, because it causes overflow in\nthe number of returns of a function.\n(since 3.1)\n\n\n\n=================================================================\n--- Version 3.2\n\n** lmathlib.c\nWed Aug 18 11:28:38 EST 1999\n>> random(0) and random(x,0) are wrong (0 is read as no argument!).\n(by Dave Bollinger; since 3.1)\n\n** lparser.c\nThu Sep  2 10:07:20 EST 1999\n>> in the (old) expression << ls->fs->f->consts[checkname(ls)] >>, checkname\ncould realloc f->consts.\n(by Supratik Champati; since 3.2 beta)\n\n** lobject.c / lbuiltin.c\nWed Sep  8 17:41:54 EST 1999\n>> tonumber'e1' and tonumber('  ', x), for x!=10, gave 0 instead of nil.\n(since 3.1)\n\n** lstrlib.c\nThu Nov 11 14:36:30 EDT 1999\n>> `strfind' does not handle \\0 in plain search.\n(by Jon Kleiser; since 3.1)\n\n** lparser.c\nWed Dec 29 16:05:43 EDT 1999\n>> return gives wrong line in debug information\n(by lhf; since 3.2 [at least])\n\n** ldo.c\nThu Dec 30 16:39:33 EDT 1999\n>> cannot reopen stdin (for binary mode)\n(by lhf & roberto; since 3.1)\n\n** lapi.c\nThu Mar  2 09:41:53 EST 2000\n>> lua_settable should check stack space (it could call a T.M.)\n(by lhf & celes; since 3.2; it was already fixed by fixed stack)\n\n** lparser.c\nMon Apr  3 09:59:06 EST 2000\n>> '%' should be in expfollow\n(by Edgar Toernig; since 3.1; it was already fixed)\n\n** lbuiltin.c\nMon Apr  3 10:05:05 EST 2000\n>> tostring() without arguments gives seg. fault.\n(by Edgar Toernig; since 3.0)\n\n\n\n=================================================================\n--- Version 4.0 alpha\n\nTested with full test suites (as locked in Mon Apr 24 14:23:11 EST 2000)\nin the following platforms:\n* Linux   - gcc, g++\n* AIX     - gcc\n* Solaris - gcc, cc\n* IRIX\t  - cc, cc-purify\n* Windows - Visual C++ (.c e .cpp, warning level=4)\n\n\n** lstrlib.c\nTue May  2 15:27:58 EST 2000\n>> `strfind' gets wrong subject length when there is an offset\n(by Jon Kleiser; since 4.0a)\n\n** lparser.c\nFri May 12 15:11:12 EST 2000\n>> first element in a list constructor is not adjusted to one value\n>> (e.g. \u00aba = {gsub('a','a','')}\u00bb)\n(by Tomas; since 4.0a)\n\n** lparser.c\nWed May 24 14:50:16 EST 2000\n>> record-constructor starting with an upvalue name gets an error\n>> (e.g. \u00ablocal a; function f() x = {a=1} end\u00bb)\n(by Edgar Toernig; since 3.1)\n\n** lparser.c\nTue Aug 29 15:56:05 EST 2000\n>> error message for `for' uses `while'\n(since 4.0a; already corrected)\n\n** lgc.c\nTue Aug 29 15:57:41 EST 2000\n>> gc tag method for nil could call line hook\n(by ry; since ?)\n\n\n\n=================================================================\n--- Version 4.0 Beta\n\n** liolib.c\nFri Sep 22 15:12:37 EST 2000\n>> `read(\"*w\")' should return nil at EOF\n(by roberto; since 4.0b)\n\n** lvm.c\nMon Sep 25 11:47:48 EST 2000\n>> lua_gettable does not get key from stack top\n(by Philip Yi; since 4.0b)\n\n** lgc.c\nMon Sep 25 11:50:48 EST 2000\n>> GC may crash when checking locked C closures\n(by Philip Yi; since 4.0b)\n\n** lapi.c\nWed Sep 27 09:50:19 EST 2000\n>> lua_tag should return LUA_NOTAG for non-valid indices\n(by Paul Hankin; since 4.0b)\n\n** llex.h / llex.c / lparser.c\nWed Sep 27 13:39:45 EST 2000\n>> parser overwrites semantic information when looking ahead\n>> (e.g. \u00aba = {print'foo'}\u00bb)\n(by Edgar Toernig; since 4.0b, deriving from previous bug)\n\n** liolib.c\nThu Oct 26 10:50:46 EDT 2000\n>> in function `read_file', realloc() doesn't free the buffer if it can't\n>> allocate new memory\n(by Mauro Vezzosi; since 4.0b)\n\n\n\n=================================================================\n--- Version 4.0\n\n** lparser.c\nWed Nov 29 09:51:44 EDT 2000\n>> parser does not accept a `;' after a `return'\n(by lhf; since 4.0b)\n\n** liolib.c\nFri Dec 22 15:30:42 EDT 2000\n>> when `read' fails it must return nil (and not no value)\n(by cassino; since at least 3.1)\n\n** lstring.c/lapi.c\nThu Feb  1 11:55:45 EDT 2001\n>> lua_pushuserdata(L, NULL) is buggy\n(by Edgar Toernig; since 4.0)\n\n** ldo.c\nFri Feb  2 14:06:40 EDT 2001\n>> \u00abwhile 1 dostring[[print('hello\\n')]] end\u00bb never reclaims memory\n(by Andrew Paton; since 4.0b)\n\n** lbaselib.c\nTue Feb  6 11:57:13 EDT 2001\n>> ESC (which starts precompiled code) in C is \\33, not \\27\n(by Edgar Toernig and lhf; since 4.0b)\n\n** lparser.c\nTue Jul 10 16:59:18 EST 2001\n>> error message for `%a' gave wrong line number\n(by Leonardo Constantino; since 4.0)\n\n** lbaselib.c\nFri Dec 21 15:21:05 EDT 2001\n>> seg. fault when rawget/rawset get extra arguments\n(by Eric Mauger; since 4.0b)\n\n** lvm.c\nWed Jun 19 13:28:20 EST 2002\n>> line hook gets wrong `ar'\n(by Daniel C. Sinclair; since 4.0.b)\n\n** ldo.c\nWed Jun 19 13:31:49 EST 2002\n>> `protectedparser' may run GC, and then collect `filename'\n>> (in function `parse_file')\n(by Alex Bilyk; since 4.0)\n\n\n\n\n=================================================================\n--- Version 5.0 alpha\n\n** lgc.c\nFri Aug 30 13:49:14 EST 2002\n>> GC metamethod stored in a weak metatable being collected together with\n>> userdata may not be cleared properly\n(by Roberto; since 5.0a)\n\n** lapi.c\nThu Nov 21 11:00:00 EST 2002\n>> ULONG_MAX>>10 may not fit into an int\n(by Jeff Petkau; since 4.0)\n\n** lparser.c\nFri Dec  6 17:06:40 UTC 2002\n>> scope of generic for variables is not sound\n(by Gavin Wraith; since 5.0a)\n\n\n\n\n=================================================================\n--- Version 5.0 beta\n** lbaselib.c\nFri Dec 20 09:53:19 UTC 2002\n>> `resume' was checking the wrong value for stack overflow\n(by Maik Zimmermann; since 5.0b)\n\n** ldo.c\nThu Jan 23 11:29:06 UTC 2003\n>> error during garbage collection in luaD_protectedparser is not being\n>> protected\n(by Benoit Germain; since 5.0a)\n\n** ldo.c (and others)\nFri Feb 28 14:20:33 EST 2003\n>> GC metamethod calls could mess C/Lua stack syncronization\n(by Roberto; since 5.0b)\n\n** lzio.h/zlio.c\nThu Mar 20 11:40:12 EST 2003\n>> zio mixes a 255 as first char in a buffer with EOZ\n(by lhf; since 5.0a)\n\n\n\n--]=]\n-----------------------------------------------------------------\n-- Lua 5.0 (final)\n\nBug{\nwhat = [[lua_closethread exists only in the manual]],\nreport = [[by Nguyen Binh, 28/04/2003]],\npatch = [[no patch; the manual is wrong]],\n}\n\n\nBug{\nwhat = [[attempt to resume a running coroutine crashes Lua]],\nexample = [[\nfunction co_func (current_co)\n   coroutine.resume(co)\nend\nco = coroutine.create(co_func)\ncoroutine.resume(co)\ncoroutine.resume(co)     --> seg. fault\n]],\nreport = [[by Alex Bilyk, 09/05/2003]],\npatch = [[\n* ldo.c:\n325,326c325\n<     if (nargs >= L->top - L->base)\n<       luaG_runerror(L, \"cannot resume dead coroutine\");\n---\n>     lua_assert(nargs < L->top - L->base);\n329c328,329\n<   else if (ci->state & CI_YIELD) {  /* inside a yield? */\n---\n>   else {  /* inside a yield */\n>     lua_assert(ci->state & CI_YIELD);\n344,345d343\n<   else\n<     luaG_runerror(L, \"cannot resume non-suspended coroutine\");\n351a350,358\n> static int resume_error (lua_State *L, const char *msg) {\n>   L->top = L->ci->base;\n>   setsvalue2s(L->top, luaS_new(L, msg));\n>   incr_top(L);\n>   lua_unlock(L);\n>   return LUA_ERRRUN;\n> }\n> \n> \n355a363,368\n>   if (L->ci == L->base_ci) {\n>     if (nargs >= L->top - L->base)\n>       return resume_error(L, \"cannot resume dead coroutine\");\n>   }\n>   else if (!(L->ci->state & CI_YIELD))  /* not inside a yield? */\n>     return resume_error(L, \"cannot resume non-suspended coroutine\");\n]],\n}\n\n\nBug{\nwhat = [[file:close cannot be called without a file. (results in seg fault)]],\nexample = [[\n> io.stdin.close()    -- correct call shold be io.stdin:close()\n]],\nreport = [[by Tuomo Valkonen, 27/05/2003]],\npatch = [[\n* liolib.c:\n161c161\n<   if (lua_isnone(L, 1)) {\n---\n>   if (lua_isnone(L, 1) && lua_type(L, lua_upvalueindex(1)) == LUA_TTABLE) {\n]],   --}}\n}\n\n\nBug{\nwhat = [[C functions also may have stacks larger than current top]],\nexample = [[\nMust recompile lua with a change in lua.c and with lua_assert defined:\n* lua.c:\n381a382\n>   lua_checkstack(l, 1000);\n]],\nreport = [[Alex Bilyk, 09/06/2003]],\npatch = [[\n* lgc.c:\n247c247\n<     if (!(ci->state & CI_C) && lim < ci->top)\n---\n>     if (lim < ci->top)\n]],\n}\n\n\nBug{\nwhat = [[`pc' address is invalidated when a coroutine is suspended]],\nexample = [[\nfunction g(x)\n    coroutine.yield(x)\nend\n\nfunction f (i)\n  debug.sethook(print, \"l\")\n  for j=1,1000 do\n    g(i+j)\n  end\nend\n\nco = coroutine.wrap(f)\nco(10)\npcall(co)\npcall(co)\n]],\nreport = [[Nick Trout, 07/07/2003]],\npatch = [[\n* lvm.c:\n402,403c402,403\n<   L->ci->u.l.pc = &pc;\n<   if (L->hookmask & LUA_MASKCALL)\n---\n>   if (L->hookmask & LUA_MASKCALL) {\n>     L->ci->u.l.pc = &pc;\n404a405\n>   }\n405a407\n>   L->ci->u.l.pc = &pc;\n676,678c678\n<           lua_assert(ci->u.l.pc == &pc &&\n<                      ttisfunction(ci->base - 1) &&\n<                      (ci->state & CI_SAVEDPC));\n---\n>           lua_assert(ttisfunction(ci->base - 1) && (ci->state & CI_SAVEDPC));\n]]\n}\n\n\nBug{\nwhat = [[userdata to be collected still counts into new GC threshold,\nincreasing memory consumption]],\nreport = [[Roberto, 25/07/2003]],\nexample = [[\na = newproxy(true)\ngetmetatable(a).__gc = function () end\nfor i=1,10000000 do\n  newproxy(a)\n  if math.mod(i, 10000) == 0 then print(gcinfo()) end\nend\n]],\npatch = [[\n* lgc.h:\n18c18\n< void luaC_separateudata (lua_State *L);\n---\n> size_t luaC_separateudata (lua_State *L);\n\n* lgc.c:\n113c113,114\n< void luaC_separateudata (lua_State *L) {\n---\n> size_t luaC_separateudata (lua_State *L) {\n>   size_t deadmem = 0;\n127a129\n>       deadmem += sizeudata(gcotou(curr)->uv.len);\n136a139\n>   return deadmem;\n390c393\n< static void checkSizes (lua_State *L) {\n---\n> static void checkSizes (lua_State *L, size_t deadmem) {\n400c403\n<   G(L)->GCthreshold = 2*G(L)->nblocks;  /* new threshold */\n---\n>   G(L)->GCthreshold = 2*G(L)->nblocks - deadmem;  /* new threshold */\n454c457,458\n< static void mark (lua_State *L) {\n---\n> static size_t mark (lua_State *L) {\n>   size_t deadmem;\n467c471\n<   luaC_separateudata(L);  /* separate userdata to be preserved */\n---\n>   deadmem = luaC_separateudata(L);  /* separate userdata to be preserved */\n475a480\n>   return deadmem;\n480c485\n<   mark(L);\n---\n>   size_t deadmem = mark(L);\n482c487\n<   checkSizes(L);\n---\n>   checkSizes(L, deadmem);\n]]\n}\n\nBug{\nwhat=[[IBM AS400 (OS400) has sizeof(void *)==16, and a `%p' may generate\nup to 60 characters in a `printf'. That causes a buffer overflow in\n`tostring'.]],\n\nreport = [[David Burgess, 25/08/2003]],\n\nexample = [[print{}; (in an AS400 machine)]],\n\npatch = [[\n* liolib.c:\n178c178\n<   char buff[32];\n---\n>   char buff[128];\n\n* lbaselib.c:\n327c327\n<   char buff[64];\n---\n>   char buff[128];\n]]\n}\n\n\nBug{\nwhat = [[syntax `local function' does not increment stack size]],\n\nreport = [[Rici Lake, 26/09/2003]],\n\nexample = [[\n-- must run this with precompiled code\nlocal a,b,c\nlocal function d () end\n]],\n\npatch = [[\n* lparser.c:\n1143a1144\n>   FuncState *fs = ls->fs;\n1145c1146,1147\n<   init_exp(&v, VLOCAL, ls->fs->freereg++);\n---\n>   init_exp(&v, VLOCAL, fs->freereg);\n>   luaK_reserveregs(fs, 1);\n1148c1150,1152\n<   luaK_storevar(ls->fs, &v, &b);\n---\n>   luaK_storevar(fs, &v, &b);\n>   /* debug information will only see the variable after this point! */\n>   getlocvar(fs, fs->nactvar - 1).startpc = fs->pc;\n]],\n\n}\n\n\nBug{\n\nwhat = [[count hook may be called without being set]],\n\nreport = [[Andreas Stenius, 06/10/2003]],\n\nexample = [[\nset your hooks with\n\n  lua_sethook(L, my_hook, LUA_MASKLINE | LUA_MASKRET, 1);\n\n(It is weird to use a count > 0 without setting the count hook,\nbut it is not wrong.)\n]],\n\npatch = [[\n* lvm.c:\n69c69\n<   if (mask > LUA_MASKLINE) {  /* instruction-hook set? */\n---\n>   if (mask & LUA_MASKCOUNT) {  /* instruction-hook set? */\n]],\n\n}\n\n\nBug{\n\nwhat = [[`dofile' eats one return value when called without arguments]],\n\nreport = [[Frederico Abraham, 15/01/2004]],\n\nexample = [[\na,b = dofile()   --< here you enter `return 1,2,3 <eof>'\nprint(a,b)   --> 2   3   (should be 1 and 2)\n]],\n\npatch = [[\n* lbaselib.c:\n313a314\n>   int n = lua_gettop(L);\n317c318\n<   return lua_gettop(L) - 1;\n---\n>   return lua_gettop(L) - n;\n]],\n\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.0.2\n\nBug{\nwhat = [[string concatenation may cause arithmetic overflow, leading\nto a buffer overflow]],\n\nreport = [[Rici Lake, 20/05/2004]],\n\nexample = [[\nlongs = string.rep(\"\\0\", 2^25)\nfunction catter(i)\n    return assert(loadstring(\n      string.format(\"return function(a) return a%s end\",\n                     string.rep(\"..a\", i-1))))()\nend\nrep129 = catter(129)\nrep129(longs)\n]],\n\npatch = [[\n* lvm.c:\n@@ -321,15 +321,15 @@\n         luaG_concaterror(L, top-2, top-1);\n     } else if (tsvalue(top-1)->tsv.len > 0) {  /* if len=0, do nothing */\n       /* at least two string values; get as many as possible */\n-      lu_mem tl = cast(lu_mem, tsvalue(top-1)->tsv.len) +\n-                  cast(lu_mem, tsvalue(top-2)->tsv.len);\n+      size_t tl = tsvalue(top-1)->tsv.len;\n       char *buffer;\n       int i;\n-      while (n < total && tostring(L, top-n-1)) {  /* collect total length */\n-        tl += tsvalue(top-n-1)->tsv.len;\n-        n++;\n+      /* collect total length */\n+      for (n = 1; n < total && tostring(L, top-n-1); n++) {\n+        size_t l = tsvalue(top-n-1)->tsv.len;\n+        if (l >= MAX_SIZET - tl) luaG_runerror(L, \"string length overflow\");\n+        tl += l;\n       }\n-      if (tl > MAX_SIZET) luaG_runerror(L, \"string size overflow\");\n       buffer = luaZ_openspace(L, &G(L)->buff, tl);\n       tl = 0;\n       for (i=n; i>0; i--) {  /* concat all strings */\n]]\n}\n\n\nBug{\nwhat = [[lua_getupvalue and setupvalue do not check for index too small]],\n\nreport = [[Mike Pall, ?/2004]],\n\nexample = [[debug.getupvalue(function() end, 0)]],\n\npatch = [[\n* lapi.c\n941c941\n<     if (n > f->c.nupvalues) return NULL;\n---\n>     if (!(1 <= n && n <= f->c.nupvalues)) return NULL;\n947c947\n<     if (n > p->sizeupvalues) return NULL;\n---\n>     if (!(1 <= n && n <= p->sizeupvalues)) return NULL;\n]]\n}\n\n\nBug{\nwhat = [[values holded in open upvalues of suspended threads may be\nincorrectly collected]],\n\nreport = [[Spencer Schumann, 31/12/2004]],\n\nexample = [[\nlocal thread_id = 0\nlocal threads = {}\n\nfunction fn(thread)\n    thread_id = thread_id + 1\n    threads[thread_id] = function()\n                             thread = nil\n                         end\n    coroutine.yield()\nend\n\nwhile true do\n    local thread = coroutine.create(fn)\n    coroutine.resume(thread, thread)\nend\n]],\n\npatch = [[\n* lgc.c:\n221,224c221,222\n<       if (!u->marked) {\n<         markobject(st, &u->value);\n<         u->marked = 1;\n<       }\n---\n>       markobject(st, u->v);\n>       u->marked = 1;\n]],\n}\n\n\nBug{\nwhat = [[rawset/rawget do not ignore extra arguments]],\n\nreport = [[Romulo Bahiense, 11/03/2005]],\n\nexample = [[\na = {}\nrawset(a, 1, 2, 3)\nprint(a[1], a[2])    -- should be 2 and nil\n]],\n\npatch = [[\n* lbaselib.c:\n175a176\n>   lua_settop(L, 2);\n183a185\n>   lua_settop(L, 3);\n]],\n}\n\n\nBug{\nwhat = [[weak tables that survive one collection are never collected]],\n\nreport = [[Chromix, 02/01/2006]],\n\nexample = [[\na = {}\nprint(gcinfo())\nfor i = 1, 10000 do\n  a[i] = setmetatable({}, {__mode = \"v\"})\nend\ncollectgarbage()\na = nil\ncollectgarbage()\nprint(gcinfo())\n]],\n\npatch = [[\n* lgc.c\n@@ -366,7 +366,7 @@\n   GCObject *curr;\n   int count = 0;  /* number of collected items */\n   while ((curr = *p) != NULL) {\n-    if (curr->gch.marked > limit) {\n+    if ((curr->gch.marked & ~(KEYWEAK | VALUEWEAK)) > limit) {\n       unmark(curr);\n       p = &curr->gch.next;\n     }\n]],\n\n}\n\n\nBug{\nwhat = [[Some \"not not exp\" may not result in boolean values]],\nreport = [[]],\nsince = [[4.0]],\nexample = [[\n-- should print false, but prints nil\nprint(not not (nil and 4))\n]],\npatch = [[]],\n}\n\n\nBug{\nwhat = [[On some machines, closing a \"piped file\" (created with io.popen)\nmay crash Lua]],\nreport = [[]],\nsince = [[5.0]],\nexample = [[\n-- only on some machines\n  f = io.popen(\"ls\")\n  f:close()\n]],\npatch = [[]],\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1\n\nBug{\nwhat = [[In 16-bit machines, expressions and/or with numeric constants as the\nright operand may result in weird values]],\n\nreport = [[Andreas Stenius/Kein-Hong Man, 15/03/2006]],\n\nexample = [[\nprint(false or 0)   -- on 16-bit machines\n]],\n\npatch = [[\n* lcode.c:\n@@ -731,17 +731,15 @@\n     case OPR_AND: {\n       lua_assert(e1->t == NO_JUMP);  /* list must be closed */\n       luaK_dischargevars(fs, e2);\n-      luaK_concat(fs, &e1->f, e2->f);\n-      e1->k = e2->k; e1->u.s.info = e2->u.s.info;\n-      e1->u.s.aux = e2->u.s.aux; e1->t = e2->t;\n+      luaK_concat(fs, &e2->f, e1->f);\n+      *e1 = *e2;\n       break;\n     }\n     case OPR_OR: {\n       lua_assert(e1->f == NO_JUMP);  /* list must be closed */\n       luaK_dischargevars(fs, e2);\n-      luaK_concat(fs, &e1->t, e2->t);\n-      e1->k = e2->k; e1->u.s.info = e2->u.s.info;\n-      e1->u.s.aux = e2->u.s.aux; e1->f = e2->f;\n+      luaK_concat(fs, &e2->t, e1->t);\n+      *e1 = *e2;\n       break;\n     }\n]],\n\n}\n\n\nBug{\nwhat = [[luaL_checkudata may produce wrong error message]],\n\nreport = [[Greg Falcon, 21/03/2006]],\n\nexample = [[\ngetmetatable(io.stdin).__gc()\n  --> bad argument #1 to '__gc' (FILE* expected, got table)\n]],\n\npatch = [[\n* lauxlib.c:\n@@ -123,11 +123,17 @@\n\n LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {\n   void *p = lua_touserdata(L, ud);\n-  lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */\n-  if (p == NULL || !lua_getmetatable(L, ud) || !lua_rawequal(L, -1, -2))\n-    luaL_typerror(L, ud, tname);\n-  lua_pop(L, 2);  /* remove both metatables */\n-  return p;\n+  if (p != NULL) {  /* value is a userdata? */\n+    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n+      lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */\n+      if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */\n+        lua_pop(L, 2);  /* remove both metatables */\n+        return p;\n+      }\n+    }\n+  }\n+  luaL_typerror(L, ud, tname);  /* else error */\n+  return NULL;  /* to avoid warnings */\n }\n]]\n\n}\n\n\nBug{\nwhat = [[\nIn Windows,\nwhen Lua is used in an application that also uses DirectX,\nit may present an erractic behavior.\nTHIS IS NOT A LUA BUG!\nThe problem is that DirectX violates an ABI that Lua depends on.]],\n\npatch = [[\nThe simplest solution is to use DirectX with\nthe D3DCREATE_FPU_PRESERVE flag.\n\nOtherwise, you can change the definition of lua_number2int,\nin luaconf.h, to this one:\n#define lua_number2int(i,d)   __asm fld d   __asm fistp i\n]],\n\n}\n\n\nBug{\nwhat = [[option '%q' in string.format does not handle '\\r' correctly.]],\n\nexample = [[\nlocal s = \"a string with \\r and \\n and \\r\\n and \\n\\r\"\nlocal c = string.format(\"return %q\", s)\nassert(assert(loadstring(c))() == s)\n]],\n\npatch = [[\n* lstrlib.c:\n@@ -703,6 +703,10 @@\n         luaL_addchar(b, *s);\n         break;\n       }\n+      case '\\r': {\n+        luaL_addlstring(b, \"\\\\r\", 2);\n+        break;\n+      }\n       case '\\0': {\n         luaL_addlstring(b, \"\\\\000\", 4);\n         break;\n]],\n\n}\n\n\nBug{\nwhat = [[lua_dostring/lua_dofile should return any values returned\nby the chunk]],\n\npatch = [[\n* lauxlib.h:\n@@ -108,9 +108,11 @@\n\n #define luaL_typename(L,i)     lua_typename(L, lua_type(L,(i)))\n\n-#define luaL_dofile(L, fn)     (luaL_loadfile(L, fn) || lua_pcall(L, 0, 0, 0))\n+#define luaL_dofile(L, fn) \\\n+       (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n-#define luaL_dostring(L, s)    (luaL_loadstring(L, s) || lua_pcall(L, 0, 0, 0))+#define luaL_dostring(L, s) \\\n+       (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))\n]],\n\n}\n\n\nBug{\n\nwhat = [[garbage collector does not compensate enough for finalizers]],\n\npatch = [[\nlgc.c:\n@@ -322,4 +322,6 @@\n\n-static void propagateall (global_State *g) {\n-  while (g->gray) propagatemark(g);\n+static size_t propagateall (global_State *g) {\n+  size_t m = 0;\n+  while (g->gray) m += propagatemark(g);\n+  return m;\n }\n@@ -542,3 +544,3 @@\n   marktmu(g);  /* mark `preserved' userdata */\n-  propagateall(g);  /* remark, to propagate `preserveness' */\n+  udsize += propagateall(g);  /* remark, to propagate `preserveness' */\n   cleartable(g->weak);  /* remove collected objects from weak tables */\n@@ -592,2 +594,4 @@\n         GCTM(L);\n+        if (g->estimate > GCFINALIZECOST)\n+          g->estimate -= GCFINALIZECOST;\n]]\n}\n\n\nBug{\n\nwhat = [[debug hooks may get wrong when mixed with coroutines]],\n\nreport = [[by Ivko Stanilov, 03/06/2006]],\n\nexample = [[\nco = coroutine.create(function (a,b)\n   coroutine.yield(a, b)\n   return b, \"end\"\nend)\n\ndebug.sethook(co, function() end, \"lcr\")\ncoroutine.resume(co, 100, 2000)\ncoroutine.resume(co, 100, 2000)\n]],\n\npatch = [[\n* ldo.c:\n@@ -389,6 +389,7 @@\n       return;\n   }\n   else {  /* resuming from previous yield */\n+    L->status = 0;\n     if (!f_isLua(ci)) {  /* `common' yield? */\n       /* finish interrupted execution of `OP_CALL' */\n       lua_assert(GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_CALL ||\n@@ -399,7 +400,6 @@\n     else  /* yielded inside a hook: just continue its execution */\n       L->base = L->ci->base;\n   }\n-  L->status = 0;\n   luaV_execute(L, cast_int(L->ci - L->base_ci));\n }\n]],\n\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.1\n\nBug{\nwhat = [[list constructors have wrong limit]],\n\nreport = [[by Norman Ramsey, June 2006]],\n\nsince = \"5.1\",\n\nexample = [[\na = {}\na[1] = \"x={1\"\nfor i = 2, 2^20 do\n  a[i] = 1\nend\na[#a + 1] = \"}\"\ns = table.concat(a, \",\")\nassert(loadstring(s))()\nprint(#x)\n]],\n\npatch = [[\n* lparser.c:\n@@ -489,7 +489,7 @@\n\n static void listfield (LexState *ls, struct ConsControl *cc) {\n   expr(ls, &cc->v);\n-  luaY_checklimit(ls->fs, cc->na, MAXARG_Bx, \"items in a constructor\");\n+  luaY_checklimit(ls->fs, cc->na, MAX_INT, \"items in a constructor\");\n   cc->na++;\n   cc->tostore++;\n }\n]],\n\n}\n\n\nBug{\nwhat = [[wrong message error in some cases involving closures]],\n\nreport = [[Shmuel Zeigerman, on 07/2006]],\n\nsince = \"5.1\",\n\nexample = [[\nlocal Var\nlocal function main()\n  NoSuchName (function() Var=0 end)\nend\nmain()\n--> lua5.1: temp:3: attempt to call upvalue 'Var' (a nil value)\n]],\n\npatch = [[\n*ldebug.c:\n@@ -435,14 +435,16 @@\n         break;\n       }\n       case OP_CLOSURE: {\n-        int nup;\n+        int nup, j;\n         check(b < pt->sizep);\n         nup = pt->p[b]->nups;\n         check(pc + nup < pt->sizecode);\n-        for (; nup>0; nup--) {\n-          OpCode op1 = GET_OPCODE(pt->code[pc+nup]);\n+        for (j = 1; j <= nup; j++) {\n+          OpCode op1 = GET_OPCODE(pt->code[pc + j]);\n           check(op1 == OP_GETUPVAL || op1 == OP_MOVE);\n         }\n+        if (reg != NO_REG)  /* tracing? */\n+          pc += nup;  /* do not 'execute' these pseudo-instructions */\n         break;\n       }\n       case OP_VARARG: {\n]],\n\n}\n\n\nBug{\nwhat = [[string.format(\"%\") may read past the string]],\nreport = [[Roberto, on 09/2006]],\nsince = [[5.0]],\nexample = [[print(string.format(\"%\"))]],\npatch = [[\n*lstrlib.c:\n@@ -723,7 +723,7 @@\n\n static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {   const char *p = strfrmt;\n-  while (strchr(FLAGS, *p)) p++;  /* skip flags */\n+  while (*p != '\\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */\n   if ((size_t)(p - strfrmt) >= sizeof(FLAGS))\n     luaL_error(L, \"invalid format (repeated flags)\");\n   if (isdigit(uchar(*p))) p++;  /* skip width */\n]],\n}\n\n\nBug{\nwhat = [[os.date throws an error when result is the empty string]],\nreport = [[]],\nsince = [[4.0]],\nexample = [[print(os.date(\"\"))]],\npatch = [[\n*loslib.c:\n@@ -148,7 +148,18 @@\n   else {\n-    char b[256];\n-    if (strftime(b, sizeof(b), s, stm))\n-      lua_pushstring(L, b);\n-    else\n-      return luaL_error(L, LUA_QL(\"date\") \" format too long\");\n+    char cc[3];\n+    luaL_Buffer b;\n+    cc[0] = '%'; cc[2] = '\\0';\n+    luaL_buffinit(L, &b);\n+    for (; *s; s++) {\n+      if (*s != '%' || *(s + 1) == '\\0')  /* no conversion specifier? */\n+        luaL_addchar(&b, *s);\n+      else {\n+        size_t reslen;\n+        char buff[200];  /* should be big enough for any conversion result */\n+        cc[1] = *(++s);\n+        reslen = strftime(buff, sizeof(buff), cc, stm);\n+        luaL_addlstring(&b, buff, reslen);\n+      }\n+    }\n+    luaL_pushresult(&b);\n   }\n]],\n}\n\n\nBug{\nwhat = [[setfenv accepts invalid 1st argument]],\nreport = [[Doug Rogers, on 02/2007]],\nsince = [[5.0]],\nexample = [[setfenv(nil, {})   -- should throw an error]],\npatch = [[\n*lbaselib.c:\n@@ -116,3 +116,3 @@\n\n-static void getfunc (lua_State *L) {\n+static void getfunc (lua_State *L, int opt) {\n   if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);\n@@ -120,3 +120,3 @@\n     lua_Debug ar;\n-    int level = luaL_optint(L, 1, 1);\n+    int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);\n     luaL_argcheck(L, level >= 0, 1, \"level must be non-negative\");\n@@ -133,3 +133,3 @@\n static int luaB_getfenv (lua_State *L) {\n-  getfunc(L);\n+  getfunc(L, 1);\n   if (lua_iscfunction(L, -1))  /* is a C function? */\n@@ -144,3 +144,3 @@\n   luaL_checktype(L, 2, LUA_TTABLE);\n-  getfunc(L);\n+  getfunc(L, 0);\n   lua_pushvalue(L, 2);\n]],\n}\n\n\nBug{\nwhat = [[wrong code for arithmetic expressions in some specific scenarios]],\nreport = [[Thierry Grellier, on 01/2007]],\nsince = [[5.1]],\nexample = [[\n-- use a large number of names (almost 256)\nv1=1; v2=1; v3=1; v4=1; v5=1; v6=1; v7=1; v8=1; v9=1;\nv10=1; v11=1; v12=1; v13=1; v14=1; v15=1; v16=1; v17=1;\nv18=1; v19=1; v20=1; v21=1; v22=1; v23=1; v24=1; v25=1;\nv26=1; v27=1; v28=1; v29=1; v30=1; v31=1; v32=1; v33=1;\nv34=1; v35=1; v36=1; v37=1; v38=1; v39=1; v40=1; v41=1;\nv42=1; v43=1; v44=1; v45=1; v46=1; v47=1; v48=1; v49=1;\nv50=1; v51=1; v52=1; v53=1; v54=1; v55=1; v56=1; v57=1;\nv58=1; v59=1; v60=1; v61=1; v62=1; v63=1; v64=1; v65=1;\nv66=1; v67=1; v68=1; v69=1; v70=1; v71=1; v72=1; v73=1;\nv74=1; v75=1; v76=1; v77=1; v78=1; v79=1; v80=1; v81=1;\nv82=1; v83=1; v84=1; v85=1; v86=1; v87=1; v88=1; v89=1;\nv90=1; v91=1; v92=1; v93=1; v94=1; v95=1; v96=1; v97=1;\nv98=1; v99=1; v100=1; v101=1; v102=1; v103=1; v104=1; v105=1;\nv106=1; v107=1; v108=1; v109=1; v110=1; v111=1; v112=1; v113=1;\nv114=1; v115=1; v116=1; v117=1; v118=1; v119=1; v120=1; v121=1;\nv122=1; v123=1; v124=1; v125=1; v126=1; v127=1; v128=1; v129=1;\nv130=1; v131=1; v132=1; v133=1; v134=1; v135=1; v136=1; v137=1;\nv138=1; v139=1; v140=1; v141=1; v142=1; v143=1; v144=1; v145=1;\nv146=1; v147=1; v148=1; v149=1; v150=1; v151=1; v152=1; v153=1;\nv154=1; v155=1; v156=1; v157=1; v158=1; v159=1; v160=1; v161=1;\nv162=1; v163=1; v164=1; v165=1; v166=1; v167=1; v168=1; v169=1;\nv170=1; v171=1; v172=1; v173=1; v174=1; v175=1; v176=1; v177=1;\nv178=1; v179=1; v180=1; v181=1; v182=1; v183=1; v184=1; v185=1;\nv186=1; v187=1; v188=1; v189=1; v190=1; v191=1; v192=1; v193=1;\nv194=1; v195=1; v196=1; v197=1; v198=1; v199=1; v200=1; v201=1;\nv202=1; v203=1; v204=1; v205=1; v206=1; v207=1; v208=1; v209=1;\nv210=1; v211=1; v212=1; v213=1; v214=1; v215=1; v216=1; v217=1;\nv218=1; v219=1; v220=1; v221=1; v222=1; v223=1; v224=1; v225=1;\nv226=1; v227=1; v228=1; v229=1; v230=1; v231=1; v232=1; v233=1;\nv234=1; v235=1; v236=1; v237=1; v238=1; v239=1; v240=1; v241=1;\nv242=1; v243=1; v244=1; v245=1; v246=1; v247=1; v248=1; v249=1;\nv250=1;\nv251={k1 = 1};\nv252=1;\nprint(2 * v251.k1, v251.k1 * 2);   -- 2 2, OK\nv253=1;\nprint(2 * v251.k1, v251.k1 * 2);   -- 1 2, ???\n]],\npatch = [[\n*lcode.c:\n@@ -657,10 +657,16 @@\n   if (constfolding(op, e1, e2))\n     return;\n   else {\n-    int o1 = luaK_exp2RK(fs, e1);\n     int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;\n-    freeexp(fs, e2);\n-    freeexp(fs, e1);\n+    int o1 = luaK_exp2RK(fs, e1);\n+    if (o1 > o2) {\n+      freeexp(fs, e1);\n+      freeexp(fs, e2);\n+    }\n+    else {\n+      freeexp(fs, e2);\n+      freeexp(fs, e1);\n+    }\n     e1->u.s.info = luaK_codeABC(fs, op, 0, o1, o2);\n     e1->k = VRELOCABLE;\n   }\n@@ -718,10 +724,15 @@\n       luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */\n       break;\n     }\n-    default: {\n+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:\n+    case OPR_MOD: case OPR_POW: {\n       if (!isnumeral(v)) luaK_exp2RK(fs, v);\n       break;\n     }\n+    default: {\n+      luaK_exp2RK(fs, v);\n+      break;\n+    }\n   }\n }\n]],\n}\n\nBug{\nwhat = [[assignment of nil to parameter may be optimized away]],\nreport = [[Thomas Lauer, on 03/2007]],\nsince = [[5.1]],\nexample = [[\nfunction f (a)\n  a=nil\n  return a\nend\n\nprint(f(\"test\"))\n]],\npatch = [[\n*lcode.c:\n@@ -35,16 +35,20 @@\n void luaK_nil (FuncState *fs, int from, int n) {\n   Instruction *previous;\n   if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */\n-    if (fs->pc == 0)  /* function start? */\n-      return;  /* positions are already clean */\n-    previous = &fs->f->code[fs->pc-1];\n-    if (GET_OPCODE(*previous) == OP_LOADNIL) {\n-      int pfrom = GETARG_A(*previous);\n-      int pto = GETARG_B(*previous);\n-      if (pfrom <= from && from <= pto+1) {  /* can connect both? */\n-        if (from+n-1 > pto)\n-          SETARG_B(*previous, from+n-1);\n-        return;\n+    if (fs->pc == 0) {  /* function start? */\n+      if (from >= fs->nactvar)\n+        return;  /* positions are already clean */\n+    }\n+    else {\n+      previous = &fs->f->code[fs->pc-1];\n+      if (GET_OPCODE(*previous) == OP_LOADNIL) {\n+        int pfrom = GETARG_A(*previous);\n+        int pto = GETARG_B(*previous);\n+        if (pfrom <= from && from <= pto+1) {  /* can connect both? */\n+          if (from+n-1 > pto)\n+            SETARG_B(*previous, from+n-1);\n+          return;\n+        }\n       }\n     }\n   }\n]],\n}\n\n\nBug{\nwhat = [[__concat metamethod converts numbers to strings]],\nreport = [[Paul Winwood, on 12/2006]],\nsince = [[5.0]],\nexample = [[\na = {}\nsetmetatable(a, {__concat = function (a,b) print(type(a), type(b)) end})\na = 4 .. a\n]],\npatch = [[\n*lvm.c:\n@@ -281,10 +281,12 @@\n   do {\n     StkId top = L->base + last + 1;\n     int n = 2;  /* number of elements handled in this pass (at least 2) */\n-    if (!tostring(L, top-2) || !tostring(L, top-1)) {\n+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {\n       if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))\n         luaG_concaterror(L, top-2, top-1);\n-    } else if (tsvalue(top-1)->len > 0) {  /* if len=0, do nothing */\n+    } else if (tsvalue(top-1)->len == 0)  /* second op is empty? */\n+      (void)tostring(L, top - 2);  /* result is first op (as string) */\n+    else {\n       /* at least two string values; get as many as possible */\n       size_t tl = tsvalue(top-1)->len;\n       char *buffer;\n]],\n}\n\n\nBug{\nwhat = [[As a library, loadlib.c should not access Lua internals\n(via lobject.h)]],\nreport = [[J\u00e9r\u00f4me Vuarand, on 03/2007]],\nsince = [[5.0]],\nexample = [[the bug has no effect on external behavior]],\npatch = [[remove the '#include \"lobject.h\" and use\n'lua_pushfstring' instead of 'luaO_pushfstring']],\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.2\n\nBug{\nwhat = [[Lua may close standard files,\nwhich then may be used by C]],\nreport = [[David Manura/Ross Berteig, on 04/2007]],\nsince = [[]],\nexample = [[\nio.close(io.stderr)\n-- in some systems, following attempts to write to 'stderr' may crash\na = a + 1\n]],\npatch = [[\n]],\n}\n\nBug{\nwhat = [[code generated for \"-nil\", \"-true\", and \"-false\" is wrong]],\nreport = [[David Manura/Rici Lake, on 04/2007]],\nsince = [[5.1]],\nexample = [[print(-nil)]],\npatch = [[\nlcode.c:\n@@ -699,7 +699,7 @@\n   e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;\n   switch (op) {\n     case OPR_MINUS: {\n-      if (e->k == VK)\n+      if (!isnumeral(e))\n         luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */\n       codearith(fs, OP_UNM, e, &e2);\n       break;\n]],\n}\n\nBug{\nwhat = [[Count hook may be called without being set.]],\nreport = [[Mike Pall, on 05/2007]],\nsince = [[?]],\nexample = [[]],\npatch = [[\nlvm.c:\n@@ -61,11 +61,9 @@\n   lu_byte mask = L->hookmask;\n   const Instruction *oldpc = L->savedpc;\n   L->savedpc = pc;\n-  if (mask > LUA_MASKLINE) {  /* instruction-hook set? */\n-    if (L->hookcount == 0) {\n-      resethookcount(L);\n-      luaD_callhook(L, LUA_HOOKCOUNT, -1);\n-    }\n+  if ((mask & LUA_MASKCOUNT) && L->hookcount == 0) {\n+    resethookcount(L);\n+    luaD_callhook(L, LUA_HOOKCOUNT, -1);\n   }\n   if (mask & LUA_MASKLINE) {\n     Proto *p = ci_func(L->ci)->l.p;\n]],\n}\n\nBug{\nwhat = [[recursive coroutines may overflow C stack]],\nreport = [[ , on ]],\nsince = [[5.0]],\nexample = [[\na = function(a) coroutine.wrap(a)(a) end\na(a)\n]],\npatch = [[The 'nCcalls' counter should be shared by all threads.\n(That is, it should be declared in the 'global_State' structure,\nnot in 'lua_State'.)\n]],\n}\n\nBug{\nwhat = [[wrong error message in some concatenations]],\nreport = [[Alex Davies, on 05/2007]],\nsince = [[5.1.2]],\nexample = [[a = nil; a = (1)..a]],\npatch = [[\nldebug.c:\n@@ -563,8 +563,8 @@\n\n\n void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {\n-  if (ttisstring(p1)) p1 = p2;\n-  lua_assert(!ttisstring(p1));\n+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;\n+  lua_assert(!ttisstring(p1) && !ttisnumber(p1));\n   luaG_typeerror(L, p1, \"concatenate\");\n }\n\n]],\n}\n\nBug{\nwhat = [[Very small numbers all collide in the hash function.\n(This creates only performance problems; the behavoir is correct.)]],\nreport = [[, on ]],\nsince = [[5.0]],\nexample = [[]],\npatch = [[\nltable.c:\n87,88c87,88\n<   n += 1;  /* normalize number (avoid -0) */\n<   lua_assert(sizeof(a) <= sizeof(n));\n---\n>   if (luai_numeq(n, 0))  /* avoid problems with -0 */\n>     return gnode(t, 0);\n]],\n}\n\nBug{\nwhat = [[Too many variables in an assignment may cause a\nC stack overflow]],\nreport = [[Mike Pall, on 07/2007]],\nsince = [[5.0]],\nexample = [[\n$ ulimit -s 1024       # Reduce C stack to 1MB for quicker results\n$ lua -e 'local s = \"a,\"; for i=1,18 do s = s..s end print(loadstring(\"local a;\"..s..\"a=nil\", \"\"))'\n]],\npatch = [[\nlparser.c:\n@@ -938,6 +938,8 @@\n     primaryexp(ls, &nv.v);\n     if (nv.v.k == VLOCAL)\n       check_conflict(ls, lh, &nv.v);\n+    luaY_checklimit(ls->fs, nvars, LUAI_MAXCCALLS - ls->L->nCcalls,\n+                    \"variable names\");\n     assignment(ls, &nv, nvars+1);\n   }\n   else {  /* assignment -> `=' explist1 */\n]],\n}\n\nBug{\nwhat = [[An error in a module loaded through the '-l' option\nshows no traceback]],\nreport = [[David Manura, on 08/2007]],\nsince = [[5.1]],\nexample = [[lua -ltemp    (assuming temp.lua has an error)]],\npatch = [[\nlua.c:\n@@ -144,7 +144,7 @@\n static int dolibrary (lua_State *L, const char *name) {\n   lua_getglobal(L, \"require\");\n   lua_pushstring(L, name);\n-  return report(L, lua_pcall(L, 1, 0, 0));\n+  return report(L, docall(L, 1, 1));\n }\n]],\n}\n\nBug{\nwhat = [['gsub' may go wild when wrongly called without its third\nargument and with a large subject]],\nreport = [[Florian Berger, on 10/2007]],\nsince = [[5.1]],\nexample = [[\nx = string.rep('a', 10000) .. string.rep('b', 10000)\nprint(#string.gsub(x, 'b'))\n]],\npatch = [[\nlstrlib.c:\n@@ -631,6 +631,2 @@\n     }\n-    default: {\n-      luaL_argerror(L, 3, \"string/function/table expected\"); \n-      return;\n-    }\n   }\n@@ -650,2 +646,3 @@\n   const char *p = luaL_checkstring(L, 2);\n+  int  tr = lua_type(L, 3);\n   int max_s = luaL_optint(L, 4, srcl+1);\n@@ -655,2 +652,5 @@\n   luaL_Buffer b;\n+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||\n+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,\n+                      \"string/function/table expected\");\n   luaL_buffinit(L, &b);\n]],\n}\n\nBug{\nwhat = [[table.remove removes last element of a table when given\nan out-of-bound index]],\nreport = [[Patrick Donnelly, on 11/2007]],\nsince = [[5.0]],\nexample = [[\na = {1,2,3}\ntable.remove(a, 4)\nprint(a[3])   --> nil   (should be 3)\n]],\npatch = [[\nltablib.c:\n@@ -118,7 +118,8 @@\n static int tremove (lua_State *L) {\n   int e = aux_getn(L, 1);\n   int pos = luaL_optint(L, 2, e);\n-  if (e == 0) return 0;  /* table is `empty' */\n+  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */\n+   return 0;  /* nothing to remove */\n   luaL_setn(L, 1, e - 1);  /* t.n = n-1 */\n   lua_rawgeti(L, 1, pos);  /* result = t[pos] */\n   for ( ;pos<e; pos++) {\n]],\n}\n\nBug{\nwhat = [[lua_setfenv may crash if called over an invalid object]],\nreport = [[Mike Pall, on 11/2007]],\nsince = [[5.1]],\nexample = [[\n> debug.setfenv(3, {})\n]],\npatch = [[\nlapi.c:\n@@ -749,7 +749,7 @@\n       res = 0;\n       break;\n   }\n-  luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));\n+  if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));\n   L->top--;\n   lua_unlock(L);\n   return res;\n]],\n}\n\nBug{\nwhat = [[stand-alone interpreter shows incorrect error message\nwhen the \"message\" is a coroutine]],\nreport = [[Patrick Donnelly, on 17/12/2007]],\nsince = [[5.1]],\nexample = [[> error(coroutine.create(function() end))]],\npatch = [[\nlua.c:\n@@ -74,6 +74,8 @@\n \n \n static int traceback (lua_State *L) {\n+  if (!lua_isstring(L, 1))  /* 'message' not a string? */\n+    return 1;  /* keep it intact */\n   lua_getfield(L, LUA_GLOBALSINDEX, \"debug\");\n   if (!lua_istable(L, -1)) {\n     lua_pop(L, 1);\n\n]],\n}\n\nBug{\nwhat = [[debug.sethook/gethook may overflow the thread's stack]],\nreport = [[Ivko Stanilov, on 2008/01/04]],\nsince = [[5.1]],\nexample = [[\na = coroutine.create(function() yield() end)\ncoroutine.resume(a)\ndebug.sethook(a)      -- may overflow the stack of 'a'\n]],\npatch = [[\nldblib.c:\n@@ -268,12 +268,11 @@\n     count = luaL_optint(L, arg+3, 0);\n     func = hookf; mask = makemask(smask, count);\n   }\n-  gethooktable(L1);\n-  lua_pushlightuserdata(L1, L1);\n+  gethooktable(L);\n+  lua_pushlightuserdata(L, L1);\n   lua_pushvalue(L, arg+1);\n-  lua_xmove(L, L1, 1);\n-  lua_rawset(L1, -3);  /* set new hook */\n-  lua_pop(L1, 1);  /* remove hook table */\n+  lua_rawset(L, -3);  /* set new hook */\n+  lua_pop(L, 1);  /* remove hook table */\n   lua_sethook(L1, func, mask, count);  /* set hooks */\n   return 0;\n }\n@@ -288,11 +287,10 @@\n   if (hook != NULL && hook != hookf)  /* external hook? */\n     lua_pushliteral(L, \"external hook\");\n   else {\n-    gethooktable(L1);\n-    lua_pushlightuserdata(L1, L1);\n-    lua_rawget(L1, -2);   /* get hook */\n-    lua_remove(L1, -2);  /* remove hook table */\n-    lua_xmove(L1, L, 1);\n+    gethooktable(L);\n+    lua_pushlightuserdata(L, L1);\n+    lua_rawget(L, -2);   /* get hook */\n+    lua_remove(L, -2);  /* remove hook table */\n   }\n   lua_pushstring(L, unmakemask(mask, buff));\n   lua_pushinteger(L, lua_gethookcount(L1));\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.3\n\nBug{\nwhat = [[LUAI_MAXCSTACK must be smaller than -LUA_REGISTRYINDEX]],\nreport = [[Patrick Donnelly, on 2008/02/11]],\nsince = [[5.1.3]],\nexample = [[\nj = 1e4\nco = coroutine.create(function()\n       t = {}\n       for i = 1, j do t[i] = i end\n       return unpack(t)\nend)\nprint(coroutine.resume(co))\n]],\npatch = [[\nluaconf.h:\n443c443,444\n< ** functions to consume unlimited stack space.\n---\n> ** functions to consume unlimited stack space. (must be smaller than\n> ** -LUA_REGISTRYINDEX)\n445,446c446\n< #define LUAI_MCS_AUX  ((int)(INT_MAX / (4*sizeof(LUA_NUMBER))))\n< #define LUAI_MAXCSTACK        (LUAI_MCS_AUX > SHRT_MAX ? SHRT_MAX : LUAI_MCS_AUX)\n---\n> #define LUAI_MAXCSTACK        8000\n]],\n}\n\nBug{\nwhat = [[coroutine.resume pushes element without ensuring stack size]],\nreport = [[on 2008/02/11]],\nsince = [[5.0]],\nexample = [[(this bug cannot be detected without internal assertions)]],\npatch = [[\nlbaselib.c:\n@@ -526,7 +526,7 @@\n   status = lua_resume(co, narg);\n   if (status == 0 || status == LUA_YIELD) {\n     int nres = lua_gettop(co);\n-    if (!lua_checkstack(L, nres))\n+    if (!lua_checkstack(L, nres + 1))\n       luaL_error(L, \"too many results to resume\");\n     lua_xmove(co, L, nres);  /* move yielded values */\n     return nres;\n]],\n}\n\nBug{\nwhat = [[lua_checkstack may have arithmetic overflow for large 'size']],\nreport = [[Patrick Donnelly, on 2008/02/12]],\nsince = [[5.0]],\nexample = [[\nprint(unpack({1,2,3}, 0, 2^31-3))\n]],\npatch = [[\n--- lapi.c      2008/01/03 15:20:39     2.55.1.3\n+++ lapi.c      2008/02/14 16:05:21\n@@ -93,15 +93,14 @@\n \n \n LUA_API int lua_checkstack (lua_State *L, int size) {\n-  int res;\n+  int res = 1;\n   lua_lock(L);\n-  if ((L->top - L->base + size) > LUAI_MAXCSTACK)\n+  if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)\n     res = 0;  /* stack overflow */\n-  else {\n+  else if (size > 0) {\n     luaD_checkstack(L, size);\n     if (L->ci->top < L->top + size)\n       L->ci->top = L->top + size;\n-    res = 1;\n   }\n   lua_unlock(L);\n   return res;\n]],\n}\n\nBug{\nwhat = [[unpack with maximum indices may crash due to arithmetic overflow]],\nreport = [[Patrick Donnelly, on 2008/02/12]],\nsince = [[5.1]],\nexample = [[\nprint(unpack({1,2,3}, 2^31-1, 2^31-1))\n]],\npatch = [[\n--- lbaselib.c  2008/02/11 16:24:24     1.191.1.5\n+++ lbaselib.c  2008/02/14 16:10:25\n@@ -344,10 +344,12 @@\n   luaL_checktype(L, 1, LUA_TTABLE);\n   i = luaL_optint(L, 2, 1);\n   e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));\n+  if (i > e) return 0;  /* empty range */\n   n = e - i + 1;  /* number of elements */\n-  if (n <= 0) return 0;  /* empty range */\n-  luaL_checkstack(L, n, \"table too big to unpack\");\n-  for (; i<=e; i++)  /* push arg[i...e] */\n+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */\n+    return luaL_error(L, \"too many results to unpack\");\n+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */\n+  while (i++ < e)  /* push arg[i + 1...e] */\n     lua_rawgeti(L, 1, i);\n   return n;\n }\n]],\n}\n\nBug{\nwhat = [[The validator for precompiled code has several flaws that\nallow malicious binary code to crash the application]],\nreport = [[Peter Cawley, on 2008/03/24]],\nsince = [[5.0]],\nexample = [[\na = string.dump(function()return;end)\na = a:gsub(string.char(30,37,122,128), string.char(34,0,0), 1)\nloadstring(a)()\n]],\npatch = [[\n--- ldebug.c    2007/12/28 15:32:23     2.29.1.3\n+++ ldebug.c    2008/04/04 15:15:40\n@@ -275,12 +275,12 @@\n \n static int precheck (const Proto *pt) {\n   check(pt->maxstacksize <= MAXSTACK);\n-  lua_assert(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);\n-  lua_assert(!(pt->is_vararg & VARARG_NEEDSARG) ||\n+  check(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);\n+  check(!(pt->is_vararg & VARARG_NEEDSARG) ||\n               (pt->is_vararg & VARARG_HASARG));\n   check(pt->sizeupvalues <= pt->nups);\n   check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);\n-  check(GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);\n+  check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);\n   return 1;\n }\n \n@@ -363,7 +363,11 @@\n     }\n     switch (op) {\n       case OP_LOADBOOL: {\n-        check(c == 0 || pc+2 < pt->sizecode);  /* check its jump */\n+        if (c == 1) {  /* does it jump? */\n+          check(pc+2 < pt->sizecode);  /* check its jump */\n+          check(GET_OPCODE(pt->code[pc+1]) != OP_SETLIST ||\n+                GETARG_C(pt->code[pc+1]) != 0);\n+        }\n         break;\n       }\n       case OP_LOADNIL: {\n@@ -428,7 +432,10 @@\n       }\n       case OP_SETLIST: {\n         if (b > 0) checkreg(pt, a + b);\n-        if (c == 0) pc++;\n+        if (c == 0) {\n+          pc++;\n+          check(pc < pt->sizecode - 1);\n+        }\n         break;\n       }\n       case OP_CLOSURE: {\n]],\n}\n\nBug{\nwhat = [[maliciously crafted precompiled code can blow the C stack]],\nreport = [[Greg Falcon, on 2008/03/25]],\nsince = [[5.0]],\nexample = [[\nfunction crash(depth)\n  local init = '\\27\\76\\117\\97\\81\\0\\1\\4\\4\\4\\8\\0\\7\\0\\0\\0\\61\\115\\116' ..\n               '\\100\\105\\110\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\2\\2\\0\\0\\0\\36' ..\n               '\\0\\0\\0\\30\\0\\128\\0\\0\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0' ..\n               '\\1\\0\\0\\0\\0\\0\\0\\2'\n  local mid = '\\1\\0\\0\\0\\30\\0\\128\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0'\n  local fin = '\\0\\0\\0\\0\\0\\0\\0\\2\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\2\\0' ..\n              '\\0\\0\\97\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\0'\n  local lch = '\\2\\0\\0\\0\\36\\0\\0\\0\\30\\0\\128\\0\\0\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0' ..\n              '\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\2'\n  local rch = '\\0\\0\\0\\0\\0\\0\\0\\2\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\2\\0' ..\n              '\\0\\0\\97\\0\\1\\0\\0\\0\\1'\n  for i=1,depth do lch,rch = lch..lch,rch..rch end\n  loadstring(init .. lch .. mid .. rch .. fin)\nend\nfor i=1,25 do print(i); crash(i) end\n]],\npatch = [[\n--- lundump.c   2008/04/04 16:00:45     2.7.1.3\n+++ lundump.c   2008/04/04 19:51:41     2.7.1.4\n@@ -161,7 +161,9 @@\n \n static Proto* LoadFunction(LoadState* S, TString* p)\n {\n- Proto* f=luaF_newproto(S->L);\n+ Proto* f;\n+ if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,\"code too deep\");\n+ f=luaF_newproto(S->L);\n  setptvalue2s(S->L,S->L->top,f); incr_top(S->L);\n  f->source=LoadString(S); if (f->source==NULL) f->source=p;\n  f->linedefined=LoadInt(S);\n@@ -175,6 +177,7 @@\n  LoadDebug(S,f);\n  IF (!luaG_checkcode(f), \"bad code\");\n  S->L->top--;\n+ S->L->nCcalls--;\n  return f;\n }\n]],\n}\n\nBug{\nwhat = [[code validator may reject (maliciously crafted) correct code]],\nreport = [[Greg Falcon, on 2008/03/26]],\nsince = [[5.0]],\nexample = [[\nz={}\nfor i=1,27290 do z[i]='1,' end\nz = 'if 1+1==2 then local a={' .. table.concat(z) .. '} end'\nfunc = loadstring(z)\nprint(loadstring(string.dump(func)))\n]],\npatch = [[\n--- ldebug.c    2008/04/04 15:30:05     2.29.1.4\n+++ ldebug.c    2008/04/04 15:47:10\n@@ -346,9 +346,18 @@\n           int dest = pc+1+b;\n           check(0 <= dest && dest < pt->sizecode);\n           if (dest > 0) {\n-            /* cannot jump to a setlist count */\n-            Instruction d = pt->code[dest-1];\n-            check(!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0));\n+            int j;\n+            /* check that it does not jump to a setlist count; this\n+               is tricky, because the count from a previous setlist may\n+               have the same value of an invalid setlist; so, we must\n+               go all the way back to the first of them (if any) */\n+            for (j = 0; j < dest; j++) {\n+              Instruction d = pt->code[dest-1-j];\n+              if (!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0)) break;\n+            }\n+            /* if 'j' is even, previous value is not a setlist (even if\n+               it looks like one) */\n+            check((j&1) == 0);\n           }\n         }\n         break;\n]],\n}\n\nBug{\nwhat = [[maliciously crafted precompiled code can inject invalid boolean\nvalues into Lua code]],\nreport = [[Greg Falcon, on 2008/03/27]],\nsince = [[5.0]],\nexample = [[\nmaybe = string.dump(function() return ({[true]=true})[true] end)\nmaybe = maybe:gsub('\\1\\1','\\1\\2')\nmaybe = loadstring(maybe)()\nassert(type(maybe) == \"boolean\" and maybe ~= true and maybe ~= false)\n]],\npatch = [[\n--- lundump.c   2008/01/18 16:39:11     2.7.1.2\n+++ lundump.c   2008/04/04 15:50:39\n@@ -115,7 +115,7 @@\n        setnilvalue(o);\n        break;\n    case LUA_TBOOLEAN:\n-       setbvalue(o,LoadChar(S));\n+       setbvalue(o,LoadChar(S)!=0);\n        break;\n    case LUA_TNUMBER:\n        setnvalue(o,LoadNumber(S));\n]],\n}\n\n\nBug{\nwhat = [['string.byte' gets confused with some out-of-range negative indices]],\nreport = [[Mike Pall, on 2008/06/03]],\nsince = [[5.1]],\nexample = [[\nprint(string.byte(\"abc\", -5))   --> 97   98   99   (should print nothing)\n]],\npatch = [[\n--- lstrlib.c\t2007/12/28 15:32:23\t1.132.1.3\n+++ lstrlib.c\t2008/07/05 11:53:42\n@@ -35,7 +35,8 @@\n \n static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {\n   /* relative string position: negative means back from end */\n-  return (pos>=0) ? pos : (ptrdiff_t)len+pos+1;\n+  if (pos < 0) pos += (ptrdiff_t)len + 1;\n+  return (pos >= 0) ? pos : 0;\n }\n \n \n]],\n}\n\n\nBug{\nwhat = [[user-requested GC step may loop forever]],\nreport = [[Makoto Hamanaka, on 2008/07/01]],\nsince = [[5.1]],\nexample = [[\ncollectgarbage(\"setpause\", 100) -- small value\ncollectgarbage(\"setstepmul\", 2000) -- large value\ncollectgarbage(\"step\",0)\n]],\npatch = [[\n--- lapi.c\t2008/02/14 16:46:39\t2.55.1.4\n+++ lapi.c\t2008/07/04 18:34:48\n@@ -929,10 +929,13 @@\n         g->GCthreshold = g->totalbytes - a;\n       else\n         g->GCthreshold = 0;\n-      while (g->GCthreshold <= g->totalbytes)\n+      while (g->GCthreshold <= g->totalbytes) {\n         luaC_step(L);\n-      if (g->gcstate == GCSpause)  /* end of cycle? */\n-        res = 1;  /* signal it */\n+        if (g->gcstate == GCSpause) {  /* end of cycle? */\n+          res = 1;  /* signal it */\n+          break;\n+        }\n+      }\n       break;\n     }\n     case LUA_GCSETPAUSE: {\n]],\n}\n\n\nBug{\nwhat = [['module' may change the environment of a C function]],\nreport = [[Peter Cawley, on 2008/07/16]],\nsince = [[5.1]],\nexample = [[\npcall(module, \"xuxu\")\nassert(debug.getfenv(pcall) == xuxu)\n]],\npatch = [[\n--- loadlib.c\t2007/12/28 14:58:43\t1.52.1.2\n+++ loadlib.c\t2008/08/05 19:39:00\n@@ -506,8 +506,11 @@\n \n static void setfenv (lua_State *L) {\n   lua_Debug ar;\n-  lua_getstack(L, 1, &ar);\n-  lua_getinfo(L, \"f\", &ar);\n+  if (lua_getstack(L, 1, &ar) == 0 ||\n+      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n+      lua_iscfunction(L, -1))\n+    luaL_error(L, \"function \" LUA_QL(\"module\")\n+                  \" not called from a Lua function\");\n   lua_pushvalue(L, -2);\n   lua_setfenv(L, -2);\n   lua_pop(L, 1);\n]],\n}\n\n\nBug{\nwhat = [[internal macro 'svalue' is wrong]],\nreport = [[Martijn van Buul, on 2008/08/04]],\nsince = [[5.1]],\nexample = [[\n/* in luaconf.h */\n#define LUAI_USER_ALIGNMENT_T   union { char b[32]; }\n]],\npatch = [[\n--- lobject.h\t2007/12/27 13:02:25\t2.20.1.1\n+++ lobject.h\t2008/08/05 19:40:48\n@@ -210,3 +210,3 @@\n #define getstr(ts)\tcast(const char *, (ts) + 1)\n-#define svalue(o)       getstr(tsvalue(o))\n+#define svalue(o)       getstr(rawtsvalue(o))\n \n]],\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.1.4\n\nBug{\nwhat = [[malicious zero-length string in binary code may segfault Lua]],\nreport = [[Peter Cawley, on 2008/09/01]],\nsince = [[5.1]],\nexample = [[\nloadstring(('').dump(function()X''end):gsub('\\2%z%z%zX','\\0\\0\\0'))()\n]],\npatch = [[\n]],\n}\n\n\nBug{\nwhat = [[wrong code generation for some particular boolean expressions]],\nreport = [[Brian Kelley, on 2009/04/15]],\nsince = [[5.0]],\nexample = [[\nprint(((1 or false) and true) or false)   --> 1\n-- should be 'true'\n]],\npatch = [[\n--- lcode.c\t2007/12/28 15:32:23\t2.25.1.3\n+++ lcode.c\t2009/06/15 14:07:34\n@@ -544,15 +544,18 @@\n       pc = NO_JUMP;  /* always true; do nothing */\n       break;\n     }\n-    case VFALSE: {\n-      pc = luaK_jump(fs);  /* always jump */\n-      break;\n-    }\n     case VJMP: {\n       invertjump(fs, e);\n       pc = e->u.s.info;\n       break;\n     }\n+    case VFALSE: {\n+      if (!hasjumps(e)) {\n+        pc = luaK_jump(fs);  /* always jump */\n+        break;\n+      }\n+      /* else go through */\n+    }\n     default: {\n       pc = jumponcond(fs, e, 0);\n       break;\n@@ -572,14 +575,17 @@\n       pc = NO_JUMP;  /* always false; do nothing */\n       break;\n     }\n-    case VTRUE: {\n-      pc = luaK_jump(fs);  /* always jump */\n-      break;\n-    }\n     case VJMP: {\n       pc = e->u.s.info;\n       break;\n     }\n+    case VTRUE: {\n+      if (!hasjumps(e)) {\n+        pc = luaK_jump(fs);  /* always jump */\n+        break;\n+      }\n+      /* else go through */\n+    }\n     default: {\n       pc = jumponcond(fs, e, 1);\n       break;\n]],\n}\n\nBug{\nwhat = [['luaV_settable' may invalidate a reference to a table and try\nto reuse it]],\nreport = [[Mark Feldman, on 2009/06/27]],\nsince = [[5.0]],\nexample = [[\ngrandparent = {}\ngrandparent.__newindex = function(s,_,_) print(s) end\n\nparent = {}\nparent.__newindex = parent\nsetmetatable(parent, grandparent)\n\nchild = setmetatable({}, parent)\nchild.foo = 10      --> (crash on some machines)\n]],\npatch = [[\n--- lvm.c\t2007/12/28 15:32:23\t2.63.1.3\n+++ lvm.c\t2009/07/01 20:36:59\n@@ -133,6 +133,7 @@\n \n void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n   int loop;\n+  TValue temp;\n   for (loop = 0; loop < MAXTAGLOOP; loop++) {\n     const TValue *tm;\n     if (ttistable(t)) {  /* `t' is a table? */\n@@ -152,7 +153,9 @@\n       callTM(L, tm, t, key, val);\n       return;\n     }\n-    t = tm;  /* else repeat with `tm' */ \n+    /* else repeat with `tm' */\n+    setobj(L, &temp, tm);  /* avoid pointing inside table (may rehash) */\n+    t = &temp;\n   }\n   luaG_runerror(L, \"loop in settable\");\n }\n]],\n}\n\nBug{\nwhat = [[smart use of varargs may create functions that return too\nmany arguments and overflow the stack of C functions]],\nreport = [[Patrick Donnelly, on 2008/12/10]],\nsince = [[]],\nexample = [[\nlocal function lunpack(i, ...)\n  if i == 0 then return ...\n  else\n    return lunpack(i-1, 1, ...)\n  end\nend\n\nNow, if C calls lunpack(n) with a huge n, it may end with\ntoo many values in its stack and confuse its stack indices.\n]],\npatch = [[\n]],\n}\n\nBug{\nwhat = [['debug.getfenv' does not check whether it has an argument]],\nreport = [[Patrick Donnelly, 2009/07/30]],\nsince = [[5.1]],\nexample = [[debug.getfenv()   -- should raise an error]],\npatch = [[\n--- ldblib.c    2008/01/21 13:11:21     1.104.1.3\n+++ ldblib.c    2009/08/04 18:43:12\n@@ -45,6 +45,7 @@\n \n \n static int db_getfenv (lua_State *L) {\n+  luaL_checkany(L, 1);\n   lua_getfenv(L, 1);\n   return 1;\n }\n]],\n}\n\nBug{\nwhat = [[GC may get stuck during a parser and avoids proper resizing of\nthe string table,\nmaking its lists grow too much and degrading performance]],\nreport = [[Sean Conner, 2009/11/10]],\nsince = [[5.1]],\nexample = [[See http://lua-users.org/lists/lua-l/2009-11/msg00463.html]],\npatch = [[\n--- llex.c\t2007/12/27 13:02:25\t2.20.1.1\n+++ llex.c\t2009/11/23 14:49:40\n@@ -118,8 +118,10 @@\n   lua_State *L = ls->L;\n   TString *ts = luaS_newlstr(L, str, l);\n   TValue *o = luaH_setstr(L, ls->fs->h, ts);  /* entry for `str' */\n-  if (ttisnil(o))\n+  if (ttisnil(o)) {\n     setbvalue(o, 1);  /* make sure `str' will not be collected */\n+    luaC_checkGC(L);\n+  }\n   return ts;\n }\n \n]]\n}\n\nBug{\nwhat = [['string.format' may get buffer as an argument when there are\nmissing arguments and format string is too long]],\nreport = [[Roberto I., 2010/04/12]],\nsince = [[5.0]],\nexample = [[\nx = string.rep(\"x\", 10000) .. \"%d\"\nprint(string.format(x))    -- gives wrong error message\n]],\npatch = [[\n--- lstrlib.c\t2008/07/11 17:27:21\t1.132.1.4\n+++ lstrlib.c\t2010/05/14 15:12:53\n@@ -754,6 +754,7 @@\n \n \n static int str_format (lua_State *L) {\n+  int top = lua_gettop(L);\n   int arg = 1;\n   size_t sfl;\n   const char *strfrmt = luaL_checklstring(L, arg, &sfl);\n@@ -768,7 +769,8 @@\n     else { /* format item */\n       char form[MAX_FORMAT];  /* to store the format (`%...') */\n       char buff[MAX_ITEM];  /* to store the formatted item */\n-      arg++;\n+      if (++arg > top)\n+        luaL_argerror(L, arg, \"no value\");\n       strfrmt = scanformat(L, strfrmt, form);\n       switch (*strfrmt++) {\n         case 'c': {\n]]\n}\n\nBug{\nwhat = [['io.read(op, \"*n\")' may return garbage if second read fails]],\nreport = [[Roberto I., 2010/04/12]],\nsince = [[5.0]],\nexample = [[\nprint(io.read(\"*n\", \"*n\"))   --<< enter \"10   hi\"\n--> file (0x884420)\tnil\n]],\npatch = [[\n--- liolib.c\t2008/01/18 17:47:43\t2.73.1.3\n+++ liolib.c\t2010/05/14 15:29:29\n@@ -276,7 +276,10 @@\n     lua_pushnumber(L, d);\n     return 1;\n   }\n-  else return 0;  /* read fails */\n+  else {\n+    lua_pushnil(L);  /* \"result\" to be removed */\n+    return 0;  /* read fails */\n+  }\n }\n \n \n]]\n}\n\nBug{\nwhat = [[wrong code generation for some particular boolean expressions]],\nreport = [[Thierry Van Elsuwe, 2011/01/20]],\nsince = [[5.0]],\nexample = [[\nprint((('hi' or true) and true) or true)\n--> hi     (should be true)\nprint(((nil and nil) or false) and true)\n--> nil    (should be false)\n]],\npatch = [[\n--- lcode.c\t2009/06/15 14:12:25\t2.25.1.4\n+++ lcode.c\t2011/01/31 14:44:25\n@@ -549,13 +549,6 @@\n       pc = e->u.s.info;\n       break;\n     }\n-    case VFALSE: {\n-      if (!hasjumps(e)) {\n-        pc = luaK_jump(fs);  /* always jump */\n-        break;\n-      }\n-      /* else go through */\n-    }\n     default: {\n       pc = jumponcond(fs, e, 0);\n       break;\n@@ -579,13 +572,6 @@\n       pc = e->u.s.info;\n       break;\n     }\n-    case VTRUE: {\n-      if (!hasjumps(e)) {\n-        pc = luaK_jump(fs);  /* always jump */\n-        break;\n-      }\n-      /* else go through */\n-    }\n     default: {\n       pc = jumponcond(fs, e, 1);\n       break;\n]]\n}\n\nBug{\nwhat = [[__newindex metamethod may not work if metatable is its own\nmetatable]],\nreport = [[Cuero Bugot, 2011/08/09]],\nsince = [[5.1]],\nexample = [[\nmeta={}\nsetmetatable(meta, meta)\nmeta.__newindex = function(t, key, value) print(\"set\") end\no = setmetatable({}, meta)\no.x = 10    -- should print 'set'\n]],\npatch = [[\n--- lvm.c\t2009/07/01 21:10:33\t2.63.1.4\n+++ lvm.c\t2011/08/17 20:36:28\n@@ -142,6 +142,7 @@\n       if (!ttisnil(oldval) ||  /* result is no nil? */\n           (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */\n         setobj2t(L, oldval, val);\n+        h->flags = 0;\n         luaC_barriert(L, h, val);\n         return;\n       }\n]]\n}\n\nBug{\nwhat = [[parser may collect a prototype while building it]],\nreport = [[Ingo van Lil, 2011/10/13]],\nsince = [[5.1.4 (caused by patch 5.1.4-6)]],\nexample = nil,\npatch = [[\n--- lparser.c\t2007/12/28 15:32:23\t2.42.1.3\n+++ lparser.c\t2011/10/17 13:10:43\n@@ -374,9 +374,9 @@\n   lua_assert(luaG_checkcode(f));\n   lua_assert(fs->bl == NULL);\n   ls->fs = fs->prev;\n-  L->top -= 2;  /* remove table and prototype from the stack */\n   /* last token read was anchored in defunct function; must reanchor it */\n   if (fs) anchor_token(ls);\n+  L->top -= 2;  /* remove table and prototype from the stack */\n }\n \n \n]]\n}\n\n\nBug{\nwhat = [[When loading a file,\nLua may call the reader function again after it returned end of input\n]],\nreport = [[Chris Howie, 2013/06/05]],\nsince = [[5.1]],\nfix = [[5.2]],\nexample = [[\nload(function () print(\"called\"); return nil end)\n--> called\n--> called             (should be called only once!)\n]],\npatch = [[\n--- lzio.h\t2007/12/27 13:02:25\t1.21.1.1\n+++ lzio.h\t2013/07/04 13:55:59\n@@ -59,6 +59,7 @@\n   lua_Reader reader;\n   void* data;\t\t\t/* additional data */\n   lua_State *L;\t\t\t/* Lua state (for reader) */\n+  int eoz;\t\t\t/* true if reader has no more data */\n };\n\n\n--- lzio.c\t2007/12/27 13:02:25\t1.31.1.1\n+++ lzio.c\t2013/07/04 13:53:06\n@@ -22,10 +22,14 @@\n   size_t size;\n   lua_State *L = z->L;\n   const char *buff;\n+  if (z->eoz) return EOZ;\n   lua_unlock(L);\n   buff = z->reader(L, z->data, &size);\n   lua_lock(L);\n-  if (buff == NULL || size == 0) return EOZ;\n+  if (buff == NULL || size == 0) {\n+    z->eoz = 1;  /* avoid calling reader function next time */\n+    return EOZ;\n+  }\n   z->n = size - 1;\n   z->p = buff;\n   return char2int(*(z->p++));\n@@ -51,6 +55,7 @@\n   z->data = data;\n   z->n = 0;\n   z->p = NULL;\n+  z->eoz = 0;\n }\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.0\n\nBug{\nwhat = [[memory hoarding when creating Lua hooks for coroutines]],\nreport = [[Arseny Vakhrushev, 2012/01/16]],\nsince = [[5.1]],\nfix = [[5.2.1]],\nexample = [[\ncollectgarbage(); print(collectgarbage'count' * 1024)\n\nfor i = 1, 100 do\n  local co = coroutine.create(function () end)\n  local x = {}\n  for j=1,1000 do x[j] = j end\n  debug.sethook(co, function () return x end, 'l')\nend\n\ncollectgarbage(); print(collectgarbage'count' * 1024)\n-- value should back to near the original level\n]],\npatch = [[\n-- For 5.2\n\n--- ldblib.c\t2011/10/24 14:54:05\t1.131\n+++ ldblib.c\t2012/01/18 02:36:59\n@@ -253,14 +253,15 @@\n }\n \n \n-#define gethooktable(L)\tluaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY);\n+#define gethooktable(L)\tluaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)\n \n \n static void hookf (lua_State *L, lua_Debug *ar) {\n   static const char *const hooknames[] =\n     {\"call\", \"return\", \"line\", \"count\", \"tail call\"};\n   gethooktable(L);\n-  lua_rawgetp(L, -1, L);\n+  lua_pushthread(L);\n+  lua_rawget(L, -2);\n   if (lua_isfunction(L, -1)) {\n     lua_pushstring(L, hooknames[(int)ar->event]);\n     if (ar->currentline >= 0)\n@@ -306,10 +307,15 @@\n     count = luaL_optint(L, arg+3, 0);\n     func = hookf; mask = makemask(smask, count);\n   }\n-  gethooktable(L);\n+  if (gethooktable(L) == 0) {  /* creating hook table? */\n+    lua_pushstring(L, \"k\");\n+    lua_setfield(L, -2, \"__mode\");  /** hooktable.__mode = \"k\" */\n+    lua_pushvalue(L, -1);\n+    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */\n+  }\n+  lua_pushthread(L1); lua_xmove(L1, L, 1);\n   lua_pushvalue(L, arg+1);\n-  lua_rawsetp(L, -2, L1);  /* set new hook */\n-  lua_pop(L, 1);  /* remove hook table */\n+  lua_rawset(L, -3);  /* set new hook */\n   lua_sethook(L1, func, mask, count);  /* set hooks */\n   return 0;\n }\n@@ -325,7 +331,8 @@\n     lua_pushliteral(L, \"external hook\");\n   else {\n     gethooktable(L);\n-    lua_rawgetp(L, -1, L1);   /* get hook */\n+    lua_pushthread(L1); lua_xmove(L1, L, 1);\n+    lua_rawget(L, -2);   /* get hook */\n     lua_remove(L, -2);  /* remove hook table */\n   }\n   lua_pushstring(L, unmakemask(mask, buff));\n]]\n}\n\nBug{\nwhat = [[Lexical gets confused with some combination of arithmetic\noperators and hexadecimal numbers]],\nreport = [[Alexandra Barros, 2012/01/17]],\nsince = [[5.2.0]],\nfix = [[5.2.1]],\nexample = [[print(0xE+1)]],\npatch = [[\n--- llex.c      2011/11/30 12:43:51     2.59\n+++ llex.c      2012/01/20 18:22:50\n@@ -223,12 +223,19 @@\n\n /* LUA_NUMBER */\n static void read_numeral (LexState *ls, SemInfo *seminfo) {\n+  const char *expo = \"Ee\";\n+  int first = ls->current;\n   lua_assert(lisdigit(ls->current));\n-  do {\n-    save_and_next(ls);\n-    if (check_next(ls, \"EePp\"))  /* exponent part? */\n+  save_and_next(ls);\n+  if (first == '0' && check_next(ls, \"Xx\"))  /* hexadecimal? */\n+    expo = \"Pp\";\n+  for (;;) {\n+    if (check_next(ls, expo))  /* exponent part? */\n       check_next(ls, \"+-\");  /* optional exponent sign */\n-  } while (lislalnum(ls->current) || ls->current == '.');\n+    if (lisxdigit(ls->current) || ls->current == '.')\n+      save_and_next(ls);\n+    else  break;\n+  }\n   save(ls, '\\0');\n   buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n   if (!buff2d(ls->buff, &seminfo->r))  /* format error? */\n]]\n}\n\nBug{\nwhat = [[Finalizers may call functions from a dynamic library after\nthe library has been unloaded]],\nreport = [[Josh Haberman, 2012/04/08]],\nsince = [[5.1]],\nfix = [[5.2.1]],\nexample = [[\nlocal u = setmetatable({}, {__gc = function () foo() end})\nlocal m = require 'mod'   -- 'mod' may be any dynamic library written in C\nfoo = m.foo     -- 'foo' may be any function from 'mod'\n-- end program; it crashes\n]],\npatch = [[\nloadlib.c:\n95c95\n< #define LIBPREFIX\t\"LOADLIB: \"\n---\n> #define CLIBS\t\t\"_CLIBS\"\n251,266c251,256\n< \n< static void **ll_register (lua_State *L, const char *path) {\n<   void **plib;\n<   lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n<   lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n<   if (!lua_isnil(L, -1))  /* is there an entry? */\n<     plib = (void **)lua_touserdata(L, -1);\n<   else {  /* no entry yet; create one */\n<     lua_pop(L, 1);  /* remove result from gettable */\n<     plib = (void **)lua_newuserdata(L, sizeof(const void *));\n<     *plib = NULL;\n<     luaL_setmetatable(L, \"_LOADLIB\");\n<     lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n<     lua_pushvalue(L, -2);\n<     lua_settable(L, LUA_REGISTRYINDEX);\n<   }\n---\n> static void *ll_checkclib (lua_State *L, const char *path) {\n>   void *plib;\n>   lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n>   lua_getfield(L, -1, path);\n>   plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n>   lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n270a261,270\n> static void ll_addtoclib (lua_State *L, const char *path, void *plib) {\n>   lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n>   lua_pushlightuserdata(L, plib);\n>   lua_pushvalue(L, -1);\n>   lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n>   lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n>   lua_pop(L, 1);  /* pop CLIBS table */\n> }\n> \n> \n272,273c272,273\n< ** __gc tag method: calls library's `ll_unloadlib' function with the lib\n< ** handle\n---\n> ** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib\n> ** handles in list CLIBS\n276,278c276,281\n<   void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n<   if (*lib) ll_unloadlib(*lib);\n<   *lib = NULL;  /* mark library as closed */\n---\n>   int n = luaL_len(L, 1);\n>   for (; n >= 1; n--) {  /* for each handle, in reverse order */\n>     lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n>     ll_unloadlib(lua_touserdata(L, -1));\n>     lua_pop(L, 1);  /* pop handle */\n>   }\n284,286c287,292\n<   void **reg = ll_register(L, path);\n<   if (*reg == NULL) *reg = ll_load(L, path, *sym == '*');\n<   if (*reg == NULL) return ERRLIB;  /* unable to load library */\n---\n>   void *reg = ll_checkclib(L, path);  /* check loaded C libraries */\n>   if (reg == NULL) {  /* must load library? */\n>     reg = ll_load(L, path, *sym == '*');\n>     if (reg == NULL) return ERRLIB;  /* unable to load library */\n>     ll_addtoclib(L, path, reg);\n>   }\n292c298\n<     lua_CFunction f = ll_sym(L, *reg, sym);\n---\n>     lua_CFunction f = ll_sym(L, reg, sym);\n675,676c681,683\n<   /* create new type _LOADLIB */\n<   luaL_newmetatable(L, \"_LOADLIB\");\n---\n>   /* create table CLIBS to keep track of loaded C libraries */\n>   luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);\n>   lua_createtable(L, 0, 1);  /* metatable for CLIBS */\n678a686\n>   lua_setmetatable(L, -2);\n]]\n}\n\nBug{\nwhat = [[wrong handling of 'nCcalls' in coroutines]],\nreport = [[Alexander Gavrilov, 2012/04/18]],\nsince = [[5.2.0]],\nfix = [[5.2.1]],\nexample = [[\ncoroutine.wrap(function()\n  print(pcall(pcall,pcall,pcall,pcall,pcall,error,3))\nend)()\n]],\npatch = [[\n--- ldo.c\t2011/11/29 15:55:08\t2.102\n+++ ldo.c\t2012/04/26 20:38:32\n@@ -402,8 +402,6 @@\n   int n;\n   lua_assert(ci->u.c.k != NULL);  /* must have a continuation */\n   lua_assert(L->nny == 0);\n-  /* finish 'luaD_call' */\n-  L->nCcalls--;\n   /* finish 'lua_callk' */\n   adjustresults(L, ci->nresults);\n   /* call continuation function */\n@@ -513,7 +511,6 @@\n         api_checknelems(L, n);\n         firstArg = L->top - n;  /* yield results come from continuation */\n       }\n-      L->nCcalls--;  /* finish 'luaD_call' */\n       luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */\n     }\n     unroll(L, NULL);\n]]\n}\n\nBug{\nwhat = [[Internal Lua values may escape through the debug API]],\nreport = [[Dan Tull, 2012/04/20]],\nsince = [[5.1]],\nfix = [[5.2.1]],\nexample = [[\n-- for Lua 5.1\nlocal firsttime = true\nlocal function foo ()\n  if firsttime then\n    firsttime = false\n    return \"a = 1\"\n  else\n    for i = 1, 10 do\n      print(debug.getlocal(2, i))\n    end\n  end\nend\n\nprint(load(foo))   -- prints some lines and then seg. fault.\n]],\npatch = [[\n]]\n}\n\nBug{\nwhat = [[Problems when yielding from debug hooks]],\nreport = [[Erik Cassel, 2012/06/05]],\nsince = [[5.2.0]],\nfix = [[5.2.1]],\nexample = [[\nSet, in C, a line hook that simply yields,\nand then call any Lua function.\nYou get an infinite loop of yields.\n]],\npatch = [[\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.1\n\nBug{\nwhat = [[Some patterns can overflow the C stack, due to recursion]],\nreport = [[Tim Starling, 2012/07/08]],\nsince = [[2.5]],\nfix = [[5.2.2]],\nexample = [[print(string.find(string.rep(\"a\", 2^20), string.rep(\".?\", 2^20)))]],\npatch = [[\n]]\n}\n\n\nBug{\nwhat = [['pcall' may not restore previous error function when\ninside coroutines]],\nreport = [[Alexander Gavrilov, 2012/06/12]],\nsince = [[5.2.0]],\nfix = [[5.2.2]],\nexample = [[\nfunction errfunc(x)\n  return 'errfunc'\nend\n\nfunction test(do_yield)\n  print(do_yield and \"yielding\" or \"not yielding\")\n  pcall(function() -- this pcall sets errfunc back to none\n    if do_yield then\n      coroutine.yield() -- stops errfunc from being restored\n    end\n  end)\n  error('fail!')\nend\n\ncoro = coroutine.wrap(function()\n  print(xpcall(test, errfunc, false))\n  print(xpcall(test, errfunc, true))\n  print(xpcall(test, errfunc, false))\nend)\n\ncoro()\n--> not yielding\n--> false\terrfunc\n--> yielding\ncoro()\n--> false\ttemp:12: fail!       <<<< should be 'errfunc' too\n--> not yielding\n--> false\terrfunc\n]],\npatch = [[\n--- ldo.c\t2012/08/28 18:30:45\t2.107\n+++ ldo.c\t2012/09/23 15:49:55\n@@ -403,7 +403,11 @@\n   int n;\n   lua_assert(ci->u.c.k != NULL);  /* must have a continuation */\n   lua_assert(L->nny == 0);\n-  /* finish 'lua_callk' */\n+  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */\n+    ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */\n+    L->errfunc = ci->u.c.old_errfunc;\n+  }\n+  /* finish 'lua_callk'/'lua_pcall' */\n   adjustresults(L, ci->nresults);\n   /* call continuation function */\n   if (!(ci->callstatus & CIST_STAT))  /* no call status? */\n]]\n}\n\nBug{\nwhat = [[Check for garbage collector in function calls does not cover\nall paths]],\nreport = [[Roberto, 2012/08/15]],\nsince = [[5.2.1]],\nfix = [[5.2.2]],\nexample = [[\nSee <a href=\"http://lua-users.org/lists/lua-l/2012-08/msg00149.html\">\nhttp://lua-users.org/lists/lua-l/2012-08/msg00149.html</a>\n]],\npatch = [[\n@@ -311,6 +311,7 @@\n       ci->top = L->top + LUA_MINSTACK;\n       lua_assert(ci->top <= L->stack_last);\n       ci->callstatus = 0;\n+      luaC_checkGC(L);  /* stack grow uses memory */\n       if (L->hookmask & LUA_MASKCALL)\n         luaD_hook(L, LUA_HOOKCALL, -1);\n       lua_unlock(L);\n@@ -338,6 +339,7 @@\n       ci->u.l.savedpc = p->code;  /* starting point */\n       ci->callstatus = CIST_LUA;\n       L->top = ci->top;\n+      luaC_checkGC(L);  /* stack grow uses memory */\n       if (L->hookmask & LUA_MASKCALL)\n         callhook(L, ci);\n       return 0;\n@@ -393,7 +395,6 @@\n     luaV_execute(L);  /* call it */\n   if (!allowyield) L->nny--;\n   L->nCcalls--;\n-  luaC_checkGC(L);\n }\n]]\n}\n\nBug{\nwhat = [[load/loadfile returns wrong result when given an environment\nfor a binary chunk with no upvalues]],\nreport = [[Vladimir Strakh, 2012/11/28]],\nsince = [[5.2.0]],\nfix = [[5.2.2]],\nexample = [[\nf = load(string.dump(function () return 1 end), nil, \"b\", {})\nprint(type(f))   --> table            (whould be a function)\n]],\npatch = [[\n--- lbaselib.c\t2012/04/27 14:13:19\t1.274\n+++ lbaselib.c\t2012/12/03 20:08:15\n@@ -244,5 +244,11 @@\n \n-static int load_aux (lua_State *L, int status) {\n-  if (status == LUA_OK)\n+static int load_aux (lua_State *L, int status, int envidx) {\n+  if (status == LUA_OK) {\n+    if (envidx != 0) {  /* 'env' parameter? */\n+      lua_pushvalue(L, envidx);  /* environment for loaded function */\n+      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n+        lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n+    }\n     return 1;\n+  }\n   else {\n@@ -258,9 +264,5 @@\n   const char *mode = luaL_optstring(L, 2, NULL);\n-  int env = !lua_isnone(L, 3);  /* 'env' parameter? */\n+  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */\n   int status = luaL_loadfilex(L, fname, mode);\n-  if (status == LUA_OK && env) {  /* 'env' parameter? */\n-    lua_pushvalue(L, 3);\n-    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue of loaded chunk */\n-  }\n-  return load_aux(L, status);\n+  return load_aux(L, status, env);\n }\n@@ -309,5 +311,5 @@\n   size_t l;\n-  int top = lua_gettop(L);\n   const char *s = lua_tolstring(L, 1, &l);\n   const char *mode = luaL_optstring(L, 3, \"bt\");\n+  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */\n   if (s != NULL) {  /* loading a string? */\n@@ -322,7 +324,3 @@\n   }\n-  if (status == LUA_OK && top >= 4) {  /* is there an 'env' argument */\n-    lua_pushvalue(L, 4);  /* environment for loaded function */\n-    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue */\n-  }\n-  return load_aux(L, status);\n+  return load_aux(L, status, env);\n }\n]]\n}\n\n\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.2\n\n\nBug{\nwhat = [[stack overflow in vararg functions with many fixed\nparameters called with few arguments]],\nreport = [[\u4e91\u98ce, 2013/04/17]],\nsince = [[5.1]],\nfix = [[5.2.3]],\nexample = [[\nfunction f(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,\n           p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,\n           p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,\n           p31, p32, p33, p34, p35, p36, p37, p38, p39, p40,\n           p41, p42, p43, p44, p45, p46, p48, p49, p50, ...)\n  local a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14\nend\n\nf()   -- seg. fault (on some machines)\n]],\npatch = [[\n--- ldo.c\t2012/10/01 14:05:04\t2.108\n+++ ldo.c\t2013/04/19 20:56:06\n@@ -324,7 +324,7 @@\n     case LUA_TLCL: {  /* Lua function: prepare its call */\n       StkId base;\n       Proto *p = clLvalue(func)->p;\n-      luaD_checkstack(L, p->maxstacksize);\n+      luaD_checkstack(L, p->maxstacksize + p->numparams);\n       func = restorestack(L, funcr);\n       n = cast_int(L->top - func) - 1;  /* number of real arguments */\n       for (; n < p->numparams; n++)\n]],\n}\n\nBug{\nwhat = [[garbage collector can trigger too many times in recursive loops]],\nreport = [[Roberto, 2013/04/25]],\nsince = [[5.2.2]],\nfix = [[5.2.3]],\nexample = [[\nfunction f() f() end\nf()   -- it takes too long before a \"stack overflow\" error\n]],\npatch = [[\n--- lgc.c\t2013/04/12 18:48:47\t2.140.1.1\n+++ lgc.c\t2013/04/25 21:30:20\n@@ -495,2 +495,3 @@\n static lu_mem traversestack (global_State *g, lua_State *th) {\n+  int n = 0;\n   StkId o = th->stack;\n@@ -505,3 +506,9 @@\n   }\n-  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;\n+  else {  /* count call infos to compute size */\n+    CallInfo *ci;\n+    for (ci = &th->base_ci; ci != th->ci; ci = ci->next)\n+      n++;\n+  }\n+  return sizeof(lua_State) + sizeof(TValue) * th->stacksize +\n+         sizeof(CallInfo) * n;\n }\n]]\n}\n\n-- [[]]\nBug{\nwhat = [[Wrong assert when reporting concatenation errors\n(manifests only when Lua is compiled in debug mode)]],\nreport = [[Roberto, 2013/05/05]],\nsince = [[?]],\nfix = [[5.2.3]],\nexample = [[\n-- only with Lua compiled in debug mode\nprint({} .. 2)\n]],\npatch = [[\n--- ldebug.c\t2013/04/12 18:48:47\t2.90.1.1\n+++ ldebug.c\t2013/05/05 14:38:30\n@@ -519,5 +519,5 @@\n l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {\n   if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;\n-  lua_assert(!ttisstring(p1) && !ttisnumber(p2));\n+  lua_assert(!ttisstring(p1) && !ttisnumber(p1));\n   luaG_typeerror(L, p1, \"concatenate\");\n }\n]]\n}\n\nBug{\nwhat = [[Wrong error message in some short-cut expressions]],\nreport = [[Egor Skriptunoff, 2013/05/10]],\nsince = [[5.0]],\nfix = [[5.2.3]],\nexample = [[\n> a,b,c = true,true,true\n> (a and b or c)('', '')\nstdin:1: attempt to call a boolean value (global 'c')\n\n    (It should be global 'b' instead of 'c'.)\n]],\npatch = [[\n--- ldebug.c\t2013/05/06 17:20:22\t2.90.1.2\n+++ ldebug.c\t2013/05/14 19:52:48\n@@ -327,12 +327,20 @@\n }\n \n \n+static int filterpc (int pc, int jmptarget) {\n+  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n+    return -1;  /* cannot know who sets that register */\n+  else return pc;  /* current position sets that register */\n+}\n+\n+\n /*\n ** try to find last instruction before 'lastpc' that modified register 'reg'\n */\n static int findsetreg (Proto *p, int lastpc, int reg) {\n   int pc;\n   int setreg = -1;  /* keep last instruction that changed 'reg' */\n+  int jmptarget = 0;  /* any code before this address is conditional */\n   for (pc = 0; pc < lastpc; pc++) {\n     Instruction i = p->code[pc];\n     OpCode op = GET_OPCODE(i);\n@@ -341,33 +349,38 @@\n       case OP_LOADNIL: {\n         int b = GETARG_B(i);\n         if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */\n-          setreg = pc;\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       case OP_TFORCALL: {\n-        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */\n+        if (reg >= a + 2)  /* affect all regs above its base */\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       case OP_CALL:\n       case OP_TAILCALL: {\n-        if (reg >= a) setreg = pc;  /* affect all registers above base */\n+        if (reg >= a)  /* affect all registers above base */\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       case OP_JMP: {\n         int b = GETARG_sBx(i);\n         int dest = pc + 1 + b;\n         /* jump is forward and do not skip `lastpc'? */\n-        if (pc < dest && dest <= lastpc)\n-          pc += b;  /* do the jump */\n+        if (pc < dest && dest <= lastpc) {\n+          if (dest > jmptarget)\n+            jmptarget = dest;  /* update 'jmptarget' */\n+        }\n         break;\n       }\n       case OP_TEST: {\n-        if (reg == a) setreg = pc;  /* jumped code can change 'a' */\n+        if (reg == a)  /* jumped code can change 'a' */\n+          setreg = filterpc(pc, jmptarget);\n         break;\n       }\n       default:\n         if (testAMode(op) && reg == a)  /* any instruction that set A */\n-          setreg = pc;\n+          setreg = filterpc(pc, jmptarget);\n         break;\n     }\n   }\n]]\n}\n\nBug{\nwhat = [[luac listings choke on long strings]],\nreport = [[Ashwin Hirschi, 2013/07/03]],\nsince = [[5.1.2]],\nfix = [[5.2.3]],\nexample = [[\n-- When you call 'luac -l' over this chunk, it chokes the output\ns=\"Lorem ipsum dolor sit amet, consectetur, \"\n]],\npatch = [[\n--- luac.c 2011-11-29 15:46:33 -0200  1.69\n+++ luac.c 2013-07-03 21:26:01 -0300\n@@ -251,7 +251,7 @@\n static void PrintConstant(const Proto* f, int i)\n {\n  const TValue* o=&f->k[i];\n- switch (ttype(o))\n+ switch (ttypenv(o))\n  {\n   case LUA_TNIL:\n        printf(\"nil\");\n]]\n}\n\nBug{\nwhat = [[GC can collect a long string still in use during parser]],\nreport = [[Roberto, 2013/08/30]],\nsince = [[5.2]],\nfix = [[5.2.3]],\nexample = [[This bug is very difficult to happen (and to reproduce),\nbecause it depends on the GC running in a very specific way when\nparsing a source code with long (larger than 40 characters) identifiers.]],\npatch = [[\n--- ltable.h\t2013/04/12 18:48:47\t2.16.1.1\n+++ ltable.h\t2013/08/30 15:34:24\n@@ -18,4 +18,8 @@\n #define invalidateTMcache(t)\t((t)->flags = 0)\n \n+/* returns the key, given the value of a table entry */\n+#define keyfromval(v) \\\n+  (gkey(cast(Node *, cast(char *, (v)) - offsetof(Node, i_val))))\n+\n \n LUAI_FUNC const TValue *luaH_getint (Table *t, int key);\n\n--- llex.c\t2013/04/12 18:48:47\t2.63.1.1\n+++ llex.c\t2013/08/30 15:34:59\n@@ -134,4 +134,7 @@\n     luaC_checkGC(L);\n   }\n+  else {  /* string already present */\n+    ts = rawtsvalue(keyfromval(o));  /* re-use value previously stored */\n+  }\n   L->top--;  /* remove string from stack */\n   return ts;\n]]\n}\n\n\nBug{\nwhat = [[Call to macro 'luai_userstateclose' should be done only\nafter the calls to __gc methods.]],\nreport = [[Jean-Luc Jumpertz, 2013/09/02]],\nsince = [[ ]],\nfix = nil,\nexample = [[No example]],\npatch = [[\n--- lstate.c\t2013/04/12 18:48:47\t2.99.1.1\n+++ lstate.c\t2013/11/08 17:39:57\n@@ -194,2 +194,4 @@\n   g->gcrunning = 1;  /* allow gc */\n+  g->version = lua_version(NULL);\n+  luai_userstateopen(L);\n }\n@@ -224,2 +226,4 @@\n   luaC_freeallobjects(L);  /* collect all objects */\n+  if (g->version)  /* closing a fully built state? */\n+    luai_userstateclose(L);\n   luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);\n@@ -289,3 +293,3 @@\n   g->panic = NULL;\n-  g->version = lua_version(NULL);\n+  g->version = NULL;\n   g->gcstate = GCSpause;\n@@ -308,4 +312,2 @@\n   }\n-  else\n-    luai_userstateopen(L);\n   return L;\n@@ -317,3 +319,2 @@\n   lua_lock(L);\n-  luai_userstateclose(L);\n   close_state(L);\n]]\n}\n\n\nBug{\nwhat = [[Resuming the running coroutine makes it unyieldable]],\nreport = [[Florian N\u00fccke, 2013/10/28]],\nsince = [[5.2]],\nfix = [[5.2.3]],\nexample = [[\n-- should print 'true'\nprint(coroutine.resume(coroutine.create(function()\n  coroutine.resume(coroutine.running())\n  coroutine.yield()\nend)))\n]],\npatch = [[\n--- ldo.c\t2013/04/19 21:03:23\t2.108.1.2\n+++ ldo.c\t2013/11/08 18:20:57\n@@ -536,2 +536,3 @@\n   int status;\n+  int oldnny = L->nny;  /* save 'nny' */\n   lua_lock(L);\n@@ -557,3 +558,3 @@\n   }\n-  L->nny = 1;  /* do not allow yields */\n+  L->nny = oldnny;  /* restore 'nny' */\n   L->nCcalls--;\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.2.3\n\nBug{\nwhat = [[compiler can optimize away overflow check in 'table.unpack']],\nreport = [[Paige DePol, 2014/03/30]],\nsince = [[5.1 (at least)]],\nfix = nil,\nexample = [[\n> unpack({}, 0, 2^31 - 1)\n(segfaults on some platforms with some compiler options)\n]],\npatch = [[\n--- ltablib.c\t2013/04/12 18:48:47\t1.65.1.1\n+++ ltablib.c\t2014/05/07 16:32:55\t1.65.1.2\n@@ -134,13 +135,14 @@\n \n \n static int unpack (lua_State *L) {\n-  int i, e, n;\n+  int i, e;\n+  unsigned int n;\n   luaL_checktype(L, 1, LUA_TTABLE);\n   i = luaL_optint(L, 2, 1);\n   e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));\n   if (i > e) return 0;  /* empty range */\n-  n = e - i + 1;  /* number of elements */\n-  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */\n+  n = (unsigned int)e - (unsigned int)i;  /* number of elements minus 1 */\n+  if (n > (INT_MAX - 10) || !lua_checkstack(L, ++n))\n     return luaL_error(L, \"too many results to unpack\");\n   lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */\n   while (i++ < e)  /* push arg[i + 1...e] */\n]]\n}\n\nBug{\nwhat = [[Ephemeron table can wrongly collect entry with strong key]],\nreport = [[J\u00f6rg Richter, 2014/08/22]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n(This bug is very hard to reproduce,\nbecause it depends on a specific interleaving of\nevents between the incremental collector and the program.)\n]],\npatch = [[\n--- lgc.c\t2013/04/26 18:22:05\t2.140.1.2\n+++ lgc.c\t2014/09/01 13:24:33\n@@ -403,7 +403,7 @@\n       reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n     }\n   }\n-  if (prop)\n+  if (g->gcstate != GCSatomic || prop)\n     linktable(h, &g->ephemeron);  /* have to propagate again */\n   else if (hasclears)  /* does table have white keys? */\n     linktable(h, &g->allweak);  /* may have to clean white keys */\n]]\n}\n\nBug{\nwhat = [[Chunk with too many lines can seg. fault]],\nreport = [[Roberto, 2014/11/14]],\nsince = [[5.1 (at least)]],\nfix = nil,\nexample = [[\n-- the cause of the bug is the use of an unitialized variable, so\n-- it cannot be reproduced reliably\nlocal s = string.rep(\"\\n\", 2^24)\nprint(load(function () return s end))\n]],\npatch = [[\n--- llex.c\t2013/08/30 15:49:41\t2.63.1.2\n+++ llex.c\t2015/02/09 17:05:31\n@@ -153,5 +153,5 @@\n     next(ls);  /* skip `\\n\\r' or `\\r\\n' */\n   if (++ls->linenumber >= MAX_INT)\n-    luaX_syntaxerror(ls, \"chunk has too many lines\");\n+    lexerror(ls, \"chunk has too many lines\", 0);\n }\n \n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.0\n\nBug{\nwhat = [['string.format(\"%f\")' can cause a buffer overflow\n(only when 'lua_Number' is long double!)]],\nreport = [[Roberto, 2015/01/13]],\nsince = [[5.3]],\nfix = nil,\nexample = [[string.format(\"%.99f\", 1e4000)    -- when floats are long double]],\npatch = [[\n--- lstrlib.c\t2014/12/11 14:03:07\t1.221\n+++ lstrlib.c\t2015/02/23 19:01:42\n@@ -800,3 +800,4 @@\n /* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */\n-#define MAX_ITEM\t512\n+#define MAX_ITEM  \\\n+  (sizeof(lua_Number) <= 4 ? 150 : sizeof(lua_Number) <= 8 ? 450 : 5050)\n \n]]\n}\n\nBug{\nwhat = [['debug.getlocal' on a coroutine suspended in a hook\ncan crash the interpreter]],\nreport = [[\u4e91\u98ce, 2015/02/11]],\nsince = [[5.2]],\nfix = nil,\nexample = [[see http://lua-users.org/lists/lua-l/2015-02/msg00146.html]],\npatch = [[\n--- ldebug.c\t2015/01/02 12:52:22\t2.110\n+++ ldebug.c\t2015/02/13 16:03:23\n@@ -49,4 +49,14 @@\n \n \n+static void swapextra (lua_State *L) {\n+  if (L->status == LUA_YIELD) {\n+    CallInfo *ci = L->ci;  /* get function that yielded */\n+    StkId temp = ci->func;  /* exchange its 'func' and 'extra' values */\n+    ci->func = restorestack(L, ci->extra);\n+    ci->extra = savestack(L, temp);\n+  }\n+}\n+\n+\n /*\n ** this function can be called asynchronous (e.g. during a signal)\n@@ -145,4 +155,5 @@\n   const char *name;\n   lua_lock(L);\n+  swapextra(L);\n   if (ar == NULL) {  /* information about non-active function? */\n     if (!isLfunction(L->top - 1))  /* not a Lua function? */\n@@ -159,4 +170,5 @@\n     }\n   }\n+  swapextra(L);\n   lua_unlock(L);\n   return name;\n@@ -166,10 +178,13 @@\n LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n   StkId pos = 0;  /* to avoid warnings */\n-  const char *name = findlocal(L, ar->i_ci, n, &pos);\n+  const char *name;\n   lua_lock(L);\n+  swapextra(L);\n+  name = findlocal(L, ar->i_ci, n, &pos);\n   if (name) {\n     setobjs2s(L, pos, L->top - 1);\n     L->top--;  /* pop value */\n   }\n+  swapextra(L);\n   lua_unlock(L);\n   return name;\n@@ -271,4 +286,5 @@\n   StkId func;\n   lua_lock(L);\n+  swapextra(L);\n   if (*what == '>') {\n     ci = NULL;\n@@ -289,4 +305,5 @@\n     api_incr_top(L);\n   }\n+  swapextra(L);\n   if (strchr(what, 'L'))\n     collectvalidlines(L, cl);\n]]\n}\n\n\nBug{\nwhat = [[suspended '__le' metamethod can give wrong result]],\nreport = [[Eric Zhong, 2015/04/07]],\nsince = [[5.2]],\nfix = nil,\n\nexample = [[\nmt = {__le = function (a,b) coroutine.yield(\"yield\"); return a.x <= b.x end}\nt1 = setmetatable({x=1}, mt)\nt2 = {x=2}\nco = coroutine.wrap(function (a,b) return t2 <= t1 end)\nco()\nprint(co())   --> true  (should be false)\n]],\n\npatch = [[\n--- lstate.h\t2014/10/30 18:53:28\t2.119\n+++ lstate.h\t2015/04/13 15:58:40\n@@ -94,6 +94,7 @@\n #define CIST_YPCALL\t(1<<4)\t/* call is a yieldable protected call */\n #define CIST_TAIL\t(1<<5)\t/* call was tail called */\n #define CIST_HOOKYIELD\t(1<<6)\t/* last hook called yielded */\n+#define CIST_LEQ\t(1<<7)  /* using __lt for __le */\n \n #define isLua(ci)\t((ci)->callstatus & CIST_LUA)\n \n--- lvm.c\t2014/12/27 20:30:38\t2.232\n+++ lvm.c\t2015/04/13 15:51:30\n@@ -292,9 +292,14 @@\n     return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;\n   else if ((res = luaT_callorderTM(L, l, r, TM_LE)) >= 0)  /* first try 'le' */\n     return res;\n-  else if ((res = luaT_callorderTM(L, r, l, TM_LT)) < 0)  /* else try 'lt' */\n-    luaG_ordererror(L, l, r);\n-  return !res;\n+  else {  /* try 'lt': */\n+    L->ci->callstatus |= CIST_LEQ;  /* mark it is doing 'lt' for 'le' */\n+    res = luaT_callorderTM(L, r, l, TM_LT);\n+    L->ci->callstatus ^= CIST_LEQ;  /* clear mark */\n+    if (res < 0)\n+      luaG_ordererror(L, l, r);\n+    return !res;  /* result is negated */\n+  }\n }\n \n \n@@ -553,11 +558,11 @@\n     case OP_LE: case OP_LT: case OP_EQ: {\n       int res = !l_isfalse(L->top - 1);\n       L->top--;\n-      /* metamethod should not be called when operand is K */\n-      lua_assert(!ISK(GETARG_B(inst)));\n-      if (op == OP_LE &&  /* \"<=\" using \"<\" instead? */\n-          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n-        res = !res;  /* invert result */\n+      if (ci->callstatus & CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n+        lua_assert(op == OP_LE);\n+        ci->callstatus ^= CIST_LEQ;  /* clear mark */\n+        res = !res;  /* negate result */\n+      }\n       lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n       if (res != GETARG_A(inst))  /* condition failed? */\n         ci->u.l.savedpc++;  /* skip jump instruction */\n]]\n}\n\n\nBug{\nwhat = [[return hook may not see correct values for\n active local variables when function returns]],\nreport = [[Philipp Janda/Peng Yi, 2015/05/19]],\nsince = [[5.0]],\nfix = nil,\nexample = [[\nsee messasge http://lua-users.org/lists/lua-l/2015-05/msg00376.html]],\npatch = [[\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.1\n\nBug{\nwhat = [['io.lines' does not check maximum number of options]],\nreport = [[Patrick Donnell, 2015/07/10]],\nsince = [[5.3.0]],\nfix = nil,\nexample = [[\n-- can segfault in some machines\nt ={}; for i = 1, 253 do t[i] = 1 end\nio.lines(\"someexistingfile\", table.unpack(t))()\n]],\npatch = [[\n--- liolib.c\t2015/07/07 17:03:34\t2.146\n+++ liolib.c\t2015/07/15 14:40:28\t2.147\n@@ -318,8 +318,15 @@\n static int io_readline (lua_State *L);\n \n \n+/*\n+** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit\n+** in the limit for upvalues of a closure)\n+*/\n+#define MAXARGLINE\t250\n+\n static void aux_lines (lua_State *L, int toclose) {\n   int n = lua_gettop(L) - 1;  /* number of arguments to read */\n+  luaL_argcheck(L, n <= MAXARGLINE, MAXARGLINE + 2, \"too many arguments\");\n   lua_pushinteger(L, n);  /* number of arguments to read */\n   lua_pushboolean(L, toclose);  /* close/not close file when finished */\n   lua_rotate(L, 2, 2);  /* move 'n' and 'toclose' to their positions */\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.2\n\nBug{\nwhat = [[Metatable may access its own dealocated field when\nit has a self reference in __newindex]],\nreport = [[actboy168@gmail.com, 2016/01/01]],\nsince = [[5.3.2]],\nfix = nil,\nexample = [[\nlocal mt = {}\nmt.__newindex = mt\nlocal t = setmetatable({}, mt)\nt[1] = 1     -- will segfault on some machines\n]],\npatch = [[\n--- lvm.c\t2015/11/23 11:30:45\t2.265\n+++ lvm.c\t2016/01/01 14:34:12\n@@ -190,18 +190,19 @@\n   for (loop = 0; loop < MAXTAGLOOP; loop++) {\n     const TValue *tm;\n     if (oldval != NULL) {\n-      lua_assert(ttistable(t) && ttisnil(oldval));\n+      Table *h = hvalue(t);  /* save 't' table */\n+      lua_assert(ttisnil(oldval));\n       /* must check the metamethod */\n-      if ((tm = fasttm(L, hvalue(t)->metatable, TM_NEWINDEX)) == NULL &&\n+      if ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&\n          /* no metamethod; is there a previous entry in the table? */\n          (oldval != luaO_nilobject ||\n          /* no previous entry; must create one. (The next test is\n             always true; we only need the assignment.) */\n-         (oldval = luaH_newkey(L, hvalue(t), key), 1))) {\n+         (oldval = luaH_newkey(L, h, key), 1))) {\n         /* no metamethod and (now) there is an entry with given key */\n         setobj2t(L, cast(TValue *, oldval), val);\n-        invalidateTMcache(hvalue(t));\n-        luaC_barrierback(L, hvalue(t), val);\n+        invalidateTMcache(h);\n+        luaC_barrierback(L, h, val);\n         return;\n       }\n       /* else will try the metamethod */\n]]\n}\n\n\nBug{\nwhat = [[label between local definitions can mix-up their initializations]],\nreport = [[Karel Tuma, 2016/03/01]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\ndo\n  local k = 0\n  local x\n  ::foo::\n  local y       -- should be reset to nil after goto, but it is not\n  assert(not y)\n  y = true\n  k = k + 1\n  if k < 2 then goto foo end\nend\n]],\npatch = [[\n--- lparser.c\t2015/11/02 16:09:30\t2.149\n+++ lparser.c\t2016/03/03 12:03:37\n@@ -1226,7 +1226,7 @@\n   checkrepeated(fs, ll, label);  /* check for repeated labels */\n   checknext(ls, TK_DBCOLON);  /* skip double colon */\n   /* create new entry for this label */\n-  l = newlabelentry(ls, ll, label, line, fs->pc);\n+  l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));\n   skipnoopstat(ls);  /* skip other no-op statements */\n   if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */\n     /* assume that locals are already out of scope */\n]]\n}\n\n\nBug{\nwhat = [['gmatch' iterator fails when called from a coroutine different\nfrom the one that created it]],\nreport = [[Nagaev Boris, 2016/03/18]],\nsince = [[5.3.2]],\nfix = nil,\nexample = [[\nlocal f = string.gmatch(\"1 2 3 4 5\", \"%d+\")\nprint(f())     --> 1\nco = coroutine.wrap(f)\nprint(co())    --> ??? (should be 2)\n]],\npatch = [[\n--- lstrlib.c\t2015/11/25 16:28:17\t1.239\n+++ lstrlib.c\t2016/04/11 15:29:41\n@@ -688,6 +688,7 @@\n static int gmatch_aux (lua_State *L) {\n   GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));\n   const char *src;\n+  gm->ms.L = L;\n   for (src = gm->src; src <= gm->ms.src_end; src++) {\n     const char *e;\n     reprepstate(&gm->ms);\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.3\n\n\nBug{\nwhat = [[expression list with four or more expressions in\na 'for' loop can crash the interpreter]],\nreport = [[Marco Sch\u00f6pl, 2016/06/17]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n-- the next loop will probably crash the interpreter\nrepeat until load \"for _ in _,_,_,_ do local function _() end\"\n]],\npatch = [[\n--- lparser.c\t2016/05/13 19:10:16\t2.153\n+++ lparser.c\t2016/06/17 19:52:48\n@@ -323,6 +323,8 @@\n       luaK_nil(fs, reg, extra);\n     }\n   }\n+  if (nexps > nvars)\n+    ls->fs->freereg -= nexps - nvars;  /* remove extra values */\n }\n \n \n@@ -1160,11 +1162,8 @@\n     int nexps;\n     checknext(ls, '=');\n     nexps = explist(ls, &e);\n-    if (nexps != nvars) {\n+    if (nexps != nvars)\n       adjust_assign(ls, nvars, nexps, &e);\n-      if (nexps > nvars)\n-        ls->fs->freereg -= nexps - nvars;  /* remove extra values */\n-    }\n     else {\n       luaK_setoneret(ls->fs, &e);  /* close last expression */\n       luaK_storevar(ls->fs, &lh->v, &e);\n]]\n}\n\n\nBug{\nwhat = [[Checking a format for 'os.date' may read pass the format string]],\nreport = [[Nagaev Boris, 2016/07/10]],\nsince = [[5.3.3]],\nfix = nil,\nexample = [[\nThis bug does not seem to happen with regular compilers.\nIt needs an \"interceptor\" 'memcmp' function that continues\nreading memory after a difference is found.]],\npatch = [[\n2c2\n< ** $Id: bugs,v 1.160 2018/05/24 20:25:14 roberto Exp roberto $\n---\n> ** $Id: bugs,v 1.160 2018/05/24 20:25:14 roberto Exp roberto $\n263c263,264\n<   for (option = LUA_STRFTIMEOPTIONS; *option != '\\0'; option += oplen) {\n---\n>   int convlen = (int)strlen(conv);\n>   for (option = LUA_STRFTIMEOPTIONS; *option != '\\0' && oplen <= convlen; option += oplen) {\n]]\n}\n\n\nBug{\nwhat = [[Lua can generate wrong code in functions with too many constants]],\nreport = [[Marco Sch\u00f6pl, 2016/07/17]],\nsince = [[5.3.3]],\nfix = nil,\nexample = [[See http://lua-users.org/lists/lua-l/2016-07/msg00303.html]],\npatch = [[\n--- lcode.c     2016/06/20 19:12:46     2.110\n+++ lcode.c     2016/07/18 15:43:41\n@@ -1018,8 +1018,8 @@\n */\n static void codebinexpval (FuncState *fs, OpCode op,\n                            expdesc *e1, expdesc *e2, int line) {\n-  int rk1 = luaK_exp2RK(fs, e1);  /* both operands are \"RK\" */\n-  int rk2 = luaK_exp2RK(fs, e2);\n+  int rk2 = luaK_exp2RK(fs, e2);  /* both operands are \"RK\" */\n+  int rk1 = luaK_exp2RK(fs, e1);\n   freeexps(fs, e1, e2);\n   e1->u.info = luaK_codeABC(fs, op, 0, rk1, rk2);  /* generate opcode */\n   e1->k = VRELOCABLE;  /* all those operations are relocatable */\n]]\n}\n\n\nBug{\nwhat = [[When a coroutine tries to resume a non-suspended coroutine,\nit can do some mess (and break C assertions) before detecting the error]],\nreport = [[Marco Sch\u00f6pl, 2016/07/20]],\nsince = [[ ]],\nfix = nil,\nexample = [[\n-- with C assertions on\nA = coroutine.running()\nB = coroutine.create(function() coroutine.resume(A) end)\ncoroutine.resume(B)\n\n-- or\nA = coroutine.wrap(function() pcall(A, _) end)\nA()\n]],\npatch = [[\n]]\n}\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.4\n\n\nBug{\nwhat = [[Wrong code for a goto followed by a label inside an 'if']],\nreport = [[\u4e91\u98ce, 2017/04/13]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n-- should print 32323232..., but prints only '3'\nif true then\n  goto LBL\n  ::loop::\n  print(2)\n  ::LBL::\n  print(3)\n  goto loop\nend\n]],\npatch = [[\n--- lparser.c\t2017/04/19 17:20:42\t2.155.1.1\n+++ lparser.c\t2017/04/29 18:11:40\t2.155.1.2\n@@ -1392,7 +1392,7 @@\n     luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */\n     enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n     gotostat(ls, v.t);  /* handle goto/break */\n-    skipnoopstat(ls);  /* skip other no-op statements */\n+    while (testnext(ls, ';')) {}  /* skip semicolons */\n     if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */\n       leaveblock(fs);\n       return;  /* and that is it */\n]]\n}\n\n\nBug{\nwhat = [[Lua crashes when building sequences with more than 2^30 elements.]],\nreport = [[Viacheslav Usov, 2017/05/11]],\nsince = [[ ]],\nfix = nil,\nexample = [[\n-- crashes if machine has enough memory\nlocal t = {}\nfor i = 1, 0x7fffffff do\n  t[i] = i\nend\n]],\npatch = [[\n--- ltable.c\t2017/04/19 17:20:42\t2.118.1.1\n+++ ltable.c\t2018/05/24 18:34:38\n@@ -223,7 +223,9 @@\n   unsigned int na = 0;  /* number of elements to go to array part */\n   unsigned int optimal = 0;  /* optimal size for array part */\n   /* loop while keys can fill more than half of total size */\n-  for (i = 0, twotoi = 1; *pna > twotoi / 2; i++, twotoi *= 2) {\n+  for (i = 0, twotoi = 1;\n+       twotoi > 0 && *pna > twotoi / 2;\n+       i++, twotoi *= 2) {\n     if (nums[i] > 0) {\n       a += nums[i];\n       if (a > twotoi/2) {  /* more than half elements present? */\n]]\n}\n\n\nBug{\nwhat = [[Table length computation overflows for sequences larger than\n2^31 elements.]],\nreport = [[Viacheslav Usov, 2017/05/12]],\nsince = [[ ]],\nfix = nil,\nexample = [[\n-- on a machine with enough memory\nlocal t = {}\nfor i = 1, 2147483681 do\n  t[i] = i\nend\nprint(#t)\n]],\npatch = [[\n--- ltable.h\t2017/04/19 17:20:42\t2.23.1.1\n+++ ltable.h\t2018/05/24 19:31:50\n@@ -56,3 +56,3 @@\n LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);\n-LUAI_FUNC int luaH_getn (Table *t);\n+LUAI_FUNC lua_Unsigned luaH_getn (Table *t);\n \n--- ltable.c\t2018/05/24 19:22:37\t2.118.1.2\n+++ ltable.c\t2018/05/24 19:25:05\n@@ -614,4 +614,4 @@\n \n-static int unbound_search (Table *t, unsigned int j) {\n-  unsigned int i = j;  /* i is zero or a present index */\n+static lua_Unsigned unbound_search (Table *t, lua_Unsigned j) {\n+  lua_Unsigned i = j;  /* i is zero or a present index */\n   j++;\n@@ -620,3 +620,3 @@\n     i = j;\n-    if (j > cast(unsigned int, MAX_INT)/2) {  /* overflow? */\n+    if (j > l_castS2U(LUA_MAXINTEGER) / 2) {  /* overflow? */\n       /* table was built with bad purposes: resort to linear search */\n@@ -630,3 +630,3 @@\n   while (j - i > 1) {\n-    unsigned int m = (i+j)/2;\n+    lua_Unsigned m = (i+j)/2;\n     if (ttisnil(luaH_getint(t, m))) j = m;\n@@ -642,3 +642,3 @@\n */\n-int luaH_getn (Table *t) {\n+lua_Unsigned luaH_getn (Table *t) {\n   unsigned int j = t->sizearray;\n]]\n}\n\n\nBug{\nwhat = [[Lua does not check GC when creating error messages]],\nreport = [[Viacheslav Usov, 2017/07/06]],\nsince = [[5.3.2]],\nfix = nil,\nexample = [[\nfunction test()\n  bob.joe.larry = 23\nend\n\n-- memory will grow steadly\nfor i = 1, math.huge do\n  pcall(test)\n  if i % 100000 == 0 then\n    io.write(collectgarbage'count'*1024, \"\\n\")\n  end\nend\n]],\npatch = [[\n--- ldebug.c\t2017/04/19 17:20:42\t2.121.1.1\n+++ ldebug.c\t2017/07/10 17:08:39\n@@ -653,6 +653,7 @@\n   CallInfo *ci = L->ci;\n   const char *msg;\n   va_list argp;\n+  luaC_checkGC(L);  /* error message uses memory */\n   va_start(argp, fmt);\n   msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n   va_end(argp);\n]]\n}\n\n\nBug{\nwhat = [[dead keys with nil values can stay in weak tables]],\nreport = [[\u4e91\u98ce Cloud Wu, 2017/08/15]],\nsince = [[5.2]],\nfix = nil,\nexample = [[\n-- The following chunk, under a memory checker like valgrind,\n-- produces a memory access violation.\n\nlocal a = setmetatable({}, {__mode = 'kv'})\n\na['ABCDEFGHIJKLMNOPQRSTUVWXYZ' .. 'abcdefghijklmnopqrstuvwxyz'] = {}\na[next(a)] = nil\ncollectgarbage()\nprint(a['BCDEFGHIJKLMNOPQRSTUVWXYZ' .. 'abcdefghijklmnopqrstuvwxyz'])\n]],\npatch = [[\n--- lgc.c\t2016/12/22 13:08:50\t2.215\n+++ lgc.c\t2017/08/31 16:08:23\n@@ -643,8 +643,9 @@\n     for (n = gnode(h, 0); n < limit; n++) {\n       if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {\n         setnilvalue(gval(n));  /* remove value ... */\n-        removeentry(n);  /* and remove entry from table */\n       }\n+      if (ttisnil(gval(n)))  /* is entry empty? */\n+        removeentry(n);  /* remove entry from table */\n     }\n   }\n }\n]]\n}\n\n\nBug{\nwhat = [['lua_pushcclosure' should not call the garbage collector when\n'n' is zero.]],\nreport = [[Andrew Gierth, 2017/12/05]],\nsince = [[5.3.3]],\nfix = nil,\nexample = [[ ]],\npatch = [[\n--- lapi.c\t2017/04/19 17:13:00\t2.259.1.1\n+++ lapi.c\t2017/12/06 18:14:45\n@@ -533,6 +533,7 @@\n   lua_lock(L);\n   if (n == 0) {\n     setfvalue(L->top, fn);\n+    api_incr_top(L);\n   }\n   else {\n     CClosure *cl;\n@@ -546,9 +547,9 @@\n       /* does not need barrier because closure is white */\n     }\n     setclCvalue(L, L->top, cl);\n+    api_incr_top(L);\n+    luaC_checkGC(L);\n   }\n-  api_incr_top(L);\n-  luaC_checkGC(L);\n   lua_unlock(L);\n }\n]]\n}\n\n\nBug{\nwhat = [[memory-allocation error when resizing a table can leave it\nin an inconsistent state.]],\nreport = [[Roberto, 2017/12/08]],\nsince = [[5.0]],\nfix = nil,\nexample = [[\nlocal a = {x = 1, y = 1, z = 1}\na[1] = 10   -- goes to the hash part (which has 4 slots)\nprint(a[1])   --> 10\n\n-- assume that the 2nd memory allocation from now fails\npcall(rawset, a, 2, 20)   -- forces a rehash\n\n-- a[1] now exists both in the array part (because the array part\n-- grew) and in the hash part (because the allocation of the hash\n-- part failed, keeping it as it was).\n-- This makes the following traversal goes forever...\nfor k,v in pairs(a) do print(k,v) end\n]],\npatch = [[\n--- ltable.c    2018/05/24 19:39:05     2.118.1.3\n+++ ltable.c    2018/06/04 16:00:25\n@@ -332,17 +332,34 @@\n }\n \n \n+typedef struct {\n+  Table *t;\n+  unsigned int nhsize;\n+} AuxsetnodeT;\n+\n+\n+static void auxsetnode (lua_State *L, void *ud) {\n+  AuxsetnodeT *asn = cast(AuxsetnodeT *, ud);\n+  setnodevector(L, asn->t, asn->nhsize);\n+}\n+\n+\n void luaH_resize (lua_State *L, Table *t, unsigned int nasize,\n                                           unsigned int nhsize) {\n   unsigned int i;\n   int j;\n+  AuxsetnodeT asn;\n   unsigned int oldasize = t->sizearray;\n   int oldhsize = allocsizenode(t);\n   Node *nold = t->node;  /* save old hash ... */\n   if (nasize > oldasize)  /* array part must grow? */\n     setarrayvector(L, t, nasize);\n   /* create new hash part with appropriate size */\n-  setnodevector(L, t, nhsize);\n+  asn.t = t; asn.nhsize = nhsize;\n+  if (luaD_rawrunprotected(L, auxsetnode, &asn) != LUA_OK) {  /* mem. error? */\n+    setarrayvector(L, t, oldasize);  /* array back to its original size */\n+    luaD_throw(L, LUA_ERRMEM);  /* rethrow memory error */\n+  }\n   if (nasize < oldasize) {  /* array part must shrink? */\n     t->sizearray = nasize;\n     /* re-insert elements from vanishing slice */\n]]\n}\n\n\n\n-----------------------------------------------------------------\n-- Lua 5.3.5\n\nBug{\nwhat = [[Long brackets with a huge number of '=' overflow some\ninternal buffer arithmetic]],\nreport = [[Marco, 2018/12/12]],\nsince = [[5.1]],\nfix = nil,\nexample = [[\nlocal eqs = string.rep(\"=\", 0x3ffffffe)\nlocal code = \"return [\" .. eqs .. \"[a]\" .. eqs .. \"]\"\nprint(#assert(load(code))())\n]],\npatch = [[\n--- a/llex.c\n+++ b/llex.c\n@@ -244,12 +244,12 @@\n \n \n /*\n-** skip a sequence '[=*[' or ']=*]'; if sequence is well formed, return\n-** its number of '='s; otherwise, return a negative number (-1 iff there\n-** are no '='s after initial bracket)\n+** reads a sequence '[=*[' or ']=*]', leaving the last bracket.\n+** If sequence is well formed, return its number of '='s + 2; otherwise,\n+** return 1 if there is no '='s or 0 otherwise (an unfinished '[==...').\n */\n-static int skip_sep (LexState *ls) {\n-  int count = 0;\n+static size_t skip_sep (LexState *ls) {\n+  size_t count = 0;\n   int s = ls->current;\n   lua_assert(s == '[' || s == ']');\n   save_and_next(ls);\n@@ -257,11 +257,14 @@\n     save_and_next(ls);\n     count++;\n   }\n-  return (ls->current == s) ? count : (-count) - 1;\n+  return (ls->current == s) ? count + 2\n+         : (count == 0) ? 1\n+         : 0;\n+\n }\n \n \n-static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {\n+static void read_long_string (LexState *ls, SemInfo *seminfo, size_t sep) {\n   int line = ls->linenumber;  /* initial line (for error message) */\n   save_and_next(ls);  /* skip 2nd '[' */\n   if (currIsNewline(ls))  /* string starts with a newline? */\n@@ -295,8 +298,8 @@\n     }\n   } endloop:\n   if (seminfo)\n-    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),\n-                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));\n+    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + sep,\n+                                     luaZ_bufflen(ls->buff) - 2 * sep);\n }\n \n \n@@ -444,9 +447,9 @@\n         /* else is a comment */\n         next(ls);\n         if (ls->current == '[') {  /* long comment? */\n-          int sep = skip_sep(ls);\n+          size_t sep = skip_sep(ls);\n           luaZ_resetbuffer(ls->buff);  /* 'skip_sep' may dirty the buffer */\n-          if (sep >= 0) {\n+          if (sep >= 2) {\n             read_long_string(ls, NULL, sep);  /* skip long comment */\n             luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */\n             break;\n@@ -458,12 +461,12 @@\n         break;\n       }\n       case '[': {  /* long string or simply '[' */\n-        int sep = skip_sep(ls);\n-        if (sep >= 0) {\n+        size_t sep = skip_sep(ls);\n+        if (sep >= 2) {\n           read_long_string(ls, seminfo, sep);\n           return TK_STRING;\n         }\n-        else if (sep != -1)  /* '[=...' missing second bracket */\n+        else if (sep == 0)  /* '[=...' missing second bracket */\n           lexerror(ls, \"invalid long string delimiter\", TK_STRING);\n         return '[';\n       }\n]]\n}\n\n\nBug{\nwhat = [[joining an upvalue with itself can cause a use-after-free crash]],\nreport = [[Fady Othman, 2019/01/10]],\nsince = [[5.3]],\nfix = nil,\nexample = [[\n-- the next code may crash the machine\nf=load(function() end)\ninteresting={}\ninteresting[0]=string.rep(\"A\",512)\ndebug.upvaluejoin(f,1,f,1)\n]],\npatch = [[\n--- a/lapi.c\n+++ b/lapi.c\n@@ -1289,6 +1289,8 @@ LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n   LClosure *f1;\n   UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n   UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n+  if (*up1 == *up2)\n+    return;\n   luaC_upvdeccount(L, *up1);\n   *up1 = *up2;\n   (*up1)->refcount++;\n]]\n}\n\n\n--[=[\nBug{\nwhat = [[ ]],\nreport = [[ ]],\nsince = [[ ]],\nfix = nil,\nexample = [[ ]],\npatch = [[\n]]\n}\n]=]\n\n\n", "/*\n** $Id: lapi.c,v 2.259.1.2 2017/12/06 18:35:12 roberto Exp $\n** Lua API\n** See Copyright Notice in lua.h\n*/\n\n#define lapi_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n\n\n\nconst char lua_ident[] =\n  \"$LuaVersion: \" LUA_COPYRIGHT \" $\"\n  \"$LuaAuthors: \" LUA_AUTHORS \" $\";\n\n\n/* value at a non-valid index */\n#define NONVALIDVALUE\t\tcast(TValue *, luaO_nilobject)\n\n/* corresponding test */\n#define isvalid(o)\t((o) != luaO_nilobject)\n\n/* test for pseudo index */\n#define ispseudo(i)\t\t((i) <= LUA_REGISTRYINDEX)\n\n/* test for upvalue */\n#define isupvalue(i)\t\t((i) < LUA_REGISTRYINDEX)\n\n/* test for valid but not pseudo index */\n#define isstackindex(i, o)\t(isvalid(o) && !ispseudo(i))\n\n#define api_checkvalidindex(l,o)  api_check(l, isvalid(o), \"invalid index\")\n\n#define api_checkstackindex(l, i, o)  \\\n\tapi_check(l, isstackindex(i, o), \"index not in the stack\")\n\n\nstatic TValue *index2addr (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    TValue *o = ci->func + idx;\n    api_check(L, idx <= ci->top - (ci->func + 1), \"unacceptable index\");\n    if (o >= L->top) return NONVALIDVALUE;\n    else return o;\n  }\n  else if (!ispseudo(idx)) {  /* negative index */\n    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), \"invalid index\");\n    return L->top + idx;\n  }\n  else if (idx == LUA_REGISTRYINDEX)\n    return &G(L)->l_registry;\n  else {  /* upvalues */\n    idx = LUA_REGISTRYINDEX - idx;\n    api_check(L, idx <= MAXUPVAL + 1, \"upvalue index too large\");\n    if (ttislcf(ci->func))  /* light C function? */\n      return NONVALIDVALUE;  /* it has no upvalues */\n    else {\n      CClosure *func = clCvalue(ci->func);\n      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;\n    }\n  }\n}\n\n\n/*\n** to be called by 'lua_checkstack' in protected mode, to grow stack\n** capturing memory errors\n*/\nstatic void growstack (lua_State *L, void *ud) {\n  int size = *(int *)ud;\n  luaD_growstack(L, size);\n}\n\n\nLUA_API int lua_checkstack (lua_State *L, int n) {\n  int res;\n  CallInfo *ci = L->ci;\n  lua_lock(L);\n  api_check(L, n >= 0, \"negative 'n'\");\n  if (L->stack_last - L->top > n)  /* stack large enough? */\n    res = 1;  /* yes; check is OK */\n  else {  /* no; need to grow stack */\n    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;\n    if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */\n      res = 0;  /* no */\n    else  /* try to grow stack */\n      res = (luaD_rawrunprotected(L, &growstack, &n) == LUA_OK);\n  }\n  if (res && ci->top < L->top + n)\n    ci->top = L->top + n;  /* adjust frame top */\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {\n  int i;\n  if (from == to) return;\n  lua_lock(to);\n  api_checknelems(from, n);\n  api_check(from, G(from) == G(to), \"moving among independent states\");\n  api_check(from, to->ci->top - to->top >= n, \"stack overflow\");\n  from->top -= n;\n  for (i = 0; i < n; i++) {\n    setobj2s(to, to->top, from->top + i);\n    to->top++;  /* stack already checked by previous 'api_check' */\n  }\n  lua_unlock(to);\n}\n\n\nLUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {\n  lua_CFunction old;\n  lua_lock(L);\n  old = G(L)->panic;\n  G(L)->panic = panicf;\n  lua_unlock(L);\n  return old;\n}\n\n\nLUA_API const lua_Number *lua_version (lua_State *L) {\n  static const lua_Number version = LUA_VERSION_NUM;\n  if (L == NULL) return &version;\n  else return G(L)->version;\n}\n\n\n\n/*\n** basic stack manipulation\n*/\n\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nLUA_API int lua_absindex (lua_State *L, int idx) {\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top - L->ci->func) + idx;\n}\n\n\nLUA_API int lua_gettop (lua_State *L) {\n  return cast_int(L->top - (L->ci->func + 1));\n}\n\n\nLUA_API void lua_settop (lua_State *L, int idx) {\n  StkId func = L->ci->func;\n  lua_lock(L);\n  if (idx >= 0) {\n    api_check(L, idx <= L->stack_last - (func + 1), \"new top too large\");\n    while (L->top < (func + 1) + idx)\n      setnilvalue(L->top++);\n    L->top = (func + 1) + idx;\n  }\n  else {\n    api_check(L, -(idx+1) <= (L->top - (func + 1)), \"invalid new top\");\n    L->top += idx+1;  /* 'subtract' index (index is negative) */\n  }\n  lua_unlock(L);\n}\n\n\n/*\n** Reverse the stack segment from 'from' to 'to'\n** (auxiliary to 'lua_rotate')\n*/\nstatic void reverse (lua_State *L, StkId from, StkId to) {\n  for (; from < to; from++, to--) {\n    TValue temp;\n    setobj(L, &temp, from);\n    setobjs2s(L, from, to);\n    setobj2s(L, to, &temp);\n  }\n}\n\n\n/*\n** Let x = AB, where A is a prefix of length 'n'. Then,\n** rotate x n == BA. But BA == (A^r . B^r)^r.\n*/\nLUA_API void lua_rotate (lua_State *L, int idx, int n) {\n  StkId p, t, m;\n  lua_lock(L);\n  t = L->top - 1;  /* end of stack segment being rotated */\n  p = index2addr(L, idx);  /* start of segment */\n  api_checkstackindex(L, idx, p);\n  api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), \"invalid 'n'\");\n  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */\n  reverse(L, p, m);  /* reverse the prefix with length 'n' */\n  reverse(L, m + 1, t);  /* reverse the suffix */\n  reverse(L, p, t);  /* reverse the entire segment */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {\n  TValue *fr, *to;\n  lua_lock(L);\n  fr = index2addr(L, fromidx);\n  to = index2addr(L, toidx);\n  api_checkvalidindex(L, to);\n  setobj(L, to, fr);\n  if (isupvalue(toidx))  /* function upvalue? */\n    luaC_barrier(L, clCvalue(L->ci->func), fr);\n  /* LUA_REGISTRYINDEX does not need gc barrier\n     (collector revisits it before finishing collection) */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushvalue (lua_State *L, int idx) {\n  lua_lock(L);\n  setobj2s(L, L->top, index2addr(L, idx));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n\n/*\n** access functions (stack -> C)\n*/\n\n\nLUA_API int lua_type (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (isvalid(o) ? ttnov(o) : LUA_TNONE);\n}\n\n\nLUA_API const char *lua_typename (lua_State *L, int t) {\n  UNUSED(L);\n  api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, \"invalid tag\");\n  return ttypename(t);\n}\n\n\nLUA_API int lua_iscfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (ttislcf(o) || (ttisCclosure(o)));\n}\n\n\nLUA_API int lua_isinteger (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return ttisinteger(o);\n}\n\n\nLUA_API int lua_isnumber (lua_State *L, int idx) {\n  lua_Number n;\n  const TValue *o = index2addr(L, idx);\n  return tonumber(o, &n);\n}\n\n\nLUA_API int lua_isstring (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return (ttisstring(o) || cvt2str(o));\n}\n\n\nLUA_API int lua_isuserdata (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return (ttisfulluserdata(o) || ttislightuserdata(o));\n}\n\n\nLUA_API int lua_rawequal (lua_State *L, int index1, int index2) {\n  StkId o1 = index2addr(L, index1);\n  StkId o2 = index2addr(L, index2);\n  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;\n}\n\n\nLUA_API void lua_arith (lua_State *L, int op) {\n  lua_lock(L);\n  if (op != LUA_OPUNM && op != LUA_OPBNOT)\n    api_checknelems(L, 2);  /* all other operations expect two operands */\n  else {  /* for unary operations, add fake 2nd operand */\n    api_checknelems(L, 1);\n    setobjs2s(L, L->top, L->top - 1);\n    api_incr_top(L);\n  }\n  /* first operand at top - 2, second at top - 1; result go to top - 2 */\n  luaO_arith(L, op, L->top - 2, L->top - 1, L->top - 2);\n  L->top--;  /* remove second operand */\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {\n  StkId o1, o2;\n  int i = 0;\n  lua_lock(L);  /* may call tag method */\n  o1 = index2addr(L, index1);\n  o2 = index2addr(L, index2);\n  if (isvalid(o1) && isvalid(o2)) {\n    switch (op) {\n      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;\n      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;\n      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;\n      default: api_check(L, 0, \"invalid option\");\n    }\n  }\n  lua_unlock(L);\n  return i;\n}\n\n\nLUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {\n  size_t sz = luaO_str2num(s, L->top);\n  if (sz != 0)\n    api_incr_top(L);\n  return sz;\n}\n\n\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {\n  lua_Number n;\n  const TValue *o = index2addr(L, idx);\n  int isnum = tonumber(o, &n);\n  if (!isnum)\n    n = 0;  /* call to 'tonumber' may change 'n' even if it fails */\n  if (pisnum) *pisnum = isnum;\n  return n;\n}\n\n\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {\n  lua_Integer res;\n  const TValue *o = index2addr(L, idx);\n  int isnum = tointeger(o, &res);\n  if (!isnum)\n    res = 0;  /* call to 'tointeger' may change 'n' even if it fails */\n  if (pisnum) *pisnum = isnum;\n  return res;\n}\n\n\nLUA_API int lua_toboolean (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return !l_isfalse(o);\n}\n\n\nLUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {\n  StkId o = index2addr(L, idx);\n  if (!ttisstring(o)) {\n    if (!cvt2str(o)) {  /* not convertible? */\n      if (len != NULL) *len = 0;\n      return NULL;\n    }\n    lua_lock(L);  /* 'luaO_tostring' may create a new string */\n    luaO_tostring(L, o);\n    luaC_checkGC(L);\n    o = index2addr(L, idx);  /* previous call may reallocate the stack */\n    lua_unlock(L);\n  }\n  if (len != NULL)\n    *len = vslen(o);\n  return svalue(o);\n}\n\n\nLUA_API size_t lua_rawlen (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttype(o)) {\n    case LUA_TSHRSTR: return tsvalue(o)->shrlen;\n    case LUA_TLNGSTR: return tsvalue(o)->u.lnglen;\n    case LUA_TUSERDATA: return uvalue(o)->len;\n    case LUA_TTABLE: return luaH_getn(hvalue(o));\n    default: return 0;\n  }\n}\n\n\nLUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  if (ttislcf(o)) return fvalue(o);\n  else if (ttisCclosure(o))\n    return clCvalue(o)->f;\n  else return NULL;  /* not a C function */\n}\n\n\nLUA_API void *lua_touserdata (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttnov(o)) {\n    case LUA_TUSERDATA: return getudatamem(uvalue(o));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\nLUA_API lua_State *lua_tothread (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (!ttisthread(o)) ? NULL : thvalue(o);\n}\n\n\nLUA_API const void *lua_topointer (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttype(o)) {\n    case LUA_TTABLE: return hvalue(o);\n    case LUA_TLCL: return clLvalue(o);\n    case LUA_TCCL: return clCvalue(o);\n    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));\n    case LUA_TTHREAD: return thvalue(o);\n    case LUA_TUSERDATA: return getudatamem(uvalue(o));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\n\n/*\n** push functions (C -> stack)\n*/\n\n\nLUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n) {\n  lua_lock(L);\n  setfltvalue(L->top, n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {\n  lua_lock(L);\n  setivalue(L->top, n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n/*\n** Pushes on the stack a string with given length. Avoid using 's' when\n** 'len' == 0 (as 's' can be NULL in that case), due to later use of\n** 'memcmp' and 'memcpy'.\n*/\nLUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {\n  TString *ts;\n  lua_lock(L);\n  ts = (len == 0) ? luaS_new(L, \"\") : luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top, ts);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushstring (lua_State *L, const char *s) {\n  lua_lock(L);\n  if (s == NULL)\n    setnilvalue(L->top);\n  else {\n    TString *ts;\n    ts = luaS_new(L, s);\n    setsvalue2s(L, L->top, ts);\n    s = getstr(ts);  /* internal copy's address */\n  }\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return s;\n}\n\n\nLUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,\n                                      va_list argp) {\n  const char *ret;\n  lua_lock(L);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *ret;\n  va_list argp;\n  lua_lock(L);\n  va_start(argp, fmt);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {\n  lua_lock(L);\n  if (n == 0) {\n    setfvalue(L->top, fn);\n    api_incr_top(L);\n  }\n  else {\n    CClosure *cl;\n    api_checknelems(L, n);\n    api_check(L, n <= MAXUPVAL, \"upvalue index too large\");\n    cl = luaF_newCclosure(L, n);\n    cl->f = fn;\n    L->top -= n;\n    while (n--) {\n      setobj2n(L, &cl->upvalue[n], L->top + n);\n      /* does not need barrier because closure is white */\n    }\n    setclCvalue(L, L->top, cl);\n    api_incr_top(L);\n    luaC_checkGC(L);\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushboolean (lua_State *L, int b) {\n  lua_lock(L);\n  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(L->top, p);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_pushthread (lua_State *L) {\n  lua_lock(L);\n  setthvalue(L, L->top, L);\n  api_incr_top(L);\n  lua_unlock(L);\n  return (G(L)->mainthread == L);\n}\n\n\n\n/*\n** get functions (Lua -> stack)\n*/\n\n\nstatic int auxgetstr (lua_State *L, const TValue *t, const char *k) {\n  const TValue *slot;\n  TString *str = luaS_new(L, k);\n  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {\n    setobj2s(L, L->top, slot);\n    api_incr_top(L);\n  }\n  else {\n    setsvalue2s(L, L->top, str);\n    api_incr_top(L);\n    luaV_finishget(L, t, L->top - 1, L->top - 1, slot);\n  }\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_getglobal (lua_State *L, const char *name) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  lua_lock(L);\n  return auxgetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);\n}\n\n\nLUA_API int lua_gettable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_getfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);\n  return auxgetstr(L, index2addr(L, idx), k);\n}\n\n\nLUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {\n  StkId t;\n  const TValue *slot;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  if (luaV_fastget(L, t, n, slot, luaH_getint)) {\n    setobj2s(L, L->top, slot);\n    api_incr_top(L);\n  }\n  else {\n    setivalue(L->top, n);\n    api_incr_top(L);\n    luaV_finishget(L, t, L->top - 1, L->top - 1, slot);\n  }\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_rawget (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top, luaH_getint(hvalue(t), n));\n  api_incr_top(L);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {\n  StkId t;\n  TValue k;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  setobj2s(L, L->top, luaH_get(hvalue(t), &k));\n  api_incr_top(L);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\nLUA_API void lua_createtable (lua_State *L, int narray, int nrec) {\n  Table *t;\n  lua_lock(L);\n  t = luaH_new(L);\n  sethvalue(L, L->top, t);\n  api_incr_top(L);\n  if (narray > 0 || nrec > 0)\n    luaH_resize(L, t, narray, nrec);\n  luaC_checkGC(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_getmetatable (lua_State *L, int objindex) {\n  const TValue *obj;\n  Table *mt;\n  int res = 0;\n  lua_lock(L);\n  obj = index2addr(L, objindex);\n  switch (ttnov(obj)) {\n    case LUA_TTABLE:\n      mt = hvalue(obj)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(obj)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttnov(obj)];\n      break;\n  }\n  if (mt != NULL) {\n    sethvalue(L, L->top, mt);\n    api_incr_top(L);\n    res = 1;\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API int lua_getuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  o = index2addr(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  getuservalue(L, uvalue(o), L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n  return ttnov(L->top - 1);\n}\n\n\n/*\n** set functions (stack -> Lua)\n*/\n\n/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\nstatic void auxsetstr (lua_State *L, const TValue *t, const char *k) {\n  const TValue *slot;\n  TString *str = luaS_new(L, k);\n  api_checknelems(L, 1);\n  if (luaV_fastset(L, t, str, slot, luaH_getstr, L->top - 1))\n    L->top--;  /* pop value */\n  else {\n    setsvalue2s(L, L->top, str);  /* push 'str' (to make it a TValue) */\n    api_incr_top(L);\n    luaV_finishset(L, t, L->top - 1, L->top - 2, slot);\n    L->top -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);  /* lock done by caller */\n}\n\n\nLUA_API void lua_setglobal (lua_State *L, const char *name) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  auxsetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);\n}\n\n\nLUA_API void lua_settable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2addr(L, idx);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  auxsetstr(L, index2addr(L, idx), k);\n}\n\n\nLUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {\n  StkId t;\n  const TValue *slot;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  if (luaV_fastset(L, t, n, slot, luaH_getint, L->top - 1))\n    L->top--;  /* pop value */\n  else {\n    setivalue(L->top, n);\n    api_incr_top(L);\n    luaV_finishset(L, t, L->top - 1, L->top - 2, slot);\n    L->top -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawset (lua_State *L, int idx) {\n  StkId o;\n  TValue *slot;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  o = index2addr(L, idx);\n  api_check(L, ttistable(o), \"table expected\");\n  slot = luaH_set(L, hvalue(o), L->top - 2);\n  setobj2t(L, slot, L->top - 1);\n  invalidateTMcache(hvalue(o));\n  luaC_barrierback(L, hvalue(o), L->top-1);\n  L->top -= 2;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttistable(o), \"table expected\");\n  luaH_setint(L, hvalue(o), n, L->top - 1);\n  luaC_barrierback(L, hvalue(o), L->top-1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {\n  StkId o;\n  TValue k, *slot;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttistable(o), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  slot = luaH_set(L, hvalue(o), &k);\n  setobj2t(L, slot, L->top - 1);\n  luaC_barrierback(L, hvalue(o), L->top - 1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  obj = index2addr(L, objindex);\n  if (ttisnil(L->top - 1))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1), \"table expected\");\n    mt = hvalue(L->top - 1);\n  }\n  switch (ttnov(obj)) {\n    case LUA_TTABLE: {\n      hvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, gcvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, uvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    default: {\n      G(L)->mt[ttnov(obj)] = mt;\n      break;\n    }\n  }\n  L->top--;\n  lua_unlock(L);\n  return 1;\n}\n\n\nLUA_API void lua_setuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  setuservalue(L, uvalue(o), L->top - 1);\n  luaC_barrier(L, gcvalue(o), L->top - 1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\n/*\n** 'load' and 'call' functions (run Lua code)\n*/\n\n\n#define checkresults(L,na,nr) \\\n     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \\\n\t\"results from function overflow current stack size\")\n\n\nLUA_API void lua_callk (lua_State *L, int nargs, int nresults,\n                        lua_KContext ctx, lua_KFunction k) {\n  StkId func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  func = L->top - (nargs+1);\n  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */\n    L->ci->u.c.k = k;  /* save continuation */\n    L->ci->u.c.ctx = ctx;  /* save context */\n    luaD_call(L, func, nresults);  /* do the call */\n  }\n  else  /* no continuation or no yieldable */\n    luaD_callnoyield(L, func, nresults);  /* just do the call */\n  adjustresults(L, nresults);\n  lua_unlock(L);\n}\n\n\n\n/*\n** Execute a protected call.\n*/\nstruct CallS {  /* data to 'f_call' */\n  StkId func;\n  int nresults;\n};\n\n\nstatic void f_call (lua_State *L, void *ud) {\n  struct CallS *c = cast(struct CallS *, ud);\n  luaD_callnoyield(L, c->func, c->nresults);\n}\n\n\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2addr(L, errfunc);\n    api_checkstackindex(L, errfunc, o);\n    func = savestack(L, o);\n  }\n  c.func = L->top - (nargs+1);  /* function to be called */\n  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->extra = savestack(L, c.func);\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */\n    luaD_call(L, c.func, nresults);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,\n                      const char *chunkname, const char *mode) {\n  ZIO z;\n  int status;\n  lua_lock(L);\n  if (!chunkname) chunkname = \"?\";\n  luaZ_init(L, &z, reader, data);\n  status = luaD_protectedparser(L, &z, chunkname, mode);\n  if (status == LUA_OK) {  /* no errors? */\n    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */\n    if (f->nupvalues >= 1) {  /* does it have an upvalue? */\n      /* get global table from registry */\n      Table *reg = hvalue(&G(L)->l_registry);\n      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n      setobj(L, f->upvals[0]->v, gt);\n      luaC_upvalbarrier(L, f->upvals[0]);\n    }\n  }\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {\n  int status;\n  TValue *o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = L->top - 1;\n  if (isLfunction(o))\n    status = luaU_dump(L, getproto(o), writer, data, strip);\n  else\n    status = 1;\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_status (lua_State *L) {\n  return L->status;\n}\n\n\n/*\n** Garbage-collection function\n*/\n\nLUA_API int lua_gc (lua_State *L, int what, int data) {\n  int res = 0;\n  global_State *g;\n  lua_lock(L);\n  g = G(L);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->gcrunning = 0;\n      break;\n    }\n    case LUA_GCRESTART: {\n      luaE_setdebt(g, 0);\n      g->gcrunning = 1;\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L, 0);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(gettotalbytes(g) >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(gettotalbytes(g) & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      l_mem debt = 1;  /* =1 to signal that it did an actual step */\n      lu_byte oldrunning = g->gcrunning;\n      g->gcrunning = 1;  /* allow GC to run */\n      if (data == 0) {\n        luaE_setdebt(g, -GCSTEPSIZE);  /* to do a \"small\" step */\n        luaC_step(L);\n      }\n      else {  /* add 'data' to total debt */\n        debt = cast(l_mem, data) * 1024 + g->GCdebt;\n        luaE_setdebt(g, debt);\n        luaC_checkGC(L);\n      }\n      g->gcrunning = oldrunning;  /* restore previous state */\n      if (debt > 0 && g->gcstate == GCSpause)  /* end of cycle? */\n        res = 1;  /* signal it */\n      break;\n    }\n    case LUA_GCSETPAUSE: {\n      res = g->gcpause;\n      g->gcpause = data;\n      break;\n    }\n    case LUA_GCSETSTEPMUL: {\n      res = g->gcstepmul;\n      if (data < 40) data = 40;  /* avoid ridiculous low values (and 0) */\n      g->gcstepmul = data;\n      break;\n    }\n    case LUA_GCISRUNNING: {\n      res = g->gcrunning;\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\n\n/*\n** miscellaneous functions\n*/\n\n\nLUA_API int lua_error (lua_State *L) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}\n\n\nLUA_API int lua_next (lua_State *L, int idx) {\n  StkId t;\n  int more;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  more = luaH_next(L, hvalue(t), L->top - 1);\n  if (more) {\n    api_incr_top(L);\n  }\n  else  /* no more elements */\n    L->top -= 1;  /* remove key */\n  lua_unlock(L);\n  return more;\n}\n\n\nLUA_API void lua_concat (lua_State *L, int n) {\n  lua_lock(L);\n  api_checknelems(L, n);\n  if (n >= 2) {\n    luaV_concat(L, n);\n  }\n  else if (n == 0) {  /* push empty string */\n    setsvalue2s(L, L->top, luaS_newlstr(L, \"\", 0));\n    api_incr_top(L);\n  }\n  /* else n == 1; nothing to do */\n  luaC_checkGC(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_len (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_objlen(L, L->top, t);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {\n  lua_Alloc f;\n  lua_lock(L);\n  if (ud) *ud = G(L)->ud;\n  f = G(L)->frealloc;\n  lua_unlock(L);\n  return f;\n}\n\n\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {\n  lua_lock(L);\n  G(L)->ud = ud;\n  G(L)->frealloc = f;\n  lua_unlock(L);\n}\n\n\nLUA_API void *lua_newuserdata (lua_State *L, size_t size) {\n  Udata *u;\n  lua_lock(L);\n  u = luaS_newudata(L, size);\n  setuvalue(L, L->top, u);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getudatamem(u);\n}\n\n\n\nstatic const char *aux_upvalue (StkId fi, int n, TValue **val,\n                                CClosure **owner, UpVal **uv) {\n  switch (ttype(fi)) {\n    case LUA_TCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (!(1 <= n && n <= f->nupvalues)) return NULL;\n      *val = &f->upvalue[n-1];\n      if (owner) *owner = f;\n      return \"\";\n    }\n    case LUA_TLCL: {  /* Lua closure */\n      LClosure *f = clLvalue(fi);\n      TString *name;\n      Proto *p = f->p;\n      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;\n      *val = f->upvals[n-1]->v;\n      if (uv) *uv = f->upvals[n - 1];\n      name = p->upvalues[n-1].name;\n      return (name == NULL) ? \"(*no name)\" : getstr(name);\n    }\n    default: return NULL;  /* not a closure */\n  }\n}\n\n\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  lua_lock(L);\n  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL, NULL);\n  if (name) {\n    setobj2s(L, L->top, val);\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  CClosure *owner = NULL;\n  UpVal *uv = NULL;\n  StkId fi;\n  lua_lock(L);\n  fi = index2addr(L, funcindex);\n  api_checknelems(L, 1);\n  name = aux_upvalue(fi, n, &val, &owner, &uv);\n  if (name) {\n    L->top--;\n    setobj(L, val, L->top);\n    if (owner) { luaC_barrier(L, owner, L->top); }\n    else if (uv) { luaC_upvalbarrier(L, uv); }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic UpVal **getupvalref (lua_State *L, int fidx, int n) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  return &f->upvals[n - 1];  /* get its upvalue pointer */\n}\n\n\nLUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  /* lua closure */\n      return *getupvalref(L, fidx, n);\n    }\n    case LUA_TCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}\n\n\nLUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  UpVal **up1 = getupvalref(L, fidx1, n1);\n  UpVal **up2 = getupvalref(L, fidx2, n2);\n  if (*up1 == *up2)\n    return;\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}\n\n\n", "# makefile for building Lua\n# see INSTALL for installation instructions\n# see ../Makefile and luaconf.h for further customization\n\n# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================\n\n# Warnings valid for both C and C++\nCWARNSCPP= \\\n\t-pedantic \\\n\t-Wextra \\\n\t-Wshadow \\\n\t-Wsign-compare \\\n\t-Wundef \\\n\t-Wwrite-strings \\\n\t-Wredundant-decls \\\n\t-Wdisabled-optimization \\\n\t-Waggregate-return \\\n\t-Wdouble-promotion \\\n\t#-Wno-aggressive-loop-optimizations   # not accepted by clang \\\n\t#-Wlogical-op   # not accepted by clang \\\n\t# the next warnings generate too much noise, so they are disabled\n\t# -Wconversion  -Wno-sign-conversion \\\n\t# -Wsign-conversion \\\n\t# -Wconversion \\\n\t# -Wstrict-overflow=2 \\\n\t# -Wformat=2 \\\n\t# -Wcast-qual \\\n\n# The next warnings are neither valid nor needed for C++\nCWARNSC= -Wdeclaration-after-statement \\\n\t-Wmissing-prototypes \\\n\t-Wnested-externs \\\n\t-Wstrict-prototypes \\\n\t-Wc++-compat \\\n\t-Wold-style-definition \\\n\n\nCWARNS= $(CWARNSCPP)  $(CWARNSC)\n\n\n# -DEXTERNMEMCHECK -DHARDSTACKTESTS -DHARDMEMTESTS -DTRACEMEM='\"tempmem\"'\n# -g -DLUA_USER_H='\"ltests.h\"'\n# -pg -malign-double\n# -DLUA_USE_CTYPE -DLUA_USE_APICHECK\n# (in clang, '-ftrapv' for runtime checks of integer overflows)\n# -fsanitize=undefined -ftrapv\nTESTS= -DLUA_USER_H='\"ltests.h\"'\n\n# -mtune=native -fomit-frame-pointer\n# -fno-stack-protector\nLOCAL = $(TESTS) $(CWARNS) -g\n\n\n\n# enable Linux goodies\nMYCFLAGS= $(LOCAL) -std=c99 -DLUA_USE_LINUX -DLUA_COMPAT_5_2\nMYLDFLAGS= $(LOCAL) -Wl,-E\nMYLIBS= -ldl -lreadline\n\n\nCC= gcc\nCFLAGS= -Wall -O2 $(MYCFLAGS)\nAR= ar rc\nRANLIB= ranlib\nRM= rm -f\n\n\n\n# == END OF USER SETTINGS. NO NEED TO CHANGE ANYTHING BELOW THIS LINE =========\n\n\nLIBS = -lm\n\nCORE_T=\tliblua.a\nCORE_O=\tlapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \\\n\tlmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o \\\n\tltm.o lundump.o lvm.o lzio.o ltests.o\nAUX_O=\tlauxlib.o\nLIB_O=\tlbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o \\\n\tlutf8lib.o lbitlib.o loadlib.o lcorolib.o linit.o\n\nLUA_T=\tlua\nLUA_O=\tlua.o\n\n# LUAC_T=\tluac\n# LUAC_O=\tluac.o print.o\n\nALL_T= $(CORE_T) $(LUA_T) $(LUAC_T)\nALL_O= $(CORE_O) $(LUA_O) $(LUAC_O) $(AUX_O) $(LIB_O)\nALL_A= $(CORE_T)\n\nall:\t$(ALL_T)\n\no:\t$(ALL_O)\n\na:\t$(ALL_A)\n\n$(CORE_T): $(CORE_O) $(AUX_O) $(LIB_O)\n\t$(AR) $@ $?\n\t$(RANLIB) $@\n\n$(LUA_T): $(LUA_O) $(CORE_T)\n\t$(CC) -o $@ $(MYLDFLAGS) $(LUA_O) $(CORE_T) $(LIBS) $(MYLIBS) $(DL)\n\n$(LUAC_T): $(LUAC_O) $(CORE_T)\n\t$(CC) -o $@ $(MYLDFLAGS) $(LUAC_O) $(CORE_T) $(LIBS) $(MYLIBS)\n\nclean:\n\trcsclean -u\n\t$(RM) $(ALL_T) $(ALL_O)\n\ndepend:\n\t@$(CC) $(CFLAGS) -MM *.c\n\necho:\n\t@echo \"CC = $(CC)\"\n\t@echo \"CFLAGS = $(CFLAGS)\"\n\t@echo \"AR = $(AR)\"\n\t@echo \"RANLIB = $(RANLIB)\"\n\t@echo \"RM = $(RM)\"\n\t@echo \"MYCFLAGS = $(MYCFLAGS)\"\n\t@echo \"MYLDFLAGS = $(MYLDFLAGS)\"\n\t@echo \"MYLIBS = $(MYLIBS)\"\n\t@echo \"DL = $(DL)\"\n\n$(ALL_O): makefile\n\n# DO NOT EDIT\n# automatically made with 'gcc -MM l*.c'\n\nlapi.o: lapi.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lstring.h \\\n ltable.h lundump.h lvm.h\nlauxlib.o: lauxlib.c lprefix.h lua.h luaconf.h lauxlib.h\nlbaselib.o: lbaselib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlbitlib.o: lbitlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlcode.o: lcode.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \\\n llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \\\n ldo.h lgc.h lstring.h ltable.h lvm.h\nlcorolib.o: lcorolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlctype.o: lctype.c lprefix.h lctype.h lua.h luaconf.h llimits.h\nldblib.o: ldblib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nldebug.o: ldebug.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lcode.h llex.h lopcodes.h lparser.h \\\n ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h\nldo.o: ldo.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \\\n lparser.h lstring.h ltable.h lundump.h lvm.h\nldump.o: ldump.c lprefix.h lua.h luaconf.h lobject.h llimits.h lstate.h \\\n ltm.h lzio.h lmem.h lundump.h\nlfunc.o: lfunc.c lprefix.h lua.h luaconf.h lfunc.h lobject.h llimits.h \\\n lgc.h lstate.h ltm.h lzio.h lmem.h\nlgc.o: lgc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h\nlinit.o: linit.c lprefix.h lua.h luaconf.h lualib.h lauxlib.h\nliolib.o: liolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nllex.o: llex.c lprefix.h lua.h luaconf.h lctype.h llimits.h ldebug.h \\\n lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lgc.h llex.h lparser.h \\\n lstring.h ltable.h\nlmathlib.o: lmathlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlmem.o: lmem.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h\nloadlib.o: loadlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlobject.o: lobject.c lprefix.h lua.h luaconf.h lctype.h llimits.h \\\n ldebug.h lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h \\\n lvm.h\nlopcodes.o: lopcodes.c lprefix.h lopcodes.h llimits.h lua.h luaconf.h\nloslib.o: loslib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlparser.o: lparser.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \\\n llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \\\n ldo.h lfunc.h lstring.h lgc.h ltable.h\nlstate.o: lstate.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h llex.h \\\n lstring.h ltable.h\nlstring.o: lstring.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \\\n lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h\nlstrlib.o: lstrlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nltable.o: ltable.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h\nltablib.o: ltablib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nltests.o: ltests.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lauxlib.h lcode.h llex.h lopcodes.h \\\n lparser.h lctype.h ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h \\\n lualib.h\nltm.o: ltm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h ltable.h lvm.h\nlua.o: lua.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlundump.o: lundump.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \\\n lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h \\\n lundump.h\nlutf8lib.o: lutf8lib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h\nlvm.o: lvm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h \\\n ltable.h lvm.h\nlzio.o: lzio.c lprefix.h lua.h luaconf.h llimits.h lmem.h lstate.h \\\n lobject.h ltm.h lzio.h\n\n# (end of Makefile)\n"], "filenames": ["bugs", "lapi.c", "makefile"], "buggy_code_start_loc": [360, 1257, 61], "buggy_code_end_loc": [4117, 1292, 64], "fixing_code_start_loc": [360, 1257, 61], "fixing_code_end_loc": [4119, 1292, 64], "type": "CWE-416", "message": "Lua 5.3.5 has a use-after-free in lua_upvaluejoin in lapi.c. For example, a crash outcome might be achieved by an attacker who is able to trigger a debug.upvaluejoin call in which the arguments have certain relationships.", "other": {"cve": {"id": "CVE-2019-6706", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-23T19:29:00.447", "lastModified": "2022-11-08T13:18:42.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Lua 5.3.5 has a use-after-free in lua_upvaluejoin in lapi.c. For example, a crash outcome might be achieved by an attacker who is able to trigger a debug.upvaluejoin call in which the arguments have certain relationships."}, {"lang": "es", "value": "Lua 5.3.5 tiene un uso de memoria previamente liberada en lua_upvaluejoin en lapi.c. Por ejemplo, un atacante podr\u00eda lograr un cierre inesperado al desencadenar una llamada debug.upvaluejoin en la que los argumentos tienen ciertas relaciones."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:5.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "B1D6D7F5-0738-45EB-A4F2-9A65F8DD2D0A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "http://lua-users.org/lists/lua-l/2019-01/msg00039.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://packetstormsecurity.com/files/151335/Lua-5.3.5-Use-After-Free.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/security/cve/cve-2019-6706", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Lua-Project/cve-analysis/blob/a43c9ccd00274b31fa2f24c6c8f20ce36655682d/CVE-2019-6706.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/lua/lua/commit/89aee84cbc9224f638f3b7951b306d2ee8ecb71e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lua/lua/commit/89aee84cbc9224f638f3b7951b306d2ee8ecb71e"}}