{"buggy_code": ["// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage cmd\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/fcgi\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/go-macaron/binding\"\n\t\"github.com/go-macaron/cache\"\n\t\"github.com/go-macaron/captcha\"\n\t\"github.com/go-macaron/csrf\"\n\t\"github.com/go-macaron/gzip\"\n\t\"github.com/go-macaron/i18n\"\n\t\"github.com/go-macaron/session\"\n\t\"github.com/go-macaron/toolbox\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/unknwon/com\"\n\t\"github.com/urfave/cli\"\n\t\"gopkg.in/macaron.v1\"\n\tlog \"unknwon.dev/clog/v2\"\n\n\t\"gogs.io/gogs/internal/app\"\n\t\"gogs.io/gogs/internal/assets/public\"\n\t\"gogs.io/gogs/internal/assets/templates\"\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/osutil\"\n\t\"gogs.io/gogs/internal/route\"\n\t\"gogs.io/gogs/internal/route/admin\"\n\tapiv1 \"gogs.io/gogs/internal/route/api/v1\"\n\t\"gogs.io/gogs/internal/route/dev\"\n\t\"gogs.io/gogs/internal/route/lfs\"\n\t\"gogs.io/gogs/internal/route/org\"\n\t\"gogs.io/gogs/internal/route/repo\"\n\t\"gogs.io/gogs/internal/route/user\"\n\t\"gogs.io/gogs/internal/template\"\n)\n\nvar Web = cli.Command{\n\tName:  \"web\",\n\tUsage: \"Start web server\",\n\tDescription: `Gogs web server is the only thing you need to run,\nand it takes care of all the other things for you`,\n\tAction: runWeb,\n\tFlags: []cli.Flag{\n\t\tstringFlag(\"port, p\", \"3000\", \"Temporary port number to prevent conflict\"),\n\t\tstringFlag(\"config, c\", \"\", \"Custom configuration file path\"),\n\t},\n}\n\n// newMacaron initializes Macaron instance.\nfunc newMacaron() *macaron.Macaron {\n\tm := macaron.New()\n\tif !conf.Server.DisableRouterLog {\n\t\tm.Use(macaron.Logger())\n\t}\n\tm.Use(macaron.Recovery())\n\tif conf.Server.EnableGzip {\n\t\tm.Use(gzip.Gziper())\n\t}\n\tif conf.Server.Protocol == \"fcgi\" {\n\t\tm.SetURLPrefix(conf.Server.Subpath)\n\t}\n\n\t// Register custom middleware first to make it possible to override files under \"public\".\n\tm.Use(macaron.Static(\n\t\tfilepath.Join(conf.CustomDir(), \"public\"),\n\t\tmacaron.StaticOptions{\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t},\n\t))\n\tvar publicFs http.FileSystem\n\tif !conf.Server.LoadAssetsFromDisk {\n\t\tpublicFs = public.NewFileSystem()\n\t}\n\tm.Use(macaron.Static(\n\t\tfilepath.Join(conf.WorkDir(), \"public\"),\n\t\tmacaron.StaticOptions{\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t\tFileSystem:  publicFs,\n\t\t},\n\t))\n\n\tm.Use(macaron.Static(\n\t\tconf.Picture.AvatarUploadPath,\n\t\tmacaron.StaticOptions{\n\t\t\tPrefix:      db.USER_AVATAR_URL_PREFIX,\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t},\n\t))\n\tm.Use(macaron.Static(\n\t\tconf.Picture.RepositoryAvatarUploadPath,\n\t\tmacaron.StaticOptions{\n\t\t\tPrefix:      db.REPO_AVATAR_URL_PREFIX,\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t},\n\t))\n\n\trenderOpt := macaron.RenderOptions{\n\t\tDirectory:         filepath.Join(conf.WorkDir(), \"templates\"),\n\t\tAppendDirectories: []string{filepath.Join(conf.CustomDir(), \"templates\")},\n\t\tFuncs:             template.FuncMap(),\n\t\tIndentJSON:        macaron.Env != macaron.PROD,\n\t}\n\tif !conf.Server.LoadAssetsFromDisk {\n\t\trenderOpt.TemplateFileSystem = templates.NewTemplateFileSystem(\"\", renderOpt.AppendDirectories[0])\n\t}\n\tm.Use(macaron.Renderer(renderOpt))\n\n\tlocaleNames, err := conf.AssetDir(\"conf/locale\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to list locale files: %v\", err)\n\t}\n\tlocaleFiles := make(map[string][]byte)\n\tfor _, name := range localeNames {\n\t\tlocaleFiles[name] = conf.MustAsset(\"conf/locale/\" + name)\n\t}\n\tm.Use(i18n.I18n(i18n.Options{\n\t\tSubURL:          conf.Server.Subpath,\n\t\tFiles:           localeFiles,\n\t\tCustomDirectory: filepath.Join(conf.CustomDir(), \"conf\", \"locale\"),\n\t\tLangs:           conf.I18n.Langs,\n\t\tNames:           conf.I18n.Names,\n\t\tDefaultLang:     \"en-US\",\n\t\tRedirect:        true,\n\t}))\n\tm.Use(cache.Cacher(cache.Options{\n\t\tAdapter:       conf.Cache.Adapter,\n\t\tAdapterConfig: conf.Cache.Host,\n\t\tInterval:      conf.Cache.Interval,\n\t}))\n\tm.Use(captcha.Captchaer(captcha.Options{\n\t\tSubURL: conf.Server.Subpath,\n\t}))\n\tm.Use(toolbox.Toolboxer(m, toolbox.Options{\n\t\tHealthCheckFuncs: []*toolbox.HealthCheckFuncDesc{\n\t\t\t{\n\t\t\t\tDesc: \"Database connection\",\n\t\t\t\tFunc: db.Ping,\n\t\t\t},\n\t\t},\n\t}))\n\treturn m\n}\n\nfunc runWeb(c *cli.Context) error {\n\terr := route.GlobalInit(c.String(\"config\"))\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to initialize application: %v\", err)\n\t}\n\n\tm := newMacaron()\n\n\treqSignIn := context.Toggle(&context.ToggleOptions{SignInRequired: true})\n\tignSignIn := context.Toggle(&context.ToggleOptions{SignInRequired: conf.Auth.RequireSigninView})\n\treqSignOut := context.Toggle(&context.ToggleOptions{SignOutRequired: true})\n\n\tbindIgnErr := binding.BindIgnErr\n\n\tm.SetAutoHead(true)\n\n\tm.Group(\"\", func() {\n\t\tm.Get(\"/\", ignSignIn, route.Home)\n\t\tm.Group(\"/explore\", func() {\n\t\t\tm.Get(\"\", func(c *context.Context) {\n\t\t\t\tc.Redirect(conf.Server.Subpath + \"/explore/repos\")\n\t\t\t})\n\t\t\tm.Get(\"/repos\", route.ExploreRepos)\n\t\t\tm.Get(\"/users\", route.ExploreUsers)\n\t\t\tm.Get(\"/organizations\", route.ExploreOrganizations)\n\t\t}, ignSignIn)\n\t\tm.Combo(\"/install\", route.InstallInit).Get(route.Install).\n\t\t\tPost(bindIgnErr(form.Install{}), route.InstallPost)\n\t\tm.Get(\"/^:type(issues|pulls)$\", reqSignIn, user.Issues)\n\n\t\t// ***** START: User *****\n\t\tm.Group(\"/user\", func() {\n\t\t\tm.Group(\"/login\", func() {\n\t\t\t\tm.Combo(\"\").Get(user.Login).\n\t\t\t\t\tPost(bindIgnErr(form.SignIn{}), user.LoginPost)\n\t\t\t\tm.Combo(\"/two_factor\").Get(user.LoginTwoFactor).Post(user.LoginTwoFactorPost)\n\t\t\t\tm.Combo(\"/two_factor_recovery_code\").Get(user.LoginTwoFactorRecoveryCode).Post(user.LoginTwoFactorRecoveryCodePost)\n\t\t\t})\n\n\t\t\tm.Get(\"/sign_up\", user.SignUp)\n\t\t\tm.Post(\"/sign_up\", bindIgnErr(form.Register{}), user.SignUpPost)\n\t\t\tm.Get(\"/reset_password\", user.ResetPasswd)\n\t\t\tm.Post(\"/reset_password\", user.ResetPasswdPost)\n\t\t}, reqSignOut)\n\n\t\tm.Group(\"/user/settings\", func() {\n\t\t\tm.Get(\"\", user.Settings)\n\t\t\tm.Post(\"\", bindIgnErr(form.UpdateProfile{}), user.SettingsPost)\n\t\t\tm.Combo(\"/avatar\").Get(user.SettingsAvatar).\n\t\t\t\tPost(binding.MultipartForm(form.Avatar{}), user.SettingsAvatarPost)\n\t\t\tm.Post(\"/avatar/delete\", user.SettingsDeleteAvatar)\n\t\t\tm.Combo(\"/email\").Get(user.SettingsEmails).\n\t\t\t\tPost(bindIgnErr(form.AddEmail{}), user.SettingsEmailPost)\n\t\t\tm.Post(\"/email/delete\", user.DeleteEmail)\n\t\t\tm.Get(\"/password\", user.SettingsPassword)\n\t\t\tm.Post(\"/password\", bindIgnErr(form.ChangePassword{}), user.SettingsPasswordPost)\n\t\t\tm.Combo(\"/ssh\").Get(user.SettingsSSHKeys).\n\t\t\t\tPost(bindIgnErr(form.AddSSHKey{}), user.SettingsSSHKeysPost)\n\t\t\tm.Post(\"/ssh/delete\", user.DeleteSSHKey)\n\t\t\tm.Group(\"/security\", func() {\n\t\t\t\tm.Get(\"\", user.SettingsSecurity)\n\t\t\t\tm.Combo(\"/two_factor_enable\").Get(user.SettingsTwoFactorEnable).\n\t\t\t\t\tPost(user.SettingsTwoFactorEnablePost)\n\t\t\t\tm.Combo(\"/two_factor_recovery_codes\").Get(user.SettingsTwoFactorRecoveryCodes).\n\t\t\t\t\tPost(user.SettingsTwoFactorRecoveryCodesPost)\n\t\t\t\tm.Post(\"/two_factor_disable\", user.SettingsTwoFactorDisable)\n\t\t\t})\n\t\t\tm.Group(\"/repositories\", func() {\n\t\t\t\tm.Get(\"\", user.SettingsRepos)\n\t\t\t\tm.Post(\"/leave\", user.SettingsLeaveRepo)\n\t\t\t})\n\t\t\tm.Group(\"/organizations\", func() {\n\t\t\t\tm.Get(\"\", user.SettingsOrganizations)\n\t\t\t\tm.Post(\"/leave\", user.SettingsLeaveOrganization)\n\t\t\t})\n\t\t\tm.Combo(\"/applications\").Get(user.SettingsApplications).\n\t\t\t\tPost(bindIgnErr(form.NewAccessToken{}), user.SettingsApplicationsPost)\n\t\t\tm.Post(\"/applications/delete\", user.SettingsDeleteApplication)\n\t\t\tm.Route(\"/delete\", \"GET,POST\", user.SettingsDelete)\n\t\t}, reqSignIn, func(c *context.Context) {\n\t\t\tc.Data[\"PageIsUserSettings\"] = true\n\t\t})\n\n\t\tm.Group(\"/user\", func() {\n\t\t\tm.Any(\"/activate\", user.Activate)\n\t\t\tm.Any(\"/activate_email\", user.ActivateEmail)\n\t\t\tm.Get(\"/email2user\", user.Email2User)\n\t\t\tm.Get(\"/forget_password\", user.ForgotPasswd)\n\t\t\tm.Post(\"/forget_password\", user.ForgotPasswdPost)\n\t\t\tm.Post(\"/logout\", user.SignOut)\n\t\t})\n\t\t// ***** END: User *****\n\n\t\treqAdmin := context.Toggle(&context.ToggleOptions{SignInRequired: true, AdminRequired: true})\n\n\t\t// ***** START: Admin *****\n\t\tm.Group(\"/admin\", func() {\n\t\t\tm.Combo(\"\").Get(admin.Dashboard).Post(admin.Operation) // \"/admin\"\n\t\t\tm.Get(\"/config\", admin.Config)\n\t\t\tm.Post(\"/config/test_mail\", admin.SendTestMail)\n\t\t\tm.Get(\"/monitor\", admin.Monitor)\n\n\t\t\tm.Group(\"/users\", func() {\n\t\t\t\tm.Get(\"\", admin.Users)\n\t\t\t\tm.Combo(\"/new\").Get(admin.NewUser).Post(bindIgnErr(form.AdminCrateUser{}), admin.NewUserPost)\n\t\t\t\tm.Combo(\"/:userid\").Get(admin.EditUser).Post(bindIgnErr(form.AdminEditUser{}), admin.EditUserPost)\n\t\t\t\tm.Post(\"/:userid/delete\", admin.DeleteUser)\n\t\t\t})\n\n\t\t\tm.Group(\"/orgs\", func() {\n\t\t\t\tm.Get(\"\", admin.Organizations)\n\t\t\t})\n\n\t\t\tm.Group(\"/repos\", func() {\n\t\t\t\tm.Get(\"\", admin.Repos)\n\t\t\t\tm.Post(\"/delete\", admin.DeleteRepo)\n\t\t\t})\n\n\t\t\tm.Group(\"/auths\", func() {\n\t\t\t\tm.Get(\"\", admin.Authentications)\n\t\t\t\tm.Combo(\"/new\").Get(admin.NewAuthSource).Post(bindIgnErr(form.Authentication{}), admin.NewAuthSourcePost)\n\t\t\t\tm.Combo(\"/:authid\").Get(admin.EditAuthSource).\n\t\t\t\t\tPost(bindIgnErr(form.Authentication{}), admin.EditAuthSourcePost)\n\t\t\t\tm.Post(\"/:authid/delete\", admin.DeleteAuthSource)\n\t\t\t})\n\n\t\t\tm.Group(\"/notices\", func() {\n\t\t\t\tm.Get(\"\", admin.Notices)\n\t\t\t\tm.Post(\"/delete\", admin.DeleteNotices)\n\t\t\t\tm.Get(\"/empty\", admin.EmptyNotices)\n\t\t\t})\n\t\t}, reqAdmin)\n\t\t// ***** END: Admin *****\n\n\t\tm.Group(\"\", func() {\n\t\t\tm.Group(\"/:username\", func() {\n\t\t\t\tm.Get(\"\", user.Profile)\n\t\t\t\tm.Get(\"/followers\", user.Followers)\n\t\t\t\tm.Get(\"/following\", user.Following)\n\t\t\t\tm.Get(\"/stars\", user.Stars)\n\t\t\t}, context.InjectParamsUser())\n\n\t\t\tm.Get(\"/attachments/:uuid\", func(c *context.Context) {\n\t\t\t\tattach, err := db.GetAttachmentByUUID(c.Params(\":uuid\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.NotFoundOrError(err, \"get attachment by UUID\")\n\t\t\t\t\treturn\n\t\t\t\t} else if !com.IsFile(attach.LocalPath()) {\n\t\t\t\t\tc.NotFound()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfr, err := os.Open(attach.LocalPath())\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Error(err, \"open attachment file\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdefer fr.Close()\n\n\t\t\t\tc.Header().Set(\"Cache-Control\", \"public,max-age=86400\")\n\t\t\t\tc.Header().Set(\"Content-Disposition\", fmt.Sprintf(`inline; filename=\"%s\"`, attach.Name))\n\n\t\t\t\tif _, err = io.Copy(c.Resp, fr); err != nil {\n\t\t\t\t\tc.Error(err, \"copy from file to response\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t\tm.Post(\"/issues/attachments\", repo.UploadIssueAttachment)\n\t\t\tm.Post(\"/releases/attachments\", repo.UploadReleaseAttachment)\n\t\t}, ignSignIn)\n\n\t\tm.Group(\"/:username\", func() {\n\t\t\tm.Post(\"/action/:action\", user.Action)\n\t\t}, reqSignIn, context.InjectParamsUser())\n\n\t\tif macaron.Env == macaron.DEV {\n\t\t\tm.Get(\"/template/*\", dev.TemplatePreview)\n\t\t}\n\n\t\treqRepoAdmin := context.RequireRepoAdmin()\n\t\treqRepoWriter := context.RequireRepoWriter()\n\n\t\twebhookRoutes := func() {\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"\", repo.Webhooks)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteWebhook)\n\t\t\t\tm.Get(\"/:type/new\", repo.WebhooksNew)\n\t\t\t\tm.Post(\"/gogs/new\", bindIgnErr(form.NewWebhook{}), repo.WebhooksNewPost)\n\t\t\t\tm.Post(\"/slack/new\", bindIgnErr(form.NewSlackHook{}), repo.WebhooksSlackNewPost)\n\t\t\t\tm.Post(\"/discord/new\", bindIgnErr(form.NewDiscordHook{}), repo.WebhooksDiscordNewPost)\n\t\t\t\tm.Post(\"/dingtalk/new\", bindIgnErr(form.NewDingtalkHook{}), repo.WebhooksDingtalkNewPost)\n\t\t\t\tm.Get(\"/:id\", repo.WebhooksEdit)\n\t\t\t\tm.Post(\"/gogs/:id\", bindIgnErr(form.NewWebhook{}), repo.WebhooksEditPost)\n\t\t\t\tm.Post(\"/slack/:id\", bindIgnErr(form.NewSlackHook{}), repo.WebhooksSlackEditPost)\n\t\t\t\tm.Post(\"/discord/:id\", bindIgnErr(form.NewDiscordHook{}), repo.WebhooksDiscordEditPost)\n\t\t\t\tm.Post(\"/dingtalk/:id\", bindIgnErr(form.NewDingtalkHook{}), repo.WebhooksDingtalkEditPost)\n\t\t\t}, repo.InjectOrgRepoContext())\n\t\t}\n\n\t\t// ***** START: Organization *****\n\t\tm.Group(\"/org\", func() {\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"/create\", org.Create)\n\t\t\t\tm.Post(\"/create\", bindIgnErr(form.CreateOrg{}), org.CreatePost)\n\t\t\t}, func(c *context.Context) {\n\t\t\t\tif !c.User.CanCreateOrganization() {\n\t\t\t\t\tc.NotFound()\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tm.Group(\"/:org\", func() {\n\t\t\t\tm.Get(\"/dashboard\", user.Dashboard)\n\t\t\t\tm.Get(\"/^:type(issues|pulls)$\", user.Issues)\n\t\t\t\tm.Get(\"/members\", org.Members)\n\t\t\t\tm.Get(\"/members/action/:action\", org.MembersAction)\n\n\t\t\t\tm.Get(\"/teams\", org.Teams)\n\t\t\t}, context.OrgAssignment(true))\n\n\t\t\tm.Group(\"/:org\", func() {\n\t\t\t\tm.Get(\"/teams/:team\", org.TeamMembers)\n\t\t\t\tm.Get(\"/teams/:team/repositories\", org.TeamRepositories)\n\t\t\t\tm.Route(\"/teams/:team/action/:action\", \"GET,POST\", org.TeamsAction)\n\t\t\t\tm.Route(\"/teams/:team/action/repo/:action\", \"GET,POST\", org.TeamsRepoAction)\n\t\t\t}, context.OrgAssignment(true, false, true))\n\n\t\t\tm.Group(\"/:org\", func() {\n\t\t\t\tm.Get(\"/teams/new\", org.NewTeam)\n\t\t\t\tm.Post(\"/teams/new\", bindIgnErr(form.CreateTeam{}), org.NewTeamPost)\n\t\t\t\tm.Get(\"/teams/:team/edit\", org.EditTeam)\n\t\t\t\tm.Post(\"/teams/:team/edit\", bindIgnErr(form.CreateTeam{}), org.EditTeamPost)\n\t\t\t\tm.Post(\"/teams/:team/delete\", org.DeleteTeam)\n\n\t\t\t\tm.Group(\"/settings\", func() {\n\t\t\t\t\tm.Combo(\"\").Get(org.Settings).\n\t\t\t\t\t\tPost(bindIgnErr(form.UpdateOrgSetting{}), org.SettingsPost)\n\t\t\t\t\tm.Post(\"/avatar\", binding.MultipartForm(form.Avatar{}), org.SettingsAvatar)\n\t\t\t\t\tm.Post(\"/avatar/delete\", org.SettingsDeleteAvatar)\n\t\t\t\t\tm.Group(\"/hooks\", webhookRoutes)\n\t\t\t\t\tm.Route(\"/delete\", \"GET,POST\", org.SettingsDelete)\n\t\t\t\t})\n\n\t\t\t\tm.Route(\"/invitations/new\", \"GET,POST\", org.Invitation)\n\t\t\t}, context.OrgAssignment(true, true))\n\t\t}, reqSignIn)\n\t\t// ***** END: Organization *****\n\n\t\t// ***** START: Repository *****\n\t\tm.Group(\"/repo\", func() {\n\t\t\tm.Get(\"/create\", repo.Create)\n\t\t\tm.Post(\"/create\", bindIgnErr(form.CreateRepo{}), repo.CreatePost)\n\t\t\tm.Get(\"/migrate\", repo.Migrate)\n\t\t\tm.Post(\"/migrate\", bindIgnErr(form.MigrateRepo{}), repo.MigratePost)\n\t\t\tm.Combo(\"/fork/:repoid\").Get(repo.Fork).\n\t\t\t\tPost(bindIgnErr(form.CreateRepo{}), repo.ForkPost)\n\t\t}, reqSignIn)\n\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Group(\"/settings\", func() {\n\t\t\t\tm.Combo(\"\").Get(repo.Settings).\n\t\t\t\t\tPost(bindIgnErr(form.RepoSetting{}), repo.SettingsPost)\n\t\t\t\tm.Combo(\"/avatar\").Get(repo.SettingsAvatar).\n\t\t\t\t\tPost(binding.MultipartForm(form.Avatar{}), repo.SettingsAvatarPost)\n\t\t\t\tm.Post(\"/avatar/delete\", repo.SettingsDeleteAvatar)\n\t\t\t\tm.Group(\"/collaboration\", func() {\n\t\t\t\t\tm.Combo(\"\").Get(repo.SettingsCollaboration).Post(repo.SettingsCollaborationPost)\n\t\t\t\t\tm.Post(\"/access_mode\", repo.ChangeCollaborationAccessMode)\n\t\t\t\t\tm.Post(\"/delete\", repo.DeleteCollaboration)\n\t\t\t\t})\n\t\t\t\tm.Group(\"/branches\", func() {\n\t\t\t\t\tm.Get(\"\", repo.SettingsBranches)\n\t\t\t\t\tm.Post(\"/default_branch\", repo.UpdateDefaultBranch)\n\t\t\t\t\tm.Combo(\"/*\").Get(repo.SettingsProtectedBranch).\n\t\t\t\t\t\tPost(bindIgnErr(form.ProtectBranch{}), repo.SettingsProtectedBranchPost)\n\t\t\t\t}, func(c *context.Context) {\n\t\t\t\t\tif c.Repo.Repository.IsMirror {\n\t\t\t\t\t\tc.NotFound()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tm.Group(\"/hooks\", func() {\n\t\t\t\t\twebhookRoutes()\n\n\t\t\t\t\tm.Group(\"/:id\", func() {\n\t\t\t\t\t\tm.Post(\"/test\", repo.TestWebhook)\n\t\t\t\t\t\tm.Post(\"/redelivery\", repo.RedeliveryWebhook)\n\t\t\t\t\t})\n\n\t\t\t\t\tm.Group(\"/git\", func() {\n\t\t\t\t\t\tm.Get(\"\", repo.SettingsGitHooks)\n\t\t\t\t\t\tm.Combo(\"/:name\").Get(repo.SettingsGitHooksEdit).\n\t\t\t\t\t\t\tPost(repo.SettingsGitHooksEditPost)\n\t\t\t\t\t}, context.GitHookService())\n\t\t\t\t})\n\n\t\t\t\tm.Group(\"/keys\", func() {\n\t\t\t\t\tm.Combo(\"\").Get(repo.SettingsDeployKeys).\n\t\t\t\t\t\tPost(bindIgnErr(form.AddSSHKey{}), repo.SettingsDeployKeysPost)\n\t\t\t\t\tm.Post(\"/delete\", repo.DeleteDeployKey)\n\t\t\t\t})\n\n\t\t\t}, func(c *context.Context) {\n\t\t\t\tc.Data[\"PageIsSettings\"] = true\n\t\t\t})\n\t\t}, reqSignIn, context.RepoAssignment(), reqRepoAdmin, context.RepoRef())\n\n\t\tm.Post(\"/:username/:reponame/action/:action\", reqSignIn, context.RepoAssignment(), repo.Action)\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Get(\"/issues\", repo.RetrieveLabels, repo.Issues)\n\t\t\tm.Get(\"/issues/:index\", repo.ViewIssue)\n\t\t\tm.Get(\"/labels/\", repo.RetrieveLabels, repo.Labels)\n\t\t\tm.Get(\"/milestones\", repo.Milestones)\n\t\t}, ignSignIn, context.RepoAssignment(true))\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\t// FIXME: should use different URLs but mostly same logic for comments of issue and pull reuqest.\n\t\t\t// So they can apply their own enable/disable logic on routers.\n\t\t\tm.Group(\"/issues\", func() {\n\t\t\t\tm.Combo(\"/new\", repo.MustEnableIssues).Get(context.RepoRef(), repo.NewIssue).\n\t\t\t\t\tPost(bindIgnErr(form.NewIssue{}), repo.NewIssuePost)\n\n\t\t\t\tm.Group(\"/:index\", func() {\n\t\t\t\t\tm.Post(\"/title\", repo.UpdateIssueTitle)\n\t\t\t\t\tm.Post(\"/content\", repo.UpdateIssueContent)\n\t\t\t\t\tm.Combo(\"/comments\").Post(bindIgnErr(form.CreateComment{}), repo.NewComment)\n\t\t\t\t})\n\t\t\t})\n\t\t\tm.Group(\"/comments/:id\", func() {\n\t\t\t\tm.Post(\"\", repo.UpdateCommentContent)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteComment)\n\t\t\t})\n\t\t}, reqSignIn, context.RepoAssignment(true))\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Group(\"/wiki\", func() {\n\t\t\t\tm.Get(\"/?:page\", repo.Wiki)\n\t\t\t\tm.Get(\"/_pages\", repo.WikiPages)\n\t\t\t}, repo.MustEnableWiki, context.RepoRef())\n\t\t}, ignSignIn, context.RepoAssignment(false, true))\n\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\t// FIXME: should use different URLs but mostly same logic for comments of issue and pull reuqest.\n\t\t\t// So they can apply their own enable/disable logic on routers.\n\t\t\tm.Group(\"/issues\", func() {\n\t\t\t\tm.Group(\"/:index\", func() {\n\t\t\t\t\tm.Post(\"/label\", repo.UpdateIssueLabel)\n\t\t\t\t\tm.Post(\"/milestone\", repo.UpdateIssueMilestone)\n\t\t\t\t\tm.Post(\"/assignee\", repo.UpdateIssueAssignee)\n\t\t\t\t}, reqRepoWriter)\n\t\t\t})\n\t\t\tm.Group(\"/labels\", func() {\n\t\t\t\tm.Post(\"/new\", bindIgnErr(form.CreateLabel{}), repo.NewLabel)\n\t\t\t\tm.Post(\"/edit\", bindIgnErr(form.CreateLabel{}), repo.UpdateLabel)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteLabel)\n\t\t\t\tm.Post(\"/initialize\", bindIgnErr(form.InitializeLabels{}), repo.InitializeLabels)\n\t\t\t}, reqRepoWriter, context.RepoRef())\n\t\t\tm.Group(\"/milestones\", func() {\n\t\t\t\tm.Combo(\"/new\").Get(repo.NewMilestone).\n\t\t\t\t\tPost(bindIgnErr(form.CreateMilestone{}), repo.NewMilestonePost)\n\t\t\t\tm.Get(\"/:id/edit\", repo.EditMilestone)\n\t\t\t\tm.Post(\"/:id/edit\", bindIgnErr(form.CreateMilestone{}), repo.EditMilestonePost)\n\t\t\t\tm.Get(\"/:id/:action\", repo.ChangeMilestonStatus)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteMilestone)\n\t\t\t}, reqRepoWriter, context.RepoRef())\n\n\t\t\tm.Group(\"/releases\", func() {\n\t\t\t\tm.Get(\"/new\", repo.NewRelease)\n\t\t\t\tm.Post(\"/new\", bindIgnErr(form.NewRelease{}), repo.NewReleasePost)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteRelease)\n\t\t\t\tm.Get(\"/edit/*\", repo.EditRelease)\n\t\t\t\tm.Post(\"/edit/*\", bindIgnErr(form.EditRelease{}), repo.EditReleasePost)\n\t\t\t}, repo.MustBeNotBare, reqRepoWriter, func(c *context.Context) {\n\t\t\t\tc.Data[\"PageIsViewFiles\"] = true\n\t\t\t})\n\n\t\t\t// FIXME: Should use c.Repo.PullRequest to unify template, currently we have inconsistent URL\n\t\t\t// for PR in same repository. After select branch on the page, the URL contains redundant head user name.\n\t\t\t// e.g. /org1/test-repo/compare/master...org1:develop\n\t\t\t// which should be /org1/test-repo/compare/master...develop\n\t\t\tm.Combo(\"/compare/*\", repo.MustAllowPulls).Get(repo.CompareAndPullRequest).\n\t\t\t\tPost(bindIgnErr(form.NewIssue{}), repo.CompareAndPullRequestPost)\n\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Combo(\"/_edit/*\").Get(repo.EditFile).\n\t\t\t\t\tPost(bindIgnErr(form.EditRepoFile{}), repo.EditFilePost)\n\t\t\t\tm.Combo(\"/_new/*\").Get(repo.NewFile).\n\t\t\t\t\tPost(bindIgnErr(form.EditRepoFile{}), repo.NewFilePost)\n\t\t\t\tm.Post(\"/_preview/*\", bindIgnErr(form.EditPreviewDiff{}), repo.DiffPreviewPost)\n\t\t\t\tm.Combo(\"/_delete/*\").Get(repo.DeleteFile).\n\t\t\t\t\tPost(bindIgnErr(form.DeleteRepoFile{}), repo.DeleteFilePost)\n\n\t\t\t\tm.Group(\"\", func() {\n\t\t\t\t\tm.Combo(\"/_upload/*\").Get(repo.UploadFile).\n\t\t\t\t\t\tPost(bindIgnErr(form.UploadRepoFile{}), repo.UploadFilePost)\n\t\t\t\t\tm.Post(\"/upload-file\", repo.UploadFileToServer)\n\t\t\t\t\tm.Post(\"/upload-remove\", bindIgnErr(form.RemoveUploadFile{}), repo.RemoveUploadFileFromServer)\n\t\t\t\t}, func(c *context.Context) {\n\t\t\t\t\tif !conf.Repository.Upload.Enabled {\n\t\t\t\t\t\tc.NotFound()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}, repo.MustBeNotBare, reqRepoWriter, context.RepoRef(), func(c *context.Context) {\n\t\t\t\tif !c.Repo.CanEnableEditor() {\n\t\t\t\t\tc.NotFound()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tc.Data[\"PageIsViewFiles\"] = true\n\t\t\t})\n\t\t}, reqSignIn, context.RepoAssignment())\n\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"/releases\", repo.MustBeNotBare, repo.Releases)\n\t\t\t\tm.Get(\"/pulls\", repo.RetrieveLabels, repo.Pulls)\n\t\t\t\tm.Get(\"/pulls/:index\", repo.ViewPull)\n\t\t\t}, context.RepoRef())\n\n\t\t\tm.Group(\"/branches\", func() {\n\t\t\t\tm.Get(\"\", repo.Branches)\n\t\t\t\tm.Get(\"/all\", repo.AllBranches)\n\t\t\t\tm.Post(\"/delete/*\", reqSignIn, reqRepoWriter, repo.DeleteBranchPost)\n\t\t\t}, repo.MustBeNotBare, func(c *context.Context) {\n\t\t\t\tc.Data[\"PageIsViewFiles\"] = true\n\t\t\t})\n\n\t\t\tm.Group(\"/wiki\", func() {\n\t\t\t\tm.Group(\"\", func() {\n\t\t\t\t\tm.Combo(\"/_new\").Get(repo.NewWiki).\n\t\t\t\t\t\tPost(bindIgnErr(form.NewWiki{}), repo.NewWikiPost)\n\t\t\t\t\tm.Combo(\"/:page/_edit\").Get(repo.EditWiki).\n\t\t\t\t\t\tPost(bindIgnErr(form.NewWiki{}), repo.EditWikiPost)\n\t\t\t\t\tm.Post(\"/:page/delete\", repo.DeleteWikiPagePost)\n\t\t\t\t}, reqSignIn, reqRepoWriter)\n\t\t\t}, repo.MustEnableWiki, context.RepoRef())\n\n\t\t\tm.Get(\"/archive/*\", repo.MustBeNotBare, repo.Download)\n\n\t\t\tm.Group(\"/pulls/:index\", func() {\n\t\t\t\tm.Get(\"/commits\", context.RepoRef(), repo.ViewPullCommits)\n\t\t\t\tm.Get(\"/files\", context.RepoRef(), repo.ViewPullFiles)\n\t\t\t\tm.Post(\"/merge\", reqRepoWriter, repo.MergePullRequest)\n\t\t\t}, repo.MustAllowPulls)\n\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"/src/*\", repo.Home)\n\t\t\t\tm.Get(\"/raw/*\", repo.SingleDownload)\n\t\t\t\tm.Get(\"/commits/*\", repo.RefCommits)\n\t\t\t\tm.Get(\"/commit/:sha([a-f0-9]{7,40})$\", repo.Diff)\n\t\t\t\tm.Get(\"/forks\", repo.Forks)\n\t\t\t}, repo.MustBeNotBare, context.RepoRef())\n\t\t\tm.Get(\"/commit/:sha([a-f0-9]{7,40})\\\\.:ext(patch|diff)\", repo.MustBeNotBare, repo.RawDiff)\n\n\t\t\tm.Get(\"/compare/:before([a-z0-9]{40})\\\\.\\\\.\\\\.:after([a-z0-9]{40})\", repo.MustBeNotBare, context.RepoRef(), repo.CompareDiff)\n\t\t}, ignSignIn, context.RepoAssignment())\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Get(\"\", context.ServeGoGet(), repo.Home)\n\t\t\tm.Get(\"/stars\", repo.Stars)\n\t\t\tm.Get(\"/watchers\", repo.Watchers)\n\t\t}, ignSignIn, context.RepoAssignment(), context.RepoRef())\n\t\t// ***** END: Repository *****\n\n\t\t// **********************\n\t\t// ----- API routes -----\n\t\t// **********************\n\n\t\t// TODO: Without session and CSRF\n\t\tm.Group(\"/api\", func() {\n\t\t\tapiv1.RegisterRoutes(m)\n\t\t}, ignSignIn)\n\t},\n\t\tsession.Sessioner(session.Options{\n\t\t\tProvider:       conf.Session.Provider,\n\t\t\tProviderConfig: conf.Session.ProviderConfig,\n\t\t\tCookieName:     conf.Session.CookieName,\n\t\t\tCookiePath:     conf.Server.Subpath,\n\t\t\tGclifetime:     conf.Session.GCInterval,\n\t\t\tMaxlifetime:    conf.Session.MaxLifeTime,\n\t\t\tSecure:         conf.Session.CookieSecure,\n\t\t}),\n\t\tcsrf.Csrfer(csrf.Options{\n\t\t\tSecret:         conf.Security.SecretKey,\n\t\t\tHeader:         \"X-CSRF-Token\",\n\t\t\tCookie:         conf.Session.CSRFCookieName,\n\t\t\tCookieDomain:   conf.Server.URL.Hostname(),\n\t\t\tCookiePath:     conf.Server.Subpath,\n\t\t\tCookieHttpOnly: true,\n\t\t\tSetCookie:      true,\n\t\t\tSecure:         conf.Server.URL.Scheme == \"https\",\n\t\t}),\n\t\tcontext.Contexter(),\n\t)\n\n\t// ***************************\n\t// ----- HTTP Git routes -----\n\t// ***************************\n\n\tm.Group(\"/:username/:reponame\", func() {\n\t\tm.Get(\"/tasks/trigger\", repo.TriggerTask)\n\n\t\tm.Group(\"/info/lfs\", func() {\n\t\t\tlfs.RegisterRoutes(m.Router)\n\t\t})\n\n\t\tm.Route(\"/*\", \"GET,POST,OPTIONS\", context.ServeGoGet(), repo.HTTPContexter(), repo.HTTP)\n\t})\n\n\t// ***************************\n\t// ----- Internal routes -----\n\t// ***************************\n\n\tm.Group(\"/-\", func() {\n\t\tm.Get(\"/metrics\", app.MetricsFilter(), promhttp.Handler()) // \"/-/metrics\"\n\n\t\tm.Group(\"/api\", func() {\n\t\t\tm.Post(\"/sanitize_ipynb\", app.SanitizeIpynb()) // \"/-/api/sanitize_ipynb\"\n\t\t})\n\t})\n\n\t// **********************\n\t// ----- robots.txt -----\n\t// **********************\n\n\tm.Get(\"/robots.txt\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif conf.HasRobotsTxt {\n\t\t\thttp.ServeFile(w, r, filepath.Join(conf.CustomDir(), \"robots.txt\"))\n\t\t} else {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t}\n\t})\n\n\tm.NotFound(route.NotFound)\n\n\t// Flag for port number in case first time run conflict.\n\tif c.IsSet(\"port\") {\n\t\tconf.Server.URL.Host = strings.Replace(conf.Server.URL.Host, \":\"+conf.Server.URL.Port(), \":\"+c.String(\"port\"), 1)\n\t\tconf.Server.ExternalURL = conf.Server.URL.String()\n\t\tconf.Server.HTTPPort = c.String(\"port\")\n\t}\n\n\tvar listenAddr string\n\tif conf.Server.Protocol == \"unix\" {\n\t\tlistenAddr = conf.Server.HTTPAddr\n\t\tlog.Info(\"Listen on %v://%s\", conf.Server.Protocol, listenAddr)\n\t} else {\n\t\tlistenAddr = fmt.Sprintf(\"%s:%s\", conf.Server.HTTPAddr, conf.Server.HTTPPort)\n\t\tlog.Info(\"Listen on %v://%s%s\", conf.Server.Protocol, listenAddr, conf.Server.Subpath)\n\t}\n\n\tswitch conf.Server.Protocol {\n\tcase \"http\":\n\t\terr = http.ListenAndServe(listenAddr, m)\n\n\tcase \"https\":\n\t\ttlsMinVersion := tls.VersionTLS12\n\t\tswitch conf.Server.TLSMinVersion {\n\t\tcase \"TLS13\":\n\t\t\ttlsMinVersion = tls.VersionTLS13\n\t\tcase \"TLS12\":\n\t\t\ttlsMinVersion = tls.VersionTLS12\n\t\tcase \"TLS11\":\n\t\t\ttlsMinVersion = tls.VersionTLS11\n\t\tcase \"TLS10\":\n\t\t\ttlsMinVersion = tls.VersionTLS10\n\t\t}\n\t\tserver := &http.Server{\n\t\t\tAddr: listenAddr,\n\t\t\tTLSConfig: &tls.Config{\n\t\t\t\tMinVersion:               uint16(tlsMinVersion),\n\t\t\t\tCurvePreferences:         []tls.CurveID{tls.X25519, tls.CurveP256, tls.CurveP384, tls.CurveP521},\n\t\t\t\tPreferServerCipherSuites: true,\n\t\t\t\tCipherSuites: []uint16{\n\t\t\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\t\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\t\t\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\t\t\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\t\t\t},\n\t\t\t}, Handler: m}\n\t\terr = server.ListenAndServeTLS(conf.Server.CertFile, conf.Server.KeyFile)\n\n\tcase \"fcgi\":\n\t\terr = fcgi.Serve(nil, m)\n\n\tcase \"unix\":\n\t\tif osutil.IsExist(listenAddr) {\n\t\t\terr = os.Remove(listenAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(\"Failed to remove existing Unix domain socket: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tvar listener *net.UnixListener\n\t\tlistener, err = net.ListenUnix(\"unix\", &net.UnixAddr{Name: listenAddr, Net: \"unix\"})\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to listen on Unix networks: %v\", err)\n\t\t}\n\n\t\t// FIXME: add proper implementation of signal capture on all protocols\n\t\t// execute this on SIGTERM or SIGINT: listener.Close()\n\t\tif err = os.Chmod(listenAddr, conf.Server.UnixSocketMode); err != nil {\n\t\t\tlog.Fatal(\"Failed to change permission of Unix domain socket: %v\", err)\n\t\t}\n\t\terr = http.Serve(listener, m)\n\n\tdefault:\n\t\tlog.Fatal(\"Unexpected server protocol: %s\", conf.Server.Protocol)\n\t}\n\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to start server: %v\", err)\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage cmd\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/fcgi\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/go-macaron/binding\"\n\t\"github.com/go-macaron/cache\"\n\t\"github.com/go-macaron/captcha\"\n\t\"github.com/go-macaron/csrf\"\n\t\"github.com/go-macaron/gzip\"\n\t\"github.com/go-macaron/i18n\"\n\t\"github.com/go-macaron/session\"\n\t\"github.com/go-macaron/toolbox\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/unknwon/com\"\n\t\"github.com/urfave/cli\"\n\t\"gopkg.in/macaron.v1\"\n\tlog \"unknwon.dev/clog/v2\"\n\n\t\"gogs.io/gogs/internal/app\"\n\t\"gogs.io/gogs/internal/assets/public\"\n\t\"gogs.io/gogs/internal/assets/templates\"\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/osutil\"\n\t\"gogs.io/gogs/internal/route\"\n\t\"gogs.io/gogs/internal/route/admin\"\n\tapiv1 \"gogs.io/gogs/internal/route/api/v1\"\n\t\"gogs.io/gogs/internal/route/dev\"\n\t\"gogs.io/gogs/internal/route/lfs\"\n\t\"gogs.io/gogs/internal/route/org\"\n\t\"gogs.io/gogs/internal/route/repo\"\n\t\"gogs.io/gogs/internal/route/user\"\n\t\"gogs.io/gogs/internal/template\"\n)\n\nvar Web = cli.Command{\n\tName:  \"web\",\n\tUsage: \"Start web server\",\n\tDescription: `Gogs web server is the only thing you need to run,\nand it takes care of all the other things for you`,\n\tAction: runWeb,\n\tFlags: []cli.Flag{\n\t\tstringFlag(\"port, p\", \"3000\", \"Temporary port number to prevent conflict\"),\n\t\tstringFlag(\"config, c\", \"\", \"Custom configuration file path\"),\n\t},\n}\n\n// newMacaron initializes Macaron instance.\nfunc newMacaron() *macaron.Macaron {\n\tm := macaron.New()\n\tif !conf.Server.DisableRouterLog {\n\t\tm.Use(macaron.Logger())\n\t}\n\tm.Use(macaron.Recovery())\n\tif conf.Server.EnableGzip {\n\t\tm.Use(gzip.Gziper())\n\t}\n\tif conf.Server.Protocol == \"fcgi\" {\n\t\tm.SetURLPrefix(conf.Server.Subpath)\n\t}\n\n\t// Register custom middleware first to make it possible to override files under \"public\".\n\tm.Use(macaron.Static(\n\t\tfilepath.Join(conf.CustomDir(), \"public\"),\n\t\tmacaron.StaticOptions{\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t},\n\t))\n\tvar publicFs http.FileSystem\n\tif !conf.Server.LoadAssetsFromDisk {\n\t\tpublicFs = public.NewFileSystem()\n\t}\n\tm.Use(macaron.Static(\n\t\tfilepath.Join(conf.WorkDir(), \"public\"),\n\t\tmacaron.StaticOptions{\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t\tFileSystem:  publicFs,\n\t\t},\n\t))\n\n\tm.Use(macaron.Static(\n\t\tconf.Picture.AvatarUploadPath,\n\t\tmacaron.StaticOptions{\n\t\t\tPrefix:      db.USER_AVATAR_URL_PREFIX,\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t},\n\t))\n\tm.Use(macaron.Static(\n\t\tconf.Picture.RepositoryAvatarUploadPath,\n\t\tmacaron.StaticOptions{\n\t\t\tPrefix:      db.REPO_AVATAR_URL_PREFIX,\n\t\t\tSkipLogging: conf.Server.DisableRouterLog,\n\t\t},\n\t))\n\n\trenderOpt := macaron.RenderOptions{\n\t\tDirectory:         filepath.Join(conf.WorkDir(), \"templates\"),\n\t\tAppendDirectories: []string{filepath.Join(conf.CustomDir(), \"templates\")},\n\t\tFuncs:             template.FuncMap(),\n\t\tIndentJSON:        macaron.Env != macaron.PROD,\n\t}\n\tif !conf.Server.LoadAssetsFromDisk {\n\t\trenderOpt.TemplateFileSystem = templates.NewTemplateFileSystem(\"\", renderOpt.AppendDirectories[0])\n\t}\n\tm.Use(macaron.Renderer(renderOpt))\n\n\tlocaleNames, err := conf.AssetDir(\"conf/locale\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to list locale files: %v\", err)\n\t}\n\tlocaleFiles := make(map[string][]byte)\n\tfor _, name := range localeNames {\n\t\tlocaleFiles[name] = conf.MustAsset(\"conf/locale/\" + name)\n\t}\n\tm.Use(i18n.I18n(i18n.Options{\n\t\tSubURL:          conf.Server.Subpath,\n\t\tFiles:           localeFiles,\n\t\tCustomDirectory: filepath.Join(conf.CustomDir(), \"conf\", \"locale\"),\n\t\tLangs:           conf.I18n.Langs,\n\t\tNames:           conf.I18n.Names,\n\t\tDefaultLang:     \"en-US\",\n\t\tRedirect:        true,\n\t}))\n\tm.Use(cache.Cacher(cache.Options{\n\t\tAdapter:       conf.Cache.Adapter,\n\t\tAdapterConfig: conf.Cache.Host,\n\t\tInterval:      conf.Cache.Interval,\n\t}))\n\tm.Use(captcha.Captchaer(captcha.Options{\n\t\tSubURL: conf.Server.Subpath,\n\t}))\n\tm.Use(toolbox.Toolboxer(m, toolbox.Options{\n\t\tHealthCheckFuncs: []*toolbox.HealthCheckFuncDesc{\n\t\t\t{\n\t\t\t\tDesc: \"Database connection\",\n\t\t\t\tFunc: db.Ping,\n\t\t\t},\n\t\t},\n\t}))\n\treturn m\n}\n\nfunc runWeb(c *cli.Context) error {\n\terr := route.GlobalInit(c.String(\"config\"))\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to initialize application: %v\", err)\n\t}\n\n\tm := newMacaron()\n\n\treqSignIn := context.Toggle(&context.ToggleOptions{SignInRequired: true})\n\tignSignIn := context.Toggle(&context.ToggleOptions{SignInRequired: conf.Auth.RequireSigninView})\n\treqSignOut := context.Toggle(&context.ToggleOptions{SignOutRequired: true})\n\n\tbindIgnErr := binding.BindIgnErr\n\n\tm.SetAutoHead(true)\n\n\tm.Group(\"\", func() {\n\t\tm.Get(\"/\", ignSignIn, route.Home)\n\t\tm.Group(\"/explore\", func() {\n\t\t\tm.Get(\"\", func(c *context.Context) {\n\t\t\t\tc.Redirect(conf.Server.Subpath + \"/explore/repos\")\n\t\t\t})\n\t\t\tm.Get(\"/repos\", route.ExploreRepos)\n\t\t\tm.Get(\"/users\", route.ExploreUsers)\n\t\t\tm.Get(\"/organizations\", route.ExploreOrganizations)\n\t\t}, ignSignIn)\n\t\tm.Combo(\"/install\", route.InstallInit).Get(route.Install).\n\t\t\tPost(bindIgnErr(form.Install{}), route.InstallPost)\n\t\tm.Get(\"/^:type(issues|pulls)$\", reqSignIn, user.Issues)\n\n\t\t// ***** START: User *****\n\t\tm.Group(\"/user\", func() {\n\t\t\tm.Group(\"/login\", func() {\n\t\t\t\tm.Combo(\"\").Get(user.Login).\n\t\t\t\t\tPost(bindIgnErr(form.SignIn{}), user.LoginPost)\n\t\t\t\tm.Combo(\"/two_factor\").Get(user.LoginTwoFactor).Post(user.LoginTwoFactorPost)\n\t\t\t\tm.Combo(\"/two_factor_recovery_code\").Get(user.LoginTwoFactorRecoveryCode).Post(user.LoginTwoFactorRecoveryCodePost)\n\t\t\t})\n\n\t\t\tm.Get(\"/sign_up\", user.SignUp)\n\t\t\tm.Post(\"/sign_up\", bindIgnErr(form.Register{}), user.SignUpPost)\n\t\t\tm.Get(\"/reset_password\", user.ResetPasswd)\n\t\t\tm.Post(\"/reset_password\", user.ResetPasswdPost)\n\t\t}, reqSignOut)\n\n\t\tm.Group(\"/user/settings\", func() {\n\t\t\tm.Get(\"\", user.Settings)\n\t\t\tm.Post(\"\", bindIgnErr(form.UpdateProfile{}), user.SettingsPost)\n\t\t\tm.Combo(\"/avatar\").Get(user.SettingsAvatar).\n\t\t\t\tPost(binding.MultipartForm(form.Avatar{}), user.SettingsAvatarPost)\n\t\t\tm.Post(\"/avatar/delete\", user.SettingsDeleteAvatar)\n\t\t\tm.Combo(\"/email\").Get(user.SettingsEmails).\n\t\t\t\tPost(bindIgnErr(form.AddEmail{}), user.SettingsEmailPost)\n\t\t\tm.Post(\"/email/delete\", user.DeleteEmail)\n\t\t\tm.Get(\"/password\", user.SettingsPassword)\n\t\t\tm.Post(\"/password\", bindIgnErr(form.ChangePassword{}), user.SettingsPasswordPost)\n\t\t\tm.Combo(\"/ssh\").Get(user.SettingsSSHKeys).\n\t\t\t\tPost(bindIgnErr(form.AddSSHKey{}), user.SettingsSSHKeysPost)\n\t\t\tm.Post(\"/ssh/delete\", user.DeleteSSHKey)\n\t\t\tm.Group(\"/security\", func() {\n\t\t\t\tm.Get(\"\", user.SettingsSecurity)\n\t\t\t\tm.Combo(\"/two_factor_enable\").Get(user.SettingsTwoFactorEnable).\n\t\t\t\t\tPost(user.SettingsTwoFactorEnablePost)\n\t\t\t\tm.Combo(\"/two_factor_recovery_codes\").Get(user.SettingsTwoFactorRecoveryCodes).\n\t\t\t\t\tPost(user.SettingsTwoFactorRecoveryCodesPost)\n\t\t\t\tm.Post(\"/two_factor_disable\", user.SettingsTwoFactorDisable)\n\t\t\t})\n\t\t\tm.Group(\"/repositories\", func() {\n\t\t\t\tm.Get(\"\", user.SettingsRepos)\n\t\t\t\tm.Post(\"/leave\", user.SettingsLeaveRepo)\n\t\t\t})\n\t\t\tm.Group(\"/organizations\", func() {\n\t\t\t\tm.Get(\"\", user.SettingsOrganizations)\n\t\t\t\tm.Post(\"/leave\", user.SettingsLeaveOrganization)\n\t\t\t})\n\t\t\tm.Combo(\"/applications\").Get(user.SettingsApplications).\n\t\t\t\tPost(bindIgnErr(form.NewAccessToken{}), user.SettingsApplicationsPost)\n\t\t\tm.Post(\"/applications/delete\", user.SettingsDeleteApplication)\n\t\t\tm.Route(\"/delete\", \"GET,POST\", user.SettingsDelete)\n\t\t}, reqSignIn, func(c *context.Context) {\n\t\t\tc.Data[\"PageIsUserSettings\"] = true\n\t\t})\n\n\t\tm.Group(\"/user\", func() {\n\t\t\tm.Any(\"/activate\", user.Activate)\n\t\t\tm.Any(\"/activate_email\", user.ActivateEmail)\n\t\t\tm.Get(\"/email2user\", user.Email2User)\n\t\t\tm.Get(\"/forget_password\", user.ForgotPasswd)\n\t\t\tm.Post(\"/forget_password\", user.ForgotPasswdPost)\n\t\t\tm.Post(\"/logout\", user.SignOut)\n\t\t})\n\t\t// ***** END: User *****\n\n\t\treqAdmin := context.Toggle(&context.ToggleOptions{SignInRequired: true, AdminRequired: true})\n\n\t\t// ***** START: Admin *****\n\t\tm.Group(\"/admin\", func() {\n\t\t\tm.Combo(\"\").Get(admin.Dashboard).Post(admin.Operation) // \"/admin\"\n\t\t\tm.Get(\"/config\", admin.Config)\n\t\t\tm.Post(\"/config/test_mail\", admin.SendTestMail)\n\t\t\tm.Get(\"/monitor\", admin.Monitor)\n\n\t\t\tm.Group(\"/users\", func() {\n\t\t\t\tm.Get(\"\", admin.Users)\n\t\t\t\tm.Combo(\"/new\").Get(admin.NewUser).Post(bindIgnErr(form.AdminCrateUser{}), admin.NewUserPost)\n\t\t\t\tm.Combo(\"/:userid\").Get(admin.EditUser).Post(bindIgnErr(form.AdminEditUser{}), admin.EditUserPost)\n\t\t\t\tm.Post(\"/:userid/delete\", admin.DeleteUser)\n\t\t\t})\n\n\t\t\tm.Group(\"/orgs\", func() {\n\t\t\t\tm.Get(\"\", admin.Organizations)\n\t\t\t})\n\n\t\t\tm.Group(\"/repos\", func() {\n\t\t\t\tm.Get(\"\", admin.Repos)\n\t\t\t\tm.Post(\"/delete\", admin.DeleteRepo)\n\t\t\t})\n\n\t\t\tm.Group(\"/auths\", func() {\n\t\t\t\tm.Get(\"\", admin.Authentications)\n\t\t\t\tm.Combo(\"/new\").Get(admin.NewAuthSource).Post(bindIgnErr(form.Authentication{}), admin.NewAuthSourcePost)\n\t\t\t\tm.Combo(\"/:authid\").Get(admin.EditAuthSource).\n\t\t\t\t\tPost(bindIgnErr(form.Authentication{}), admin.EditAuthSourcePost)\n\t\t\t\tm.Post(\"/:authid/delete\", admin.DeleteAuthSource)\n\t\t\t})\n\n\t\t\tm.Group(\"/notices\", func() {\n\t\t\t\tm.Get(\"\", admin.Notices)\n\t\t\t\tm.Post(\"/delete\", admin.DeleteNotices)\n\t\t\t\tm.Get(\"/empty\", admin.EmptyNotices)\n\t\t\t})\n\t\t}, reqAdmin)\n\t\t// ***** END: Admin *****\n\n\t\tm.Group(\"\", func() {\n\t\t\tm.Group(\"/:username\", func() {\n\t\t\t\tm.Get(\"\", user.Profile)\n\t\t\t\tm.Get(\"/followers\", user.Followers)\n\t\t\t\tm.Get(\"/following\", user.Following)\n\t\t\t\tm.Get(\"/stars\", user.Stars)\n\t\t\t}, context.InjectParamsUser())\n\n\t\t\tm.Get(\"/attachments/:uuid\", func(c *context.Context) {\n\t\t\t\tattach, err := db.GetAttachmentByUUID(c.Params(\":uuid\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.NotFoundOrError(err, \"get attachment by UUID\")\n\t\t\t\t\treturn\n\t\t\t\t} else if !com.IsFile(attach.LocalPath()) {\n\t\t\t\t\tc.NotFound()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfr, err := os.Open(attach.LocalPath())\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.Error(err, \"open attachment file\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdefer fr.Close()\n\n\t\t\t\tc.Header().Set(\"Content-Security-Policy\", \"default-src 'none'; style-src 'unsafe-inline'; sandbox\")\n\t\t\t\tc.Header().Set(\"Cache-Control\", \"public,max-age=86400\")\n\t\t\t\tc.Header().Set(\"Content-Disposition\", fmt.Sprintf(`inline; filename=\"%s\"`, attach.Name))\n\n\t\t\t\tif _, err = io.Copy(c.Resp, fr); err != nil {\n\t\t\t\t\tc.Error(err, \"copy from file to response\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t\tm.Post(\"/issues/attachments\", repo.UploadIssueAttachment)\n\t\t\tm.Post(\"/releases/attachments\", repo.UploadReleaseAttachment)\n\t\t}, ignSignIn)\n\n\t\tm.Group(\"/:username\", func() {\n\t\t\tm.Post(\"/action/:action\", user.Action)\n\t\t}, reqSignIn, context.InjectParamsUser())\n\n\t\tif macaron.Env == macaron.DEV {\n\t\t\tm.Get(\"/template/*\", dev.TemplatePreview)\n\t\t}\n\n\t\treqRepoAdmin := context.RequireRepoAdmin()\n\t\treqRepoWriter := context.RequireRepoWriter()\n\n\t\twebhookRoutes := func() {\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"\", repo.Webhooks)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteWebhook)\n\t\t\t\tm.Get(\"/:type/new\", repo.WebhooksNew)\n\t\t\t\tm.Post(\"/gogs/new\", bindIgnErr(form.NewWebhook{}), repo.WebhooksNewPost)\n\t\t\t\tm.Post(\"/slack/new\", bindIgnErr(form.NewSlackHook{}), repo.WebhooksSlackNewPost)\n\t\t\t\tm.Post(\"/discord/new\", bindIgnErr(form.NewDiscordHook{}), repo.WebhooksDiscordNewPost)\n\t\t\t\tm.Post(\"/dingtalk/new\", bindIgnErr(form.NewDingtalkHook{}), repo.WebhooksDingtalkNewPost)\n\t\t\t\tm.Get(\"/:id\", repo.WebhooksEdit)\n\t\t\t\tm.Post(\"/gogs/:id\", bindIgnErr(form.NewWebhook{}), repo.WebhooksEditPost)\n\t\t\t\tm.Post(\"/slack/:id\", bindIgnErr(form.NewSlackHook{}), repo.WebhooksSlackEditPost)\n\t\t\t\tm.Post(\"/discord/:id\", bindIgnErr(form.NewDiscordHook{}), repo.WebhooksDiscordEditPost)\n\t\t\t\tm.Post(\"/dingtalk/:id\", bindIgnErr(form.NewDingtalkHook{}), repo.WebhooksDingtalkEditPost)\n\t\t\t}, repo.InjectOrgRepoContext())\n\t\t}\n\n\t\t// ***** START: Organization *****\n\t\tm.Group(\"/org\", func() {\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"/create\", org.Create)\n\t\t\t\tm.Post(\"/create\", bindIgnErr(form.CreateOrg{}), org.CreatePost)\n\t\t\t}, func(c *context.Context) {\n\t\t\t\tif !c.User.CanCreateOrganization() {\n\t\t\t\t\tc.NotFound()\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tm.Group(\"/:org\", func() {\n\t\t\t\tm.Get(\"/dashboard\", user.Dashboard)\n\t\t\t\tm.Get(\"/^:type(issues|pulls)$\", user.Issues)\n\t\t\t\tm.Get(\"/members\", org.Members)\n\t\t\t\tm.Get(\"/members/action/:action\", org.MembersAction)\n\n\t\t\t\tm.Get(\"/teams\", org.Teams)\n\t\t\t}, context.OrgAssignment(true))\n\n\t\t\tm.Group(\"/:org\", func() {\n\t\t\t\tm.Get(\"/teams/:team\", org.TeamMembers)\n\t\t\t\tm.Get(\"/teams/:team/repositories\", org.TeamRepositories)\n\t\t\t\tm.Route(\"/teams/:team/action/:action\", \"GET,POST\", org.TeamsAction)\n\t\t\t\tm.Route(\"/teams/:team/action/repo/:action\", \"GET,POST\", org.TeamsRepoAction)\n\t\t\t}, context.OrgAssignment(true, false, true))\n\n\t\t\tm.Group(\"/:org\", func() {\n\t\t\t\tm.Get(\"/teams/new\", org.NewTeam)\n\t\t\t\tm.Post(\"/teams/new\", bindIgnErr(form.CreateTeam{}), org.NewTeamPost)\n\t\t\t\tm.Get(\"/teams/:team/edit\", org.EditTeam)\n\t\t\t\tm.Post(\"/teams/:team/edit\", bindIgnErr(form.CreateTeam{}), org.EditTeamPost)\n\t\t\t\tm.Post(\"/teams/:team/delete\", org.DeleteTeam)\n\n\t\t\t\tm.Group(\"/settings\", func() {\n\t\t\t\t\tm.Combo(\"\").Get(org.Settings).\n\t\t\t\t\t\tPost(bindIgnErr(form.UpdateOrgSetting{}), org.SettingsPost)\n\t\t\t\t\tm.Post(\"/avatar\", binding.MultipartForm(form.Avatar{}), org.SettingsAvatar)\n\t\t\t\t\tm.Post(\"/avatar/delete\", org.SettingsDeleteAvatar)\n\t\t\t\t\tm.Group(\"/hooks\", webhookRoutes)\n\t\t\t\t\tm.Route(\"/delete\", \"GET,POST\", org.SettingsDelete)\n\t\t\t\t})\n\n\t\t\t\tm.Route(\"/invitations/new\", \"GET,POST\", org.Invitation)\n\t\t\t}, context.OrgAssignment(true, true))\n\t\t}, reqSignIn)\n\t\t// ***** END: Organization *****\n\n\t\t// ***** START: Repository *****\n\t\tm.Group(\"/repo\", func() {\n\t\t\tm.Get(\"/create\", repo.Create)\n\t\t\tm.Post(\"/create\", bindIgnErr(form.CreateRepo{}), repo.CreatePost)\n\t\t\tm.Get(\"/migrate\", repo.Migrate)\n\t\t\tm.Post(\"/migrate\", bindIgnErr(form.MigrateRepo{}), repo.MigratePost)\n\t\t\tm.Combo(\"/fork/:repoid\").Get(repo.Fork).\n\t\t\t\tPost(bindIgnErr(form.CreateRepo{}), repo.ForkPost)\n\t\t}, reqSignIn)\n\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Group(\"/settings\", func() {\n\t\t\t\tm.Combo(\"\").Get(repo.Settings).\n\t\t\t\t\tPost(bindIgnErr(form.RepoSetting{}), repo.SettingsPost)\n\t\t\t\tm.Combo(\"/avatar\").Get(repo.SettingsAvatar).\n\t\t\t\t\tPost(binding.MultipartForm(form.Avatar{}), repo.SettingsAvatarPost)\n\t\t\t\tm.Post(\"/avatar/delete\", repo.SettingsDeleteAvatar)\n\t\t\t\tm.Group(\"/collaboration\", func() {\n\t\t\t\t\tm.Combo(\"\").Get(repo.SettingsCollaboration).Post(repo.SettingsCollaborationPost)\n\t\t\t\t\tm.Post(\"/access_mode\", repo.ChangeCollaborationAccessMode)\n\t\t\t\t\tm.Post(\"/delete\", repo.DeleteCollaboration)\n\t\t\t\t})\n\t\t\t\tm.Group(\"/branches\", func() {\n\t\t\t\t\tm.Get(\"\", repo.SettingsBranches)\n\t\t\t\t\tm.Post(\"/default_branch\", repo.UpdateDefaultBranch)\n\t\t\t\t\tm.Combo(\"/*\").Get(repo.SettingsProtectedBranch).\n\t\t\t\t\t\tPost(bindIgnErr(form.ProtectBranch{}), repo.SettingsProtectedBranchPost)\n\t\t\t\t}, func(c *context.Context) {\n\t\t\t\t\tif c.Repo.Repository.IsMirror {\n\t\t\t\t\t\tc.NotFound()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tm.Group(\"/hooks\", func() {\n\t\t\t\t\twebhookRoutes()\n\n\t\t\t\t\tm.Group(\"/:id\", func() {\n\t\t\t\t\t\tm.Post(\"/test\", repo.TestWebhook)\n\t\t\t\t\t\tm.Post(\"/redelivery\", repo.RedeliveryWebhook)\n\t\t\t\t\t})\n\n\t\t\t\t\tm.Group(\"/git\", func() {\n\t\t\t\t\t\tm.Get(\"\", repo.SettingsGitHooks)\n\t\t\t\t\t\tm.Combo(\"/:name\").Get(repo.SettingsGitHooksEdit).\n\t\t\t\t\t\t\tPost(repo.SettingsGitHooksEditPost)\n\t\t\t\t\t}, context.GitHookService())\n\t\t\t\t})\n\n\t\t\t\tm.Group(\"/keys\", func() {\n\t\t\t\t\tm.Combo(\"\").Get(repo.SettingsDeployKeys).\n\t\t\t\t\t\tPost(bindIgnErr(form.AddSSHKey{}), repo.SettingsDeployKeysPost)\n\t\t\t\t\tm.Post(\"/delete\", repo.DeleteDeployKey)\n\t\t\t\t})\n\n\t\t\t}, func(c *context.Context) {\n\t\t\t\tc.Data[\"PageIsSettings\"] = true\n\t\t\t})\n\t\t}, reqSignIn, context.RepoAssignment(), reqRepoAdmin, context.RepoRef())\n\n\t\tm.Post(\"/:username/:reponame/action/:action\", reqSignIn, context.RepoAssignment(), repo.Action)\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Get(\"/issues\", repo.RetrieveLabels, repo.Issues)\n\t\t\tm.Get(\"/issues/:index\", repo.ViewIssue)\n\t\t\tm.Get(\"/labels/\", repo.RetrieveLabels, repo.Labels)\n\t\t\tm.Get(\"/milestones\", repo.Milestones)\n\t\t}, ignSignIn, context.RepoAssignment(true))\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\t// FIXME: should use different URLs but mostly same logic for comments of issue and pull reuqest.\n\t\t\t// So they can apply their own enable/disable logic on routers.\n\t\t\tm.Group(\"/issues\", func() {\n\t\t\t\tm.Combo(\"/new\", repo.MustEnableIssues).Get(context.RepoRef(), repo.NewIssue).\n\t\t\t\t\tPost(bindIgnErr(form.NewIssue{}), repo.NewIssuePost)\n\n\t\t\t\tm.Group(\"/:index\", func() {\n\t\t\t\t\tm.Post(\"/title\", repo.UpdateIssueTitle)\n\t\t\t\t\tm.Post(\"/content\", repo.UpdateIssueContent)\n\t\t\t\t\tm.Combo(\"/comments\").Post(bindIgnErr(form.CreateComment{}), repo.NewComment)\n\t\t\t\t})\n\t\t\t})\n\t\t\tm.Group(\"/comments/:id\", func() {\n\t\t\t\tm.Post(\"\", repo.UpdateCommentContent)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteComment)\n\t\t\t})\n\t\t}, reqSignIn, context.RepoAssignment(true))\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Group(\"/wiki\", func() {\n\t\t\t\tm.Get(\"/?:page\", repo.Wiki)\n\t\t\t\tm.Get(\"/_pages\", repo.WikiPages)\n\t\t\t}, repo.MustEnableWiki, context.RepoRef())\n\t\t}, ignSignIn, context.RepoAssignment(false, true))\n\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\t// FIXME: should use different URLs but mostly same logic for comments of issue and pull reuqest.\n\t\t\t// So they can apply their own enable/disable logic on routers.\n\t\t\tm.Group(\"/issues\", func() {\n\t\t\t\tm.Group(\"/:index\", func() {\n\t\t\t\t\tm.Post(\"/label\", repo.UpdateIssueLabel)\n\t\t\t\t\tm.Post(\"/milestone\", repo.UpdateIssueMilestone)\n\t\t\t\t\tm.Post(\"/assignee\", repo.UpdateIssueAssignee)\n\t\t\t\t}, reqRepoWriter)\n\t\t\t})\n\t\t\tm.Group(\"/labels\", func() {\n\t\t\t\tm.Post(\"/new\", bindIgnErr(form.CreateLabel{}), repo.NewLabel)\n\t\t\t\tm.Post(\"/edit\", bindIgnErr(form.CreateLabel{}), repo.UpdateLabel)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteLabel)\n\t\t\t\tm.Post(\"/initialize\", bindIgnErr(form.InitializeLabels{}), repo.InitializeLabels)\n\t\t\t}, reqRepoWriter, context.RepoRef())\n\t\t\tm.Group(\"/milestones\", func() {\n\t\t\t\tm.Combo(\"/new\").Get(repo.NewMilestone).\n\t\t\t\t\tPost(bindIgnErr(form.CreateMilestone{}), repo.NewMilestonePost)\n\t\t\t\tm.Get(\"/:id/edit\", repo.EditMilestone)\n\t\t\t\tm.Post(\"/:id/edit\", bindIgnErr(form.CreateMilestone{}), repo.EditMilestonePost)\n\t\t\t\tm.Get(\"/:id/:action\", repo.ChangeMilestonStatus)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteMilestone)\n\t\t\t}, reqRepoWriter, context.RepoRef())\n\n\t\t\tm.Group(\"/releases\", func() {\n\t\t\t\tm.Get(\"/new\", repo.NewRelease)\n\t\t\t\tm.Post(\"/new\", bindIgnErr(form.NewRelease{}), repo.NewReleasePost)\n\t\t\t\tm.Post(\"/delete\", repo.DeleteRelease)\n\t\t\t\tm.Get(\"/edit/*\", repo.EditRelease)\n\t\t\t\tm.Post(\"/edit/*\", bindIgnErr(form.EditRelease{}), repo.EditReleasePost)\n\t\t\t}, repo.MustBeNotBare, reqRepoWriter, func(c *context.Context) {\n\t\t\t\tc.Data[\"PageIsViewFiles\"] = true\n\t\t\t})\n\n\t\t\t// FIXME: Should use c.Repo.PullRequest to unify template, currently we have inconsistent URL\n\t\t\t// for PR in same repository. After select branch on the page, the URL contains redundant head user name.\n\t\t\t// e.g. /org1/test-repo/compare/master...org1:develop\n\t\t\t// which should be /org1/test-repo/compare/master...develop\n\t\t\tm.Combo(\"/compare/*\", repo.MustAllowPulls).Get(repo.CompareAndPullRequest).\n\t\t\t\tPost(bindIgnErr(form.NewIssue{}), repo.CompareAndPullRequestPost)\n\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Combo(\"/_edit/*\").Get(repo.EditFile).\n\t\t\t\t\tPost(bindIgnErr(form.EditRepoFile{}), repo.EditFilePost)\n\t\t\t\tm.Combo(\"/_new/*\").Get(repo.NewFile).\n\t\t\t\t\tPost(bindIgnErr(form.EditRepoFile{}), repo.NewFilePost)\n\t\t\t\tm.Post(\"/_preview/*\", bindIgnErr(form.EditPreviewDiff{}), repo.DiffPreviewPost)\n\t\t\t\tm.Combo(\"/_delete/*\").Get(repo.DeleteFile).\n\t\t\t\t\tPost(bindIgnErr(form.DeleteRepoFile{}), repo.DeleteFilePost)\n\n\t\t\t\tm.Group(\"\", func() {\n\t\t\t\t\tm.Combo(\"/_upload/*\").Get(repo.UploadFile).\n\t\t\t\t\t\tPost(bindIgnErr(form.UploadRepoFile{}), repo.UploadFilePost)\n\t\t\t\t\tm.Post(\"/upload-file\", repo.UploadFileToServer)\n\t\t\t\t\tm.Post(\"/upload-remove\", bindIgnErr(form.RemoveUploadFile{}), repo.RemoveUploadFileFromServer)\n\t\t\t\t}, func(c *context.Context) {\n\t\t\t\t\tif !conf.Repository.Upload.Enabled {\n\t\t\t\t\t\tc.NotFound()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}, repo.MustBeNotBare, reqRepoWriter, context.RepoRef(), func(c *context.Context) {\n\t\t\t\tif !c.Repo.CanEnableEditor() {\n\t\t\t\t\tc.NotFound()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tc.Data[\"PageIsViewFiles\"] = true\n\t\t\t})\n\t\t}, reqSignIn, context.RepoAssignment())\n\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"/releases\", repo.MustBeNotBare, repo.Releases)\n\t\t\t\tm.Get(\"/pulls\", repo.RetrieveLabels, repo.Pulls)\n\t\t\t\tm.Get(\"/pulls/:index\", repo.ViewPull)\n\t\t\t}, context.RepoRef())\n\n\t\t\tm.Group(\"/branches\", func() {\n\t\t\t\tm.Get(\"\", repo.Branches)\n\t\t\t\tm.Get(\"/all\", repo.AllBranches)\n\t\t\t\tm.Post(\"/delete/*\", reqSignIn, reqRepoWriter, repo.DeleteBranchPost)\n\t\t\t}, repo.MustBeNotBare, func(c *context.Context) {\n\t\t\t\tc.Data[\"PageIsViewFiles\"] = true\n\t\t\t})\n\n\t\t\tm.Group(\"/wiki\", func() {\n\t\t\t\tm.Group(\"\", func() {\n\t\t\t\t\tm.Combo(\"/_new\").Get(repo.NewWiki).\n\t\t\t\t\t\tPost(bindIgnErr(form.NewWiki{}), repo.NewWikiPost)\n\t\t\t\t\tm.Combo(\"/:page/_edit\").Get(repo.EditWiki).\n\t\t\t\t\t\tPost(bindIgnErr(form.NewWiki{}), repo.EditWikiPost)\n\t\t\t\t\tm.Post(\"/:page/delete\", repo.DeleteWikiPagePost)\n\t\t\t\t}, reqSignIn, reqRepoWriter)\n\t\t\t}, repo.MustEnableWiki, context.RepoRef())\n\n\t\t\tm.Get(\"/archive/*\", repo.MustBeNotBare, repo.Download)\n\n\t\t\tm.Group(\"/pulls/:index\", func() {\n\t\t\t\tm.Get(\"/commits\", context.RepoRef(), repo.ViewPullCommits)\n\t\t\t\tm.Get(\"/files\", context.RepoRef(), repo.ViewPullFiles)\n\t\t\t\tm.Post(\"/merge\", reqRepoWriter, repo.MergePullRequest)\n\t\t\t}, repo.MustAllowPulls)\n\n\t\t\tm.Group(\"\", func() {\n\t\t\t\tm.Get(\"/src/*\", repo.Home)\n\t\t\t\tm.Get(\"/raw/*\", repo.SingleDownload)\n\t\t\t\tm.Get(\"/commits/*\", repo.RefCommits)\n\t\t\t\tm.Get(\"/commit/:sha([a-f0-9]{7,40})$\", repo.Diff)\n\t\t\t\tm.Get(\"/forks\", repo.Forks)\n\t\t\t}, repo.MustBeNotBare, context.RepoRef())\n\t\t\tm.Get(\"/commit/:sha([a-f0-9]{7,40})\\\\.:ext(patch|diff)\", repo.MustBeNotBare, repo.RawDiff)\n\n\t\t\tm.Get(\"/compare/:before([a-z0-9]{40})\\\\.\\\\.\\\\.:after([a-z0-9]{40})\", repo.MustBeNotBare, context.RepoRef(), repo.CompareDiff)\n\t\t}, ignSignIn, context.RepoAssignment())\n\t\tm.Group(\"/:username/:reponame\", func() {\n\t\t\tm.Get(\"\", context.ServeGoGet(), repo.Home)\n\t\t\tm.Get(\"/stars\", repo.Stars)\n\t\t\tm.Get(\"/watchers\", repo.Watchers)\n\t\t}, ignSignIn, context.RepoAssignment(), context.RepoRef())\n\t\t// ***** END: Repository *****\n\n\t\t// **********************\n\t\t// ----- API routes -----\n\t\t// **********************\n\n\t\t// TODO: Without session and CSRF\n\t\tm.Group(\"/api\", func() {\n\t\t\tapiv1.RegisterRoutes(m)\n\t\t}, ignSignIn)\n\t},\n\t\tsession.Sessioner(session.Options{\n\t\t\tProvider:       conf.Session.Provider,\n\t\t\tProviderConfig: conf.Session.ProviderConfig,\n\t\t\tCookieName:     conf.Session.CookieName,\n\t\t\tCookiePath:     conf.Server.Subpath,\n\t\t\tGclifetime:     conf.Session.GCInterval,\n\t\t\tMaxlifetime:    conf.Session.MaxLifeTime,\n\t\t\tSecure:         conf.Session.CookieSecure,\n\t\t}),\n\t\tcsrf.Csrfer(csrf.Options{\n\t\t\tSecret:         conf.Security.SecretKey,\n\t\t\tHeader:         \"X-CSRF-Token\",\n\t\t\tCookie:         conf.Session.CSRFCookieName,\n\t\t\tCookieDomain:   conf.Server.URL.Hostname(),\n\t\t\tCookiePath:     conf.Server.Subpath,\n\t\t\tCookieHttpOnly: true,\n\t\t\tSetCookie:      true,\n\t\t\tSecure:         conf.Server.URL.Scheme == \"https\",\n\t\t}),\n\t\tcontext.Contexter(),\n\t)\n\n\t// ***************************\n\t// ----- HTTP Git routes -----\n\t// ***************************\n\n\tm.Group(\"/:username/:reponame\", func() {\n\t\tm.Get(\"/tasks/trigger\", repo.TriggerTask)\n\n\t\tm.Group(\"/info/lfs\", func() {\n\t\t\tlfs.RegisterRoutes(m.Router)\n\t\t})\n\n\t\tm.Route(\"/*\", \"GET,POST,OPTIONS\", context.ServeGoGet(), repo.HTTPContexter(), repo.HTTP)\n\t})\n\n\t// ***************************\n\t// ----- Internal routes -----\n\t// ***************************\n\n\tm.Group(\"/-\", func() {\n\t\tm.Get(\"/metrics\", app.MetricsFilter(), promhttp.Handler()) // \"/-/metrics\"\n\n\t\tm.Group(\"/api\", func() {\n\t\t\tm.Post(\"/sanitize_ipynb\", app.SanitizeIpynb()) // \"/-/api/sanitize_ipynb\"\n\t\t})\n\t})\n\n\t// **********************\n\t// ----- robots.txt -----\n\t// **********************\n\n\tm.Get(\"/robots.txt\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif conf.HasRobotsTxt {\n\t\t\thttp.ServeFile(w, r, filepath.Join(conf.CustomDir(), \"robots.txt\"))\n\t\t} else {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t}\n\t})\n\n\tm.NotFound(route.NotFound)\n\n\t// Flag for port number in case first time run conflict.\n\tif c.IsSet(\"port\") {\n\t\tconf.Server.URL.Host = strings.Replace(conf.Server.URL.Host, \":\"+conf.Server.URL.Port(), \":\"+c.String(\"port\"), 1)\n\t\tconf.Server.ExternalURL = conf.Server.URL.String()\n\t\tconf.Server.HTTPPort = c.String(\"port\")\n\t}\n\n\tvar listenAddr string\n\tif conf.Server.Protocol == \"unix\" {\n\t\tlistenAddr = conf.Server.HTTPAddr\n\t\tlog.Info(\"Listen on %v://%s\", conf.Server.Protocol, listenAddr)\n\t} else {\n\t\tlistenAddr = fmt.Sprintf(\"%s:%s\", conf.Server.HTTPAddr, conf.Server.HTTPPort)\n\t\tlog.Info(\"Listen on %v://%s%s\", conf.Server.Protocol, listenAddr, conf.Server.Subpath)\n\t}\n\n\tswitch conf.Server.Protocol {\n\tcase \"http\":\n\t\terr = http.ListenAndServe(listenAddr, m)\n\n\tcase \"https\":\n\t\ttlsMinVersion := tls.VersionTLS12\n\t\tswitch conf.Server.TLSMinVersion {\n\t\tcase \"TLS13\":\n\t\t\ttlsMinVersion = tls.VersionTLS13\n\t\tcase \"TLS12\":\n\t\t\ttlsMinVersion = tls.VersionTLS12\n\t\tcase \"TLS11\":\n\t\t\ttlsMinVersion = tls.VersionTLS11\n\t\tcase \"TLS10\":\n\t\t\ttlsMinVersion = tls.VersionTLS10\n\t\t}\n\t\tserver := &http.Server{\n\t\t\tAddr: listenAddr,\n\t\t\tTLSConfig: &tls.Config{\n\t\t\t\tMinVersion:               uint16(tlsMinVersion),\n\t\t\t\tCurvePreferences:         []tls.CurveID{tls.X25519, tls.CurveP256, tls.CurveP384, tls.CurveP521},\n\t\t\t\tPreferServerCipherSuites: true,\n\t\t\t\tCipherSuites: []uint16{\n\t\t\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\t\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\t\t\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\t\t\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\t\t\t},\n\t\t\t}, Handler: m}\n\t\terr = server.ListenAndServeTLS(conf.Server.CertFile, conf.Server.KeyFile)\n\n\tcase \"fcgi\":\n\t\terr = fcgi.Serve(nil, m)\n\n\tcase \"unix\":\n\t\tif osutil.IsExist(listenAddr) {\n\t\t\terr = os.Remove(listenAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(\"Failed to remove existing Unix domain socket: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tvar listener *net.UnixListener\n\t\tlistener, err = net.ListenUnix(\"unix\", &net.UnixAddr{Name: listenAddr, Net: \"unix\"})\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to listen on Unix networks: %v\", err)\n\t\t}\n\n\t\t// FIXME: add proper implementation of signal capture on all protocols\n\t\t// execute this on SIGTERM or SIGINT: listener.Close()\n\t\tif err = os.Chmod(listenAddr, conf.Server.UnixSocketMode); err != nil {\n\t\t\tlog.Fatal(\"Failed to change permission of Unix domain socket: %v\", err)\n\t\t}\n\t\terr = http.Serve(listener, m)\n\n\tdefault:\n\t\tlog.Fatal(\"Unexpected server protocol: %s\", conf.Server.Protocol)\n\t}\n\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to start server: %v\", err)\n\t}\n\n\treturn nil\n}\n"], "filenames": ["internal/cmd/web.go"], "buggy_code_start_loc": [316], "buggy_code_end_loc": [316], "fixing_code_start_loc": [317], "fixing_code_end_loc": [318], "type": "CWE-79", "message": "Stored xss bug in GitHub repository gogs/gogs prior to 0.12.7. As the repo is public , any user can view the report and when open the attachment then xss is executed. This bug allow executed any javascript code in victim account .", "other": {"cve": {"id": "CVE-2022-1464", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-05T14:15:08.010", "lastModified": "2022-05-13T18:27:15.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stored xss bug in GitHub repository gogs/gogs prior to 0.12.7. As the repo is public , any user can view the report and when open the attachment then xss is executed. This bug allow executed any javascript code in victim account ."}, {"lang": "es", "value": "Un bug de tipo xss almacenado en el repositorio de GitHub gogs/gogs versiones anteriores a 0.12.7. Como el repositorio es p\u00fablico, cualquier usuario puede visualizar el informe y cuando abre el archivo adjunto es ejecutado el ataque de tipo xss. Este error permite ejecutar cualquier c\u00f3digo javascript en la cuenta de la v\u00edctima"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gogs:gogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.7", "matchCriteriaId": "29733251-D132-49EF-A387-88B54749F501"}]}]}], "references": [{"url": "https://github.com/gogs/gogs/commit/bc77440b301ac8780698be91dff1ac33b7cee850", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/34a12146-3a5d-4efc-a0f8-7a3ae04b198d", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gogs/gogs/commit/bc77440b301ac8780698be91dff1ac33b7cee850"}}